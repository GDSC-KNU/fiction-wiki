// runtime can't be in strict mode because a global variable is assign and maybe created.
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["react-refresh"],{

/***/ "./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/helpers.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/helpers.js ***!
  \********************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n})); // This file is copied from the Metro JavaScript bundler, with minor tweaks for\n// webpack 4 compatibility.\n//\n// https://github.com/facebook/metro/blob/d6b9685c730d0d63577db40f41369157f28dfa3a/packages/metro/src/lib/polyfills/require.js\n\nconst runtime_1 = __importDefault(__webpack_require__(/*! next/dist/compiled/react-refresh/runtime */ \"./node_modules/next/dist/compiled/react-refresh/runtime.js\"));\n\nfunction isSafeExport(key) {\n  return key === '__esModule' || key === '__N_SSG' || key === '__N_SSP' || key === '__N_RSC' || // TODO: remove this key from page config instead of allow listing it\n  key === 'config';\n}\n\nfunction registerExportsForReactRefresh(moduleExports, moduleID) {\n  runtime_1.default.register(moduleExports, moduleID + ' %exports%');\n\n  if (moduleExports == null || typeof moduleExports !== 'object') {\n    // Exit if we can't iterate over exports.\n    // (This is important for legacy environments.)\n    return;\n  }\n\n  for (var key in moduleExports) {\n    if (isSafeExport(key)) {\n      continue;\n    }\n\n    var exportValue = moduleExports[key];\n    var typeID = moduleID + ' %exports% ' + key;\n    runtime_1.default.register(exportValue, typeID);\n  }\n}\n\nfunction isReactRefreshBoundary(moduleExports) {\n  if (runtime_1.default.isLikelyComponentType(moduleExports)) {\n    return true;\n  }\n\n  if (moduleExports == null || typeof moduleExports !== 'object') {\n    // Exit if we can't iterate over exports.\n    return false;\n  }\n\n  var hasExports = false;\n  var areAllExportsComponents = true;\n\n  for (var key in moduleExports) {\n    hasExports = true;\n\n    if (isSafeExport(key)) {\n      continue;\n    }\n\n    var exportValue = moduleExports[key];\n\n    if (!runtime_1.default.isLikelyComponentType(exportValue)) {\n      areAllExportsComponents = false;\n    }\n  }\n\n  return hasExports && areAllExportsComponents;\n}\n\nfunction shouldInvalidateReactRefreshBoundary(prevExports, nextExports) {\n  var prevSignature = getRefreshBoundarySignature(prevExports);\n  var nextSignature = getRefreshBoundarySignature(nextExports);\n\n  if (prevSignature.length !== nextSignature.length) {\n    return true;\n  }\n\n  for (var i = 0; i < nextSignature.length; i++) {\n    if (prevSignature[i] !== nextSignature[i]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getRefreshBoundarySignature(moduleExports) {\n  var signature = [];\n  signature.push(runtime_1.default.getFamilyByType(moduleExports));\n\n  if (moduleExports == null || typeof moduleExports !== 'object') {\n    // Exit if we can't iterate over exports.\n    // (This is important for legacy environments.)\n    return signature;\n  }\n\n  for (var key in moduleExports) {\n    if (isSafeExport(key)) {\n      continue;\n    }\n\n    var exportValue = moduleExports[key];\n    signature.push(key);\n    signature.push(runtime_1.default.getFamilyByType(exportValue));\n  }\n\n  return signature;\n}\n\nvar isUpdateScheduled = false;\n\nfunction scheduleUpdate() {\n  if (isUpdateScheduled) {\n    return;\n  }\n\n  function canApplyUpdate() {\n    return module.hot.status() === 'idle';\n  }\n\n  isUpdateScheduled = true;\n  setTimeout(function () {\n    isUpdateScheduled = false; // Only trigger refresh if the webpack HMR state is idle\n\n    if (canApplyUpdate()) {\n      try {\n        runtime_1.default.performReactRefresh();\n      } catch (err) {\n        console.warn('Warning: Failed to re-render. We will retry on the next Fast Refresh event.\\n' + err);\n      }\n\n      return;\n    }\n\n    return scheduleUpdate();\n  }, 30);\n} // Needs to be compatible with IE11\n\n\nexports[\"default\"] = {\n  registerExportsForReactRefresh: registerExportsForReactRefresh,\n  isReactRefreshBoundary: isReactRefreshBoundary,\n  shouldInvalidateReactRefreshBoundary: shouldInvalidateReactRefreshBoundary,\n  getRefreshBoundarySignature: getRefreshBoundarySignature,\n  scheduleUpdate: scheduleUpdate\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL0BuZXh0L3JlYWN0LXJlZnJlc2gtdXRpbHMvZGlzdC9pbnRlcm5hbC9oZWxwZXJzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxJQUFJQSxlQUFlLEdBQUksUUFBUSxLQUFLQSxlQUFkLElBQWtDLFVBQVVDLEdBQVYsRUFBZTtFQUNuRSxPQUFRQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0MsVUFBWixHQUEwQkQsR0FBMUIsR0FBZ0M7SUFBRSxXQUFXQTtFQUFiLENBQXZDO0FBQ0gsQ0FGRDs7QUFHQUUsOENBQTZDO0VBQUVHLEtBQUssRUFBRTtBQUFULENBQTdDLEcsQ0FDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNQyxTQUFTLEdBQUdQLGVBQWUsQ0FBQ1EsbUJBQU8sQ0FBQyw0R0FBRCxDQUFSLENBQWpDOztBQUNBLFNBQVNDLFlBQVQsQ0FBc0JDLEdBQXRCLEVBQTJCO0VBQ3ZCLE9BQVFBLEdBQUcsS0FBSyxZQUFSLElBQ0pBLEdBQUcsS0FBSyxTQURKLElBRUpBLEdBQUcsS0FBSyxTQUZKLElBR0pBLEdBQUcsS0FBSyxTQUhKLElBSUo7RUFDQUEsR0FBRyxLQUFLLFFBTFo7QUFNSDs7QUFDRCxTQUFTQyw4QkFBVCxDQUF3Q0MsYUFBeEMsRUFBdURDLFFBQXZELEVBQWlFO0VBQzdETixTQUFTLENBQUNPLE9BQVYsQ0FBa0JDLFFBQWxCLENBQTJCSCxhQUEzQixFQUEwQ0MsUUFBUSxHQUFHLFlBQXJEOztFQUNBLElBQUlELGFBQWEsSUFBSSxJQUFqQixJQUF5QixPQUFPQSxhQUFQLEtBQXlCLFFBQXRELEVBQWdFO0lBQzVEO0lBQ0E7SUFDQTtFQUNIOztFQUNELEtBQUssSUFBSUYsR0FB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VCxHQUEwQjtFQUN0QixJQUFJRCxpQkFBSixFQUF1QjtJQUNuQjtFQUNIOztFQUNELFNBQVNFLGNBQVQsR0FBMEI7SUFDdEIsT0FBT0MsVUFBQSxDQUFXRSxNQUFYLE9BQXdCLE1BQS9CO0VBQ0g7O0VBQ0RMLGlCQUFpQixHQUFHLElBQXBCO0VBQ0FNLFVBQVUsQ0FBQyxZQUFZO0lBQ25CTixpQkFBaUIsR0FBRyxLQUFwQixDQURtQixDQUVuQjs7SUFDQSxJQUFJRSxjQUFjLEVBQWxCLEVBQXNCO01BQ2xCLElBQUk7UUFDQTVCLFNBQVMsQ0FBQ08sT0FBVixDQUFrQjBCLG1CQUFsQjtNQUNILENBRkQsQ0FHQSxPQUFPQyxHQUFQLEVBQVk7UUFDUkMsT0FBTyxDQUFDQyxJQUFSLENBQWEsa0ZBQ1RGLEdBREo7TUFFSDs7TUFDRDtJQUNIOztJQUNELE9BQU9QLGNBQWMsRUFBckI7RUFDSCxDQWRTLEVBY1AsRUFkTyxDQUFWO0FBZUgsQyxDQUNEOzs7QUFDQTdCLGtCQUFBLEdBQWtCO0VBQ2RNLDhCQUE4QixFQUFFQSw4QkFEbEI7RUFFZE8sc0JBQXNCLEVBQUVBLHNCQUZWO0VBR2RJLG9DQUFvQyxFQUFFQSxvQ0FIeEI7RUFJZEksMkJBQTJCLEVBQUVBLDJCQUpmO0VBS2RRLGNBQWMsRUFBRUE7QUFMRixDQUFsQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL0BuZXh0L3JlYWN0LXJlZnJlc2gtdXRpbHMvZGlzdC9pbnRlcm5hbC9oZWxwZXJzLmpzPzQwM2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBNSVQgTGljZW5zZVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXHJcbiAqIFNPRlRXQVJFLlxyXG4gKi9cclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyBUaGlzIGZpbGUgaXMgY29waWVkIGZyb20gdGhlIE1ldHJvIEphdmFTY3JpcHQgYnVuZGxlciwgd2l0aCBtaW5vciB0d2Vha3MgZm9yXHJcbi8vIHdlYnBhY2sgNCBjb21wYXRpYmlsaXR5LlxyXG4vL1xyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svbWV0cm8vYmxvYi9kNmI5Njg1YzczMGQwZDYzNTc3ZGI0MGY0MTM2OTE1N2YyOGRmYTNhL3BhY2thZ2VzL21ldHJvL3NyYy9saWIvcG9seWZpbGxzL3JlcXVpcmUuanNcclxuY29uc3QgcnVudGltZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtcmVmcmVzaC9ydW50aW1lXCIpKTtcclxuZnVuY3Rpb24gaXNTYWZlRXhwb3J0KGtleSkge1xyXG4gICAgcmV0dXJuIChrZXkgPT09ICdfX2VzTW9kdWxlJyB8fFxyXG4gICAgICAgIGtleSA9PT0gJ19fTl9TU0cnIHx8XHJcbiAgICAgICAga2V5ID09PSAnX19OX1NTUCcgfHxcclxuICAgICAgICBrZXkgPT09ICdfX05fUlNDJyB8fFxyXG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGtleSBmcm9tIHBhZ2UgY29uZmlnIGluc3RlYWQgb2YgYWxsb3cgbGlzdGluZyBpdFxyXG4gICAgICAgIGtleSA9PT0gJ2NvbmZpZycpO1xyXG59XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyRXhwb3J0c0ZvclJlYWN0UmVmcmVzaChtb2R1bGVFeHBvcnRzLCBtb2R1bGVJRCkge1xyXG4gICAgcnVudGltZV8xLmRlZmF1bHQucmVnaXN0ZXIobW9kdWxlRXhwb3J0cywgbW9kdWxlSUQgKyAnICVleHBvcnRzJScpO1xyXG4gICAgaWYgKG1vZHVsZUV4cG9ydHMgPT0gbnVsbCB8fCB0eXBlb2YgbW9kdWxlRXhwb3J0cyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAvLyBFeGl0IGlmIHdlIGNhbid0IGl0ZXJhdGUgb3ZlciBleHBvcnRzLlxyXG4gICAgICAgIC8vIChUaGlzIGlzIGltcG9ydGFudCBmb3IgbGVnYWN5IGVudmlyb25tZW50cy4pXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIga2V5IGluIG1vZHVsZUV4cG9ydHMpIHtcclxuICAgICAgICBpZiAoaXNTYWZlRXhwb3J0KGtleSkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBleHBvcnRWYWx1ZSA9IG1vZHVsZUV4cG9ydHNba2V5XTtcclxuICAgICAgICB2YXIgdHlwZUlEID0gbW9kdWxlSUQgKyAnICVleHBvcnRzJSAnICsga2V5O1xyXG4gICAgICAgIHJ1bnRpbWVfMS5kZWZhdWx0LnJlZ2lzdGVyKGV4cG9ydFZhbHVlLCB0eXBlSUQpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzUmVhY3RSZWZyZXNoQm91bmRhcnkobW9kdWxlRXhwb3J0cykge1xyXG4gICAgaWYgKHJ1bnRpbWVfMS5kZWZhdWx0LmlzTGlrZWx5Q29tcG9uZW50VHlwZShtb2R1bGVFeHBvcnRzKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG1vZHVsZUV4cG9ydHMgPT0gbnVsbCB8fCB0eXBlb2YgbW9kdWxlRXhwb3J0cyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAvLyBFeGl0IGlmIHdlIGNhbid0IGl0ZXJhdGUgb3ZlciBleHBvcnRzLlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhciBoYXNFeHBvcnRzID0gZmFsc2U7XHJcbiAgICB2YXIgYXJlQWxsRXhwb3J0c0NvbXBvbmVudHMgPSB0cnVlO1xyXG4gICAgZm9yICh2YXIga2V5IGluIG1vZHVsZUV4cG9ydHMpIHtcclxuICAgICAgICBoYXNFeHBvcnRzID0gdHJ1ZTtcclxuICAgICAgICBpZiAoaXNTYWZlRXhwb3J0KGtleSkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBleHBvcnRWYWx1ZSA9IG1vZHVsZUV4cG9ydHNba2V5XTtcclxuICAgICAgICBpZiAoIXJ1bnRpbWVfMS5kZWZhdWx0LmlzTGlrZWx5Q29tcG9uZW50VHlwZShleHBvcnRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgYXJlQWxsRXhwb3J0c0NvbXBvbmVudHMgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzRXhwb3J0cyAmJiBhcmVBbGxFeHBvcnRzQ29tcG9uZW50cztcclxufVxyXG5mdW5jdGlvbiBzaG91bGRJbnZhbGlkYXRlUmVhY3RSZWZyZXNoQm91bmRhcnkocHJldkV4cG9ydHMsIG5leHRFeHBvcnRzKSB7XHJcbiAgICB2YXIgcHJldlNpZ25hdHVyZSA9IGdldFJlZnJlc2hCb3VuZGFyeVNpZ25hdHVyZShwcmV2RXhwb3J0cyk7XHJcbiAgICB2YXIgbmV4dFNpZ25hdHVyZSA9IGdldFJlZnJlc2hCb3VuZGFyeVNpZ25hdHVyZShuZXh0RXhwb3J0cyk7XHJcbiAgICBpZiAocHJldlNpZ25hdHVyZS5sZW5ndGggIT09IG5leHRTaWduYXR1cmUubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHRTaWduYXR1cmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAocHJldlNpZ25hdHVyZVtpXSAhPT0gbmV4dFNpZ25hdHVyZVtpXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmVmcmVzaEJvdW5kYXJ5U2lnbmF0dXJlKG1vZHVsZUV4cG9ydHMpIHtcclxuICAgIHZhciBzaWduYXR1cmUgPSBbXTtcclxuICAgIHNpZ25hdHVyZS5wdXNoKHJ1bnRpbWVfMS5kZWZhdWx0LmdldEZhbWlseUJ5VHlwZShtb2R1bGVFeHBvcnRzKSk7XHJcbiAgICBpZiAobW9kdWxlRXhwb3J0cyA9PSBudWxsIHx8IHR5cGVvZiBtb2R1bGVFeHBvcnRzICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIEV4aXQgaWYgd2UgY2FuJ3QgaXRlcmF0ZSBvdmVyIGV4cG9ydHMuXHJcbiAgICAgICAgLy8gKFRoaXMgaXMgaW1wb3J0YW50IGZvciBsZWdhY3kgZW52aXJvbm1lbnRzLilcclxuICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIga2V5IGluIG1vZHVsZUV4cG9ydHMpIHtcclxuICAgICAgICBpZiAoaXNTYWZlRXhwb3J0KGtleSkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBleHBvcnRWYWx1ZSA9IG1vZHVsZUV4cG9ydHNba2V5XTtcclxuICAgICAgICBzaWduYXR1cmUucHVzaChrZXkpO1xyXG4gICAgICAgIHNpZ25hdHVyZS5wdXNoKHJ1bnRpbWVfMS5kZWZhdWx0LmdldEZhbWlseUJ5VHlwZShleHBvcnRWYWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNpZ25hdHVyZTtcclxufVxyXG52YXIgaXNVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcclxuZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGUoKSB7XHJcbiAgICBpZiAoaXNVcGRhdGVTY2hlZHVsZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjYW5BcHBseVVwZGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gbW9kdWxlLmhvdC5zdGF0dXMoKSA9PT0gJ2lkbGUnO1xyXG4gICAgfVxyXG4gICAgaXNVcGRhdGVTY2hlZHVsZWQgPSB0cnVlO1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaXNVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcclxuICAgICAgICAvLyBPbmx5IHRyaWdnZXIgcmVmcmVzaCBpZiB0aGUgd2VicGFjayBITVIgc3RhdGUgaXMgaWRsZVxyXG4gICAgICAgIGlmIChjYW5BcHBseVVwZGF0ZSgpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBydW50aW1lXzEuZGVmYXVsdC5wZXJmb3JtUmVhY3RSZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBGYWlsZWQgdG8gcmUtcmVuZGVyLiBXZSB3aWxsIHJldHJ5IG9uIHRoZSBuZXh0IEZhc3QgUmVmcmVzaCBldmVudC5cXG4nICtcclxuICAgICAgICAgICAgICAgICAgICBlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlVXBkYXRlKCk7XHJcbiAgICB9LCAzMCk7XHJcbn1cclxuLy8gTmVlZHMgdG8gYmUgY29tcGF0aWJsZSB3aXRoIElFMTFcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gICAgcmVnaXN0ZXJFeHBvcnRzRm9yUmVhY3RSZWZyZXNoOiByZWdpc3RlckV4cG9ydHNGb3JSZWFjdFJlZnJlc2gsXHJcbiAgICBpc1JlYWN0UmVmcmVzaEJvdW5kYXJ5OiBpc1JlYWN0UmVmcmVzaEJvdW5kYXJ5LFxyXG4gICAgc2hvdWxkSW52YWxpZGF0ZVJlYWN0UmVmcmVzaEJvdW5kYXJ5OiBzaG91bGRJbnZhbGlkYXRlUmVhY3RSZWZyZXNoQm91bmRhcnksXHJcbiAgICBnZXRSZWZyZXNoQm91bmRhcnlTaWduYXR1cmU6IGdldFJlZnJlc2hCb3VuZGFyeVNpZ25hdHVyZSxcclxuICAgIHNjaGVkdWxlVXBkYXRlOiBzY2hlZHVsZVVwZGF0ZSxcclxufTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicnVudGltZV8xIiwicmVxdWlyZSIsImlzU2FmZUV4cG9ydCIsImtleSIsInJlZ2lzdGVyRXhwb3J0c0ZvclJlYWN0UmVmcmVzaCIsIm1vZHVsZUV4cG9ydHMiLCJtb2R1bGVJRCIsImRlZmF1bHQiLCJyZWdpc3RlciIsImV4cG9ydFZhbHVlIiwidHlwZUlEIiwiaXNSZWFjdFJlZnJlc2hCb3VuZGFyeSIsImlzTGlrZWx5Q29tcG9uZW50VHlwZSIsImhhc0V4cG9ydHMiLCJhcmVBbGxFeHBvcnRzQ29tcG9uZW50cyIsInNob3VsZEludmFsaWRhdGVSZWFjdFJlZnJlc2hCb3VuZGFyeSIsInByZXZFeHBvcnRzIiwibmV4dEV4cG9ydHMiLCJwcmV2U2lnbmF0dXJlIiwiZ2V0UmVmcmVzaEJvdW5kYXJ5U2lnbmF0dXJlIiwibmV4dFNpZ25hdHVyZSIsImxlbmd0aCIsImkiLCJzaWduYXR1cmUiLCJwdXNoIiwiZ2V0RmFtaWx5QnlUeXBlIiwiaXNVcGRhdGVTY2hlZHVsZWQiLCJzY2hlZHVsZVVwZGF0ZSIsImNhbkFwcGx5VXBkYXRlIiwibW9kdWxlIiwiaG90Iiwic3RhdHVzIiwic2V0VGltZW91dCIsInBlcmZvcm1SZWFjdFJlZnJlc2giLCJlcnIiLCJjb25zb2xlIiwid2FybiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/helpers.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nconst runtime_1 = __importDefault(__webpack_require__(/*! next/dist/compiled/react-refresh/runtime */ \"./node_modules/next/dist/compiled/react-refresh/runtime.js\"));\n\nconst helpers_1 = __importDefault(__webpack_require__(/*! ./internal/helpers */ \"./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/helpers.js\")); // Hook into ReactDOM initialization\n\n\nruntime_1.default.injectIntoGlobalHook(self); // Register global helpers\n\nself.$RefreshHelpers$ = helpers_1.default; // Register a helper for module execution interception\n\nself.$RefreshInterceptModuleExecution$ = function (webpackModuleId) {\n  var prevRefreshReg = self.$RefreshReg$;\n  var prevRefreshSig = self.$RefreshSig$;\n\n  self.$RefreshReg$ = function (type, id) {\n    runtime_1.default.register(type, webpackModuleId + ' ' + id);\n  };\n\n  self.$RefreshSig$ = runtime_1.default.createSignatureFunctionForTransform; // Modeled after `useEffect` cleanup pattern:\n  // https://reactjs.org/docs/hooks-effect.html#effects-with-cleanup\n\n  return function () {\n    self.$RefreshReg$ = prevRefreshReg;\n    self.$RefreshSig$ = prevRefreshSig;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL0BuZXh0L3JlYWN0LXJlZnJlc2gtdXRpbHMvZGlzdC9ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiLElBQUlBLGVBQWUsR0FBSSxRQUFRLEtBQUtBLGVBQWQsSUFBa0MsVUFBVUMsR0FBVixFQUFlO0VBQ25FLE9BQVFBLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFaLEdBQTBCRCxHQUExQixHQUFnQztJQUFFLFdBQVdBO0VBQWIsQ0FBdkM7QUFDSCxDQUZEOztBQUdBRSw4Q0FBNkM7RUFBRUcsS0FBSyxFQUFFO0FBQVQsQ0FBN0M7O0FBQ0EsTUFBTUMsU0FBUyxHQUFHUCxlQUFlLENBQUNRLG1CQUFPLENBQUMsNEdBQUQsQ0FBUixDQUFqQzs7QUFDQSxNQUFNQyxTQUFTLEdBQUdULGVBQWUsQ0FBQ1EsbUJBQU8sQ0FBQyxnSEFBRCxDQUFSLENBQWpDLEMsQ0FDQTs7O0FBQ0FELFNBQVMsQ0FBQ0csT0FBVixDQUFrQkMsb0JBQWxCLENBQXVDQyxJQUF2QyxFLENBQ0E7O0FBQ0FBLElBQUksQ0FBQ0MsZ0JBQUwsR0FBd0JKLFNBQVMsQ0FBQ0MsT0FBbEMsQyxDQUNBOztBQUNBRSxJQUFJLENBQUNFLGlDQUFMLEdBQXlDLFVBQVVDLGVBQVYsRUFBMkI7RUFDaEUsSUFBSUMsY0FBYyxHQUFHSixJQUFJLENBQUNLLFlBQTFCO0VBQ0EsSUFBSUMsY0FBYyxHQUFHTixJQUFJLENBQUNPLFlBQTFCOztFQUNBUCxJQUFJLENBQUNLLFlBQUwsR0FBb0IsVUFBVUcsSUFBVixFQUFnQkMsRUFBaEIsRUFBb0I7SUFDcENkLFNBQVMsQ0FBQ0csT0FBVixDQUFrQlksUUFBbEIsQ0FBMkJGLElBQTNCLEVBQWlDTCxlQUFlLEdBQUcsR0FBbEIsR0FBd0JNLEVBQXpEO0VBQ0gsQ0FGRDs7RUFHQVQsSUFBSSxDQUFDTyxZQUFMLEdBQW9CWixTQUFTLENBQUNHLE9BQVYsQ0FBa0JhLG1DQUF0QyxDQU5nRSxDQU9oRTtFQUNBOztFQUNBLE9BQU8sWUFBWTtJQUNmWCxJQUFJLENBQUNLLFlBQUwsR0FBb0JELGNBQXBCO0lBQ0FKLElBQUksQ0FBQ08sWUFBTCxHQUFvQkQsY0FBcEI7RUFDSCxDQUhEO0FBSUgsQ0FiRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL0BuZXh0L3JlYWN0LXJlZnJlc2gtdXRpbHMvZGlzdC9ydW50aW1lLmpzPzhhYjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgcnVudGltZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtcmVmcmVzaC9ydW50aW1lXCIpKTtcclxuY29uc3QgaGVscGVyc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL2hlbHBlcnNcIikpO1xyXG4vLyBIb29rIGludG8gUmVhY3RET00gaW5pdGlhbGl6YXRpb25cclxucnVudGltZV8xLmRlZmF1bHQuaW5qZWN0SW50b0dsb2JhbEhvb2soc2VsZik7XHJcbi8vIFJlZ2lzdGVyIGdsb2JhbCBoZWxwZXJzXHJcbnNlbGYuJFJlZnJlc2hIZWxwZXJzJCA9IGhlbHBlcnNfMS5kZWZhdWx0O1xyXG4vLyBSZWdpc3RlciBhIGhlbHBlciBmb3IgbW9kdWxlIGV4ZWN1dGlvbiBpbnRlcmNlcHRpb25cclxuc2VsZi4kUmVmcmVzaEludGVyY2VwdE1vZHVsZUV4ZWN1dGlvbiQgPSBmdW5jdGlvbiAod2VicGFja01vZHVsZUlkKSB7XHJcbiAgICB2YXIgcHJldlJlZnJlc2hSZWcgPSBzZWxmLiRSZWZyZXNoUmVnJDtcclxuICAgIHZhciBwcmV2UmVmcmVzaFNpZyA9IHNlbGYuJFJlZnJlc2hTaWckO1xyXG4gICAgc2VsZi4kUmVmcmVzaFJlZyQgPSBmdW5jdGlvbiAodHlwZSwgaWQpIHtcclxuICAgICAgICBydW50aW1lXzEuZGVmYXVsdC5yZWdpc3Rlcih0eXBlLCB3ZWJwYWNrTW9kdWxlSWQgKyAnICcgKyBpZCk7XHJcbiAgICB9O1xyXG4gICAgc2VsZi4kUmVmcmVzaFNpZyQgPSBydW50aW1lXzEuZGVmYXVsdC5jcmVhdGVTaWduYXR1cmVGdW5jdGlvbkZvclRyYW5zZm9ybTtcclxuICAgIC8vIE1vZGVsZWQgYWZ0ZXIgYHVzZUVmZmVjdGAgY2xlYW51cCBwYXR0ZXJuOlxyXG4gICAgLy8gaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2hvb2tzLWVmZmVjdC5odG1sI2VmZmVjdHMtd2l0aC1jbGVhbnVwXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYuJFJlZnJlc2hSZWckID0gcHJldlJlZnJlc2hSZWc7XHJcbiAgICAgICAgc2VsZi4kUmVmcmVzaFNpZyQgPSBwcmV2UmVmcmVzaFNpZztcclxuICAgIH07XHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ1bnRpbWUuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJ1bnRpbWVfMSIsInJlcXVpcmUiLCJoZWxwZXJzXzEiLCJkZWZhdWx0IiwiaW5qZWN0SW50b0dsb2JhbEhvb2siLCJzZWxmIiwiJFJlZnJlc2hIZWxwZXJzJCIsIiRSZWZyZXNoSW50ZXJjZXB0TW9kdWxlRXhlY3V0aW9uJCIsIndlYnBhY2tNb2R1bGVJZCIsInByZXZSZWZyZXNoUmVnIiwiJFJlZnJlc2hSZWckIiwicHJldlJlZnJlc2hTaWciLCIkUmVmcmVzaFNpZyQiLCJ0eXBlIiwiaWQiLCJyZWdpc3RlciIsImNyZWF0ZVNpZ25hdHVyZUZ1bmN0aW9uRm9yVHJhbnNmb3JtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\r\n * @license React\r\n * react-refresh-runtime.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n\n\nif (true) {\n  (function () {\n    'use strict'; // ATTENTION\n\n    var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\n    var REACT_MEMO_TYPE = Symbol.for('react.memo');\n    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.\n    // It's OK to reference families, but use WeakMap/Set for types.\n\n    var allFamiliesByID = new Map();\n    var allFamiliesByType = new PossiblyWeakMap();\n    var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families\n    // that have actually been edited here. This keeps checks fast.\n    // $FlowIssue\n\n    var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.\n    // It is an array of [Family, NextType] tuples.\n\n    var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.\n\n    var helpersByRendererID = new Map();\n    var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.\n\n    var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.\n\n    var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.\n    // It needs to be weak because we do this even for roots that failed to mount.\n    // If there is no WeakMap, we won't attempt to do retrying.\n    // $FlowIssue\n\n    var rootElements = // $FlowIssue\n    typeof WeakMap === 'function' ? new WeakMap() : null;\n    var isPerformingRefresh = false;\n\n    function computeFullKey(signature) {\n      if (signature.fullKey !== null) {\n        return signature.fullKey;\n      }\n\n      var fullKey = signature.ownKey;\n      var hooks;\n\n      try {\n        hooks = signature.getCustomHooks();\n      } catch (err) {\n        // This can happen in an edge case, e.g. if expression like Foo.useSomething\n        // depends on Foo which is lazily initialized during rendering.\n        // In that case just assume we'll have to remount.\n        signature.forceReset = true;\n        signature.fullKey = fullKey;\n        return fullKey;\n      }\n\n      for (var i = 0; i < hooks.length; i++) {\n        var hook = hooks[i];\n\n        if (typeof hook !== 'function') {\n          // Something's wrong. Assume we need to remount.\n          signature.forceReset = true;\n          signature.fullKey = fullKey;\n          return fullKey;\n        }\n\n        var nestedHookSignature = allSignaturesByType.get(hook);\n\n        if (nestedHookSignature === undefined) {\n          // No signature means Hook wasn't in the source code, e.g. in a library.\n          // We'll skip it because we can assume it won't change during this session.\n          continue;\n        }\n\n        var nestedHookKey = computeFullKey(nestedHookSignature);\n\n        if (nestedHookSignature.forceReset) {\n          signature.forceReset = true;\n        }\n\n        fullKey += '\\n---\\n' + nestedHookKey;\n      }\n\n      signature.fullKey = fullKey;\n      return fullKey;\n    }\n\n    function haveEqualSignatures(prevType, nextType) {\n      var prevSignature = allSignaturesByType.get(prevType);\n      var nextSignature = allSignaturesByType.get(nextType);\n\n      if (prevSignature === undefined && nextSignature === undefined) {\n        return true;\n      }\n\n      if (prevSignature === undefined || nextSignature === undefined) {\n        return false;\n      }\n\n      if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n        return false;\n      }\n\n      if (nextSignature.forceReset) {\n        return false;\n      }\n\n      return true;\n    }\n\n    function isReactClass(type) {\n      return type.prototype && type.prototype.isReactComponent;\n    }\n\n    function canPreserveStateBetween(prevType, nextType) {\n      if (isReactClass(prevType) || isReactClass(nextType)) {\n        return false;\n      }\n\n      if (haveEqualSignatures(prevType, nextType)) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function resolveFamily(type) {\n      // Only check updated types to keep lookups fast.\n      return updatedFamiliesByType.get(type);\n    } // If we didn't care about IE11, we could use new Map/Set(iterable).\n\n\n    function cloneMap(map) {\n      var clone = new Map();\n      map.forEach(function (value, key) {\n        clone.set(key, value);\n      });\n      return clone;\n    }\n\n    function cloneSet(set) {\n      var clone = new Set();\n      set.forEach(function (value) {\n        clone.add(value);\n      });\n      return clone;\n    } // This is a safety mechanism to protect against rogue getters and Proxies.\n\n\n    function getProperty(object, property) {\n      try {\n        return object[property];\n      } catch (err) {\n        // Intentionally ignore.\n        return undefined;\n      }\n    }\n\n    function performReactRefresh() {\n      if (pendingUpdates.length === 0) {\n        return null;\n      }\n\n      if (isPerformingRefresh) {\n        return null;\n      }\n\n      isPerformingRefresh = true;\n\n      try {\n        var staleFamilies = new Set();\n        var updatedFamilies = new Set();\n        var updates = pendingUpdates;\n        pendingUpdates = [];\n        updates.forEach(function (_ref) {\n          var family = _ref[0],\n              nextType = _ref[1]; // Now that we got a real edit, we can create associations\n          // that will be read by the React reconciler.\n\n          var prevType = family.current;\n          updatedFamiliesByType.set(prevType, family);\n          updatedFamiliesByType.set(nextType, family);\n          family.current = nextType; // Determine whether this should be a re-render or a re-mount.\n\n          if (canPreserveStateBetween(prevType, nextType)) {\n            updatedFamilies.add(family);\n          } else {\n            staleFamilies.add(family);\n          }\n        }); // TODO: rename these fields to something more meaningful.\n\n        var update = {\n          updatedFamilies: updatedFamilies,\n          // Families that will re-render preserving state\n          staleFamilies: staleFamilies // Families that will be remounted\n\n        };\n        helpersByRendererID.forEach(function (helpers) {\n          // Even if there are no roots, set the handler on first update.\n          // This ensures that if *new* roots are mounted, they'll use the resolve handler.\n          helpers.setRefreshHandler(resolveFamily);\n        });\n        var didError = false;\n        var firstError = null; // We snapshot maps and sets that are mutated during commits.\n        // If we don't do this, there is a risk they will be mutated while\n        // we iterate over them. For example, trying to recover a failed root\n        // may cause another root to be added to the failed list -- an infinite loop.\n\n        var failedRootsSnapshot = cloneSet(failedRoots);\n        var mountedRootsSnapshot = cloneSet(mountedRoots);\n        var helpersByRootSnapshot = cloneMap(helpersByRoot);\n        failedRootsSnapshot.forEach(function (root) {\n          var helpers = helpersByRootSnapshot.get(root);\n\n          if (helpers === undefined) {\n            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n          }\n\n          if (!failedRoots.has(root)) {// No longer failed.\n          }\n\n          if (rootElements === null) {\n            return;\n          }\n\n          if (!rootElements.has(root)) {\n            return;\n          }\n\n          var element = rootElements.get(root);\n\n          try {\n            helpers.scheduleRoot(root, element);\n          } catch (err) {\n            if (!didError) {\n              didError = true;\n              firstError = err;\n            } // Keep trying other roots.\n\n          }\n        });\n        mountedRootsSnapshot.forEach(function (root) {\n          var helpers = helpersByRootSnapshot.get(root);\n\n          if (helpers === undefined) {\n            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n          }\n\n          if (!mountedRoots.has(root)) {// No longer mounted.\n          }\n\n          try {\n            helpers.scheduleRefresh(root, update);\n          } catch (err) {\n            if (!didError) {\n              didError = true;\n              firstError = err;\n            } // Keep trying other roots.\n\n          }\n        });\n\n        if (didError) {\n          throw firstError;\n        }\n\n        return update;\n      } finally {\n        isPerformingRefresh = false;\n      }\n    }\n\n    function register(type, id) {\n      {\n        if (type === null) {\n          return;\n        }\n\n        if (typeof type !== 'function' && typeof type !== 'object') {\n          return;\n        } // This can happen in an edge case, e.g. if we register\n        // return value of a HOC but it returns a cached component.\n        // Ignore anything but the first registration for each type.\n\n\n        if (allFamiliesByType.has(type)) {\n          return;\n        } // Create family or remember to update it.\n        // None of this bookkeeping affects reconciliation\n        // until the first performReactRefresh() call above.\n\n\n        var family = allFamiliesByID.get(id);\n\n        if (family === undefined) {\n          family = {\n            current: type\n          };\n          allFamiliesByID.set(id, family);\n        } else {\n          pendingUpdates.push([family, type]);\n        }\n\n        allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.\n\n        if (typeof type === 'object' && type !== null) {\n          switch (getProperty(type, '$$typeof')) {\n            case REACT_FORWARD_REF_TYPE:\n              register(type.render, id + '$render');\n              break;\n\n            case REACT_MEMO_TYPE:\n              register(type.type, id + '$type');\n              break;\n          }\n        }\n      }\n    }\n\n    function setSignature(type, key) {\n      var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;\n      {\n        if (!allSignaturesByType.has(type)) {\n          allSignaturesByType.set(type, {\n            forceReset: forceReset,\n            ownKey: key,\n            fullKey: null,\n            getCustomHooks: getCustomHooks || function () {\n              return [];\n            }\n          });\n        } // Visit inner types because we might not have signed them.\n\n\n        if (typeof type === 'object' && type !== null) {\n          switch (getProperty(type, '$$typeof')) {\n            case REACT_FORWARD_REF_TYPE:\n              setSignature(type.render, key, forceReset, getCustomHooks);\n              break;\n\n            case REACT_MEMO_TYPE:\n              setSignature(type.type, key, forceReset, getCustomHooks);\n              break;\n          }\n        }\n      }\n    } // This is lazily called during first render for a type.\n    // It captures Hook list at that time so inline requires don't break comparisons.\n\n\n    function collectCustomHooksForSignature(type) {\n      {\n        var signature = allSignaturesByType.get(type);\n\n        if (signature !== undefined) {\n          computeFullKey(signature);\n        }\n      }\n    }\n\n    function getFamilyByID(id) {\n      {\n        return allFamiliesByID.get(id);\n      }\n    }\n\n    function getFamilyByType(type) {\n      {\n        return allFamiliesByType.get(type);\n      }\n    }\n\n    function findAffectedHostInstances(families) {\n      {\n        var affectedInstances = new Set();\n        mountedRoots.forEach(function (root) {\n          var helpers = helpersByRoot.get(root);\n\n          if (helpers === undefined) {\n            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n          }\n\n          var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\n          instancesForRoot.forEach(function (inst) {\n            affectedInstances.add(inst);\n          });\n        });\n        return affectedInstances;\n      }\n    }\n\n    function injectIntoGlobalHook(globalObject) {\n      {\n        // For React Native, the global hook will be set up by require('react-devtools-core').\n        // That code will run before us. So we need to monkeypatch functions on existing hook.\n        // For React Web, the global hook will be set up by the extension.\n        // This will also run before us.\n        var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n        if (hook === undefined) {\n          // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.\n          // Note that in this case it's important that renderer code runs *after* this method call.\n          // Otherwise, the renderer will think that there is no global hook, and won't do the injection.\n          var nextID = 0;\n          globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n            renderers: new Map(),\n            supportsFiber: true,\n            inject: function (injected) {\n              return nextID++;\n            },\n            onScheduleFiberRoot: function (id, root, children) {},\n            onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},\n            onCommitFiberUnmount: function () {}\n          };\n        }\n\n        if (hook.isDisabled) {\n          // This isn't a real property on the hook, but it can be set to opt out\n          // of DevTools integration and associated warnings and logs.\n          // Using console['warn'] to evade Babel and ESLint\n          console['warn']('Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' + 'Fast Refresh is not compatible with this shim and will be disabled.');\n          return;\n        } // Here, we just want to get a reference to scheduleRefresh.\n\n\n        var oldInject = hook.inject;\n\n        hook.inject = function (injected) {\n          var id = oldInject.apply(this, arguments);\n\n          if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n            // This version supports React Refresh.\n            helpersByRendererID.set(id, injected);\n          }\n\n          return id;\n        }; // Do the same for any already injected roots.\n        // This is useful if ReactDOM has already been initialized.\n        // https://github.com/facebook/react/issues/17626\n\n\n        hook.renderers.forEach(function (injected, id) {\n          if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n            // This version supports React Refresh.\n            helpersByRendererID.set(id, injected);\n          }\n        }); // We also want to track currently mounted roots.\n\n        var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n\n        var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function () {};\n\n        hook.onScheduleFiberRoot = function (id, root, children) {\n          if (!isPerformingRefresh) {\n            // If it was intentionally scheduled, don't attempt to restore.\n            // This includes intentionally scheduled unmounts.\n            failedRoots.delete(root);\n\n            if (rootElements !== null) {\n              rootElements.set(root, children);\n            }\n          }\n\n          return oldOnScheduleFiberRoot.apply(this, arguments);\n        };\n\n        hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {\n          var helpers = helpersByRendererID.get(id);\n\n          if (helpers !== undefined) {\n            helpersByRoot.set(root, helpers);\n            var current = root.current;\n            var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.\n            // This logic is copy-pasted from similar logic in the DevTools backend.\n            // If this breaks with some refactoring, you'll want to update DevTools too.\n\n            if (alternate !== null) {\n              var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);\n              var isMounted = current.memoizedState != null && current.memoizedState.element != null;\n\n              if (!wasMounted && isMounted) {\n                // Mount a new root.\n                mountedRoots.add(root);\n                failedRoots.delete(root);\n              } else if (wasMounted && isMounted) ;else if (wasMounted && !isMounted) {\n                // Unmount an existing root.\n                mountedRoots.delete(root);\n\n                if (didError) {\n                  // We'll remount it on future edits.\n                  failedRoots.add(root);\n                } else {\n                  helpersByRoot.delete(root);\n                }\n              } else if (!wasMounted && !isMounted) {\n                if (didError) {\n                  // We'll remount it on future edits.\n                  failedRoots.add(root);\n                }\n              }\n            } else {\n              // Mount a new root.\n              mountedRoots.add(root);\n            }\n          } // Always call the decorated DevTools hook.\n\n\n          return oldOnCommitFiberRoot.apply(this, arguments);\n        };\n      }\n    }\n\n    function hasUnrecoverableErrors() {\n      // TODO: delete this after removing dependency in RN.\n      return false;\n    } // Exposed for testing.\n\n\n    function _getMountedRootCount() {\n      {\n        return mountedRoots.size;\n      }\n    } // This is a wrapper over more primitive functions for setting signature.\n    // Signatures let us decide whether the Hook order has changed on refresh.\n    //\n    // This function is intended to be used as a transform target, e.g.:\n    // var _s = createSignatureFunctionForTransform()\n    //\n    // function Hello() {\n    //   const [foo, setFoo] = useState(0);\n    //   const value = useCustomHook();\n    //   _s(); /* Call without arguments triggers collecting the custom Hook list.\n    //          * This doesn't happen during the module evaluation because we\n    //          * don't want to change the module order with inline requires.\n    //          * Next calls are noops. */\n    //   return <h1>Hi</h1>;\n    // }\n    //\n    // /* Call with arguments attaches the signature to the type: */\n    // _s(\n    //   Hello,\n    //   'useState{[foo, setFoo]}(0)',\n    //   () => [useCustomHook], /* Lazy to avoid triggering inline requires */\n    // );\n\n\n    function createSignatureFunctionForTransform() {\n      {\n        var savedType;\n        var hasCustomHooks;\n        var didCollectHooks = false;\n        return function (type, key, forceReset, getCustomHooks) {\n          if (typeof key === 'string') {\n            // We're in the initial phase that associates signatures\n            // with the functions. Note this may be called multiple times\n            // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).\n            if (!savedType) {\n              // We're in the innermost call, so this is the actual type.\n              savedType = type;\n              hasCustomHooks = typeof getCustomHooks === 'function';\n            } // Set the signature for all types (even wrappers!) in case\n            // they have no signatures of their own. This is to prevent\n            // problems like https://github.com/facebook/react/issues/20417.\n\n\n            if (type != null && (typeof type === 'function' || typeof type === 'object')) {\n              setSignature(type, key, forceReset, getCustomHooks);\n            }\n\n            return type;\n          } else {\n            // We're in the _s() call without arguments, which means\n            // this is the time to collect custom Hook signatures.\n            // Only do this once. This path is hot and runs *inside* every render!\n            if (!didCollectHooks && hasCustomHooks) {\n              didCollectHooks = true;\n              collectCustomHooksForSignature(savedType);\n            }\n          }\n        };\n      }\n    }\n\n    function isLikelyComponentType(type) {\n      {\n        switch (typeof type) {\n          case 'function':\n            {\n              // First, deal with classes.\n              if (type.prototype != null) {\n                if (type.prototype.isReactComponent) {\n                  // React class.\n                  return true;\n                }\n\n                var ownNames = Object.getOwnPropertyNames(type.prototype);\n\n                if (ownNames.length > 1 || ownNames[0] !== 'constructor') {\n                  // This looks like a class.\n                  return false;\n                } // eslint-disable-next-line no-proto\n\n\n                if (type.prototype.__proto__ !== Object.prototype) {\n                  // It has a superclass.\n                  return false;\n                } // Pass through.\n                // This looks like a regular function with empty prototype.\n\n              } // For plain functions and arrows, use name as a heuristic.\n\n\n              var name = type.name || type.displayName;\n              return typeof name === 'string' && /^[A-Z]/.test(name);\n            }\n\n          case 'object':\n            {\n              if (type != null) {\n                switch (getProperty(type, '$$typeof')) {\n                  case REACT_FORWARD_REF_TYPE:\n                  case REACT_MEMO_TYPE:\n                    // Definitely React components.\n                    return true;\n\n                  default:\n                    return false;\n                }\n              }\n\n              return false;\n            }\n\n          default:\n            {\n              return false;\n            }\n        }\n      }\n    }\n\n    exports._getMountedRootCount = _getMountedRootCount;\n    exports.collectCustomHooksForSignature = collectCustomHooksForSignature;\n    exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;\n    exports.findAffectedHostInstances = findAffectedHostInstances;\n    exports.getFamilyByID = getFamilyByID;\n    exports.getFamilyByType = getFamilyByType;\n    exports.hasUnrecoverableErrors = hasUnrecoverableErrors;\n    exports.injectIntoGlobalHook = injectIntoGlobalHook;\n    exports.isLikelyComponentType = isLikelyComponentType;\n    exports.performReactRefresh = performReactRefresh;\n    exports.register = register;\n    exports.setSignature = setSignature;\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXJlZnJlc2gvY2pzL3JlYWN0LXJlZnJlc2gtcnVudGltZS5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFYTs7QUFFYixJQUFJQSxJQUFKLEVBQTJDO0VBQ3pDLENBQUMsWUFBVztJQUNkLGFBRGMsQ0FHZDs7SUFDQSxJQUFJRyxzQkFBc0IsR0FBR0MsTUFBTSxDQUFDQyxHQUFQLENBQVcsbUJBQVgsQ0FBN0I7SUFDQSxJQUFJQyxlQUFlLEdBQUdGLE1BQU0sQ0FBQ0MsR0FBUCxDQUFXLFlBQVgsQ0FBdEI7SUFFQSxJQUFJRSxlQUFlLEdBQUcsT0FBT0MsT0FBUCxLQUFtQixVQUFuQixHQUFnQ0EsT0FBaEMsR0FBMENDLEdBQWhFLENBUGMsQ0FPdUQ7SUFDckU7O0lBRUEsSUFBSUMsZUFBZSxHQUFHLElBQUlELEdBQUosRUFBdEI7SUFDQSxJQUFJRSxpQkFBaUIsR0FBRyxJQUFJSixlQUFKLEVBQXhCO0lBQ0EsSUFBSUssbUJBQW1CLEdBQUcsSUFBSUwsZUFBSixFQUExQixDQVpjLENBWW1DO0lBQ2pEO0lBQ0E7O0lBRUEsSUFBSU0scUJBQXFCLEdBQUcsSUFBSU4sZUFBSixFQUE1QixDQWhCYyxDQWdCcUM7SUFDbkQ7O0lBRUEsSUFBSU8sY0FBYyxHQUFHLEVBQXJCLENBbkJjLENBbUJXOztJQUV6QixJQUFJQyxtQkFBbUIsR0FBRyxJQUFJTixHQUFKLEVBQTFCO0lBQ0EsSUFBSU8sYUFBYSxHQUFHLElBQUlQLEdBQUosRUFBcEIsQ0F0QmMsQ0FzQmlCOztJQUUvQixJQUFJUSxZQUFZLEdBQUcsSUFBSUMsR0FBSixFQUFuQixDQXhCYyxDQXdCZ0I7O0lBRTlCLElBQUlDLFdBQVcsR0FBRyxJQUFJRCxHQUFKLEVBQWxCLENBMUJjLENBMEJlO0lBQzdCO0lBQ0E7SUFDQTs7SUFFQSxJQUFJRSxZQUFZ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Q0U7b0JBQ0EsT0FBTyxJQUFQOztrQkFFRjtvQkFDRSxPQUFPLEtBQVA7Z0JBUEo7Y0FTRDs7Y0FFRCxPQUFPLEtBQVA7WUFDRDs7VUFFSDtZQUNFO2NBQ0UsT0FBTyxLQUFQO1lBQ0Q7UUFuREw7TUFxREQ7SUFDRjs7SUFFRGlJLDRCQUFBLEdBQStCZCxvQkFBL0I7SUFDQWMsc0NBQUEsR0FBeUNoRCw4QkFBekM7SUFDQWdELDJDQUFBLEdBQThDWixtQ0FBOUM7SUFDQVksaUNBQUEsR0FBb0M3Qyx5QkFBcEM7SUFDQTZDLHFCQUFBLEdBQXdCL0MsYUFBeEI7SUFDQStDLHVCQUFBLEdBQTBCOUMsZUFBMUI7SUFDQThDLDhCQUFBLEdBQWlDZixzQkFBakM7SUFDQWUsNEJBQUEsR0FBK0J2QyxvQkFBL0I7SUFDQXVDLDZCQUFBLEdBQWdDUixxQkFBaEM7SUFDQVEsMkJBQUEsR0FBOEIzRSxtQkFBOUI7SUFDQTJFLGdCQUFBLEdBQW1CdEQsUUFBbkI7SUFDQXNELG9CQUFBLEdBQXVCbEQsWUFBdkI7RUFDRyxDQW5vQkQ7QUFvb0JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtcmVmcmVzaC9janMvcmVhY3QtcmVmcmVzaC1ydW50aW1lLmRldmVsb3BtZW50LmpzPzdlODQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBsaWNlbnNlIFJlYWN0XHJcbiAqIHJlYWN0LXJlZnJlc2gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgKGZ1bmN0aW9uKCkge1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vLyBBVFRFTlRJT05cclxudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xyXG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xyXG5cclxudmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDsgLy8gV2UgbmV2ZXIgcmVtb3ZlIHRoZXNlIGFzc29jaWF0aW9ucy5cclxuLy8gSXQncyBPSyB0byByZWZlcmVuY2UgZmFtaWxpZXMsIGJ1dCB1c2UgV2Vha01hcC9TZXQgZm9yIHR5cGVzLlxyXG5cclxudmFyIGFsbEZhbWlsaWVzQnlJRCA9IG5ldyBNYXAoKTtcclxudmFyIGFsbEZhbWlsaWVzQnlUeXBlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xyXG52YXIgYWxsU2lnbmF0dXJlc0J5VHlwZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTsgLy8gVGhpcyBXZWFrTWFwIGlzIHJlYWQgYnkgUmVhY3QsIHNvIHdlIG9ubHkgcHV0IGZhbWlsaWVzXHJcbi8vIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGVkaXRlZCBoZXJlLiBUaGlzIGtlZXBzIGNoZWNrcyBmYXN0LlxyXG4vLyAkRmxvd0lzc3VlXHJcblxyXG52YXIgdXBkYXRlZEZhbWlsaWVzQnlUeXBlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpOyAvLyBUaGlzIGlzIGNsZWFyZWQgb24gZXZlcnkgcGVyZm9ybVJlYWN0UmVmcmVzaCgpIGNhbGwuXHJcbi8vIEl0IGlzIGFuIGFycmF5IG9mIFtGYW1pbHksIE5leHRUeXBlXSB0dXBsZXMuXHJcblxyXG52YXIgcGVuZGluZ1VwZGF0ZXMgPSBbXTsgLy8gVGhpcyBpcyBpbmplY3RlZCBieSB0aGUgcmVuZGVyZXIgdmlhIERldlRvb2xzIGdsb2JhbCBob29rLlxyXG5cclxudmFyIGhlbHBlcnNCeVJlbmRlcmVySUQgPSBuZXcgTWFwKCk7XHJcbnZhciBoZWxwZXJzQnlSb290ID0gbmV3IE1hcCgpOyAvLyBXZSBrZWVwIHRyYWNrIG9mIG1vdW50ZWQgcm9vdHMgc28gd2UgY2FuIHNjaGVkdWxlIHVwZGF0ZXMuXHJcblxyXG52YXIgbW91bnRlZFJvb3RzID0gbmV3IFNldCgpOyAvLyBJZiBhIHJvb3QgY2FwdHVyZXMgYW4gZXJyb3IsIHdlIHJlbWVtYmVyIGl0IHNvIHdlIGNhbiByZXRyeSBvbiBlZGl0LlxyXG5cclxudmFyIGZhaWxlZFJvb3RzID0gbmV3IFNldCgpOyAvLyBJbiBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IFdlYWtNYXAsIHdlIGFsc28gcmVtZW1iZXIgdGhlIGxhc3QgZWxlbWVudCBmb3IgZXZlcnkgcm9vdC5cclxuLy8gSXQgbmVlZHMgdG8gYmUgd2VhayBiZWNhdXNlIHdlIGRvIHRoaXMgZXZlbiBmb3Igcm9vdHMgdGhhdCBmYWlsZWQgdG8gbW91bnQuXHJcbi8vIElmIHRoZXJlIGlzIG5vIFdlYWtNYXAsIHdlIHdvbid0IGF0dGVtcHQgdG8gZG8gcmV0cnlpbmcuXHJcbi8vICRGbG93SXNzdWVcclxuXHJcbnZhciByb290RWxlbWVudHMgPSAvLyAkRmxvd0lzc3VlXHJcbnR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gbmV3IFdlYWtNYXAoKSA6IG51bGw7XHJcbnZhciBpc1BlcmZvcm1pbmdSZWZyZXNoID0gZmFsc2U7XHJcblxyXG5mdW5jdGlvbiBjb21wdXRlRnVsbEtleShzaWduYXR1cmUpIHtcclxuICBpZiAoc2lnbmF0dXJlLmZ1bGxLZXkgIT09IG51bGwpIHtcclxuICAgIHJldHVybiBzaWduYXR1cmUuZnVsbEtleTtcclxuICB9XHJcblxyXG4gIHZhciBmdWxsS2V5ID0gc2lnbmF0dXJlLm93bktleTtcclxuICB2YXIgaG9va3M7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBob29rcyA9IHNpZ25hdHVyZS5nZXRDdXN0b21Ib29rcygpO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgLy8gVGhpcyBjYW4gaGFwcGVuIGluIGFuIGVkZ2UgY2FzZSwgZS5nLiBpZiBleHByZXNzaW9uIGxpa2UgRm9vLnVzZVNvbWV0aGluZ1xyXG4gICAgLy8gZGVwZW5kcyBvbiBGb28gd2hpY2ggaXMgbGF6aWx5IGluaXRpYWxpemVkIGR1cmluZyByZW5kZXJpbmcuXHJcbiAgICAvLyBJbiB0aGF0IGNhc2UganVzdCBhc3N1bWUgd2UnbGwgaGF2ZSB0byByZW1vdW50LlxyXG4gICAgc2lnbmF0dXJlLmZvcmNlUmVzZXQgPSB0cnVlO1xyXG4gICAgc2lnbmF0dXJlLmZ1bGxLZXkgPSBmdWxsS2V5O1xyXG4gICAgcmV0dXJuIGZ1bGxLZXk7XHJcbiAgfVxyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgaG9vayA9IGhvb2tzW2ldO1xyXG5cclxuICAgIGlmICh0eXBlb2YgaG9vayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAvLyBTb21ldGhpbmcncyB3cm9uZy4gQXNzdW1lIHdlIG5lZWQgdG8gcmVtb3VudC5cclxuICAgICAgc2lnbmF0dXJlLmZvcmNlUmVzZXQgPSB0cnVlO1xyXG4gICAgICBzaWduYXR1cmUuZnVsbEtleSA9IGZ1bGxLZXk7XHJcbiAgICAgIHJldHVybiBmdWxsS2V5O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBuZXN0ZWRIb29rU2lnbmF0dXJlID0gYWxsU2lnbmF0dXJlc0J5VHlwZS5nZXQoaG9vayk7XHJcblxyXG4gICAgaWYgKG5lc3RlZEhvb2tTaWduYXR1cmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBObyBzaWduYXR1cmUgbWVhbnMgSG9vayB3YXNuJ3QgaW4gdGhlIHNvdXJjZSBjb2RlLCBlLmcuIGluIGEgbGlicmFyeS5cclxuICAgICAgLy8gV2UnbGwgc2tpcCBpdCBiZWNhdXNlIHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgY2hhbmdlIGR1cmluZyB0aGlzIHNlc3Npb24uXHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBuZXN0ZWRIb29rS2V5ID0gY29tcHV0ZUZ1bGxLZXkobmVzdGVkSG9va1NpZ25hdHVyZSk7XHJcblxyXG4gICAgaWYgKG5lc3RlZEhvb2tTaWduYXR1cmUuZm9yY2VSZXNldCkge1xyXG4gICAgICBzaWduYXR1cmUuZm9yY2VSZXNldCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVsbEtleSArPSAnXFxuLS0tXFxuJyArIG5lc3RlZEhvb2tLZXk7XHJcbiAgfVxyXG5cclxuICBzaWduYXR1cmUuZnVsbEtleSA9IGZ1bGxLZXk7XHJcbiAgcmV0dXJuIGZ1bGxLZXk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhdmVFcXVhbFNpZ25hdHVyZXMocHJldlR5cGUsIG5leHRUeXBlKSB7XHJcbiAgdmFyIHByZXZTaWduYXR1cmUgPSBhbGxTaWduYXR1cmVzQnlUeXBlLmdldChwcmV2VHlwZSk7XHJcbiAgdmFyIG5leHRTaWduYXR1cmUgPSBhbGxTaWduYXR1cmVzQnlUeXBlLmdldChuZXh0VHlwZSk7XHJcblxyXG4gIGlmIChwcmV2U2lnbmF0dXJlID09PSB1bmRlZmluZWQgJiYgbmV4dFNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChwcmV2U2lnbmF0dXJlID09PSB1bmRlZmluZWQgfHwgbmV4dFNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoY29tcHV0ZUZ1bGxLZXkocHJldlNpZ25hdHVyZSkgIT09IGNvbXB1dGVGdWxsS2V5KG5leHRTaWduYXR1cmUpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAobmV4dFNpZ25hdHVyZS5mb3JjZVJlc2V0KSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNSZWFjdENsYXNzKHR5cGUpIHtcclxuICByZXR1cm4gdHlwZS5wcm90b3R5cGUgJiYgdHlwZS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gY2FuUHJlc2VydmVTdGF0ZUJldHdlZW4ocHJldlR5cGUsIG5leHRUeXBlKSB7XHJcbiAgaWYgKGlzUmVhY3RDbGFzcyhwcmV2VHlwZSkgfHwgaXNSZWFjdENsYXNzKG5leHRUeXBlKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKGhhdmVFcXVhbFNpZ25hdHVyZXMocHJldlR5cGUsIG5leHRUeXBlKSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVGYW1pbHkodHlwZSkge1xyXG4gIC8vIE9ubHkgY2hlY2sgdXBkYXRlZCB0eXBlcyB0byBrZWVwIGxvb2t1cHMgZmFzdC5cclxuICByZXR1cm4gdXBkYXRlZEZhbWlsaWVzQnlUeXBlLmdldCh0eXBlKTtcclxufSAvLyBJZiB3ZSBkaWRuJ3QgY2FyZSBhYm91dCBJRTExLCB3ZSBjb3VsZCB1c2UgbmV3IE1hcC9TZXQoaXRlcmFibGUpLlxyXG5cclxuXHJcbmZ1bmN0aW9uIGNsb25lTWFwKG1hcCkge1xyXG4gIHZhciBjbG9uZSA9IG5ldyBNYXAoKTtcclxuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgY2xvbmUuc2V0KGtleSwgdmFsdWUpO1xyXG4gIH0pO1xyXG4gIHJldHVybiBjbG9uZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2xvbmVTZXQoc2V0KSB7XHJcbiAgdmFyIGNsb25lID0gbmV3IFNldCgpO1xyXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgY2xvbmUuYWRkKHZhbHVlKTtcclxuICB9KTtcclxuICByZXR1cm4gY2xvbmU7XHJcbn0gLy8gVGhpcyBpcyBhIHNhZmV0eSBtZWNoYW5pc20gdG8gcHJvdGVjdCBhZ2FpbnN0IHJvZ3VlIGdldHRlcnMgYW5kIFByb3hpZXMuXHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0UHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gb2JqZWN0W3Byb3BlcnR5XTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIC8vIEludGVudGlvbmFsbHkgaWdub3JlLlxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBlcmZvcm1SZWFjdFJlZnJlc2goKSB7XHJcblxyXG4gIGlmIChwZW5kaW5nVXBkYXRlcy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzUGVyZm9ybWluZ1JlZnJlc2gpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgaXNQZXJmb3JtaW5nUmVmcmVzaCA9IHRydWU7XHJcblxyXG4gIHRyeSB7XHJcbiAgICB2YXIgc3RhbGVGYW1pbGllcyA9IG5ldyBTZXQoKTtcclxuICAgIHZhciB1cGRhdGVkRmFtaWxpZXMgPSBuZXcgU2V0KCk7XHJcbiAgICB2YXIgdXBkYXRlcyA9IHBlbmRpbmdVcGRhdGVzO1xyXG4gICAgcGVuZGluZ1VwZGF0ZXMgPSBbXTtcclxuICAgIHVwZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xyXG4gICAgICB2YXIgZmFtaWx5ID0gX3JlZlswXSxcclxuICAgICAgICAgIG5leHRUeXBlID0gX3JlZlsxXTtcclxuICAgICAgLy8gTm93IHRoYXQgd2UgZ290IGEgcmVhbCBlZGl0LCB3ZSBjYW4gY3JlYXRlIGFzc29jaWF0aW9uc1xyXG4gICAgICAvLyB0aGF0IHdpbGwgYmUgcmVhZCBieSB0aGUgUmVhY3QgcmVjb25jaWxlci5cclxuICAgICAgdmFyIHByZXZUeXBlID0gZmFtaWx5LmN1cnJlbnQ7XHJcbiAgICAgIHVwZGF0ZWRGYW1pbGllc0J5VHlwZS5zZXQocHJldlR5cGUsIGZhbWlseSk7XHJcbiAgICAgIHVwZGF0ZWRGYW1pbGllc0J5VHlwZS5zZXQobmV4dFR5cGUsIGZhbWlseSk7XHJcbiAgICAgIGZhbWlseS5jdXJyZW50ID0gbmV4dFR5cGU7IC8vIERldGVybWluZSB3aGV0aGVyIHRoaXMgc2hvdWxkIGJlIGEgcmUtcmVuZGVyIG9yIGEgcmUtbW91bnQuXHJcblxyXG4gICAgICBpZiAoY2FuUHJlc2VydmVTdGF0ZUJldHdlZW4ocHJldlR5cGUsIG5leHRUeXBlKSkge1xyXG4gICAgICAgIHVwZGF0ZWRGYW1pbGllcy5hZGQoZmFtaWx5KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdGFsZUZhbWlsaWVzLmFkZChmYW1pbHkpO1xyXG4gICAgICB9XHJcbiAgICB9KTsgLy8gVE9ETzogcmVuYW1lIHRoZXNlIGZpZWxkcyB0byBzb21ldGhpbmcgbW9yZSBtZWFuaW5nZnVsLlxyXG5cclxuICAgIHZhciB1cGRhdGUgPSB7XHJcbiAgICAgIHVwZGF0ZWRGYW1pbGllczogdXBkYXRlZEZhbWlsaWVzLFxyXG4gICAgICAvLyBGYW1pbGllcyB0aGF0IHdpbGwgcmUtcmVuZGVyIHByZXNlcnZpbmcgc3RhdGVcclxuICAgICAgc3RhbGVGYW1pbGllczogc3RhbGVGYW1pbGllcyAvLyBGYW1pbGllcyB0aGF0IHdpbGwgYmUgcmVtb3VudGVkXHJcblxyXG4gICAgfTtcclxuICAgIGhlbHBlcnNCeVJlbmRlcmVySUQuZm9yRWFjaChmdW5jdGlvbiAoaGVscGVycykge1xyXG4gICAgICAvLyBFdmVuIGlmIHRoZXJlIGFyZSBubyByb290cywgc2V0IHRoZSBoYW5kbGVyIG9uIGZpcnN0IHVwZGF0ZS5cclxuICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgaWYgKm5ldyogcm9vdHMgYXJlIG1vdW50ZWQsIHRoZXknbGwgdXNlIHRoZSByZXNvbHZlIGhhbmRsZXIuXHJcbiAgICAgIGhlbHBlcnMuc2V0UmVmcmVzaEhhbmRsZXIocmVzb2x2ZUZhbWlseSk7XHJcbiAgICB9KTtcclxuICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xyXG4gICAgdmFyIGZpcnN0RXJyb3IgPSBudWxsOyAvLyBXZSBzbmFwc2hvdCBtYXBzIGFuZCBzZXRzIHRoYXQgYXJlIG11dGF0ZWQgZHVyaW5nIGNvbW1pdHMuXHJcbiAgICAvLyBJZiB3ZSBkb24ndCBkbyB0aGlzLCB0aGVyZSBpcyBhIHJpc2sgdGhleSB3aWxsIGJlIG11dGF0ZWQgd2hpbGVcclxuICAgIC8vIHdlIGl0ZXJhdGUgb3ZlciB0aGVtLiBGb3IgZXhhbXBsZSwgdHJ5aW5nIHRvIHJlY292ZXIgYSBmYWlsZWQgcm9vdFxyXG4gICAgLy8gbWF5IGNhdXNlIGFub3RoZXIgcm9vdCB0byBiZSBhZGRlZCB0byB0aGUgZmFpbGVkIGxpc3QgLS0gYW4gaW5maW5pdGUgbG9vcC5cclxuXHJcbiAgICB2YXIgZmFpbGVkUm9vdHNTbmFwc2hvdCA9IGNsb25lU2V0KGZhaWxlZFJvb3RzKTtcclxuICAgIHZhciBtb3VudGVkUm9vdHNTbmFwc2hvdCA9IGNsb25lU2V0KG1vdW50ZWRSb290cyk7XHJcbiAgICB2YXIgaGVscGVyc0J5Um9vdFNuYXBzaG90ID0gY2xvbmVNYXAoaGVscGVyc0J5Um9vdCk7XHJcbiAgICBmYWlsZWRSb290c1NuYXBzaG90LmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcclxuICAgICAgdmFyIGhlbHBlcnMgPSBoZWxwZXJzQnlSb290U25hcHNob3QuZ2V0KHJvb3QpO1xyXG5cclxuICAgICAgaWYgKGhlbHBlcnMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgaGVscGVycyBmb3IgYSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0IFJlZnJlc2guJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghZmFpbGVkUm9vdHMuaGFzKHJvb3QpKSB7Ly8gTm8gbG9uZ2VyIGZhaWxlZC5cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJvb3RFbGVtZW50cyA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFyb290RWxlbWVudHMuaGFzKHJvb3QpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZWxlbWVudCA9IHJvb3RFbGVtZW50cy5nZXQocm9vdCk7XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGhlbHBlcnMuc2NoZWR1bGVSb290KHJvb3QsIGVsZW1lbnQpO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBpZiAoIWRpZEVycm9yKSB7XHJcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XHJcbiAgICAgICAgICBmaXJzdEVycm9yID0gZXJyO1xyXG4gICAgICAgIH0gLy8gS2VlcCB0cnlpbmcgb3RoZXIgcm9vdHMuXHJcblxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIG1vdW50ZWRSb290c1NuYXBzaG90LmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcclxuICAgICAgdmFyIGhlbHBlcnMgPSBoZWxwZXJzQnlSb290U25hcHNob3QuZ2V0KHJvb3QpO1xyXG5cclxuICAgICAgaWYgKGhlbHBlcnMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgaGVscGVycyBmb3IgYSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0IFJlZnJlc2guJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghbW91bnRlZFJvb3RzLmhhcyhyb290KSkgey8vIE5vIGxvbmdlciBtb3VudGVkLlxyXG4gICAgICB9XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGhlbHBlcnMuc2NoZWR1bGVSZWZyZXNoKHJvb3QsIHVwZGF0ZSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGlmICghZGlkRXJyb3IpIHtcclxuICAgICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcclxuICAgICAgICAgIGZpcnN0RXJyb3IgPSBlcnI7XHJcbiAgICAgICAgfSAvLyBLZWVwIHRyeWluZyBvdGhlciByb290cy5cclxuXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChkaWRFcnJvcikge1xyXG4gICAgICB0aHJvdyBmaXJzdEVycm9yO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1cGRhdGU7XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIGlzUGVyZm9ybWluZ1JlZnJlc2ggPSBmYWxzZTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gcmVnaXN0ZXIodHlwZSwgaWQpIHtcclxuICB7XHJcbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9IC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBhbiBlZGdlIGNhc2UsIGUuZy4gaWYgd2UgcmVnaXN0ZXJcclxuICAgIC8vIHJldHVybiB2YWx1ZSBvZiBhIEhPQyBidXQgaXQgcmV0dXJucyBhIGNhY2hlZCBjb21wb25lbnQuXHJcbiAgICAvLyBJZ25vcmUgYW55dGhpbmcgYnV0IHRoZSBmaXJzdCByZWdpc3RyYXRpb24gZm9yIGVhY2ggdHlwZS5cclxuXHJcblxyXG4gICAgaWYgKGFsbEZhbWlsaWVzQnlUeXBlLmhhcyh0eXBlKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9IC8vIENyZWF0ZSBmYW1pbHkgb3IgcmVtZW1iZXIgdG8gdXBkYXRlIGl0LlxyXG4gICAgLy8gTm9uZSBvZiB0aGlzIGJvb2trZWVwaW5nIGFmZmVjdHMgcmVjb25jaWxpYXRpb25cclxuICAgIC8vIHVudGlsIHRoZSBmaXJzdCBwZXJmb3JtUmVhY3RSZWZyZXNoKCkgY2FsbCBhYm92ZS5cclxuXHJcblxyXG4gICAgdmFyIGZhbWlseSA9IGFsbEZhbWlsaWVzQnlJRC5nZXQoaWQpO1xyXG5cclxuICAgIGlmIChmYW1pbHkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBmYW1pbHkgPSB7XHJcbiAgICAgICAgY3VycmVudDogdHlwZVxyXG4gICAgICB9O1xyXG4gICAgICBhbGxGYW1pbGllc0J5SUQuc2V0KGlkLCBmYW1pbHkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGVuZGluZ1VwZGF0ZXMucHVzaChbZmFtaWx5LCB0eXBlXSk7XHJcbiAgICB9XHJcblxyXG4gICAgYWxsRmFtaWxpZXNCeVR5cGUuc2V0KHR5cGUsIGZhbWlseSk7IC8vIFZpc2l0IGlubmVyIHR5cGVzIGJlY2F1c2Ugd2UgbWlnaHQgbm90IGhhdmUgcmVnaXN0ZXJlZCB0aGVtLlxyXG5cclxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xyXG4gICAgICBzd2l0Y2ggKGdldFByb3BlcnR5KHR5cGUsICckJHR5cGVvZicpKSB7XHJcbiAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxyXG4gICAgICAgICAgcmVnaXN0ZXIodHlwZS5yZW5kZXIsIGlkICsgJyRyZW5kZXInKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcclxuICAgICAgICAgIHJlZ2lzdGVyKHR5cGUudHlwZSwgaWQgKyAnJHR5cGUnKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldFNpZ25hdHVyZSh0eXBlLCBrZXkpIHtcclxuICB2YXIgZm9yY2VSZXNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XHJcbiAgdmFyIGdldEN1c3RvbUhvb2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XHJcblxyXG4gIHtcclxuICAgIGlmICghYWxsU2lnbmF0dXJlc0J5VHlwZS5oYXModHlwZSkpIHtcclxuICAgICAgYWxsU2lnbmF0dXJlc0J5VHlwZS5zZXQodHlwZSwge1xyXG4gICAgICAgIGZvcmNlUmVzZXQ6IGZvcmNlUmVzZXQsXHJcbiAgICAgICAgb3duS2V5OiBrZXksXHJcbiAgICAgICAgZnVsbEtleTogbnVsbCxcclxuICAgICAgICBnZXRDdXN0b21Ib29rczogZ2V0Q3VzdG9tSG9va3MgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9IC8vIFZpc2l0IGlubmVyIHR5cGVzIGJlY2F1c2Ugd2UgbWlnaHQgbm90IGhhdmUgc2lnbmVkIHRoZW0uXHJcblxyXG5cclxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xyXG4gICAgICBzd2l0Y2ggKGdldFByb3BlcnR5KHR5cGUsICckJHR5cGVvZicpKSB7XHJcbiAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxyXG4gICAgICAgICAgc2V0U2lnbmF0dXJlKHR5cGUucmVuZGVyLCBrZXksIGZvcmNlUmVzZXQsIGdldEN1c3RvbUhvb2tzKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcclxuICAgICAgICAgIHNldFNpZ25hdHVyZSh0eXBlLnR5cGUsIGtleSwgZm9yY2VSZXNldCwgZ2V0Q3VzdG9tSG9va3MpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0gLy8gVGhpcyBpcyBsYXppbHkgY2FsbGVkIGR1cmluZyBmaXJzdCByZW5kZXIgZm9yIGEgdHlwZS5cclxuLy8gSXQgY2FwdHVyZXMgSG9vayBsaXN0IGF0IHRoYXQgdGltZSBzbyBpbmxpbmUgcmVxdWlyZXMgZG9uJ3QgYnJlYWsgY29tcGFyaXNvbnMuXHJcblxyXG5mdW5jdGlvbiBjb2xsZWN0Q3VzdG9tSG9va3NGb3JTaWduYXR1cmUodHlwZSkge1xyXG4gIHtcclxuICAgIHZhciBzaWduYXR1cmUgPSBhbGxTaWduYXR1cmVzQnlUeXBlLmdldCh0eXBlKTtcclxuXHJcbiAgICBpZiAoc2lnbmF0dXJlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29tcHV0ZUZ1bGxLZXkoc2lnbmF0dXJlKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0RmFtaWx5QnlJRChpZCkge1xyXG4gIHtcclxuICAgIHJldHVybiBhbGxGYW1pbGllc0J5SUQuZ2V0KGlkKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0RmFtaWx5QnlUeXBlKHR5cGUpIHtcclxuICB7XHJcbiAgICByZXR1cm4gYWxsRmFtaWxpZXNCeVR5cGUuZ2V0KHR5cGUpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBmaW5kQWZmZWN0ZWRIb3N0SW5zdGFuY2VzKGZhbWlsaWVzKSB7XHJcbiAge1xyXG4gICAgdmFyIGFmZmVjdGVkSW5zdGFuY2VzID0gbmV3IFNldCgpO1xyXG4gICAgbW91bnRlZFJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcclxuICAgICAgdmFyIGhlbHBlcnMgPSBoZWxwZXJzQnlSb290LmdldChyb290KTtcclxuXHJcbiAgICAgIGlmIChoZWxwZXJzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGhlbHBlcnMgZm9yIGEgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCBSZWZyZXNoLicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgaW5zdGFuY2VzRm9yUm9vdCA9IGhlbHBlcnMuZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoKHJvb3QsIGZhbWlsaWVzKTtcclxuICAgICAgaW5zdGFuY2VzRm9yUm9vdC5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0KSB7XHJcbiAgICAgICAgYWZmZWN0ZWRJbnN0YW5jZXMuYWRkKGluc3QpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGFmZmVjdGVkSW5zdGFuY2VzO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBpbmplY3RJbnRvR2xvYmFsSG9vayhnbG9iYWxPYmplY3QpIHtcclxuICB7XHJcbiAgICAvLyBGb3IgUmVhY3QgTmF0aXZlLCB0aGUgZ2xvYmFsIGhvb2sgd2lsbCBiZSBzZXQgdXAgYnkgcmVxdWlyZSgncmVhY3QtZGV2dG9vbHMtY29yZScpLlxyXG4gICAgLy8gVGhhdCBjb2RlIHdpbGwgcnVuIGJlZm9yZSB1cy4gU28gd2UgbmVlZCB0byBtb25rZXlwYXRjaCBmdW5jdGlvbnMgb24gZXhpc3RpbmcgaG9vay5cclxuICAgIC8vIEZvciBSZWFjdCBXZWIsIHRoZSBnbG9iYWwgaG9vayB3aWxsIGJlIHNldCB1cCBieSB0aGUgZXh0ZW5zaW9uLlxyXG4gICAgLy8gVGhpcyB3aWxsIGFsc28gcnVuIGJlZm9yZSB1cy5cclxuICAgIHZhciBob29rID0gZ2xvYmFsT2JqZWN0Ll9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcclxuXHJcbiAgICBpZiAoaG9vayA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vIEhvd2V2ZXIsIGlmIHRoZXJlIGlzIG5vIERldlRvb2xzIGV4dGVuc2lvbiwgd2UnbGwgbmVlZCB0byBzZXQgdXAgdGhlIGdsb2JhbCBob29rIG91cnNlbHZlcy5cclxuICAgICAgLy8gTm90ZSB0aGF0IGluIHRoaXMgY2FzZSBpdCdzIGltcG9ydGFudCB0aGF0IHJlbmRlcmVyIGNvZGUgcnVucyAqYWZ0ZXIqIHRoaXMgbWV0aG9kIGNhbGwuXHJcbiAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHJlbmRlcmVyIHdpbGwgdGhpbmsgdGhhdCB0aGVyZSBpcyBubyBnbG9iYWwgaG9vaywgYW5kIHdvbid0IGRvIHRoZSBpbmplY3Rpb24uXHJcbiAgICAgIHZhciBuZXh0SUQgPSAwO1xyXG4gICAgICBnbG9iYWxPYmplY3QuX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID0gaG9vayA9IHtcclxuICAgICAgICByZW5kZXJlcnM6IG5ldyBNYXAoKSxcclxuICAgICAgICBzdXBwb3J0c0ZpYmVyOiB0cnVlLFxyXG4gICAgICAgIGluamVjdDogZnVuY3Rpb24gKGluamVjdGVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV4dElEKys7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvblNjaGVkdWxlRmliZXJSb290OiBmdW5jdGlvbiAoaWQsIHJvb3QsIGNoaWxkcmVuKSB7fSxcclxuICAgICAgICBvbkNvbW1pdEZpYmVyUm9vdDogZnVuY3Rpb24gKGlkLCByb290LCBtYXliZVByaW9yaXR5TGV2ZWwsIGRpZEVycm9yKSB7fSxcclxuICAgICAgICBvbkNvbW1pdEZpYmVyVW5tb3VudDogZnVuY3Rpb24gKCkge31cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaG9vay5pc0Rpc2FibGVkKSB7XHJcbiAgICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XHJcbiAgICAgIC8vIG9mIERldlRvb2xzIGludGVncmF0aW9uIGFuZCBhc3NvY2lhdGVkIHdhcm5pbmdzIGFuZCBsb2dzLlxyXG4gICAgICAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxyXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1NvbWV0aGluZyBoYXMgc2hpbW1lZCB0aGUgUmVhY3QgRGV2VG9vbHMgZ2xvYmFsIGhvb2sgKF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXykuICcgKyAnRmFzdCBSZWZyZXNoIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhpcyBzaGltIGFuZCB3aWxsIGJlIGRpc2FibGVkLicpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9IC8vIEhlcmUsIHdlIGp1c3Qgd2FudCB0byBnZXQgYSByZWZlcmVuY2UgdG8gc2NoZWR1bGVSZWZyZXNoLlxyXG5cclxuXHJcbiAgICB2YXIgb2xkSW5qZWN0ID0gaG9vay5pbmplY3Q7XHJcblxyXG4gICAgaG9vay5pbmplY3QgPSBmdW5jdGlvbiAoaW5qZWN0ZWQpIHtcclxuICAgICAgdmFyIGlkID0gb2xkSW5qZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGluamVjdGVkLnNjaGVkdWxlUmVmcmVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5qZWN0ZWQuc2V0UmVmcmVzaEhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBUaGlzIHZlcnNpb24gc3VwcG9ydHMgUmVhY3QgUmVmcmVzaC5cclxuICAgICAgICBoZWxwZXJzQnlSZW5kZXJlcklELnNldChpZCwgaW5qZWN0ZWQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gaWQ7XHJcbiAgICB9OyAvLyBEbyB0aGUgc2FtZSBmb3IgYW55IGFscmVhZHkgaW5qZWN0ZWQgcm9vdHMuXHJcbiAgICAvLyBUaGlzIGlzIHVzZWZ1bCBpZiBSZWFjdERPTSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLlxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNzYyNlxyXG5cclxuXHJcbiAgICBob29rLnJlbmRlcmVycy5mb3JFYWNoKGZ1bmN0aW9uIChpbmplY3RlZCwgaWQpIHtcclxuICAgICAgaWYgKHR5cGVvZiBpbmplY3RlZC5zY2hlZHVsZVJlZnJlc2ggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluamVjdGVkLnNldFJlZnJlc2hIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gVGhpcyB2ZXJzaW9uIHN1cHBvcnRzIFJlYWN0IFJlZnJlc2guXHJcbiAgICAgICAgaGVscGVyc0J5UmVuZGVyZXJJRC5zZXQoaWQsIGluamVjdGVkKTtcclxuICAgICAgfVxyXG4gICAgfSk7IC8vIFdlIGFsc28gd2FudCB0byB0cmFjayBjdXJyZW50bHkgbW91bnRlZCByb290cy5cclxuXHJcbiAgICB2YXIgb2xkT25Db21taXRGaWJlclJvb3QgPSBob29rLm9uQ29tbWl0RmliZXJSb290O1xyXG5cclxuICAgIHZhciBvbGRPblNjaGVkdWxlRmliZXJSb290ID0gaG9vay5vblNjaGVkdWxlRmliZXJSb290IHx8IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuICAgIGhvb2sub25TY2hlZHVsZUZpYmVyUm9vdCA9IGZ1bmN0aW9uIChpZCwgcm9vdCwgY2hpbGRyZW4pIHtcclxuICAgICAgaWYgKCFpc1BlcmZvcm1pbmdSZWZyZXNoKSB7XHJcbiAgICAgICAgLy8gSWYgaXQgd2FzIGludGVudGlvbmFsbHkgc2NoZWR1bGVkLCBkb24ndCBhdHRlbXB0IHRvIHJlc3RvcmUuXHJcbiAgICAgICAgLy8gVGhpcyBpbmNsdWRlcyBpbnRlbnRpb25hbGx5IHNjaGVkdWxlZCB1bm1vdW50cy5cclxuICAgICAgICBmYWlsZWRSb290cy5kZWxldGUocm9vdCk7XHJcblxyXG4gICAgICAgIGlmIChyb290RWxlbWVudHMgIT09IG51bGwpIHtcclxuICAgICAgICAgIHJvb3RFbGVtZW50cy5zZXQocm9vdCwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG9sZE9uU2NoZWR1bGVGaWJlclJvb3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgaG9vay5vbkNvbW1pdEZpYmVyUm9vdCA9IGZ1bmN0aW9uIChpZCwgcm9vdCwgbWF5YmVQcmlvcml0eUxldmVsLCBkaWRFcnJvcikge1xyXG4gICAgICB2YXIgaGVscGVycyA9IGhlbHBlcnNCeVJlbmRlcmVySUQuZ2V0KGlkKTtcclxuXHJcbiAgICAgIGlmIChoZWxwZXJzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBoZWxwZXJzQnlSb290LnNldChyb290LCBoZWxwZXJzKTtcclxuICAgICAgICB2YXIgY3VycmVudCA9IHJvb3QuY3VycmVudDtcclxuICAgICAgICB2YXIgYWx0ZXJuYXRlID0gY3VycmVudC5hbHRlcm5hdGU7IC8vIFdlIG5lZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyByb290IGhhcyBqdXN0ICh1biltb3VudGVkLlxyXG4gICAgICAgIC8vIFRoaXMgbG9naWMgaXMgY29weS1wYXN0ZWQgZnJvbSBzaW1pbGFyIGxvZ2ljIGluIHRoZSBEZXZUb29scyBiYWNrZW5kLlxyXG4gICAgICAgIC8vIElmIHRoaXMgYnJlYWtzIHdpdGggc29tZSByZWZhY3RvcmluZywgeW91J2xsIHdhbnQgdG8gdXBkYXRlIERldlRvb2xzIHRvby5cclxuXHJcbiAgICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgdmFyIHdhc01vdW50ZWQgPSBhbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSAhPSBudWxsICYmIGFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmVsZW1lbnQgIT0gbnVsbCAmJiBtb3VudGVkUm9vdHMuaGFzKHJvb3QpO1xyXG4gICAgICAgICAgdmFyIGlzTW91bnRlZCA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5lbGVtZW50ICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgaWYgKCF3YXNNb3VudGVkICYmIGlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAvLyBNb3VudCBhIG5ldyByb290LlxyXG4gICAgICAgICAgICBtb3VudGVkUm9vdHMuYWRkKHJvb3QpO1xyXG4gICAgICAgICAgICBmYWlsZWRSb290cy5kZWxldGUocm9vdCk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHdhc01vdW50ZWQgJiYgaXNNb3VudGVkKSA7IGVsc2UgaWYgKHdhc01vdW50ZWQgJiYgIWlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAvLyBVbm1vdW50IGFuIGV4aXN0aW5nIHJvb3QuXHJcbiAgICAgICAgICAgIG1vdW50ZWRSb290cy5kZWxldGUocm9vdCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGlkRXJyb3IpIHtcclxuICAgICAgICAgICAgICAvLyBXZSdsbCByZW1vdW50IGl0IG9uIGZ1dHVyZSBlZGl0cy5cclxuICAgICAgICAgICAgICBmYWlsZWRSb290cy5hZGQocm9vdCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaGVscGVyc0J5Um9vdC5kZWxldGUocm9vdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAoIXdhc01vdW50ZWQgJiYgIWlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICBpZiAoZGlkRXJyb3IpIHtcclxuICAgICAgICAgICAgICAvLyBXZSdsbCByZW1vdW50IGl0IG9uIGZ1dHVyZSBlZGl0cy5cclxuICAgICAgICAgICAgICBmYWlsZWRSb290cy5hZGQocm9vdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gTW91bnQgYSBuZXcgcm9vdC5cclxuICAgICAgICAgIG1vdW50ZWRSb290cy5hZGQocm9vdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IC8vIEFsd2F5cyBjYWxsIHRoZSBkZWNvcmF0ZWQgRGV2VG9vbHMgaG9vay5cclxuXHJcblxyXG4gICAgICByZXR1cm4gb2xkT25Db21taXRGaWJlclJvb3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhc1VucmVjb3ZlcmFibGVFcnJvcnMoKSB7XHJcbiAgLy8gVE9ETzogZGVsZXRlIHRoaXMgYWZ0ZXIgcmVtb3ZpbmcgZGVwZW5kZW5jeSBpbiBSTi5cclxuICByZXR1cm4gZmFsc2U7XHJcbn0gLy8gRXhwb3NlZCBmb3IgdGVzdGluZy5cclxuXHJcbmZ1bmN0aW9uIF9nZXRNb3VudGVkUm9vdENvdW50KCkge1xyXG4gIHtcclxuICAgIHJldHVybiBtb3VudGVkUm9vdHMuc2l6ZTtcclxuICB9XHJcbn0gLy8gVGhpcyBpcyBhIHdyYXBwZXIgb3ZlciBtb3JlIHByaW1pdGl2ZSBmdW5jdGlvbnMgZm9yIHNldHRpbmcgc2lnbmF0dXJlLlxyXG4vLyBTaWduYXR1cmVzIGxldCB1cyBkZWNpZGUgd2hldGhlciB0aGUgSG9vayBvcmRlciBoYXMgY2hhbmdlZCBvbiByZWZyZXNoLlxyXG4vL1xyXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgYSB0cmFuc2Zvcm0gdGFyZ2V0LCBlLmcuOlxyXG4vLyB2YXIgX3MgPSBjcmVhdGVTaWduYXR1cmVGdW5jdGlvbkZvclRyYW5zZm9ybSgpXHJcbi8vXHJcbi8vIGZ1bmN0aW9uIEhlbGxvKCkge1xyXG4vLyAgIGNvbnN0IFtmb28sIHNldEZvb10gPSB1c2VTdGF0ZSgwKTtcclxuLy8gICBjb25zdCB2YWx1ZSA9IHVzZUN1c3RvbUhvb2soKTtcclxuLy8gICBfcygpOyAvKiBDYWxsIHdpdGhvdXQgYXJndW1lbnRzIHRyaWdnZXJzIGNvbGxlY3RpbmcgdGhlIGN1c3RvbSBIb29rIGxpc3QuXHJcbi8vICAgICAgICAgICogVGhpcyBkb2Vzbid0IGhhcHBlbiBkdXJpbmcgdGhlIG1vZHVsZSBldmFsdWF0aW9uIGJlY2F1c2Ugd2VcclxuLy8gICAgICAgICAgKiBkb24ndCB3YW50IHRvIGNoYW5nZSB0aGUgbW9kdWxlIG9yZGVyIHdpdGggaW5saW5lIHJlcXVpcmVzLlxyXG4vLyAgICAgICAgICAqIE5leHQgY2FsbHMgYXJlIG5vb3BzLiAqL1xyXG4vLyAgIHJldHVybiA8aDE+SGk8L2gxPjtcclxuLy8gfVxyXG4vL1xyXG4vLyAvKiBDYWxsIHdpdGggYXJndW1lbnRzIGF0dGFjaGVzIHRoZSBzaWduYXR1cmUgdG8gdGhlIHR5cGU6ICovXHJcbi8vIF9zKFxyXG4vLyAgIEhlbGxvLFxyXG4vLyAgICd1c2VTdGF0ZXtbZm9vLCBzZXRGb29dfSgwKScsXHJcbi8vICAgKCkgPT4gW3VzZUN1c3RvbUhvb2tdLCAvKiBMYXp5IHRvIGF2b2lkIHRyaWdnZXJpbmcgaW5saW5lIHJlcXVpcmVzICovXHJcbi8vICk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTaWduYXR1cmVGdW5jdGlvbkZvclRyYW5zZm9ybSgpIHtcclxuICB7XHJcbiAgICB2YXIgc2F2ZWRUeXBlO1xyXG4gICAgdmFyIGhhc0N1c3RvbUhvb2tzO1xyXG4gICAgdmFyIGRpZENvbGxlY3RIb29rcyA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0eXBlLCBrZXksIGZvcmNlUmVzZXQsIGdldEN1c3RvbUhvb2tzKSB7XHJcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vIFdlJ3JlIGluIHRoZSBpbml0aWFsIHBoYXNlIHRoYXQgYXNzb2NpYXRlcyBzaWduYXR1cmVzXHJcbiAgICAgICAgLy8gd2l0aCB0aGUgZnVuY3Rpb25zLiBOb3RlIHRoaXMgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xyXG4gICAgICAgIC8vIGluIEhPQyBjaGFpbnMgbGlrZSBfcyhob2MxKF9zKGhvYzIoX3MoYWN0dWFsRnVuY3Rpb24pKSkpKS5cclxuICAgICAgICBpZiAoIXNhdmVkVHlwZSkge1xyXG4gICAgICAgICAgLy8gV2UncmUgaW4gdGhlIGlubmVybW9zdCBjYWxsLCBzbyB0aGlzIGlzIHRoZSBhY3R1YWwgdHlwZS5cclxuICAgICAgICAgIHNhdmVkVHlwZSA9IHR5cGU7XHJcbiAgICAgICAgICBoYXNDdXN0b21Ib29rcyA9IHR5cGVvZiBnZXRDdXN0b21Ib29rcyA9PT0gJ2Z1bmN0aW9uJztcclxuICAgICAgICB9IC8vIFNldCB0aGUgc2lnbmF0dXJlIGZvciBhbGwgdHlwZXMgKGV2ZW4gd3JhcHBlcnMhKSBpbiBjYXNlXHJcbiAgICAgICAgLy8gdGhleSBoYXZlIG5vIHNpZ25hdHVyZXMgb2YgdGhlaXIgb3duLiBUaGlzIGlzIHRvIHByZXZlbnRcclxuICAgICAgICAvLyBwcm9ibGVtcyBsaWtlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjA0MTcuXHJcblxyXG5cclxuICAgICAgICBpZiAodHlwZSAhPSBudWxsICYmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpKSB7XHJcbiAgICAgICAgICBzZXRTaWduYXR1cmUodHlwZSwga2V5LCBmb3JjZVJlc2V0LCBnZXRDdXN0b21Ib29rcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHlwZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBXZSdyZSBpbiB0aGUgX3MoKSBjYWxsIHdpdGhvdXQgYXJndW1lbnRzLCB3aGljaCBtZWFuc1xyXG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIHRpbWUgdG8gY29sbGVjdCBjdXN0b20gSG9vayBzaWduYXR1cmVzLlxyXG4gICAgICAgIC8vIE9ubHkgZG8gdGhpcyBvbmNlLiBUaGlzIHBhdGggaXMgaG90IGFuZCBydW5zICppbnNpZGUqIGV2ZXJ5IHJlbmRlciFcclxuICAgICAgICBpZiAoIWRpZENvbGxlY3RIb29rcyAmJiBoYXNDdXN0b21Ib29rcykge1xyXG4gICAgICAgICAgZGlkQ29sbGVjdEhvb2tzID0gdHJ1ZTtcclxuICAgICAgICAgIGNvbGxlY3RDdXN0b21Ib29rc0ZvclNpZ25hdHVyZShzYXZlZFR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gaXNMaWtlbHlDb21wb25lbnRUeXBlKHR5cGUpIHtcclxuICB7XHJcbiAgICBzd2l0Y2ggKHR5cGVvZiB0eXBlKSB7XHJcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuICAgICAgICB7XHJcbiAgICAgICAgICAvLyBGaXJzdCwgZGVhbCB3aXRoIGNsYXNzZXMuXHJcbiAgICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgIC8vIFJlYWN0IGNsYXNzLlxyXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb3duTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0eXBlLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAob3duTmFtZXMubGVuZ3RoID4gMSB8fCBvd25OYW1lc1swXSAhPT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICAgICAgICAgIC8vIFRoaXMgbG9va3MgbGlrZSBhIGNsYXNzLlxyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG9cclxuXHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUuX19wcm90b19fICE9PSBPYmplY3QucHJvdG90eXBlKSB7XHJcbiAgICAgICAgICAgICAgLy8gSXQgaGFzIGEgc3VwZXJjbGFzcy5cclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gLy8gUGFzcyB0aHJvdWdoLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGxvb2tzIGxpa2UgYSByZWd1bGFyIGZ1bmN0aW9uIHdpdGggZW1wdHkgcHJvdG90eXBlLlxyXG5cclxuICAgICAgICAgIH0gLy8gRm9yIHBsYWluIGZ1bmN0aW9ucyBhbmQgYXJyb3dzLCB1c2UgbmFtZSBhcyBhIGhldXJpc3RpYy5cclxuXHJcblxyXG4gICAgICAgICAgdmFyIG5hbWUgPSB0eXBlLm5hbWUgfHwgdHlwZS5kaXNwbGF5TmFtZTtcclxuICAgICAgICAgIHJldHVybiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgL15bQS1aXS8udGVzdChuYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGlmICh0eXBlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChnZXRQcm9wZXJ0eSh0eXBlLCAnJCR0eXBlb2YnKSkge1xyXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcclxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcclxuICAgICAgICAgICAgICAgIC8vIERlZmluaXRlbHkgUmVhY3QgY29tcG9uZW50cy5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuX2dldE1vdW50ZWRSb290Q291bnQgPSBfZ2V0TW91bnRlZFJvb3RDb3VudDtcclxuZXhwb3J0cy5jb2xsZWN0Q3VzdG9tSG9va3NGb3JTaWduYXR1cmUgPSBjb2xsZWN0Q3VzdG9tSG9va3NGb3JTaWduYXR1cmU7XHJcbmV4cG9ydHMuY3JlYXRlU2lnbmF0dXJlRnVuY3Rpb25Gb3JUcmFuc2Zvcm0gPSBjcmVhdGVTaWduYXR1cmVGdW5jdGlvbkZvclRyYW5zZm9ybTtcclxuZXhwb3J0cy5maW5kQWZmZWN0ZWRIb3N0SW5zdGFuY2VzID0gZmluZEFmZmVjdGVkSG9zdEluc3RhbmNlcztcclxuZXhwb3J0cy5nZXRGYW1pbHlCeUlEID0gZ2V0RmFtaWx5QnlJRDtcclxuZXhwb3J0cy5nZXRGYW1pbHlCeVR5cGUgPSBnZXRGYW1pbHlCeVR5cGU7XHJcbmV4cG9ydHMuaGFzVW5yZWNvdmVyYWJsZUVycm9ycyA9IGhhc1VucmVjb3ZlcmFibGVFcnJvcnM7XHJcbmV4cG9ydHMuaW5qZWN0SW50b0dsb2JhbEhvb2sgPSBpbmplY3RJbnRvR2xvYmFsSG9vaztcclxuZXhwb3J0cy5pc0xpa2VseUNvbXBvbmVudFR5cGUgPSBpc0xpa2VseUNvbXBvbmVudFR5cGU7XHJcbmV4cG9ydHMucGVyZm9ybVJlYWN0UmVmcmVzaCA9IHBlcmZvcm1SZWFjdFJlZnJlc2g7XHJcbmV4cG9ydHMucmVnaXN0ZXIgPSByZWdpc3RlcjtcclxuZXhwb3J0cy5zZXRTaWduYXR1cmUgPSBzZXRTaWduYXR1cmU7XHJcbiAgfSkoKTtcclxufVxyXG4iXSwibmFtZXMiOlsicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlN5bWJvbCIsImZvciIsIlJFQUNUX01FTU9fVFlQRSIsIlBvc3NpYmx5V2Vha01hcCIsIldlYWtNYXAiLCJNYXAiLCJhbGxGYW1pbGllc0J5SUQiLCJhbGxGYW1pbGllc0J5VHlwZSIsImFsbFNpZ25hdHVyZXNCeVR5cGUiLCJ1cGRhdGVkRmFtaWxpZXNCeVR5cGUiLCJwZW5kaW5nVXBkYXRlcyIsImhlbHBlcnNCeVJlbmRlcmVySUQiLCJoZWxwZXJzQnlSb290IiwibW91bnRlZFJvb3RzIiwiU2V0IiwiZmFpbGVkUm9vdHMiLCJyb290RWxlbWVudHMiLCJpc1BlcmZvcm1pbmdSZWZyZXNoIiwiY29tcHV0ZUZ1bGxLZXkiLCJzaWduYXR1cmUiLCJmdWxsS2V5Iiwib3duS2V5IiwiaG9va3MiLCJnZXRDdXN0b21Ib29rcyIsImVyciIsImZvcmNlUmVzZXQiLCJpIiwibGVuZ3RoIiwiaG9vayIsIm5lc3RlZEhvb2tTaWduYXR1cmUiLCJnZXQiLCJ1bmRlZmluZWQiLCJuZXN0ZWRIb29rS2V5IiwiaGF2ZUVxdWFsU2lnbmF0dXJlcyIsInByZXZUeXBlIiwibmV4dFR5cGUiLCJwcmV2U2lnbmF0dXJlIiwibmV4dFNpZ25hdHVyZSIsImlzUmVhY3RDbGFzcyIsInR5cGUiLCJwcm90b3R5cGUiLCJpc1JlYWN0Q29tcG9uZW50IiwiY2FuUHJlc2VydmVTdGF0ZUJldHdlZW4iLCJyZXNvbHZlRmFtaWx5IiwiY2xvbmVNYXAiLCJtYXAiLCJjbG9uZSIsImZvckVhY2giLCJ2YWx1ZSIsImtleSIsInNldCIsImNsb25lU2V0IiwiYWRkIiwiZ2V0UHJvcGVydHkiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInBlcmZvcm1SZWFjdFJlZnJlc2giLCJzdGFsZUZhbWlsaWVzIiwidXBkYXRlZEZhbWlsaWVzIiwidXBkYXRlcyIsIl9yZWYiLCJmYW1pbHkiLCJjdXJyZW50IiwidXBkYXRlIiwiaGVscGVycyIsInNldFJlZnJlc2hIYW5kbGVyIiwiZGlkRXJyb3IiLCJmaXJzdEVycm9yIiwiZmFpbGVkUm9vdHNTbmFwc2hvdCIsIm1vdW50ZWRSb290c1NuYXBzaG90IiwiaGVscGVyc0J5Um9vdFNuYXBzaG90Iiwicm9vdCIsIkVycm9yIiwiaGFzIiwiZWxlbWVudCIsInNjaGVkdWxlUm9vdCIsInNjaGVkdWxlUmVmcmVzaCIsInJlZ2lzdGVyIiwiaWQiLCJwdXNoIiwicmVuZGVyIiwic2V0U2lnbmF0dXJlIiwiYXJndW1lbnRzIiwiY29sbGVjdEN1c3RvbUhvb2tzRm9yU2lnbmF0dXJlIiwiZ2V0RmFtaWx5QnlJRCIsImdldEZhbWlseUJ5VHlwZSIsImZpbmRBZmZlY3RlZEhvc3RJbnN0YW5jZXMiLCJmYW1pbGllcyIsImFmZmVjdGVkSW5zdGFuY2VzIiwiaW5zdGFuY2VzRm9yUm9vdCIsImZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaCIsImluc3QiLCJpbmplY3RJbnRvR2xvYmFsSG9vayIsImdsb2JhbE9iamVjdCIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsIm5leHRJRCIsInJlbmRlcmVycyIsInN1cHBvcnRzRmliZXIiLCJpbmplY3QiLCJpbmplY3RlZCIsIm9uU2NoZWR1bGVGaWJlclJvb3QiLCJjaGlsZHJlbiIsIm9uQ29tbWl0RmliZXJSb290IiwibWF5YmVQcmlvcml0eUxldmVsIiwib25Db21taXRGaWJlclVubW91bnQiLCJpc0Rpc2FibGVkIiwiY29uc29sZSIsIm9sZEluamVjdCIsImFwcGx5Iiwib2xkT25Db21taXRGaWJlclJvb3QiLCJvbGRPblNjaGVkdWxlRmliZXJSb290IiwiZGVsZXRlIiwiYWx0ZXJuYXRlIiwid2FzTW91bnRlZCIsIm1lbW9pemVkU3RhdGUiLCJpc01vdW50ZWQiLCJoYXNVbnJlY292ZXJhYmxlRXJyb3JzIiwiX2dldE1vdW50ZWRSb290Q291bnQiLCJzaXplIiwiY3JlYXRlU2lnbmF0dXJlRnVuY3Rpb25Gb3JUcmFuc2Zvcm0iLCJzYXZlZFR5cGUiLCJoYXNDdXN0b21Ib29rcyIsImRpZENvbGxlY3RIb29rcyIsImlzTGlrZWx5Q29tcG9uZW50VHlwZSIsIm93bk5hbWVzIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9fcHJvdG9fXyIsIm5hbWUiLCJkaXNwbGF5TmFtZSIsInRlc3QiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/react-refresh/runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-refresh/runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-refresh-runtime.development.js */ \"./node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXJlZnJlc2gvcnVudGltZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJQSxLQUFKLEVBQTJDLEVBQTNDLE1BRU87RUFDTEcsa0xBQUE7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXJlZnJlc2gvcnVudGltZS5qcz85YzZlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWZyZXNoLXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcclxufSBlbHNlIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlZnJlc2gtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/react-refresh/runtime.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ var __webpack_exports__ = (__webpack_exec__("./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js"));
/******/ _N_E = __webpack_exports__;
/******/ }
]);