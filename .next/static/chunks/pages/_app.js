/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLGlCQUFULENBQTJCQyxHQUEzQixFQUFnQ0MsR0FBaEMsRUFBcUM7RUFDbkMsSUFBSUEsR0FBRyxJQUFJLElBQVAsSUFBZUEsR0FBRyxHQUFHRCxHQUFHLENBQUNFLE1BQTdCLEVBQXFDRCxHQUFHLEdBQUdELEdBQUcsQ0FBQ0UsTUFBVjs7RUFFckMsS0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBUixFQUFXQyxJQUFJLEdBQUcsSUFBSUMsS0FBSixDQUFVSixHQUFWLENBQXZCLEVBQXVDRSxDQUFDLEdBQUdGLEdBQTNDLEVBQWdERSxDQUFDLEVBQWpELEVBQXFEO0lBQ25EQyxJQUFJLENBQUNELENBQUQsQ0FBSixHQUFVSCxHQUFHLENBQUNHLENBQUQsQ0FBYjtFQUNEOztFQUVELE9BQU9DLElBQVA7QUFDRDs7QUFFREUsTUFBTSxDQUFDQyxPQUFQLEdBQWlCUixpQkFBakIsRUFBb0NPLHlCQUFBLEdBQTRCLElBQWhFLEVBQXNFQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF6RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzP2NmMDkiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcclxuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFycjI7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2FycmF5TGlrZVRvQXJyYXkiLCJhcnIiLCJsZW4iLCJsZW5ndGgiLCJpIiwiYXJyMiIsIkFycmF5IiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/arrayLikeToArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxHQUF6QixFQUE4QjtFQUM1QixJQUFJQyxLQUFLLENBQUNDLE9BQU4sQ0FBY0YsR0FBZCxDQUFKLEVBQXdCLE9BQU9BLEdBQVA7QUFDekI7O0FBRURHLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsZUFBakIsRUFBa0NJLHlCQUFBLEdBQTRCLElBQTlELEVBQW9FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF2RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcz9hNTI1Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfYXJyYXlXaXRoSG9sZXMiLCJhcnIiLCJBcnJheSIsImlzQXJyYXkiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/arrayWithHoles.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0Esc0JBQVQsQ0FBZ0NDLElBQWhDLEVBQXNDO0VBQ3BDLElBQUlBLElBQUksS0FBSyxLQUFLLENBQWxCLEVBQXFCO0lBQ25CLE1BQU0sSUFBSUMsY0FBSixDQUFtQiwyREFBbkIsQ0FBTjtFQUNEOztFQUVELE9BQU9ELElBQVA7QUFDRDs7QUFFREUsTUFBTSxDQUFDQyxPQUFQLEdBQWlCSixzQkFBakIsRUFBeUNHLHlCQUFBLEdBQTRCLElBQXJFLEVBQTJFQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUE5RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/MjAxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcclxuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XHJcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc2VsZjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/assertThisInitialized.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLGtCQUFULENBQTRCQyxHQUE1QixFQUFpQ0MsT0FBakMsRUFBMENDLE1BQTFDLEVBQWtEQyxLQUFsRCxFQUF5REMsTUFBekQsRUFBaUVDLEdBQWpFLEVBQXNFQyxHQUF0RSxFQUEyRTtFQUN6RSxJQUFJO0lBQ0YsSUFBSUMsSUFBSSxHQUFHUCxHQUFHLENBQUNLLEdBQUQsQ0FBSCxDQUFTQyxHQUFULENBQVg7SUFDQSxJQUFJRSxLQUFLLEdBQUdELElBQUksQ0FBQ0MsS0FBakI7RUFDRCxDQUhELENBR0UsT0FBT0MsS0FBUCxFQUFjO0lBQ2RQLE1BQU0sQ0FBQ08sS0FBRCxDQUFOO0lBQ0E7RUFDRDs7RUFFRCxJQUFJRixJQUFJLENBQUNHLElBQVQsRUFBZTtJQUNiVCxPQUFPLENBQUNPLEtBQUQsQ0FBUDtFQUNELENBRkQsTUFFTztJQUNMRyxPQUFPLENBQUNWLE9BQVIsQ0FBZ0JPLEtBQWhCLEVBQXVCSSxJQUF2QixDQUE0QlQsS0FBNUIsRUFBbUNDLE1BQW5DO0VBQ0Q7QUFDRjs7QUFFRCxTQUFTUyxpQkFBVCxDQUEyQkMsRUFBM0IsRUFBK0I7RUFDN0IsT0FBTyxZQUFZO0lBQ2pCLElBQUlDLElBQUksR0FBRyxJQUFYO0lBQUEsSUFDSUMsSUFBSSxHQUFHQyxTQURYO0lBRUEsT0FBTyxJQUFJTixPQUFKLENBQVksVUFBVVYsT0FBVixFQUFtQkMsTUFBbkIsRUFBMkI7TUFDNUMsSUFBSUYsR0FBRyxHQUFHYyxFQUFFLENBQUNJLEtBQUgsQ0FBU0gsSUFBVCxFQUFlQyxJQUFmLENBQVY7O01BRUEsU0FBU2IsS0FBVCxDQUFlSyxLQUFmLEVBQXNCO1FBQ3BCVCxrQkFBa0IsQ0FBQ0MsR0FBRCxFQUFNQyxPQUFOLEVBQWVDLE1BQWYsRUFBdUJDLEtBQXZCLEVBQThCQyxNQUE5QixFQUFzQyxNQUF0QyxFQUE4Q0ksS0FBOUMsQ0FBbEI7TUFDRDs7TUFFRCxTQUFTSixNQUFULENBQWdCZSxHQUFoQixFQUFxQjtRQUNuQnBCLGtCQUFrQixDQUFDQyxHQUFELEVBQU1DLE9BQU4sRUFBZUMsTUFBZixFQUF1QkMsS0FBdkIsRUFBOEJDLE1BQTlCLEVBQXNDLE9BQXRDLEVBQStDZSxHQUEvQyxDQUFsQjtNQUNEOztNQUVEaEIsS0FBSyxDQUFDaUIsU0FBRCxDQUFMO0lBQ0QsQ0FaTSxDQUFQO0VBYUQsQ0FoQkQ7QUFpQkQ7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQlQsaUJBQWpCLEVBQW9DUSx5QkFBQSxHQUE0QixJQUFoRSxFQUFzRUEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBekciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcz9kMzEyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcclxuICB0cnkge1xyXG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xyXG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmVqZWN0KGVycm9yKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlmIChpbmZvLmRvbmUpIHtcclxuICAgIHJlc29sdmUodmFsdWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XHJcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XHJcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XHJcbiAgICB9KTtcclxuICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbImFzeW5jR2VuZXJhdG9yU3RlcCIsImdlbiIsInJlc29sdmUiLCJyZWplY3QiLCJfbmV4dCIsIl90aHJvdyIsImtleSIsImFyZyIsImluZm8iLCJ2YWx1ZSIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJmbiIsInNlbGYiLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJlcnIiLCJ1bmRlZmluZWQiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/asyncToGenerator.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxRQUF6QixFQUFtQ0MsV0FBbkMsRUFBZ0Q7RUFDOUMsSUFBSSxFQUFFRCxRQUFRLFlBQVlDLFdBQXRCLENBQUosRUFBd0M7SUFDdEMsTUFBTSxJQUFJQyxTQUFKLENBQWMsbUNBQWQsQ0FBTjtFQUNEO0FBQ0Y7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsZUFBakIsRUFBa0NJLHlCQUFBLEdBQTRCLElBQTlELEVBQW9FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF2RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcz9iN2FlIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcclxuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/classCallCheck.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nvar isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct.js */ \"./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js\");\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsY0FBYyxHQUFHQyxtQkFBTyxDQUFDLG9GQUFELENBQTVCOztBQUVBLElBQUlDLHdCQUF3QixHQUFHRCxtQkFBTyxDQUFDLHdHQUFELENBQXRDOztBQUVBLFNBQVNFLFVBQVQsQ0FBb0JDLE1BQXBCLEVBQTRCQyxJQUE1QixFQUFrQ0MsS0FBbEMsRUFBeUM7RUFDdkMsSUFBSUosd0JBQXdCLEVBQTVCLEVBQWdDO0lBQzlCSyxNQUFNLENBQUNDLE9BQVAsR0FBaUJMLFVBQVUsR0FBR00sT0FBTyxDQUFDQyxTQUF0QyxFQUFpREgseUJBQUEsR0FBNEIsSUFBN0UsRUFBbUZBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQXRIO0VBQ0QsQ0FGRCxNQUVPO0lBQ0xELE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsVUFBVSxHQUFHLFNBQVNBLFVBQVQsQ0FBb0JDLE1BQXBCLEVBQTRCQyxJQUE1QixFQUFrQ0MsS0FBbEMsRUFBeUM7TUFDckUsSUFBSU0sQ0FBQyxHQUFHLENBQUMsSUFBRCxDQUFSO01BQ0FBLENBQUMsQ0FBQ0MsSUFBRixDQUFPQyxLQUFQLENBQWFGLENBQWIsRUFBZ0JQLElBQWhCO01BQ0EsSUFBSVUsV0FBVyxHQUFHQyxRQUFRLENBQUNDLElBQVQsQ0FBY0gsS0FBZCxDQUFvQlYsTUFBcEIsRUFBNEJRLENBQTVCLENBQWxCO01BQ0EsSUFBSU0sUUFBUSxHQUFHLElBQUlILFdBQUosRUFBZjtNQUNBLElBQUlULEtBQUosRUFBV04sY0FBYyxDQUFDa0IsUUFBRCxFQUFXWixLQUFLLENBQUNhLFNBQWpCLENBQWQ7TUFDWCxPQUFPRCxRQUFQO0lBQ0QsQ0FQRCxFQU9HWCx5QkFBQSxHQUE0QixJQVAvQixFQU9xQ0EseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FQeEU7RUFRRDs7RUFFRCxPQUFPTCxVQUFVLENBQUNXLEtBQVgsQ0FBaUIsSUFBakIsRUFBdUJNLFNBQXZCLENBQVA7QUFDRDs7QUFFRGIsTUFBTSxDQUFDQyxPQUFQLEdBQWlCTCxVQUFqQixFQUE2QkkseUJBQUEsR0FBNEIsSUFBekQsRUFBK0RBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQWxHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcz8yOTFlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xyXG5cclxudmFyIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHJlcXVpcmUoXCIuL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qc1wiKTtcclxuXHJcbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xyXG4gIGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3QsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcclxuICB9IGVsc2Uge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XHJcbiAgICAgIHZhciBhID0gW251bGxdO1xyXG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XHJcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcclxuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XHJcbiAgICAgIGlmIChDbGFzcykgc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XHJcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcclxuICB9XHJcblxyXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJzZXRQcm90b3R5cGVPZiIsInJlcXVpcmUiLCJpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY29uc3RydWN0IiwiUGFyZW50IiwiYXJncyIsIkNsYXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJfX2VzTW9kdWxlIiwiYSIsInB1c2giLCJhcHBseSIsIkNvbnN0cnVjdG9yIiwiRnVuY3Rpb24iLCJiaW5kIiwiaW5zdGFuY2UiLCJwcm90b3R5cGUiLCJhcmd1bWVudHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/construct.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxpQkFBVCxDQUEyQkMsTUFBM0IsRUFBbUNDLEtBQW5DLEVBQTBDO0VBQ3hDLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsS0FBSyxDQUFDRSxNQUExQixFQUFrQ0QsQ0FBQyxFQUFuQyxFQUF1QztJQUNyQyxJQUFJRSxVQUFVLEdBQUdILEtBQUssQ0FBQ0MsQ0FBRCxDQUF0QjtJQUNBRSxVQUFVLENBQUNDLFVBQVgsR0FBd0JELFVBQVUsQ0FBQ0MsVUFBWCxJQUF5QixLQUFqRDtJQUNBRCxVQUFVLENBQUNFLFlBQVgsR0FBMEIsSUFBMUI7SUFDQSxJQUFJLFdBQVdGLFVBQWYsRUFBMkJBLFVBQVUsQ0FBQ0csUUFBWCxHQUFzQixJQUF0QjtJQUMzQkMsTUFBTSxDQUFDQyxjQUFQLENBQXNCVCxNQUF0QixFQUE4QkksVUFBVSxDQUFDTSxHQUF6QyxFQUE4Q04sVUFBOUM7RUFDRDtBQUNGOztBQUVELFNBQVNPLFlBQVQsQ0FBc0JDLFdBQXRCLEVBQW1DQyxVQUFuQyxFQUErQ0MsV0FBL0MsRUFBNEQ7RUFDMUQsSUFBSUQsVUFBSixFQUFnQmQsaUJBQWlCLENBQUNhLFdBQVcsQ0FBQ0csU0FBYixFQUF3QkYsVUFBeEIsQ0FBakI7RUFDaEIsSUFBSUMsV0FBSixFQUFpQmYsaUJBQWlCLENBQUNhLFdBQUQsRUFBY0UsV0FBZCxDQUFqQjtFQUNqQk4sTUFBTSxDQUFDQyxjQUFQLENBQXNCRyxXQUF0QixFQUFtQyxXQUFuQyxFQUFnRDtJQUM5Q0wsUUFBUSxFQUFFO0VBRG9DLENBQWhEO0VBR0EsT0FBT0ssV0FBUDtBQUNEOztBQUVESSxNQUFNLENBQUNDLE9BQVAsR0FBaUJOLFlBQWpCLEVBQStCSyx5QkFBQSxHQUE0QixJQUEzRCxFQUFpRUEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBcEciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanM/NTQ2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcclxuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcclxuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcclxuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XHJcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XHJcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xyXG4gICAgd3JpdGFibGU6IGZhbHNlXHJcbiAgfSk7XHJcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsIl9jcmVhdGVDbGFzcyIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicHJvdG90eXBlIiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/createClass.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxHQUF6QixFQUE4QkMsR0FBOUIsRUFBbUNDLEtBQW5DLEVBQTBDO0VBQ3hDLElBQUlELEdBQUcsSUFBSUQsR0FBWCxFQUFnQjtJQUNkRyxNQUFNLENBQUNDLGNBQVAsQ0FBc0JKLEdBQXRCLEVBQTJCQyxHQUEzQixFQUFnQztNQUM5QkMsS0FBSyxFQUFFQSxLQUR1QjtNQUU5QkcsVUFBVSxFQUFFLElBRmtCO01BRzlCQyxZQUFZLEVBQUUsSUFIZ0I7TUFJOUJDLFFBQVEsRUFBRTtJQUpvQixDQUFoQztFQU1ELENBUEQsTUFPTztJQUNMUCxHQUFHLENBQUNDLEdBQUQsQ0FBSCxHQUFXQyxLQUFYO0VBQ0Q7O0VBRUQsT0FBT0YsR0FBUDtBQUNEOztBQUVEUSxNQUFNLENBQUNDLE9BQVAsR0FBaUJWLGVBQWpCLEVBQWtDUyx5QkFBQSxHQUE0QixJQUE5RCxFQUFvRUEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBdkciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanM/ZDk0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XHJcbiAgaWYgKGtleSBpbiBvYmopIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xyXG4gICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/defineProperty.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxDQUF6QixFQUE0QjtFQUMxQkMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCSCxlQUFlLEdBQUdJLE1BQU0sQ0FBQ0MsY0FBUCxHQUF3QkQsTUFBTSxDQUFDRSxjQUEvQixHQUFnRCxTQUFTTixlQUFULENBQXlCQyxDQUF6QixFQUE0QjtJQUM3RyxPQUFPQSxDQUFDLENBQUNNLFNBQUYsSUFBZUgsTUFBTSxDQUFDRSxjQUFQLENBQXNCTCxDQUF0QixDQUF0QjtFQUNELENBRkQsRUFFR0MseUJBQUEsR0FBNEIsSUFGL0IsRUFFcUNBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BRnhFO0VBR0EsT0FBT0gsZUFBZSxDQUFDQyxDQUFELENBQXRCO0FBQ0Q7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkgsZUFBakIsRUFBa0NFLHlCQUFBLEdBQTRCLElBQTlELEVBQW9FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF2RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcz85MDAzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xyXG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcclxuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XHJcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2dldFByb3RvdHlwZU9mIiwibyIsIm1vZHVsZSIsImV4cG9ydHMiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/getPrototypeOf.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxjQUFjLEdBQUdDLG1CQUFPLENBQUMsb0ZBQUQsQ0FBNUI7O0FBRUEsU0FBU0MsU0FBVCxDQUFtQkMsUUFBbkIsRUFBNkJDLFVBQTdCLEVBQXlDO0VBQ3ZDLElBQUksT0FBT0EsVUFBUCxLQUFzQixVQUF0QixJQUFvQ0EsVUFBVSxLQUFLLElBQXZELEVBQTZEO0lBQzNELE1BQU0sSUFBSUMsU0FBSixDQUFjLG9EQUFkLENBQU47RUFDRDs7RUFFREYsUUFBUSxDQUFDRyxTQUFULEdBQXFCQyxNQUFNLENBQUNDLE1BQVAsQ0FBY0osVUFBVSxJQUFJQSxVQUFVLENBQUNFLFNBQXZDLEVBQWtEO0lBQ3JFRyxXQUFXLEVBQUU7TUFDWEMsS0FBSyxFQUFFUCxRQURJO01BRVhRLFFBQVEsRUFBRSxJQUZDO01BR1hDLFlBQVksRUFBRTtJQUhIO0VBRHdELENBQWxELENBQXJCO0VBT0FMLE1BQU0sQ0FBQ00sY0FBUCxDQUFzQlYsUUFBdEIsRUFBZ0MsV0FBaEMsRUFBNkM7SUFDM0NRLFFBQVEsRUFBRTtFQURpQyxDQUE3QztFQUdBLElBQUlQLFVBQUosRUFBZ0JKLGNBQWMsQ0FBQ0csUUFBRCxFQUFXQyxVQUFYLENBQWQ7QUFDakI7O0FBRURVLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQmIsU0FBakIsRUFBNEJZLHlCQUFBLEdBQTRCLElBQXhELEVBQThEQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUFqRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcz9mMzViIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xyXG5cclxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XHJcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xyXG4gIH1cclxuXHJcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XHJcbiAgICBjb25zdHJ1Y3Rvcjoge1xyXG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXHJcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH1cclxuICB9KTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcclxuICAgIHdyaXRhYmxlOiBmYWxzZVxyXG4gIH0pO1xyXG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbInNldFByb3RvdHlwZU9mIiwicmVxdWlyZSIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsIlR5cGVFcnJvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwidmFsdWUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImRlZmluZVByb3BlcnR5IiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/inherits.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0Esc0JBQVQsQ0FBZ0NDLEdBQWhDLEVBQXFDO0VBQ25DLE9BQU9BLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFYLEdBQXdCRCxHQUF4QixHQUE4QjtJQUNuQyxXQUFXQTtFQUR3QixDQUFyQztBQUdEOztBQUVERSxNQUFNLENBQUNDLE9BQVAsR0FBaUJKLHNCQUFqQixFQUF5Q0cseUJBQUEsR0FBNEIsSUFBckUsRUFBMkVBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQTlHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcz9lZThjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XHJcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcclxuICAgIFwiZGVmYXVsdFwiOiBvYmpcclxuICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/interopRequireDefault.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeFunction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeFunction.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nmodule.exports = _isNativeFunction, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZUZ1bmN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLGlCQUFULENBQTJCQyxFQUEzQixFQUErQjtFQUM3QixPQUFPQyxRQUFRLENBQUNDLFFBQVQsQ0FBa0JDLElBQWxCLENBQXVCSCxFQUF2QixFQUEyQkksT0FBM0IsQ0FBbUMsZUFBbkMsTUFBd0QsQ0FBQyxDQUFoRTtBQUNEOztBQUVEQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJQLGlCQUFqQixFQUFvQ00seUJBQUEsR0FBNEIsSUFBaEUsRUFBc0VBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQXpHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlRnVuY3Rpb24uanM/OGM4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xyXG4gIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlRnVuY3Rpb24sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2lzTmF0aXZlRnVuY3Rpb24iLCJmbiIsIkZ1bmN0aW9uIiwidG9TdHJpbmciLCJjYWxsIiwiaW5kZXhPZiIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/isNativeFunction.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nmodule.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EseUJBQVQsR0FBcUM7RUFDbkMsSUFBSSxPQUFPQyxPQUFQLEtBQW1CLFdBQW5CLElBQWtDLENBQUNBLE9BQU8sQ0FBQ0MsU0FBL0MsRUFBMEQsT0FBTyxLQUFQO0VBQzFELElBQUlELE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkMsSUFBdEIsRUFBNEIsT0FBTyxLQUFQO0VBQzVCLElBQUksT0FBT0MsS0FBUCxLQUFpQixVQUFyQixFQUFpQyxPQUFPLElBQVA7O0VBRWpDLElBQUk7SUFDRkMsT0FBTyxDQUFDQyxTQUFSLENBQWtCQyxPQUFsQixDQUEwQkMsSUFBMUIsQ0FBK0JQLE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkcsT0FBbEIsRUFBMkIsRUFBM0IsRUFBK0IsWUFBWSxDQUFFLENBQTdDLENBQS9CO0lBQ0EsT0FBTyxJQUFQO0VBQ0QsQ0FIRCxDQUdFLE9BQU9JLENBQVAsRUFBVTtJQUNWLE9BQU8sS0FBUDtFQUNEO0FBQ0Y7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQlgseUJBQWpCLEVBQTRDVSx5QkFBQSxHQUE0QixJQUF4RSxFQUE4RUEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBakgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzPzFkNTQiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcclxuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XHJcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcclxuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xyXG5cclxuICB0cnkge1xyXG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInByb3RvdHlwZSIsInZhbHVlT2YiLCJjYWxsIiwiZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxxQkFBVCxDQUErQkMsR0FBL0IsRUFBb0NDLENBQXBDLEVBQXVDO0VBQ3JDLElBQUlDLEVBQUUsR0FBR0YsR0FBRyxJQUFJLElBQVAsR0FBYyxJQUFkLEdBQXFCLE9BQU9HLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNILEdBQUcsQ0FBQ0csTUFBTSxDQUFDQyxRQUFSLENBQXBDLElBQXlESixHQUFHLENBQUMsWUFBRCxDQUExRjs7RUFFQSxJQUFJRSxFQUFFLElBQUksSUFBVixFQUFnQjtFQUNoQixJQUFJRyxJQUFJLEdBQUcsRUFBWDtFQUNBLElBQUlDLEVBQUUsR0FBRyxJQUFUO0VBQ0EsSUFBSUMsRUFBRSxHQUFHLEtBQVQ7O0VBRUEsSUFBSUMsRUFBSixFQUFRQyxFQUFSOztFQUVBLElBQUk7SUFDRixLQUFLUCxFQUFFLEdBQUdBLEVBQUUsQ0FBQ1EsSUFBSCxDQUFRVixHQUFSLENBQVYsRUFBd0IsRUFBRU0sRUFBRSxHQUFHLENBQUNFLEVBQUUsR0FBR04sRUFBRSxDQUFDUyxJQUFILEVBQU4sRUFBaUJDLElBQXhCLENBQXhCLEVBQXVETixFQUFFLEdBQUcsSUFBNUQsRUFBa0U7TUFDaEVELElBQUksQ0FBQ1EsSUFBTCxDQUFVTCxFQUFFLENBQUNNLEtBQWI7O01BRUEsSUFBSWIsQ0FBQyxJQUFJSSxJQUFJLENBQUNVLE1BQUwsS0FBZ0JkLENBQXpCLEVBQTRCO0lBQzdCO0VBQ0YsQ0FORCxDQU1FLE9BQU9lLEdBQVAsRUFBWTtJQUNaVCxFQUFFLEdBQUcsSUFBTDtJQUNBRSxFQUFFLEdBQUdPLEdBQUw7RUFDRCxDQVRELFNBU1U7SUFDUixJQUFJO01BQ0YsSUFBSSxDQUFDVixFQUFELElBQU9KLEVBQUUsQ0FBQyxRQUFELENBQUYsSUFBZ0IsSUFBM0IsRUFBaUNBLEVBQUUsQ0FBQyxRQUFELENBQUY7SUFDbEMsQ0FGRCxTQUVVO01BQ1IsSUFBSUssRUFBSixFQUFRLE1BQU1FLEVBQU47SUFDVDtFQUNGOztFQUVELE9BQU9KLElBQVA7QUFDRDs7QUFFRFksTUFBTSxDQUFDQyxPQUFQLEdBQWlCbkIscUJBQWpCLEVBQXdDa0IseUJBQUEsR0FBNEIsSUFBcEUsRUFBMEVBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQTdHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzP2FmZTciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xyXG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcclxuXHJcbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcclxuICB2YXIgX2FyciA9IFtdO1xyXG4gIHZhciBfbiA9IHRydWU7XHJcbiAgdmFyIF9kID0gZmFsc2U7XHJcblxyXG4gIHZhciBfcywgX2U7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XHJcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XHJcblxyXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBfZCA9IHRydWU7XHJcbiAgICBfZSA9IGVycjtcclxuICB9IGZpbmFsbHkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBfYXJyO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJhcnIiLCJpIiwiX2kiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9hcnIiLCJfbiIsIl9kIiwiX3MiLCJfZSIsImNhbGwiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImxlbmd0aCIsImVyciIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EsZ0JBQVQsR0FBNEI7RUFDMUIsTUFBTSxJQUFJQyxTQUFKLENBQWMsMklBQWQsQ0FBTjtBQUNEOztBQUVEQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJILGdCQUFqQixFQUFtQ0UseUJBQUEsR0FBNEIsSUFBL0QsRUFBcUVBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQXhHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcz80YzIwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XHJcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/nonIterableRest.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\n\nvar assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized.js */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLE9BQU8sR0FBR0Msc0dBQWQ7O0FBRUEsSUFBSUMscUJBQXFCLEdBQUdELG1CQUFPLENBQUMsa0dBQUQsQ0FBbkM7O0FBRUEsU0FBU0UsMEJBQVQsQ0FBb0NDLElBQXBDLEVBQTBDQyxJQUExQyxFQUFnRDtFQUM5QyxJQUFJQSxJQUFJLEtBQUtMLE9BQU8sQ0FBQ0ssSUFBRCxDQUFQLEtBQWtCLFFBQWxCLElBQThCLE9BQU9BLElBQVAsS0FBZ0IsVUFBbkQsQ0FBUixFQUF3RTtJQUN0RSxPQUFPQSxJQUFQO0VBQ0QsQ0FGRCxNQUVPLElBQUlBLElBQUksS0FBSyxLQUFLLENBQWxCLEVBQXFCO0lBQzFCLE1BQU0sSUFBSUMsU0FBSixDQUFjLDBEQUFkLENBQU47RUFDRDs7RUFFRCxPQUFPSixxQkFBcUIsQ0FBQ0UsSUFBRCxDQUE1QjtBQUNEOztBQUVERyxNQUFNLENBQUNDLE9BQVAsR0FBaUJMLDBCQUFqQixFQUE2Q0kseUJBQUEsR0FBNEIsSUFBekUsRUFBK0VBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQWxIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanM/MGViOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XHJcblxyXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzXCIpO1xyXG5cclxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xyXG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XHJcbiAgICByZXR1cm4gY2FsbDtcclxuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwicmVxdWlyZSIsImFzc2VydFRoaXNJbml0aWFsaXplZCIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic2VsZiIsImNhbGwiLCJUeXBlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxDQUF6QixFQUE0QkMsQ0FBNUIsRUFBK0I7RUFDN0JDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkosZUFBZSxHQUFHSyxNQUFNLENBQUNDLGNBQVAsSUFBeUIsU0FBU04sZUFBVCxDQUF5QkMsQ0FBekIsRUFBNEJDLENBQTVCLEVBQStCO0lBQ3pGRCxDQUFDLENBQUNNLFNBQUYsR0FBY0wsQ0FBZDtJQUNBLE9BQU9ELENBQVA7RUFDRCxDQUhELEVBR0dFLHlCQUFBLEdBQTRCLElBSC9CLEVBR3FDQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUh4RTtFQUlBLE9BQU9KLGVBQWUsQ0FBQ0MsQ0FBRCxFQUFJQyxDQUFKLENBQXRCO0FBQ0Q7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkosZUFBakIsRUFBa0NHLHlCQUFBLEdBQTRCLElBQTlELEVBQW9FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF2RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcz8wNTI2Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcclxuICAgIG8uX19wcm90b19fID0gcDtcclxuICAgIHJldHVybiBvO1xyXG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcclxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfc2V0UHJvdG90eXBlT2YiLCJvIiwicCIsIm1vZHVsZSIsImV4cG9ydHMiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/setPrototypeOf.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles.js */ \"./node_modules/@babel/runtime/helpers/arrayWithHoles.js\");\n\nvar iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit.js */ \"./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\");\n\nvar unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ \"./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\");\n\nvar nonIterableRest = __webpack_require__(/*! ./nonIterableRest.js */ \"./node_modules/@babel/runtime/helpers/nonIterableRest.js\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLGNBQWMsR0FBR0MsbUJBQU8sQ0FBQyxvRkFBRCxDQUE1Qjs7QUFFQSxJQUFJQyxvQkFBb0IsR0FBR0QsbUJBQU8sQ0FBQyxnR0FBRCxDQUFsQzs7QUFFQSxJQUFJRSwwQkFBMEIsR0FBR0YsbUJBQU8sQ0FBQyw0R0FBRCxDQUF4Qzs7QUFFQSxJQUFJRyxlQUFlLEdBQUdILG1CQUFPLENBQUMsc0ZBQUQsQ0FBN0I7O0FBRUEsU0FBU0ksY0FBVCxDQUF3QkMsR0FBeEIsRUFBNkJDLENBQTdCLEVBQWdDO0VBQzlCLE9BQU9QLGNBQWMsQ0FBQ00sR0FBRCxDQUFkLElBQXVCSixvQkFBb0IsQ0FBQ0ksR0FBRCxFQUFNQyxDQUFOLENBQTNDLElBQXVESiwwQkFBMEIsQ0FBQ0csR0FBRCxFQUFNQyxDQUFOLENBQWpGLElBQTZGSCxlQUFlLEVBQW5IO0FBQ0Q7O0FBRURJLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkosY0FBakIsRUFBaUNHLHlCQUFBLEdBQTRCLElBQTdELEVBQW1FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF0RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzP2Y1MGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXMuanNcIik7XHJcblxyXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1wiKTtcclxuXHJcbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCIpO1xyXG5cclxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdC5qc1wiKTtcclxuXHJcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xyXG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJhcnJheVdpdGhIb2xlcyIsInJlcXVpcmUiLCJpdGVyYWJsZVRvQXJyYXlMaW1pdCIsInVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5Iiwibm9uSXRlcmFibGVSZXN0IiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJpIiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/slicedToArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(obj);\n}\n\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0I7RUFDcEI7O0VBRUEsT0FBTyxDQUFDQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJILE9BQU8sR0FBRyxjQUFjLE9BQU9JLE1BQXJCLElBQStCLFlBQVksT0FBT0EsTUFBTSxDQUFDQyxRQUF6RCxHQUFvRSxVQUFVSixHQUFWLEVBQWU7SUFDcEgsT0FBTyxPQUFPQSxHQUFkO0VBQ0QsQ0FGa0MsR0FFL0IsVUFBVUEsR0FBVixFQUFlO0lBQ2pCLE9BQU9BLEdBQUcsSUFBSSxjQUFjLE9BQU9HLE1BQTVCLElBQXNDSCxHQUFHLENBQUNLLFdBQUosS0FBb0JGLE1BQTFELElBQW9FSCxHQUFHLEtBQUtHLE1BQU0sQ0FBQ0csU0FBbkYsR0FBK0YsUUFBL0YsR0FBMEcsT0FBT04sR0FBeEg7RUFDRCxDQUpPLEVBSUxDLHlCQUFBLEdBQTRCLElBSnZCLEVBSTZCQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUpqRSxHQUkyRUgsT0FBTyxDQUFDQyxHQUFELENBSnpGO0FBS0Q7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkgsT0FBakIsRUFBMEJFLHlCQUFBLEdBQTRCLElBQXRELEVBQTREQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUEvRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanM/ZjMzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xyXG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcclxuXHJcbiAgcmV0dXJuIChtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcclxuICB9IDogZnVuY3Rpb24gKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcclxuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMpLCBfdHlwZW9mKG9iaik7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwib2JqIiwibW9kdWxlIiwiZXhwb3J0cyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/typeof.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ \"./node_modules/@babel/runtime/helpers/arrayLikeToArray.js\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxnQkFBZ0IsR0FBR0MsbUJBQU8sQ0FBQyx3RkFBRCxDQUE5Qjs7QUFFQSxTQUFTQywyQkFBVCxDQUFxQ0MsQ0FBckMsRUFBd0NDLE1BQXhDLEVBQWdEO0VBQzlDLElBQUksQ0FBQ0QsQ0FBTCxFQUFRO0VBQ1IsSUFBSSxPQUFPQSxDQUFQLEtBQWEsUUFBakIsRUFBMkIsT0FBT0gsZ0JBQWdCLENBQUNHLENBQUQsRUFBSUMsTUFBSixDQUF2QjtFQUMzQixJQUFJQyxDQUFDLEdBQUdDLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkMsUUFBakIsQ0FBMEJDLElBQTFCLENBQStCTixDQUEvQixFQUFrQ08sS0FBbEMsQ0FBd0MsQ0FBeEMsRUFBMkMsQ0FBQyxDQUE1QyxDQUFSO0VBQ0EsSUFBSUwsQ0FBQyxLQUFLLFFBQU4sSUFBa0JGLENBQUMsQ0FBQ1EsV0FBeEIsRUFBcUNOLENBQUMsR0FBR0YsQ0FBQyxDQUFDUSxXQUFGLENBQWNDLElBQWxCO0VBQ3JDLElBQUlQLENBQUMsS0FBSyxLQUFOLElBQWVBLENBQUMsS0FBSyxLQUF6QixFQUFnQyxPQUFPUSxLQUFLLENBQUNDLElBQU4sQ0FBV1gsQ0FBWCxDQUFQO0VBQ2hDLElBQUlFLENBQUMsS0FBSyxXQUFOLElBQXFCLDJDQUEyQ1UsSUFBM0MsQ0FBZ0RWLENBQWhELENBQXpCLEVBQTZFLE9BQU9MLGdCQUFnQixDQUFDRyxDQUFELEVBQUlDLE1BQUosQ0FBdkI7QUFDOUU7O0FBRURZLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQmYsMkJBQWpCLEVBQThDYyx5QkFBQSxHQUE0QixJQUExRSxFQUFnRkEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBbkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanM/ZGE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XHJcblxyXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XHJcbiAgaWYgKCFvKSByZXR1cm47XHJcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xyXG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcclxuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xyXG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJhcnJheUxpa2VUb0FycmF5IiwicmVxdWlyZSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm8iLCJtaW5MZW4iLCJuIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/wrapNativeSuper.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\n\nvar setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nvar isNativeFunction = __webpack_require__(/*! ./isNativeFunction.js */ \"./node_modules/@babel/runtime/helpers/isNativeFunction.js\");\n\nvar construct = __webpack_require__(/*! ./construct.js */ \"./node_modules/@babel/runtime/helpers/construct.js\");\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _wrapNativeSuper(Class);\n}\n\nmodule.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsY0FBYyxHQUFHQyxtQkFBTyxDQUFDLG9GQUFELENBQTVCOztBQUVBLElBQUlDLGNBQWMsR0FBR0QsbUJBQU8sQ0FBQyxvRkFBRCxDQUE1Qjs7QUFFQSxJQUFJRSxnQkFBZ0IsR0FBR0YsbUJBQU8sQ0FBQyx3RkFBRCxDQUE5Qjs7QUFFQSxJQUFJRyxTQUFTLEdBQUdILG1CQUFPLENBQUMsMEVBQUQsQ0FBdkI7O0FBRUEsU0FBU0ksZ0JBQVQsQ0FBMEJDLEtBQTFCLEVBQWlDO0VBQy9CLElBQUlDLE1BQU0sR0FBRyxPQUFPQyxHQUFQLEtBQWUsVUFBZixHQUE0QixJQUFJQSxHQUFKLEVBQTVCLEdBQXdDQyxTQUFyRDs7RUFFQUMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCTixnQkFBZ0IsR0FBRyxTQUFTQSxnQkFBVCxDQUEwQkMsS0FBMUIsRUFBaUM7SUFDbkUsSUFBSUEsS0FBSyxLQUFLLElBQVYsSUFBa0IsQ0FBQ0gsZ0JBQWdCLENBQUNHLEtBQUQsQ0FBdkMsRUFBZ0QsT0FBT0EsS0FBUDs7SUFFaEQsSUFBSSxPQUFPQSxLQUFQLEtBQWlCLFVBQXJCLEVBQWlDO01BQy9CLE1BQU0sSUFBSU0sU0FBSixDQUFjLG9EQUFkLENBQU47SUFDRDs7SUFFRCxJQUFJLE9BQU9MLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7TUFDakMsSUFBSUEsTUFBTSxDQUFDTSxHQUFQLENBQVdQLEtBQVgsQ0FBSixFQUF1QixPQUFPQyxNQUFNLENBQUNPLEdBQVAsQ0FBV1IsS0FBWCxDQUFQOztNQUV2QkMsTUFBTSxDQUFDUSxHQUFQLENBQVdULEtBQVgsRUFBa0JVLE9BQWxCO0lBQ0Q7O0lBRUQsU0FBU0EsT0FBVCxHQUFtQjtNQUNqQixPQUFPWixTQUFTLENBQUNFLEtBQUQsRUFBUVcsU0FBUixFQUFtQmpCLGNBQWMsQ0FBQyxJQUFELENBQWQsQ0FBcUJrQixXQUF4QyxDQUFoQjtJQUNEOztJQUVERixPQUFPLENBQUNHLFNBQVIsR0FBb0JDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjZixLQUFLLENBQUNhLFNBQXBCLEVBQStCO01BQ2pERCxXQUFXLEVBQUU7UUFDWEksS0FBSyxFQUFFTixPQURJO1FBRVhPLFVBQVUsRUFBRSxLQUZEO1FBR1hDLFFBQVEsRUFBRSxJQUhDO1FBSVhDLFlBQVksRUFBRTtNQUpIO0lBRG9DLENBQS9CLENBQXBCO0lBUUEsT0FBT3ZCLGNBQWMsQ0FBQ2MsT0FBRCxFQUFVVixLQUFWLENBQXJCO0VBQ0QsQ0ExQkQsRUEwQkdJLHlCQUFBLEdBQTRCLElBMUIvQixFQTBCcUNBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BMUJ4RTtFQTJCQSxPQUFPTixnQkFBZ0IsQ0FBQ0MsS0FBRCxDQUF2QjtBQUNEOztBQUVESSxNQUFNLENBQUNDLE9BQVAsR0FBaUJOLGdCQUFqQixFQUFtQ0sseUJBQUEsR0FBNEIsSUFBL0QsRUFBcUVBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQXhHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlci5qcz9mNTIxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mLmpzXCIpO1xyXG5cclxudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2YuanNcIik7XHJcblxyXG52YXIgaXNOYXRpdmVGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2lzTmF0aXZlRnVuY3Rpb24uanNcIik7XHJcblxyXG52YXIgY29uc3RydWN0ID0gcmVxdWlyZShcIi4vY29uc3RydWN0LmpzXCIpO1xyXG5cclxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xyXG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XHJcblxyXG4gIG1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcclxuICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcclxuXHJcbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xyXG5cclxuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcclxuICAgICAgcmV0dXJuIGNvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBnZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XHJcbiAgICB9XHJcblxyXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xyXG4gICAgICBjb25zdHJ1Y3Rvcjoge1xyXG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XHJcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xyXG4gIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfd3JhcE5hdGl2ZVN1cGVyLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbImdldFByb3RvdHlwZU9mIiwicmVxdWlyZSIsInNldFByb3RvdHlwZU9mIiwiaXNOYXRpdmVGdW5jdGlvbiIsImNvbnN0cnVjdCIsIl93cmFwTmF0aXZlU3VwZXIiLCJDbGFzcyIsIl9jYWNoZSIsIk1hcCIsInVuZGVmaW5lZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJUeXBlRXJyb3IiLCJoYXMiLCJnZXQiLCJzZXQiLCJXcmFwcGVyIiwiYXJndW1lbnRzIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/wrapNativeSuper.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUFBLGdIQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcz84MTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XHJcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/regenerator/index.js\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/lib/_define_property.js":
/*!***********************************************************!*\
  !*** ./node_modules/@swc/helpers/lib/_define_property.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = _defineProperty;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2xpYi9fZGVmaW5lX3Byb3BlcnR5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCxrQkFBQSxHQUFrQkcsZUFBbEI7O0FBQ0EsU0FBU0EsZUFBVCxDQUF5QkMsR0FBekIsRUFBOEJDLEdBQTlCLEVBQW1DSixLQUFuQyxFQUEwQztFQUN0QyxJQUFJSSxHQUFHLElBQUlELEdBQVgsRUFBZ0I7SUFDWk4sTUFBTSxDQUFDQyxjQUFQLENBQXNCSyxHQUF0QixFQUEyQkMsR0FBM0IsRUFBZ0M7TUFDNUJKLEtBQUssRUFBRUEsS0FEcUI7TUFFNUJLLFVBQVUsRUFBRSxJQUZnQjtNQUc1QkMsWUFBWSxFQUFFLElBSGM7TUFJNUJDLFFBQVEsRUFBRTtJQUprQixDQUFoQztFQU1ILENBUEQsTUFPTztJQUNISixHQUFHLENBQUNDLEdBQUQsQ0FBSCxHQUFXSixLQUFYO0VBQ0g7O0VBQ0QsT0FBT0csR0FBUDtBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvbGliL19kZWZpbmVfcHJvcGVydHkuanM/NzY0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZpbmVQcm9wZXJ0eTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/lib/_define_property.js\n"));

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength;\nexports.toByteArray = toByteArray;\nexports.fromByteArray = fromByteArray;\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n} // Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction getLens(b64) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');\n  } // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n  var validLen = b64.indexOf('=');\n  if (validLen === -1) validLen = len;\n  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n  return [validLen, placeHoldersLen];\n} // base64 is 4/3 + up to two characters of the original data\n\n\nfunction byteLength(b64) {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\n\nfunction _byteLength(b64, validLen, placeHoldersLen) {\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\n\nfunction toByteArray(b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars\n\n  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n  var i;\n\n  for (i = 0; i < len; i += 4) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = tmp >> 16 & 0xFF;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  return arr;\n}\n\nfunction tripletToBase64(num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\n\nfunction encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n    output.push(tripletToBase64(tmp));\n  }\n\n  return output.join('');\n}\n\nfunction fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n  // go through the array every three bytes, we'll deal with trailing stuff later\n\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');\n  }\n\n  return parts.join('');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBUixHQUFhLElBQWQsQ0FETixHQUVBLElBSEY7RUFLRCxDQVBELE1BT08sSUFBSVksVUFBVSxLQUFLLENBQW5CLEVBQXNCO0lBQzNCWixHQUFHLEdBQUcsQ0FBQ00sS0FBSyxDQUFDakIsR0FBRyxHQUFHLENBQVAsQ0FBTCxJQUFrQixDQUFuQixJQUF3QmlCLEtBQUssQ0FBQ2pCLEdBQUcsR0FBRyxDQUFQLENBQW5DO0lBQ0F3QixLQUFLLENBQUNILElBQU4sQ0FDRTVCLE1BQU0sQ0FBQ2tCLEdBQUcsSUFBSSxFQUFSLENBQU4sR0FDQWxCLE1BQU0sQ0FBRWtCLEdBQUcsSUFBSSxDQUFSLEdBQWEsSUFBZCxDQUROLEdBRUFsQixNQUFNLENBQUVrQixHQUFHLElBQUksQ0FBUixHQUFhLElBQWQsQ0FGTixHQUdBLEdBSkY7RUFNRDs7RUFFRCxPQUFPYSxLQUFLLENBQUNGLElBQU4sQ0FBVyxFQUFYLENBQVA7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzPzM3NzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsImJ5dGVMZW5ndGgiLCJ0b0J5dGVBcnJheSIsImZyb21CeXRlQXJyYXkiLCJsb29rdXAiLCJyZXZMb29rdXAiLCJBcnIiLCJVaW50OEFycmF5IiwiQXJyYXkiLCJjb2RlIiwiaSIsImxlbiIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJnZXRMZW5zIiwiYjY0IiwiRXJyb3IiLCJ2YWxpZExlbiIsImluZGV4T2YiLCJwbGFjZUhvbGRlcnNMZW4iLCJsZW5zIiwiX2J5dGVMZW5ndGgiLCJ0bXAiLCJhcnIiLCJjdXJCeXRlIiwidHJpcGxldFRvQmFzZTY0IiwibnVtIiwiZW5jb2RlQ2h1bmsiLCJ1aW50OCIsInN0YXJ0IiwiZW5kIiwib3V0cHV0IiwicHVzaCIsImpvaW4iLCJleHRyYUJ5dGVzIiwicGFydHMiLCJtYXhDaHVua0xlbmd0aCIsImxlbjIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n/* eslint-disable no-proto */\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\");\n\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\");\n\nconst customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation\n? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n: null;\nexports.Buffer = Buffer;\nexports.SlowBuffer = SlowBuffer;\nexports.INSPECT_MAX_BYTES = 50;\nconst K_MAX_LENGTH = 0x7fffffff;\nexports.kMaxLength = K_MAX_LENGTH;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\n\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {\n  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');\n}\n\nfunction typedArraySupport() {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1);\n    const proto = {\n      foo: function () {\n        return 42;\n      }\n    };\n    Object.setPrototypeOf(proto, Uint8Array.prototype);\n    Object.setPrototypeOf(arr, proto);\n    return arr.foo() === 42;\n  } catch (e) {\n    return false;\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined;\n    return this.buffer;\n  }\n});\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined;\n    return this.byteOffset;\n  }\n});\n\nfunction createBuffer(length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n  } // Return an augmented `Uint8Array` instance\n\n\n  const buf = new Uint8Array(length);\n  Object.setPrototypeOf(buf, Buffer.prototype);\n  return buf;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\n\nfunction Buffer(arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError('The \"string\" argument must be of type string. Received type number');\n    }\n\n    return allocUnsafe(arg);\n  }\n\n  return from(arg, encodingOrOffset, length);\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n\nfunction from(value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset);\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value);\n  }\n\n  if (value == null) {\n    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);\n  }\n\n  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n    return fromArrayBuffer(value, encodingOrOffset, length);\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length);\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n  }\n\n  const valueOf = value.valueOf && value.valueOf();\n\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length);\n  }\n\n  const b = fromObject(value);\n  if (b) return b;\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);\n  }\n\n  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\n\n\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length);\n}; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\n\n\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\nObject.setPrototypeOf(Buffer, Uint8Array);\n\nfunction assertSize(size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number');\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n  }\n}\n\nfunction alloc(size, fill, encoding) {\n  assertSize(size);\n\n  if (size <= 0) {\n    return createBuffer(size);\n  }\n\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n  }\n\n  return createBuffer(size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\n\n\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding);\n};\n\nfunction allocUnsafe(size) {\n  assertSize(size);\n  return createBuffer(size < 0 ? 0 : checked(size) | 0);\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\n\n\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\n\n\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size);\n};\n\nfunction fromString(string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding);\n  }\n\n  const length = byteLength(string, encoding) | 0;\n  let buf = createBuffer(length);\n  const actual = buf.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual);\n  }\n\n  return buf;\n}\n\nfunction fromArrayLike(array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0;\n  const buf = createBuffer(length);\n\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255;\n  }\n\n  return buf;\n}\n\nfunction fromArrayView(arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView);\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n  }\n\n  return fromArrayLike(arrayView);\n}\n\nfunction fromArrayBuffer(array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds');\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds');\n  }\n\n  let buf;\n\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array);\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset);\n  } else {\n    buf = new Uint8Array(array, byteOffset, length);\n  } // Return an augmented `Uint8Array` instance\n\n\n  Object.setPrototypeOf(buf, Buffer.prototype);\n  return buf;\n}\n\nfunction fromObject(obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0;\n    const buf = createBuffer(len);\n\n    if (buf.length === 0) {\n      return buf;\n    }\n\n    obj.copy(buf, 0, 0, len);\n    return buf;\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0);\n    }\n\n    return fromArrayLike(obj);\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data);\n  }\n}\n\nfunction checked(length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n  }\n\n  return length | 0;\n}\n\nfunction SlowBuffer(length) {\n  if (+length != length) {\n    // eslint-disable-line eqeqeq\n    length = 0;\n  }\n\n  return Buffer.alloc(+length);\n}\n\nBuffer.isBuffer = function isBuffer(b) {\n  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false\n};\n\nBuffer.compare = function compare(a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n  }\n\n  if (a === b) return 0;\n  let x = a.length;\n  let y = b.length;\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true;\n\n    default:\n      return false;\n  }\n};\n\nBuffer.concat = function concat(list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers');\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0);\n  }\n\n  let i;\n\n  if (length === undefined) {\n    length = 0;\n\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length);\n  let pos = 0;\n\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i];\n\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);\n        buf.copy(buffer, pos);\n      } else {\n        Uint8Array.prototype.set.call(buffer, buf, pos);\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    } else {\n      buf.copy(buffer, pos);\n    }\n\n    pos += buf.length;\n  }\n\n  return buffer;\n};\n\nfunction byteLength(string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length;\n  }\n\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength;\n  }\n\n  if (typeof string !== 'string') {\n    throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);\n  }\n\n  const len = string.length;\n  const mustMatch = arguments.length > 2 && arguments[2] === true;\n  if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion\n\n  let loweredCase = false;\n\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len;\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length;\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2;\n\n      case 'hex':\n        return len >>> 1;\n\n      case 'base64':\n        return base64ToBytes(string).length;\n\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8\n        }\n\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\nBuffer.byteLength = byteLength;\n\nfunction slowToString(encoding, start, end) {\n  let loweredCase = false; // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\n  if (start === undefined || start < 0) {\n    start = 0;\n  } // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n\n\n  if (start > this.length) {\n    return '';\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return '';\n  } // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n\n\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return '';\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end);\n\n      case 'ascii':\n        return asciiSlice(this, start, end);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end);\n\n      case 'base64':\n        return base64Slice(this, start, end);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n} // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\n\n\nBuffer.prototype._isBuffer = true;\n\nfunction swap(b, n, m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  const len = this.length;\n\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits');\n  }\n\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n\n  return this;\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  const len = this.length;\n\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits');\n  }\n\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n\n  return this;\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  const len = this.length;\n\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits');\n  }\n\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n\n  return this;\n};\n\nBuffer.prototype.toString = function toString() {\n  const length = this.length;\n  if (length === 0) return '';\n  if (arguments.length === 0) return utf8Slice(this, 0, length);\n  return slowToString.apply(this, arguments);\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\nBuffer.prototype.equals = function equals(b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n  if (this === b) return true;\n  return Buffer.compare(this, b) === 0;\n};\n\nBuffer.prototype.inspect = function inspect() {\n  let str = '';\n  const max = exports.INSPECT_MAX_BYTES;\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n  if (this.length > max) str += ' ... ';\n  return '<Buffer ' + str + '>';\n};\n\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;\n}\n\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength);\n  }\n\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index');\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0;\n  }\n\n  if (thisStart >= thisEnd) {\n    return -1;\n  }\n\n  if (start >= end) {\n    return 1;\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n  if (this === target) return 0;\n  let x = thisEnd - thisStart;\n  let y = end - start;\n  const len = Math.min(x, y);\n  const thisCopy = this.slice(thisStart, thisEnd);\n  const targetCopy = target.slice(start, end);\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\n\n\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1; // Normalize byteOffset\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n\n  byteOffset = +byteOffset; // Coerce to Number.\n\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : buffer.length - 1;\n  } // Normalize byteOffset: negative offsets start from the end of the buffer\n\n\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1;else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;else return -1;\n  } // Normalize val\n\n\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  } // Finally, search either indexOf (if dir is true) or lastIndexOf\n\n\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1;\n    }\n\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n      }\n    }\n\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n  }\n\n  throw new TypeError('val must be string, number or Buffer');\n}\n\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1;\n  let arrLength = arr.length;\n  let valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n\n    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1;\n      }\n\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read(buf, i) {\n    if (indexSize === 1) {\n      return buf[i];\n    } else {\n      return buf.readUInt16BE(i * indexSize);\n    }\n  }\n\n  let i;\n\n  if (dir) {\n    let foundIndex = -1;\n\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true;\n\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break;\n        }\n      }\n\n      if (found) return i;\n    }\n  }\n\n  return -1;\n}\n\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\n\nfunction hexWrite(buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  const remaining = buf.length - offset;\n\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  const strLen = string.length;\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n\n  let i;\n\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (numberIsNaN(parsed)) return i;\n    buf[offset + i] = parsed;\n  }\n\n  return i;\n}\n\nfunction utf8Write(buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nfunction asciiWrite(buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\n\nfunction base64Write(buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\n\nfunction ucs2Write(buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0; // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0; // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0;\n\n    if (isFinite(length)) {\n      length = length >>> 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n  } else {\n    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n  }\n\n  const remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds');\n  }\n\n  if (!encoding) encoding = 'utf8';\n  let loweredCase = false;\n\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length);\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length);\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  };\n};\n\nfunction base64Slice(buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf);\n  } else {\n    return base64.fromByteArray(buf.slice(start, end));\n  }\n}\n\nfunction utf8Slice(buf, start, end) {\n  end = Math.min(buf.length, end);\n  const res = [];\n  let i = start;\n\n  while (i < end) {\n    const firstByte = buf[i];\n    let codePoint = null;\n    let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n\n          break;\n\n        case 2:\n          secondByte = buf[i + 1];\n\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n          break;\n\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n          break;\n\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res);\n} // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\n\n\nconst MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray(codePoints) {\n  const len = codePoints.length;\n\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n  } // Decode in chunks to avoid \"call stack size exceeded\".\n\n\n  let res = '';\n  let i = 0;\n\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n\n  return res;\n}\n\nfunction asciiSlice(buf, start, end) {\n  let ret = '';\n  end = Math.min(buf.length, end);\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n\n  return ret;\n}\n\nfunction latin1Slice(buf, start, end) {\n  let ret = '';\n  end = Math.min(buf.length, end);\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n\n  return ret;\n}\n\nfunction hexSlice(buf, start, end) {\n  const len = buf.length;\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n  let out = '';\n\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]];\n  }\n\n  return out;\n}\n\nfunction utf16leSlice(buf, start, end) {\n  const bytes = buf.slice(start, end);\n  let res = ''; // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n\n  return res;\n}\n\nBuffer.prototype.slice = function slice(start, end) {\n  const len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n  const newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance\n\n  Object.setPrototypeOf(newBuf, Buffer.prototype);\n  return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\n\n\nfunction checkOffset(offset, ext, length) {\n  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n}\n\nBuffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n  let val = this[offset];\n  let mul = 1;\n  let i = 0;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  let val = this[offset + --byteLength];\n  let mul = 1;\n\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset];\n};\n\nBuffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | this[offset + 1] << 8;\n};\n\nBuffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] << 8 | this[offset + 1];\n};\n\nBuffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\n\nBuffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n  offset = offset >>> 0;\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8);\n  }\n\n  const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n  const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n  return BigInt(lo) + (BigInt(hi) << BigInt(32));\n});\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n  offset = offset >>> 0;\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8);\n  }\n\n  const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n  const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n});\n\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n  let val = this[offset];\n  let mul = 1;\n  let i = 0;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  mul *= 0x80;\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n  return val;\n};\n\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n  let i = byteLength;\n  let mul = 1;\n  let val = this[offset + --i];\n\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n\n  mul *= 0x80;\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n  return val;\n};\n\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return this[offset];\n  return (0xff - this[offset] + 1) * -1;\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  const val = this[offset] | this[offset + 1] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  const val = this[offset + 1] | this[offset] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n  offset = offset >>> 0;\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8);\n  }\n\n  const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24); // Overflow\n\n  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n});\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n  offset = offset >>> 0;\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8);\n  }\n\n  const val = (first << 24) + // Overflow\n  this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n});\n\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, true, 23, 4);\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, false, 23, 4);\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, true, 52, 8);\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, false, 52, 8);\n};\n\nfunction checkInt(buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n}\n\nBuffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  let mul = 1;\n  let i = 0;\n  this[offset] = value & 0xFF;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  let i = byteLength - 1;\n  let mul = 1;\n  this[offset + i] = value & 0xFF;\n\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nBuffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  this[offset] = value & 0xff;\n  this[offset + 1] = value >>> 8;\n  return offset + 2;\n};\n\nBuffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  this[offset] = value >>> 8;\n  this[offset + 1] = value & 0xff;\n  return offset + 2;\n};\n\nBuffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  this[offset + 3] = value >>> 24;\n  this[offset + 2] = value >>> 16;\n  this[offset + 1] = value >>> 8;\n  this[offset] = value & 0xff;\n  return offset + 4;\n};\n\nBuffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  this[offset] = value >>> 24;\n  this[offset + 1] = value >>> 16;\n  this[offset + 2] = value >>> 8;\n  this[offset + 3] = value & 0xff;\n  return offset + 4;\n};\n\nfunction wrtBigUInt64LE(buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7);\n  let lo = Number(value & BigInt(0xffffffff));\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  return offset;\n}\n\nfunction wrtBigUInt64BE(buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7);\n  let lo = Number(value & BigInt(0xffffffff));\n  buf[offset + 7] = lo;\n  lo = lo >> 8;\n  buf[offset + 6] = lo;\n  lo = lo >> 8;\n  buf[offset + 5] = lo;\n  lo = lo >> 8;\n  buf[offset + 4] = lo;\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n  buf[offset + 3] = hi;\n  hi = hi >> 8;\n  buf[offset + 2] = hi;\n  hi = hi >> 8;\n  buf[offset + 1] = hi;\n  hi = hi >> 8;\n  buf[offset] = hi;\n  return offset + 8;\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));\n});\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));\n});\n\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n\n  if (!noAssert) {\n    const limit = Math.pow(2, 8 * byteLength - 1);\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  let i = 0;\n  let mul = 1;\n  let sub = 0;\n  this[offset] = value & 0xFF;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n\n  if (!noAssert) {\n    const limit = Math.pow(2, 8 * byteLength - 1);\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  let i = byteLength - 1;\n  let mul = 1;\n  let sub = 0;\n  this[offset + i] = value & 0xFF;\n\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  this[offset] = value & 0xff;\n  this[offset + 1] = value >>> 8;\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  this[offset] = value >>> 8;\n  this[offset + 1] = value & 0xff;\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  this[offset] = value & 0xff;\n  this[offset + 1] = value >>> 8;\n  this[offset + 2] = value >>> 16;\n  this[offset + 3] = value >>> 24;\n  return offset + 4;\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  this[offset] = value >>> 24;\n  this[offset + 1] = value >>> 16;\n  this[offset + 2] = value >>> 8;\n  this[offset + 3] = value & 0xff;\n  return offset + 4;\n};\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));\n});\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));\n});\n\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n  if (offset < 0) throw new RangeError('Index out of range');\n}\n\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  ieee754.write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4;\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert);\n};\n\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  ieee754.write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8;\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert);\n}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n  if (end === start) return 0;\n  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds');\n  }\n\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');\n  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?\n\n  if (end > this.length) end = this.length;\n\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  const len = end - start;\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end);\n  } else {\n    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n  }\n\n  return len;\n}; // Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\n\n\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string');\n    }\n\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding);\n    }\n\n    if (val.length === 1) {\n      const code = val.charCodeAt(0);\n\n      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code;\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  } else if (typeof val === 'boolean') {\n    val = Number(val);\n  } // Invalid ranges are not set to a default, so can range check early.\n\n\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index');\n  }\n\n  if (end <= start) {\n    return this;\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n  if (!val) val = 0;\n  let i;\n\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);\n    const len = bytes.length;\n\n    if (len === 0) {\n      throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n    }\n\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this;\n}; // CUSTOM ERRORS\n// =============\n// Simplified versions from Node, changed for Buffer-only usage\n\n\nconst errors = {};\n\nfunction E(sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor() {\n      super();\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      }); // Add the error code to the name to include it in the stack trace.\n\n      this.name = `${this.name} [${sym}]`; // Access the stack to generate the error message including the error code\n      // from the name.\n\n      this.stack; // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n\n      delete this.name;\n    }\n\n    get code() {\n      return sym;\n    }\n\n    set code(value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      });\n    }\n\n    toString() {\n      return `${this.name} [${sym}]: ${this.message}`;\n    }\n\n  };\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {\n  if (name) {\n    return `${name} is outside of buffer bounds`;\n  }\n\n  return 'Attempt to access memory outside buffer bounds';\n}, RangeError);\nE('ERR_INVALID_ARG_TYPE', function (name, actual) {\n  return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n}, TypeError);\nE('ERR_OUT_OF_RANGE', function (str, range, input) {\n  let msg = `The value of \"${str}\" is out of range.`;\n  let received = input;\n\n  if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n    received = addNumericalSeparator(String(input));\n  } else if (typeof input === 'bigint') {\n    received = String(input);\n\n    if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n      received = addNumericalSeparator(received);\n    }\n\n    received += 'n';\n  }\n\n  msg += ` It must be ${range}. Received ${received}`;\n  return msg;\n}, RangeError);\n\nfunction addNumericalSeparator(val) {\n  let res = '';\n  let i = val.length;\n  const start = val[0] === '-' ? 1 : 0;\n\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`;\n  }\n\n  return `${val.slice(0, i)}${res}`;\n} // CHECK FUNCTIONS\n// ===============\n\n\nfunction checkBounds(buf, offset, byteLength) {\n  validateNumber(offset, 'offset');\n\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1));\n  }\n}\n\nfunction checkIntBI(value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : '';\n    let range;\n\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`;\n    }\n\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value);\n  }\n\n  checkBounds(buf, offset, byteLength);\n}\n\nfunction validateNumber(value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);\n  }\n}\n\nfunction boundsError(value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type);\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);\n} // HELPER FUNCTIONS\n// ================\n\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\nfunction base64clean(str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]; // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\n  str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''\n\n  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n\n  return str;\n}\n\nfunction utf8ToBytes(string, units) {\n  units = units || Infinity;\n  let codePoint;\n  const length = string.length;\n  let leadSurrogate = null;\n  const bytes = [];\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i); // is surrogate component\n\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } // valid lead\n\n\n        leadSurrogate = codePoint;\n        continue;\n      } // 2 leads in a row\n\n\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue;\n      } // valid surrogate pair\n\n\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null; // encode utf8\n\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break;\n      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break;\n      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break;\n      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n\n  return bytes;\n}\n\nfunction asciiToBytes(str) {\n  const byteArray = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n\n  return byteArray;\n}\n\nfunction utf16leToBytes(str, units) {\n  let c, hi, lo;\n  const byteArray = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break;\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return base64.toByteArray(base64clean(str));\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  let i;\n\n  for (i = 0; i < length; ++i) {\n    if (i + offset >= dst.length || i >= src.length) break;\n    dst[i + offset] = src[i];\n  }\n\n  return i;\n} // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\n\n\nfunction isInstance(obj, type) {\n  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n}\n\nfunction numberIsNaN(obj) {\n  // For IE11 support\n  return obj !== obj; // eslint-disable-line no-self-compare\n} // Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\n\n\nconst hexSliceLookupTable = function () {\n  const alphabet = '0123456789abcdef';\n  const table = new Array(256);\n\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16;\n\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j];\n    }\n  }\n\n  return table;\n}(); // Return not function with Error if BigInt not supported\n\n\nfunction defineBigIntMethod(fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;\n}\n\nfunction BufferBigIntNotDefined() {\n  throw new Error('BigInt not supported');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsRUFBcEIsRUFBd0IsRUFBRUEsQ0FBMUIsRUFBNkI7SUFDM0IsTUFBTTBPLEdBQUcsR0FBRzFPLENBQUMsR0FBRyxFQUFoQjs7SUFDQSxLQUFLLElBQUl3RSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEVBQXBCLEVBQXdCLEVBQUVBLENBQTFCLEVBQTZCO01BQzNCaUssS0FBSyxDQUFDQyxHQUFHLEdBQUdsSyxDQUFQLENBQUwsR0FBaUJnSyxRQUFRLENBQUN4TyxDQUFELENBQVIsR0FBY3dPLFFBQVEsQ0FBQ2hLLENBQUQsQ0FBdkM7SUFDRDtFQUNGOztFQUNELE9BQU9pSyxLQUFQO0FBQ0QsQ0FWMkIsRUFBNUIsQyxDQVlBOzs7QUFDQSxTQUFTdkcsa0JBQVQsQ0FBNkJ5RyxFQUE3QixFQUFpQztFQUMvQixPQUFPLE9BQU9sRyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDbUcsc0JBQWhDLEdBQXlERCxFQUFoRTtBQUNEOztBQUVELFNBQVNDLHNCQUFULEdBQW1DO0VBQ2pDLE1BQU0sSUFBSW5KLEtBQUosQ0FBVSxzQkFBVixDQUFOO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcz85MDFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG5jb25zdCBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5jb25zdCBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuY29uc3QgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGNvbnN0IGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgbGV0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgbGV0IGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICBjb25zdCBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICBsZXQgeCA9IGEubGVuZ3RoXG4gIGxldCB5ID0gYi5sZW5ndGhcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIGxldCBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgbGV0IHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGNvbnN0IG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2VyY2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIGNvbnN0IGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIGxldCBzdHIgPSAnJ1xuICBjb25zdCBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICBsZXQgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgbGV0IHkgPSBlbmQgLSBzdGFydFxuICBjb25zdCBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICBsZXQgaW5kZXhTaXplID0gMVxuICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICBsZXQgaVxuICBpZiAoZGlyKSB7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICBjb25zdCByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIGNvbnN0IHJlcyA9IFtdXG5cbiAgbGV0IGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIGxldCBjb2RlUG9pbnQgPSBudWxsXG4gICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5jb25zdCBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgbGV0IG91dCA9ICcnXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgbGV0IHJlcyA9ICcnXG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICBsZXQgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGxvID0gZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNFxuXG4gIGNvbnN0IGhpID0gdGhpc1srK29mZnNldF0gK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIGxhc3QgKiAyICoqIDI0XG5cbiAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgY29uc3QgbG8gPSB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3RcblxuICByZXR1cm4gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoXG4gIGxldCBtdWwgPSAxXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICtcbiAgICB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICtcbiAgICB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArXG4gICAgKGxhc3QgPDwgMjQpIC8vIE92ZXJmbG93XG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gKGZpcnN0IDw8IDI0KSArIC8vIE92ZXJmbG93XG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQodGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRMRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICByZXR1cm4gb2Zmc2V0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyA3XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNl0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDVdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA0XSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgM10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDJdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAxXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0XSA9IGhpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gMFxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICBsZXQgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBDVVNUT00gRVJST1JTXG4vLyA9PT09PT09PT09PT09XG5cbi8vIFNpbXBsaWZpZWQgdmVyc2lvbnMgZnJvbSBOb2RlLCBjaGFuZ2VkIGZvciBCdWZmZXItb25seSB1c2FnZVxuY29uc3QgZXJyb3JzID0ge31cbmZ1bmN0aW9uIEUgKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkge1xuICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske3N5bX1dYFxuICAgICAgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgICAgIC8vIGZyb20gdGhlIG5hbWUuXG4gICAgICB0aGlzLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgICAvLyBSZXNldCB0aGUgbmFtZSB0byB0aGUgYWN0dWFsIG5hbWUuXG4gICAgICBkZWxldGUgdGhpcy5uYW1lXG4gICAgfVxuXG4gICAgZ2V0IGNvZGUgKCkge1xuICAgICAgcmV0dXJuIHN5bVxuICAgIH1cblxuICAgIHNldCBjb2RlICh2YWx1ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2RlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgIH1cbiAgfVxufVxuXG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLFxuICBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gYCR7bmFtZX0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYFxuICAgIH1cblxuICAgIHJldHVybiAnQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcydcbiAgfSwgUmFuZ2VFcnJvcilcbkUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcbiAgZnVuY3Rpb24gKG5hbWUsIGFjdHVhbCkge1xuICAgIHJldHVybiBgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWBcbiAgfSwgVHlwZUVycm9yKVxuRSgnRVJSX09VVF9PRl9SQU5HRScsXG4gIGZ1bmN0aW9uIChzdHIsIHJhbmdlLCBpbnB1dCkge1xuICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLmBcbiAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dFxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7XG4gICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpXG4gICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7XG4gICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKVxuICAgICAgfVxuICAgICAgcmVjZWl2ZWQgKz0gJ24nXG4gICAgfVxuICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YFxuICAgIHJldHVybiBtc2dcbiAgfSwgUmFuZ2VFcnJvcilcblxuZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yICh2YWwpIHtcbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gdmFsLmxlbmd0aFxuICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gJy0nID8gMSA6IDBcbiAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHtcbiAgICByZXMgPSBgXyR7dmFsLnNsaWNlKGkgLSAzLCBpKX0ke3Jlc31gXG4gIH1cbiAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gXG59XG5cbi8vIENIRUNLIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRzIChidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBpZiAoYnVmW29mZnNldF0gPT09IHVuZGVmaW5lZCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoICsgMSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRCSSAodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHtcbiAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gJ2JpZ2ludCcgPyAnbicgOiAnJ1xuICAgIGxldCByYW5nZVxuICAgIGlmIChieXRlTGVuZ3RoID4gMykge1xuICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkge1xuICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4fSR7bn1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogYCArXG4gICAgICAgICAgICAgICAgYCR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn1gXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlID0gYD49ICR7bWlufSR7bn0gYW5kIDw9ICR7bWF4fSR7bn1gXG4gICAgfVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSgndmFsdWUnLCByYW5nZSwgdmFsdWUpXG4gIH1cbiAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyICh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0Vycm9yICh2YWx1ZSwgbGVuZ3RoLCB0eXBlKSB7XG4gIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcbiAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSlcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JywgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuXG4gIGlmIChsZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKVxuICB9XG5cbiAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUpXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuY29uc3QgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIGxldCBjb2RlUG9pbnRcbiAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgY29uc3QgYnl0ZXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIGxldCBjLCBoaSwgbG9cbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxuY29uc3QgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgY29uc3QgaTE2ID0gaSAqIDE2XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG5cbi8vIFJldHVybiBub3QgZnVuY3Rpb24gd2l0aCBFcnJvciBpZiBCaWdJbnQgbm90IHN1cHBvcnRlZFxuZnVuY3Rpb24gZGVmaW5lQmlnSW50TWV0aG9kIChmbikge1xuICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXJCaWdJbnROb3REZWZpbmVkIDogZm5cbn1cblxuZnVuY3Rpb24gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQmlnSW50IG5vdCBzdXBwb3J0ZWQnKVxufVxuIl0sIm5hbWVzIjpbImJhc2U2NCIsInJlcXVpcmUiLCJpZWVlNzU0IiwiY3VzdG9tSW5zcGVjdFN5bWJvbCIsIlN5bWJvbCIsImV4cG9ydHMiLCJCdWZmZXIiLCJTbG93QnVmZmVyIiwiSU5TUEVDVF9NQVhfQllURVMiLCJLX01BWF9MRU5HVEgiLCJrTWF4TGVuZ3RoIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsInR5cGVkQXJyYXlTdXBwb3J0IiwiY29uc29sZSIsImVycm9yIiwiYXJyIiwiVWludDhBcnJheSIsInByb3RvIiwiZm9vIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJlIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiaXNCdWZmZXIiLCJ1bmRlZmluZWQiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiY3JlYXRlQnVmZmVyIiwibGVuZ3RoIiwiUmFuZ2VFcnJvciIsImJ1ZiIsImFyZyIsImVuY29kaW5nT3JPZmZzZXQiLCJUeXBlRXJyb3IiLCJhbGxvY1Vuc2FmZSIsImZyb20iLCJwb29sU2l6ZSIsInZhbHVlIiwiZnJvbVN0cmluZyIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiZnJvbUFycmF5VmlldyIsImlzSW5zdGFuY2UiLCJmcm9tQXJyYXlCdWZmZXIiLCJTaGFyZWRBcnJheUJ1ZmZlciIsInZhbHVlT2YiLCJiIiwiZnJvbU9iamVjdCIsInRvUHJpbWl0aXZlIiwiYXNzZXJ0U2l6ZSIsInNpemUiLCJhbGxvYyIsImZpbGwiLCJlbmNvZGluZyIsImNoZWNrZWQiLCJhbGxvY1Vuc2FmZVNsb3ciLCJzdHJpbmciLCJpc0VuY29kaW5nIiwiYnl0ZUxlbmd0aCIsImFjdHVhbCIsIndyaXRlIiwic2xpY2UiLCJmcm9tQXJyYXlMaWtlIiwiYXJyYXkiLCJpIiwiYXJyYXlWaWV3IiwiY29weSIsIm9iaiIsImxlbiIsIm51bWJlcklzTmFOIiwidHlwZSIsIkFycmF5IiwiaXNBcnJheSIsImRhdGEiLCJ0b1N0cmluZyIsIl9pc0J1ZmZlciIsImNvbXBhcmUiLCJhIiwib2Zmc2V0IiwieCIsInkiLCJNYXRoIiwibWluIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJjb25jYXQiLCJsaXN0IiwicG9zIiwic2V0IiwiY2FsbCIsIm11c3RNYXRjaCIsImFyZ3VtZW50cyIsImxvd2VyZWRDYXNlIiwidXRmOFRvQnl0ZXMiLCJiYXNlNjRUb0J5dGVzIiwic2xvd1RvU3RyaW5nIiwic3RhcnQiLCJlbmQiLCJoZXhTbGljZSIsInV0ZjhTbGljZSIsImFzY2lpU2xpY2UiLCJsYXRpbjFTbGljZSIsImJhc2U2NFNsaWNlIiwidXRmMTZsZVNsaWNlIiwic3dhcCIsIm4iLCJtIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiYXBwbHkiLCJ0b0xvY2FsZVN0cmluZyIsImVxdWFscyIsImluc3BlY3QiLCJzdHIiLCJtYXgiLCJyZXBsYWNlIiwidHJpbSIsInRhcmdldCIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsInZhbCIsImRpciIsImFycmF5SW5kZXhPZiIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJqIiwiaW5jbHVkZXMiLCJoZXhXcml0ZSIsIk51bWJlciIsInJlbWFpbmluZyIsInN0ckxlbiIsInBhcnNlZCIsInBhcnNlSW50Iiwic3Vic3RyIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJiYXNlNjRXcml0ZSIsInVjczJXcml0ZSIsInV0ZjE2bGVUb0J5dGVzIiwiaXNGaW5pdGUiLCJFcnJvciIsInRvSlNPTiIsIl9hcnIiLCJmcm9tQnl0ZUFycmF5IiwicmVzIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsInB1c2giLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJNQVhfQVJHVU1FTlRTX0xFTkdUSCIsImNvZGVQb2ludHMiLCJmcm9tQ2hhckNvZGUiLCJyZXQiLCJvdXQiLCJoZXhTbGljZUxvb2t1cFRhYmxlIiwiYnl0ZXMiLCJuZXdCdWYiLCJzdWJhcnJheSIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVpbnRMRSIsInJlYWRVSW50TEUiLCJub0Fzc2VydCIsIm11bCIsInJlYWRVaW50QkUiLCJyZWFkVUludEJFIiwicmVhZFVpbnQ4IiwicmVhZFVJbnQ4IiwicmVhZFVpbnQxNkxFIiwicmVhZFVJbnQxNkxFIiwicmVhZFVpbnQxNkJFIiwicmVhZFVpbnQzMkxFIiwicmVhZFVJbnQzMkxFIiwicmVhZFVpbnQzMkJFIiwicmVhZFVJbnQzMkJFIiwicmVhZEJpZ1VJbnQ2NExFIiwiZGVmaW5lQmlnSW50TWV0aG9kIiwidmFsaWRhdGVOdW1iZXIiLCJmaXJzdCIsImxhc3QiLCJib3VuZHNFcnJvciIsImxvIiwiaGkiLCJCaWdJbnQiLCJyZWFkQmlnVUludDY0QkUiLCJyZWFkSW50TEUiLCJwb3ciLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEJpZ0ludDY0TEUiLCJyZWFkQmlnSW50NjRCRSIsInJlYWRGbG9hdExFIiwicmVhZEZsb2F0QkUiLCJyZWFkRG91YmxlTEUiLCJyZWFkRG91YmxlQkUiLCJjaGVja0ludCIsIndyaXRlVWludExFIiwid3JpdGVVSW50TEUiLCJtYXhCeXRlcyIsIndyaXRlVWludEJFIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVpbnQ4Iiwid3JpdGVVSW50OCIsIndyaXRlVWludDE2TEUiLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVaW50MTZCRSIsIndyaXRlVUludDE2QkUiLCJ3cml0ZVVpbnQzMkxFIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVWludDMyQkUiLCJ3cml0ZVVJbnQzMkJFIiwid3J0QmlnVUludDY0TEUiLCJjaGVja0ludEJJIiwid3J0QmlnVUludDY0QkUiLCJ3cml0ZUJpZ1VJbnQ2NExFIiwid3JpdGVCaWdVSW50NjRCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsInN1YiIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJ3cml0ZUJpZ0ludDY0TEUiLCJ3cml0ZUJpZ0ludDY0QkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0IiwibGl0dGxlRW5kaWFuIiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiY29weVdpdGhpbiIsImNvZGUiLCJjaGFyQ29kZUF0IiwiZXJyb3JzIiwiRSIsInN5bSIsImdldE1lc3NhZ2UiLCJCYXNlIiwiTm9kZUVycm9yIiwiY29uc3RydWN0b3IiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsIm5hbWUiLCJzdGFjayIsIm1lc3NhZ2UiLCJyYW5nZSIsImlucHV0IiwibXNnIiwicmVjZWl2ZWQiLCJpc0ludGVnZXIiLCJhYnMiLCJhZGROdW1lcmljYWxTZXBhcmF0b3IiLCJjaGVja0JvdW5kcyIsIkVSUl9PVVRfT0ZfUkFOR0UiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsImZsb29yIiwiRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTIiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInNwbGl0IiwidW5pdHMiLCJJbmZpbml0eSIsImxlYWRTdXJyb2dhdGUiLCJieXRlQXJyYXkiLCJjIiwidG9CeXRlQXJyYXkiLCJzcmMiLCJkc3QiLCJhbHBoYWJldCIsInRhYmxlIiwiaTE2IiwiZm4iLCJCdWZmZXJCaWdJbnROb3REZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/buffer/index.js\n"));

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? nBytes - 1 : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n  i += d;\n  e = s & (1 << -nBits) - 1;\n  s >>= -nBits;\n  nBits += eLen;\n\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : (s ? -1 : 1) * Infinity;\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n  var i = isLE ? 0 : nBytes - 1;\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = e << mLen | m;\n  eLen += mLen;\n\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0FBRyxDQUFkLEVBQWlCUCxNQUFNLENBQUNDLE1BQU0sR0FBR1UsQ0FBVixDQUFOLEdBQXFCTixDQUFDLEdBQUcsSUFBekIsRUFBK0JNLENBQUMsSUFBSUMsQ0FBcEMsRUFBdUNQLENBQUMsSUFBSSxHQUE1QyxFQUFpREUsSUFBSSxJQUFJLENBQTFFLEVBQTZFLENBQUU7O0VBRS9FUCxNQUFNLENBQUNDLE1BQU0sR0FBR1UsQ0FBVCxHQUFhQyxDQUFkLENBQU4sSUFBMEJDLENBQUMsR0FBRyxHQUE5QjtBQUNELENBbEREIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzP2ViYzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiJdLCJuYW1lcyI6WyJleHBvcnRzIiwicmVhZCIsImJ1ZmZlciIsIm9mZnNldCIsImlzTEUiLCJtTGVuIiwibkJ5dGVzIiwiZSIsIm0iLCJlTGVuIiwiZU1heCIsImVCaWFzIiwibkJpdHMiLCJpIiwiZCIsInMiLCJOYU4iLCJJbmZpbml0eSIsIk1hdGgiLCJwb3ciLCJ3cml0ZSIsInZhbHVlIiwiYyIsInJ0IiwiYWJzIiwiaXNOYU4iLCJmbG9vciIsImxvZyIsIkxOMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/client/_utils.js":
/*!*************************************************!*\
  !*** ./node_modules/next-auth/client/_utils.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BroadcastChannel = BroadcastChannel;\nexports.apiBaseUrl = apiBaseUrl;\nexports.fetchData = fetchData;\nexports.now = now;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction fetchData(_x, _x2, _x3) {\n  return _fetchData.apply(this, arguments);\n}\n\nfunction _fetchData() {\n  _fetchData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(path, __NEXTAUTH, logger) {\n    var _ref,\n        ctx,\n        _ref$req,\n        req,\n        url,\n        options,\n        res,\n        data,\n        _args = arguments;\n\n    return _regenerator.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref = _args.length > 3 && _args[3] !== undefined ? _args[3] : {}, ctx = _ref.ctx, _ref$req = _ref.req, req = _ref$req === void 0 ? ctx === null || ctx === void 0 ? void 0 : ctx.req : _ref$req;\n            url = \"\".concat(apiBaseUrl(__NEXTAUTH), \"/\").concat(path);\n            _context.prev = 2;\n            options = req !== null && req !== void 0 && req.headers.cookie ? {\n              headers: {\n                cookie: req.headers.cookie\n              }\n            } : {};\n            _context.next = 6;\n            return fetch(url, options);\n\n          case 6:\n            res = _context.sent;\n            _context.next = 9;\n            return res.json();\n\n          case 9:\n            data = _context.sent;\n\n            if (res.ok) {\n              _context.next = 12;\n              break;\n            }\n\n            throw data;\n\n          case 12:\n            return _context.abrupt(\"return\", Object.keys(data).length > 0 ? data : null);\n\n          case 15:\n            _context.prev = 15;\n            _context.t0 = _context[\"catch\"](2);\n            logger.error(\"CLIENT_FETCH_ERROR\", {\n              error: _context.t0,\n              url: url\n            });\n            return _context.abrupt(\"return\", null);\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[2, 15]]);\n  }));\n  return _fetchData.apply(this, arguments);\n}\n\nfunction apiBaseUrl(__NEXTAUTH) {\n  if (typeof window === \"undefined\") {\n    return \"\".concat(__NEXTAUTH.baseUrlServer).concat(__NEXTAUTH.basePathServer);\n  }\n\n  return __NEXTAUTH.basePath;\n}\n\nfunction now() {\n  return Math.floor(Date.now() / 1000);\n}\n\nfunction BroadcastChannel() {\n  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"nextauth.message\";\n  return {\n    receive: function receive(onReceive) {\n      var handler = function handler(event) {\n        var _event$newValue;\n\n        if (event.key !== name) return;\n        var message = JSON.parse((_event$newValue = event.newValue) !== null && _event$newValue !== void 0 ? _event$newValue : \"{}\");\n        if ((message === null || message === void 0 ? void 0 : message.event) !== \"session\" || !(message !== null && message !== void 0 && message.data)) return;\n        onReceive(message);\n      };\n\n      window.addEventListener(\"storage\", handler);\n      return function () {\n        return window.removeEventListener(\"storage\", handler);\n      };\n    },\n    post: function post(message) {\n      if (typeof window === \"undefined\") return;\n\n      try {\n        localStorage.setItem(name, JSON.stringify(_objectSpread(_objectSpread({}, message), {}, {\n          timestamp: now()\n        })));\n      } catch (_unused) {}\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2NsaWVudC9fdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSUEsc0JBQXNCLEdBQUdDLG1CQUFPLENBQUMsb0hBQUQsQ0FBcEM7O0FBRUFDLDhDQUE2QztFQUMzQ0csS0FBSyxFQUFFO0FBRG9DLENBQTdDO0FBR0FELHdCQUFBLEdBQTJCRSxnQkFBM0I7QUFDQUYsa0JBQUEsR0FBcUJHLFVBQXJCO0FBQ0FILGlCQUFBLEdBQW9CSSxTQUFwQjtBQUNBSixXQUFBLEdBQWNLLEdBQWQ7O0FBRUEsSUFBSUMsWUFBWSxHQUFHVixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxzRkFBRCxDQUFSLENBQXpDOztBQUVBLElBQUlVLGdCQUFnQixHQUFHWCxzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxzR0FBRCxDQUFSLENBQTdDOztBQUVBLElBQUlXLGtCQUFrQixHQUFHWixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQywwR0FBRCxDQUFSLENBQS9DOztBQUVBLFNBQVNZLE9BQVQsQ0FBaUJDLE1BQWpCLEVBQXlCQyxjQUF6QixFQUF5QztFQUFFLElBQUlDLElBQUksR0FBR2QsTUFBTSxDQUFDYyxJQUFQLENBQVlGLE1BQVosQ0FBWDs7RUFBZ0MsSUFBSVosTUFBTSxDQUFDZSxxQkFBWCxFQUFrQztJQUFFLElBQUlDLE9BQU8sR0FBR2hCLE1BQU0sQ0FBQ2UscUJBQVAsQ0FBNkJILE1BQTdCLENBQWQ7SUFBb0RDLGNBQWMsS0FBS0csT0FBTyxHQUFHQSxPQUFPLENBQUNDLE1BQVIsQ0FBZSxVQUFVQyxHQUFWLEVBQWU7TUFBRSxPQUFPbEIsTUFBTSxDQUFDbUIsd0JBQVAsQ0FBZ0NQLE1BQWhDLEVBQXdDTSxHQUF4QyxFQUE2Q0UsVUFBcEQ7SUFBaUUsQ0FBakcsQ0FBZixDQUFkLEVBQWtJTixJQUFJLENBQUNPLElBQUwsQ0FBVUMsS0FBVixDQUFnQlIsSUFBaEIsRUFBc0JFLE9BQXRCLENBQWxJO0VBQW1LOztFQUFD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aUM7VUFDdEZVLFNBQVMsRUFBRXJGLEdBQUc7UUFEd0UsQ0FBakMsQ0FBNUIsQ0FBM0I7TUFHRCxDQUpELENBSUUsT0FBT3NGLE9BQVAsRUFBZ0IsQ0FBRTtJQUNyQjtFQXhCSSxDQUFQO0FBMEJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvY2xpZW50L191dGlscy5qcz8wZGEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQnJvYWRjYXN0Q2hhbm5lbCA9IEJyb2FkY2FzdENoYW5uZWw7XG5leHBvcnRzLmFwaUJhc2VVcmwgPSBhcGlCYXNlVXJsO1xuZXhwb3J0cy5mZXRjaERhdGEgPSBmZXRjaERhdGE7XG5leHBvcnRzLm5vdyA9IG5vdztcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gZmV0Y2hEYXRhKF94LCBfeDIsIF94Mykge1xuICByZXR1cm4gX2ZldGNoRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZmV0Y2hEYXRhKCkge1xuICBfZmV0Y2hEYXRhID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocGF0aCwgX19ORVhUQVVUSCwgbG9nZ2VyKSB7XG4gICAgdmFyIF9yZWYsXG4gICAgICAgIGN0eCxcbiAgICAgICAgX3JlZiRyZXEsXG4gICAgICAgIHJlcSxcbiAgICAgICAgdXJsLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICByZXMsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfcmVmID0gX2FyZ3MubGVuZ3RoID4gMyAmJiBfYXJnc1szXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbM10gOiB7fSwgY3R4ID0gX3JlZi5jdHgsIF9yZWYkcmVxID0gX3JlZi5yZXEsIHJlcSA9IF9yZWYkcmVxID09PSB2b2lkIDAgPyBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgucmVxIDogX3JlZiRyZXE7XG4gICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdChhcGlCYXNlVXJsKF9fTkVYVEFVVEgpLCBcIi9cIikuY29uY2F0KHBhdGgpO1xuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI7XG4gICAgICAgICAgICBvcHRpb25zID0gcmVxICE9PSBudWxsICYmIHJlcSAhPT0gdm9pZCAwICYmIHJlcS5oZWFkZXJzLmNvb2tpZSA/IHtcbiAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIGNvb2tpZTogcmVxLmhlYWRlcnMuY29va2llXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gOiB7fTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKHVybCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXMgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmpzb24oKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IGRhdGE7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggPiAwID8gZGF0YSA6IG51bGwpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxNTtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgyKTtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkNMSUVOVF9GRVRDSF9FUlJPUlwiLCB7XG4gICAgICAgICAgICAgIGVycm9yOiBfY29udGV4dC50MCxcbiAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBudWxsKTtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMiwgMTVdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9mZXRjaERhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gYXBpQmFzZVVybChfX05FWFRBVVRIKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KF9fTkVYVEFVVEguYmFzZVVybFNlcnZlcikuY29uY2F0KF9fTkVYVEFVVEguYmFzZVBhdGhTZXJ2ZXIpO1xuICB9XG5cbiAgcmV0dXJuIF9fTkVYVEFVVEguYmFzZVBhdGg7XG59XG5cbmZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xufVxuXG5mdW5jdGlvbiBCcm9hZGNhc3RDaGFubmVsKCkge1xuICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJuZXh0YXV0aC5tZXNzYWdlXCI7XG4gIHJldHVybiB7XG4gICAgcmVjZWl2ZTogZnVuY3Rpb24gcmVjZWl2ZShvblJlY2VpdmUpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgICAgICB2YXIgX2V2ZW50JG5ld1ZhbHVlO1xuXG4gICAgICAgIGlmIChldmVudC5rZXkgIT09IG5hbWUpIHJldHVybjtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKChfZXZlbnQkbmV3VmFsdWUgPSBldmVudC5uZXdWYWx1ZSkgIT09IG51bGwgJiYgX2V2ZW50JG5ld1ZhbHVlICE9PSB2b2lkIDAgPyBfZXZlbnQkbmV3VmFsdWUgOiBcInt9XCIpO1xuICAgICAgICBpZiAoKG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVzc2FnZS5ldmVudCkgIT09IFwic2Vzc2lvblwiIHx8ICEobWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgJiYgbWVzc2FnZS5kYXRhKSkgcmV0dXJuO1xuICAgICAgICBvblJlY2VpdmUobWVzc2FnZSk7XG4gICAgICB9O1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInN0b3JhZ2VcIiwgaGFuZGxlcik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdG9yYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIHBvc3Q6IGZ1bmN0aW9uIHBvc3QobWVzc2FnZSkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obmFtZSwgSlNPTi5zdHJpbmdpZnkoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBtZXNzYWdlKSwge30sIHtcbiAgICAgICAgICB0aW1lc3RhbXA6IG5vdygpXG4gICAgICAgIH0pKSk7XG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7fVxuICAgIH1cbiAgfTtcbn0iXSwibmFtZXMiOlsiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJyb2FkY2FzdENoYW5uZWwiLCJhcGlCYXNlVXJsIiwiZmV0Y2hEYXRhIiwibm93IiwiX3JlZ2VuZXJhdG9yIiwiX2RlZmluZVByb3BlcnR5MiIsIl9hc3luY1RvR2VuZXJhdG9yMiIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwiZm9yRWFjaCIsImtleSIsImRlZmF1bHQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl94IiwiX3gyIiwiX3gzIiwiX2ZldGNoRGF0YSIsIm1hcmsiLCJfY2FsbGVlIiwicGF0aCIsIl9fTkVYVEFVVEgiLCJsb2dnZXIiLCJfcmVmIiwiY3R4IiwiX3JlZiRyZXEiLCJyZXEiLCJ1cmwiLCJvcHRpb25zIiwicmVzIiwiZGF0YSIsIl9hcmdzIiwid3JhcCIsIl9jYWxsZWUkIiwiX2NvbnRleHQiLCJwcmV2IiwibmV4dCIsInVuZGVmaW5lZCIsImNvbmNhdCIsImhlYWRlcnMiLCJjb29raWUiLCJmZXRjaCIsInNlbnQiLCJqc29uIiwib2siLCJhYnJ1cHQiLCJ0MCIsImVycm9yIiwic3RvcCIsIndpbmRvdyIsImJhc2VVcmxTZXJ2ZXIiLCJiYXNlUGF0aFNlcnZlciIsImJhc2VQYXRoIiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsIm5hbWUiLCJyZWNlaXZlIiwib25SZWNlaXZlIiwiaGFuZGxlciIsImV2ZW50IiwiX2V2ZW50JG5ld1ZhbHVlIiwibWVzc2FnZSIsIkpTT04iLCJwYXJzZSIsIm5ld1ZhbHVlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwb3N0IiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInRpbWVzdGFtcCIsIl91bnVzZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next-auth/client/_utils.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/core/errors.js":
/*!***********************************************!*\
  !*** ./node_modules/next-auth/core/errors.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.UnsupportedStrategy = exports.UnknownError = exports.OAuthCallbackError = exports.MissingSecret = exports.MissingAuthorize = exports.MissingAdapter = exports.MissingAPIRoute = exports.InvalidCallbackUrl = exports.AccountNotLinkedError = void 0;\nexports.adapterErrorHandler = adapterErrorHandler;\nexports.capitalize = capitalize;\nexports.eventsErrorHandler = eventsErrorHandler;\nexports.upperSnake = upperSnake;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ \"./node_modules/@babel/runtime/helpers/wrapNativeSuper.js\"));\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar UnknownError = function (_Error) {\n  (0, _inherits2.default)(UnknownError, _Error);\n\n  var _super = _createSuper(UnknownError);\n\n  function UnknownError(error) {\n    var _message;\n\n    var _this;\n\n    (0, _classCallCheck2.default)(this, UnknownError);\n    _this = _super.call(this, (_message = error === null || error === void 0 ? void 0 : error.message) !== null && _message !== void 0 ? _message : error);\n    _this.name = \"UnknownError\";\n    _this.code = error.code;\n\n    if (error instanceof Error) {\n      _this.stack = error.stack;\n    }\n\n    return _this;\n  }\n\n  (0, _createClass2.default)(UnknownError, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        name: this.name,\n        message: this.message,\n        stack: this.stack\n      };\n    }\n  }]);\n  return UnknownError;\n}((0, _wrapNativeSuper2.default)(Error));\n\nexports.UnknownError = UnknownError;\n\nvar OAuthCallbackError = function (_UnknownError) {\n  (0, _inherits2.default)(OAuthCallbackError, _UnknownError);\n\n  var _super2 = _createSuper(OAuthCallbackError);\n\n  function OAuthCallbackError() {\n    var _this2;\n\n    (0, _classCallCheck2.default)(this, OAuthCallbackError);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this2 = _super2.call.apply(_super2, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), \"name\", \"OAuthCallbackError\");\n    return _this2;\n  }\n\n  return (0, _createClass2.default)(OAuthCallbackError);\n}(UnknownError);\n\nexports.OAuthCallbackError = OAuthCallbackError;\n\nvar AccountNotLinkedError = function (_UnknownError2) {\n  (0, _inherits2.default)(AccountNotLinkedError, _UnknownError2);\n\n  var _super3 = _createSuper(AccountNotLinkedError);\n\n  function AccountNotLinkedError() {\n    var _this3;\n\n    (0, _classCallCheck2.default)(this, AccountNotLinkedError);\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    _this3 = _super3.call.apply(_super3, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this3), \"name\", \"AccountNotLinkedError\");\n    return _this3;\n  }\n\n  return (0, _createClass2.default)(AccountNotLinkedError);\n}(UnknownError);\n\nexports.AccountNotLinkedError = AccountNotLinkedError;\n\nvar MissingAPIRoute = function (_UnknownError3) {\n  (0, _inherits2.default)(MissingAPIRoute, _UnknownError3);\n\n  var _super4 = _createSuper(MissingAPIRoute);\n\n  function MissingAPIRoute() {\n    var _this4;\n\n    (0, _classCallCheck2.default)(this, MissingAPIRoute);\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    _this4 = _super4.call.apply(_super4, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), \"name\", \"MissingAPIRouteError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), \"code\", \"MISSING_NEXTAUTH_API_ROUTE_ERROR\");\n    return _this4;\n  }\n\n  return (0, _createClass2.default)(MissingAPIRoute);\n}(UnknownError);\n\nexports.MissingAPIRoute = MissingAPIRoute;\n\nvar MissingSecret = function (_UnknownError4) {\n  (0, _inherits2.default)(MissingSecret, _UnknownError4);\n\n  var _super5 = _createSuper(MissingSecret);\n\n  function MissingSecret() {\n    var _this5;\n\n    (0, _classCallCheck2.default)(this, MissingSecret);\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    _this5 = _super5.call.apply(_super5, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), \"name\", \"MissingSecretError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), \"code\", \"NO_SECRET\");\n    return _this5;\n  }\n\n  return (0, _createClass2.default)(MissingSecret);\n}(UnknownError);\n\nexports.MissingSecret = MissingSecret;\n\nvar MissingAuthorize = function (_UnknownError5) {\n  (0, _inherits2.default)(MissingAuthorize, _UnknownError5);\n\n  var _super6 = _createSuper(MissingAuthorize);\n\n  function MissingAuthorize() {\n    var _this6;\n\n    (0, _classCallCheck2.default)(this, MissingAuthorize);\n\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    _this6 = _super6.call.apply(_super6, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), \"name\", \"MissingAuthorizeError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), \"code\", \"CALLBACK_CREDENTIALS_HANDLER_ERROR\");\n    return _this6;\n  }\n\n  return (0, _createClass2.default)(MissingAuthorize);\n}(UnknownError);\n\nexports.MissingAuthorize = MissingAuthorize;\n\nvar MissingAdapter = function (_UnknownError6) {\n  (0, _inherits2.default)(MissingAdapter, _UnknownError6);\n\n  var _super7 = _createSuper(MissingAdapter);\n\n  function MissingAdapter() {\n    var _this7;\n\n    (0, _classCallCheck2.default)(this, MissingAdapter);\n\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    _this7 = _super7.call.apply(_super7, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), \"name\", \"MissingAdapterError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), \"code\", \"EMAIL_REQUIRES_ADAPTER_ERROR\");\n    return _this7;\n  }\n\n  return (0, _createClass2.default)(MissingAdapter);\n}(UnknownError);\n\nexports.MissingAdapter = MissingAdapter;\n\nvar UnsupportedStrategy = function (_UnknownError7) {\n  (0, _inherits2.default)(UnsupportedStrategy, _UnknownError7);\n\n  var _super8 = _createSuper(UnsupportedStrategy);\n\n  function UnsupportedStrategy() {\n    var _this8;\n\n    (0, _classCallCheck2.default)(this, UnsupportedStrategy);\n\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    _this8 = _super8.call.apply(_super8, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this8), \"name\", \"UnsupportedStrategyError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this8), \"code\", \"CALLBACK_CREDENTIALS_JWT_ERROR\");\n    return _this8;\n  }\n\n  return (0, _createClass2.default)(UnsupportedStrategy);\n}(UnknownError);\n\nexports.UnsupportedStrategy = UnsupportedStrategy;\n\nvar InvalidCallbackUrl = function (_UnknownError8) {\n  (0, _inherits2.default)(InvalidCallbackUrl, _UnknownError8);\n\n  var _super9 = _createSuper(InvalidCallbackUrl);\n\n  function InvalidCallbackUrl() {\n    var _this9;\n\n    (0, _classCallCheck2.default)(this, InvalidCallbackUrl);\n\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n\n    _this9 = _super9.call.apply(_super9, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this9), \"name\", \"InvalidCallbackUrl\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this9), \"code\", \"INVALID_CALLBACK_URL_ERROR\");\n    return _this9;\n  }\n\n  return (0, _createClass2.default)(InvalidCallbackUrl);\n}(UnknownError);\n\nexports.InvalidCallbackUrl = InvalidCallbackUrl;\n\nfunction upperSnake(s) {\n  return s.replace(/([A-Z])/g, \"_$1\").toUpperCase();\n}\n\nfunction capitalize(s) {\n  return \"\".concat(s[0].toUpperCase()).concat(s.slice(1));\n}\n\nfunction eventsErrorHandler(methods, logger) {\n  return Object.keys(methods).reduce(function (acc, name) {\n    acc[name] = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {\n      var method,\n          _args = arguments;\n      return _regenerator.default.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              method = methods[name];\n              _context.next = 4;\n              return method.apply(void 0, _args);\n\n            case 4:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 7:\n              _context.prev = 7;\n              _context.t0 = _context[\"catch\"](0);\n              logger.error(\"\".concat(upperSnake(name), \"_EVENT_ERROR\"), _context.t0);\n\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 7]]);\n    }));\n    return acc;\n  }, {});\n}\n\nfunction adapterErrorHandler(adapter, logger) {\n  if (!adapter) return;\n  return Object.keys(adapter).reduce(function (acc, name) {\n    acc[name] = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {\n      var _len9,\n          args,\n          _key9,\n          method,\n          e,\n          _args2 = arguments;\n\n      return _regenerator.default.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n\n              for (_len9 = _args2.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n                args[_key9] = _args2[_key9];\n              }\n\n              logger.debug(\"adapter_\".concat(name), {\n                args: args\n              });\n              method = adapter[name];\n              _context2.next = 6;\n              return method.apply(void 0, args);\n\n            case 6:\n              return _context2.abrupt(\"return\", _context2.sent);\n\n            case 9:\n              _context2.prev = 9;\n              _context2.t0 = _context2[\"catch\"](0);\n              logger.error(\"adapter_error_\".concat(name), _context2.t0);\n              e = new UnknownError(_context2.t0);\n              e.name = \"\".concat(capitalize(name), \"Error\");\n              throw e;\n\n            case 15:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[0, 9]]);\n    }));\n    return acc;\n  }, {});\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2NvcmUvZXJyb3JzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUlBLHNCQUFzQixHQUFHQyxtQkFBTyxDQUFDLG9IQUFELENBQXBDOztBQUVBQyw4Q0FBNkM7RUFDM0NHLEtBQUssRUFBRTtBQURvQyxDQUE3QztBQUdBRCwyQkFBQSxHQUE4QkEsb0JBQUEsR0FBdUJBLDBCQUFBLEdBQTZCQSxxQkFBQSxHQUF3QkEsd0JBQUEsR0FBMkJBLHNCQUFBLEdBQXlCQSx1QkFBQSxHQUEwQkEsMEJBQUEsR0FBNkJBLDZCQUFBLEdBQWdDLEtBQUssQ0FBMVA7QUFDQUEsMkJBQUEsR0FBOEJXLG1CQUE5QjtBQUNBWCxrQkFBQSxHQUFxQlksVUFBckI7QUFDQVosMEJBQUEsR0FBNkJhLGtCQUE3QjtBQUNBYixrQkFBQSxHQUFxQmMsVUFBckI7O0FBRUEsSUFBSUMsWUFBWSxHQUFHbkIsc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsc0ZBQUQsQ0FBUixDQUF6Qzs7QUFFQSxJQUFJbUIsa0JBQWtCLEdBQUdwQixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQywwR0FBRCxDQUFSLENBQS9DOztBQUVBLElBQUlvQix1QkFBdUIsR0FBR3JCLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLG9IQUFELENBQVIsQ0FBcEQ7O0FBRUEsSUFBSXFCLGdCQUFnQixHQUFHdEIsc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsc0dBQUQsQ0FBUixDQUE3Qzs7QUFFQSxJQUFJc0IsZ0JBQWdCLEdBQUd2QixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxzR0FBRCxDQUFSLENBQTdDOztBQUVBLElBQUl1QixhQUFhLEdBQUd4QixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxnR0FBRCxDQUFSLENBQTFDOztBQUVBLElBQUl3QixVQUFVLEdBQUd6QixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQywwRkFBRCxDQUFSLENBQXZDOztBQUVBLElBQUl5QiwyQkFBMkIsR0FB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QUEzQixDQUFKO2NBQ0E3RSxDQUFDLENBQUNPLElBQUYsR0FBUyxHQUFHYyxNQUFILENBQVV0RCxVQUFVLENBQUN3QyxJQUFELENBQXBCLEVBQTRCLE9BQTVCLENBQVQ7Y0FDQSxNQUFNUCxDQUFOOztZQUVGLEtBQUssRUFBTDtZQUNBLEtBQUssS0FBTDtjQUNFLE9BQU9xRixTQUFTLENBQUNQLElBQVYsRUFBUDtVQTVCSjtRQThCRDtNQUNGLENBakNNLEVBaUNKRSxRQWpDSSxFQWlDTSxJQWpDTixFQWlDWSxDQUFDLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBRCxDQWpDWixDQUFQO0lBa0NELENBMUMyQyxDQUFoQyxDQUFaO0lBMkNBLE9BQU9mLEdBQVA7RUFDRCxDQTdDTSxFQTZDSixFQTdDSSxDQUFQO0FBOENEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvY29yZS9lcnJvcnMuanM/ZGRjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlVuc3VwcG9ydGVkU3RyYXRlZ3kgPSBleHBvcnRzLlVua25vd25FcnJvciA9IGV4cG9ydHMuT0F1dGhDYWxsYmFja0Vycm9yID0gZXhwb3J0cy5NaXNzaW5nU2VjcmV0ID0gZXhwb3J0cy5NaXNzaW5nQXV0aG9yaXplID0gZXhwb3J0cy5NaXNzaW5nQWRhcHRlciA9IGV4cG9ydHMuTWlzc2luZ0FQSVJvdXRlID0gZXhwb3J0cy5JbnZhbGlkQ2FsbGJhY2tVcmwgPSBleHBvcnRzLkFjY291bnROb3RMaW5rZWRFcnJvciA9IHZvaWQgMDtcbmV4cG9ydHMuYWRhcHRlckVycm9ySGFuZGxlciA9IGFkYXB0ZXJFcnJvckhhbmRsZXI7XG5leHBvcnRzLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuZXhwb3J0cy5ldmVudHNFcnJvckhhbmRsZXIgPSBldmVudHNFcnJvckhhbmRsZXI7XG5leHBvcnRzLnVwcGVyU25ha2UgPSB1cHBlclNuYWtlO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF93cmFwTmF0aXZlU3VwZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXJcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFVua25vd25FcnJvciA9IGZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVW5rbm93bkVycm9yLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVW5rbm93bkVycm9yKTtcblxuICBmdW5jdGlvbiBVbmtub3duRXJyb3IoZXJyb3IpIHtcbiAgICB2YXIgX21lc3NhZ2U7XG5cbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBVbmtub3duRXJyb3IpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgKF9tZXNzYWdlID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpICE9PSBudWxsICYmIF9tZXNzYWdlICE9PSB2b2lkIDAgPyBfbWVzc2FnZSA6IGVycm9yKTtcbiAgICBfdGhpcy5uYW1lID0gXCJVbmtub3duRXJyb3JcIjtcbiAgICBfdGhpcy5jb2RlID0gZXJyb3IuY29kZTtcblxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBfdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFVua25vd25FcnJvciwgW3tcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICBzdGFjazogdGhpcy5zdGFja1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFVua25vd25FcnJvcjtcbn0oKDAsIF93cmFwTmF0aXZlU3VwZXIyLmRlZmF1bHQpKEVycm9yKSk7XG5cbmV4cG9ydHMuVW5rbm93bkVycm9yID0gVW5rbm93bkVycm9yO1xuXG52YXIgT0F1dGhDYWxsYmFja0Vycm9yID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3IpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoT0F1dGhDYWxsYmFja0Vycm9yLCBfVW5rbm93bkVycm9yKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihPQXV0aENhbGxiYWNrRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIE9BdXRoQ2FsbGJhY2tFcnJvcigpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgT0F1dGhDYWxsYmFja0Vycm9yKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpczIgPSBfc3VwZXIyLmNhbGwuYXBwbHkoX3N1cGVyMiwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzMiksIFwibmFtZVwiLCBcIk9BdXRoQ2FsbGJhY2tFcnJvclwiKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgcmV0dXJuICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKE9BdXRoQ2FsbGJhY2tFcnJvcik7XG59KFVua25vd25FcnJvcik7XG5cbmV4cG9ydHMuT0F1dGhDYWxsYmFja0Vycm9yID0gT0F1dGhDYWxsYmFja0Vycm9yO1xuXG52YXIgQWNjb3VudE5vdExpbmtlZEVycm9yID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3IyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEFjY291bnROb3RMaW5rZWRFcnJvciwgX1Vua25vd25FcnJvcjIpO1xuXG4gIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKEFjY291bnROb3RMaW5rZWRFcnJvcik7XG5cbiAgZnVuY3Rpb24gQWNjb3VudE5vdExpbmtlZEVycm9yKCkge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBBY2NvdW50Tm90TGlua2VkRXJyb3IpO1xuXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgX3RoaXMzID0gX3N1cGVyMy5jYWxsLmFwcGx5KF9zdXBlcjMsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczMpLCBcIm5hbWVcIiwgXCJBY2NvdW50Tm90TGlua2VkRXJyb3JcIik7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShBY2NvdW50Tm90TGlua2VkRXJyb3IpO1xufShVbmtub3duRXJyb3IpO1xuXG5leHBvcnRzLkFjY291bnROb3RMaW5rZWRFcnJvciA9IEFjY291bnROb3RMaW5rZWRFcnJvcjtcblxudmFyIE1pc3NpbmdBUElSb3V0ZSA9IGZ1bmN0aW9uIChfVW5rbm93bkVycm9yMykge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShNaXNzaW5nQVBJUm91dGUsIF9Vbmtub3duRXJyb3IzKTtcblxuICB2YXIgX3N1cGVyNCA9IF9jcmVhdGVTdXBlcihNaXNzaW5nQVBJUm91dGUpO1xuXG4gIGZ1bmN0aW9uIE1pc3NpbmdBUElSb3V0ZSgpIHtcbiAgICB2YXIgX3RoaXM0O1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgTWlzc2luZ0FQSVJvdXRlKTtcblxuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cblxuICAgIF90aGlzNCA9IF9zdXBlcjQuY2FsbC5hcHBseShfc3VwZXI0LCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM0KSwgXCJuYW1lXCIsIFwiTWlzc2luZ0FQSVJvdXRlRXJyb3JcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNCksIFwiY29kZVwiLCBcIk1JU1NJTkdfTkVYVEFVVEhfQVBJX1JPVVRFX0VSUk9SXCIpO1xuICAgIHJldHVybiBfdGhpczQ7XG4gIH1cblxuICByZXR1cm4gKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoTWlzc2luZ0FQSVJvdXRlKTtcbn0oVW5rbm93bkVycm9yKTtcblxuZXhwb3J0cy5NaXNzaW5nQVBJUm91dGUgPSBNaXNzaW5nQVBJUm91dGU7XG5cbnZhciBNaXNzaW5nU2VjcmV0ID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3I0KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKE1pc3NpbmdTZWNyZXQsIF9Vbmtub3duRXJyb3I0KTtcblxuICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihNaXNzaW5nU2VjcmV0KTtcblxuICBmdW5jdGlvbiBNaXNzaW5nU2VjcmV0KCkge1xuICAgIHZhciBfdGhpczU7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBNaXNzaW5nU2VjcmV0KTtcblxuICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgIH1cblxuICAgIF90aGlzNSA9IF9zdXBlcjUuY2FsbC5hcHBseShfc3VwZXI1LCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM1KSwgXCJuYW1lXCIsIFwiTWlzc2luZ1NlY3JldEVycm9yXCIpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczUpLCBcImNvZGVcIiwgXCJOT19TRUNSRVRcIik7XG4gICAgcmV0dXJuIF90aGlzNTtcbiAgfVxuXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShNaXNzaW5nU2VjcmV0KTtcbn0oVW5rbm93bkVycm9yKTtcblxuZXhwb3J0cy5NaXNzaW5nU2VjcmV0ID0gTWlzc2luZ1NlY3JldDtcblxudmFyIE1pc3NpbmdBdXRob3JpemUgPSBmdW5jdGlvbiAoX1Vua25vd25FcnJvcjUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoTWlzc2luZ0F1dGhvcml6ZSwgX1Vua25vd25FcnJvcjUpO1xuXG4gIHZhciBfc3VwZXI2ID0gX2NyZWF0ZVN1cGVyKE1pc3NpbmdBdXRob3JpemUpO1xuXG4gIGZ1bmN0aW9uIE1pc3NpbmdBdXRob3JpemUoKSB7XG4gICAgdmFyIF90aGlzNjtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIE1pc3NpbmdBdXRob3JpemUpO1xuXG4gICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgfVxuXG4gICAgX3RoaXM2ID0gX3N1cGVyNi5jYWxsLmFwcGx5KF9zdXBlcjYsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczYpLCBcIm5hbWVcIiwgXCJNaXNzaW5nQXV0aG9yaXplRXJyb3JcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNiksIFwiY29kZVwiLCBcIkNBTExCQUNLX0NSRURFTlRJQUxTX0hBTkRMRVJfRVJST1JcIik7XG4gICAgcmV0dXJuIF90aGlzNjtcbiAgfVxuXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShNaXNzaW5nQXV0aG9yaXplKTtcbn0oVW5rbm93bkVycm9yKTtcblxuZXhwb3J0cy5NaXNzaW5nQXV0aG9yaXplID0gTWlzc2luZ0F1dGhvcml6ZTtcblxudmFyIE1pc3NpbmdBZGFwdGVyID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3I2KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKE1pc3NpbmdBZGFwdGVyLCBfVW5rbm93bkVycm9yNik7XG5cbiAgdmFyIF9zdXBlcjcgPSBfY3JlYXRlU3VwZXIoTWlzc2luZ0FkYXB0ZXIpO1xuXG4gIGZ1bmN0aW9uIE1pc3NpbmdBZGFwdGVyKCkge1xuICAgIHZhciBfdGhpczc7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBNaXNzaW5nQWRhcHRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICAgIGFyZ3NbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgICB9XG5cbiAgICBfdGhpczcgPSBfc3VwZXI3LmNhbGwuYXBwbHkoX3N1cGVyNywgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNyksIFwibmFtZVwiLCBcIk1pc3NpbmdBZGFwdGVyRXJyb3JcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNyksIFwiY29kZVwiLCBcIkVNQUlMX1JFUVVJUkVTX0FEQVBURVJfRVJST1JcIik7XG4gICAgcmV0dXJuIF90aGlzNztcbiAgfVxuXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShNaXNzaW5nQWRhcHRlcik7XG59KFVua25vd25FcnJvcik7XG5cbmV4cG9ydHMuTWlzc2luZ0FkYXB0ZXIgPSBNaXNzaW5nQWRhcHRlcjtcblxudmFyIFVuc3VwcG9ydGVkU3RyYXRlZ3kgPSBmdW5jdGlvbiAoX1Vua25vd25FcnJvcjcpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVW5zdXBwb3J0ZWRTdHJhdGVneSwgX1Vua25vd25FcnJvcjcpO1xuXG4gIHZhciBfc3VwZXI4ID0gX2NyZWF0ZVN1cGVyKFVuc3VwcG9ydGVkU3RyYXRlZ3kpO1xuXG4gIGZ1bmN0aW9uIFVuc3VwcG9ydGVkU3RyYXRlZ3koKSB7XG4gICAgdmFyIF90aGlzODtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFVuc3VwcG9ydGVkU3RyYXRlZ3kpO1xuXG4gICAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43KSwgX2tleTcgPSAwOyBfa2V5NyA8IF9sZW43OyBfa2V5NysrKSB7XG4gICAgICBhcmdzW19rZXk3XSA9IGFyZ3VtZW50c1tfa2V5N107XG4gICAgfVxuXG4gICAgX3RoaXM4ID0gX3N1cGVyOC5jYWxsLmFwcGx5KF9zdXBlcjgsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczgpLCBcIm5hbWVcIiwgXCJVbnN1cHBvcnRlZFN0cmF0ZWd5RXJyb3JcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzOCksIFwiY29kZVwiLCBcIkNBTExCQUNLX0NSRURFTlRJQUxTX0pXVF9FUlJPUlwiKTtcbiAgICByZXR1cm4gX3RoaXM4O1xuICB9XG5cbiAgcmV0dXJuICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFVuc3VwcG9ydGVkU3RyYXRlZ3kpO1xufShVbmtub3duRXJyb3IpO1xuXG5leHBvcnRzLlVuc3VwcG9ydGVkU3RyYXRlZ3kgPSBVbnN1cHBvcnRlZFN0cmF0ZWd5O1xuXG52YXIgSW52YWxpZENhbGxiYWNrVXJsID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3I4KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEludmFsaWRDYWxsYmFja1VybCwgX1Vua25vd25FcnJvcjgpO1xuXG4gIHZhciBfc3VwZXI5ID0gX2NyZWF0ZVN1cGVyKEludmFsaWRDYWxsYmFja1VybCk7XG5cbiAgZnVuY3Rpb24gSW52YWxpZENhbGxiYWNrVXJsKCkge1xuICAgIHZhciBfdGhpczk7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBJbnZhbGlkQ2FsbGJhY2tVcmwpO1xuXG4gICAgZm9yICh2YXIgX2xlbjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW44KSwgX2tleTggPSAwOyBfa2V5OCA8IF9sZW44OyBfa2V5OCsrKSB7XG4gICAgICBhcmdzW19rZXk4XSA9IGFyZ3VtZW50c1tfa2V5OF07XG4gICAgfVxuXG4gICAgX3RoaXM5ID0gX3N1cGVyOS5jYWxsLmFwcGx5KF9zdXBlcjksIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczkpLCBcIm5hbWVcIiwgXCJJbnZhbGlkQ2FsbGJhY2tVcmxcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzOSksIFwiY29kZVwiLCBcIklOVkFMSURfQ0FMTEJBQ0tfVVJMX0VSUk9SXCIpO1xuICAgIHJldHVybiBfdGhpczk7XG4gIH1cblxuICByZXR1cm4gKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoSW52YWxpZENhbGxiYWNrVXJsKTtcbn0oVW5rbm93bkVycm9yKTtcblxuZXhwb3J0cy5JbnZhbGlkQ2FsbGJhY2tVcmwgPSBJbnZhbGlkQ2FsbGJhY2tVcmw7XG5cbmZ1bmN0aW9uIHVwcGVyU25ha2Uocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC8oW0EtWl0pL2csIFwiXyQxXCIpLnRvVXBwZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUocykge1xuICByZXR1cm4gXCJcIi5jb25jYXQoc1swXS50b1VwcGVyQ2FzZSgpKS5jb25jYXQocy5zbGljZSgxKSk7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c0Vycm9ySGFuZGxlcihtZXRob2RzLCBsb2dnZXIpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1ldGhvZHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBuYW1lKSB7XG4gICAgYWNjW25hbWVdID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICB2YXIgbWV0aG9kLFxuICAgICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgICBtZXRob2QgPSBtZXRob2RzW25hbWVdO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh2b2lkIDAsIF9hcmdzKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA3O1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIlwiLmNvbmNhdCh1cHBlclNuYWtlKG5hbWUpLCBcIl9FVkVOVF9FUlJPUlwiKSwgX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1swLCA3XV0pO1xuICAgIH0pKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGFkYXB0ZXJFcnJvckhhbmRsZXIoYWRhcHRlciwgbG9nZ2VyKSB7XG4gIGlmICghYWRhcHRlcikgcmV0dXJuO1xuICByZXR1cm4gT2JqZWN0LmtleXMoYWRhcHRlcikucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5hbWUpIHtcbiAgICBhY2NbbmFtZV0gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICB2YXIgX2xlbjksXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgICBfa2V5OSxcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgZSxcbiAgICAgICAgICBfYXJnczIgPSBhcmd1bWVudHM7XG5cbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAwO1xuXG4gICAgICAgICAgICAgIGZvciAoX2xlbjkgPSBfYXJnczIubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW45KSwgX2tleTkgPSAwOyBfa2V5OSA8IF9sZW45OyBfa2V5OSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5OV0gPSBfYXJnczJbX2tleTldO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiYWRhcHRlcl9cIi5jb25jYXQobmFtZSksIHtcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBtZXRob2QgPSBhZGFwdGVyW25hbWVdO1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodm9pZCAwLCBhcmdzKTtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA5O1xuICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiYWRhcHRlcl9lcnJvcl9cIi5jb25jYXQobmFtZSksIF9jb250ZXh0Mi50MCk7XG4gICAgICAgICAgICAgIGUgPSBuZXcgVW5rbm93bkVycm9yKF9jb250ZXh0Mi50MCk7XG4gICAgICAgICAgICAgIGUubmFtZSA9IFwiXCIuY29uY2F0KGNhcGl0YWxpemUobmFtZSksIFwiRXJyb3JcIik7XG4gICAgICAgICAgICAgIHRocm93IGU7XG5cbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbMCwgOV1dKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufSJdLCJuYW1lcyI6WyJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVW5zdXBwb3J0ZWRTdHJhdGVneSIsIlVua25vd25FcnJvciIsIk9BdXRoQ2FsbGJhY2tFcnJvciIsIk1pc3NpbmdTZWNyZXQiLCJNaXNzaW5nQXV0aG9yaXplIiwiTWlzc2luZ0FkYXB0ZXIiLCJNaXNzaW5nQVBJUm91dGUiLCJJbnZhbGlkQ2FsbGJhY2tVcmwiLCJBY2NvdW50Tm90TGlua2VkRXJyb3IiLCJhZGFwdGVyRXJyb3JIYW5kbGVyIiwiY2FwaXRhbGl6ZSIsImV2ZW50c0Vycm9ySGFuZGxlciIsInVwcGVyU25ha2UiLCJfcmVnZW5lcmF0b3IiLCJfYXN5bmNUb0dlbmVyYXRvcjIiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkMiIsIl9kZWZpbmVQcm9wZXJ0eTIiLCJfY2xhc3NDYWxsQ2hlY2syIiwiX2NyZWF0ZUNsYXNzMiIsIl9pbmhlcml0czIiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIiLCJfZ2V0UHJvdG90eXBlT2YyIiwiX3dyYXBOYXRpdmVTdXBlcjIiLCJfY3JlYXRlU3VwZXIiLCJEZXJpdmVkIiwiaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY3JlYXRlU3VwZXJJbnRlcm5hbCIsIlN1cGVyIiwiZGVmYXVsdCIsInJlc3VsdCIsIk5ld1RhcmdldCIsImNvbnN0cnVjdG9yIiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsImFyZ3VtZW50cyIsImFwcGx5Iiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInByb3RvdHlwZSIsInZhbHVlT2YiLCJjYWxsIiwiZSIsIl9FcnJvciIsIl9zdXBlciIsImVycm9yIiwiX21lc3NhZ2UiLCJfdGhpcyIsIm1lc3NhZ2UiLCJuYW1lIiwiY29kZSIsIkVycm9yIiwic3RhY2siLCJrZXkiLCJ0b0pTT04iLCJfVW5rbm93bkVycm9yIiwiX3N1cGVyMiIsIl90aGlzMiIsIl9sZW4iLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiY29uY2F0IiwiX1Vua25vd25FcnJvcjIiLCJfc3VwZXIzIiwiX3RoaXMzIiwiX2xlbjIiLCJfa2V5MiIsIl9Vbmtub3duRXJyb3IzIiwiX3N1cGVyNCIsIl90aGlzNCIsIl9sZW4zIiwiX2tleTMiLCJfVW5rbm93bkVycm9yNCIsIl9zdXBlcjUiLCJfdGhpczUiLCJfbGVuNCIsIl9rZXk0IiwiX1Vua25vd25FcnJvcjUiLCJfc3VwZXI2IiwiX3RoaXM2IiwiX2xlbjUiLCJfa2V5NSIsIl9Vbmtub3duRXJyb3I2IiwiX3N1cGVyNyIsIl90aGlzNyIsIl9sZW42IiwiX2tleTYiLCJfVW5rbm93bkVycm9yNyIsIl9zdXBlcjgiLCJfdGhpczgiLCJfbGVuNyIsIl9rZXk3IiwiX1Vua25vd25FcnJvcjgiLCJfc3VwZXI5IiwiX3RoaXM5IiwiX2xlbjgiLCJfa2V5OCIsInMiLCJyZXBsYWNlIiwidG9VcHBlckNhc2UiLCJzbGljZSIsIm1ldGhvZHMiLCJsb2dnZXIiLCJrZXlzIiwicmVkdWNlIiwiYWNjIiwibWFyayIsIl9jYWxsZWUiLCJtZXRob2QiLCJfYXJncyIsIndyYXAiLCJfY2FsbGVlJCIsIl9jb250ZXh0IiwicHJldiIsIm5leHQiLCJhYnJ1cHQiLCJzZW50IiwidDAiLCJzdG9wIiwiYWRhcHRlciIsIl9jYWxsZWUyIiwiX2xlbjkiLCJfa2V5OSIsIl9hcmdzMiIsIl9jYWxsZWUyJCIsIl9jb250ZXh0MiIsImRlYnVnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next-auth/core/errors.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/react/index.js":
/*!***********************************************!*\
  !*** ./node_modules/next-auth/react/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar _exportNames = {\n  useSession: true,\n  getSession: true,\n  getCsrfToken: true,\n  getProviders: true,\n  signIn: true,\n  signOut: true,\n  SessionProvider: true\n};\nexports.SessionProvider = SessionProvider;\nexports.getCsrfToken = getCsrfToken;\nexports.getProviders = getProviders;\nexports.getSession = getSession;\nexports.signIn = signIn;\nexports.signOut = signOut;\nexports.useSession = useSession;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _logger2 = _interopRequireWildcard(__webpack_require__(/*! ../utils/logger */ \"./node_modules/next-auth/utils/logger.js\"));\n\nvar _parseUrl = _interopRequireDefault(__webpack_require__(/*! ../utils/parse-url */ \"./node_modules/next-auth/utils/parse-url.js\"));\n\nvar _utils = __webpack_require__(/*! ../client/_utils */ \"./node_modules/next-auth/client/_utils.js\");\n\nvar _jsxRuntime = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/next-auth/react/types.js\");\n\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _types[key];\n    }\n  });\n});\n\nvar _process$env$NEXTAUTH, _ref, _process$env$NEXTAUTH2, _process$env$NEXTAUTH3;\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nvar __NEXTAUTH = {\n  baseUrl: (0, _parseUrl.default)((_process$env$NEXTAUTH = process.env.NEXTAUTH_URL) !== null && _process$env$NEXTAUTH !== void 0 ? _process$env$NEXTAUTH : process.env.VERCEL_URL).origin,\n  basePath: (0, _parseUrl.default)(process.env.NEXTAUTH_URL).path,\n  baseUrlServer: (0, _parseUrl.default)((_ref = (_process$env$NEXTAUTH2 = process.env.NEXTAUTH_URL_INTERNAL) !== null && _process$env$NEXTAUTH2 !== void 0 ? _process$env$NEXTAUTH2 : process.env.NEXTAUTH_URL) !== null && _ref !== void 0 ? _ref : process.env.VERCEL_URL).origin,\n  basePathServer: (0, _parseUrl.default)((_process$env$NEXTAUTH3 = process.env.NEXTAUTH_URL_INTERNAL) !== null && _process$env$NEXTAUTH3 !== void 0 ? _process$env$NEXTAUTH3 : process.env.NEXTAUTH_URL).path,\n  _lastSync: 0,\n  _session: undefined,\n  _getSession: function _getSession() {}\n};\nvar broadcast = (0, _utils.BroadcastChannel)();\nvar logger = (0, _logger2.proxyLogger)(_logger2.default, __NEXTAUTH.basePath);\nvar SessionContext = React.createContext(undefined);\n\nfunction useSession(options) {\n  var value = React.useContext(SessionContext);\n\n  if (!value && \"development\" !== \"production\") {\n    throw new Error(\"[next-auth]: `useSession` must be wrapped in a <SessionProvider />\");\n  }\n\n  var _ref2 = options !== null && options !== void 0 ? options : {},\n      required = _ref2.required,\n      onUnauthenticated = _ref2.onUnauthenticated;\n\n  var requiredAndNotLoading = required && value.status === \"unauthenticated\";\n  React.useEffect(function () {\n    if (requiredAndNotLoading) {\n      var url = \"/api/auth/signin?\".concat(new URLSearchParams({\n        error: \"SessionRequired\",\n        callbackUrl: window.location.href\n      }));\n      if (onUnauthenticated) onUnauthenticated();else window.location.href = url;\n    }\n  }, [requiredAndNotLoading, onUnauthenticated]);\n\n  if (requiredAndNotLoading) {\n    return {\n      data: value.data,\n      status: \"loading\"\n    };\n  }\n\n  return value;\n}\n\nfunction getSession(_x) {\n  return _getSession2.apply(this, arguments);\n}\n\nfunction _getSession2() {\n  _getSession2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(params) {\n    var _params$broadcast;\n\n    var session;\n    return _regenerator.default.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return (0, _utils.fetchData)(\"session\", __NEXTAUTH, logger, params);\n\n          case 2:\n            session = _context2.sent;\n\n            if ((_params$broadcast = params === null || params === void 0 ? void 0 : params.broadcast) !== null && _params$broadcast !== void 0 ? _params$broadcast : true) {\n              broadcast.post({\n                event: \"session\",\n                data: {\n                  trigger: \"getSession\"\n                }\n              });\n            }\n\n            return _context2.abrupt(\"return\", session);\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getSession2.apply(this, arguments);\n}\n\nfunction getCsrfToken(_x2) {\n  return _getCsrfToken.apply(this, arguments);\n}\n\nfunction _getCsrfToken() {\n  _getCsrfToken = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(params) {\n    var response;\n    return _regenerator.default.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return (0, _utils.fetchData)(\"csrf\", __NEXTAUTH, logger, params);\n\n          case 2:\n            response = _context3.sent;\n            return _context3.abrupt(\"return\", response === null || response === void 0 ? void 0 : response.csrfToken);\n\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getCsrfToken.apply(this, arguments);\n}\n\nfunction getProviders() {\n  return _getProviders.apply(this, arguments);\n}\n\nfunction _getProviders() {\n  _getProviders = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4() {\n    return _regenerator.default.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return (0, _utils.fetchData)(\"providers\", __NEXTAUTH, logger);\n\n          case 2:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 3:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _getProviders.apply(this, arguments);\n}\n\nfunction signIn(_x3, _x4, _x5) {\n  return _signIn.apply(this, arguments);\n}\n\nfunction _signIn() {\n  _signIn = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5(provider, options, authorizationParams) {\n    var _ref5, _ref5$callbackUrl, callbackUrl, _ref5$redirect, redirect, baseUrl, providers, isCredentials, isEmail, isSupportingReturn, signInUrl, _signInUrl, res, data, _data$url, url, error;\n\n    return _regenerator.default.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _ref5 = options !== null && options !== void 0 ? options : {}, _ref5$callbackUrl = _ref5.callbackUrl, callbackUrl = _ref5$callbackUrl === void 0 ? window.location.href : _ref5$callbackUrl, _ref5$redirect = _ref5.redirect, redirect = _ref5$redirect === void 0 ? true : _ref5$redirect;\n            baseUrl = (0, _utils.apiBaseUrl)(__NEXTAUTH);\n            _context5.next = 4;\n            return getProviders();\n\n          case 4:\n            providers = _context5.sent;\n\n            if (providers) {\n              _context5.next = 8;\n              break;\n            }\n\n            window.location.href = \"\".concat(baseUrl, \"/error\");\n            return _context5.abrupt(\"return\");\n\n          case 8:\n            if (!(!provider || !(provider in providers))) {\n              _context5.next = 11;\n              break;\n            }\n\n            window.location.href = \"\".concat(baseUrl, \"/signin?\").concat(new URLSearchParams({\n              callbackUrl: callbackUrl\n            }));\n            return _context5.abrupt(\"return\");\n\n          case 11:\n            isCredentials = providers[provider].type === \"credentials\";\n            isEmail = providers[provider].type === \"email\";\n            isSupportingReturn = isCredentials || isEmail;\n            signInUrl = \"\".concat(baseUrl, \"/\").concat(isCredentials ? \"callback\" : \"signin\", \"/\").concat(provider);\n            _signInUrl = \"\".concat(signInUrl, \"?\").concat(new URLSearchParams(authorizationParams));\n            _context5.t0 = fetch;\n            _context5.t1 = _signInUrl;\n            _context5.t2 = {\n              \"Content-Type\": \"application/x-www-form-urlencoded\"\n            };\n            _context5.t3 = URLSearchParams;\n            _context5.t4 = _objectSpread;\n            _context5.t5 = _objectSpread({}, options);\n            _context5.t6 = {};\n            _context5.next = 25;\n            return getCsrfToken();\n\n          case 25:\n            _context5.t7 = _context5.sent;\n            _context5.t8 = callbackUrl;\n            _context5.t9 = {\n              csrfToken: _context5.t7,\n              callbackUrl: _context5.t8,\n              json: true\n            };\n            _context5.t10 = (0, _context5.t4)(_context5.t5, _context5.t6, _context5.t9);\n            _context5.t11 = new _context5.t3(_context5.t10);\n            _context5.t12 = {\n              method: \"post\",\n              headers: _context5.t2,\n              body: _context5.t11\n            };\n            _context5.next = 33;\n            return (0, _context5.t0)(_context5.t1, _context5.t12);\n\n          case 33:\n            res = _context5.sent;\n            _context5.next = 36;\n            return res.json();\n\n          case 36:\n            data = _context5.sent;\n\n            if (!(redirect || !isSupportingReturn)) {\n              _context5.next = 42;\n              break;\n            }\n\n            url = (_data$url = data.url) !== null && _data$url !== void 0 ? _data$url : callbackUrl;\n            window.location.href = url;\n            if (url.includes(\"#\")) window.location.reload();\n            return _context5.abrupt(\"return\");\n\n          case 42:\n            error = new URL(data.url).searchParams.get(\"error\");\n\n            if (!res.ok) {\n              _context5.next = 46;\n              break;\n            }\n\n            _context5.next = 46;\n            return __NEXTAUTH._getSession({\n              event: \"storage\"\n            });\n\n          case 46:\n            return _context5.abrupt(\"return\", {\n              error: error,\n              status: res.status,\n              ok: res.ok,\n              url: error ? null : data.url\n            });\n\n          case 47:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _signIn.apply(this, arguments);\n}\n\nfunction signOut(_x6) {\n  return _signOut.apply(this, arguments);\n}\n\nfunction _signOut() {\n  _signOut = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee6(options) {\n    var _options$redirect;\n\n    var _ref6, _ref6$callbackUrl, callbackUrl, baseUrl, fetchOptions, res, data, _data$url2, url;\n\n    return _regenerator.default.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _ref6 = options !== null && options !== void 0 ? options : {}, _ref6$callbackUrl = _ref6.callbackUrl, callbackUrl = _ref6$callbackUrl === void 0 ? window.location.href : _ref6$callbackUrl;\n            baseUrl = (0, _utils.apiBaseUrl)(__NEXTAUTH);\n            _context6.t0 = {\n              \"Content-Type\": \"application/x-www-form-urlencoded\"\n            };\n            _context6.t1 = URLSearchParams;\n            _context6.next = 6;\n            return getCsrfToken();\n\n          case 6:\n            _context6.t2 = _context6.sent;\n            _context6.t3 = callbackUrl;\n            _context6.t4 = {\n              csrfToken: _context6.t2,\n              callbackUrl: _context6.t3,\n              json: true\n            };\n            _context6.t5 = new _context6.t1(_context6.t4);\n            fetchOptions = {\n              method: \"post\",\n              headers: _context6.t0,\n              body: _context6.t5\n            };\n            _context6.next = 13;\n            return fetch(\"\".concat(baseUrl, \"/signout\"), fetchOptions);\n\n          case 13:\n            res = _context6.sent;\n            _context6.next = 16;\n            return res.json();\n\n          case 16:\n            data = _context6.sent;\n            broadcast.post({\n              event: \"session\",\n              data: {\n                trigger: \"signout\"\n              }\n            });\n\n            if (!((_options$redirect = options === null || options === void 0 ? void 0 : options.redirect) !== null && _options$redirect !== void 0 ? _options$redirect : true)) {\n              _context6.next = 23;\n              break;\n            }\n\n            url = (_data$url2 = data.url) !== null && _data$url2 !== void 0 ? _data$url2 : callbackUrl;\n            window.location.href = url;\n            if (url.includes(\"#\")) window.location.reload();\n            return _context6.abrupt(\"return\");\n\n          case 23:\n            _context6.next = 25;\n            return __NEXTAUTH._getSession({\n              event: \"storage\"\n            });\n\n          case 25:\n            return _context6.abrupt(\"return\", data);\n\n          case 26:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _signOut.apply(this, arguments);\n}\n\nfunction SessionProvider(props) {\n  var children = props.children,\n      basePath = props.basePath;\n  if (basePath) __NEXTAUTH.basePath = basePath;\n  var hasInitialSession = props.session !== undefined;\n  __NEXTAUTH._lastSync = hasInitialSession ? (0, _utils.now)() : 0;\n\n  var _React$useState = React.useState(function () {\n    if (hasInitialSession) __NEXTAUTH._session = props.session;\n    return props.session;\n  }),\n      _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),\n      session = _React$useState2[0],\n      setSession = _React$useState2[1];\n\n  var _React$useState3 = React.useState(!hasInitialSession),\n      _React$useState4 = (0, _slicedToArray2.default)(_React$useState3, 2),\n      loading = _React$useState4[0],\n      setLoading = _React$useState4[1];\n\n  React.useEffect(function () {\n    __NEXTAUTH._getSession = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {\n      var _ref4,\n          event,\n          storageEvent,\n          _args = arguments;\n\n      return _regenerator.default.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _ref4 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, event = _ref4.event;\n              _context.prev = 1;\n              storageEvent = event === \"storage\";\n\n              if (!(storageEvent || __NEXTAUTH._session === undefined)) {\n                _context.next = 10;\n                break;\n              }\n\n              __NEXTAUTH._lastSync = (0, _utils.now)();\n              _context.next = 7;\n              return getSession({\n                broadcast: !storageEvent\n              });\n\n            case 7:\n              __NEXTAUTH._session = _context.sent;\n              setSession(__NEXTAUTH._session);\n              return _context.abrupt(\"return\");\n\n            case 10:\n              if (!(!event || __NEXTAUTH._session === null || (0, _utils.now)() < __NEXTAUTH._lastSync)) {\n                _context.next = 12;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 12:\n              __NEXTAUTH._lastSync = (0, _utils.now)();\n              _context.next = 15;\n              return getSession();\n\n            case 15:\n              __NEXTAUTH._session = _context.sent;\n              setSession(__NEXTAUTH._session);\n              _context.next = 22;\n              break;\n\n            case 19:\n              _context.prev = 19;\n              _context.t0 = _context[\"catch\"](1);\n              logger.error(\"CLIENT_SESSION_ERROR\", _context.t0);\n\n            case 22:\n              _context.prev = 22;\n              setLoading(false);\n              return _context.finish(22);\n\n            case 25:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 19, 22, 25]]);\n    }));\n\n    __NEXTAUTH._getSession();\n\n    return function () {\n      __NEXTAUTH._lastSync = 0;\n      __NEXTAUTH._session = undefined;\n\n      __NEXTAUTH._getSession = function () {};\n    };\n  }, []);\n  React.useEffect(function () {\n    var unsubscribe = broadcast.receive(function () {\n      return __NEXTAUTH._getSession({\n        event: \"storage\"\n      });\n    });\n    return function () {\n      return unsubscribe();\n    };\n  }, []);\n  React.useEffect(function () {\n    var _props$refetchOnWindo = props.refetchOnWindowFocus,\n        refetchOnWindowFocus = _props$refetchOnWindo === void 0 ? true : _props$refetchOnWindo;\n\n    var visibilityHandler = function visibilityHandler() {\n      if (refetchOnWindowFocus && document.visibilityState === \"visible\") __NEXTAUTH._getSession({\n        event: \"visibilitychange\"\n      });\n    };\n\n    document.addEventListener(\"visibilitychange\", visibilityHandler, false);\n    return function () {\n      return document.removeEventListener(\"visibilitychange\", visibilityHandler, false);\n    };\n  }, [props.refetchOnWindowFocus]);\n  React.useEffect(function () {\n    var refetchInterval = props.refetchInterval;\n\n    if (refetchInterval) {\n      var refetchIntervalTimer = setInterval(function () {\n        if (__NEXTAUTH._session) {\n          __NEXTAUTH._getSession({\n            event: \"poll\"\n          });\n        }\n      }, refetchInterval * 1000);\n      return function () {\n        return clearInterval(refetchIntervalTimer);\n      };\n    }\n  }, [props.refetchInterval]);\n  var value = React.useMemo(function () {\n    return {\n      data: session,\n      status: loading ? \"loading\" : session ? \"authenticated\" : \"unauthenticated\"\n    };\n  }, [session, loading]);\n  return (0, _jsxRuntime.jsx)(SessionContext.Provider, {\n    value: value,\n    children: children\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTs7QUFFYixJQUFJQSxzQkFBc0IsR0FBR0MsbUJBQU8sQ0FBQyxvSEFBRCxDQUFwQzs7QUFFQSxJQUFJQyxPQUFPLEdBQUdELG1CQUFPLENBQUMsc0ZBQUQsQ0FBckI7O0FBRUFFLDhDQUE2QztFQUMzQ0csS0FBSyxFQUFFO0FBRG9DLENBQTdDO0FBR0EsSUFBSUMsWUFBWSxHQUFHO0VBQ2pCQyxVQUFVLEVBQUUsSUFESztFQUVqQkMsVUFBVSxFQUFFLElBRks7RUFHakJDLFlBQVksRUFBRSxJQUhHO0VBSWpCQyxZQUFZLEVBQUUsSUFKRztFQUtqQkMsTUFBTSxFQUFFLElBTFM7RUFNakJDLE9BQU8sRUFBRSxJQU5RO0VBT2pCQyxlQUFlLEVBQUU7QUFQQSxDQUFuQjtBQVNBVCx1QkFBQSxHQUEwQlMsZUFBMUI7QUFDQVQsb0JBQUEsR0FBdUJLLFlBQXZCO0FBQ0FMLG9CQUFBLEdBQXVCTSxZQUF2QjtBQUNBTixrQkFBQSxHQUFxQkksVUFBckI7QUFDQUosY0FBQSxHQUFpQk8sTUFBakI7QUFDQVAsZUFBQSxHQUFrQlEsT0FBbEI7QUFDQVIsa0JBQUEsR0FBcUJHLFVBQXJCOztBQUVBLElBQUlPLFlBQVksR0FBR2Ysc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsc0ZBQUQsQ0FBUixDQUF6Qzs7QUFFQSxJQUFJZSxnQkFBZ0IsR0FBR2hCLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLHNHQUFELENBQVIsQ0FBN0M7O0FBRUEsSUFBSWdCLGVBQWUsR0FBR2pCLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLG9HQUFELENBQVIsQ0FBNUM7O0FBRUEsSUFBSWlCLGtCQUFrQixHQUFHbEIsc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsMEdBQUQsQ0FBUixDQUEvQzs7QUFFQSxJQUFJa0IsS0FBSyxHQUFHQyx1QkFBdUIsQ0FBQ25CLG1CQUFPLENBQUMsNENBQUQsQ0FBUixD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MUIsSUFBSTRILGVBQWUsR0FBRzVCLEtBQUssQ0FBQzRCLGVBQTVCOztJQUVBLElBQUlBLGVBQUosRUFBcUI7TUFDbkIsSUFBSUMsb0JBQW9CLEdBQUdDLFdBQVcsQ0FBQyxZQUFZO1FBQ2pELElBQUk3SixVQUFVLENBQUNhLFFBQWYsRUFBeUI7VUFDdkJiLFVBQVUsQ0FBQ2UsV0FBWCxDQUF1QjtZQUNyQnlDLEtBQUssRUFBRTtVQURjLENBQXZCO1FBR0Q7TUFDRixDQU5xQyxFQU1uQ21HLGVBQWUsR0FBRyxJQU5pQixDQUF0QztNQU9BLE9BQU8sWUFBWTtRQUNqQixPQUFPRyxhQUFhLENBQUNGLG9CQUFELENBQXBCO01BQ0QsQ0FGRDtJQUdEO0VBQ0YsQ0FmRCxFQWVHLENBQUM3QixLQUFLLENBQUM0QixlQUFQLENBZkg7RUFnQkEsSUFBSTNOLEtBQUssR0FBR2EsS0FBSyxDQUFDa04sT0FBTixDQUFjLFlBQVk7SUFDcEMsT0FBTztNQUNMdkgsSUFBSSxFQUFFTyxPQUREO01BRUxqQixNQUFNLEVBQUUyRyxPQUFPLEdBQUcsU0FBSCxHQUFlMUYsT0FBTyxHQUFHLGVBQUgsR0FBcUI7SUFGckQsQ0FBUDtFQUlELENBTFcsRUFLVCxDQUFDQSxPQUFELEVBQVUwRixPQUFWLENBTFMsQ0FBWjtFQU1BLE9BQU8sQ0FBQyxHQUFHdkwsV0FBVyxDQUFDOE0sR0FBaEIsRUFBcUI1SSxjQUFjLENBQUM2SSxRQUFwQyxFQUE4QztJQUNuRGpPLEtBQUssRUFBRUEsS0FENEM7SUFFbkRnTSxRQUFRLEVBQUVBO0VBRnlDLENBQTlDLENBQVA7QUFJRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0L2luZGV4LmpzP2MxOWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBfZXhwb3J0TmFtZXMgPSB7XG4gIHVzZVNlc3Npb246IHRydWUsXG4gIGdldFNlc3Npb246IHRydWUsXG4gIGdldENzcmZUb2tlbjogdHJ1ZSxcbiAgZ2V0UHJvdmlkZXJzOiB0cnVlLFxuICBzaWduSW46IHRydWUsXG4gIHNpZ25PdXQ6IHRydWUsXG4gIFNlc3Npb25Qcm92aWRlcjogdHJ1ZVxufTtcbmV4cG9ydHMuU2Vzc2lvblByb3ZpZGVyID0gU2Vzc2lvblByb3ZpZGVyO1xuZXhwb3J0cy5nZXRDc3JmVG9rZW4gPSBnZXRDc3JmVG9rZW47XG5leHBvcnRzLmdldFByb3ZpZGVycyA9IGdldFByb3ZpZGVycztcbmV4cG9ydHMuZ2V0U2Vzc2lvbiA9IGdldFNlc3Npb247XG5leHBvcnRzLnNpZ25JbiA9IHNpZ25JbjtcbmV4cG9ydHMuc2lnbk91dCA9IHNpZ25PdXQ7XG5leHBvcnRzLnVzZVNlc3Npb24gPSB1c2VTZXNzaW9uO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5XCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfbG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuLi91dGlscy9sb2dnZXJcIikpO1xuXG52YXIgX3BhcnNlVXJsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvcGFyc2UtdXJsXCIpKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi9jbGllbnQvX3V0aWxzXCIpO1xuXG52YXIgX2pzeFJ1bnRpbWUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxuT2JqZWN0LmtleXMoX3R5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfdHlwZXNba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfdHlwZXNba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBfcHJvY2VzcyRlbnYkTkVYVEFVVEgsIF9yZWYsIF9wcm9jZXNzJGVudiRORVhUQVVUSDIsIF9wcm9jZXNzJGVudiRORVhUQVVUSDM7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgX19ORVhUQVVUSCA9IHtcbiAgYmFzZVVybDogKDAsIF9wYXJzZVVybC5kZWZhdWx0KSgoX3Byb2Nlc3MkZW52JE5FWFRBVVRIID0gcHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMKSAhPT0gbnVsbCAmJiBfcHJvY2VzcyRlbnYkTkVYVEFVVEggIT09IHZvaWQgMCA/IF9wcm9jZXNzJGVudiRORVhUQVVUSCA6IHByb2Nlc3MuZW52LlZFUkNFTF9VUkwpLm9yaWdpbixcbiAgYmFzZVBhdGg6ICgwLCBfcGFyc2VVcmwuZGVmYXVsdCkocHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMKS5wYXRoLFxuICBiYXNlVXJsU2VydmVyOiAoMCwgX3BhcnNlVXJsLmRlZmF1bHQpKChfcmVmID0gKF9wcm9jZXNzJGVudiRORVhUQVVUSDIgPSBwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkxfSU5URVJOQUwpICE9PSBudWxsICYmIF9wcm9jZXNzJGVudiRORVhUQVVUSDIgIT09IHZvaWQgMCA/IF9wcm9jZXNzJGVudiRORVhUQVVUSDIgOiBwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkwpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiBwcm9jZXNzLmVudi5WRVJDRUxfVVJMKS5vcmlnaW4sXG4gIGJhc2VQYXRoU2VydmVyOiAoMCwgX3BhcnNlVXJsLmRlZmF1bHQpKChfcHJvY2VzcyRlbnYkTkVYVEFVVEgzID0gcHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMX0lOVEVSTkFMKSAhPT0gbnVsbCAmJiBfcHJvY2VzcyRlbnYkTkVYVEFVVEgzICE9PSB2b2lkIDAgPyBfcHJvY2VzcyRlbnYkTkVYVEFVVEgzIDogcHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMKS5wYXRoLFxuICBfbGFzdFN5bmM6IDAsXG4gIF9zZXNzaW9uOiB1bmRlZmluZWQsXG4gIF9nZXRTZXNzaW9uOiBmdW5jdGlvbiBfZ2V0U2Vzc2lvbigpIHt9XG59O1xudmFyIGJyb2FkY2FzdCA9ICgwLCBfdXRpbHMuQnJvYWRjYXN0Q2hhbm5lbCkoKTtcbnZhciBsb2dnZXIgPSAoMCwgX2xvZ2dlcjIucHJveHlMb2dnZXIpKF9sb2dnZXIyLmRlZmF1bHQsIF9fTkVYVEFVVEguYmFzZVBhdGgpO1xudmFyIFNlc3Npb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuXG5mdW5jdGlvbiB1c2VTZXNzaW9uKG9wdGlvbnMpIHtcbiAgdmFyIHZhbHVlID0gUmVhY3QudXNlQ29udGV4dChTZXNzaW9uQ29udGV4dCk7XG5cbiAgaWYgKCF2YWx1ZSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbmV4dC1hdXRoXTogYHVzZVNlc3Npb25gIG11c3QgYmUgd3JhcHBlZCBpbiBhIDxTZXNzaW9uUHJvdmlkZXIgLz5cIik7XG4gIH1cblxuICB2YXIgX3JlZjIgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSxcbiAgICAgIHJlcXVpcmVkID0gX3JlZjIucmVxdWlyZWQsXG4gICAgICBvblVuYXV0aGVudGljYXRlZCA9IF9yZWYyLm9uVW5hdXRoZW50aWNhdGVkO1xuXG4gIHZhciByZXF1aXJlZEFuZE5vdExvYWRpbmcgPSByZXF1aXJlZCAmJiB2YWx1ZS5zdGF0dXMgPT09IFwidW5hdXRoZW50aWNhdGVkXCI7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJlcXVpcmVkQW5kTm90TG9hZGluZykge1xuICAgICAgdmFyIHVybCA9IFwiL2FwaS9hdXRoL3NpZ25pbj9cIi5jb25jYXQobmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGVycm9yOiBcIlNlc3Npb25SZXF1aXJlZFwiLFxuICAgICAgICBjYWxsYmFja1VybDogd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICAgIH0pKTtcbiAgICAgIGlmIChvblVuYXV0aGVudGljYXRlZCkgb25VbmF1dGhlbnRpY2F0ZWQoKTtlbHNlIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgIH1cbiAgfSwgW3JlcXVpcmVkQW5kTm90TG9hZGluZywgb25VbmF1dGhlbnRpY2F0ZWRdKTtcblxuICBpZiAocmVxdWlyZWRBbmROb3RMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHZhbHVlLmRhdGEsXG4gICAgICBzdGF0dXM6IFwibG9hZGluZ1wiXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Vzc2lvbihfeCkge1xuICByZXR1cm4gX2dldFNlc3Npb24yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRTZXNzaW9uMigpIHtcbiAgX2dldFNlc3Npb24yID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHBhcmFtcykge1xuICAgIHZhciBfcGFyYW1zJGJyb2FkY2FzdDtcblxuICAgIHZhciBzZXNzaW9uO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmZldGNoRGF0YSkoXCJzZXNzaW9uXCIsIF9fTkVYVEFVVEgsIGxvZ2dlciwgcGFyYW1zKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHNlc3Npb24gPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgaWYgKChfcGFyYW1zJGJyb2FkY2FzdCA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5icm9hZGNhc3QpICE9PSBudWxsICYmIF9wYXJhbXMkYnJvYWRjYXN0ICE9PSB2b2lkIDAgPyBfcGFyYW1zJGJyb2FkY2FzdCA6IHRydWUpIHtcbiAgICAgICAgICAgICAgYnJvYWRjYXN0LnBvc3Qoe1xuICAgICAgICAgICAgICAgIGV2ZW50OiBcInNlc3Npb25cIixcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICB0cmlnZ2VyOiBcImdldFNlc3Npb25cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHNlc3Npb24pO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0U2Vzc2lvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q3NyZlRva2VuKF94Mikge1xuICByZXR1cm4gX2dldENzcmZUb2tlbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0Q3NyZlRva2VuKCkge1xuICBfZ2V0Q3NyZlRva2VuID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKHBhcmFtcykge1xuICAgIHZhciByZXNwb25zZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF91dGlscy5mZXRjaERhdGEpKFwiY3NyZlwiLCBfX05FWFRBVVRILCBsb2dnZXIsIHBhcmFtcyk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmNzcmZUb2tlbik7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRDc3JmVG9rZW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvdmlkZXJzKCkge1xuICByZXR1cm4gX2dldFByb3ZpZGVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdmlkZXJzKCkge1xuICBfZ2V0UHJvdmlkZXJzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KCkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmZldGNoRGF0YSkoXCJwcm92aWRlcnNcIiwgX19ORVhUQVVUSCwgbG9nZ2VyKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0KTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFByb3ZpZGVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBzaWduSW4oX3gzLCBfeDQsIF94NSkge1xuICByZXR1cm4gX3NpZ25Jbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfc2lnbkluKCkge1xuICBfc2lnbkluID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KHByb3ZpZGVyLCBvcHRpb25zLCBhdXRob3JpemF0aW9uUGFyYW1zKSB7XG4gICAgdmFyIF9yZWY1LCBfcmVmNSRjYWxsYmFja1VybCwgY2FsbGJhY2tVcmwsIF9yZWY1JHJlZGlyZWN0LCByZWRpcmVjdCwgYmFzZVVybCwgcHJvdmlkZXJzLCBpc0NyZWRlbnRpYWxzLCBpc0VtYWlsLCBpc1N1cHBvcnRpbmdSZXR1cm4sIHNpZ25JblVybCwgX3NpZ25JblVybCwgcmVzLCBkYXRhLCBfZGF0YSR1cmwsIHVybCwgZXJyb3I7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfcmVmNSA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCBfcmVmNSRjYWxsYmFja1VybCA9IF9yZWY1LmNhbGxiYWNrVXJsLCBjYWxsYmFja1VybCA9IF9yZWY1JGNhbGxiYWNrVXJsID09PSB2b2lkIDAgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6IF9yZWY1JGNhbGxiYWNrVXJsLCBfcmVmNSRyZWRpcmVjdCA9IF9yZWY1LnJlZGlyZWN0LCByZWRpcmVjdCA9IF9yZWY1JHJlZGlyZWN0ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjUkcmVkaXJlY3Q7XG4gICAgICAgICAgICBiYXNlVXJsID0gKDAsIF91dGlscy5hcGlCYXNlVXJsKShfX05FWFRBVVRIKTtcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiBnZXRQcm92aWRlcnMoKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHByb3ZpZGVycyA9IF9jb250ZXh0NS5zZW50O1xuXG4gICAgICAgICAgICBpZiAocHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gXCJcIi5jb25jYXQoYmFzZVVybCwgXCIvZXJyb3JcIik7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGlmICghKCFwcm92aWRlciB8fCAhKHByb3ZpZGVyIGluIHByb3ZpZGVycykpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IFwiXCIuY29uY2F0KGJhc2VVcmwsIFwiL3NpZ25pbj9cIikuY29uY2F0KG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgICBjYWxsYmFja1VybDogY2FsbGJhY2tVcmxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGlzQ3JlZGVudGlhbHMgPSBwcm92aWRlcnNbcHJvdmlkZXJdLnR5cGUgPT09IFwiY3JlZGVudGlhbHNcIjtcbiAgICAgICAgICAgIGlzRW1haWwgPSBwcm92aWRlcnNbcHJvdmlkZXJdLnR5cGUgPT09IFwiZW1haWxcIjtcbiAgICAgICAgICAgIGlzU3VwcG9ydGluZ1JldHVybiA9IGlzQ3JlZGVudGlhbHMgfHwgaXNFbWFpbDtcbiAgICAgICAgICAgIHNpZ25JblVybCA9IFwiXCIuY29uY2F0KGJhc2VVcmwsIFwiL1wiKS5jb25jYXQoaXNDcmVkZW50aWFscyA/IFwiY2FsbGJhY2tcIiA6IFwic2lnbmluXCIsIFwiL1wiKS5jb25jYXQocHJvdmlkZXIpO1xuICAgICAgICAgICAgX3NpZ25JblVybCA9IFwiXCIuY29uY2F0KHNpZ25JblVybCwgXCI/XCIpLmNvbmNhdChuZXcgVVJMU2VhcmNoUGFyYW1zKGF1dGhvcml6YXRpb25QYXJhbXMpKTtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IGZldGNoO1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQxID0gX3NpZ25JblVybDtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MiA9IHtcbiAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MyA9IFVSTFNlYXJjaFBhcmFtcztcbiAgICAgICAgICAgIF9jb250ZXh0NS50NCA9IF9vYmplY3RTcHJlYWQ7XG4gICAgICAgICAgICBfY29udGV4dDUudDUgPSBfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIF9jb250ZXh0NS50NiA9IHt9O1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAyNTtcbiAgICAgICAgICAgIHJldHVybiBnZXRDc3JmVG9rZW4oKTtcblxuICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICBfY29udGV4dDUudDcgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0NS50OCA9IGNhbGxiYWNrVXJsO1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQ5ID0ge1xuICAgICAgICAgICAgICBjc3JmVG9rZW46IF9jb250ZXh0NS50NyxcbiAgICAgICAgICAgICAgY2FsbGJhY2tVcmw6IF9jb250ZXh0NS50OCxcbiAgICAgICAgICAgICAganNvbjogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MTAgPSAoMCwgX2NvbnRleHQ1LnQ0KShfY29udGV4dDUudDUsIF9jb250ZXh0NS50NiwgX2NvbnRleHQ1LnQ5KTtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MTEgPSBuZXcgX2NvbnRleHQ1LnQzKF9jb250ZXh0NS50MTApO1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQxMiA9IHtcbiAgICAgICAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgICAgICAgaGVhZGVyczogX2NvbnRleHQ1LnQyLFxuICAgICAgICAgICAgICBib2R5OiBfY29udGV4dDUudDExXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzMztcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2NvbnRleHQ1LnQwKShfY29udGV4dDUudDEsIF9jb250ZXh0NS50MTIpO1xuXG4gICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgIHJlcyA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzNjtcbiAgICAgICAgICAgIHJldHVybiByZXMuanNvbigpO1xuXG4gICAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDUuc2VudDtcblxuICAgICAgICAgICAgaWYgKCEocmVkaXJlY3QgfHwgIWlzU3VwcG9ydGluZ1JldHVybikpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0MjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVybCA9IChfZGF0YSR1cmwgPSBkYXRhLnVybCkgIT09IG51bGwgJiYgX2RhdGEkdXJsICE9PSB2b2lkIDAgPyBfZGF0YSR1cmwgOiBjYWxsYmFja1VybDtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgaWYgKHVybC5pbmNsdWRlcyhcIiNcIikpIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFVSTChkYXRhLnVybCkuc2VhcmNoUGFyYW1zLmdldChcImVycm9yXCIpO1xuXG4gICAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQ2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0NjtcbiAgICAgICAgICAgIHJldHVybiBfX05FWFRBVVRILl9nZXRTZXNzaW9uKHtcbiAgICAgICAgICAgICAgZXZlbnQ6IFwic3RvcmFnZVwiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNDY6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgICAgICAgICBvazogcmVzLm9rLFxuICAgICAgICAgICAgICB1cmw6IGVycm9yID8gbnVsbCA6IGRhdGEudXJsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9zaWduSW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gc2lnbk91dChfeDYpIHtcbiAgcmV0dXJuIF9zaWduT3V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9zaWduT3V0KCkge1xuICBfc2lnbk91dCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNihvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zJHJlZGlyZWN0O1xuXG4gICAgdmFyIF9yZWY2LCBfcmVmNiRjYWxsYmFja1VybCwgY2FsbGJhY2tVcmwsIGJhc2VVcmwsIGZldGNoT3B0aW9ucywgcmVzLCBkYXRhLCBfZGF0YSR1cmwyLCB1cmw7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfcmVmNiA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCBfcmVmNiRjYWxsYmFja1VybCA9IF9yZWY2LmNhbGxiYWNrVXJsLCBjYWxsYmFja1VybCA9IF9yZWY2JGNhbGxiYWNrVXJsID09PSB2b2lkIDAgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6IF9yZWY2JGNhbGxiYWNrVXJsO1xuICAgICAgICAgICAgYmFzZVVybCA9ICgwLCBfdXRpbHMuYXBpQmFzZVVybCkoX19ORVhUQVVUSCk7XG4gICAgICAgICAgICBfY29udGV4dDYudDAgPSB7XG4gICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfY29udGV4dDYudDEgPSBVUkxTZWFyY2hQYXJhbXM7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q3NyZlRva2VuKCk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBfY29udGV4dDYudDIgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Ni50MyA9IGNhbGxiYWNrVXJsO1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQ0ID0ge1xuICAgICAgICAgICAgICBjc3JmVG9rZW46IF9jb250ZXh0Ni50MixcbiAgICAgICAgICAgICAgY2FsbGJhY2tVcmw6IF9jb250ZXh0Ni50MyxcbiAgICAgICAgICAgICAganNvbjogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9jb250ZXh0Ni50NSA9IG5ldyBfY29udGV4dDYudDEoX2NvbnRleHQ2LnQ0KTtcbiAgICAgICAgICAgIGZldGNoT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgICAgICAgaGVhZGVyczogX2NvbnRleHQ2LnQwLFxuICAgICAgICAgICAgICBib2R5OiBfY29udGV4dDYudDVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDEzO1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKFwiXCIuY29uY2F0KGJhc2VVcmwsIFwiL3NpZ25vdXRcIiksIGZldGNoT3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgYnJvYWRjYXN0LnBvc3Qoe1xuICAgICAgICAgICAgICBldmVudDogXCJzZXNzaW9uXCIsXG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBcInNpZ25vdXRcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCEoKF9vcHRpb25zJHJlZGlyZWN0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZGlyZWN0KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRyZWRpcmVjdCAhPT0gdm9pZCAwID8gX29wdGlvbnMkcmVkaXJlY3QgOiB0cnVlKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDIzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXJsID0gKF9kYXRhJHVybDIgPSBkYXRhLnVybCkgIT09IG51bGwgJiYgX2RhdGEkdXJsMiAhPT0gdm9pZCAwID8gX2RhdGEkdXJsMiA6IGNhbGxiYWNrVXJsO1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICBpZiAodXJsLmluY2x1ZGVzKFwiI1wiKSkgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAyNTtcbiAgICAgICAgICAgIHJldHVybiBfX05FWFRBVVRILl9nZXRTZXNzaW9uKHtcbiAgICAgICAgICAgICAgZXZlbnQ6IFwic3RvcmFnZVwiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBkYXRhKTtcblxuICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNik7XG4gIH0pKTtcbiAgcmV0dXJuIF9zaWduT3V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIFNlc3Npb25Qcm92aWRlcihwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGJhc2VQYXRoID0gcHJvcHMuYmFzZVBhdGg7XG4gIGlmIChiYXNlUGF0aCkgX19ORVhUQVVUSC5iYXNlUGF0aCA9IGJhc2VQYXRoO1xuICB2YXIgaGFzSW5pdGlhbFNlc3Npb24gPSBwcm9wcy5zZXNzaW9uICE9PSB1bmRlZmluZWQ7XG4gIF9fTkVYVEFVVEguX2xhc3RTeW5jID0gaGFzSW5pdGlhbFNlc3Npb24gPyAoMCwgX3V0aWxzLm5vdykoKSA6IDA7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGFzSW5pdGlhbFNlc3Npb24pIF9fTkVYVEFVVEguX3Nlc3Npb24gPSBwcm9wcy5zZXNzaW9uO1xuICAgIHJldHVybiBwcm9wcy5zZXNzaW9uO1xuICB9KSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSAoMCwgX3NsaWNlZFRvQXJyYXkyLmRlZmF1bHQpKF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICBzZXNzaW9uID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldFNlc3Npb24gPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoIWhhc0luaXRpYWxTZXNzaW9uKSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTQgPSAoMCwgX3NsaWNlZFRvQXJyYXkyLmRlZmF1bHQpKF9SZWFjdCR1c2VTdGF0ZTMsIDIpLFxuICAgICAgbG9hZGluZyA9IF9SZWFjdCR1c2VTdGF0ZTRbMF0sXG4gICAgICBzZXRMb2FkaW5nID0gX1JlYWN0JHVzZVN0YXRlNFsxXTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIF9fTkVYVEFVVEguX2dldFNlc3Npb24gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgIHZhciBfcmVmNCxcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgICBzdG9yYWdlRXZlbnQsXG4gICAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfcmVmNCA9IF9hcmdzLmxlbmd0aCA+IDAgJiYgX2FyZ3NbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzBdIDoge30sIGV2ZW50ID0gX3JlZjQuZXZlbnQ7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuICAgICAgICAgICAgICBzdG9yYWdlRXZlbnQgPSBldmVudCA9PT0gXCJzdG9yYWdlXCI7XG5cbiAgICAgICAgICAgICAgaWYgKCEoc3RvcmFnZUV2ZW50IHx8IF9fTkVYVEFVVEguX3Nlc3Npb24gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfX05FWFRBVVRILl9sYXN0U3luYyA9ICgwLCBfdXRpbHMubm93KSgpO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuIGdldFNlc3Npb24oe1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdDogIXN0b3JhZ2VFdmVudFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfX05FWFRBVVRILl9zZXNzaW9uID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgc2V0U2Vzc2lvbihfX05FWFRBVVRILl9zZXNzaW9uKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgaWYgKCEoIWV2ZW50IHx8IF9fTkVYVEFVVEguX3Nlc3Npb24gPT09IG51bGwgfHwgKDAsIF91dGlscy5ub3cpKCkgPCBfX05FWFRBVVRILl9sYXN0U3luYykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBfX05FWFRBVVRILl9sYXN0U3luYyA9ICgwLCBfdXRpbHMubm93KSgpO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRTZXNzaW9uKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIF9fTkVYVEFVVEguX3Nlc3Npb24gPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBzZXRTZXNzaW9uKF9fTkVYVEFVVEguX3Nlc3Npb24pO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTk7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiQ0xJRU5UX1NFU1NJT05fRVJST1JcIiwgX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjI7XG4gICAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDIyKTtcblxuICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMSwgMTksIDIyLCAyNV1dKTtcbiAgICB9KSk7XG5cbiAgICBfX05FWFRBVVRILl9nZXRTZXNzaW9uKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgX19ORVhUQVVUSC5fbGFzdFN5bmMgPSAwO1xuICAgICAgX19ORVhUQVVUSC5fc2Vzc2lvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIH07XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdW5zdWJzY3JpYmUgPSBicm9hZGNhc3QucmVjZWl2ZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7XG4gICAgICAgIGV2ZW50OiBcInN0b3JhZ2VcIlxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB1bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3Byb3BzJHJlZmV0Y2hPbldpbmRvID0gcHJvcHMucmVmZXRjaE9uV2luZG93Rm9jdXMsXG4gICAgICAgIHJlZmV0Y2hPbldpbmRvd0ZvY3VzID0gX3Byb3BzJHJlZmV0Y2hPbldpbmRvID09PSB2b2lkIDAgPyB0cnVlIDogX3Byb3BzJHJlZmV0Y2hPbldpbmRvO1xuXG4gICAgdmFyIHZpc2liaWxpdHlIYW5kbGVyID0gZnVuY3Rpb24gdmlzaWJpbGl0eUhhbmRsZXIoKSB7XG4gICAgICBpZiAocmVmZXRjaE9uV2luZG93Rm9jdXMgJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIikgX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7XG4gICAgICAgIGV2ZW50OiBcInZpc2liaWxpdHljaGFuZ2VcIlxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHZpc2liaWxpdHlIYW5kbGVyLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB2aXNpYmlsaXR5SGFuZGxlciwgZmFsc2UpO1xuICAgIH07XG4gIH0sIFtwcm9wcy5yZWZldGNoT25XaW5kb3dGb2N1c10pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWZldGNoSW50ZXJ2YWwgPSBwcm9wcy5yZWZldGNoSW50ZXJ2YWw7XG5cbiAgICBpZiAocmVmZXRjaEludGVydmFsKSB7XG4gICAgICB2YXIgcmVmZXRjaEludGVydmFsVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfX05FWFRBVVRILl9zZXNzaW9uKSB7XG4gICAgICAgICAgX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7XG4gICAgICAgICAgICBldmVudDogXCJwb2xsXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgcmVmZXRjaEludGVydmFsICogMTAwMCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2xlYXJJbnRlcnZhbChyZWZldGNoSW50ZXJ2YWxUaW1lcik7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3Byb3BzLnJlZmV0Y2hJbnRlcnZhbF0pO1xuICB2YXIgdmFsdWUgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogc2Vzc2lvbixcbiAgICAgIHN0YXR1czogbG9hZGluZyA/IFwibG9hZGluZ1wiIDogc2Vzc2lvbiA/IFwiYXV0aGVudGljYXRlZFwiIDogXCJ1bmF1dGhlbnRpY2F0ZWRcIlxuICAgIH07XG4gIH0sIFtzZXNzaW9uLCBsb2FkaW5nXSk7XG4gIHJldHVybiAoMCwgX2pzeFJ1bnRpbWUuanN4KShTZXNzaW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59Il0sIm5hbWVzIjpbIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3R5cGVvZiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX2V4cG9ydE5hbWVzIiwidXNlU2Vzc2lvbiIsImdldFNlc3Npb24iLCJnZXRDc3JmVG9rZW4iLCJnZXRQcm92aWRlcnMiLCJzaWduSW4iLCJzaWduT3V0IiwiU2Vzc2lvblByb3ZpZGVyIiwiX3JlZ2VuZXJhdG9yIiwiX2RlZmluZVByb3BlcnR5MiIsIl9zbGljZWRUb0FycmF5MiIsIl9hc3luY1RvR2VuZXJhdG9yMiIsIlJlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfbG9nZ2VyMiIsIl9wYXJzZVVybCIsIl91dGlscyIsIl9qc3hSdW50aW1lIiwiX3R5cGVzIiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3Byb2Nlc3MkZW52JE5FWFRBVVRIIiwiX3JlZiIsIl9wcm9jZXNzJGVudiRORVhUQVVUSDIiLCJfcHJvY2VzcyRlbnYkTkVYVEFVVEgzIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwibm9kZUludGVyb3AiLCJXZWFrTWFwIiwiY2FjaGVCYWJlbEludGVyb3AiLCJjYWNoZU5vZGVJbnRlcm9wIiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJjYWNoZSIsImhhcyIsIm5ld09iaiIsImhhc1Byb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlc2MiLCJzZXQiLCJvd25LZXlzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9fTkVYVEFVVEgiLCJiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRBVVRIX1VSTCIsIlZFUkNFTF9VUkwiLCJvcmlnaW4iLCJiYXNlUGF0aCIsInBhdGgiLCJiYXNlVXJsU2VydmVyIiwiTkVYVEFVVEhfVVJMX0lOVEVSTkFMIiwiYmFzZVBhdGhTZXJ2ZXIiLCJfbGFzdFN5bmMiLCJfc2Vzc2lvbiIsInVuZGVmaW5lZCIsIl9nZXRTZXNzaW9uIiwiYnJvYWRjYXN0IiwiQnJvYWRjYXN0Q2hhbm5lbCIsImxvZ2dlciIsInByb3h5TG9nZ2VyIiwiU2Vzc2lvbkNvbnRleHQiLCJjcmVhdGVDb250ZXh0Iiwib3B0aW9ucyIsInVzZUNvbnRleHQiLCJOT0RFX0VOViIsIkVycm9yIiwiX3JlZjIiLCJyZXF1aXJlZCIsIm9uVW5hdXRoZW50aWNhdGVkIiwicmVxdWlyZWRBbmROb3RMb2FkaW5nIiwic3RhdHVzIiwidXNlRWZmZWN0IiwidXJsIiwiY29uY2F0IiwiVVJMU2VhcmNoUGFyYW1zIiwiZXJyb3IiLCJjYWxsYmFja1VybCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsImRhdGEiLCJfeCIsIl9nZXRTZXNzaW9uMiIsIm1hcmsiLCJfY2FsbGVlMiIsInBhcmFtcyIsIl9wYXJhbXMkYnJvYWRjYXN0Iiwic2Vzc2lvbiIsIndyYXAiLCJfY2FsbGVlMiQiLCJfY29udGV4dDIiLCJwcmV2IiwibmV4dCIsImZldGNoRGF0YSIsInNlbnQiLCJwb3N0IiwiZXZlbnQiLCJ0cmlnZ2VyIiwiYWJydXB0Iiwic3RvcCIsIl94MiIsIl9nZXRDc3JmVG9rZW4iLCJfY2FsbGVlMyIsInJlc3BvbnNlIiwiX2NhbGxlZTMkIiwiX2NvbnRleHQzIiwiY3NyZlRva2VuIiwiX2dldFByb3ZpZGVycyIsIl9jYWxsZWU0IiwiX2NhbGxlZTQkIiwiX2NvbnRleHQ0IiwiX3gzIiwiX3g0IiwiX3g1IiwiX3NpZ25JbiIsIl9jYWxsZWU1IiwicHJvdmlkZXIiLCJhdXRob3JpemF0aW9uUGFyYW1zIiwiX3JlZjUiLCJfcmVmNSRjYWxsYmFja1VybCIsIl9yZWY1JHJlZGlyZWN0IiwicmVkaXJlY3QiLCJwcm92aWRlcnMiLCJpc0NyZWRlbnRpYWxzIiwiaXNFbWFpbCIsImlzU3VwcG9ydGluZ1JldHVybiIsInNpZ25JblVybCIsIl9zaWduSW5VcmwiLCJyZXMiLCJfZGF0YSR1cmwiLCJfY2FsbGVlNSQiLCJfY29udGV4dDUiLCJhcGlCYXNlVXJsIiwidHlwZSIsInQwIiwiZmV0Y2giLCJ0MSIsInQyIiwidDMiLCJ0NCIsInQ1IiwidDYiLCJ0NyIsInQ4IiwidDkiLCJqc29uIiwidDEwIiwidDExIiwidDEyIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJpbmNsdWRlcyIsInJlbG9hZCIsIlVSTCIsInNlYXJjaFBhcmFtcyIsIm9rIiwiX3g2IiwiX3NpZ25PdXQiLCJfY2FsbGVlNiIsIl9vcHRpb25zJHJlZGlyZWN0IiwiX3JlZjYiLCJfcmVmNiRjYWxsYmFja1VybCIsImZldGNoT3B0aW9ucyIsIl9kYXRhJHVybDIiLCJfY2FsbGVlNiQiLCJfY29udGV4dDYiLCJwcm9wcyIsImNoaWxkcmVuIiwiaGFzSW5pdGlhbFNlc3Npb24iLCJub3ciLCJfUmVhY3QkdXNlU3RhdGUiLCJ1c2VTdGF0ZSIsIl9SZWFjdCR1c2VTdGF0ZTIiLCJzZXRTZXNzaW9uIiwiX1JlYWN0JHVzZVN0YXRlMyIsIl9SZWFjdCR1c2VTdGF0ZTQiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsIl9jYWxsZWUiLCJfcmVmNCIsInN0b3JhZ2VFdmVudCIsIl9hcmdzIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsImZpbmlzaCIsInVuc3Vic2NyaWJlIiwicmVjZWl2ZSIsIl9wcm9wcyRyZWZldGNoT25XaW5kbyIsInJlZmV0Y2hPbldpbmRvd0ZvY3VzIiwidmlzaWJpbGl0eUhhbmRsZXIiLCJkb2N1bWVudCIsInZpc2liaWxpdHlTdGF0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVmZXRjaEludGVydmFsIiwicmVmZXRjaEludGVydmFsVGltZXIiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJ1c2VNZW1vIiwianN4IiwiUHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next-auth/react/index.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/react/types.js":
/*!***********************************************!*\
  !*** ./node_modules/next-auth/react/types.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0L3R5cGVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViQSw4Q0FBNkM7RUFDM0NHLEtBQUssRUFBRTtBQURvQyxDQUE3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0L3R5cGVzLmpzPzFlNWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next-auth/react/types.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/utils/logger.js":
/*!************************************************!*\
  !*** ./node_modules/next-auth/utils/logger.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nexports.proxyLogger = proxyLogger;\nexports.setLogger = setLogger;\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _errors = __webpack_require__(/*! ../core/errors */ \"./node_modules/next-auth/core/errors.js\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction formatError(o) {\n  if (o instanceof Error && !(o instanceof _errors.UnknownError)) {\n    return {\n      message: o.message,\n      stack: o.stack,\n      name: o.name\n    };\n  }\n\n  if (hasErrorProperty(o)) {\n    var _o$message;\n\n    o.error = formatError(o.error);\n    o.message = (_o$message = o.message) !== null && _o$message !== void 0 ? _o$message : o.error.message;\n  }\n\n  return o;\n}\n\nfunction hasErrorProperty(x) {\n  return !!(x !== null && x !== void 0 && x.error);\n}\n\nvar _logger = {\n  error: function error(code, metadata) {\n    metadata = formatError(metadata);\n    console.error(\"[next-auth][error][\".concat(code, \"]\"), \"\\nhttps://next-auth.js.org/errors#\".concat(code.toLowerCase()), metadata.message, metadata);\n  },\n  warn: function warn(code) {\n    console.warn(\"[next-auth][warn][\".concat(code, \"]\"), \"\\nhttps://next-auth.js.org/warnings#\".concat(code.toLowerCase()));\n  },\n  debug: function debug(code, metadata) {\n    console.log(\"[next-auth][debug][\".concat(code, \"]\"), metadata);\n  }\n};\n\nfunction setLogger() {\n  var newLogger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var debug = arguments.length > 1 ? arguments[1] : undefined;\n  if (!debug) _logger.debug = function () {};\n  if (newLogger.error) _logger.error = newLogger.error;\n  if (newLogger.warn) _logger.warn = newLogger.warn;\n  if (newLogger.debug) _logger.debug = newLogger.debug;\n}\n\nvar _default = _logger;\nexports[\"default\"] = _default;\n\nfunction proxyLogger() {\n  var logger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _logger;\n  var basePath = arguments.length > 1 ? arguments[1] : undefined;\n\n  try {\n    if (typeof window === \"undefined\") {\n      return logger;\n    }\n\n    var clientLogger = {};\n\n    var _loop = function _loop(level) {\n      clientLogger[level] = function (code, metadata) {\n        _logger[level](code, metadata);\n\n        if (level === \"error\") {\n          metadata = formatError(metadata);\n        }\n\n        ;\n        metadata.client = true;\n        var url = \"\".concat(basePath, \"/_log\");\n        var body = new URLSearchParams(_objectSpread({\n          level: level,\n          code: code\n        }, metadata));\n\n        if (navigator.sendBeacon) {\n          return navigator.sendBeacon(url, body);\n        }\n\n        return fetch(url, {\n          method: \"POST\",\n          body: body,\n          keepalive: true\n        });\n      };\n    };\n\n    for (var level in logger) {\n      _loop(level);\n    }\n\n    return clientLogger;\n  } catch (_unused) {\n    return _logger;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3V0aWxzL2xvZ2dlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJQSxzQkFBc0IsR0FBR0MsbUJBQU8sQ0FBQyxvSEFBRCxDQUFwQzs7QUFFQUMsOENBQTZDO0VBQzNDRyxLQUFLLEVBQUU7QUFEb0MsQ0FBN0M7QUFHQUQsa0JBQUEsR0FBa0IsS0FBSyxDQUF2QjtBQUNBQSxtQkFBQSxHQUFzQkcsV0FBdEI7QUFDQUgsaUJBQUEsR0FBb0JJLFNBQXBCOztBQUVBLElBQUlDLGdCQUFnQixHQUFHVCxzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxzR0FBRCxDQUFSLENBQTdDOztBQUVBLElBQUlTLE9BQU8sR0FBR1QsbUJBQU8sQ0FBQywrREFBRCxDQUFyQjs7QUFFQSxTQUFTVSxPQUFULENBQWlCQyxNQUFqQixFQUF5QkMsY0FBekIsRUFBeUM7RUFBRSxJQUFJQyxJQUFJLEdBQUdaLE1BQU0sQ0FBQ1ksSUFBUCxDQUFZRixNQUFaLENBQVg7O0VBQWdDLElBQUlWLE1BQU0sQ0FBQ2EscUJBQVgsRUFBa0M7SUFBRSxJQUFJQyxPQUFPLEdBQUdkLE1BQU0sQ0FBQ2EscUJBQVAsQ0FBNkJILE1BQTdCLENBQWQ7SUFBb0RDLGNBQWMsS0FBS0csT0FBTyxHQUFHQSxPQUFPLENBQUNDLE1BQVIsQ0FBZSxVQUFVQyxHQUFWLEVBQWU7TUFBRSxPQUFPaEIsTUFBTSxDQUFDaUIsd0JBQVAsQ0FBZ0NQLE1BQWhDLEVBQXdDTSxHQUF4QyxFQUE2Q0UsVUFBcEQ7SUFBaUUsQ0FBakcsQ0FBZixDQUFkLEVBQWtJTixJQUFJLENBQUNPLElBQUwsQ0FBVUMsS0FBVixDQUFnQlIsSUFBaEIsRUFBc0JFLE9BQXRCLENBQWxJO0VBQW1LOztFQUFDLE9BQU9GLElBQVA7QUFBYzs7QUFFclYsU0FBU1MsYUFBVCxDQUF1QkMsTUFBdkIsRUFBK0I7RUFBRSxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdDLFNB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aEJMLElBQUksRUFBRUEsSUFGVTtVQUdoQk0sU0FBUyxFQUFFO1FBSEssQ0FBTixDQUFaO01BS0QsQ0F4QkQ7SUF5QkQsQ0ExQkQ7O0lBNEJBLEtBQUssSUFBSVQsS0FBVCxJQUFrQkwsTUFBbEIsRUFBMEI7TUFDeEJJLEtBQUssQ0FBQ0MsS0FBRCxDQUFMO0lBQ0Q7O0lBRUQsT0FBT0YsWUFBUDtFQUNELENBeENELENBd0NFLE9BQU9ZLE9BQVAsRUFBZ0I7SUFDaEIsT0FBTzNCLE9BQVA7RUFDRDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvdXRpbHMvbG9nZ2VyLmpzP2YyOTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuZXhwb3J0cy5wcm94eUxvZ2dlciA9IHByb3h5TG9nZ2VyO1xuZXhwb3J0cy5zZXRMb2dnZXIgPSBzZXRMb2dnZXI7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfZXJyb3JzID0gcmVxdWlyZShcIi4uL2NvcmUvZXJyb3JzXCIpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBFcnJvciAmJiAhKG8gaW5zdGFuY2VvZiBfZXJyb3JzLlVua25vd25FcnJvcikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogby5tZXNzYWdlLFxuICAgICAgc3RhY2s6IG8uc3RhY2ssXG4gICAgICBuYW1lOiBvLm5hbWVcbiAgICB9O1xuICB9XG5cbiAgaWYgKGhhc0Vycm9yUHJvcGVydHkobykpIHtcbiAgICB2YXIgX28kbWVzc2FnZTtcblxuICAgIG8uZXJyb3IgPSBmb3JtYXRFcnJvcihvLmVycm9yKTtcbiAgICBvLm1lc3NhZ2UgPSAoX28kbWVzc2FnZSA9IG8ubWVzc2FnZSkgIT09IG51bGwgJiYgX28kbWVzc2FnZSAhPT0gdm9pZCAwID8gX28kbWVzc2FnZSA6IG8uZXJyb3IubWVzc2FnZTtcbiAgfVxuXG4gIHJldHVybiBvO1xufVxuXG5mdW5jdGlvbiBoYXNFcnJvclByb3BlcnR5KHgpIHtcbiAgcmV0dXJuICEhKHggIT09IG51bGwgJiYgeCAhPT0gdm9pZCAwICYmIHguZXJyb3IpO1xufVxuXG52YXIgX2xvZ2dlciA9IHtcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKGNvZGUsIG1ldGFkYXRhKSB7XG4gICAgbWV0YWRhdGEgPSBmb3JtYXRFcnJvcihtZXRhZGF0YSk7XG4gICAgY29uc29sZS5lcnJvcihcIltuZXh0LWF1dGhdW2Vycm9yXVtcIi5jb25jYXQoY29kZSwgXCJdXCIpLCBcIlxcbmh0dHBzOi8vbmV4dC1hdXRoLmpzLm9yZy9lcnJvcnMjXCIuY29uY2F0KGNvZGUudG9Mb3dlckNhc2UoKSksIG1ldGFkYXRhLm1lc3NhZ2UsIG1ldGFkYXRhKTtcbiAgfSxcbiAgd2FybjogZnVuY3Rpb24gd2Fybihjb2RlKSB7XG4gICAgY29uc29sZS53YXJuKFwiW25leHQtYXV0aF1bd2Fybl1bXCIuY29uY2F0KGNvZGUsIFwiXVwiKSwgXCJcXG5odHRwczovL25leHQtYXV0aC5qcy5vcmcvd2FybmluZ3MjXCIuY29uY2F0KGNvZGUudG9Mb3dlckNhc2UoKSkpO1xuICB9LFxuICBkZWJ1ZzogZnVuY3Rpb24gZGVidWcoY29kZSwgbWV0YWRhdGEpIHtcbiAgICBjb25zb2xlLmxvZyhcIltuZXh0LWF1dGhdW2RlYnVnXVtcIi5jb25jYXQoY29kZSwgXCJdXCIpLCBtZXRhZGF0YSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldExvZ2dlcigpIHtcbiAgdmFyIG5ld0xvZ2dlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICBpZiAoIWRlYnVnKSBfbG9nZ2VyLmRlYnVnID0gZnVuY3Rpb24gKCkge307XG4gIGlmIChuZXdMb2dnZXIuZXJyb3IpIF9sb2dnZXIuZXJyb3IgPSBuZXdMb2dnZXIuZXJyb3I7XG4gIGlmIChuZXdMb2dnZXIud2FybikgX2xvZ2dlci53YXJuID0gbmV3TG9nZ2VyLndhcm47XG4gIGlmIChuZXdMb2dnZXIuZGVidWcpIF9sb2dnZXIuZGVidWcgPSBuZXdMb2dnZXIuZGVidWc7XG59XG5cbnZhciBfZGVmYXVsdCA9IF9sb2dnZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcblxuZnVuY3Rpb24gcHJveHlMb2dnZXIoKSB7XG4gIHZhciBsb2dnZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9sb2dnZXI7XG4gIHZhciBiYXNlUGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfVxuXG4gICAgdmFyIGNsaWVudExvZ2dlciA9IHt9O1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AobGV2ZWwpIHtcbiAgICAgIGNsaWVudExvZ2dlcltsZXZlbF0gPSBmdW5jdGlvbiAoY29kZSwgbWV0YWRhdGEpIHtcbiAgICAgICAgX2xvZ2dlcltsZXZlbF0oY29kZSwgbWV0YWRhdGEpO1xuXG4gICAgICAgIGlmIChsZXZlbCA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgbWV0YWRhdGEgPSBmb3JtYXRFcnJvcihtZXRhZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICA7XG4gICAgICAgIG1ldGFkYXRhLmNsaWVudCA9IHRydWU7XG4gICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChiYXNlUGF0aCwgXCIvX2xvZ1wiKTtcbiAgICAgICAgdmFyIGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgICBjb2RlOiBjb2RlXG4gICAgICAgIH0sIG1ldGFkYXRhKSk7XG5cbiAgICAgICAgaWYgKG5hdmlnYXRvci5zZW5kQmVhY29uKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5zZW5kQmVhY29uKHVybCwgYm9keSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgIGtlZXBhbGl2ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZvciAodmFyIGxldmVsIGluIGxvZ2dlcikge1xuICAgICAgX2xvb3AobGV2ZWwpO1xuICAgIH1cblxuICAgIHJldHVybiBjbGllbnRMb2dnZXI7XG4gIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICByZXR1cm4gX2xvZ2dlcjtcbiAgfVxufSJdLCJuYW1lcyI6WyJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsInByb3h5TG9nZ2VyIiwic2V0TG9nZ2VyIiwiX2RlZmluZVByb3BlcnR5MiIsIl9lcnJvcnMiLCJvd25LZXlzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImZvckVhY2giLCJrZXkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImZvcm1hdEVycm9yIiwibyIsIkVycm9yIiwiVW5rbm93bkVycm9yIiwibWVzc2FnZSIsInN0YWNrIiwibmFtZSIsImhhc0Vycm9yUHJvcGVydHkiLCJfbyRtZXNzYWdlIiwiZXJyb3IiLCJ4IiwiX2xvZ2dlciIsImNvZGUiLCJtZXRhZGF0YSIsImNvbnNvbGUiLCJjb25jYXQiLCJ0b0xvd2VyQ2FzZSIsIndhcm4iLCJkZWJ1ZyIsImxvZyIsIm5ld0xvZ2dlciIsInVuZGVmaW5lZCIsIl9kZWZhdWx0IiwibG9nZ2VyIiwiYmFzZVBhdGgiLCJ3aW5kb3ciLCJjbGllbnRMb2dnZXIiLCJfbG9vcCIsImxldmVsIiwiY2xpZW50IiwidXJsIiwiYm9keSIsIlVSTFNlYXJjaFBhcmFtcyIsIm5hdmlnYXRvciIsInNlbmRCZWFjb24iLCJmZXRjaCIsIm1ldGhvZCIsImtlZXBhbGl2ZSIsIl91bnVzZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next-auth/utils/logger.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/utils/parse-url.js":
/*!***************************************************!*\
  !*** ./node_modules/next-auth/utils/parse-url.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = parseUrl;\n\nfunction parseUrl(url) {\n  var _url2;\n\n  const defaultUrl = new URL(\"http://localhost:3000/api/auth\");\n\n  if (url && !url.startsWith(\"http\")) {\n    url = `https://${url}`;\n  }\n\n  const _url = new URL((_url2 = url) !== null && _url2 !== void 0 ? _url2 : defaultUrl);\n\n  const path = (_url.pathname === \"/\" ? defaultUrl.pathname : _url.pathname).replace(/\\/$/, \"\");\n  const base = `${_url.origin}${path}`;\n  return {\n    origin: _url.origin,\n    host: _url.host,\n    path,\n    base,\n    toString: () => base\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3V0aWxzL3BhcnNlLXVybC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYkEsOENBQTZDO0VBQzNDRyxLQUFLLEVBQUU7QUFEb0MsQ0FBN0M7QUFHQUQsa0JBQUEsR0FBa0JHLFFBQWxCOztBQUVBLFNBQVNBLFFBQVQsQ0FBa0JDLEdBQWxCLEVBQXVCO0VBQ3JCLElBQUlDLEtBQUo7O0VBRUEsTUFBTUMsVUFBVSxHQUFHLElBQUlDLEdBQUosQ0FBUSxnQ0FBUixDQUFuQjs7RUFFQSxJQUFJSCxHQUFHLElBQUksQ0FBQ0EsR0FBRyxDQUFDSSxVQUFKLENBQWUsTUFBZixDQUFaLEVBQW9DO0lBQ2xDSixHQUFHLEdBQUksV0FBVUEsR0FBSSxFQUFyQjtFQUNEOztFQUVELE1BQU1LLElBQUksR0FBRyxJQUFJRixHQUFKLENBQVEsQ0FBQ0YsS0FBSyxHQUFHRCxHQUFULE1BQWtCLElBQWxCLElBQTBCQyxLQUFLLEtBQUssS0FBSyxDQUF6QyxHQUE2Q0EsS0FBN0MsR0FBcURDLFVBQTdELENBQWI7O0VBRUEsTUFBTUksSUFBSSxHQUFHLENBQUNELElBQUksQ0FBQ0UsUUFBTCxLQUFrQixHQUFsQixHQUF3QkwsVUFBVSxDQUFDSyxRQUFuQyxHQUE4Q0YsSUFBSSxDQUFDRSxRQUFwRCxFQUE4REMsT0FBOUQsQ0FBc0UsS0FBdEUsRUFBNkUsRUFBN0UsQ0FBYjtFQUNBLE1BQU1DLElBQUksR0FBSSxHQUFFSixJQUFJLENBQUNLLE1BQU8sR0FBRUosSUFBSyxFQUFuQztFQUNBLE9BQU87SUFDTEksTUFBTSxFQUFFTCxJQUFJLENBQUNLLE1BRFI7SUFFTEMsSUFBSSxFQUFFTixJQUFJLENBQUNNLElBRk47SUFHTEwsSUFISztJQUlMRyxJQUpLO0lBS0xHLFFBQVEsRUFBRSxNQUFNSDtFQUxYLENBQVA7QUFPRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3V0aWxzL3BhcnNlLXVybC5qcz9jMzM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VVcmw7XG5cbmZ1bmN0aW9uIHBhcnNlVXJsKHVybCkge1xuICB2YXIgX3VybDI7XG5cbiAgY29uc3QgZGVmYXVsdFVybCA9IG5ldyBVUkwoXCJodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGhcIik7XG5cbiAgaWYgKHVybCAmJiAhdXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgdXJsID0gYGh0dHBzOi8vJHt1cmx9YDtcbiAgfVxuXG4gIGNvbnN0IF91cmwgPSBuZXcgVVJMKChfdXJsMiA9IHVybCkgIT09IG51bGwgJiYgX3VybDIgIT09IHZvaWQgMCA/IF91cmwyIDogZGVmYXVsdFVybCk7XG5cbiAgY29uc3QgcGF0aCA9IChfdXJsLnBhdGhuYW1lID09PSBcIi9cIiA/IGRlZmF1bHRVcmwucGF0aG5hbWUgOiBfdXJsLnBhdGhuYW1lKS5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gIGNvbnN0IGJhc2UgPSBgJHtfdXJsLm9yaWdpbn0ke3BhdGh9YDtcbiAgcmV0dXJuIHtcbiAgICBvcmlnaW46IF91cmwub3JpZ2luLFxuICAgIGhvc3Q6IF91cmwuaG9zdCxcbiAgICBwYXRoLFxuICAgIGJhc2UsXG4gICAgdG9TdHJpbmc6ICgpID0+IGJhc2VcbiAgfTtcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwicGFyc2VVcmwiLCJ1cmwiLCJfdXJsMiIsImRlZmF1bHRVcmwiLCJVUkwiLCJzdGFydHNXaXRoIiwiX3VybCIsInBhdGgiLCJwYXRobmFtZSIsInJlcGxhY2UiLCJiYXNlIiwib3JpZ2luIiwiaG9zdCIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next-auth/utils/parse-url.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar ref, ref1;\nmodule.exports = ((ref = __webpack_require__.g.process) == null ? void 0 : ref.env) && typeof ((ref1 = __webpack_require__.g.process) == null ? void 0 : ref1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! ../../compiled/process */ \"./node_modules/next/dist/compiled/process/browser.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBQTs7SUFDRUMsS0FBOEJBO0FBRGhDRCxNQUFNLENBQUNFLE9BQVBGLEdBQ0VDLEtBQWMsR0FBZEEscUJBQU0sQ0FBQ0UsT0FBUEYsS0FBYyxJQUFkQSxlQUFjLENBQUVHLEdBQWhCSCxLQUF1QixRQUFPQSxLQUFjLEdBQWRBLHFCQUFNLENBQUNFLE9BQVBGLEtBQWMsSUFBZEEsZ0JBQWMsQ0FBRUcsR0FBdkIsTUFBK0IsUUFBdERILEdBQ0lBLHFCQUFNLENBQUNFLE9BRFhGLEdBRUlJLG1CQUFPLENBQUMsb0ZBQUQsQ0FIYkwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzPzkyOWIiXSwibmFtZXMiOlsibW9kdWxlIiwiZ2xvYmFsIiwiZXhwb3J0cyIsInByb2Nlc3MiLCJlbnYiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function (useSourceMap) {\n  var list = [] // return the list of modules as css string\n  ;\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  } // import a list of modules into the list\n  ; // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \"\" // eslint-disable-next-line prefer-destructuring\n  ;\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \"function\") {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFNQUE7QUFOQTs7OztBQUlBO0FBQ0E7O0FBQ0FBLE1BQU0sQ0FBQ0MsT0FBUEQsR0FBaUIsVUFBVUUsWUFBVixFQUF3QjtFQUN2QyxJQUFJQyxJQUFJLEdBQUcsRUFBWCxDQUFjO0VBQWQ7O0VBRUFBLElBQUksQ0FBQ0MsUUFBTEQsR0FBZ0IsU0FBU0MsUUFBVCxHQUFvQjtJQUNsQyxPQUFPLEtBQUtDLEdBQUwsQ0FBUyxVQUFVQyxJQUFWLEVBQWdCO01BQzlCLElBQUlDLE9BQU8sR0FBR0Msc0JBQXNCLENBQUNGLElBQUQsRUFBT0osWUFBUCxDQUFwQzs7TUFFQSxJQUFJSSxJQUFJLENBQUMsQ0FBRCxDQUFSLEVBQWE7UUFDWCxPQUFPLFVBQVVHLE1BQVYsQ0FBaUJILElBQUksQ0FBQyxDQUFELENBQXJCLEVBQTBCLElBQTFCLEVBQWdDRyxNQUFoQyxDQUF1Q0YsT0FBdkMsRUFBZ0QsR0FBaEQsQ0FBUDtNQUNEOztNQUVELE9BQU9BLE9BQVA7SUFDRCxDQVJNLEVBUUpHLElBUkksQ0FRQyxFQVJELENBQVA7RUFTRCxDQVZEUCxDQVVFO0VBVkZBLENBSHVDLENBY3ZDOzs7RUFFQUEsSUFBSSxDQUFDUSxDQUFMUixHQUFTLFVBQVVTLE9BQVYsRUFBbUJDLFVBQW5CLEVBQStCQyxNQUEvQixFQUF1QztJQUM5QyxJQUFJLE9BQU9GLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7TUFDL0I7TUFDQUEsT0FBTyxHQUFHLENBQUMsQ0FBQyxJQUFELEVBQU9BLE9BQVAsRUFBZ0IsRUFBaEIsQ0FBRCxDQUFWQTtJQUNEOztJQUVELElBQUlHLHNCQUFzQixHQUFHLEVBQTdCOztJQUVBLElBQUlELE1BQUosRUFBWTtNQUNWLEtBQUssSUFBSUgsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLSyxNQUF6QixFQUFpQ0wsQ0FBQyxFQUFsQyxFQUFzQztRQUNwQztRQUNBLElBQUlNLEVBQUUsR0FBRyxLQUFLTixDQUFMLEVBQVEsQ0FBUixDQUFUOztRQUVBLElBQUlNLEVBQUUsSUFBSSxJQUFWLEVBQWdCO1VBQ2RGLHNCQUFzQixDQUFDRSxFQUFELENBQXRCRixHQUE2QixJQUE3QkE7UUFDRDtNQUNGO0lBQ0Y7O0lBRUQsS0FBSyxJQUFJRyxFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxHQUFHTixPQUFPLENBQUNJLE1BQTlCLEVBQXNDRSxFQUFFLEVBQXhDLEVBQTRDO01BQzFDLElBQUlaLElBQUksR0FBRyxHQUFHRyxNQUFILENBQVVHLE9BQU8sQ0FBQ00sRUFBRCxDQUFqQixDQUFYOztNQUVBLElBQUlKLE1BQU0sSUFBSUMsc0JBQXNCLENBQUNULElBQUksQ0FBQyxDQUFELENBQUwsQ0FBcEMsRUFBK0M7UUFFN0M7TUFDRDs7TUFFRCxJQUFJTyxVQUFKLEVBQWdCO1FBQ2QsSUFBSSxDQUFDUCxJQUFJLENBQUMsQ0FBRCxDQUFULEVBQWM7VUFDWkEsSUFBSSxDQUFDLENBQUQsQ0FBSkEsR0FBVU8sVUFBVlA7UUFDRCxDQUZELE1BRU87VUFDTEEsSUFBSSxDQUFDLENBQUQsQ0FBSkEsR0FBVSxHQUFHRyxNQUFILENBQVVJLFVBQVYsRUFBc0IsT0FBdEIsRUFBK0JKLE1BQS9CLENBQXNDSCxJQUFJLENBQUMsQ0FBRCxDQUExQyxDQUFWQTtRQUNEO01BQ0Y7O01BRURILElBQUksQ0FBQ2dCLElBQUxoQixDQUFVRyxJQUFWSDtJQUNEO0VBQ0YsQ0FyQ0RBOztFQXVDQSxPQUFPQSxJQUFQO0FBQ0QsQ0F4RERIOztBQTBEQSxTQUFTUSxzQkFBVCxDQUFnQ0YsSUFBaEMsRUFBc0NKLFlBQXRDLEVBQW9EO0VBQ2xELElBQUlLLE9BQU8sR0FBR0QsSUFBSSxDQUFDLENBQUQsQ0FBSkEsSUFBVyxFQUF6QixDQUE0QjtFQUE1QjtFQUVBLElBQUljLFVBQVUsR0FBR2QsSUFBSSxDQUFDLENBQUQsQ0FBckI7O0VBRUEsSUFBSSxDQUFDYyxVQUFMLEVBQWlCO0lBQ2YsT0FBT2IsT0FBUDtFQUNEOztFQUVELElBQUlMLFlBQVksSUFBSSxPQUFPbUIsSUFBUCxLQUFnQixVQUFwQyxFQUFnRDtJQUM5QyxJQUFJQyxhQUFhLEdBQUdDLFNBQVMsQ0FBQ0gsVUFBRCxDQUE3QjtJQUNBLElBQUlJLFVBQVUsR0FBR0osVUFBVSxDQUFDSyxPQUFYTCxDQUFtQmYsR0FBbkJlLENBQXVCLFVBQVVNLE1BQVYsRUFBa0I7TUFDeEQsT0FBTyxpQkFDSmpCLE1BREksQ0FDR1csVUFBVSxDQUFDTyxVQUFYUCxJQUF5QixFQUQ1QixFQUVKWCxNQUZJLENBRUdpQixNQUZILEVBRVcsS0FGWCxDQUFQO0lBR0QsQ0FKZ0JOLENBQWpCO0lBS0EsT0FBTyxDQUFDYixPQUFELEVBQVVFLE1BQVYsQ0FBaUJlLFVBQWpCLEVBQTZCZixNQUE3QixDQUFvQyxDQUFDYSxhQUFELENBQXBDLEVBQXFEWixJQUFyRCxDQUEwRCxJQUExRCxDQUFQO0VBQ0Q7O0VBRUQsT0FBTyxDQUFDSCxPQUFELEVBQVVHLElBQVYsQ0FBZSxJQUFmLENBQVA7QUFDRCxDLENBQUM7OztBQUVGLFNBQVNhLFNBQVQsQ0FBbUJLLFNBQW5CLEVBQThCO0VBQzVCO0VBQ0EsSUFBSUMsTUFBTSxHQUFHUixJQUFJLENBQUNTLFFBQVEsQ0FBQ0Msa0JBQWtCLENBQUNDLElBQUksQ0FBQ0MsU0FBTEQsQ0FBZUosU0FBZkksQ0FBRCxDQUFuQixDQUFULENBQWpCO0VBQ0EsSUFBSUUsSUFBSSxHQUNOLCtEQUErRHpCLE1BQS9ELENBQ0VvQixNQURGLENBREY7RUFJQSxPQUFPLE9BQU9wQixNQUFQLENBQWN5QixJQUFkLEVBQW9CLEtBQXBCLENBQVA7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzP2NjZmMiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVzZVNvdXJjZU1hcCIsImxpc3QiLCJ0b1N0cmluZyIsIm1hcCIsIml0ZW0iLCJjb250ZW50IiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsImNvbmNhdCIsImpvaW4iLCJpIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJkZWR1cGUiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwibGVuZ3RoIiwiaWQiLCJfaSIsInB1c2giLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZSIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getDomainLocale = getDomainLocale;\nvar basePath =  false || \"\";\n\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n  if (false) { var finalLocale, proto, domain, target, detectDomainLocale, normalizeLocalePath; } else {\n    return false;\n  }\n}\n\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n  Object.defineProperty(exports.default, \"__esModule\", {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0NILEVBQUFBO0FBR0FFLHVCQUFBQSxHQUEwQkUsZUFBMUJGO0FBQ0EsSUFBTUcsUUFBUSxHQUFHQyxNQUFBQSxJQUFzQyxFQUF2RDs7QUFDQSxTQUFTRixlQUFULENBQXlCSyxJQUF6QixFQUErQkMsTUFBL0IsRUFBdUNDLE9BQXZDLEVBQWdEQyxhQUFoRCxFQUErRDtFQUMzRCxJQUFJTixLQUFKLEVBQXFDLG9GQUFyQyxNQVdPO0lBQ0gsT0FBTyxLQUFQO0VBQ0g7QUFDSjs7QUFFRCxJQUFJLENBQUMsT0FBT0osT0FBTyxDQUFDd0IsT0FBZixLQUEyQixVQUEzQixJQUEwQyxPQUFPeEIsT0FBTyxDQUFDd0IsT0FBZixLQUEyQixRQUEzQixJQUF1Q3hCLE9BQU8sQ0FBQ3dCLE9BQVJ4QixLQUFvQixJQUF0RyxLQUFnSCxPQUFPQSxPQUFPLENBQUN3QixPQUFSeEIsQ0FBZ0J5QixVQUF2QixLQUFzQyxXQUExSixFQUF1SztFQUNySzNCLE1BQU0sQ0FBQ0MsY0FBUEQsQ0FBc0JFLE9BQU8sQ0FBQ3dCLE9BQTlCMUIsRUFBdUMsWUFBdkNBLEVBQXFEO0lBQUVHLEtBQUssRUFBRTtFQUFULENBQXJESDtFQUNBQSxNQUFNLENBQUM0QixNQUFQNUIsQ0FBY0UsT0FBTyxDQUFDd0IsT0FBdEIxQixFQUErQkUsT0FBL0JGO0VBQ0E2QixNQUFNLENBQUMzQixPQUFQMkIsR0FBaUIzQixPQUFPLENBQUN3QixPQUF6Qkc7QUFDRCxDLENBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZ2V0LWRvbWFpbi1sb2NhbGUuanM/NWMyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0RG9tYWluTG9jYWxlID0gZ2V0RG9tYWluTG9jYWxlO1xuY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnO1xuZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKHBhdGgsIGxvY2FsZSwgbG9jYWxlcywgZG9tYWluTG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZUxvY2FsZVBhdGggPSByZXF1aXJlKCcuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCcpLm5vcm1hbGl6ZUxvY2FsZVBhdGg7XG4gICAgICAgIGNvbnN0IGRldGVjdERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoJy4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKS5kZXRlY3REb21haW5Mb2NhbGU7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGxvY2FsZSB8fCBub3JtYWxpemVMb2NhbGVQYXRoKHBhdGgsIGxvY2FsZXMpLmRldGVjdGVkTG9jYWxlO1xuICAgICAgICBjb25zdCBkb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUoZG9tYWluTG9jYWxlcywgdW5kZWZpbmVkLCB0YXJnZXQpO1xuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICBjb25zdCBwcm90byA9IGBodHRwJHtkb21haW4uaHR0cCA/ICcnIDogJ3MnfTovL2A7XG4gICAgICAgICAgICBjb25zdCBmaW5hbExvY2FsZSA9IHRhcmdldCA9PT0gZG9tYWluLmRlZmF1bHRMb2NhbGUgPyAnJyA6IGAvJHt0YXJnZXR9YDtcbiAgICAgICAgICAgIHJldHVybiBgJHtwcm90b30ke2RvbWFpbi5kb21haW59JHtiYXNlUGF0aH0ke2ZpbmFsTG9jYWxlfSR7cGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtZG9tYWluLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXREb21haW5Mb2NhbGUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsImxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJyZXF1aXJlIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwidGFyZ2V0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJkb21haW4iLCJ1bmRlZmluZWQiLCJwcm90byIsImNvbmNhdCIsImh0dHAiLCJmaW5hbExvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/image.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/image.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _defineProperty = (__webpack_require__(/*! @swc/helpers/lib/_define_property.js */ \"./node_modules/@swc/helpers/lib/_define_property.js\")[\"default\"]);\n\nvar _slicedToArray = (__webpack_require__(/*! @swc/helpers/lib/_sliced_to_array.js */ \"./node_modules/@swc/helpers/lib/_sliced_to_array.js\")[\"default\"]);\n\nvar _toConsumableArray = (__webpack_require__(/*! @swc/helpers/lib/_to_consumable_array.js */ \"./node_modules/@swc/helpers/lib/_to_consumable_array.js\")[\"default\"]);\n\nvar _s = $RefreshSig$(),\n    _s1 = $RefreshSig$();\n\n\"client\";\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = Image;\n\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\n\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\n\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\n\nvar _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ \"./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\")[\"default\"]);\n\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _head = _interop_require_default(__webpack_require__(/*! ../shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\"));\n\nvar _imageConfig = __webpack_require__(/*! ../shared/lib/image-config */ \"./node_modules/next/dist/shared/lib/image-config.js\");\n\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\n\nvar _imageConfigContext = __webpack_require__(/*! ../shared/lib/image-config-context */ \"./node_modules/next/dist/shared/lib/image-config-context.js\");\n\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\n\nvar _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\n\nfunction Image(_param) {\n  _s();\n\n  var src = _param.src,\n      sizes = _param.sizes,\n      _unoptimized = _param.unoptimized,\n      unoptimized = _unoptimized === void 0 ? false : _unoptimized,\n      _priority = _param.priority,\n      priority = _priority === void 0 ? false : _priority,\n      loading = _param.loading,\n      _lazyRoot = _param.lazyRoot,\n      lazyRoot = _lazyRoot === void 0 ? null : _lazyRoot,\n      lazyBoundary = _param.lazyBoundary,\n      className = _param.className,\n      quality = _param.quality,\n      width = _param.width,\n      height = _param.height,\n      style = _param.style,\n      objectFit = _param.objectFit,\n      objectPosition = _param.objectPosition,\n      onLoadingComplete = _param.onLoadingComplete,\n      _placeholder = _param.placeholder,\n      placeholder = _placeholder === void 0 ? \"empty\" : _placeholder,\n      blurDataURL = _param.blurDataURL,\n      all = _object_without_properties_loose(_param, [\"src\", \"sizes\", \"unoptimized\", \"priority\", \"loading\", \"lazyRoot\", \"lazyBoundary\", \"className\", \"quality\", \"width\", \"height\", \"style\", \"objectFit\", \"objectPosition\", \"onLoadingComplete\", \"placeholder\", \"blurDataURL\"]);\n\n  var configContext = (0, _react).useContext(_imageConfigContext.ImageConfigContext);\n  var config = (0, _react).useMemo(function () {\n    var c = configEnv || configContext || _imageConfig.imageConfigDefault;\n\n    var allSizes = _toConsumableArray(c.deviceSizes).concat(_toConsumableArray(c.imageSizes)).sort(function (a, b) {\n      return a - b;\n    });\n\n    var deviceSizes = c.deviceSizes.sort(function (a, b) {\n      return a - b;\n    });\n    return _extends({}, c, {\n      allSizes: allSizes,\n      deviceSizes: deviceSizes\n    });\n  }, [configContext]);\n  var rest = all;\n  var layout = sizes ? \"responsive\" : \"intrinsic\";\n\n  if (\"layout\" in rest) {\n    // Override default layout if the user specified one:\n    if (rest.layout) layout = rest.layout; // Remove property so it's not spread on <img>:\n\n    delete rest.layout;\n  }\n\n  var loader = defaultImageLoader;\n\n  if (\"loader\" in rest) {\n    if (rest.loader) {\n      var customImageLoader = rest.loader;\n\n      var _tmp;\n\n      _tmp = function (obj) {\n        var _ = obj.config,\n            opts = _object_without_properties_loose(obj, [\"config\"]); // The config object is internal only so we must\n        // not pass it to the user-defined loader()\n\n\n        return customImageLoader(opts);\n      }, loader = _tmp, _tmp;\n    } // Remove property so it's not spread on <img>\n\n\n    delete rest.loader;\n  }\n\n  var staticSrc = \"\";\n\n  if (isStaticImport(src)) {\n    var staticImageData = isStaticRequire(src) ? src.default : src;\n\n    if (!staticImageData.src) {\n      throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \".concat(JSON.stringify(staticImageData)));\n    }\n\n    blurDataURL = blurDataURL || staticImageData.blurDataURL;\n    staticSrc = staticImageData.src;\n\n    if (!layout || layout !== \"fill\") {\n      height = height || staticImageData.height;\n      width = width || staticImageData.width;\n\n      if (!staticImageData.height || !staticImageData.width) {\n        throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \".concat(JSON.stringify(staticImageData)));\n      }\n    }\n  }\n\n  src = typeof src === \"string\" ? src : staticSrc;\n  var isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n\n  if (src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n    unoptimized = true;\n    isLazy = false;\n  }\n\n  if ( true && loadedImageURLs.has(src)) {\n    isLazy = false;\n  }\n\n  if (config.unoptimized) {\n    unoptimized = true;\n  }\n\n  var ref = _slicedToArray((0, _react).useState(false), 2),\n      blurComplete = ref[0],\n      setBlurComplete = ref[1];\n\n  var ref1 = _slicedToArray((0, _useIntersection).useIntersection({\n    rootRef: lazyRoot,\n    rootMargin: lazyBoundary || \"200px\",\n    disabled: !isLazy\n  }), 3),\n      setIntersection = ref1[0],\n      isIntersected = ref1[1],\n      resetIntersected = ref1[2];\n\n  var isVisible = !isLazy || isIntersected;\n  var wrapperStyle = {\n    boxSizing: \"border-box\",\n    display: \"block\",\n    overflow: \"hidden\",\n    width: \"initial\",\n    height: \"initial\",\n    background: \"none\",\n    opacity: 1,\n    border: 0,\n    margin: 0,\n    padding: 0\n  };\n  var sizerStyle = {\n    boxSizing: \"border-box\",\n    display: \"block\",\n    width: \"initial\",\n    height: \"initial\",\n    background: \"none\",\n    opacity: 1,\n    border: 0,\n    margin: 0,\n    padding: 0\n  };\n  var hasSizer = false;\n  var sizerSvgUrl;\n  var layoutStyle = {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0,\n    boxSizing: \"border-box\",\n    padding: 0,\n    border: \"none\",\n    margin: \"auto\",\n    display: \"block\",\n    width: 0,\n    height: 0,\n    minWidth: \"100%\",\n    maxWidth: \"100%\",\n    minHeight: \"100%\",\n    maxHeight: \"100%\",\n    objectFit: objectFit,\n    objectPosition: objectPosition\n  };\n  var widthInt = getInt(width);\n  var heightInt = getInt(height);\n  var qualityInt = getInt(quality);\n\n  if (true) {\n    if (!src) {\n      // React doesn't show the stack trace and there's\n      // no `src` to help identify which image, so we\n      // instead console.error(ref) during mount.\n      widthInt = widthInt || 1;\n      heightInt = heightInt || 1;\n      unoptimized = true;\n    } else {\n      if (!VALID_LAYOUT_VALUES.includes(layout)) {\n        if (layout === \"raw\") {\n          throw new Error('The layout=\"raw\" experiment has been moved to a new module. Please import `next/future/image` instead.');\n        }\n\n        throw new Error('Image with src \"'.concat(src, '\" has invalid \"layout\" property. Provided \"').concat(layout, '\" should be one of ').concat(VALID_LAYOUT_VALUES.map(String).join(\",\"), \".\"));\n      }\n\n      if (typeof widthInt !== \"undefined\" && isNaN(widthInt) || typeof heightInt !== \"undefined\" && isNaN(heightInt)) {\n        throw new Error('Image with src \"'.concat(src, '\" has invalid \"width\" or \"height\" property. These should be numeric values.'));\n      }\n\n      if (layout === \"fill\" && (width || height)) {\n        (0, _utils).warnOnce('Image with src \"'.concat(src, '\" and \"layout=\\'fill\\'\" has unused properties assigned. Please remove \"width\" and \"height\".'));\n      }\n\n      if (!VALID_LOADING_VALUES.includes(loading)) {\n        throw new Error('Image with src \"'.concat(src, '\" has invalid \"loading\" property. Provided \"').concat(loading, '\" should be one of ').concat(VALID_LOADING_VALUES.map(String).join(\",\"), \".\"));\n      }\n\n      if (priority && loading === \"lazy\") {\n        throw new Error('Image with src \"'.concat(src, '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.'));\n      }\n\n      if (sizes && layout !== \"fill\" && layout !== \"responsive\") {\n        (0, _utils).warnOnce('Image with src \"'.concat(src, '\" has \"sizes\" property but it will be ignored. Only use \"sizes\" with \"layout=\\'fill\\'\" or \"layout=\\'responsive\\'\"'));\n      }\n\n      if (placeholder === \"blur\") {\n        if (layout !== \"fill\" && (widthInt || 0) * (heightInt || 0) < 1600) {\n          (0, _utils).warnOnce('Image with src \"'.concat(src, '\" is smaller than 40x40. Consider removing the \"placeholder=\\'blur\\'\" property to improve performance.'));\n        }\n\n        if (!blurDataURL) {\n          var VALID_BLUR_EXT = [\"jpeg\", \"png\", \"webp\", \"avif\"] // should match next-image-loader\n          ;\n          throw new Error('Image with src \"'.concat(src, '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n          Possible solutions:\\n            - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n            - Change the \"src\" property to a static import with one of the supported file types: ').concat(VALID_BLUR_EXT.join(\",\"), '\\n            - Remove the \"placeholder\" property, effectively no blur effect\\n          Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url'));\n        }\n      }\n\n      if (\"ref\" in rest) {\n        (0, _utils).warnOnce('Image with src \"'.concat(src, '\" is using unsupported \"ref\" property. Consider using the \"onLoadingComplete\" property instead.'));\n      }\n\n      if (!unoptimized && loader !== defaultImageLoader) {\n        var urlStr = loader({\n          config: config,\n          src: src,\n          width: widthInt || 400,\n          quality: qualityInt || 75\n        });\n        var url;\n\n        try {\n          url = new URL(urlStr);\n        } catch (err) {}\n\n        if (urlStr === src || url && url.pathname === src && !url.search) {\n          (0, _utils).warnOnce('Image with src \"'.concat(src, '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.') + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n        }\n      }\n\n      if (style) {\n        var overwrittenStyles = Object.keys(style).filter(function (key) {\n          return key in layoutStyle;\n        });\n\n        if (overwrittenStyles.length) {\n          (0, _utils).warnOnce(\"Image with src \".concat(src, \" is assigned the following styles, which are overwritten by automatically-generated styles: \").concat(overwrittenStyles.join(\", \")));\n        }\n      }\n\n      if ( true && !perfObserver && window.PerformanceObserver) {\n        perfObserver = new PerformanceObserver(function (entryList) {\n          var _iteratorNormalCompletion = true,\n              _didIteratorError = false,\n              _iteratorError = undefined;\n\n          try {\n            for (var _iterator = entryList.getEntries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var entry = _step.value;\n              var ref; // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n\n              var imgSrc = (entry == null ? void 0 : (ref = entry.element) == null ? void 0 : ref.src) || \"\";\n              var lcpImage = allImgs.get(imgSrc);\n\n              if (lcpImage && !lcpImage.priority && lcpImage.placeholder !== \"blur\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                // https://web.dev/lcp/#measure-lcp-in-javascript\n                (0, _utils).warnOnce('Image with src \"'.concat(lcpImage.src, '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.') + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        });\n\n        try {\n          perfObserver.observe({\n            type: \"largest-contentful-paint\",\n            buffered: true\n          });\n        } catch (err1) {\n          // Log error but don't crash the app\n          console.error(err1);\n        }\n      }\n    }\n  }\n\n  var imgStyle = Object.assign({}, style, layoutStyle);\n  var blurStyle = placeholder === \"blur\" && !blurComplete ? {\n    backgroundSize: objectFit || \"cover\",\n    backgroundPosition: objectPosition || \"0% 0%\",\n    filter: \"blur(20px)\",\n    backgroundImage: 'url(\"'.concat(blurDataURL, '\")')\n  } : {};\n\n  if (layout === \"fill\") {\n    // <Image src=\"i.png\" layout=\"fill\" />\n    wrapperStyle.display = \"block\";\n    wrapperStyle.position = \"absolute\";\n    wrapperStyle.top = 0;\n    wrapperStyle.left = 0;\n    wrapperStyle.bottom = 0;\n    wrapperStyle.right = 0;\n  } else if (typeof widthInt !== \"undefined\" && typeof heightInt !== \"undefined\") {\n    // <Image src=\"i.png\" width=\"100\" height=\"100\" />\n    var quotient = heightInt / widthInt;\n    var paddingTop = isNaN(quotient) ? \"100%\" : \"\".concat(quotient * 100, \"%\");\n\n    if (layout === \"responsive\") {\n      // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"responsive\" />\n      wrapperStyle.display = \"block\";\n      wrapperStyle.position = \"relative\";\n      hasSizer = true;\n      sizerStyle.paddingTop = paddingTop;\n    } else if (layout === \"intrinsic\") {\n      // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"intrinsic\" />\n      wrapperStyle.display = \"inline-block\";\n      wrapperStyle.position = \"relative\";\n      wrapperStyle.maxWidth = \"100%\";\n      hasSizer = true;\n      sizerStyle.maxWidth = \"100%\";\n      sizerSvgUrl = \"data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27\".concat(widthInt, \"%27%20height=%27\").concat(heightInt, \"%27/%3e\");\n    } else if (layout === \"fixed\") {\n      // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"fixed\" />\n      wrapperStyle.display = \"inline-block\";\n      wrapperStyle.position = \"relative\";\n      wrapperStyle.width = widthInt;\n      wrapperStyle.height = heightInt;\n    }\n  } else {\n    // <Image src=\"i.png\" />\n    if (true) {\n      throw new Error('Image with src \"'.concat(src, '\" must use \"width\" and \"height\" properties or \"layout=\\'fill\\'\" property.'));\n    }\n  }\n\n  var imgAttributes = {\n    src: emptyDataURL,\n    srcSet: undefined,\n    sizes: undefined\n  };\n\n  if (isVisible) {\n    imgAttributes = generateImgAttrs({\n      config: config,\n      src: src,\n      unoptimized: unoptimized,\n      layout: layout,\n      width: widthInt,\n      quality: qualityInt,\n      sizes: sizes,\n      loader: loader\n    });\n  }\n\n  var srcString = src;\n\n  if (true) {\n    if (true) {\n      var fullUrl;\n\n      try {\n        fullUrl = new URL(imgAttributes.src);\n      } catch (e) {\n        fullUrl = new URL(imgAttributes.src, window.location.href);\n      }\n\n      allImgs.set(fullUrl.href, {\n        src: src,\n        priority: priority,\n        placeholder: placeholder\n      });\n    }\n  }\n\n  var imageSrcSetPropName = \"imagesrcset\";\n  var imageSizesPropName = \"imagesizes\";\n\n  if (true) {\n    imageSrcSetPropName = \"imageSrcSet\";\n    imageSizesPropName = \"imageSizes\";\n  }\n\n  var _obj;\n\n  var linkProps = (_obj = {}, // Note: imagesrcset and imagesizes are not in the link element type with react 17.\n  _defineProperty(_obj, imageSrcSetPropName, imgAttributes.srcSet), _defineProperty(_obj, imageSizesPropName, imgAttributes.sizes), _defineProperty(_obj, \"crossOrigin\", rest.crossOrigin), _obj);\n  var useLayoutEffect =  false ? 0 : _react.default.useLayoutEffect;\n  var onLoadingCompleteRef = (0, _react).useRef(onLoadingComplete);\n  var previousImageSrc = (0, _react).useRef(src);\n  (0, _react).useEffect(function () {\n    onLoadingCompleteRef.current = onLoadingComplete;\n  }, [onLoadingComplete]);\n  useLayoutEffect(function () {\n    if (previousImageSrc.current !== src) {\n      resetIntersected();\n      previousImageSrc.current = src;\n    }\n  }, [resetIntersected, src]);\n\n  var imgElementArgs = _extends({\n    isLazy: isLazy,\n    imgAttributes: imgAttributes,\n    heightInt: heightInt,\n    widthInt: widthInt,\n    qualityInt: qualityInt,\n    layout: layout,\n    className: className,\n    imgStyle: imgStyle,\n    blurStyle: blurStyle,\n    loading: loading,\n    config: config,\n    unoptimized: unoptimized,\n    placeholder: placeholder,\n    loader: loader,\n    srcString: srcString,\n    onLoadingCompleteRef: onLoadingCompleteRef,\n    setBlurComplete: setBlurComplete,\n    setIntersection: setIntersection,\n    isVisible: isVisible,\n    noscriptSizes: sizes\n  }, rest);\n\n  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"span\", {\n    style: wrapperStyle\n  }, hasSizer ? /*#__PURE__*/_react.default.createElement(\"span\", {\n    style: sizerStyle\n  }, sizerSvgUrl ? /*#__PURE__*/_react.default.createElement(\"img\", {\n    style: {\n      display: \"block\",\n      maxWidth: \"100%\",\n      width: \"initial\",\n      height: \"initial\",\n      background: \"none\",\n      opacity: 1,\n      border: 0,\n      margin: 0,\n      padding: 0\n    },\n    alt: \"\",\n    \"aria-hidden\": true,\n    src: sizerSvgUrl\n  }) : null) : null, /*#__PURE__*/_react.default.createElement(ImageElement, Object.assign({}, imgElementArgs))), priority ? // for browsers that do not support `imagesrcset`, and in those cases\n  // it would likely cause the incorrect image to be preloaded.\n  //\n  // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n\n  /*#__PURE__*/\n  _react.default.createElement(_head.default, null, /*#__PURE__*/_react.default.createElement(\"link\", Object.assign({\n    key: \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes,\n    rel: \"preload\",\n    as: \"image\",\n    href: imgAttributes.srcSet ? undefined : imgAttributes.src\n  }, linkProps))) : null);\n}\n\n_s(Image, \"JC32V8ZswcgqIp1SSTncST29uwM=\");\n\n_c = Image;\n\"client\";\n\nfunction normalizeSrc(src) {\n  return src[0] === \"/\" ? src.slice(1) : src;\n}\n\nvar configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[\"lh3.googleusercontent.com\",\"avatars.githubusercontent.com\",\"imagedelivery.net\"],\"remotePatterns\":[]};\nvar loadedImageURLs = new Set();\nvar allImgs = new Map();\nvar perfObserver;\nvar emptyDataURL = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n\nif (false) {}\n\nvar VALID_LOADING_VALUES = [\"lazy\", \"eager\", undefined];\n\nfunction imgixLoader(param) {\n  var config = param.config,\n      src = param.src,\n      width = param.width,\n      quality = param.quality; // Demo: https://static.imgix.net/daisy.png?auto=format&fit=max&w=300\n\n  var url = new URL(\"\".concat(config.path).concat(normalizeSrc(src)));\n  var params = url.searchParams; // auto params can be combined with comma separation, or reiteration\n\n  params.set(\"auto\", params.getAll(\"auto\").join(\",\") || \"format\");\n  params.set(\"fit\", params.get(\"fit\") || \"max\");\n  params.set(\"w\", params.get(\"w\") || width.toString());\n\n  if (quality) {\n    params.set(\"q\", quality.toString());\n  }\n\n  return url.href;\n}\n\nfunction akamaiLoader(param) {\n  var config = param.config,\n      src = param.src,\n      width = param.width;\n  return \"\".concat(config.path).concat(normalizeSrc(src), \"?imwidth=\").concat(width);\n}\n\nfunction cloudinaryLoader(param) {\n  var config = param.config,\n      src = param.src,\n      width = param.width,\n      quality = param.quality; // Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg\n\n  var params = [\"f_auto\", \"c_limit\", \"w_\" + width, \"q_\" + (quality || \"auto\")];\n  var paramsString = params.join(\",\") + \"/\";\n  return \"\".concat(config.path).concat(paramsString).concat(normalizeSrc(src));\n}\n\nfunction customLoader(param) {\n  var src = param.src;\n  throw new Error('Image with src \"'.concat(src, '\" is missing \"loader\" prop.') + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n}\n\nfunction defaultLoader(param) {\n  var config = param.config,\n      src = param.src,\n      width = param.width,\n      quality = param.quality;\n\n  if (true) {\n    var missingValues = []; // these should always be provided but make sure they are\n\n    if (!src) missingValues.push(\"src\");\n    if (!width) missingValues.push(\"width\");\n\n    if (missingValues.length > 0) {\n      throw new Error(\"Next Image Optimization requires \".concat(missingValues.join(\", \"), \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \").concat(JSON.stringify({\n        src: src,\n        width: width,\n        quality: quality\n      })));\n    }\n\n    if (src.startsWith(\"//\")) {\n      throw new Error('Failed to parse src \"'.concat(src, '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)'));\n    }\n\n    if (!src.startsWith(\"/\") && (config.domains || config.remotePatterns)) {\n      var parsedSrc;\n\n      try {\n        parsedSrc = new URL(src);\n      } catch (err) {\n        console.error(err);\n        throw new Error('Failed to parse src \"'.concat(src, '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)'));\n      }\n\n      if (true) {\n        // We use dynamic require because this should only error in development\n        var hasMatch = (__webpack_require__(/*! ../shared/lib/match-remote-pattern */ \"./node_modules/next/dist/shared/lib/match-remote-pattern.js\").hasMatch);\n\n        if (!hasMatch(config.domains, config.remotePatterns, parsedSrc)) {\n          throw new Error(\"Invalid src prop (\".concat(src, ') on `next/image`, hostname \"').concat(parsedSrc.hostname, '\" is not configured under images in your `next.config.js`\\n') + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n        }\n      }\n    }\n  }\n\n  if (src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n    // Special case to make svg serve as-is to avoid proxying\n    // through the built-in Image Optimization API.\n    return src;\n  }\n\n  return \"\".concat((0, _normalizeTrailingSlash).normalizePathTrailingSlash(config.path), \"?url=\").concat(encodeURIComponent(src), \"&w=\").concat(width, \"&q=\").concat(quality || 75);\n}\n\nvar loaders = new Map([[\"default\", defaultLoader], [\"imgix\", imgixLoader], [\"cloudinary\", cloudinaryLoader], [\"akamai\", akamaiLoader], [\"custom\", customLoader]]);\nvar VALID_LAYOUT_VALUES = [\"fill\", \"fixed\", \"intrinsic\", \"responsive\", undefined];\n\nfunction isStaticRequire(src) {\n  return src.default !== undefined;\n}\n\nfunction isStaticImageData(src) {\n  return src.src !== undefined;\n}\n\nfunction isStaticImport(src) {\n  return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\n\nfunction getWidths(param, width, layout, sizes) {\n  var deviceSizes = param.deviceSizes,\n      allSizes = param.allSizes;\n\n  if (sizes && (layout === \"fill\" || layout === \"responsive\")) {\n    // Find all the \"vw\" percent sizes used in the sizes prop\n    var viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n    var percentSizes = [];\n\n    for (var match; match = viewportWidthRe.exec(sizes); match) {\n      percentSizes.push(parseInt(match[2]));\n    }\n\n    if (percentSizes.length) {\n      var _Math;\n\n      var smallestRatio = (_Math = Math).min.apply(_Math, _toConsumableArray(percentSizes)) * 0.01;\n      return {\n        widths: allSizes.filter(function (s) {\n          return s >= deviceSizes[0] * smallestRatio;\n        }),\n        kind: \"w\"\n      };\n    }\n\n    return {\n      widths: allSizes,\n      kind: \"w\"\n    };\n  }\n\n  if (typeof width !== \"number\" || layout === \"fill\" || layout === \"responsive\") {\n    return {\n      widths: deviceSizes,\n      kind: \"w\"\n    };\n  }\n\n  var widths = _toConsumableArray(new Set( // > are actually 3x in the green color, but only 1.5x in the red and\n  // > blue colors. Showing a 3x resolution image in the app vs a 2x\n  // > resolution image will be visually the same, though the 3x image\n  // > takes significantly more data. Even true 3x resolution screens are\n  // > wasteful as the human eye cannot see that level of detail without\n  // > something like a magnifying glass.\n  // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n  [width, width * 2\n  /*, width * 3*/\n  ].map(function (w) {\n    return allSizes.find(function (p) {\n      return p >= w;\n    }) || allSizes[allSizes.length - 1];\n  })));\n\n  return {\n    widths: widths,\n    kind: \"x\"\n  };\n}\n\nfunction generateImgAttrs(param) {\n  var config = param.config,\n      src = param.src,\n      unoptimized = param.unoptimized,\n      layout = param.layout,\n      width = param.width,\n      quality = param.quality,\n      sizes = param.sizes,\n      loader = param.loader;\n\n  if (unoptimized) {\n    return {\n      src: src,\n      srcSet: undefined,\n      sizes: undefined\n    };\n  }\n\n  var ref = getWidths(config, width, layout, sizes),\n      widths = ref.widths,\n      kind = ref.kind;\n  var last = widths.length - 1;\n  return {\n    sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n    srcSet: widths.map(function (w, i) {\n      return \"\".concat(loader({\n        config: config,\n        src: src,\n        quality: quality,\n        width: w\n      }), \" \").concat(kind === \"w\" ? w : i + 1).concat(kind);\n    }).join(\", \"),\n    // It's intended to keep `src` the last attribute because React updates\n    // attributes in order. If we keep `src` the first one, Safari will\n    // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n    // updated by React. That causes multiple unnecessary requests if `srcSet`\n    // and `sizes` are defined.\n    // This bug cannot be reproduced in Chrome or Firefox.\n    src: loader({\n      config: config,\n      src: src,\n      quality: quality,\n      width: widths[last]\n    })\n  };\n}\n\nfunction getInt(x) {\n  if (typeof x === \"number\") {\n    return x;\n  }\n\n  if (typeof x === \"string\") {\n    return parseInt(x, 10);\n  }\n\n  return undefined;\n}\n\nfunction defaultImageLoader(loaderProps) {\n  var ref;\n  var loaderKey = ((ref = loaderProps.config) == null ? void 0 : ref.loader) || \"default\";\n  var load = loaders.get(loaderKey);\n\n  if (load) {\n    return load(loaderProps);\n  }\n\n  throw new Error('Unknown \"loader\" found in \"next.config.js\". Expected: '.concat(_imageConfig.VALID_LOADERS.join(\", \"), \". Received: \").concat(loaderKey));\n} // See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\n\n\nfunction handleLoading(img, src, layout, placeholder, onLoadingCompleteRef, setBlurComplete) {\n  if (!img || img.src === emptyDataURL || img[\"data-loaded-src\"] === src) {\n    return;\n  }\n\n  img[\"data-loaded-src\"] = src;\n  var p = \"decode\" in img ? img.decode() : Promise.resolve();\n  p.catch(function () {}).then(function () {\n    if (!img.parentNode) {\n      // Exit early in case of race condition:\n      // - onload() is called\n      // - decode() is called but incomplete\n      // - unmount is called\n      // - decode() completes\n      return;\n    }\n\n    loadedImageURLs.add(src);\n\n    if (placeholder === \"blur\") {\n      setBlurComplete(true);\n    }\n\n    if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n      var naturalWidth = img.naturalWidth,\n          naturalHeight = img.naturalHeight; // Pass back read-only primitive values but not the\n      // underlying DOM element because it could be misused.\n\n      onLoadingCompleteRef.current({\n        naturalWidth: naturalWidth,\n        naturalHeight: naturalHeight\n      });\n    }\n\n    if (true) {\n      var ref;\n\n      if ((ref = img.parentElement) == null ? void 0 : ref.parentElement) {\n        var parent = getComputedStyle(img.parentElement.parentElement);\n\n        if (!parent.position) {// The parent has not been rendered to the dom yet and therefore it has no position. Skip the warnings for such cases.\n        } else if (layout === \"responsive\" && parent.display === \"flex\") {\n          (0, _utils).warnOnce('Image with src \"'.concat(src, '\" may not render properly as a child of a flex container. Consider wrapping the image with a div to configure the width.'));\n        } else if (layout === \"fill\" && parent.position !== \"relative\" && parent.position !== \"fixed\" && parent.position !== \"absolute\") {\n          (0, _utils).warnOnce('Image with src \"'.concat(src, '\" may not render properly with a parent using position:\"').concat(parent.position, '\". Consider changing the parent style to position:\"relative\" with a width and height.'));\n        }\n      }\n    }\n  });\n}\n\nvar ImageElement = function (_param) {\n  _s1();\n\n  var imgAttributes = _param.imgAttributes,\n      heightInt = _param.heightInt,\n      widthInt = _param.widthInt,\n      qualityInt = _param.qualityInt,\n      layout = _param.layout,\n      className = _param.className,\n      imgStyle = _param.imgStyle,\n      blurStyle = _param.blurStyle,\n      isLazy = _param.isLazy,\n      placeholder = _param.placeholder,\n      loading = _param.loading,\n      srcString = _param.srcString,\n      config = _param.config,\n      unoptimized = _param.unoptimized,\n      loader = _param.loader,\n      onLoadingCompleteRef = _param.onLoadingCompleteRef,\n      setBlurComplete = _param.setBlurComplete,\n      setIntersection = _param.setIntersection,\n      onLoad = _param.onLoad,\n      onError = _param.onError,\n      isVisible = _param.isVisible,\n      noscriptSizes = _param.noscriptSizes,\n      rest = _object_without_properties_loose(_param, [\"imgAttributes\", \"heightInt\", \"widthInt\", \"qualityInt\", \"layout\", \"className\", \"imgStyle\", \"blurStyle\", \"isLazy\", \"placeholder\", \"loading\", \"srcString\", \"config\", \"unoptimized\", \"loader\", \"onLoadingCompleteRef\", \"setBlurComplete\", \"setIntersection\", \"onLoad\", \"onError\", \"isVisible\", \"noscriptSizes\"]);\n\n  loading = isLazy ? \"lazy\" : loading;\n  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"img\", Object.assign({}, rest, imgAttributes, {\n    decoding: \"async\",\n    \"data-nimg\": layout,\n    className: className,\n    style: _extends({}, imgStyle, blurStyle),\n    ref: (0, _react).useCallback(function (img) {\n      if (true) {\n        if (img && !srcString) {\n          console.error('Image is missing required \"src\" property:', img);\n        }\n      }\n\n      setIntersection(img);\n\n      if (img == null ? void 0 : img.complete) {\n        handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);\n      }\n    }, [setIntersection, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete]),\n    onLoad: function (event) {\n      var img = event.currentTarget;\n      handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);\n\n      if (onLoad) {\n        onLoad(event);\n      }\n    },\n    onError: function (event) {\n      if (placeholder === \"blur\") {\n        // If the real image fails to load, this will still remove the placeholder.\n        setBlurComplete(true);\n      }\n\n      if (onError) {\n        onError(event);\n      }\n    }\n  })), (isLazy || placeholder === \"blur\") && /*#__PURE__*/_react.default.createElement(\"noscript\", null, /*#__PURE__*/_react.default.createElement(\"img\", Object.assign({}, rest, generateImgAttrs({\n    config: config,\n    src: srcString,\n    unoptimized: unoptimized,\n    layout: layout,\n    width: widthInt,\n    quality: qualityInt,\n    sizes: noscriptSizes,\n    loader: loader\n  }), {\n    decoding: \"async\",\n    \"data-nimg\": layout,\n    style: imgStyle,\n    className: className,\n    // @ts-ignore - TODO: upgrade to `@types/react@17`\n    loading: loading\n  }))));\n};\n\n_s1(ImageElement, \"epj4qY15NHsef74wNqHIp5fdZmg=\");\n\n_c1 = ImageElement;\n\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n  Object.defineProperty(exports.default, \"__esModule\", {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n} //# sourceMappingURL=image.js.map\n\n\nvar _c, _c1;\n\n$RefreshReg$(_c, \"Image\");\n$RefreshReg$(_c1, \"ImageElement\");\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTs7Ozs7Ozs7Ozs7Ozs7O0FBRGI7QUFFQUEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0NILEVBQUFBO0FBR0FFLGtCQUFBQSxHQUFrQkcsS0FBbEJIOztBQUNBLElBQUlJLFFBQVEsR0FBR0MsbUhBQWY7O0FBQ0EsSUFBSUMsd0JBQXdCLEdBQUdELG1KQUEvQjs7QUFDQSxJQUFJRSx5QkFBeUIsR0FBR0YscUpBQWhDOztBQUNBLElBQUlHLGdDQUFnQyxHQUFHSCxtS0FBdkM7O0FBQ0EsSUFBSUksTUFBTSxHQUFHRix5QkFBeUIsQ0FBQ0YsbUJBQU8sQ0FBQyw0Q0FBRCxDQUFSLENBQXRDOztBQUNBLElBQUlLLEtBQUssR0FBR0osd0JBQXdCLENBQUNELG1CQUFPLENBQUMsdUVBQUQsQ0FBUixDQUFwQzs7QUFDQSxJQUFJTSxZQUFZLEdBQUdOLG1CQUFPLENBQUMsdUZBQUQsQ0FBMUI7O0FBQ0EsSUFBSU8sZ0JBQWdCLEdBQUdQLG1CQUFPLENBQUMsK0VBQUQsQ0FBOUI7O0FBQ0EsSUFBSVEsbUJBQW1CLEdBQUdSLG1CQUFPLENBQUMsdUdBQUQsQ0FBakM7O0FBQ0EsSUFBSVMsTUFBTSxHQUFHVCxtQkFBTyxDQUFDLHlFQUFELENBQXBCOztBQUNBLElBQUlVLHVCQUF1QixHQUFHVixtQkFBTyxDQUFDLCtGQUFELENBQXJDOztBQUNBLFNBQVNGLEtBQVQsQ0FBZWEsTUFBZixFQUF1Qjs7O0VBQ25CLElBQU1DLEdBQUcsR0FBb09ELE1BQU0sQ0FBN09DLEdBQU47RUFBQSxJQUFZQyxLQUFLLEdBQTRORixNQUFNLENBQXZPRSxLQUFaO0VBQUEsSUFBaUJDLGVBQTROSCxNQUFNLENBQS9OSSxXQUFwQjtFQUFBLElBQW9CQSxXQUFXLDZCQUFFLEtBQUYsR0FBT0QsWUFBdEM7RUFBQSxJQUFzQ0UsWUFBdU1MLE1BQU0sQ0FBMU1NLFFBQXpDO0VB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Y2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaW1hZ2UuanM/ODJmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcImNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBJbWFnZTtcbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19leHRlbmRzLmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnZhciBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZSA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlLmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9oZWFkID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2hlYWRcIikpO1xudmFyIF9pbWFnZUNvbmZpZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZ1wiKTtcbnZhciBfdXNlSW50ZXJzZWN0aW9uID0gcmVxdWlyZShcIi4vdXNlLWludGVyc2VjdGlvblwiKTtcbnZhciBfaW1hZ2VDb25maWdDb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLWNvbnRleHRcIik7XG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvdXRpbHNcIik7XG52YXIgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2ggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XG5mdW5jdGlvbiBJbWFnZShfcGFyYW0pIHtcbiAgICB2YXIgeyBzcmMgLCBzaXplcyAsIHVub3B0aW1pemVkID1mYWxzZSAsIHByaW9yaXR5ID1mYWxzZSAsIGxvYWRpbmcgLCBsYXp5Um9vdCA9bnVsbCAsIGxhenlCb3VuZGFyeSAsIGNsYXNzTmFtZSAsIHF1YWxpdHkgLCB3aWR0aCAsIGhlaWdodCAsIHN0eWxlICwgb2JqZWN0Rml0ICwgb2JqZWN0UG9zaXRpb24gLCBvbkxvYWRpbmdDb21wbGV0ZSAsIHBsYWNlaG9sZGVyID0nZW1wdHknICwgYmx1ckRhdGFVUkwgIH0gPSBfcGFyYW0sIGFsbCA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKF9wYXJhbSwgW1xuICAgICAgICBcInNyY1wiLFxuICAgICAgICBcInNpemVzXCIsXG4gICAgICAgIFwidW5vcHRpbWl6ZWRcIixcbiAgICAgICAgXCJwcmlvcml0eVwiLFxuICAgICAgICBcImxvYWRpbmdcIixcbiAgICAgICAgXCJsYXp5Um9vdFwiLFxuICAgICAgICBcImxhenlCb3VuZGFyeVwiLFxuICAgICAgICBcImNsYXNzTmFtZVwiLFxuICAgICAgICBcInF1YWxpdHlcIixcbiAgICAgICAgXCJ3aWR0aFwiLFxuICAgICAgICBcImhlaWdodFwiLFxuICAgICAgICBcInN0eWxlXCIsXG4gICAgICAgIFwib2JqZWN0Rml0XCIsXG4gICAgICAgIFwib2JqZWN0UG9zaXRpb25cIixcbiAgICAgICAgXCJvbkxvYWRpbmdDb21wbGV0ZVwiLFxuICAgICAgICBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgIFwiYmx1ckRhdGFVUkxcIlxuICAgIF0pO1xuICAgIGNvbnN0IGNvbmZpZ0NvbnRleHQgPSAoMCwgX3JlYWN0KS51c2VDb250ZXh0KF9pbWFnZUNvbmZpZ0NvbnRleHQuSW1hZ2VDb25maWdDb250ZXh0KTtcbiAgICBjb25zdCBjb25maWcgPSAoMCwgX3JlYWN0KS51c2VNZW1vKCgpPT57XG4gICAgICAgIGNvbnN0IGMgPSBjb25maWdFbnYgfHwgY29uZmlnQ29udGV4dCB8fCBfaW1hZ2VDb25maWcuaW1hZ2VDb25maWdEZWZhdWx0O1xuICAgICAgICBjb25zdCBhbGxTaXplcyA9IFtcbiAgICAgICAgICAgIC4uLmMuZGV2aWNlU2l6ZXMsXG4gICAgICAgICAgICAuLi5jLmltYWdlU2l6ZXNcbiAgICAgICAgXS5zb3J0KChhLCBiKT0+YSAtIGIpO1xuICAgICAgICBjb25zdCBkZXZpY2VTaXplcyA9IGMuZGV2aWNlU2l6ZXMuc29ydCgoYSwgYik9PmEgLSBiKTtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBjLCB7XG4gICAgICAgICAgICBhbGxTaXplcyxcbiAgICAgICAgICAgIGRldmljZVNpemVzXG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgY29uZmlnQ29udGV4dFxuICAgIF0pO1xuICAgIGxldCByZXN0ID0gYWxsO1xuICAgIGxldCBsYXlvdXQgPSBzaXplcyA/ICdyZXNwb25zaXZlJyA6ICdpbnRyaW5zaWMnO1xuICAgIGlmICgnbGF5b3V0JyBpbiByZXN0KSB7XG4gICAgICAgIC8vIE92ZXJyaWRlIGRlZmF1bHQgbGF5b3V0IGlmIHRoZSB1c2VyIHNwZWNpZmllZCBvbmU6XG4gICAgICAgIGlmIChyZXN0LmxheW91dCkgbGF5b3V0ID0gcmVzdC5sYXlvdXQ7XG4gICAgICAgIC8vIFJlbW92ZSBwcm9wZXJ0eSBzbyBpdCdzIG5vdCBzcHJlYWQgb24gPGltZz46XG4gICAgICAgIGRlbGV0ZSByZXN0LmxheW91dDtcbiAgICB9XG4gICAgbGV0IGxvYWRlciA9IGRlZmF1bHRJbWFnZUxvYWRlcjtcbiAgICBpZiAoJ2xvYWRlcicgaW4gcmVzdCkge1xuICAgICAgICBpZiAocmVzdC5sb2FkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUltYWdlTG9hZGVyID0gcmVzdC5sb2FkZXI7XG4gICAgICAgICAgICB2YXIgX3RtcDtcbiAgICAgICAgICAgIF90bXAgPSAob2JqKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29uZmlnOiBfICB9ID0gb2JqLCBvcHRzID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2Uob2JqLCBbXG4gICAgICAgICAgICAgICAgICAgIFwiY29uZmlnXCJcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29uZmlnIG9iamVjdCBpcyBpbnRlcm5hbCBvbmx5IHNvIHdlIG11c3RcbiAgICAgICAgICAgICAgICAvLyBub3QgcGFzcyBpdCB0byB0aGUgdXNlci1kZWZpbmVkIGxvYWRlcigpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUltYWdlTG9hZGVyKG9wdHMpO1xuICAgICAgICAgICAgfSwgbG9hZGVyID0gX3RtcCwgX3RtcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgcHJvcGVydHkgc28gaXQncyBub3Qgc3ByZWFkIG9uIDxpbWc+XG4gICAgICAgIGRlbGV0ZSByZXN0LmxvYWRlcjtcbiAgICB9XG4gICAgbGV0IHN0YXRpY1NyYyA9ICcnO1xuICAgIGlmIChpc1N0YXRpY0ltcG9ydChzcmMpKSB7XG4gICAgICAgIGNvbnN0IHN0YXRpY0ltYWdlRGF0YSA9IGlzU3RhdGljUmVxdWlyZShzcmMpID8gc3JjLmRlZmF1bHQgOiBzcmM7XG4gICAgICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLnNyYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIHNyYy4gUmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShzdGF0aWNJbWFnZURhdGEpfWApO1xuICAgICAgICB9XG4gICAgICAgIGJsdXJEYXRhVVJMID0gYmx1ckRhdGFVUkwgfHwgc3RhdGljSW1hZ2VEYXRhLmJsdXJEYXRhVVJMO1xuICAgICAgICBzdGF0aWNTcmMgPSBzdGF0aWNJbWFnZURhdGEuc3JjO1xuICAgICAgICBpZiAoIWxheW91dCB8fCBsYXlvdXQgIT09ICdmaWxsJykge1xuICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IHN0YXRpY0ltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHN0YXRpY0ltYWdlRGF0YS53aWR0aDtcbiAgICAgICAgICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLmhlaWdodCB8fCAhc3RhdGljSW1hZ2VEYXRhLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIGhlaWdodCBhbmQgd2lkdGguIFJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoc3RhdGljSW1hZ2VEYXRhKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzcmMgPSB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyA/IHNyYyA6IHN0YXRpY1NyYztcbiAgICBsZXQgaXNMYXp5ID0gIXByaW9yaXR5ICYmIChsb2FkaW5nID09PSAnbGF6eScgfHwgdHlwZW9mIGxvYWRpbmcgPT09ICd1bmRlZmluZWQnKTtcbiAgICBpZiAoc3JjLnN0YXJ0c1dpdGgoJ2RhdGE6JykgfHwgc3JjLnN0YXJ0c1dpdGgoJ2Jsb2I6JykpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9EYXRhX1VSSXNcbiAgICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICBpc0xhenkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIGxvYWRlZEltYWdlVVJMcy5oYXMoc3JjKSkge1xuICAgICAgICBpc0xhenkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy51bm9wdGltaXplZCkge1xuICAgICAgICB1bm9wdGltaXplZCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IFtibHVyQ29tcGxldGUsIHNldEJsdXJDb21wbGV0ZV0gPSAoMCwgX3JlYWN0KS51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3NldEludGVyc2VjdGlvbiwgaXNJbnRlcnNlY3RlZCwgcmVzZXRJbnRlcnNlY3RlZF0gPSAoMCwgX3VzZUludGVyc2VjdGlvbikudXNlSW50ZXJzZWN0aW9uKHtcbiAgICAgICAgcm9vdFJlZjogbGF6eVJvb3QsXG4gICAgICAgIHJvb3RNYXJnaW46IGxhenlCb3VuZGFyeSB8fCAnMjAwcHgnLFxuICAgICAgICBkaXNhYmxlZDogIWlzTGF6eVxuICAgIH0pO1xuICAgIGNvbnN0IGlzVmlzaWJsZSA9ICFpc0xhenkgfHwgaXNJbnRlcnNlY3RlZDtcbiAgICBjb25zdCB3cmFwcGVyU3R5bGUgPSB7XG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIHdpZHRoOiAnaW5pdGlhbCcsXG4gICAgICAgIGhlaWdodDogJ2luaXRpYWwnLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBwYWRkaW5nOiAwXG4gICAgfTtcbiAgICBjb25zdCBzaXplclN0eWxlID0ge1xuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgd2lkdGg6ICdpbml0aWFsJyxcbiAgICAgICAgaGVpZ2h0OiAnaW5pdGlhbCcsXG4gICAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBhZGRpbmc6IDBcbiAgICB9O1xuICAgIGxldCBoYXNTaXplciA9IGZhbHNlO1xuICAgIGxldCBzaXplclN2Z1VybDtcbiAgICBjb25zdCBsYXlvdXRTdHlsZSA9IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICBtYXJnaW46ICdhdXRvJyxcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgbWluV2lkdGg6ICcxMDAlJyxcbiAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgbWluSGVpZ2h0OiAnMTAwJScsXG4gICAgICAgIG1heEhlaWdodDogJzEwMCUnLFxuICAgICAgICBvYmplY3RGaXQsXG4gICAgICAgIG9iamVjdFBvc2l0aW9uXG4gICAgfTtcbiAgICBsZXQgd2lkdGhJbnQgPSBnZXRJbnQod2lkdGgpO1xuICAgIGxldCBoZWlnaHRJbnQgPSBnZXRJbnQoaGVpZ2h0KTtcbiAgICBjb25zdCBxdWFsaXR5SW50ID0gZ2V0SW50KHF1YWxpdHkpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICghc3JjKSB7XG4gICAgICAgICAgICAvLyBSZWFjdCBkb2Vzbid0IHNob3cgdGhlIHN0YWNrIHRyYWNlIGFuZCB0aGVyZSdzXG4gICAgICAgICAgICAvLyBubyBgc3JjYCB0byBoZWxwIGlkZW50aWZ5IHdoaWNoIGltYWdlLCBzbyB3ZVxuICAgICAgICAgICAgLy8gaW5zdGVhZCBjb25zb2xlLmVycm9yKHJlZikgZHVyaW5nIG1vdW50LlxuICAgICAgICAgICAgd2lkdGhJbnQgPSB3aWR0aEludCB8fCAxO1xuICAgICAgICAgICAgaGVpZ2h0SW50ID0gaGVpZ2h0SW50IHx8IDE7XG4gICAgICAgICAgICB1bm9wdGltaXplZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIVZBTElEX0xBWU9VVF9WQUxVRVMuaW5jbHVkZXMobGF5b3V0KSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXlvdXQgPT09ICdyYXcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGxheW91dD1cInJhd1wiIGV4cGVyaW1lbnQgaGFzIGJlZW4gbW92ZWQgdG8gYSBuZXcgbW9kdWxlLiBQbGVhc2UgaW1wb3J0IFxcYG5leHQvZnV0dXJlL2ltYWdlXFxgIGluc3RlYWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcImxheW91dFwiIHByb3BlcnR5LiBQcm92aWRlZCBcIiR7bGF5b3V0fVwiIHNob3VsZCBiZSBvbmUgb2YgJHtWQUxJRF9MQVlPVVRfVkFMVUVTLm1hcChTdHJpbmcpLmpvaW4oJywnKX0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpZHRoSW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hTih3aWR0aEludCkgfHwgdHlwZW9mIGhlaWdodEludCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYU4oaGVpZ2h0SW50KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcIndpZHRoXCIgb3IgXCJoZWlnaHRcIiBwcm9wZXJ0eS4gVGhlc2Ugc2hvdWxkIGJlIG51bWVyaWMgdmFsdWVzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxheW91dCA9PT0gJ2ZpbGwnICYmICh3aWR0aCB8fCBoZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgYW5kIFwibGF5b3V0PSdmaWxsJ1wiIGhhcyB1bnVzZWQgcHJvcGVydGllcyBhc3NpZ25lZC4gUGxlYXNlIHJlbW92ZSBcIndpZHRoXCIgYW5kIFwiaGVpZ2h0XCIuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVZBTElEX0xPQURJTkdfVkFMVUVTLmluY2x1ZGVzKGxvYWRpbmcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwibG9hZGluZ1wiIHByb3BlcnR5LiBQcm92aWRlZCBcIiR7bG9hZGluZ31cIiBzaG91bGQgYmUgb25lIG9mICR7VkFMSURfTE9BRElOR19WQUxVRVMubWFwKFN0cmluZykuam9pbignLCcpfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmlvcml0eSAmJiBsb2FkaW5nID09PSAnbGF6eScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJwcmlvcml0eVwiIGFuZCBcImxvYWRpbmc9J2xhenknXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2l6ZXMgJiYgbGF5b3V0ICE9PSAnZmlsbCcgJiYgbGF5b3V0ICE9PSAncmVzcG9uc2l2ZScpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgXCJzaXplc1wiIHByb3BlcnR5IGJ1dCBpdCB3aWxsIGJlIGlnbm9yZWQuIE9ubHkgdXNlIFwic2l6ZXNcIiB3aXRoIFwibGF5b3V0PSdmaWxsJ1wiIG9yIFwibGF5b3V0PSdyZXNwb25zaXZlJ1wiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIgPT09ICdibHVyJykge1xuICAgICAgICAgICAgICAgIGlmIChsYXlvdXQgIT09ICdmaWxsJyAmJiAod2lkdGhJbnQgfHwgMCkgKiAoaGVpZ2h0SW50IHx8IDApIDwgMTYwMCkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyBzbWFsbGVyIHRoYW4gNDB4NDAuIENvbnNpZGVyIHJlbW92aW5nIHRoZSBcInBsYWNlaG9sZGVyPSdibHVyJ1wiIHByb3BlcnR5IHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYmx1ckRhdGFVUkwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVkFMSURfQkxVUl9FWFQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnanBlZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncG5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3ZWJwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdmlmJ1xuICAgICAgICAgICAgICAgICAgICBdIC8vIHNob3VsZCBtYXRjaCBuZXh0LWltYWdlLWxvYWRlclxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgXCJwbGFjZWhvbGRlcj0nYmx1cidcIiBwcm9wZXJ0eSBidXQgaXMgbWlzc2luZyB0aGUgXCJibHVyRGF0YVVSTFwiIHByb3BlcnR5LlxuICAgICAgICAgIFBvc3NpYmxlIHNvbHV0aW9uczpcbiAgICAgICAgICAgIC0gQWRkIGEgXCJibHVyRGF0YVVSTFwiIHByb3BlcnR5LCB0aGUgY29udGVudHMgc2hvdWxkIGJlIGEgc21hbGwgRGF0YSBVUkwgdG8gcmVwcmVzZW50IHRoZSBpbWFnZVxuICAgICAgICAgICAgLSBDaGFuZ2UgdGhlIFwic3JjXCIgcHJvcGVydHkgdG8gYSBzdGF0aWMgaW1wb3J0IHdpdGggb25lIG9mIHRoZSBzdXBwb3J0ZWQgZmlsZSB0eXBlczogJHtWQUxJRF9CTFVSX0VYVC5qb2luKCcsJyl9XG4gICAgICAgICAgICAtIFJlbW92ZSB0aGUgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5LCBlZmZlY3RpdmVseSBubyBibHVyIGVmZmVjdFxuICAgICAgICAgIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcGxhY2Vob2xkZXItYmx1ci1kYXRhLXVybGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgncmVmJyBpbiByZXN0KSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgdXNpbmcgdW5zdXBwb3J0ZWQgXCJyZWZcIiBwcm9wZXJ0eS4gQ29uc2lkZXIgdXNpbmcgdGhlIFwib25Mb2FkaW5nQ29tcGxldGVcIiBwcm9wZXJ0eSBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF1bm9wdGltaXplZCAmJiBsb2FkZXIgIT09IGRlZmF1bHRJbWFnZUxvYWRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybFN0ciA9IGxvYWRlcih7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGhJbnQgfHwgNDAwLFxuICAgICAgICAgICAgICAgICAgICBxdWFsaXR5OiBxdWFsaXR5SW50IHx8IDc1XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IHVybDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHVybFN0cik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIGlmICh1cmxTdHIgPT09IHNyYyB8fCB1cmwgJiYgdXJsLnBhdGhuYW1lID09PSBzcmMgJiYgIXVybC5zZWFyY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGEgXCJsb2FkZXJcIiBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IGltcGxlbWVudCB3aWR0aC4gUGxlYXNlIGltcGxlbWVudCBpdCBvciB1c2UgdGhlIFwidW5vcHRpbWl6ZWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLmAgKyBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyLXdpZHRoYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG92ZXJ3cml0dGVuU3R5bGVzID0gT2JqZWN0LmtleXMoc3R5bGUpLmZpbHRlcigoa2V5KT0+a2V5IGluIGxheW91dFN0eWxlKTtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcndyaXR0ZW5TdHlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbHMpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyAke3NyY30gaXMgYXNzaWduZWQgdGhlIGZvbGxvd2luZyBzdHlsZXMsIHdoaWNoIGFyZSBvdmVyd3JpdHRlbiBieSBhdXRvbWF0aWNhbGx5LWdlbmVyYXRlZCBzdHlsZXM6ICR7b3ZlcndyaXR0ZW5TdHlsZXMuam9pbignLCAnKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXBlcmZPYnNlcnZlciAmJiB3aW5kb3cuUGVyZm9ybWFuY2VPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIHBlcmZPYnNlcnZlciA9IG5ldyBQZXJmb3JtYW5jZU9ic2VydmVyKChlbnRyeUxpc3QpPT57XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cnlMaXN0LmdldEVudHJpZXMoKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIG1pc3NpbmcgXCJMYXJnZXN0Q29udGVudGZ1bFBhaW50XCIgY2xhc3Mgd2l0aCBcImVsZW1lbnRcIiBwcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWdTcmMgPSAoZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IChyZWYgPSBlbnRyeS5lbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogcmVmLnNyYykgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsY3BJbWFnZSA9IGFsbEltZ3MuZ2V0KGltZ1NyYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGNwSW1hZ2UgJiYgIWxjcEltYWdlLnByaW9yaXR5ICYmIGxjcEltYWdlLnBsYWNlaG9sZGVyICE9PSAnYmx1cicgJiYgIWxjcEltYWdlLnNyYy5zdGFydHNXaXRoKCdkYXRhOicpICYmICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aCgnYmxvYjonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd2ViLmRldi9sY3AvI21lYXN1cmUtbGNwLWluLWphdmFzY3JpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke2xjcEltYWdlLnNyY31cIiB3YXMgZGV0ZWN0ZWQgYXMgdGhlIExhcmdlc3QgQ29udGVudGZ1bCBQYWludCAoTENQKS4gUGxlYXNlIGFkZCB0aGUgXCJwcmlvcml0eVwiIHByb3BlcnR5IGlmIHRoaXMgaW1hZ2UgaXMgYWJvdmUgdGhlIGZvbGQuYCArIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNwcmlvcml0eWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcGVyZk9ic2VydmVyLm9ic2VydmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xhcmdlc3QtY29udGVudGZ1bC1wYWludCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJlZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9nIGVycm9yIGJ1dCBkb24ndCBjcmFzaCB0aGUgYXBwXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW1nU3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwgbGF5b3V0U3R5bGUpO1xuICAgIGNvbnN0IGJsdXJTdHlsZSA9IHBsYWNlaG9sZGVyID09PSAnYmx1cicgJiYgIWJsdXJDb21wbGV0ZSA/IHtcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IG9iamVjdEZpdCB8fCAnY292ZXInLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IG9iamVjdFBvc2l0aW9uIHx8ICcwJSAwJScsXG4gICAgICAgIGZpbHRlcjogJ2JsdXIoMjBweCknLFxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoXCIke2JsdXJEYXRhVVJMfVwiKWBcbiAgICB9IDoge307XG4gICAgaWYgKGxheW91dCA9PT0gJ2ZpbGwnKSB7XG4gICAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIGxheW91dD1cImZpbGxcIiAvPlxuICAgICAgICB3cmFwcGVyU3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHdyYXBwZXJTdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHdyYXBwZXJTdHlsZS50b3AgPSAwO1xuICAgICAgICB3cmFwcGVyU3R5bGUubGVmdCA9IDA7XG4gICAgICAgIHdyYXBwZXJTdHlsZS5ib3R0b20gPSAwO1xuICAgICAgICB3cmFwcGVyU3R5bGUucmlnaHQgPSAwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpZHRoSW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaGVpZ2h0SW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIC8+XG4gICAgICAgIGNvbnN0IHF1b3RpZW50ID0gaGVpZ2h0SW50IC8gd2lkdGhJbnQ7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdUb3AgPSBpc05hTihxdW90aWVudCkgPyAnMTAwJScgOiBgJHtxdW90aWVudCAqIDEwMH0lYDtcbiAgICAgICAgaWYgKGxheW91dCA9PT0gJ3Jlc3BvbnNpdmUnKSB7XG4gICAgICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIGxheW91dD1cInJlc3BvbnNpdmVcIiAvPlxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgIGhhc1NpemVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHNpemVyU3R5bGUucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3A7XG4gICAgICAgIH0gZWxzZSBpZiAobGF5b3V0ID09PSAnaW50cmluc2ljJykge1xuICAgICAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiBsYXlvdXQ9XCJpbnRyaW5zaWNcIiAvPlxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUubWF4V2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgICBoYXNTaXplciA9IHRydWU7XG4gICAgICAgICAgICBzaXplclN0eWxlLm1heFdpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgc2l6ZXJTdmdVcmwgPSBgZGF0YTppbWFnZS9zdmcreG1sLCUzY3N2ZyUyMHhtbG5zPSUyN2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJTI3JTIwdmVyc2lvbj0lMjcxLjElMjclMjB3aWR0aD0lMjcke3dpZHRoSW50fSUyNyUyMGhlaWdodD0lMjcke2hlaWdodEludH0lMjcvJTNlYDtcbiAgICAgICAgfSBlbHNlIGlmIChsYXlvdXQgPT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgbGF5b3V0PVwiZml4ZWRcIiAvPlxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUud2lkdGggPSB3aWR0aEludDtcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5oZWlnaHQgPSBoZWlnaHRJbnQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiAvPlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIG11c3QgdXNlIFwid2lkdGhcIiBhbmQgXCJoZWlnaHRcIiBwcm9wZXJ0aWVzIG9yIFwibGF5b3V0PSdmaWxsJ1wiIHByb3BlcnR5LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBpbWdBdHRyaWJ1dGVzID0ge1xuICAgICAgICBzcmM6IGVtcHR5RGF0YVVSTCxcbiAgICAgICAgc3JjU2V0OiB1bmRlZmluZWQsXG4gICAgICAgIHNpemVzOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgaW1nQXR0cmlidXRlcyA9IGdlbmVyYXRlSW1nQXR0cnMoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgICAgICBsYXlvdXQsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGhJbnQsXG4gICAgICAgICAgICBxdWFsaXR5OiBxdWFsaXR5SW50LFxuICAgICAgICAgICAgc2l6ZXMsXG4gICAgICAgICAgICBsb2FkZXJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBzcmNTdHJpbmcgPSBzcmM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsZXQgZnVsbFVybDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnVsbFVybCA9IG5ldyBVUkwoaW1nQXR0cmlidXRlcy5zcmMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGZ1bGxVcmwgPSBuZXcgVVJMKGltZ0F0dHJpYnV0ZXMuc3JjLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbGxJbWdzLnNldChmdWxsVXJsLmhyZWYsIHtcbiAgICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBpbWFnZVNyY1NldFByb3BOYW1lID0gJ2ltYWdlc3Jjc2V0JztcbiAgICBsZXQgaW1hZ2VTaXplc1Byb3BOYW1lID0gJ2ltYWdlc2l6ZXMnO1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfUkVBQ1RfUk9PVCkge1xuICAgICAgICBpbWFnZVNyY1NldFByb3BOYW1lID0gJ2ltYWdlU3JjU2V0JztcbiAgICAgICAgaW1hZ2VTaXplc1Byb3BOYW1lID0gJ2ltYWdlU2l6ZXMnO1xuICAgIH1cbiAgICBjb25zdCBsaW5rUHJvcHMgPSB7XG4gICAgICAgIC8vIE5vdGU6IGltYWdlc3Jjc2V0IGFuZCBpbWFnZXNpemVzIGFyZSBub3QgaW4gdGhlIGxpbmsgZWxlbWVudCB0eXBlIHdpdGggcmVhY3QgMTcuXG4gICAgICAgIFtpbWFnZVNyY1NldFByb3BOYW1lXTogaW1nQXR0cmlidXRlcy5zcmNTZXQsXG4gICAgICAgIFtpbWFnZVNpemVzUHJvcE5hbWVdOiBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICBjcm9zc09yaWdpbjogcmVzdC5jcm9zc09yaWdpblxuICAgIH07XG4gICAgY29uc3QgdXNlTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBfcmVhY3QuZGVmYXVsdC51c2VFZmZlY3QgOiBfcmVhY3QuZGVmYXVsdC51c2VMYXlvdXRFZmZlY3Q7XG4gICAgY29uc3Qgb25Mb2FkaW5nQ29tcGxldGVSZWYgPSAoMCwgX3JlYWN0KS51c2VSZWYob25Mb2FkaW5nQ29tcGxldGUpO1xuICAgIGNvbnN0IHByZXZpb3VzSW1hZ2VTcmMgPSAoMCwgX3JlYWN0KS51c2VSZWYoc3JjKTtcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYuY3VycmVudCA9IG9uTG9hZGluZ0NvbXBsZXRlO1xuICAgIH0sIFtcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVcbiAgICBdKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKHByZXZpb3VzSW1hZ2VTcmMuY3VycmVudCAhPT0gc3JjKSB7XG4gICAgICAgICAgICByZXNldEludGVyc2VjdGVkKCk7XG4gICAgICAgICAgICBwcmV2aW91c0ltYWdlU3JjLmN1cnJlbnQgPSBzcmM7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHJlc2V0SW50ZXJzZWN0ZWQsXG4gICAgICAgIHNyY1xuICAgIF0pO1xuICAgIGNvbnN0IGltZ0VsZW1lbnRBcmdzID0gX2V4dGVuZHMoe1xuICAgICAgICBpc0xhenksXG4gICAgICAgIGltZ0F0dHJpYnV0ZXMsXG4gICAgICAgIGhlaWdodEludCxcbiAgICAgICAgd2lkdGhJbnQsXG4gICAgICAgIHF1YWxpdHlJbnQsXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICBpbWdTdHlsZSxcbiAgICAgICAgYmx1clN0eWxlLFxuICAgICAgICBsb2FkaW5nLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgbG9hZGVyLFxuICAgICAgICBzcmNTdHJpbmcsXG4gICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLFxuICAgICAgICBzZXRCbHVyQ29tcGxldGUsXG4gICAgICAgIHNldEludGVyc2VjdGlvbixcbiAgICAgICAgaXNWaXNpYmxlLFxuICAgICAgICBub3NjcmlwdFNpemVzOiBzaXplc1xuICAgIH0sIHJlc3QpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBzdHlsZTogd3JhcHBlclN0eWxlXG4gICAgfSwgaGFzU2l6ZXIgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgc3R5bGU6IHNpemVyU3R5bGVcbiAgICB9LCBzaXplclN2Z1VybCA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIHdpZHRoOiAnaW5pdGlhbCcsXG4gICAgICAgICAgICBoZWlnaHQ6ICdpbml0aWFsJyxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGFsdDogXCJcIixcbiAgICAgICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgICAgICBzcmM6IHNpemVyU3ZnVXJsXG4gICAgfSkgOiBudWxsKSA6IG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChJbWFnZUVsZW1lbnQsIE9iamVjdC5hc3NpZ24oe30sIGltZ0VsZW1lbnRBcmdzKSkpLCBwcmlvcml0eSA/IC8vIE5vdGUgaG93IHdlIG9taXQgdGhlIGBocmVmYCBhdHRyaWJ1dGUsIGFzIGl0IHdvdWxkIG9ubHkgYmUgcmVsZXZhbnRcbiAgICAvLyBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBgaW1hZ2VzcmNzZXRgLCBhbmQgaW4gdGhvc2UgY2FzZXNcbiAgICAvLyBpdCB3b3VsZCBsaWtlbHkgY2F1c2UgdGhlIGluY29ycmVjdCBpbWFnZSB0byBiZSBwcmVsb2FkZWQuXG4gICAgLy9cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCNhdHRyLWxpbmstaW1hZ2VzcmNzZXRcbiAgICAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hlYWQuZGVmYXVsdCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibGlua1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAga2V5OiAnX19uaW1nLScgKyBpbWdBdHRyaWJ1dGVzLnNyYyArIGltZ0F0dHJpYnV0ZXMuc3JjU2V0ICsgaW1nQXR0cmlidXRlcy5zaXplcyxcbiAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgYXM6IFwiaW1hZ2VcIixcbiAgICAgICAgaHJlZjogaW1nQXR0cmlidXRlcy5zcmNTZXQgPyB1bmRlZmluZWQgOiBpbWdBdHRyaWJ1dGVzLnNyY1xuICAgIH0sIGxpbmtQcm9wcykpKSA6IG51bGwpO1xufVxuJ2NsaWVudCc7XG5mdW5jdGlvbiBub3JtYWxpemVTcmMoc3JjKSB7XG4gICAgcmV0dXJuIHNyY1swXSA9PT0gJy8nID8gc3JjLnNsaWNlKDEpIDogc3JjO1xufVxuY29uc3QgY29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFM7XG5jb25zdCBsb2FkZWRJbWFnZVVSTHMgPSBuZXcgU2V0KCk7XG5jb25zdCBhbGxJbWdzID0gbmV3IE1hcCgpO1xubGV0IHBlcmZPYnNlcnZlcjtcbmNvbnN0IGVtcHR5RGF0YVVSTCA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL3lINUJBRUFBQUFBTEFBQUFBQUJBQUVBQUFJQlJBQTcnO1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZ2xvYmFsLl9fTkVYVF9JTUFHRV9JTVBPUlRFRCA9IHRydWU7XG59XG5jb25zdCBWQUxJRF9MT0FESU5HX1ZBTFVFUyA9IFtcbiAgICAnbGF6eScsXG4gICAgJ2VhZ2VyJyxcbiAgICB1bmRlZmluZWRcbl07XG5mdW5jdGlvbiBpbWdpeExvYWRlcih7IGNvbmZpZyAsIHNyYyAsIHdpZHRoICwgcXVhbGl0eSAgfSkge1xuICAgIC8vIERlbW86IGh0dHBzOi8vc3RhdGljLmltZ2l4Lm5ldC9kYWlzeS5wbmc/YXV0bz1mb3JtYXQmZml0PW1heCZ3PTMwMFxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7Y29uZmlnLnBhdGh9JHtub3JtYWxpemVTcmMoc3JjKX1gKTtcbiAgICBjb25zdCBwYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xuICAgIC8vIGF1dG8gcGFyYW1zIGNhbiBiZSBjb21iaW5lZCB3aXRoIGNvbW1hIHNlcGFyYXRpb24sIG9yIHJlaXRlcmF0aW9uXG4gICAgcGFyYW1zLnNldCgnYXV0bycsIHBhcmFtcy5nZXRBbGwoJ2F1dG8nKS5qb2luKCcsJykgfHwgJ2Zvcm1hdCcpO1xuICAgIHBhcmFtcy5zZXQoJ2ZpdCcsIHBhcmFtcy5nZXQoJ2ZpdCcpIHx8ICdtYXgnKTtcbiAgICBwYXJhbXMuc2V0KCd3JywgcGFyYW1zLmdldCgndycpIHx8IHdpZHRoLnRvU3RyaW5nKCkpO1xuICAgIGlmIChxdWFsaXR5KSB7XG4gICAgICAgIHBhcmFtcy5zZXQoJ3EnLCBxdWFsaXR5LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsLmhyZWY7XG59XG5mdW5jdGlvbiBha2FtYWlMb2FkZXIoeyBjb25maWcgLCBzcmMgLCB3aWR0aCAgfSkge1xuICAgIHJldHVybiBgJHtjb25maWcucGF0aH0ke25vcm1hbGl6ZVNyYyhzcmMpfT9pbXdpZHRoPSR7d2lkdGh9YDtcbn1cbmZ1bmN0aW9uIGNsb3VkaW5hcnlMb2FkZXIoeyBjb25maWcgLCBzcmMgLCB3aWR0aCAsIHF1YWxpdHkgIH0pIHtcbiAgICAvLyBEZW1vOiBodHRwczovL3Jlcy5jbG91ZGluYXJ5LmNvbS9kZW1vL2ltYWdlL3VwbG9hZC93XzMwMCxjX2xpbWl0LHFfYXV0by90dXJ0bGVzLmpwZ1xuICAgIGNvbnN0IHBhcmFtcyA9IFtcbiAgICAgICAgJ2ZfYXV0bycsXG4gICAgICAgICdjX2xpbWl0JyxcbiAgICAgICAgJ3dfJyArIHdpZHRoLFxuICAgICAgICAncV8nICsgKHF1YWxpdHkgfHwgJ2F1dG8nKVxuICAgIF07XG4gICAgY29uc3QgcGFyYW1zU3RyaW5nID0gcGFyYW1zLmpvaW4oJywnKSArICcvJztcbiAgICByZXR1cm4gYCR7Y29uZmlnLnBhdGh9JHtwYXJhbXNTdHJpbmd9JHtub3JtYWxpemVTcmMoc3JjKX1gO1xufVxuZnVuY3Rpb24gY3VzdG9tTG9hZGVyKHsgc3JjICB9KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIG1pc3NpbmcgXCJsb2FkZXJcIiBwcm9wLmAgKyBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyYCk7XG59XG5mdW5jdGlvbiBkZWZhdWx0TG9hZGVyKHsgY29uZmlnICwgc3JjICwgd2lkdGggLCBxdWFsaXR5ICB9KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ1ZhbHVlcyA9IFtdO1xuICAgICAgICAvLyB0aGVzZSBzaG91bGQgYWx3YXlzIGJlIHByb3ZpZGVkIGJ1dCBtYWtlIHN1cmUgdGhleSBhcmVcbiAgICAgICAgaWYgKCFzcmMpIG1pc3NpbmdWYWx1ZXMucHVzaCgnc3JjJyk7XG4gICAgICAgIGlmICghd2lkdGgpIG1pc3NpbmdWYWx1ZXMucHVzaCgnd2lkdGgnKTtcbiAgICAgICAgaWYgKG1pc3NpbmdWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXh0IEltYWdlIE9wdGltaXphdGlvbiByZXF1aXJlcyAke21pc3NpbmdWYWx1ZXMuam9pbignLCAnKX0gdG8gYmUgcHJvdmlkZWQuIE1ha2Ugc3VyZSB5b3UgcGFzcyB0aGVtIGFzIHByb3BzIHRvIHRoZSBcXGBuZXh0L2ltYWdlXFxgIGNvbXBvbmVudC4gUmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBxdWFsaXR5XG4gICAgICAgICAgICB9KX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3JjLnN0YXJ0c1dpdGgoJy8vJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHNyYyBcIiR7c3JjfVwiIG9uIFxcYG5leHQvaW1hZ2VcXGAsIHByb3RvY29sLXJlbGF0aXZlIFVSTCAoLy8pIG11c3QgYmUgY2hhbmdlZCB0byBhbiBhYnNvbHV0ZSBVUkwgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzcmMuc3RhcnRzV2l0aCgnLycpICYmIChjb25maWcuZG9tYWlucyB8fCBjb25maWcucmVtb3RlUGF0dGVybnMpKSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkU3JjO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZWRTcmMgPSBuZXcgVVJMKHNyYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJHtzcmN9XCIgb24gXFxgbmV4dC9pbWFnZVxcYCwgaWYgdXNpbmcgcmVsYXRpdmUgaW1hZ2UgaXQgbXVzdCBzdGFydCB3aXRoIGEgbGVhZGluZyBzbGFzaCBcIi9cIiBvciBiZSBhbiBhYnNvbHV0ZSBVUkwgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0Jykge1xuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBkeW5hbWljIHJlcXVpcmUgYmVjYXVzZSB0aGlzIHNob3VsZCBvbmx5IGVycm9yIGluIGRldmVsb3BtZW50XG4gICAgICAgICAgICAgICAgY29uc3QgeyBoYXNNYXRjaCAgfSA9IHJlcXVpcmUoJy4uL3NoYXJlZC9saWIvbWF0Y2gtcmVtb3RlLXBhdHRlcm4nKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc01hdGNoKGNvbmZpZy5kb21haW5zLCBjb25maWcucmVtb3RlUGF0dGVybnMsIHBhcnNlZFNyYykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNyYyBwcm9wICgke3NyY30pIG9uIFxcYG5leHQvaW1hZ2VcXGAsIGhvc3RuYW1lIFwiJHtwYXJzZWRTcmMuaG9zdG5hbWV9XCIgaXMgbm90IGNvbmZpZ3VyZWQgdW5kZXIgaW1hZ2VzIGluIHlvdXIgXFxgbmV4dC5jb25maWcuanNcXGBcXG5gICsgYFNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtdW5jb25maWd1cmVkLWhvc3RgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNyYy5lbmRzV2l0aCgnLnN2ZycpICYmICFjb25maWcuZGFuZ2Vyb3VzbHlBbGxvd1NWRykge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgdG8gbWFrZSBzdmcgc2VydmUgYXMtaXMgdG8gYXZvaWQgcHJveHlpbmdcbiAgICAgICAgLy8gdGhyb3VnaCB0aGUgYnVpbHQtaW4gSW1hZ2UgT3B0aW1pemF0aW9uIEFQSS5cbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gICAgcmV0dXJuIGAkeygwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2goY29uZmlnLnBhdGgpfT91cmw9JHtlbmNvZGVVUklDb21wb25lbnQoc3JjKX0mdz0ke3dpZHRofSZxPSR7cXVhbGl0eSB8fCA3NX1gO1xufVxuY29uc3QgbG9hZGVycyA9IG5ldyBNYXAoW1xuICAgIFtcbiAgICAgICAgJ2RlZmF1bHQnLFxuICAgICAgICBkZWZhdWx0TG9hZGVyXG4gICAgXSxcbiAgICBbXG4gICAgICAgICdpbWdpeCcsXG4gICAgICAgIGltZ2l4TG9hZGVyXG4gICAgXSxcbiAgICBbXG4gICAgICAgICdjbG91ZGluYXJ5JyxcbiAgICAgICAgY2xvdWRpbmFyeUxvYWRlclxuICAgIF0sXG4gICAgW1xuICAgICAgICAnYWthbWFpJyxcbiAgICAgICAgYWthbWFpTG9hZGVyXG4gICAgXSxcbiAgICBbXG4gICAgICAgICdjdXN0b20nLFxuICAgICAgICBjdXN0b21Mb2FkZXJcbiAgICBdLCBcbl0pO1xuY29uc3QgVkFMSURfTEFZT1VUX1ZBTFVFUyA9IFtcbiAgICAnZmlsbCcsXG4gICAgJ2ZpeGVkJyxcbiAgICAnaW50cmluc2ljJyxcbiAgICAncmVzcG9uc2l2ZScsXG4gICAgdW5kZWZpbmVkLCBcbl07XG5mdW5jdGlvbiBpc1N0YXRpY1JlcXVpcmUoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5kZWZhdWx0ICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc1N0YXRpY0ltYWdlRGF0YShzcmMpIHtcbiAgICByZXR1cm4gc3JjLnNyYyAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNTdGF0aWNJbXBvcnQoc3JjKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzcmMgPT09ICdvYmplY3QnICYmIChpc1N0YXRpY1JlcXVpcmUoc3JjKSB8fCBpc1N0YXRpY0ltYWdlRGF0YShzcmMpKTtcbn1cbmZ1bmN0aW9uIGdldFdpZHRocyh7IGRldmljZVNpemVzICwgYWxsU2l6ZXMgIH0sIHdpZHRoLCBsYXlvdXQsIHNpemVzKSB7XG4gICAgaWYgKHNpemVzICYmIChsYXlvdXQgPT09ICdmaWxsJyB8fCBsYXlvdXQgPT09ICdyZXNwb25zaXZlJykpIHtcbiAgICAgICAgLy8gRmluZCBhbGwgdGhlIFwidndcIiBwZXJjZW50IHNpemVzIHVzZWQgaW4gdGhlIHNpemVzIHByb3BcbiAgICAgICAgY29uc3Qgdmlld3BvcnRXaWR0aFJlID0gLyhefFxccykoMT9cXGQ/XFxkKXZ3L2c7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRTaXplcyA9IFtdO1xuICAgICAgICBmb3IobGV0IG1hdGNoOyBtYXRjaCA9IHZpZXdwb3J0V2lkdGhSZS5leGVjKHNpemVzKTsgbWF0Y2gpe1xuICAgICAgICAgICAgcGVyY2VudFNpemVzLnB1c2gocGFyc2VJbnQobWF0Y2hbMl0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVyY2VudFNpemVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc21hbGxlc3RSYXRpbyA9IE1hdGgubWluKC4uLnBlcmNlbnRTaXplcykgKiAwLjAxO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aHM6IGFsbFNpemVzLmZpbHRlcigocyk9PnMgPj0gZGV2aWNlU2l6ZXNbMF0gKiBzbWFsbGVzdFJhdGlvKSxcbiAgICAgICAgICAgICAgICBraW5kOiAndydcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoczogYWxsU2l6ZXMsXG4gICAgICAgICAgICBraW5kOiAndydcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ251bWJlcicgfHwgbGF5b3V0ID09PSAnZmlsbCcgfHwgbGF5b3V0ID09PSAncmVzcG9uc2l2ZScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoczogZGV2aWNlU2l6ZXMsXG4gICAgICAgICAgICBraW5kOiAndydcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGhzID0gW1xuICAgICAgICAuLi5uZXcgU2V0KC8vID4gVGhpcyBtZWFucyB0aGF0IG1vc3QgT0xFRCBzY3JlZW5zIHRoYXQgc2F5IHRoZXkgYXJlIDN4IHJlc29sdXRpb24sXG4gICAgICAgIC8vID4gYXJlIGFjdHVhbGx5IDN4IGluIHRoZSBncmVlbiBjb2xvciwgYnV0IG9ubHkgMS41eCBpbiB0aGUgcmVkIGFuZFxuICAgICAgICAvLyA+IGJsdWUgY29sb3JzLiBTaG93aW5nIGEgM3ggcmVzb2x1dGlvbiBpbWFnZSBpbiB0aGUgYXBwIHZzIGEgMnhcbiAgICAgICAgLy8gPiByZXNvbHV0aW9uIGltYWdlIHdpbGwgYmUgdmlzdWFsbHkgdGhlIHNhbWUsIHRob3VnaCB0aGUgM3ggaW1hZ2VcbiAgICAgICAgLy8gPiB0YWtlcyBzaWduaWZpY2FudGx5IG1vcmUgZGF0YS4gRXZlbiB0cnVlIDN4IHJlc29sdXRpb24gc2NyZWVucyBhcmVcbiAgICAgICAgLy8gPiB3YXN0ZWZ1bCBhcyB0aGUgaHVtYW4gZXllIGNhbm5vdCBzZWUgdGhhdCBsZXZlbCBvZiBkZXRhaWwgd2l0aG91dFxuICAgICAgICAvLyA+IHNvbWV0aGluZyBsaWtlIGEgbWFnbmlmeWluZyBnbGFzcy5cbiAgICAgICAgLy8gaHR0cHM6Ly9ibG9nLnR3aXR0ZXIuY29tL2VuZ2luZWVyaW5nL2VuX3VzL3RvcGljcy9pbmZyYXN0cnVjdHVyZS8yMDE5L2NhcHBpbmctaW1hZ2UtZmlkZWxpdHktb24tdWx0cmEtaGlnaC1yZXNvbHV0aW9uLWRldmljZXMuaHRtbFxuICAgICAgICBbXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIHdpZHRoICogMiAvKiwgd2lkdGggKiAzKi8gXG4gICAgICAgIF0ubWFwKCh3KT0+YWxsU2l6ZXMuZmluZCgocCk9PnAgPj0gdykgfHwgYWxsU2l6ZXNbYWxsU2l6ZXMubGVuZ3RoIC0gMV0pKSwgXG4gICAgXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aHMsXG4gICAgICAgIGtpbmQ6ICd4J1xuICAgIH07XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltZ0F0dHJzKHsgY29uZmlnICwgc3JjICwgdW5vcHRpbWl6ZWQgLCBsYXlvdXQgLCB3aWR0aCAsIHF1YWxpdHkgLCBzaXplcyAsIGxvYWRlciAgfSkge1xuICAgIGlmICh1bm9wdGltaXplZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgc3JjU2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaXplczogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHsgd2lkdGhzICwga2luZCAgfSA9IGdldFdpZHRocyhjb25maWcsIHdpZHRoLCBsYXlvdXQsIHNpemVzKTtcbiAgICBjb25zdCBsYXN0ID0gd2lkdGhzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2l6ZXM6ICFzaXplcyAmJiBraW5kID09PSAndycgPyAnMTAwdncnIDogc2l6ZXMsXG4gICAgICAgIHNyY1NldDogd2lkdGhzLm1hcCgodywgaSk9PmAke2xvYWRlcih7XG4gICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICBxdWFsaXR5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3XG4gICAgICAgICAgICB9KX0gJHtraW5kID09PSAndycgPyB3IDogaSArIDF9JHtraW5kfWApLmpvaW4oJywgJyksXG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgc3JjYCB0aGUgbGFzdCBhdHRyaWJ1dGUgYmVjYXVzZSBSZWFjdCB1cGRhdGVzXG4gICAgICAgIC8vIGF0dHJpYnV0ZXMgaW4gb3JkZXIuIElmIHdlIGtlZXAgYHNyY2AgdGhlIGZpcnN0IG9uZSwgU2FmYXJpIHdpbGxcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgc3RhcnQgdG8gZmV0Y2ggYHNyY2AsIGJlZm9yZSBgc2l6ZXNgIGFuZCBgc3JjU2V0YCBhcmUgZXZlblxuICAgICAgICAvLyB1cGRhdGVkIGJ5IFJlYWN0LiBUaGF0IGNhdXNlcyBtdWx0aXBsZSB1bm5lY2Vzc2FyeSByZXF1ZXN0cyBpZiBgc3JjU2V0YFxuICAgICAgICAvLyBhbmQgYHNpemVzYCBhcmUgZGVmaW5lZC5cbiAgICAgICAgLy8gVGhpcyBidWcgY2Fubm90IGJlIHJlcHJvZHVjZWQgaW4gQ2hyb21lIG9yIEZpcmVmb3guXG4gICAgICAgIHNyYzogbG9hZGVyKHtcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHF1YWxpdHksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGhzW2xhc3RdXG4gICAgICAgIH0pXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEludCh4KSB7XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoeCwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZGVmYXVsdEltYWdlTG9hZGVyKGxvYWRlclByb3BzKSB7XG4gICAgdmFyIHJlZjtcbiAgICBjb25zdCBsb2FkZXJLZXkgPSAoKHJlZiA9IGxvYWRlclByb3BzLmNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5sb2FkZXIpIHx8ICdkZWZhdWx0JztcbiAgICBjb25zdCBsb2FkID0gbG9hZGVycy5nZXQobG9hZGVyS2V5KTtcbiAgICBpZiAobG9hZCkge1xuICAgICAgICByZXR1cm4gbG9hZChsb2FkZXJQcm9wcyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBcImxvYWRlclwiIGZvdW5kIGluIFwibmV4dC5jb25maWcuanNcIi4gRXhwZWN0ZWQ6ICR7X2ltYWdlQ29uZmlnLlZBTElEX0xPQURFUlMuam9pbignLCAnKX0uIFJlY2VpdmVkOiAke2xvYWRlcktleX1gKTtcbn1cbi8vIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzk3Nzc4MzMvMjY2NTM1IGZvciB3aHkgd2UgdXNlIHRoaXMgcmVmXG4vLyBoYW5kbGVyIGluc3RlYWQgb2YgdGhlIGltZydzIG9uTG9hZCBhdHRyaWJ1dGUuXG5mdW5jdGlvbiBoYW5kbGVMb2FkaW5nKGltZywgc3JjLCBsYXlvdXQsIHBsYWNlaG9sZGVyLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlKSB7XG4gICAgaWYgKCFpbWcgfHwgaW1nLnNyYyA9PT0gZW1wdHlEYXRhVVJMIHx8IGltZ1snZGF0YS1sb2FkZWQtc3JjJ10gPT09IHNyYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGltZ1snZGF0YS1sb2FkZWQtc3JjJ10gPSBzcmM7XG4gICAgY29uc3QgcCA9ICdkZWNvZGUnIGluIGltZyA/IGltZy5kZWNvZGUoKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHAuY2F0Y2goKCk9Pnt9KS50aGVuKCgpPT57XG4gICAgICAgIGlmICghaW1nLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaW4gY2FzZSBvZiByYWNlIGNvbmRpdGlvbjpcbiAgICAgICAgICAgIC8vIC0gb25sb2FkKCkgaXMgY2FsbGVkXG4gICAgICAgICAgICAvLyAtIGRlY29kZSgpIGlzIGNhbGxlZCBidXQgaW5jb21wbGV0ZVxuICAgICAgICAgICAgLy8gLSB1bm1vdW50IGlzIGNhbGxlZFxuICAgICAgICAgICAgLy8gLSBkZWNvZGUoKSBjb21wbGV0ZXNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZWRJbWFnZVVSTHMuYWRkKHNyYyk7XG4gICAgICAgIGlmIChwbGFjZWhvbGRlciA9PT0gJ2JsdXInKSB7XG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTG9hZGluZ0NvbXBsZXRlUmVmID09IG51bGwgPyB2b2lkIDAgOiBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hdHVyYWxXaWR0aCAsIG5hdHVyYWxIZWlnaHQgIH0gPSBpbWc7XG4gICAgICAgICAgICAvLyBQYXNzIGJhY2sgcmVhZC1vbmx5IHByaW1pdGl2ZSB2YWx1ZXMgYnV0IG5vdCB0aGVcbiAgICAgICAgICAgIC8vIHVuZGVybHlpbmcgRE9NIGVsZW1lbnQgYmVjYXVzZSBpdCBjb3VsZCBiZSBtaXN1c2VkLlxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYuY3VycmVudCh7XG4gICAgICAgICAgICAgICAgbmF0dXJhbFdpZHRoLFxuICAgICAgICAgICAgICAgIG5hdHVyYWxIZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgaWYgKChyZWYgPSBpbWcucGFyZW50RWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZ2V0Q29tcHV0ZWRTdHlsZShpbWcucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudC5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwYXJlbnQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIHRvIHRoZSBkb20geWV0IGFuZCB0aGVyZWZvcmUgaXQgaGFzIG5vIHBvc2l0aW9uLiBTa2lwIHRoZSB3YXJuaW5ncyBmb3Igc3VjaCBjYXNlcy5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxheW91dCA9PT0gJ3Jlc3BvbnNpdmUnICYmIHBhcmVudC5kaXNwbGF5ID09PSAnZmxleCcpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgbWF5IG5vdCByZW5kZXIgcHJvcGVybHkgYXMgYSBjaGlsZCBvZiBhIGZsZXggY29udGFpbmVyLiBDb25zaWRlciB3cmFwcGluZyB0aGUgaW1hZ2Ugd2l0aCBhIGRpdiB0byBjb25maWd1cmUgdGhlIHdpZHRoLmApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5b3V0ID09PSAnZmlsbCcgJiYgcGFyZW50LnBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBhcmVudC5wb3NpdGlvbiAhPT0gJ2ZpeGVkJyAmJiBwYXJlbnQucG9zaXRpb24gIT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgbWF5IG5vdCByZW5kZXIgcHJvcGVybHkgd2l0aCBhIHBhcmVudCB1c2luZyBwb3NpdGlvbjpcIiR7cGFyZW50LnBvc2l0aW9ufVwiLiBDb25zaWRlciBjaGFuZ2luZyB0aGUgcGFyZW50IHN0eWxlIHRvIHBvc2l0aW9uOlwicmVsYXRpdmVcIiB3aXRoIGEgd2lkdGggYW5kIGhlaWdodC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IEltYWdlRWxlbWVudCA9IChfcGFyYW0pPT57XG4gICAgdmFyIHsgaW1nQXR0cmlidXRlcyAsIGhlaWdodEludCAsIHdpZHRoSW50ICwgcXVhbGl0eUludCAsIGxheW91dCAsIGNsYXNzTmFtZSAsIGltZ1N0eWxlICwgYmx1clN0eWxlICwgaXNMYXp5ICwgcGxhY2Vob2xkZXIgLCBsb2FkaW5nICwgc3JjU3RyaW5nICwgY29uZmlnICwgdW5vcHRpbWl6ZWQgLCBsb2FkZXIgLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiAsIHNldEJsdXJDb21wbGV0ZSAsIHNldEludGVyc2VjdGlvbiAsIG9uTG9hZCAsIG9uRXJyb3IgLCBpc1Zpc2libGUgLCBub3NjcmlwdFNpemVzICB9ID0gX3BhcmFtLCByZXN0ID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UoX3BhcmFtLCBbXG4gICAgICAgIFwiaW1nQXR0cmlidXRlc1wiLFxuICAgICAgICBcImhlaWdodEludFwiLFxuICAgICAgICBcIndpZHRoSW50XCIsXG4gICAgICAgIFwicXVhbGl0eUludFwiLFxuICAgICAgICBcImxheW91dFwiLFxuICAgICAgICBcImNsYXNzTmFtZVwiLFxuICAgICAgICBcImltZ1N0eWxlXCIsXG4gICAgICAgIFwiYmx1clN0eWxlXCIsXG4gICAgICAgIFwiaXNMYXp5XCIsXG4gICAgICAgIFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgXCJsb2FkaW5nXCIsXG4gICAgICAgIFwic3JjU3RyaW5nXCIsXG4gICAgICAgIFwiY29uZmlnXCIsXG4gICAgICAgIFwidW5vcHRpbWl6ZWRcIixcbiAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgXCJvbkxvYWRpbmdDb21wbGV0ZVJlZlwiLFxuICAgICAgICBcInNldEJsdXJDb21wbGV0ZVwiLFxuICAgICAgICBcInNldEludGVyc2VjdGlvblwiLFxuICAgICAgICBcIm9uTG9hZFwiLFxuICAgICAgICBcIm9uRXJyb3JcIixcbiAgICAgICAgXCJpc1Zpc2libGVcIixcbiAgICAgICAgXCJub3NjcmlwdFNpemVzXCJcbiAgICBdKTtcbiAgICBsb2FkaW5nID0gaXNMYXp5ID8gJ2xhenknIDogbG9hZGluZztcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwgT2JqZWN0LmFzc2lnbih7fSwgcmVzdCwgaW1nQXR0cmlidXRlcywge1xuICAgICAgICBkZWNvZGluZzogXCJhc3luY1wiLFxuICAgICAgICBcImRhdGEtbmltZ1wiOiBsYXlvdXQsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIGltZ1N0eWxlLCBibHVyU3R5bGUpLFxuICAgICAgICByZWY6ICgwLCBfcmVhY3QpLnVzZUNhbGxiYWNrKChpbWcpPT57XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmIChpbWcgJiYgIXNyY1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBJbWFnZSBpcyBtaXNzaW5nIHJlcXVpcmVkIFwic3JjXCIgcHJvcGVydHk6YCwgaW1nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRJbnRlcnNlY3Rpb24oaW1nKTtcbiAgICAgICAgICAgIGlmIChpbWcgPT0gbnVsbCA/IHZvaWQgMCA6IGltZy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBzcmNTdHJpbmcsIGxheW91dCwgcGxhY2Vob2xkZXIsIG9uTG9hZGluZ0NvbXBsZXRlUmVmLCBzZXRCbHVyQ29tcGxldGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXG4gICAgICAgICAgICBzZXRJbnRlcnNlY3Rpb24sXG4gICAgICAgICAgICBzcmNTdHJpbmcsXG4gICAgICAgICAgICBsYXlvdXQsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLFxuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlLCBcbiAgICAgICAgXSksXG4gICAgICAgIG9uTG9hZDogKGV2ZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgaW1nID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBzcmNTdHJpbmcsIGxheW91dCwgcGxhY2Vob2xkZXIsIG9uTG9hZGluZ0NvbXBsZXRlUmVmLCBzZXRCbHVyQ29tcGxldGUpO1xuICAgICAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgICAgICAgIG9uTG9hZChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChldmVudCk9PntcbiAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlciA9PT0gJ2JsdXInKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlYWwgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgdGhpcyB3aWxsIHN0aWxsIHJlbW92ZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKSwgKGlzTGF6eSB8fCBwbGFjZWhvbGRlciA9PT0gJ2JsdXInKSAmJiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJub3NjcmlwdFwiLCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwgT2JqZWN0LmFzc2lnbih7fSwgcmVzdCwgZ2VuZXJhdGVJbWdBdHRycyh7XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgc3JjOiBzcmNTdHJpbmcsXG4gICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCxcbiAgICAgICAgc2l6ZXM6IG5vc2NyaXB0U2l6ZXMsXG4gICAgICAgIGxvYWRlclxuICAgIH0pLCB7XG4gICAgICAgIGRlY29kaW5nOiBcImFzeW5jXCIsXG4gICAgICAgIFwiZGF0YS1uaW1nXCI6IGxheW91dCxcbiAgICAgICAgc3R5bGU6IGltZ1N0eWxlLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgLy8gQHRzLWlnbm9yZSAtIFRPRE86IHVwZ3JhZGUgdG8gYEB0eXBlcy9yZWFjdEAxN2BcbiAgICAgICAgbG9hZGluZzogbG9hZGluZ1xuICAgIH0pKSkpO1xufTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIkltYWdlIiwiX2V4dGVuZHMiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlIiwiX3JlYWN0IiwiX2hlYWQiLCJfaW1hZ2VDb25maWciLCJfdXNlSW50ZXJzZWN0aW9uIiwiX2ltYWdlQ29uZmlnQ29udGV4dCIsIl91dGlscyIsIl9ub3JtYWxpemVUcmFpbGluZ1NsYXNoIiwiX3BhcmFtIiwic3JjIiwic2l6ZXMiLCJfdW5vcHRpbWl6ZWQiLCJ1bm9wdGltaXplZCIsIl9wcmlvcml0eSIsInByaW9yaXR5IiwibG9hZGluZyIsIl9sYXp5Um9vdCIsImxhenlSb290IiwibGF6eUJvdW5kYXJ5IiwiY2xhc3NOYW1lIiwicXVhbGl0eSIsIndpZHRoIiwiaGVpZ2h0Iiwic3R5bGUiLCJvYmplY3RGaXQiLCJvYmplY3RQb3NpdGlvbiIsIm9uTG9hZGluZ0NvbXBsZXRlIiwiX3BsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXIiLCJibHVyRGF0YVVSTCIsImFsbCIsImNvbmZpZ0NvbnRleHQiLCJ1c2VDb250ZXh0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwiY29uZmlnIiwidXNlTWVtbyIsImMiLCJjb25maWdFbnYiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJhbGxTaXplcyIsIl90b0NvbnN1bWFibGVBcnJheSIsImRldmljZVNpemVzIiwiaW1hZ2VTaXplcyIsInNvcnQiLCJhIiwiYiIsInJlc3QiLCJsYXlvdXQiLCJsb2FkZXIiLCJkZWZhdWx0SW1hZ2VMb2FkZXIiLCJjdXN0b21JbWFnZUxvYWRlciIsIl90bXAiLCJvYmoiLCJvcHRzIiwic3RhdGljU3JjIiwiaXNTdGF0aWNJbXBvcnQiLCJzdGF0aWNJbWFnZURhdGEiLCJpc1N0YXRpY1JlcXVpcmUiLCJFcnJvciIsImNvbmNhdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJpc0xhenkiLCJzdGFydHNXaXRoIiwibG9hZGVkSW1hZ2VVUkxzIiwiaGFzIiwicmVmIiwidXNlU3RhdGUiLCJibHVyQ29tcGxldGUiLCJzZXRCbHVyQ29tcGxldGUiLCJyZWYxIiwidXNlSW50ZXJzZWN0aW9uIiwicm9vdFJlZiIsInJvb3RNYXJnaW4iLCJkaXNhYmxlZCIsInNldEludGVyc2VjdGlvbiIsImlzSW50ZXJzZWN0ZWQiLCJyZXNldEludGVyc2VjdGVkIiwiaXNWaXNpYmxlIiwid3JhcHBlclN0eWxlIiwiYm94U2l6aW5nIiwiZGlzcGxheSIsIm92ZXJmbG93IiwiYmFja2dyb3VuZCIsIm9wYWNpdHkiLCJib3JkZXIiLCJtYXJnaW4iLCJwYWRkaW5nIiwic2l6ZXJTdHlsZSIsImhhc1NpemVyIiwic2l6ZXJTdmdVcmwiLCJsYXlvdXRTdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsImJvdHRvbSIsInJpZ2h0IiwibWluV2lkdGgiLCJtYXhXaWR0aCIsIm1pbkhlaWdodCIsIm1heEhlaWdodCIsIndpZHRoSW50IiwiZ2V0SW50IiwiaGVpZ2h0SW50IiwicXVhbGl0eUludCIsInByb2Nlc3MiLCJWQUxJRF9MQVlPVVRfVkFMVUVTIiwiaW5jbHVkZXMiLCJtYXAiLCJTdHJpbmciLCJqb2luIiwiaXNOYU4iLCJ3YXJuT25jZSIsIlZBTElEX0xPQURJTkdfVkFMVUVTIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJ1cmwiLCJVUkwiLCJlcnIiLCJwYXRobmFtZSIsInNlYXJjaCIsIm92ZXJ3cml0dGVuU3R5bGVzIiwia2V5cyIsImZpbHRlciIsImtleSIsImxlbmd0aCIsInBlcmZPYnNlcnZlciIsIndpbmRvdyIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJlbnRyeUxpc3QiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uIiwiX2RpZEl0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvciIsImdldEVudHJpZXMiLCJTeW1ib2wiLCJfc3RlcCIsImVudHJ5IiwiaW1nU3JjIiwiZWxlbWVudCIsImxjcEltYWdlIiwiYWxsSW1ncyIsImdldCIsIm9ic2VydmUiLCJ0eXBlIiwiYnVmZmVyZWQiLCJjb25zb2xlIiwiZXJyb3IiLCJpbWdTdHlsZSIsImFzc2lnbiIsImJsdXJTdHlsZSIsImJhY2tncm91bmRTaXplIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZEltYWdlIiwicXVvdGllbnQiLCJwYWRkaW5nVG9wIiwiaW1nQXR0cmlidXRlcyIsImVtcHR5RGF0YVVSTCIsInNyY1NldCIsInVuZGVmaW5lZCIsImdlbmVyYXRlSW1nQXR0cnMiLCJzcmNTdHJpbmciLCJmdWxsVXJsIiwiZSIsImxvY2F0aW9uIiwiaHJlZiIsInNldCIsImltYWdlU3JjU2V0UHJvcE5hbWUiLCJpbWFnZVNpemVzUHJvcE5hbWUiLCJlbnYiLCJfX05FWFRfUkVBQ1RfUk9PVCIsIl9vYmoiLCJsaW5rUHJvcHMiLCJfZGVmaW5lUHJvcGVydHkiLCJjcm9zc09yaWdpbiIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsIm9uTG9hZGluZ0NvbXBsZXRlUmVmIiwidXNlUmVmIiwicHJldmlvdXNJbWFnZVNyYyIsImN1cnJlbnQiLCJpbWdFbGVtZW50QXJncyIsIm5vc2NyaXB0U2l6ZXMiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJhbHQiLCJJbWFnZUVsZW1lbnQiLCJyZWwiLCJhcyIsIm5vcm1hbGl6ZVNyYyIsInNsaWNlIiwiX19ORVhUX0lNQUdFX09QVFMiLCJTZXQiLCJNYXAiLCJnbG9iYWwiLCJfX05FWFRfSU1BR0VfSU1QT1JURUQiLCJpbWdpeExvYWRlciIsInBhcmFtIiwicGF0aCIsInBhcmFtcyIsInNlYXJjaFBhcmFtcyIsImdldEFsbCIsInRvU3RyaW5nIiwiYWthbWFpTG9hZGVyIiwiY2xvdWRpbmFyeUxvYWRlciIsInBhcmFtc1N0cmluZyIsImN1c3RvbUxvYWRlciIsImRlZmF1bHRMb2FkZXIiLCJtaXNzaW5nVmFsdWVzIiwicHVzaCIsImRvbWFpbnMiLCJyZW1vdGVQYXR0ZXJucyIsInBhcnNlZFNyYyIsImhhc01hdGNoIiwiaG9zdG5hbWUiLCJlbmRzV2l0aCIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJlbmNvZGVVUklDb21wb25lbnQiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsImxvYWRlcnMiLCJpc1N0YXRpY0ltYWdlRGF0YSIsImdldFdpZHRocyIsInZpZXdwb3J0V2lkdGhSZSIsInBlcmNlbnRTaXplcyIsIm1hdGNoIiwiZXhlYyIsInBhcnNlSW50IiwiTWF0aCIsInNtYWxsZXN0UmF0aW8iLCJtaW4iLCJ3aWR0aHMiLCJzIiwia2luZCIsInciLCJmaW5kIiwicCIsImxhc3QiLCJpIiwieCIsImxvYWRlclByb3BzIiwibG9hZGVyS2V5IiwibG9hZCIsIlZBTElEX0xPQURFUlMiLCJoYW5kbGVMb2FkaW5nIiwiaW1nIiwiZGVjb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsInRoZW4iLCJwYXJlbnROb2RlIiwiYWRkIiwibmF0dXJhbFdpZHRoIiwibmF0dXJhbEhlaWdodCIsInBhcmVudEVsZW1lbnQiLCJwYXJlbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwib25Mb2FkIiwib25FcnJvciIsImRlY29kaW5nIiwidXNlQ2FsbGJhY2siLCJjb21wbGV0ZSIsImV2ZW50IiwiY3VycmVudFRhcmdldCIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/image.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _slicedToArray = (__webpack_require__(/*! @swc/helpers/lib/_sliced_to_array.js */ \"./node_modules/@swc/helpers/lib/_sliced_to_array.js\")[\"default\"]);\n\nvar _typeOf = (__webpack_require__(/*! @swc/helpers/lib/_type_of.js */ \"./node_modules/@swc/helpers/lib/_type_of.js\")[\"default\"]);\n\nvar _s = $RefreshSig$();\n\n\"client\";\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\n\nvar _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ \"./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\")[\"default\"]);\n\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _router = __webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\");\n\nvar _addLocale = __webpack_require__(/*! ./add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\n\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\n\nvar _appRouterContext = __webpack_require__(/*! ../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\n\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\n\nvar _getDomainLocale = __webpack_require__(/*! ./get-domain-locale */ \"./node_modules/next/dist/client/get-domain-locale.js\");\n\nvar _addBasePath = __webpack_require__(/*! ./add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\n\n\"client\";\nvar prefetched = {};\n\nfunction prefetch(router, href, as, options) {\n  if ( false || !router) return;\n  if (!(0, _router).isLocalURL(href)) return; // Prefetch the JSON page if asked (only in the client)\n  // We need to handle a prefetch error here since we may be\n  // loading with priority which can reject but we don't\n  // want to force navigation since this is only a prefetch\n\n  Promise.resolve(router.prefetch(href, as, options)).catch(function (err) {\n    if (true) {\n      // rethrow to show invalid URL errors\n      throw err;\n    }\n  });\n  var curLocale = options && typeof options.locale !== \"undefined\" ? options.locale : router && router.locale; // Join on an invalid URI character\n\n  prefetched[href + \"%\" + as + (curLocale ? \"%\" + curLocale : \"\")] = true;\n}\n\nfunction isModifiedEvent(event) {\n  var target = event.currentTarget.target;\n  return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || event.nativeEvent && event.nativeEvent.which === 2;\n}\n\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled) {\n  var nodeName = e.currentTarget.nodeName; // anchors inside an svg have a lowercase nodeName\n\n  var isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n\n  if (isAnchorNodeName && (isModifiedEvent(e) || !(0, _router).isLocalURL(href))) {\n    // ignore click for browser’s default behavior\n    return;\n  }\n\n  e.preventDefault();\n\n  var navigate = function () {\n    // If the router is an NextRouter instance it will have `beforePopState`\n    if (\"beforePopState\" in router) {\n      router[replace ? \"replace\" : \"push\"](href, as, {\n        shallow: shallow,\n        locale: locale,\n        scroll: scroll\n      });\n    } else {\n      // If `beforePopState` doesn't exist on the router it's the AppRouter.\n      var method = replace ? \"replace\" : \"push\";\n      router[method](href, {\n        forceOptimisticNavigation: !prefetchEnabled\n      });\n    }\n  };\n\n  if (isAppRouter) {\n    // @ts-expect-error startTransition exists.\n    _react.default.startTransition(navigate);\n  } else {\n    navigate();\n  }\n}\n\nvar Link = /*#__PURE__*/_s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n  _s();\n\n  if (true) {\n    var createPropError = function createPropError(args) {\n      return new Error(\"Failed prop type: The prop `\".concat(args.key, \"` expects a \").concat(args.expected, \" in `<Link>`, but got `\").concat(args.actual, \"` instead.\") + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0));\n    }; // TypeScript trick for type-guarding:\n\n\n    var requiredPropsGuard = {\n      href: true\n    };\n    var requiredProps = Object.keys(requiredPropsGuard);\n    requiredProps.forEach(function (key) {\n      if (key === \"href\") {\n        if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n          throw createPropError({\n            key: key,\n            expected: \"`string` or `object`\",\n            actual: props[key] === null ? \"null\" : _typeOf(props[key])\n          });\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _ = key;\n      }\n    }); // TypeScript trick for type-guarding:\n\n    var optionalPropsGuard = {\n      as: true,\n      replace: true,\n      scroll: true,\n      shallow: true,\n      passHref: true,\n      prefetch: true,\n      locale: true,\n      onClick: true,\n      onMouseEnter: true,\n      onTouchStart: true,\n      legacyBehavior: true\n    };\n    var optionalProps = Object.keys(optionalPropsGuard);\n    optionalProps.forEach(function (key) {\n      var valType = _typeOf(props[key]);\n\n      if (key === \"as\") {\n        if (props[key] && valType !== \"string\" && valType !== \"object\") {\n          throw createPropError({\n            key: key,\n            expected: \"`string` or `object`\",\n            actual: valType\n          });\n        }\n      } else if (key === \"locale\") {\n        if (props[key] && valType !== \"string\") {\n          throw createPropError({\n            key: key,\n            expected: \"`string`\",\n            actual: valType\n          });\n        }\n      } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n        if (props[key] && valType !== \"function\") {\n          throw createPropError({\n            key: key,\n            expected: \"`function`\",\n            actual: valType\n          });\n        }\n      } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n        if (props[key] != null && valType !== \"boolean\") {\n          throw createPropError({\n            key: key,\n            expected: \"`boolean`\",\n            actual: valType\n          });\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _ = key;\n      }\n    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n\n    var hasWarned = _react.default.useRef(false);\n\n    if (props.prefetch && !hasWarned.current) {\n      hasWarned.current = true;\n      console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n    }\n  }\n\n  var children;\n\n  var hrefProp = props.href,\n      asProp = props.as,\n      childrenProp = props.children,\n      prefetchProp = props.prefetch,\n      passHref = props.passHref,\n      replace = props.replace,\n      shallow = props.shallow,\n      scroll = props.scroll,\n      locale = props.locale,\n      onClick = props.onClick,\n      onMouseEnter = props.onMouseEnter,\n      onTouchStart = props.onTouchStart,\n      _legacyBehavior = props.legacyBehavior,\n      legacyBehavior = _legacyBehavior === void 0 ? Boolean(false) !== true : _legacyBehavior,\n      restProps = _object_without_properties_loose(props, [\"href\", \"as\", \"children\", \"prefetch\", \"passHref\", \"replace\", \"shallow\", \"scroll\", \"locale\", \"onClick\", \"onMouseEnter\", \"onTouchStart\", \"legacyBehavior\"]);\n\n  children = childrenProp;\n\n  if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n    children = /*#__PURE__*/_react.default.createElement(\"a\", null, children);\n  }\n\n  var p = prefetchProp !== false;\n\n  var router = _react.default.useContext(_routerContext.RouterContext); // TODO-APP: type error. Remove `as any`\n\n\n  var appRouter = _react.default.useContext(_appRouterContext.AppRouterContext);\n\n  if (appRouter) {\n    router = appRouter;\n  }\n\n  var ref = _react.default.useMemo(function () {\n    var ref = _slicedToArray((0, _router).resolveHref(router, hrefProp, true), 2),\n        resolvedHref = ref[0],\n        resolvedAs = ref[1];\n\n    return {\n      href: resolvedHref,\n      as: asProp ? (0, _router).resolveHref(router, asProp) : resolvedAs || resolvedHref\n    };\n  }, [router, hrefProp, asProp]),\n      href = ref.href,\n      as = ref.as;\n\n  var previousHref = _react.default.useRef(href);\n\n  var previousAs = _react.default.useRef(as); // This will return the first child, if multiple are provided it will throw an error\n\n\n  var child;\n\n  if (legacyBehavior) {\n    if (true) {\n      if (onClick) {\n        console.warn('\"onClick\" was passed to <Link> with `href` of `'.concat(hrefProp, '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link'));\n      }\n\n      if (onMouseEnter) {\n        console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `'.concat(hrefProp, '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link'));\n      }\n\n      try {\n        child = _react.default.Children.only(children);\n      } catch (err) {\n        if (!children) {\n          throw new Error(\"No children were passed to <Link> with `href` of `\".concat(hrefProp, \"` but one child is required https://nextjs.org/docs/messages/link-no-children\"));\n        }\n\n        throw new Error(\"Multiple children were passed to <Link> with `href` of `\".concat(hrefProp, \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\") + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0));\n      }\n    } else {}\n  }\n\n  var childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n\n  var ref1 = _slicedToArray((0, _useIntersection).useIntersection({\n    rootMargin: \"200px\"\n  }), 3),\n      setIntersectionRef = ref1[0],\n      isVisible = ref1[1],\n      resetVisible = ref1[2];\n\n  var setRef = _react.default.useCallback(function (el) {\n    // Before the link getting observed, check if visible state need to be reset\n    if (previousAs.current !== as || previousHref.current !== href) {\n      resetVisible();\n      previousAs.current = as;\n      previousHref.current = href;\n    }\n\n    setIntersectionRef(el);\n\n    if (childRef) {\n      if (typeof childRef === \"function\") childRef(el);else if (typeof childRef === \"object\") {\n        childRef.current = el;\n      }\n    }\n  }, [as, childRef, href, resetVisible, setIntersectionRef]);\n\n  _react.default.useEffect(function () {\n    var shouldPrefetch = isVisible && p && (0, _router).isLocalURL(href);\n    var curLocale = typeof locale !== \"undefined\" ? locale : router && router.locale;\n    var isPrefetched = prefetched[href + \"%\" + as + (curLocale ? \"%\" + curLocale : \"\")];\n\n    if (shouldPrefetch && !isPrefetched) {\n      prefetch(router, href, as, {\n        locale: curLocale\n      });\n    }\n  }, [as, href, isVisible, locale, p, router]);\n\n  var childProps = {\n    ref: setRef,\n    onClick: function (e) {\n      if (true) {\n        if (!e) {\n          throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n        }\n      }\n\n      if (!legacyBehavior && typeof onClick === \"function\") {\n        onClick(e);\n      }\n\n      if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n        child.props.onClick(e);\n      }\n\n      if (!e.defaultPrevented) {\n        linkClicked(e, router, href, as, replace, shallow, scroll, locale, Boolean(appRouter), p);\n      }\n    },\n    onMouseEnter: function (e) {\n      if (!legacyBehavior && typeof onMouseEnter === \"function\") {\n        onMouseEnter(e);\n      }\n\n      if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n        child.props.onMouseEnter(e);\n      } // Check for not prefetch disabled in page using appRouter\n\n\n      if (!(!p && appRouter)) {\n        if ((0, _router).isLocalURL(href)) {\n          prefetch(router, href, as, {\n            priority: true\n          });\n        }\n      }\n    },\n    onTouchStart: function (e) {\n      if (!legacyBehavior && typeof onTouchStart === \"function\") {\n        onTouchStart(e);\n      }\n\n      if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n        child.props.onTouchStart(e);\n      } // Check for not prefetch disabled in page using appRouter\n\n\n      if (!(!p && appRouter)) {\n        if ((0, _router).isLocalURL(href)) {\n          prefetch(router, href, as, {\n            priority: true\n          });\n        }\n      }\n    }\n  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n  // defined, we specify the current 'href', so that repetition is not needed by the user\n\n  if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n    var curLocale = typeof locale !== \"undefined\" ? locale : router && router.locale; // we only render domain locales if we are currently on a domain locale\n    // so that locale links are still visitable in development/preview envs\n\n    var localeDomain = router && router.isLocaleDomain && (0, _getDomainLocale).getDomainLocale(as, curLocale, router.locales, router.domainLocales);\n    childProps.href = localeDomain || (0, _addBasePath).addBasePath((0, _addLocale).addLocale(as, curLocale, router && router.defaultLocale));\n  }\n\n  return legacyBehavior ? /*#__PURE__*/_react.default.cloneElement(child, childProps) : /*#__PURE__*/_react.default.createElement(\"a\", Object.assign({}, restProps, childProps), children);\n}, \"xuB00qEWT1T+jc4Svm2qUBtJuIg=\")), \"xuB00qEWT1T+jc4Svm2qUBtJuIg=\");\n\n_c1 = Link;\nvar _default = Link;\nexports[\"default\"] = _default;\n\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n  Object.defineProperty(exports.default, \"__esModule\", {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\n\n\nvar _c, _c1;\n\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUNhOzs7Ozs7Ozs7Ozs7QUFEYjtBQUVBQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3Q0gsRUFBQUE7QUFHQUUsa0JBQUFBLEdBQWtCLEtBQUssQ0FBdkJBOztBQUNBLElBQUlHLHdCQUF3QixHQUFHQyxtSkFBL0I7O0FBQ0EsSUFBSUMsZ0NBQWdDLEdBQUdELG1LQUF2Qzs7QUFDQSxJQUFJRSxNQUFNLEdBQUdILHdCQUF3QixDQUFDQyxtQkFBTyxDQUFDLDRDQUFELENBQVIsQ0FBckM7O0FBQ0EsSUFBSUcsT0FBTyxHQUFHSCxtQkFBTyxDQUFDLHlGQUFELENBQXJCOztBQUNBLElBQUlJLFVBQVUsR0FBR0osbUJBQU8sQ0FBQyxtRUFBRCxDQUF4Qjs7QUFDQSxJQUFJSyxjQUFjLEdBQUdMLG1CQUFPLENBQUMsMkZBQUQsQ0FBNUI7O0FBQ0EsSUFBSU0saUJBQWlCLEdBQUdOLG1CQUFPLENBQUMsbUdBQUQsQ0FBL0I7O0FBQ0EsSUFBSU8sZ0JBQWdCLEdBQUdQLG1CQUFPLENBQUMsK0VBQUQsQ0FBOUI7O0FBQ0EsSUFBSVEsZ0JBQWdCLEdBQUdSLG1CQUFPLENBQUMsaUZBQUQsQ0FBOUI7O0FBQ0EsSUFBSVMsWUFBWSxHQUFHVCxtQkFBTyxDQUFDLHlFQUFELENBQTFCOztBQUNBO0FBQ0EsSUFBTVUsVUFBVSxHQUFHLEVBQW5COztBQUNBLFNBQVNDLFFBQVQsQ0FBa0JDLE1BQWxCLEVBQTBCQyxJQUExQixFQUFnQ0MsRUFBaEMsRUFBb0NDLE9BQXBDLEVBQTZDO0VBQ3pDLElBQUksVUFBaUMsQ0FBQ0gsTUFBdEMsRUFBOEM7RUFDOUMsSUFBSSxDQUFDLENBQUMsR0FBR1QsT0FBSixFQUFhYSxVQUFiLENBQXdCSCxJQUF4QixDQUFMLEVBQW9DLE9BRkssQ0FHekM7RUFDQTtFQUNBO0VBQ0E7O0VBQ0FJLE9BQU8sQ0FBQ0MsT0FBUkQsQ0FBZ0JM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T0FBTyxDQUFDRSxPQUE5QkosRUFBdUMsWUFBdkNBLEVBQXFEO0lBQUVHLEtBQUssRUFBRTtFQUFULENBQXJESDtFQUNBQSxNQUFNLENBQUMySSxNQUFQM0ksQ0FBY0UsT0FBTyxDQUFDRSxPQUF0QkosRUFBK0JFLE9BQS9CRjtFQUNBOEksTUFBTSxDQUFDNUksT0FBUDRJLEdBQWlCNUksT0FBTyxDQUFDRSxPQUF6QjBJO0FBQ0QsQyxDQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanM/ZTRmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcImNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZS5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yb3V0ZXIgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyXCIpO1xudmFyIF9hZGRMb2NhbGUgPSByZXF1aXJlKFwiLi9hZGQtbG9jYWxlXCIpO1xudmFyIF9yb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHRcIik7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG52YXIgX3VzZUludGVyc2VjdGlvbiA9IHJlcXVpcmUoXCIuL3VzZS1pbnRlcnNlY3Rpb25cIik7XG52YXIgX2dldERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoXCIuL2dldC1kb21haW4tbG9jYWxlXCIpO1xudmFyIF9hZGRCYXNlUGF0aCA9IHJlcXVpcmUoXCIuL2FkZC1iYXNlLXBhdGhcIik7XG4nY2xpZW50JztcbmNvbnN0IHByZWZldGNoZWQgPSB7fTtcbmZ1bmN0aW9uIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXJvdXRlcikgcmV0dXJuO1xuICAgIGlmICghKDAsIF9yb3V0ZXIpLmlzTG9jYWxVUkwoaHJlZikpIHJldHVybjtcbiAgICAvLyBQcmVmZXRjaCB0aGUgSlNPTiBwYWdlIGlmIGFza2VkIChvbmx5IGluIHRoZSBjbGllbnQpXG4gICAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAgIC8vIGxvYWRpbmcgd2l0aCBwcmlvcml0eSB3aGljaCBjYW4gcmVqZWN0IGJ1dCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgdG8gZm9yY2UgbmF2aWdhdGlvbiBzaW5jZSB0aGlzIGlzIG9ubHkgYSBwcmVmZXRjaFxuICAgIFByb21pc2UucmVzb2x2ZShyb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXMsIG9wdGlvbnMpKS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgY3VyTG9jYWxlID0gb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5sb2NhbGUgOiByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZTtcbiAgICAvLyBKb2luIG9uIGFuIGludmFsaWQgVVJJIGNoYXJhY3RlclxuICAgIHByZWZldGNoZWRbaHJlZiArICclJyArIGFzICsgKGN1ckxvY2FsZSA/ICclJyArIGN1ckxvY2FsZSA6ICcnKV0gPSB0cnVlO1xufVxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgeyB0YXJnZXQgIH0gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0ICE9PSAnX3NlbGYnIHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDI7XG59XG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSwgaXNBcHBSb3V0ZXIsIHByZWZldGNoRW5hYmxlZCkge1xuICAgIGNvbnN0IHsgbm9kZU5hbWUgIH0gPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgLy8gYW5jaG9ycyBpbnNpZGUgYW4gc3ZnIGhhdmUgYSBsb3dlcmNhc2Ugbm9kZU5hbWVcbiAgICBjb25zdCBpc0FuY2hvck5vZGVOYW1lID0gbm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0EnO1xuICAgIGlmIChpc0FuY2hvck5vZGVOYW1lICYmIChpc01vZGlmaWVkRXZlbnQoZSkgfHwgISgwLCBfcm91dGVyKS5pc0xvY2FsVVJMKGhyZWYpKSkge1xuICAgICAgICAvLyBpZ25vcmUgY2xpY2sgZm9yIGJyb3dzZXLigJlzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgbmF2aWdhdGUgPSAoKT0+e1xuICAgICAgICAvLyBJZiB0aGUgcm91dGVyIGlzIGFuIE5leHRSb3V0ZXIgaW5zdGFuY2UgaXQgd2lsbCBoYXZlIGBiZWZvcmVQb3BTdGF0ZWBcbiAgICAgICAgaWYgKCdiZWZvcmVQb3BTdGF0ZScgaW4gcm91dGVyKSB7XG4gICAgICAgICAgICByb3V0ZXJbcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdwdXNoJ10oaHJlZiwgYXMsIHtcbiAgICAgICAgICAgICAgICBzaGFsbG93LFxuICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBzY3JvbGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgYGJlZm9yZVBvcFN0YXRlYCBkb2Vzbid0IGV4aXN0IG9uIHRoZSByb3V0ZXIgaXQncyB0aGUgQXBwUm91dGVyLlxuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdwdXNoJztcbiAgICAgICAgICAgIHJvdXRlclttZXRob2RdKGhyZWYsIHtcbiAgICAgICAgICAgICAgICBmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uOiAhcHJlZmV0Y2hFbmFibGVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQXBwUm91dGVyKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc3RhcnRUcmFuc2l0aW9uIGV4aXN0cy5cbiAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKG5hdmlnYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuYXZpZ2F0ZSgpO1xuICAgIH1cbn1cbmNvbnN0IExpbmsgPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmZvcndhcmRSZWYoZnVuY3Rpb24gTGlua0NvbXBvbmVudChwcm9wcywgZm9yd2FyZGVkUmVmKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUHJvcEVycm9yKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYEZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIFxcYCR7YXJncy5rZXl9XFxgIGV4cGVjdHMgYSAke2FyZ3MuZXhwZWN0ZWR9IGluIFxcYDxMaW5rPlxcYCwgYnV0IGdvdCBcXGAke2FyZ3MuYWN0dWFsfVxcYCBpbnN0ZWFkLmAgKyAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCIgOiAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcHNHdWFyZCA9IHtcbiAgICAgICAgICAgIGhyZWY6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWRQcm9wcyA9IE9iamVjdC5rZXlzKHJlcXVpcmVkUHJvcHNHdWFyZCk7XG4gICAgICAgIHJlcXVpcmVkUHJvcHMuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHByb3BzW2tleV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBwcm9wc1trZXldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgY29uc3QgXyA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHNHdWFyZCA9IHtcbiAgICAgICAgICAgIGFzOiB0cnVlLFxuICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgIHNoYWxsb3c6IHRydWUsXG4gICAgICAgICAgICBwYXNzSHJlZjogdHJ1ZSxcbiAgICAgICAgICAgIHByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgbG9jYWxlOiB0cnVlLFxuICAgICAgICAgICAgb25DbGljazogdHJ1ZSxcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcjogdHJ1ZSxcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydDogdHJ1ZSxcbiAgICAgICAgICAgIGxlZ2FjeUJlaGF2aW9yOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSBPYmplY3Qua2V5cyhvcHRpb25hbFByb3BzR3VhcmQpO1xuICAgICAgICBvcHRpb25hbFByb3BzLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IHZhbFR5cGUgPSB0eXBlb2YgcHJvcHNba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdhcycpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJyAmJiB2YWxUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCBvciBgb2JqZWN0YCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdsb2NhbGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnb25DbGljaycgfHwga2V5ID09PSAnb25Nb3VzZUVudGVyJyB8fCBrZXkgPT09ICdvblRvdWNoU3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgZnVuY3Rpb25gJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3JlcGxhY2UnIHx8IGtleSA9PT0gJ3Njcm9sbCcgfHwga2V5ID09PSAnc2hhbGxvdycgfHwga2V5ID09PSAncGFzc0hyZWYnIHx8IGtleSA9PT0gJ3ByZWZldGNoJyB8fCBrZXkgPT09ICdsZWdhY3lCZWhhdmlvcicpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAhPSBudWxsICYmIHZhbFR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgYm9vbGVhbmAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgY29uc3QgXyA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoaXMgaG9vayBpcyBpbiBhIGNvbmRpdGlvbmFsIGJ1dCB0aGF0IGlzIG9rIGJlY2F1c2UgYHByb2Nlc3MuZW52Lk5PREVfRU5WYCBuZXZlciBjaGFuZ2VzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICBjb25zdCBoYXNXYXJuZWQgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoZmFsc2UpO1xuICAgICAgICBpZiAocHJvcHMucHJlZmV0Y2ggJiYgIWhhc1dhcm5lZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBoYXNXYXJuZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05leHQuanMgYXV0by1wcmVmZXRjaGVzIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdmlld3BvcnQuIFRoZSBwcmVmZXRjaCBhdHRyaWJ1dGUgaXMgbm8gbG9uZ2VyIG5lZWRlZC4gTW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcHJlZmV0Y2gtdHJ1ZS1kZXByZWNhdGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuO1xuICAgIGNvbnN0IHsgaHJlZjogaHJlZlByb3AgLCBhczogYXNQcm9wICwgY2hpbGRyZW46IGNoaWxkcmVuUHJvcCAsIHByZWZldGNoOiBwcmVmZXRjaFByb3AgLCBwYXNzSHJlZiAsIHJlcGxhY2UgLCBzaGFsbG93ICwgc2Nyb2xsICwgbG9jYWxlICwgb25DbGljayAsIG9uTW91c2VFbnRlciAsIG9uVG91Y2hTdGFydCAsIGxlZ2FjeUJlaGF2aW9yID1Cb29sZWFuKHByb2Nlc3MuZW52Ll9fTkVYVF9ORVdfTElOS19CRUhBVklPUikgIT09IHRydWUgIH0gPSBwcm9wcywgcmVzdFByb3BzID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UocHJvcHMsIFtcbiAgICAgICAgXCJocmVmXCIsXG4gICAgICAgIFwiYXNcIixcbiAgICAgICAgXCJjaGlsZHJlblwiLFxuICAgICAgICBcInByZWZldGNoXCIsXG4gICAgICAgIFwicGFzc0hyZWZcIixcbiAgICAgICAgXCJyZXBsYWNlXCIsXG4gICAgICAgIFwic2hhbGxvd1wiLFxuICAgICAgICBcInNjcm9sbFwiLFxuICAgICAgICBcImxvY2FsZVwiLFxuICAgICAgICBcIm9uQ2xpY2tcIixcbiAgICAgICAgXCJvbk1vdXNlRW50ZXJcIixcbiAgICAgICAgXCJvblRvdWNoU3RhcnRcIixcbiAgICAgICAgXCJsZWdhY3lCZWhhdmlvclwiXG4gICAgXSk7XG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlblByb3A7XG4gICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZHJlbiA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYVwiLCBudWxsLCBjaGlsZHJlbik7XG4gICAgfVxuICAgIGNvbnN0IHAgPSBwcmVmZXRjaFByb3AgIT09IGZhbHNlO1xuICAgIGxldCByb3V0ZXIgPSBfcmVhY3QuZGVmYXVsdC51c2VDb250ZXh0KF9yb3V0ZXJDb250ZXh0LlJvdXRlckNvbnRleHQpO1xuICAgIC8vIFRPRE8tQVBQOiB0eXBlIGVycm9yLiBSZW1vdmUgYGFzIGFueWBcbiAgICBjb25zdCBhcHBSb3V0ZXIgPSBfcmVhY3QuZGVmYXVsdC51c2VDb250ZXh0KF9hcHBSb3V0ZXJDb250ZXh0LkFwcFJvdXRlckNvbnRleHQpO1xuICAgIGlmIChhcHBSb3V0ZXIpIHtcbiAgICAgICAgcm91dGVyID0gYXBwUm91dGVyO1xuICAgIH1cbiAgICBjb25zdCB7IGhyZWYgLCBhcyAgfSA9IF9yZWFjdC5kZWZhdWx0LnVzZU1lbW8oKCk9PntcbiAgICAgICAgY29uc3QgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSAoMCwgX3JvdXRlcikucmVzb2x2ZUhyZWYocm91dGVyLCBocmVmUHJvcCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICBhczogYXNQcm9wID8gKDAsIF9yb3V0ZXIpLnJlc29sdmVIcmVmKHJvdXRlciwgYXNQcm9wKSA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICByb3V0ZXIsXG4gICAgICAgIGhyZWZQcm9wLFxuICAgICAgICBhc1Byb3BcbiAgICBdKTtcbiAgICBjb25zdCBwcmV2aW91c0hyZWYgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoaHJlZik7XG4gICAgY29uc3QgcHJldmlvdXNBcyA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihhcyk7XG4gICAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gICAgbGV0IGNoaWxkO1xuICAgIGlmIChsZWdhY3lCZWhhdmlvcikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBcIm9uQ2xpY2tcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uQ2xpY2sgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmtgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbk1vdXNlRW50ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFwib25Nb3VzZUVudGVyXCIgd2FzIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBcImxlZ2FjeUJlaGF2aW9yXCIgd2FzIHNldC4gVGhlIGxlZ2FjeSBiZWhhdmlvciByZXF1aXJlcyBvbk1vdXNlRW50ZXIgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmtgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBjaGlsZHJlbiB3ZXJlIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBvbmUgY2hpbGQgaXMgcmVxdWlyZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1uby1jaGlsZHJlbmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGxlIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IG9ubHkgb25lIGNoaWxkIGlzIHN1cHBvcnRlZCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9saW5rLW11bHRpcGxlLWNoaWxkcmVuYCArICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFwiIFxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCIgOiAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGQgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaGlsZFJlZiA9IGxlZ2FjeUJlaGF2aW9yID8gY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09PSAnb2JqZWN0JyAmJiBjaGlsZC5yZWYgOiBmb3J3YXJkZWRSZWY7XG4gICAgY29uc3QgW3NldEludGVyc2VjdGlvblJlZiwgaXNWaXNpYmxlLCByZXNldFZpc2libGVdID0gKDAsIF91c2VJbnRlcnNlY3Rpb24pLnVzZUludGVyc2VjdGlvbih7XG4gICAgICAgIHJvb3RNYXJnaW46ICcyMDBweCdcbiAgICB9KTtcbiAgICBjb25zdCBzZXRSZWYgPSBfcmVhY3QuZGVmYXVsdC51c2VDYWxsYmFjaygoZWwpPT57XG4gICAgICAgIC8vIEJlZm9yZSB0aGUgbGluayBnZXR0aW5nIG9ic2VydmVkLCBjaGVjayBpZiB2aXNpYmxlIHN0YXRlIG5lZWQgdG8gYmUgcmVzZXRcbiAgICAgICAgaWYgKHByZXZpb3VzQXMuY3VycmVudCAhPT0gYXMgfHwgcHJldmlvdXNIcmVmLmN1cnJlbnQgIT09IGhyZWYpIHtcbiAgICAgICAgICAgIHJlc2V0VmlzaWJsZSgpO1xuICAgICAgICAgICAgcHJldmlvdXNBcy5jdXJyZW50ID0gYXM7XG4gICAgICAgICAgICBwcmV2aW91c0hyZWYuY3VycmVudCA9IGhyZWY7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW50ZXJzZWN0aW9uUmVmKGVsKTtcbiAgICAgICAgaWYgKGNoaWxkUmVmKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkUmVmID09PSAnZnVuY3Rpb24nKSBjaGlsZFJlZihlbCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRSZWYuY3VycmVudCA9IGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBhcyxcbiAgICAgICAgY2hpbGRSZWYsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIHJlc2V0VmlzaWJsZSxcbiAgICAgICAgc2V0SW50ZXJzZWN0aW9uUmVmXG4gICAgXSk7XG4gICAgX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGNvbnN0IHNob3VsZFByZWZldGNoID0gaXNWaXNpYmxlICYmIHAgJiYgKDAsIF9yb3V0ZXIpLmlzTG9jYWxVUkwoaHJlZik7XG4gICAgICAgIGNvbnN0IGN1ckxvY2FsZSA9IHR5cGVvZiBsb2NhbGUgIT09ICd1bmRlZmluZWQnID8gbG9jYWxlIDogcm91dGVyICYmIHJvdXRlci5sb2NhbGU7XG4gICAgICAgIGNvbnN0IGlzUHJlZmV0Y2hlZCA9IHByZWZldGNoZWRbaHJlZiArICclJyArIGFzICsgKGN1ckxvY2FsZSA/ICclJyArIGN1ckxvY2FsZSA6ICcnKV07XG4gICAgICAgIGlmIChzaG91bGRQcmVmZXRjaCAmJiAhaXNQcmVmZXRjaGVkKSB7XG4gICAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgbG9jYWxlOiBjdXJMb2NhbGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBhcyxcbiAgICAgICAgaHJlZixcbiAgICAgICAgaXNWaXNpYmxlLFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIHAsXG4gICAgICAgIHJvdXRlclxuICAgIF0pO1xuICAgIGNvbnN0IGNoaWxkUHJvcHMgPSB7XG4gICAgICAgIHJlZjogc2V0UmVmLFxuICAgICAgICBvbkNsaWNrOiAoZSk9PntcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9uZW50IHJlbmRlcmVkIGluc2lkZSBuZXh0L2xpbmsgaGFzIHRvIHBhc3MgY2xpY2sgZXZlbnQgdG8gXCJvbkNsaWNrXCIgcHJvcC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25DbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uQ2xpY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlLCBCb29sZWFuKGFwcFJvdXRlciksIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRW50ZXI6IChlKT0+e1xuICAgICAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25Nb3VzZUVudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3Igbm90IHByZWZldGNoIGRpc2FibGVkIGluIHBhZ2UgdXNpbmcgYXBwUm91dGVyXG4gICAgICAgICAgICBpZiAoISghcCAmJiBhcHBSb3V0ZXIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfcm91dGVyKS5pc0xvY2FsVVJMKGhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Ub3VjaFN0YXJ0OiAoZSk9PntcbiAgICAgICAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uVG91Y2hTdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9uVG91Y2hTdGFydChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Ub3VjaFN0YXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25Ub3VjaFN0YXJ0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG5vdCBwcmVmZXRjaCBkaXNhYmxlZCBpbiBwYWdlIHVzaW5nIGFwcFJvdXRlclxuICAgICAgICAgICAgaWYgKCEoIXAgJiYgYXBwUm91dGVyKSkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX3JvdXRlcikuaXNMb2NhbFVSTChocmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIElmIGNoaWxkIGlzIGFuIDxhPiB0YWcgYW5kIGRvZXNuJ3QgaGF2ZSBhIGhyZWYgYXR0cmlidXRlLCBvciBpZiB0aGUgJ3Bhc3NIcmVmJyBwcm9wZXJ0eSBpc1xuICAgIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlclxuICAgIGlmICghbGVnYWN5QmVoYXZpb3IgfHwgcGFzc0hyZWYgfHwgY2hpbGQudHlwZSA9PT0gJ2EnICYmICEoJ2hyZWYnIGluIGNoaWxkLnByb3BzKSkge1xuICAgICAgICBjb25zdCBjdXJMb2NhbGUgPSB0eXBlb2YgbG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IGxvY2FsZSA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlO1xuICAgICAgICAvLyB3ZSBvbmx5IHJlbmRlciBkb21haW4gbG9jYWxlcyBpZiB3ZSBhcmUgY3VycmVudGx5IG9uIGEgZG9tYWluIGxvY2FsZVxuICAgICAgICAvLyBzbyB0aGF0IGxvY2FsZSBsaW5rcyBhcmUgc3RpbGwgdmlzaXRhYmxlIGluIGRldmVsb3BtZW50L3ByZXZpZXcgZW52c1xuICAgICAgICBjb25zdCBsb2NhbGVEb21haW4gPSByb3V0ZXIgJiYgcm91dGVyLmlzTG9jYWxlRG9tYWluICYmICgwLCBfZ2V0RG9tYWluTG9jYWxlKS5nZXREb21haW5Mb2NhbGUoYXMsIGN1ckxvY2FsZSwgcm91dGVyLmxvY2FsZXMsIHJvdXRlci5kb21haW5Mb2NhbGVzKTtcbiAgICAgICAgY2hpbGRQcm9wcy5ocmVmID0gbG9jYWxlRG9tYWluIHx8ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKCgwLCBfYWRkTG9jYWxlKS5hZGRMb2NhbGUoYXMsIGN1ckxvY2FsZSwgcm91dGVyICYmIHJvdXRlci5kZWZhdWx0TG9jYWxlKSk7XG4gICAgfVxuICAgIHJldHVybiBsZWdhY3lCZWhhdmlvciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwgT2JqZWN0LmFzc2lnbih7fSwgcmVzdFByb3BzLCBjaGlsZFByb3BzKSwgY2hpbGRyZW4pO1xufSk7XG52YXIgX2RlZmF1bHQgPSBMaW5rO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmsuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZSIsIl9yZWFjdCIsIl9yb3V0ZXIiLCJfYWRkTG9jYWxlIiwiX3JvdXRlckNvbnRleHQiLCJfYXBwUm91dGVyQ29udGV4dCIsIl91c2VJbnRlcnNlY3Rpb24iLCJfZ2V0RG9tYWluTG9jYWxlIiwiX2FkZEJhc2VQYXRoIiwicHJlZmV0Y2hlZCIsInByZWZldGNoIiwicm91dGVyIiwiaHJlZiIsImFzIiwib3B0aW9ucyIsImlzTG9jYWxVUkwiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhdGNoIiwiZXJyIiwicHJvY2VzcyIsImN1ckxvY2FsZSIsImxvY2FsZSIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwidGFyZ2V0IiwiY3VycmVudFRhcmdldCIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwicmVwbGFjZSIsInNoYWxsb3ciLCJzY3JvbGwiLCJpc0FwcFJvdXRlciIsInByZWZldGNoRW5hYmxlZCIsIm5vZGVOYW1lIiwiaXNBbmNob3JOb2RlTmFtZSIsInRvVXBwZXJDYXNlIiwicHJldmVudERlZmF1bHQiLCJuYXZpZ2F0ZSIsIm1ldGhvZCIsImZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24iLCJzdGFydFRyYW5zaXRpb24iLCJMaW5rIiwiZm9yd2FyZFJlZiIsIl9jIiwiTGlua0NvbXBvbmVudCIsInByb3BzIiwiZm9yd2FyZGVkUmVmIiwiY3JlYXRlUHJvcEVycm9yIiwiYXJncyIsIkVycm9yIiwia2V5IiwiZXhwZWN0ZWQiLCJjb25jYXQiLCJhY3R1YWwiLCJyZXF1aXJlZFByb3BzR3VhcmQiLCJyZXF1aXJlZFByb3BzIiwia2V5cyIsImZvckVhY2giLCJfdHlwZU9mIiwiXyIsIm9wdGlvbmFsUHJvcHNHdWFyZCIsInBhc3NIcmVmIiwib25DbGljayIsIm9uTW91c2VFbnRlciIsIm9uVG91Y2hTdGFydCIsImxlZ2FjeUJlaGF2aW9yIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJoYXNXYXJuZWQiLCJ1c2VSZWYiLCJjdXJyZW50IiwiY29uc29sZSIsIndhcm4iLCJjaGlsZHJlbiIsIl9sZWdhY3lCZWhhdmlvciIsIkJvb2xlYW4iLCJlbnYiLCJfX05FWFRfTkVXX0xJTktfQkVIQVZJT1IiLCJyZXN0UHJvcHMiLCJjaGlsZHJlblByb3AiLCJjcmVhdGVFbGVtZW50IiwicCIsInByZWZldGNoUHJvcCIsInVzZUNvbnRleHQiLCJSb3V0ZXJDb250ZXh0IiwiYXBwUm91dGVyIiwiQXBwUm91dGVyQ29udGV4dCIsInVzZU1lbW8iLCJyZWYiLCJyZXNvbHZlSHJlZiIsImhyZWZQcm9wIiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZWRBcyIsImFzUHJvcCIsInByZXZpb3VzSHJlZiIsInByZXZpb3VzQXMiLCJjaGlsZCIsIkNoaWxkcmVuIiwib25seSIsImNoaWxkUmVmIiwicmVmMSIsInVzZUludGVyc2VjdGlvbiIsInJvb3RNYXJnaW4iLCJzZXRJbnRlcnNlY3Rpb25SZWYiLCJpc1Zpc2libGUiLCJyZXNldFZpc2libGUiLCJzZXRSZWYiLCJ1c2VDYWxsYmFjayIsImVsIiwidXNlRWZmZWN0Iiwic2hvdWxkUHJlZmV0Y2giLCJpc1ByZWZldGNoZWQiLCJjaGlsZFByb3BzIiwiZGVmYXVsdFByZXZlbnRlZCIsInByaW9yaXR5IiwidHlwZSIsImxvY2FsZURvbWFpbiIsImlzTG9jYWxlRG9tYWluIiwiZ2V0RG9tYWluTG9jYWxlIiwibG9jYWxlcyIsImRvbWFpbkxvY2FsZXMiLCJhZGRCYXNlUGF0aCIsImFkZExvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJjbG9uZUVsZW1lbnQiLCJhc3NpZ24iLCJfZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _slicedToArray = (__webpack_require__(/*! @swc/helpers/lib/_sliced_to_array.js */ \"./node_modules/@swc/helpers/lib/_sliced_to_array.js\")[\"default\"]);\n\nvar _s = $RefreshSig$();\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.useIntersection = useIntersection;\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\n\nvar hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nvar observers = new Map();\nvar idList = [];\n\nfunction createObserver(options) {\n  var id = {\n    root: options.root || null,\n    margin: options.rootMargin || \"\"\n  };\n  var existing = idList.find(function (obj) {\n    return obj.root === id.root && obj.margin === id.margin;\n  });\n  var instance;\n\n  if (existing) {\n    instance = observers.get(existing);\n\n    if (instance) {\n      return instance;\n    }\n  }\n\n  var elements = new Map();\n  var observer = new IntersectionObserver(function (entries) {\n    entries.forEach(function (entry) {\n      var callback = elements.get(entry.target);\n      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n\n      if (callback && isVisible) {\n        callback(isVisible);\n      }\n    });\n  }, options);\n  instance = {\n    id: id,\n    observer: observer,\n    elements: elements\n  };\n  idList.push(id);\n  observers.set(id, instance);\n  return instance;\n}\n\nfunction observe(element, callback, options) {\n  var ref = createObserver(options),\n      id = ref.id,\n      observer = ref.observer,\n      elements = ref.elements;\n  elements.set(element, callback);\n  observer.observe(element);\n  return function unobserve() {\n    elements.delete(element);\n    observer.unobserve(element); // Destroy observer when there's nothing left to watch:\n\n    if (elements.size === 0) {\n      observer.disconnect();\n      observers.delete(id);\n      var index = idList.findIndex(function (obj) {\n        return obj.root === id.root && obj.margin === id.margin;\n      });\n\n      if (index > -1) {\n        idList.splice(index, 1);\n      }\n    }\n  };\n}\n\nfunction useIntersection(param) {\n  var rootRef = param.rootRef,\n      rootMargin = param.rootMargin,\n      disabled = param.disabled;\n\n  _s();\n\n  var isDisabled = disabled || !hasIntersectionObserver;\n\n  var ref = _slicedToArray((0, _react).useState(false), 2),\n      visible = ref[0],\n      setVisible = ref[1];\n\n  var ref1 = _slicedToArray((0, _react).useState(null), 2),\n      element = ref1[0],\n      setElement = ref1[1];\n\n  (0, _react).useEffect(function () {\n    if (hasIntersectionObserver) {\n      if (isDisabled || visible) return;\n\n      if (element && element.tagName) {\n        var unobserve = observe(element, function (isVisible) {\n          return isVisible && setVisible(isVisible);\n        }, {\n          root: rootRef == null ? void 0 : rootRef.current,\n          rootMargin: rootMargin\n        });\n        return unobserve;\n      }\n    } else {\n      if (!visible) {\n        var idleCallback = (0, _requestIdleCallback).requestIdleCallback(function () {\n          return setVisible(true);\n        });\n        return function () {\n          return (0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n        };\n      }\n    }\n  }, [element, isDisabled, rootMargin, rootRef, visible]);\n  var resetVisible = (0, _react).useCallback(function () {\n    setVisible(false);\n  }, []);\n  return [setElement, visible, resetVisible];\n}\n\n_s(useIntersection, \"mCSdCffdW7h1A87zcVCmaEd/d2A=\");\n\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n  Object.defineProperty(exports.default, \"__esModule\", {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOzs7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDSCxFQUFBQTtBQUdBRSx1QkFBQUEsR0FBMEJFLGVBQTFCRjs7QUFDQSxJQUFJRyxNQUFNLEdBQUdDLG1CQUFPLENBQUMsNENBQUQsQ0FBcEI7O0FBQ0EsSUFBSUMsb0JBQW9CLEdBQUdELG1CQUFPLENBQUMseUZBQUQsQ0FBbEM7O0FBQ0EsSUFBTUUsdUJBQXVCLEdBQUcsT0FBT0Msb0JBQVAsS0FBZ0MsVUFBaEU7QUFDQSxJQUFNQyxTQUFTLEdBQUcsSUFBSUMsR0FBSixFQUFsQjtBQUNBLElBQU1DLE1BQU0sR0FBRyxFQUFmOztBQUNBLFNBQVNDLGNBQVQsQ0FBd0JDLE9BQXhCLEVBQWlDO0VBQzdCLElBQU1DLEVBQUUsR0FBRztJQUNQQyxJQUFJLEVBQUVGLE9BQU8sQ0FBQ0UsSUFBUkYsSUFBZ0IsSUFEZjtJQUVQRyxNQUFNLEVBQUVILE9BQU8sQ0FBQ0ksVUFBUkosSUFBc0I7RUFGdkIsQ0FBWDtFQUlBLElBQU1LLFFBQVEsR0FBR1AsTUFBTSxDQUFDUSxJQUFQUixDQUFZLFVBQUNTLEdBQUQsRUFBSTtXQUFHQSxHQUFHLENBQUNMLElBQUpLLEtBQWFOLEVBQUUsQ0FBQ0MsSUFBaEJLLElBQXdCQSxHQUFHLENBQUNKLE1BQUpJLEtBQWVOLEVBQUUsQ0FBQ0U7RUFBTSxDQUFuRUwsQ0FBakI7RUFDQSxJQUFJVSxRQUFKOztFQUNBLElBQUlILFFBQUosRUFBYztJQUNWRyxRQUFRLEdBQUdaLFNBQVMsQ0FBQ2EsR0FBVmIsQ0FBY1MsUUFBZFQsQ0FBWFk7O0lBQ0EsSUFBSUEsUUFBSixFQUFjO01BQ1YsT0FBT0EsUUFBUDtJQUNIO0VBQ0o7O0VBQ0QsSUFBTUUsUUFBUSxHQUFHLElBQUliLEdBQUosRUFBakI7RUFDQSxJQUFNYyxRQUFRLEdB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QUVISCxPQUZHLEVBR0hVLFlBSEcsQ0FBUDtBQUtIOztHQW5DUXpELGlCQUFlOztBQXFDeEIsSUFBSSxDQUFDLE9BQU9GLE9BQU8sQ0FBQzZELE9BQWYsS0FBMkIsVUFBM0IsSUFBMEMsT0FBTzdELE9BQU8sQ0FBQzZELE9BQWYsS0FBMkIsUUFBM0IsSUFBdUM3RCxPQUFPLENBQUM2RCxPQUFSN0QsS0FBb0IsSUFBdEcsS0FBZ0gsT0FBT0EsT0FBTyxDQUFDNkQsT0FBUjdELENBQWdCOEQsVUFBdkIsS0FBc0MsV0FBMUosRUFBdUs7RUFDcktoRSxNQUFNLENBQUNDLGNBQVBELENBQXNCRSxPQUFPLENBQUM2RCxPQUE5Qi9ELEVBQXVDLFlBQXZDQSxFQUFxRDtJQUFFRyxLQUFLLEVBQUU7RUFBVCxDQUFyREg7RUFDQUEsTUFBTSxDQUFDaUUsTUFBUGpFLENBQWNFLE9BQU8sQ0FBQzZELE9BQXRCL0QsRUFBK0JFLE9BQS9CRjtFQUNBa0UsTUFBTSxDQUFDaEUsT0FBUGdFLEdBQWlCaEUsT0FBTyxDQUFDNkQsT0FBekJHO0FBQ0QsQyxDQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanM/ZmQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudXNlSW50ZXJzZWN0aW9uID0gdXNlSW50ZXJzZWN0aW9uO1xudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBfcmVxdWVzdElkbGVDYWxsYmFjayA9IHJlcXVpcmUoXCIuL3JlcXVlc3QtaWRsZS1jYWxsYmFja1wiKTtcbmNvbnN0IGhhc0ludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nO1xuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuY29uc3QgaWRMaXN0ID0gW107XG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zKSB7XG4gICAgY29uc3QgaWQgPSB7XG4gICAgICAgIHJvb3Q6IG9wdGlvbnMucm9vdCB8fCBudWxsLFxuICAgICAgICBtYXJnaW46IG9wdGlvbnMucm9vdE1hcmdpbiB8fCAnJ1xuICAgIH07XG4gICAgY29uc3QgZXhpc3RpbmcgPSBpZExpc3QuZmluZCgob2JqKT0+b2JqLnJvb3QgPT09IGlkLnJvb3QgJiYgb2JqLm1hcmdpbiA9PT0gaWQubWFyZ2luKTtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgIGluc3RhbmNlID0gb2JzZXJ2ZXJzLmdldChleGlzdGluZyk7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKT0+e1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KT0+e1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBlbGVtZW50cy5nZXQoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMDtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBpc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpc1Zpc2libGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpbnN0YW5jZSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIG9ic2VydmVyLFxuICAgICAgICBlbGVtZW50c1xuICAgIH07XG4gICAgaWRMaXN0LnB1c2goaWQpO1xuICAgIG9ic2VydmVycy5zZXQoaWQsIGluc3RhbmNlKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBvYnNlcnZlKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBpZCAsIG9ic2VydmVyICwgZWxlbWVudHMgIH0gPSBjcmVhdGVPYnNlcnZlcihvcHRpb25zKTtcbiAgICBlbGVtZW50cy5zZXQoZWxlbWVudCwgY2FsbGJhY2spO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVub2JzZXJ2ZSgpIHtcbiAgICAgICAgZWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgIC8vIERlc3Ryb3kgb2JzZXJ2ZXIgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byB3YXRjaDpcbiAgICAgICAgaWYgKGVsZW1lbnRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIG9ic2VydmVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpZExpc3QuZmluZEluZGV4KChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW4pO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZExpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiB1c2VJbnRlcnNlY3Rpb24oeyByb290UmVmICwgcm9vdE1hcmdpbiAsIGRpc2FibGVkICB9KSB7XG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IGRpc2FibGVkIHx8ICFoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbiAgICBjb25zdCBbdmlzaWJsZSwgc2V0VmlzaWJsZV0gPSAoMCwgX3JlYWN0KS51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2VsZW1lbnQsIHNldEVsZW1lbnRdID0gKDAsIF9yZWFjdCkudXNlU3RhdGUobnVsbCk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgdmlzaWJsZSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5vYnNlcnZlID0gb2JzZXJ2ZShlbGVtZW50LCAoaXNWaXNpYmxlKT0+aXNWaXNpYmxlICYmIHNldFZpc2libGUoaXNWaXNpYmxlKSwge1xuICAgICAgICAgICAgICAgICAgICByb290OiByb290UmVmID09IG51bGwgPyB2b2lkIDAgOiByb290UmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIHJvb3RNYXJnaW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5vYnNlcnZlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWRsZUNhbGxiYWNrID0gKDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpPT5zZXRWaXNpYmxlKHRydWUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCk9PigwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykuY2FuY2VsSWRsZUNhbGxiYWNrKGlkbGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIGlzRGlzYWJsZWQsXG4gICAgICAgIHJvb3RNYXJnaW4sXG4gICAgICAgIHJvb3RSZWYsXG4gICAgICAgIHZpc2libGVcbiAgICBdKTtcbiAgICBjb25zdCByZXNldFZpc2libGUgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygoKT0+e1xuICAgICAgICBzZXRWaXNpYmxlKGZhbHNlKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc2V0RWxlbWVudCxcbiAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgcmVzZXRWaXNpYmxlXG4gICAgXTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWludGVyc2VjdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1c2VJbnRlcnNlY3Rpb24iLCJfcmVhY3QiLCJyZXF1aXJlIiwiX3JlcXVlc3RJZGxlQ2FsbGJhY2siLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwib2JzZXJ2ZXJzIiwiTWFwIiwiaWRMaXN0IiwiY3JlYXRlT2JzZXJ2ZXIiLCJvcHRpb25zIiwiaWQiLCJyb290IiwibWFyZ2luIiwicm9vdE1hcmdpbiIsImV4aXN0aW5nIiwiZmluZCIsIm9iaiIsImluc3RhbmNlIiwiZ2V0IiwiZWxlbWVudHMiLCJvYnNlcnZlciIsImVudHJpZXMiLCJmb3JFYWNoIiwiZW50cnkiLCJjYWxsYmFjayIsInRhcmdldCIsImlzVmlzaWJsZSIsImlzSW50ZXJzZWN0aW5nIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJwdXNoIiwic2V0Iiwib2JzZXJ2ZSIsImVsZW1lbnQiLCJ1bm9ic2VydmUiLCJkZWxldGUiLCJzaXplIiwiZGlzY29ubmVjdCIsImluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwicGFyYW0iLCJyb290UmVmIiwiZGlzYWJsZWQiLCJpc0Rpc2FibGVkIiwicmVmIiwidXNlU3RhdGUiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsInJlZjEiLCJzZXRFbGVtZW50IiwidXNlRWZmZWN0IiwidGFnTmFtZSIsImN1cnJlbnQiLCJpZGxlQ2FsbGJhY2siLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwicmVzZXRWaXNpYmxlIiwidXNlQ2FsbGJhY2siLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/app-router-context.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/app-router-context.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TemplateContext = exports.GlobalLayoutRouterContext = exports.LayoutRouterContext = exports.AppRouterContext = void 0;\n\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\n\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar AppRouterContext = _react.default.createContext(null);\n\nexports.AppRouterContext = AppRouterContext;\n\nvar LayoutRouterContext = _react.default.createContext(null);\n\nexports.LayoutRouterContext = LayoutRouterContext;\n\nvar GlobalLayoutRouterContext = _react.default.createContext(null);\n\nexports.GlobalLayoutRouterContext = GlobalLayoutRouterContext;\n\nvar TemplateContext = _react.default.createContext(null);\n\nexports.TemplateContext = TemplateContext;\n\nif (true) {\n  AppRouterContext.displayName = \"AppRouterContext\";\n  LayoutRouterContext.displayName = \"LayoutRouterContext\";\n  GlobalLayoutRouterContext.displayName = \"GlobalLayoutRouterContext\";\n  TemplateContext.displayName = \"TemplateContext\";\n} //# sourceMappingURL=app-router-context.js.map\n\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3Q0gsRUFBQUE7QUFHQUUsdUJBQUFBLEdBQTBCQSxpQ0FBQUEsR0FBb0NBLDJCQUFBQSxHQUE4QkEsd0JBQUFBLEdBQTJCLEtBQUssQ0FBNUhBOztBQUNBLElBQUlNLHdCQUF3QixHQUFHQyxtSkFBL0I7O0FBQ0EsSUFBSUUsTUFBTSxHQUFHSCx3QkFBd0IsQ0FBQ0MsbUJBQU8sQ0FBQyw0Q0FBRCxDQUFSLENBQXJDOztBQUNBLElBQU1GLGdCQUFnQixHQUFHSSxNQUFNLENBQUNELE9BQVBDLENBQWVDLGFBQWZELENBQTZCLElBQTdCQSxDQUF6Qjs7QUFDQVQsd0JBQUFBLEdBQTJCSyxnQkFBM0JMOztBQUNBLElBQU1JLG1CQUFtQixHQUFHSyxNQUFNLENBQUNELE9BQVBDLENBQWVDLGFBQWZELENBQTZCLElBQTdCQSxDQUE1Qjs7QUFDQVQsMkJBQUFBLEdBQThCSSxtQkFBOUJKOztBQUNBLElBQU1HLHlCQUF5QixHQUFHTSxNQUFNLENBQUNELE9BQVBDLENBQWVDLGFBQWZELENBQTZCLElBQTdCQSxDQUFsQzs7QUFDQVQsaUNBQUFBLEdBQW9DRyx5QkFBcENIOztBQUNBLElBQU1FLGVBQWUsR0FBR08sTUFBTSxDQUFDRCxPQUFQQyxDQUFlQyxhQUFmRCxDQUE2QixJQUE3QkEsQ0FBeEI7O0FBQ0FULHVCQUFBQSxHQUEwQkUsZUFBMUJGOztBQUNBLElBQUlXLElBQUosRUFBMkM7RUFDdkNOLGdCQUFnQixDQUFDTyxXQUFqQlAsR0FBK0Isa0JBQS9CQTtFQUNBRCxtQkFBbUIsQ0FBQ1EsV0FBcEJSLEdBQWtDLHFCQUFsQ0E7RUFDQUQseUJBQXlCLENBQUNTLFdBQTFCVCxHQUF3QywyQkFBeENBO0VBQ0FELGVBQWUsQ0FBQ1UsV0FBaEJWLEdBQThCLGlCQUE5QkE7QUFDSCxDLENBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5qcz9kYmRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5UZW1wbGF0ZUNvbnRleHQgPSBleHBvcnRzLkdsb2JhbExheW91dFJvdXRlckNvbnRleHQgPSBleHBvcnRzLkxheW91dFJvdXRlckNvbnRleHQgPSBleHBvcnRzLkFwcFJvdXRlckNvbnRleHQgPSB2b2lkIDA7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBBcHBSb3V0ZXJDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChudWxsKTtcbmV4cG9ydHMuQXBwUm91dGVyQ29udGV4dCA9IEFwcFJvdXRlckNvbnRleHQ7XG5jb25zdCBMYXlvdXRSb3V0ZXJDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChudWxsKTtcbmV4cG9ydHMuTGF5b3V0Um91dGVyQ29udGV4dCA9IExheW91dFJvdXRlckNvbnRleHQ7XG5jb25zdCBHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChudWxsKTtcbmV4cG9ydHMuR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCA9IEdsb2JhbExheW91dFJvdXRlckNvbnRleHQ7XG5jb25zdCBUZW1wbGF0ZUNvbnRleHQgPSBfcmVhY3QuZGVmYXVsdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuZXhwb3J0cy5UZW1wbGF0ZUNvbnRleHQgPSBUZW1wbGF0ZUNvbnRleHQ7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIEFwcFJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnQXBwUm91dGVyQ29udGV4dCc7XG4gICAgTGF5b3V0Um91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdMYXlvdXRSb3V0ZXJDb250ZXh0JztcbiAgICBHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0dsb2JhbExheW91dFJvdXRlckNvbnRleHQnO1xuICAgIFRlbXBsYXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdUZW1wbGF0ZUNvbnRleHQnO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGVyLWNvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVGVtcGxhdGVDb250ZXh0IiwiR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsIkxheW91dFJvdXRlckNvbnRleHQiLCJBcHBSb3V0ZXJDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsImRlZmF1bHQiLCJfcmVhY3QiLCJjcmVhdGVDb250ZXh0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/app-router-context.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.matchRemotePattern = matchRemotePattern;\nexports.hasMatch = hasMatch;\n\nvar _micromatch = __webpack_require__(/*! next/dist/compiled/micromatch */ \"./node_modules/next/dist/compiled/micromatch/index.js\");\n\nfunction matchRemotePattern(pattern, url) {\n  if (pattern.protocol !== undefined) {\n    var actualProto = url.protocol.slice(0, -1);\n\n    if (pattern.protocol !== actualProto) {\n      return false;\n    }\n  }\n\n  if (pattern.port !== undefined) {\n    if (pattern.port !== url.port) {\n      return false;\n    }\n  }\n\n  if (pattern.hostname === undefined) {\n    throw new Error(\"Pattern should define hostname but found\\n\".concat(JSON.stringify(pattern)));\n  } else {\n    if (!(0, _micromatch).makeRe(pattern.hostname).test(url.hostname)) {\n      return false;\n    }\n  }\n\n  var _pathname;\n\n  if (!(0, _micromatch).makeRe((_pathname = pattern.pathname) != null ? _pathname : \"**\").test(url.pathname)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction hasMatch(domains, remotePatterns, url) {\n  return domains.some(function (domain) {\n    return url.hostname === domain;\n  }) || remotePatterns.some(function (p) {\n    return matchRemotePattern(p, url);\n  });\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbWF0Y2gtcmVtb3RlLXBhdHRlcm4uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDSCxFQUFBQTtBQUdBRSwwQkFBQUEsR0FBNkJFLGtCQUE3QkY7QUFDQUEsZ0JBQUFBLEdBQW1CRyxRQUFuQkg7O0FBQ0EsSUFBSUksV0FBVyxHQUFHQyxtQkFBTyxDQUFDLDRGQUFELENBQXpCOztBQUNBLFNBQVNILGtCQUFULENBQTRCSSxPQUE1QixFQUFxQ0MsR0FBckMsRUFBMEM7RUFDdEMsSUFBSUQsT0FBTyxDQUFDRSxRQUFSRixLQUFxQkcsU0FBekIsRUFBb0M7SUFDaEMsSUFBTUMsV0FBVyxHQUFHSCxHQUFHLENBQUNDLFFBQUpELENBQWFJLEtBQWJKLENBQW1CLENBQW5CQSxFQUFzQixDQUFDLENBQXZCQSxDQUFwQjs7SUFDQSxJQUFJRCxPQUFPLENBQUNFLFFBQVJGLEtBQXFCSSxXQUF6QixFQUFzQztNQUNsQyxPQUFPLEtBQVA7SUFDSDtFQUNKOztFQUNELElBQUlKLE9BQU8sQ0FBQ00sSUFBUk4sS0FBaUJHLFNBQXJCLEVBQWdDO0lBQzVCLElBQUlILE9BQU8sQ0FBQ00sSUFBUk4sS0FBaUJDLEdBQUcsQ0FBQ0ssSUFBekIsRUFBK0I7TUFDM0IsT0FBTyxLQUFQO0lBQ0g7RUFDSjs7RUFDRCxJQUFJTixPQUFPLENBQUNPLFFBQVJQLEtBQXFCRyxTQUF6QixFQUFvQztJQUNoQyxNQUFNLElBQUlLLEtBQUosQ0FBVSw2Q0FBcUVDLE1BQXJFLENBQTZDQyxJQUFJLENBQUNDLFNBQUxELENBQWVWLE9BQWZVLENBQTdDLENBQVYsQ0FBTjtFQUNKLENBRkEsTUFFTztJQUNILElBQUksQ0FBQyxDQUFDLEdBQUdaLFdBQUosRUFBaUJjLE1BQWpCLENBQXdCWixPQUFPLENBQUNPLFFBQWhDLEVBQTBDTSxJQUExQyxDQUErQ1osR0FBRyxDQUFDTSxRQUFuRCxDQUFMLEVBQW1FO01BQy9ELE9BQU8sS0FBUDtJQUNIO0VBQ0o7O0VBQ0QsSUFBSU8sU0FBSjs7RUFDQSxJQUFJLENBQUMsQ0FBQyxHQUFHaEIsV0FBSixFQUFpQmMsTUFBakIsQ0FBd0IsQ0FBQ0UsU0FBUyxHQUFHZCxPQUFPLENBQUNlLFFBQXJCLEtBQWtDLElBQWxDLEdBQXlDRCxTQUF6QyxHQUFxRCxJQUE3RSxFQUFtRkQsSUFBbkYsQ0FBd0ZaLEdBQUcsQ0FBQ2MsUUFBNUYsQ0FBTCxFQUE0RztJQUN4RyxPQUFPLEtBQVA7RUFDSDs7RUFDRCxPQUFPLElBQVA7QUFDSDs7QUFDRCxTQUFTbEIsUUFBVCxDQUFrQm1CLE9BQWxCLEVBQTJCQyxjQUEzQixFQUEyQ2hCLEdBQTNDLEVBQWdEO0VBQzVDLE9BQU9lLE9BQU8sQ0FBQ0UsSUFBUkYsQ0FBYSxVQUFDRyxNQUFELEVBQU87V0FBR2xCLEdBQUcsQ0FBQ00sUUFBSk4sS0FBaUJrQjtFQUFNLENBQTlDSCxLQUFtREMsY0FBYyxDQUFDQyxJQUFmRCxDQUFvQixVQUFDRyxDQUFELEVBQUU7V0FBR3hCLGtCQUFrQixDQUFDd0IsQ0FBRCxFQUFJbkIsR0FBSjtFQUFRLENBQW5EZ0IsQ0FBMUQ7QUFDSCxDLENBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL21hdGNoLXJlbW90ZS1wYXR0ZXJuLmpzPzBjOWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1hdGNoUmVtb3RlUGF0dGVybiA9IG1hdGNoUmVtb3RlUGF0dGVybjtcbmV4cG9ydHMuaGFzTWF0Y2ggPSBoYXNNYXRjaDtcbnZhciBfbWljcm9tYXRjaCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvbWljcm9tYXRjaFwiKTtcbmZ1bmN0aW9uIG1hdGNoUmVtb3RlUGF0dGVybihwYXR0ZXJuLCB1cmwpIHtcbiAgICBpZiAocGF0dGVybi5wcm90b2NvbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGFjdHVhbFByb3RvID0gdXJsLnByb3RvY29sLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgaWYgKHBhdHRlcm4ucHJvdG9jb2wgIT09IGFjdHVhbFByb3RvKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdHRlcm4ucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuLnBvcnQgIT09IHVybC5wb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdHRlcm4uaG9zdG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdHRlcm4gc2hvdWxkIGRlZmluZSBob3N0bmFtZSBidXQgZm91bmRcXG4ke0pTT04uc3RyaW5naWZ5KHBhdHRlcm4pfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKDAsIF9taWNyb21hdGNoKS5tYWtlUmUocGF0dGVybi5ob3N0bmFtZSkudGVzdCh1cmwuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9wYXRobmFtZTtcbiAgICBpZiAoISgwLCBfbWljcm9tYXRjaCkubWFrZVJlKChfcGF0aG5hbWUgPSBwYXR0ZXJuLnBhdGhuYW1lKSAhPSBudWxsID8gX3BhdGhuYW1lIDogJyoqJykudGVzdCh1cmwucGF0aG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBoYXNNYXRjaChkb21haW5zLCByZW1vdGVQYXR0ZXJucywgdXJsKSB7XG4gICAgcmV0dXJuIGRvbWFpbnMuc29tZSgoZG9tYWluKT0+dXJsLmhvc3RuYW1lID09PSBkb21haW4pIHx8IHJlbW90ZVBhdHRlcm5zLnNvbWUoKHApPT5tYXRjaFJlbW90ZVBhdHRlcm4ocCwgdXJsKSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGNoLXJlbW90ZS1wYXR0ZXJuLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1hdGNoUmVtb3RlUGF0dGVybiIsImhhc01hdGNoIiwiX21pY3JvbWF0Y2giLCJyZXF1aXJlIiwicGF0dGVybiIsInVybCIsInByb3RvY29sIiwidW5kZWZpbmVkIiwiYWN0dWFsUHJvdG8iLCJzbGljZSIsInBvcnQiLCJob3N0bmFtZSIsIkVycm9yIiwiY29uY2F0IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1ha2VSZSIsInRlc3QiLCJfcGF0aG5hbWUiLCJwYXRobmFtZSIsImRvbWFpbnMiLCJyZW1vdGVQYXR0ZXJucyIsInNvbWUiLCJkb21haW4iLCJwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/micromatch/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/micromatch/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n(() => {\n  \"use strict\";\n\n  var e = {\n    333: (e, t, r) => {\n      const n = r(137);\n      const u = r(179);\n      const s = r(13);\n      const o = r(719);\n\n      const braces = (e, t = {}) => {\n        let r = [];\n\n        if (Array.isArray(e)) {\n          for (let n of e) {\n            let e = braces.create(n, t);\n\n            if (Array.isArray(e)) {\n              r.push(...e);\n            } else {\n              r.push(e);\n            }\n          }\n        } else {\n          r = [].concat(braces.create(e, t));\n        }\n\n        if (t && t.expand === true && t.nodupes === true) {\n          r = [...new Set(r)];\n        }\n\n        return r;\n      };\n\n      braces.parse = (e, t = {}) => o(e, t);\n\n      braces.stringify = (e, t = {}) => {\n        if (typeof e === \"string\") {\n          return n(braces.parse(e, t), t);\n        }\n\n        return n(e, t);\n      };\n\n      braces.compile = (e, t = {}) => {\n        if (typeof e === \"string\") {\n          e = braces.parse(e, t);\n        }\n\n        return u(e, t);\n      };\n\n      braces.expand = (e, t = {}) => {\n        if (typeof e === \"string\") {\n          e = braces.parse(e, t);\n        }\n\n        let r = s(e, t);\n\n        if (t.noempty === true) {\n          r = r.filter(Boolean);\n        }\n\n        if (t.nodupes === true) {\n          r = [...new Set(r)];\n        }\n\n        return r;\n      };\n\n      braces.create = (e, t = {}) => {\n        if (e === \"\" || e.length < 3) {\n          return [e];\n        }\n\n        return t.expand !== true ? braces.compile(e, t) : braces.expand(e, t);\n      };\n\n      e.exports = braces;\n    },\n    179: (e, t, r) => {\n      const n = r(783);\n      const u = r(617);\n\n      const compile = (e, t = {}) => {\n        let walk = (e, r = {}) => {\n          let s = u.isInvalidBrace(r);\n          let o = e.invalid === true && t.escapeInvalid === true;\n          let i = s === true || o === true;\n          let a = t.escapeInvalid === true ? \"\\\\\" : \"\";\n          let l = \"\";\n\n          if (e.isOpen === true) {\n            return a + e.value;\n          }\n\n          if (e.isClose === true) {\n            return a + e.value;\n          }\n\n          if (e.type === \"open\") {\n            return i ? a + e.value : \"(\";\n          }\n\n          if (e.type === \"close\") {\n            return i ? a + e.value : \")\";\n          }\n\n          if (e.type === \"comma\") {\n            return e.prev.type === \"comma\" ? \"\" : i ? e.value : \"|\";\n          }\n\n          if (e.value) {\n            return e.value;\n          }\n\n          if (e.nodes && e.ranges > 0) {\n            let r = u.reduce(e.nodes);\n            let s = n(...r, { ...t,\n              wrap: false,\n              toRegex: true\n            });\n\n            if (s.length !== 0) {\n              return r.length > 1 && s.length > 1 ? `(${s})` : s;\n            }\n          }\n\n          if (e.nodes) {\n            for (let t of e.nodes) {\n              l += walk(t, e);\n            }\n          }\n\n          return l;\n        };\n\n        return walk(e);\n      };\n\n      e.exports = compile;\n    },\n    457: e => {\n      e.exports = {\n        MAX_LENGTH: 1024 * 64,\n        CHAR_0: \"0\",\n        CHAR_9: \"9\",\n        CHAR_UPPERCASE_A: \"A\",\n        CHAR_LOWERCASE_A: \"a\",\n        CHAR_UPPERCASE_Z: \"Z\",\n        CHAR_LOWERCASE_Z: \"z\",\n        CHAR_LEFT_PARENTHESES: \"(\",\n        CHAR_RIGHT_PARENTHESES: \")\",\n        CHAR_ASTERISK: \"*\",\n        CHAR_AMPERSAND: \"&\",\n        CHAR_AT: \"@\",\n        CHAR_BACKSLASH: \"\\\\\",\n        CHAR_BACKTICK: \"`\",\n        CHAR_CARRIAGE_RETURN: \"\\r\",\n        CHAR_CIRCUMFLEX_ACCENT: \"^\",\n        CHAR_COLON: \":\",\n        CHAR_COMMA: \",\",\n        CHAR_DOLLAR: \"$\",\n        CHAR_DOT: \".\",\n        CHAR_DOUBLE_QUOTE: '\"',\n        CHAR_EQUAL: \"=\",\n        CHAR_EXCLAMATION_MARK: \"!\",\n        CHAR_FORM_FEED: \"\\f\",\n        CHAR_FORWARD_SLASH: \"/\",\n        CHAR_HASH: \"#\",\n        CHAR_HYPHEN_MINUS: \"-\",\n        CHAR_LEFT_ANGLE_BRACKET: \"<\",\n        CHAR_LEFT_CURLY_BRACE: \"{\",\n        CHAR_LEFT_SQUARE_BRACKET: \"[\",\n        CHAR_LINE_FEED: \"\\n\",\n        CHAR_NO_BREAK_SPACE: \" \",\n        CHAR_PERCENT: \"%\",\n        CHAR_PLUS: \"+\",\n        CHAR_QUESTION_MARK: \"?\",\n        CHAR_RIGHT_ANGLE_BRACKET: \">\",\n        CHAR_RIGHT_CURLY_BRACE: \"}\",\n        CHAR_RIGHT_SQUARE_BRACKET: \"]\",\n        CHAR_SEMICOLON: \";\",\n        CHAR_SINGLE_QUOTE: \"'\",\n        CHAR_SPACE: \" \",\n        CHAR_TAB: \"\\t\",\n        CHAR_UNDERSCORE: \"_\",\n        CHAR_VERTICAL_LINE: \"|\",\n        CHAR_ZERO_WIDTH_NOBREAK_SPACE: \"\\ufeff\"\n      };\n    },\n    13: (e, t, r) => {\n      const n = r(783);\n      const u = r(137);\n      const s = r(617);\n\n      const append = (e = \"\", t = \"\", r = false) => {\n        let n = [];\n        e = [].concat(e);\n        t = [].concat(t);\n        if (!t.length) return e;\n\n        if (!e.length) {\n          return r ? s.flatten(t).map(e => `{${e}}`) : t;\n        }\n\n        for (let u of e) {\n          if (Array.isArray(u)) {\n            for (let e of u) {\n              n.push(append(e, t, r));\n            }\n          } else {\n            for (let e of t) {\n              if (r === true && typeof e === \"string\") e = `{${e}}`;\n              n.push(Array.isArray(e) ? append(u, e, r) : u + e);\n            }\n          }\n        }\n\n        return s.flatten(n);\n      };\n\n      const expand = (e, t = {}) => {\n        let r = t.rangeLimit === void 0 ? 1e3 : t.rangeLimit;\n\n        let walk = (e, o = {}) => {\n          e.queue = [];\n          let i = o;\n          let a = o.queue;\n\n          while (i.type !== \"brace\" && i.type !== \"root\" && i.parent) {\n            i = i.parent;\n            a = i.queue;\n          }\n\n          if (e.invalid || e.dollar) {\n            a.push(append(a.pop(), u(e, t)));\n            return;\n          }\n\n          if (e.type === \"brace\" && e.invalid !== true && e.nodes.length === 2) {\n            a.push(append(a.pop(), [\"{}\"]));\n            return;\n          }\n\n          if (e.nodes && e.ranges > 0) {\n            let o = s.reduce(e.nodes);\n\n            if (s.exceedsLimit(...o, t.step, r)) {\n              throw new RangeError(\"expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.\");\n            }\n\n            let i = n(...o, t);\n\n            if (i.length === 0) {\n              i = u(e, t);\n            }\n\n            a.push(append(a.pop(), i));\n            e.nodes = [];\n            return;\n          }\n\n          let l = s.encloseBrace(e);\n          let c = e.queue;\n          let p = e;\n\n          while (p.type !== \"brace\" && p.type !== \"root\" && p.parent) {\n            p = p.parent;\n            c = p.queue;\n          }\n\n          for (let t = 0; t < e.nodes.length; t++) {\n            let r = e.nodes[t];\n\n            if (r.type === \"comma\" && e.type === \"brace\") {\n              if (t === 1) c.push(\"\");\n              c.push(\"\");\n              continue;\n            }\n\n            if (r.type === \"close\") {\n              a.push(append(a.pop(), c, l));\n              continue;\n            }\n\n            if (r.value && r.type !== \"open\") {\n              c.push(append(c.pop(), r.value));\n              continue;\n            }\n\n            if (r.nodes) {\n              walk(r, e);\n            }\n          }\n\n          return c;\n        };\n\n        return s.flatten(walk(e));\n      };\n\n      e.exports = expand;\n    },\n    719: (e, t, r) => {\n      const n = r(137);\n      const {\n        MAX_LENGTH: u,\n        CHAR_BACKSLASH: s,\n        CHAR_BACKTICK: o,\n        CHAR_COMMA: i,\n        CHAR_DOT: a,\n        CHAR_LEFT_PARENTHESES: l,\n        CHAR_RIGHT_PARENTHESES: c,\n        CHAR_LEFT_CURLY_BRACE: p,\n        CHAR_RIGHT_CURLY_BRACE: f,\n        CHAR_LEFT_SQUARE_BRACKET: A,\n        CHAR_RIGHT_SQUARE_BRACKET: R,\n        CHAR_DOUBLE_QUOTE: _,\n        CHAR_SINGLE_QUOTE: h,\n        CHAR_NO_BREAK_SPACE: g,\n        CHAR_ZERO_WIDTH_NOBREAK_SPACE: E\n      } = r(457);\n\n      const parse = (e, t = {}) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(\"Expected a string\");\n        }\n\n        let r = t || {};\n        let C = typeof r.maxLength === \"number\" ? Math.min(u, r.maxLength) : u;\n\n        if (e.length > C) {\n          throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${C})`);\n        }\n\n        let y = {\n          type: \"root\",\n          input: e,\n          nodes: []\n        };\n        let d = [y];\n        let x = y;\n        let b = y;\n        let S = 0;\n        let H = e.length;\n        let v = 0;\n        let $ = 0;\n        let m;\n        let T = {};\n\n        const advance = () => e[v++];\n\n        const push = e => {\n          if (e.type === \"text\" && b.type === \"dot\") {\n            b.type = \"text\";\n          }\n\n          if (b && b.type === \"text\" && e.type === \"text\") {\n            b.value += e.value;\n            return;\n          }\n\n          x.nodes.push(e);\n          e.parent = x;\n          e.prev = b;\n          b = e;\n          return e;\n        };\n\n        push({\n          type: \"bos\"\n        });\n\n        while (v < H) {\n          x = d[d.length - 1];\n          m = advance();\n\n          if (m === E || m === g) {\n            continue;\n          }\n\n          if (m === s) {\n            push({\n              type: \"text\",\n              value: (t.keepEscaping ? m : \"\") + advance()\n            });\n            continue;\n          }\n\n          if (m === R) {\n            push({\n              type: \"text\",\n              value: \"\\\\\" + m\n            });\n            continue;\n          }\n\n          if (m === A) {\n            S++;\n            let e = true;\n            let t;\n\n            while (v < H && (t = advance())) {\n              m += t;\n\n              if (t === A) {\n                S++;\n                continue;\n              }\n\n              if (t === s) {\n                m += advance();\n                continue;\n              }\n\n              if (t === R) {\n                S--;\n\n                if (S === 0) {\n                  break;\n                }\n              }\n            }\n\n            push({\n              type: \"text\",\n              value: m\n            });\n            continue;\n          }\n\n          if (m === l) {\n            x = push({\n              type: \"paren\",\n              nodes: []\n            });\n            d.push(x);\n            push({\n              type: \"text\",\n              value: m\n            });\n            continue;\n          }\n\n          if (m === c) {\n            if (x.type !== \"paren\") {\n              push({\n                type: \"text\",\n                value: m\n              });\n              continue;\n            }\n\n            x = d.pop();\n            push({\n              type: \"text\",\n              value: m\n            });\n            x = d[d.length - 1];\n            continue;\n          }\n\n          if (m === _ || m === h || m === o) {\n            let e = m;\n            let r;\n\n            if (t.keepQuotes !== true) {\n              m = \"\";\n            }\n\n            while (v < H && (r = advance())) {\n              if (r === s) {\n                m += r + advance();\n                continue;\n              }\n\n              if (r === e) {\n                if (t.keepQuotes === true) m += r;\n                break;\n              }\n\n              m += r;\n            }\n\n            push({\n              type: \"text\",\n              value: m\n            });\n            continue;\n          }\n\n          if (m === p) {\n            $++;\n            let e = b.value && b.value.slice(-1) === \"$\" || x.dollar === true;\n            let t = {\n              type: \"brace\",\n              open: true,\n              close: false,\n              dollar: e,\n              depth: $,\n              commas: 0,\n              ranges: 0,\n              nodes: []\n            };\n            x = push(t);\n            d.push(x);\n            push({\n              type: \"open\",\n              value: m\n            });\n            continue;\n          }\n\n          if (m === f) {\n            if (x.type !== \"brace\") {\n              push({\n                type: \"text\",\n                value: m\n              });\n              continue;\n            }\n\n            let e = \"close\";\n            x = d.pop();\n            x.close = true;\n            push({\n              type: e,\n              value: m\n            });\n            $--;\n            x = d[d.length - 1];\n            continue;\n          }\n\n          if (m === i && $ > 0) {\n            if (x.ranges > 0) {\n              x.ranges = 0;\n              let e = x.nodes.shift();\n              x.nodes = [e, {\n                type: \"text\",\n                value: n(x)\n              }];\n            }\n\n            push({\n              type: \"comma\",\n              value: m\n            });\n            x.commas++;\n            continue;\n          }\n\n          if (m === a && $ > 0 && x.commas === 0) {\n            let e = x.nodes;\n\n            if ($ === 0 || e.length === 0) {\n              push({\n                type: \"text\",\n                value: m\n              });\n              continue;\n            }\n\n            if (b.type === \"dot\") {\n              x.range = [];\n              b.value += m;\n              b.type = \"range\";\n\n              if (x.nodes.length !== 3 && x.nodes.length !== 5) {\n                x.invalid = true;\n                x.ranges = 0;\n                b.type = \"text\";\n                continue;\n              }\n\n              x.ranges++;\n              x.args = [];\n              continue;\n            }\n\n            if (b.type === \"range\") {\n              e.pop();\n              let t = e[e.length - 1];\n              t.value += b.value + m;\n              b = t;\n              x.ranges--;\n              continue;\n            }\n\n            push({\n              type: \"dot\",\n              value: m\n            });\n            continue;\n          }\n\n          push({\n            type: \"text\",\n            value: m\n          });\n        }\n\n        do {\n          x = d.pop();\n\n          if (x.type !== \"root\") {\n            x.nodes.forEach(e => {\n              if (!e.nodes) {\n                if (e.type === \"open\") e.isOpen = true;\n                if (e.type === \"close\") e.isClose = true;\n                if (!e.nodes) e.type = \"text\";\n                e.invalid = true;\n              }\n            });\n            let e = d[d.length - 1];\n            let t = e.nodes.indexOf(x);\n            e.nodes.splice(t, 1, ...x.nodes);\n          }\n        } while (d.length > 0);\n\n        push({\n          type: \"eos\"\n        });\n        return y;\n      };\n\n      e.exports = parse;\n    },\n    137: (e, t, r) => {\n      const n = r(617);\n\n      e.exports = (e, t = {}) => {\n        let stringify = (e, r = {}) => {\n          let u = t.escapeInvalid && n.isInvalidBrace(r);\n          let s = e.invalid === true && t.escapeInvalid === true;\n          let o = \"\";\n\n          if (e.value) {\n            if ((u || s) && n.isOpenOrClose(e)) {\n              return \"\\\\\" + e.value;\n            }\n\n            return e.value;\n          }\n\n          if (e.value) {\n            return e.value;\n          }\n\n          if (e.nodes) {\n            for (let t of e.nodes) {\n              o += stringify(t);\n            }\n          }\n\n          return o;\n        };\n\n        return stringify(e);\n      };\n    },\n    617: (e, t) => {\n      t.isInteger = e => {\n        if (typeof e === \"number\") {\n          return Number.isInteger(e);\n        }\n\n        if (typeof e === \"string\" && e.trim() !== \"\") {\n          return Number.isInteger(Number(e));\n        }\n\n        return false;\n      };\n\n      t.find = (e, t) => e.nodes.find(e => e.type === t);\n\n      t.exceedsLimit = (e, r, n = 1, u) => {\n        if (u === false) return false;\n        if (!t.isInteger(e) || !t.isInteger(r)) return false;\n        return (Number(r) - Number(e)) / Number(n) >= u;\n      };\n\n      t.escapeNode = (e, t = 0, r) => {\n        let n = e.nodes[t];\n        if (!n) return;\n\n        if (r && n.type === r || n.type === \"open\" || n.type === \"close\") {\n          if (n.escaped !== true) {\n            n.value = \"\\\\\" + n.value;\n            n.escaped = true;\n          }\n        }\n      };\n\n      t.encloseBrace = e => {\n        if (e.type !== \"brace\") return false;\n\n        if (e.commas >> 0 + e.ranges >> 0 === 0) {\n          e.invalid = true;\n          return true;\n        }\n\n        return false;\n      };\n\n      t.isInvalidBrace = e => {\n        if (e.type !== \"brace\") return false;\n        if (e.invalid === true || e.dollar) return true;\n\n        if (e.commas >> 0 + e.ranges >> 0 === 0) {\n          e.invalid = true;\n          return true;\n        }\n\n        if (e.open !== true || e.close !== true) {\n          e.invalid = true;\n          return true;\n        }\n\n        return false;\n      };\n\n      t.isOpenOrClose = e => {\n        if (e.type === \"open\" || e.type === \"close\") {\n          return true;\n        }\n\n        return e.open === true || e.close === true;\n      };\n\n      t.reduce = e => e.reduce((e, t) => {\n        if (t.type === \"text\") e.push(t.value);\n        if (t.type === \"range\") t.type = \"text\";\n        return e;\n      }, []);\n\n      t.flatten = (...e) => {\n        const t = [];\n\n        const flat = e => {\n          for (let r = 0; r < e.length; r++) {\n            let n = e[r];\n            Array.isArray(n) ? flat(n, t) : n !== void 0 && t.push(n);\n          }\n\n          return t;\n        };\n\n        flat(e);\n        return t;\n      };\n    },\n    783: (e, t, r) => {\n      /*!\n       * fill-range <https://github.com/jonschlinkert/fill-range>\n       *\n       * Copyright (c) 2014-present, Jon Schlinkert.\n       * Licensed under the MIT License.\n       */\n      const n = r(837);\n      const u = r(492);\n\n      const isObject = e => e !== null && typeof e === \"object\" && !Array.isArray(e);\n\n      const transform = e => t => e === true ? Number(t) : String(t);\n\n      const isValidValue = e => typeof e === \"number\" || typeof e === \"string\" && e !== \"\";\n\n      const isNumber = e => Number.isInteger(+e);\n\n      const zeros = e => {\n        let t = `${e}`;\n        let r = -1;\n        if (t[0] === \"-\") t = t.slice(1);\n        if (t === \"0\") return false;\n\n        while (t[++r] === \"0\");\n\n        return r > 0;\n      };\n\n      const stringify = (e, t, r) => {\n        if (typeof e === \"string\" || typeof t === \"string\") {\n          return true;\n        }\n\n        return r.stringify === true;\n      };\n\n      const pad = (e, t, r) => {\n        if (t > 0) {\n          let r = e[0] === \"-\" ? \"-\" : \"\";\n          if (r) e = e.slice(1);\n          e = r + e.padStart(r ? t - 1 : t, \"0\");\n        }\n\n        if (r === false) {\n          return String(e);\n        }\n\n        return e;\n      };\n\n      const toMaxLen = (e, t) => {\n        let r = e[0] === \"-\" ? \"-\" : \"\";\n\n        if (r) {\n          e = e.slice(1);\n          t--;\n        }\n\n        while (e.length < t) e = \"0\" + e;\n\n        return r ? \"-\" + e : e;\n      };\n\n      const toSequence = (e, t) => {\n        e.negatives.sort((e, t) => e < t ? -1 : e > t ? 1 : 0);\n        e.positives.sort((e, t) => e < t ? -1 : e > t ? 1 : 0);\n        let r = t.capture ? \"\" : \"?:\";\n        let n = \"\";\n        let u = \"\";\n        let s;\n\n        if (e.positives.length) {\n          n = e.positives.join(\"|\");\n        }\n\n        if (e.negatives.length) {\n          u = `-(${r}${e.negatives.join(\"|\")})`;\n        }\n\n        if (n && u) {\n          s = `${n}|${u}`;\n        } else {\n          s = n || u;\n        }\n\n        if (t.wrap) {\n          return `(${r}${s})`;\n        }\n\n        return s;\n      };\n\n      const toRange = (e, t, r, n) => {\n        if (r) {\n          return u(e, t, {\n            wrap: false,\n            ...n\n          });\n        }\n\n        let s = String.fromCharCode(e);\n        if (e === t) return s;\n        let o = String.fromCharCode(t);\n        return `[${s}-${o}]`;\n      };\n\n      const toRegex = (e, t, r) => {\n        if (Array.isArray(e)) {\n          let t = r.wrap === true;\n          let n = r.capture ? \"\" : \"?:\";\n          return t ? `(${n}${e.join(\"|\")})` : e.join(\"|\");\n        }\n\n        return u(e, t, r);\n      };\n\n      const rangeError = (...e) => new RangeError(\"Invalid range arguments: \" + n.inspect(...e));\n\n      const invalidRange = (e, t, r) => {\n        if (r.strictRanges === true) throw rangeError([e, t]);\n        return [];\n      };\n\n      const invalidStep = (e, t) => {\n        if (t.strictRanges === true) {\n          throw new TypeError(`Expected step \"${e}\" to be a number`);\n        }\n\n        return [];\n      };\n\n      const fillNumbers = (e, t, r = 1, n = {}) => {\n        let u = Number(e);\n        let s = Number(t);\n\n        if (!Number.isInteger(u) || !Number.isInteger(s)) {\n          if (n.strictRanges === true) throw rangeError([e, t]);\n          return [];\n        }\n\n        if (u === 0) u = 0;\n        if (s === 0) s = 0;\n        let o = u > s;\n        let i = String(e);\n        let a = String(t);\n        let l = String(r);\n        r = Math.max(Math.abs(r), 1);\n        let c = zeros(i) || zeros(a) || zeros(l);\n        let p = c ? Math.max(i.length, a.length, l.length) : 0;\n        let f = c === false && stringify(e, t, n) === false;\n        let A = n.transform || transform(f);\n\n        if (n.toRegex && r === 1) {\n          return toRange(toMaxLen(e, p), toMaxLen(t, p), true, n);\n        }\n\n        let R = {\n          negatives: [],\n          positives: []\n        };\n\n        let push = e => R[e < 0 ? \"negatives\" : \"positives\"].push(Math.abs(e));\n\n        let _ = [];\n        let h = 0;\n\n        while (o ? u >= s : u <= s) {\n          if (n.toRegex === true && r > 1) {\n            push(u);\n          } else {\n            _.push(pad(A(u, h), p, f));\n          }\n\n          u = o ? u - r : u + r;\n          h++;\n        }\n\n        if (n.toRegex === true) {\n          return r > 1 ? toSequence(R, n) : toRegex(_, null, {\n            wrap: false,\n            ...n\n          });\n        }\n\n        return _;\n      };\n\n      const fillLetters = (e, t, r = 1, n = {}) => {\n        if (!isNumber(e) && e.length > 1 || !isNumber(t) && t.length > 1) {\n          return invalidRange(e, t, n);\n        }\n\n        let u = n.transform || (e => String.fromCharCode(e));\n\n        let s = `${e}`.charCodeAt(0);\n        let o = `${t}`.charCodeAt(0);\n        let i = s > o;\n        let a = Math.min(s, o);\n        let l = Math.max(s, o);\n\n        if (n.toRegex && r === 1) {\n          return toRange(a, l, false, n);\n        }\n\n        let c = [];\n        let p = 0;\n\n        while (i ? s >= o : s <= o) {\n          c.push(u(s, p));\n          s = i ? s - r : s + r;\n          p++;\n        }\n\n        if (n.toRegex === true) {\n          return toRegex(c, null, {\n            wrap: false,\n            options: n\n          });\n        }\n\n        return c;\n      };\n\n      const fill = (e, t, r, n = {}) => {\n        if (t == null && isValidValue(e)) {\n          return [e];\n        }\n\n        if (!isValidValue(e) || !isValidValue(t)) {\n          return invalidRange(e, t, n);\n        }\n\n        if (typeof r === \"function\") {\n          return fill(e, t, 1, {\n            transform: r\n          });\n        }\n\n        if (isObject(r)) {\n          return fill(e, t, 0, r);\n        }\n\n        let u = { ...n\n        };\n        if (u.capture === true) u.wrap = true;\n        r = r || u.step || 1;\n\n        if (!isNumber(r)) {\n          if (r != null && !isObject(r)) return invalidStep(r, u);\n          return fill(e, t, 1, r);\n        }\n\n        if (isNumber(e) && isNumber(t)) {\n          return fillNumbers(e, t, r, u);\n        }\n\n        return fillLetters(e, t, Math.max(Math.abs(r), 1), u);\n      };\n\n      e.exports = fill;\n    },\n    357: e => {\n      /*!\n       * is-number <https://github.com/jonschlinkert/is-number>\n       *\n       * Copyright (c) 2014-present, Jon Schlinkert.\n       * Released under the MIT License.\n       */\n      e.exports = function (e) {\n        if (typeof e === \"number\") {\n          return e - e === 0;\n        }\n\n        if (typeof e === \"string\" && e.trim() !== \"\") {\n          return Number.isFinite ? Number.isFinite(+e) : isFinite(+e);\n        }\n\n        return false;\n      };\n    },\n    971: (e, t, r) => {\n      const n = r(837);\n      const u = r(333);\n      const s = r(251);\n      const o = r(513);\n\n      const isEmptyString = e => e === \"\" || e === \"./\";\n\n      const micromatch = (e, t, r) => {\n        t = [].concat(t);\n        e = [].concat(e);\n        let n = new Set();\n        let u = new Set();\n        let o = new Set();\n        let i = 0;\n\n        let onResult = e => {\n          o.add(e.output);\n\n          if (r && r.onResult) {\n            r.onResult(e);\n          }\n        };\n\n        for (let o = 0; o < t.length; o++) {\n          let a = s(String(t[o]), { ...r,\n            onResult: onResult\n          }, true);\n          let l = a.state.negated || a.state.negatedExtglob;\n          if (l) i++;\n\n          for (let t of e) {\n            let e = a(t, true);\n            let r = l ? !e.isMatch : e.isMatch;\n            if (!r) continue;\n\n            if (l) {\n              n.add(e.output);\n            } else {\n              n.delete(e.output);\n              u.add(e.output);\n            }\n          }\n        }\n\n        let a = i === t.length ? [...o] : [...u];\n        let l = a.filter(e => !n.has(e));\n\n        if (r && l.length === 0) {\n          if (r.failglob === true) {\n            throw new Error(`No matches found for \"${t.join(\", \")}\"`);\n          }\n\n          if (r.nonull === true || r.nullglob === true) {\n            return r.unescape ? t.map(e => e.replace(/\\\\/g, \"\")) : t;\n          }\n        }\n\n        return l;\n      };\n\n      micromatch.match = micromatch;\n\n      micromatch.matcher = (e, t) => s(e, t);\n\n      micromatch.isMatch = (e, t, r) => s(t, r)(e);\n\n      micromatch.any = micromatch.isMatch;\n\n      micromatch.not = (e, t, r = {}) => {\n        t = [].concat(t).map(String);\n        let n = new Set();\n        let u = [];\n\n        let onResult = e => {\n          if (r.onResult) r.onResult(e);\n          u.push(e.output);\n        };\n\n        let s = micromatch(e, t, { ...r,\n          onResult: onResult\n        });\n\n        for (let e of u) {\n          if (!s.includes(e)) {\n            n.add(e);\n          }\n        }\n\n        return [...n];\n      };\n\n      micromatch.contains = (e, t, r) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(`Expected a string: \"${n.inspect(e)}\"`);\n        }\n\n        if (Array.isArray(t)) {\n          return t.some(t => micromatch.contains(e, t, r));\n        }\n\n        if (typeof t === \"string\") {\n          if (isEmptyString(e) || isEmptyString(t)) {\n            return false;\n          }\n\n          if (e.includes(t) || e.startsWith(\"./\") && e.slice(2).includes(t)) {\n            return true;\n          }\n        }\n\n        return micromatch.isMatch(e, t, { ...r,\n          contains: true\n        });\n      };\n\n      micromatch.matchKeys = (e, t, r) => {\n        if (!o.isObject(e)) {\n          throw new TypeError(\"Expected the first argument to be an object\");\n        }\n\n        let n = micromatch(Object.keys(e), t, r);\n        let u = {};\n\n        for (let t of n) u[t] = e[t];\n\n        return u;\n      };\n\n      micromatch.some = (e, t, r) => {\n        let n = [].concat(e);\n\n        for (let e of [].concat(t)) {\n          let t = s(String(e), r);\n\n          if (n.some(e => t(e))) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      micromatch.every = (e, t, r) => {\n        let n = [].concat(e);\n\n        for (let e of [].concat(t)) {\n          let t = s(String(e), r);\n\n          if (!n.every(e => t(e))) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n\n      micromatch.all = (e, t, r) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(`Expected a string: \"${n.inspect(e)}\"`);\n        }\n\n        return [].concat(t).every(t => s(t, r)(e));\n      };\n\n      micromatch.capture = (e, t, r) => {\n        let n = o.isWindows(r);\n        let u = s.makeRe(String(e), { ...r,\n          capture: true\n        });\n        let i = u.exec(n ? o.toPosixSlashes(t) : t);\n\n        if (i) {\n          return i.slice(1).map(e => e === void 0 ? \"\" : e);\n        }\n      };\n\n      micromatch.makeRe = (...e) => s.makeRe(...e);\n\n      micromatch.scan = (...e) => s.scan(...e);\n\n      micromatch.parse = (e, t) => {\n        let r = [];\n\n        for (let n of [].concat(e || [])) {\n          for (let e of u(String(n), t)) {\n            r.push(s.parse(e, t));\n          }\n        }\n\n        return r;\n      };\n\n      micromatch.braces = (e, t) => {\n        if (typeof e !== \"string\") throw new TypeError(\"Expected a string\");\n\n        if (t && t.nobrace === true || !/\\{.*\\}/.test(e)) {\n          return [e];\n        }\n\n        return u(e, t);\n      };\n\n      micromatch.braceExpand = (e, t) => {\n        if (typeof e !== \"string\") throw new TypeError(\"Expected a string\");\n        return micromatch.braces(e, { ...t,\n          expand: true\n        });\n      };\n\n      e.exports = micromatch;\n    },\n    251: (e, t, r) => {\n      e.exports = r(683);\n    },\n    356: (e, t, r) => {\n      const n = r(17);\n      const u = \"\\\\\\\\/\";\n      const s = `[^${u}]`;\n      const o = \"\\\\.\";\n      const i = \"\\\\+\";\n      const a = \"\\\\?\";\n      const l = \"\\\\/\";\n      const c = \"(?=.)\";\n      const p = \"[^/]\";\n      const f = `(?:${l}|$)`;\n      const A = `(?:^|${l})`;\n      const R = `${o}{1,2}${f}`;\n      const _ = `(?!${o})`;\n      const h = `(?!${A}${R})`;\n      const g = `(?!${o}{0,1}${f})`;\n      const E = `(?!${R})`;\n      const C = `[^.${l}]`;\n      const y = `${p}*?`;\n      const d = {\n        DOT_LITERAL: o,\n        PLUS_LITERAL: i,\n        QMARK_LITERAL: a,\n        SLASH_LITERAL: l,\n        ONE_CHAR: c,\n        QMARK: p,\n        END_ANCHOR: f,\n        DOTS_SLASH: R,\n        NO_DOT: _,\n        NO_DOTS: h,\n        NO_DOT_SLASH: g,\n        NO_DOTS_SLASH: E,\n        QMARK_NO_DOT: C,\n        STAR: y,\n        START_ANCHOR: A\n      };\n      const x = { ...d,\n        SLASH_LITERAL: `[${u}]`,\n        QMARK: s,\n        STAR: `${s}*?`,\n        DOTS_SLASH: `${o}{1,2}(?:[${u}]|$)`,\n        NO_DOT: `(?!${o})`,\n        NO_DOTS: `(?!(?:^|[${u}])${o}{1,2}(?:[${u}]|$))`,\n        NO_DOT_SLASH: `(?!${o}{0,1}(?:[${u}]|$))`,\n        NO_DOTS_SLASH: `(?!${o}{1,2}(?:[${u}]|$))`,\n        QMARK_NO_DOT: `[^.${u}]`,\n        START_ANCHOR: `(?:^|[${u}])`,\n        END_ANCHOR: `(?:[${u}]|$)`\n      };\n      const b = {\n        alnum: \"a-zA-Z0-9\",\n        alpha: \"a-zA-Z\",\n        ascii: \"\\\\x00-\\\\x7F\",\n        blank: \" \\\\t\",\n        cntrl: \"\\\\x00-\\\\x1F\\\\x7F\",\n        digit: \"0-9\",\n        graph: \"\\\\x21-\\\\x7E\",\n        lower: \"a-z\",\n        print: \"\\\\x20-\\\\x7E \",\n        punct: \"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",\n        space: \" \\\\t\\\\r\\\\n\\\\v\\\\f\",\n        upper: \"A-Z\",\n        word: \"A-Za-z0-9_\",\n        xdigit: \"A-Fa-f0-9\"\n      };\n      e.exports = {\n        MAX_LENGTH: 1024 * 64,\n        POSIX_REGEX_SOURCE: b,\n        REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n        REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n        REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n        REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n        REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n        REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n        REPLACEMENTS: {\n          \"***\": \"*\",\n          \"**/**\": \"**\",\n          \"**/**/**\": \"**\"\n        },\n        CHAR_0: 48,\n        CHAR_9: 57,\n        CHAR_UPPERCASE_A: 65,\n        CHAR_LOWERCASE_A: 97,\n        CHAR_UPPERCASE_Z: 90,\n        CHAR_LOWERCASE_Z: 122,\n        CHAR_LEFT_PARENTHESES: 40,\n        CHAR_RIGHT_PARENTHESES: 41,\n        CHAR_ASTERISK: 42,\n        CHAR_AMPERSAND: 38,\n        CHAR_AT: 64,\n        CHAR_BACKWARD_SLASH: 92,\n        CHAR_CARRIAGE_RETURN: 13,\n        CHAR_CIRCUMFLEX_ACCENT: 94,\n        CHAR_COLON: 58,\n        CHAR_COMMA: 44,\n        CHAR_DOT: 46,\n        CHAR_DOUBLE_QUOTE: 34,\n        CHAR_EQUAL: 61,\n        CHAR_EXCLAMATION_MARK: 33,\n        CHAR_FORM_FEED: 12,\n        CHAR_FORWARD_SLASH: 47,\n        CHAR_GRAVE_ACCENT: 96,\n        CHAR_HASH: 35,\n        CHAR_HYPHEN_MINUS: 45,\n        CHAR_LEFT_ANGLE_BRACKET: 60,\n        CHAR_LEFT_CURLY_BRACE: 123,\n        CHAR_LEFT_SQUARE_BRACKET: 91,\n        CHAR_LINE_FEED: 10,\n        CHAR_NO_BREAK_SPACE: 160,\n        CHAR_PERCENT: 37,\n        CHAR_PLUS: 43,\n        CHAR_QUESTION_MARK: 63,\n        CHAR_RIGHT_ANGLE_BRACKET: 62,\n        CHAR_RIGHT_CURLY_BRACE: 125,\n        CHAR_RIGHT_SQUARE_BRACKET: 93,\n        CHAR_SEMICOLON: 59,\n        CHAR_SINGLE_QUOTE: 39,\n        CHAR_SPACE: 32,\n        CHAR_TAB: 9,\n        CHAR_UNDERSCORE: 95,\n        CHAR_VERTICAL_LINE: 124,\n        CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n        SEP: n.sep,\n\n        extglobChars(e) {\n          return {\n            \"!\": {\n              type: \"negate\",\n              open: \"(?:(?!(?:\",\n              close: `))${e.STAR})`\n            },\n            \"?\": {\n              type: \"qmark\",\n              open: \"(?:\",\n              close: \")?\"\n            },\n            \"+\": {\n              type: \"plus\",\n              open: \"(?:\",\n              close: \")+\"\n            },\n            \"*\": {\n              type: \"star\",\n              open: \"(?:\",\n              close: \")*\"\n            },\n            \"@\": {\n              type: \"at\",\n              open: \"(?:\",\n              close: \")\"\n            }\n          };\n        },\n\n        globChars(e) {\n          return e === true ? x : d;\n        }\n\n      };\n    },\n    754: (e, t, r) => {\n      const n = r(356);\n      const u = r(513);\n      const {\n        MAX_LENGTH: s,\n        POSIX_REGEX_SOURCE: o,\n        REGEX_NON_SPECIAL_CHARS: i,\n        REGEX_SPECIAL_CHARS_BACKREF: a,\n        REPLACEMENTS: l\n      } = n;\n\n      const expandRange = (e, t) => {\n        if (typeof t.expandRange === \"function\") {\n          return t.expandRange(...e, t);\n        }\n\n        e.sort();\n        const r = `[${e.join(\"-\")}]`;\n\n        try {\n          new RegExp(r);\n        } catch (t) {\n          return e.map(e => u.escapeRegex(e)).join(\"..\");\n        }\n\n        return r;\n      };\n\n      const syntaxError = (e, t) => `Missing ${e}: \"${t}\" - use \"\\\\\\\\${t}\" to match literal characters`;\n\n      const parse = (e, t) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(\"Expected a string\");\n        }\n\n        e = l[e] || e;\n        const r = { ...t\n        };\n        const c = typeof r.maxLength === \"number\" ? Math.min(s, r.maxLength) : s;\n        let p = e.length;\n\n        if (p > c) {\n          throw new SyntaxError(`Input length: ${p}, exceeds maximum allowed length: ${c}`);\n        }\n\n        const f = {\n          type: \"bos\",\n          value: \"\",\n          output: r.prepend || \"\"\n        };\n        const A = [f];\n        const R = r.capture ? \"\" : \"?:\";\n\n        const _ = u.isWindows(t);\n\n        const h = n.globChars(_);\n        const g = n.extglobChars(h);\n        const {\n          DOT_LITERAL: E,\n          PLUS_LITERAL: C,\n          SLASH_LITERAL: y,\n          ONE_CHAR: d,\n          DOTS_SLASH: x,\n          NO_DOT: b,\n          NO_DOT_SLASH: S,\n          NO_DOTS_SLASH: H,\n          QMARK: v,\n          QMARK_NO_DOT: $,\n          STAR: m,\n          START_ANCHOR: T\n        } = h;\n\n        const globstar = e => `(${R}(?:(?!${T}${e.dot ? x : E}).)*?)`;\n\n        const L = r.dot ? \"\" : b;\n        const O = r.dot ? v : $;\n        let w = r.bash === true ? globstar(r) : m;\n\n        if (r.capture) {\n          w = `(${w})`;\n        }\n\n        if (typeof r.noext === \"boolean\") {\n          r.noextglob = r.noext;\n        }\n\n        const N = {\n          input: e,\n          index: -1,\n          start: 0,\n          dot: r.dot === true,\n          consumed: \"\",\n          output: \"\",\n          prefix: \"\",\n          backtrack: false,\n          negated: false,\n          brackets: 0,\n          braces: 0,\n          parens: 0,\n          quotes: 0,\n          globstar: false,\n          tokens: A\n        };\n        e = u.removePrefix(e, N);\n        p = e.length;\n        const k = [];\n        const I = [];\n        const M = [];\n        let P = f;\n        let B;\n\n        const eos = () => N.index === p - 1;\n\n        const G = N.peek = (t = 1) => e[N.index + t];\n\n        const D = N.advance = () => e[++N.index];\n\n        const remaining = () => e.slice(N.index + 1);\n\n        const consume = (e = \"\", t = 0) => {\n          N.consumed += e;\n          N.index += t;\n        };\n\n        const append = e => {\n          N.output += e.output != null ? e.output : e.value;\n          consume(e.value);\n        };\n\n        const negate = () => {\n          let e = 1;\n\n          while (G() === \"!\" && (G(2) !== \"(\" || G(3) === \"?\")) {\n            D();\n            N.start++;\n            e++;\n          }\n\n          if (e % 2 === 0) {\n            return false;\n          }\n\n          N.negated = true;\n          N.start++;\n          return true;\n        };\n\n        const increment = e => {\n          N[e]++;\n          M.push(e);\n        };\n\n        const decrement = e => {\n          N[e]--;\n          M.pop();\n        };\n\n        const push = e => {\n          if (P.type === \"globstar\") {\n            const t = N.braces > 0 && (e.type === \"comma\" || e.type === \"brace\");\n            const r = e.extglob === true || k.length && (e.type === \"pipe\" || e.type === \"paren\");\n\n            if (e.type !== \"slash\" && e.type !== \"paren\" && !t && !r) {\n              N.output = N.output.slice(0, -P.output.length);\n              P.type = \"star\";\n              P.value = \"*\";\n              P.output = w;\n              N.output += P.output;\n            }\n          }\n\n          if (k.length && e.type !== \"paren\" && !g[e.value]) {\n            k[k.length - 1].inner += e.value;\n          }\n\n          if (e.value || e.output) append(e);\n\n          if (P && P.type === \"text\" && e.type === \"text\") {\n            P.value += e.value;\n            P.output = (P.output || \"\") + e.value;\n            return;\n          }\n\n          e.prev = P;\n          A.push(e);\n          P = e;\n        };\n\n        const extglobOpen = (e, t) => {\n          const n = { ...g[t],\n            conditions: 1,\n            inner: \"\"\n          };\n          n.prev = P;\n          n.parens = N.parens;\n          n.output = N.output;\n          const u = (r.capture ? \"(\" : \"\") + n.open;\n          increment(\"parens\");\n          push({\n            type: e,\n            value: t,\n            output: N.output ? \"\" : d\n          });\n          push({\n            type: \"paren\",\n            extglob: true,\n            value: D(),\n            output: u\n          });\n          k.push(n);\n        };\n\n        const extglobClose = e => {\n          let t = e.close + (r.capture ? \")\" : \"\");\n\n          if (e.type === \"negate\") {\n            let n = w;\n\n            if (e.inner && e.inner.length > 1 && e.inner.includes(\"/\")) {\n              n = globstar(r);\n            }\n\n            if (n !== w || eos() || /^\\)+$/.test(remaining())) {\n              t = e.close = `)$))${n}`;\n            }\n\n            if (e.prev.type === \"bos\") {\n              N.negatedExtglob = true;\n            }\n          }\n\n          push({\n            type: \"paren\",\n            extglob: true,\n            value: B,\n            output: t\n          });\n          decrement(\"parens\");\n        };\n\n        if (r.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(e)) {\n          let n = false;\n          let s = e.replace(a, (e, t, r, u, s, o) => {\n            if (u === \"\\\\\") {\n              n = true;\n              return e;\n            }\n\n            if (u === \"?\") {\n              if (t) {\n                return t + u + (s ? v.repeat(s.length) : \"\");\n              }\n\n              if (o === 0) {\n                return O + (s ? v.repeat(s.length) : \"\");\n              }\n\n              return v.repeat(r.length);\n            }\n\n            if (u === \".\") {\n              return E.repeat(r.length);\n            }\n\n            if (u === \"*\") {\n              if (t) {\n                return t + u + (s ? w : \"\");\n              }\n\n              return w;\n            }\n\n            return t ? e : `\\\\${e}`;\n          });\n\n          if (n === true) {\n            if (r.unescape === true) {\n              s = s.replace(/\\\\/g, \"\");\n            } else {\n              s = s.replace(/\\\\+/g, e => e.length % 2 === 0 ? \"\\\\\\\\\" : e ? \"\\\\\" : \"\");\n            }\n          }\n\n          if (s === e && r.contains === true) {\n            N.output = e;\n            return N;\n          }\n\n          N.output = u.wrapOutput(s, N, t);\n          return N;\n        }\n\n        while (!eos()) {\n          B = D();\n\n          if (B === \"\\0\") {\n            continue;\n          }\n\n          if (B === \"\\\\\") {\n            const e = G();\n\n            if (e === \"/\" && r.bash !== true) {\n              continue;\n            }\n\n            if (e === \".\" || e === \";\") {\n              continue;\n            }\n\n            if (!e) {\n              B += \"\\\\\";\n              push({\n                type: \"text\",\n                value: B\n              });\n              continue;\n            }\n\n            const t = /^\\\\+/.exec(remaining());\n            let n = 0;\n\n            if (t && t[0].length > 2) {\n              n = t[0].length;\n              N.index += n;\n\n              if (n % 2 !== 0) {\n                B += \"\\\\\";\n              }\n            }\n\n            if (r.unescape === true) {\n              B = D() || \"\";\n            } else {\n              B += D() || \"\";\n            }\n\n            if (N.brackets === 0) {\n              push({\n                type: \"text\",\n                value: B\n              });\n              continue;\n            }\n          }\n\n          if (N.brackets > 0 && (B !== \"]\" || P.value === \"[\" || P.value === \"[^\")) {\n            if (r.posix !== false && B === \":\") {\n              const e = P.value.slice(1);\n\n              if (e.includes(\"[\")) {\n                P.posix = true;\n\n                if (e.includes(\":\")) {\n                  const e = P.value.lastIndexOf(\"[\");\n                  const t = P.value.slice(0, e);\n                  const r = P.value.slice(e + 2);\n                  const n = o[r];\n\n                  if (n) {\n                    P.value = t + n;\n                    N.backtrack = true;\n                    D();\n\n                    if (!f.output && A.indexOf(P) === 1) {\n                      f.output = d;\n                    }\n\n                    continue;\n                  }\n                }\n              }\n            }\n\n            if (B === \"[\" && G() !== \":\" || B === \"-\" && G() === \"]\") {\n              B = `\\\\${B}`;\n            }\n\n            if (B === \"]\" && (P.value === \"[\" || P.value === \"[^\")) {\n              B = `\\\\${B}`;\n            }\n\n            if (r.posix === true && B === \"!\" && P.value === \"[\") {\n              B = \"^\";\n            }\n\n            P.value += B;\n            append({\n              value: B\n            });\n            continue;\n          }\n\n          if (N.quotes === 1 && B !== '\"') {\n            B = u.escapeRegex(B);\n            P.value += B;\n            append({\n              value: B\n            });\n            continue;\n          }\n\n          if (B === '\"') {\n            N.quotes = N.quotes === 1 ? 0 : 1;\n\n            if (r.keepQuotes === true) {\n              push({\n                type: \"text\",\n                value: B\n              });\n            }\n\n            continue;\n          }\n\n          if (B === \"(\") {\n            increment(\"parens\");\n            push({\n              type: \"paren\",\n              value: B\n            });\n            continue;\n          }\n\n          if (B === \")\") {\n            if (N.parens === 0 && r.strictBrackets === true) {\n              throw new SyntaxError(syntaxError(\"opening\", \"(\"));\n            }\n\n            const e = k[k.length - 1];\n\n            if (e && N.parens === e.parens + 1) {\n              extglobClose(k.pop());\n              continue;\n            }\n\n            push({\n              type: \"paren\",\n              value: B,\n              output: N.parens ? \")\" : \"\\\\)\"\n            });\n            decrement(\"parens\");\n            continue;\n          }\n\n          if (B === \"[\") {\n            if (r.nobracket === true || !remaining().includes(\"]\")) {\n              if (r.nobracket !== true && r.strictBrackets === true) {\n                throw new SyntaxError(syntaxError(\"closing\", \"]\"));\n              }\n\n              B = `\\\\${B}`;\n            } else {\n              increment(\"brackets\");\n            }\n\n            push({\n              type: \"bracket\",\n              value: B\n            });\n            continue;\n          }\n\n          if (B === \"]\") {\n            if (r.nobracket === true || P && P.type === \"bracket\" && P.value.length === 1) {\n              push({\n                type: \"text\",\n                value: B,\n                output: `\\\\${B}`\n              });\n              continue;\n            }\n\n            if (N.brackets === 0) {\n              if (r.strictBrackets === true) {\n                throw new SyntaxError(syntaxError(\"opening\", \"[\"));\n              }\n\n              push({\n                type: \"text\",\n                value: B,\n                output: `\\\\${B}`\n              });\n              continue;\n            }\n\n            decrement(\"brackets\");\n            const e = P.value.slice(1);\n\n            if (P.posix !== true && e[0] === \"^\" && !e.includes(\"/\")) {\n              B = `/${B}`;\n            }\n\n            P.value += B;\n            append({\n              value: B\n            });\n\n            if (r.literalBrackets === false || u.hasRegexChars(e)) {\n              continue;\n            }\n\n            const t = u.escapeRegex(P.value);\n            N.output = N.output.slice(0, -P.value.length);\n\n            if (r.literalBrackets === true) {\n              N.output += t;\n              P.value = t;\n              continue;\n            }\n\n            P.value = `(${R}${t}|${P.value})`;\n            N.output += P.value;\n            continue;\n          }\n\n          if (B === \"{\" && r.nobrace !== true) {\n            increment(\"braces\");\n            const e = {\n              type: \"brace\",\n              value: B,\n              output: \"(\",\n              outputIndex: N.output.length,\n              tokensIndex: N.tokens.length\n            };\n            I.push(e);\n            push(e);\n            continue;\n          }\n\n          if (B === \"}\") {\n            const e = I[I.length - 1];\n\n            if (r.nobrace === true || !e) {\n              push({\n                type: \"text\",\n                value: B,\n                output: B\n              });\n              continue;\n            }\n\n            let t = \")\";\n\n            if (e.dots === true) {\n              const e = A.slice();\n              const n = [];\n\n              for (let t = e.length - 1; t >= 0; t--) {\n                A.pop();\n\n                if (e[t].type === \"brace\") {\n                  break;\n                }\n\n                if (e[t].type !== \"dots\") {\n                  n.unshift(e[t].value);\n                }\n              }\n\n              t = expandRange(n, r);\n              N.backtrack = true;\n            }\n\n            if (e.comma !== true && e.dots !== true) {\n              const r = N.output.slice(0, e.outputIndex);\n              const n = N.tokens.slice(e.tokensIndex);\n              e.value = e.output = \"\\\\{\";\n              B = t = \"\\\\}\";\n              N.output = r;\n\n              for (const e of n) {\n                N.output += e.output || e.value;\n              }\n            }\n\n            push({\n              type: \"brace\",\n              value: B,\n              output: t\n            });\n            decrement(\"braces\");\n            I.pop();\n            continue;\n          }\n\n          if (B === \"|\") {\n            if (k.length > 0) {\n              k[k.length - 1].conditions++;\n            }\n\n            push({\n              type: \"text\",\n              value: B\n            });\n            continue;\n          }\n\n          if (B === \",\") {\n            let e = B;\n            const t = I[I.length - 1];\n\n            if (t && M[M.length - 1] === \"braces\") {\n              t.comma = true;\n              e = \"|\";\n            }\n\n            push({\n              type: \"comma\",\n              value: B,\n              output: e\n            });\n            continue;\n          }\n\n          if (B === \"/\") {\n            if (P.type === \"dot\" && N.index === N.start + 1) {\n              N.start = N.index + 1;\n              N.consumed = \"\";\n              N.output = \"\";\n              A.pop();\n              P = f;\n              continue;\n            }\n\n            push({\n              type: \"slash\",\n              value: B,\n              output: y\n            });\n            continue;\n          }\n\n          if (B === \".\") {\n            if (N.braces > 0 && P.type === \"dot\") {\n              if (P.value === \".\") P.output = E;\n              const e = I[I.length - 1];\n              P.type = \"dots\";\n              P.output += B;\n              P.value += B;\n              e.dots = true;\n              continue;\n            }\n\n            if (N.braces + N.parens === 0 && P.type !== \"bos\" && P.type !== \"slash\") {\n              push({\n                type: \"text\",\n                value: B,\n                output: E\n              });\n              continue;\n            }\n\n            push({\n              type: \"dot\",\n              value: B,\n              output: E\n            });\n            continue;\n          }\n\n          if (B === \"?\") {\n            const e = P && P.value === \"(\";\n\n            if (!e && r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n              extglobOpen(\"qmark\", B);\n              continue;\n            }\n\n            if (P && P.type === \"paren\") {\n              const e = G();\n              let t = B;\n\n              if (e === \"<\" && !u.supportsLookbehinds()) {\n                throw new Error(\"Node.js v10 or higher is required for regex lookbehinds\");\n              }\n\n              if (P.value === \"(\" && !/[!=<:]/.test(e) || e === \"<\" && !/<([!=]|\\w+>)/.test(remaining())) {\n                t = `\\\\${B}`;\n              }\n\n              push({\n                type: \"text\",\n                value: B,\n                output: t\n              });\n              continue;\n            }\n\n            if (r.dot !== true && (P.type === \"slash\" || P.type === \"bos\")) {\n              push({\n                type: \"qmark\",\n                value: B,\n                output: $\n              });\n              continue;\n            }\n\n            push({\n              type: \"qmark\",\n              value: B,\n              output: v\n            });\n            continue;\n          }\n\n          if (B === \"!\") {\n            if (r.noextglob !== true && G() === \"(\") {\n              if (G(2) !== \"?\" || !/[!=<:]/.test(G(3))) {\n                extglobOpen(\"negate\", B);\n                continue;\n              }\n            }\n\n            if (r.nonegate !== true && N.index === 0) {\n              negate();\n              continue;\n            }\n          }\n\n          if (B === \"+\") {\n            if (r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n              extglobOpen(\"plus\", B);\n              continue;\n            }\n\n            if (P && P.value === \"(\" || r.regex === false) {\n              push({\n                type: \"plus\",\n                value: B,\n                output: C\n              });\n              continue;\n            }\n\n            if (P && (P.type === \"bracket\" || P.type === \"paren\" || P.type === \"brace\") || N.parens > 0) {\n              push({\n                type: \"plus\",\n                value: B\n              });\n              continue;\n            }\n\n            push({\n              type: \"plus\",\n              value: C\n            });\n            continue;\n          }\n\n          if (B === \"@\") {\n            if (r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n              push({\n                type: \"at\",\n                extglob: true,\n                value: B,\n                output: \"\"\n              });\n              continue;\n            }\n\n            push({\n              type: \"text\",\n              value: B\n            });\n            continue;\n          }\n\n          if (B !== \"*\") {\n            if (B === \"$\" || B === \"^\") {\n              B = `\\\\${B}`;\n            }\n\n            const e = i.exec(remaining());\n\n            if (e) {\n              B += e[0];\n              N.index += e[0].length;\n            }\n\n            push({\n              type: \"text\",\n              value: B\n            });\n            continue;\n          }\n\n          if (P && (P.type === \"globstar\" || P.star === true)) {\n            P.type = \"star\";\n            P.star = true;\n            P.value += B;\n            P.output = w;\n            N.backtrack = true;\n            N.globstar = true;\n            consume(B);\n            continue;\n          }\n\n          let t = remaining();\n\n          if (r.noextglob !== true && /^\\([^?]/.test(t)) {\n            extglobOpen(\"star\", B);\n            continue;\n          }\n\n          if (P.type === \"star\") {\n            if (r.noglobstar === true) {\n              consume(B);\n              continue;\n            }\n\n            const n = P.prev;\n            const u = n.prev;\n            const s = n.type === \"slash\" || n.type === \"bos\";\n            const o = u && (u.type === \"star\" || u.type === \"globstar\");\n\n            if (r.bash === true && (!s || t[0] && t[0] !== \"/\")) {\n              push({\n                type: \"star\",\n                value: B,\n                output: \"\"\n              });\n              continue;\n            }\n\n            const i = N.braces > 0 && (n.type === \"comma\" || n.type === \"brace\");\n            const a = k.length && (n.type === \"pipe\" || n.type === \"paren\");\n\n            if (!s && n.type !== \"paren\" && !i && !a) {\n              push({\n                type: \"star\",\n                value: B,\n                output: \"\"\n              });\n              continue;\n            }\n\n            while (t.slice(0, 3) === \"/**\") {\n              const r = e[N.index + 4];\n\n              if (r && r !== \"/\") {\n                break;\n              }\n\n              t = t.slice(3);\n              consume(\"/**\", 3);\n            }\n\n            if (n.type === \"bos\" && eos()) {\n              P.type = \"globstar\";\n              P.value += B;\n              P.output = globstar(r);\n              N.output = P.output;\n              N.globstar = true;\n              consume(B);\n              continue;\n            }\n\n            if (n.type === \"slash\" && n.prev.type !== \"bos\" && !o && eos()) {\n              N.output = N.output.slice(0, -(n.output + P.output).length);\n              n.output = `(?:${n.output}`;\n              P.type = \"globstar\";\n              P.output = globstar(r) + (r.strictSlashes ? \")\" : \"|$)\");\n              P.value += B;\n              N.globstar = true;\n              N.output += n.output + P.output;\n              consume(B);\n              continue;\n            }\n\n            if (n.type === \"slash\" && n.prev.type !== \"bos\" && t[0] === \"/\") {\n              const e = t[1] !== void 0 ? \"|$\" : \"\";\n              N.output = N.output.slice(0, -(n.output + P.output).length);\n              n.output = `(?:${n.output}`;\n              P.type = \"globstar\";\n              P.output = `${globstar(r)}${y}|${y}${e})`;\n              P.value += B;\n              N.output += n.output + P.output;\n              N.globstar = true;\n              consume(B + D());\n              push({\n                type: \"slash\",\n                value: \"/\",\n                output: \"\"\n              });\n              continue;\n            }\n\n            if (n.type === \"bos\" && t[0] === \"/\") {\n              P.type = \"globstar\";\n              P.value += B;\n              P.output = `(?:^|${y}|${globstar(r)}${y})`;\n              N.output = P.output;\n              N.globstar = true;\n              consume(B + D());\n              push({\n                type: \"slash\",\n                value: \"/\",\n                output: \"\"\n              });\n              continue;\n            }\n\n            N.output = N.output.slice(0, -P.output.length);\n            P.type = \"globstar\";\n            P.output = globstar(r);\n            P.value += B;\n            N.output += P.output;\n            N.globstar = true;\n            consume(B);\n            continue;\n          }\n\n          const n = {\n            type: \"star\",\n            value: B,\n            output: w\n          };\n\n          if (r.bash === true) {\n            n.output = \".*?\";\n\n            if (P.type === \"bos\" || P.type === \"slash\") {\n              n.output = L + n.output;\n            }\n\n            push(n);\n            continue;\n          }\n\n          if (P && (P.type === \"bracket\" || P.type === \"paren\") && r.regex === true) {\n            n.output = B;\n            push(n);\n            continue;\n          }\n\n          if (N.index === N.start || P.type === \"slash\" || P.type === \"dot\") {\n            if (P.type === \"dot\") {\n              N.output += S;\n              P.output += S;\n            } else if (r.dot === true) {\n              N.output += H;\n              P.output += H;\n            } else {\n              N.output += L;\n              P.output += L;\n            }\n\n            if (G() !== \"*\") {\n              N.output += d;\n              P.output += d;\n            }\n          }\n\n          push(n);\n        }\n\n        while (N.brackets > 0) {\n          if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \"]\"));\n          N.output = u.escapeLast(N.output, \"[\");\n          decrement(\"brackets\");\n        }\n\n        while (N.parens > 0) {\n          if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \")\"));\n          N.output = u.escapeLast(N.output, \"(\");\n          decrement(\"parens\");\n        }\n\n        while (N.braces > 0) {\n          if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \"}\"));\n          N.output = u.escapeLast(N.output, \"{\");\n          decrement(\"braces\");\n        }\n\n        if (r.strictSlashes !== true && (P.type === \"star\" || P.type === \"bracket\")) {\n          push({\n            type: \"maybe_slash\",\n            value: \"\",\n            output: `${y}?`\n          });\n        }\n\n        if (N.backtrack === true) {\n          N.output = \"\";\n\n          for (const e of N.tokens) {\n            N.output += e.output != null ? e.output : e.value;\n\n            if (e.suffix) {\n              N.output += e.suffix;\n            }\n          }\n        }\n\n        return N;\n      };\n\n      parse.fastpaths = (e, t) => {\n        const r = { ...t\n        };\n        const o = typeof r.maxLength === \"number\" ? Math.min(s, r.maxLength) : s;\n        const i = e.length;\n\n        if (i > o) {\n          throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${o}`);\n        }\n\n        e = l[e] || e;\n        const a = u.isWindows(t);\n        const {\n          DOT_LITERAL: c,\n          SLASH_LITERAL: p,\n          ONE_CHAR: f,\n          DOTS_SLASH: A,\n          NO_DOT: R,\n          NO_DOTS: _,\n          NO_DOTS_SLASH: h,\n          STAR: g,\n          START_ANCHOR: E\n        } = n.globChars(a);\n        const C = r.dot ? _ : R;\n        const y = r.dot ? h : R;\n        const d = r.capture ? \"\" : \"?:\";\n        const x = {\n          negated: false,\n          prefix: \"\"\n        };\n        let b = r.bash === true ? \".*?\" : g;\n\n        if (r.capture) {\n          b = `(${b})`;\n        }\n\n        const globstar = e => {\n          if (e.noglobstar === true) return b;\n          return `(${d}(?:(?!${E}${e.dot ? A : c}).)*?)`;\n        };\n\n        const create = e => {\n          switch (e) {\n            case \"*\":\n              return `${C}${f}${b}`;\n\n            case \".*\":\n              return `${c}${f}${b}`;\n\n            case \"*.*\":\n              return `${C}${b}${c}${f}${b}`;\n\n            case \"*/*\":\n              return `${C}${b}${p}${f}${y}${b}`;\n\n            case \"**\":\n              return C + globstar(r);\n\n            case \"**/*\":\n              return `(?:${C}${globstar(r)}${p})?${y}${f}${b}`;\n\n            case \"**/*.*\":\n              return `(?:${C}${globstar(r)}${p})?${y}${b}${c}${f}${b}`;\n\n            case \"**/.*\":\n              return `(?:${C}${globstar(r)}${p})?${c}${f}${b}`;\n\n            default:\n              {\n                const t = /^(.*?)\\.(\\w+)$/.exec(e);\n                if (!t) return;\n                const r = create(t[1]);\n                if (!r) return;\n                return r + c + t[2];\n              }\n          }\n        };\n\n        const S = u.removePrefix(e, x);\n        let H = create(S);\n\n        if (H && r.strictSlashes !== true) {\n          H += `${p}?`;\n        }\n\n        return H;\n      };\n\n      e.exports = parse;\n    },\n    683: (e, t, r) => {\n      const n = r(17);\n      const u = r(700);\n      const s = r(754);\n      const o = r(513);\n      const i = r(356);\n\n      const isObject = e => e && typeof e === \"object\" && !Array.isArray(e);\n\n      const picomatch = (e, t, r = false) => {\n        if (Array.isArray(e)) {\n          const n = e.map(e => picomatch(e, t, r));\n\n          const arrayMatcher = e => {\n            for (const t of n) {\n              const r = t(e);\n              if (r) return r;\n            }\n\n            return false;\n          };\n\n          return arrayMatcher;\n        }\n\n        const n = isObject(e) && e.tokens && e.input;\n\n        if (e === \"\" || typeof e !== \"string\" && !n) {\n          throw new TypeError(\"Expected pattern to be a non-empty string\");\n        }\n\n        const u = t || {};\n        const s = o.isWindows(t);\n        const i = n ? picomatch.compileRe(e, t) : picomatch.makeRe(e, t, false, true);\n        const a = i.state;\n        delete i.state;\n\n        let isIgnored = () => false;\n\n        if (u.ignore) {\n          const e = { ...t,\n            ignore: null,\n            onMatch: null,\n            onResult: null\n          };\n          isIgnored = picomatch(u.ignore, e, r);\n        }\n\n        const matcher = (r, n = false) => {\n          const {\n            isMatch: o,\n            match: l,\n            output: c\n          } = picomatch.test(r, i, t, {\n            glob: e,\n            posix: s\n          });\n          const p = {\n            glob: e,\n            state: a,\n            regex: i,\n            posix: s,\n            input: r,\n            output: c,\n            match: l,\n            isMatch: o\n          };\n\n          if (typeof u.onResult === \"function\") {\n            u.onResult(p);\n          }\n\n          if (o === false) {\n            p.isMatch = false;\n            return n ? p : false;\n          }\n\n          if (isIgnored(r)) {\n            if (typeof u.onIgnore === \"function\") {\n              u.onIgnore(p);\n            }\n\n            p.isMatch = false;\n            return n ? p : false;\n          }\n\n          if (typeof u.onMatch === \"function\") {\n            u.onMatch(p);\n          }\n\n          return n ? p : true;\n        };\n\n        if (r) {\n          matcher.state = a;\n        }\n\n        return matcher;\n      };\n\n      picomatch.test = (e, t, r, {\n        glob: n,\n        posix: u\n      } = {}) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(\"Expected input to be a string\");\n        }\n\n        if (e === \"\") {\n          return {\n            isMatch: false,\n            output: \"\"\n          };\n        }\n\n        const s = r || {};\n        const i = s.format || (u ? o.toPosixSlashes : null);\n        let a = e === n;\n        let l = a && i ? i(e) : e;\n\n        if (a === false) {\n          l = i ? i(e) : e;\n          a = l === n;\n        }\n\n        if (a === false || s.capture === true) {\n          if (s.matchBase === true || s.basename === true) {\n            a = picomatch.matchBase(e, t, r, u);\n          } else {\n            a = t.exec(l);\n          }\n        }\n\n        return {\n          isMatch: Boolean(a),\n          match: a,\n          output: l\n        };\n      };\n\n      picomatch.matchBase = (e, t, r, u = o.isWindows(r)) => {\n        const s = t instanceof RegExp ? t : picomatch.makeRe(t, r);\n        return s.test(n.basename(e));\n      };\n\n      picomatch.isMatch = (e, t, r) => picomatch(t, r)(e);\n\n      picomatch.parse = (e, t) => {\n        if (Array.isArray(e)) return e.map(e => picomatch.parse(e, t));\n        return s(e, { ...t,\n          fastpaths: false\n        });\n      };\n\n      picomatch.scan = (e, t) => u(e, t);\n\n      picomatch.compileRe = (e, t, r = false, n = false) => {\n        if (r === true) {\n          return e.output;\n        }\n\n        const u = t || {};\n        const s = u.contains ? \"\" : \"^\";\n        const o = u.contains ? \"\" : \"$\";\n        let i = `${s}(?:${e.output})${o}`;\n\n        if (e && e.negated === true) {\n          i = `^(?!${i}).*$`;\n        }\n\n        const a = picomatch.toRegex(i, t);\n\n        if (n === true) {\n          a.state = e;\n        }\n\n        return a;\n      };\n\n      picomatch.makeRe = (e, t, r = false, n = false) => {\n        if (!e || typeof e !== \"string\") {\n          throw new TypeError(\"Expected a non-empty string\");\n        }\n\n        const u = t || {};\n        let o = {\n          negated: false,\n          fastpaths: true\n        };\n        let i = \"\";\n        let a;\n\n        if (e.startsWith(\"./\")) {\n          e = e.slice(2);\n          i = o.prefix = \"./\";\n        }\n\n        if (u.fastpaths !== false && (e[0] === \".\" || e[0] === \"*\")) {\n          a = s.fastpaths(e, t);\n        }\n\n        if (a === undefined) {\n          o = s(e, t);\n          o.prefix = i + (o.prefix || \"\");\n        } else {\n          o.output = a;\n        }\n\n        return picomatch.compileRe(o, t, r, n);\n      };\n\n      picomatch.toRegex = (e, t) => {\n        try {\n          const r = t || {};\n          return new RegExp(e, r.flags || (r.nocase ? \"i\" : \"\"));\n        } catch (e) {\n          if (t && t.debug === true) throw e;\n          return /$^/;\n        }\n      };\n\n      picomatch.constants = i;\n      e.exports = picomatch;\n    },\n    700: (e, t, r) => {\n      const n = r(513);\n      const {\n        CHAR_ASTERISK: u,\n        CHAR_AT: s,\n        CHAR_BACKWARD_SLASH: o,\n        CHAR_COMMA: i,\n        CHAR_DOT: a,\n        CHAR_EXCLAMATION_MARK: l,\n        CHAR_FORWARD_SLASH: c,\n        CHAR_LEFT_CURLY_BRACE: p,\n        CHAR_LEFT_PARENTHESES: f,\n        CHAR_LEFT_SQUARE_BRACKET: A,\n        CHAR_PLUS: R,\n        CHAR_QUESTION_MARK: _,\n        CHAR_RIGHT_CURLY_BRACE: h,\n        CHAR_RIGHT_PARENTHESES: g,\n        CHAR_RIGHT_SQUARE_BRACKET: E\n      } = r(356);\n\n      const isPathSeparator = e => e === c || e === o;\n\n      const depth = e => {\n        if (e.isPrefix !== true) {\n          e.depth = e.isGlobstar ? Infinity : 1;\n        }\n      };\n\n      const scan = (e, t) => {\n        const r = t || {};\n        const C = e.length - 1;\n        const y = r.parts === true || r.scanToEnd === true;\n        const d = [];\n        const x = [];\n        const b = [];\n        let S = e;\n        let H = -1;\n        let v = 0;\n        let $ = 0;\n        let m = false;\n        let T = false;\n        let L = false;\n        let O = false;\n        let w = false;\n        let N = false;\n        let k = false;\n        let I = false;\n        let M = false;\n        let P = 0;\n        let B;\n        let G;\n        let D = {\n          value: \"\",\n          depth: 0,\n          isGlob: false\n        };\n\n        const eos = () => H >= C;\n\n        const peek = () => S.charCodeAt(H + 1);\n\n        const advance = () => {\n          B = G;\n          return S.charCodeAt(++H);\n        };\n\n        while (H < C) {\n          G = advance();\n          let e;\n\n          if (G === o) {\n            k = D.backslashes = true;\n            G = advance();\n\n            if (G === p) {\n              N = true;\n            }\n\n            continue;\n          }\n\n          if (N === true || G === p) {\n            P++;\n\n            while (eos() !== true && (G = advance())) {\n              if (G === o) {\n                k = D.backslashes = true;\n                advance();\n                continue;\n              }\n\n              if (G === p) {\n                P++;\n                continue;\n              }\n\n              if (N !== true && G === a && (G = advance()) === a) {\n                m = D.isBrace = true;\n                L = D.isGlob = true;\n                M = true;\n\n                if (y === true) {\n                  continue;\n                }\n\n                break;\n              }\n\n              if (N !== true && G === i) {\n                m = D.isBrace = true;\n                L = D.isGlob = true;\n                M = true;\n\n                if (y === true) {\n                  continue;\n                }\n\n                break;\n              }\n\n              if (G === h) {\n                P--;\n\n                if (P === 0) {\n                  N = false;\n                  m = D.isBrace = true;\n                  M = true;\n                  break;\n                }\n              }\n            }\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n\n          if (G === c) {\n            d.push(H);\n            x.push(D);\n            D = {\n              value: \"\",\n              depth: 0,\n              isGlob: false\n            };\n            if (M === true) continue;\n\n            if (B === a && H === v + 1) {\n              v += 2;\n              continue;\n            }\n\n            $ = H + 1;\n            continue;\n          }\n\n          if (r.noext !== true) {\n            const e = G === R || G === s || G === u || G === _ || G === l;\n\n            if (e === true && peek() === f) {\n              L = D.isGlob = true;\n              O = D.isExtglob = true;\n              M = true;\n\n              if (y === true) {\n                while (eos() !== true && (G = advance())) {\n                  if (G === o) {\n                    k = D.backslashes = true;\n                    G = advance();\n                    continue;\n                  }\n\n                  if (G === g) {\n                    L = D.isGlob = true;\n                    M = true;\n                    break;\n                  }\n                }\n\n                continue;\n              }\n\n              break;\n            }\n          }\n\n          if (G === u) {\n            if (B === u) w = D.isGlobstar = true;\n            L = D.isGlob = true;\n            M = true;\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n\n          if (G === _) {\n            L = D.isGlob = true;\n            M = true;\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n\n          if (G === A) {\n            while (eos() !== true && (e = advance())) {\n              if (e === o) {\n                k = D.backslashes = true;\n                advance();\n                continue;\n              }\n\n              if (e === E) {\n                T = D.isBracket = true;\n                L = D.isGlob = true;\n                M = true;\n                break;\n              }\n            }\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n\n          if (r.nonegate !== true && G === l && H === v) {\n            I = D.negated = true;\n            v++;\n            continue;\n          }\n\n          if (r.noparen !== true && G === f) {\n            L = D.isGlob = true;\n\n            if (y === true) {\n              while (eos() !== true && (G = advance())) {\n                if (G === f) {\n                  k = D.backslashes = true;\n                  G = advance();\n                  continue;\n                }\n\n                if (G === g) {\n                  M = true;\n                  break;\n                }\n              }\n\n              continue;\n            }\n\n            break;\n          }\n\n          if (L === true) {\n            M = true;\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n        }\n\n        if (r.noext === true) {\n          O = false;\n          L = false;\n        }\n\n        let U = S;\n        let K = \"\";\n        let F = \"\";\n\n        if (v > 0) {\n          K = S.slice(0, v);\n          S = S.slice(v);\n          $ -= v;\n        }\n\n        if (U && L === true && $ > 0) {\n          U = S.slice(0, $);\n          F = S.slice($);\n        } else if (L === true) {\n          U = \"\";\n          F = S;\n        } else {\n          U = S;\n        }\n\n        if (U && U !== \"\" && U !== \"/\" && U !== S) {\n          if (isPathSeparator(U.charCodeAt(U.length - 1))) {\n            U = U.slice(0, -1);\n          }\n        }\n\n        if (r.unescape === true) {\n          if (F) F = n.removeBackslashes(F);\n\n          if (U && k === true) {\n            U = n.removeBackslashes(U);\n          }\n        }\n\n        const Q = {\n          prefix: K,\n          input: e,\n          start: v,\n          base: U,\n          glob: F,\n          isBrace: m,\n          isBracket: T,\n          isGlob: L,\n          isExtglob: O,\n          isGlobstar: w,\n          negated: I\n        };\n\n        if (r.tokens === true) {\n          Q.maxDepth = 0;\n\n          if (!isPathSeparator(G)) {\n            x.push(D);\n          }\n\n          Q.tokens = x;\n        }\n\n        if (r.parts === true || r.tokens === true) {\n          let t;\n\n          for (let n = 0; n < d.length; n++) {\n            const u = t ? t + 1 : v;\n            const s = d[n];\n            const o = e.slice(u, s);\n\n            if (r.tokens) {\n              if (n === 0 && v !== 0) {\n                x[n].isPrefix = true;\n                x[n].value = K;\n              } else {\n                x[n].value = o;\n              }\n\n              depth(x[n]);\n              Q.maxDepth += x[n].depth;\n            }\n\n            if (n !== 0 || o !== \"\") {\n              b.push(o);\n            }\n\n            t = s;\n          }\n\n          if (t && t + 1 < e.length) {\n            const n = e.slice(t + 1);\n            b.push(n);\n\n            if (r.tokens) {\n              x[x.length - 1].value = n;\n              depth(x[x.length - 1]);\n              Q.maxDepth += x[x.length - 1].depth;\n            }\n          }\n\n          Q.slashes = d;\n          Q.parts = b;\n        }\n\n        return Q;\n      };\n\n      e.exports = scan;\n    },\n    513: (e, t, r) => {\n      const n = r(17);\n      const u = process.platform === \"win32\";\n      const {\n        REGEX_BACKSLASH: s,\n        REGEX_REMOVE_BACKSLASH: o,\n        REGEX_SPECIAL_CHARS: i,\n        REGEX_SPECIAL_CHARS_GLOBAL: a\n      } = r(356);\n\n      t.isObject = e => e !== null && typeof e === \"object\" && !Array.isArray(e);\n\n      t.hasRegexChars = e => i.test(e);\n\n      t.isRegexChar = e => e.length === 1 && t.hasRegexChars(e);\n\n      t.escapeRegex = e => e.replace(a, \"\\\\$1\");\n\n      t.toPosixSlashes = e => e.replace(s, \"/\");\n\n      t.removeBackslashes = e => e.replace(o, e => e === \"\\\\\" ? \"\" : e);\n\n      t.supportsLookbehinds = () => {\n        const e = process.version.slice(1).split(\".\").map(Number);\n\n        if (e.length === 3 && e[0] >= 9 || e[0] === 8 && e[1] >= 10) {\n          return true;\n        }\n\n        return false;\n      };\n\n      t.isWindows = e => {\n        if (e && typeof e.windows === \"boolean\") {\n          return e.windows;\n        }\n\n        return u === true || n.sep === \"\\\\\";\n      };\n\n      t.escapeLast = (e, r, n) => {\n        const u = e.lastIndexOf(r, n);\n        if (u === -1) return e;\n        if (e[u - 1] === \"\\\\\") return t.escapeLast(e, r, u - 1);\n        return `${e.slice(0, u)}\\\\${e.slice(u)}`;\n      };\n\n      t.removePrefix = (e, t = {}) => {\n        let r = e;\n\n        if (r.startsWith(\"./\")) {\n          r = r.slice(2);\n          t.prefix = \"./\";\n        }\n\n        return r;\n      };\n\n      t.wrapOutput = (e, t = {}, r = {}) => {\n        const n = r.contains ? \"\" : \"^\";\n        const u = r.contains ? \"\" : \"$\";\n        let s = `${n}(?:${e})${u}`;\n\n        if (t.negated === true) {\n          s = `(?:^(?!${s}).*$)`;\n        }\n\n        return s;\n      };\n    },\n    492: (e, t, r) => {\n      /*!\n       * to-regex-range <https://github.com/micromatch/to-regex-range>\n       *\n       * Copyright (c) 2015-present, Jon Schlinkert.\n       * Released under the MIT License.\n       */\n      const n = r(357);\n\n      const toRegexRange = (e, t, r) => {\n        if (n(e) === false) {\n          throw new TypeError(\"toRegexRange: expected the first argument to be a number\");\n        }\n\n        if (t === void 0 || e === t) {\n          return String(e);\n        }\n\n        if (n(t) === false) {\n          throw new TypeError(\"toRegexRange: expected the second argument to be a number.\");\n        }\n\n        let u = {\n          relaxZeros: true,\n          ...r\n        };\n\n        if (typeof u.strictZeros === \"boolean\") {\n          u.relaxZeros = u.strictZeros === false;\n        }\n\n        let s = String(u.relaxZeros);\n        let o = String(u.shorthand);\n        let i = String(u.capture);\n        let a = String(u.wrap);\n        let l = e + \":\" + t + \"=\" + s + o + i + a;\n\n        if (toRegexRange.cache.hasOwnProperty(l)) {\n          return toRegexRange.cache[l].result;\n        }\n\n        let c = Math.min(e, t);\n        let p = Math.max(e, t);\n\n        if (Math.abs(c - p) === 1) {\n          let r = e + \"|\" + t;\n\n          if (u.capture) {\n            return `(${r})`;\n          }\n\n          if (u.wrap === false) {\n            return r;\n          }\n\n          return `(?:${r})`;\n        }\n\n        let f = hasPadding(e) || hasPadding(t);\n        let A = {\n          min: e,\n          max: t,\n          a: c,\n          b: p\n        };\n        let R = [];\n        let _ = [];\n\n        if (f) {\n          A.isPadded = f;\n          A.maxLen = String(A.max).length;\n        }\n\n        if (c < 0) {\n          let e = p < 0 ? Math.abs(p) : 1;\n          _ = splitToPatterns(e, Math.abs(c), A, u);\n          c = A.a = 0;\n        }\n\n        if (p >= 0) {\n          R = splitToPatterns(c, p, A, u);\n        }\n\n        A.negatives = _;\n        A.positives = R;\n        A.result = collatePatterns(_, R, u);\n\n        if (u.capture === true) {\n          A.result = `(${A.result})`;\n        } else if (u.wrap !== false && R.length + _.length > 1) {\n          A.result = `(?:${A.result})`;\n        }\n\n        toRegexRange.cache[l] = A;\n        return A.result;\n      };\n\n      function collatePatterns(e, t, r) {\n        let n = filterPatterns(e, t, \"-\", false, r) || [];\n        let u = filterPatterns(t, e, \"\", false, r) || [];\n        let s = filterPatterns(e, t, \"-?\", true, r) || [];\n        let o = n.concat(s).concat(u);\n        return o.join(\"|\");\n      }\n\n      function splitToRanges(e, t) {\n        let r = 1;\n        let n = 1;\n        let u = countNines(e, r);\n        let s = new Set([t]);\n\n        while (e <= u && u <= t) {\n          s.add(u);\n          r += 1;\n          u = countNines(e, r);\n        }\n\n        u = countZeros(t + 1, n) - 1;\n\n        while (e < u && u <= t) {\n          s.add(u);\n          n += 1;\n          u = countZeros(t + 1, n) - 1;\n        }\n\n        s = [...s];\n        s.sort(compare);\n        return s;\n      }\n\n      function rangeToPattern(e, t, r) {\n        if (e === t) {\n          return {\n            pattern: e,\n            count: [],\n            digits: 0\n          };\n        }\n\n        let n = zip(e, t);\n        let u = n.length;\n        let s = \"\";\n        let o = 0;\n\n        for (let e = 0; e < u; e++) {\n          let [t, u] = n[e];\n\n          if (t === u) {\n            s += t;\n          } else if (t !== \"0\" || u !== \"9\") {\n            s += toCharacterClass(t, u, r);\n          } else {\n            o++;\n          }\n        }\n\n        if (o) {\n          s += r.shorthand === true ? \"\\\\d\" : \"[0-9]\";\n        }\n\n        return {\n          pattern: s,\n          count: [o],\n          digits: u\n        };\n      }\n\n      function splitToPatterns(e, t, r, n) {\n        let u = splitToRanges(e, t);\n        let s = [];\n        let o = e;\n        let i;\n\n        for (let e = 0; e < u.length; e++) {\n          let t = u[e];\n          let a = rangeToPattern(String(o), String(t), n);\n          let l = \"\";\n\n          if (!r.isPadded && i && i.pattern === a.pattern) {\n            if (i.count.length > 1) {\n              i.count.pop();\n            }\n\n            i.count.push(a.count[0]);\n            i.string = i.pattern + toQuantifier(i.count);\n            o = t + 1;\n            continue;\n          }\n\n          if (r.isPadded) {\n            l = padZeros(t, r, n);\n          }\n\n          a.string = l + a.pattern + toQuantifier(a.count);\n          s.push(a);\n          o = t + 1;\n          i = a;\n        }\n\n        return s;\n      }\n\n      function filterPatterns(e, t, r, n, u) {\n        let s = [];\n\n        for (let u of e) {\n          let {\n            string: e\n          } = u;\n\n          if (!n && !contains(t, \"string\", e)) {\n            s.push(r + e);\n          }\n\n          if (n && contains(t, \"string\", e)) {\n            s.push(r + e);\n          }\n        }\n\n        return s;\n      }\n\n      function zip(e, t) {\n        let r = [];\n\n        for (let n = 0; n < e.length; n++) r.push([e[n], t[n]]);\n\n        return r;\n      }\n\n      function compare(e, t) {\n        return e > t ? 1 : t > e ? -1 : 0;\n      }\n\n      function contains(e, t, r) {\n        return e.some(e => e[t] === r);\n      }\n\n      function countNines(e, t) {\n        return Number(String(e).slice(0, -t) + \"9\".repeat(t));\n      }\n\n      function countZeros(e, t) {\n        return e - e % Math.pow(10, t);\n      }\n\n      function toQuantifier(e) {\n        let [t = 0, r = \"\"] = e;\n\n        if (r || t > 1) {\n          return `{${t + (r ? \",\" + r : \"\")}}`;\n        }\n\n        return \"\";\n      }\n\n      function toCharacterClass(e, t, r) {\n        return `[${e}${t - e === 1 ? \"\" : \"-\"}${t}]`;\n      }\n\n      function hasPadding(e) {\n        return /^-?(0+)\\d/.test(e);\n      }\n\n      function padZeros(e, t, r) {\n        if (!t.isPadded) {\n          return e;\n        }\n\n        let n = Math.abs(t.maxLen - String(e).length);\n        let u = r.relaxZeros !== false;\n\n        switch (n) {\n          case 0:\n            return \"\";\n\n          case 1:\n            return u ? \"0?\" : \"0\";\n\n          case 2:\n            return u ? \"0{0,2}\" : \"00\";\n\n          default:\n            {\n              return u ? `0{0,${n}}` : `0{${n}}`;\n            }\n        }\n      }\n\n      toRegexRange.cache = {};\n\n      toRegexRange.clearCache = () => toRegexRange.cache = {};\n\n      e.exports = toRegexRange;\n    },\n    17: e => {\n      e.exports = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\n    },\n    837: e => {\n      e.exports = __webpack_require__(/*! util */ \"./node_modules/next/dist/compiled/util/util.js\");\n    }\n  };\n  var t = {};\n\n  function __nccwpck_require__(r) {\n    var n = t[r];\n\n    if (n !== undefined) {\n      return n.exports;\n    }\n\n    var u = t[r] = {\n      exports: {}\n    };\n    var s = true;\n\n    try {\n      e[r](u, u.exports, __nccwpck_require__);\n      s = false;\n    } finally {\n      if (s) delete t[r];\n    }\n\n    return u.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var r = __nccwpck_require__(971);\n\n  module.exports = r;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2gvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQSxDQUFDLE1BQUk7RUFBQzs7RUFBYSxJQUFJQSxDQUFDLEdBQUM7SUFBQyxLQUFJLENBQUNBLENBQUQsRUFBR0MsQ0FBSCxFQUFLQyxDQUFMLEtBQVM7TUFBQyxNQUFNQyxDQUFDLEdBQUNELENBQUMsQ0FBQyxHQUFELENBQVQ7TUFBZSxNQUFNRSxDQUFDLEdBQUNGLENBQUMsQ0FBQyxHQUFELENBQVQ7TUFBZSxNQUFNRyxDQUFDLEdBQUNILENBQUMsQ0FBQyxFQUFELENBQVQ7TUFBYyxNQUFNSSxDQUFDLEdBQUNKLENBQUMsQ0FBQyxHQUFELENBQVQ7O01BQWUsTUFBTUssTUFBTSxHQUFDLENBQUNQLENBQUQsRUFBR0MsQ0FBQyxHQUFDLEVBQUwsS0FBVTtRQUFDLElBQUlDLENBQUMsR0FBQyxFQUFOOztRQUFTLElBQUdNLEtBQUssQ0FBQ0MsT0FBTixDQUFjVCxDQUFkLENBQUgsRUFBb0I7VUFBQyxLQUFJLElBQUlHLENBQVIsSUFBYUgsQ0FBYixFQUFlO1lBQUMsSUFBSUEsQ0FBQyxHQUFDTyxNQUFNLENBQUNHLE1BQVAsQ0FBY1AsQ0FBZCxFQUFnQkYsQ0FBaEIsQ0FBTjs7WUFBeUIsSUFBR08sS0FBSyxDQUFDQyxPQUFOLENBQWNULENBQWQsQ0FBSCxFQUFvQjtjQUFDRSxDQUFDLENBQUNTLElBQUYsQ0FBTyxHQUFHWCxDQUFWO1lBQWEsQ0FBbEMsTUFBc0M7Y0FBQ0UsQ0FBQyxDQUFDUyxJQUFGLENBQU9YLENBQVA7WUFBVTtVQUFDO1FBQUMsQ0FBakgsTUFBcUg7VUFBQ0UsQ0FBQyxHQUFDLEdBQUdVLE1BQUgsQ0FBVUwsTUFBTSxDQUFDRyxNQUFQLENBQWNWLENBQWQsRUFBZ0JDLENBQWhCLENBQVYsQ0FBRjtRQUFnQzs7UUFBQSxJQUFHQSxDQUFDLElBQUVBLENBQUMsQ0FBQ1ksTUFBRixLQUFXLElBQWQsSUFBb0Ja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OztJQUFXLElBQUc7TUFBQ0wsQ0FBQyxDQUFDRSxDQUFELENBQUQsQ0FBS0UsQ0FBTCxFQUFPQSxDQUFDLENBQUNtQixPQUFULEVBQWlCa1gsbUJBQWpCO01BQXNDcFksQ0FBQyxHQUFDLEtBQUY7SUFBUSxDQUFsRCxTQUF5RDtNQUFDLElBQUdBLENBQUgsRUFBSyxPQUFPSixDQUFDLENBQUNDLENBQUQsQ0FBUjtJQUFZOztJQUFBLE9BQU9FLENBQUMsQ0FBQ21CLE9BQVQ7RUFBaUI7O0VBQUEsSUFBRyxPQUFPa1gsbUJBQVAsS0FBNkIsV0FBaEMsRUFBNENBLG1CQUFtQixDQUFDQyxFQUFwQixHQUF1QkMsU0FBUyxHQUFDLEdBQWpDOztFQUFxQyxJQUFJelksQ0FBQyxHQUFDdVksbUJBQW1CLENBQUMsR0FBRCxDQUF6Qjs7RUFBK0JHLE1BQU0sQ0FBQ3JYLE9BQVAsR0FBZXJCLENBQWY7QUFBaUIsQ0FyQnh2SCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2gvaW5kZXguanM/M2NlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17MzMzOihlLHQscik9Pntjb25zdCBuPXIoMTM3KTtjb25zdCB1PXIoMTc5KTtjb25zdCBzPXIoMTMpO2NvbnN0IG89cig3MTkpO2NvbnN0IGJyYWNlcz0oZSx0PXt9KT0+e2xldCByPVtdO2lmKEFycmF5LmlzQXJyYXkoZSkpe2ZvcihsZXQgbiBvZiBlKXtsZXQgZT1icmFjZXMuY3JlYXRlKG4sdCk7aWYoQXJyYXkuaXNBcnJheShlKSl7ci5wdXNoKC4uLmUpfWVsc2V7ci5wdXNoKGUpfX19ZWxzZXtyPVtdLmNvbmNhdChicmFjZXMuY3JlYXRlKGUsdCkpfWlmKHQmJnQuZXhwYW5kPT09dHJ1ZSYmdC5ub2R1cGVzPT09dHJ1ZSl7cj1bLi4ubmV3IFNldChyKV19cmV0dXJuIHJ9O2JyYWNlcy5wYXJzZT0oZSx0PXt9KT0+byhlLHQpO2JyYWNlcy5zdHJpbmdpZnk9KGUsdD17fSk9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBuKGJyYWNlcy5wYXJzZShlLHQpLHQpfXJldHVybiBuKGUsdCl9O2JyYWNlcy5jb21waWxlPShlLHQ9e30pPT57aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtlPWJyYWNlcy5wYXJzZShlLHQpfXJldHVybiB1KGUsdCl9O2JyYWNlcy5leHBhbmQ9KGUsdD17fSk9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2U9YnJhY2VzLnBhcnNlKGUsdCl9bGV0IHI9cyhlLHQpO2lmKHQubm9lbXB0eT09PXRydWUpe3I9ci5maWx0ZXIoQm9vbGVhbil9aWYodC5ub2R1cGVzPT09dHJ1ZSl7cj1bLi4ubmV3IFNldChyKV19cmV0dXJuIHJ9O2JyYWNlcy5jcmVhdGU9KGUsdD17fSk9PntpZihlPT09XCJcInx8ZS5sZW5ndGg8Myl7cmV0dXJuW2VdfXJldHVybiB0LmV4cGFuZCE9PXRydWU/YnJhY2VzLmNvbXBpbGUoZSx0KTpicmFjZXMuZXhwYW5kKGUsdCl9O2UuZXhwb3J0cz1icmFjZXN9LDE3OTooZSx0LHIpPT57Y29uc3Qgbj1yKDc4Myk7Y29uc3QgdT1yKDYxNyk7Y29uc3QgY29tcGlsZT0oZSx0PXt9KT0+e2xldCB3YWxrPShlLHI9e30pPT57bGV0IHM9dS5pc0ludmFsaWRCcmFjZShyKTtsZXQgbz1lLmludmFsaWQ9PT10cnVlJiZ0LmVzY2FwZUludmFsaWQ9PT10cnVlO2xldCBpPXM9PT10cnVlfHxvPT09dHJ1ZTtsZXQgYT10LmVzY2FwZUludmFsaWQ9PT10cnVlP1wiXFxcXFwiOlwiXCI7bGV0IGw9XCJcIjtpZihlLmlzT3Blbj09PXRydWUpe3JldHVybiBhK2UudmFsdWV9aWYoZS5pc0Nsb3NlPT09dHJ1ZSl7cmV0dXJuIGErZS52YWx1ZX1pZihlLnR5cGU9PT1cIm9wZW5cIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKFwifWlmKGUudHlwZT09PVwiY2xvc2VcIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKVwifWlmKGUudHlwZT09PVwiY29tbWFcIil7cmV0dXJuIGUucHJldi50eXBlPT09XCJjb21tYVwiP1wiXCI6aT9lLnZhbHVlOlwifFwifWlmKGUudmFsdWUpe3JldHVybiBlLnZhbHVlfWlmKGUubm9kZXMmJmUucmFuZ2VzPjApe2xldCByPXUucmVkdWNlKGUubm9kZXMpO2xldCBzPW4oLi4ucix7Li4udCx3cmFwOmZhbHNlLHRvUmVnZXg6dHJ1ZX0pO2lmKHMubGVuZ3RoIT09MCl7cmV0dXJuIHIubGVuZ3RoPjEmJnMubGVuZ3RoPjE/YCgke3N9KWA6c319aWYoZS5ub2Rlcyl7Zm9yKGxldCB0IG9mIGUubm9kZXMpe2wrPXdhbGsodCxlKX19cmV0dXJuIGx9O3JldHVybiB3YWxrKGUpfTtlLmV4cG9ydHM9Y29tcGlsZX0sNDU3OmU9PntlLmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxDSEFSXzA6XCIwXCIsQ0hBUl85OlwiOVwiLENIQVJfVVBQRVJDQVNFX0E6XCJBXCIsQ0hBUl9MT1dFUkNBU0VfQTpcImFcIixDSEFSX1VQUEVSQ0FTRV9aOlwiWlwiLENIQVJfTE9XRVJDQVNFX1o6XCJ6XCIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOlwiKFwiLENIQVJfUklHSFRfUEFSRU5USEVTRVM6XCIpXCIsQ0hBUl9BU1RFUklTSzpcIipcIixDSEFSX0FNUEVSU0FORDpcIiZcIixDSEFSX0FUOlwiQFwiLENIQVJfQkFDS1NMQVNIOlwiXFxcXFwiLENIQVJfQkFDS1RJQ0s6XCJgXCIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46XCJcXHJcIixDSEFSX0NJUkNVTUZMRVhfQUNDRU5UOlwiXlwiLENIQVJfQ09MT046XCI6XCIsQ0hBUl9DT01NQTpcIixcIixDSEFSX0RPTExBUjpcIiRcIixDSEFSX0RPVDpcIi5cIixDSEFSX0RPVUJMRV9RVU9URTonXCInLENIQVJfRVFVQUw6XCI9XCIsQ0hBUl9FWENMQU1BVElPTl9NQVJLOlwiIVwiLENIQVJfRk9STV9GRUVEOlwiXFxmXCIsQ0hBUl9GT1JXQVJEX1NMQVNIOlwiL1wiLENIQVJfSEFTSDpcIiNcIixDSEFSX0hZUEhFTl9NSU5VUzpcIi1cIixDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDpcIjxcIixDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6XCJ7XCIsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOlwiW1wiLENIQVJfTElORV9GRUVEOlwiXFxuXCIsQ0hBUl9OT19CUkVBS19TUEFDRTpcIsKgXCIsQ0hBUl9QRVJDRU5UOlwiJVwiLENIQVJfUExVUzpcIitcIixDSEFSX1FVRVNUSU9OX01BUks6XCI/XCIsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOlwiPlwiLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6XCJ9XCIsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpcIl1cIixDSEFSX1NFTUlDT0xPTjpcIjtcIixDSEFSX1NJTkdMRV9RVU9URTpcIidcIixDSEFSX1NQQUNFOlwiIFwiLENIQVJfVEFCOlwiXFx0XCIsQ0hBUl9VTkRFUlNDT1JFOlwiX1wiLENIQVJfVkVSVElDQUxfTElORTpcInxcIixDSEFSX1pFUk9fV0lEVEhfTk9CUkVBS19TUEFDRTpcIlxcdWZlZmZcIn19LDEzOihlLHQscik9Pntjb25zdCBuPXIoNzgzKTtjb25zdCB1PXIoMTM3KTtjb25zdCBzPXIoNjE3KTtjb25zdCBhcHBlbmQ9KGU9XCJcIix0PVwiXCIscj1mYWxzZSk9PntsZXQgbj1bXTtlPVtdLmNvbmNhdChlKTt0PVtdLmNvbmNhdCh0KTtpZighdC5sZW5ndGgpcmV0dXJuIGU7aWYoIWUubGVuZ3RoKXtyZXR1cm4gcj9zLmZsYXR0ZW4odCkubWFwKChlPT5geyR7ZX19YCkpOnR9Zm9yKGxldCB1IG9mIGUpe2lmKEFycmF5LmlzQXJyYXkodSkpe2ZvcihsZXQgZSBvZiB1KXtuLnB1c2goYXBwZW5kKGUsdCxyKSl9fWVsc2V7Zm9yKGxldCBlIG9mIHQpe2lmKHI9PT10cnVlJiZ0eXBlb2YgZT09PVwic3RyaW5nXCIpZT1geyR7ZX19YDtuLnB1c2goQXJyYXkuaXNBcnJheShlKT9hcHBlbmQodSxlLHIpOnUrZSl9fX1yZXR1cm4gcy5mbGF0dGVuKG4pfTtjb25zdCBleHBhbmQ9KGUsdD17fSk9PntsZXQgcj10LnJhbmdlTGltaXQ9PT12b2lkIDA/MWUzOnQucmFuZ2VMaW1pdDtsZXQgd2Fsaz0oZSxvPXt9KT0+e2UucXVldWU9W107bGV0IGk9bztsZXQgYT1vLnF1ZXVlO3doaWxlKGkudHlwZSE9PVwiYnJhY2VcIiYmaS50eXBlIT09XCJyb290XCImJmkucGFyZW50KXtpPWkucGFyZW50O2E9aS5xdWV1ZX1pZihlLmludmFsaWR8fGUuZG9sbGFyKXthLnB1c2goYXBwZW5kKGEucG9wKCksdShlLHQpKSk7cmV0dXJufWlmKGUudHlwZT09PVwiYnJhY2VcIiYmZS5pbnZhbGlkIT09dHJ1ZSYmZS5ub2Rlcy5sZW5ndGg9PT0yKXthLnB1c2goYXBwZW5kKGEucG9wKCksW1wie31cIl0pKTtyZXR1cm59aWYoZS5ub2RlcyYmZS5yYW5nZXM+MCl7bGV0IG89cy5yZWR1Y2UoZS5ub2Rlcyk7aWYocy5leGNlZWRzTGltaXQoLi4ubyx0LnN0ZXAscikpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiZXhwYW5kZWQgYXJyYXkgbGVuZ3RoIGV4Y2VlZHMgcmFuZ2UgbGltaXQuIFVzZSBvcHRpb25zLnJhbmdlTGltaXQgdG8gaW5jcmVhc2Ugb3IgZGlzYWJsZSB0aGUgbGltaXQuXCIpfWxldCBpPW4oLi4ubyx0KTtpZihpLmxlbmd0aD09PTApe2k9dShlLHQpfWEucHVzaChhcHBlbmQoYS5wb3AoKSxpKSk7ZS5ub2Rlcz1bXTtyZXR1cm59bGV0IGw9cy5lbmNsb3NlQnJhY2UoZSk7bGV0IGM9ZS5xdWV1ZTtsZXQgcD1lO3doaWxlKHAudHlwZSE9PVwiYnJhY2VcIiYmcC50eXBlIT09XCJyb290XCImJnAucGFyZW50KXtwPXAucGFyZW50O2M9cC5xdWV1ZX1mb3IobGV0IHQ9MDt0PGUubm9kZXMubGVuZ3RoO3QrKyl7bGV0IHI9ZS5ub2Rlc1t0XTtpZihyLnR5cGU9PT1cImNvbW1hXCImJmUudHlwZT09PVwiYnJhY2VcIil7aWYodD09PTEpYy5wdXNoKFwiXCIpO2MucHVzaChcIlwiKTtjb250aW51ZX1pZihyLnR5cGU9PT1cImNsb3NlXCIpe2EucHVzaChhcHBlbmQoYS5wb3AoKSxjLGwpKTtjb250aW51ZX1pZihyLnZhbHVlJiZyLnR5cGUhPT1cIm9wZW5cIil7Yy5wdXNoKGFwcGVuZChjLnBvcCgpLHIudmFsdWUpKTtjb250aW51ZX1pZihyLm5vZGVzKXt3YWxrKHIsZSl9fXJldHVybiBjfTtyZXR1cm4gcy5mbGF0dGVuKHdhbGsoZSkpfTtlLmV4cG9ydHM9ZXhwYW5kfSw3MTk6KGUsdCxyKT0+e2NvbnN0IG49cigxMzcpO2NvbnN0e01BWF9MRU5HVEg6dSxDSEFSX0JBQ0tTTEFTSDpzLENIQVJfQkFDS1RJQ0s6byxDSEFSX0NPTU1BOmksQ0hBUl9ET1Q6YSxDSEFSX0xFRlRfUEFSRU5USEVTRVM6bCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmMsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOnAsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6UixDSEFSX0RPVUJMRV9RVU9URTpfLENIQVJfU0lOR0xFX1FVT1RFOmgsQ0hBUl9OT19CUkVBS19TUEFDRTpnLENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOkV9PXIoNDU3KTtjb25zdCBwYXJzZT0oZSx0PXt9KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpfWxldCByPXR8fHt9O2xldCBDPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4odSxyLm1heExlbmd0aCk6dTtpZihlLmxlbmd0aD5DKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aCAoJHtlLmxlbmd0aH0pLCBleGNlZWRzIG1heCBjaGFyYWN0ZXJzICgke0N9KWApfWxldCB5PXt0eXBlOlwicm9vdFwiLGlucHV0OmUsbm9kZXM6W119O2xldCBkPVt5XTtsZXQgeD15O2xldCBiPXk7bGV0IFM9MDtsZXQgSD1lLmxlbmd0aDtsZXQgdj0wO2xldCAkPTA7bGV0IG07bGV0IFQ9e307Y29uc3QgYWR2YW5jZT0oKT0+ZVt2KytdO2NvbnN0IHB1c2g9ZT0+e2lmKGUudHlwZT09PVwidGV4dFwiJiZiLnR5cGU9PT1cImRvdFwiKXtiLnR5cGU9XCJ0ZXh0XCJ9aWYoYiYmYi50eXBlPT09XCJ0ZXh0XCImJmUudHlwZT09PVwidGV4dFwiKXtiLnZhbHVlKz1lLnZhbHVlO3JldHVybn14Lm5vZGVzLnB1c2goZSk7ZS5wYXJlbnQ9eDtlLnByZXY9YjtiPWU7cmV0dXJuIGV9O3B1c2goe3R5cGU6XCJib3NcIn0pO3doaWxlKHY8SCl7eD1kW2QubGVuZ3RoLTFdO209YWR2YW5jZSgpO2lmKG09PT1FfHxtPT09Zyl7Y29udGludWV9aWYobT09PXMpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6KHQua2VlcEVzY2FwaW5nP206XCJcIikrYWR2YW5jZSgpfSk7Y29udGludWV9aWYobT09PVIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6XCJcXFxcXCIrbX0pO2NvbnRpbnVlfWlmKG09PT1BKXtTKys7bGV0IGU9dHJ1ZTtsZXQgdDt3aGlsZSh2PEgmJih0PWFkdmFuY2UoKSkpe20rPXQ7aWYodD09PUEpe1MrKztjb250aW51ZX1pZih0PT09cyl7bSs9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKHQ9PT1SKXtTLS07aWYoUz09PTApe2JyZWFrfX19cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWwpe3g9cHVzaCh7dHlwZTpcInBhcmVuXCIsbm9kZXM6W119KTtkLnB1c2goeCk7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWMpe2lmKHgudHlwZSE9PVwicGFyZW5cIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9eD1kLnBvcCgpO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09X3x8bT09PWh8fG09PT1vKXtsZXQgZT1tO2xldCByO2lmKHQua2VlcFF1b3RlcyE9PXRydWUpe209XCJcIn13aGlsZSh2PEgmJihyPWFkdmFuY2UoKSkpe2lmKHI9PT1zKXttKz1yK2FkdmFuY2UoKTtjb250aW51ZX1pZihyPT09ZSl7aWYodC5rZWVwUXVvdGVzPT09dHJ1ZSltKz1yO2JyZWFrfW0rPXJ9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PXApeyQrKztsZXQgZT1iLnZhbHVlJiZiLnZhbHVlLnNsaWNlKC0xKT09PVwiJFwifHx4LmRvbGxhcj09PXRydWU7bGV0IHQ9e3R5cGU6XCJicmFjZVwiLG9wZW46dHJ1ZSxjbG9zZTpmYWxzZSxkb2xsYXI6ZSxkZXB0aDokLGNvbW1hczowLHJhbmdlczowLG5vZGVzOltdfTt4PXB1c2godCk7ZC5wdXNoKHgpO3B1c2goe3R5cGU6XCJvcGVuXCIsdmFsdWU6bX0pO2NvbnRpbnVlfWlmKG09PT1mKXtpZih4LnR5cGUhPT1cImJyYWNlXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO2NvbnRpbnVlfWxldCBlPVwiY2xvc2VcIjt4PWQucG9wKCk7eC5jbG9zZT10cnVlO3B1c2goe3R5cGU6ZSx2YWx1ZTptfSk7JC0tO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09aSYmJD4wKXtpZih4LnJhbmdlcz4wKXt4LnJhbmdlcz0wO2xldCBlPXgubm9kZXMuc2hpZnQoKTt4Lm5vZGVzPVtlLHt0eXBlOlwidGV4dFwiLHZhbHVlOm4oeCl9XX1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTptfSk7eC5jb21tYXMrKztjb250aW51ZX1pZihtPT09YSYmJD4wJiZ4LmNvbW1hcz09PTApe2xldCBlPXgubm9kZXM7aWYoJD09PTB8fGUubGVuZ3RoPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYoYi50eXBlPT09XCJkb3RcIil7eC5yYW5nZT1bXTtiLnZhbHVlKz1tO2IudHlwZT1cInJhbmdlXCI7aWYoeC5ub2Rlcy5sZW5ndGghPT0zJiZ4Lm5vZGVzLmxlbmd0aCE9PTUpe3guaW52YWxpZD10cnVlO3gucmFuZ2VzPTA7Yi50eXBlPVwidGV4dFwiO2NvbnRpbnVlfXgucmFuZ2VzKys7eC5hcmdzPVtdO2NvbnRpbnVlfWlmKGIudHlwZT09PVwicmFuZ2VcIil7ZS5wb3AoKTtsZXQgdD1lW2UubGVuZ3RoLTFdO3QudmFsdWUrPWIudmFsdWUrbTtiPXQ7eC5yYW5nZXMtLTtjb250aW51ZX1wdXNoKHt0eXBlOlwiZG90XCIsdmFsdWU6bX0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pfWRve3g9ZC5wb3AoKTtpZih4LnR5cGUhPT1cInJvb3RcIil7eC5ub2Rlcy5mb3JFYWNoKChlPT57aWYoIWUubm9kZXMpe2lmKGUudHlwZT09PVwib3BlblwiKWUuaXNPcGVuPXRydWU7aWYoZS50eXBlPT09XCJjbG9zZVwiKWUuaXNDbG9zZT10cnVlO2lmKCFlLm5vZGVzKWUudHlwZT1cInRleHRcIjtlLmludmFsaWQ9dHJ1ZX19KSk7bGV0IGU9ZFtkLmxlbmd0aC0xXTtsZXQgdD1lLm5vZGVzLmluZGV4T2YoeCk7ZS5ub2Rlcy5zcGxpY2UodCwxLC4uLngubm9kZXMpfX13aGlsZShkLmxlbmd0aD4wKTtwdXNoKHt0eXBlOlwiZW9zXCJ9KTtyZXR1cm4geX07ZS5leHBvcnRzPXBhcnNlfSwxMzc6KGUsdCxyKT0+e2NvbnN0IG49cig2MTcpO2UuZXhwb3J0cz0oZSx0PXt9KT0+e2xldCBzdHJpbmdpZnk9KGUscj17fSk9PntsZXQgdT10LmVzY2FwZUludmFsaWQmJm4uaXNJbnZhbGlkQnJhY2Uocik7bGV0IHM9ZS5pbnZhbGlkPT09dHJ1ZSYmdC5lc2NhcGVJbnZhbGlkPT09dHJ1ZTtsZXQgbz1cIlwiO2lmKGUudmFsdWUpe2lmKCh1fHxzKSYmbi5pc09wZW5PckNsb3NlKGUpKXtyZXR1cm5cIlxcXFxcIitlLnZhbHVlfXJldHVybiBlLnZhbHVlfWlmKGUudmFsdWUpe3JldHVybiBlLnZhbHVlfWlmKGUubm9kZXMpe2ZvcihsZXQgdCBvZiBlLm5vZGVzKXtvKz1zdHJpbmdpZnkodCl9fXJldHVybiBvfTtyZXR1cm4gc3RyaW5naWZ5KGUpfX0sNjE3OihlLHQpPT57dC5pc0ludGVnZXI9ZT0+e2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7cmV0dXJuIE51bWJlci5pc0ludGVnZXIoZSl9aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlLnRyaW0oKSE9PVwiXCIpe3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcihlKSl9cmV0dXJuIGZhbHNlfTt0LmZpbmQ9KGUsdCk9PmUubm9kZXMuZmluZCgoZT0+ZS50eXBlPT09dCkpO3QuZXhjZWVkc0xpbWl0PShlLHIsbj0xLHUpPT57aWYodT09PWZhbHNlKXJldHVybiBmYWxzZTtpZighdC5pc0ludGVnZXIoZSl8fCF0LmlzSW50ZWdlcihyKSlyZXR1cm4gZmFsc2U7cmV0dXJuKE51bWJlcihyKS1OdW1iZXIoZSkpL051bWJlcihuKT49dX07dC5lc2NhcGVOb2RlPShlLHQ9MCxyKT0+e2xldCBuPWUubm9kZXNbdF07aWYoIW4pcmV0dXJuO2lmKHImJm4udHlwZT09PXJ8fG4udHlwZT09PVwib3BlblwifHxuLnR5cGU9PT1cImNsb3NlXCIpe2lmKG4uZXNjYXBlZCE9PXRydWUpe24udmFsdWU9XCJcXFxcXCIrbi52YWx1ZTtuLmVzY2FwZWQ9dHJ1ZX19fTt0LmVuY2xvc2VCcmFjZT1lPT57aWYoZS50eXBlIT09XCJicmFjZVwiKXJldHVybiBmYWxzZTtpZihlLmNvbW1hcz4+MCtlLnJhbmdlcz4+MD09PTApe2UuaW52YWxpZD10cnVlO3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dC5pc0ludmFsaWRCcmFjZT1lPT57aWYoZS50eXBlIT09XCJicmFjZVwiKXJldHVybiBmYWxzZTtpZihlLmludmFsaWQ9PT10cnVlfHxlLmRvbGxhcilyZXR1cm4gdHJ1ZTtpZihlLmNvbW1hcz4+MCtlLnJhbmdlcz4+MD09PTApe2UuaW52YWxpZD10cnVlO3JldHVybiB0cnVlfWlmKGUub3BlbiE9PXRydWV8fGUuY2xvc2UhPT10cnVlKXtlLmludmFsaWQ9dHJ1ZTtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9O3QuaXNPcGVuT3JDbG9zZT1lPT57aWYoZS50eXBlPT09XCJvcGVuXCJ8fGUudHlwZT09PVwiY2xvc2VcIil7cmV0dXJuIHRydWV9cmV0dXJuIGUub3Blbj09PXRydWV8fGUuY2xvc2U9PT10cnVlfTt0LnJlZHVjZT1lPT5lLnJlZHVjZSgoKGUsdCk9PntpZih0LnR5cGU9PT1cInRleHRcIillLnB1c2godC52YWx1ZSk7aWYodC50eXBlPT09XCJyYW5nZVwiKXQudHlwZT1cInRleHRcIjtyZXR1cm4gZX0pLFtdKTt0LmZsYXR0ZW49KC4uLmUpPT57Y29uc3QgdD1bXTtjb25zdCBmbGF0PWU9Pntmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7bGV0IG49ZVtyXTtBcnJheS5pc0FycmF5KG4pP2ZsYXQobix0KTpuIT09dm9pZCAwJiZ0LnB1c2gobil9cmV0dXJuIHR9O2ZsYXQoZSk7cmV0dXJuIHR9fSw3ODM6KGUsdCxyKT0+e1xuLyohXG4gKiBmaWxsLXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9maWxsLXJhbmdlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY29uc3Qgbj1yKDgzNyk7Y29uc3QgdT1yKDQ5Mik7Y29uc3QgaXNPYmplY3Q9ZT0+ZSE9PW51bGwmJnR5cGVvZiBlPT09XCJvYmplY3RcIiYmIUFycmF5LmlzQXJyYXkoZSk7Y29uc3QgdHJhbnNmb3JtPWU9PnQ9PmU9PT10cnVlP051bWJlcih0KTpTdHJpbmcodCk7Y29uc3QgaXNWYWxpZFZhbHVlPWU9PnR5cGVvZiBlPT09XCJudW1iZXJcInx8dHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlIT09XCJcIjtjb25zdCBpc051bWJlcj1lPT5OdW1iZXIuaXNJbnRlZ2VyKCtlKTtjb25zdCB6ZXJvcz1lPT57bGV0IHQ9YCR7ZX1gO2xldCByPS0xO2lmKHRbMF09PT1cIi1cIil0PXQuc2xpY2UoMSk7aWYodD09PVwiMFwiKXJldHVybiBmYWxzZTt3aGlsZSh0Wysrcl09PT1cIjBcIik7cmV0dXJuIHI+MH07Y29uc3Qgc3RyaW5naWZ5PShlLHQscik9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCJ8fHR5cGVvZiB0PT09XCJzdHJpbmdcIil7cmV0dXJuIHRydWV9cmV0dXJuIHIuc3RyaW5naWZ5PT09dHJ1ZX07Y29uc3QgcGFkPShlLHQscik9PntpZih0PjApe2xldCByPWVbMF09PT1cIi1cIj9cIi1cIjpcIlwiO2lmKHIpZT1lLnNsaWNlKDEpO2U9citlLnBhZFN0YXJ0KHI/dC0xOnQsXCIwXCIpfWlmKHI9PT1mYWxzZSl7cmV0dXJuIFN0cmluZyhlKX1yZXR1cm4gZX07Y29uc3QgdG9NYXhMZW49KGUsdCk9PntsZXQgcj1lWzBdPT09XCItXCI/XCItXCI6XCJcIjtpZihyKXtlPWUuc2xpY2UoMSk7dC0tfXdoaWxlKGUubGVuZ3RoPHQpZT1cIjBcIitlO3JldHVybiByP1wiLVwiK2U6ZX07Y29uc3QgdG9TZXF1ZW5jZT0oZSx0KT0+e2UubmVnYXRpdmVzLnNvcnQoKChlLHQpPT5lPHQ/LTE6ZT50PzE6MCkpO2UucG9zaXRpdmVzLnNvcnQoKChlLHQpPT5lPHQ/LTE6ZT50PzE6MCkpO2xldCByPXQuY2FwdHVyZT9cIlwiOlwiPzpcIjtsZXQgbj1cIlwiO2xldCB1PVwiXCI7bGV0IHM7aWYoZS5wb3NpdGl2ZXMubGVuZ3RoKXtuPWUucG9zaXRpdmVzLmpvaW4oXCJ8XCIpfWlmKGUubmVnYXRpdmVzLmxlbmd0aCl7dT1gLSgke3J9JHtlLm5lZ2F0aXZlcy5qb2luKFwifFwiKX0pYH1pZihuJiZ1KXtzPWAke259fCR7dX1gfWVsc2V7cz1ufHx1fWlmKHQud3JhcCl7cmV0dXJuYCgke3J9JHtzfSlgfXJldHVybiBzfTtjb25zdCB0b1JhbmdlPShlLHQscixuKT0+e2lmKHIpe3JldHVybiB1KGUsdCx7d3JhcDpmYWxzZSwuLi5ufSl9bGV0IHM9U3RyaW5nLmZyb21DaGFyQ29kZShlKTtpZihlPT09dClyZXR1cm4gcztsZXQgbz1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpO3JldHVybmBbJHtzfS0ke299XWB9O2NvbnN0IHRvUmVnZXg9KGUsdCxyKT0+e2lmKEFycmF5LmlzQXJyYXkoZSkpe2xldCB0PXIud3JhcD09PXRydWU7bGV0IG49ci5jYXB0dXJlP1wiXCI6XCI/OlwiO3JldHVybiB0P2AoJHtufSR7ZS5qb2luKFwifFwiKX0pYDplLmpvaW4oXCJ8XCIpfXJldHVybiB1KGUsdCxyKX07Y29uc3QgcmFuZ2VFcnJvcj0oLi4uZSk9Pm5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByYW5nZSBhcmd1bWVudHM6IFwiK24uaW5zcGVjdCguLi5lKSk7Y29uc3QgaW52YWxpZFJhbmdlPShlLHQscik9PntpZihyLnN0cmljdFJhbmdlcz09PXRydWUpdGhyb3cgcmFuZ2VFcnJvcihbZSx0XSk7cmV0dXJuW119O2NvbnN0IGludmFsaWRTdGVwPShlLHQpPT57aWYodC5zdHJpY3RSYW5nZXM9PT10cnVlKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBzdGVwIFwiJHtlfVwiIHRvIGJlIGEgbnVtYmVyYCl9cmV0dXJuW119O2NvbnN0IGZpbGxOdW1iZXJzPShlLHQscj0xLG49e30pPT57bGV0IHU9TnVtYmVyKGUpO2xldCBzPU51bWJlcih0KTtpZighTnVtYmVyLmlzSW50ZWdlcih1KXx8IU51bWJlci5pc0ludGVnZXIocykpe2lmKG4uc3RyaWN0UmFuZ2VzPT09dHJ1ZSl0aHJvdyByYW5nZUVycm9yKFtlLHRdKTtyZXR1cm5bXX1pZih1PT09MCl1PTA7aWYocz09PTApcz0wO2xldCBvPXU+cztsZXQgaT1TdHJpbmcoZSk7bGV0IGE9U3RyaW5nKHQpO2xldCBsPVN0cmluZyhyKTtyPU1hdGgubWF4KE1hdGguYWJzKHIpLDEpO2xldCBjPXplcm9zKGkpfHx6ZXJvcyhhKXx8emVyb3MobCk7bGV0IHA9Yz9NYXRoLm1heChpLmxlbmd0aCxhLmxlbmd0aCxsLmxlbmd0aCk6MDtsZXQgZj1jPT09ZmFsc2UmJnN0cmluZ2lmeShlLHQsbik9PT1mYWxzZTtsZXQgQT1uLnRyYW5zZm9ybXx8dHJhbnNmb3JtKGYpO2lmKG4udG9SZWdleCYmcj09PTEpe3JldHVybiB0b1JhbmdlKHRvTWF4TGVuKGUscCksdG9NYXhMZW4odCxwKSx0cnVlLG4pfWxldCBSPXtuZWdhdGl2ZXM6W10scG9zaXRpdmVzOltdfTtsZXQgcHVzaD1lPT5SW2U8MD9cIm5lZ2F0aXZlc1wiOlwicG9zaXRpdmVzXCJdLnB1c2goTWF0aC5hYnMoZSkpO2xldCBfPVtdO2xldCBoPTA7d2hpbGUobz91Pj1zOnU8PXMpe2lmKG4udG9SZWdleD09PXRydWUmJnI+MSl7cHVzaCh1KX1lbHNle18ucHVzaChwYWQoQSh1LGgpLHAsZikpfXU9bz91LXI6dStyO2grK31pZihuLnRvUmVnZXg9PT10cnVlKXtyZXR1cm4gcj4xP3RvU2VxdWVuY2UoUixuKTp0b1JlZ2V4KF8sbnVsbCx7d3JhcDpmYWxzZSwuLi5ufSl9cmV0dXJuIF99O2NvbnN0IGZpbGxMZXR0ZXJzPShlLHQscj0xLG49e30pPT57aWYoIWlzTnVtYmVyKGUpJiZlLmxlbmd0aD4xfHwhaXNOdW1iZXIodCkmJnQubGVuZ3RoPjEpe3JldHVybiBpbnZhbGlkUmFuZ2UoZSx0LG4pfWxldCB1PW4udHJhbnNmb3JtfHwoZT0+U3RyaW5nLmZyb21DaGFyQ29kZShlKSk7bGV0IHM9YCR7ZX1gLmNoYXJDb2RlQXQoMCk7bGV0IG89YCR7dH1gLmNoYXJDb2RlQXQoMCk7bGV0IGk9cz5vO2xldCBhPU1hdGgubWluKHMsbyk7bGV0IGw9TWF0aC5tYXgocyxvKTtpZihuLnRvUmVnZXgmJnI9PT0xKXtyZXR1cm4gdG9SYW5nZShhLGwsZmFsc2Usbil9bGV0IGM9W107bGV0IHA9MDt3aGlsZShpP3M+PW86czw9byl7Yy5wdXNoKHUocyxwKSk7cz1pP3MtcjpzK3I7cCsrfWlmKG4udG9SZWdleD09PXRydWUpe3JldHVybiB0b1JlZ2V4KGMsbnVsbCx7d3JhcDpmYWxzZSxvcHRpb25zOm59KX1yZXR1cm4gY307Y29uc3QgZmlsbD0oZSx0LHIsbj17fSk9PntpZih0PT1udWxsJiZpc1ZhbGlkVmFsdWUoZSkpe3JldHVybltlXX1pZighaXNWYWxpZFZhbHVlKGUpfHwhaXNWYWxpZFZhbHVlKHQpKXtyZXR1cm4gaW52YWxpZFJhbmdlKGUsdCxuKX1pZih0eXBlb2Ygcj09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZpbGwoZSx0LDEse3RyYW5zZm9ybTpyfSl9aWYoaXNPYmplY3Qocikpe3JldHVybiBmaWxsKGUsdCwwLHIpfWxldCB1PXsuLi5ufTtpZih1LmNhcHR1cmU9PT10cnVlKXUud3JhcD10cnVlO3I9cnx8dS5zdGVwfHwxO2lmKCFpc051bWJlcihyKSl7aWYociE9bnVsbCYmIWlzT2JqZWN0KHIpKXJldHVybiBpbnZhbGlkU3RlcChyLHUpO3JldHVybiBmaWxsKGUsdCwxLHIpfWlmKGlzTnVtYmVyKGUpJiZpc051bWJlcih0KSl7cmV0dXJuIGZpbGxOdW1iZXJzKGUsdCxyLHUpfXJldHVybiBmaWxsTGV0dGVycyhlLHQsTWF0aC5tYXgoTWF0aC5hYnMociksMSksdSl9O2UuZXhwb3J0cz1maWxsfSwzNTc6ZT0+e1xuLyohXG4gKiBpcy1udW1iZXIgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLW51bWJlcj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmUuZXhwb3J0cz1mdW5jdGlvbihlKXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe3JldHVybiBlLWU9PT0wfWlmKHR5cGVvZiBlPT09XCJzdHJpbmdcIiYmZS50cmltKCkhPT1cIlwiKXtyZXR1cm4gTnVtYmVyLmlzRmluaXRlP051bWJlci5pc0Zpbml0ZSgrZSk6aXNGaW5pdGUoK2UpfXJldHVybiBmYWxzZX19LDk3MTooZSx0LHIpPT57Y29uc3Qgbj1yKDgzNyk7Y29uc3QgdT1yKDMzMyk7Y29uc3Qgcz1yKDI1MSk7Y29uc3Qgbz1yKDUxMyk7Y29uc3QgaXNFbXB0eVN0cmluZz1lPT5lPT09XCJcInx8ZT09PVwiLi9cIjtjb25zdCBtaWNyb21hdGNoPShlLHQscik9Pnt0PVtdLmNvbmNhdCh0KTtlPVtdLmNvbmNhdChlKTtsZXQgbj1uZXcgU2V0O2xldCB1PW5ldyBTZXQ7bGV0IG89bmV3IFNldDtsZXQgaT0wO2xldCBvblJlc3VsdD1lPT57by5hZGQoZS5vdXRwdXQpO2lmKHImJnIub25SZXN1bHQpe3Iub25SZXN1bHQoZSl9fTtmb3IobGV0IG89MDtvPHQubGVuZ3RoO28rKyl7bGV0IGE9cyhTdHJpbmcodFtvXSksey4uLnIsb25SZXN1bHQ6b25SZXN1bHR9LHRydWUpO2xldCBsPWEuc3RhdGUubmVnYXRlZHx8YS5zdGF0ZS5uZWdhdGVkRXh0Z2xvYjtpZihsKWkrKztmb3IobGV0IHQgb2YgZSl7bGV0IGU9YSh0LHRydWUpO2xldCByPWw/IWUuaXNNYXRjaDplLmlzTWF0Y2g7aWYoIXIpY29udGludWU7aWYobCl7bi5hZGQoZS5vdXRwdXQpfWVsc2V7bi5kZWxldGUoZS5vdXRwdXQpO3UuYWRkKGUub3V0cHV0KX19fWxldCBhPWk9PT10Lmxlbmd0aD9bLi4ub106Wy4uLnVdO2xldCBsPWEuZmlsdGVyKChlPT4hbi5oYXMoZSkpKTtpZihyJiZsLmxlbmd0aD09PTApe2lmKHIuZmFpbGdsb2I9PT10cnVlKXt0aHJvdyBuZXcgRXJyb3IoYE5vIG1hdGNoZXMgZm91bmQgZm9yIFwiJHt0LmpvaW4oXCIsIFwiKX1cImApfWlmKHIubm9udWxsPT09dHJ1ZXx8ci5udWxsZ2xvYj09PXRydWUpe3JldHVybiByLnVuZXNjYXBlP3QubWFwKChlPT5lLnJlcGxhY2UoL1xcXFwvZyxcIlwiKSkpOnR9fXJldHVybiBsfTttaWNyb21hdGNoLm1hdGNoPW1pY3JvbWF0Y2g7bWljcm9tYXRjaC5tYXRjaGVyPShlLHQpPT5zKGUsdCk7bWljcm9tYXRjaC5pc01hdGNoPShlLHQscik9PnModCxyKShlKTttaWNyb21hdGNoLmFueT1taWNyb21hdGNoLmlzTWF0Y2g7bWljcm9tYXRjaC5ub3Q9KGUsdCxyPXt9KT0+e3Q9W10uY29uY2F0KHQpLm1hcChTdHJpbmcpO2xldCBuPW5ldyBTZXQ7bGV0IHU9W107bGV0IG9uUmVzdWx0PWU9PntpZihyLm9uUmVzdWx0KXIub25SZXN1bHQoZSk7dS5wdXNoKGUub3V0cHV0KX07bGV0IHM9bWljcm9tYXRjaChlLHQsey4uLnIsb25SZXN1bHQ6b25SZXN1bHR9KTtmb3IobGV0IGUgb2YgdSl7aWYoIXMuaW5jbHVkZXMoZSkpe24uYWRkKGUpfX1yZXR1cm5bLi4ubl19O21pY3JvbWF0Y2guY29udGFpbnM9KGUsdCxyKT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmc6IFwiJHtuLmluc3BlY3QoZSl9XCJgKX1pZihBcnJheS5pc0FycmF5KHQpKXtyZXR1cm4gdC5zb21lKCh0PT5taWNyb21hdGNoLmNvbnRhaW5zKGUsdCxyKSkpfWlmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7aWYoaXNFbXB0eVN0cmluZyhlKXx8aXNFbXB0eVN0cmluZyh0KSl7cmV0dXJuIGZhbHNlfWlmKGUuaW5jbHVkZXModCl8fGUuc3RhcnRzV2l0aChcIi4vXCIpJiZlLnNsaWNlKDIpLmluY2x1ZGVzKHQpKXtyZXR1cm4gdHJ1ZX19cmV0dXJuIG1pY3JvbWF0Y2guaXNNYXRjaChlLHQsey4uLnIsY29udGFpbnM6dHJ1ZX0pfTttaWNyb21hdGNoLm1hdGNoS2V5cz0oZSx0LHIpPT57aWYoIW8uaXNPYmplY3QoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0XCIpfWxldCBuPW1pY3JvbWF0Y2goT2JqZWN0LmtleXMoZSksdCxyKTtsZXQgdT17fTtmb3IobGV0IHQgb2Ygbil1W3RdPWVbdF07cmV0dXJuIHV9O21pY3JvbWF0Y2guc29tZT0oZSx0LHIpPT57bGV0IG49W10uY29uY2F0KGUpO2ZvcihsZXQgZSBvZltdLmNvbmNhdCh0KSl7bGV0IHQ9cyhTdHJpbmcoZSkscik7aWYobi5zb21lKChlPT50KGUpKSkpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9O21pY3JvbWF0Y2guZXZlcnk9KGUsdCxyKT0+e2xldCBuPVtdLmNvbmNhdChlKTtmb3IobGV0IGUgb2ZbXS5jb25jYXQodCkpe2xldCB0PXMoU3RyaW5nKGUpLHIpO2lmKCFuLmV2ZXJ5KChlPT50KGUpKSkpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9O21pY3JvbWF0Y2guYWxsPShlLHQscik9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nOiBcIiR7bi5pbnNwZWN0KGUpfVwiYCl9cmV0dXJuW10uY29uY2F0KHQpLmV2ZXJ5KCh0PT5zKHQscikoZSkpKX07bWljcm9tYXRjaC5jYXB0dXJlPShlLHQscik9PntsZXQgbj1vLmlzV2luZG93cyhyKTtsZXQgdT1zLm1ha2VSZShTdHJpbmcoZSksey4uLnIsY2FwdHVyZTp0cnVlfSk7bGV0IGk9dS5leGVjKG4/by50b1Bvc2l4U2xhc2hlcyh0KTp0KTtpZihpKXtyZXR1cm4gaS5zbGljZSgxKS5tYXAoKGU9PmU9PT12b2lkIDA/XCJcIjplKSl9fTttaWNyb21hdGNoLm1ha2VSZT0oLi4uZSk9PnMubWFrZVJlKC4uLmUpO21pY3JvbWF0Y2guc2Nhbj0oLi4uZSk9PnMuc2NhbiguLi5lKTttaWNyb21hdGNoLnBhcnNlPShlLHQpPT57bGV0IHI9W107Zm9yKGxldCBuIG9mW10uY29uY2F0KGV8fFtdKSl7Zm9yKGxldCBlIG9mIHUoU3RyaW5nKG4pLHQpKXtyLnB1c2gocy5wYXJzZShlLHQpKX19cmV0dXJuIHJ9O21pY3JvbWF0Y2guYnJhY2VzPShlLHQpPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKTtpZih0JiZ0Lm5vYnJhY2U9PT10cnVlfHwhL1xcey4qXFx9Ly50ZXN0KGUpKXtyZXR1cm5bZV19cmV0dXJuIHUoZSx0KX07bWljcm9tYXRjaC5icmFjZUV4cGFuZD0oZSx0KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBzdHJpbmdcIik7cmV0dXJuIG1pY3JvbWF0Y2guYnJhY2VzKGUsey4uLnQsZXhwYW5kOnRydWV9KX07ZS5leHBvcnRzPW1pY3JvbWF0Y2h9LDI1MTooZSx0LHIpPT57ZS5leHBvcnRzPXIoNjgzKX0sMzU2OihlLHQscik9Pntjb25zdCBuPXIoMTcpO2NvbnN0IHU9XCJcXFxcXFxcXC9cIjtjb25zdCBzPWBbXiR7dX1dYDtjb25zdCBvPVwiXFxcXC5cIjtjb25zdCBpPVwiXFxcXCtcIjtjb25zdCBhPVwiXFxcXD9cIjtjb25zdCBsPVwiXFxcXC9cIjtjb25zdCBjPVwiKD89LilcIjtjb25zdCBwPVwiW14vXVwiO2NvbnN0IGY9YCg/OiR7bH18JClgO2NvbnN0IEE9YCg/Ol58JHtsfSlgO2NvbnN0IFI9YCR7b317MSwyfSR7Zn1gO2NvbnN0IF89YCg/ISR7b30pYDtjb25zdCBoPWAoPyEke0F9JHtSfSlgO2NvbnN0IGc9YCg/ISR7b317MCwxfSR7Zn0pYDtjb25zdCBFPWAoPyEke1J9KWA7Y29uc3QgQz1gW14uJHtsfV1gO2NvbnN0IHk9YCR7cH0qP2A7Y29uc3QgZD17RE9UX0xJVEVSQUw6byxQTFVTX0xJVEVSQUw6aSxRTUFSS19MSVRFUkFMOmEsU0xBU0hfTElURVJBTDpsLE9ORV9DSEFSOmMsUU1BUks6cCxFTkRfQU5DSE9SOmYsRE9UU19TTEFTSDpSLE5PX0RPVDpfLE5PX0RPVFM6aCxOT19ET1RfU0xBU0g6ZyxOT19ET1RTX1NMQVNIOkUsUU1BUktfTk9fRE9UOkMsU1RBUjp5LFNUQVJUX0FOQ0hPUjpBfTtjb25zdCB4PXsuLi5kLFNMQVNIX0xJVEVSQUw6YFske3V9XWAsUU1BUks6cyxTVEFSOmAke3N9Kj9gLERPVFNfU0xBU0g6YCR7b317MSwyfSg/Olske3V9XXwkKWAsTk9fRE9UOmAoPyEke299KWAsTk9fRE9UUzpgKD8hKD86XnxbJHt1fV0pJHtvfXsxLDJ9KD86WyR7dX1dfCQpKWAsTk9fRE9UX1NMQVNIOmAoPyEke299ezAsMX0oPzpbJHt1fV18JCkpYCxOT19ET1RTX1NMQVNIOmAoPyEke299ezEsMn0oPzpbJHt1fV18JCkpYCxRTUFSS19OT19ET1Q6YFteLiR7dX1dYCxTVEFSVF9BTkNIT1I6YCg/Ol58WyR7dX1dKWAsRU5EX0FOQ0hPUjpgKD86WyR7dX1dfCQpYH07Y29uc3QgYj17YWxudW06XCJhLXpBLVowLTlcIixhbHBoYTpcImEtekEtWlwiLGFzY2lpOlwiXFxcXHgwMC1cXFxceDdGXCIsYmxhbms6XCIgXFxcXHRcIixjbnRybDpcIlxcXFx4MDAtXFxcXHgxRlxcXFx4N0ZcIixkaWdpdDpcIjAtOVwiLGdyYXBoOlwiXFxcXHgyMS1cXFxceDdFXCIsbG93ZXI6XCJhLXpcIixwcmludDpcIlxcXFx4MjAtXFxcXHg3RSBcIixwdW5jdDpcIlxcXFwtIVxcXCIjJCUmJygpXFxcXCorLC4vOjs8PT4/QFtcXFxcXV5fYHt8fX5cIixzcGFjZTpcIiBcXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmXCIsdXBwZXI6XCJBLVpcIix3b3JkOlwiQS1aYS16MC05X1wiLHhkaWdpdDpcIkEtRmEtZjAtOVwifTtlLmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxQT1NJWF9SRUdFWF9TT1VSQ0U6YixSRUdFWF9CQUNLU0xBU0g6L1xcXFwoPyFbKis/XiR7fSh8KVtcXF1dKS9nLFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOi9eW15AIVtcXF0uLCQqKz9ee30oKXxcXFxcL10rLyxSRUdFWF9TUEVDSUFMX0NIQVJTOi9bLSorPy5eJHt9KHwpW1xcXV0vLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjovKFxcXFw/KSgoXFxXKShcXDMqKSkvZyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDovKFstKis/Ll4ke30ofClbXFxdXSkvZyxSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOi8oPzpcXFsuKj9bXlxcXFxdXFxdfFxcXFwoPz0uKSkvZyxSRVBMQUNFTUVOVFM6e1wiKioqXCI6XCIqXCIsXCIqKi8qKlwiOlwiKipcIixcIioqLyoqLyoqXCI6XCIqKlwifSxDSEFSXzA6NDgsQ0hBUl85OjU3LENIQVJfVVBQRVJDQVNFX0E6NjUsQ0hBUl9MT1dFUkNBU0VfQTo5NyxDSEFSX1VQUEVSQ0FTRV9aOjkwLENIQVJfTE9XRVJDQVNFX1o6MTIyLENIQVJfTEVGVF9QQVJFTlRIRVNFUzo0MCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOjQxLENIQVJfQVNURVJJU0s6NDIsQ0hBUl9BTVBFUlNBTkQ6MzgsQ0hBUl9BVDo2NCxDSEFSX0JBQ0tXQVJEX1NMQVNIOjkyLENIQVJfQ0FSUklBR0VfUkVUVVJOOjEzLENIQVJfQ0lSQ1VNRkxFWF9BQ0NFTlQ6OTQsQ0hBUl9DT0xPTjo1OCxDSEFSX0NPTU1BOjQ0LENIQVJfRE9UOjQ2LENIQVJfRE9VQkxFX1FVT1RFOjM0LENIQVJfRVFVQUw6NjEsQ0hBUl9FWENMQU1BVElPTl9NQVJLOjMzLENIQVJfRk9STV9GRUVEOjEyLENIQVJfRk9SV0FSRF9TTEFTSDo0NyxDSEFSX0dSQVZFX0FDQ0VOVDo5NixDSEFSX0hBU0g6MzUsQ0hBUl9IWVBIRU5fTUlOVVM6NDUsQ0hBUl9MRUZUX0FOR0xFX0JSQUNLRVQ6NjAsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOjEyMyxDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQ6OTEsQ0hBUl9MSU5FX0ZFRUQ6MTAsQ0hBUl9OT19CUkVBS19TUEFDRToxNjAsQ0hBUl9QRVJDRU5UOjM3LENIQVJfUExVUzo0MyxDSEFSX1FVRVNUSU9OX01BUks6NjMsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOjYyLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6MTI1LENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6OTMsQ0hBUl9TRU1JQ09MT046NTksQ0hBUl9TSU5HTEVfUVVPVEU6MzksQ0hBUl9TUEFDRTozMixDSEFSX1RBQjo5LENIQVJfVU5ERVJTQ09SRTo5NSxDSEFSX1ZFUlRJQ0FMX0xJTkU6MTI0LENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOjY1Mjc5LFNFUDpuLnNlcCxleHRnbG9iQ2hhcnMoZSl7cmV0dXJue1wiIVwiOnt0eXBlOlwibmVnYXRlXCIsb3BlbjpcIig/Oig/ISg/OlwiLGNsb3NlOmApKSR7ZS5TVEFSfSlgfSxcIj9cIjp7dHlwZTpcInFtYXJrXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKT9cIn0sXCIrXCI6e3R5cGU6XCJwbHVzXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKStcIn0sXCIqXCI6e3R5cGU6XCJzdGFyXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKSpcIn0sXCJAXCI6e3R5cGU6XCJhdFwiLG9wZW46XCIoPzpcIixjbG9zZTpcIilcIn19fSxnbG9iQ2hhcnMoZSl7cmV0dXJuIGU9PT10cnVlP3g6ZH19fSw3NTQ6KGUsdCxyKT0+e2NvbnN0IG49cigzNTYpO2NvbnN0IHU9cig1MTMpO2NvbnN0e01BWF9MRU5HVEg6cyxQT1NJWF9SRUdFWF9TT1VSQ0U6byxSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzppLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjphLFJFUExBQ0VNRU5UUzpsfT1uO2NvbnN0IGV4cGFuZFJhbmdlPShlLHQpPT57aWYodHlwZW9mIHQuZXhwYW5kUmFuZ2U9PT1cImZ1bmN0aW9uXCIpe3JldHVybiB0LmV4cGFuZFJhbmdlKC4uLmUsdCl9ZS5zb3J0KCk7Y29uc3Qgcj1gWyR7ZS5qb2luKFwiLVwiKX1dYDt0cnl7bmV3IFJlZ0V4cChyKX1jYXRjaCh0KXtyZXR1cm4gZS5tYXAoKGU9PnUuZXNjYXBlUmVnZXgoZSkpKS5qb2luKFwiLi5cIil9cmV0dXJuIHJ9O2NvbnN0IHN5bnRheEVycm9yPShlLHQpPT5gTWlzc2luZyAke2V9OiBcIiR7dH1cIiAtIHVzZSBcIlxcXFxcXFxcJHt0fVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7Y29uc3QgcGFyc2U9KGUsdCk9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX1lPWxbZV18fGU7Y29uc3Qgcj17Li4udH07Y29uc3QgYz10eXBlb2Ygci5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsci5tYXhMZW5ndGgpOnM7bGV0IHA9ZS5sZW5ndGg7aWYocD5jKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtwfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke2N9YCl9Y29uc3QgZj17dHlwZTpcImJvc1wiLHZhbHVlOlwiXCIsb3V0cHV0OnIucHJlcGVuZHx8XCJcIn07Y29uc3QgQT1bZl07Y29uc3QgUj1yLmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgXz11LmlzV2luZG93cyh0KTtjb25zdCBoPW4uZ2xvYkNoYXJzKF8pO2NvbnN0IGc9bi5leHRnbG9iQ2hhcnMoaCk7Y29uc3R7RE9UX0xJVEVSQUw6RSxQTFVTX0xJVEVSQUw6QyxTTEFTSF9MSVRFUkFMOnksT05FX0NIQVI6ZCxET1RTX1NMQVNIOngsTk9fRE9UOmIsTk9fRE9UX1NMQVNIOlMsTk9fRE9UU19TTEFTSDpILFFNQVJLOnYsUU1BUktfTk9fRE9UOiQsU1RBUjptLFNUQVJUX0FOQ0hPUjpUfT1oO2NvbnN0IGdsb2JzdGFyPWU9PmAoJHtSfSg/Oig/ISR7VH0ke2UuZG90P3g6RX0pLikqPylgO2NvbnN0IEw9ci5kb3Q/XCJcIjpiO2NvbnN0IE89ci5kb3Q/djokO2xldCB3PXIuYmFzaD09PXRydWU/Z2xvYnN0YXIocik6bTtpZihyLmNhcHR1cmUpe3c9YCgke3d9KWB9aWYodHlwZW9mIHIubm9leHQ9PT1cImJvb2xlYW5cIil7ci5ub2V4dGdsb2I9ci5ub2V4dH1jb25zdCBOPXtpbnB1dDplLGluZGV4Oi0xLHN0YXJ0OjAsZG90OnIuZG90PT09dHJ1ZSxjb25zdW1lZDpcIlwiLG91dHB1dDpcIlwiLHByZWZpeDpcIlwiLGJhY2t0cmFjazpmYWxzZSxuZWdhdGVkOmZhbHNlLGJyYWNrZXRzOjAsYnJhY2VzOjAscGFyZW5zOjAscXVvdGVzOjAsZ2xvYnN0YXI6ZmFsc2UsdG9rZW5zOkF9O2U9dS5yZW1vdmVQcmVmaXgoZSxOKTtwPWUubGVuZ3RoO2NvbnN0IGs9W107Y29uc3QgST1bXTtjb25zdCBNPVtdO2xldCBQPWY7bGV0IEI7Y29uc3QgZW9zPSgpPT5OLmluZGV4PT09cC0xO2NvbnN0IEc9Ti5wZWVrPSh0PTEpPT5lW04uaW5kZXgrdF07Y29uc3QgRD1OLmFkdmFuY2U9KCk9PmVbKytOLmluZGV4XTtjb25zdCByZW1haW5pbmc9KCk9PmUuc2xpY2UoTi5pbmRleCsxKTtjb25zdCBjb25zdW1lPShlPVwiXCIsdD0wKT0+e04uY29uc3VtZWQrPWU7Ti5pbmRleCs9dH07Y29uc3QgYXBwZW5kPWU9PntOLm91dHB1dCs9ZS5vdXRwdXQhPW51bGw/ZS5vdXRwdXQ6ZS52YWx1ZTtjb25zdW1lKGUudmFsdWUpfTtjb25zdCBuZWdhdGU9KCk9PntsZXQgZT0xO3doaWxlKEcoKT09PVwiIVwiJiYoRygyKSE9PVwiKFwifHxHKDMpPT09XCI/XCIpKXtEKCk7Ti5zdGFydCsrO2UrK31pZihlJTI9PT0wKXtyZXR1cm4gZmFsc2V9Ti5uZWdhdGVkPXRydWU7Ti5zdGFydCsrO3JldHVybiB0cnVlfTtjb25zdCBpbmNyZW1lbnQ9ZT0+e05bZV0rKztNLnB1c2goZSl9O2NvbnN0IGRlY3JlbWVudD1lPT57TltlXS0tO00ucG9wKCl9O2NvbnN0IHB1c2g9ZT0+e2lmKFAudHlwZT09PVwiZ2xvYnN0YXJcIil7Y29uc3QgdD1OLmJyYWNlcz4wJiYoZS50eXBlPT09XCJjb21tYVwifHxlLnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IHI9ZS5leHRnbG9iPT09dHJ1ZXx8ay5sZW5ndGgmJihlLnR5cGU9PT1cInBpcGVcInx8ZS50eXBlPT09XCJwYXJlblwiKTtpZihlLnR5cGUhPT1cInNsYXNoXCImJmUudHlwZSE9PVwicGFyZW5cIiYmIXQmJiFyKXtOLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC1QLm91dHB1dC5sZW5ndGgpO1AudHlwZT1cInN0YXJcIjtQLnZhbHVlPVwiKlwiO1Aub3V0cHV0PXc7Ti5vdXRwdXQrPVAub3V0cHV0fX1pZihrLmxlbmd0aCYmZS50eXBlIT09XCJwYXJlblwiJiYhZ1tlLnZhbHVlXSl7a1trLmxlbmd0aC0xXS5pbm5lcis9ZS52YWx1ZX1pZihlLnZhbHVlfHxlLm91dHB1dClhcHBlbmQoZSk7aWYoUCYmUC50eXBlPT09XCJ0ZXh0XCImJmUudHlwZT09PVwidGV4dFwiKXtQLnZhbHVlKz1lLnZhbHVlO1Aub3V0cHV0PShQLm91dHB1dHx8XCJcIikrZS52YWx1ZTtyZXR1cm59ZS5wcmV2PVA7QS5wdXNoKGUpO1A9ZX07Y29uc3QgZXh0Z2xvYk9wZW49KGUsdCk9Pntjb25zdCBuPXsuLi5nW3RdLGNvbmRpdGlvbnM6MSxpbm5lcjpcIlwifTtuLnByZXY9UDtuLnBhcmVucz1OLnBhcmVucztuLm91dHB1dD1OLm91dHB1dDtjb25zdCB1PShyLmNhcHR1cmU/XCIoXCI6XCJcIikrbi5vcGVuO2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOmUsdmFsdWU6dCxvdXRwdXQ6Ti5vdXRwdXQ/XCJcIjpkfSk7cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkQoKSxvdXRwdXQ6dX0pO2sucHVzaChuKX07Y29uc3QgZXh0Z2xvYkNsb3NlPWU9PntsZXQgdD1lLmNsb3NlKyhyLmNhcHR1cmU/XCIpXCI6XCJcIik7aWYoZS50eXBlPT09XCJuZWdhdGVcIil7bGV0IG49dztpZihlLmlubmVyJiZlLmlubmVyLmxlbmd0aD4xJiZlLmlubmVyLmluY2x1ZGVzKFwiL1wiKSl7bj1nbG9ic3RhcihyKX1pZihuIT09d3x8ZW9zKCl8fC9eXFwpKyQvLnRlc3QocmVtYWluaW5nKCkpKXt0PWUuY2xvc2U9YCkkKSkke259YH1pZihlLnByZXYudHlwZT09PVwiYm9zXCIpe04ubmVnYXRlZEV4dGdsb2I9dHJ1ZX19cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkIsb3V0cHV0OnR9KTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9O2lmKHIuZmFzdHBhdGhzIT09ZmFsc2UmJiEvKF5bKiFdfFsvKClbXFxde31cIl0pLy50ZXN0KGUpKXtsZXQgbj1mYWxzZTtsZXQgcz1lLnJlcGxhY2UoYSwoKGUsdCxyLHUscyxvKT0+e2lmKHU9PT1cIlxcXFxcIil7bj10cnVlO3JldHVybiBlfWlmKHU9PT1cIj9cIil7aWYodCl7cmV0dXJuIHQrdSsocz92LnJlcGVhdChzLmxlbmd0aCk6XCJcIil9aWYobz09PTApe3JldHVybiBPKyhzP3YucmVwZWF0KHMubGVuZ3RoKTpcIlwiKX1yZXR1cm4gdi5yZXBlYXQoci5sZW5ndGgpfWlmKHU9PT1cIi5cIil7cmV0dXJuIEUucmVwZWF0KHIubGVuZ3RoKX1pZih1PT09XCIqXCIpe2lmKHQpe3JldHVybiB0K3UrKHM/dzpcIlwiKX1yZXR1cm4gd31yZXR1cm4gdD9lOmBcXFxcJHtlfWB9KSk7aWYobj09PXRydWUpe2lmKHIudW5lc2NhcGU9PT10cnVlKXtzPXMucmVwbGFjZSgvXFxcXC9nLFwiXCIpfWVsc2V7cz1zLnJlcGxhY2UoL1xcXFwrL2csKGU9PmUubGVuZ3RoJTI9PT0wP1wiXFxcXFxcXFxcIjplP1wiXFxcXFwiOlwiXCIpKX19aWYocz09PWUmJnIuY29udGFpbnM9PT10cnVlKXtOLm91dHB1dD1lO3JldHVybiBOfU4ub3V0cHV0PXUud3JhcE91dHB1dChzLE4sdCk7cmV0dXJuIE59d2hpbGUoIWVvcygpKXtCPUQoKTtpZihCPT09XCJcXDBcIil7Y29udGludWV9aWYoQj09PVwiXFxcXFwiKXtjb25zdCBlPUcoKTtpZihlPT09XCIvXCImJnIuYmFzaCE9PXRydWUpe2NvbnRpbnVlfWlmKGU9PT1cIi5cInx8ZT09PVwiO1wiKXtjb250aW51ZX1pZighZSl7Qis9XCJcXFxcXCI7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCfSk7Y29udGludWV9Y29uc3QgdD0vXlxcXFwrLy5leGVjKHJlbWFpbmluZygpKTtsZXQgbj0wO2lmKHQmJnRbMF0ubGVuZ3RoPjIpe249dFswXS5sZW5ndGg7Ti5pbmRleCs9bjtpZihuJTIhPT0wKXtCKz1cIlxcXFxcIn19aWYoci51bmVzY2FwZT09PXRydWUpe0I9RCgpfHxcIlwifWVsc2V7Qis9RCgpfHxcIlwifWlmKE4uYnJhY2tldHM9PT0wKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX19aWYoTi5icmFja2V0cz4wJiYoQiE9PVwiXVwifHxQLnZhbHVlPT09XCJbXCJ8fFAudmFsdWU9PT1cIlteXCIpKXtpZihyLnBvc2l4IT09ZmFsc2UmJkI9PT1cIjpcIil7Y29uc3QgZT1QLnZhbHVlLnNsaWNlKDEpO2lmKGUuaW5jbHVkZXMoXCJbXCIpKXtQLnBvc2l4PXRydWU7aWYoZS5pbmNsdWRlcyhcIjpcIikpe2NvbnN0IGU9UC52YWx1ZS5sYXN0SW5kZXhPZihcIltcIik7Y29uc3QgdD1QLnZhbHVlLnNsaWNlKDAsZSk7Y29uc3Qgcj1QLnZhbHVlLnNsaWNlKGUrMik7Y29uc3Qgbj1vW3JdO2lmKG4pe1AudmFsdWU9dCtuO04uYmFja3RyYWNrPXRydWU7RCgpO2lmKCFmLm91dHB1dCYmQS5pbmRleE9mKFApPT09MSl7Zi5vdXRwdXQ9ZH1jb250aW51ZX19fX1pZihCPT09XCJbXCImJkcoKSE9PVwiOlwifHxCPT09XCItXCImJkcoKT09PVwiXVwiKXtCPWBcXFxcJHtCfWB9aWYoQj09PVwiXVwiJiYoUC52YWx1ZT09PVwiW1wifHxQLnZhbHVlPT09XCJbXlwiKSl7Qj1gXFxcXCR7Qn1gfWlmKHIucG9zaXg9PT10cnVlJiZCPT09XCIhXCImJlAudmFsdWU9PT1cIltcIil7Qj1cIl5cIn1QLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2NvbnRpbnVlfWlmKE4ucXVvdGVzPT09MSYmQiE9PSdcIicpe0I9dS5lc2NhcGVSZWdleChCKTtQLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT0nXCInKXtOLnF1b3Rlcz1OLnF1b3Rlcz09PTE/MDoxO2lmKHIua2VlcFF1b3Rlcz09PXRydWUpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pfWNvbnRpbnVlfWlmKEI9PT1cIihcIil7aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6XCJwYXJlblwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihCPT09XCIpXCIpe2lmKE4ucGFyZW5zPT09MCYmci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIihcIikpfWNvbnN0IGU9a1trLmxlbmd0aC0xXTtpZihlJiZOLnBhcmVucz09PWUucGFyZW5zKzEpe2V4dGdsb2JDbG9zZShrLnBvcCgpKTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpCLG91dHB1dDpOLnBhcmVucz9cIilcIjpcIlxcXFwpXCJ9KTtkZWNyZW1lbnQoXCJwYXJlbnNcIik7Y29udGludWV9aWYoQj09PVwiW1wiKXtpZihyLm5vYnJhY2tldD09PXRydWV8fCFyZW1haW5pbmcoKS5pbmNsdWRlcyhcIl1cIikpe2lmKHIubm9icmFja2V0IT09dHJ1ZSYmci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpfUI9YFxcXFwke0J9YH1lbHNle2luY3JlbWVudChcImJyYWNrZXRzXCIpfXB1c2goe3R5cGU6XCJicmFja2V0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT1cIl1cIil7aWYoci5ub2JyYWNrZXQ9PT10cnVlfHxQJiZQLnR5cGU9PT1cImJyYWNrZXRcIiYmUC52YWx1ZS5sZW5ndGg9PT0xKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OmBcXFxcJHtCfWB9KTtjb250aW51ZX1pZihOLmJyYWNrZXRzPT09MCl7aWYoci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIltcIikpfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6QixvdXRwdXQ6YFxcXFwke0J9YH0pO2NvbnRpbnVlfWRlY3JlbWVudChcImJyYWNrZXRzXCIpO2NvbnN0IGU9UC52YWx1ZS5zbGljZSgxKTtpZihQLnBvc2l4IT09dHJ1ZSYmZVswXT09PVwiXlwiJiYhZS5pbmNsdWRlcyhcIi9cIikpe0I9YC8ke0J9YH1QLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2lmKHIubGl0ZXJhbEJyYWNrZXRzPT09ZmFsc2V8fHUuaGFzUmVnZXhDaGFycyhlKSl7Y29udGludWV9Y29uc3QgdD11LmVzY2FwZVJlZ2V4KFAudmFsdWUpO04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLVAudmFsdWUubGVuZ3RoKTtpZihyLmxpdGVyYWxCcmFja2V0cz09PXRydWUpe04ub3V0cHV0Kz10O1AudmFsdWU9dDtjb250aW51ZX1QLnZhbHVlPWAoJHtSfSR7dH18JHtQLnZhbHVlfSlgO04ub3V0cHV0Kz1QLnZhbHVlO2NvbnRpbnVlfWlmKEI9PT1cIntcIiYmci5ub2JyYWNlIT09dHJ1ZSl7aW5jcmVtZW50KFwiYnJhY2VzXCIpO2NvbnN0IGU9e3R5cGU6XCJicmFjZVwiLHZhbHVlOkIsb3V0cHV0OlwiKFwiLG91dHB1dEluZGV4Ok4ub3V0cHV0Lmxlbmd0aCx0b2tlbnNJbmRleDpOLnRva2Vucy5sZW5ndGh9O0kucHVzaChlKTtwdXNoKGUpO2NvbnRpbnVlfWlmKEI9PT1cIn1cIil7Y29uc3QgZT1JW0kubGVuZ3RoLTFdO2lmKHIubm9icmFjZT09PXRydWV8fCFlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OkJ9KTtjb250aW51ZX1sZXQgdD1cIilcIjtpZihlLmRvdHM9PT10cnVlKXtjb25zdCBlPUEuc2xpY2UoKTtjb25zdCBuPVtdO2ZvcihsZXQgdD1lLmxlbmd0aC0xO3Q+PTA7dC0tKXtBLnBvcCgpO2lmKGVbdF0udHlwZT09PVwiYnJhY2VcIil7YnJlYWt9aWYoZVt0XS50eXBlIT09XCJkb3RzXCIpe24udW5zaGlmdChlW3RdLnZhbHVlKX19dD1leHBhbmRSYW5nZShuLHIpO04uYmFja3RyYWNrPXRydWV9aWYoZS5jb21tYSE9PXRydWUmJmUuZG90cyE9PXRydWUpe2NvbnN0IHI9Ti5vdXRwdXQuc2xpY2UoMCxlLm91dHB1dEluZGV4KTtjb25zdCBuPU4udG9rZW5zLnNsaWNlKGUudG9rZW5zSW5kZXgpO2UudmFsdWU9ZS5vdXRwdXQ9XCJcXFxce1wiO0I9dD1cIlxcXFx9XCI7Ti5vdXRwdXQ9cjtmb3IoY29uc3QgZSBvZiBuKXtOLm91dHB1dCs9ZS5vdXRwdXR8fGUudmFsdWV9fXB1c2goe3R5cGU6XCJicmFjZVwiLHZhbHVlOkIsb3V0cHV0OnR9KTtkZWNyZW1lbnQoXCJicmFjZXNcIik7SS5wb3AoKTtjb250aW51ZX1pZihCPT09XCJ8XCIpe2lmKGsubGVuZ3RoPjApe2tbay5sZW5ndGgtMV0uY29uZGl0aW9ucysrfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT1cIixcIil7bGV0IGU9Qjtjb25zdCB0PUlbSS5sZW5ndGgtMV07aWYodCYmTVtNLmxlbmd0aC0xXT09PVwiYnJhY2VzXCIpe3QuY29tbWE9dHJ1ZTtlPVwifFwifXB1c2goe3R5cGU6XCJjb21tYVwiLHZhbHVlOkIsb3V0cHV0OmV9KTtjb250aW51ZX1pZihCPT09XCIvXCIpe2lmKFAudHlwZT09PVwiZG90XCImJk4uaW5kZXg9PT1OLnN0YXJ0KzEpe04uc3RhcnQ9Ti5pbmRleCsxO04uY29uc3VtZWQ9XCJcIjtOLm91dHB1dD1cIlwiO0EucG9wKCk7UD1mO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOkIsb3V0cHV0Onl9KTtjb250aW51ZX1pZihCPT09XCIuXCIpe2lmKE4uYnJhY2VzPjAmJlAudHlwZT09PVwiZG90XCIpe2lmKFAudmFsdWU9PT1cIi5cIilQLm91dHB1dD1FO2NvbnN0IGU9SVtJLmxlbmd0aC0xXTtQLnR5cGU9XCJkb3RzXCI7UC5vdXRwdXQrPUI7UC52YWx1ZSs9QjtlLmRvdHM9dHJ1ZTtjb250aW51ZX1pZihOLmJyYWNlcytOLnBhcmVucz09PTAmJlAudHlwZSE9PVwiYm9zXCImJlAudHlwZSE9PVwic2xhc2hcIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDpFfSk7Y29udGludWV9cHVzaCh7dHlwZTpcImRvdFwiLHZhbHVlOkIsb3V0cHV0OkV9KTtjb250aW51ZX1pZihCPT09XCI/XCIpe2NvbnN0IGU9UCYmUC52YWx1ZT09PVwiKFwiO2lmKCFlJiZyLm5vZXh0Z2xvYiE9PXRydWUmJkcoKT09PVwiKFwiJiZHKDIpIT09XCI/XCIpe2V4dGdsb2JPcGVuKFwicW1hcmtcIixCKTtjb250aW51ZX1pZihQJiZQLnR5cGU9PT1cInBhcmVuXCIpe2NvbnN0IGU9RygpO2xldCB0PUI7aWYoZT09PVwiPFwiJiYhdS5zdXBwb3J0c0xvb2tiZWhpbmRzKCkpe3Rocm93IG5ldyBFcnJvcihcIk5vZGUuanMgdjEwIG9yIGhpZ2hlciBpcyByZXF1aXJlZCBmb3IgcmVnZXggbG9va2JlaGluZHNcIil9aWYoUC52YWx1ZT09PVwiKFwiJiYhL1shPTw6XS8udGVzdChlKXx8ZT09PVwiPFwiJiYhLzwoWyE9XXxcXHcrPikvLnRlc3QocmVtYWluaW5nKCkpKXt0PWBcXFxcJHtCfWB9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDp0fSk7Y29udGludWV9aWYoci5kb3QhPT10cnVlJiYoUC50eXBlPT09XCJzbGFzaFwifHxQLnR5cGU9PT1cImJvc1wiKSl7cHVzaCh7dHlwZTpcInFtYXJrXCIsdmFsdWU6QixvdXRwdXQ6JH0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkIsb3V0cHV0OnZ9KTtjb250aW51ZX1pZihCPT09XCIhXCIpe2lmKHIubm9leHRnbG9iIT09dHJ1ZSYmRygpPT09XCIoXCIpe2lmKEcoMikhPT1cIj9cInx8IS9bIT08Ol0vLnRlc3QoRygzKSkpe2V4dGdsb2JPcGVuKFwibmVnYXRlXCIsQik7Y29udGludWV9fWlmKHIubm9uZWdhdGUhPT10cnVlJiZOLmluZGV4PT09MCl7bmVnYXRlKCk7Y29udGludWV9fWlmKEI9PT1cIitcIil7aWYoci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIiYmRygyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInBsdXNcIixCKTtjb250aW51ZX1pZihQJiZQLnZhbHVlPT09XCIoXCJ8fHIucmVnZXg9PT1mYWxzZSl7cHVzaCh7dHlwZTpcInBsdXNcIix2YWx1ZTpCLG91dHB1dDpDfSk7Y29udGludWV9aWYoUCYmKFAudHlwZT09PVwiYnJhY2tldFwifHxQLnR5cGU9PT1cInBhcmVuXCJ8fFAudHlwZT09PVwiYnJhY2VcIil8fE4ucGFyZW5zPjApe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6Qn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6Q30pO2NvbnRpbnVlfWlmKEI9PT1cIkBcIil7aWYoci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIiYmRygyKSE9PVwiP1wiKXtwdXNoKHt0eXBlOlwiYXRcIixleHRnbG9iOnRydWUsdmFsdWU6QixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEIhPT1cIipcIil7aWYoQj09PVwiJFwifHxCPT09XCJeXCIpe0I9YFxcXFwke0J9YH1jb25zdCBlPWkuZXhlYyhyZW1haW5pbmcoKSk7aWYoZSl7Qis9ZVswXTtOLmluZGV4Kz1lWzBdLmxlbmd0aH1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihQJiYoUC50eXBlPT09XCJnbG9ic3RhclwifHxQLnN0YXI9PT10cnVlKSl7UC50eXBlPVwic3RhclwiO1Auc3Rhcj10cnVlO1AudmFsdWUrPUI7UC5vdXRwdXQ9dztOLmJhY2t0cmFjaz10cnVlO04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIpO2NvbnRpbnVlfWxldCB0PXJlbWFpbmluZygpO2lmKHIubm9leHRnbG9iIT09dHJ1ZSYmL15cXChbXj9dLy50ZXN0KHQpKXtleHRnbG9iT3BlbihcInN0YXJcIixCKTtjb250aW51ZX1pZihQLnR5cGU9PT1cInN0YXJcIil7aWYoci5ub2dsb2JzdGFyPT09dHJ1ZSl7Y29uc3VtZShCKTtjb250aW51ZX1jb25zdCBuPVAucHJldjtjb25zdCB1PW4ucHJldjtjb25zdCBzPW4udHlwZT09PVwic2xhc2hcInx8bi50eXBlPT09XCJib3NcIjtjb25zdCBvPXUmJih1LnR5cGU9PT1cInN0YXJcInx8dS50eXBlPT09XCJnbG9ic3RhclwiKTtpZihyLmJhc2g9PT10cnVlJiYoIXN8fHRbMF0mJnRbMF0hPT1cIi9cIikpe3B1c2goe3R5cGU6XCJzdGFyXCIsdmFsdWU6QixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWNvbnN0IGk9Ti5icmFjZXM+MCYmKG4udHlwZT09PVwiY29tbWFcInx8bi50eXBlPT09XCJicmFjZVwiKTtjb25zdCBhPWsubGVuZ3RoJiYobi50eXBlPT09XCJwaXBlXCJ8fG4udHlwZT09PVwicGFyZW5cIik7aWYoIXMmJm4udHlwZSE9PVwicGFyZW5cIiYmIWkmJiFhKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX13aGlsZSh0LnNsaWNlKDAsMyk9PT1cIi8qKlwiKXtjb25zdCByPWVbTi5pbmRleCs0XTtpZihyJiZyIT09XCIvXCIpe2JyZWFrfXQ9dC5zbGljZSgzKTtjb25zdW1lKFwiLyoqXCIsMyl9aWYobi50eXBlPT09XCJib3NcIiYmZW9zKCkpe1AudHlwZT1cImdsb2JzdGFyXCI7UC52YWx1ZSs9QjtQLm91dHB1dD1nbG9ic3RhcihyKTtOLm91dHB1dD1QLm91dHB1dDtOLmdsb2JzdGFyPXRydWU7Y29uc3VtZShCKTtjb250aW51ZX1pZihuLnR5cGU9PT1cInNsYXNoXCImJm4ucHJldi50eXBlIT09XCJib3NcIiYmIW8mJmVvcygpKXtOLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrUC5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtQLnR5cGU9XCJnbG9ic3RhclwiO1Aub3V0cHV0PWdsb2JzdGFyKHIpKyhyLnN0cmljdFNsYXNoZXM/XCIpXCI6XCJ8JClcIik7UC52YWx1ZSs9QjtOLmdsb2JzdGFyPXRydWU7Ti5vdXRwdXQrPW4ub3V0cHV0K1Aub3V0cHV0O2NvbnN1bWUoQik7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJnRbMF09PT1cIi9cIil7Y29uc3QgZT10WzFdIT09dm9pZCAwP1wifCRcIjpcIlwiO04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLShuLm91dHB1dCtQLm91dHB1dCkubGVuZ3RoKTtuLm91dHB1dD1gKD86JHtuLm91dHB1dH1gO1AudHlwZT1cImdsb2JzdGFyXCI7UC5vdXRwdXQ9YCR7Z2xvYnN0YXIocil9JHt5fXwke3l9JHtlfSlgO1AudmFsdWUrPUI7Ti5vdXRwdXQrPW4ub3V0cHV0K1Aub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIrRCgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWlmKG4udHlwZT09PVwiYm9zXCImJnRbMF09PT1cIi9cIil7UC50eXBlPVwiZ2xvYnN0YXJcIjtQLnZhbHVlKz1CO1Aub3V0cHV0PWAoPzpefCR7eX18JHtnbG9ic3RhcihyKX0ke3l9KWA7Ti5vdXRwdXQ9UC5vdXRwdXQ7Ti5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoQitEKCkpO3B1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOlwiL1wiLG91dHB1dDpcIlwifSk7Y29udGludWV9Ti5vdXRwdXQ9Ti5vdXRwdXQuc2xpY2UoMCwtUC5vdXRwdXQubGVuZ3RoKTtQLnR5cGU9XCJnbG9ic3RhclwiO1Aub3V0cHV0PWdsb2JzdGFyKHIpO1AudmFsdWUrPUI7Ti5vdXRwdXQrPVAub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIpO2NvbnRpbnVlfWNvbnN0IG49e3R5cGU6XCJzdGFyXCIsdmFsdWU6QixvdXRwdXQ6d307aWYoci5iYXNoPT09dHJ1ZSl7bi5vdXRwdXQ9XCIuKj9cIjtpZihQLnR5cGU9PT1cImJvc1wifHxQLnR5cGU9PT1cInNsYXNoXCIpe24ub3V0cHV0PUwrbi5vdXRwdXR9cHVzaChuKTtjb250aW51ZX1pZihQJiYoUC50eXBlPT09XCJicmFja2V0XCJ8fFAudHlwZT09PVwicGFyZW5cIikmJnIucmVnZXg9PT10cnVlKXtuLm91dHB1dD1CO3B1c2gobik7Y29udGludWV9aWYoTi5pbmRleD09PU4uc3RhcnR8fFAudHlwZT09PVwic2xhc2hcInx8UC50eXBlPT09XCJkb3RcIil7aWYoUC50eXBlPT09XCJkb3RcIil7Ti5vdXRwdXQrPVM7UC5vdXRwdXQrPVN9ZWxzZSBpZihyLmRvdD09PXRydWUpe04ub3V0cHV0Kz1IO1Aub3V0cHV0Kz1IfWVsc2V7Ti5vdXRwdXQrPUw7UC5vdXRwdXQrPUx9aWYoRygpIT09XCIqXCIpe04ub3V0cHV0Kz1kO1Aub3V0cHV0Kz1kfX1wdXNoKG4pfXdoaWxlKE4uYnJhY2tldHM+MCl7aWYoci5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiXVwiKSk7Ti5vdXRwdXQ9dS5lc2NhcGVMYXN0KE4ub3V0cHV0LFwiW1wiKTtkZWNyZW1lbnQoXCJicmFja2V0c1wiKX13aGlsZShOLnBhcmVucz4wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCIpXCIpKTtOLm91dHB1dD11LmVzY2FwZUxhc3QoTi5vdXRwdXQsXCIoXCIpO2RlY3JlbWVudChcInBhcmVuc1wiKX13aGlsZShOLmJyYWNlcz4wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJ9XCIpKTtOLm91dHB1dD11LmVzY2FwZUxhc3QoTi5vdXRwdXQsXCJ7XCIpO2RlY3JlbWVudChcImJyYWNlc1wiKX1pZihyLnN0cmljdFNsYXNoZXMhPT10cnVlJiYoUC50eXBlPT09XCJzdGFyXCJ8fFAudHlwZT09PVwiYnJhY2tldFwiKSl7cHVzaCh7dHlwZTpcIm1heWJlX3NsYXNoXCIsdmFsdWU6XCJcIixvdXRwdXQ6YCR7eX0/YH0pfWlmKE4uYmFja3RyYWNrPT09dHJ1ZSl7Ti5vdXRwdXQ9XCJcIjtmb3IoY29uc3QgZSBvZiBOLnRva2Vucyl7Ti5vdXRwdXQrPWUub3V0cHV0IT1udWxsP2Uub3V0cHV0OmUudmFsdWU7aWYoZS5zdWZmaXgpe04ub3V0cHV0Kz1lLnN1ZmZpeH19fXJldHVybiBOfTtwYXJzZS5mYXN0cGF0aHM9KGUsdCk9Pntjb25zdCByPXsuLi50fTtjb25zdCBvPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4ocyxyLm1heExlbmd0aCk6cztjb25zdCBpPWUubGVuZ3RoO2lmKGk+byl7dGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7aX0sIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIGxlbmd0aDogJHtvfWApfWU9bFtlXXx8ZTtjb25zdCBhPXUuaXNXaW5kb3dzKHQpO2NvbnN0e0RPVF9MSVRFUkFMOmMsU0xBU0hfTElURVJBTDpwLE9ORV9DSEFSOmYsRE9UU19TTEFTSDpBLE5PX0RPVDpSLE5PX0RPVFM6XyxOT19ET1RTX1NMQVNIOmgsU1RBUjpnLFNUQVJUX0FOQ0hPUjpFfT1uLmdsb2JDaGFycyhhKTtjb25zdCBDPXIuZG90P186Ujtjb25zdCB5PXIuZG90P2g6Ujtjb25zdCBkPXIuY2FwdHVyZT9cIlwiOlwiPzpcIjtjb25zdCB4PXtuZWdhdGVkOmZhbHNlLHByZWZpeDpcIlwifTtsZXQgYj1yLmJhc2g9PT10cnVlP1wiLio/XCI6ZztpZihyLmNhcHR1cmUpe2I9YCgke2J9KWB9Y29uc3QgZ2xvYnN0YXI9ZT0+e2lmKGUubm9nbG9ic3Rhcj09PXRydWUpcmV0dXJuIGI7cmV0dXJuYCgke2R9KD86KD8hJHtFfSR7ZS5kb3Q/QTpjfSkuKSo/KWB9O2NvbnN0IGNyZWF0ZT1lPT57c3dpdGNoKGUpe2Nhc2VcIipcIjpyZXR1cm5gJHtDfSR7Zn0ke2J9YDtjYXNlXCIuKlwiOnJldHVybmAke2N9JHtmfSR7Yn1gO2Nhc2VcIiouKlwiOnJldHVybmAke0N9JHtifSR7Y30ke2Z9JHtifWA7Y2FzZVwiKi8qXCI6cmV0dXJuYCR7Q30ke2J9JHtwfSR7Zn0ke3l9JHtifWA7Y2FzZVwiKipcIjpyZXR1cm4gQytnbG9ic3RhcihyKTtjYXNlXCIqKi8qXCI6cmV0dXJuYCg/OiR7Q30ke2dsb2JzdGFyKHIpfSR7cH0pPyR7eX0ke2Z9JHtifWA7Y2FzZVwiKiovKi4qXCI6cmV0dXJuYCg/OiR7Q30ke2dsb2JzdGFyKHIpfSR7cH0pPyR7eX0ke2J9JHtjfSR7Zn0ke2J9YDtjYXNlXCIqKi8uKlwiOnJldHVybmAoPzoke0N9JHtnbG9ic3RhcihyKX0ke3B9KT8ke2N9JHtmfSR7Yn1gO2RlZmF1bHQ6e2NvbnN0IHQ9L14oLio/KVxcLihcXHcrKSQvLmV4ZWMoZSk7aWYoIXQpcmV0dXJuO2NvbnN0IHI9Y3JlYXRlKHRbMV0pO2lmKCFyKXJldHVybjtyZXR1cm4gcitjK3RbMl19fX07Y29uc3QgUz11LnJlbW92ZVByZWZpeChlLHgpO2xldCBIPWNyZWF0ZShTKTtpZihIJiZyLnN0cmljdFNsYXNoZXMhPT10cnVlKXtIKz1gJHtwfT9gfXJldHVybiBIfTtlLmV4cG9ydHM9cGFyc2V9LDY4MzooZSx0LHIpPT57Y29uc3Qgbj1yKDE3KTtjb25zdCB1PXIoNzAwKTtjb25zdCBzPXIoNzU0KTtjb25zdCBvPXIoNTEzKTtjb25zdCBpPXIoMzU2KTtjb25zdCBpc09iamVjdD1lPT5lJiZ0eXBlb2YgZT09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KGUpO2NvbnN0IHBpY29tYXRjaD0oZSx0LHI9ZmFsc2UpPT57aWYoQXJyYXkuaXNBcnJheShlKSl7Y29uc3Qgbj1lLm1hcCgoZT0+cGljb21hdGNoKGUsdCxyKSkpO2NvbnN0IGFycmF5TWF0Y2hlcj1lPT57Zm9yKGNvbnN0IHQgb2Ygbil7Y29uc3Qgcj10KGUpO2lmKHIpcmV0dXJuIHJ9cmV0dXJuIGZhbHNlfTtyZXR1cm4gYXJyYXlNYXRjaGVyfWNvbnN0IG49aXNPYmplY3QoZSkmJmUudG9rZW5zJiZlLmlucHV0O2lmKGU9PT1cIlwifHx0eXBlb2YgZSE9PVwic3RyaW5nXCImJiFuKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9Y29uc3QgdT10fHx7fTtjb25zdCBzPW8uaXNXaW5kb3dzKHQpO2NvbnN0IGk9bj9waWNvbWF0Y2guY29tcGlsZVJlKGUsdCk6cGljb21hdGNoLm1ha2VSZShlLHQsZmFsc2UsdHJ1ZSk7Y29uc3QgYT1pLnN0YXRlO2RlbGV0ZSBpLnN0YXRlO2xldCBpc0lnbm9yZWQ9KCk9PmZhbHNlO2lmKHUuaWdub3JlKXtjb25zdCBlPXsuLi50LGlnbm9yZTpudWxsLG9uTWF0Y2g6bnVsbCxvblJlc3VsdDpudWxsfTtpc0lnbm9yZWQ9cGljb21hdGNoKHUuaWdub3JlLGUscil9Y29uc3QgbWF0Y2hlcj0ocixuPWZhbHNlKT0+e2NvbnN0e2lzTWF0Y2g6byxtYXRjaDpsLG91dHB1dDpjfT1waWNvbWF0Y2gudGVzdChyLGksdCx7Z2xvYjplLHBvc2l4OnN9KTtjb25zdCBwPXtnbG9iOmUsc3RhdGU6YSxyZWdleDppLHBvc2l4OnMsaW5wdXQ6cixvdXRwdXQ6YyxtYXRjaDpsLGlzTWF0Y2g6b307aWYodHlwZW9mIHUub25SZXN1bHQ9PT1cImZ1bmN0aW9uXCIpe3Uub25SZXN1bHQocCl9aWYobz09PWZhbHNlKXtwLmlzTWF0Y2g9ZmFsc2U7cmV0dXJuIG4/cDpmYWxzZX1pZihpc0lnbm9yZWQocikpe2lmKHR5cGVvZiB1Lm9uSWdub3JlPT09XCJmdW5jdGlvblwiKXt1Lm9uSWdub3JlKHApfXAuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9wOmZhbHNlfWlmKHR5cGVvZiB1Lm9uTWF0Y2g9PT1cImZ1bmN0aW9uXCIpe3Uub25NYXRjaChwKX1yZXR1cm4gbj9wOnRydWV9O2lmKHIpe21hdGNoZXIuc3RhdGU9YX1yZXR1cm4gbWF0Y2hlcn07cGljb21hdGNoLnRlc3Q9KGUsdCxyLHtnbG9iOm4scG9zaXg6dX09e30pPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgaW5wdXQgdG8gYmUgYSBzdHJpbmdcIil9aWYoZT09PVwiXCIpe3JldHVybntpc01hdGNoOmZhbHNlLG91dHB1dDpcIlwifX1jb25zdCBzPXJ8fHt9O2NvbnN0IGk9cy5mb3JtYXR8fCh1P28udG9Qb3NpeFNsYXNoZXM6bnVsbCk7bGV0IGE9ZT09PW47bGV0IGw9YSYmaT9pKGUpOmU7aWYoYT09PWZhbHNlKXtsPWk/aShlKTplO2E9bD09PW59aWYoYT09PWZhbHNlfHxzLmNhcHR1cmU9PT10cnVlKXtpZihzLm1hdGNoQmFzZT09PXRydWV8fHMuYmFzZW5hbWU9PT10cnVlKXthPXBpY29tYXRjaC5tYXRjaEJhc2UoZSx0LHIsdSl9ZWxzZXthPXQuZXhlYyhsKX19cmV0dXJue2lzTWF0Y2g6Qm9vbGVhbihhKSxtYXRjaDphLG91dHB1dDpsfX07cGljb21hdGNoLm1hdGNoQmFzZT0oZSx0LHIsdT1vLmlzV2luZG93cyhyKSk9Pntjb25zdCBzPXQgaW5zdGFuY2VvZiBSZWdFeHA/dDpwaWNvbWF0Y2gubWFrZVJlKHQscik7cmV0dXJuIHMudGVzdChuLmJhc2VuYW1lKGUpKX07cGljb21hdGNoLmlzTWF0Y2g9KGUsdCxyKT0+cGljb21hdGNoKHQscikoZSk7cGljb21hdGNoLnBhcnNlPShlLHQpPT57aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZS5tYXAoKGU9PnBpY29tYXRjaC5wYXJzZShlLHQpKSk7cmV0dXJuIHMoZSx7Li4udCxmYXN0cGF0aHM6ZmFsc2V9KX07cGljb21hdGNoLnNjYW49KGUsdCk9PnUoZSx0KTtwaWNvbWF0Y2guY29tcGlsZVJlPShlLHQscj1mYWxzZSxuPWZhbHNlKT0+e2lmKHI9PT10cnVlKXtyZXR1cm4gZS5vdXRwdXR9Y29uc3QgdT10fHx7fTtjb25zdCBzPXUuY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCBvPXUuY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgaT1gJHtzfSg/OiR7ZS5vdXRwdXR9KSR7b31gO2lmKGUmJmUubmVnYXRlZD09PXRydWUpe2k9YF4oPyEke2l9KS4qJGB9Y29uc3QgYT1waWNvbWF0Y2gudG9SZWdleChpLHQpO2lmKG49PT10cnVlKXthLnN0YXRlPWV9cmV0dXJuIGF9O3BpY29tYXRjaC5tYWtlUmU9KGUsdCxyPWZhbHNlLG49ZmFsc2UpPT57aWYoIWV8fHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1jb25zdCB1PXR8fHt9O2xldCBvPXtuZWdhdGVkOmZhbHNlLGZhc3RwYXRoczp0cnVlfTtsZXQgaT1cIlwiO2xldCBhO2lmKGUuc3RhcnRzV2l0aChcIi4vXCIpKXtlPWUuc2xpY2UoMik7aT1vLnByZWZpeD1cIi4vXCJ9aWYodS5mYXN0cGF0aHMhPT1mYWxzZSYmKGVbMF09PT1cIi5cInx8ZVswXT09PVwiKlwiKSl7YT1zLmZhc3RwYXRocyhlLHQpfWlmKGE9PT11bmRlZmluZWQpe289cyhlLHQpO28ucHJlZml4PWkrKG8ucHJlZml4fHxcIlwiKX1lbHNle28ub3V0cHV0PWF9cmV0dXJuIHBpY29tYXRjaC5jb21waWxlUmUobyx0LHIsbil9O3BpY29tYXRjaC50b1JlZ2V4PShlLHQpPT57dHJ5e2NvbnN0IHI9dHx8e307cmV0dXJuIG5ldyBSZWdFeHAoZSxyLmZsYWdzfHwoci5ub2Nhc2U/XCJpXCI6XCJcIikpfWNhdGNoKGUpe2lmKHQmJnQuZGVidWc9PT10cnVlKXRocm93IGU7cmV0dXJuLyReL319O3BpY29tYXRjaC5jb25zdGFudHM9aTtlLmV4cG9ydHM9cGljb21hdGNofSw3MDA6KGUsdCxyKT0+e2NvbnN0IG49cig1MTMpO2NvbnN0e0NIQVJfQVNURVJJU0s6dSxDSEFSX0FUOnMsQ0hBUl9CQUNLV0FSRF9TTEFTSDpvLENIQVJfQ09NTUE6aSxDSEFSX0RPVDphLENIQVJfRVhDTEFNQVRJT05fTUFSSzpsLENIQVJfRk9SV0FSRF9TTEFTSDpjLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpwLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUExVUzpSLENIQVJfUVVFU1RJT05fTUFSSzpfLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6aCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmcsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpFfT1yKDM1Nik7Y29uc3QgaXNQYXRoU2VwYXJhdG9yPWU9PmU9PT1jfHxlPT09bztjb25zdCBkZXB0aD1lPT57aWYoZS5pc1ByZWZpeCE9PXRydWUpe2UuZGVwdGg9ZS5pc0dsb2JzdGFyP0luZmluaXR5OjF9fTtjb25zdCBzY2FuPShlLHQpPT57Y29uc3Qgcj10fHx7fTtjb25zdCBDPWUubGVuZ3RoLTE7Y29uc3QgeT1yLnBhcnRzPT09dHJ1ZXx8ci5zY2FuVG9FbmQ9PT10cnVlO2NvbnN0IGQ9W107Y29uc3QgeD1bXTtjb25zdCBiPVtdO2xldCBTPWU7bGV0IEg9LTE7bGV0IHY9MDtsZXQgJD0wO2xldCBtPWZhbHNlO2xldCBUPWZhbHNlO2xldCBMPWZhbHNlO2xldCBPPWZhbHNlO2xldCB3PWZhbHNlO2xldCBOPWZhbHNlO2xldCBrPWZhbHNlO2xldCBJPWZhbHNlO2xldCBNPWZhbHNlO2xldCBQPTA7bGV0IEI7bGV0IEc7bGV0IEQ9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2NvbnN0IGVvcz0oKT0+SD49Qztjb25zdCBwZWVrPSgpPT5TLmNoYXJDb2RlQXQoSCsxKTtjb25zdCBhZHZhbmNlPSgpPT57Qj1HO3JldHVybiBTLmNoYXJDb2RlQXQoKytIKX07d2hpbGUoSDxDKXtHPWFkdmFuY2UoKTtsZXQgZTtpZihHPT09byl7az1ELmJhY2tzbGFzaGVzPXRydWU7Rz1hZHZhbmNlKCk7aWYoRz09PXApe049dHJ1ZX1jb250aW51ZX1pZihOPT09dHJ1ZXx8Rz09PXApe1ArKzt3aGlsZShlb3MoKSE9PXRydWUmJihHPWFkdmFuY2UoKSkpe2lmKEc9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoRz09PXApe1ArKztjb250aW51ZX1pZihOIT09dHJ1ZSYmRz09PWEmJihHPWFkdmFuY2UoKSk9PT1hKXttPUQuaXNCcmFjZT10cnVlO0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKE4hPT10cnVlJiZHPT09aSl7bT1ELmlzQnJhY2U9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2lmKHk9PT10cnVlKXtjb250aW51ZX1icmVha31pZihHPT09aCl7UC0tO2lmKFA9PT0wKXtOPWZhbHNlO209RC5pc0JyYWNlPXRydWU7TT10cnVlO2JyZWFrfX19aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1jKXtkLnB1c2goSCk7eC5wdXNoKEQpO0Q9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2lmKE09PT10cnVlKWNvbnRpbnVlO2lmKEI9PT1hJiZIPT09disxKXt2Kz0yO2NvbnRpbnVlfSQ9SCsxO2NvbnRpbnVlfWlmKHIubm9leHQhPT10cnVlKXtjb25zdCBlPUc9PT1SfHxHPT09c3x8Rz09PXV8fEc9PT1ffHxHPT09bDtpZihlPT09dHJ1ZSYmcGVlaygpPT09Zil7TD1ELmlzR2xvYj10cnVlO089RC5pc0V4dGdsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKEc9YWR2YW5jZSgpKSl7aWYoRz09PW8pe2s9RC5iYWNrc2xhc2hlcz10cnVlO0c9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKEc9PT1nKXtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha319aWYoRz09PXUpe2lmKEI9PT11KXc9RC5pc0dsb2JzdGFyPXRydWU7TD1ELmlzR2xvYj10cnVlO009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoRz09PV8pe0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1BKXt3aGlsZShlb3MoKSE9PXRydWUmJihlPWFkdmFuY2UoKSkpe2lmKGU9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoZT09PUUpe1Q9RC5pc0JyYWNrZXQ9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2JyZWFrfX1pZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoci5ub25lZ2F0ZSE9PXRydWUmJkc9PT1sJiZIPT09dil7ST1ELm5lZ2F0ZWQ9dHJ1ZTt2Kys7Y29udGludWV9aWYoci5ub3BhcmVuIT09dHJ1ZSYmRz09PWYpe0w9RC5pc0dsb2I9dHJ1ZTtpZih5PT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoRz1hZHZhbmNlKCkpKXtpZihHPT09Zil7az1ELmJhY2tzbGFzaGVzPXRydWU7Rz1hZHZhbmNlKCk7Y29udGludWV9aWYoRz09PWcpe009dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9aWYoTD09PXRydWUpe009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9fWlmKHIubm9leHQ9PT10cnVlKXtPPWZhbHNlO0w9ZmFsc2V9bGV0IFU9UztsZXQgSz1cIlwiO2xldCBGPVwiXCI7aWYodj4wKXtLPVMuc2xpY2UoMCx2KTtTPVMuc2xpY2Uodik7JC09dn1pZihVJiZMPT09dHJ1ZSYmJD4wKXtVPVMuc2xpY2UoMCwkKTtGPVMuc2xpY2UoJCl9ZWxzZSBpZihMPT09dHJ1ZSl7VT1cIlwiO0Y9U31lbHNle1U9U31pZihVJiZVIT09XCJcIiYmVSE9PVwiL1wiJiZVIT09Uyl7aWYoaXNQYXRoU2VwYXJhdG9yKFUuY2hhckNvZGVBdChVLmxlbmd0aC0xKSkpe1U9VS5zbGljZSgwLC0xKX19aWYoci51bmVzY2FwZT09PXRydWUpe2lmKEYpRj1uLnJlbW92ZUJhY2tzbGFzaGVzKEYpO2lmKFUmJms9PT10cnVlKXtVPW4ucmVtb3ZlQmFja3NsYXNoZXMoVSl9fWNvbnN0IFE9e3ByZWZpeDpLLGlucHV0OmUsc3RhcnQ6dixiYXNlOlUsZ2xvYjpGLGlzQnJhY2U6bSxpc0JyYWNrZXQ6VCxpc0dsb2I6TCxpc0V4dGdsb2I6Tyxpc0dsb2JzdGFyOncsbmVnYXRlZDpJfTtpZihyLnRva2Vucz09PXRydWUpe1EubWF4RGVwdGg9MDtpZighaXNQYXRoU2VwYXJhdG9yKEcpKXt4LnB1c2goRCl9US50b2tlbnM9eH1pZihyLnBhcnRzPT09dHJ1ZXx8ci50b2tlbnM9PT10cnVlKXtsZXQgdDtmb3IobGV0IG49MDtuPGQubGVuZ3RoO24rKyl7Y29uc3QgdT10P3QrMTp2O2NvbnN0IHM9ZFtuXTtjb25zdCBvPWUuc2xpY2UodSxzKTtpZihyLnRva2Vucyl7aWYobj09PTAmJnYhPT0wKXt4W25dLmlzUHJlZml4PXRydWU7eFtuXS52YWx1ZT1LfWVsc2V7eFtuXS52YWx1ZT1vfWRlcHRoKHhbbl0pO1EubWF4RGVwdGgrPXhbbl0uZGVwdGh9aWYobiE9PTB8fG8hPT1cIlwiKXtiLnB1c2gobyl9dD1zfWlmKHQmJnQrMTxlLmxlbmd0aCl7Y29uc3Qgbj1lLnNsaWNlKHQrMSk7Yi5wdXNoKG4pO2lmKHIudG9rZW5zKXt4W3gubGVuZ3RoLTFdLnZhbHVlPW47ZGVwdGgoeFt4Lmxlbmd0aC0xXSk7US5tYXhEZXB0aCs9eFt4Lmxlbmd0aC0xXS5kZXB0aH19US5zbGFzaGVzPWQ7US5wYXJ0cz1ifXJldHVybiBRfTtlLmV4cG9ydHM9c2Nhbn0sNTEzOihlLHQscik9Pntjb25zdCBuPXIoMTcpO2NvbnN0IHU9cHJvY2Vzcy5wbGF0Zm9ybT09PVwid2luMzJcIjtjb25zdHtSRUdFWF9CQUNLU0xBU0g6cyxSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOm8sUkVHRVhfU1BFQ0lBTF9DSEFSUzppLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOmF9PXIoMzU2KTt0LmlzT2JqZWN0PWU9PmUhPT1udWxsJiZ0eXBlb2YgZT09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KGUpO3QuaGFzUmVnZXhDaGFycz1lPT5pLnRlc3QoZSk7dC5pc1JlZ2V4Q2hhcj1lPT5lLmxlbmd0aD09PTEmJnQuaGFzUmVnZXhDaGFycyhlKTt0LmVzY2FwZVJlZ2V4PWU9PmUucmVwbGFjZShhLFwiXFxcXCQxXCIpO3QudG9Qb3NpeFNsYXNoZXM9ZT0+ZS5yZXBsYWNlKHMsXCIvXCIpO3QucmVtb3ZlQmFja3NsYXNoZXM9ZT0+ZS5yZXBsYWNlKG8sKGU9PmU9PT1cIlxcXFxcIj9cIlwiOmUpKTt0LnN1cHBvcnRzTG9va2JlaGluZHM9KCk9Pntjb25zdCBlPXByb2Nlc3MudmVyc2lvbi5zbGljZSgxKS5zcGxpdChcIi5cIikubWFwKE51bWJlcik7aWYoZS5sZW5ndGg9PT0zJiZlWzBdPj05fHxlWzBdPT09OCYmZVsxXT49MTApe3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dC5pc1dpbmRvd3M9ZT0+e2lmKGUmJnR5cGVvZiBlLndpbmRvd3M9PT1cImJvb2xlYW5cIil7cmV0dXJuIGUud2luZG93c31yZXR1cm4gdT09PXRydWV8fG4uc2VwPT09XCJcXFxcXCJ9O3QuZXNjYXBlTGFzdD0oZSxyLG4pPT57Y29uc3QgdT1lLmxhc3RJbmRleE9mKHIsbik7aWYodT09PS0xKXJldHVybiBlO2lmKGVbdS0xXT09PVwiXFxcXFwiKXJldHVybiB0LmVzY2FwZUxhc3QoZSxyLHUtMSk7cmV0dXJuYCR7ZS5zbGljZSgwLHUpfVxcXFwke2Uuc2xpY2UodSl9YH07dC5yZW1vdmVQcmVmaXg9KGUsdD17fSk9PntsZXQgcj1lO2lmKHIuc3RhcnRzV2l0aChcIi4vXCIpKXtyPXIuc2xpY2UoMik7dC5wcmVmaXg9XCIuL1wifXJldHVybiByfTt0LndyYXBPdXRwdXQ9KGUsdD17fSxyPXt9KT0+e2NvbnN0IG49ci5jb250YWlucz9cIlwiOlwiXlwiO2NvbnN0IHU9ci5jb250YWlucz9cIlwiOlwiJFwiO2xldCBzPWAke259KD86JHtlfSkke3V9YDtpZih0Lm5lZ2F0ZWQ9PT10cnVlKXtzPWAoPzpeKD8hJHtzfSkuKiQpYH1yZXR1cm4gc319LDQ5MjooZSx0LHIpPT57XG4vKiFcbiAqIHRvLXJlZ2V4LXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vbWljcm9tYXRjaC90by1yZWdleC1yYW5nZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmNvbnN0IG49cigzNTcpO2NvbnN0IHRvUmVnZXhSYW5nZT0oZSx0LHIpPT57aWYobihlKT09PWZhbHNlKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9SZWdleFJhbmdlOiBleHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYSBudW1iZXJcIil9aWYodD09PXZvaWQgMHx8ZT09PXQpe3JldHVybiBTdHJpbmcoZSl9aWYobih0KT09PWZhbHNlKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9SZWdleFJhbmdlOiBleHBlY3RlZCB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgbnVtYmVyLlwiKX1sZXQgdT17cmVsYXhaZXJvczp0cnVlLC4uLnJ9O2lmKHR5cGVvZiB1LnN0cmljdFplcm9zPT09XCJib29sZWFuXCIpe3UucmVsYXhaZXJvcz11LnN0cmljdFplcm9zPT09ZmFsc2V9bGV0IHM9U3RyaW5nKHUucmVsYXhaZXJvcyk7bGV0IG89U3RyaW5nKHUuc2hvcnRoYW5kKTtsZXQgaT1TdHJpbmcodS5jYXB0dXJlKTtsZXQgYT1TdHJpbmcodS53cmFwKTtsZXQgbD1lK1wiOlwiK3QrXCI9XCIrcytvK2krYTtpZih0b1JlZ2V4UmFuZ2UuY2FjaGUuaGFzT3duUHJvcGVydHkobCkpe3JldHVybiB0b1JlZ2V4UmFuZ2UuY2FjaGVbbF0ucmVzdWx0fWxldCBjPU1hdGgubWluKGUsdCk7bGV0IHA9TWF0aC5tYXgoZSx0KTtpZihNYXRoLmFicyhjLXApPT09MSl7bGV0IHI9ZStcInxcIit0O2lmKHUuY2FwdHVyZSl7cmV0dXJuYCgke3J9KWB9aWYodS53cmFwPT09ZmFsc2Upe3JldHVybiByfXJldHVybmAoPzoke3J9KWB9bGV0IGY9aGFzUGFkZGluZyhlKXx8aGFzUGFkZGluZyh0KTtsZXQgQT17bWluOmUsbWF4OnQsYTpjLGI6cH07bGV0IFI9W107bGV0IF89W107aWYoZil7QS5pc1BhZGRlZD1mO0EubWF4TGVuPVN0cmluZyhBLm1heCkubGVuZ3RofWlmKGM8MCl7bGV0IGU9cDwwP01hdGguYWJzKHApOjE7Xz1zcGxpdFRvUGF0dGVybnMoZSxNYXRoLmFicyhjKSxBLHUpO2M9QS5hPTB9aWYocD49MCl7Uj1zcGxpdFRvUGF0dGVybnMoYyxwLEEsdSl9QS5uZWdhdGl2ZXM9XztBLnBvc2l0aXZlcz1SO0EucmVzdWx0PWNvbGxhdGVQYXR0ZXJucyhfLFIsdSk7aWYodS5jYXB0dXJlPT09dHJ1ZSl7QS5yZXN1bHQ9YCgke0EucmVzdWx0fSlgfWVsc2UgaWYodS53cmFwIT09ZmFsc2UmJlIubGVuZ3RoK18ubGVuZ3RoPjEpe0EucmVzdWx0PWAoPzoke0EucmVzdWx0fSlgfXRvUmVnZXhSYW5nZS5jYWNoZVtsXT1BO3JldHVybiBBLnJlc3VsdH07ZnVuY3Rpb24gY29sbGF0ZVBhdHRlcm5zKGUsdCxyKXtsZXQgbj1maWx0ZXJQYXR0ZXJucyhlLHQsXCItXCIsZmFsc2Uscil8fFtdO2xldCB1PWZpbHRlclBhdHRlcm5zKHQsZSxcIlwiLGZhbHNlLHIpfHxbXTtsZXQgcz1maWx0ZXJQYXR0ZXJucyhlLHQsXCItP1wiLHRydWUscil8fFtdO2xldCBvPW4uY29uY2F0KHMpLmNvbmNhdCh1KTtyZXR1cm4gby5qb2luKFwifFwiKX1mdW5jdGlvbiBzcGxpdFRvUmFuZ2VzKGUsdCl7bGV0IHI9MTtsZXQgbj0xO2xldCB1PWNvdW50TmluZXMoZSxyKTtsZXQgcz1uZXcgU2V0KFt0XSk7d2hpbGUoZTw9dSYmdTw9dCl7cy5hZGQodSk7cis9MTt1PWNvdW50TmluZXMoZSxyKX11PWNvdW50WmVyb3ModCsxLG4pLTE7d2hpbGUoZTx1JiZ1PD10KXtzLmFkZCh1KTtuKz0xO3U9Y291bnRaZXJvcyh0KzEsbiktMX1zPVsuLi5zXTtzLnNvcnQoY29tcGFyZSk7cmV0dXJuIHN9ZnVuY3Rpb24gcmFuZ2VUb1BhdHRlcm4oZSx0LHIpe2lmKGU9PT10KXtyZXR1cm57cGF0dGVybjplLGNvdW50OltdLGRpZ2l0czowfX1sZXQgbj16aXAoZSx0KTtsZXQgdT1uLmxlbmd0aDtsZXQgcz1cIlwiO2xldCBvPTA7Zm9yKGxldCBlPTA7ZTx1O2UrKyl7bGV0W3QsdV09bltlXTtpZih0PT09dSl7cys9dH1lbHNlIGlmKHQhPT1cIjBcInx8dSE9PVwiOVwiKXtzKz10b0NoYXJhY3RlckNsYXNzKHQsdSxyKX1lbHNle28rK319aWYobyl7cys9ci5zaG9ydGhhbmQ9PT10cnVlP1wiXFxcXGRcIjpcIlswLTldXCJ9cmV0dXJue3BhdHRlcm46cyxjb3VudDpbb10sZGlnaXRzOnV9fWZ1bmN0aW9uIHNwbGl0VG9QYXR0ZXJucyhlLHQscixuKXtsZXQgdT1zcGxpdFRvUmFuZ2VzKGUsdCk7bGV0IHM9W107bGV0IG89ZTtsZXQgaTtmb3IobGV0IGU9MDtlPHUubGVuZ3RoO2UrKyl7bGV0IHQ9dVtlXTtsZXQgYT1yYW5nZVRvUGF0dGVybihTdHJpbmcobyksU3RyaW5nKHQpLG4pO2xldCBsPVwiXCI7aWYoIXIuaXNQYWRkZWQmJmkmJmkucGF0dGVybj09PWEucGF0dGVybil7aWYoaS5jb3VudC5sZW5ndGg+MSl7aS5jb3VudC5wb3AoKX1pLmNvdW50LnB1c2goYS5jb3VudFswXSk7aS5zdHJpbmc9aS5wYXR0ZXJuK3RvUXVhbnRpZmllcihpLmNvdW50KTtvPXQrMTtjb250aW51ZX1pZihyLmlzUGFkZGVkKXtsPXBhZFplcm9zKHQscixuKX1hLnN0cmluZz1sK2EucGF0dGVybit0b1F1YW50aWZpZXIoYS5jb3VudCk7cy5wdXNoKGEpO289dCsxO2k9YX1yZXR1cm4gc31mdW5jdGlvbiBmaWx0ZXJQYXR0ZXJucyhlLHQscixuLHUpe2xldCBzPVtdO2ZvcihsZXQgdSBvZiBlKXtsZXR7c3RyaW5nOmV9PXU7aWYoIW4mJiFjb250YWlucyh0LFwic3RyaW5nXCIsZSkpe3MucHVzaChyK2UpfWlmKG4mJmNvbnRhaW5zKHQsXCJzdHJpbmdcIixlKSl7cy5wdXNoKHIrZSl9fXJldHVybiBzfWZ1bmN0aW9uIHppcChlLHQpe2xldCByPVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXIucHVzaChbZVtuXSx0W25dXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gY29tcGFyZShlLHQpe3JldHVybiBlPnQ/MTp0PmU/LTE6MH1mdW5jdGlvbiBjb250YWlucyhlLHQscil7cmV0dXJuIGUuc29tZSgoZT0+ZVt0XT09PXIpKX1mdW5jdGlvbiBjb3VudE5pbmVzKGUsdCl7cmV0dXJuIE51bWJlcihTdHJpbmcoZSkuc2xpY2UoMCwtdCkrXCI5XCIucmVwZWF0KHQpKX1mdW5jdGlvbiBjb3VudFplcm9zKGUsdCl7cmV0dXJuIGUtZSVNYXRoLnBvdygxMCx0KX1mdW5jdGlvbiB0b1F1YW50aWZpZXIoZSl7bGV0W3Q9MCxyPVwiXCJdPWU7aWYocnx8dD4xKXtyZXR1cm5geyR7dCsocj9cIixcIityOlwiXCIpfX1gfXJldHVyblwiXCJ9ZnVuY3Rpb24gdG9DaGFyYWN0ZXJDbGFzcyhlLHQscil7cmV0dXJuYFske2V9JHt0LWU9PT0xP1wiXCI6XCItXCJ9JHt0fV1gfWZ1bmN0aW9uIGhhc1BhZGRpbmcoZSl7cmV0dXJuL14tPygwKylcXGQvLnRlc3QoZSl9ZnVuY3Rpb24gcGFkWmVyb3MoZSx0LHIpe2lmKCF0LmlzUGFkZGVkKXtyZXR1cm4gZX1sZXQgbj1NYXRoLmFicyh0Lm1heExlbi1TdHJpbmcoZSkubGVuZ3RoKTtsZXQgdT1yLnJlbGF4WmVyb3MhPT1mYWxzZTtzd2l0Y2gobil7Y2FzZSAwOnJldHVyblwiXCI7Y2FzZSAxOnJldHVybiB1P1wiMD9cIjpcIjBcIjtjYXNlIDI6cmV0dXJuIHU/XCIwezAsMn1cIjpcIjAwXCI7ZGVmYXVsdDp7cmV0dXJuIHU/YDB7MCwke259fWA6YDB7JHtufX1gfX19dG9SZWdleFJhbmdlLmNhY2hlPXt9O3RvUmVnZXhSYW5nZS5jbGVhckNhY2hlPSgpPT50b1JlZ2V4UmFuZ2UuY2FjaGU9e307ZS5leHBvcnRzPXRvUmVnZXhSYW5nZX0sMTc6ZT0+e2UuZXhwb3J0cz1yZXF1aXJlKFwicGF0aFwiKX0sODM3OmU9PntlLmV4cG9ydHM9cmVxdWlyZShcInV0aWxcIil9fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgdT10W3JdPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXtlW3JdKHUsdS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSB0W3JdfXJldHVybiB1LmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oOTcxKTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOlsiZSIsInQiLCJyIiwibiIsInUiLCJzIiwibyIsImJyYWNlcyIsIkFycmF5IiwiaXNBcnJheSIsImNyZWF0ZSIsInB1c2giLCJjb25jYXQiLCJleHBhbmQiLCJub2R1cGVzIiwiU2V0IiwicGFyc2UiLCJzdHJpbmdpZnkiLCJjb21waWxlIiwibm9lbXB0eSIsImZpbHRlciIsIkJvb2xlYW4iLCJsZW5ndGgiLCJleHBvcnRzIiwid2FsayIsImlzSW52YWxpZEJyYWNlIiwiaW52YWxpZCIsImVzY2FwZUludmFsaWQiLCJpIiwiYSIsImwiLCJpc09wZW4iLCJ2YWx1ZSIsImlzQ2xvc2UiLCJ0eXBlIiwicHJldiIsIm5vZGVzIiwicmFuZ2VzIiwicmVkdWNlIiwid3JhcCIsInRvUmVnZXgiLCJNQVhfTEVOR1RIIiwiQ0hBUl8wIiwiQ0hBUl85IiwiQ0hBUl9VUFBFUkNBU0VfQSIsIkNIQVJfTE9XRVJDQVNFX0EiLCJDSEFSX1VQUEVSQ0FTRV9aIiwiQ0hBUl9MT1dFUkNBU0VfWiIsIkNIQVJfTEVGVF9QQVJFTlRIRVNFUyIsIkNIQVJfUklHSFRfUEFSRU5USEVTRVMiLCJDSEFSX0FTVEVSSVNLIiwiQ0hBUl9BTVBFUlNBTkQiLCJDSEFSX0FUIiwiQ0hBUl9CQUNLU0xBU0giLCJDSEFSX0JBQ0tUSUNLIiwiQ0hBUl9DQVJSSUFHRV9SRVRVUk4iLCJDSEFSX0NJUkNVTUZMRVhfQUNDRU5UIiwiQ0hBUl9DT0xPTiIsIkNIQVJfQ09NTUEiLCJDSEFSX0RPTExBUiIsIkNIQVJfRE9UIiwiQ0hBUl9ET1VCTEVfUVVPVEUiLCJDSEFSX0VRVUFMIiwiQ0hBUl9FWENMQU1BVElPTl9NQVJLIiwiQ0hBUl9GT1JNX0ZFRUQiLCJDSEFSX0ZPUldBUkRfU0xBU0giLCJDSEFSX0hBU0giLCJDSEFSX0hZUEhFTl9NSU5VUyIsIkNIQVJfTEVGVF9BTkdMRV9CUkFDS0VUIiwiQ0hBUl9MRUZUX0NVUkxZX0JSQUNFIiwiQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUIiwiQ0hBUl9MSU5FX0ZFRUQiLCJDSEFSX05PX0JSRUFLX1NQQUNFIiwiQ0hBUl9QRVJDRU5UIiwiQ0hBUl9QTFVTIiwiQ0hBUl9RVUVTVElPTl9NQVJLIiwiQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUIiwiQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRSIsIkNIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQiLCJDSEFSX1NFTUlDT0xPTiIsIkNIQVJfU0lOR0xFX1FVT1RFIiwiQ0hBUl9TUEFDRSIsIkNIQVJfVEFCIiwiQ0hBUl9VTkRFUlNDT1JFIiwiQ0hBUl9WRVJUSUNBTF9MSU5FIiwiQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0UiLCJhcHBlbmQiLCJmbGF0dGVuIiwibWFwIiwicmFuZ2VMaW1pdCIsInF1ZXVlIiwicGFyZW50IiwiZG9sbGFyIiwicG9wIiwiZXhjZWVkc0xpbWl0Iiwic3RlcCIsIlJhbmdlRXJyb3IiLCJlbmNsb3NlQnJhY2UiLCJjIiwicCIsImYiLCJBIiwiUiIsIl8iLCJoIiwiZyIsIkUiLCJUeXBlRXJyb3IiLCJDIiwibWF4TGVuZ3RoIiwiTWF0aCIsIm1pbiIsIlN5bnRheEVycm9yIiwieSIsImlucHV0IiwiZCIsIngiLCJiIiwiUyIsIkgiLCJ2IiwiJCIsIm0iLCJUIiwiYWR2YW5jZSIsImtlZXBFc2NhcGluZyIsImtlZXBRdW90ZXMiLCJzbGljZSIsIm9wZW4iLCJjbG9zZSIsImRlcHRoIiwiY29tbWFzIiwic2hpZnQiLCJyYW5nZSIsImFyZ3MiLCJmb3JFYWNoIiwiaW5kZXhPZiIsInNwbGljZSIsImlzT3Blbk9yQ2xvc2UiLCJpc0ludGVnZXIiLCJOdW1iZXIiLCJ0cmltIiwiZmluZCIsImVzY2FwZU5vZGUiLCJlc2NhcGVkIiwiZmxhdCIsImlzT2JqZWN0IiwidHJhbnNmb3JtIiwiU3RyaW5nIiwiaXNWYWxpZFZhbHVlIiwiaXNOdW1iZXIiLCJ6ZXJvcyIsInBhZCIsInBhZFN0YXJ0IiwidG9NYXhMZW4iLCJ0b1NlcXVlbmNlIiwibmVnYXRpdmVzIiwic29ydCIsInBvc2l0aXZlcyIsImNhcHR1cmUiLCJqb2luIiwidG9SYW5nZSIsImZyb21DaGFyQ29kZSIsInJhbmdlRXJyb3IiLCJpbnNwZWN0IiwiaW52YWxpZFJhbmdlIiwic3RyaWN0UmFuZ2VzIiwiaW52YWxpZFN0ZXAiLCJmaWxsTnVtYmVycyIsIm1heCIsImFicyIsImZpbGxMZXR0ZXJzIiwiY2hhckNvZGVBdCIsIm9wdGlvbnMiLCJmaWxsIiwiaXNGaW5pdGUiLCJpc0VtcHR5U3RyaW5nIiwibWljcm9tYXRjaCIsIm9uUmVzdWx0IiwiYWRkIiwib3V0cHV0Iiwic3RhdGUiLCJuZWdhdGVkIiwibmVnYXRlZEV4dGdsb2IiLCJpc01hdGNoIiwiZGVsZXRlIiwiaGFzIiwiZmFpbGdsb2IiLCJFcnJvciIsIm5vbnVsbCIsIm51bGxnbG9iIiwidW5lc2NhcGUiLCJyZXBsYWNlIiwibWF0Y2giLCJtYXRjaGVyIiwiYW55Iiwibm90IiwiaW5jbHVkZXMiLCJjb250YWlucyIsInNvbWUiLCJzdGFydHNXaXRoIiwibWF0Y2hLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImV2ZXJ5IiwiYWxsIiwiaXNXaW5kb3dzIiwibWFrZVJlIiwiZXhlYyIsInRvUG9zaXhTbGFzaGVzIiwic2NhbiIsIm5vYnJhY2UiLCJ0ZXN0IiwiYnJhY2VFeHBhbmQiLCJET1RfTElURVJBTCIsIlBMVVNfTElURVJBTCIsIlFNQVJLX0xJVEVSQUwiLCJTTEFTSF9MSVRFUkFMIiwiT05FX0NIQVIiLCJRTUFSSyIsIkVORF9BTkNIT1IiLCJET1RTX1NMQVNIIiwiTk9fRE9UIiwiTk9fRE9UUyIsIk5PX0RPVF9TTEFTSCIsIk5PX0RPVFNfU0xBU0giLCJRTUFSS19OT19ET1QiLCJTVEFSIiwiU1RBUlRfQU5DSE9SIiwiYWxudW0iLCJhbHBoYSIsImFzY2lpIiwiYmxhbmsiLCJjbnRybCIsImRpZ2l0IiwiZ3JhcGgiLCJsb3dlciIsInByaW50IiwicHVuY3QiLCJzcGFjZSIsInVwcGVyIiwid29yZCIsInhkaWdpdCIsIlBPU0lYX1JFR0VYX1NPVVJDRSIsIlJFR0VYX0JBQ0tTTEFTSCIsIlJFR0VYX05PTl9TUEVDSUFMX0NIQVJTIiwiUkVHRVhfU1BFQ0lBTF9DSEFSUyIsIlJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRiIsIlJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMIiwiUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSCIsIlJFUExBQ0VNRU5UUyIsIkNIQVJfQkFDS1dBUkRfU0xBU0giLCJDSEFSX0dSQVZFX0FDQ0VOVCIsIlNFUCIsInNlcCIsImV4dGdsb2JDaGFycyIsImdsb2JDaGFycyIsImV4cGFuZFJhbmdlIiwiUmVnRXhwIiwiZXNjYXBlUmVnZXgiLCJzeW50YXhFcnJvciIsInByZXBlbmQiLCJnbG9ic3RhciIsImRvdCIsIkwiLCJPIiwidyIsImJhc2giLCJub2V4dCIsIm5vZXh0Z2xvYiIsIk4iLCJpbmRleCIsInN0YXJ0IiwiY29uc3VtZWQiLCJwcmVmaXgiLCJiYWNrdHJhY2siLCJicmFja2V0cyIsInBhcmVucyIsInF1b3RlcyIsInRva2VucyIsInJlbW92ZVByZWZpeCIsImsiLCJJIiwiTSIsIlAiLCJCIiwiZW9zIiwiRyIsInBlZWsiLCJEIiwicmVtYWluaW5nIiwiY29uc3VtZSIsIm5lZ2F0ZSIsImluY3JlbWVudCIsImRlY3JlbWVudCIsImV4dGdsb2IiLCJpbm5lciIsImV4dGdsb2JPcGVuIiwiY29uZGl0aW9ucyIsImV4dGdsb2JDbG9zZSIsImZhc3RwYXRocyIsInJlcGVhdCIsIndyYXBPdXRwdXQiLCJwb3NpeCIsImxhc3RJbmRleE9mIiwic3RyaWN0QnJhY2tldHMiLCJub2JyYWNrZXQiLCJsaXRlcmFsQnJhY2tldHMiLCJoYXNSZWdleENoYXJzIiwib3V0cHV0SW5kZXgiLCJ0b2tlbnNJbmRleCIsImRvdHMiLCJ1bnNoaWZ0IiwiY29tbWEiLCJzdXBwb3J0c0xvb2tiZWhpbmRzIiwibm9uZWdhdGUiLCJyZWdleCIsInN0YXIiLCJub2dsb2JzdGFyIiwic3RyaWN0U2xhc2hlcyIsImVzY2FwZUxhc3QiLCJzdWZmaXgiLCJwaWNvbWF0Y2giLCJhcnJheU1hdGNoZXIiLCJjb21waWxlUmUiLCJpc0lnbm9yZWQiLCJpZ25vcmUiLCJvbk1hdGNoIiwiZ2xvYiIsIm9uSWdub3JlIiwiZm9ybWF0IiwibWF0Y2hCYXNlIiwiYmFzZW5hbWUiLCJ1bmRlZmluZWQiLCJmbGFncyIsIm5vY2FzZSIsImRlYnVnIiwiY29uc3RhbnRzIiwiaXNQYXRoU2VwYXJhdG9yIiwiaXNQcmVmaXgiLCJpc0dsb2JzdGFyIiwiSW5maW5pdHkiLCJwYXJ0cyIsInNjYW5Ub0VuZCIsImlzR2xvYiIsImJhY2tzbGFzaGVzIiwiaXNCcmFjZSIsImlzRXh0Z2xvYiIsImlzQnJhY2tldCIsIm5vcGFyZW4iLCJVIiwiSyIsIkYiLCJyZW1vdmVCYWNrc2xhc2hlcyIsIlEiLCJiYXNlIiwibWF4RGVwdGgiLCJzbGFzaGVzIiwicHJvY2VzcyIsInBsYXRmb3JtIiwiaXNSZWdleENoYXIiLCJ2ZXJzaW9uIiwic3BsaXQiLCJ3aW5kb3dzIiwidG9SZWdleFJhbmdlIiwicmVsYXhaZXJvcyIsInN0cmljdFplcm9zIiwic2hvcnRoYW5kIiwiY2FjaGUiLCJoYXNPd25Qcm9wZXJ0eSIsInJlc3VsdCIsImhhc1BhZGRpbmciLCJpc1BhZGRlZCIsIm1heExlbiIsInNwbGl0VG9QYXR0ZXJucyIsImNvbGxhdGVQYXR0ZXJucyIsImZpbHRlclBhdHRlcm5zIiwic3BsaXRUb1JhbmdlcyIsImNvdW50TmluZXMiLCJjb3VudFplcm9zIiwiY29tcGFyZSIsInJhbmdlVG9QYXR0ZXJuIiwicGF0dGVybiIsImNvdW50IiwiZGlnaXRzIiwiemlwIiwidG9DaGFyYWN0ZXJDbGFzcyIsInN0cmluZyIsInRvUXVhbnRpZmllciIsInBhZFplcm9zIiwicG93IiwiY2xlYXJDYWNoZSIsInJlcXVpcmUiLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/micromatch/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-browserify/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-browserify/index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function () {\n  \"use strict\";\n\n  var e = {\n    114: function (e) {\n      function assertPath(e) {\n        if (typeof e !== \"string\") {\n          throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(e));\n        }\n      }\n\n      function normalizeStringPosix(e, r) {\n        var t = \"\";\n        var i = 0;\n        var n = -1;\n        var a = 0;\n        var f;\n\n        for (var l = 0; l <= e.length; ++l) {\n          if (l < e.length) f = e.charCodeAt(l);else if (f === 47) break;else f = 47;\n\n          if (f === 47) {\n            if (n === l - 1 || a === 1) {} else if (n !== l - 1 && a === 2) {\n              if (t.length < 2 || i !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {\n                if (t.length > 2) {\n                  var s = t.lastIndexOf(\"/\");\n\n                  if (s !== t.length - 1) {\n                    if (s === -1) {\n                      t = \"\";\n                      i = 0;\n                    } else {\n                      t = t.slice(0, s);\n                      i = t.length - 1 - t.lastIndexOf(\"/\");\n                    }\n\n                    n = l;\n                    a = 0;\n                    continue;\n                  }\n                } else if (t.length === 2 || t.length === 1) {\n                  t = \"\";\n                  i = 0;\n                  n = l;\n                  a = 0;\n                  continue;\n                }\n              }\n\n              if (r) {\n                if (t.length > 0) t += \"/..\";else t = \"..\";\n                i = 2;\n              }\n            } else {\n              if (t.length > 0) t += \"/\" + e.slice(n + 1, l);else t = e.slice(n + 1, l);\n              i = l - n - 1;\n            }\n\n            n = l;\n            a = 0;\n          } else if (f === 46 && a !== -1) {\n            ++a;\n          } else {\n            a = -1;\n          }\n        }\n\n        return t;\n      }\n\n      function _format(e, r) {\n        var t = r.dir || r.root;\n        var i = r.base || (r.name || \"\") + (r.ext || \"\");\n\n        if (!t) {\n          return i;\n        }\n\n        if (t === r.root) {\n          return t + i;\n        }\n\n        return t + e + i;\n      }\n\n      var r = {\n        resolve: function resolve() {\n          var e = \"\";\n          var r = false;\n          var t;\n\n          for (var i = arguments.length - 1; i >= -1 && !r; i--) {\n            var n;\n            if (i >= 0) n = arguments[i];else {\n              if (t === undefined) t = \"\";\n              n = t;\n            }\n            assertPath(n);\n\n            if (n.length === 0) {\n              continue;\n            }\n\n            e = n + \"/\" + e;\n            r = n.charCodeAt(0) === 47;\n          }\n\n          e = normalizeStringPosix(e, !r);\n\n          if (r) {\n            if (e.length > 0) return \"/\" + e;else return \"/\";\n          } else if (e.length > 0) {\n            return e;\n          } else {\n            return \".\";\n          }\n        },\n        normalize: function normalize(e) {\n          assertPath(e);\n          if (e.length === 0) return \".\";\n          var r = e.charCodeAt(0) === 47;\n          var t = e.charCodeAt(e.length - 1) === 47;\n          e = normalizeStringPosix(e, !r);\n          if (e.length === 0 && !r) e = \".\";\n          if (e.length > 0 && t) e += \"/\";\n          if (r) return \"/\" + e;\n          return e;\n        },\n        isAbsolute: function isAbsolute(e) {\n          assertPath(e);\n          return e.length > 0 && e.charCodeAt(0) === 47;\n        },\n        join: function join() {\n          if (arguments.length === 0) return \".\";\n          var e;\n\n          for (var t = 0; t < arguments.length; ++t) {\n            var i = arguments[t];\n            assertPath(i);\n\n            if (i.length > 0) {\n              if (e === undefined) e = i;else e += \"/\" + i;\n            }\n          }\n\n          if (e === undefined) return \".\";\n          return r.normalize(e);\n        },\n        relative: function relative(e, t) {\n          assertPath(e);\n          assertPath(t);\n          if (e === t) return \"\";\n          e = r.resolve(e);\n          t = r.resolve(t);\n          if (e === t) return \"\";\n          var i = 1;\n\n          for (; i < e.length; ++i) {\n            if (e.charCodeAt(i) !== 47) break;\n          }\n\n          var n = e.length;\n          var a = n - i;\n          var f = 1;\n\n          for (; f < t.length; ++f) {\n            if (t.charCodeAt(f) !== 47) break;\n          }\n\n          var l = t.length;\n          var s = l - f;\n          var o = a < s ? a : s;\n          var u = -1;\n          var h = 0;\n\n          for (; h <= o; ++h) {\n            if (h === o) {\n              if (s > o) {\n                if (t.charCodeAt(f + h) === 47) {\n                  return t.slice(f + h + 1);\n                } else if (h === 0) {\n                  return t.slice(f + h);\n                }\n              } else if (a > o) {\n                if (e.charCodeAt(i + h) === 47) {\n                  u = h;\n                } else if (h === 0) {\n                  u = 0;\n                }\n              }\n\n              break;\n            }\n\n            var c = e.charCodeAt(i + h);\n            var v = t.charCodeAt(f + h);\n            if (c !== v) break;else if (c === 47) u = h;\n          }\n\n          var g = \"\";\n\n          for (h = i + u + 1; h <= n; ++h) {\n            if (h === n || e.charCodeAt(h) === 47) {\n              if (g.length === 0) g += \"..\";else g += \"/..\";\n            }\n          }\n\n          if (g.length > 0) return g + t.slice(f + u);else {\n            f += u;\n            if (t.charCodeAt(f) === 47) ++f;\n            return t.slice(f);\n          }\n        },\n        _makeLong: function _makeLong(e) {\n          return e;\n        },\n        dirname: function dirname(e) {\n          assertPath(e);\n          if (e.length === 0) return \".\";\n          var r = e.charCodeAt(0);\n          var t = r === 47;\n          var i = -1;\n          var n = true;\n\n          for (var a = e.length - 1; a >= 1; --a) {\n            r = e.charCodeAt(a);\n\n            if (r === 47) {\n              if (!n) {\n                i = a;\n                break;\n              }\n            } else {\n              n = false;\n            }\n          }\n\n          if (i === -1) return t ? \"/\" : \".\";\n          if (t && i === 1) return \"//\";\n          return e.slice(0, i);\n        },\n        basename: function basename(e, r) {\n          if (r !== undefined && typeof r !== \"string\") throw new TypeError('\"ext\" argument must be a string');\n          assertPath(e);\n          var t = 0;\n          var i = -1;\n          var n = true;\n          var a;\n\n          if (r !== undefined && r.length > 0 && r.length <= e.length) {\n            if (r.length === e.length && r === e) return \"\";\n            var f = r.length - 1;\n            var l = -1;\n\n            for (a = e.length - 1; a >= 0; --a) {\n              var s = e.charCodeAt(a);\n\n              if (s === 47) {\n                if (!n) {\n                  t = a + 1;\n                  break;\n                }\n              } else {\n                if (l === -1) {\n                  n = false;\n                  l = a + 1;\n                }\n\n                if (f >= 0) {\n                  if (s === r.charCodeAt(f)) {\n                    if (--f === -1) {\n                      i = a;\n                    }\n                  } else {\n                    f = -1;\n                    i = l;\n                  }\n                }\n              }\n            }\n\n            if (t === i) i = l;else if (i === -1) i = e.length;\n            return e.slice(t, i);\n          } else {\n            for (a = e.length - 1; a >= 0; --a) {\n              if (e.charCodeAt(a) === 47) {\n                if (!n) {\n                  t = a + 1;\n                  break;\n                }\n              } else if (i === -1) {\n                n = false;\n                i = a + 1;\n              }\n            }\n\n            if (i === -1) return \"\";\n            return e.slice(t, i);\n          }\n        },\n        extname: function extname(e) {\n          assertPath(e);\n          var r = -1;\n          var t = 0;\n          var i = -1;\n          var n = true;\n          var a = 0;\n\n          for (var f = e.length - 1; f >= 0; --f) {\n            var l = e.charCodeAt(f);\n\n            if (l === 47) {\n              if (!n) {\n                t = f + 1;\n                break;\n              }\n\n              continue;\n            }\n\n            if (i === -1) {\n              n = false;\n              i = f + 1;\n            }\n\n            if (l === 46) {\n              if (r === -1) r = f;else if (a !== 1) a = 1;\n            } else if (r !== -1) {\n              a = -1;\n            }\n          }\n\n          if (r === -1 || i === -1 || a === 0 || a === 1 && r === i - 1 && r === t + 1) {\n            return \"\";\n          }\n\n          return e.slice(r, i);\n        },\n        format: function format(e) {\n          if (e === null || typeof e !== \"object\") {\n            throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof e);\n          }\n\n          return _format(\"/\", e);\n        },\n        parse: function parse(e) {\n          assertPath(e);\n          var r = {\n            root: \"\",\n            dir: \"\",\n            base: \"\",\n            ext: \"\",\n            name: \"\"\n          };\n          if (e.length === 0) return r;\n          var t = e.charCodeAt(0);\n          var i = t === 47;\n          var n;\n\n          if (i) {\n            r.root = \"/\";\n            n = 1;\n          } else {\n            n = 0;\n          }\n\n          var a = -1;\n          var f = 0;\n          var l = -1;\n          var s = true;\n          var o = e.length - 1;\n          var u = 0;\n\n          for (; o >= n; --o) {\n            t = e.charCodeAt(o);\n\n            if (t === 47) {\n              if (!s) {\n                f = o + 1;\n                break;\n              }\n\n              continue;\n            }\n\n            if (l === -1) {\n              s = false;\n              l = o + 1;\n            }\n\n            if (t === 46) {\n              if (a === -1) a = o;else if (u !== 1) u = 1;\n            } else if (a !== -1) {\n              u = -1;\n            }\n          }\n\n          if (a === -1 || l === -1 || u === 0 || u === 1 && a === l - 1 && a === f + 1) {\n            if (l !== -1) {\n              if (f === 0 && i) r.base = r.name = e.slice(1, l);else r.base = r.name = e.slice(f, l);\n            }\n          } else {\n            if (f === 0 && i) {\n              r.name = e.slice(1, a);\n              r.base = e.slice(1, l);\n            } else {\n              r.name = e.slice(f, a);\n              r.base = e.slice(f, l);\n            }\n\n            r.ext = e.slice(a, l);\n          }\n\n          if (f > 0) r.dir = e.slice(0, f - 1);else if (i) r.dir = \"/\";\n          return r;\n        },\n        sep: \"/\",\n        delimiter: \":\",\n        win32: null,\n        posix: null\n      };\n      r.posix = r;\n      e.exports = r;\n    }\n  };\n  var r = {};\n\n  function __nccwpck_require__(t) {\n    var i = r[t];\n\n    if (i !== undefined) {\n      return i.exports;\n    }\n\n    var n = r[t] = {\n      exports: {}\n    };\n    var a = true;\n\n    try {\n      e[t](n, n.exports, __nccwpck_require__);\n      a = false;\n    } finally {\n      if (a) delete r[t];\n    }\n\n    return n.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var t = __nccwpck_require__(114);\n\n  module.exports = t;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsQ0FBQyxZQUFVO0VBQUM7O0VBQWEsSUFBSUEsQ0FBQyxHQUFDO0lBQUMsS0FBSSxVQUFTQSxDQUFULEVBQVc7TUFBQyxTQUFTQyxVQUFULENBQW9CRCxDQUFwQixFQUFzQjtRQUFDLElBQUcsT0FBT0EsQ0FBUCxLQUFXLFFBQWQsRUFBdUI7VUFBQyxNQUFNLElBQUlFLFNBQUosQ0FBYyxxQ0FBbUNDLElBQUksQ0FBQ0MsU0FBTCxDQUFlSixDQUFmLENBQWpELENBQU47UUFBMEU7TUFBQzs7TUFBQSxTQUFTSyxvQkFBVCxDQUE4QkwsQ0FBOUIsRUFBZ0NNLENBQWhDLEVBQWtDO1FBQUMsSUFBSUMsQ0FBQyxHQUFDLEVBQU47UUFBUyxJQUFJQyxDQUFDLEdBQUMsQ0FBTjtRQUFRLElBQUlDLENBQUMsR0FBQyxDQUFDLENBQVA7UUFBUyxJQUFJQyxDQUFDLEdBQUMsQ0FBTjtRQUFRLElBQUlDLENBQUo7O1FBQU0sS0FBSSxJQUFJQyxDQUFDLEdBQUMsQ0FBVixFQUFZQSxDQUFDLElBQUVaLENBQUMsQ0FBQ2EsTUFBakIsRUFBd0IsRUFBRUQsQ0FBMUIsRUFBNEI7VUFBQyxJQUFHQSxDQUFDLEdBQUNaLENBQUMsQ0FBQ2EsTUFBUCxFQUFjRixDQUFDLEdBQUNYLENBQUMsQ0FBQ2MsVUFBRixDQUFhRixDQUFiLENBQUYsQ0FBZCxLQUFxQyxJQUFHRCxDQUFDLEtBQUcsRUFBUCxFQUFVLE1BQVYsS0FBcUJBLENBQUMsR0FBQyxFQUFGOztVQUFLLElBQUdBLENBQUMsS0FBRyxFQUFQLEVBQVU7WUFBQyxJQUFHRixDQUFDLEtBQUdHLENBQUMsR0FBQyxDQUFOLElBQVNGLENBQUMsS0FBRyxDQUFoQixFQUFrQixDQUFFLENBQXBCLE1BQXlCLElBQUdELENBQUMsS0FBR0csQ0FBQyxHQUFDLENBQU4sSUFBU0YsQ0FBQyxLQUFHLENB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QUssRUFBQyxJQUFoNUg7UUFBcTVIQyxLQUFLLEVBQUM7TUFBMzVILENBQU47TUFBdTZIeEMsQ0FBQyxDQUFDd0MsS0FBRixHQUFReEMsQ0FBUjtNQUFVTixDQUFDLENBQUMrQyxPQUFGLEdBQVV6QyxDQUFWO0lBQVk7RUFBbjRKLENBQU47RUFBMjRKLElBQUlBLENBQUMsR0FBQyxFQUFOOztFQUFTLFNBQVMwQyxtQkFBVCxDQUE2QnpDLENBQTdCLEVBQStCO0lBQUMsSUFBSUMsQ0FBQyxHQUFDRixDQUFDLENBQUNDLENBQUQsQ0FBUDs7SUFBVyxJQUFHQyxDQUFDLEtBQUdrQixTQUFQLEVBQWlCO01BQUMsT0FBT2xCLENBQUMsQ0FBQ3VDLE9BQVQ7SUFBaUI7O0lBQUEsSUFBSXRDLENBQUMsR0FBQ0gsQ0FBQyxDQUFDQyxDQUFELENBQUQsR0FBSztNQUFDd0MsT0FBTyxFQUFDO0lBQVQsQ0FBWDtJQUF3QixJQUFJckMsQ0FBQyxHQUFDLElBQU47O0lBQVcsSUFBRztNQUFDVixDQUFDLENBQUNPLENBQUQsQ0FBRCxDQUFLRSxDQUFMLEVBQU9BLENBQUMsQ0FBQ3NDLE9BQVQsRUFBaUJDLG1CQUFqQjtNQUFzQ3RDLENBQUMsR0FBQyxLQUFGO0lBQVEsQ0FBbEQsU0FBeUQ7TUFBQyxJQUFHQSxDQUFILEVBQUssT0FBT0osQ0FBQyxDQUFDQyxDQUFELENBQVI7SUFBWTs7SUFBQSxPQUFPRSxDQUFDLENBQUNzQyxPQUFUO0VBQWlCOztFQUFBLElBQUcsT0FBT0MsbUJBQVAsS0FBNkIsV0FBaEMsRUFBNENBLG1CQUFtQixDQUFDQyxFQUFwQixHQUF1QkMsU0FBUyxHQUFDLEdBQWpDOztFQUFxQyxJQUFJM0MsQ0FBQyxHQUFDeUMsbUJBQW1CLENBQUMsR0FBRCxDQUF6Qjs7RUFBK0JHLE1BQU0sQ0FBQ0osT0FBUCxHQUFleEMsQ0FBZjtBQUFpQixDQUEzdksiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanM/M2NkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT17MTE0OmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGFzc2VydFBhdGgoZSl7aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShlKSl9fWZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KGUscil7dmFyIHQ9XCJcIjt2YXIgaT0wO3ZhciBuPS0xO3ZhciBhPTA7dmFyIGY7Zm9yKHZhciBsPTA7bDw9ZS5sZW5ndGg7KytsKXtpZihsPGUubGVuZ3RoKWY9ZS5jaGFyQ29kZUF0KGwpO2Vsc2UgaWYoZj09PTQ3KWJyZWFrO2Vsc2UgZj00NztpZihmPT09NDcpe2lmKG49PT1sLTF8fGE9PT0xKXt9ZWxzZSBpZihuIT09bC0xJiZhPT09Mil7aWYodC5sZW5ndGg8Mnx8aSE9PTJ8fHQuY2hhckNvZGVBdCh0Lmxlbmd0aC0xKSE9PTQ2fHx0LmNoYXJDb2RlQXQodC5sZW5ndGgtMikhPT00Nil7aWYodC5sZW5ndGg+Mil7dmFyIHM9dC5sYXN0SW5kZXhPZihcIi9cIik7aWYocyE9PXQubGVuZ3RoLTEpe2lmKHM9PT0tMSl7dD1cIlwiO2k9MH1lbHNle3Q9dC5zbGljZSgwLHMpO2k9dC5sZW5ndGgtMS10Lmxhc3RJbmRleE9mKFwiL1wiKX1uPWw7YT0wO2NvbnRpbnVlfX1lbHNlIGlmKHQubGVuZ3RoPT09Mnx8dC5sZW5ndGg9PT0xKXt0PVwiXCI7aT0wO249bDthPTA7Y29udGludWV9fWlmKHIpe2lmKHQubGVuZ3RoPjApdCs9XCIvLi5cIjtlbHNlIHQ9XCIuLlwiO2k9Mn19ZWxzZXtpZih0Lmxlbmd0aD4wKXQrPVwiL1wiK2Uuc2xpY2UobisxLGwpO2Vsc2UgdD1lLnNsaWNlKG4rMSxsKTtpPWwtbi0xfW49bDthPTB9ZWxzZSBpZihmPT09NDYmJmEhPT0tMSl7KythfWVsc2V7YT0tMX19cmV0dXJuIHR9ZnVuY3Rpb24gX2Zvcm1hdChlLHIpe3ZhciB0PXIuZGlyfHxyLnJvb3Q7dmFyIGk9ci5iYXNlfHwoci5uYW1lfHxcIlwiKSsoci5leHR8fFwiXCIpO2lmKCF0KXtyZXR1cm4gaX1pZih0PT09ci5yb290KXtyZXR1cm4gdCtpfXJldHVybiB0K2UraX12YXIgcj17cmVzb2x2ZTpmdW5jdGlvbiByZXNvbHZlKCl7dmFyIGU9XCJcIjt2YXIgcj1mYWxzZTt2YXIgdDtmb3IodmFyIGk9YXJndW1lbnRzLmxlbmd0aC0xO2k+PS0xJiYhcjtpLS0pe3ZhciBuO2lmKGk+PTApbj1hcmd1bWVudHNbaV07ZWxzZXtpZih0PT09dW5kZWZpbmVkKXQ9XCJcIjtuPXR9YXNzZXJ0UGF0aChuKTtpZihuLmxlbmd0aD09PTApe2NvbnRpbnVlfWU9bitcIi9cIitlO3I9bi5jaGFyQ29kZUF0KDApPT09NDd9ZT1ub3JtYWxpemVTdHJpbmdQb3NpeChlLCFyKTtpZihyKXtpZihlLmxlbmd0aD4wKXJldHVyblwiL1wiK2U7ZWxzZSByZXR1cm5cIi9cIn1lbHNlIGlmKGUubGVuZ3RoPjApe3JldHVybiBlfWVsc2V7cmV0dXJuXCIuXCJ9fSxub3JtYWxpemU6ZnVuY3Rpb24gbm9ybWFsaXplKGUpe2Fzc2VydFBhdGgoZSk7aWYoZS5sZW5ndGg9PT0wKXJldHVyblwiLlwiO3ZhciByPWUuY2hhckNvZGVBdCgwKT09PTQ3O3ZhciB0PWUuY2hhckNvZGVBdChlLmxlbmd0aC0xKT09PTQ3O2U9bm9ybWFsaXplU3RyaW5nUG9zaXgoZSwhcik7aWYoZS5sZW5ndGg9PT0wJiYhcillPVwiLlwiO2lmKGUubGVuZ3RoPjAmJnQpZSs9XCIvXCI7aWYocilyZXR1cm5cIi9cIitlO3JldHVybiBlfSxpc0Fic29sdXRlOmZ1bmN0aW9uIGlzQWJzb2x1dGUoZSl7YXNzZXJ0UGF0aChlKTtyZXR1cm4gZS5sZW5ndGg+MCYmZS5jaGFyQ29kZUF0KDApPT09NDd9LGpvaW46ZnVuY3Rpb24gam9pbigpe2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0wKXJldHVyblwiLlwiO3ZhciBlO2Zvcih2YXIgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDsrK3Qpe3ZhciBpPWFyZ3VtZW50c1t0XTthc3NlcnRQYXRoKGkpO2lmKGkubGVuZ3RoPjApe2lmKGU9PT11bmRlZmluZWQpZT1pO2Vsc2UgZSs9XCIvXCIraX19aWYoZT09PXVuZGVmaW5lZClyZXR1cm5cIi5cIjtyZXR1cm4gci5ub3JtYWxpemUoZSl9LHJlbGF0aXZlOmZ1bmN0aW9uIHJlbGF0aXZlKGUsdCl7YXNzZXJ0UGF0aChlKTthc3NlcnRQYXRoKHQpO2lmKGU9PT10KXJldHVyblwiXCI7ZT1yLnJlc29sdmUoZSk7dD1yLnJlc29sdmUodCk7aWYoZT09PXQpcmV0dXJuXCJcIjt2YXIgaT0xO2Zvcig7aTxlLmxlbmd0aDsrK2kpe2lmKGUuY2hhckNvZGVBdChpKSE9PTQ3KWJyZWFrfXZhciBuPWUubGVuZ3RoO3ZhciBhPW4taTt2YXIgZj0xO2Zvcig7Zjx0Lmxlbmd0aDsrK2Ype2lmKHQuY2hhckNvZGVBdChmKSE9PTQ3KWJyZWFrfXZhciBsPXQubGVuZ3RoO3ZhciBzPWwtZjt2YXIgbz1hPHM/YTpzO3ZhciB1PS0xO3ZhciBoPTA7Zm9yKDtoPD1vOysraCl7aWYoaD09PW8pe2lmKHM+byl7aWYodC5jaGFyQ29kZUF0KGYraCk9PT00Nyl7cmV0dXJuIHQuc2xpY2UoZitoKzEpfWVsc2UgaWYoaD09PTApe3JldHVybiB0LnNsaWNlKGYraCl9fWVsc2UgaWYoYT5vKXtpZihlLmNoYXJDb2RlQXQoaStoKT09PTQ3KXt1PWh9ZWxzZSBpZihoPT09MCl7dT0wfX1icmVha312YXIgYz1lLmNoYXJDb2RlQXQoaStoKTt2YXIgdj10LmNoYXJDb2RlQXQoZitoKTtpZihjIT09dilicmVhaztlbHNlIGlmKGM9PT00Nyl1PWh9dmFyIGc9XCJcIjtmb3IoaD1pK3UrMTtoPD1uOysraCl7aWYoaD09PW58fGUuY2hhckNvZGVBdChoKT09PTQ3KXtpZihnLmxlbmd0aD09PTApZys9XCIuLlwiO2Vsc2UgZys9XCIvLi5cIn19aWYoZy5sZW5ndGg+MClyZXR1cm4gZyt0LnNsaWNlKGYrdSk7ZWxzZXtmKz11O2lmKHQuY2hhckNvZGVBdChmKT09PTQ3KSsrZjtyZXR1cm4gdC5zbGljZShmKX19LF9tYWtlTG9uZzpmdW5jdGlvbiBfbWFrZUxvbmcoZSl7cmV0dXJuIGV9LGRpcm5hbWU6ZnVuY3Rpb24gZGlybmFtZShlKXthc3NlcnRQYXRoKGUpO2lmKGUubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgcj1lLmNoYXJDb2RlQXQoMCk7dmFyIHQ9cj09PTQ3O3ZhciBpPS0xO3ZhciBuPXRydWU7Zm9yKHZhciBhPWUubGVuZ3RoLTE7YT49MTstLWEpe3I9ZS5jaGFyQ29kZUF0KGEpO2lmKHI9PT00Nyl7aWYoIW4pe2k9YTticmVha319ZWxzZXtuPWZhbHNlfX1pZihpPT09LTEpcmV0dXJuIHQ/XCIvXCI6XCIuXCI7aWYodCYmaT09PTEpcmV0dXJuXCIvL1wiO3JldHVybiBlLnNsaWNlKDAsaSl9LGJhc2VuYW1lOmZ1bmN0aW9uIGJhc2VuYW1lKGUscil7aWYociE9PXVuZGVmaW5lZCYmdHlwZW9mIHIhPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXh0XCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO2Fzc2VydFBhdGgoZSk7dmFyIHQ9MDt2YXIgaT0tMTt2YXIgbj10cnVlO3ZhciBhO2lmKHIhPT11bmRlZmluZWQmJnIubGVuZ3RoPjAmJnIubGVuZ3RoPD1lLmxlbmd0aCl7aWYoci5sZW5ndGg9PT1lLmxlbmd0aCYmcj09PWUpcmV0dXJuXCJcIjt2YXIgZj1yLmxlbmd0aC0xO3ZhciBsPS0xO2ZvcihhPWUubGVuZ3RoLTE7YT49MDstLWEpe3ZhciBzPWUuY2hhckNvZGVBdChhKTtpZihzPT09NDcpe2lmKCFuKXt0PWErMTticmVha319ZWxzZXtpZihsPT09LTEpe249ZmFsc2U7bD1hKzF9aWYoZj49MCl7aWYocz09PXIuY2hhckNvZGVBdChmKSl7aWYoLS1mPT09LTEpe2k9YX19ZWxzZXtmPS0xO2k9bH19fX1pZih0PT09aSlpPWw7ZWxzZSBpZihpPT09LTEpaT1lLmxlbmd0aDtyZXR1cm4gZS5zbGljZSh0LGkpfWVsc2V7Zm9yKGE9ZS5sZW5ndGgtMTthPj0wOy0tYSl7aWYoZS5jaGFyQ29kZUF0KGEpPT09NDcpe2lmKCFuKXt0PWErMTticmVha319ZWxzZSBpZihpPT09LTEpe249ZmFsc2U7aT1hKzF9fWlmKGk9PT0tMSlyZXR1cm5cIlwiO3JldHVybiBlLnNsaWNlKHQsaSl9fSxleHRuYW1lOmZ1bmN0aW9uIGV4dG5hbWUoZSl7YXNzZXJ0UGF0aChlKTt2YXIgcj0tMTt2YXIgdD0wO3ZhciBpPS0xO3ZhciBuPXRydWU7dmFyIGE9MDtmb3IodmFyIGY9ZS5sZW5ndGgtMTtmPj0wOy0tZil7dmFyIGw9ZS5jaGFyQ29kZUF0KGYpO2lmKGw9PT00Nyl7aWYoIW4pe3Q9ZisxO2JyZWFrfWNvbnRpbnVlfWlmKGk9PT0tMSl7bj1mYWxzZTtpPWYrMX1pZihsPT09NDYpe2lmKHI9PT0tMSlyPWY7ZWxzZSBpZihhIT09MSlhPTF9ZWxzZSBpZihyIT09LTEpe2E9LTF9fWlmKHI9PT0tMXx8aT09PS0xfHxhPT09MHx8YT09PTEmJnI9PT1pLTEmJnI9PT10KzEpe3JldHVyblwiXCJ9cmV0dXJuIGUuc2xpY2UocixpKX0sZm9ybWF0OmZ1bmN0aW9uIGZvcm1hdChlKXtpZihlPT09bnVsbHx8dHlwZW9mIGUhPT1cIm9iamVjdFwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJwYXRoT2JqZWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnK3R5cGVvZiBlKX1yZXR1cm4gX2Zvcm1hdChcIi9cIixlKX0scGFyc2U6ZnVuY3Rpb24gcGFyc2UoZSl7YXNzZXJ0UGF0aChlKTt2YXIgcj17cm9vdDpcIlwiLGRpcjpcIlwiLGJhc2U6XCJcIixleHQ6XCJcIixuYW1lOlwiXCJ9O2lmKGUubGVuZ3RoPT09MClyZXR1cm4gcjt2YXIgdD1lLmNoYXJDb2RlQXQoMCk7dmFyIGk9dD09PTQ3O3ZhciBuO2lmKGkpe3Iucm9vdD1cIi9cIjtuPTF9ZWxzZXtuPTB9dmFyIGE9LTE7dmFyIGY9MDt2YXIgbD0tMTt2YXIgcz10cnVlO3ZhciBvPWUubGVuZ3RoLTE7dmFyIHU9MDtmb3IoO28+PW47LS1vKXt0PWUuY2hhckNvZGVBdChvKTtpZih0PT09NDcpe2lmKCFzKXtmPW8rMTticmVha31jb250aW51ZX1pZihsPT09LTEpe3M9ZmFsc2U7bD1vKzF9aWYodD09PTQ2KXtpZihhPT09LTEpYT1vO2Vsc2UgaWYodSE9PTEpdT0xfWVsc2UgaWYoYSE9PS0xKXt1PS0xfX1pZihhPT09LTF8fGw9PT0tMXx8dT09PTB8fHU9PT0xJiZhPT09bC0xJiZhPT09ZisxKXtpZihsIT09LTEpe2lmKGY9PT0wJiZpKXIuYmFzZT1yLm5hbWU9ZS5zbGljZSgxLGwpO2Vsc2Ugci5iYXNlPXIubmFtZT1lLnNsaWNlKGYsbCl9fWVsc2V7aWYoZj09PTAmJmkpe3IubmFtZT1lLnNsaWNlKDEsYSk7ci5iYXNlPWUuc2xpY2UoMSxsKX1lbHNle3IubmFtZT1lLnNsaWNlKGYsYSk7ci5iYXNlPWUuc2xpY2UoZixsKX1yLmV4dD1lLnNsaWNlKGEsbCl9aWYoZj4wKXIuZGlyPWUuc2xpY2UoMCxmLTEpO2Vsc2UgaWYoaSlyLmRpcj1cIi9cIjtyZXR1cm4gcn0sc2VwOlwiL1wiLGRlbGltaXRlcjpcIjpcIix3aW4zMjpudWxsLHBvc2l4Om51bGx9O3IucG9zaXg9cjtlLmV4cG9ydHM9cn19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIGk9clt0XTtpZihpIT09dW5kZWZpbmVkKXtyZXR1cm4gaS5leHBvcnRzfXZhciBuPXJbdF09e2V4cG9ydHM6e319O3ZhciBhPXRydWU7dHJ5e2VbdF0obixuLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7YT1mYWxzZX1maW5hbGx5e2lmKGEpZGVsZXRlIHJbdF19cmV0dXJuIG4uZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXygxMTQpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6WyJlIiwiYXNzZXJ0UGF0aCIsIlR5cGVFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJub3JtYWxpemVTdHJpbmdQb3NpeCIsInIiLCJ0IiwiaSIsIm4iLCJhIiwiZiIsImwiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwicyIsImxhc3RJbmRleE9mIiwic2xpY2UiLCJfZm9ybWF0IiwiZGlyIiwicm9vdCIsImJhc2UiLCJuYW1lIiwiZXh0IiwicmVzb2x2ZSIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsIm5vcm1hbGl6ZSIsImlzQWJzb2x1dGUiLCJqb2luIiwicmVsYXRpdmUiLCJvIiwidSIsImgiLCJjIiwidiIsImciLCJfbWFrZUxvbmciLCJkaXJuYW1lIiwiYmFzZW5hbWUiLCJleHRuYW1lIiwiZm9ybWF0IiwicGFyc2UiLCJzZXAiLCJkZWxpbWl0ZXIiLCJ3aW4zMiIsInBvc2l4IiwiZXhwb3J0cyIsIl9fbmNjd3Bja19yZXF1aXJlX18iLCJhYiIsIl9fZGlybmFtZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/path-browserify/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function () {\n  var e = {\n    229: function (e) {\n      var t = e.exports = {};\n      var r;\n      var n;\n\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n\n      (function () {\n        try {\n          if (typeof setTimeout === \"function\") {\n            r = setTimeout;\n          } else {\n            r = defaultSetTimout;\n          }\n        } catch (e) {\n          r = defaultSetTimout;\n        }\n\n        try {\n          if (typeof clearTimeout === \"function\") {\n            n = clearTimeout;\n          } else {\n            n = defaultClearTimeout;\n          }\n        } catch (e) {\n          n = defaultClearTimeout;\n        }\n      })();\n\n      function runTimeout(e) {\n        if (r === setTimeout) {\n          return setTimeout(e, 0);\n        }\n\n        if ((r === defaultSetTimout || !r) && setTimeout) {\n          r = setTimeout;\n          return setTimeout(e, 0);\n        }\n\n        try {\n          return r(e, 0);\n        } catch (t) {\n          try {\n            return r.call(null, e, 0);\n          } catch (t) {\n            return r.call(this, e, 0);\n          }\n        }\n      }\n\n      function runClearTimeout(e) {\n        if (n === clearTimeout) {\n          return clearTimeout(e);\n        }\n\n        if ((n === defaultClearTimeout || !n) && clearTimeout) {\n          n = clearTimeout;\n          return clearTimeout(e);\n        }\n\n        try {\n          return n(e);\n        } catch (t) {\n          try {\n            return n.call(null, e);\n          } catch (t) {\n            return n.call(this, e);\n          }\n        }\n      }\n\n      var i = [];\n      var o = false;\n      var u;\n      var a = -1;\n\n      function cleanUpNextTick() {\n        if (!o || !u) {\n          return;\n        }\n\n        o = false;\n\n        if (u.length) {\n          i = u.concat(i);\n        } else {\n          a = -1;\n        }\n\n        if (i.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (o) {\n          return;\n        }\n\n        var e = runTimeout(cleanUpNextTick);\n        o = true;\n        var t = i.length;\n\n        while (t) {\n          u = i;\n          i = [];\n\n          while (++a < t) {\n            if (u) {\n              u[a].run();\n            }\n          }\n\n          a = -1;\n          t = i.length;\n        }\n\n        u = null;\n        o = false;\n        runClearTimeout(e);\n      }\n\n      t.nextTick = function (e) {\n        var t = new Array(arguments.length - 1);\n\n        if (arguments.length > 1) {\n          for (var r = 1; r < arguments.length; r++) {\n            t[r - 1] = arguments[r];\n          }\n        }\n\n        i.push(new Item(e, t));\n\n        if (i.length === 1 && !o) {\n          runTimeout(drainQueue);\n        }\n      };\n\n      function Item(e, t) {\n        this.fun = e;\n        this.array = t;\n      }\n\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n\n      t.title = \"browser\";\n      t.browser = true;\n      t.env = {};\n      t.argv = [];\n      t.version = \"\";\n      t.versions = {};\n\n      function noop() {}\n\n      t.on = noop;\n      t.addListener = noop;\n      t.once = noop;\n      t.off = noop;\n      t.removeListener = noop;\n      t.removeAllListeners = noop;\n      t.emit = noop;\n      t.prependListener = noop;\n      t.prependOnceListener = noop;\n\n      t.listeners = function (e) {\n        return [];\n      };\n\n      t.binding = function (e) {\n        throw new Error(\"process.binding is not supported\");\n      };\n\n      t.cwd = function () {\n        return \"/\";\n      };\n\n      t.chdir = function (e) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n\n      t.umask = function () {\n        return 0;\n      };\n    }\n  };\n  var t = {};\n\n  function __nccwpck_require__(r) {\n    var n = t[r];\n\n    if (n !== undefined) {\n      return n.exports;\n    }\n\n    var i = t[r] = {\n      exports: {}\n    };\n    var o = true;\n\n    try {\n      e[r](i, i.exports, __nccwpck_require__);\n      o = false;\n    } finally {\n      if (o) delete t[r];\n    }\n\n    return i.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var r = __nccwpck_require__(229);\n\n  module.exports = r;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsQ0FBQyxZQUFVO0VBQUMsSUFBSUEsQ0FBQyxHQUFDO0lBQUMsS0FBSSxVQUFTQSxDQUFULEVBQVc7TUFBQyxJQUFJQyxDQUFDLEdBQUNELENBQUMsQ0FBQ0UsT0FBRixHQUFVLEVBQWhCO01BQW1CLElBQUlDLENBQUo7TUFBTSxJQUFJQyxDQUFKOztNQUFNLFNBQVNDLGdCQUFULEdBQTJCO1FBQUMsTUFBTSxJQUFJQyxLQUFKLENBQVUsaUNBQVYsQ0FBTjtNQUFtRDs7TUFBQSxTQUFTQyxtQkFBVCxHQUE4QjtRQUFDLE1BQU0sSUFBSUQsS0FBSixDQUFVLG1DQUFWLENBQU47TUFBcUQ7O01BQUEsQ0FBQyxZQUFVO1FBQUMsSUFBRztVQUFDLElBQUcsT0FBT0UsVUFBUCxLQUFvQixVQUF2QixFQUFrQztZQUFDTCxDQUFDLEdBQUNLLFVBQUY7VUFBYSxDQUFoRCxNQUFvRDtZQUFDTCxDQUFDLEdBQUNFLGdCQUFGO1VBQW1CO1FBQUMsQ0FBN0UsQ0FBNkUsT0FBTUwsQ0FBTixFQUFRO1VBQUNHLENBQUMsR0FBQ0UsZ0JBQUY7UUFBbUI7O1FBQUEsSUFBRztVQUFDLElBQUcsT0FBT0ksWUFBUCxLQUFzQixVQUF6QixFQUFvQztZQUFDTCxDQUFDLEdBQUNLLFlBQUY7VUFBZSxDQUFwRCxNQUF3RDtZQUFDTCxDQUFDLEdBQUNHLG1CQUFGO1VBQXNCO1FBQUMsQ0FBcEYsQ0FBb0YsT0FBTVAsQ0FBTixFQUFRO1VBQUNJLENBQUMsR0FBQ0csbUJBQUY7UUFBc0I7TUFBQyxDQUF6Tzs7TUFBNk8sU0FBU0csVUFBVCxDQUFvQlYsQ0FBcEIsRUFBc0I7UUFBQyxJQUFHRyxDQUFDLEtBQUdLLFVBQVAsRUFBa0I7VUFBQyxPQUFPQSxVQUFVLENBQUNSLENBQUQsRUFBRyxDQUFILENBQWpCO1FBQXVCOztRQUFBLElBQUcsQ0FBQ0csQ0FBQyxLQUFH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SUFBaUI7O0lBQUEsSUFBSVcsQ0FBQyxHQUFDWixDQUFDLENBQUNFLENBQUQsQ0FBRCxHQUFLO01BQUNELE9BQU8sRUFBQztJQUFULENBQVg7SUFBd0IsSUFBSVksQ0FBQyxHQUFDLElBQU47O0lBQVcsSUFBRztNQUFDZCxDQUFDLENBQUNHLENBQUQsQ0FBRCxDQUFLVSxDQUFMLEVBQU9BLENBQUMsQ0FBQ1gsT0FBVCxFQUFpQmtELG1CQUFqQjtNQUFzQ3RDLENBQUMsR0FBQyxLQUFGO0lBQVEsQ0FBbEQsU0FBeUQ7TUFBQyxJQUFHQSxDQUFILEVBQUssT0FBT2IsQ0FBQyxDQUFDRSxDQUFELENBQVI7SUFBWTs7SUFBQSxPQUFPVSxDQUFDLENBQUNYLE9BQVQ7RUFBaUI7O0VBQUEsSUFBRyxPQUFPa0QsbUJBQVAsS0FBNkIsV0FBaEMsRUFBNENBLG1CQUFtQixDQUFDRSxFQUFwQixHQUF1QkMsU0FBUyxHQUFDLEdBQWpDOztFQUFxQyxJQUFJcEQsQ0FBQyxHQUFDaUQsbUJBQW1CLENBQUMsR0FBRCxDQUF6Qjs7RUFBK0JJLE1BQU0sQ0FBQ3RELE9BQVAsR0FBZUMsQ0FBZjtBQUFpQixDQUF0NEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanM/MWIxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17MjI5OmZ1bmN0aW9uKGUpe3ZhciB0PWUuZXhwb3J0cz17fTt2YXIgcjt2YXIgbjtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfShmdW5jdGlvbigpe3RyeXtpZih0eXBlb2Ygc2V0VGltZW91dD09PVwiZnVuY3Rpb25cIil7cj1zZXRUaW1lb3V0fWVsc2V7cj1kZWZhdWx0U2V0VGltb3V0fX1jYXRjaChlKXtyPWRlZmF1bHRTZXRUaW1vdXR9dHJ5e2lmKHR5cGVvZiBjbGVhclRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe249Y2xlYXJUaW1lb3V0fWVsc2V7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX1jYXRjaChlKXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fSkoKTtmdW5jdGlvbiBydW5UaW1lb3V0KGUpe2lmKHI9PT1zZXRUaW1lb3V0KXtyZXR1cm4gc2V0VGltZW91dChlLDApfWlmKChyPT09ZGVmYXVsdFNldFRpbW91dHx8IXIpJiZzZXRUaW1lb3V0KXtyPXNldFRpbWVvdXQ7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX10cnl7cmV0dXJuIHIoZSwwKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUsMCl9Y2F0Y2godCl7cmV0dXJuIHIuY2FsbCh0aGlzLGUsMCl9fX1mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQoZSl7aWYobj09PWNsZWFyVGltZW91dCl7cmV0dXJuIGNsZWFyVGltZW91dChlKX1pZigobj09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCFuKSYmY2xlYXJUaW1lb3V0KXtuPWNsZWFyVGltZW91dDtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfXRyeXtyZXR1cm4gbihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlKX19fXZhciBpPVtdO3ZhciBvPWZhbHNlO3ZhciB1O3ZhciBhPS0xO2Z1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpe2lmKCFvfHwhdSl7cmV0dXJufW89ZmFsc2U7aWYodS5sZW5ndGgpe2k9dS5jb25jYXQoaSl9ZWxzZXthPS0xfWlmKGkubGVuZ3RoKXtkcmFpblF1ZXVlKCl9fWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZihvKXtyZXR1cm59dmFyIGU9cnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO289dHJ1ZTt2YXIgdD1pLmxlbmd0aDt3aGlsZSh0KXt1PWk7aT1bXTt3aGlsZSgrK2E8dCl7aWYodSl7dVthXS5ydW4oKX19YT0tMTt0PWkubGVuZ3RofXU9bnVsbDtvPWZhbHNlO3J1bkNsZWFyVGltZW91dChlKX10Lm5leHRUaWNrPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dFtyLTFdPWFyZ3VtZW50c1tyXX19aS5wdXNoKG5ldyBJdGVtKGUsdCkpO2lmKGkubGVuZ3RoPT09MSYmIW8pe3J1blRpbWVvdXQoZHJhaW5RdWV1ZSl9fTtmdW5jdGlvbiBJdGVtKGUsdCl7dGhpcy5mdW49ZTt0aGlzLmFycmF5PXR9SXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX07dC50aXRsZT1cImJyb3dzZXJcIjt0LmJyb3dzZXI9dHJ1ZTt0LmVudj17fTt0LmFyZ3Y9W107dC52ZXJzaW9uPVwiXCI7dC52ZXJzaW9ucz17fTtmdW5jdGlvbiBub29wKCl7fXQub249bm9vcDt0LmFkZExpc3RlbmVyPW5vb3A7dC5vbmNlPW5vb3A7dC5vZmY9bm9vcDt0LnJlbW92ZUxpc3RlbmVyPW5vb3A7dC5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDt0LmVtaXQ9bm9vcDt0LnByZXBlbmRMaXN0ZW5lcj1ub29wO3QucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wO3QubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybltdfTt0LmJpbmRpbmc9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3QuY2hkaXI9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGk9dFtyXT17ZXhwb3J0czp7fX07dmFyIG89dHJ1ZTt0cnl7ZVtyXShpLGkuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtvPWZhbHNlfWZpbmFsbHl7aWYobylkZWxldGUgdFtyXX1yZXR1cm4gaS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj1fX25jY3dwY2tfcmVxdWlyZV9fKDIyOSk7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbImUiLCJ0IiwiZXhwb3J0cyIsInIiLCJuIiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiY2FsbCIsInJ1bkNsZWFyVGltZW91dCIsImkiLCJvIiwidSIsImEiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwicnVuIiwibmV4dFRpY2siLCJBcnJheSIsImFyZ3VtZW50cyIsInB1c2giLCJJdGVtIiwiZnVuIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwidW5kZWZpbmVkIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/util/util.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/compiled/util/util.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n(function () {\n  var r = {\n    992: function (r) {\n      r.exports = function (r, t, n) {\n        if (r.filter) return r.filter(t, n);\n        if (void 0 === r || null === r) throw new TypeError();\n        if (\"function\" != typeof t) throw new TypeError();\n        var o = [];\n\n        for (var i = 0; i < r.length; i++) {\n          if (!e.call(r, i)) continue;\n          var a = r[i];\n          if (t.call(n, a, i, r)) o.push(a);\n        }\n\n        return o;\n      };\n\n      var e = Object.prototype.hasOwnProperty;\n    },\n    256: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(838);\n      var o = t(139);\n      var i = o(n(\"String.prototype.indexOf\"));\n\n      r.exports = function callBoundIntrinsic(r, e) {\n        var t = n(r, !!e);\n\n        if (typeof t === \"function\" && i(r, \".prototype.\") > -1) {\n          return o(t);\n        }\n\n        return t;\n      };\n    },\n    139: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(174);\n      var o = t(838);\n      var i = o(\"%Function.prototype.apply%\");\n      var a = o(\"%Function.prototype.call%\");\n      var f = o(\"%Reflect.apply%\", true) || n.call(a, i);\n      var u = o(\"%Object.getOwnPropertyDescriptor%\", true);\n      var s = o(\"%Object.defineProperty%\", true);\n      var y = o(\"%Math.max%\");\n\n      if (s) {\n        try {\n          s({}, \"a\", {\n            value: 1\n          });\n        } catch (r) {\n          s = null;\n        }\n      }\n\n      r.exports = function callBind(r) {\n        var e = f(n, a, arguments);\n\n        if (u && s) {\n          var t = u(e, \"length\");\n\n          if (t.configurable) {\n            s(e, \"length\", {\n              value: 1 + y(0, r.length - (arguments.length - 1))\n            });\n          }\n        }\n\n        return e;\n      };\n\n      var c = function applyBind() {\n        return f(n, i, arguments);\n      };\n\n      if (s) {\n        s(r.exports, \"apply\", {\n          value: c\n        });\n      } else {\n        r.exports.apply = c;\n      }\n    },\n    144: function (r) {\n      var e = Object.prototype.hasOwnProperty;\n      var t = Object.prototype.toString;\n\n      r.exports = function forEach(r, n, o) {\n        if (t.call(n) !== \"[object Function]\") {\n          throw new TypeError(\"iterator must be a function\");\n        }\n\n        var i = r.length;\n\n        if (i === +i) {\n          for (var a = 0; a < i; a++) {\n            n.call(o, r[a], a, r);\n          }\n        } else {\n          for (var f in r) {\n            if (e.call(r, f)) {\n              n.call(o, r[f], f, r);\n            }\n          }\n        }\n      };\n    },\n    426: function (r) {\n      \"use strict\";\n\n      var e = \"Function.prototype.bind called on incompatible \";\n      var t = Array.prototype.slice;\n      var n = Object.prototype.toString;\n      var o = \"[object Function]\";\n\n      r.exports = function bind(r) {\n        var i = this;\n\n        if (typeof i !== \"function\" || n.call(i) !== o) {\n          throw new TypeError(e + i);\n        }\n\n        var a = t.call(arguments, 1);\n        var f;\n\n        var binder = function () {\n          if (this instanceof f) {\n            var e = i.apply(this, a.concat(t.call(arguments)));\n\n            if (Object(e) === e) {\n              return e;\n            }\n\n            return this;\n          } else {\n            return i.apply(r, a.concat(t.call(arguments)));\n          }\n        };\n\n        var u = Math.max(0, i.length - a.length);\n        var s = [];\n\n        for (var y = 0; y < u; y++) {\n          s.push(\"$\" + y);\n        }\n\n        f = Function(\"binder\", \"return function (\" + s.join(\",\") + \"){ return binder.apply(this,arguments); }\")(binder);\n\n        if (i.prototype) {\n          var c = function Empty() {};\n\n          c.prototype = i.prototype;\n          f.prototype = new c();\n          c.prototype = null;\n        }\n\n        return f;\n      };\n    },\n    174: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(426);\n      r.exports = Function.prototype.bind || n;\n    },\n    838: function (r, e, t) {\n      \"use strict\";\n\n      var n;\n      var o = SyntaxError;\n      var i = Function;\n      var a = TypeError;\n\n      var getEvalledConstructor = function (r) {\n        try {\n          return i('\"use strict\"; return (' + r + \").constructor;\")();\n        } catch (r) {}\n      };\n\n      var f = Object.getOwnPropertyDescriptor;\n\n      if (f) {\n        try {\n          f({}, \"\");\n        } catch (r) {\n          f = null;\n        }\n      }\n\n      var throwTypeError = function () {\n        throw new a();\n      };\n\n      var u = f ? function () {\n        try {\n          arguments.callee;\n          return throwTypeError;\n        } catch (r) {\n          try {\n            return f(arguments, \"callee\").get;\n          } catch (r) {\n            return throwTypeError;\n          }\n        }\n      }() : throwTypeError;\n      var s = t(115)();\n\n      var y = Object.getPrototypeOf || function (r) {\n        return r.__proto__;\n      };\n\n      var c = {};\n      var p = typeof Uint8Array === \"undefined\" ? n : y(Uint8Array);\n      var l = {\n        \"%AggregateError%\": typeof AggregateError === \"undefined\" ? n : AggregateError,\n        \"%Array%\": Array,\n        \"%ArrayBuffer%\": typeof ArrayBuffer === \"undefined\" ? n : ArrayBuffer,\n        \"%ArrayIteratorPrototype%\": s ? y([][Symbol.iterator]()) : n,\n        \"%AsyncFromSyncIteratorPrototype%\": n,\n        \"%AsyncFunction%\": c,\n        \"%AsyncGenerator%\": c,\n        \"%AsyncGeneratorFunction%\": c,\n        \"%AsyncIteratorPrototype%\": c,\n        \"%Atomics%\": typeof Atomics === \"undefined\" ? n : Atomics,\n        \"%BigInt%\": typeof BigInt === \"undefined\" ? n : BigInt,\n        \"%Boolean%\": Boolean,\n        \"%DataView%\": typeof DataView === \"undefined\" ? n : DataView,\n        \"%Date%\": Date,\n        \"%decodeURI%\": decodeURI,\n        \"%decodeURIComponent%\": decodeURIComponent,\n        \"%encodeURI%\": encodeURI,\n        \"%encodeURIComponent%\": encodeURIComponent,\n        \"%Error%\": Error,\n        \"%eval%\": eval,\n        \"%EvalError%\": EvalError,\n        \"%Float32Array%\": typeof Float32Array === \"undefined\" ? n : Float32Array,\n        \"%Float64Array%\": typeof Float64Array === \"undefined\" ? n : Float64Array,\n        \"%FinalizationRegistry%\": typeof FinalizationRegistry === \"undefined\" ? n : FinalizationRegistry,\n        \"%Function%\": i,\n        \"%GeneratorFunction%\": c,\n        \"%Int8Array%\": typeof Int8Array === \"undefined\" ? n : Int8Array,\n        \"%Int16Array%\": typeof Int16Array === \"undefined\" ? n : Int16Array,\n        \"%Int32Array%\": typeof Int32Array === \"undefined\" ? n : Int32Array,\n        \"%isFinite%\": isFinite,\n        \"%isNaN%\": isNaN,\n        \"%IteratorPrototype%\": s ? y(y([][Symbol.iterator]())) : n,\n        \"%JSON%\": typeof JSON === \"object\" ? JSON : n,\n        \"%Map%\": typeof Map === \"undefined\" ? n : Map,\n        \"%MapIteratorPrototype%\": typeof Map === \"undefined\" || !s ? n : y(new Map()[Symbol.iterator]()),\n        \"%Math%\": Math,\n        \"%Number%\": Number,\n        \"%Object%\": Object,\n        \"%parseFloat%\": parseFloat,\n        \"%parseInt%\": parseInt,\n        \"%Promise%\": typeof Promise === \"undefined\" ? n : Promise,\n        \"%Proxy%\": typeof Proxy === \"undefined\" ? n : Proxy,\n        \"%RangeError%\": RangeError,\n        \"%ReferenceError%\": ReferenceError,\n        \"%Reflect%\": typeof Reflect === \"undefined\" ? n : Reflect,\n        \"%RegExp%\": RegExp,\n        \"%Set%\": typeof Set === \"undefined\" ? n : Set,\n        \"%SetIteratorPrototype%\": typeof Set === \"undefined\" || !s ? n : y(new Set()[Symbol.iterator]()),\n        \"%SharedArrayBuffer%\": typeof SharedArrayBuffer === \"undefined\" ? n : SharedArrayBuffer,\n        \"%String%\": String,\n        \"%StringIteratorPrototype%\": s ? y(\"\"[Symbol.iterator]()) : n,\n        \"%Symbol%\": s ? Symbol : n,\n        \"%SyntaxError%\": o,\n        \"%ThrowTypeError%\": u,\n        \"%TypedArray%\": p,\n        \"%TypeError%\": a,\n        \"%Uint8Array%\": typeof Uint8Array === \"undefined\" ? n : Uint8Array,\n        \"%Uint8ClampedArray%\": typeof Uint8ClampedArray === \"undefined\" ? n : Uint8ClampedArray,\n        \"%Uint16Array%\": typeof Uint16Array === \"undefined\" ? n : Uint16Array,\n        \"%Uint32Array%\": typeof Uint32Array === \"undefined\" ? n : Uint32Array,\n        \"%URIError%\": URIError,\n        \"%WeakMap%\": typeof WeakMap === \"undefined\" ? n : WeakMap,\n        \"%WeakRef%\": typeof WeakRef === \"undefined\" ? n : WeakRef,\n        \"%WeakSet%\": typeof WeakSet === \"undefined\" ? n : WeakSet\n      };\n\n      var g = function doEval(r) {\n        var e;\n\n        if (r === \"%AsyncFunction%\") {\n          e = getEvalledConstructor(\"async function () {}\");\n        } else if (r === \"%GeneratorFunction%\") {\n          e = getEvalledConstructor(\"function* () {}\");\n        } else if (r === \"%AsyncGeneratorFunction%\") {\n          e = getEvalledConstructor(\"async function* () {}\");\n        } else if (r === \"%AsyncGenerator%\") {\n          var t = doEval(\"%AsyncGeneratorFunction%\");\n\n          if (t) {\n            e = t.prototype;\n          }\n        } else if (r === \"%AsyncIteratorPrototype%\") {\n          var n = doEval(\"%AsyncGenerator%\");\n\n          if (n) {\n            e = y(n.prototype);\n          }\n        }\n\n        l[r] = e;\n        return e;\n      };\n\n      var b = {\n        \"%ArrayBufferPrototype%\": [\"ArrayBuffer\", \"prototype\"],\n        \"%ArrayPrototype%\": [\"Array\", \"prototype\"],\n        \"%ArrayProto_entries%\": [\"Array\", \"prototype\", \"entries\"],\n        \"%ArrayProto_forEach%\": [\"Array\", \"prototype\", \"forEach\"],\n        \"%ArrayProto_keys%\": [\"Array\", \"prototype\", \"keys\"],\n        \"%ArrayProto_values%\": [\"Array\", \"prototype\", \"values\"],\n        \"%AsyncFunctionPrototype%\": [\"AsyncFunction\", \"prototype\"],\n        \"%AsyncGenerator%\": [\"AsyncGeneratorFunction\", \"prototype\"],\n        \"%AsyncGeneratorPrototype%\": [\"AsyncGeneratorFunction\", \"prototype\", \"prototype\"],\n        \"%BooleanPrototype%\": [\"Boolean\", \"prototype\"],\n        \"%DataViewPrototype%\": [\"DataView\", \"prototype\"],\n        \"%DatePrototype%\": [\"Date\", \"prototype\"],\n        \"%ErrorPrototype%\": [\"Error\", \"prototype\"],\n        \"%EvalErrorPrototype%\": [\"EvalError\", \"prototype\"],\n        \"%Float32ArrayPrototype%\": [\"Float32Array\", \"prototype\"],\n        \"%Float64ArrayPrototype%\": [\"Float64Array\", \"prototype\"],\n        \"%FunctionPrototype%\": [\"Function\", \"prototype\"],\n        \"%Generator%\": [\"GeneratorFunction\", \"prototype\"],\n        \"%GeneratorPrototype%\": [\"GeneratorFunction\", \"prototype\", \"prototype\"],\n        \"%Int8ArrayPrototype%\": [\"Int8Array\", \"prototype\"],\n        \"%Int16ArrayPrototype%\": [\"Int16Array\", \"prototype\"],\n        \"%Int32ArrayPrototype%\": [\"Int32Array\", \"prototype\"],\n        \"%JSONParse%\": [\"JSON\", \"parse\"],\n        \"%JSONStringify%\": [\"JSON\", \"stringify\"],\n        \"%MapPrototype%\": [\"Map\", \"prototype\"],\n        \"%NumberPrototype%\": [\"Number\", \"prototype\"],\n        \"%ObjectPrototype%\": [\"Object\", \"prototype\"],\n        \"%ObjProto_toString%\": [\"Object\", \"prototype\", \"toString\"],\n        \"%ObjProto_valueOf%\": [\"Object\", \"prototype\", \"valueOf\"],\n        \"%PromisePrototype%\": [\"Promise\", \"prototype\"],\n        \"%PromiseProto_then%\": [\"Promise\", \"prototype\", \"then\"],\n        \"%Promise_all%\": [\"Promise\", \"all\"],\n        \"%Promise_reject%\": [\"Promise\", \"reject\"],\n        \"%Promise_resolve%\": [\"Promise\", \"resolve\"],\n        \"%RangeErrorPrototype%\": [\"RangeError\", \"prototype\"],\n        \"%ReferenceErrorPrototype%\": [\"ReferenceError\", \"prototype\"],\n        \"%RegExpPrototype%\": [\"RegExp\", \"prototype\"],\n        \"%SetPrototype%\": [\"Set\", \"prototype\"],\n        \"%SharedArrayBufferPrototype%\": [\"SharedArrayBuffer\", \"prototype\"],\n        \"%StringPrototype%\": [\"String\", \"prototype\"],\n        \"%SymbolPrototype%\": [\"Symbol\", \"prototype\"],\n        \"%SyntaxErrorPrototype%\": [\"SyntaxError\", \"prototype\"],\n        \"%TypedArrayPrototype%\": [\"TypedArray\", \"prototype\"],\n        \"%TypeErrorPrototype%\": [\"TypeError\", \"prototype\"],\n        \"%Uint8ArrayPrototype%\": [\"Uint8Array\", \"prototype\"],\n        \"%Uint8ClampedArrayPrototype%\": [\"Uint8ClampedArray\", \"prototype\"],\n        \"%Uint16ArrayPrototype%\": [\"Uint16Array\", \"prototype\"],\n        \"%Uint32ArrayPrototype%\": [\"Uint32Array\", \"prototype\"],\n        \"%URIErrorPrototype%\": [\"URIError\", \"prototype\"],\n        \"%WeakMapPrototype%\": [\"WeakMap\", \"prototype\"],\n        \"%WeakSetPrototype%\": [\"WeakSet\", \"prototype\"]\n      };\n      var d = t(174);\n      var v = t(101);\n      var m = d.call(Function.call, Array.prototype.concat);\n      var S = d.call(Function.apply, Array.prototype.splice);\n      var A = d.call(Function.call, String.prototype.replace);\n      var h = d.call(Function.call, String.prototype.slice);\n      var O = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\n      var j = /\\\\(\\\\)?/g;\n\n      var w = function stringToPath(r) {\n        var e = h(r, 0, 1);\n        var t = h(r, -1);\n\n        if (e === \"%\" && t !== \"%\") {\n          throw new o(\"invalid intrinsic syntax, expected closing `%`\");\n        } else if (t === \"%\" && e !== \"%\") {\n          throw new o(\"invalid intrinsic syntax, expected opening `%`\");\n        }\n\n        var n = [];\n        A(r, O, function (r, e, t, o) {\n          n[n.length] = t ? A(o, j, \"$1\") : e || r;\n        });\n        return n;\n      };\n\n      var P = function getBaseIntrinsic(r, e) {\n        var t = r;\n        var n;\n\n        if (v(b, t)) {\n          n = b[t];\n          t = \"%\" + n[0] + \"%\";\n        }\n\n        if (v(l, t)) {\n          var i = l[t];\n\n          if (i === c) {\n            i = g(t);\n          }\n\n          if (typeof i === \"undefined\" && !e) {\n            throw new a(\"intrinsic \" + r + \" exists, but is not available. Please file an issue!\");\n          }\n\n          return {\n            alias: n,\n            name: t,\n            value: i\n          };\n        }\n\n        throw new o(\"intrinsic \" + r + \" does not exist!\");\n      };\n\n      r.exports = function GetIntrinsic(r, e) {\n        if (typeof r !== \"string\" || r.length === 0) {\n          throw new a(\"intrinsic name must be a non-empty string\");\n        }\n\n        if (arguments.length > 1 && typeof e !== \"boolean\") {\n          throw new a('\"allowMissing\" argument must be a boolean');\n        }\n\n        var t = w(r);\n        var i = t.length > 0 ? t[0] : \"\";\n        var u = P(\"%\" + i + \"%\", e);\n        var s = u.name;\n        var y = u.value;\n        var c = false;\n        var p = u.alias;\n\n        if (p) {\n          i = p[0];\n          S(t, m([0, 1], p));\n        }\n\n        for (var g = 1, b = true; g < t.length; g += 1) {\n          var d = t[g];\n          var A = h(d, 0, 1);\n          var O = h(d, -1);\n\n          if ((A === '\"' || A === \"'\" || A === \"`\" || O === '\"' || O === \"'\" || O === \"`\") && A !== O) {\n            throw new o(\"property names with quotes must have matching quotes\");\n          }\n\n          if (d === \"constructor\" || !b) {\n            c = true;\n          }\n\n          i += \".\" + d;\n          s = \"%\" + i + \"%\";\n\n          if (v(l, s)) {\n            y = l[s];\n          } else if (y != null) {\n            if (!(d in y)) {\n              if (!e) {\n                throw new a(\"base intrinsic for \" + r + \" exists, but the property is not available.\");\n              }\n\n              return void n;\n            }\n\n            if (f && g + 1 >= t.length) {\n              var j = f(y, d);\n              b = !!j;\n\n              if (b && \"get\" in j && !(\"originalValue\" in j.get)) {\n                y = j.get;\n              } else {\n                y = y[d];\n              }\n            } else {\n              b = v(y, d);\n              y = y[d];\n            }\n\n            if (b && !c) {\n              l[s] = y;\n            }\n          }\n        }\n\n        return y;\n      };\n    },\n    942: function (r, e, t) {\n      \"use strict\";\n\n      var n = typeof Symbol !== \"undefined\" && Symbol;\n      var o = t(773);\n\n      r.exports = function hasNativeSymbols() {\n        if (typeof n !== \"function\") {\n          return false;\n        }\n\n        if (typeof Symbol !== \"function\") {\n          return false;\n        }\n\n        if (typeof n(\"foo\") !== \"symbol\") {\n          return false;\n        }\n\n        if (typeof Symbol(\"bar\") !== \"symbol\") {\n          return false;\n        }\n\n        return o();\n      };\n    },\n    773: function (r) {\n      \"use strict\";\n\n      r.exports = function hasSymbols() {\n        if (typeof Symbol !== \"function\" || typeof Object.getOwnPropertySymbols !== \"function\") {\n          return false;\n        }\n\n        if (typeof Symbol.iterator === \"symbol\") {\n          return true;\n        }\n\n        var r = {};\n        var e = Symbol(\"test\");\n        var t = Object(e);\n\n        if (typeof e === \"string\") {\n          return false;\n        }\n\n        if (Object.prototype.toString.call(e) !== \"[object Symbol]\") {\n          return false;\n        }\n\n        if (Object.prototype.toString.call(t) !== \"[object Symbol]\") {\n          return false;\n        }\n\n        var n = 42;\n        r[e] = n;\n\n        for (e in r) {\n          return false;\n        }\n\n        if (typeof Object.keys === \"function\" && Object.keys(r).length !== 0) {\n          return false;\n        }\n\n        if (typeof Object.getOwnPropertyNames === \"function\" && Object.getOwnPropertyNames(r).length !== 0) {\n          return false;\n        }\n\n        var o = Object.getOwnPropertySymbols(r);\n\n        if (o.length !== 1 || o[0] !== e) {\n          return false;\n        }\n\n        if (!Object.prototype.propertyIsEnumerable.call(r, e)) {\n          return false;\n        }\n\n        if (typeof Object.getOwnPropertyDescriptor === \"function\") {\n          var i = Object.getOwnPropertyDescriptor(r, e);\n\n          if (i.value !== n || i.enumerable !== true) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n    },\n    115: function (r, e, t) {\n      \"use strict\";\n\n      var n = typeof Symbol !== \"undefined\" && Symbol;\n      var o = t(832);\n\n      r.exports = function hasNativeSymbols() {\n        if (typeof n !== \"function\") {\n          return false;\n        }\n\n        if (typeof Symbol !== \"function\") {\n          return false;\n        }\n\n        if (typeof n(\"foo\") !== \"symbol\") {\n          return false;\n        }\n\n        if (typeof Symbol(\"bar\") !== \"symbol\") {\n          return false;\n        }\n\n        return o();\n      };\n    },\n    832: function (r) {\n      \"use strict\";\n\n      r.exports = function hasSymbols() {\n        if (typeof Symbol !== \"function\" || typeof Object.getOwnPropertySymbols !== \"function\") {\n          return false;\n        }\n\n        if (typeof Symbol.iterator === \"symbol\") {\n          return true;\n        }\n\n        var r = {};\n        var e = Symbol(\"test\");\n        var t = Object(e);\n\n        if (typeof e === \"string\") {\n          return false;\n        }\n\n        if (Object.prototype.toString.call(e) !== \"[object Symbol]\") {\n          return false;\n        }\n\n        if (Object.prototype.toString.call(t) !== \"[object Symbol]\") {\n          return false;\n        }\n\n        var n = 42;\n        r[e] = n;\n\n        for (e in r) {\n          return false;\n        }\n\n        if (typeof Object.keys === \"function\" && Object.keys(r).length !== 0) {\n          return false;\n        }\n\n        if (typeof Object.getOwnPropertyNames === \"function\" && Object.getOwnPropertyNames(r).length !== 0) {\n          return false;\n        }\n\n        var o = Object.getOwnPropertySymbols(r);\n\n        if (o.length !== 1 || o[0] !== e) {\n          return false;\n        }\n\n        if (!Object.prototype.propertyIsEnumerable.call(r, e)) {\n          return false;\n        }\n\n        if (typeof Object.getOwnPropertyDescriptor === \"function\") {\n          var i = Object.getOwnPropertyDescriptor(r, e);\n\n          if (i.value !== n || i.enumerable !== true) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n    },\n    101: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(174);\n      r.exports = n.call(Function.call, Object.prototype.hasOwnProperty);\n    },\n    782: function (r) {\n      if (typeof Object.create === \"function\") {\n        r.exports = function inherits(r, e) {\n          if (e) {\n            r.super_ = e;\n            r.prototype = Object.create(e.prototype, {\n              constructor: {\n                value: r,\n                enumerable: false,\n                writable: true,\n                configurable: true\n              }\n            });\n          }\n        };\n      } else {\n        r.exports = function inherits(r, e) {\n          if (e) {\n            r.super_ = e;\n\n            var TempCtor = function () {};\n\n            TempCtor.prototype = e.prototype;\n            r.prototype = new TempCtor();\n            r.prototype.constructor = r;\n          }\n        };\n      }\n    },\n    157: function (r) {\n      \"use strict\";\n\n      var e = typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\";\n      var t = Object.prototype.toString;\n\n      var n = function isArguments(r) {\n        if (e && r && typeof r === \"object\" && Symbol.toStringTag in r) {\n          return false;\n        }\n\n        return t.call(r) === \"[object Arguments]\";\n      };\n\n      var o = function isArguments(r) {\n        if (n(r)) {\n          return true;\n        }\n\n        return r !== null && typeof r === \"object\" && typeof r.length === \"number\" && r.length >= 0 && t.call(r) !== \"[object Array]\" && t.call(r.callee) === \"[object Function]\";\n      };\n\n      var i = function () {\n        return n(arguments);\n      }();\n\n      n.isLegacyArguments = o;\n      r.exports = i ? n : o;\n    },\n    391: function (r) {\n      \"use strict\";\n\n      var e = Object.prototype.toString;\n      var t = Function.prototype.toString;\n      var n = /^\\s*(?:function)?\\*/;\n      var o = typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\";\n      var i = Object.getPrototypeOf;\n\n      var getGeneratorFunc = function () {\n        if (!o) {\n          return false;\n        }\n\n        try {\n          return Function(\"return function*() {}\")();\n        } catch (r) {}\n      };\n\n      var a = getGeneratorFunc();\n      var f = a ? i(a) : {};\n\n      r.exports = function isGeneratorFunction(r) {\n        if (typeof r !== \"function\") {\n          return false;\n        }\n\n        if (n.test(t.call(r))) {\n          return true;\n        }\n\n        if (!o) {\n          var a = e.call(r);\n          return a === \"[object GeneratorFunction]\";\n        }\n\n        return i(r) === f;\n      };\n    },\n    994: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(144);\n      var o = t(349);\n      var i = t(256);\n      var a = i(\"Object.prototype.toString\");\n      var f = t(942)();\n      var u = f && typeof Symbol.toStringTag === \"symbol\";\n      var s = o();\n\n      var y = i(\"Array.prototype.indexOf\", true) || function indexOf(r, e) {\n        for (var t = 0; t < r.length; t += 1) {\n          if (r[t] === e) {\n            return t;\n          }\n        }\n\n        return -1;\n      };\n\n      var c = i(\"String.prototype.slice\");\n      var p = {};\n      var l = t(466);\n      var g = Object.getPrototypeOf;\n\n      if (u && l && g) {\n        n(s, function (r) {\n          var e = new __webpack_require__.g[r]();\n\n          if (!(Symbol.toStringTag in e)) {\n            throw new EvalError(\"this engine has support for Symbol.toStringTag, but \" + r + \" does not have the property! Please report this.\");\n          }\n\n          var t = g(e);\n          var n = l(t, Symbol.toStringTag);\n\n          if (!n) {\n            var o = g(t);\n            n = l(o, Symbol.toStringTag);\n          }\n\n          p[r] = n.get;\n        });\n      }\n\n      var b = function tryAllTypedArrays(r) {\n        var e = false;\n        n(p, function (t, n) {\n          if (!e) {\n            try {\n              e = t.call(r) === n;\n            } catch (r) {}\n          }\n        });\n        return e;\n      };\n\n      r.exports = function isTypedArray(r) {\n        if (!r || typeof r !== \"object\") {\n          return false;\n        }\n\n        if (!u) {\n          var e = c(a(r), 8, -1);\n          return y(s, e) > -1;\n        }\n\n        if (!l) {\n          return false;\n        }\n\n        return b(r);\n      };\n    },\n    369: function (r) {\n      r.exports = function isBuffer(r) {\n        return r instanceof Buffer;\n      };\n    },\n    584: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(157);\n      var o = t(391);\n      var i = t(490);\n      var a = t(994);\n\n      function uncurryThis(r) {\n        return r.call.bind(r);\n      }\n\n      var f = typeof BigInt !== \"undefined\";\n      var u = typeof Symbol !== \"undefined\";\n      var s = uncurryThis(Object.prototype.toString);\n      var y = uncurryThis(Number.prototype.valueOf);\n      var c = uncurryThis(String.prototype.valueOf);\n      var p = uncurryThis(Boolean.prototype.valueOf);\n\n      if (f) {\n        var l = uncurryThis(BigInt.prototype.valueOf);\n      }\n\n      if (u) {\n        var g = uncurryThis(Symbol.prototype.valueOf);\n      }\n\n      function checkBoxedPrimitive(r, e) {\n        if (typeof r !== \"object\") {\n          return false;\n        }\n\n        try {\n          e(r);\n          return true;\n        } catch (r) {\n          return false;\n        }\n      }\n\n      e.isArgumentsObject = n;\n      e.isGeneratorFunction = o;\n      e.isTypedArray = a;\n\n      function isPromise(r) {\n        return typeof Promise !== \"undefined\" && r instanceof Promise || r !== null && typeof r === \"object\" && typeof r.then === \"function\" && typeof r.catch === \"function\";\n      }\n\n      e.isPromise = isPromise;\n\n      function isArrayBufferView(r) {\n        if (typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView) {\n          return ArrayBuffer.isView(r);\n        }\n\n        return a(r) || isDataView(r);\n      }\n\n      e.isArrayBufferView = isArrayBufferView;\n\n      function isUint8Array(r) {\n        return i(r) === \"Uint8Array\";\n      }\n\n      e.isUint8Array = isUint8Array;\n\n      function isUint8ClampedArray(r) {\n        return i(r) === \"Uint8ClampedArray\";\n      }\n\n      e.isUint8ClampedArray = isUint8ClampedArray;\n\n      function isUint16Array(r) {\n        return i(r) === \"Uint16Array\";\n      }\n\n      e.isUint16Array = isUint16Array;\n\n      function isUint32Array(r) {\n        return i(r) === \"Uint32Array\";\n      }\n\n      e.isUint32Array = isUint32Array;\n\n      function isInt8Array(r) {\n        return i(r) === \"Int8Array\";\n      }\n\n      e.isInt8Array = isInt8Array;\n\n      function isInt16Array(r) {\n        return i(r) === \"Int16Array\";\n      }\n\n      e.isInt16Array = isInt16Array;\n\n      function isInt32Array(r) {\n        return i(r) === \"Int32Array\";\n      }\n\n      e.isInt32Array = isInt32Array;\n\n      function isFloat32Array(r) {\n        return i(r) === \"Float32Array\";\n      }\n\n      e.isFloat32Array = isFloat32Array;\n\n      function isFloat64Array(r) {\n        return i(r) === \"Float64Array\";\n      }\n\n      e.isFloat64Array = isFloat64Array;\n\n      function isBigInt64Array(r) {\n        return i(r) === \"BigInt64Array\";\n      }\n\n      e.isBigInt64Array = isBigInt64Array;\n\n      function isBigUint64Array(r) {\n        return i(r) === \"BigUint64Array\";\n      }\n\n      e.isBigUint64Array = isBigUint64Array;\n\n      function isMapToString(r) {\n        return s(r) === \"[object Map]\";\n      }\n\n      isMapToString.working = typeof Map !== \"undefined\" && isMapToString(new Map());\n\n      function isMap(r) {\n        if (typeof Map === \"undefined\") {\n          return false;\n        }\n\n        return isMapToString.working ? isMapToString(r) : r instanceof Map;\n      }\n\n      e.isMap = isMap;\n\n      function isSetToString(r) {\n        return s(r) === \"[object Set]\";\n      }\n\n      isSetToString.working = typeof Set !== \"undefined\" && isSetToString(new Set());\n\n      function isSet(r) {\n        if (typeof Set === \"undefined\") {\n          return false;\n        }\n\n        return isSetToString.working ? isSetToString(r) : r instanceof Set;\n      }\n\n      e.isSet = isSet;\n\n      function isWeakMapToString(r) {\n        return s(r) === \"[object WeakMap]\";\n      }\n\n      isWeakMapToString.working = typeof WeakMap !== \"undefined\" && isWeakMapToString(new WeakMap());\n\n      function isWeakMap(r) {\n        if (typeof WeakMap === \"undefined\") {\n          return false;\n        }\n\n        return isWeakMapToString.working ? isWeakMapToString(r) : r instanceof WeakMap;\n      }\n\n      e.isWeakMap = isWeakMap;\n\n      function isWeakSetToString(r) {\n        return s(r) === \"[object WeakSet]\";\n      }\n\n      isWeakSetToString.working = typeof WeakSet !== \"undefined\" && isWeakSetToString(new WeakSet());\n\n      function isWeakSet(r) {\n        return isWeakSetToString(r);\n      }\n\n      e.isWeakSet = isWeakSet;\n\n      function isArrayBufferToString(r) {\n        return s(r) === \"[object ArrayBuffer]\";\n      }\n\n      isArrayBufferToString.working = typeof ArrayBuffer !== \"undefined\" && isArrayBufferToString(new ArrayBuffer());\n\n      function isArrayBuffer(r) {\n        if (typeof ArrayBuffer === \"undefined\") {\n          return false;\n        }\n\n        return isArrayBufferToString.working ? isArrayBufferToString(r) : r instanceof ArrayBuffer;\n      }\n\n      e.isArrayBuffer = isArrayBuffer;\n\n      function isDataViewToString(r) {\n        return s(r) === \"[object DataView]\";\n      }\n\n      isDataViewToString.working = typeof ArrayBuffer !== \"undefined\" && typeof DataView !== \"undefined\" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));\n\n      function isDataView(r) {\n        if (typeof DataView === \"undefined\") {\n          return false;\n        }\n\n        return isDataViewToString.working ? isDataViewToString(r) : r instanceof DataView;\n      }\n\n      e.isDataView = isDataView;\n      var b = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : undefined;\n\n      function isSharedArrayBufferToString(r) {\n        return s(r) === \"[object SharedArrayBuffer]\";\n      }\n\n      function isSharedArrayBuffer(r) {\n        if (typeof b === \"undefined\") {\n          return false;\n        }\n\n        if (typeof isSharedArrayBufferToString.working === \"undefined\") {\n          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new b());\n        }\n\n        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(r) : r instanceof b;\n      }\n\n      e.isSharedArrayBuffer = isSharedArrayBuffer;\n\n      function isAsyncFunction(r) {\n        return s(r) === \"[object AsyncFunction]\";\n      }\n\n      e.isAsyncFunction = isAsyncFunction;\n\n      function isMapIterator(r) {\n        return s(r) === \"[object Map Iterator]\";\n      }\n\n      e.isMapIterator = isMapIterator;\n\n      function isSetIterator(r) {\n        return s(r) === \"[object Set Iterator]\";\n      }\n\n      e.isSetIterator = isSetIterator;\n\n      function isGeneratorObject(r) {\n        return s(r) === \"[object Generator]\";\n      }\n\n      e.isGeneratorObject = isGeneratorObject;\n\n      function isWebAssemblyCompiledModule(r) {\n        return s(r) === \"[object WebAssembly.Module]\";\n      }\n\n      e.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\n      function isNumberObject(r) {\n        return checkBoxedPrimitive(r, y);\n      }\n\n      e.isNumberObject = isNumberObject;\n\n      function isStringObject(r) {\n        return checkBoxedPrimitive(r, c);\n      }\n\n      e.isStringObject = isStringObject;\n\n      function isBooleanObject(r) {\n        return checkBoxedPrimitive(r, p);\n      }\n\n      e.isBooleanObject = isBooleanObject;\n\n      function isBigIntObject(r) {\n        return f && checkBoxedPrimitive(r, l);\n      }\n\n      e.isBigIntObject = isBigIntObject;\n\n      function isSymbolObject(r) {\n        return u && checkBoxedPrimitive(r, g);\n      }\n\n      e.isSymbolObject = isSymbolObject;\n\n      function isBoxedPrimitive(r) {\n        return isNumberObject(r) || isStringObject(r) || isBooleanObject(r) || isBigIntObject(r) || isSymbolObject(r);\n      }\n\n      e.isBoxedPrimitive = isBoxedPrimitive;\n\n      function isAnyArrayBuffer(r) {\n        return typeof Uint8Array !== \"undefined\" && (isArrayBuffer(r) || isSharedArrayBuffer(r));\n      }\n\n      e.isAnyArrayBuffer = isAnyArrayBuffer;\n      [\"isProxy\", \"isExternal\", \"isModuleNamespaceObject\"].forEach(function (r) {\n        Object.defineProperty(e, r, {\n          enumerable: false,\n          value: function () {\n            throw new Error(r + \" is not supported in userland\");\n          }\n        });\n      });\n    },\n    177: function (r, e, t) {\n      var n = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(r) {\n        var e = Object.keys(r);\n        var t = {};\n\n        for (var n = 0; n < e.length; n++) {\n          t[e[n]] = Object.getOwnPropertyDescriptor(r, e[n]);\n        }\n\n        return t;\n      };\n\n      var o = /%[sdj%]/g;\n\n      e.format = function (r) {\n        if (!isString(r)) {\n          var e = [];\n\n          for (var t = 0; t < arguments.length; t++) {\n            e.push(inspect(arguments[t]));\n          }\n\n          return e.join(\" \");\n        }\n\n        var t = 1;\n        var n = arguments;\n        var i = n.length;\n        var a = String(r).replace(o, function (r) {\n          if (r === \"%%\") return \"%\";\n          if (t >= i) return r;\n\n          switch (r) {\n            case \"%s\":\n              return String(n[t++]);\n\n            case \"%d\":\n              return Number(n[t++]);\n\n            case \"%j\":\n              try {\n                return JSON.stringify(n[t++]);\n              } catch (r) {\n                return \"[Circular]\";\n              }\n\n            default:\n              return r;\n          }\n        });\n\n        for (var f = n[t]; t < i; f = n[++t]) {\n          if (isNull(f) || !isObject(f)) {\n            a += \" \" + f;\n          } else {\n            a += \" \" + inspect(f);\n          }\n        }\n\n        return a;\n      };\n\n      e.deprecate = function (r, t) {\n        if (typeof process !== \"undefined\" && process.noDeprecation === true) {\n          return r;\n        }\n\n        if (typeof process === \"undefined\") {\n          return function () {\n            return e.deprecate(r, t).apply(this, arguments);\n          };\n        }\n\n        var n = false;\n\n        function deprecated() {\n          if (!n) {\n            if (process.throwDeprecation) {\n              throw new Error(t);\n            } else if (process.traceDeprecation) {\n              console.trace(t);\n            } else {\n              console.error(t);\n            }\n\n            n = true;\n          }\n\n          return r.apply(this, arguments);\n        }\n\n        return deprecated;\n      };\n\n      var i = {};\n      var a = /^$/;\n\n      if (process.env.NODE_DEBUG) {\n        var f = process.env.NODE_DEBUG;\n        f = f.replace(/[|\\\\{}()[\\]^$+?.]/g, \"\\\\$&\").replace(/\\*/g, \".*\").replace(/,/g, \"$|^\").toUpperCase();\n        a = new RegExp(\"^\" + f + \"$\", \"i\");\n      }\n\n      e.debuglog = function (r) {\n        r = r.toUpperCase();\n\n        if (!i[r]) {\n          if (a.test(r)) {\n            var t = process.pid;\n\n            i[r] = function () {\n              var n = e.format.apply(e, arguments);\n              console.error(\"%s %d: %s\", r, t, n);\n            };\n          } else {\n            i[r] = function () {};\n          }\n        }\n\n        return i[r];\n      };\n\n      function inspect(r, t) {\n        var n = {\n          seen: [],\n          stylize: stylizeNoColor\n        };\n        if (arguments.length >= 3) n.depth = arguments[2];\n        if (arguments.length >= 4) n.colors = arguments[3];\n\n        if (isBoolean(t)) {\n          n.showHidden = t;\n        } else if (t) {\n          e._extend(n, t);\n        }\n\n        if (isUndefined(n.showHidden)) n.showHidden = false;\n        if (isUndefined(n.depth)) n.depth = 2;\n        if (isUndefined(n.colors)) n.colors = false;\n        if (isUndefined(n.customInspect)) n.customInspect = true;\n        if (n.colors) n.stylize = stylizeWithColor;\n        return formatValue(n, r, n.depth);\n      }\n\n      e.inspect = inspect;\n      inspect.colors = {\n        bold: [1, 22],\n        italic: [3, 23],\n        underline: [4, 24],\n        inverse: [7, 27],\n        white: [37, 39],\n        grey: [90, 39],\n        black: [30, 39],\n        blue: [34, 39],\n        cyan: [36, 39],\n        green: [32, 39],\n        magenta: [35, 39],\n        red: [31, 39],\n        yellow: [33, 39]\n      };\n      inspect.styles = {\n        special: \"cyan\",\n        number: \"yellow\",\n        boolean: \"yellow\",\n        undefined: \"grey\",\n        null: \"bold\",\n        string: \"green\",\n        date: \"magenta\",\n        regexp: \"red\"\n      };\n\n      function stylizeWithColor(r, e) {\n        var t = inspect.styles[e];\n\n        if (t) {\n          return \"\u001b[\" + inspect.colors[t][0] + \"m\" + r + \"\u001b[\" + inspect.colors[t][1] + \"m\";\n        } else {\n          return r;\n        }\n      }\n\n      function stylizeNoColor(r, e) {\n        return r;\n      }\n\n      function arrayToHash(r) {\n        var e = {};\n        r.forEach(function (r, t) {\n          e[r] = true;\n        });\n        return e;\n      }\n\n      function formatValue(r, t, n) {\n        if (r.customInspect && t && isFunction(t.inspect) && t.inspect !== e.inspect && !(t.constructor && t.constructor.prototype === t)) {\n          var o = t.inspect(n, r);\n\n          if (!isString(o)) {\n            o = formatValue(r, o, n);\n          }\n\n          return o;\n        }\n\n        var i = formatPrimitive(r, t);\n\n        if (i) {\n          return i;\n        }\n\n        var a = Object.keys(t);\n        var f = arrayToHash(a);\n\n        if (r.showHidden) {\n          a = Object.getOwnPropertyNames(t);\n        }\n\n        if (isError(t) && (a.indexOf(\"message\") >= 0 || a.indexOf(\"description\") >= 0)) {\n          return formatError(t);\n        }\n\n        if (a.length === 0) {\n          if (isFunction(t)) {\n            var u = t.name ? \": \" + t.name : \"\";\n            return r.stylize(\"[Function\" + u + \"]\", \"special\");\n          }\n\n          if (isRegExp(t)) {\n            return r.stylize(RegExp.prototype.toString.call(t), \"regexp\");\n          }\n\n          if (isDate(t)) {\n            return r.stylize(Date.prototype.toString.call(t), \"date\");\n          }\n\n          if (isError(t)) {\n            return formatError(t);\n          }\n        }\n\n        var s = \"\",\n            y = false,\n            c = [\"{\", \"}\"];\n\n        if (isArray(t)) {\n          y = true;\n          c = [\"[\", \"]\"];\n        }\n\n        if (isFunction(t)) {\n          var p = t.name ? \": \" + t.name : \"\";\n          s = \" [Function\" + p + \"]\";\n        }\n\n        if (isRegExp(t)) {\n          s = \" \" + RegExp.prototype.toString.call(t);\n        }\n\n        if (isDate(t)) {\n          s = \" \" + Date.prototype.toUTCString.call(t);\n        }\n\n        if (isError(t)) {\n          s = \" \" + formatError(t);\n        }\n\n        if (a.length === 0 && (!y || t.length == 0)) {\n          return c[0] + s + c[1];\n        }\n\n        if (n < 0) {\n          if (isRegExp(t)) {\n            return r.stylize(RegExp.prototype.toString.call(t), \"regexp\");\n          } else {\n            return r.stylize(\"[Object]\", \"special\");\n          }\n        }\n\n        r.seen.push(t);\n        var l;\n\n        if (y) {\n          l = formatArray(r, t, n, f, a);\n        } else {\n          l = a.map(function (e) {\n            return formatProperty(r, t, n, f, e, y);\n          });\n        }\n\n        r.seen.pop();\n        return reduceToSingleString(l, s, c);\n      }\n\n      function formatPrimitive(r, e) {\n        if (isUndefined(e)) return r.stylize(\"undefined\", \"undefined\");\n\n        if (isString(e)) {\n          var t = \"'\" + JSON.stringify(e).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n          return r.stylize(t, \"string\");\n        }\n\n        if (isNumber(e)) return r.stylize(\"\" + e, \"number\");\n        if (isBoolean(e)) return r.stylize(\"\" + e, \"boolean\");\n        if (isNull(e)) return r.stylize(\"null\", \"null\");\n      }\n\n      function formatError(r) {\n        return \"[\" + Error.prototype.toString.call(r) + \"]\";\n      }\n\n      function formatArray(r, e, t, n, o) {\n        var i = [];\n\n        for (var a = 0, f = e.length; a < f; ++a) {\n          if (hasOwnProperty(e, String(a))) {\n            i.push(formatProperty(r, e, t, n, String(a), true));\n          } else {\n            i.push(\"\");\n          }\n        }\n\n        o.forEach(function (o) {\n          if (!o.match(/^\\d+$/)) {\n            i.push(formatProperty(r, e, t, n, o, true));\n          }\n        });\n        return i;\n      }\n\n      function formatProperty(r, e, t, n, o, i) {\n        var a, f, u;\n        u = Object.getOwnPropertyDescriptor(e, o) || {\n          value: e[o]\n        };\n\n        if (u.get) {\n          if (u.set) {\n            f = r.stylize(\"[Getter/Setter]\", \"special\");\n          } else {\n            f = r.stylize(\"[Getter]\", \"special\");\n          }\n        } else {\n          if (u.set) {\n            f = r.stylize(\"[Setter]\", \"special\");\n          }\n        }\n\n        if (!hasOwnProperty(n, o)) {\n          a = \"[\" + o + \"]\";\n        }\n\n        if (!f) {\n          if (r.seen.indexOf(u.value) < 0) {\n            if (isNull(t)) {\n              f = formatValue(r, u.value, null);\n            } else {\n              f = formatValue(r, u.value, t - 1);\n            }\n\n            if (f.indexOf(\"\\n\") > -1) {\n              if (i) {\n                f = f.split(\"\\n\").map(function (r) {\n                  return \"  \" + r;\n                }).join(\"\\n\").substr(2);\n              } else {\n                f = \"\\n\" + f.split(\"\\n\").map(function (r) {\n                  return \"   \" + r;\n                }).join(\"\\n\");\n              }\n            }\n          } else {\n            f = r.stylize(\"[Circular]\", \"special\");\n          }\n        }\n\n        if (isUndefined(a)) {\n          if (i && o.match(/^\\d+$/)) {\n            return f;\n          }\n\n          a = JSON.stringify(\"\" + o);\n\n          if (a.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n            a = a.substr(1, a.length - 2);\n            a = r.stylize(a, \"name\");\n          } else {\n            a = a.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n            a = r.stylize(a, \"string\");\n          }\n        }\n\n        return a + \": \" + f;\n      }\n\n      function reduceToSingleString(r, e, t) {\n        var n = 0;\n        var o = r.reduce(function (r, e) {\n          n++;\n          if (e.indexOf(\"\\n\") >= 0) n++;\n          return r + e.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n        }, 0);\n\n        if (o > 60) {\n          return t[0] + (e === \"\" ? \"\" : e + \"\\n \") + \" \" + r.join(\",\\n  \") + \" \" + t[1];\n        }\n\n        return t[0] + e + \" \" + r.join(\", \") + \" \" + t[1];\n      }\n\n      e.types = t(584);\n\n      function isArray(r) {\n        return Array.isArray(r);\n      }\n\n      e.isArray = isArray;\n\n      function isBoolean(r) {\n        return typeof r === \"boolean\";\n      }\n\n      e.isBoolean = isBoolean;\n\n      function isNull(r) {\n        return r === null;\n      }\n\n      e.isNull = isNull;\n\n      function isNullOrUndefined(r) {\n        return r == null;\n      }\n\n      e.isNullOrUndefined = isNullOrUndefined;\n\n      function isNumber(r) {\n        return typeof r === \"number\";\n      }\n\n      e.isNumber = isNumber;\n\n      function isString(r) {\n        return typeof r === \"string\";\n      }\n\n      e.isString = isString;\n\n      function isSymbol(r) {\n        return typeof r === \"symbol\";\n      }\n\n      e.isSymbol = isSymbol;\n\n      function isUndefined(r) {\n        return r === void 0;\n      }\n\n      e.isUndefined = isUndefined;\n\n      function isRegExp(r) {\n        return isObject(r) && objectToString(r) === \"[object RegExp]\";\n      }\n\n      e.isRegExp = isRegExp;\n      e.types.isRegExp = isRegExp;\n\n      function isObject(r) {\n        return typeof r === \"object\" && r !== null;\n      }\n\n      e.isObject = isObject;\n\n      function isDate(r) {\n        return isObject(r) && objectToString(r) === \"[object Date]\";\n      }\n\n      e.isDate = isDate;\n      e.types.isDate = isDate;\n\n      function isError(r) {\n        return isObject(r) && (objectToString(r) === \"[object Error]\" || r instanceof Error);\n      }\n\n      e.isError = isError;\n      e.types.isNativeError = isError;\n\n      function isFunction(r) {\n        return typeof r === \"function\";\n      }\n\n      e.isFunction = isFunction;\n\n      function isPrimitive(r) {\n        return r === null || typeof r === \"boolean\" || typeof r === \"number\" || typeof r === \"string\" || typeof r === \"symbol\" || typeof r === \"undefined\";\n      }\n\n      e.isPrimitive = isPrimitive;\n      e.isBuffer = t(369);\n\n      function objectToString(r) {\n        return Object.prototype.toString.call(r);\n      }\n\n      function pad(r) {\n        return r < 10 ? \"0\" + r.toString(10) : r.toString(10);\n      }\n\n      var u = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n      function timestamp() {\n        var r = new Date();\n        var e = [pad(r.getHours()), pad(r.getMinutes()), pad(r.getSeconds())].join(\":\");\n        return [r.getDate(), u[r.getMonth()], e].join(\" \");\n      }\n\n      e.log = function () {\n        console.log(\"%s - %s\", timestamp(), e.format.apply(e, arguments));\n      };\n\n      e.inherits = t(782);\n\n      e._extend = function (r, e) {\n        if (!e || !isObject(e)) return r;\n        var t = Object.keys(e);\n        var n = t.length;\n\n        while (n--) {\n          r[t[n]] = e[t[n]];\n        }\n\n        return r;\n      };\n\n      function hasOwnProperty(r, e) {\n        return Object.prototype.hasOwnProperty.call(r, e);\n      }\n\n      var s = typeof Symbol !== \"undefined\" ? Symbol(\"util.promisify.custom\") : undefined;\n\n      e.promisify = function promisify(r) {\n        if (typeof r !== \"function\") throw new TypeError('The \"original\" argument must be of type Function');\n\n        if (s && r[s]) {\n          var e = r[s];\n\n          if (typeof e !== \"function\") {\n            throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n          }\n\n          Object.defineProperty(e, s, {\n            value: e,\n            enumerable: false,\n            writable: false,\n            configurable: true\n          });\n          return e;\n        }\n\n        function e() {\n          var e, t;\n          var n = new Promise(function (r, n) {\n            e = r;\n            t = n;\n          });\n          var o = [];\n\n          for (var i = 0; i < arguments.length; i++) {\n            o.push(arguments[i]);\n          }\n\n          o.push(function (r, n) {\n            if (r) {\n              t(r);\n            } else {\n              e(n);\n            }\n          });\n\n          try {\n            r.apply(this, o);\n          } catch (r) {\n            t(r);\n          }\n\n          return n;\n        }\n\n        Object.setPrototypeOf(e, Object.getPrototypeOf(r));\n        if (s) Object.defineProperty(e, s, {\n          value: e,\n          enumerable: false,\n          writable: false,\n          configurable: true\n        });\n        return Object.defineProperties(e, n(r));\n      };\n\n      e.promisify.custom = s;\n\n      function callbackifyOnRejected(r, e) {\n        if (!r) {\n          var t = new Error(\"Promise was rejected with a falsy value\");\n          t.reason = r;\n          r = t;\n        }\n\n        return e(r);\n      }\n\n      function callbackify(r) {\n        if (typeof r !== \"function\") {\n          throw new TypeError('The \"original\" argument must be of type Function');\n        }\n\n        function callbackified() {\n          var e = [];\n\n          for (var t = 0; t < arguments.length; t++) {\n            e.push(arguments[t]);\n          }\n\n          var n = e.pop();\n\n          if (typeof n !== \"function\") {\n            throw new TypeError(\"The last argument must be of type Function\");\n          }\n\n          var o = this;\n\n          var cb = function () {\n            return n.apply(o, arguments);\n          };\n\n          r.apply(this, e).then(function (r) {\n            process.nextTick(cb.bind(null, null, r));\n          }, function (r) {\n            process.nextTick(callbackifyOnRejected.bind(null, r, cb));\n          });\n        }\n\n        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(r));\n        Object.defineProperties(callbackified, n(r));\n        return callbackified;\n      }\n\n      e.callbackify = callbackify;\n    },\n    490: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(144);\n      var o = t(349);\n      var i = t(256);\n      var a = i(\"Object.prototype.toString\");\n      var f = t(942)();\n      var u = f && typeof Symbol.toStringTag === \"symbol\";\n      var s = o();\n      var y = i(\"String.prototype.slice\");\n      var c = {};\n      var p = t(466);\n      var l = Object.getPrototypeOf;\n\n      if (u && p && l) {\n        n(s, function (r) {\n          if (typeof __webpack_require__.g[r] === \"function\") {\n            var e = new __webpack_require__.g[r]();\n\n            if (!(Symbol.toStringTag in e)) {\n              throw new EvalError(\"this engine has support for Symbol.toStringTag, but \" + r + \" does not have the property! Please report this.\");\n            }\n\n            var t = l(e);\n            var n = p(t, Symbol.toStringTag);\n\n            if (!n) {\n              var o = l(t);\n              n = p(o, Symbol.toStringTag);\n            }\n\n            c[r] = n.get;\n          }\n        });\n      }\n\n      var g = function tryAllTypedArrays(r) {\n        var e = false;\n        n(c, function (t, n) {\n          if (!e) {\n            try {\n              var o = t.call(r);\n\n              if (o === n) {\n                e = o;\n              }\n            } catch (r) {}\n          }\n        });\n        return e;\n      };\n\n      var b = t(994);\n\n      r.exports = function whichTypedArray(r) {\n        if (!b(r)) {\n          return false;\n        }\n\n        if (!u) {\n          return y(a(r), 8, -1);\n        }\n\n        return g(r);\n      };\n    },\n    349: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(992);\n\n      r.exports = function availableTypedArrays() {\n        return n([\"BigInt64Array\", \"BigUint64Array\", \"Float32Array\", \"Float64Array\", \"Int16Array\", \"Int32Array\", \"Int8Array\", \"Uint16Array\", \"Uint32Array\", \"Uint8Array\", \"Uint8ClampedArray\"], function (r) {\n          return typeof __webpack_require__.g[r] === \"function\";\n        });\n      };\n    },\n    466: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(838);\n      var o = n(\"%Object.getOwnPropertyDescriptor%\", true);\n\n      if (o) {\n        try {\n          o([], \"length\");\n        } catch (r) {\n          o = null;\n        }\n      }\n\n      r.exports = o;\n    }\n  };\n  var e = {};\n\n  function __nccwpck_require__(t) {\n    var n = e[t];\n\n    if (n !== undefined) {\n      return n.exports;\n    }\n\n    var o = e[t] = {\n      exports: {}\n    };\n    var i = true;\n\n    try {\n      r[t](o, o.exports, __nccwpck_require__);\n      i = false;\n    } finally {\n      if (i) delete e[t];\n    }\n\n    return o.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var t = __nccwpck_require__(177);\n\n  module.exports = t;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3V0aWwvdXRpbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxDQUFDLFlBQVU7RUFBQyxJQUFJQSxDQUFDLEdBQUM7SUFBQyxLQUFJLFVBQVNBLENBQVQsRUFBVztNQUFDQSxDQUFDLENBQUNDLE9BQUYsR0FBVSxVQUFTRCxDQUFULEVBQVdFLENBQVgsRUFBYUMsQ0FBYixFQUFlO1FBQUMsSUFBR0gsQ0FBQyxDQUFDSSxNQUFMLEVBQVksT0FBT0osQ0FBQyxDQUFDSSxNQUFGLENBQVNGLENBQVQsRUFBV0MsQ0FBWCxDQUFQO1FBQXFCLElBQUcsS0FBSyxDQUFMLEtBQVNILENBQVQsSUFBWSxTQUFPQSxDQUF0QixFQUF3QixNQUFNLElBQUlLLFNBQUosRUFBTjtRQUFvQixJQUFHLGNBQVksT0FBT0gsQ0FBdEIsRUFBd0IsTUFBTSxJQUFJRyxTQUFKLEVBQU47UUFBb0IsSUFBSUMsQ0FBQyxHQUFDLEVBQU47O1FBQVMsS0FBSSxJQUFJQyxDQUFDLEdBQUMsQ0FBVixFQUFZQSxDQUFDLEdBQUNQLENBQUMsQ0FBQ1EsTUFBaEIsRUFBdUJELENBQUMsRUFBeEIsRUFBMkI7VUFBQyxJQUFHLENBQUNFLENBQUMsQ0FBQ0MsSUFBRixDQUFPVixDQUFQLEVBQVNPLENBQVQsQ0FBSixFQUFnQjtVQUFTLElBQUlJLENBQUMsR0FBQ1gsQ0FBQyxDQUFDTyxDQUFELENBQVA7VUFBVyxJQUFHTCxDQUFDLENBQUNRLElBQUYsQ0FBT1AsQ0FBUCxFQUFTUSxDQUFULEVBQVdKLENBQVgsRUFBYVAsQ0FBYixDQUFILEVBQW1CTSxDQUFDLENBQUNNLElBQUYsQ0FBT0QsQ0FBUDtRQUFVOztRQUFBLE9BQU9MLENBQVA7TUFBUyxDQUFsUTs7TUFBbVEsSUFBSUcsQ0FBQyxHQUFDSSxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLGNBQXZCO0lBQXNDLENBQTFUO0lBQTJULEtBQUksVUFBU2YsQ0FBVCxFQUFXUyxDQUFYLEVBQWFQLENB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QSxDQUFILEVBQUssT0FBT0UsQ0FBQyxDQUFDUCxDQUFELENBQVI7SUFBWTs7SUFBQSxPQUFPSSxDQUFDLENBQUNMLE9BQVQ7RUFBaUI7O0VBQUEsSUFBRyxPQUFPaVMsbUJBQVAsS0FBNkIsV0FBaEMsRUFBNENBLG1CQUFtQixDQUFDQyxFQUFwQixHQUF1QkMsU0FBUyxHQUFDLEdBQWpDOztFQUFxQyxJQUFJbFMsQ0FBQyxHQUFDZ1MsbUJBQW1CLENBQUMsR0FBRCxDQUF6Qjs7RUFBK0JHLE1BQU0sQ0FBQ3BTLE9BQVAsR0FBZUMsQ0FBZjtBQUFpQixDQUExNS9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvdXRpbC91dGlsLmpzP2FjMTQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIHI9ezk5MjpmdW5jdGlvbihyKXtyLmV4cG9ydHM9ZnVuY3Rpb24ocix0LG4pe2lmKHIuZmlsdGVyKXJldHVybiByLmZpbHRlcih0LG4pO2lmKHZvaWQgMD09PXJ8fG51bGw9PT1yKXRocm93IG5ldyBUeXBlRXJyb3I7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO3ZhciBvPVtdO2Zvcih2YXIgaT0wO2k8ci5sZW5ndGg7aSsrKXtpZighZS5jYWxsKHIsaSkpY29udGludWU7dmFyIGE9cltpXTtpZih0LmNhbGwobixhLGkscikpby5wdXNoKGEpfXJldHVybiBvfTt2YXIgZT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5fSwyNTY6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoODM4KTt2YXIgbz10KDEzOSk7dmFyIGk9byhuKFwiU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mXCIpKTtyLmV4cG9ydHM9ZnVuY3Rpb24gY2FsbEJvdW5kSW50cmluc2ljKHIsZSl7dmFyIHQ9bihyLCEhZSk7aWYodHlwZW9mIHQ9PT1cImZ1bmN0aW9uXCImJmkocixcIi5wcm90b3R5cGUuXCIpPi0xKXtyZXR1cm4gbyh0KX1yZXR1cm4gdH19LDEzOTpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCgxNzQpO3ZhciBvPXQoODM4KTt2YXIgaT1vKFwiJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSVcIik7dmFyIGE9byhcIiVGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCVcIik7dmFyIGY9byhcIiVSZWZsZWN0LmFwcGx5JVwiLHRydWUpfHxuLmNhbGwoYSxpKTt2YXIgdT1vKFwiJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlXCIsdHJ1ZSk7dmFyIHM9byhcIiVPYmplY3QuZGVmaW5lUHJvcGVydHklXCIsdHJ1ZSk7dmFyIHk9byhcIiVNYXRoLm1heCVcIik7aWYocyl7dHJ5e3Moe30sXCJhXCIse3ZhbHVlOjF9KX1jYXRjaChyKXtzPW51bGx9fXIuZXhwb3J0cz1mdW5jdGlvbiBjYWxsQmluZChyKXt2YXIgZT1mKG4sYSxhcmd1bWVudHMpO2lmKHUmJnMpe3ZhciB0PXUoZSxcImxlbmd0aFwiKTtpZih0LmNvbmZpZ3VyYWJsZSl7cyhlLFwibGVuZ3RoXCIse3ZhbHVlOjEreSgwLHIubGVuZ3RoLShhcmd1bWVudHMubGVuZ3RoLTEpKX0pfX1yZXR1cm4gZX07dmFyIGM9ZnVuY3Rpb24gYXBwbHlCaW5kKCl7cmV0dXJuIGYobixpLGFyZ3VtZW50cyl9O2lmKHMpe3Moci5leHBvcnRzLFwiYXBwbHlcIix7dmFsdWU6Y30pfWVsc2V7ci5leHBvcnRzLmFwcGx5PWN9fSwxNDQ6ZnVuY3Rpb24ocil7dmFyIGU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTt2YXIgdD1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO3IuZXhwb3J0cz1mdW5jdGlvbiBmb3JFYWNoKHIsbixvKXtpZih0LmNhbGwobikhPT1cIltvYmplY3QgRnVuY3Rpb25dXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIil9dmFyIGk9ci5sZW5ndGg7aWYoaT09PStpKXtmb3IodmFyIGE9MDthPGk7YSsrKXtuLmNhbGwobyxyW2FdLGEscil9fWVsc2V7Zm9yKHZhciBmIGluIHIpe2lmKGUuY2FsbChyLGYpKXtuLmNhbGwobyxyW2ZdLGYscil9fX19fSw0MjY6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9XCJGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlIFwiO3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZTt2YXIgbj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO3ZhciBvPVwiW29iamVjdCBGdW5jdGlvbl1cIjtyLmV4cG9ydHM9ZnVuY3Rpb24gYmluZChyKXt2YXIgaT10aGlzO2lmKHR5cGVvZiBpIT09XCJmdW5jdGlvblwifHxuLmNhbGwoaSkhPT1vKXt0aHJvdyBuZXcgVHlwZUVycm9yKGUraSl9dmFyIGE9dC5jYWxsKGFyZ3VtZW50cywxKTt2YXIgZjt2YXIgYmluZGVyPWZ1bmN0aW9uKCl7aWYodGhpcyBpbnN0YW5jZW9mIGYpe3ZhciBlPWkuYXBwbHkodGhpcyxhLmNvbmNhdCh0LmNhbGwoYXJndW1lbnRzKSkpO2lmKE9iamVjdChlKT09PWUpe3JldHVybiBlfXJldHVybiB0aGlzfWVsc2V7cmV0dXJuIGkuYXBwbHkocixhLmNvbmNhdCh0LmNhbGwoYXJndW1lbnRzKSkpfX07dmFyIHU9TWF0aC5tYXgoMCxpLmxlbmd0aC1hLmxlbmd0aCk7dmFyIHM9W107Zm9yKHZhciB5PTA7eTx1O3krKyl7cy5wdXNoKFwiJFwiK3kpfWY9RnVuY3Rpb24oXCJiaW5kZXJcIixcInJldHVybiBmdW5jdGlvbiAoXCIrcy5qb2luKFwiLFwiKStcIil7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9XCIpKGJpbmRlcik7aWYoaS5wcm90b3R5cGUpe3ZhciBjPWZ1bmN0aW9uIEVtcHR5KCl7fTtjLnByb3RvdHlwZT1pLnByb3RvdHlwZTtmLnByb3RvdHlwZT1uZXcgYztjLnByb3RvdHlwZT1udWxsfXJldHVybiBmfX0sMTc0OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KDQyNik7ci5leHBvcnRzPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kfHxufSw4Mzg6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuO3ZhciBvPVN5bnRheEVycm9yO3ZhciBpPUZ1bmN0aW9uO3ZhciBhPVR5cGVFcnJvcjt2YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yPWZ1bmN0aW9uKHIpe3RyeXtyZXR1cm4gaSgnXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJytyK1wiKS5jb25zdHJ1Y3RvcjtcIikoKX1jYXRjaChyKXt9fTt2YXIgZj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2lmKGYpe3RyeXtmKHt9LFwiXCIpfWNhdGNoKHIpe2Y9bnVsbH19dmFyIHRocm93VHlwZUVycm9yPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IGF9O3ZhciB1PWY/ZnVuY3Rpb24oKXt0cnl7YXJndW1lbnRzLmNhbGxlZTtyZXR1cm4gdGhyb3dUeXBlRXJyb3J9Y2F0Y2gocil7dHJ5e3JldHVybiBmKGFyZ3VtZW50cyxcImNhbGxlZVwiKS5nZXR9Y2F0Y2gocil7cmV0dXJuIHRocm93VHlwZUVycm9yfX19KCk6dGhyb3dUeXBlRXJyb3I7dmFyIHM9dCgxMTUpKCk7dmFyIHk9T2JqZWN0LmdldFByb3RvdHlwZU9mfHxmdW5jdGlvbihyKXtyZXR1cm4gci5fX3Byb3RvX199O3ZhciBjPXt9O3ZhciBwPXR5cGVvZiBVaW50OEFycmF5PT09XCJ1bmRlZmluZWRcIj9uOnkoVWludDhBcnJheSk7dmFyIGw9e1wiJUFnZ3JlZ2F0ZUVycm9yJVwiOnR5cGVvZiBBZ2dyZWdhdGVFcnJvcj09PVwidW5kZWZpbmVkXCI/bjpBZ2dyZWdhdGVFcnJvcixcIiVBcnJheSVcIjpBcnJheSxcIiVBcnJheUJ1ZmZlciVcIjp0eXBlb2YgQXJyYXlCdWZmZXI9PT1cInVuZGVmaW5lZFwiP246QXJyYXlCdWZmZXIsXCIlQXJyYXlJdGVyYXRvclByb3RvdHlwZSVcIjpzP3koW11bU3ltYm9sLml0ZXJhdG9yXSgpKTpuLFwiJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSVcIjpuLFwiJUFzeW5jRnVuY3Rpb24lXCI6YyxcIiVBc3luY0dlbmVyYXRvciVcIjpjLFwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCI6YyxcIiVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJVwiOmMsXCIlQXRvbWljcyVcIjp0eXBlb2YgQXRvbWljcz09PVwidW5kZWZpbmVkXCI/bjpBdG9taWNzLFwiJUJpZ0ludCVcIjp0eXBlb2YgQmlnSW50PT09XCJ1bmRlZmluZWRcIj9uOkJpZ0ludCxcIiVCb29sZWFuJVwiOkJvb2xlYW4sXCIlRGF0YVZpZXclXCI6dHlwZW9mIERhdGFWaWV3PT09XCJ1bmRlZmluZWRcIj9uOkRhdGFWaWV3LFwiJURhdGUlXCI6RGF0ZSxcIiVkZWNvZGVVUkklXCI6ZGVjb2RlVVJJLFwiJWRlY29kZVVSSUNvbXBvbmVudCVcIjpkZWNvZGVVUklDb21wb25lbnQsXCIlZW5jb2RlVVJJJVwiOmVuY29kZVVSSSxcIiVlbmNvZGVVUklDb21wb25lbnQlXCI6ZW5jb2RlVVJJQ29tcG9uZW50LFwiJUVycm9yJVwiOkVycm9yLFwiJWV2YWwlXCI6ZXZhbCxcIiVFdmFsRXJyb3IlXCI6RXZhbEVycm9yLFwiJUZsb2F0MzJBcnJheSVcIjp0eXBlb2YgRmxvYXQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9uOkZsb2F0MzJBcnJheSxcIiVGbG9hdDY0QXJyYXklXCI6dHlwZW9mIEZsb2F0NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bjpGbG9hdDY0QXJyYXksXCIlRmluYWxpemF0aW9uUmVnaXN0cnklXCI6dHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5PT09XCJ1bmRlZmluZWRcIj9uOkZpbmFsaXphdGlvblJlZ2lzdHJ5LFwiJUZ1bmN0aW9uJVwiOmksXCIlR2VuZXJhdG9yRnVuY3Rpb24lXCI6YyxcIiVJbnQ4QXJyYXklXCI6dHlwZW9mIEludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bjpJbnQ4QXJyYXksXCIlSW50MTZBcnJheSVcIjp0eXBlb2YgSW50MTZBcnJheT09PVwidW5kZWZpbmVkXCI/bjpJbnQxNkFycmF5LFwiJUludDMyQXJyYXklXCI6dHlwZW9mIEludDMyQXJyYXk9PT1cInVuZGVmaW5lZFwiP246SW50MzJBcnJheSxcIiVpc0Zpbml0ZSVcIjppc0Zpbml0ZSxcIiVpc05hTiVcIjppc05hTixcIiVJdGVyYXRvclByb3RvdHlwZSVcIjpzP3koeShbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKTpuLFwiJUpTT04lXCI6dHlwZW9mIEpTT049PT1cIm9iamVjdFwiP0pTT046bixcIiVNYXAlXCI6dHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCI/bjpNYXAsXCIlTWFwSXRlcmF0b3JQcm90b3R5cGUlXCI6dHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCJ8fCFzP246eSgobmV3IE1hcClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcIiVNYXRoJVwiOk1hdGgsXCIlTnVtYmVyJVwiOk51bWJlcixcIiVPYmplY3QlXCI6T2JqZWN0LFwiJXBhcnNlRmxvYXQlXCI6cGFyc2VGbG9hdCxcIiVwYXJzZUludCVcIjpwYXJzZUludCxcIiVQcm9taXNlJVwiOnR5cGVvZiBQcm9taXNlPT09XCJ1bmRlZmluZWRcIj9uOlByb21pc2UsXCIlUHJveHklXCI6dHlwZW9mIFByb3h5PT09XCJ1bmRlZmluZWRcIj9uOlByb3h5LFwiJVJhbmdlRXJyb3IlXCI6UmFuZ2VFcnJvcixcIiVSZWZlcmVuY2VFcnJvciVcIjpSZWZlcmVuY2VFcnJvcixcIiVSZWZsZWN0JVwiOnR5cGVvZiBSZWZsZWN0PT09XCJ1bmRlZmluZWRcIj9uOlJlZmxlY3QsXCIlUmVnRXhwJVwiOlJlZ0V4cCxcIiVTZXQlXCI6dHlwZW9mIFNldD09PVwidW5kZWZpbmVkXCI/bjpTZXQsXCIlU2V0SXRlcmF0b3JQcm90b3R5cGUlXCI6dHlwZW9mIFNldD09PVwidW5kZWZpbmVkXCJ8fCFzP246eSgobmV3IFNldClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcIiVTaGFyZWRBcnJheUJ1ZmZlciVcIjp0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI9PT1cInVuZGVmaW5lZFwiP246U2hhcmVkQXJyYXlCdWZmZXIsXCIlU3RyaW5nJVwiOlN0cmluZyxcIiVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSVcIjpzP3koXCJcIltTeW1ib2wuaXRlcmF0b3JdKCkpOm4sXCIlU3ltYm9sJVwiOnM/U3ltYm9sOm4sXCIlU3ludGF4RXJyb3IlXCI6byxcIiVUaHJvd1R5cGVFcnJvciVcIjp1LFwiJVR5cGVkQXJyYXklXCI6cCxcIiVUeXBlRXJyb3IlXCI6YSxcIiVVaW50OEFycmF5JVwiOnR5cGVvZiBVaW50OEFycmF5PT09XCJ1bmRlZmluZWRcIj9uOlVpbnQ4QXJyYXksXCIlVWludDhDbGFtcGVkQXJyYXklXCI6dHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5PT09XCJ1bmRlZmluZWRcIj9uOlVpbnQ4Q2xhbXBlZEFycmF5LFwiJVVpbnQxNkFycmF5JVwiOnR5cGVvZiBVaW50MTZBcnJheT09PVwidW5kZWZpbmVkXCI/bjpVaW50MTZBcnJheSxcIiVVaW50MzJBcnJheSVcIjp0eXBlb2YgVWludDMyQXJyYXk9PT1cInVuZGVmaW5lZFwiP246VWludDMyQXJyYXksXCIlVVJJRXJyb3IlXCI6VVJJRXJyb3IsXCIlV2Vha01hcCVcIjp0eXBlb2YgV2Vha01hcD09PVwidW5kZWZpbmVkXCI/bjpXZWFrTWFwLFwiJVdlYWtSZWYlXCI6dHlwZW9mIFdlYWtSZWY9PT1cInVuZGVmaW5lZFwiP246V2Vha1JlZixcIiVXZWFrU2V0JVwiOnR5cGVvZiBXZWFrU2V0PT09XCJ1bmRlZmluZWRcIj9uOldlYWtTZXR9O3ZhciBnPWZ1bmN0aW9uIGRvRXZhbChyKXt2YXIgZTtpZihyPT09XCIlQXN5bmNGdW5jdGlvbiVcIil7ZT1nZXRFdmFsbGVkQ29uc3RydWN0b3IoXCJhc3luYyBmdW5jdGlvbiAoKSB7fVwiKX1lbHNlIGlmKHI9PT1cIiVHZW5lcmF0b3JGdW5jdGlvbiVcIil7ZT1nZXRFdmFsbGVkQ29uc3RydWN0b3IoXCJmdW5jdGlvbiogKCkge31cIil9ZWxzZSBpZihyPT09XCIlQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiVcIil7ZT1nZXRFdmFsbGVkQ29uc3RydWN0b3IoXCJhc3luYyBmdW5jdGlvbiogKCkge31cIil9ZWxzZSBpZihyPT09XCIlQXN5bmNHZW5lcmF0b3IlXCIpe3ZhciB0PWRvRXZhbChcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiKTtpZih0KXtlPXQucHJvdG90eXBlfX1lbHNlIGlmKHI9PT1cIiVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJVwiKXt2YXIgbj1kb0V2YWwoXCIlQXN5bmNHZW5lcmF0b3IlXCIpO2lmKG4pe2U9eShuLnByb3RvdHlwZSl9fWxbcl09ZTtyZXR1cm4gZX07dmFyIGI9e1wiJUFycmF5QnVmZmVyUHJvdG90eXBlJVwiOltcIkFycmF5QnVmZmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlQXJyYXlQcm90b3R5cGUlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVBcnJheVByb3RvX2VudHJpZXMlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwiZW50cmllc1wiXSxcIiVBcnJheVByb3RvX2ZvckVhY2glXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwiZm9yRWFjaFwiXSxcIiVBcnJheVByb3RvX2tleXMlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwia2V5c1wiXSxcIiVBcnJheVByb3RvX3ZhbHVlcyVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJ2YWx1ZXNcIl0sXCIlQXN5bmNGdW5jdGlvblByb3RvdHlwZSVcIjpbXCJBc3luY0Z1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlQXN5bmNHZW5lcmF0b3IlXCI6W1wiQXN5bmNHZW5lcmF0b3JGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJVwiOltcIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiLFwicHJvdG90eXBlXCJdLFwiJUJvb2xlYW5Qcm90b3R5cGUlXCI6W1wiQm9vbGVhblwiLFwicHJvdG90eXBlXCJdLFwiJURhdGFWaWV3UHJvdG90eXBlJVwiOltcIkRhdGFWaWV3XCIsXCJwcm90b3R5cGVcIl0sXCIlRGF0ZVByb3RvdHlwZSVcIjpbXCJEYXRlXCIsXCJwcm90b3R5cGVcIl0sXCIlRXJyb3JQcm90b3R5cGUlXCI6W1wiRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVFdmFsRXJyb3JQcm90b3R5cGUlXCI6W1wiRXZhbEVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlRmxvYXQzMkFycmF5UHJvdG90eXBlJVwiOltcIkZsb2F0MzJBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUZsb2F0NjRBcnJheVByb3RvdHlwZSVcIjpbXCJGbG9hdDY0QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVGdW5jdGlvblByb3RvdHlwZSVcIjpbXCJGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUdlbmVyYXRvciVcIjpbXCJHZW5lcmF0b3JGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUdlbmVyYXRvclByb3RvdHlwZSVcIjpbXCJHZW5lcmF0b3JGdW5jdGlvblwiLFwicHJvdG90eXBlXCIsXCJwcm90b3R5cGVcIl0sXCIlSW50OEFycmF5UHJvdG90eXBlJVwiOltcIkludDhBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUludDE2QXJyYXlQcm90b3R5cGUlXCI6W1wiSW50MTZBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUludDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiSW50MzJBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUpTT05QYXJzZSVcIjpbXCJKU09OXCIsXCJwYXJzZVwiXSxcIiVKU09OU3RyaW5naWZ5JVwiOltcIkpTT05cIixcInN0cmluZ2lmeVwiXSxcIiVNYXBQcm90b3R5cGUlXCI6W1wiTWFwXCIsXCJwcm90b3R5cGVcIl0sXCIlTnVtYmVyUHJvdG90eXBlJVwiOltcIk51bWJlclwiLFwicHJvdG90eXBlXCJdLFwiJU9iamVjdFByb3RvdHlwZSVcIjpbXCJPYmplY3RcIixcInByb3RvdHlwZVwiXSxcIiVPYmpQcm90b190b1N0cmluZyVcIjpbXCJPYmplY3RcIixcInByb3RvdHlwZVwiLFwidG9TdHJpbmdcIl0sXCIlT2JqUHJvdG9fdmFsdWVPZiVcIjpbXCJPYmplY3RcIixcInByb3RvdHlwZVwiLFwidmFsdWVPZlwiXSxcIiVQcm9taXNlUHJvdG90eXBlJVwiOltcIlByb21pc2VcIixcInByb3RvdHlwZVwiXSxcIiVQcm9taXNlUHJvdG9fdGhlbiVcIjpbXCJQcm9taXNlXCIsXCJwcm90b3R5cGVcIixcInRoZW5cIl0sXCIlUHJvbWlzZV9hbGwlXCI6W1wiUHJvbWlzZVwiLFwiYWxsXCJdLFwiJVByb21pc2VfcmVqZWN0JVwiOltcIlByb21pc2VcIixcInJlamVjdFwiXSxcIiVQcm9taXNlX3Jlc29sdmUlXCI6W1wiUHJvbWlzZVwiLFwicmVzb2x2ZVwiXSxcIiVSYW5nZUVycm9yUHJvdG90eXBlJVwiOltcIlJhbmdlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSVcIjpbXCJSZWZlcmVuY2VFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVJlZ0V4cFByb3RvdHlwZSVcIjpbXCJSZWdFeHBcIixcInByb3RvdHlwZVwiXSxcIiVTZXRQcm90b3R5cGUlXCI6W1wiU2V0XCIsXCJwcm90b3R5cGVcIl0sXCIlU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlXCI6W1wiU2hhcmVkQXJyYXlCdWZmZXJcIixcInByb3RvdHlwZVwiXSxcIiVTdHJpbmdQcm90b3R5cGUlXCI6W1wiU3RyaW5nXCIsXCJwcm90b3R5cGVcIl0sXCIlU3ltYm9sUHJvdG90eXBlJVwiOltcIlN5bWJvbFwiLFwicHJvdG90eXBlXCJdLFwiJVN5bnRheEVycm9yUHJvdG90eXBlJVwiOltcIlN5bnRheEVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlVHlwZWRBcnJheVByb3RvdHlwZSVcIjpbXCJUeXBlZEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVHlwZUVycm9yUHJvdG90eXBlJVwiOltcIlR5cGVFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQ4QXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDhBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQ4Q2xhbXBlZEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDE2QXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDE2QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50MzJBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50MzJBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVSSUVycm9yUHJvdG90eXBlJVwiOltcIlVSSUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlV2Vha01hcFByb3RvdHlwZSVcIjpbXCJXZWFrTWFwXCIsXCJwcm90b3R5cGVcIl0sXCIlV2Vha1NldFByb3RvdHlwZSVcIjpbXCJXZWFrU2V0XCIsXCJwcm90b3R5cGVcIl19O3ZhciBkPXQoMTc0KTt2YXIgdj10KDEwMSk7dmFyIG09ZC5jYWxsKEZ1bmN0aW9uLmNhbGwsQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7dmFyIFM9ZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO3ZhciBBPWQuY2FsbChGdW5jdGlvbi5jYWxsLFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7dmFyIGg9ZC5jYWxsKEZ1bmN0aW9uLmNhbGwsU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7dmFyIE89L1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7dmFyIGo9L1xcXFwoXFxcXCk/L2c7dmFyIHc9ZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHIpe3ZhciBlPWgociwwLDEpO3ZhciB0PWgociwtMSk7aWYoZT09PVwiJVwiJiZ0IT09XCIlXCIpe3Rocm93IG5ldyBvKFwiaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYFwiKX1lbHNlIGlmKHQ9PT1cIiVcIiYmZSE9PVwiJVwiKXt0aHJvdyBuZXcgbyhcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWBcIil9dmFyIG49W107QShyLE8sKGZ1bmN0aW9uKHIsZSx0LG8pe25bbi5sZW5ndGhdPXQ/QShvLGosXCIkMVwiKTplfHxyfSkpO3JldHVybiBufTt2YXIgUD1mdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKHIsZSl7dmFyIHQ9cjt2YXIgbjtpZih2KGIsdCkpe249Ylt0XTt0PVwiJVwiK25bMF0rXCIlXCJ9aWYodihsLHQpKXt2YXIgaT1sW3RdO2lmKGk9PT1jKXtpPWcodCl9aWYodHlwZW9mIGk9PT1cInVuZGVmaW5lZFwiJiYhZSl7dGhyb3cgbmV3IGEoXCJpbnRyaW5zaWMgXCIrcitcIiBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSFcIil9cmV0dXJue2FsaWFzOm4sbmFtZTp0LHZhbHVlOml9fXRocm93IG5ldyBvKFwiaW50cmluc2ljIFwiK3IrXCIgZG9lcyBub3QgZXhpc3QhXCIpfTtyLmV4cG9ydHM9ZnVuY3Rpb24gR2V0SW50cmluc2ljKHIsZSl7aWYodHlwZW9mIHIhPT1cInN0cmluZ1wifHxyLmxlbmd0aD09PTApe3Rocm93IG5ldyBhKFwiaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9aWYoYXJndW1lbnRzLmxlbmd0aD4xJiZ0eXBlb2YgZSE9PVwiYm9vbGVhblwiKXt0aHJvdyBuZXcgYSgnXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpfXZhciB0PXcocik7dmFyIGk9dC5sZW5ndGg+MD90WzBdOlwiXCI7dmFyIHU9UChcIiVcIitpK1wiJVwiLGUpO3ZhciBzPXUubmFtZTt2YXIgeT11LnZhbHVlO3ZhciBjPWZhbHNlO3ZhciBwPXUuYWxpYXM7aWYocCl7aT1wWzBdO1ModCxtKFswLDFdLHApKX1mb3IodmFyIGc9MSxiPXRydWU7Zzx0Lmxlbmd0aDtnKz0xKXt2YXIgZD10W2ddO3ZhciBBPWgoZCwwLDEpO3ZhciBPPWgoZCwtMSk7aWYoKEE9PT0nXCInfHxBPT09XCInXCJ8fEE9PT1cImBcInx8KE89PT0nXCInfHxPPT09XCInXCJ8fE89PT1cImBcIikpJiZBIT09Tyl7dGhyb3cgbmV3IG8oXCJwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzXCIpfWlmKGQ9PT1cImNvbnN0cnVjdG9yXCJ8fCFiKXtjPXRydWV9aSs9XCIuXCIrZDtzPVwiJVwiK2krXCIlXCI7aWYodihsLHMpKXt5PWxbc119ZWxzZSBpZih5IT1udWxsKXtpZighKGQgaW4geSkpe2lmKCFlKXt0aHJvdyBuZXcgYShcImJhc2UgaW50cmluc2ljIGZvciBcIityK1wiIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLlwiKX1yZXR1cm4gdm9pZCBufWlmKGYmJmcrMT49dC5sZW5ndGgpe3ZhciBqPWYoeSxkKTtiPSEhajtpZihiJiZcImdldFwiaW4gaiYmIShcIm9yaWdpbmFsVmFsdWVcImluIGouZ2V0KSl7eT1qLmdldH1lbHNle3k9eVtkXX19ZWxzZXtiPXYoeSxkKTt5PXlbZF19aWYoYiYmIWMpe2xbc109eX19fXJldHVybiB5fX0sOTQyOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIiYmU3ltYm9sO3ZhciBvPXQoNzczKTtyLmV4cG9ydHM9ZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpe2lmKHR5cGVvZiBuIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbCE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBuKFwiZm9vXCIpIT09XCJzeW1ib2xcIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBTeW1ib2woXCJiYXJcIikhPT1cInN5bWJvbFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIG8oKX19LDc3MzpmdW5jdGlvbihyKXtcInVzZSBzdHJpY3RcIjtyLmV4cG9ydHM9ZnVuY3Rpb24gaGFzU3ltYm9scygpe2lmKHR5cGVvZiBTeW1ib2whPT1cImZ1bmN0aW9uXCJ8fHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbC5pdGVyYXRvcj09PVwic3ltYm9sXCIpe3JldHVybiB0cnVlfXZhciByPXt9O3ZhciBlPVN5bWJvbChcInRlc3RcIik7dmFyIHQ9T2JqZWN0KGUpO2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSE9PVwiW29iamVjdCBTeW1ib2xdXCIpe3JldHVybiBmYWxzZX1pZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkhPT1cIltvYmplY3QgU3ltYm9sXVwiKXtyZXR1cm4gZmFsc2V9dmFyIG49NDI7cltlXT1uO2ZvcihlIGluIHIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgT2JqZWN0LmtleXM9PT1cImZ1bmN0aW9uXCImJk9iamVjdC5rZXlzKHIpLmxlbmd0aCE9PTApe3JldHVybiBmYWxzZX1pZih0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM9PT1cImZ1bmN0aW9uXCImJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHIpLmxlbmd0aCE9PTApe3JldHVybiBmYWxzZX12YXIgbz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHIpO2lmKG8ubGVuZ3RoIT09MXx8b1swXSE9PWUpe3JldHVybiBmYWxzZX1pZighT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHIsZSkpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcj09PVwiZnVuY3Rpb25cIil7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLGUpO2lmKGkudmFsdWUhPT1ufHxpLmVudW1lcmFibGUhPT10cnVlKXtyZXR1cm4gZmFsc2V9fXJldHVybiB0cnVlfX0sMTE1OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIiYmU3ltYm9sO3ZhciBvPXQoODMyKTtyLmV4cG9ydHM9ZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpe2lmKHR5cGVvZiBuIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbCE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBuKFwiZm9vXCIpIT09XCJzeW1ib2xcIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBTeW1ib2woXCJiYXJcIikhPT1cInN5bWJvbFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIG8oKX19LDgzMjpmdW5jdGlvbihyKXtcInVzZSBzdHJpY3RcIjtyLmV4cG9ydHM9ZnVuY3Rpb24gaGFzU3ltYm9scygpe2lmKHR5cGVvZiBTeW1ib2whPT1cImZ1bmN0aW9uXCJ8fHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbC5pdGVyYXRvcj09PVwic3ltYm9sXCIpe3JldHVybiB0cnVlfXZhciByPXt9O3ZhciBlPVN5bWJvbChcInRlc3RcIik7dmFyIHQ9T2JqZWN0KGUpO2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSE9PVwiW29iamVjdCBTeW1ib2xdXCIpe3JldHVybiBmYWxzZX1pZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkhPT1cIltvYmplY3QgU3ltYm9sXVwiKXtyZXR1cm4gZmFsc2V9dmFyIG49NDI7cltlXT1uO2ZvcihlIGluIHIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgT2JqZWN0LmtleXM9PT1cImZ1bmN0aW9uXCImJk9iamVjdC5rZXlzKHIpLmxlbmd0aCE9PTApe3JldHVybiBmYWxzZX1pZih0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM9PT1cImZ1bmN0aW9uXCImJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHIpLmxlbmd0aCE9PTApe3JldHVybiBmYWxzZX12YXIgbz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHIpO2lmKG8ubGVuZ3RoIT09MXx8b1swXSE9PWUpe3JldHVybiBmYWxzZX1pZighT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHIsZSkpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcj09PVwiZnVuY3Rpb25cIil7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLGUpO2lmKGkudmFsdWUhPT1ufHxpLmVudW1lcmFibGUhPT10cnVlKXtyZXR1cm4gZmFsc2V9fXJldHVybiB0cnVlfX0sMTAxOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KDE3NCk7ci5leHBvcnRzPW4uY2FsbChGdW5jdGlvbi5jYWxsLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpfSw3ODI6ZnVuY3Rpb24ocil7aWYodHlwZW9mIE9iamVjdC5jcmVhdGU9PT1cImZ1bmN0aW9uXCIpe3IuZXhwb3J0cz1mdW5jdGlvbiBpbmhlcml0cyhyLGUpe2lmKGUpe3Iuc3VwZXJfPWU7ci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnIsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfX0pfX19ZWxzZXtyLmV4cG9ydHM9ZnVuY3Rpb24gaW5oZXJpdHMocixlKXtpZihlKXtyLnN1cGVyXz1lO3ZhciBUZW1wQ3Rvcj1mdW5jdGlvbigpe307VGVtcEN0b3IucHJvdG90eXBlPWUucHJvdG90eXBlO3IucHJvdG90eXBlPW5ldyBUZW1wQ3RvcjtyLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1yfX19fSwxNTc6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgbj1mdW5jdGlvbiBpc0FyZ3VtZW50cyhyKXtpZihlJiZyJiZ0eXBlb2Ygcj09PVwib2JqZWN0XCImJlN5bWJvbC50b1N0cmluZ1RhZyBpbiByKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHQuY2FsbChyKT09PVwiW29iamVjdCBBcmd1bWVudHNdXCJ9O3ZhciBvPWZ1bmN0aW9uIGlzQXJndW1lbnRzKHIpe2lmKG4ocikpe3JldHVybiB0cnVlfXJldHVybiByIT09bnVsbCYmdHlwZW9mIHI9PT1cIm9iamVjdFwiJiZ0eXBlb2Ygci5sZW5ndGg9PT1cIm51bWJlclwiJiZyLmxlbmd0aD49MCYmdC5jYWxsKHIpIT09XCJbb2JqZWN0IEFycmF5XVwiJiZ0LmNhbGwoci5jYWxsZWUpPT09XCJbb2JqZWN0IEZ1bmN0aW9uXVwifTt2YXIgaT1mdW5jdGlvbigpe3JldHVybiBuKGFyZ3VtZW50cyl9KCk7bi5pc0xlZ2FjeUFyZ3VtZW50cz1vO3IuZXhwb3J0cz1pP246b30sMzkxOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3ZhciBlPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7dmFyIHQ9RnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO3ZhciBuPS9eXFxzKig/OmZ1bmN0aW9uKT9cXCovO3ZhciBvPXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PT1cInN5bWJvbFwiO3ZhciBpPU9iamVjdC5nZXRQcm90b3R5cGVPZjt2YXIgZ2V0R2VuZXJhdG9yRnVuYz1mdW5jdGlvbigpe2lmKCFvKXtyZXR1cm4gZmFsc2V9dHJ5e3JldHVybiBGdW5jdGlvbihcInJldHVybiBmdW5jdGlvbiooKSB7fVwiKSgpfWNhdGNoKHIpe319O3ZhciBhPWdldEdlbmVyYXRvckZ1bmMoKTt2YXIgZj1hP2koYSk6e307ci5leHBvcnRzPWZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24ocil7aWYodHlwZW9mIHIhPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZihuLnRlc3QodC5jYWxsKHIpKSl7cmV0dXJuIHRydWV9aWYoIW8pe3ZhciBhPWUuY2FsbChyKTtyZXR1cm4gYT09PVwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIn1yZXR1cm4gaShyKT09PWZ9fSw5OTQ6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoMTQ0KTt2YXIgbz10KDM0OSk7dmFyIGk9dCgyNTYpO3ZhciBhPWkoXCJPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXCIpO3ZhciBmPXQoOTQyKSgpO3ZhciB1PWYmJnR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PT1cInN5bWJvbFwiO3ZhciBzPW8oKTt2YXIgeT1pKFwiQXJyYXkucHJvdG90eXBlLmluZGV4T2ZcIix0cnVlKXx8ZnVuY3Rpb24gaW5kZXhPZihyLGUpe2Zvcih2YXIgdD0wO3Q8ci5sZW5ndGg7dCs9MSl7aWYoclt0XT09PWUpe3JldHVybiB0fX1yZXR1cm4tMX07dmFyIGM9aShcIlN0cmluZy5wcm90b3R5cGUuc2xpY2VcIik7dmFyIHA9e307dmFyIGw9dCg0NjYpO3ZhciBnPU9iamVjdC5nZXRQcm90b3R5cGVPZjtpZih1JiZsJiZnKXtuKHMsKGZ1bmN0aW9uKHIpe3ZhciBlPW5ldyBnbG9iYWxbcl07aWYoIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gZSkpe3Rocm93IG5ldyBFdmFsRXJyb3IoXCJ0aGlzIGVuZ2luZSBoYXMgc3VwcG9ydCBmb3IgU3ltYm9sLnRvU3RyaW5nVGFnLCBidXQgXCIrcitcIiBkb2VzIG5vdCBoYXZlIHRoZSBwcm9wZXJ0eSEgUGxlYXNlIHJlcG9ydCB0aGlzLlwiKX12YXIgdD1nKGUpO3ZhciBuPWwodCxTeW1ib2wudG9TdHJpbmdUYWcpO2lmKCFuKXt2YXIgbz1nKHQpO249bChvLFN5bWJvbC50b1N0cmluZ1RhZyl9cFtyXT1uLmdldH0pKX12YXIgYj1mdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyhyKXt2YXIgZT1mYWxzZTtuKHAsKGZ1bmN0aW9uKHQsbil7aWYoIWUpe3RyeXtlPXQuY2FsbChyKT09PW59Y2F0Y2gocil7fX19KSk7cmV0dXJuIGV9O3IuZXhwb3J0cz1mdW5jdGlvbiBpc1R5cGVkQXJyYXkocil7aWYoIXJ8fHR5cGVvZiByIT09XCJvYmplY3RcIil7cmV0dXJuIGZhbHNlfWlmKCF1KXt2YXIgZT1jKGEociksOCwtMSk7cmV0dXJuIHkocyxlKT4tMX1pZighbCl7cmV0dXJuIGZhbHNlfXJldHVybiBiKHIpfX0sMzY5OmZ1bmN0aW9uKHIpe3IuZXhwb3J0cz1mdW5jdGlvbiBpc0J1ZmZlcihyKXtyZXR1cm4gciBpbnN0YW5jZW9mIEJ1ZmZlcn19LDU4NDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCgxNTcpO3ZhciBvPXQoMzkxKTt2YXIgaT10KDQ5MCk7dmFyIGE9dCg5OTQpO2Z1bmN0aW9uIHVuY3VycnlUaGlzKHIpe3JldHVybiByLmNhbGwuYmluZChyKX12YXIgZj10eXBlb2YgQmlnSW50IT09XCJ1bmRlZmluZWRcIjt2YXIgdT10eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIjt2YXIgcz11bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTt2YXIgeT11bmN1cnJ5VGhpcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YpO3ZhciBjPXVuY3VycnlUaGlzKFN0cmluZy5wcm90b3R5cGUudmFsdWVPZik7dmFyIHA9dW5jdXJyeVRoaXMoQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZik7aWYoZil7dmFyIGw9dW5jdXJyeVRoaXMoQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mKX1pZih1KXt2YXIgZz11bmN1cnJ5VGhpcyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpfWZ1bmN0aW9uIGNoZWNrQm94ZWRQcmltaXRpdmUocixlKXtpZih0eXBlb2YgciE9PVwib2JqZWN0XCIpe3JldHVybiBmYWxzZX10cnl7ZShyKTtyZXR1cm4gdHJ1ZX1jYXRjaChyKXtyZXR1cm4gZmFsc2V9fWUuaXNBcmd1bWVudHNPYmplY3Q9bjtlLmlzR2VuZXJhdG9yRnVuY3Rpb249bztlLmlzVHlwZWRBcnJheT1hO2Z1bmN0aW9uIGlzUHJvbWlzZShyKXtyZXR1cm4gdHlwZW9mIFByb21pc2UhPT1cInVuZGVmaW5lZFwiJiZyIGluc3RhbmNlb2YgUHJvbWlzZXx8ciE9PW51bGwmJnR5cGVvZiByPT09XCJvYmplY3RcIiYmdHlwZW9mIHIudGhlbj09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIHIuY2F0Y2g9PT1cImZ1bmN0aW9uXCJ9ZS5pc1Byb21pc2U9aXNQcm9taXNlO2Z1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHIpe2lmKHR5cGVvZiBBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCImJkFycmF5QnVmZmVyLmlzVmlldyl7cmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhyKX1yZXR1cm4gYShyKXx8aXNEYXRhVmlldyhyKX1lLmlzQXJyYXlCdWZmZXJWaWV3PWlzQXJyYXlCdWZmZXJWaWV3O2Z1bmN0aW9uIGlzVWludDhBcnJheShyKXtyZXR1cm4gaShyKT09PVwiVWludDhBcnJheVwifWUuaXNVaW50OEFycmF5PWlzVWludDhBcnJheTtmdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJVaW50OENsYW1wZWRBcnJheVwifWUuaXNVaW50OENsYW1wZWRBcnJheT1pc1VpbnQ4Q2xhbXBlZEFycmF5O2Z1bmN0aW9uIGlzVWludDE2QXJyYXkocil7cmV0dXJuIGkocik9PT1cIlVpbnQxNkFycmF5XCJ9ZS5pc1VpbnQxNkFycmF5PWlzVWludDE2QXJyYXk7ZnVuY3Rpb24gaXNVaW50MzJBcnJheShyKXtyZXR1cm4gaShyKT09PVwiVWludDMyQXJyYXlcIn1lLmlzVWludDMyQXJyYXk9aXNVaW50MzJBcnJheTtmdW5jdGlvbiBpc0ludDhBcnJheShyKXtyZXR1cm4gaShyKT09PVwiSW50OEFycmF5XCJ9ZS5pc0ludDhBcnJheT1pc0ludDhBcnJheTtmdW5jdGlvbiBpc0ludDE2QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkludDE2QXJyYXlcIn1lLmlzSW50MTZBcnJheT1pc0ludDE2QXJyYXk7ZnVuY3Rpb24gaXNJbnQzMkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJJbnQzMkFycmF5XCJ9ZS5pc0ludDMyQXJyYXk9aXNJbnQzMkFycmF5O2Z1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJGbG9hdDMyQXJyYXlcIn1lLmlzRmxvYXQzMkFycmF5PWlzRmxvYXQzMkFycmF5O2Z1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJGbG9hdDY0QXJyYXlcIn1lLmlzRmxvYXQ2NEFycmF5PWlzRmxvYXQ2NEFycmF5O2Z1bmN0aW9uIGlzQmlnSW50NjRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiQmlnSW50NjRBcnJheVwifWUuaXNCaWdJbnQ2NEFycmF5PWlzQmlnSW50NjRBcnJheTtmdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJCaWdVaW50NjRBcnJheVwifWUuaXNCaWdVaW50NjRBcnJheT1pc0JpZ1VpbnQ2NEFycmF5O2Z1bmN0aW9uIGlzTWFwVG9TdHJpbmcocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgTWFwXVwifWlzTWFwVG9TdHJpbmcud29ya2luZz10eXBlb2YgTWFwIT09XCJ1bmRlZmluZWRcIiYmaXNNYXBUb1N0cmluZyhuZXcgTWFwKTtmdW5jdGlvbiBpc01hcChyKXtpZih0eXBlb2YgTWFwPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc01hcFRvU3RyaW5nLndvcmtpbmc/aXNNYXBUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgTWFwfWUuaXNNYXA9aXNNYXA7ZnVuY3Rpb24gaXNTZXRUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBTZXRdXCJ9aXNTZXRUb1N0cmluZy53b3JraW5nPXR5cGVvZiBTZXQhPT1cInVuZGVmaW5lZFwiJiZpc1NldFRvU3RyaW5nKG5ldyBTZXQpO2Z1bmN0aW9uIGlzU2V0KHIpe2lmKHR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGlzU2V0VG9TdHJpbmcud29ya2luZz9pc1NldFRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBTZXR9ZS5pc1NldD1pc1NldDtmdW5jdGlvbiBpc1dlYWtNYXBUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBXZWFrTWFwXVwifWlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIFdlYWtNYXAhPT1cInVuZGVmaW5lZFwiJiZpc1dlYWtNYXBUb1N0cmluZyhuZXcgV2Vha01hcCk7ZnVuY3Rpb24gaXNXZWFrTWFwKHIpe2lmKHR5cGVvZiBXZWFrTWFwPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc1dlYWtNYXBUb1N0cmluZy53b3JraW5nP2lzV2Vha01hcFRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBXZWFrTWFwfWUuaXNXZWFrTWFwPWlzV2Vha01hcDtmdW5jdGlvbiBpc1dlYWtTZXRUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBXZWFrU2V0XVwifWlzV2Vha1NldFRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIFdlYWtTZXQhPT1cInVuZGVmaW5lZFwiJiZpc1dlYWtTZXRUb1N0cmluZyhuZXcgV2Vha1NldCk7ZnVuY3Rpb24gaXNXZWFrU2V0KHIpe3JldHVybiBpc1dlYWtTZXRUb1N0cmluZyhyKX1lLmlzV2Vha1NldD1pc1dlYWtTZXQ7ZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IEFycmF5QnVmZmVyXVwifWlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nPXR5cGVvZiBBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCImJmlzQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgQXJyYXlCdWZmZXIpO2Z1bmN0aW9uIGlzQXJyYXlCdWZmZXIocil7aWYodHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz9pc0FycmF5QnVmZmVyVG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfWUuaXNBcnJheUJ1ZmZlcj1pc0FycmF5QnVmZmVyO2Z1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBEYXRhVmlld11cIn1pc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZz10eXBlb2YgQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiZ0eXBlb2YgRGF0YVZpZXchPT1cInVuZGVmaW5lZFwiJiZpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwwLDEpKTtmdW5jdGlvbiBpc0RhdGFWaWV3KHIpe2lmKHR5cGVvZiBEYXRhVmlldz09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmc/aXNEYXRhVmlld1RvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBEYXRhVmlld31lLmlzRGF0YVZpZXc9aXNEYXRhVmlldzt2YXIgYj10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiP1NoYXJlZEFycmF5QnVmZmVyOnVuZGVmaW5lZDtmdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdXCJ9ZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlcihyKXtpZih0eXBlb2YgYj09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc9PT1cInVuZGVmaW5lZFwiKXtpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz1pc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcobmV3IGIpfXJldHVybiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz9pc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIGJ9ZS5pc1NoYXJlZEFycmF5QnVmZmVyPWlzU2hhcmVkQXJyYXlCdWZmZXI7ZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dXCJ9ZS5pc0FzeW5jRnVuY3Rpb249aXNBc3luY0Z1bmN0aW9uO2Z1bmN0aW9uIGlzTWFwSXRlcmF0b3Iocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgTWFwIEl0ZXJhdG9yXVwifWUuaXNNYXBJdGVyYXRvcj1pc01hcEl0ZXJhdG9yO2Z1bmN0aW9uIGlzU2V0SXRlcmF0b3Iocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgU2V0IEl0ZXJhdG9yXVwifWUuaXNTZXRJdGVyYXRvcj1pc1NldEl0ZXJhdG9yO2Z1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IEdlbmVyYXRvcl1cIn1lLmlzR2VuZXJhdG9yT2JqZWN0PWlzR2VuZXJhdG9yT2JqZWN0O2Z1bmN0aW9uIGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZShyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBXZWJBc3NlbWJseS5Nb2R1bGVdXCJ9ZS5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU9aXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlO2Z1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHIpe3JldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHIseSl9ZS5pc051bWJlck9iamVjdD1pc051bWJlck9iamVjdDtmdW5jdGlvbiBpc1N0cmluZ09iamVjdChyKXtyZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZShyLGMpfWUuaXNTdHJpbmdPYmplY3Q9aXNTdHJpbmdPYmplY3Q7ZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHIpe3JldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHIscCl9ZS5pc0Jvb2xlYW5PYmplY3Q9aXNCb29sZWFuT2JqZWN0O2Z1bmN0aW9uIGlzQmlnSW50T2JqZWN0KHIpe3JldHVybiBmJiZjaGVja0JveGVkUHJpbWl0aXZlKHIsbCl9ZS5pc0JpZ0ludE9iamVjdD1pc0JpZ0ludE9iamVjdDtmdW5jdGlvbiBpc1N5bWJvbE9iamVjdChyKXtyZXR1cm4gdSYmY2hlY2tCb3hlZFByaW1pdGl2ZShyLGcpfWUuaXNTeW1ib2xPYmplY3Q9aXNTeW1ib2xPYmplY3Q7ZnVuY3Rpb24gaXNCb3hlZFByaW1pdGl2ZShyKXtyZXR1cm4gaXNOdW1iZXJPYmplY3Qocil8fGlzU3RyaW5nT2JqZWN0KHIpfHxpc0Jvb2xlYW5PYmplY3Qocil8fGlzQmlnSW50T2JqZWN0KHIpfHxpc1N5bWJvbE9iamVjdChyKX1lLmlzQm94ZWRQcmltaXRpdmU9aXNCb3hlZFByaW1pdGl2ZTtmdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHIpe3JldHVybiB0eXBlb2YgVWludDhBcnJheSE9PVwidW5kZWZpbmVkXCImJihpc0FycmF5QnVmZmVyKHIpfHxpc1NoYXJlZEFycmF5QnVmZmVyKHIpKX1lLmlzQW55QXJyYXlCdWZmZXI9aXNBbnlBcnJheUJ1ZmZlcjtbXCJpc1Byb3h5XCIsXCJpc0V4dGVybmFsXCIsXCJpc01vZHVsZU5hbWVzcGFjZU9iamVjdFwiXS5mb3JFYWNoKChmdW5jdGlvbihyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOmZhbHNlLHZhbHVlOmZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKHIrXCIgaXMgbm90IHN1cHBvcnRlZCBpbiB1c2VybGFuZFwiKX19KX0pKX0sMTc3OmZ1bmN0aW9uKHIsZSx0KXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yc3x8ZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhyKXt2YXIgZT1PYmplY3Qua2V5cyhyKTt2YXIgdD17fTtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dFtlW25dXT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZVtuXSl9cmV0dXJuIHR9O3ZhciBvPS8lW3NkaiVdL2c7ZS5mb3JtYXQ9ZnVuY3Rpb24ocil7aWYoIWlzU3RyaW5nKHIpKXt2YXIgZT1bXTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXtlLnB1c2goaW5zcGVjdChhcmd1bWVudHNbdF0pKX1yZXR1cm4gZS5qb2luKFwiIFwiKX12YXIgdD0xO3ZhciBuPWFyZ3VtZW50czt2YXIgaT1uLmxlbmd0aDt2YXIgYT1TdHJpbmcocikucmVwbGFjZShvLChmdW5jdGlvbihyKXtpZihyPT09XCIlJVwiKXJldHVyblwiJVwiO2lmKHQ+PWkpcmV0dXJuIHI7c3dpdGNoKHIpe2Nhc2VcIiVzXCI6cmV0dXJuIFN0cmluZyhuW3QrK10pO2Nhc2VcIiVkXCI6cmV0dXJuIE51bWJlcihuW3QrK10pO2Nhc2VcIiVqXCI6dHJ5e3JldHVybiBKU09OLnN0cmluZ2lmeShuW3QrK10pfWNhdGNoKHIpe3JldHVyblwiW0NpcmN1bGFyXVwifWRlZmF1bHQ6cmV0dXJuIHJ9fSkpO2Zvcih2YXIgZj1uW3RdO3Q8aTtmPW5bKyt0XSl7aWYoaXNOdWxsKGYpfHwhaXNPYmplY3QoZikpe2ErPVwiIFwiK2Z9ZWxzZXthKz1cIiBcIitpbnNwZWN0KGYpfX1yZXR1cm4gYX07ZS5kZXByZWNhdGU9ZnVuY3Rpb24ocix0KXtpZih0eXBlb2YgcHJvY2VzcyE9PVwidW5kZWZpbmVkXCImJnByb2Nlc3Mubm9EZXByZWNhdGlvbj09PXRydWUpe3JldHVybiByfWlmKHR5cGVvZiBwcm9jZXNzPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUuZGVwcmVjYXRlKHIsdCkuYXBwbHkodGhpcyxhcmd1bWVudHMpfX12YXIgbj1mYWxzZTtmdW5jdGlvbiBkZXByZWNhdGVkKCl7aWYoIW4pe2lmKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbil7dGhyb3cgbmV3IEVycm9yKHQpfWVsc2UgaWYocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKXtjb25zb2xlLnRyYWNlKHQpfWVsc2V7Y29uc29sZS5lcnJvcih0KX1uPXRydWV9cmV0dXJuIHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBkZXByZWNhdGVkfTt2YXIgaT17fTt2YXIgYT0vXiQvO2lmKHByb2Nlc3MuZW52Lk5PREVfREVCVUcpe3ZhciBmPXByb2Nlc3MuZW52Lk5PREVfREVCVUc7Zj1mLnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csXCJcXFxcJCZcIikucmVwbGFjZSgvXFwqL2csXCIuKlwiKS5yZXBsYWNlKC8sL2csXCIkfF5cIikudG9VcHBlckNhc2UoKTthPW5ldyBSZWdFeHAoXCJeXCIrZitcIiRcIixcImlcIil9ZS5kZWJ1Z2xvZz1mdW5jdGlvbihyKXtyPXIudG9VcHBlckNhc2UoKTtpZighaVtyXSl7aWYoYS50ZXN0KHIpKXt2YXIgdD1wcm9jZXNzLnBpZDtpW3JdPWZ1bmN0aW9uKCl7dmFyIG49ZS5mb3JtYXQuYXBwbHkoZSxhcmd1bWVudHMpO2NvbnNvbGUuZXJyb3IoXCIlcyAlZDogJXNcIixyLHQsbil9fWVsc2V7aVtyXT1mdW5jdGlvbigpe319fXJldHVybiBpW3JdfTtmdW5jdGlvbiBpbnNwZWN0KHIsdCl7dmFyIG49e3NlZW46W10sc3R5bGl6ZTpzdHlsaXplTm9Db2xvcn07aWYoYXJndW1lbnRzLmxlbmd0aD49MyluLmRlcHRoPWFyZ3VtZW50c1syXTtpZihhcmd1bWVudHMubGVuZ3RoPj00KW4uY29sb3JzPWFyZ3VtZW50c1szXTtpZihpc0Jvb2xlYW4odCkpe24uc2hvd0hpZGRlbj10fWVsc2UgaWYodCl7ZS5fZXh0ZW5kKG4sdCl9aWYoaXNVbmRlZmluZWQobi5zaG93SGlkZGVuKSluLnNob3dIaWRkZW49ZmFsc2U7aWYoaXNVbmRlZmluZWQobi5kZXB0aCkpbi5kZXB0aD0yO2lmKGlzVW5kZWZpbmVkKG4uY29sb3JzKSluLmNvbG9ycz1mYWxzZTtpZihpc1VuZGVmaW5lZChuLmN1c3RvbUluc3BlY3QpKW4uY3VzdG9tSW5zcGVjdD10cnVlO2lmKG4uY29sb3JzKW4uc3R5bGl6ZT1zdHlsaXplV2l0aENvbG9yO3JldHVybiBmb3JtYXRWYWx1ZShuLHIsbi5kZXB0aCl9ZS5pbnNwZWN0PWluc3BlY3Q7aW5zcGVjdC5jb2xvcnM9e2JvbGQ6WzEsMjJdLGl0YWxpYzpbMywyM10sdW5kZXJsaW5lOls0LDI0XSxpbnZlcnNlOls3LDI3XSx3aGl0ZTpbMzcsMzldLGdyZXk6WzkwLDM5XSxibGFjazpbMzAsMzldLGJsdWU6WzM0LDM5XSxjeWFuOlszNiwzOV0sZ3JlZW46WzMyLDM5XSxtYWdlbnRhOlszNSwzOV0scmVkOlszMSwzOV0seWVsbG93OlszMywzOV19O2luc3BlY3Quc3R5bGVzPXtzcGVjaWFsOlwiY3lhblwiLG51bWJlcjpcInllbGxvd1wiLGJvb2xlYW46XCJ5ZWxsb3dcIix1bmRlZmluZWQ6XCJncmV5XCIsbnVsbDpcImJvbGRcIixzdHJpbmc6XCJncmVlblwiLGRhdGU6XCJtYWdlbnRhXCIscmVnZXhwOlwicmVkXCJ9O2Z1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3IocixlKXt2YXIgdD1pbnNwZWN0LnN0eWxlc1tlXTtpZih0KXtyZXR1cm5cIlx1MDAxYltcIitpbnNwZWN0LmNvbG9yc1t0XVswXStcIm1cIityK1wiXHUwMDFiW1wiK2luc3BlY3QuY29sb3JzW3RdWzFdK1wibVwifWVsc2V7cmV0dXJuIHJ9fWZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHIsZSl7cmV0dXJuIHJ9ZnVuY3Rpb24gYXJyYXlUb0hhc2gocil7dmFyIGU9e307ci5mb3JFYWNoKChmdW5jdGlvbihyLHQpe2Vbcl09dHJ1ZX0pKTtyZXR1cm4gZX1mdW5jdGlvbiBmb3JtYXRWYWx1ZShyLHQsbil7aWYoci5jdXN0b21JbnNwZWN0JiZ0JiZpc0Z1bmN0aW9uKHQuaW5zcGVjdCkmJnQuaW5zcGVjdCE9PWUuaW5zcGVjdCYmISh0LmNvbnN0cnVjdG9yJiZ0LmNvbnN0cnVjdG9yLnByb3RvdHlwZT09PXQpKXt2YXIgbz10Lmluc3BlY3QobixyKTtpZighaXNTdHJpbmcobykpe289Zm9ybWF0VmFsdWUocixvLG4pfXJldHVybiBvfXZhciBpPWZvcm1hdFByaW1pdGl2ZShyLHQpO2lmKGkpe3JldHVybiBpfXZhciBhPU9iamVjdC5rZXlzKHQpO3ZhciBmPWFycmF5VG9IYXNoKGEpO2lmKHIuc2hvd0hpZGRlbil7YT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0KX1pZihpc0Vycm9yKHQpJiYoYS5pbmRleE9mKFwibWVzc2FnZVwiKT49MHx8YS5pbmRleE9mKFwiZGVzY3JpcHRpb25cIik+PTApKXtyZXR1cm4gZm9ybWF0RXJyb3IodCl9aWYoYS5sZW5ndGg9PT0wKXtpZihpc0Z1bmN0aW9uKHQpKXt2YXIgdT10Lm5hbWU/XCI6IFwiK3QubmFtZTpcIlwiO3JldHVybiByLnN0eWxpemUoXCJbRnVuY3Rpb25cIit1K1wiXVwiLFwic3BlY2lhbFwiKX1pZihpc1JlZ0V4cCh0KSl7cmV0dXJuIHIuc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCksXCJyZWdleHBcIil9aWYoaXNEYXRlKHQpKXtyZXR1cm4gci5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCksXCJkYXRlXCIpfWlmKGlzRXJyb3IodCkpe3JldHVybiBmb3JtYXRFcnJvcih0KX19dmFyIHM9XCJcIix5PWZhbHNlLGM9W1wie1wiLFwifVwiXTtpZihpc0FycmF5KHQpKXt5PXRydWU7Yz1bXCJbXCIsXCJdXCJdfWlmKGlzRnVuY3Rpb24odCkpe3ZhciBwPXQubmFtZT9cIjogXCIrdC5uYW1lOlwiXCI7cz1cIiBbRnVuY3Rpb25cIitwK1wiXVwifWlmKGlzUmVnRXhwKHQpKXtzPVwiIFwiK1JlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX1pZihpc0RhdGUodCkpe3M9XCIgXCIrRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh0KX1pZihpc0Vycm9yKHQpKXtzPVwiIFwiK2Zvcm1hdEVycm9yKHQpfWlmKGEubGVuZ3RoPT09MCYmKCF5fHx0Lmxlbmd0aD09MCkpe3JldHVybiBjWzBdK3MrY1sxXX1pZihuPDApe2lmKGlzUmVnRXhwKHQpKXtyZXR1cm4gci5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSxcInJlZ2V4cFwiKX1lbHNle3JldHVybiByLnN0eWxpemUoXCJbT2JqZWN0XVwiLFwic3BlY2lhbFwiKX19ci5zZWVuLnB1c2godCk7dmFyIGw7aWYoeSl7bD1mb3JtYXRBcnJheShyLHQsbixmLGEpfWVsc2V7bD1hLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGZvcm1hdFByb3BlcnR5KHIsdCxuLGYsZSx5KX0pKX1yLnNlZW4ucG9wKCk7cmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKGwscyxjKX1mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUocixlKXtpZihpc1VuZGVmaW5lZChlKSlyZXR1cm4gci5zdHlsaXplKFwidW5kZWZpbmVkXCIsXCJ1bmRlZmluZWRcIik7aWYoaXNTdHJpbmcoZSkpe3ZhciB0PVwiJ1wiK0pTT04uc3RyaW5naWZ5KGUpLnJlcGxhY2UoL15cInxcIiQvZyxcIlwiKS5yZXBsYWNlKC8nL2csXCJcXFxcJ1wiKS5yZXBsYWNlKC9cXFxcXCIvZywnXCInKStcIidcIjtyZXR1cm4gci5zdHlsaXplKHQsXCJzdHJpbmdcIil9aWYoaXNOdW1iZXIoZSkpcmV0dXJuIHIuc3R5bGl6ZShcIlwiK2UsXCJudW1iZXJcIik7aWYoaXNCb29sZWFuKGUpKXJldHVybiByLnN0eWxpemUoXCJcIitlLFwiYm9vbGVhblwiKTtpZihpc051bGwoZSkpcmV0dXJuIHIuc3R5bGl6ZShcIm51bGxcIixcIm51bGxcIil9ZnVuY3Rpb24gZm9ybWF0RXJyb3Iocil7cmV0dXJuXCJbXCIrRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocikrXCJdXCJ9ZnVuY3Rpb24gZm9ybWF0QXJyYXkocixlLHQsbixvKXt2YXIgaT1bXTtmb3IodmFyIGE9MCxmPWUubGVuZ3RoO2E8ZjsrK2Epe2lmKGhhc093blByb3BlcnR5KGUsU3RyaW5nKGEpKSl7aS5wdXNoKGZvcm1hdFByb3BlcnR5KHIsZSx0LG4sU3RyaW5nKGEpLHRydWUpKX1lbHNle2kucHVzaChcIlwiKX19by5mb3JFYWNoKChmdW5jdGlvbihvKXtpZighby5tYXRjaCgvXlxcZCskLykpe2kucHVzaChmb3JtYXRQcm9wZXJ0eShyLGUsdCxuLG8sdHJ1ZSkpfX0pKTtyZXR1cm4gaX1mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShyLGUsdCxuLG8saSl7dmFyIGEsZix1O3U9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG8pfHx7dmFsdWU6ZVtvXX07aWYodS5nZXQpe2lmKHUuc2V0KXtmPXIuc3R5bGl6ZShcIltHZXR0ZXIvU2V0dGVyXVwiLFwic3BlY2lhbFwiKX1lbHNle2Y9ci5zdHlsaXplKFwiW0dldHRlcl1cIixcInNwZWNpYWxcIil9fWVsc2V7aWYodS5zZXQpe2Y9ci5zdHlsaXplKFwiW1NldHRlcl1cIixcInNwZWNpYWxcIil9fWlmKCFoYXNPd25Qcm9wZXJ0eShuLG8pKXthPVwiW1wiK28rXCJdXCJ9aWYoIWYpe2lmKHIuc2Vlbi5pbmRleE9mKHUudmFsdWUpPDApe2lmKGlzTnVsbCh0KSl7Zj1mb3JtYXRWYWx1ZShyLHUudmFsdWUsbnVsbCl9ZWxzZXtmPWZvcm1hdFZhbHVlKHIsdS52YWx1ZSx0LTEpfWlmKGYuaW5kZXhPZihcIlxcblwiKT4tMSl7aWYoaSl7Zj1mLnNwbGl0KFwiXFxuXCIpLm1hcCgoZnVuY3Rpb24ocil7cmV0dXJuXCIgIFwiK3J9KSkuam9pbihcIlxcblwiKS5zdWJzdHIoMil9ZWxzZXtmPVwiXFxuXCIrZi5zcGxpdChcIlxcblwiKS5tYXAoKGZ1bmN0aW9uKHIpe3JldHVyblwiICAgXCIrcn0pKS5qb2luKFwiXFxuXCIpfX19ZWxzZXtmPXIuc3R5bGl6ZShcIltDaXJjdWxhcl1cIixcInNwZWNpYWxcIil9fWlmKGlzVW5kZWZpbmVkKGEpKXtpZihpJiZvLm1hdGNoKC9eXFxkKyQvKSl7cmV0dXJuIGZ9YT1KU09OLnN0cmluZ2lmeShcIlwiK28pO2lmKGEubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKXthPWEuc3Vic3RyKDEsYS5sZW5ndGgtMik7YT1yLnN0eWxpemUoYSxcIm5hbWVcIil9ZWxzZXthPWEucmVwbGFjZSgvJy9nLFwiXFxcXCdcIikucmVwbGFjZSgvXFxcXFwiL2csJ1wiJykucmVwbGFjZSgvKF5cInxcIiQpL2csXCInXCIpO2E9ci5zdHlsaXplKGEsXCJzdHJpbmdcIil9fXJldHVybiBhK1wiOiBcIitmfWZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKHIsZSx0KXt2YXIgbj0wO3ZhciBvPXIucmVkdWNlKChmdW5jdGlvbihyLGUpe24rKztpZihlLmluZGV4T2YoXCJcXG5cIik+PTApbisrO3JldHVybiByK2UucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csXCJcIikubGVuZ3RoKzF9KSwwKTtpZihvPjYwKXtyZXR1cm4gdFswXSsoZT09PVwiXCI/XCJcIjplK1wiXFxuIFwiKStcIiBcIityLmpvaW4oXCIsXFxuICBcIikrXCIgXCIrdFsxXX1yZXR1cm4gdFswXStlK1wiIFwiK3Iuam9pbihcIiwgXCIpK1wiIFwiK3RbMV19ZS50eXBlcz10KDU4NCk7ZnVuY3Rpb24gaXNBcnJheShyKXtyZXR1cm4gQXJyYXkuaXNBcnJheShyKX1lLmlzQXJyYXk9aXNBcnJheTtmdW5jdGlvbiBpc0Jvb2xlYW4ocil7cmV0dXJuIHR5cGVvZiByPT09XCJib29sZWFuXCJ9ZS5pc0Jvb2xlYW49aXNCb29sZWFuO2Z1bmN0aW9uIGlzTnVsbChyKXtyZXR1cm4gcj09PW51bGx9ZS5pc051bGw9aXNOdWxsO2Z1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHIpe3JldHVybiByPT1udWxsfWUuaXNOdWxsT3JVbmRlZmluZWQ9aXNOdWxsT3JVbmRlZmluZWQ7ZnVuY3Rpb24gaXNOdW1iZXIocil7cmV0dXJuIHR5cGVvZiByPT09XCJudW1iZXJcIn1lLmlzTnVtYmVyPWlzTnVtYmVyO2Z1bmN0aW9uIGlzU3RyaW5nKHIpe3JldHVybiB0eXBlb2Ygcj09PVwic3RyaW5nXCJ9ZS5pc1N0cmluZz1pc1N0cmluZztmdW5jdGlvbiBpc1N5bWJvbChyKXtyZXR1cm4gdHlwZW9mIHI9PT1cInN5bWJvbFwifWUuaXNTeW1ib2w9aXNTeW1ib2w7ZnVuY3Rpb24gaXNVbmRlZmluZWQocil7cmV0dXJuIHI9PT12b2lkIDB9ZS5pc1VuZGVmaW5lZD1pc1VuZGVmaW5lZDtmdW5jdGlvbiBpc1JlZ0V4cChyKXtyZXR1cm4gaXNPYmplY3QocikmJm9iamVjdFRvU3RyaW5nKHIpPT09XCJbb2JqZWN0IFJlZ0V4cF1cIn1lLmlzUmVnRXhwPWlzUmVnRXhwO2UudHlwZXMuaXNSZWdFeHA9aXNSZWdFeHA7ZnVuY3Rpb24gaXNPYmplY3Qocil7cmV0dXJuIHR5cGVvZiByPT09XCJvYmplY3RcIiYmciE9PW51bGx9ZS5pc09iamVjdD1pc09iamVjdDtmdW5jdGlvbiBpc0RhdGUocil7cmV0dXJuIGlzT2JqZWN0KHIpJiZvYmplY3RUb1N0cmluZyhyKT09PVwiW29iamVjdCBEYXRlXVwifWUuaXNEYXRlPWlzRGF0ZTtlLnR5cGVzLmlzRGF0ZT1pc0RhdGU7ZnVuY3Rpb24gaXNFcnJvcihyKXtyZXR1cm4gaXNPYmplY3QocikmJihvYmplY3RUb1N0cmluZyhyKT09PVwiW29iamVjdCBFcnJvcl1cInx8ciBpbnN0YW5jZW9mIEVycm9yKX1lLmlzRXJyb3I9aXNFcnJvcjtlLnR5cGVzLmlzTmF0aXZlRXJyb3I9aXNFcnJvcjtmdW5jdGlvbiBpc0Z1bmN0aW9uKHIpe3JldHVybiB0eXBlb2Ygcj09PVwiZnVuY3Rpb25cIn1lLmlzRnVuY3Rpb249aXNGdW5jdGlvbjtmdW5jdGlvbiBpc1ByaW1pdGl2ZShyKXtyZXR1cm4gcj09PW51bGx8fHR5cGVvZiByPT09XCJib29sZWFuXCJ8fHR5cGVvZiByPT09XCJudW1iZXJcInx8dHlwZW9mIHI9PT1cInN0cmluZ1wifHx0eXBlb2Ygcj09PVwic3ltYm9sXCJ8fHR5cGVvZiByPT09XCJ1bmRlZmluZWRcIn1lLmlzUHJpbWl0aXZlPWlzUHJpbWl0aXZlO2UuaXNCdWZmZXI9dCgzNjkpO2Z1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHIpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocil9ZnVuY3Rpb24gcGFkKHIpe3JldHVybiByPDEwP1wiMFwiK3IudG9TdHJpbmcoMTApOnIudG9TdHJpbmcoMTApfXZhciB1PVtcIkphblwiLFwiRmViXCIsXCJNYXJcIixcIkFwclwiLFwiTWF5XCIsXCJKdW5cIixcIkp1bFwiLFwiQXVnXCIsXCJTZXBcIixcIk9jdFwiLFwiTm92XCIsXCJEZWNcIl07ZnVuY3Rpb24gdGltZXN0YW1wKCl7dmFyIHI9bmV3IERhdGU7dmFyIGU9W3BhZChyLmdldEhvdXJzKCkpLHBhZChyLmdldE1pbnV0ZXMoKSkscGFkKHIuZ2V0U2Vjb25kcygpKV0uam9pbihcIjpcIik7cmV0dXJuW3IuZ2V0RGF0ZSgpLHVbci5nZXRNb250aCgpXSxlXS5qb2luKFwiIFwiKX1lLmxvZz1mdW5jdGlvbigpe2NvbnNvbGUubG9nKFwiJXMgLSAlc1wiLHRpbWVzdGFtcCgpLGUuZm9ybWF0LmFwcGx5KGUsYXJndW1lbnRzKSl9O2UuaW5oZXJpdHM9dCg3ODIpO2UuX2V4dGVuZD1mdW5jdGlvbihyLGUpe2lmKCFlfHwhaXNPYmplY3QoZSkpcmV0dXJuIHI7dmFyIHQ9T2JqZWN0LmtleXMoZSk7dmFyIG49dC5sZW5ndGg7d2hpbGUobi0tKXtyW3Rbbl1dPWVbdFtuXV19cmV0dXJuIHJ9O2Z1bmN0aW9uIGhhc093blByb3BlcnR5KHIsZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLGUpfXZhciBzPXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiP1N5bWJvbChcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiKTp1bmRlZmluZWQ7ZS5wcm9taXNpZnk9ZnVuY3Rpb24gcHJvbWlzaWZ5KHIpe2lmKHR5cGVvZiByIT09XCJmdW5jdGlvblwiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7aWYocyYmcltzXSl7dmFyIGU9cltzXTtpZih0eXBlb2YgZSE9PVwiZnVuY3Rpb25cIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscyx7dmFsdWU6ZSxlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOmZhbHNlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7cmV0dXJuIGV9ZnVuY3Rpb24gZSgpe3ZhciBlLHQ7dmFyIG49bmV3IFByb21pc2UoKGZ1bmN0aW9uKHIsbil7ZT1yO3Q9bn0pKTt2YXIgbz1bXTtmb3IodmFyIGk9MDtpPGFyZ3VtZW50cy5sZW5ndGg7aSsrKXtvLnB1c2goYXJndW1lbnRzW2ldKX1vLnB1c2goKGZ1bmN0aW9uKHIsbil7aWYocil7dChyKX1lbHNle2Uobil9fSkpO3RyeXtyLmFwcGx5KHRoaXMsbyl9Y2F0Y2gocil7dChyKX1yZXR1cm4gbn1PYmplY3Quc2V0UHJvdG90eXBlT2YoZSxPYmplY3QuZ2V0UHJvdG90eXBlT2YocikpO2lmKHMpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscyx7dmFsdWU6ZSxlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOmZhbHNlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsbihyKSl9O2UucHJvbWlzaWZ5LmN1c3RvbT1zO2Z1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyLGUpe2lmKCFyKXt2YXIgdD1uZXcgRXJyb3IoXCJQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWVcIik7dC5yZWFzb249cjtyPXR9cmV0dXJuIGUocil9ZnVuY3Rpb24gY2FsbGJhY2tpZnkocil7aWYodHlwZW9mIHIhPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyl9ZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpe3ZhciBlPVtdO2Zvcih2YXIgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe2UucHVzaChhcmd1bWVudHNbdF0pfXZhciBuPWUucG9wKCk7aWYodHlwZW9mIG4hPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb25cIil9dmFyIG89dGhpczt2YXIgY2I9ZnVuY3Rpb24oKXtyZXR1cm4gbi5hcHBseShvLGFyZ3VtZW50cyl9O3IuYXBwbHkodGhpcyxlKS50aGVuKChmdW5jdGlvbihyKXtwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCxudWxsLHIpKX0pLChmdW5jdGlvbihyKXtwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZC5iaW5kKG51bGwscixjYikpfSkpfU9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLE9iamVjdC5nZXRQcm90b3R5cGVPZihyKSk7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxuKHIpKTtyZXR1cm4gY2FsbGJhY2tpZmllZH1lLmNhbGxiYWNraWZ5PWNhbGxiYWNraWZ5fSw0OTA6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoMTQ0KTt2YXIgbz10KDM0OSk7dmFyIGk9dCgyNTYpO3ZhciBhPWkoXCJPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXCIpO3ZhciBmPXQoOTQyKSgpO3ZhciB1PWYmJnR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PT1cInN5bWJvbFwiO3ZhciBzPW8oKTt2YXIgeT1pKFwiU3RyaW5nLnByb3RvdHlwZS5zbGljZVwiKTt2YXIgYz17fTt2YXIgcD10KDQ2Nik7dmFyIGw9T2JqZWN0LmdldFByb3RvdHlwZU9mO2lmKHUmJnAmJmwpe24ocywoZnVuY3Rpb24ocil7aWYodHlwZW9mIGdsb2JhbFtyXT09PVwiZnVuY3Rpb25cIil7dmFyIGU9bmV3IGdsb2JhbFtyXTtpZighKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBlKSl7dGhyb3cgbmV3IEV2YWxFcnJvcihcInRoaXMgZW5naW5lIGhhcyBzdXBwb3J0IGZvciBTeW1ib2wudG9TdHJpbmdUYWcsIGJ1dCBcIityK1wiIGRvZXMgbm90IGhhdmUgdGhlIHByb3BlcnR5ISBQbGVhc2UgcmVwb3J0IHRoaXMuXCIpfXZhciB0PWwoZSk7dmFyIG49cCh0LFN5bWJvbC50b1N0cmluZ1RhZyk7aWYoIW4pe3ZhciBvPWwodCk7bj1wKG8sU3ltYm9sLnRvU3RyaW5nVGFnKX1jW3JdPW4uZ2V0fX0pKX12YXIgZz1mdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyhyKXt2YXIgZT1mYWxzZTtuKGMsKGZ1bmN0aW9uKHQsbil7aWYoIWUpe3RyeXt2YXIgbz10LmNhbGwocik7aWYobz09PW4pe2U9b319Y2F0Y2gocil7fX19KSk7cmV0dXJuIGV9O3ZhciBiPXQoOTk0KTtyLmV4cG9ydHM9ZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHIpe2lmKCFiKHIpKXtyZXR1cm4gZmFsc2V9aWYoIXUpe3JldHVybiB5KGEociksOCwtMSl9cmV0dXJuIGcocil9fSwzNDk6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoOTkyKTtyLmV4cG9ydHM9ZnVuY3Rpb24gYXZhaWxhYmxlVHlwZWRBcnJheXMoKXtyZXR1cm4gbihbXCJCaWdJbnQ2NEFycmF5XCIsXCJCaWdVaW50NjRBcnJheVwiLFwiRmxvYXQzMkFycmF5XCIsXCJGbG9hdDY0QXJyYXlcIixcIkludDE2QXJyYXlcIixcIkludDMyQXJyYXlcIixcIkludDhBcnJheVwiLFwiVWludDE2QXJyYXlcIixcIlVpbnQzMkFycmF5XCIsXCJVaW50OEFycmF5XCIsXCJVaW50OENsYW1wZWRBcnJheVwiXSwoZnVuY3Rpb24ocil7cmV0dXJuIHR5cGVvZiBnbG9iYWxbcl09PT1cImZ1bmN0aW9uXCJ9KSl9fSw0NjY6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoODM4KTt2YXIgbz1uKFwiJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlXCIsdHJ1ZSk7aWYobyl7dHJ5e28oW10sXCJsZW5ndGhcIil9Y2F0Y2gocil7bz1udWxsfX1yLmV4cG9ydHM9b319O3ZhciBlPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIG49ZVt0XTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBvPWVbdF09e2V4cG9ydHM6e319O3ZhciBpPXRydWU7dHJ5e3JbdF0obyxvLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7aT1mYWxzZX1maW5hbGx5e2lmKGkpZGVsZXRlIGVbdF19cmV0dXJuIG8uZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXygxNzcpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6WyJyIiwiZXhwb3J0cyIsInQiLCJuIiwiZmlsdGVyIiwiVHlwZUVycm9yIiwibyIsImkiLCJsZW5ndGgiLCJlIiwiY2FsbCIsImEiLCJwdXNoIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsQm91bmRJbnRyaW5zaWMiLCJmIiwidSIsInMiLCJ5IiwidmFsdWUiLCJjYWxsQmluZCIsImFyZ3VtZW50cyIsImNvbmZpZ3VyYWJsZSIsImMiLCJhcHBseUJpbmQiLCJhcHBseSIsInRvU3RyaW5nIiwiZm9yRWFjaCIsIkFycmF5Iiwic2xpY2UiLCJiaW5kIiwiYmluZGVyIiwiY29uY2F0IiwiTWF0aCIsIm1heCIsIkZ1bmN0aW9uIiwiam9pbiIsIkVtcHR5IiwiU3ludGF4RXJyb3IiLCJnZXRFdmFsbGVkQ29uc3RydWN0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ0aHJvd1R5cGVFcnJvciIsImNhbGxlZSIsImdldCIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwicCIsIlVpbnQ4QXJyYXkiLCJsIiwiQWdncmVnYXRlRXJyb3IiLCJBcnJheUJ1ZmZlciIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiQXRvbWljcyIsIkJpZ0ludCIsIkJvb2xlYW4iLCJEYXRhVmlldyIsIkRhdGUiLCJkZWNvZGVVUkkiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlbmNvZGVVUkkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJFcnJvciIsImV2YWwiLCJFdmFsRXJyb3IiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiaXNGaW5pdGUiLCJpc05hTiIsIkpTT04iLCJNYXAiLCJOdW1iZXIiLCJwYXJzZUZsb2F0IiwicGFyc2VJbnQiLCJQcm9taXNlIiwiUHJveHkiLCJSYW5nZUVycm9yIiwiUmVmZXJlbmNlRXJyb3IiLCJSZWZsZWN0IiwiUmVnRXhwIiwiU2V0IiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJTdHJpbmciLCJVaW50OENsYW1wZWRBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJVUklFcnJvciIsIldlYWtNYXAiLCJXZWFrUmVmIiwiV2Vha1NldCIsImciLCJkb0V2YWwiLCJiIiwiZCIsInYiLCJtIiwiUyIsInNwbGljZSIsIkEiLCJyZXBsYWNlIiwiaCIsIk8iLCJqIiwidyIsInN0cmluZ1RvUGF0aCIsIlAiLCJnZXRCYXNlSW50cmluc2ljIiwiYWxpYXMiLCJuYW1lIiwiR2V0SW50cmluc2ljIiwiaGFzTmF0aXZlU3ltYm9scyIsImhhc1N5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZW51bWVyYWJsZSIsImNyZWF0ZSIsImluaGVyaXRzIiwic3VwZXJfIiwiY29uc3RydWN0b3IiLCJ3cml0YWJsZSIsIlRlbXBDdG9yIiwidG9TdHJpbmdUYWciLCJpc0FyZ3VtZW50cyIsImlzTGVnYWN5QXJndW1lbnRzIiwiZ2V0R2VuZXJhdG9yRnVuYyIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJ0ZXN0IiwiaW5kZXhPZiIsImdsb2JhbCIsInRyeUFsbFR5cGVkQXJyYXlzIiwiaXNUeXBlZEFycmF5IiwiaXNCdWZmZXIiLCJCdWZmZXIiLCJ1bmN1cnJ5VGhpcyIsInZhbHVlT2YiLCJjaGVja0JveGVkUHJpbWl0aXZlIiwiaXNBcmd1bWVudHNPYmplY3QiLCJpc1Byb21pc2UiLCJ0aGVuIiwiY2F0Y2giLCJpc0FycmF5QnVmZmVyVmlldyIsImlzVmlldyIsImlzRGF0YVZpZXciLCJpc1VpbnQ4QXJyYXkiLCJpc1VpbnQ4Q2xhbXBlZEFycmF5IiwiaXNVaW50MTZBcnJheSIsImlzVWludDMyQXJyYXkiLCJpc0ludDhBcnJheSIsImlzSW50MTZBcnJheSIsImlzSW50MzJBcnJheSIsImlzRmxvYXQzMkFycmF5IiwiaXNGbG9hdDY0QXJyYXkiLCJpc0JpZ0ludDY0QXJyYXkiLCJpc0JpZ1VpbnQ2NEFycmF5IiwiaXNNYXBUb1N0cmluZyIsIndvcmtpbmciLCJpc01hcCIsImlzU2V0VG9TdHJpbmciLCJpc1NldCIsImlzV2Vha01hcFRvU3RyaW5nIiwiaXNXZWFrTWFwIiwiaXNXZWFrU2V0VG9TdHJpbmciLCJpc1dlYWtTZXQiLCJpc0FycmF5QnVmZmVyVG9TdHJpbmciLCJpc0FycmF5QnVmZmVyIiwiaXNEYXRhVmlld1RvU3RyaW5nIiwidW5kZWZpbmVkIiwiaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nIiwiaXNTaGFyZWRBcnJheUJ1ZmZlciIsImlzQXN5bmNGdW5jdGlvbiIsImlzTWFwSXRlcmF0b3IiLCJpc1NldEl0ZXJhdG9yIiwiaXNHZW5lcmF0b3JPYmplY3QiLCJpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUiLCJpc051bWJlck9iamVjdCIsImlzU3RyaW5nT2JqZWN0IiwiaXNCb29sZWFuT2JqZWN0IiwiaXNCaWdJbnRPYmplY3QiLCJpc1N5bWJvbE9iamVjdCIsImlzQm94ZWRQcmltaXRpdmUiLCJpc0FueUFycmF5QnVmZmVyIiwiZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZm9ybWF0IiwiaXNTdHJpbmciLCJpbnNwZWN0Iiwic3RyaW5naWZ5IiwiaXNOdWxsIiwiaXNPYmplY3QiLCJkZXByZWNhdGUiLCJwcm9jZXNzIiwibm9EZXByZWNhdGlvbiIsImRlcHJlY2F0ZWQiLCJ0aHJvd0RlcHJlY2F0aW9uIiwidHJhY2VEZXByZWNhdGlvbiIsImNvbnNvbGUiLCJ0cmFjZSIsImVycm9yIiwiZW52IiwiTk9ERV9ERUJVRyIsInRvVXBwZXJDYXNlIiwiZGVidWdsb2ciLCJwaWQiLCJzZWVuIiwic3R5bGl6ZSIsInN0eWxpemVOb0NvbG9yIiwiZGVwdGgiLCJjb2xvcnMiLCJpc0Jvb2xlYW4iLCJzaG93SGlkZGVuIiwiX2V4dGVuZCIsImlzVW5kZWZpbmVkIiwiY3VzdG9tSW5zcGVjdCIsInN0eWxpemVXaXRoQ29sb3IiLCJmb3JtYXRWYWx1ZSIsImJvbGQiLCJpdGFsaWMiLCJ1bmRlcmxpbmUiLCJpbnZlcnNlIiwid2hpdGUiLCJncmV5IiwiYmxhY2siLCJibHVlIiwiY3lhbiIsImdyZWVuIiwibWFnZW50YSIsInJlZCIsInllbGxvdyIsInN0eWxlcyIsInNwZWNpYWwiLCJudW1iZXIiLCJib29sZWFuIiwibnVsbCIsInN0cmluZyIsImRhdGUiLCJyZWdleHAiLCJhcnJheVRvSGFzaCIsImlzRnVuY3Rpb24iLCJmb3JtYXRQcmltaXRpdmUiLCJpc0Vycm9yIiwiZm9ybWF0RXJyb3IiLCJpc1JlZ0V4cCIsImlzRGF0ZSIsImlzQXJyYXkiLCJ0b1VUQ1N0cmluZyIsImZvcm1hdEFycmF5IiwibWFwIiwiZm9ybWF0UHJvcGVydHkiLCJwb3AiLCJyZWR1Y2VUb1NpbmdsZVN0cmluZyIsImlzTnVtYmVyIiwibWF0Y2giLCJzZXQiLCJzcGxpdCIsInN1YnN0ciIsInJlZHVjZSIsInR5cGVzIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc1N5bWJvbCIsIm9iamVjdFRvU3RyaW5nIiwiaXNOYXRpdmVFcnJvciIsImlzUHJpbWl0aXZlIiwicGFkIiwidGltZXN0YW1wIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldERhdGUiLCJnZXRNb250aCIsImxvZyIsInByb21pc2lmeSIsInNldFByb3RvdHlwZU9mIiwiZGVmaW5lUHJvcGVydGllcyIsImN1c3RvbSIsImNhbGxiYWNraWZ5T25SZWplY3RlZCIsInJlYXNvbiIsImNhbGxiYWNraWZ5IiwiY2FsbGJhY2tpZmllZCIsImNiIiwibmV4dFRpY2siLCJ3aGljaFR5cGVkQXJyYXkiLCJhdmFpbGFibGVUeXBlZEFycmF5cyIsIl9fbmNjd3Bja19yZXF1aXJlX18iLCJhYiIsIl9fZGlybmFtZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/util/util.js\n"));

/***/ }),

/***/ "./node_modules/next/image.js":
/*!************************************!*\
  !*** ./node_modules/next/image.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/image */ \"./node_modules/next/dist/client/image.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQUEsMkdBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvaW1hZ2UuanM/MDUzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGllbnQvaW1hZ2UnKVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/image.js\n"));

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/link */ \"./node_modules/next/dist/client/link.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBQSx5R0FBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzPzc1YjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/link.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nif (true) {\n  (function () {\n    'use strict';\n\n    var React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\"); // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types.\n\n\n    var REACT_ELEMENT_TYPE = Symbol.for('react.element');\n    var REACT_PORTAL_TYPE = Symbol.for('react.portal');\n    var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\n    var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\n    var REACT_PROFILER_TYPE = Symbol.for('react.profiler');\n    var REACT_PROVIDER_TYPE = Symbol.for('react.provider');\n    var REACT_CONTEXT_TYPE = Symbol.for('react.context');\n    var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\n    var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\n    var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\n    var REACT_MEMO_TYPE = Symbol.for('react.memo');\n    var REACT_LAZY_TYPE = Symbol.for('react.lazy');\n    var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable !== 'object') {\n        return null;\n      }\n\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n\n      return null;\n    }\n\n    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n    function error(format) {\n      {\n        {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          printWarning('error', format, args);\n        }\n      }\n    }\n\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n        var argsWithFormat = args.map(function (item) {\n          return String(item);\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    } // -----------------------------------------------------------------------------\n\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n\n    var enableCacheElement = false;\n    var enableTransitionTracing = false; // No known bugs, but needs performance testing\n\n    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n    // stuff. Intended to enable React core members to more easily debug scheduling\n    // issues in DEV builds.\n\n    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\n    var REACT_MODULE_REFERENCE;\n    {\n      REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n    }\n\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n        return true;\n      }\n\n      if (typeof type === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var displayName = outerType.displayName;\n\n      if (displayName) {\n        return displayName;\n      }\n\n      var functionName = innerType.displayName || innerType.name || '';\n      return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n    } // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\n    function getComponentNameFromType(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return 'Fragment';\n\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n\n        case REACT_PROFILER_TYPE:\n          return 'Profiler';\n\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n\n        case REACT_SUSPENSE_TYPE:\n          return 'Suspense';\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return 'SuspenseList';\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n\n          case REACT_MEMO_TYPE:\n            var outerName = type.displayName || null;\n\n            if (outerName !== null) {\n              return outerName;\n            }\n\n            return getComponentNameFromType(type.type) || 'Memo';\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                return getComponentNameFromType(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n          // eslint-disable-next-line no-fallthrough\n        }\n      }\n\n      return null;\n    }\n\n    var assign = Object.assign; // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n\n    function disabledLog() {}\n\n    disabledLog.__reactDisabledLog = true;\n\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        disabledDepth++;\n      }\n    }\n\n    function reenableLogs() {\n      {\n        disabledDepth--;\n\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: assign({}, props, {\n              value: prevLog\n            }),\n            info: assign({}, props, {\n              value: prevInfo\n            }),\n            warn: assign({}, props, {\n              value: prevWarn\n            }),\n            error: assign({}, props, {\n              value: prevError\n            }),\n            group: assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n\n    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n        return '\\n' + prefix + name;\n      }\n    }\n\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n\n      {\n        var frame = componentFrameCache.get(fn);\n\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher.current = null;\n        disableLogs();\n      }\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                    // but we have a user-provided \"displayName\"\n                    // splice it in to make the stack more readable.\n\n\n                    if (fn.displayName && _frame.includes('<anonymous>')) {\n                      _frame = _frame.replace('<anonymous>', fn.displayName);\n                    }\n\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame('Suspense');\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n\n      return '';\n    }\n\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(hasOwnProperty);\n\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n              setCurrentlyValidatingElement(null);\n            }\n\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n\n    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\n    function isArray(a) {\n      return isArrayImpl(a);\n    }\n    /*\n     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n     *\n     * The functions in this module will throw an easier-to-understand,\n     * easier-to-debug exception with a clear errors message message explaining the\n     * problem. (Instead of a confusing exception thrown inside the implementation\n     * of the `value` object).\n     */\n    // $FlowFixMe only called in DEV, so void return is not possible.\n\n\n    function typeName(value) {\n      {\n        // toStringTag is needed for namespaced types like Temporal.Instant\n        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n        return type;\n      }\n    } // $FlowFixMe only called in DEV, so void return is not possible.\n\n\n    function willCoercionThrow(value) {\n      {\n        try {\n          testStringCoercion(value);\n          return false;\n        } catch (e) {\n          return true;\n        }\n      }\n    }\n\n    function testStringCoercion(value) {\n      // If you ended up here by following an exception call stack, here's what's\n      // happened: you supplied an object or symbol value to React (as a prop, key,\n      // DOM attribute, CSS property, string ref, etc.) and when React tried to\n      // coerce it to a string using `'' + value`, an exception was thrown.\n      //\n      // The most common types that will cause this exception are `Symbol` instances\n      // and Temporal objects like `Temporal.Instant`. But any object that has a\n      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n      // exception. (Library authors do this to prevent users from using built-in\n      // numeric operators like `+` or comparison operators like `>=` because custom\n      // methods are needed to perform accurate arithmetic or comparison.)\n      //\n      // To fix the problem, coerce this object or symbol value to a string before\n      // passing it to React. The most reliable way is usually `String(value)`.\n      //\n      // To find which value is throwing, check the browser or debugger console.\n      // Before this exception was thrown, there should be `console.error` output\n      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n      // problem and how that type was used: key, atrribute, input value prop, etc.\n      // In most cases, this console output also shows the component and its\n      // ancestor components where the exception happened.\n      //\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      return '' + value;\n    }\n\n    function checkKeyStringCoercion(value) {\n      {\n        if (willCoercionThrow(value)) {\n          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n        }\n      }\n    }\n\n    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown;\n    var specialPropRefWarningShown;\n    var didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n\n    function warnIfStringRefCannotBeAutoConverted(config, self) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n\n    function defineKeyPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingKey = function () {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingKey.isReactWarning = true;\n        Object.defineProperty(props, 'key', {\n          get: warnAboutAccessingKey,\n          configurable: true\n        });\n      }\n    }\n\n    function defineRefPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingRef = function () {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingRef.isReactWarning = true;\n        Object.defineProperty(props, 'ref', {\n          get: warnAboutAccessingRef,\n          configurable: true\n        });\n      }\n    }\n    /**\n     * Factory method to create a new React element. This no longer adheres to\n     * the class pattern, so do not use new to call it. Also, instanceof check\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n     * if something is a React Element.\n     *\n     * @param {*} type\n     * @param {*} props\n     * @param {*} key\n     * @param {string|object} ref\n     * @param {*} owner\n     * @param {*} self A *temporary* helper to detect places where `this` is\n     * different from the `owner` when React.createElement is called, so that we\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n     * functions, and as long as `this` and owner are the same, there will be no\n     * change in behavior.\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\n     * indicating filename, line number, and/or other information.\n     * @internal\n     */\n\n\n    var ReactElement = function (type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\n     * https://github.com/reactjs/rfcs/pull/107\n     * @param {*} type\n     * @param {object} props\n     * @param {string} key\n     */\n\n\n    function jsxDEV(type, config, maybeKey, source, self) {\n      {\n        var propName; // Reserved names are extracted\n\n        var props = {};\n        var key = null;\n        var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n        // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n        // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n        // but as an intermediary step, we will use jsxDEV for everything except\n        // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n        // key is explicitly declared to be undefined or not.\n\n        if (maybeKey !== undefined) {\n          {\n            checkKeyStringCoercion(maybeKey);\n          }\n          key = '' + maybeKey;\n        }\n\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        }\n\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          warnIfStringRefCannotBeAutoConverted(config, self);\n        } // Remaining properties are added to a new props object\n\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        } // Resolve default props\n\n\n        if (type && type.defaultProps) {\n          var defaultProps = type.defaultProps;\n\n          for (propName in defaultProps) {\n            if (props[propName] === undefined) {\n              props[propName] = defaultProps[propName];\n            }\n          }\n        }\n\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n\n        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n      }\n    }\n\n    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n    /**\n     * Verifies the object is a ReactElement.\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\n     * @param {?object} object\n     * @return {boolean} True if `object` is a ReactElement.\n     * @final\n     */\n\n    function isValidElement(object) {\n      {\n        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n      }\n    }\n\n    function getDeclarationErrorAddendum() {\n      {\n        if (ReactCurrentOwner$1.current) {\n          var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n          if (name) {\n            return '\\n\\nCheck the render method of `' + name + '`.';\n          }\n        }\n\n        return '';\n      }\n    }\n\n    function getSourceInfoErrorAddendum(source) {\n      {\n        if (source !== undefined) {\n          var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n          var lineNumber = source.lineNumber;\n          return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n        }\n\n        return '';\n      }\n    }\n    /**\n     * Warn if there's no key explicitly set on dynamic arrays of children or\n     * object keys are not valid. This allows us to keep track of children between\n     * updates.\n     */\n\n\n    var ownerHasKeyUseWarning = {};\n\n    function getCurrentComponentErrorInfo(parentType) {\n      {\n        var info = getDeclarationErrorAddendum();\n\n        if (!info) {\n          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n          if (parentName) {\n            info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n          }\n        }\n\n        return info;\n      }\n    }\n    /**\n     * Warn if the element doesn't have an explicit key assigned to it.\n     * This element is in an array. The array could grow and shrink or be\n     * reordered. All children that haven't already been validated are required to\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n     * will only be shown once.\n     *\n     * @internal\n     * @param {ReactElement} element Element that requires a key.\n     * @param {*} parentType element's parent's type.\n     */\n\n\n    function validateExplicitKey(element, parentType) {\n      {\n        if (!element._store || element._store.validated || element.key != null) {\n          return;\n        }\n\n        element._store.validated = true;\n        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n          return;\n        }\n\n        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n        // property, it may be the creator of the child that's responsible for\n        // assigning it a key.\n\n        var childOwner = '';\n\n        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n          // Give the component that originally created this child.\n          childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n        }\n\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\n     * Ensure that every element either is passed in a static location, in an\n     * array with an explicit keys property defined, or in an object literal\n     * with valid key property.\n     *\n     * @internal\n     * @param {ReactNode} node Statically passed child of any type.\n     * @param {*} parentType node's parent's type.\n     */\n\n\n    function validateChildKeys(node, parentType) {\n      {\n        if (typeof node !== 'object') {\n          return;\n        }\n\n        if (isArray(node)) {\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n\n            if (isValidElement(child)) {\n              validateExplicitKey(child, parentType);\n            }\n          }\n        } else if (isValidElement(node)) {\n          // This element was passed in a valid location.\n          if (node._store) {\n            node._store.validated = true;\n          }\n        } else if (node) {\n          var iteratorFn = getIteratorFn(node);\n\n          if (typeof iteratorFn === 'function') {\n            // Entry iterators used to provide implicit keys,\n            // but now we print a separate warning for them later.\n            if (iteratorFn !== node.entries) {\n              var iterator = iteratorFn.call(node);\n              var step;\n\n              while (!(step = iterator.next()).done) {\n                if (isValidElement(step.value)) {\n                  validateExplicitKey(step.value, parentType);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Given an element, validate that its props follow the propTypes definition,\n     * provided by the type.\n     *\n     * @param {ReactElement} element\n     */\n\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n\n        var propTypes;\n\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentNameFromType(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentNameFromType(type);\n\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\n     * Given a fragment, validate that it can only be provided with fragment props\n     * @param {ReactElement} fragment\n     */\n\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n\n    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n      {\n        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n        // succeed and there will likely be errors in render.\n\n        if (!validType) {\n          var info = '';\n\n          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n            info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n          }\n\n          var sourceInfo = getSourceInfoErrorAddendum(source);\n\n          if (sourceInfo) {\n            info += sourceInfo;\n          } else {\n            info += getDeclarationErrorAddendum();\n          }\n\n          var typeString;\n\n          if (type === null) {\n            typeString = 'null';\n          } else if (isArray(type)) {\n            typeString = 'array';\n          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n            typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n            info = ' Did you accidentally export a JSX literal instead of a component?';\n          } else {\n            typeString = typeof type;\n          }\n\n          error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n\n        var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n        // TODO: Drop this when these are no longer allowed as the type argument.\n\n        if (element == null) {\n          return element;\n        } // Skip key warning if the type isn't valid since our key validation logic\n        // doesn't expect a non-string/function type and can throw confusing errors.\n        // We don't want exception behavior to differ between dev and prod.\n        // (Rendering will throw with a helpful message and as soon as the type is\n        // fixed, the key warnings will appear.)\n\n\n        if (validType) {\n          var children = props.children;\n\n          if (children !== undefined) {\n            if (isStaticChildren) {\n              if (isArray(children)) {\n                for (var i = 0; i < children.length; i++) {\n                  validateChildKeys(children[i], type);\n                }\n\n                if (Object.freeze) {\n                  Object.freeze(children);\n                }\n              } else {\n                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n              }\n            } else {\n              validateChildKeys(children, type);\n            }\n          }\n        }\n\n        if (type === REACT_FRAGMENT_TYPE) {\n          validateFragmentProps(element);\n        } else {\n          validatePropTypes(element);\n        }\n\n        return element;\n      }\n    } // These two functions exist to still get child warnings in dev\n\n\n    var jsxDEV$1 = jsxWithValidation;\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = jsxDEV$1;\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFYTs7QUFFYixJQUFJQSxJQUFKLEVBQTJDO0VBQ3pDLENBQUMsWUFBVztJQUNkOztJQUVBLElBQUlHLEtBQUssR0FBR0MsbUJBQU8sQ0FBQyw0Q0FBRCxDQUFuQixDQUhjLENBS2Q7SUFDQTtJQUNBO0lBQ0E7OztJQUNBLElBQUlDLGtCQUFrQixHQUFHQyxNQUFNLENBQUNDLEdBQVAsQ0FBVyxlQUFYLENBQXpCO0lBQ0EsSUFBSUMsaUJBQWlCLEdBQUdGLE1BQU0sQ0FBQ0MsR0FBUCxDQUFXLGNBQVgsQ0FBeEI7SUFDQSxJQUFJRSxtQkFBbUIsR0FBR0gsTUFBTSxDQUFDQyxHQUFQLENBQVcsZ0JBQVgsQ0FBMUI7SUFDQSxJQUFJRyxzQkFBc0IsR0FBR0osTUFBTSxDQUFDQyxHQUFQLENBQVcsbUJBQVgsQ0FBN0I7SUFDQSxJQUFJSSxtQkFBbUIsR0FBR0wsTUFBTSxDQUFDQyxHQUFQLENBQVcsZ0JBQVgsQ0FBMUI7SUFDQSxJQUFJSyxtQkFBbUIsR0FBR04sTUFBTSxDQUFDQyxHQUFQLENBQVcsZ0JBQVgsQ0FBMUI7SUFDQSxJQUFJTSxrQkFBa0IsR0FBR1AsTUFBTSxDQUFDQyxHQUFQLENBQVcsZUFBWCxDQUF6QjtJQUNBLElBQUlPLHNCQUFzQixHQUFHUixNQUFNLENBQUNDLEdBQVAsQ0FBVyxtQkFBWCxDQUE3QjtJQUNBLElBQUlRLG1CQUFtQixHQUFHVCxNQUFNLENBQUNDLEdBQVAsQ0FBVyxnQkFBWCxDQUExQjtJQUNBLElBQUlTLHdCQUF3QixHQUFHVixNQUFNLENBQUNDLEdBQVAsQ0FBVyxxQkFBWCxDQUEvQjtJQUNBLElBQUlVLGVBQWUsR0FBR1gsTUFBTSxDQUFDQyxHQUFQLENBQVcsWUFBWCxDQUF0QjtJQUNBLElBQUlXLGVB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Z0JBQ0Q7Y0FDRixDQVJELE1BUU87Z0JBQ0xqTyxLQUFLLENBQUMsMkRBQTJELGdFQUEzRCxHQUE4SCxrQ0FBL0gsQ0FBTDtjQUNEO1lBQ0YsQ0FaRCxNQVlPO2NBQ0wwTSxpQkFBaUIsQ0FBQ3VCLFFBQUQsRUFBV2xNLElBQVgsQ0FBakI7WUFDRDtVQUNGO1FBQ0Y7O1FBRUQsSUFBSUEsSUFBSSxLQUFLbEQsbUJBQWIsRUFBa0M7VUFDaEM0TyxxQkFBcUIsQ0FBQzFGLE9BQUQsQ0FBckI7UUFDRCxDQUZELE1BRU87VUFDTG9GLGlCQUFpQixDQUFDcEYsT0FBRCxDQUFqQjtRQUNEOztRQUVELE9BQU9BLE9BQVA7TUFDRDtJQUNGLENBM3ZDYSxDQTJ2Q1o7OztJQUVGLElBQUltRyxRQUFRLEdBQUlOLGlCQUFoQjtJQUVBTyxnQkFBQSxHQUFtQnRQLG1CQUFuQjtJQUNBc1AsY0FBQSxHQUFpQkQsUUFBakI7RUFDRyxDQWp3Q0Q7QUFrd0NEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzPzE3ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cbnZhciBlbmFibGVDYWNoZUVsZW1lbnQgPSBmYWxzZTtcbnZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTsgLy8gVHJhY2sgd2hpY2ggRmliZXIocykgc2NoZWR1bGUgcmVuZGVyIHdvcmsuXG5cbnZhciBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFO1xuXG57XG4gIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5tb2R1bGUucmVmZXJlbmNlJyk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWJDEgPSAganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWJDE7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiUmVhY3QiLCJyZXF1aXJlIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiU3ltYm9sIiwiZm9yIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwidHlwZSIsIiQkdHlwZW9mIiwiZ2V0TW9kdWxlSWQiLCJ1bmRlZmluZWQiLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZGlzcGxheU5hbWUiLCJmdW5jdGlvbk5hbWUiLCJuYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCJ0YWciLCJjb250ZXh0IiwicHJvdmlkZXIiLCJfY29udGV4dCIsInJlbmRlciIsIm91dGVyTmFtZSIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJpbml0IiwiX2luaXQiLCJ4IiwiYXNzaWduIiwiT2JqZWN0IiwiZGlzYWJsZWREZXB0aCIsInByZXZMb2ciLCJwcmV2SW5mbyIsInByZXZXYXJuIiwicHJldkVycm9yIiwicHJldkdyb3VwIiwicHJldkdyb3VwQ29sbGFwc2VkIiwicHJldkdyb3VwRW5kIiwiZGlzYWJsZWRMb2ciLCJfX3JlYWN0RGlzYWJsZWRMb2ciLCJkaXNhYmxlTG9ncyIsImxvZyIsImluZm8iLCJ3YXJuIiwiZ3JvdXAiLCJncm91cENvbGxhcHNlZCIsImdyb3VwRW5kIiwicHJvcHMiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwidmFsdWUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnRpZXMiLCJyZWVuYWJsZUxvZ3MiLCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyIiwicHJlZml4IiwiZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUiLCJzb3VyY2UiLCJvd25lckZuIiwiRXJyb3IiLCJtYXRjaCIsInRyaW0iLCJyZWVudHJ5IiwiY29tcG9uZW50RnJhbWVDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCIsIldlYWtNYXAiLCJNYXAiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiZm4iLCJjb25zdHJ1Y3QiLCJmcmFtZSIsImdldCIsImNvbnRyb2wiLCJwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJwcmV2aW91c0Rpc3BhdGNoZXIiLCJjdXJyZW50IiwiRmFrZSIsImRlZmluZVByb3BlcnR5Iiwic2V0IiwiUmVmbGVjdCIsInNhbXBsZSIsInNhbXBsZUxpbmVzIiwic3BsaXQiLCJjb250cm9sTGluZXMiLCJzIiwiYyIsIl9mcmFtZSIsInJlcGxhY2UiLCJpbmNsdWRlcyIsInN5bnRoZXRpY0ZyYW1lIiwiZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lIiwic2hvdWxkQ29uc3RydWN0IiwiQ29tcG9uZW50IiwiaXNSZWFjdENvbXBvbmVudCIsImRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFViIsImhhc093blByb3BlcnR5IiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJlbGVtZW50Iiwib3duZXIiLCJfb3duZXIiLCJfc291cmNlIiwic2V0RXh0cmFTdGFja0ZyYW1lIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImNvbXBvbmVudE5hbWUiLCJoYXMiLCJiaW5kIiwidHlwZVNwZWNOYW1lIiwiZXJyb3IkMSIsImVyciIsImV4IiwibWVzc2FnZSIsImlzQXJyYXlJbXBsIiwiaXNBcnJheSIsImEiLCJ0eXBlTmFtZSIsImhhc1RvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJjb25zdHJ1Y3RvciIsIndpbGxDb2VyY2lvblRocm93IiwidGVzdFN0cmluZ0NvZXJjaW9uIiwiZSIsImNoZWNrS2V5U3RyaW5nQ29lcmNpb24iLCJSZWFjdEN1cnJlbnRPd25lciIsIlJFU0VSVkVEX1BST1BTIiwia2V5IiwicmVmIiwiX19zZWxmIiwiX19zb3VyY2UiLCJzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biIsInNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duIiwiZGlkV2FybkFib3V0U3RyaW5nUmVmcyIsImhhc1ZhbGlkUmVmIiwiY29uZmlnIiwiZ2V0dGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaXNSZWFjdFdhcm5pbmciLCJoYXNWYWxpZEtleSIsIndhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZCIsInNlbGYiLCJzdGF0ZU5vZGUiLCJkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ0tleSIsImRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nUmVmIiwiUmVhY3RFbGVtZW50IiwiX3N0b3JlIiwiZnJlZXplIiwianN4REVWIiwibWF5YmVLZXkiLCJwcm9wTmFtZSIsImRlZmF1bHRQcm9wcyIsIlJlYWN0Q3VycmVudE93bmVyJDEiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwicHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24iLCJpc1ZhbGlkRWxlbWVudCIsIm9iamVjdCIsImdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSIsImdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwiZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsInBhcmVudFR5cGUiLCJwYXJlbnROYW1lIiwidmFsaWRhdGVFeHBsaWNpdEtleSIsInZhbGlkYXRlZCIsImN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJjaGlsZE93bmVyIiwidmFsaWRhdGVDaGlsZEtleXMiLCJub2RlIiwiaSIsImNoaWxkIiwiaXRlcmF0b3JGbiIsImVudHJpZXMiLCJzdGVwIiwibmV4dCIsImRvbmUiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsIl9uYW1lIiwiZ2V0RGVmYXVsdFByb3BzIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJmcmFnbWVudCIsImtleXMiLCJqc3hXaXRoVmFsaWRhdGlvbiIsImlzU3RhdGljQ2hpbGRyZW4iLCJ2YWxpZFR5cGUiLCJzb3VyY2VJbmZvIiwidHlwZVN0cmluZyIsImNoaWxkcmVuIiwianN4REVWJDEiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nif (true) {\n  (function () {\n    'use strict';\n\n    var React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\"); // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types.\n\n\n    var REACT_ELEMENT_TYPE = Symbol.for('react.element');\n    var REACT_PORTAL_TYPE = Symbol.for('react.portal');\n    var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\n    var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\n    var REACT_PROFILER_TYPE = Symbol.for('react.profiler');\n    var REACT_PROVIDER_TYPE = Symbol.for('react.provider');\n    var REACT_CONTEXT_TYPE = Symbol.for('react.context');\n    var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\n    var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\n    var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\n    var REACT_MEMO_TYPE = Symbol.for('react.memo');\n    var REACT_LAZY_TYPE = Symbol.for('react.lazy');\n    var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable !== 'object') {\n        return null;\n      }\n\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n\n      return null;\n    }\n\n    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n    function error(format) {\n      {\n        {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          printWarning('error', format, args);\n        }\n      }\n    }\n\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n        var argsWithFormat = args.map(function (item) {\n          return String(item);\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    } // -----------------------------------------------------------------------------\n\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n\n    var enableCacheElement = false;\n    var enableTransitionTracing = false; // No known bugs, but needs performance testing\n\n    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n    // stuff. Intended to enable React core members to more easily debug scheduling\n    // issues in DEV builds.\n\n    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\n    var REACT_MODULE_REFERENCE;\n    {\n      REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n    }\n\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n        return true;\n      }\n\n      if (typeof type === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var displayName = outerType.displayName;\n\n      if (displayName) {\n        return displayName;\n      }\n\n      var functionName = innerType.displayName || innerType.name || '';\n      return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n    } // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\n    function getComponentNameFromType(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return 'Fragment';\n\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n\n        case REACT_PROFILER_TYPE:\n          return 'Profiler';\n\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n\n        case REACT_SUSPENSE_TYPE:\n          return 'Suspense';\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return 'SuspenseList';\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n\n          case REACT_MEMO_TYPE:\n            var outerName = type.displayName || null;\n\n            if (outerName !== null) {\n              return outerName;\n            }\n\n            return getComponentNameFromType(type.type) || 'Memo';\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                return getComponentNameFromType(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n          // eslint-disable-next-line no-fallthrough\n        }\n      }\n\n      return null;\n    }\n\n    var assign = Object.assign; // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n\n    function disabledLog() {}\n\n    disabledLog.__reactDisabledLog = true;\n\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        disabledDepth++;\n      }\n    }\n\n    function reenableLogs() {\n      {\n        disabledDepth--;\n\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: assign({}, props, {\n              value: prevLog\n            }),\n            info: assign({}, props, {\n              value: prevInfo\n            }),\n            warn: assign({}, props, {\n              value: prevWarn\n            }),\n            error: assign({}, props, {\n              value: prevError\n            }),\n            group: assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n\n    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n        return '\\n' + prefix + name;\n      }\n    }\n\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n\n      {\n        var frame = componentFrameCache.get(fn);\n\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher.current = null;\n        disableLogs();\n      }\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                    // but we have a user-provided \"displayName\"\n                    // splice it in to make the stack more readable.\n\n\n                    if (fn.displayName && _frame.includes('<anonymous>')) {\n                      _frame = _frame.replace('<anonymous>', fn.displayName);\n                    }\n\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame('Suspense');\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n\n      return '';\n    }\n\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(hasOwnProperty);\n\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n              setCurrentlyValidatingElement(null);\n            }\n\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n\n    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\n    function isArray(a) {\n      return isArrayImpl(a);\n    }\n    /*\n     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n     *\n     * The functions in this module will throw an easier-to-understand,\n     * easier-to-debug exception with a clear errors message message explaining the\n     * problem. (Instead of a confusing exception thrown inside the implementation\n     * of the `value` object).\n     */\n    // $FlowFixMe only called in DEV, so void return is not possible.\n\n\n    function typeName(value) {\n      {\n        // toStringTag is needed for namespaced types like Temporal.Instant\n        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n        return type;\n      }\n    } // $FlowFixMe only called in DEV, so void return is not possible.\n\n\n    function willCoercionThrow(value) {\n      {\n        try {\n          testStringCoercion(value);\n          return false;\n        } catch (e) {\n          return true;\n        }\n      }\n    }\n\n    function testStringCoercion(value) {\n      // If you ended up here by following an exception call stack, here's what's\n      // happened: you supplied an object or symbol value to React (as a prop, key,\n      // DOM attribute, CSS property, string ref, etc.) and when React tried to\n      // coerce it to a string using `'' + value`, an exception was thrown.\n      //\n      // The most common types that will cause this exception are `Symbol` instances\n      // and Temporal objects like `Temporal.Instant`. But any object that has a\n      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n      // exception. (Library authors do this to prevent users from using built-in\n      // numeric operators like `+` or comparison operators like `>=` because custom\n      // methods are needed to perform accurate arithmetic or comparison.)\n      //\n      // To fix the problem, coerce this object or symbol value to a string before\n      // passing it to React. The most reliable way is usually `String(value)`.\n      //\n      // To find which value is throwing, check the browser or debugger console.\n      // Before this exception was thrown, there should be `console.error` output\n      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n      // problem and how that type was used: key, atrribute, input value prop, etc.\n      // In most cases, this console output also shows the component and its\n      // ancestor components where the exception happened.\n      //\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      return '' + value;\n    }\n\n    function checkKeyStringCoercion(value) {\n      {\n        if (willCoercionThrow(value)) {\n          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n        }\n      }\n    }\n\n    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown;\n    var specialPropRefWarningShown;\n    var didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n\n    function warnIfStringRefCannotBeAutoConverted(config, self) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n\n    function defineKeyPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingKey = function () {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingKey.isReactWarning = true;\n        Object.defineProperty(props, 'key', {\n          get: warnAboutAccessingKey,\n          configurable: true\n        });\n      }\n    }\n\n    function defineRefPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingRef = function () {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingRef.isReactWarning = true;\n        Object.defineProperty(props, 'ref', {\n          get: warnAboutAccessingRef,\n          configurable: true\n        });\n      }\n    }\n    /**\n     * Factory method to create a new React element. This no longer adheres to\n     * the class pattern, so do not use new to call it. Also, instanceof check\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n     * if something is a React Element.\n     *\n     * @param {*} type\n     * @param {*} props\n     * @param {*} key\n     * @param {string|object} ref\n     * @param {*} owner\n     * @param {*} self A *temporary* helper to detect places where `this` is\n     * different from the `owner` when React.createElement is called, so that we\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n     * functions, and as long as `this` and owner are the same, there will be no\n     * change in behavior.\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\n     * indicating filename, line number, and/or other information.\n     * @internal\n     */\n\n\n    var ReactElement = function (type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\n     * https://github.com/reactjs/rfcs/pull/107\n     * @param {*} type\n     * @param {object} props\n     * @param {string} key\n     */\n\n\n    function jsxDEV(type, config, maybeKey, source, self) {\n      {\n        var propName; // Reserved names are extracted\n\n        var props = {};\n        var key = null;\n        var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n        // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n        // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n        // but as an intermediary step, we will use jsxDEV for everything except\n        // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n        // key is explicitly declared to be undefined or not.\n\n        if (maybeKey !== undefined) {\n          {\n            checkKeyStringCoercion(maybeKey);\n          }\n          key = '' + maybeKey;\n        }\n\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        }\n\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          warnIfStringRefCannotBeAutoConverted(config, self);\n        } // Remaining properties are added to a new props object\n\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        } // Resolve default props\n\n\n        if (type && type.defaultProps) {\n          var defaultProps = type.defaultProps;\n\n          for (propName in defaultProps) {\n            if (props[propName] === undefined) {\n              props[propName] = defaultProps[propName];\n            }\n          }\n        }\n\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n\n        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n      }\n    }\n\n    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n    /**\n     * Verifies the object is a ReactElement.\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\n     * @param {?object} object\n     * @return {boolean} True if `object` is a ReactElement.\n     * @final\n     */\n\n    function isValidElement(object) {\n      {\n        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n      }\n    }\n\n    function getDeclarationErrorAddendum() {\n      {\n        if (ReactCurrentOwner$1.current) {\n          var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n          if (name) {\n            return '\\n\\nCheck the render method of `' + name + '`.';\n          }\n        }\n\n        return '';\n      }\n    }\n\n    function getSourceInfoErrorAddendum(source) {\n      {\n        if (source !== undefined) {\n          var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n          var lineNumber = source.lineNumber;\n          return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n        }\n\n        return '';\n      }\n    }\n    /**\n     * Warn if there's no key explicitly set on dynamic arrays of children or\n     * object keys are not valid. This allows us to keep track of children between\n     * updates.\n     */\n\n\n    var ownerHasKeyUseWarning = {};\n\n    function getCurrentComponentErrorInfo(parentType) {\n      {\n        var info = getDeclarationErrorAddendum();\n\n        if (!info) {\n          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n          if (parentName) {\n            info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n          }\n        }\n\n        return info;\n      }\n    }\n    /**\n     * Warn if the element doesn't have an explicit key assigned to it.\n     * This element is in an array. The array could grow and shrink or be\n     * reordered. All children that haven't already been validated are required to\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n     * will only be shown once.\n     *\n     * @internal\n     * @param {ReactElement} element Element that requires a key.\n     * @param {*} parentType element's parent's type.\n     */\n\n\n    function validateExplicitKey(element, parentType) {\n      {\n        if (!element._store || element._store.validated || element.key != null) {\n          return;\n        }\n\n        element._store.validated = true;\n        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n          return;\n        }\n\n        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n        // property, it may be the creator of the child that's responsible for\n        // assigning it a key.\n\n        var childOwner = '';\n\n        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n          // Give the component that originally created this child.\n          childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n        }\n\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\n     * Ensure that every element either is passed in a static location, in an\n     * array with an explicit keys property defined, or in an object literal\n     * with valid key property.\n     *\n     * @internal\n     * @param {ReactNode} node Statically passed child of any type.\n     * @param {*} parentType node's parent's type.\n     */\n\n\n    function validateChildKeys(node, parentType) {\n      {\n        if (typeof node !== 'object') {\n          return;\n        }\n\n        if (isArray(node)) {\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n\n            if (isValidElement(child)) {\n              validateExplicitKey(child, parentType);\n            }\n          }\n        } else if (isValidElement(node)) {\n          // This element was passed in a valid location.\n          if (node._store) {\n            node._store.validated = true;\n          }\n        } else if (node) {\n          var iteratorFn = getIteratorFn(node);\n\n          if (typeof iteratorFn === 'function') {\n            // Entry iterators used to provide implicit keys,\n            // but now we print a separate warning for them later.\n            if (iteratorFn !== node.entries) {\n              var iterator = iteratorFn.call(node);\n              var step;\n\n              while (!(step = iterator.next()).done) {\n                if (isValidElement(step.value)) {\n                  validateExplicitKey(step.value, parentType);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Given an element, validate that its props follow the propTypes definition,\n     * provided by the type.\n     *\n     * @param {ReactElement} element\n     */\n\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n\n        var propTypes;\n\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentNameFromType(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentNameFromType(type);\n\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\n     * Given a fragment, validate that it can only be provided with fragment props\n     * @param {ReactElement} fragment\n     */\n\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n\n    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n      {\n        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n        // succeed and there will likely be errors in render.\n\n        if (!validType) {\n          var info = '';\n\n          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n            info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n          }\n\n          var sourceInfo = getSourceInfoErrorAddendum(source);\n\n          if (sourceInfo) {\n            info += sourceInfo;\n          } else {\n            info += getDeclarationErrorAddendum();\n          }\n\n          var typeString;\n\n          if (type === null) {\n            typeString = 'null';\n          } else if (isArray(type)) {\n            typeString = 'array';\n          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n            typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n            info = ' Did you accidentally export a JSX literal instead of a component?';\n          } else {\n            typeString = typeof type;\n          }\n\n          error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n\n        var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n        // TODO: Drop this when these are no longer allowed as the type argument.\n\n        if (element == null) {\n          return element;\n        } // Skip key warning if the type isn't valid since our key validation logic\n        // doesn't expect a non-string/function type and can throw confusing errors.\n        // We don't want exception behavior to differ between dev and prod.\n        // (Rendering will throw with a helpful message and as soon as the type is\n        // fixed, the key warnings will appear.)\n\n\n        if (validType) {\n          var children = props.children;\n\n          if (children !== undefined) {\n            if (isStaticChildren) {\n              if (isArray(children)) {\n                for (var i = 0; i < children.length; i++) {\n                  validateChildKeys(children[i], type);\n                }\n\n                if (Object.freeze) {\n                  Object.freeze(children);\n                }\n              } else {\n                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n              }\n            } else {\n              validateChildKeys(children, type);\n            }\n          }\n        }\n\n        if (type === REACT_FRAGMENT_TYPE) {\n          validateFragmentProps(element);\n        } else {\n          validatePropTypes(element);\n        }\n\n        return element;\n      }\n    } // These two functions exist to still get child warnings in dev\n    // even with the prod transform. This means that jsxDEV is purely\n    // opt-in behavior for better messages but that we won't stop\n    // giving you warnings if you use production apis.\n\n\n    function jsxWithValidationStatic(type, props, key) {\n      {\n        return jsxWithValidation(type, props, key, true);\n      }\n    }\n\n    function jsxWithValidationDynamic(type, props, key) {\n      {\n        return jsxWithValidation(type, props, key, false);\n      }\n    }\n\n    var jsx = jsxWithValidationDynamic; // we may want to special case jsxs internally to take advantage of static children.\n    // for now we can ship identical prod functions\n\n    var jsxs = jsxWithValidationStatic;\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsx = jsx;\n    exports.jsxs = jsxs;\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVhOztBQUViLElBQUlBLElBQUosRUFBMkM7RUFDekMsQ0FBQyxZQUFXO0lBQ2Q7O0lBRUEsSUFBSUcsS0FBSyxHQUFHQyxtQkFBTyxDQUFDLDRDQUFELENBQW5CLENBSGMsQ0FLZDtJQUNBO0lBQ0E7SUFDQTs7O0lBQ0EsSUFBSUMsa0JBQWtCLEdBQUdDLE1BQU0sQ0FBQ0MsR0FBUCxDQUFXLGVBQVgsQ0FBekI7SUFDQSxJQUFJQyxpQkFBaUIsR0FBR0YsTUFBTSxDQUFDQyxHQUFQLENBQVcsY0FBWCxDQUF4QjtJQUNBLElBQUlFLG1CQUFtQixHQUFHSCxNQUFNLENBQUNDLEdBQVAsQ0FBVyxnQkFBWCxDQUExQjtJQUNBLElBQUlHLHNCQUFzQixHQUFHSixNQUFNLENBQUNDLEdBQVAsQ0FBVyxtQkFBWCxDQUE3QjtJQUNBLElBQUlJLG1CQUFtQixHQUFHTCxNQUFNLENBQUNDLEdBQVAsQ0FBVyxnQkFBWCxDQUExQjtJQUNBLElBQUlLLG1CQUFtQixHQUFHTixNQUFNLENBQUNDLEdBQVAsQ0FBVyxnQkFBWCxDQUExQjtJQUNBLElBQUlNLGtCQUFrQixHQUFHUCxNQUFNLENBQUNDLEdBQVAsQ0FBVyxlQUFYLENBQXpCO0lBQ0EsSUFBSU8sc0JBQXNCLEdBQUdSLE1BQU0sQ0FBQ0MsR0FBUCxDQUFXLG1CQUFYLENBQTdCO0lBQ0EsSUFBSVEsbUJBQW1CLEdBQUdULE1BQU0sQ0FBQ0MsR0FBUCxDQUFXLGdCQUFYLENBQTFCO0lBQ0EsSUFBSVMsd0JBQXdCLEdBQUdWLE1BQU0sQ0FBQ0MsR0FBUCxDQUFXLHFCQUFYLENBQS9CO0lBQ0EsSUFBSVUsZUFBZSxHQUFHWCxNQUFNLENBQUNDLEdBQVAsQ0FBVyxZQUFYLENBQXRCO0lBQ0EsSUFBSVcsZUFBZSxH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RDtjQUNGLENBUkQsTUFRTztnQkFDTGpPLEtBQUssQ0FBQywyREFBMkQsZ0VBQTNELEdBQThILGtDQUEvSCxDQUFMO2NBQ0Q7WUFDRixDQVpELE1BWU87Y0FDTDBNLGlCQUFpQixDQUFDdUIsUUFBRCxFQUFXbE0sSUFBWCxDQUFqQjtZQUNEO1VBQ0Y7UUFDRjs7UUFFRCxJQUFJQSxJQUFJLEtBQUtsRCxtQkFBYixFQUFrQztVQUNoQzRPLHFCQUFxQixDQUFDMUYsT0FBRCxDQUFyQjtRQUNELENBRkQsTUFFTztVQUNMb0YsaUJBQWlCLENBQUNwRixPQUFELENBQWpCO1FBQ0Q7O1FBRUQsT0FBT0EsT0FBUDtNQUNEO0lBQ0YsQ0EzdkNhLENBMnZDWjtJQUNGO0lBQ0E7SUFDQTs7O0lBRUEsU0FBU21HLHVCQUFULENBQWlDbk0sSUFBakMsRUFBdUM0QyxLQUF2QyxFQUE4Q2tGLEdBQTlDLEVBQW1EO01BQ2pEO1FBQ0UsT0FBTytELGlCQUFpQixDQUFDN0wsSUFBRCxFQUFPNEMsS0FBUCxFQUFja0YsR0FBZCxFQUFtQixJQUFuQixDQUF4QjtNQUNEO0lBQ0Y7O0lBQ0QsU0FBU3NFLHdCQUFULENBQWtDcE0sSUFBbEMsRUFBd0M0QyxLQUF4QyxFQUErQ2tGLEdBQS9DLEVBQW9EO01BQ2xEO1FBQ0UsT0FBTytELGlCQUFpQixDQUFDN0wsSUFBRCxFQUFPNEMsS0FBUCxFQUFja0YsR0FBZCxFQUFtQixLQUFuQixDQUF4QjtNQUNEO0lBQ0Y7O0lBRUQsSUFBSXVFLEdBQUcsR0FBSUQsd0JBQVgsQ0Ezd0NjLENBMndDd0I7SUFDdEM7O0lBRUEsSUFBSUUsSUFBSSxHQUFJSCx1QkFBWjtJQUVBSSxnQkFBQSxHQUFtQnpQLG1CQUFuQjtJQUNBeVAsV0FBQSxHQUFjRixHQUFkO0lBQ0FFLFlBQUEsR0FBZUQsSUFBZjtFQUNHLENBbnhDRDtBQW94Q0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcz8yZmMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cbnZhciBlbmFibGVDYWNoZUVsZW1lbnQgPSBmYWxzZTtcbnZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTsgLy8gVHJhY2sgd2hpY2ggRmliZXIocykgc2NoZWR1bGUgcmVuZGVyIHdvcmsuXG5cbnZhciBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFO1xuXG57XG4gIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5tb2R1bGUucmVmZXJlbmNlJyk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuLy8gZXZlbiB3aXRoIHRoZSBwcm9kIHRyYW5zZm9ybS4gVGhpcyBtZWFucyB0aGF0IGpzeERFViBpcyBwdXJlbHlcbi8vIG9wdC1pbiBiZWhhdmlvciBmb3IgYmV0dGVyIG1lc3NhZ2VzIGJ1dCB0aGF0IHdlIHdvbid0IHN0b3Bcbi8vIGdpdmluZyB5b3Ugd2FybmluZ3MgaWYgeW91IHVzZSBwcm9kdWN0aW9uIGFwaXMuXG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljKHR5cGUsIHByb3BzLCBrZXkpIHtcbiAge1xuICAgIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25EeW5hbWljKHR5cGUsIHByb3BzLCBrZXkpIHtcbiAge1xuICAgIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBmYWxzZSk7XG4gIH1cbn1cblxudmFyIGpzeCA9ICBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWMgOyAvLyB3ZSBtYXkgd2FudCB0byBzcGVjaWFsIGNhc2UganN4cyBpbnRlcm5hbGx5IHRvIHRha2UgYWR2YW50YWdlIG9mIHN0YXRpYyBjaGlsZHJlbi5cbi8vIGZvciBub3cgd2UgY2FuIHNoaXAgaWRlbnRpY2FsIHByb2QgZnVuY3Rpb25zXG5cbnZhciBqc3hzID0gIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljIDtcblxuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLmpzeCA9IGpzeDtcbmV4cG9ydHMuanN4cyA9IGpzeHM7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiUmVhY3QiLCJyZXF1aXJlIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiU3ltYm9sIiwiZm9yIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwidHlwZSIsIiQkdHlwZW9mIiwiZ2V0TW9kdWxlSWQiLCJ1bmRlZmluZWQiLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZGlzcGxheU5hbWUiLCJmdW5jdGlvbk5hbWUiLCJuYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCJ0YWciLCJjb250ZXh0IiwicHJvdmlkZXIiLCJfY29udGV4dCIsInJlbmRlciIsIm91dGVyTmFtZSIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJpbml0IiwiX2luaXQiLCJ4IiwiYXNzaWduIiwiT2JqZWN0IiwiZGlzYWJsZWREZXB0aCIsInByZXZMb2ciLCJwcmV2SW5mbyIsInByZXZXYXJuIiwicHJldkVycm9yIiwicHJldkdyb3VwIiwicHJldkdyb3VwQ29sbGFwc2VkIiwicHJldkdyb3VwRW5kIiwiZGlzYWJsZWRMb2ciLCJfX3JlYWN0RGlzYWJsZWRMb2ciLCJkaXNhYmxlTG9ncyIsImxvZyIsImluZm8iLCJ3YXJuIiwiZ3JvdXAiLCJncm91cENvbGxhcHNlZCIsImdyb3VwRW5kIiwicHJvcHMiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwidmFsdWUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnRpZXMiLCJyZWVuYWJsZUxvZ3MiLCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyIiwicHJlZml4IiwiZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUiLCJzb3VyY2UiLCJvd25lckZuIiwiRXJyb3IiLCJtYXRjaCIsInRyaW0iLCJyZWVudHJ5IiwiY29tcG9uZW50RnJhbWVDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCIsIldlYWtNYXAiLCJNYXAiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiZm4iLCJjb25zdHJ1Y3QiLCJmcmFtZSIsImdldCIsImNvbnRyb2wiLCJwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJwcmV2aW91c0Rpc3BhdGNoZXIiLCJjdXJyZW50IiwiRmFrZSIsImRlZmluZVByb3BlcnR5Iiwic2V0IiwiUmVmbGVjdCIsInNhbXBsZSIsInNhbXBsZUxpbmVzIiwic3BsaXQiLCJjb250cm9sTGluZXMiLCJzIiwiYyIsIl9mcmFtZSIsInJlcGxhY2UiLCJpbmNsdWRlcyIsInN5bnRoZXRpY0ZyYW1lIiwiZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lIiwic2hvdWxkQ29uc3RydWN0IiwiQ29tcG9uZW50IiwiaXNSZWFjdENvbXBvbmVudCIsImRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFViIsImhhc093blByb3BlcnR5IiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJlbGVtZW50Iiwib3duZXIiLCJfb3duZXIiLCJfc291cmNlIiwic2V0RXh0cmFTdGFja0ZyYW1lIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImNvbXBvbmVudE5hbWUiLCJoYXMiLCJiaW5kIiwidHlwZVNwZWNOYW1lIiwiZXJyb3IkMSIsImVyciIsImV4IiwibWVzc2FnZSIsImlzQXJyYXlJbXBsIiwiaXNBcnJheSIsImEiLCJ0eXBlTmFtZSIsImhhc1RvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJjb25zdHJ1Y3RvciIsIndpbGxDb2VyY2lvblRocm93IiwidGVzdFN0cmluZ0NvZXJjaW9uIiwiZSIsImNoZWNrS2V5U3RyaW5nQ29lcmNpb24iLCJSZWFjdEN1cnJlbnRPd25lciIsIlJFU0VSVkVEX1BST1BTIiwia2V5IiwicmVmIiwiX19zZWxmIiwiX19zb3VyY2UiLCJzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biIsInNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duIiwiZGlkV2FybkFib3V0U3RyaW5nUmVmcyIsImhhc1ZhbGlkUmVmIiwiY29uZmlnIiwiZ2V0dGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaXNSZWFjdFdhcm5pbmciLCJoYXNWYWxpZEtleSIsIndhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZCIsInNlbGYiLCJzdGF0ZU5vZGUiLCJkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ0tleSIsImRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nUmVmIiwiUmVhY3RFbGVtZW50IiwiX3N0b3JlIiwiZnJlZXplIiwianN4REVWIiwibWF5YmVLZXkiLCJwcm9wTmFtZSIsImRlZmF1bHRQcm9wcyIsIlJlYWN0Q3VycmVudE93bmVyJDEiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwicHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24iLCJpc1ZhbGlkRWxlbWVudCIsIm9iamVjdCIsImdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSIsImdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwiZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsInBhcmVudFR5cGUiLCJwYXJlbnROYW1lIiwidmFsaWRhdGVFeHBsaWNpdEtleSIsInZhbGlkYXRlZCIsImN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJjaGlsZE93bmVyIiwidmFsaWRhdGVDaGlsZEtleXMiLCJub2RlIiwiaSIsImNoaWxkIiwiaXRlcmF0b3JGbiIsImVudHJpZXMiLCJzdGVwIiwibmV4dCIsImRvbmUiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsIl9uYW1lIiwiZ2V0RGVmYXVsdFByb3BzIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJmcmFnbWVudCIsImtleXMiLCJqc3hXaXRoVmFsaWRhdGlvbiIsImlzU3RhdGljQ2hpbGRyZW4iLCJ2YWxpZFR5cGUiLCJzb3VyY2VJbmZvIiwidHlwZVN0cmluZyIsImNoaWxkcmVuIiwianN4V2l0aFZhbGlkYXRpb25TdGF0aWMiLCJqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWMiLCJqc3giLCJqc3hzIiwiZXhwb3J0cyIsIkZyYWdtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUlBLEtBQUosRUFBMkMsRUFBM0MsTUFFTztFQUNMRyx1SkFBQTtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/NTc3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-runtime.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSUEsS0FBSixFQUEyQyxFQUEzQyxNQUVPO0VBQ0xHLCtJQUFBO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzPzM0ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-runtime.js\n"));

/***/ }),

/***/ "./node_modules/recoil/es/index.js":
/*!*****************************************!*\
  !*** ./node_modules/recoil/es/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultValue\": function() { return /* binding */ Recoil_index_1; },\n/* harmony export */   \"RecoilLoadable\": function() { return /* binding */ Recoil_index_3; },\n/* harmony export */   \"RecoilRoot\": function() { return /* binding */ Recoil_index_4; },\n/* harmony export */   \"atom\": function() { return /* binding */ Recoil_index_7; },\n/* harmony export */   \"atomFamily\": function() { return /* binding */ Recoil_index_9; },\n/* harmony export */   \"constSelector\": function() { return /* binding */ Recoil_index_11; },\n/* harmony export */   \"errorSelector\": function() { return /* binding */ Recoil_index_12; },\n/* harmony export */   \"isRecoilValue\": function() { return /* binding */ Recoil_index_2; },\n/* harmony export */   \"noWait\": function() { return /* binding */ Recoil_index_14; },\n/* harmony export */   \"readOnlySelector\": function() { return /* binding */ Recoil_index_13; },\n/* harmony export */   \"retentionZone\": function() { return /* binding */ Recoil_index_37; },\n/* harmony export */   \"selector\": function() { return /* binding */ Recoil_index_8; },\n/* harmony export */   \"selectorFamily\": function() { return /* binding */ Recoil_index_10; },\n/* harmony export */   \"snapshot_UNSTABLE\": function() { return /* binding */ Recoil_index_35; },\n/* harmony export */   \"useGetRecoilValueInfo_UNSTABLE\": function() { return /* binding */ Recoil_index_25; },\n/* harmony export */   \"useGotoRecoilSnapshot\": function() { return /* binding */ Recoil_index_32; },\n/* harmony export */   \"useRecoilBridgeAcrossReactRoots_UNSTABLE\": function() { return /* binding */ Recoil_index_6; },\n/* harmony export */   \"useRecoilCallback\": function() { return /* binding */ Recoil_index_30; },\n/* harmony export */   \"useRecoilRefresher_UNSTABLE\": function() { return /* binding */ Recoil_index_26; },\n/* harmony export */   \"useRecoilSnapshot\": function() { return /* binding */ Recoil_index_33; },\n/* harmony export */   \"useRecoilState\": function() { return /* binding */ Recoil_index_21; },\n/* harmony export */   \"useRecoilStateLoadable\": function() { return /* binding */ Recoil_index_22; },\n/* harmony export */   \"useRecoilState_TRANSITION_SUPPORT_UNSTABLE\": function() { return /* binding */ Recoil_index_29; },\n/* harmony export */   \"useRecoilStoreID\": function() { return /* binding */ Recoil_index_5; },\n/* harmony export */   \"useRecoilTransactionObserver_UNSTABLE\": function() { return /* binding */ Recoil_index_34; },\n/* harmony export */   \"useRecoilTransaction_UNSTABLE\": function() { return /* binding */ Recoil_index_31; },\n/* harmony export */   \"useRecoilValue\": function() { return /* binding */ Recoil_index_19; },\n/* harmony export */   \"useRecoilValueLoadable\": function() { return /* binding */ Recoil_index_20; },\n/* harmony export */   \"useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE\": function() { return /* binding */ Recoil_index_27; },\n/* harmony export */   \"useRecoilValue_TRANSITION_SUPPORT_UNSTABLE\": function() { return /* binding */ Recoil_index_28; },\n/* harmony export */   \"useResetRecoilState\": function() { return /* binding */ Recoil_index_24; },\n/* harmony export */   \"useRetain\": function() { return /* binding */ Recoil_index_36; },\n/* harmony export */   \"useSetRecoilState\": function() { return /* binding */ Recoil_index_23; },\n/* harmony export */   \"waitForAll\": function() { return /* binding */ Recoil_index_17; },\n/* harmony export */   \"waitForAllSettled\": function() { return /* binding */ Recoil_index_18; },\n/* harmony export */   \"waitForAny\": function() { return /* binding */ Recoil_index_16; },\n/* harmony export */   \"waitForNone\": function() { return /* binding */ Recoil_index_15; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n\n\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction err(message) {\n  const error = new Error(message); // In V8, Error objects keep the closure scope chain alive until the\n  // err.stack property is accessed.\n\n  if (error.stack === undefined) {\n    // IE sets the stack only if error is thrown\n    try {\n      throw error;\n    } catch (_) {} // eslint-disable-line fb-www/no-unused-catch-bindings, no-empty\n\n  }\n\n  return error;\n}\n\nvar err_1 = err; // @oss-only\n\nvar Recoil_err = err_1;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n// Split declaration and implementation to allow this function to pretend to\n// check for actual instance of Promise instead of something with a `then`\n// method.\n// eslint-disable-next-line no-redeclare\n\nfunction isPromise(p) {\n  return !!p && typeof p.then === 'function';\n}\n\nvar Recoil_isPromise = isPromise;\n\nfunction nullthrows(x, message) {\n  if (x != null) {\n    return x;\n  }\n\n  throw Recoil_err(message !== null && message !== void 0 ? message : 'Got unexpected null or undefined');\n}\n\nvar Recoil_nullthrows = nullthrows;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass BaseLoadable {\n  getValue() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  toPromise() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  valueMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  valueOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected value, but in \"${this.state}\" state`);\n  }\n\n  promiseMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  promiseOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected promise, but in \"${this.state}\" state`);\n  }\n\n  errorMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  errorOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected error, but in \"${this.state}\" state`);\n  }\n\n  is(other) {\n    // $FlowFixMe[prop-missing]\n    return other.state === this.state && other.contents === this.contents;\n  }\n\n  map(_map) {\n    throw Recoil_err('BaseLoadable');\n  }\n\n}\n\nclass ValueLoadable extends BaseLoadable {\n  constructor(value) {\n    super();\n\n    _defineProperty(this, \"state\", 'hasValue');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = value;\n  }\n\n  getValue() {\n    return this.contents;\n  }\n\n  toPromise() {\n    return Promise.resolve(this.contents);\n  }\n\n  valueMaybe() {\n    return this.contents;\n  }\n\n  valueOrThrow() {\n    return this.contents;\n  }\n\n  promiseMaybe() {\n    return undefined;\n  }\n\n  errorMaybe() {\n    return undefined;\n  }\n\n  map(map) {\n    try {\n      const next = map(this.contents);\n      return Recoil_isPromise(next) ? loadableWithPromise(next) : isLoadable(next) ? next : loadableWithValue(next);\n    } catch (e) {\n      return Recoil_isPromise(e) ? // If we \"suspended\", then try again.\n      // errors and subsequent retries will be handled in 'loading' case\n      // $FlowFixMe[prop-missing]\n      loadableWithPromise(e.next(() => this.map(map))) : loadableWithError(e);\n    }\n  }\n\n}\n\nclass ErrorLoadable extends BaseLoadable {\n  constructor(error) {\n    super();\n\n    _defineProperty(this, \"state\", 'hasError');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = error;\n  }\n\n  getValue() {\n    throw this.contents;\n  }\n\n  toPromise() {\n    return Promise.reject(this.contents);\n  }\n\n  valueMaybe() {\n    return undefined;\n  }\n\n  promiseMaybe() {\n    return undefined;\n  }\n\n  errorMaybe() {\n    return this.contents;\n  }\n\n  errorOrThrow() {\n    return this.contents;\n  }\n\n  map(_map) {\n    // $FlowIssue[incompatible-return]\n    return this;\n  }\n\n}\n\nclass LoadingLoadable extends BaseLoadable {\n  constructor(promise) {\n    super();\n\n    _defineProperty(this, \"state\", 'loading');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = promise;\n  }\n\n  getValue() {\n    throw this.contents;\n  }\n\n  toPromise() {\n    return this.contents;\n  }\n\n  valueMaybe() {\n    return undefined;\n  }\n\n  promiseMaybe() {\n    return this.contents;\n  }\n\n  promiseOrThrow() {\n    return this.contents;\n  }\n\n  errorMaybe() {\n    return undefined;\n  }\n\n  map(map) {\n    return loadableWithPromise(this.contents.then(value => {\n      const next = map(value);\n\n      if (isLoadable(next)) {\n        const nextLoadable = next;\n\n        switch (nextLoadable.state) {\n          case 'hasValue':\n            return nextLoadable.contents;\n\n          case 'hasError':\n            throw nextLoadable.contents;\n\n          case 'loading':\n            return nextLoadable.contents;\n        }\n      } // $FlowIssue[incompatible-return]\n\n\n      return next;\n    }).catch(e => {\n      if (Recoil_isPromise(e)) {\n        // we were \"suspended,\" try again\n        return e.then(() => this.map(map).contents);\n      }\n\n      throw e;\n    }));\n  }\n\n}\n\nfunction loadableWithValue(value) {\n  return Object.freeze(new ValueLoadable(value));\n}\n\nfunction loadableWithError(error) {\n  return Object.freeze(new ErrorLoadable(error));\n}\n\nfunction loadableWithPromise(promise) {\n  return Object.freeze(new LoadingLoadable(promise));\n}\n\nfunction loadableLoading() {\n  return Object.freeze(new LoadingLoadable(new Promise(() => {})));\n}\n\nfunction loadableAllArray(inputs) {\n  return inputs.every(i => i.state === 'hasValue') ? loadableWithValue(inputs.map(i => i.contents)) : inputs.some(i => i.state === 'hasError') ? loadableWithError(Recoil_nullthrows(inputs.find(i => i.state === 'hasError'), 'Invalid loadable passed to loadableAll').contents) : loadableWithPromise(Promise.all(inputs.map(i => i.contents)));\n}\n\nfunction loadableAll(inputs) {\n  const unwrapedInputs = Array.isArray(inputs) ? inputs : Object.getOwnPropertyNames(inputs).map(key => inputs[key]);\n  const normalizedInputs = unwrapedInputs.map(x => isLoadable(x) ? x : Recoil_isPromise(x) ? loadableWithPromise(x) : loadableWithValue(x));\n  const output = loadableAllArray(normalizedInputs);\n  return Array.isArray(inputs) ? // $FlowIssue[incompatible-return]\n  output : // Object.getOwnPropertyNames() has consistent key ordering with ES6\n  // $FlowIssue[incompatible-call]\n  output.map(outputs => Object.getOwnPropertyNames(inputs).reduce((out, key, idx) => ({ ...out,\n    [key]: outputs[idx]\n  }), {}));\n}\n\nfunction isLoadable(x) {\n  return x instanceof BaseLoadable;\n}\n\nconst LoadableStaticInterface = {\n  of: value => Recoil_isPromise(value) ? loadableWithPromise(value) : isLoadable(value) ? value : loadableWithValue(value),\n  error: error => loadableWithError(error),\n  // $FlowIssue[incompatible-return]\n  loading: () => loadableLoading(),\n  // $FlowIssue[unclear-type]\n  all: loadableAll,\n  isLoadable\n};\nvar Recoil_Loadable = {\n  loadableWithValue,\n  loadableWithError,\n  loadableWithPromise,\n  loadableLoading,\n  loadableAll,\n  isLoadable,\n  RecoilLoadable: LoadableStaticInterface\n};\nvar Recoil_Loadable_1 = Recoil_Loadable.loadableWithValue;\nvar Recoil_Loadable_2 = Recoil_Loadable.loadableWithError;\nvar Recoil_Loadable_3 = Recoil_Loadable.loadableWithPromise;\nvar Recoil_Loadable_4 = Recoil_Loadable.loadableLoading;\nvar Recoil_Loadable_5 = Recoil_Loadable.loadableAll;\nvar Recoil_Loadable_6 = Recoil_Loadable.isLoadable;\nvar Recoil_Loadable_7 = Recoil_Loadable.RecoilLoadable;\nvar Recoil_Loadable$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  loadableWithValue: Recoil_Loadable_1,\n  loadableWithError: Recoil_Loadable_2,\n  loadableWithPromise: Recoil_Loadable_3,\n  loadableLoading: Recoil_Loadable_4,\n  loadableAll: Recoil_Loadable_5,\n  isLoadable: Recoil_Loadable_6,\n  RecoilLoadable: Recoil_Loadable_7\n});\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nconst gks = new Map().set('recoil_hamt_2020', true).set('recoil_sync_external_store', true).set('recoil_suppress_rerender_in_callback', true).set('recoil_memory_managament_2020', true);\n\nfunction Recoil_gkx_OSS(gk) {\n  var _gks$get;\n\n  return (_gks$get = gks.get(gk)) !== null && _gks$get !== void 0 ? _gks$get : false;\n}\n\nRecoil_gkx_OSS.setPass = gk => {\n  gks.set(gk, true);\n};\n\nRecoil_gkx_OSS.setFail = gk => {\n  gks.set(gk, false);\n};\n\nRecoil_gkx_OSS.clear = () => {\n  gks.clear();\n};\n\nvar Recoil_gkx = Recoil_gkx_OSS; // @oss-only\n\nvar _createMutableSource, _useMutableSource, _useSyncExternalStore;\n\nconst createMutableSource = // flowlint-next-line unclear-type:off\n(_createMutableSource = (react__WEBPACK_IMPORTED_MODULE_0___default().createMutableSource)) !== null && _createMutableSource !== void 0 ? _createMutableSource : (react__WEBPACK_IMPORTED_MODULE_0___default().unstable_createMutableSource);\nconst useMutableSource = // flowlint-next-line unclear-type:off\n(_useMutableSource = (react__WEBPACK_IMPORTED_MODULE_0___default().useMutableSource)) !== null && _useMutableSource !== void 0 ? _useMutableSource : (react__WEBPACK_IMPORTED_MODULE_0___default().unstable_useMutableSource); // https://github.com/reactwg/react-18/discussions/86\n\nconst useSyncExternalStore = // flowlint-next-line unclear-type:off\n(_useSyncExternalStore = (react__WEBPACK_IMPORTED_MODULE_0___default().useSyncExternalStore)) !== null && _useSyncExternalStore !== void 0 ? _useSyncExternalStore : // flowlint-next-line unclear-type:off\n(react__WEBPACK_IMPORTED_MODULE_0___default().unstable_useSyncExternalStore);\n/**\r\n * mode: The React API and approach to use for syncing state with React\r\n * early: Re-renders from Recoil updates occur:\r\n *    1) earlier\r\n *    2) in sync with React updates in the same batch\r\n *    3) before transaction observers instead of after.\r\n * concurrent: Is the current mode compatible with Concurrent Mode and useTransition()\r\n */\n\nfunction reactMode() {\n  // NOTE: This mode is currently broken with some Suspense cases\n  // see Recoil_selector-test.js\n  if (Recoil_gkx('recoil_transition_support')) {\n    return {\n      mode: 'TRANSITION_SUPPORT',\n      early: true,\n      concurrent: true\n    };\n  }\n\n  if (Recoil_gkx('recoil_sync_external_store') && useSyncExternalStore != null) {\n    return {\n      mode: 'SYNC_EXTERNAL_STORE',\n      early: true,\n      concurrent: false\n    };\n  }\n\n  if (Recoil_gkx('recoil_mutable_source') && useMutableSource != null && typeof window !== 'undefined' && !window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE) {\n    return Recoil_gkx('recoil_suppress_rerender_in_callback') ? {\n      mode: 'MUTABLE_SOURCE',\n      early: true,\n      concurrent: true\n    } : {\n      mode: 'MUTABLE_SOURCE',\n      early: false,\n      concurrent: false\n    };\n  }\n\n  return Recoil_gkx('recoil_suppress_rerender_in_callback') ? {\n    mode: 'LEGACY',\n    early: true,\n    concurrent: false\n  } : {\n    mode: 'LEGACY',\n    early: false,\n    concurrent: false\n  };\n} // TODO Need to figure out if there is a standard/open-source equivalent to see if hot module replacement is happening:\n\n\nfunction isFastRefreshEnabled() {\n  // @fb-only: const {isAcceptingUpdate} = require('__debug');\n  // @fb-only: return typeof isAcceptingUpdate === 'function' && isAcceptingUpdate();\n  return false; // @oss-only\n}\n\nvar Recoil_ReactMode = {\n  createMutableSource,\n  useMutableSource,\n  useSyncExternalStore,\n  reactMode,\n  isFastRefreshEnabled\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n// eslint-disable-next-line no-unused-vars\n\nclass AbstractRecoilValue {\n  constructor(newKey) {\n    _defineProperty(this, \"key\", void 0);\n\n    this.key = newKey;\n  }\n\n  toJSON() {\n    return {\n      key: this.key\n    };\n  }\n\n}\n\nclass RecoilState extends AbstractRecoilValue {}\n\nclass RecoilValueReadOnly extends AbstractRecoilValue {}\n\nfunction isRecoilValue(x) {\n  return x instanceof RecoilState || x instanceof RecoilValueReadOnly;\n}\n\nvar Recoil_RecoilValue = {\n  AbstractRecoilValue,\n  RecoilState,\n  RecoilValueReadOnly,\n  isRecoilValue\n};\nvar Recoil_RecoilValue_1 = Recoil_RecoilValue.AbstractRecoilValue;\nvar Recoil_RecoilValue_2 = Recoil_RecoilValue.RecoilState;\nvar Recoil_RecoilValue_3 = Recoil_RecoilValue.RecoilValueReadOnly;\nvar Recoil_RecoilValue_4 = Recoil_RecoilValue.isRecoilValue;\nvar Recoil_RecoilValue$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AbstractRecoilValue: Recoil_RecoilValue_1,\n  RecoilState: Recoil_RecoilValue_2,\n  RecoilValueReadOnly: Recoil_RecoilValue_3,\n  isRecoilValue: Recoil_RecoilValue_4\n});\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction sprintf(format, ...args) {\n  let index = 0;\n  return format.replace(/%s/g, () => String(args[index++]));\n}\n\nvar sprintf_1 = sprintf;\n\nfunction expectationViolation(format, ...args) {\n  if (true) {\n    const message = sprintf_1.call(null, format, ...args);\n    const error = new Error(message);\n    error.name = 'Expectation Violation';\n    console.error(error);\n  }\n}\n\nvar expectationViolation_1 = expectationViolation; // @oss-only\n\nvar Recoil_expectationViolation = expectationViolation_1;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Creates a new iterable whose output is generated by passing the input\r\n * iterable's values through the mapper function.\r\n */\n\nfunction mapIterable(iterable, callback) {\n  // Use generator to create iterable/iterator\n  return function* () {\n    let index = 0;\n\n    for (const value of iterable) {\n      yield callback(value, index++);\n    }\n  }();\n}\n\nvar Recoil_mapIterable = mapIterable;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction recoverableViolation(message, _projectName, {\n  error\n} = {}) {\n  if (true) {\n    console.error(message, error);\n  }\n\n  return null;\n}\n\nvar recoverableViolation_1 = recoverableViolation; // @oss-only\n\nvar Recoil_recoverableViolation = recoverableViolation_1;\nconst {\n  isFastRefreshEnabled: isFastRefreshEnabled$1\n} = Recoil_ReactMode;\n\nclass DefaultValue {}\n\nconst DEFAULT_VALUE = new DefaultValue(); // flowlint-next-line unclear-type:off\n\nconst nodes = new Map(); // flowlint-next-line unclear-type:off\n\nconst recoilValues = new Map();\n/* eslint-disable no-redeclare */\n\nfunction recoilValuesForKeys(keys) {\n  return Recoil_mapIterable(keys, key => Recoil_nullthrows(recoilValues.get(key)));\n}\n\nfunction registerNode(node) {\n  if (nodes.has(node.key)) {\n    const message = `Duplicate atom key \"${node.key}\". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;\n\n    if (true) {\n      // TODO Figure this out for open-source\n      if (!isFastRefreshEnabled$1()) {\n        Recoil_expectationViolation(message, 'recoil');\n      }\n    } else {}\n  }\n\n  nodes.set(node.key, node);\n  const recoilValue = node.set == null ? new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key) : new Recoil_RecoilValue$1.RecoilState(node.key);\n  recoilValues.set(node.key, recoilValue);\n  return recoilValue;\n}\n/* eslint-enable no-redeclare */\n\n\nclass NodeMissingError extends Error {} // flowlint-next-line unclear-type:off\n\n\nfunction getNode(key) {\n  const node = nodes.get(key);\n\n  if (node == null) {\n    throw new NodeMissingError(`Missing definition for RecoilValue: \"${key}\"\"`);\n  }\n\n  return node;\n} // flowlint-next-line unclear-type:off\n\n\nfunction getNodeMaybe(key) {\n  return nodes.get(key);\n}\n\nconst configDeletionHandlers = new Map();\n\nfunction deleteNodeConfigIfPossible(key) {\n  var _node$shouldDeleteCon;\n\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const node = nodes.get(key);\n\n  if (node !== null && node !== void 0 && (_node$shouldDeleteCon = node.shouldDeleteConfigOnRelease) !== null && _node$shouldDeleteCon !== void 0 && _node$shouldDeleteCon.call(node)) {\n    var _getConfigDeletionHan;\n\n    nodes.delete(key);\n    (_getConfigDeletionHan = getConfigDeletionHandler(key)) === null || _getConfigDeletionHan === void 0 ? void 0 : _getConfigDeletionHan();\n    configDeletionHandlers.delete(key);\n  }\n}\n\nfunction setConfigDeletionHandler(key, fn) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  if (fn === undefined) {\n    configDeletionHandlers.delete(key);\n  } else {\n    configDeletionHandlers.set(key, fn);\n  }\n}\n\nfunction getConfigDeletionHandler(key) {\n  return configDeletionHandlers.get(key);\n}\n\nvar Recoil_Node = {\n  nodes,\n  recoilValues,\n  registerNode,\n  getNode,\n  getNodeMaybe,\n  deleteNodeConfigIfPossible,\n  setConfigDeletionHandler,\n  getConfigDeletionHandler,\n  recoilValuesForKeys,\n  NodeMissingError,\n  DefaultValue,\n  DEFAULT_VALUE\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction enqueueExecution(s, f) {\n  f();\n}\n\nvar Recoil_Queue = {\n  enqueueExecution\n};\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar hamt_1 = createCommonjsModule(function (module) {\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n  /**\r\n      @fileOverview Hash Array Mapped Trie.\r\n  \r\n      Code based on: https://github.com/exclipy/pdata\r\n  */\n\n\n  var hamt = {}; // export\n\n  /* Configuration\r\n   ******************************************************************************/\n\n  var SIZE = 5;\n  var BUCKET_SIZE = Math.pow(2, SIZE);\n  var MASK = BUCKET_SIZE - 1;\n  var MAX_INDEX_NODE = BUCKET_SIZE / 2;\n  var MIN_ARRAY_NODE = BUCKET_SIZE / 4;\n  /*\r\n   ******************************************************************************/\n\n  var nothing = {};\n\n  var constant = function constant(x) {\n    return function () {\n      return x;\n    };\n  };\n  /**\r\n      Get 32 bit hash of string.\r\n  \r\n      Based on:\r\n      http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\r\n  */\n\n\n  var hash = hamt.hash = function (str) {\n    var type = typeof str === 'undefined' ? 'undefined' : _typeof(str);\n    if (type === 'number') return str;\n    if (type !== 'string') str += '';\n    var hash = 0;\n\n    for (var i = 0, len = str.length; i < len; ++i) {\n      var c = str.charCodeAt(i);\n      hash = (hash << 5) - hash + c | 0;\n    }\n\n    return hash;\n  };\n  /* Bit Ops\r\n   ******************************************************************************/\n\n  /**\r\n      Hamming weight.\r\n  \r\n      Taken from: http://jsperf.com/hamming-weight\r\n  */\n\n\n  var popcount = function popcount(x) {\n    x -= x >> 1 & 0x55555555;\n    x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n    x = x + (x >> 4) & 0x0f0f0f0f;\n    x += x >> 8;\n    x += x >> 16;\n    return x & 0x7f;\n  };\n\n  var hashFragment = function hashFragment(shift, h) {\n    return h >>> shift & MASK;\n  };\n\n  var toBitmap = function toBitmap(x) {\n    return 1 << x;\n  };\n\n  var fromBitmap = function fromBitmap(bitmap, bit) {\n    return popcount(bitmap & bit - 1);\n  };\n  /* Array Ops\r\n   ******************************************************************************/\n\n  /**\r\n      Set a value in an array.\r\n  \r\n      @param mutate Should the input array be mutated?\r\n      @param at Index to change.\r\n      @param v New value\r\n      @param arr Array.\r\n  */\n\n\n  var arrayUpdate = function arrayUpdate(mutate, at, v, arr) {\n    var out = arr;\n\n    if (!mutate) {\n      var len = arr.length;\n      out = new Array(len);\n\n      for (var i = 0; i < len; ++i) {\n        out[i] = arr[i];\n      }\n    }\n\n    out[at] = v;\n    return out;\n  };\n  /**\r\n      Remove a value from an array.\r\n  \r\n      @param mutate Should the input array be mutated?\r\n      @param at Index to remove.\r\n      @param arr Array.\r\n  */\n\n\n  var arraySpliceOut = function arraySpliceOut(mutate, at, arr) {\n    var newLen = arr.length - 1;\n    var i = 0;\n    var g = 0;\n    var out = arr;\n\n    if (mutate) {\n      i = g = at;\n    } else {\n      out = new Array(newLen);\n\n      while (i < at) {\n        out[g++] = arr[i++];\n      }\n    }\n\n    ++i;\n\n    while (i <= newLen) {\n      out[g++] = arr[i++];\n    }\n\n    if (mutate) {\n      out.length = newLen;\n    }\n\n    return out;\n  };\n  /**\r\n      Insert a value into an array.\r\n  \r\n      @param mutate Should the input array be mutated?\r\n      @param at Index to insert at.\r\n      @param v Value to insert,\r\n      @param arr Array.\r\n  */\n\n\n  var arraySpliceIn = function arraySpliceIn(mutate, at, v, arr) {\n    var len = arr.length;\n\n    if (mutate) {\n      var _i = len;\n\n      while (_i >= at) {\n        arr[_i--] = arr[_i];\n      }\n\n      arr[at] = v;\n      return arr;\n    }\n\n    var i = 0,\n        g = 0;\n    var out = new Array(len + 1);\n\n    while (i < at) {\n      out[g++] = arr[i++];\n    }\n\n    out[at] = v;\n\n    while (i < len) {\n      out[++g] = arr[i++];\n    }\n\n    return out;\n  };\n  /* Node Structures\r\n   ******************************************************************************/\n\n\n  var LEAF = 1;\n  var COLLISION = 2;\n  var INDEX = 3;\n  var ARRAY = 4;\n  /**\r\n      Empty node.\r\n  */\n\n  var empty = {\n    __hamt_isEmpty: true\n  };\n\n  var isEmptyNode = function isEmptyNode(x) {\n    return x === empty || x && x.__hamt_isEmpty;\n  };\n  /**\r\n      Leaf holding a value.\r\n  \r\n      @member edit Edit of the node.\r\n      @member hash Hash of key.\r\n      @member key Key.\r\n      @member value Value stored.\r\n  */\n\n\n  var Leaf = function Leaf(edit, hash, key, value) {\n    return {\n      type: LEAF,\n      edit: edit,\n      hash: hash,\n      key: key,\n      value: value,\n      _modify: Leaf__modify\n    };\n  };\n  /**\r\n      Leaf holding multiple values with the same hash but different keys.\r\n  \r\n      @member edit Edit of the node.\r\n      @member hash Hash of key.\r\n      @member children Array of collision children node.\r\n  */\n\n\n  var Collision = function Collision(edit, hash, children) {\n    return {\n      type: COLLISION,\n      edit: edit,\n      hash: hash,\n      children: children,\n      _modify: Collision__modify\n    };\n  };\n  /**\r\n      Internal node with a sparse set of children.\r\n  \r\n      Uses a bitmap and array to pack children.\r\n  \r\n    @member edit Edit of the node.\r\n      @member mask Bitmap that encode the positions of children in the array.\r\n      @member children Array of child nodes.\r\n  */\n\n\n  var IndexedNode = function IndexedNode(edit, mask, children) {\n    return {\n      type: INDEX,\n      edit: edit,\n      mask: mask,\n      children: children,\n      _modify: IndexedNode__modify\n    };\n  };\n  /**\r\n      Internal node with many children.\r\n  \r\n      @member edit Edit of the node.\r\n      @member size Number of children.\r\n      @member children Array of child nodes.\r\n  */\n\n\n  var ArrayNode = function ArrayNode(edit, size, children) {\n    return {\n      type: ARRAY,\n      edit: edit,\n      size: size,\n      children: children,\n      _modify: ArrayNode__modify\n    };\n  };\n  /**\r\n      Is `node` a leaf node?\r\n  */\n\n\n  var isLeaf = function isLeaf(node) {\n    return node === empty || node.type === LEAF || node.type === COLLISION;\n  };\n  /* Internal node operations.\r\n   ******************************************************************************/\n\n  /**\r\n      Expand an indexed node into an array node.\r\n  \r\n    @param edit Current edit.\r\n      @param frag Index of added child.\r\n      @param child Added child.\r\n      @param mask Index node mask before child added.\r\n      @param subNodes Index node children before child added.\r\n  */\n\n\n  var expand = function expand(edit, frag, child, bitmap, subNodes) {\n    var arr = [];\n    var bit = bitmap;\n    var count = 0;\n\n    for (var i = 0; bit; ++i) {\n      if (bit & 1) arr[i] = subNodes[count++];\n      bit >>>= 1;\n    }\n\n    arr[frag] = child;\n    return ArrayNode(edit, count + 1, arr);\n  };\n  /**\r\n      Collapse an array node into a indexed node.\r\n  \r\n    @param edit Current edit.\r\n      @param count Number of elements in new array.\r\n      @param removed Index of removed element.\r\n      @param elements Array node children before remove.\r\n  */\n\n\n  var pack = function pack(edit, count, removed, elements) {\n    var children = new Array(count - 1);\n    var g = 0;\n    var bitmap = 0;\n\n    for (var i = 0, len = elements.length; i < len; ++i) {\n      if (i !== removed) {\n        var elem = elements[i];\n\n        if (elem && !isEmptyNode(elem)) {\n          children[g++] = elem;\n          bitmap |= 1 << i;\n        }\n      }\n    }\n\n    return IndexedNode(edit, bitmap, children);\n  };\n  /**\r\n      Merge two leaf nodes.\r\n  \r\n      @param shift Current shift.\r\n      @param h1 Node 1 hash.\r\n      @param n1 Node 1.\r\n      @param h2 Node 2 hash.\r\n      @param n2 Node 2.\r\n  */\n\n\n  var mergeLeaves = function mergeLeaves(edit, shift, h1, n1, h2, n2) {\n    if (h1 === h2) return Collision(edit, h1, [n2, n1]);\n    var subH1 = hashFragment(shift, h1);\n    var subH2 = hashFragment(shift, h2);\n    return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [mergeLeaves(edit, shift + SIZE, h1, n1, h2, n2)] : subH1 < subH2 ? [n1, n2] : [n2, n1]);\n  };\n  /**\r\n      Update an entry in a collision list.\r\n  \r\n      @param mutate Should mutation be used?\r\n      @param edit Current edit.\r\n      @param keyEq Key compare function.\r\n      @param hash Hash of collision.\r\n      @param list Collision list.\r\n      @param f Update function.\r\n      @param k Key to update.\r\n      @param size Size ref.\r\n  */\n\n\n  var updateCollisionList = function updateCollisionList(mutate, edit, keyEq, h, list, f, k, size) {\n    var len = list.length;\n\n    for (var i = 0; i < len; ++i) {\n      var child = list[i];\n\n      if (keyEq(k, child.key)) {\n        var value = child.value;\n\n        var _newValue = f(value);\n\n        if (_newValue === value) return list;\n\n        if (_newValue === nothing) {\n          --size.value;\n          return arraySpliceOut(mutate, i, list);\n        }\n\n        return arrayUpdate(mutate, i, Leaf(edit, h, k, _newValue), list);\n      }\n    }\n\n    var newValue = f();\n    if (newValue === nothing) return list;\n    ++size.value;\n    return arrayUpdate(mutate, len, Leaf(edit, h, k, newValue), list);\n  };\n\n  var canEditNode = function canEditNode(edit, node) {\n    return edit === node.edit;\n  };\n  /* Editing\r\n   ******************************************************************************/\n\n\n  var Leaf__modify = function Leaf__modify(edit, keyEq, shift, f, h, k, size) {\n    if (keyEq(k, this.key)) {\n      var _v = f(this.value);\n\n      if (_v === this.value) return this;else if (_v === nothing) {\n        --size.value;\n        return empty;\n      }\n\n      if (canEditNode(edit, this)) {\n        this.value = _v;\n        return this;\n      }\n\n      return Leaf(edit, h, k, _v);\n    }\n\n    var v = f();\n    if (v === nothing) return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n  };\n\n  var Collision__modify = function Collision__modify(edit, keyEq, shift, f, h, k, size) {\n    if (h === this.hash) {\n      var canEdit = canEditNode(edit, this);\n      var list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f, k, size);\n      if (list === this.children) return this;\n      return list.length > 1 ? Collision(edit, this.hash, list) : list[0]; // collapse single element collision list\n    }\n\n    var v = f();\n    if (v === nothing) return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n  };\n\n  var IndexedNode__modify = function IndexedNode__modify(edit, keyEq, shift, f, h, k, size) {\n    var mask = this.mask;\n    var children = this.children;\n    var frag = hashFragment(shift, h);\n    var bit = toBitmap(frag);\n    var indx = fromBitmap(mask, bit);\n    var exists = mask & bit;\n    var current = exists ? children[indx] : empty;\n\n    var child = current._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n\n    if (current === child) return this;\n    var canEdit = canEditNode(edit, this);\n    var bitmap = mask;\n    var newChildren = void 0;\n\n    if (exists && isEmptyNode(child)) {\n      // remove\n      bitmap &= ~bit;\n      if (!bitmap) return empty;\n      if (children.length <= 2 && isLeaf(children[indx ^ 1])) return children[indx ^ 1]; // collapse\n\n      newChildren = arraySpliceOut(canEdit, indx, children);\n    } else if (!exists && !isEmptyNode(child)) {\n      // add\n      if (children.length >= MAX_INDEX_NODE) return expand(edit, frag, child, mask, children);\n      bitmap |= bit;\n      newChildren = arraySpliceIn(canEdit, indx, child, children);\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, indx, child, children);\n    }\n\n    if (canEdit) {\n      this.mask = bitmap;\n      this.children = newChildren;\n      return this;\n    }\n\n    return IndexedNode(edit, bitmap, newChildren);\n  };\n\n  var ArrayNode__modify = function ArrayNode__modify(edit, keyEq, shift, f, h, k, size) {\n    var count = this.size;\n    var children = this.children;\n    var frag = hashFragment(shift, h);\n    var child = children[frag];\n\n    var newChild = (child || empty)._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n\n    if (child === newChild) return this;\n    var canEdit = canEditNode(edit, this);\n    var newChildren = void 0;\n\n    if (isEmptyNode(child) && !isEmptyNode(newChild)) {\n      // add\n      ++count;\n      newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {\n      // remove\n      --count;\n      if (count <= MIN_ARRAY_NODE) return pack(edit, count, frag, children);\n      newChildren = arrayUpdate(canEdit, frag, empty, children);\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    }\n\n    if (canEdit) {\n      this.size = count;\n      this.children = newChildren;\n      return this;\n    }\n\n    return ArrayNode(edit, count, newChildren);\n  };\n\n  empty._modify = function (edit, keyEq, shift, f, h, k, size) {\n    var v = f();\n    if (v === nothing) return empty;\n    ++size.value;\n    return Leaf(edit, h, k, v);\n  };\n  /*\r\n   ******************************************************************************/\n\n\n  function Map(editable, edit, config, root, size) {\n    this._editable = editable;\n    this._edit = edit;\n    this._config = config;\n    this._root = root;\n    this._size = size;\n  }\n\n  Map.prototype.setTree = function (newRoot, newSize) {\n    if (this._editable) {\n      this._root = newRoot;\n      this._size = newSize;\n      return this;\n    }\n\n    return newRoot === this._root ? this : new Map(this._editable, this._edit, this._config, newRoot, newSize);\n  };\n  /* Queries\r\n   ******************************************************************************/\n\n  /**\r\n      Lookup the value for `key` in `map` using a custom `hash`.\r\n  \r\n      Returns the value or `alt` if none.\r\n  */\n\n\n  var tryGetHash = hamt.tryGetHash = function (alt, hash, key, map) {\n    var node = map._root;\n    var shift = 0;\n    var keyEq = map._config.keyEq;\n\n    while (true) {\n      switch (node.type) {\n        case LEAF:\n          {\n            return keyEq(key, node.key) ? node.value : alt;\n          }\n\n        case COLLISION:\n          {\n            if (hash === node.hash) {\n              var children = node.children;\n\n              for (var i = 0, len = children.length; i < len; ++i) {\n                var child = children[i];\n                if (keyEq(key, child.key)) return child.value;\n              }\n            }\n\n            return alt;\n          }\n\n        case INDEX:\n          {\n            var frag = hashFragment(shift, hash);\n            var bit = toBitmap(frag);\n\n            if (node.mask & bit) {\n              node = node.children[fromBitmap(node.mask, bit)];\n              shift += SIZE;\n              break;\n            }\n\n            return alt;\n          }\n\n        case ARRAY:\n          {\n            node = node.children[hashFragment(shift, hash)];\n\n            if (node) {\n              shift += SIZE;\n              break;\n            }\n\n            return alt;\n          }\n\n        default:\n          return alt;\n      }\n    }\n  };\n\n  Map.prototype.tryGetHash = function (alt, hash, key) {\n    return tryGetHash(alt, hash, key, this);\n  };\n  /**\r\n      Lookup the value for `key` in `map` using internal hash function.\r\n  \r\n      @see `tryGetHash`\r\n  */\n\n\n  var tryGet = hamt.tryGet = function (alt, key, map) {\n    return tryGetHash(alt, map._config.hash(key), key, map);\n  };\n\n  Map.prototype.tryGet = function (alt, key) {\n    return tryGet(alt, key, this);\n  };\n  /**\r\n      Lookup the value for `key` in `map` using a custom `hash`.\r\n  \r\n      Returns the value or `undefined` if none.\r\n  */\n\n\n  var getHash = hamt.getHash = function (hash, key, map) {\n    return tryGetHash(undefined, hash, key, map);\n  };\n\n  Map.prototype.getHash = function (hash, key) {\n    return getHash(hash, key, this);\n  };\n  /**\r\n      Lookup the value for `key` in `map` using internal hash function.\r\n  \r\n      @see `get`\r\n  */\n\n\n  var get = hamt.get = function (key, map) {\n    return tryGetHash(undefined, map._config.hash(key), key, map);\n  };\n\n  Map.prototype.get = function (key, alt) {\n    return tryGet(alt, key, this);\n  };\n  /**\r\n      Does an entry exist for `key` in `map`? Uses custom `hash`.\r\n  */\n\n\n  var hasHash = hamt.has = function (hash, key, map) {\n    return tryGetHash(nothing, hash, key, map) !== nothing;\n  };\n\n  Map.prototype.hasHash = function (hash, key) {\n    return hasHash(hash, key, this);\n  };\n  /**\r\n      Does an entry exist for `key` in `map`? Uses internal hash function.\r\n  */\n\n\n  var has = hamt.has = function (key, map) {\n    return hasHash(map._config.hash(key), key, map);\n  };\n\n  Map.prototype.has = function (key) {\n    return has(key, this);\n  };\n\n  var defKeyCompare = function defKeyCompare(x, y) {\n    return x === y;\n  };\n  /**\r\n      Create an empty map.\r\n  \r\n      @param config Configuration.\r\n  */\n\n\n  hamt.make = function (config) {\n    return new Map(0, 0, {\n      keyEq: config && config.keyEq || defKeyCompare,\n      hash: config && config.hash || hash\n    }, empty, 0);\n  };\n  /**\r\n      Empty map.\r\n  */\n\n\n  hamt.empty = hamt.make();\n  /**\r\n      Does `map` contain any elements?\r\n  */\n\n  var isEmpty = hamt.isEmpty = function (map) {\n    return map && !!isEmptyNode(map._root);\n  };\n\n  Map.prototype.isEmpty = function () {\n    return isEmpty(this);\n  };\n  /* Updates\r\n   ******************************************************************************/\n\n  /**\r\n      Alter the value stored for `key` in `map` using function `f` using\r\n      custom hash.\r\n  \r\n      `f` is invoked with the current value for `k` if it exists,\r\n      or no arguments if no such value exists. `modify` will always either\r\n      update or insert a value into the map.\r\n  \r\n      Returns a map with the modified value. Does not alter `map`.\r\n  */\n\n\n  var modifyHash = hamt.modifyHash = function (f, hash, key, map) {\n    var size = {\n      value: map._size\n    };\n\n    var newRoot = map._root._modify(map._editable ? map._edit : NaN, map._config.keyEq, 0, f, hash, key, size);\n\n    return map.setTree(newRoot, size.value);\n  };\n\n  Map.prototype.modifyHash = function (hash, key, f) {\n    return modifyHash(f, hash, key, this);\n  };\n  /**\r\n      Alter the value stored for `key` in `map` using function `f` using\r\n      internal hash function.\r\n  \r\n      @see `modifyHash`\r\n  */\n\n\n  var modify = hamt.modify = function (f, key, map) {\n    return modifyHash(f, map._config.hash(key), key, map);\n  };\n\n  Map.prototype.modify = function (key, f) {\n    return modify(f, key, this);\n  };\n  /**\r\n      Store `value` for `key` in `map` using custom `hash`.\r\n  \r\n      Returns a map with the modified value. Does not alter `map`.\r\n  */\n\n\n  var setHash = hamt.setHash = function (hash, key, value, map) {\n    return modifyHash(constant(value), hash, key, map);\n  };\n\n  Map.prototype.setHash = function (hash, key, value) {\n    return setHash(hash, key, value, this);\n  };\n  /**\r\n      Store `value` for `key` in `map` using internal hash function.\r\n  \r\n      @see `setHash`\r\n  */\n\n\n  var set = hamt.set = function (key, value, map) {\n    return setHash(map._config.hash(key), key, value, map);\n  };\n\n  Map.prototype.set = function (key, value) {\n    return set(key, value, this);\n  };\n  /**\r\n      Remove the entry for `key` in `map`.\r\n  \r\n      Returns a map with the value removed. Does not alter `map`.\r\n  */\n\n\n  var del = constant(nothing);\n\n  var removeHash = hamt.removeHash = function (hash, key, map) {\n    return modifyHash(del, hash, key, map);\n  };\n\n  Map.prototype.removeHash = Map.prototype.deleteHash = function (hash, key) {\n    return removeHash(hash, key, this);\n  };\n  /**\r\n      Remove the entry for `key` in `map` using internal hash function.\r\n  \r\n      @see `removeHash`\r\n  */\n\n\n  var remove = hamt.remove = function (key, map) {\n    return removeHash(map._config.hash(key), key, map);\n  };\n\n  Map.prototype.remove = Map.prototype.delete = function (key) {\n    return remove(key, this);\n  };\n  /* Mutation\r\n   ******************************************************************************/\n\n  /**\r\n      Mark `map` as mutable.\r\n   */\n\n\n  var beginMutation = hamt.beginMutation = function (map) {\n    return new Map(map._editable + 1, map._edit + 1, map._config, map._root, map._size);\n  };\n\n  Map.prototype.beginMutation = function () {\n    return beginMutation(this);\n  };\n  /**\r\n      Mark `map` as immutable.\r\n   */\n\n\n  var endMutation = hamt.endMutation = function (map) {\n    map._editable = map._editable && map._editable - 1;\n    return map;\n  };\n\n  Map.prototype.endMutation = function () {\n    return endMutation(this);\n  };\n  /**\r\n      Mutate `map` within the context of `f`.\r\n      @param f\r\n      @param map HAMT\r\n  */\n\n\n  var mutate = hamt.mutate = function (f, map) {\n    var transient = beginMutation(map);\n    f(transient);\n    return endMutation(transient);\n  };\n\n  Map.prototype.mutate = function (f) {\n    return mutate(f, this);\n  };\n  /* Traversal\r\n   ******************************************************************************/\n\n  /**\r\n      Apply a continuation.\r\n  */\n\n\n  var appk = function appk(k) {\n    return k && lazyVisitChildren(k[0], k[1], k[2], k[3], k[4]);\n  };\n  /**\r\n      Recursively visit all values stored in an array of nodes lazily.\r\n  */\n\n\n  var lazyVisitChildren = function lazyVisitChildren(len, children, i, f, k) {\n    while (i < len) {\n      var child = children[i++];\n      if (child && !isEmptyNode(child)) return lazyVisit(child, f, [len, children, i, f, k]);\n    }\n\n    return appk(k);\n  };\n  /**\r\n      Recursively visit all values stored in `node` lazily.\r\n  */\n\n\n  var lazyVisit = function lazyVisit(node, f, k) {\n    switch (node.type) {\n      case LEAF:\n        return {\n          value: f(node),\n          rest: k\n        };\n\n      case COLLISION:\n      case ARRAY:\n      case INDEX:\n        var children = node.children;\n        return lazyVisitChildren(children.length, children, 0, f, k);\n\n      default:\n        return appk(k);\n    }\n  };\n\n  var DONE = {\n    done: true\n  };\n  /**\r\n      Javascript iterator over a map.\r\n  */\n\n  function MapIterator(v) {\n    this.v = v;\n  }\n\n  MapIterator.prototype.next = function () {\n    if (!this.v) return DONE;\n    var v0 = this.v;\n    this.v = appk(v0.rest);\n    return v0;\n  };\n\n  MapIterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n  /**\r\n      Lazily visit each value in map with function `f`.\r\n  */\n\n\n  var visit = function visit(map, f) {\n    return new MapIterator(lazyVisit(map._root, f));\n  };\n  /**\r\n      Get a Javascsript iterator of `map`.\r\n  \r\n      Iterates over `[key, value]` arrays.\r\n  */\n\n\n  var buildPairs = function buildPairs(x) {\n    return [x.key, x.value];\n  };\n\n  var entries = hamt.entries = function (map) {\n    return visit(map, buildPairs);\n  };\n\n  Map.prototype.entries = Map.prototype[Symbol.iterator] = function () {\n    return entries(this);\n  };\n  /**\r\n      Get array of all keys in `map`.\r\n  \r\n      Order is not guaranteed.\r\n  */\n\n\n  var buildKeys = function buildKeys(x) {\n    return x.key;\n  };\n\n  var keys = hamt.keys = function (map) {\n    return visit(map, buildKeys);\n  };\n\n  Map.prototype.keys = function () {\n    return keys(this);\n  };\n  /**\r\n      Get array of all values in `map`.\r\n  \r\n      Order is not guaranteed, duplicates are preserved.\r\n  */\n\n\n  var buildValues = function buildValues(x) {\n    return x.value;\n  };\n\n  var values = hamt.values = Map.prototype.values = function (map) {\n    return visit(map, buildValues);\n  };\n\n  Map.prototype.values = function () {\n    return values(this);\n  };\n  /* Fold\r\n   ******************************************************************************/\n\n  /**\r\n      Visit every entry in the map, aggregating data.\r\n  \r\n      Order of nodes is not guaranteed.\r\n  \r\n      @param f Function mapping accumulated value, value, and key to new value.\r\n      @param z Starting value.\r\n      @param m HAMT\r\n  */\n\n\n  var fold = hamt.fold = function (f, z, m) {\n    var root = m._root;\n    if (root.type === LEAF) return f(z, root.value, root.key);\n    var toVisit = [root.children];\n    var children = void 0;\n\n    while (children = toVisit.pop()) {\n      for (var i = 0, len = children.length; i < len;) {\n        var child = children[i++];\n\n        if (child && child.type) {\n          if (child.type === LEAF) z = f(z, child.value, child.key);else toVisit.push(child.children);\n        }\n      }\n    }\n\n    return z;\n  };\n\n  Map.prototype.fold = function (f, z) {\n    return fold(f, z, this);\n  };\n  /**\r\n      Visit every entry in the map, aggregating data.\r\n  \r\n      Order of nodes is not guaranteed.\r\n  \r\n      @param f Function invoked with value and key\r\n      @param map HAMT\r\n  */\n\n\n  var forEach = hamt.forEach = function (f, map) {\n    return fold(function (_, value, key) {\n      return f(value, key, map);\n    }, null, map);\n  };\n\n  Map.prototype.forEach = function (f) {\n    return forEach(f, this);\n  };\n  /* Aggregate\r\n   ******************************************************************************/\n\n  /**\r\n      Get the number of entries in `map`.\r\n  */\n\n\n  var count = hamt.count = function (map) {\n    return map._size;\n  };\n\n  Map.prototype.count = function () {\n    return count(this);\n  };\n\n  Object.defineProperty(Map.prototype, 'size', {\n    get: Map.prototype.count\n  });\n  /* Export\r\n   ******************************************************************************/\n\n  if (module.exports) {\n    module.exports = hamt;\n  } else {\n    undefined.hamt = hamt;\n  }\n});\n\nclass BuiltInMap {\n  constructor(existing) {\n    _defineProperty(this, \"_map\", void 0);\n\n    this._map = new Map(existing === null || existing === void 0 ? void 0 : existing.entries());\n  }\n\n  keys() {\n    return this._map.keys();\n  }\n\n  entries() {\n    return this._map.entries();\n  }\n\n  get(k) {\n    return this._map.get(k);\n  }\n\n  has(k) {\n    return this._map.has(k);\n  }\n\n  set(k, v) {\n    this._map.set(k, v);\n\n    return this;\n  }\n\n  delete(k) {\n    this._map.delete(k);\n\n    return this;\n  }\n\n  clone() {\n    return persistentMap(this);\n  }\n\n  toMap() {\n    return new Map(this._map);\n  }\n\n}\n\nclass HashArrayMappedTrieMap {\n  // Because hamt.empty is not a function there is no way to introduce type\n  // parameters on it, so empty is typed as HAMTPlusMap<string, mixed>.\n  // $FlowIssue\n  constructor(existing) {\n    _defineProperty(this, \"_hamt\", hamt_1.empty.beginMutation());\n\n    if (existing instanceof HashArrayMappedTrieMap) {\n      const h = existing._hamt.endMutation();\n\n      existing._hamt = h.beginMutation();\n      this._hamt = h.beginMutation();\n    } else if (existing) {\n      for (const [k, v] of existing.entries()) {\n        this._hamt.set(k, v);\n      }\n    }\n  }\n\n  keys() {\n    return this._hamt.keys();\n  }\n\n  entries() {\n    return this._hamt.entries();\n  }\n\n  get(k) {\n    return this._hamt.get(k);\n  }\n\n  has(k) {\n    return this._hamt.has(k);\n  }\n\n  set(k, v) {\n    this._hamt.set(k, v);\n\n    return this;\n  }\n\n  delete(k) {\n    this._hamt.delete(k);\n\n    return this;\n  }\n\n  clone() {\n    return persistentMap(this);\n  }\n\n  toMap() {\n    return new Map(this._hamt);\n  }\n\n}\n\nfunction persistentMap(existing) {\n  if (Recoil_gkx('recoil_hamt_2020')) {\n    return new HashArrayMappedTrieMap(existing);\n  } else {\n    return new BuiltInMap(existing);\n  }\n}\n\nvar Recoil_PersistentMap = {\n  persistentMap\n};\nvar Recoil_PersistentMap_1 = Recoil_PersistentMap.persistentMap;\nvar Recoil_PersistentMap$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  persistentMap: Recoil_PersistentMap_1\n});\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Returns a set containing all of the values from the first set that are not\r\n * present in any of the subsequent sets.\r\n *\r\n * Note: this is written procedurally (i.e., without filterSet) for performant\r\n * use in tight loops.\r\n */\n\nfunction differenceSets(set, ...setsWithValuesToRemove) {\n  const ret = new Set();\n\n  FIRST: for (const value of set) {\n    for (const otherSet of setsWithValuesToRemove) {\n      if (otherSet.has(value)) {\n        continue FIRST;\n      }\n    }\n\n    ret.add(value);\n  }\n\n  return ret;\n}\n\nvar Recoil_differenceSets = differenceSets;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Returns a new Map object with the same keys as the original, but with the\r\n * values replaced with the output of the given callback function.\r\n */\n\nfunction mapMap(map, callback) {\n  const result = new Map();\n  map.forEach((value, key) => {\n    result.set(key, callback(value, key));\n  });\n  return result;\n}\n\nvar Recoil_mapMap = mapMap;\n\nfunction makeGraph() {\n  return {\n    nodeDeps: new Map(),\n    nodeToNodeSubscriptions: new Map()\n  };\n}\n\nfunction cloneGraph(graph) {\n  return {\n    nodeDeps: Recoil_mapMap(graph.nodeDeps, s => new Set(s)),\n    nodeToNodeSubscriptions: Recoil_mapMap(graph.nodeToNodeSubscriptions, s => new Set(s))\n  };\n} // Note that this overwrites the deps of existing nodes, rather than unioning\n// the new deps with the old deps.\n\n\nfunction mergeDepsIntoGraph(key, newDeps, graph, // If olderGraph is given then we will not overwrite changes made to the given\n// graph compared with olderGraph:\nolderGraph) {\n  const {\n    nodeDeps,\n    nodeToNodeSubscriptions\n  } = graph;\n  const oldDeps = nodeDeps.get(key);\n\n  if (oldDeps && olderGraph && oldDeps !== olderGraph.nodeDeps.get(key)) {\n    return;\n  } // Update nodeDeps:\n\n\n  nodeDeps.set(key, newDeps); // Add new deps to nodeToNodeSubscriptions:\n\n  const addedDeps = oldDeps == null ? newDeps : Recoil_differenceSets(newDeps, oldDeps);\n\n  for (const dep of addedDeps) {\n    if (!nodeToNodeSubscriptions.has(dep)) {\n      nodeToNodeSubscriptions.set(dep, new Set());\n    }\n\n    const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));\n    existing.add(key);\n  } // Remove removed deps from nodeToNodeSubscriptions:\n\n\n  if (oldDeps) {\n    const removedDeps = Recoil_differenceSets(oldDeps, newDeps);\n\n    for (const dep of removedDeps) {\n      if (!nodeToNodeSubscriptions.has(dep)) {\n        return;\n      }\n\n      const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));\n      existing.delete(key);\n\n      if (existing.size === 0) {\n        nodeToNodeSubscriptions.delete(dep);\n      }\n    }\n  }\n}\n\nfunction saveDepsToStore(key, deps, store, version) {\n  var _storeState$nextTree, _storeState$previousT, _storeState$previousT2, _storeState$previousT3;\n\n  const storeState = store.getState();\n\n  if (!(version === storeState.currentTree.version || version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {\n    Recoil_recoverableViolation('Tried to save dependencies to a discarded tree');\n  } // Merge the dependencies discovered into the store's dependency map\n  // for the version that was read:\n\n\n  const graph = store.getGraph(version);\n  mergeDepsIntoGraph(key, deps, graph); // If this version is not the latest version, also write these dependencies\n  // into later versions if they don't already have their own:\n\n  if (version === ((_storeState$previousT2 = storeState.previousTree) === null || _storeState$previousT2 === void 0 ? void 0 : _storeState$previousT2.version)) {\n    const currentGraph = store.getGraph(storeState.currentTree.version);\n    mergeDepsIntoGraph(key, deps, currentGraph, graph);\n  }\n\n  if (version === ((_storeState$previousT3 = storeState.previousTree) === null || _storeState$previousT3 === void 0 ? void 0 : _storeState$previousT3.version) || version === storeState.currentTree.version) {\n    var _storeState$nextTree2;\n\n    const nextVersion = (_storeState$nextTree2 = storeState.nextTree) === null || _storeState$nextTree2 === void 0 ? void 0 : _storeState$nextTree2.version;\n\n    if (nextVersion !== undefined) {\n      const nextGraph = store.getGraph(nextVersion);\n      mergeDepsIntoGraph(key, deps, nextGraph, graph);\n    }\n  }\n}\n\nvar Recoil_Graph = {\n  cloneGraph,\n  graph: makeGraph,\n  saveDepsToStore\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nlet nextTreeStateVersion = 0;\n\nconst getNextTreeStateVersion = () => nextTreeStateVersion++;\n\nlet nextStoreID = 0;\n\nconst getNextStoreID = () => nextStoreID++;\n\nlet nextComponentID = 0;\n\nconst getNextComponentID = () => nextComponentID++;\n\nvar Recoil_Keys = {\n  getNextTreeStateVersion,\n  getNextStoreID,\n  getNextComponentID\n};\nconst {\n  persistentMap: persistentMap$1\n} = Recoil_PersistentMap$1;\nconst {\n  graph\n} = Recoil_Graph;\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$1\n} = Recoil_Keys;\n\nfunction makeEmptyTreeState() {\n  const version = getNextTreeStateVersion$1();\n  return {\n    version,\n    stateID: version,\n    transactionMetadata: {},\n    dirtyAtoms: new Set(),\n    atomValues: persistentMap$1(),\n    nonvalidatedAtoms: persistentMap$1()\n  };\n}\n\nfunction makeEmptyStoreState() {\n  const currentTree = makeEmptyTreeState();\n  return {\n    currentTree,\n    nextTree: null,\n    previousTree: null,\n    commitDepth: 0,\n    knownAtoms: new Set(),\n    knownSelectors: new Set(),\n    transactionSubscriptions: new Map(),\n    nodeTransactionSubscriptions: new Map(),\n    nodeToComponentSubscriptions: new Map(),\n    queuedComponentCallbacks_DEPRECATED: [],\n    suspendedComponentResolvers: new Set(),\n    graphsByVersion: new Map().set(currentTree.version, graph()),\n    retention: {\n      referenceCounts: new Map(),\n      nodesRetainedByZone: new Map(),\n      retainablesToCheckForRelease: new Set()\n    },\n    nodeCleanupFunctions: new Map()\n  };\n}\n\nvar Recoil_State = {\n  makeEmptyTreeState,\n  makeEmptyStoreState,\n  getNextTreeStateVersion: getNextTreeStateVersion$1\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nclass RetentionZone {}\n\nfunction retentionZone() {\n  return new RetentionZone();\n}\n\nvar Recoil_RetentionZone = {\n  RetentionZone,\n  retentionZone\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * Utilities for working with built-in Maps and Sets without mutating them.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction setByAddingToSet(set, v) {\n  const next = new Set(set);\n  next.add(v);\n  return next;\n}\n\nfunction setByDeletingFromSet(set, v) {\n  const next = new Set(set);\n  next.delete(v);\n  return next;\n}\n\nfunction mapBySettingInMap(map, k, v) {\n  const next = new Map(map);\n  next.set(k, v);\n  return next;\n}\n\nfunction mapByUpdatingInMap(map, k, updater) {\n  const next = new Map(map);\n  next.set(k, updater(next.get(k)));\n  return next;\n}\n\nfunction mapByDeletingFromMap(map, k) {\n  const next = new Map(map);\n  next.delete(k);\n  return next;\n}\n\nfunction mapByDeletingMultipleFromMap(map, ks) {\n  const next = new Map(map);\n  ks.forEach(k => next.delete(k));\n  return next;\n}\n\nvar Recoil_CopyOnWrite = {\n  setByAddingToSet,\n  setByDeletingFromSet,\n  mapBySettingInMap,\n  mapByUpdatingInMap,\n  mapByDeletingFromMap,\n  mapByDeletingMultipleFromMap\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Creates a new iterable whose output is generated by passing the input\r\n * iterable's values through the filter function.\r\n */\n\nfunction* filterIterable(iterable, predicate) {\n  // Use generator to create iterable/iterator\n  let index = 0;\n\n  for (const value of iterable) {\n    if (predicate(value, index++)) {\n      yield value;\n    }\n  }\n}\n\nvar Recoil_filterIterable = filterIterable;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Return a proxy object based on the provided base and factories objects.\r\n * The proxy will include all properties of the base object as-is.\r\n * The factories object contains callbacks to obtain the values of the properies\r\n * for its keys.\r\n *\r\n * This is useful for providing users an object where some properties may be\r\n * lazily computed only on first access.\r\n */\n// $FlowIssue[unclear-type]\n\nfunction lazyProxy(base, factories) {\n  const proxy = new Proxy(base, {\n    // Compute and cache lazy property if not already done.\n    get: (target, prop) => {\n      if (!(prop in target) && prop in factories) {\n        target[prop] = factories[prop]();\n      }\n\n      return target[prop];\n    },\n    // This method allows user to iterate keys as normal\n    ownKeys: target => {\n      return Object.keys(target);\n    }\n  }); // $FlowIssue[incompatible-return]\n\n  return proxy;\n}\n\nvar Recoil_lazyProxy = lazyProxy;\nconst {\n  getNode: getNode$1,\n  getNodeMaybe: getNodeMaybe$1,\n  recoilValuesForKeys: recoilValuesForKeys$1\n} = Recoil_Node;\nconst {\n  RetentionZone: RetentionZone$1\n} = Recoil_RetentionZone;\nconst {\n  setByAddingToSet: setByAddingToSet$1\n} = Recoil_CopyOnWrite; // flowlint-next-line unclear-type:off\n\nconst emptySet = Object.freeze(new Set());\n\nclass ReadOnlyRecoilValueError extends Error {}\n\nfunction initializeRetentionForNode(store, nodeKey, retainedBy) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return () => undefined;\n  }\n\n  const {\n    nodesRetainedByZone\n  } = store.getState().retention;\n\n  function addToZone(zone) {\n    let set = nodesRetainedByZone.get(zone);\n\n    if (!set) {\n      nodesRetainedByZone.set(zone, set = new Set());\n    }\n\n    set.add(nodeKey);\n  }\n\n  if (retainedBy instanceof RetentionZone$1) {\n    addToZone(retainedBy);\n  } else if (Array.isArray(retainedBy)) {\n    for (const zone of retainedBy) {\n      addToZone(zone);\n    }\n  }\n\n  return () => {\n    if (!Recoil_gkx('recoil_memory_managament_2020')) {\n      return;\n    }\n\n    const {\n      retention\n    } = store.getState();\n\n    function deleteFromZone(zone) {\n      const set = retention.nodesRetainedByZone.get(zone);\n      set === null || set === void 0 ? void 0 : set.delete(nodeKey);\n\n      if (set && set.size === 0) {\n        retention.nodesRetainedByZone.delete(zone);\n      }\n    }\n\n    if (retainedBy instanceof RetentionZone$1) {\n      deleteFromZone(retainedBy);\n    } else if (Array.isArray(retainedBy)) {\n      for (const zone of retainedBy) {\n        deleteFromZone(zone);\n      }\n    }\n  };\n}\n\nfunction initializeNodeIfNewToStore(store, treeState, key, trigger) {\n  const storeState = store.getState();\n\n  if (storeState.nodeCleanupFunctions.has(key)) {\n    return;\n  }\n\n  const node = getNode$1(key);\n  const retentionCleanup = initializeRetentionForNode(store, key, node.retainedBy);\n  const nodeCleanup = node.init(store, treeState, trigger);\n  storeState.nodeCleanupFunctions.set(key, () => {\n    nodeCleanup();\n    retentionCleanup();\n  });\n}\n\nfunction initializeNode(store, key, trigger) {\n  initializeNodeIfNewToStore(store, store.getState().currentTree, key, trigger);\n}\n\nfunction cleanUpNode(store, key) {\n  var _state$nodeCleanupFun;\n\n  const state = store.getState();\n  (_state$nodeCleanupFun = state.nodeCleanupFunctions.get(key)) === null || _state$nodeCleanupFun === void 0 ? void 0 : _state$nodeCleanupFun();\n  state.nodeCleanupFunctions.delete(key);\n} // Get the current value loadable of a node and update the state.\n// Update dependencies and subscriptions for selectors.\n// Update saved value validation for atoms.\n\n\nfunction getNodeLoadable(store, state, key) {\n  initializeNodeIfNewToStore(store, state, key, 'get');\n  return getNode$1(key).get(store, state);\n} // Peek at the current value loadable for a node without any evaluation or state change\n\n\nfunction peekNodeLoadable(store, state, key) {\n  return getNode$1(key).peek(store, state);\n} // Write value directly to state bypassing the Node interface as the node\n// definitions may not have been loaded yet when processing the initial snapshot.\n\n\nfunction setUnvalidatedAtomValue_DEPRECATED(state, key, newValue) {\n  var _node$invalidate;\n\n  const node = getNodeMaybe$1(key);\n  node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);\n  return { ...state,\n    atomValues: state.atomValues.clone().delete(key),\n    nonvalidatedAtoms: state.nonvalidatedAtoms.clone().set(key, newValue),\n    dirtyAtoms: setByAddingToSet$1(state.dirtyAtoms, key)\n  };\n} // Return the discovered dependencies and values to be written by setting\n// a node value. (Multiple values may be written due to selectors getting to\n// set upstreams; deps may be discovered because of reads in updater functions.)\n\n\nfunction setNodeValue(store, state, key, newValue) {\n  const node = getNode$1(key);\n\n  if (node.set == null) {\n    throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${key}`);\n  }\n\n  const set = node.set; // so flow doesn't lose the above refinement.\n\n  initializeNodeIfNewToStore(store, state, key, 'set');\n  return set(store, state, newValue);\n}\n\nfunction peekNodeInfo(store, state, key) {\n  const storeState = store.getState();\n  const graph = store.getGraph(state.version);\n  const type = getNode$1(key).nodeType;\n  return Recoil_lazyProxy({\n    type\n  }, {\n    loadable: () => peekNodeLoadable(store, state, key),\n    isActive: () => storeState.knownAtoms.has(key) || storeState.knownSelectors.has(key),\n    isSet: () => type === 'selector' ? false : state.atomValues.has(key),\n    isModified: () => state.dirtyAtoms.has(key),\n    // Report current dependencies.  If the node hasn't been evaluated, then\n    // dependencies may be missing based on the current state.\n    deps: () => {\n      var _graph$nodeDeps$get;\n\n      return recoilValuesForKeys$1((_graph$nodeDeps$get = graph.nodeDeps.get(key)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : []);\n    },\n    // Reports all \"current\" subscribers.  Evaluating other nodes or\n    // previous in-progress async evaluations may introduce new subscribers.\n    subscribers: () => {\n      var _storeState$nodeToCom, _storeState$nodeToCom2;\n\n      return {\n        nodes: recoilValuesForKeys$1(Recoil_filterIterable(getDownstreamNodes(store, state, new Set([key])), nodeKey => nodeKey !== key)),\n        components: Recoil_mapIterable((_storeState$nodeToCom = (_storeState$nodeToCom2 = storeState.nodeToComponentSubscriptions.get(key)) === null || _storeState$nodeToCom2 === void 0 ? void 0 : _storeState$nodeToCom2.values()) !== null && _storeState$nodeToCom !== void 0 ? _storeState$nodeToCom : [], ([name]) => ({\n          name\n        }))\n      };\n    }\n  });\n} // Find all of the recursively dependent nodes\n\n\nfunction getDownstreamNodes(store, state, keys) {\n  const visitedNodes = new Set();\n  const visitingNodes = Array.from(keys);\n  const graph = store.getGraph(state.version);\n\n  for (let key = visitingNodes.pop(); key; key = visitingNodes.pop()) {\n    var _graph$nodeToNodeSubs;\n\n    visitedNodes.add(key);\n    const subscribedNodes = (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(key)) !== null && _graph$nodeToNodeSubs !== void 0 ? _graph$nodeToNodeSubs : emptySet;\n\n    for (const downstreamNode of subscribedNodes) {\n      if (!visitedNodes.has(downstreamNode)) {\n        visitingNodes.push(downstreamNode);\n      }\n    }\n  }\n\n  return visitedNodes;\n}\n\nvar Recoil_FunctionalCore = {\n  getNodeLoadable,\n  peekNodeLoadable,\n  setNodeValue,\n  initializeNode,\n  cleanUpNode,\n  setUnvalidatedAtomValue_DEPRECATED,\n  peekNodeInfo,\n  getDownstreamNodes\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nlet _invalidateMemoizedSnapshot = null;\n\nfunction setInvalidateMemoizedSnapshot(invalidate) {\n  _invalidateMemoizedSnapshot = invalidate;\n}\n\nfunction invalidateMemoizedSnapshot() {\n  var _invalidateMemoizedSn;\n\n  (_invalidateMemoizedSn = _invalidateMemoizedSnapshot) === null || _invalidateMemoizedSn === void 0 ? void 0 : _invalidateMemoizedSn();\n}\n\nvar Recoil_SnapshotCache = {\n  setInvalidateMemoizedSnapshot,\n  invalidateMemoizedSnapshot\n};\nconst {\n  getDownstreamNodes: getDownstreamNodes$1,\n  getNodeLoadable: getNodeLoadable$1,\n  setNodeValue: setNodeValue$1\n} = Recoil_FunctionalCore;\nconst {\n  getNextComponentID: getNextComponentID$1\n} = Recoil_Keys;\nconst {\n  getNode: getNode$2,\n  getNodeMaybe: getNodeMaybe$2\n} = Recoil_Node;\nconst {\n  DefaultValue: DefaultValue$1\n} = Recoil_Node;\nconst {\n  reactMode: reactMode$1\n} = Recoil_ReactMode;\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$1,\n  RecoilState: RecoilState$1,\n  RecoilValueReadOnly: RecoilValueReadOnly$1,\n  isRecoilValue: isRecoilValue$1\n} = Recoil_RecoilValue$1;\nconst {\n  invalidateMemoizedSnapshot: invalidateMemoizedSnapshot$1\n} = Recoil_SnapshotCache;\n\nfunction getRecoilValueAsLoadable(store, {\n  key\n}, treeState = store.getState().currentTree) {\n  var _storeState$nextTree, _storeState$previousT; // Reading from an older tree can cause bugs because the dependencies that we\n  // discover during the read are lost.\n\n\n  const storeState = store.getState();\n\n  if (!(treeState.version === storeState.currentTree.version || treeState.version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || treeState.version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {\n    Recoil_recoverableViolation('Tried to read from a discarded tree');\n  }\n\n  const loadable = getNodeLoadable$1(store, treeState, key);\n\n  if (loadable.state === 'loading') {\n    loadable.contents.catch(() => {\n      /**\r\n       * HACK: intercept thrown error here to prevent an uncaught promise exception. Ideally this would happen closer to selector\r\n       * execution (perhaps introducing a new ERROR class to be resolved by async selectors that are in an error state)\r\n       */\n      return;\n    });\n  }\n\n  return loadable;\n}\n\nfunction applyAtomValueWrites(atomValues, writes) {\n  const result = atomValues.clone();\n  writes.forEach((v, k) => {\n    if (v.state === 'hasValue' && v.contents instanceof DefaultValue$1) {\n      result.delete(k);\n    } else {\n      result.set(k, v);\n    }\n  });\n  return result;\n}\n\nfunction valueFromValueOrUpdater(store, state, {\n  key\n}, valueOrUpdater) {\n  if (typeof valueOrUpdater === 'function') {\n    // Updater form: pass in the current value. Throw if the current value\n    // is unavailable (namely when updating an async selector that's\n    // pending or errored):\n    const current = getNodeLoadable$1(store, state, key);\n\n    if (current.state === 'loading') {\n      const msg = `Tried to set atom or selector \"${key}\" using an updater function while the current state is pending, this is not currently supported.`;\n      Recoil_recoverableViolation(msg);\n      throw Recoil_err(msg);\n    } else if (current.state === 'hasError') {\n      throw current.contents;\n    } // T itself may be a function, so our refinement is not sufficient:\n\n\n    return valueOrUpdater(current.contents); // flowlint-line unclear-type:off\n  } else {\n    return valueOrUpdater;\n  }\n}\n\nfunction applyAction(store, state, action) {\n  if (action.type === 'set') {\n    const {\n      recoilValue,\n      valueOrUpdater\n    } = action;\n    const newValue = valueFromValueOrUpdater(store, state, recoilValue, valueOrUpdater);\n    const writes = setNodeValue$1(store, state, recoilValue.key, newValue);\n\n    for (const [key, loadable] of writes.entries()) {\n      writeLoadableToTreeState(state, key, loadable);\n    }\n  } else if (action.type === 'setLoadable') {\n    const {\n      recoilValue: {\n        key\n      },\n      loadable\n    } = action;\n    writeLoadableToTreeState(state, key, loadable);\n  } else if (action.type === 'markModified') {\n    const {\n      recoilValue: {\n        key\n      }\n    } = action;\n    state.dirtyAtoms.add(key);\n  } else if (action.type === 'setUnvalidated') {\n    var _node$invalidate; // Write value directly to state bypassing the Node interface as the node\n    // definitions may not have been loaded yet when processing the initial snapshot.\n\n\n    const {\n      recoilValue: {\n        key\n      },\n      unvalidatedValue\n    } = action;\n    const node = getNodeMaybe$2(key);\n    node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);\n    state.atomValues.delete(key);\n    state.nonvalidatedAtoms.set(key, unvalidatedValue);\n    state.dirtyAtoms.add(key);\n  } else {\n    Recoil_recoverableViolation(`Unknown action ${action.type}`);\n  }\n}\n\nfunction writeLoadableToTreeState(state, key, loadable) {\n  if (loadable.state === 'hasValue' && loadable.contents instanceof DefaultValue$1) {\n    state.atomValues.delete(key);\n  } else {\n    state.atomValues.set(key, loadable);\n  }\n\n  state.dirtyAtoms.add(key);\n  state.nonvalidatedAtoms.delete(key);\n}\n\nfunction applyActionsToStore(store, actions) {\n  store.replaceState(state => {\n    const newState = copyTreeState(state);\n\n    for (const action of actions) {\n      applyAction(store, newState, action);\n    }\n\n    invalidateDownstreams(store, newState);\n    invalidateMemoizedSnapshot$1();\n    return newState;\n  });\n}\n\nfunction queueOrPerformStateUpdate(store, action) {\n  if (batchStack.length) {\n    const actionsByStore = batchStack[batchStack.length - 1];\n    let actions = actionsByStore.get(store);\n\n    if (!actions) {\n      actionsByStore.set(store, actions = []);\n    }\n\n    actions.push(action);\n  } else {\n    applyActionsToStore(store, [action]);\n  }\n}\n\nconst batchStack = [];\n\nfunction batchStart() {\n  const actionsByStore = new Map();\n  batchStack.push(actionsByStore);\n  return () => {\n    for (const [store, actions] of actionsByStore) {\n      applyActionsToStore(store, actions);\n    }\n\n    const popped = batchStack.pop();\n\n    if (popped !== actionsByStore) {\n      Recoil_recoverableViolation('Incorrect order of batch popping');\n    }\n  };\n}\n\nfunction copyTreeState(state) {\n  return { ...state,\n    atomValues: state.atomValues.clone(),\n    nonvalidatedAtoms: state.nonvalidatedAtoms.clone(),\n    dirtyAtoms: new Set(state.dirtyAtoms)\n  };\n}\n\nfunction invalidateDownstreams(store, state) {\n  // Inform any nodes that were changed or downstream of changes so that they\n  // can clear out any caches as needed due to the update:\n  const downstreams = getDownstreamNodes$1(store, state, state.dirtyAtoms);\n\n  for (const key of downstreams) {\n    var _getNodeMaybe, _getNodeMaybe$invalid;\n\n    (_getNodeMaybe = getNodeMaybe$2(key)) === null || _getNodeMaybe === void 0 ? void 0 : (_getNodeMaybe$invalid = _getNodeMaybe.invalidate) === null || _getNodeMaybe$invalid === void 0 ? void 0 : _getNodeMaybe$invalid.call(_getNodeMaybe, state);\n  }\n}\n\nfunction setRecoilValue(store, recoilValue, valueOrUpdater) {\n  queueOrPerformStateUpdate(store, {\n    type: 'set',\n    recoilValue,\n    valueOrUpdater\n  });\n}\n\nfunction setRecoilValueLoadable(store, recoilValue, loadable) {\n  if (loadable instanceof DefaultValue$1) {\n    return setRecoilValue(store, recoilValue, loadable);\n  }\n\n  queueOrPerformStateUpdate(store, {\n    type: 'setLoadable',\n    recoilValue,\n    loadable: loadable\n  });\n}\n\nfunction markRecoilValueModified(store, recoilValue) {\n  queueOrPerformStateUpdate(store, {\n    type: 'markModified',\n    recoilValue\n  });\n}\n\nfunction setUnvalidatedRecoilValue(store, recoilValue, unvalidatedValue) {\n  queueOrPerformStateUpdate(store, {\n    type: 'setUnvalidated',\n    recoilValue,\n    unvalidatedValue\n  });\n}\n\nfunction subscribeToRecoilValue(store, {\n  key\n}, callback, componentDebugName = null) {\n  const subID = getNextComponentID$1();\n  const storeState = store.getState();\n\n  if (!storeState.nodeToComponentSubscriptions.has(key)) {\n    storeState.nodeToComponentSubscriptions.set(key, new Map());\n  }\n\n  Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID, [componentDebugName !== null && componentDebugName !== void 0 ? componentDebugName : '<not captured>', callback]); // Handle the case that, during the same tick that we are subscribing, an atom\n  // has been updated by some effect handler. Otherwise we will miss the update.\n\n  const mode = reactMode$1();\n\n  if (mode.early && (mode.mode === 'LEGACY' || mode.mode === 'MUTABLE_SOURCE')) {\n    const nextTree = store.getState().nextTree;\n\n    if (nextTree && nextTree.dirtyAtoms.has(key)) {\n      callback(nextTree);\n    }\n  }\n\n  return {\n    release: () => {\n      const releaseStoreState = store.getState();\n      const subs = releaseStoreState.nodeToComponentSubscriptions.get(key);\n\n      if (subs === undefined || !subs.has(subID)) {\n        Recoil_recoverableViolation(`Subscription missing at release time for atom ${key}. This is a bug in Recoil.`);\n        return;\n      }\n\n      subs.delete(subID);\n\n      if (subs.size === 0) {\n        releaseStoreState.nodeToComponentSubscriptions.delete(key);\n      }\n    }\n  };\n}\n\nfunction refreshRecoilValue(store, recoilValue) {\n  var _node$clearCache;\n\n  const {\n    currentTree\n  } = store.getState();\n  const node = getNode$2(recoilValue.key);\n  (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, currentTree);\n}\n\nvar Recoil_RecoilValueInterface = {\n  RecoilValueReadOnly: RecoilValueReadOnly$1,\n  AbstractRecoilValue: AbstractRecoilValue$1,\n  RecoilState: RecoilState$1,\n  getRecoilValueAsLoadable,\n  setRecoilValue,\n  setRecoilValueLoadable,\n  markRecoilValueModified,\n  setUnvalidatedRecoilValue,\n  subscribeToRecoilValue,\n  isRecoilValue: isRecoilValue$1,\n  applyAtomValueWrites,\n  // TODO Remove export when deprecating initialStoreState_DEPRECATED in RecoilRoot\n  batchStart,\n  writeLoadableToTreeState,\n  invalidateDownstreams,\n  copyTreeState,\n  refreshRecoilValue\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * The someSet() method tests whether some elements in the given Set pass the\r\n * test implemented by the provided function.\r\n */\n\nfunction someSet(set, callback, context) {\n  const iterator = set.entries();\n  let current = iterator.next();\n\n  while (!current.done) {\n    const entry = current.value;\n\n    if (callback.call(context, entry[1], entry[0], set)) {\n      return true;\n    }\n\n    current = iterator.next();\n  }\n\n  return false;\n}\n\nvar Recoil_someSet = someSet;\nconst {\n  cleanUpNode: cleanUpNode$1\n} = Recoil_FunctionalCore;\nconst {\n  deleteNodeConfigIfPossible: deleteNodeConfigIfPossible$1,\n  getNode: getNode$3\n} = Recoil_Node;\nconst {\n  RetentionZone: RetentionZone$2\n} = Recoil_RetentionZone; // Components that aren't mounted after suspending for this long will be assumed\n// to be discarded and their resources released.\n\nconst SUSPENSE_TIMEOUT_MS = 120000;\nconst emptySet$1 = new Set();\n\nfunction releaseRetainablesNowOnCurrentTree(store, retainables) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree;\n\n  if (storeState.nextTree) {\n    Recoil_recoverableViolation('releaseNodesNowOnCurrentTree should only be called at the end of a batch');\n    return; // leak memory rather than erase something that's about to be used.\n  }\n\n  const nodes = new Set();\n\n  for (const r of retainables) {\n    if (r instanceof RetentionZone$2) {\n      for (const n of nodesRetainedByZone(storeState, r)) {\n        nodes.add(n);\n      }\n    } else {\n      nodes.add(r);\n    }\n  }\n\n  const releasableNodes = findReleasableNodes(store, nodes);\n\n  for (const node of releasableNodes) {\n    releaseNode(store, treeState, node);\n  }\n}\n\nfunction findReleasableNodes(store, searchFromNodes) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree;\n  const graph = store.getGraph(treeState.version);\n  const releasableNodes = new Set(); // mutated to collect answer\n\n  const nonReleasableNodes = new Set();\n  findReleasableNodesInner(searchFromNodes);\n  return releasableNodes;\n\n  function findReleasableNodesInner(searchFromNodes) {\n    const releasableNodesFoundThisIteration = new Set();\n    const downstreams = getDownstreamNodesInTopologicalOrder(store, treeState, searchFromNodes, releasableNodes, // don't descend into these\n    nonReleasableNodes // don't descend into these\n    ); // Find which of the downstream nodes are releasable and which are not:\n\n    for (const node of downstreams) {\n      var _storeState$retention; // Not releasable if configured to be retained forever:\n\n\n      if (getNode$3(node).retainedBy === 'recoilRoot') {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if retained directly by a component:\n\n\n      if (((_storeState$retention = storeState.retention.referenceCounts.get(node)) !== null && _storeState$retention !== void 0 ? _storeState$retention : 0) > 0) {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if retained by a zone:\n\n\n      if (zonesThatCouldRetainNode(node).some(z => storeState.retention.referenceCounts.get(z))) {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if it has a non-releasable child (which will already be in\n      // nonReleasableNodes because we are going in topological order):\n\n\n      const nodeChildren = graph.nodeToNodeSubscriptions.get(node);\n\n      if (nodeChildren && Recoil_someSet(nodeChildren, child => nonReleasableNodes.has(child))) {\n        nonReleasableNodes.add(node);\n        continue;\n      }\n\n      releasableNodes.add(node);\n      releasableNodesFoundThisIteration.add(node);\n    } // If we found any releasable nodes, we need to walk UP from those nodes to\n    // find whether their parents can now be released as well:\n\n\n    const parents = new Set();\n\n    for (const node of releasableNodesFoundThisIteration) {\n      for (const parent of (_graph$nodeDeps$get = graph.nodeDeps.get(node)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : emptySet$1) {\n        var _graph$nodeDeps$get;\n\n        if (!releasableNodes.has(parent)) {\n          parents.add(parent);\n        }\n      }\n    }\n\n    if (parents.size) {\n      findReleasableNodesInner(parents);\n    }\n  }\n} // Children before parents\n\n\nfunction getDownstreamNodesInTopologicalOrder(store, treeState, nodes, // Mutable set is destroyed in place\ndoNotDescendInto1, doNotDescendInto2) {\n  const graph = store.getGraph(treeState.version);\n  const answer = [];\n  const visited = new Set();\n\n  while (nodes.size > 0) {\n    visit(Recoil_nullthrows(nodes.values().next().value));\n  }\n\n  return answer;\n\n  function visit(node) {\n    if (doNotDescendInto1.has(node) || doNotDescendInto2.has(node)) {\n      nodes.delete(node);\n      return;\n    }\n\n    if (visited.has(node)) {\n      return;\n    }\n\n    const children = graph.nodeToNodeSubscriptions.get(node);\n\n    if (children) {\n      for (const child of children) {\n        visit(child);\n      }\n    }\n\n    visited.add(node);\n    nodes.delete(node);\n    answer.push(node);\n  }\n}\n\nfunction releaseNode(store, treeState, node) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  } // Atom effects, in-closure caches, etc.:\n\n\n  cleanUpNode$1(store, node); // Delete from store state:\n\n  const storeState = store.getState();\n  storeState.knownAtoms.delete(node);\n  storeState.knownSelectors.delete(node);\n  storeState.nodeTransactionSubscriptions.delete(node);\n  storeState.retention.referenceCounts.delete(node);\n  const zones = zonesThatCouldRetainNode(node);\n\n  for (const zone of zones) {\n    var _storeState$retention2;\n\n    (_storeState$retention2 = storeState.retention.nodesRetainedByZone.get(zone)) === null || _storeState$retention2 === void 0 ? void 0 : _storeState$retention2.delete(node);\n  } // Note that we DO NOT delete from nodeToComponentSubscriptions because this\n  // already happens when the last component that was retaining the node unmounts,\n  // and this could happen either before or after that.\n  // Delete from TreeState and dep graph:\n\n\n  treeState.atomValues.delete(node);\n  treeState.dirtyAtoms.delete(node);\n  treeState.nonvalidatedAtoms.delete(node);\n  const graph = storeState.graphsByVersion.get(treeState.version);\n\n  if (graph) {\n    const deps = graph.nodeDeps.get(node);\n\n    if (deps !== undefined) {\n      graph.nodeDeps.delete(node);\n\n      for (const dep of deps) {\n        var _graph$nodeToNodeSubs;\n\n        (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(dep)) === null || _graph$nodeToNodeSubs === void 0 ? void 0 : _graph$nodeToNodeSubs.delete(node);\n      }\n    } // No need to delete sub's deps as there should be no subs at this point.\n    // But an invariant would require deleting nodes in topological order.\n\n\n    graph.nodeToNodeSubscriptions.delete(node);\n  } // Node config (for family members only as their configs can be recreated, and\n  // only if they are not retained within any other Stores):\n\n\n  deleteNodeConfigIfPossible$1(node);\n}\n\nfunction nodesRetainedByZone(storeState, zone) {\n  var _storeState$retention3;\n\n  return (_storeState$retention3 = storeState.retention.nodesRetainedByZone.get(zone)) !== null && _storeState$retention3 !== void 0 ? _storeState$retention3 : emptySet$1;\n}\n\nfunction zonesThatCouldRetainNode(node) {\n  const retainedBy = getNode$3(node).retainedBy;\n\n  if (retainedBy === undefined || retainedBy === 'components' || retainedBy === 'recoilRoot') {\n    return [];\n  } else if (retainedBy instanceof RetentionZone$2) {\n    return [retainedBy];\n  } else {\n    return retainedBy; // it's an array of zones\n  }\n}\n\nfunction scheduleOrPerformPossibleReleaseOfRetainable(store, retainable) {\n  const state = store.getState();\n\n  if (state.nextTree) {\n    state.retention.retainablesToCheckForRelease.add(retainable);\n  } else {\n    releaseRetainablesNowOnCurrentTree(store, new Set([retainable]));\n  }\n}\n\nfunction updateRetainCount(store, retainable, delta) {\n  var _map$get;\n\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const map = store.getState().retention.referenceCounts;\n  const newCount = ((_map$get = map.get(retainable)) !== null && _map$get !== void 0 ? _map$get : 0) + delta;\n\n  if (newCount === 0) {\n    updateRetainCountToZero(store, retainable);\n  } else {\n    map.set(retainable, newCount);\n  }\n}\n\nfunction updateRetainCountToZero(store, retainable) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const map = store.getState().retention.referenceCounts;\n  map.delete(retainable);\n  scheduleOrPerformPossibleReleaseOfRetainable(store, retainable);\n}\n\nfunction releaseScheduledRetainablesNow(store) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const state = store.getState();\n  releaseRetainablesNowOnCurrentTree(store, state.retention.retainablesToCheckForRelease);\n  state.retention.retainablesToCheckForRelease.clear();\n}\n\nfunction retainedByOptionWithDefault(r) {\n  // The default will change from 'recoilRoot' to 'components' in the future.\n  return r === undefined ? 'recoilRoot' : r;\n}\n\nvar Recoil_Retention = {\n  SUSPENSE_TIMEOUT_MS,\n  updateRetainCount,\n  updateRetainCountToZero,\n  releaseScheduledRetainablesNow,\n  retainedByOptionWithDefault\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * This is to export esstiential functions from react-dom\r\n * for our web build\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nconst {\n  unstable_batchedUpdates\n} = (react_dom__WEBPACK_IMPORTED_MODULE_1___default());\nvar ReactBatchedUpdates = {\n  unstable_batchedUpdates\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * This is to export esstiential functions from react-dom\r\n * for our web build\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n// @fb-only: const {unstable_batchedUpdates} = require('ReactDOMComet');\n// prettier-ignore\n\nconst {\n  unstable_batchedUpdates: unstable_batchedUpdates$1\n} = ReactBatchedUpdates; // @oss-only\n\nvar Recoil_ReactBatchedUpdates = {\n  unstable_batchedUpdates: unstable_batchedUpdates$1\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nconst {\n  batchStart: batchStart$1\n} = Recoil_RecoilValueInterface;\nconst {\n  unstable_batchedUpdates: unstable_batchedUpdates$2\n} = Recoil_ReactBatchedUpdates;\nlet batcher = unstable_batchedUpdates$2; // flowlint-next-line unclear-type:off\n\n/**\r\n * Sets the provided batcher function as the batcher function used by Recoil.\r\n *\r\n * Set the batcher to a custom batcher for your renderer,\r\n * if you use a renderer other than React DOM or React Native.\r\n */\n\nconst setBatcher = newBatcher => {\n  batcher = newBatcher;\n};\n/**\r\n * Returns the current batcher function.\r\n */\n\n\nconst getBatcher = () => batcher;\n/**\r\n * Calls the current batcher function and passes the\r\n * provided callback function.\r\n */\n\n\nconst batchUpdates = callback => {\n  batcher(() => {\n    let batchEnd = () => undefined;\n\n    try {\n      batchEnd = batchStart$1();\n      callback();\n    } finally {\n      batchEnd();\n    }\n  });\n};\n\nvar Recoil_Batching = {\n  getBatcher,\n  setBatcher,\n  batchUpdates\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Combines multiple Iterables into a single Iterable.\r\n * Traverses the input Iterables in the order provided and maintains the order\r\n * of their elements.\r\n *\r\n * Example:\r\n * ```\r\n * const r = Array.from(concatIterables(['a', 'b'], ['c'], ['d', 'e', 'f']));\r\n * r == ['a', 'b', 'c', 'd', 'e', 'f'];\r\n * ```\r\n */\n\nfunction* concatIterables(iters) {\n  for (const iter of iters) {\n    for (const val of iter) {\n      yield val;\n    }\n  }\n}\n\nvar Recoil_concatIterables = concatIterables;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/* eslint-disable fb-www/typeof-undefined */\n\nconst isSSR = // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709\ntypeof Window === 'undefined' || typeof window === 'undefined';\n/* eslint-enable fb-www/typeof-undefined */\n\nconst isWindow = value => !isSSR && ( // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709\nvalue === window || value instanceof Window);\n\nconst isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative'; // eslint-disable-line fb-www/typeof-undefined\n\nvar Recoil_Environment = {\n  isSSR,\n  isReactNative,\n  isWindow\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Caches a function's results based on the key returned by the passed\r\n * hashFunction.\r\n */\n\nfunction memoizeWithArgsHash(fn, hashFunction) {\n  let cache;\n\n  const memoizedFn = (...args) => {\n    if (!cache) {\n      cache = {};\n    }\n\n    const key = hashFunction(...args);\n\n    if (!Object.hasOwnProperty.call(cache, key)) {\n      cache[key] = fn(...args);\n    }\n\n    return cache[key];\n  };\n\n  return memoizedFn;\n}\n/**\r\n * Caches a function's results based on a comparison of the arguments.\r\n * Only caches the last return of the function.\r\n * Defaults to reference equality\r\n */\n\n\nfunction memoizeOneWithArgsHash(fn, hashFunction) {\n  let lastKey;\n  let lastResult; // breaking cache when arguments change\n\n  const memoizedFn = (...args) => {\n    const key = hashFunction(...args);\n\n    if (lastKey === key) {\n      return lastResult;\n    }\n\n    lastKey = key;\n    lastResult = fn(...args);\n    return lastResult;\n  };\n\n  return memoizedFn;\n}\n/**\r\n * Caches a function's results based on a comparison of the arguments.\r\n * Only caches the last return of the function.\r\n * Defaults to reference equality\r\n */\n\n\nfunction memoizeOneWithArgsHashAndInvalidation(fn, hashFunction) {\n  let lastKey;\n  let lastResult; // breaking cache when arguments change\n\n  const memoizedFn = (...args) => {\n    const key = hashFunction(...args);\n\n    if (lastKey === key) {\n      return lastResult;\n    }\n\n    lastKey = key;\n    lastResult = fn(...args);\n    return lastResult;\n  };\n\n  const invalidate = () => {\n    lastKey = null;\n  };\n\n  return [memoizedFn, invalidate];\n}\n\nvar Recoil_Memoize = {\n  memoizeWithArgsHash,\n  memoizeOneWithArgsHash,\n  memoizeOneWithArgsHashAndInvalidation\n};\nconst {\n  batchUpdates: batchUpdates$1\n} = Recoil_Batching;\nconst {\n  initializeNode: initializeNode$1,\n  peekNodeInfo: peekNodeInfo$1\n} = Recoil_FunctionalCore;\nconst {\n  graph: graph$1\n} = Recoil_Graph;\nconst {\n  getNextStoreID: getNextStoreID$1\n} = Recoil_Keys;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$1,\n  recoilValues: recoilValues$1,\n  recoilValuesForKeys: recoilValuesForKeys$2\n} = Recoil_Node;\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$2,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$1,\n  setRecoilValue: setRecoilValue$1,\n  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$1\n} = Recoil_RecoilValueInterface;\nconst {\n  updateRetainCount: updateRetainCount$1\n} = Recoil_Retention;\nconst {\n  setInvalidateMemoizedSnapshot: setInvalidateMemoizedSnapshot$1\n} = Recoil_SnapshotCache;\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$2,\n  makeEmptyStoreState: makeEmptyStoreState$1\n} = Recoil_State;\nconst {\n  isSSR: isSSR$1\n} = Recoil_Environment;\nconst {\n  memoizeOneWithArgsHashAndInvalidation: memoizeOneWithArgsHashAndInvalidation$1\n} = Recoil_Memoize; // Opaque at this surface because it's part of the public API from here.\n\nconst retainWarning = `\nRecoil Snapshots only last for the duration of the callback they are provided to. To keep a Snapshot longer, do this:\n\n  const release = snapshot.retain();\n  try {\n    await doSomethingWithSnapshot(snapshot);\n  } finally {\n    release();\n  }\n\nThis is currently a DEV-only warning but will become a thrown exception in the next release of Recoil.\n`; // A \"Snapshot\" is \"read-only\" and captures a specific set of values of atoms.\n// However, the data-flow-graph and selector values may evolve as selector\n// evaluation functions are executed and async selectors resolve.\n\nclass Snapshot {\n  // eslint-disable-next-line fb-www/no-uninitialized-properties\n  constructor(storeState, parentStoreID) {\n    _defineProperty(this, \"_store\", void 0);\n\n    _defineProperty(this, \"_refCount\", 1);\n\n    _defineProperty(this, \"getLoadable\", recoilValue => {\n      this.checkRefCount_INTERNAL();\n      return getRecoilValueAsLoadable$1(this._store, recoilValue);\n    });\n\n    _defineProperty(this, \"getPromise\", recoilValue => {\n      this.checkRefCount_INTERNAL();\n      return this.getLoadable(recoilValue).toPromise();\n    });\n\n    _defineProperty(this, \"getNodes_UNSTABLE\", opt => {\n      this.checkRefCount_INTERNAL(); // TODO Deal with modified selectors\n\n      if ((opt === null || opt === void 0 ? void 0 : opt.isModified) === true) {\n        if ((opt === null || opt === void 0 ? void 0 : opt.isInitialized) === false) {\n          return [];\n        }\n\n        const state = this._store.getState().currentTree;\n\n        return recoilValuesForKeys$2(state.dirtyAtoms);\n      }\n\n      const knownAtoms = this._store.getState().knownAtoms;\n\n      const knownSelectors = this._store.getState().knownSelectors;\n\n      return (opt === null || opt === void 0 ? void 0 : opt.isInitialized) == null ? recoilValues$1.values() : opt.isInitialized === true ? recoilValuesForKeys$2(Recoil_concatIterables([knownAtoms, knownSelectors])) : Recoil_filterIterable(recoilValues$1.values(), ({\n        key\n      }) => !knownAtoms.has(key) && !knownSelectors.has(key));\n    });\n\n    _defineProperty(this, \"getInfo_UNSTABLE\", ({\n      key\n    }) => {\n      this.checkRefCount_INTERNAL();\n      return peekNodeInfo$1(this._store, this._store.getState().currentTree, key);\n    });\n\n    _defineProperty(this, \"map\", mapper => {\n      this.checkRefCount_INTERNAL();\n      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);\n      mapper(mutableSnapshot); // if removing batchUpdates from `set` add it here\n\n      return mutableSnapshot;\n    });\n\n    _defineProperty(this, \"asyncMap\", async mapper => {\n      this.checkRefCount_INTERNAL();\n      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);\n      mutableSnapshot.retain(); // Retain new snapshot during async mapper\n\n      await mapper(mutableSnapshot); // Continue to retain the new snapshot for the user, but auto-release it\n      // after the next tick, the same as a new synchronous snapshot.\n\n      mutableSnapshot.autoRelease_INTERNAL();\n      return mutableSnapshot;\n    });\n\n    this._store = {\n      storeID: getNextStoreID$1(),\n      parentStoreID,\n      getState: () => storeState,\n      replaceState: replacer => {\n        // no batching, so nextTree is never active\n        storeState.currentTree = replacer(storeState.currentTree);\n      },\n      getGraph: version => {\n        const graphs = storeState.graphsByVersion;\n\n        if (graphs.has(version)) {\n          return Recoil_nullthrows(graphs.get(version));\n        }\n\n        const newGraph = graph$1();\n        graphs.set(version, newGraph);\n        return newGraph;\n      },\n      subscribeToTransactions: () => ({\n        release: () => {}\n      }),\n      addTransactionMetadata: () => {\n        throw Recoil_err('Cannot subscribe to Snapshots');\n      }\n    }; // Initialize any nodes that are live in the parent store (primarily so that\n    // this snapshot gets counted towards the node's live stores count).\n    // TODO Optimize this when cloning snapshots for callbacks\n\n    for (const nodeKey of this._store.getState().knownAtoms) {\n      initializeNode$1(this._store, nodeKey, 'get');\n      updateRetainCount$1(this._store, nodeKey, 1);\n    }\n\n    this.autoRelease_INTERNAL();\n  }\n\n  retain() {\n    if (this._refCount <= 0) {\n      if (true) {\n        throw Recoil_err('Snapshot has already been released.');\n      } else {}\n    }\n\n    this._refCount++;\n    let released = false;\n    return () => {\n      if (!released) {\n        released = true;\n\n        this._release();\n      }\n    };\n  }\n  /**\r\n   * Release the snapshot on the next tick.  This means the snapshot is retained\r\n   * during the execution of the current function using it.\r\n   */\n\n\n  autoRelease_INTERNAL() {\n    if (!isSSR$1) {\n      // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936\n      window.setTimeout(() => this._release(), 10);\n    }\n  }\n\n  _release() {\n    this._refCount--;\n\n    if (this._refCount === 0) {\n      this._store.getState().nodeCleanupFunctions.forEach(cleanup => cleanup());\n\n      this._store.getState().nodeCleanupFunctions.clear();\n\n      if (!Recoil_gkx('recoil_memory_managament_2020')) {\n        return;\n      } // Temporarily nerfing this to allow us to find broken call sites without\n      // actually breaking anybody yet.\n      // for (const k of this._store.getState().knownAtoms) {\n      //   updateRetainCountToZero(this._store, k);\n      // }\n\n    } else if (this._refCount < 0) {\n      if (true) {\n        Recoil_recoverableViolation('Snapshot released an extra time.');\n      }\n    }\n  }\n\n  isRetained() {\n    return this._refCount > 0;\n  }\n\n  checkRefCount_INTERNAL() {\n    if (Recoil_gkx('recoil_memory_managament_2020') && this._refCount <= 0) {\n      if (true) {\n        Recoil_recoverableViolation(retainWarning);\n      } // What we will ship later:\n      // throw err(retainWarning);\n\n    }\n  }\n\n  getStore_INTERNAL() {\n    this.checkRefCount_INTERNAL();\n    return this._store;\n  }\n\n  getID() {\n    this.checkRefCount_INTERNAL();\n    return this._store.getState().currentTree.stateID;\n  }\n\n  getStoreID() {\n    this.checkRefCount_INTERNAL();\n    return this._store.storeID;\n  } // We want to allow the methods to be destructured and used as accessors\n\n  /* eslint-disable fb-www/extra-arrow-initializer */\n\n  /* eslint-enable fb-www/extra-arrow-initializer */\n\n\n}\n\nfunction cloneStoreState(store, treeState, bumpVersion = false) {\n  const storeState = store.getState();\n  const version = bumpVersion ? getNextTreeStateVersion$2() : treeState.version;\n  return {\n    // Always clone the TreeState to isolate stores from accidental mutations.\n    // For example, reading a selector from a cloned snapshot shouldn't cache\n    // in the original treestate which may cause the original to skip\n    // initialization of upstream atoms.\n    currentTree: {\n      // TODO snapshots shouldn't really have versions because a new version number\n      // is always assigned when the snapshot is gone to.\n      version: bumpVersion ? version : treeState.version,\n      stateID: bumpVersion ? version : treeState.stateID,\n      transactionMetadata: { ...treeState.transactionMetadata\n      },\n      dirtyAtoms: new Set(treeState.dirtyAtoms),\n      atomValues: treeState.atomValues.clone(),\n      nonvalidatedAtoms: treeState.nonvalidatedAtoms.clone()\n    },\n    commitDepth: 0,\n    nextTree: null,\n    previousTree: null,\n    knownAtoms: new Set(storeState.knownAtoms),\n    // FIXME here's a copy\n    knownSelectors: new Set(storeState.knownSelectors),\n    // FIXME here's a copy\n    transactionSubscriptions: new Map(),\n    nodeTransactionSubscriptions: new Map(),\n    nodeToComponentSubscriptions: new Map(),\n    queuedComponentCallbacks_DEPRECATED: [],\n    suspendedComponentResolvers: new Set(),\n    graphsByVersion: new Map().set(version, store.getGraph(treeState.version)),\n    retention: {\n      referenceCounts: new Map(),\n      nodesRetainedByZone: new Map(),\n      retainablesToCheckForRelease: new Set()\n    },\n    // FIXME here's a copy\n    // Create blank cleanup handlers for atoms so snapshots don't re-run\n    // atom effects.\n    nodeCleanupFunctions: new Map(Recoil_mapIterable(storeState.nodeCleanupFunctions.entries(), ([key]) => [key, () => {}]))\n  };\n} // Factory to build a fresh snapshot\n\n\nfunction freshSnapshot(initializeState) {\n  const snapshot = new Snapshot(makeEmptyStoreState$1());\n  return initializeState != null ? snapshot.map(initializeState) : snapshot;\n} // Factory to clone a snapshot state\n\n\nconst [memoizedCloneSnapshot, invalidateMemoizedSnapshot$2] = memoizeOneWithArgsHashAndInvalidation$1((store, version) => {\n  var _storeState$nextTree;\n\n  const storeState = store.getState();\n  const treeState = version === 'latest' ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : Recoil_nullthrows(storeState.previousTree);\n  return new Snapshot(cloneStoreState(store, treeState), store.storeID);\n}, (store, version) => {\n  var _store$getState$nextT, _store$getState$previ;\n\n  return String(version) + String(store.storeID) + String((_store$getState$nextT = store.getState().nextTree) === null || _store$getState$nextT === void 0 ? void 0 : _store$getState$nextT.version) + String(store.getState().currentTree.version) + String((_store$getState$previ = store.getState().previousTree) === null || _store$getState$previ === void 0 ? void 0 : _store$getState$previ.version);\n}); // Avoid circular dependencies\n\nsetInvalidateMemoizedSnapshot$1(invalidateMemoizedSnapshot$2);\n\nfunction cloneSnapshot(store, version = 'latest') {\n  const snapshot = memoizedCloneSnapshot(store, version);\n\n  if (!snapshot.isRetained()) {\n    invalidateMemoizedSnapshot$2();\n    return memoizedCloneSnapshot(store, version);\n  }\n\n  return snapshot;\n}\n\nclass MutableSnapshot extends Snapshot {\n  constructor(snapshot, batch) {\n    super(cloneStoreState(snapshot.getStore_INTERNAL(), snapshot.getStore_INTERNAL().getState().currentTree, true), snapshot.getStoreID());\n\n    _defineProperty(this, \"_batch\", void 0);\n\n    _defineProperty(this, \"set\", (recoilState, newValueOrUpdater) => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // This batchUpdates ensures this `set` is applied immediately and you can\n      // read the written value after calling `set`. I would like to remove this\n      // behavior and only batch in `Snapshot.map`, but this would be a breaking\n      // change potentially.\n\n      this._batch(() => {\n        updateRetainCount$1(store, recoilState.key, 1);\n        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, newValueOrUpdater);\n      });\n    });\n\n    _defineProperty(this, \"reset\", recoilState => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.\n\n      this._batch(() => {\n        updateRetainCount$1(store, recoilState.key, 1);\n        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, DEFAULT_VALUE$1);\n      });\n    });\n\n    _defineProperty(this, \"setUnvalidatedAtomValues_DEPRECATED\", values => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.\n\n      batchUpdates$1(() => {\n        for (const [k, v] of values.entries()) {\n          updateRetainCount$1(store, k, 1);\n          setUnvalidatedRecoilValue$1(store, new AbstractRecoilValue$2(k), v);\n        }\n      });\n    });\n\n    this._batch = batch;\n  }\n\n}\n\nvar Recoil_Snapshot = {\n  Snapshot,\n  MutableSnapshot,\n  freshSnapshot,\n  cloneSnapshot\n};\nvar Recoil_Snapshot_1 = Recoil_Snapshot.Snapshot;\nvar Recoil_Snapshot_2 = Recoil_Snapshot.MutableSnapshot;\nvar Recoil_Snapshot_3 = Recoil_Snapshot.freshSnapshot;\nvar Recoil_Snapshot_4 = Recoil_Snapshot.cloneSnapshot;\nvar Recoil_Snapshot$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Snapshot: Recoil_Snapshot_1,\n  MutableSnapshot: Recoil_Snapshot_2,\n  freshSnapshot: Recoil_Snapshot_3,\n  cloneSnapshot: Recoil_Snapshot_4\n});\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction unionSets(...sets) {\n  const result = new Set();\n\n  for (const set of sets) {\n    for (const value of set) {\n      result.add(value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_unionSets = unionSets;\nconst {\n  useRef\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n/**\r\n * The same as `useRef()` except that if a function is specified then it will\r\n * call that function to get the value to initialize the reference with.\r\n * This is similar to how `useState()` behaves when given a function.  It allows\r\n * the user to avoid generating the initial value for subsequent renders.\r\n * The tradeoff is that to set the reference to a function itself you need to\r\n * nest it: useRefInitOnce(() => () => {...});\r\n */\n\nfunction useRefInitOnce(initialValue) {\n  // $FlowExpectedError[incompatible-call]\n  const ref = useRef(initialValue);\n\n  if (ref.current === initialValue && typeof initialValue === 'function') {\n    // $FlowExpectedError[incompatible-use]\n    ref.current = initialValue();\n  }\n\n  return ref;\n}\n\nvar Recoil_useRefInitOnce = useRefInitOnce; // @fb-only: const RecoilusagelogEvent = require('RecoilusagelogEvent');\n// @fb-only: const RecoilUsageLogFalcoEvent = require('RecoilUsageLogFalcoEvent');\n// @fb-only: const URI = require('URI');\n\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$3,\n  makeEmptyStoreState: makeEmptyStoreState$2\n} = Recoil_State;\nconst {\n  cleanUpNode: cleanUpNode$2,\n  getDownstreamNodes: getDownstreamNodes$2,\n  initializeNode: initializeNode$2,\n  setNodeValue: setNodeValue$2,\n  setUnvalidatedAtomValue_DEPRECATED: setUnvalidatedAtomValue_DEPRECATED$1\n} = Recoil_FunctionalCore;\nconst {\n  graph: graph$2\n} = Recoil_Graph;\nconst {\n  cloneGraph: cloneGraph$1\n} = Recoil_Graph;\nconst {\n  getNextStoreID: getNextStoreID$2\n} = Recoil_Keys;\nconst {\n  createMutableSource: createMutableSource$1,\n  reactMode: reactMode$2\n} = Recoil_ReactMode;\nconst {\n  applyAtomValueWrites: applyAtomValueWrites$1\n} = Recoil_RecoilValueInterface;\nconst {\n  releaseScheduledRetainablesNow: releaseScheduledRetainablesNow$1\n} = Recoil_Retention;\nconst {\n  freshSnapshot: freshSnapshot$1\n} = Recoil_Snapshot$1;\nconst {\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef: useRef$1,\n  useState\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction notInAContext() {\n  throw Recoil_err('This component must be used inside a <RecoilRoot> component.');\n}\n\nconst defaultStore = Object.freeze({\n  storeID: getNextStoreID$2(),\n  getState: notInAContext,\n  replaceState: notInAContext,\n  getGraph: notInAContext,\n  subscribeToTransactions: notInAContext,\n  addTransactionMetadata: notInAContext\n});\nlet stateReplacerIsBeingExecuted = false;\n\nfunction startNextTreeIfNeeded(store) {\n  if (stateReplacerIsBeingExecuted) {\n    throw Recoil_err('An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.');\n  }\n\n  const storeState = store.getState();\n\n  if (storeState.nextTree === null) {\n    if (Recoil_gkx('recoil_memory_managament_2020') && Recoil_gkx('recoil_release_on_cascading_update_killswitch_2021')) {\n      // If this is a cascading update (that is, rendering due to one state change\n      // invokes a second state change), we won't have cleaned up retainables yet\n      // because this normally happens after notifying components. Do it before\n      // proceeding with the cascading update so that it remains predictable:\n      if (storeState.commitDepth > 0) {\n        releaseScheduledRetainablesNow$1(store);\n      }\n    }\n\n    const version = storeState.currentTree.version;\n    const nextVersion = getNextTreeStateVersion$3();\n    storeState.nextTree = { ...storeState.currentTree,\n      version: nextVersion,\n      stateID: nextVersion,\n      dirtyAtoms: new Set(),\n      transactionMetadata: {}\n    };\n    storeState.graphsByVersion.set(nextVersion, cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))));\n  }\n}\n\nconst AppContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext({\n  current: defaultStore\n});\n\nconst useStoreRef = () => useContext(AppContext); // $FlowExpectedError[incompatible-call]\n\n\nconst MutableSourceContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\n\nfunction useRecoilMutableSource() {\n  const mutableSource = useContext(MutableSourceContext);\n\n  if (mutableSource == null) {\n    Recoil_expectationViolation('Attempted to use a Recoil hook outside of a <RecoilRoot>. ' + '<RecoilRoot> must be an ancestor of any component that uses ' + 'Recoil hooks.');\n  }\n\n  return mutableSource;\n}\n\nfunction notifyComponents(store, storeState, treeState) {\n  const dependentNodes = getDownstreamNodes$2(store, treeState, treeState.dirtyAtoms);\n\n  for (const key of dependentNodes) {\n    const comps = storeState.nodeToComponentSubscriptions.get(key);\n\n    if (comps) {\n      for (const [_subID, [_debugName, callback]] of comps) {\n        callback(treeState);\n      }\n    }\n  }\n}\n\nfunction sendEndOfBatchNotifications(store) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree; // Inform transaction subscribers of the transaction:\n\n  const dirtyAtoms = treeState.dirtyAtoms;\n\n  if (dirtyAtoms.size) {\n    // Execute Node-specific subscribers before global subscribers\n    for (const [key, subscriptions] of storeState.nodeTransactionSubscriptions) {\n      if (dirtyAtoms.has(key)) {\n        for (const [_, subscription] of subscriptions) {\n          subscription(store);\n        }\n      }\n    }\n\n    for (const [_, subscription] of storeState.transactionSubscriptions) {\n      subscription(store);\n    }\n\n    if (!reactMode$2().early || storeState.suspendedComponentResolvers.size > 0) {\n      // Notifying components is needed to wake from suspense, even when using\n      // early rendering.\n      notifyComponents(store, storeState, treeState); // Wake all suspended components so the right one(s) can try to re-render.\n      // We need to wake up components not just when some asynchronous selector\n      // resolved, but also when changing synchronous values because this may cause\n      // a selector to change from asynchronous to synchronous, in which case there\n      // would be no follow-up asynchronous resolution to wake us up.\n      // TODO OPTIMIZATION Only wake up related downstream components\n\n      storeState.suspendedComponentResolvers.forEach(cb => cb());\n      storeState.suspendedComponentResolvers.clear();\n    }\n  } // Special behavior ONLY invoked by useInterface.\n  // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.\n\n\n  storeState.queuedComponentCallbacks_DEPRECATED.forEach(cb => cb(treeState));\n  storeState.queuedComponentCallbacks_DEPRECATED.splice(0, storeState.queuedComponentCallbacks_DEPRECATED.length);\n}\n\nfunction endBatch(store) {\n  const storeState = store.getState();\n  storeState.commitDepth++;\n\n  try {\n    const {\n      nextTree\n    } = storeState; // Ignore commits that are not because of Recoil transactions -- namely,\n    // because something above RecoilRoot re-rendered:\n\n    if (nextTree == null) {\n      return;\n    } // nextTree is now committed -- note that copying and reset occurs when\n    // a transaction begins, in startNextTreeIfNeeded:\n\n\n    storeState.previousTree = storeState.currentTree;\n    storeState.currentTree = nextTree;\n    storeState.nextTree = null;\n    sendEndOfBatchNotifications(store);\n\n    if (storeState.previousTree != null) {\n      storeState.graphsByVersion.delete(storeState.previousTree.version);\n    } else {\n      Recoil_recoverableViolation('Ended batch with no previous state, which is unexpected', 'recoil');\n    }\n\n    storeState.previousTree = null;\n\n    if (Recoil_gkx('recoil_memory_managament_2020')) {\n      // Only release retainables if there were no writes during the end of the\n      // batch.  This avoids releasing something we might be about to use.\n      if (nextTree == null) {\n        releaseScheduledRetainablesNow$1(store);\n      }\n    }\n  } finally {\n    storeState.commitDepth--;\n  }\n}\n/*\r\n * The purpose of the Batcher is to observe when React batches end so that\r\n * Recoil state changes can be batched. Whenever Recoil state changes, we call\r\n * setState on the batcher. Then we wait for that change to be committed, which\r\n * signifies the end of the batch. That's when we respond to the Recoil change.\r\n */\n\n\nfunction Batcher({\n  setNotifyBatcherOfChange\n}) {\n  const storeRef = useStoreRef();\n  const [, setState] = useState([]);\n  setNotifyBatcherOfChange(() => setState({}));\n  useEffect(() => {\n    setNotifyBatcherOfChange(() => setState({})); // If an asynchronous selector resolves after the Batcher is unmounted,\n    // notifyBatcherOfChange will still be called. An error gets thrown whenever\n    // setState is called after a component is already unmounted, so this sets\n    // notifyBatcherOfChange to be a no-op.\n\n    return () => {\n      setNotifyBatcherOfChange(() => {});\n    };\n  }, [setNotifyBatcherOfChange]);\n  useEffect(() => {\n    // enqueueExecution runs this function immediately; it is only used to\n    // manipulate the order of useEffects during tests, since React seems to\n    // call useEffect in an unpredictable order sometimes.\n    Recoil_Queue.enqueueExecution('Batcher', () => {\n      endBatch(storeRef.current);\n    });\n  });\n  return null;\n}\n\nif (true) {\n  if (typeof window !== 'undefined' && !window.$recoilDebugStates) {\n    window.$recoilDebugStates = [];\n  }\n} // When removing this deprecated function, remove stateBySettingRecoilValue\n// which will no longer be needed.\n\n\nfunction initialStoreState_DEPRECATED(store, initializeState) {\n  const initial = makeEmptyStoreState$2();\n  initializeState({\n    set: (atom, value) => {\n      const state = initial.currentTree;\n      const writes = setNodeValue$2(store, state, atom.key, value);\n      const writtenNodes = new Set(writes.keys());\n      const nonvalidatedAtoms = state.nonvalidatedAtoms.clone();\n\n      for (const n of writtenNodes) {\n        nonvalidatedAtoms.delete(n);\n      }\n\n      initial.currentTree = { ...state,\n        dirtyAtoms: Recoil_unionSets(state.dirtyAtoms, writtenNodes),\n        atomValues: applyAtomValueWrites$1(state.atomValues, writes),\n        // NB: PLEASE un-export applyAtomValueWrites when deleting this code\n        nonvalidatedAtoms\n      };\n    },\n    setUnvalidatedAtomValues: atomValues => {\n      // FIXME replace this with a mutative loop\n      atomValues.forEach((v, k) => {\n        initial.currentTree = setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree, k, v);\n      });\n    }\n  });\n  return initial;\n} // Initialize state snapshot for <RecoilRoot> for the initializeState prop.\n// Atom effect initialization takes precedence over this prop.\n// Any atom effects will be run before initialization, but then cleaned up,\n// they are then re-run when used as part of rendering.  These semantics are\n// compatible with React StrictMode where effects may be re-run multiple times\n// but state initialization only happens once the first time.\n\n\nfunction initialStoreState(initializeState) {\n  // Initialize a snapshot and get its store\n  const snapshot = freshSnapshot$1(initializeState);\n  const storeState = snapshot.getStore_INTERNAL().getState(); // Counteract the snapshot auto-release\n\n  snapshot.retain(); // Cleanup any effects run during initialization and clear the handlers so\n  // they will re-initialize if used during rendering.  This allows atom effect\n  // initialization to take precedence over initializeState and be compatible\n  // with StrictMode semantics.\n\n  storeState.nodeCleanupFunctions.forEach(cleanup => cleanup());\n  storeState.nodeCleanupFunctions.clear();\n  return storeState;\n}\n\nlet nextID = 0;\n\nfunction RecoilRoot_INTERNAL({\n  initializeState_DEPRECATED,\n  initializeState,\n  store_INTERNAL: storeProp,\n  // For use with React \"context bridging\"\n  children\n}) {\n  // prettier-ignore\n  // @fb-only: useEffect(() => {\n  // @fb-only: if (gkx('recoil_usage_logging')) {\n  // @fb-only: try {\n  // @fb-only: RecoilUsageLogFalcoEvent.log(() => ({\n  // @fb-only: type: RecoilusagelogEvent.RECOIL_ROOT_MOUNTED,\n  // @fb-only: path: URI.getRequestURI().getPath(),\n  // @fb-only: }));\n  // @fb-only: } catch {\n  // @fb-only: recoverableViolation(\n  // @fb-only: 'Error when logging Recoil Usage event',\n  // @fb-only: 'recoil',\n  // @fb-only: );\n  // @fb-only: }\n  // @fb-only: }\n  // @fb-only: }, []);\n  let storeStateRef; // eslint-disable-line prefer-const\n\n  const getGraph = version => {\n    const graphs = storeStateRef.current.graphsByVersion;\n\n    if (graphs.has(version)) {\n      return Recoil_nullthrows(graphs.get(version));\n    }\n\n    const newGraph = graph$2();\n    graphs.set(version, newGraph);\n    return newGraph;\n  };\n\n  const subscribeToTransactions = (callback, key) => {\n    if (key == null) {\n      // Global transaction subscriptions\n      const {\n        transactionSubscriptions\n      } = storeRef.current.getState();\n      const id = nextID++;\n      transactionSubscriptions.set(id, callback);\n      return {\n        release: () => {\n          transactionSubscriptions.delete(id);\n        }\n      };\n    } else {\n      // Node-specific transaction subscriptions:\n      const {\n        nodeTransactionSubscriptions\n      } = storeRef.current.getState();\n\n      if (!nodeTransactionSubscriptions.has(key)) {\n        nodeTransactionSubscriptions.set(key, new Map());\n      }\n\n      const id = nextID++;\n      Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id, callback);\n      return {\n        release: () => {\n          const subs = nodeTransactionSubscriptions.get(key);\n\n          if (subs) {\n            subs.delete(id);\n\n            if (subs.size === 0) {\n              nodeTransactionSubscriptions.delete(key);\n            }\n          }\n        }\n      };\n    }\n  };\n\n  const addTransactionMetadata = metadata => {\n    startNextTreeIfNeeded(storeRef.current);\n\n    for (const k of Object.keys(metadata)) {\n      Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k] = metadata[k];\n    }\n  };\n\n  const replaceState = replacer => {\n    startNextTreeIfNeeded(storeRef.current); // Use replacer to get the next state:\n\n    const nextTree = Recoil_nullthrows(storeStateRef.current.nextTree);\n    let replaced;\n\n    try {\n      stateReplacerIsBeingExecuted = true;\n      replaced = replacer(nextTree);\n    } finally {\n      stateReplacerIsBeingExecuted = false;\n    }\n\n    if (replaced === nextTree) {\n      return;\n    }\n\n    if (true) {\n      if (typeof window !== 'undefined') {\n        window.$recoilDebugStates.push(replaced); // TODO this shouldn't happen here because it's not batched\n      }\n    } // Save changes to nextTree and schedule a React update:\n\n\n    storeStateRef.current.nextTree = replaced;\n\n    if (reactMode$2().early) {\n      notifyComponents(storeRef.current, storeStateRef.current, replaced);\n    }\n\n    Recoil_nullthrows(notifyBatcherOfChange.current)();\n  };\n\n  const notifyBatcherOfChange = useRef$1(null);\n  const setNotifyBatcherOfChange = useCallback(x => {\n    notifyBatcherOfChange.current = x;\n  }, [notifyBatcherOfChange]);\n  const storeRef = Recoil_useRefInitOnce(() => storeProp !== null && storeProp !== void 0 ? storeProp : {\n    storeID: getNextStoreID$2(),\n    getState: () => storeStateRef.current,\n    replaceState,\n    getGraph,\n    subscribeToTransactions,\n    addTransactionMetadata\n  });\n\n  if (storeProp != null) {\n    storeRef.current = storeProp;\n  }\n\n  storeStateRef = Recoil_useRefInitOnce(() => initializeState_DEPRECATED != null ? initialStoreState_DEPRECATED(storeRef.current, initializeState_DEPRECATED) : initializeState != null ? initialStoreState(initializeState) : makeEmptyStoreState$2());\n  const mutableSource = useMemo(() => createMutableSource$1 === null || createMutableSource$1 === void 0 ? void 0 : createMutableSource$1(storeStateRef, () => storeStateRef.current.currentTree.version), [storeStateRef]); // Cleanup when the <RecoilRoot> is unmounted\n\n  useEffect(() => {\n    // React is free to call effect cleanup handlers and effects at will, the\n    // deps array is only an optimization.  For example, React strict mode\n    // will execute each effect twice for testing.  Therefore, we need symmetry\n    // to re-initialize all known atoms after they were cleaned up.\n    const store = storeRef.current;\n\n    for (const atomKey of new Set(store.getState().knownAtoms)) {\n      initializeNode$2(store, atomKey, 'get');\n    }\n\n    return () => {\n      for (const atomKey of store.getState().knownAtoms) {\n        cleanUpNode$2(store, atomKey);\n      }\n    };\n  }, [storeRef]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AppContext.Provider, {\n    value: storeRef\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MutableSourceContext.Provider, {\n    value: mutableSource\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Batcher, {\n    setNotifyBatcherOfChange: setNotifyBatcherOfChange\n  }), children));\n}\n\nfunction RecoilRoot(props) {\n  const {\n    override,\n    ...propsExceptOverride\n  } = props;\n  const ancestorStoreRef = useStoreRef();\n\n  if (override === false && ancestorStoreRef.current !== defaultStore) {\n    // If ancestorStoreRef.current !== defaultStore, it means that this\n    // RecoilRoot is not nested within another.\n    return props.children;\n  }\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RecoilRoot_INTERNAL, propsExceptOverride);\n}\n\nfunction useRecoilStoreID() {\n  return useStoreRef().current.storeID;\n}\n\nvar Recoil_RecoilRoot = {\n  RecoilRoot,\n  useStoreRef,\n  useRecoilMutableSource,\n  useRecoilStoreID,\n  notifyComponents_FOR_TESTING: notifyComponents,\n  sendEndOfBatchNotifications_FOR_TESTING: sendEndOfBatchNotifications\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction shallowArrayEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar Recoil_shallowArrayEqual = shallowArrayEqual;\nconst {\n  useEffect: useEffect$1,\n  useRef: useRef$2\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction usePrevious(value) {\n  const ref = useRef$2();\n  useEffect$1(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\nvar Recoil_usePrevious = usePrevious;\nconst {\n  useStoreRef: useStoreRef$1\n} = Recoil_RecoilRoot;\nconst {\n  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$1\n} = Recoil_Retention;\nconst {\n  updateRetainCount: updateRetainCount$2\n} = Recoil_Retention;\nconst {\n  RetentionZone: RetentionZone$3\n} = Recoil_RetentionZone;\nconst {\n  useEffect: useEffect$2,\n  useRef: useRef$3\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\nconst {\n  isSSR: isSSR$2\n} = Recoil_Environment; // I don't see a way to avoid the any type here because we want to accept readable\n// and writable values with any type parameter, but normally with writable ones\n// RecoilState<SomeT> is not a subtype of RecoilState<mixed>.\n// flowlint-line unclear-type:off\n\nfunction useRetain(toRetain) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  } // eslint-disable-next-line fb-www/react-hooks\n\n\n  return useRetain_ACTUAL(toRetain);\n}\n\nfunction useRetain_ACTUAL(toRetain) {\n  const array = Array.isArray(toRetain) ? toRetain : [toRetain];\n  const retainables = array.map(a => a instanceof RetentionZone$3 ? a : a.key);\n  const storeRef = useStoreRef$1();\n  useEffect$2(() => {\n    if (!Recoil_gkx('recoil_memory_managament_2020')) {\n      return;\n    }\n\n    const store = storeRef.current;\n\n    if (timeoutID.current && !isSSR$2) {\n      // Already performed a temporary retain on render, simply cancel the release\n      // of that temporary retain.\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n    } else {\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, 1);\n      }\n    }\n\n    return () => {\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }; // eslint-disable-next-line fb-www/react-hooks-deps\n  }, [storeRef, ...retainables]); // We want to retain if the component suspends. This is terrible but the Suspense\n  // API affords us no better option. If we suspend and never commit after some\n  // seconds, then release. The 'actual' retain/release in the effect above\n  // cancels this.\n\n  const timeoutID = useRef$3();\n  const previousRetainables = Recoil_usePrevious(retainables);\n\n  if (!isSSR$2 && (previousRetainables === undefined || !Recoil_shallowArrayEqual(previousRetainables, retainables))) {\n    const store = storeRef.current;\n\n    for (const r of retainables) {\n      updateRetainCount$2(store, r, 1);\n    }\n\n    if (previousRetainables) {\n      for (const r of previousRetainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }\n\n    if (timeoutID.current) {\n      window.clearTimeout(timeoutID.current);\n    }\n\n    timeoutID.current = window.setTimeout(() => {\n      timeoutID.current = null;\n\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }, SUSPENSE_TIMEOUT_MS$1);\n  }\n}\n\nvar Recoil_useRetain = useRetain;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * THIS CODE HAS BEEN COMMENTED OUT INTENTIONALLY\r\n *\r\n * This technique of getting the component name is imperfect, since it both only\r\n * works in a non-minified code base, and more importantly introduces performance\r\n * problems since it relies in throwing errors which is an expensive operation.\r\n *\r\n * At some point we may want to reevaluate this technique hence why we have commented\r\n * this code out, rather than delete it all together.\r\n */\n// const {useRef} = require('react');\n// const gkx = require('recoil-shared/util/Recoil_gkx');\n// const stackTraceParser = require('recoil-shared/util/Recoil_stackTraceParser');\n\nfunction useComponentName() {\n  // const nameRef = useRef();\n  // if (__DEV__) {\n  //   if (gkx('recoil_infer_component_names')) {\n  //     if (nameRef.current === undefined) {\n  //       // There is no blessed way to determine the calling React component from\n  //       // within a hook. This hack uses the fact that hooks must start with 'use'\n  //       // and that hooks are either called by React Components or other hooks. It\n  //       // follows therefore, that to find the calling component, you simply need\n  //       // to look down the stack and find the first function which doesn't start\n  //       // with 'use'. We are only enabling this in dev for now, since once the\n  //       // codebase is minified, the naming assumptions no longer hold true.\n  //       // eslint-disable-next-line fb-www/no-new-error\n  //       const frames = stackTraceParser(new Error().stack);\n  //       for (const {methodName} of frames) {\n  //         // I observed cases where the frame was of the form 'Object.useXXX'\n  //         // hence why I'm searching for hooks following a word boundary\n  //         if (!methodName.match(/\\buse[^\\b]+$/)) {\n  //           return (nameRef.current = methodName);\n  //         }\n  //       }\n  //       nameRef.current = null;\n  //     }\n  //     return nameRef.current ?? '<unable to determine component name>';\n  //   }\n  // }\n  // @fb-only: return \"<component name only available when both in dev mode and when passing GK 'recoil_infer_component_names'>\";\n  return '<component name not available>'; // @oss-only\n}\n\nvar Recoil_useComponentName = useComponentName;\nconst {\n  batchUpdates: batchUpdates$2\n} = Recoil_Batching;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$2\n} = Recoil_Node;\nconst {\n  reactMode: reactMode$3,\n  useMutableSource: useMutableSource$1,\n  useSyncExternalStore: useSyncExternalStore$1\n} = Recoil_ReactMode;\nconst {\n  useRecoilMutableSource: useRecoilMutableSource$1,\n  useStoreRef: useStoreRef$2\n} = Recoil_RecoilRoot;\nconst {\n  isRecoilValue: isRecoilValue$2\n} = Recoil_RecoilValue$1;\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$3,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$2,\n  setRecoilValue: setRecoilValue$2,\n  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$2,\n  subscribeToRecoilValue: subscribeToRecoilValue$1\n} = Recoil_RecoilValueInterface;\nconst {\n  useCallback: useCallback$1,\n  useEffect: useEffect$3,\n  useMemo: useMemo$1,\n  useRef: useRef$4,\n  useState: useState$1\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\nconst {\n  setByAddingToSet: setByAddingToSet$2\n} = Recoil_CopyOnWrite;\n\nfunction handleLoadable(loadable, recoilValue, storeRef) {\n  // We can't just throw the promise we are waiting on to Suspense.  If the\n  // upstream dependencies change it may produce a state in which the component\n  // can render, but it would still be suspended on a Promise that may never resolve.\n  if (loadable.state === 'hasValue') {\n    return loadable.contents;\n  } else if (loadable.state === 'loading') {\n    const promise = new Promise(resolve => {\n      storeRef.current.getState().suspendedComponentResolvers.add(resolve);\n    }); // $FlowExpectedError Flow(prop-missing) for integrating with tools that inspect thrown promises @fb-only\n    // @fb-only: promise.displayName = `Recoil State: ${recoilValue.key}`;\n\n    throw promise;\n  } else if (loadable.state === 'hasError') {\n    throw loadable.contents;\n  } else {\n    throw Recoil_err(`Invalid value of loadable atom \"${recoilValue.key}\"`);\n  }\n}\n\nfunction validateRecoilValue(recoilValue, hookName) {\n  if (!isRecoilValue$2(recoilValue)) {\n    throw Recoil_err(`Invalid argument to ${hookName}: expected an atom or selector but got ${String(recoilValue)}`);\n  }\n}\n/**\r\n * Various things are broken with useRecoilInterface, particularly concurrent\r\n * mode, React strict mode, and memory management. They will not be fixed.\r\n * */\n\n\nfunction useRecoilInterface_DEPRECATED() {\n  const componentName = Recoil_useComponentName();\n  const storeRef = useStoreRef$2();\n  const [, forceUpdate] = useState$1([]);\n  const recoilValuesUsed = useRef$4(new Set());\n  recoilValuesUsed.current = new Set(); // Track the RecoilValues used just during this render\n\n  const previousSubscriptions = useRef$4(new Set());\n  const subscriptions = useRef$4(new Map());\n  const unsubscribeFrom = useCallback$1(key => {\n    const sub = subscriptions.current.get(key);\n\n    if (sub) {\n      sub.release();\n      subscriptions.current.delete(key);\n    }\n  }, [subscriptions]);\n  const updateState = useCallback$1((_state, key) => {\n    if (subscriptions.current.has(key)) {\n      forceUpdate([]);\n    }\n  }, []); // Effect to add/remove subscriptions as nodes are used\n\n  useEffect$3(() => {\n    const store = storeRef.current;\n    Recoil_differenceSets(recoilValuesUsed.current, previousSubscriptions.current).forEach(key => {\n      if (subscriptions.current.has(key)) {\n        Recoil_expectationViolation(`Double subscription to RecoilValue \"${key}\"`);\n        return;\n      }\n\n      const sub = subscribeToRecoilValue$1(store, new AbstractRecoilValue$3(key), state => updateState(state, key), componentName);\n      subscriptions.current.set(key, sub);\n      /**\r\n       * Since we're subscribing in an effect we need to update to the latest\r\n       * value of the atom since it may have changed since we rendered. We can\r\n       * go ahead and do that now, unless we're in the middle of a batch --\r\n       * in which case we should do it at the end of the batch, due to the\r\n       * following edge case: Suppose an atom is updated in another useEffect\r\n       * of this same component. Then the following sequence of events occur:\r\n       * 1. Atom is updated and subs fired (but we may not be subscribed\r\n       *    yet depending on order of effects, so we miss this) Updated value\r\n       *    is now in nextTree, but not currentTree.\r\n       * 2. This effect happens. We subscribe and update.\r\n       * 3. From the update we re-render and read currentTree, with old value.\r\n       * 4. Batcher's effect sets currentTree to nextTree.\r\n       * In this sequence we miss the update. To avoid that, add the update\r\n       * to queuedComponentCallback if a batch is in progress.\r\n       */\n      // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.\n\n      const state = store.getState();\n\n      if (state.nextTree) {\n        store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {\n          updateState(store.getState(), key);\n        });\n      } else {\n        updateState(store.getState(), key);\n      }\n    });\n    Recoil_differenceSets(previousSubscriptions.current, recoilValuesUsed.current).forEach(key => {\n      unsubscribeFrom(key);\n    });\n    previousSubscriptions.current = recoilValuesUsed.current;\n  }); // Effect to unsubscribe from all when unmounting\n\n  useEffect$3(() => {\n    const currentSubscriptions = subscriptions.current; // Restore subscriptions that were cleared due to StrictMode running this effect twice\n\n    Recoil_differenceSets(recoilValuesUsed.current, new Set(currentSubscriptions.keys())).forEach(key => {\n      const sub = subscribeToRecoilValue$1(storeRef.current, new AbstractRecoilValue$3(key), state => updateState(state, key), componentName);\n      currentSubscriptions.set(key, sub);\n    });\n    return () => currentSubscriptions.forEach((_, key) => unsubscribeFrom(key));\n  }, [componentName, storeRef, unsubscribeFrom, updateState]);\n  return useMemo$1(() => {\n    // eslint-disable-next-line no-shadow\n    function useSetRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useSetRecoilState');\n      }\n\n      return newValueOrUpdater => {\n        setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);\n      };\n    } // eslint-disable-next-line no-shadow\n\n\n    function useResetRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useResetRecoilState');\n      }\n\n      return () => setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilValueLoadable(recoilValue) {\n      var _storeState$nextTree;\n\n      if (true) {\n        validateRecoilValue(recoilValue, 'useRecoilValueLoadable');\n      }\n\n      if (!recoilValuesUsed.current.has(recoilValue.key)) {\n        recoilValuesUsed.current = setByAddingToSet$2(recoilValuesUsed.current, recoilValue.key);\n      } // TODO Restore optimization to memoize lookup\n\n\n      const storeState = storeRef.current.getState();\n      return getRecoilValueAsLoadable$2(storeRef.current, recoilValue, reactMode$3().early ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : storeState.currentTree);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilValue(recoilValue) {\n      if (true) {\n        validateRecoilValue(recoilValue, 'useRecoilValue');\n      }\n\n      const loadable = useRecoilValueLoadable(recoilValue);\n      return handleLoadable(loadable, recoilValue, storeRef);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useRecoilState');\n      }\n\n      return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilStateLoadable(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useRecoilStateLoadable');\n      }\n\n      return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];\n    }\n\n    return {\n      getRecoilValue: useRecoilValue,\n      getRecoilValueLoadable: useRecoilValueLoadable,\n      getRecoilState: useRecoilState,\n      getRecoilStateLoadable: useRecoilStateLoadable,\n      getSetRecoilState: useSetRecoilState,\n      getResetRecoilState: useResetRecoilState\n    };\n  }, [recoilValuesUsed, storeRef]);\n}\n\nconst recoilComponentGetRecoilValueCount_FOR_TESTING = {\n  current: 0\n};\n\nfunction useRecoilValueLoadable_SYNC_EXTERNAL_STORE(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const componentName = Recoil_useComponentName();\n  const getSnapshot = useCallback$1(() => {\n    var _storeState$nextTree2;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree2 = storeState.nextTree) !== null && _storeState$nextTree2 !== void 0 ? _storeState$nextTree2 : storeState.currentTree : storeState.currentTree;\n    const loadable = getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n    return {\n      loadable,\n      key: recoilValue.key\n    };\n  }, [storeRef, recoilValue]); // Memoize the state to avoid unnecessary rerenders\n\n  const memoizePreviousSnapshot = useCallback$1(getState => {\n    let prevState;\n    return () => {\n      var _prevState, _prevState2;\n\n      const nextState = getState();\n\n      if ((_prevState = prevState) !== null && _prevState !== void 0 && _prevState.loadable.is(nextState.loadable) && ((_prevState2 = prevState) === null || _prevState2 === void 0 ? void 0 : _prevState2.key) === nextState.key) {\n        return prevState;\n      }\n\n      prevState = nextState;\n      return nextState;\n    };\n  }, []);\n  const getMemoizedSnapshot = useMemo$1(() => memoizePreviousSnapshot(getSnapshot), [getSnapshot, memoizePreviousSnapshot]);\n  const subscribe = useCallback$1(notify => {\n    const store = storeRef.current;\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, notify, componentName);\n    return subscription.release;\n  }, [storeRef, recoilValue, componentName]);\n  return useSyncExternalStore$1(subscribe, getMemoizedSnapshot, // getSnapshot()\n  getMemoizedSnapshot // getServerSnapshot() for SSR support\n  ).loadable;\n}\n\nfunction useRecoilValueLoadable_MUTABLE_SOURCE(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree3;\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree3 = storeState.nextTree) !== null && _storeState$nextTree3 !== void 0 ? _storeState$nextTree3 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const getLoadableWithTesting = useCallback$1(() => {\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    return getLoadable();\n  }, [getLoadable]);\n  const componentName = Recoil_useComponentName();\n  const subscribe = useCallback$1((_storeState, notify) => {\n    const store = storeRef.current;\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, () => {\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return notify();\n      } // Only re-render if the value has changed.\n      // This will evaluate the atom/selector now as well as when the\n      // component renders, but that may help with prefetching.\n\n\n      const newLoadable = getLoadable();\n\n      if (!prevLoadableRef.current.is(newLoadable)) {\n        notify();\n      } // If the component is suspended then the effect setting prevLoadableRef\n      // will not run.  So, set the previous value here when its subscription\n      // is fired to wake it up.  We can't just rely on this, though, because\n      // this only executes when an atom/selector is dirty and the atom/selector\n      // passed to the hook can dynamically change.\n\n\n      prevLoadableRef.current = newLoadable;\n    }, componentName);\n    return subscription.release;\n  }, [storeRef, recoilValue, componentName, getLoadable]);\n  const source = useRecoilMutableSource$1();\n\n  if (source == null) {\n    throw Recoil_err('Recoil hooks must be used in components contained within a <RecoilRoot> component.');\n  }\n\n  const loadable = useMutableSource$1(source, getLoadableWithTesting, subscribe);\n  const prevLoadableRef = useRef$4(loadable);\n  useEffect$3(() => {\n    prevLoadableRef.current = loadable;\n  });\n  return loadable;\n}\n\nfunction useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const componentName = Recoil_useComponentName(); // Accessors to get the current state\n\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree4;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree4 = storeState.nextTree) !== null && _storeState$nextTree4 !== void 0 ? _storeState$nextTree4 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const getState = useCallback$1(() => ({\n    loadable: getLoadable(),\n    key: recoilValue.key\n  }), [getLoadable, recoilValue.key]); // Memoize state snapshots\n\n  const updateState = useCallback$1(prevState => {\n    const nextState = getState();\n    return prevState.loadable.is(nextState.loadable) && prevState.key === nextState.key ? prevState : nextState;\n  }, [getState]); // Subscribe to Recoil state changes\n\n  useEffect$3(() => {\n    const subscription = subscribeToRecoilValue$1(storeRef.current, recoilValue, _state => {\n      setState(updateState);\n    }, componentName); // Update state in case we are using a different key\n\n    setState(updateState);\n    return subscription.release;\n  }, [componentName, recoilValue, storeRef, updateState]); // Get the current state\n\n  const [state, setState] = useState$1(getState); // If we changed keys, then return the state for the new key.\n  // This is important in case the old key would cause the component to suspend.\n  // We don't have to set the new state here since the subscribing effect above\n  // will do that.\n\n  return state.key !== recoilValue.key ? getState().loadable : state.loadable;\n}\n\nfunction useRecoilValueLoadable_LEGACY(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const [, forceUpdate] = useState$1([]);\n  const componentName = Recoil_useComponentName();\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree5;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree5 = storeState.nextTree) !== null && _storeState$nextTree5 !== void 0 ? _storeState$nextTree5 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const loadable = getLoadable();\n  const prevLoadableRef = useRef$4(loadable);\n  useEffect$3(() => {\n    prevLoadableRef.current = loadable;\n  });\n  useEffect$3(() => {\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, _state => {\n      var _prevLoadableRef$curr;\n\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return forceUpdate([]);\n      }\n\n      const newLoadable = getLoadable();\n\n      if (!((_prevLoadableRef$curr = prevLoadableRef.current) !== null && _prevLoadableRef$curr !== void 0 && _prevLoadableRef$curr.is(newLoadable))) {\n        forceUpdate(newLoadable);\n      }\n\n      prevLoadableRef.current = newLoadable;\n    }, componentName);\n    /**\r\n     * Since we're subscribing in an effect we need to update to the latest\r\n     * value of the atom since it may have changed since we rendered. We can\r\n     * go ahead and do that now, unless we're in the middle of a batch --\r\n     * in which case we should do it at the end of the batch, due to the\r\n     * following edge case: Suppose an atom is updated in another useEffect\r\n     * of this same component. Then the following sequence of events occur:\r\n     * 1. Atom is updated and subs fired (but we may not be subscribed\r\n     *    yet depending on order of effects, so we miss this) Updated value\r\n     *    is now in nextTree, but not currentTree.\r\n     * 2. This effect happens. We subscribe and update.\r\n     * 3. From the update we re-render and read currentTree, with old value.\r\n     * 4. Batcher's effect sets currentTree to nextTree.\r\n     * In this sequence we miss the update. To avoid that, add the update\r\n     * to queuedComponentCallback if a batch is in progress.\r\n     */\n\n    if (storeState.nextTree) {\n      store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {\n        prevLoadableRef.current = null;\n        forceUpdate([]);\n      });\n    } else {\n      var _prevLoadableRef$curr2;\n\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return forceUpdate([]);\n      }\n\n      const newLoadable = getLoadable();\n\n      if (!((_prevLoadableRef$curr2 = prevLoadableRef.current) !== null && _prevLoadableRef$curr2 !== void 0 && _prevLoadableRef$curr2.is(newLoadable))) {\n        forceUpdate(newLoadable);\n      }\n\n      prevLoadableRef.current = newLoadable;\n    }\n\n    return subscription.release;\n  }, [componentName, getLoadable, recoilValue, storeRef]);\n  return loadable;\n}\n/**\r\n  Like useRecoilValue(), but either returns the value if available or\r\n  just undefined if not available for any reason, such as pending or error.\r\n*/\n\n\nfunction useRecoilValueLoadable(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValueLoadable');\n  }\n\n  if (Recoil_gkx('recoil_memory_managament_2020')) {\n    // eslint-disable-next-line fb-www/react-hooks\n    Recoil_useRetain(recoilValue);\n  }\n\n  return {\n    TRANSITION_SUPPORT: useRecoilValueLoadable_TRANSITION_SUPPORT,\n    SYNC_EXTERNAL_STORE: useRecoilValueLoadable_SYNC_EXTERNAL_STORE,\n    MUTABLE_SOURCE: useRecoilValueLoadable_MUTABLE_SOURCE,\n    LEGACY: useRecoilValueLoadable_LEGACY\n  }[reactMode$3().mode](recoilValue);\n}\n/**\r\n  Returns the value represented by the RecoilValue.\r\n  If the value is pending, it will throw a Promise to suspend the component,\r\n  if the value is an error it will throw it for the nearest React error boundary.\r\n  This will also subscribe the component for any updates in the value.\r\n  */\n\n\nfunction useRecoilValue(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValue');\n  }\n\n  const storeRef = useStoreRef$2();\n  const loadable = useRecoilValueLoadable(recoilValue);\n  return handleLoadable(loadable, recoilValue, storeRef);\n}\n/**\r\n  Returns a function that allows the value of a RecoilState to be updated, but does\r\n  not subscribe the component to changes to that RecoilState.\r\n*/\n\n\nfunction useSetRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useSetRecoilState');\n  }\n\n  const storeRef = useStoreRef$2();\n  return useCallback$1(newValueOrUpdater => {\n    setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);\n  }, [storeRef, recoilState]);\n}\n/**\r\n  Returns a function that will reset the value of a RecoilState to its default\r\n*/\n\n\nfunction useResetRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useResetRecoilState');\n  }\n\n  const storeRef = useStoreRef$2();\n  return useCallback$1(() => {\n    setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n  }, [storeRef, recoilState]);\n}\n/**\r\n  Equivalent to useState(). Allows the value of the RecoilState to be read and written.\r\n  Subsequent updates to the RecoilState will cause the component to re-render. If the\r\n  RecoilState is pending, this will suspend the component and initiate the\r\n  retrieval of the value. If evaluating the RecoilState resulted in an error, this will\r\n  throw the error so that the nearest React error boundary can catch it.\r\n*/\n\n\nfunction useRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilState');\n  }\n\n  return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];\n}\n/**\r\n  Like useRecoilState(), but does not cause Suspense or React error handling. Returns\r\n  an object that indicates whether the RecoilState is available, pending, or\r\n  unavailable due to an error.\r\n*/\n\n\nfunction useRecoilStateLoadable(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilStateLoadable');\n  }\n\n  return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];\n}\n\nfunction useSetUnvalidatedAtomValues() {\n  const storeRef = useStoreRef$2();\n  return (values, transactionMetadata = {}) => {\n    batchUpdates$2(() => {\n      storeRef.current.addTransactionMetadata(transactionMetadata);\n      values.forEach((value, key) => setUnvalidatedRecoilValue$2(storeRef.current, new AbstractRecoilValue$3(key), value));\n    });\n  };\n}\n/**\r\n * Experimental variants of hooks with support for useTransition()\r\n */\n\n\nfunction useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE');\n\n    if (!reactMode$3().early) {\n      Recoil_recoverableViolation('Attepmt to use a hook with UNSTABLE_TRANSITION_SUPPORT in a rendering mode incompatible with concurrent rendering.  Try enabling the recoil_sync_external_store or recoil_transition_support GKs.');\n    }\n  }\n\n  if (Recoil_gkx('recoil_memory_managament_2020')) {\n    // eslint-disable-next-line fb-www/react-hooks\n    Recoil_useRetain(recoilValue);\n  }\n\n  return useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue);\n}\n\nfunction useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValue_TRANSITION_SUPPORT_UNSTABLE');\n  }\n\n  const storeRef = useStoreRef$2();\n  const loadable = useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue);\n  return handleLoadable(loadable, recoilValue, storeRef);\n}\n\nfunction useRecoilState_TRANSITION_SUPPORT_UNSTABLE(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilState_TRANSITION_SUPPORT_UNSTABLE');\n  }\n\n  return [useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilState), useSetRecoilState(recoilState)];\n}\n\nvar Recoil_Hooks = {\n  recoilComponentGetRecoilValueCount_FOR_TESTING,\n  useRecoilInterface: useRecoilInterface_DEPRECATED,\n  useRecoilState,\n  useRecoilStateLoadable,\n  useRecoilValue,\n  useRecoilValueLoadable,\n  useResetRecoilState,\n  useSetRecoilState,\n  useSetUnvalidatedAtomValues,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Returns a map containing all of the keys + values from the original map where\r\n * the given callback returned true.\r\n */\n\nfunction filterMap(map, callback) {\n  const result = new Map();\n\n  for (const [key, value] of map) {\n    if (callback(value, key)) {\n      result.set(key, value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_filterMap = filterMap;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Returns a set containing all of the values from the original set where\r\n * the given callback returned true.\r\n */\n\nfunction filterSet(set, callback) {\n  const result = new Set();\n\n  for (const value of set) {\n    if (callback(value)) {\n      result.add(value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_filterSet = filterSet;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction mergeMaps(...maps) {\n  const result = new Map();\n\n  for (let i = 0; i < maps.length; i++) {\n    const iterator = maps[i].keys();\n    let nextKey;\n\n    while (!(nextKey = iterator.next()).done) {\n      // $FlowIssue[incompatible-call] - map/iterator knows nothing about flow types\n      result.set(nextKey.value, maps[i].get(nextKey.value));\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_mergeMaps = mergeMaps;\nconst {\n  batchUpdates: batchUpdates$3\n} = Recoil_Batching;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$3,\n  getNode: getNode$4,\n  nodes: nodes$1\n} = Recoil_Node;\nconst {\n  useStoreRef: useStoreRef$3\n} = Recoil_RecoilRoot;\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$4,\n  setRecoilValueLoadable: setRecoilValueLoadable$1\n} = Recoil_RecoilValueInterface;\nconst {\n  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$2\n} = Recoil_Retention;\nconst {\n  cloneSnapshot: cloneSnapshot$1\n} = Recoil_Snapshot$1;\nconst {\n  useCallback: useCallback$2,\n  useEffect: useEffect$4,\n  useRef: useRef$5,\n  useState: useState$2\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\nconst {\n  isSSR: isSSR$3\n} = Recoil_Environment;\n\nfunction useTransactionSubscription(callback) {\n  const storeRef = useStoreRef$3();\n  useEffect$4(() => {\n    const sub = storeRef.current.subscribeToTransactions(callback);\n    return sub.release;\n  }, [callback, storeRef]);\n}\n\nfunction externallyVisibleAtomValuesInState(state) {\n  const atomValues = state.atomValues.toMap();\n  const persistedAtomContentsValues = Recoil_mapMap(Recoil_filterMap(atomValues, (v, k) => {\n    const node = getNode$4(k);\n    const persistence = node.persistence_UNSTABLE;\n    return persistence != null && persistence.type !== 'none' && v.state === 'hasValue';\n  }), v => v.contents); // Merge in nonvalidated atoms; we may not have defs for them but they will\n  // all have persistence on or they wouldn't be there in the first place.\n\n  return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(), persistedAtomContentsValues);\n}\n/**\r\n  Calls the given callback after any atoms have been modified and the consequent\r\n  component re-renders have been committed. This is intended for persisting\r\n  the values of the atoms to storage. The stored values can then be restored\r\n  using the useSetUnvalidatedAtomValues hook.\r\n\r\n  The callback receives the following info:\r\n\r\n  atomValues: The current value of every atom that is both persistable (persistence\r\n              type not set to 'none') and whose value is available (not in an\r\n              error or loading state).\r\n\r\n  previousAtomValues: The value of every persistable and available atom before\r\n               the transaction began.\r\n\r\n  atomInfo: A map containing the persistence settings for each atom. Every key\r\n            that exists in atomValues will also exist in atomInfo.\r\n\r\n  modifiedAtoms: The set of atoms that were written to during the transaction.\r\n\r\n  transactionMetadata: Arbitrary information that was added via the\r\n          useSetUnvalidatedAtomValues hook. Useful for ignoring the useSetUnvalidatedAtomValues\r\n          transaction, to avoid loops.\r\n*/\n\n\nfunction useTransactionObservation_DEPRECATED(callback) {\n  useTransactionSubscription(useCallback$2(store => {\n    let previousTree = store.getState().previousTree;\n    const currentTree = store.getState().currentTree;\n\n    if (!previousTree) {\n      Recoil_recoverableViolation('Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil');\n      previousTree = store.getState().currentTree; // attempt to trundle on\n    }\n\n    const atomValues = externallyVisibleAtomValuesInState(currentTree);\n    const previousAtomValues = externallyVisibleAtomValuesInState(previousTree);\n    const atomInfo = Recoil_mapMap(nodes$1, node => {\n      var _node$persistence_UNS, _node$persistence_UNS2, _node$persistence_UNS3, _node$persistence_UNS4;\n\n      return {\n        persistence_UNSTABLE: {\n          type: (_node$persistence_UNS = (_node$persistence_UNS2 = node.persistence_UNSTABLE) === null || _node$persistence_UNS2 === void 0 ? void 0 : _node$persistence_UNS2.type) !== null && _node$persistence_UNS !== void 0 ? _node$persistence_UNS : 'none',\n          backButton: (_node$persistence_UNS3 = (_node$persistence_UNS4 = node.persistence_UNSTABLE) === null || _node$persistence_UNS4 === void 0 ? void 0 : _node$persistence_UNS4.backButton) !== null && _node$persistence_UNS3 !== void 0 ? _node$persistence_UNS3 : false\n        }\n      };\n    }); // Filter on existance in atomValues so that externally-visible rules\n    // are also applied to modified atoms (specifically exclude selectors):\n\n    const modifiedAtoms = Recoil_filterSet(currentTree.dirtyAtoms, k => atomValues.has(k) || previousAtomValues.has(k));\n    callback({\n      atomValues,\n      previousAtomValues,\n      atomInfo,\n      modifiedAtoms,\n      transactionMetadata: { ...currentTree.transactionMetadata\n      }\n    });\n  }, [callback]));\n}\n\nfunction useRecoilTransactionObserver(callback) {\n  useTransactionSubscription(useCallback$2(store => {\n    const snapshot = cloneSnapshot$1(store, 'latest');\n    const previousSnapshot = cloneSnapshot$1(store, 'previous');\n    callback({\n      snapshot,\n      previousSnapshot\n    });\n  }, [callback]));\n} // Return a snapshot of the current state and subscribe to all state changes\n\n\nfunction useRecoilSnapshot() {\n  const storeRef = useStoreRef$3();\n  const [snapshot, setSnapshot] = useState$2(() => cloneSnapshot$1(storeRef.current));\n  const previousSnapshot = Recoil_usePrevious(snapshot);\n  const timeoutID = useRef$5();\n  const releaseRef = useRef$5();\n  useTransactionSubscription(useCallback$2(store => setSnapshot(cloneSnapshot$1(store)), [])); // Retain snapshot for duration component is mounted\n\n  useEffect$4(() => {\n    const release = snapshot.retain(); // Release the retain from the rendering call\n\n    if (timeoutID.current && !isSSR$3) {\n      var _releaseRef$current;\n\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n      (_releaseRef$current = releaseRef.current) === null || _releaseRef$current === void 0 ? void 0 : _releaseRef$current.call(releaseRef);\n      releaseRef.current = null;\n    }\n\n    return () => {\n      // Defer the release.  If \"Fast Refresh\"\" is used then the component may\n      // re-render with the same state.  The previous cleanup will then run and\n      // then the new effect will run. We don't want the snapshot to be released\n      // by that cleanup before the new effect has a chance to retain it again.\n      // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936\n      window.setTimeout(release, 10);\n    };\n  }, [snapshot]); // Retain snapshot until above effect is run.\n  // Release after a threshold in case component is suspended.\n\n  if (previousSnapshot !== snapshot && !isSSR$3) {\n    // Release the previous snapshot\n    if (timeoutID.current) {\n      var _releaseRef$current2;\n\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n      (_releaseRef$current2 = releaseRef.current) === null || _releaseRef$current2 === void 0 ? void 0 : _releaseRef$current2.call(releaseRef);\n      releaseRef.current = null;\n    }\n\n    releaseRef.current = snapshot.retain();\n    timeoutID.current = window.setTimeout(() => {\n      var _releaseRef$current3;\n\n      timeoutID.current = null;\n      (_releaseRef$current3 = releaseRef.current) === null || _releaseRef$current3 === void 0 ? void 0 : _releaseRef$current3.call(releaseRef);\n      releaseRef.current = null;\n    }, SUSPENSE_TIMEOUT_MS$2);\n  }\n\n  return snapshot;\n}\n\nfunction gotoSnapshot(store, snapshot) {\n  var _storeState$nextTree;\n\n  const storeState = store.getState();\n  const prev = (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree;\n  const next = snapshot.getStore_INTERNAL().getState().currentTree;\n  batchUpdates$3(() => {\n    const keysToUpdate = new Set();\n\n    for (const keys of [prev.atomValues.keys(), next.atomValues.keys()]) {\n      for (const key of keys) {\n        var _prev$atomValues$get, _next$atomValues$get;\n\n        if (((_prev$atomValues$get = prev.atomValues.get(key)) === null || _prev$atomValues$get === void 0 ? void 0 : _prev$atomValues$get.contents) !== ((_next$atomValues$get = next.atomValues.get(key)) === null || _next$atomValues$get === void 0 ? void 0 : _next$atomValues$get.contents) && getNode$4(key).shouldRestoreFromSnapshots) {\n          keysToUpdate.add(key);\n        }\n      }\n    }\n\n    keysToUpdate.forEach(key => {\n      setRecoilValueLoadable$1(store, new AbstractRecoilValue$4(key), next.atomValues.has(key) ? Recoil_nullthrows(next.atomValues.get(key)) : DEFAULT_VALUE$3);\n    });\n    store.replaceState(state => ({ ...state,\n      stateID: snapshot.getID()\n    }));\n  });\n}\n\nfunction useGotoRecoilSnapshot() {\n  const storeRef = useStoreRef$3();\n  return useCallback$2(snapshot => gotoSnapshot(storeRef.current, snapshot), [storeRef]);\n}\n\nvar Recoil_SnapshotHooks = {\n  useRecoilSnapshot,\n  gotoSnapshot,\n  useGotoRecoilSnapshot,\n  useRecoilTransactionObserver,\n  useTransactionObservation_DEPRECATED,\n  useTransactionSubscription_DEPRECATED: useTransactionSubscription\n};\nconst {\n  peekNodeInfo: peekNodeInfo$2\n} = Recoil_FunctionalCore;\nconst {\n  useStoreRef: useStoreRef$4\n} = Recoil_RecoilRoot;\n\nfunction useGetRecoilValueInfo() {\n  const storeRef = useStoreRef$4();\n  return ({\n    key\n  }) => peekNodeInfo$2(storeRef.current, storeRef.current.getState().currentTree, key);\n}\n\nvar Recoil_useGetRecoilValueInfo = useGetRecoilValueInfo;\nconst {\n  reactMode: reactMode$4\n} = Recoil_ReactMode;\nconst {\n  RecoilRoot: RecoilRoot$1,\n  useStoreRef: useStoreRef$5\n} = Recoil_RecoilRoot;\nconst {\n  useMemo: useMemo$2\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction useRecoilBridgeAcrossReactRoots() {\n  // The test fails when using useMutableSource(), but only if act() is used\n  // for the nested root.  So, this may only be a testing environment issue.\n  if (reactMode$4().mode === 'MUTABLE_SOURCE') {\n    // eslint-disable-next-line fb-www/no-console\n    console.warn('Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.');\n  }\n\n  const store = useStoreRef$5().current;\n  return useMemo$2(() => {\n    // eslint-disable-next-line no-shadow\n    function RecoilBridge({\n      children\n    }) {\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RecoilRoot$1, {\n        store_INTERNAL: store\n      }, children);\n    }\n\n    return RecoilBridge;\n  }, [store]);\n}\n\nvar Recoil_useRecoilBridgeAcrossReactRoots = useRecoilBridgeAcrossReactRoots;\nconst {\n  loadableWithValue: loadableWithValue$1\n} = Recoil_Loadable$1;\nconst {\n  initializeNode: initializeNode$3\n} = Recoil_FunctionalCore;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$4,\n  getNode: getNode$5\n} = Recoil_Node;\nconst {\n  copyTreeState: copyTreeState$1,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$3,\n  invalidateDownstreams: invalidateDownstreams$1,\n  writeLoadableToTreeState: writeLoadableToTreeState$1\n} = Recoil_RecoilValueInterface;\n\nfunction isAtom(recoilValue) {\n  return getNode$5(recoilValue.key).nodeType === 'atom';\n}\n\nclass TransactionInterfaceImpl {\n  constructor(store, treeState) {\n    _defineProperty(this, \"_store\", void 0);\n\n    _defineProperty(this, \"_treeState\", void 0);\n\n    _defineProperty(this, \"_changes\", void 0);\n\n    _defineProperty(this, \"get\", recoilValue => {\n      if (this._changes.has(recoilValue.key)) {\n        // $FlowIssue[incompatible-return]\n        return this._changes.get(recoilValue.key);\n      }\n\n      if (!isAtom(recoilValue)) {\n        throw Recoil_err('Reading selectors within atomicUpdate is not supported');\n      }\n\n      const loadable = getRecoilValueAsLoadable$3(this._store, recoilValue, this._treeState);\n\n      if (loadable.state === 'hasValue') {\n        return loadable.contents;\n      } else if (loadable.state === 'hasError') {\n        throw loadable.contents;\n      } else {\n        throw Recoil_err(`Expected Recoil atom ${recoilValue.key} to have a value, but it is in a loading state.`);\n      }\n    });\n\n    _defineProperty(this, \"set\", (recoilState, valueOrUpdater) => {\n      if (!isAtom(recoilState)) {\n        throw Recoil_err('Setting selectors within atomicUpdate is not supported');\n      }\n\n      if (typeof valueOrUpdater === 'function') {\n        const current = this.get(recoilState);\n\n        this._changes.set(recoilState.key, valueOrUpdater(current)); // flowlint-line unclear-type:off\n\n      } else {\n        // Initialize atom and run effects if not initialized yet\n        initializeNode$3(this._store, recoilState.key, 'set');\n\n        this._changes.set(recoilState.key, valueOrUpdater);\n      }\n    });\n\n    _defineProperty(this, \"reset\", recoilState => {\n      this.set(recoilState, DEFAULT_VALUE$4);\n    });\n\n    this._store = store;\n    this._treeState = treeState;\n    this._changes = new Map();\n  } // Allow destructing\n  // eslint-disable-next-line fb-www/extra-arrow-initializer\n\n\n  newTreeState_INTERNAL() {\n    if (this._changes.size === 0) {\n      return this._treeState;\n    }\n\n    const newState = copyTreeState$1(this._treeState);\n\n    for (const [k, v] of this._changes) {\n      writeLoadableToTreeState$1(newState, k, loadableWithValue$1(v));\n    }\n\n    invalidateDownstreams$1(this._store, newState);\n    return newState;\n  }\n\n}\n\nfunction atomicUpdater(store) {\n  return fn => {\n    store.replaceState(treeState => {\n      const changeset = new TransactionInterfaceImpl(store, treeState);\n      fn(changeset);\n      return changeset.newTreeState_INTERNAL();\n    });\n  };\n}\n\nvar Recoil_AtomicUpdates = {\n  atomicUpdater\n};\nvar Recoil_AtomicUpdates_1 = Recoil_AtomicUpdates.atomicUpdater;\nvar Recoil_AtomicUpdates$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  atomicUpdater: Recoil_AtomicUpdates_1\n});\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nvar invariant_1 = invariant; // @oss-only\n\nvar Recoil_invariant = invariant_1;\nconst {\n  atomicUpdater: atomicUpdater$1\n} = Recoil_AtomicUpdates$1;\nconst {\n  batchUpdates: batchUpdates$4\n} = Recoil_Batching;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$5\n} = Recoil_Node;\nconst {\n  useStoreRef: useStoreRef$6\n} = Recoil_RecoilRoot;\nconst {\n  refreshRecoilValue: refreshRecoilValue$1,\n  setRecoilValue: setRecoilValue$3\n} = Recoil_RecoilValueInterface;\nconst {\n  cloneSnapshot: cloneSnapshot$2\n} = Recoil_Snapshot$1;\nconst {\n  gotoSnapshot: gotoSnapshot$1\n} = Recoil_SnapshotHooks;\nconst {\n  useCallback: useCallback$3\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nclass Sentinel {}\n\nconst SENTINEL = new Sentinel();\n\nfunction recoilCallback(store, fn, args, extraInterface) {\n  let ret = SENTINEL;\n  let releaseSnapshot;\n  batchUpdates$4(() => {\n    const errMsg = 'useRecoilCallback() expects a function that returns a function: ' + 'it accepts a function of the type (RecoilInterface) => (Args) => ReturnType ' + 'and returns a callback function (Args) => ReturnType, where RecoilInterface is ' + 'an object {snapshot, set, ...} and Args and ReturnType are the argument and return ' + 'types of the callback you want to create.  Please see the docs ' + 'at recoiljs.org for details.';\n\n    if (typeof fn !== 'function') {\n      throw Recoil_err(errMsg);\n    } // Clone the snapshot lazily to avoid overhead if the callback does not use it.\n    // Note that this means the snapshot may represent later state from when\n    // the callback was called if it first accesses the snapshot asynchronously.\n\n\n    const callbackInterface = Recoil_lazyProxy({ ...(extraInterface !== null && extraInterface !== void 0 ? extraInterface : {}),\n      // flowlint-line unclear-type:off\n      set: (node, newValue) => setRecoilValue$3(store, node, newValue),\n      reset: node => setRecoilValue$3(store, node, DEFAULT_VALUE$5),\n      refresh: node => refreshRecoilValue$1(store, node),\n      gotoSnapshot: snapshot => gotoSnapshot$1(store, snapshot),\n      transact_UNSTABLE: transaction => atomicUpdater$1(store)(transaction)\n    }, {\n      snapshot: () => {\n        const snapshot = cloneSnapshot$2(store);\n        releaseSnapshot = snapshot.retain();\n        return snapshot;\n      }\n    });\n    const callback = fn(callbackInterface);\n\n    if (typeof callback !== 'function') {\n      throw Recoil_err(errMsg);\n    }\n\n    ret = callback(...args);\n  });\n  !!(ret instanceof Sentinel) ?  true ? Recoil_invariant(false, 'batchUpdates should return immediately') : 0 : void 0;\n\n  if (Recoil_isPromise(ret)) {\n    ret.finally(() => {\n      var _releaseSnapshot;\n\n      (_releaseSnapshot = releaseSnapshot) === null || _releaseSnapshot === void 0 ? void 0 : _releaseSnapshot();\n    });\n  } else {\n    var _releaseSnapshot2;\n\n    (_releaseSnapshot2 = releaseSnapshot) === null || _releaseSnapshot2 === void 0 ? void 0 : _releaseSnapshot2();\n  } // $FlowFixMe[incompatible-cast]\n\n\n  return ret;\n}\n\nfunction useRecoilCallback(fn, deps) {\n  const storeRef = useStoreRef$6();\n  return useCallback$3( // $FlowIssue[incompatible-call]\n  (...args) => {\n    return recoilCallback(storeRef.current, fn, args);\n  }, deps != null ? [...deps, storeRef] : undefined // eslint-disable-line fb-www/react-hooks-deps\n  );\n}\n\nvar Recoil_useRecoilCallback = {\n  recoilCallback,\n  useRecoilCallback\n};\nconst {\n  useStoreRef: useStoreRef$7\n} = Recoil_RecoilRoot;\nconst {\n  refreshRecoilValue: refreshRecoilValue$2\n} = Recoil_RecoilValueInterface;\nconst {\n  useCallback: useCallback$4\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction useRecoilRefresher(recoilValue) {\n  const storeRef = useStoreRef$7();\n  return useCallback$4(() => {\n    const store = storeRef.current;\n    refreshRecoilValue$2(store, recoilValue);\n  }, [recoilValue, storeRef]);\n}\n\nvar Recoil_useRecoilRefresher = useRecoilRefresher;\nconst {\n  atomicUpdater: atomicUpdater$2\n} = Recoil_AtomicUpdates$1;\nconst {\n  useStoreRef: useStoreRef$8\n} = Recoil_RecoilRoot;\nconst {\n  useMemo: useMemo$3\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction useRecoilTransaction(fn, deps) {\n  const storeRef = useStoreRef$8();\n  return useMemo$3(() => (...args) => {\n    const atomicUpdate = atomicUpdater$2(storeRef.current);\n    atomicUpdate(transactionInterface => {\n      fn(transactionInterface)(...args);\n    });\n  }, deps != null ? [...deps, storeRef] : undefined // eslint-disable-line fb-www/react-hooks-deps\n  );\n}\n\nvar Recoil_useRecoilTransaction = useRecoilTransaction;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nclass WrappedValue {\n  constructor(value) {\n    _defineProperty(this, \"value\", void 0);\n\n    this.value = value;\n  }\n\n}\n\nvar Recoil_Wrapper = {\n  WrappedValue\n};\nvar Recoil_Wrapper_1 = Recoil_Wrapper.WrappedValue;\nvar Recoil_Wrapper$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  WrappedValue: Recoil_Wrapper_1\n});\nconst {\n  isFastRefreshEnabled: isFastRefreshEnabled$2\n} = Recoil_ReactMode;\n\nclass ChangedPathError extends Error {}\n\nclass TreeCache {\n  // $FlowIssue[unclear-type]\n  constructor(options) {\n    var _options$onHit, _options$onSet, _options$mapNodeValue;\n\n    _defineProperty(this, \"_name\", void 0);\n\n    _defineProperty(this, \"_numLeafs\", void 0);\n\n    _defineProperty(this, \"_root\", void 0);\n\n    _defineProperty(this, \"_onHit\", void 0);\n\n    _defineProperty(this, \"_onSet\", void 0);\n\n    _defineProperty(this, \"_mapNodeValue\", void 0);\n\n    this._name = options === null || options === void 0 ? void 0 : options.name;\n    this._numLeafs = 0;\n    this._root = null;\n    this._onHit = (_options$onHit = options === null || options === void 0 ? void 0 : options.onHit) !== null && _options$onHit !== void 0 ? _options$onHit : () => {};\n    this._onSet = (_options$onSet = options === null || options === void 0 ? void 0 : options.onSet) !== null && _options$onSet !== void 0 ? _options$onSet : () => {};\n    this._mapNodeValue = (_options$mapNodeValue = options === null || options === void 0 ? void 0 : options.mapNodeValue) !== null && _options$mapNodeValue !== void 0 ? _options$mapNodeValue : val => val;\n  }\n\n  size() {\n    return this._numLeafs;\n  } // $FlowIssue[unclear-type]\n\n\n  root() {\n    return this._root;\n  }\n\n  get(getNodeValue, handlers) {\n    var _this$getLeafNode;\n\n    return (_this$getLeafNode = this.getLeafNode(getNodeValue, handlers)) === null || _this$getLeafNode === void 0 ? void 0 : _this$getLeafNode.value;\n  }\n\n  getLeafNode(getNodeValue, handlers) {\n    if (this._root == null) {\n      return undefined;\n    } // Iterate down the tree based on the current node values until we hit a leaf\n    // $FlowIssue[unclear-type]\n\n\n    let node = this._root;\n\n    while (node) {\n      handlers === null || handlers === void 0 ? void 0 : handlers.onNodeVisit(node);\n\n      if (node.type === 'leaf') {\n        this._onHit(node);\n\n        return node;\n      }\n\n      const nodeValue = this._mapNodeValue(getNodeValue(node.nodeKey));\n\n      node = node.branches.get(nodeValue);\n    }\n\n    return undefined;\n  }\n\n  set(route, value, handlers) {\n    const addLeaf = () => {\n      var _node2, _node3, _this$_root2, _handlers$onNodeVisit2; // First, setup the branch nodes for the route:\n      // Iterate down the tree to find or add branch nodes following the route\n\n\n      let node;\n      let branchKey;\n\n      for (const [nodeKey, nodeValue] of route) {\n        var _node, _handlers$onNodeVisit, _this$_root; // If the previous root was a leaf, while we not have a get(), it means\n        // the selector has inconsistent values or implementation changed.\n\n\n        const root = this._root;\n\n        if ((root === null || root === void 0 ? void 0 : root.type) === 'leaf') {\n          throw this.invalidCacheError();\n        } // node now refers to the next node down in the tree\n\n\n        const parent = node; // $FlowFixMe[prop-missing]\n        // $FlowFixMe[incompatible-type]\n\n        node = parent ? parent.branches.get(branchKey) : root; // $FlowFixMe[prop-missing]\n        // $FlowFixMe[incompatible-type]\n\n        node = (_node = node) !== null && _node !== void 0 ? _node : {\n          type: 'branch',\n          nodeKey,\n          parent,\n          branches: new Map(),\n          branchKey\n        }; // If we found an existing node, confirm it has a consistent value\n\n        if (node.type !== 'branch' || node.nodeKey !== nodeKey) {\n          throw this.invalidCacheError();\n        } // Add the branch node to the tree\n\n\n        parent === null || parent === void 0 ? void 0 : parent.branches.set(branchKey, node);\n        handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit = handlers.onNodeVisit) === null || _handlers$onNodeVisit === void 0 ? void 0 : _handlers$onNodeVisit.call(handlers, node); // Prepare for next iteration and install root if it is new.\n\n        branchKey = this._mapNodeValue(nodeValue);\n        this._root = (_this$_root = this._root) !== null && _this$_root !== void 0 ? _this$_root : node;\n      } // Second, setup the leaf node:\n      // If there is an existing leaf for this route confirm it is consistent\n\n\n      const oldLeaf = node ? (_node2 = node) === null || _node2 === void 0 ? void 0 : _node2.branches.get(branchKey) : this._root;\n\n      if (oldLeaf != null && (oldLeaf.type !== 'leaf' || oldLeaf.branchKey !== branchKey)) {\n        throw this.invalidCacheError();\n      } // Create a new or replacement leaf.\n\n\n      const leafNode = {\n        type: 'leaf',\n        value,\n        parent: node,\n        branchKey\n      }; // Install the leaf and call handlers\n\n      (_node3 = node) === null || _node3 === void 0 ? void 0 : _node3.branches.set(branchKey, leafNode);\n      this._root = (_this$_root2 = this._root) !== null && _this$_root2 !== void 0 ? _this$_root2 : leafNode;\n      this._numLeafs++;\n\n      this._onSet(leafNode);\n\n      handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit2 = handlers.onNodeVisit) === null || _handlers$onNodeVisit2 === void 0 ? void 0 : _handlers$onNodeVisit2.call(handlers, leafNode);\n    };\n\n    try {\n      addLeaf();\n    } catch (error) {\n      // If the cache was stale or observed inconsistent values, such as with\n      // Fast Refresh, then clear it and rebuild with the new values.\n      if (error instanceof ChangedPathError) {\n        this.clear();\n        addLeaf();\n      } else {\n        throw error;\n      }\n    }\n  } // Returns true if leaf was actually deleted from the tree\n\n\n  delete(leaf) {\n    const root = this.root();\n\n    if (!root) {\n      return false;\n    }\n\n    if (leaf === root) {\n      this._root = null;\n      this._numLeafs = 0;\n      return true;\n    } // Iterate up from the leaf deleteing it from it's parent's branches.\n\n\n    let node = leaf.parent;\n    let branchKey = leaf.branchKey;\n\n    while (node) {\n      var _node4;\n\n      node.branches.delete(branchKey); // Stop iterating if we hit the root.\n\n      if (node === root) {\n        if (node.branches.size === 0) {\n          this._root = null;\n          this._numLeafs = 0;\n        } else {\n          this._numLeafs--;\n        }\n\n        return true;\n      } // Stop iterating if there are other branches since we don't need to\n      // remove any more nodes.\n\n\n      if (node.branches.size > 0) {\n        break;\n      } // Iterate up to our parent\n\n\n      branchKey = (_node4 = node) === null || _node4 === void 0 ? void 0 : _node4.branchKey;\n      node = node.parent;\n    } // Confirm that the leaf we are deleting is actually attached to our tree\n\n\n    for (; node !== root; node = node.parent) {\n      if (node == null) {\n        return false;\n      }\n    }\n\n    this._numLeafs--;\n    return true;\n  }\n\n  clear() {\n    this._numLeafs = 0;\n    this._root = null;\n  }\n\n  invalidCacheError() {\n    const CHANGED_PATH_ERROR_MESSAGE = isFastRefreshEnabled$2() ? 'Possible Fast Refresh module reload detected.  ' + 'This may also be caused by an selector returning inconsistent values. ' + 'Resetting cache.' : 'Invalid cache values.  This happens when selectors do not return ' + 'consistent values for the same input dependency values.  That may also ' + 'be caused when using Fast Refresh to change a selector implementation.  ' + 'Resetting cache.';\n    Recoil_recoverableViolation(CHANGED_PATH_ERROR_MESSAGE + (this._name != null ? ` - ${this._name}` : ''));\n    throw new ChangedPathError();\n  }\n\n}\n\nvar Recoil_TreeCache = {\n  TreeCache\n};\nvar Recoil_TreeCache_1 = Recoil_TreeCache.TreeCache;\nvar Recoil_TreeCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  TreeCache: Recoil_TreeCache_1\n});\n\nclass LRUCache {\n  constructor(options) {\n    var _options$mapKey;\n\n    _defineProperty(this, \"_maxSize\", void 0);\n\n    _defineProperty(this, \"_size\", void 0);\n\n    _defineProperty(this, \"_head\", void 0);\n\n    _defineProperty(this, \"_tail\", void 0);\n\n    _defineProperty(this, \"_map\", void 0);\n\n    _defineProperty(this, \"_keyMapper\", void 0);\n\n    this._maxSize = options.maxSize;\n    this._size = 0;\n    this._head = null;\n    this._tail = null;\n    this._map = new Map();\n    this._keyMapper = (_options$mapKey = options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : v => v;\n  }\n\n  head() {\n    return this._head;\n  }\n\n  tail() {\n    return this._tail;\n  }\n\n  size() {\n    return this._size;\n  }\n\n  maxSize() {\n    return this._maxSize;\n  }\n\n  has(key) {\n    return this._map.has(this._keyMapper(key));\n  }\n\n  get(key) {\n    const mappedKey = this._keyMapper(key);\n\n    const node = this._map.get(mappedKey);\n\n    if (!node) {\n      return undefined;\n    }\n\n    this.set(key, node.value);\n    return node.value;\n  }\n\n  set(key, val) {\n    const mappedKey = this._keyMapper(key);\n\n    const existingNode = this._map.get(mappedKey);\n\n    if (existingNode) {\n      this.delete(key);\n    }\n\n    const head = this.head();\n    const node = {\n      key,\n      right: head,\n      left: null,\n      value: val\n    };\n\n    if (head) {\n      head.left = node;\n    } else {\n      this._tail = node;\n    }\n\n    this._map.set(mappedKey, node);\n\n    this._head = node;\n    this._size++;\n\n    this._maybeDeleteLRU();\n  }\n\n  _maybeDeleteLRU() {\n    if (this.size() > this.maxSize()) {\n      this.deleteLru();\n    }\n  }\n\n  deleteLru() {\n    const tail = this.tail();\n\n    if (tail) {\n      this.delete(tail.key);\n    }\n  }\n\n  delete(key) {\n    const mappedKey = this._keyMapper(key);\n\n    if (!this._size || !this._map.has(mappedKey)) {\n      return;\n    }\n\n    const node = Recoil_nullthrows(this._map.get(mappedKey));\n    const right = node.right;\n    const left = node.left;\n\n    if (right) {\n      right.left = node.left;\n    }\n\n    if (left) {\n      left.right = node.right;\n    }\n\n    if (node === this.head()) {\n      this._head = right;\n    }\n\n    if (node === this.tail()) {\n      this._tail = left;\n    }\n\n    this._map.delete(mappedKey);\n\n    this._size--;\n  }\n\n  clear() {\n    this._size = 0;\n    this._head = null;\n    this._tail = null;\n    this._map = new Map();\n  }\n\n}\n\nvar Recoil_LRUCache = {\n  LRUCache\n};\nvar Recoil_LRUCache_1 = Recoil_LRUCache.LRUCache;\nvar Recoil_LRUCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  LRUCache: Recoil_LRUCache_1\n});\nconst {\n  LRUCache: LRUCache$1\n} = Recoil_LRUCache$1;\nconst {\n  TreeCache: TreeCache$1\n} = Recoil_TreeCache$1;\n\nfunction treeCacheLRU({\n  name,\n  maxSize,\n  mapNodeValue = v => v\n}) {\n  const lruCache = new LRUCache$1({\n    maxSize\n  });\n  const cache = new TreeCache$1({\n    name,\n    mapNodeValue,\n    onHit: node => {\n      lruCache.set(node, true);\n    },\n    onSet: node => {\n      const lruNode = lruCache.tail();\n      lruCache.set(node, true);\n\n      if (lruNode && cache.size() > maxSize) {\n        cache.delete(lruNode.key);\n      }\n    }\n  });\n  return cache;\n}\n\nvar Recoil_treeCacheLRU = treeCacheLRU;\nconst TIME_WARNING_THRESHOLD_MS = 15;\n\nfunction stringify(x, opt, key) {\n  // A optimization to avoid the more expensive JSON.stringify() for simple strings\n  // This may lose protection for u2028 and u2029, though.\n  if (typeof x === 'string' && !x.includes('\"') && !x.includes('\\\\')) {\n    return `\"${x}\"`;\n  } // Handle primitive types\n\n\n  switch (typeof x) {\n    case 'undefined':\n      return '';\n    // JSON.stringify(undefined) returns undefined, but we always want to return a string\n\n    case 'boolean':\n      return x ? 'true' : 'false';\n\n    case 'number':\n    case 'symbol':\n      // case 'bigint': // BigInt is not supported in www\n      return String(x);\n\n    case 'string':\n      // Add surrounding quotes and escape internal quotes\n      return JSON.stringify(x);\n\n    case 'function':\n      if ((opt === null || opt === void 0 ? void 0 : opt.allowFunctions) !== true) {\n        throw Recoil_err('Attempt to serialize function in a Recoil cache key');\n      }\n\n      return `__FUNCTION(${x.name})__`;\n  }\n\n  if (x === null) {\n    return 'null';\n  } // Fallback case for unknown types\n\n\n  if (typeof x !== 'object') {\n    var _JSON$stringify;\n\n    return (_JSON$stringify = JSON.stringify(x)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : '';\n  } // Deal with all promises as equivalent for now.\n\n\n  if (Recoil_isPromise(x)) {\n    return '__PROMISE__';\n  } // Arrays handle recursive stringification\n\n\n  if (Array.isArray(x)) {\n    return `[${x.map((v, i) => stringify(v, opt, i.toString()))}]`;\n  } // If an object defines a toJSON() method, then use that to override the\n  // serialization.  This matches the behavior of JSON.stringify().\n  // Pass the key for compatibility.\n  // Immutable.js collections define this method to allow us to serialize them.\n\n\n  if (typeof x.toJSON === 'function') {\n    // flowlint-next-line unclear-type: off\n    return stringify(x.toJSON(key), opt, key);\n  } // For built-in Maps, sort the keys in a stable order instead of the\n  // default insertion order.  Support non-string keys.\n\n\n  if (x instanceof Map) {\n    const obj = {};\n\n    for (const [k, v] of x) {\n      // Stringify will escape any nested quotes\n      obj[typeof k === 'string' ? k : stringify(k, opt)] = v;\n    }\n\n    return stringify(obj, opt, key);\n  } // For built-in Sets, sort the keys in a stable order instead of the\n  // default insertion order.\n\n\n  if (x instanceof Set) {\n    return stringify(Array.from(x).sort((a, b) => stringify(a, opt).localeCompare(stringify(b, opt))), opt, key);\n  } // Anything else that is iterable serialize as an Array.\n\n\n  if (Symbol !== undefined && x[Symbol.iterator] != null && typeof x[Symbol.iterator] === 'function') {\n    // flowlint-next-line unclear-type: off\n    return stringify(Array.from(x), opt, key);\n  } // For all other Objects, sort the keys in a stable order.\n\n\n  return `{${Object.keys(x).filter(k => x[k] !== undefined).sort() // stringify the key to add quotes and escape any nested slashes or quotes.\n  .map(k => `${stringify(k, opt)}:${stringify(x[k], opt, k)}`).join(',')}}`;\n} // Utility similar to JSON.stringify() except:\n// * Serialize built-in Sets as an Array\n// * Serialize built-in Maps as an Object.  Supports non-string keys.\n// * Serialize other iterables as arrays\n// * Sort the keys of Objects and Maps to have a stable order based on string conversion.\n//    This overrides their default insertion order.\n// * Still uses toJSON() of any object to override serialization\n// * Support Symbols (though don't guarantee uniqueness)\n// * We could support BigInt, but Flow doesn't seem to like it.\n// See Recoil_stableStringify-test.js for examples\n\n\nfunction stableStringify(x, opt = {\n  allowFunctions: false\n}) {\n  if (true) {\n    if (typeof window !== 'undefined') {\n      const startTime = window.performance ? window.performance.now() : 0;\n      const str = stringify(x, opt);\n      const endTime = window.performance ? window.performance.now() : 0;\n\n      if (endTime - startTime > TIME_WARNING_THRESHOLD_MS) {\n        /* eslint-disable fb-www/no-console */\n        console.groupCollapsed(`Recoil: Spent ${endTime - startTime}ms computing a cache key`);\n        console.warn(x, str);\n        console.groupEnd();\n        /* eslint-enable fb-www/no-console */\n      }\n\n      return str;\n    }\n  }\n\n  return stringify(x, opt);\n}\n\nvar Recoil_stableStringify = stableStringify;\nconst {\n  TreeCache: TreeCache$2\n} = Recoil_TreeCache$1;\nconst defaultPolicy = {\n  equality: 'reference',\n  eviction: 'keep-all',\n  maxSize: Infinity\n};\n\nfunction treeCacheFromPolicy({\n  equality = defaultPolicy.equality,\n  eviction = defaultPolicy.eviction,\n  maxSize = defaultPolicy.maxSize\n} = defaultPolicy, name) {\n  const valueMapper = getValueMapper(equality);\n  return getTreeCache(eviction, maxSize, valueMapper, name);\n}\n\nfunction getValueMapper(equality) {\n  switch (equality) {\n    case 'reference':\n      return val => val;\n\n    case 'value':\n      return val => Recoil_stableStringify(val);\n  }\n\n  throw Recoil_err(`Unrecognized equality policy ${equality}`);\n}\n\nfunction getTreeCache(eviction, maxSize, mapNodeValue, name) {\n  switch (eviction) {\n    case 'keep-all':\n      return new TreeCache$2({\n        name,\n        mapNodeValue\n      });\n\n    case 'lru':\n      return Recoil_treeCacheLRU({\n        name,\n        maxSize: Recoil_nullthrows(maxSize),\n        mapNodeValue\n      });\n\n    case 'most-recent':\n      return Recoil_treeCacheLRU({\n        name,\n        maxSize: 1,\n        mapNodeValue\n      });\n  }\n\n  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);\n}\n\nvar Recoil_treeCacheFromPolicy = treeCacheFromPolicy;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction isNode(object) {\n  var _ownerDocument, _doc$defaultView;\n\n  if (typeof window === 'undefined') {\n    return false;\n  }\n\n  const doc = object != null ? (_ownerDocument = object.ownerDocument) !== null && _ownerDocument !== void 0 ? _ownerDocument : object : document;\n  const defaultView = (_doc$defaultView = doc.defaultView) !== null && _doc$defaultView !== void 0 ? _doc$defaultView : window;\n  return !!(object != null && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));\n}\n\nvar Recoil_isNode = isNode;\nconst {\n  isReactNative: isReactNative$1,\n  isWindow: isWindow$1\n} = Recoil_Environment;\n\nfunction shouldNotBeFrozen(value) {\n  // Primitives and functions:\n  if (value === null || typeof value !== 'object') {\n    return true;\n  } // React elements:\n\n\n  switch (typeof value.$$typeof) {\n    case 'symbol':\n      return true;\n\n    case 'number':\n      return true;\n  } // Immutable structures:\n\n\n  if (value['@@__IMMUTABLE_ITERABLE__@@'] != null || value['@@__IMMUTABLE_KEYED__@@'] != null || value['@@__IMMUTABLE_INDEXED__@@'] != null || value['@@__IMMUTABLE_ORDERED__@@'] != null || value['@@__IMMUTABLE_RECORD__@@'] != null) {\n    return true;\n  } // DOM nodes:\n\n\n  if (Recoil_isNode(value)) {\n    return true;\n  }\n\n  if (Recoil_isPromise(value)) {\n    return true;\n  }\n\n  if (value instanceof Error) {\n    return true;\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return true;\n  } // Some environments, just as Jest, don't work with the instanceof check\n\n\n  if (!isReactNative$1 && isWindow$1(value)) {\n    return true;\n  }\n\n  return false;\n} // Recursively freeze a value to enforce it is read-only.\n// This may also have minimal performance improvements for enumerating\n// objects (based on browser implementations, of course)\n\n\nfunction deepFreezeValue(value) {\n  if (typeof value !== 'object' || shouldNotBeFrozen(value)) {\n    return;\n  }\n\n  Object.freeze(value); // Make all properties read-only\n\n  for (const key in value) {\n    // $FlowIssue[method-unbinding] added when improving typing for this parameters\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      const prop = value[key]; // Prevent infinite recurssion for circular references.\n\n      if (typeof prop === 'object' && prop != null && !Object.isFrozen(prop)) {\n        deepFreezeValue(prop);\n      }\n    }\n  }\n\n  Object.seal(value); // This also makes existing properties non-configurable.\n}\n\nvar Recoil_deepFreezeValue = deepFreezeValue;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * This is a stub for some integration into FB internal stuff\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction startPerfBlock(_id) {\n  return () => null;\n}\n\nvar Recoil_PerformanceTimings = {\n  startPerfBlock\n};\nconst {\n  isLoadable: isLoadable$1,\n  loadableWithError: loadableWithError$1,\n  loadableWithPromise: loadableWithPromise$1,\n  loadableWithValue: loadableWithValue$2\n} = Recoil_Loadable$1;\nconst {\n  WrappedValue: WrappedValue$1\n} = Recoil_Wrapper$1;\nconst {\n  getNodeLoadable: getNodeLoadable$2,\n  peekNodeLoadable: peekNodeLoadable$1,\n  setNodeValue: setNodeValue$3\n} = Recoil_FunctionalCore;\nconst {\n  saveDepsToStore: saveDepsToStore$1\n} = Recoil_Graph;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$6,\n  getConfigDeletionHandler: getConfigDeletionHandler$1,\n  getNode: getNode$6,\n  registerNode: registerNode$1\n} = Recoil_Node;\nconst {\n  isRecoilValue: isRecoilValue$3\n} = Recoil_RecoilValue$1;\nconst {\n  markRecoilValueModified: markRecoilValueModified$1\n} = Recoil_RecoilValueInterface;\nconst {\n  retainedByOptionWithDefault: retainedByOptionWithDefault$1\n} = Recoil_Retention;\nconst {\n  recoilCallback: recoilCallback$1\n} = Recoil_useRecoilCallback;\nconst {\n  startPerfBlock: startPerfBlock$1\n} = Recoil_PerformanceTimings;\n\nclass Canceled {}\n\nconst CANCELED = new Canceled();\n/**\r\n * An ExecutionID is an arbitrary ID that lets us distinguish executions from\r\n * each other. This is necessary as we need a way of solving this problem:\r\n * \"given 3 async executions, only update state for the 'latest' execution when\r\n * it finishes running regardless of when the other 2 finish\". ExecutionIDs\r\n * provide a convenient way of identifying executions so that we can track and\r\n * manage them over time.\r\n */\n\nconst dependencyStack = []; // for detecting circular dependencies.\n\nconst waitingStores = new Map();\n\nconst getNewExecutionID = (() => {\n  let executionID = 0;\n  return () => executionID++;\n})();\n/* eslint-disable no-redeclare */\n\n\nfunction selector(options) {\n  let recoilValue = null;\n  const {\n    key,\n    get,\n    cachePolicy_UNSTABLE: cachePolicy\n  } = options;\n  const set = options.set != null ? options.set : undefined; // flow\n\n  if (true) {\n    if (typeof key !== 'string') {\n      throw Recoil_err('A key option with a unique string value must be provided when creating a selector.');\n    }\n\n    if (typeof get !== 'function') {\n      throw Recoil_err('Selectors must specify a get callback option to get the selector value.');\n    }\n  } // This is every discovered dependency across all executions\n\n\n  const discoveredDependencyNodeKeys = new Set();\n  const cache = Recoil_treeCacheFromPolicy(cachePolicy !== null && cachePolicy !== void 0 ? cachePolicy : {\n    equality: 'reference',\n    eviction: 'keep-all'\n  }, key);\n  const retainedBy = retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE);\n  const executionInfoMap = new Map();\n  let liveStoresCount = 0;\n\n  function selectorIsLive() {\n    return !Recoil_gkx('recoil_memory_managament_2020') || liveStoresCount > 0;\n  }\n\n  function selectorInit(store) {\n    store.getState().knownSelectors.add(key);\n    liveStoresCount++;\n    return () => {\n      liveStoresCount--;\n    };\n  }\n\n  function selectorShouldDeleteConfigOnRelease() {\n    return getConfigDeletionHandler$1(key) !== undefined && !selectorIsLive();\n  }\n\n  function resolveAsync(store, state, executionID, loadable, depValues) {\n    setCache(state, loadable, depValues);\n    notifyStoresOfResolvedAsync(store, executionID);\n  }\n\n  function notifyStoresOfResolvedAsync(store, executionID) {\n    if (isLatestExecution(store, executionID)) {\n      clearExecutionInfo(store);\n    }\n\n    notifyWaitingStores(executionID, true);\n  }\n  /**\r\n   * Notify stores to pull the selector again if a new async dep was discovered.\r\n   * 1) Async selector adds a new dep but doesn't resolve yet.\r\n   *    Note that deps for an async selector are based on the state when the\r\n   *    evaluation started, in order to provide a consistent picture of state.\r\n   * 2) But, new value of dep based on the current state might cause the selector\r\n   *    to resolve or resolve differently.\r\n   * 3) Therefore, this notification will pull the selector based on the current\r\n   *    state for the components\r\n   */\n\n\n  function notifyStoresOfNewAsyncDep(store, executionID) {\n    if (isLatestExecution(store, executionID)) {\n      const executionInfo = Recoil_nullthrows(getExecutionInfo(store));\n      executionInfo.stateVersions.clear();\n      notifyWaitingStores(executionID, false);\n    }\n  }\n\n  function notifyWaitingStores(executionID, clearWaitlist) {\n    const stores = waitingStores.get(executionID);\n\n    if (stores != null) {\n      for (const waitingStore of stores) {\n        markRecoilValueModified$1(waitingStore, Recoil_nullthrows(recoilValue));\n      }\n\n      if (clearWaitlist) {\n        waitingStores.delete(executionID);\n      }\n    }\n  }\n\n  function markStoreWaitingForResolvedAsync(store, executionID) {\n    let stores = waitingStores.get(executionID);\n\n    if (stores == null) {\n      waitingStores.set(executionID, stores = new Set());\n    }\n\n    stores.add(store);\n  }\n  /**\r\n   * This function attaches a then() and a catch() to a promise that was\r\n   * returned from a selector's get() (either explicitly or implicitly by\r\n   * running a function that uses the \"async\" keyword). If a selector's get()\r\n   * returns a promise, we have two possibilities:\r\n   *\r\n   * 1. The promise will resolve, in which case it will have completely finished\r\n   *    executing without any remaining pending dependencies. No more retries\r\n   *    are needed and we can proceed with updating the cache and notifying\r\n   *    subscribers (if it is the latest execution, otherwise only the cache\r\n   *    will be updated and subscriptions will not be fired). This is the case\r\n   *    handled by the attached then() handler.\r\n   *\r\n   * 2. The promise will throw because it either has an error or it came across\r\n   *    an async dependency that has not yet resolved, in which case we will\r\n   *    call wrapDepdencyPromise(), whose responsibility is to handle dependency\r\n   *    promises. This case is handled by the attached catch() handler.\r\n   *\r\n   * Both branches will eventually resolve to the final result of the selector\r\n   * (or an error if a real error occurred).\r\n   *\r\n   * The execution will run to completion even if it is stale, and its value\r\n   * will be cached. But stale executions will not update global state or update\r\n   * executionInfo as that is the responsibility of the 'latest' execution.\r\n   *\r\n   * Note this function should not be passed a promise that was thrown--AKA a\r\n   * dependency promise. Dependency promises should be passed to\r\n   * wrapPendingDependencyPromise()).\r\n   */\n\n\n  function wrapResultPromise(store, promise, state, depValues, executionID, loadingDepsState) {\n    return promise.then(value => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      const loadable = loadableWithValue$2(value);\n      resolveAsync(store, state, executionID, loadable, depValues);\n      return value;\n    }).catch(errorOrPromise => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      if (Recoil_isPromise(errorOrPromise)) {\n        return wrapPendingDependencyPromise(store, errorOrPromise, state, depValues, executionID, loadingDepsState);\n      }\n\n      const loadable = loadableWithError$1(errorOrPromise);\n      resolveAsync(store, state, executionID, loadable, depValues);\n      throw errorOrPromise;\n    });\n  }\n  /**\r\n   * This function attaches a then() and a catch() to a promise that was\r\n   * thrown from a selector's get(). If a selector's get() throws a promise,\r\n   * we have two possibilities:\r\n   *\r\n   * 1. The promise will resolve, meaning one of our selector's dependencies is\r\n   *    now available and we should \"retry\" our get() by running it again. This\r\n   *    is the case handled by the attached then() handler.\r\n   *\r\n   * 2. The promise will throw because something went wrong with the dependency\r\n   *    promise (in other words a real error occurred). This case is handled by\r\n   *    the attached catch() handler. If the dependency promise throws, it is\r\n   *    _always_ a real error and not another dependency promise (any dependency\r\n   *    promises would have been handled upstream).\r\n   *\r\n   * The then() branch will eventually resolve to the final result of the\r\n   * selector (or an error if a real error occurs), and the catch() will always\r\n   * resolve to an error because the dependency promise is a promise that was\r\n   * wrapped upstream, meaning it will only resolve to its real value or to a\r\n   * real error.\r\n   *\r\n   * The execution will run to completion even if it is stale, and its value\r\n   * will be cached. But stale executions will not update global state or update\r\n   * executionInfo as that is the responsibility of the 'latest' execution.\r\n   *\r\n   * Note this function should not be passed a promise that was returned from\r\n   * get(). The intention is that this function is only passed promises that\r\n   * were thrown due to a pending dependency. Promises returned by get() should\r\n   * be passed to wrapResultPromise() instead.\r\n   */\n\n\n  function wrapPendingDependencyPromise(store, promise, state, existingDeps, executionID, loadingDepsState) {\n    return promise.then(resolvedDep => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      } // Check if we are handling a pending Recoil dependency or if the user\n      // threw their own Promise to \"suspend\" a selector evaluation.  We need\n      // to check that the loadingDepPromise actually matches the promise that\n      // we caught in case the selector happened to catch the promise we threw\n      // for a pending Recoil dependency from `getRecoilValue()` and threw\n      // their own promise instead.\n\n\n      if (loadingDepsState.loadingDepKey != null && loadingDepsState.loadingDepPromise === promise) {\n        /**\r\n         * Note for async atoms, this means we are changing the atom's value\r\n         * in the store for the given version. This should be alright because\r\n         * the version of state is now stale and a new version will have\r\n         * already been triggered by the atom being resolved (see this logic\r\n         * in Recoil_atom.js)\r\n         */\n        state.atomValues.set(loadingDepsState.loadingDepKey, loadableWithValue$2(resolvedDep));\n      } else {\n        /**\r\n         * If resolvedDepKey is not defined, the promise was a user-thrown\r\n         * promise. User-thrown promises are an advanced feature and they\r\n         * should be avoided in almost all cases. Using `loadable.map()` inside\r\n         * of selectors for loading loadables and then throwing that mapped\r\n         * loadable's promise is an example of a user-thrown promise.\r\n         *\r\n         * When we hit a user-thrown promise, we have to bail out of an optimization\r\n         * where we bypass calculating selector cache keys for selectors that\r\n         * have been previously seen for a given state (these selectors are saved in\r\n         * state.atomValues) to avoid stale state as we have no way of knowing\r\n         * what state changes happened (if any) in result to the promise resolving.\r\n         *\r\n         * Ideally we would only bail out selectors that are in the chain of\r\n         * dependencies for this selector, but there's currently no way to get\r\n         * a full list of a selector's downstream nodes because the state that\r\n         * is executing may be a discarded tree (so store.getGraph(state.version)\r\n         * will be empty), and the full dep tree may not be in the selector\r\n         * caches in the case where the selector's cache was cleared. To solve\r\n         * for this we would have to keep track of all running selector\r\n         * executions and their downstream deps. Because this only covers edge\r\n         * cases, that complexity might not be justifyable.\r\n         */\n        store.getState().knownSelectors.forEach(nodeKey => {\n          state.atomValues.delete(nodeKey);\n        });\n      }\n      /**\r\n       * Optimization: Now that the dependency has resolved, let's try hitting\r\n       * the cache in case the dep resolved to a value we have previously seen.\r\n       *\r\n       * TODO:\r\n       * Note this optimization is not perfect because it only prevents re-executions\r\n       * _after_ the point where an async dependency is found. Any code leading\r\n       * up to the async dependency may have run unnecessarily. The ideal case\r\n       * would be to wait for the async dependency to resolve first, check the\r\n       * cache, and prevent _any_ execution of the selector if the resulting\r\n       * value of the dependency leads to a path that is found in the cache.\r\n       * The ideal case is more difficult to implement as it would require that\r\n       * we capture and wait for the the async dependency right after checking\r\n       * the cache. The current approach takes advantage of the fact that running\r\n       * the selector already has a code path that lets us exit early when\r\n       * an async dep resolves.\r\n       */\n\n\n      const cachedLoadable = getLoadableFromCacheAndUpdateDeps(store, state);\n\n      if (cachedLoadable && cachedLoadable.state !== 'loading') {\n        /**\r\n         * This has to notify stores of a resolved async, even if there is no\r\n         * current pending execution for the following case:\r\n         * 1) A component renders with this pending loadable.\r\n         * 2) The upstream dependency resolves.\r\n         * 3) While processing some other selector it reads this one, such as\r\n         *    while traversing its dependencies.  At this point it gets the\r\n         *    new resolved value synchronously and clears the current\r\n         *    execution ID.  The component wasn't getting the value itself,\r\n         *    though, so it still has the pending loadable.\r\n         * 4) When this code executes the current execution id was cleared\r\n         *    and it wouldn't notify the component of the new value.\r\n         *\r\n         * I think this is only an issue with \"early\" rendering since the\r\n         * components got their value using the in-progress execution.\r\n         * We don't have a unit test for this case yet.  I'm not sure it is\r\n         * necessary with recoil_transition_support mode.\r\n         */\n        if (isLatestExecution(store, executionID) || getExecutionInfo(store) == null) {\n          notifyStoresOfResolvedAsync(store, executionID);\n        }\n\n        if (cachedLoadable.state === 'hasValue') {\n          return cachedLoadable.contents;\n        } else {\n          throw cachedLoadable.contents;\n        }\n      }\n      /**\r\n       * If this execution is stale, let's check to see if there is some in\r\n       * progress execution with a matching state. If we find a match, then\r\n       * we can take the value from that in-progress execution. Note this may\r\n       * sound like an edge case, but may be very common in cases where a\r\n       * loading dependency resolves from loading to having a value (thus\r\n       * possibly triggering a re-render), and React re-renders before the\r\n       * chained .then() functions run, thus starting a new execution as the\r\n       * dep has changed value. Without this check we will run the selector\r\n       * twice (once in the new execution and once again in this .then(), so\r\n       * this check is necessary to keep unnecessary re-executions to a\r\n       * minimum).\r\n       *\r\n       * Also note this code does not check across all executions that may be\r\n       * running. It only optimizes for the _latest_ execution per store as\r\n       * we currently do not maintain a list of all currently running executions.\r\n       * This means in some cases we may run selectors more than strictly\r\n       * necessary when there are multiple executions running for the same\r\n       * selector. This may be a valid tradeoff as checking for dep changes\r\n       * across all in-progress executions may take longer than just\r\n       * re-running the selector. This will be app-dependent, and maybe in the\r\n       * future we can make the behavior configurable. An ideal fix may be\r\n       * to extend the tree cache to support caching loading states.\r\n       */\n\n\n      if (!isLatestExecution(store, executionID)) {\n        const executionInfo = getInProgressExecutionInfo(store, state);\n\n        if (executionInfo != null) {\n          /**\r\n           * Returning promise here without wrapping as the wrapper logic was\r\n           * already done upstream when this promise was generated.\r\n           */\n          return executionInfo.loadingLoadable.contents;\n        }\n      } // Retry the selector evaluation now that the dependency has resolved\n\n\n      const [loadable, depValues] = evaluateSelectorGetter(store, state, executionID);\n\n      if (loadable.state !== 'loading') {\n        resolveAsync(store, state, executionID, loadable, depValues);\n      }\n\n      if (loadable.state === 'hasError') {\n        throw loadable.contents;\n      }\n\n      return loadable.contents;\n    }).catch(error => {\n      // The selector was released since the request began; ignore the response.\n      if (error instanceof Canceled) {\n        throw CANCELED;\n      }\n\n      if (!selectorIsLive()) {\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      const loadable = loadableWithError$1(error);\n      resolveAsync(store, state, executionID, loadable, existingDeps);\n      throw error;\n    });\n  }\n\n  function updateDeps(store, state, deps, executionID) {\n    var _store$getState, _store$getState$curre, _store$getState2, _store$getState2$next;\n\n    if (isLatestExecution(store, executionID) || state.version === ((_store$getState = store.getState()) === null || _store$getState === void 0 ? void 0 : (_store$getState$curre = _store$getState.currentTree) === null || _store$getState$curre === void 0 ? void 0 : _store$getState$curre.version) || state.version === ((_store$getState2 = store.getState()) === null || _store$getState2 === void 0 ? void 0 : (_store$getState2$next = _store$getState2.nextTree) === null || _store$getState2$next === void 0 ? void 0 : _store$getState2$next.version)) {\n      var _store$getState$nextT, _store$getState3, _store$getState3$next;\n\n      saveDepsToStore$1(key, deps, store, (_store$getState$nextT = (_store$getState3 = store.getState()) === null || _store$getState3 === void 0 ? void 0 : (_store$getState3$next = _store$getState3.nextTree) === null || _store$getState3$next === void 0 ? void 0 : _store$getState3$next.version) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree.version);\n    }\n\n    for (const nodeKey of deps) {\n      discoveredDependencyNodeKeys.add(nodeKey);\n    }\n  }\n\n  function evaluateSelectorGetter(store, state, executionID) {\n    const endPerfBlock = startPerfBlock$1(key); // TODO T63965866: use execution ID here\n\n    let duringSynchronousExecution = true;\n    let duringAsynchronousExecution = true;\n\n    const finishEvaluation = () => {\n      endPerfBlock();\n      duringAsynchronousExecution = false;\n    };\n\n    let result;\n    let resultIsError = false;\n    let loadable;\n    const loadingDepsState = {\n      loadingDepKey: null,\n      loadingDepPromise: null\n    };\n    /**\r\n     * Starting a fresh set of deps that we'll be using to update state. We're\r\n     * starting a new set versus adding it in existing state deps because\r\n     * the version of state that we update deps for may be a more recent version\r\n     * than the version the selector was called with. This is because the latest\r\n     * execution will update the deps of the current/latest version of state\r\n     * (This is safe to do because the fact that the selector is the latest\r\n     * execution means the deps we discover below are our best guess at the\r\n     * deps for the current/latest state in the store)\r\n     */\n\n    const depValues = new Map();\n\n    function getRecoilValue({\n      key: depKey\n    }) {\n      const depLoadable = getNodeLoadable$2(store, state, depKey);\n      depValues.set(depKey, depLoadable); // We need to update asynchronous dependencies as we go so the selector\n      // knows if it has to restart evaluation if one of them is updated before\n      // the asynchronous selector completely resolves.\n\n      if (!duringSynchronousExecution) {\n        updateDeps(store, state, new Set(depValues.keys()), executionID);\n        notifyStoresOfNewAsyncDep(store, executionID);\n      }\n\n      switch (depLoadable.state) {\n        case 'hasValue':\n          return depLoadable.contents;\n\n        case 'hasError':\n          throw depLoadable.contents;\n\n        case 'loading':\n          loadingDepsState.loadingDepKey = depKey;\n          loadingDepsState.loadingDepPromise = depLoadable.contents;\n          throw depLoadable.contents;\n      }\n\n      throw Recoil_err('Invalid Loadable state');\n    }\n\n    const getCallback = fn => {\n      return (...args) => {\n        if (duringAsynchronousExecution) {\n          throw Recoil_err('Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.');\n        }\n\n        !(recoilValue != null) ?  true ? Recoil_invariant(false, 'Recoil Value can never be null') : 0 : void 0;\n        return recoilCallback$1(store, fn, args, {\n          node: recoilValue\n        } // flowlint-line unclear-type:off\n        );\n      };\n    };\n\n    try {\n      result = get({\n        get: getRecoilValue,\n        getCallback\n      });\n      result = isRecoilValue$3(result) ? getRecoilValue(result) : result;\n\n      if (isLoadable$1(result)) {\n        if (result.state === 'hasError') {\n          resultIsError = true;\n        }\n\n        result = result.contents;\n      }\n\n      if (Recoil_isPromise(result)) {\n        result = wrapResultPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);\n      } else {\n        finishEvaluation();\n      }\n\n      result = result instanceof WrappedValue$1 ? result.value : result;\n    } catch (errorOrDepPromise) {\n      result = errorOrDepPromise;\n\n      if (Recoil_isPromise(result)) {\n        result = wrapPendingDependencyPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);\n      } else {\n        resultIsError = true;\n        finishEvaluation();\n      }\n    }\n\n    if (resultIsError) {\n      loadable = loadableWithError$1(result);\n    } else if (Recoil_isPromise(result)) {\n      loadable = loadableWithPromise$1(result);\n    } else {\n      loadable = loadableWithValue$2(result);\n    }\n\n    duringSynchronousExecution = false;\n    updateExecutionInfoDepValues(store, executionID, depValues);\n    updateDeps(store, state, new Set(depValues.keys()), executionID);\n    return [loadable, depValues];\n  }\n\n  function getLoadableFromCacheAndUpdateDeps(store, state) {\n    // First, look up in the state cache\n    // If it's here, then the deps in the store should already be valid.\n    let cachedLoadable = state.atomValues.get(key);\n\n    if (cachedLoadable != null) {\n      return cachedLoadable;\n    } // Second, look up in the selector cache and update the deps in the store\n\n\n    const depsAfterCacheLookup = new Set();\n\n    try {\n      cachedLoadable = cache.get(nodeKey => {\n        !(typeof nodeKey === 'string') ?  true ? Recoil_invariant(false, 'Cache nodeKey is type string') : 0 : void 0;\n        return getNodeLoadable$2(store, state, nodeKey).contents;\n      }, {\n        onNodeVisit: node => {\n          if (node.type === 'branch' && node.nodeKey !== key) {\n            depsAfterCacheLookup.add(node.nodeKey);\n          }\n        }\n      });\n    } catch (error) {\n      throw Recoil_err(`Problem with cache lookup for selector \"${key}\": ${error.message}`);\n    }\n\n    if (cachedLoadable) {\n      var _getExecutionInfo; // Cache the results in the state to allow for cheaper lookup than\n      // iterating the tree cache of dependencies.\n\n\n      state.atomValues.set(key, cachedLoadable);\n      /**\r\n       * Ensure store contains correct dependencies if we hit the cache so that\r\n       * the store deps and cache are in sync for a given state. This is important\r\n       * because store deps are normally updated when new executions are created,\r\n       * but cache hits don't trigger new executions but they still _may_ signify\r\n       * a change in deps in the store if the store deps for this state are empty\r\n       * or stale.\r\n       */\n\n      updateDeps(store, state, depsAfterCacheLookup, (_getExecutionInfo = getExecutionInfo(store)) === null || _getExecutionInfo === void 0 ? void 0 : _getExecutionInfo.executionID);\n    }\n\n    return cachedLoadable;\n  }\n  /**\r\n   * Given a tree state, this function returns a Loadable of the current state.\r\n   *\r\n   * The selector's get() function will only be re-evaluated if _both_ of the\r\n   * following statements are true:\r\n   *\r\n   * 1. The current dep values from the given state produced a cache key that\r\n   *    was not found in the cache.\r\n   * 2. There is no currently running async execution OR there is an\r\n   *    async execution that is running, but after comparing the dep values in\r\n   *    the given state with the dep values that the execution has discovered so\r\n   *    far we find that at least one dep value has changed, in which case we\r\n   *    start a new execution (the previously running execution will continue to\r\n   *    run to completion, but only the new execution will be deemed the\r\n   *    'latest' execution, meaning it will be the only execution that will\r\n   *    update global state when it is finished. Any non-latest executions will\r\n   *    run to completion and update the selector cache but not global state).\r\n   */\n\n\n  function getSelectorLoadableAndUpdateDeps(store, state) {\n    // First, see if our current state is cached\n    const cachedVal = getLoadableFromCacheAndUpdateDeps(store, state);\n\n    if (cachedVal != null) {\n      clearExecutionInfo(store);\n      return cachedVal;\n    } // Second, check if there is already an ongoing execution based on the current state\n\n\n    const inProgressExecutionInfo = getInProgressExecutionInfo(store, state);\n\n    if (inProgressExecutionInfo != null) {\n      var _inProgressExecutionI;\n\n      if (((_inProgressExecutionI = inProgressExecutionInfo.loadingLoadable) === null || _inProgressExecutionI === void 0 ? void 0 : _inProgressExecutionI.state) === 'loading') {\n        markStoreWaitingForResolvedAsync(store, inProgressExecutionInfo.executionID);\n      } // FIXME: check after the fact to see if we made the right choice by waiting\n\n\n      return inProgressExecutionInfo.loadingLoadable;\n    } // Third, start a new evaluation of the selector\n\n\n    const newExecutionID = getNewExecutionID();\n    const [loadable, newDepValues] = evaluateSelectorGetter(store, state, newExecutionID);\n    /**\r\n     * Conditionally updates the cache with a given loadable.\r\n     *\r\n     * We only cache loadables that are not loading because our cache keys are\r\n     * based on dep values, which are in an unfinished state for loadables that\r\n     * have a 'loading' state (new deps may be discovered while the selector\r\n     * runs its async code). We never want to cache partial dependencies b/c it\r\n     * could lead to errors, such as prematurely returning the result based on a\r\n     * partial list of deps-- we need the full list of deps to ensure that we\r\n     * are returning the correct result from cache.\r\n     */\n\n    if (loadable.state === 'loading') {\n      setExecutionInfo(store, newExecutionID, loadable, newDepValues, state);\n      markStoreWaitingForResolvedAsync(store, newExecutionID);\n    } else {\n      clearExecutionInfo(store);\n      setCache(state, loadable, newDepValues);\n    }\n\n    return loadable;\n  }\n  /**\r\n   * Searches execution info across all stores to see if there is an in-progress\r\n   * execution whose dependency values match the values of the requesting store.\r\n   */\n\n\n  function getInProgressExecutionInfo(store, state) {\n    // Sort the pending executions so that our current store is checked first.\n    const pendingExecutions = Recoil_concatIterables([executionInfoMap.has(store) ? [Recoil_nullthrows(executionInfoMap.get(store))] : [], Recoil_mapIterable(Recoil_filterIterable(executionInfoMap, ([s]) => s !== store), ([, execInfo]) => execInfo)]);\n\n    function anyDepChanged(execDepValues) {\n      for (const [depKey, execLoadable] of execDepValues) {\n        if (!getNodeLoadable$2(store, state, depKey).is(execLoadable)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    for (const execInfo of pendingExecutions) {\n      if ( // If this execution was already checked to be valid with this version\n      // of state, then let's use it!\n      execInfo.stateVersions.get(state.version) || // If the deps for the execution match our current state, then it's valid\n      !anyDepChanged(execInfo.depValuesDiscoveredSoFarDuringAsyncWork)) {\n        execInfo.stateVersions.set(state.version, true);\n        return execInfo;\n      } else {\n        execInfo.stateVersions.set(state.version, false);\n      }\n    }\n\n    return undefined;\n  }\n\n  function getExecutionInfo(store) {\n    return executionInfoMap.get(store);\n  }\n  /**\r\n   * This function will update the selector's execution info when the selector\r\n   * has either finished running an execution or has started a new execution. If\r\n   * the given loadable is in a 'loading' state, the intention is that a new\r\n   * execution has started. Otherwise, the intention is that an execution has\r\n   * just finished.\r\n   */\n\n\n  function setExecutionInfo(store, newExecutionID, loadable, depValues, state) {\n    executionInfoMap.set(store, {\n      depValuesDiscoveredSoFarDuringAsyncWork: depValues,\n      executionID: newExecutionID,\n      loadingLoadable: loadable,\n      stateVersions: new Map([[state.version, true]])\n    });\n  }\n\n  function updateExecutionInfoDepValues(store, executionID, depValues) {\n    // We only need to bother updating the deps for the latest execution because\n    // that's all getInProgressExecutionInfo() will be looking for.\n    if (isLatestExecution(store, executionID)) {\n      const executionInfo = getExecutionInfo(store);\n\n      if (executionInfo != null) {\n        executionInfo.depValuesDiscoveredSoFarDuringAsyncWork = depValues;\n      }\n    }\n  }\n\n  function clearExecutionInfo(store) {\n    executionInfoMap.delete(store);\n  }\n\n  function isLatestExecution(store, executionID) {\n    var _getExecutionInfo2;\n\n    return executionID === ((_getExecutionInfo2 = getExecutionInfo(store)) === null || _getExecutionInfo2 === void 0 ? void 0 : _getExecutionInfo2.executionID);\n  }\n  /**\r\n   * FIXME: dep keys should take into account the state of the loadable to\r\n   * prevent the edge case where a loadable with an error and a loadable with\r\n   * an error as a value are treated as the same thing incorrectly. For example\r\n   * these two should be treated differently:\r\n   *\r\n   * selector({key: '', get: () => new Error('hi')});\r\n   * selector({key: '', get () => {throw new Error('hi')}});\r\n   *\r\n   * With current implementation they are treated the same\r\n   */\n\n\n  function depValuesToDepRoute(depValues) {\n    return Array.from(depValues.entries()).map(([depKey, valLoadable]) => [depKey, valLoadable.contents]);\n  }\n\n  function setCache(state, loadable, depValues) {\n    if (true) {\n      if (loadable.state !== 'loading' && Boolean(options.dangerouslyAllowMutability) === false) {\n        Recoil_deepFreezeValue(loadable.contents);\n      }\n    }\n\n    state.atomValues.set(key, loadable);\n\n    try {\n      cache.set(depValuesToDepRoute(depValues), loadable);\n    } catch (error) {\n      throw Recoil_err(`Problem with setting cache for selector \"${key}\": ${error.message}`);\n    }\n  }\n\n  function detectCircularDependencies(fn) {\n    if (dependencyStack.includes(key)) {\n      const message = `Recoil selector has circular dependencies: ${dependencyStack.slice(dependencyStack.indexOf(key)).join(' \\u2192 ')}`;\n      return loadableWithError$1(Recoil_err(message));\n    }\n\n    dependencyStack.push(key);\n\n    try {\n      return fn();\n    } finally {\n      dependencyStack.pop();\n    }\n  }\n\n  function selectorPeek(store, state) {\n    const cachedLoadable = state.atomValues.get(key);\n\n    if (cachedLoadable != null) {\n      return cachedLoadable;\n    }\n\n    return cache.get(nodeKey => {\n      var _peekNodeLoadable;\n\n      !(typeof nodeKey === 'string') ?  true ? Recoil_invariant(false, 'Cache nodeKey is type string') : 0 : void 0;\n      return (_peekNodeLoadable = peekNodeLoadable$1(store, state, nodeKey)) === null || _peekNodeLoadable === void 0 ? void 0 : _peekNodeLoadable.contents;\n    });\n  }\n\n  function selectorGet(store, state) {\n    return detectCircularDependencies(() => getSelectorLoadableAndUpdateDeps(store, state));\n  }\n\n  function invalidateSelector(state) {\n    state.atomValues.delete(key);\n  }\n\n  function clearSelectorCache(store, treeState) {\n    !(recoilValue != null) ?  true ? Recoil_invariant(false, 'Recoil Value can never be null') : 0 : void 0;\n\n    for (const nodeKey of discoveredDependencyNodeKeys) {\n      var _node$clearCache;\n\n      const node = getNode$6(nodeKey);\n      (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, treeState);\n    }\n\n    discoveredDependencyNodeKeys.clear();\n    invalidateSelector(treeState);\n    cache.clear();\n    markRecoilValueModified$1(store, recoilValue);\n  }\n\n  if (set != null) {\n    /**\r\n     * ES5 strict mode prohibits defining non-top-level function declarations,\r\n     * so don't use function declaration syntax here\r\n     */\n    const selectorSet = (store, state, newValue) => {\n      let syncSelectorSetFinished = false;\n      const writes = new Map();\n\n      function getRecoilValue({\n        key: depKey\n      }) {\n        if (syncSelectorSetFinished) {\n          throw Recoil_err('Recoil: Async selector sets are not currently supported.');\n        }\n\n        const loadable = getNodeLoadable$2(store, state, depKey);\n\n        if (loadable.state === 'hasValue') {\n          return loadable.contents;\n        } else if (loadable.state === 'loading') {\n          const msg = `Getting value of asynchronous atom or selector \"${depKey}\" in a pending state while setting selector \"${key}\" is not yet supported.`;\n          Recoil_recoverableViolation(msg);\n          throw Recoil_err(msg);\n        } else {\n          throw loadable.contents;\n        }\n      }\n\n      function setRecoilState(recoilState, valueOrUpdater) {\n        if (syncSelectorSetFinished) {\n          const msg = 'Recoil: Async selector sets are not currently supported.';\n          Recoil_recoverableViolation(msg);\n          throw Recoil_err(msg);\n        }\n\n        const setValue = typeof valueOrUpdater === 'function' ? // cast to any because we can't restrict type S from being a function itself without losing support for opaque types\n        // flowlint-next-line unclear-type:off\n        valueOrUpdater(getRecoilValue(recoilState)) : valueOrUpdater;\n        const upstreamWrites = setNodeValue$3(store, state, recoilState.key, setValue);\n        upstreamWrites.forEach((v, k) => writes.set(k, v));\n      }\n\n      function resetRecoilState(recoilState) {\n        setRecoilState(recoilState, DEFAULT_VALUE$6);\n      }\n\n      const ret = set({\n        set: setRecoilState,\n        get: getRecoilValue,\n        reset: resetRecoilState\n      }, newValue); // set should be a void method, but if the user makes it `async`, then it\n      // will return a Promise, which we don't currently support.\n\n      if (ret !== undefined) {\n        throw Recoil_isPromise(ret) ? Recoil_err('Recoil: Async selector sets are not currently supported.') : Recoil_err('Recoil: selector set should be a void function.');\n      }\n\n      syncSelectorSetFinished = true;\n      return writes;\n    };\n\n    return recoilValue = registerNode$1({\n      key,\n      nodeType: 'selector',\n      peek: selectorPeek,\n      get: selectorGet,\n      set: selectorSet,\n      init: selectorInit,\n      invalidate: invalidateSelector,\n      clearCache: clearSelectorCache,\n      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,\n      dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n      shouldRestoreFromSnapshots: false,\n      retainedBy\n    });\n  } else {\n    return recoilValue = registerNode$1({\n      key,\n      nodeType: 'selector',\n      peek: selectorPeek,\n      get: selectorGet,\n      init: selectorInit,\n      invalidate: invalidateSelector,\n      clearCache: clearSelectorCache,\n      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,\n      dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n      shouldRestoreFromSnapshots: false,\n      retainedBy\n    });\n  }\n}\n/* eslint-enable no-redeclare */\n// $FlowIssue[incompatible-use]\n\n\nselector.value = value => new WrappedValue$1(value);\n\nvar Recoil_selector = selector; // @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';\n// @fb-only: const {scopedAtom} = require('Recoil_ScopedAtom');\n\nconst {\n  isLoadable: isLoadable$2,\n  loadableWithError: loadableWithError$2,\n  loadableWithPromise: loadableWithPromise$2,\n  loadableWithValue: loadableWithValue$3\n} = Recoil_Loadable$1;\nconst {\n  WrappedValue: WrappedValue$2\n} = Recoil_Wrapper$1;\nconst {\n  peekNodeInfo: peekNodeInfo$3\n} = Recoil_FunctionalCore;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$7,\n  DefaultValue: DefaultValue$2,\n  getConfigDeletionHandler: getConfigDeletionHandler$2,\n  registerNode: registerNode$2,\n  setConfigDeletionHandler: setConfigDeletionHandler$1\n} = Recoil_Node;\nconst {\n  isRecoilValue: isRecoilValue$4\n} = Recoil_RecoilValue$1;\nconst {\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$4,\n  markRecoilValueModified: markRecoilValueModified$2,\n  setRecoilValue: setRecoilValue$4,\n  setRecoilValueLoadable: setRecoilValueLoadable$2\n} = Recoil_RecoilValueInterface;\nconst {\n  retainedByOptionWithDefault: retainedByOptionWithDefault$2\n} = Recoil_Retention;\n\nconst unwrap = x => x instanceof WrappedValue$2 ? x.value : x;\n\nfunction baseAtom(options) {\n  const {\n    key,\n    persistence_UNSTABLE: persistence\n  } = options;\n  const retainedBy = retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE);\n  let liveStoresCount = 0;\n\n  function unwrapPromise(promise) {\n    return loadableWithPromise$2(promise.then(value => {\n      defaultLoadable = loadableWithValue$3(value);\n      return value;\n    }).catch(error => {\n      defaultLoadable = loadableWithError$2(error);\n      throw error;\n    }));\n  }\n\n  let defaultLoadable = Recoil_isPromise(options.default) ? unwrapPromise(options.default) : isLoadable$2(options.default) ? options.default.state === 'loading' ? unwrapPromise(options.default.contents) : options.default : loadableWithValue$3(unwrap(options.default));\n  maybeFreezeValueOrPromise(defaultLoadable.contents);\n  let cachedAnswerForUnvalidatedValue = undefined; // Cleanup handlers for this atom\n  // Rely on stable reference equality of the store to use it as a key per <RecoilRoot>\n\n  const cleanupEffectsByStore = new Map();\n\n  function maybeFreezeValueOrPromise(valueOrPromise) {\n    if (true) {\n      if (options.dangerouslyAllowMutability !== true) {\n        if (Recoil_isPromise(valueOrPromise)) {\n          return valueOrPromise.then(value => {\n            Recoil_deepFreezeValue(value);\n            return value;\n          });\n        } else {\n          Recoil_deepFreezeValue(valueOrPromise);\n          return valueOrPromise;\n        }\n      }\n    }\n\n    return valueOrPromise;\n  }\n\n  function wrapPendingPromise(store, promise) {\n    const wrappedPromise = promise.then(value => {\n      var _store$getState$nextT, _state$atomValues$get;\n\n      const state = (_store$getState$nextT = store.getState().nextTree) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree;\n\n      if (((_state$atomValues$get = state.atomValues.get(key)) === null || _state$atomValues$get === void 0 ? void 0 : _state$atomValues$get.contents) === wrappedPromise) {\n        setRecoilValue$4(store, node, value);\n      }\n\n      return value;\n    }).catch(error => {\n      var _store$getState$nextT2, _state$atomValues$get2;\n\n      const state = (_store$getState$nextT2 = store.getState().nextTree) !== null && _store$getState$nextT2 !== void 0 ? _store$getState$nextT2 : store.getState().currentTree;\n\n      if (((_state$atomValues$get2 = state.atomValues.get(key)) === null || _state$atomValues$get2 === void 0 ? void 0 : _state$atomValues$get2.contents) === wrappedPromise) {\n        setRecoilValueLoadable$2(store, node, loadableWithError$2(error));\n      }\n\n      throw error;\n    });\n    return wrappedPromise;\n  }\n\n  function initAtom(store, initState, trigger) {\n    var _options$effects;\n\n    liveStoresCount++;\n\n    const cleanupAtom = () => {\n      var _cleanupEffectsByStor;\n\n      liveStoresCount--;\n      (_cleanupEffectsByStor = cleanupEffectsByStore.get(store)) === null || _cleanupEffectsByStor === void 0 ? void 0 : _cleanupEffectsByStor.forEach(cleanup => cleanup());\n      cleanupEffectsByStore.delete(store);\n    };\n\n    store.getState().knownAtoms.add(key); // Setup async defaults to notify subscribers when they resolve\n\n    if (defaultLoadable.state === 'loading') {\n      const notifyDefaultSubscribers = () => {\n        var _store$getState$nextT3;\n\n        const state = (_store$getState$nextT3 = store.getState().nextTree) !== null && _store$getState$nextT3 !== void 0 ? _store$getState$nextT3 : store.getState().currentTree;\n\n        if (!state.atomValues.has(key)) {\n          markRecoilValueModified$2(store, node);\n        }\n      };\n\n      defaultLoadable.contents.finally(notifyDefaultSubscribers);\n    } ///////////////////\n    // Run Atom Effects\n    ///////////////////\n\n\n    const effects = (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE;\n\n    if (effects != null) {\n      // This state is scoped by Store, since this is in the initAtom() closure\n      let initValue = DEFAULT_VALUE$7;\n      let isDuringInit = true;\n      let isInitError = false;\n      let pendingSetSelf = null;\n\n      function getLoadable(recoilValue) {\n        // Normally we can just get the current value of another atom.\n        // But for our own value we need to check if there is a pending\n        // initialized value or get the fallback default value.\n        if (isDuringInit && recoilValue.key === key) {\n          // Cast T to S\n          const retValue = initValue; // flowlint-line unclear-type:off\n\n          return retValue instanceof DefaultValue$2 ? peekAtom(store, initState) // flowlint-line unclear-type:off\n          : Recoil_isPromise(retValue) ? loadableWithPromise$2(retValue.then(v => v instanceof DefaultValue$2 ? // Cast T to S\n          defaultLoadable.toPromise() // flowlint-line unclear-type:off\n          : v)) : loadableWithValue$3(retValue);\n        }\n\n        return getRecoilValueAsLoadable$4(store, recoilValue);\n      }\n\n      function getPromise(recoilValue) {\n        return getLoadable(recoilValue).toPromise();\n      }\n\n      function getInfo_UNSTABLE(recoilValue) {\n        var _store$getState$nextT4;\n\n        const info = peekNodeInfo$3(store, (_store$getState$nextT4 = store.getState().nextTree) !== null && _store$getState$nextT4 !== void 0 ? _store$getState$nextT4 : store.getState().currentTree, recoilValue.key);\n        return isDuringInit && recoilValue.key === key && !(initValue instanceof DefaultValue$2) ? { ...info,\n          isSet: true,\n          loadable: getLoadable(recoilValue)\n        } : info;\n      }\n\n      const setSelf = effect => valueOrUpdater => {\n        if (isDuringInit) {\n          const currentLoadable = getLoadable(node);\n          const currentValue = currentLoadable.state === 'hasValue' ? currentLoadable.contents : DEFAULT_VALUE$7;\n          initValue = typeof valueOrUpdater === 'function' ? // cast to any because we can't restrict T from being a function without losing support for opaque types\n          valueOrUpdater(currentValue) // flowlint-line unclear-type:off\n          : valueOrUpdater;\n\n          if (Recoil_isPromise(initValue)) {\n            initValue = initValue.then(value => {\n              // Avoid calling onSet() when setSelf() initializes with a Promise\n              pendingSetSelf = {\n                effect,\n                value\n              };\n              return value;\n            });\n          }\n        } else {\n          if (Recoil_isPromise(valueOrUpdater)) {\n            throw Recoil_err('Setting atoms to async values is not implemented.');\n          }\n\n          if (typeof valueOrUpdater !== 'function') {\n            pendingSetSelf = {\n              effect,\n              value: unwrap(valueOrUpdater)\n            };\n          }\n\n          setRecoilValue$4(store, node, typeof valueOrUpdater === 'function' ? currentValue => {\n            const newValue = unwrap( // cast to any because we can't restrict T from being a function without losing support for opaque types\n            valueOrUpdater(currentValue) // flowlint-line unclear-type:off\n            );\n            pendingSetSelf = {\n              effect,\n              value: newValue\n            };\n            return newValue;\n          } : unwrap(valueOrUpdater));\n        }\n      };\n\n      const resetSelf = effect => () => setSelf(effect)(DEFAULT_VALUE$7);\n\n      const onSet = effect => handler => {\n        var _cleanupEffectsByStor2;\n\n        const {\n          release\n        } = store.subscribeToTransactions(currentStore => {\n          var _currentTree$atomValu; // eslint-disable-next-line prefer-const\n\n\n          let {\n            currentTree,\n            previousTree\n          } = currentStore.getState();\n\n          if (!previousTree) {\n            Recoil_recoverableViolation('Transaction subscribers notified without a next tree being present -- this is a bug in Recoil');\n            previousTree = currentTree; // attempt to trundle on\n          }\n\n          const newLoadable = (_currentTree$atomValu = currentTree.atomValues.get(key)) !== null && _currentTree$atomValu !== void 0 ? _currentTree$atomValu : defaultLoadable;\n\n          if (newLoadable.state === 'hasValue') {\n            var _previousTree$atomVal, _pendingSetSelf, _pendingSetSelf2, _pendingSetSelf3;\n\n            const newValue = newLoadable.contents;\n            const oldLoadable = (_previousTree$atomVal = previousTree.atomValues.get(key)) !== null && _previousTree$atomVal !== void 0 ? _previousTree$atomVal : defaultLoadable;\n            const oldValue = oldLoadable.state === 'hasValue' ? oldLoadable.contents : DEFAULT_VALUE$7; // TODO This isn't actually valid, use as a placeholder for now.\n            // Ignore atom value changes that were set via setSelf() in the same effect.\n            // We will still properly call the handler if there was a subsequent\n            // set from something other than an atom effect which was batched\n            // with the `setSelf()` call.  However, we may incorrectly ignore\n            // the handler if the subsequent batched call happens to set the\n            // atom to the exact same value as the `setSelf()`.   But, in that\n            // case, it was kind of a noop, so the semantics are debatable..\n\n            if (((_pendingSetSelf = pendingSetSelf) === null || _pendingSetSelf === void 0 ? void 0 : _pendingSetSelf.effect) !== effect || ((_pendingSetSelf2 = pendingSetSelf) === null || _pendingSetSelf2 === void 0 ? void 0 : _pendingSetSelf2.value) !== newValue) {\n              handler(newValue, oldValue, !currentTree.atomValues.has(key));\n            } else if (((_pendingSetSelf3 = pendingSetSelf) === null || _pendingSetSelf3 === void 0 ? void 0 : _pendingSetSelf3.effect) === effect) {\n              pendingSetSelf = null;\n            }\n          }\n        }, key);\n        cleanupEffectsByStore.set(store, [...((_cleanupEffectsByStor2 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor2 !== void 0 ? _cleanupEffectsByStor2 : []), release]);\n      };\n\n      for (const effect of effects) {\n        try {\n          const cleanup = effect({\n            node,\n            storeID: store.storeID,\n            parentStoreID_UNSTABLE: store.parentStoreID,\n            trigger,\n            setSelf: setSelf(effect),\n            resetSelf: resetSelf(effect),\n            onSet: onSet(effect),\n            getPromise,\n            getLoadable,\n            getInfo_UNSTABLE\n          });\n\n          if (cleanup != null) {\n            var _cleanupEffectsByStor3;\n\n            cleanupEffectsByStore.set(store, [...((_cleanupEffectsByStor3 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor3 !== void 0 ? _cleanupEffectsByStor3 : []), cleanup]);\n          }\n        } catch (error) {\n          initValue = error;\n          isInitError = true;\n        }\n      }\n\n      isDuringInit = false; // Mutate initial state in place since we know there are no other subscribers\n      // since we are the ones initializing on first use.\n\n      if (!(initValue instanceof DefaultValue$2)) {\n        var _store$getState$nextT5;\n\n        const initLoadable = isInitError ? loadableWithError$2(initValue) : Recoil_isPromise(initValue) ? loadableWithPromise$2(wrapPendingPromise(store, initValue)) : loadableWithValue$3(unwrap(initValue));\n        maybeFreezeValueOrPromise(initLoadable.contents);\n        initState.atomValues.set(key, initLoadable); // If there is a pending transaction, then also mutate the next state tree.\n        // This could happen if the atom was first initialized in an action that\n        // also updated some other atom's state.\n\n        (_store$getState$nextT5 = store.getState().nextTree) === null || _store$getState$nextT5 === void 0 ? void 0 : _store$getState$nextT5.atomValues.set(key, initLoadable);\n      }\n    }\n\n    return cleanupAtom;\n  }\n\n  function peekAtom(_store, state) {\n    var _ref, _state$atomValues$get3;\n\n    return (_ref = (_state$atomValues$get3 = state.atomValues.get(key)) !== null && _state$atomValues$get3 !== void 0 ? _state$atomValues$get3 : cachedAnswerForUnvalidatedValue) !== null && _ref !== void 0 ? _ref : defaultLoadable;\n  }\n\n  function getAtom(_store, state) {\n    if (state.atomValues.has(key)) {\n      // Atom value is stored in state:\n      return Recoil_nullthrows(state.atomValues.get(key));\n    } else if (state.nonvalidatedAtoms.has(key)) {\n      // Atom value is stored but needs validation before use.\n      // We might have already validated it and have a cached validated value:\n      if (cachedAnswerForUnvalidatedValue != null) {\n        return cachedAnswerForUnvalidatedValue;\n      }\n\n      if (persistence == null) {\n        Recoil_expectationViolation(`Tried to restore a persisted value for atom ${key} but it has no persistence settings.`);\n        return defaultLoadable;\n      }\n\n      const nonvalidatedValue = state.nonvalidatedAtoms.get(key);\n      const validatorResult = persistence.validator(nonvalidatedValue, DEFAULT_VALUE$7);\n      const validatedValueLoadable = validatorResult instanceof DefaultValue$2 ? defaultLoadable : loadableWithValue$3(validatorResult);\n      cachedAnswerForUnvalidatedValue = validatedValueLoadable;\n      return cachedAnswerForUnvalidatedValue;\n    } else {\n      return defaultLoadable;\n    }\n  }\n\n  function invalidateAtom() {\n    cachedAnswerForUnvalidatedValue = undefined;\n  }\n\n  function setAtom(_store, state, newValue) {\n    // Bail out if we're being set to the existing value, or if we're being\n    // reset but have no stored value (validated or unvalidated) to reset from:\n    if (state.atomValues.has(key)) {\n      const existing = Recoil_nullthrows(state.atomValues.get(key));\n\n      if (existing.state === 'hasValue' && newValue === existing.contents) {\n        return new Map();\n      }\n    } else if (!state.nonvalidatedAtoms.has(key) && newValue instanceof DefaultValue$2) {\n      return new Map();\n    }\n\n    maybeFreezeValueOrPromise(newValue);\n    cachedAnswerForUnvalidatedValue = undefined; // can be released now if it was previously in use\n\n    return new Map().set(key, loadableWithValue$3(newValue));\n  }\n\n  function shouldDeleteConfigOnReleaseAtom() {\n    return getConfigDeletionHandler$2(key) !== undefined && liveStoresCount <= 0;\n  }\n\n  const node = registerNode$2({\n    key,\n    nodeType: 'atom',\n    peek: peekAtom,\n    get: getAtom,\n    set: setAtom,\n    init: initAtom,\n    invalidate: invalidateAtom,\n    shouldDeleteConfigOnRelease: shouldDeleteConfigOnReleaseAtom,\n    dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n    persistence_UNSTABLE: options.persistence_UNSTABLE ? {\n      type: options.persistence_UNSTABLE.type,\n      backButton: options.persistence_UNSTABLE.backButton\n    } : undefined,\n    shouldRestoreFromSnapshots: true,\n    retainedBy\n  });\n  return node;\n} // prettier-ignore\n\n\nfunction atom(options) {\n  if (true) {\n    if (typeof options.key !== 'string') {\n      throw Recoil_err('A key option with a unique string value must be provided when creating an atom.');\n    }\n  }\n\n  const { // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n    ...restOptions\n  } = options;\n  const optionsDefault = 'default' in options ? // $FlowIssue[prop-missing] No way to refine in Flow that property is not defined\n  // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined\n  options.default : new Promise(() => {});\n\n  if (isRecoilValue$4(optionsDefault) // Continue to use atomWithFallback for promise defaults for scoped atoms\n  // for now, since scoped atoms don't support async defaults\n  // @fb-only: || (isPromise(optionsDefault) && scopeRules_APPEND_ONLY_READ_THE_DOCS)\n  // @fb-only: || (isLoadable(optionsDefault) && scopeRules_APPEND_ONLY_READ_THE_DOCS)\n  ) {\n    return atomWithFallback({ ...restOptions,\n      default: optionsDefault // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n\n    }); // @fb-only: } else if (scopeRules_APPEND_ONLY_READ_THE_DOCS\n    // @fb-only: && !isPromise(optionsDefault)\n    // @fb-only: && !isLoadable(optionsDefault)\n    // @fb-only: ) {\n    // @fb-only: return scopedAtom<T>({\n    // @fb-only: ...restOptions,\n    // @fb-only: default: unwrap<T>(optionsDefault),\n    // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n    // @fb-only: });\n  } else {\n    return baseAtom({ ...restOptions,\n      default: optionsDefault\n    });\n  }\n}\n\nfunction atomWithFallback(options) {\n  const base = atom({ ...options,\n    default: DEFAULT_VALUE$7,\n    persistence_UNSTABLE: options.persistence_UNSTABLE === undefined ? undefined : { ...options.persistence_UNSTABLE,\n      validator: storedValue => storedValue instanceof DefaultValue$2 ? storedValue : Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue, DEFAULT_VALUE$7)\n    },\n    // TODO Hack for now.\n    effects: options.effects,\n    // flowlint-line unclear-type: off\n    effects_UNSTABLE: options.effects_UNSTABLE // flowlint-line unclear-type: off\n\n  });\n  const sel = Recoil_selector({\n    key: `${options.key}__withFallback`,\n    get: ({\n      get\n    }) => {\n      const baseValue = get(base);\n      return baseValue instanceof DefaultValue$2 ? options.default : baseValue;\n    },\n    set: ({\n      set\n    }, newValue) => set(base, newValue),\n    // This selector does not need to cache as it is a wrapper selector\n    // and the selector within the wrapper selector will have a cache\n    // option by default\n    cachePolicy_UNSTABLE: {\n      eviction: 'most-recent'\n    },\n    dangerouslyAllowMutability: options.dangerouslyAllowMutability\n  });\n  setConfigDeletionHandler$1(sel.key, getConfigDeletionHandler$2(options.key));\n  return sel;\n}\n\natom.value = value => new WrappedValue$2(value);\n\nvar Recoil_atom = atom;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nclass MapCache {\n  constructor(options) {\n    var _options$mapKey;\n\n    _defineProperty(this, \"_map\", void 0);\n\n    _defineProperty(this, \"_keyMapper\", void 0);\n\n    this._map = new Map();\n    this._keyMapper = (_options$mapKey = options === null || options === void 0 ? void 0 : options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : v => v;\n  }\n\n  size() {\n    return this._map.size;\n  }\n\n  has(key) {\n    return this._map.has(this._keyMapper(key));\n  }\n\n  get(key) {\n    return this._map.get(this._keyMapper(key));\n  }\n\n  set(key, val) {\n    this._map.set(this._keyMapper(key), val);\n  }\n\n  delete(key) {\n    this._map.delete(this._keyMapper(key));\n  }\n\n  clear() {\n    this._map.clear();\n  }\n\n}\n\nvar Recoil_MapCache = {\n  MapCache\n};\nvar Recoil_MapCache_1 = Recoil_MapCache.MapCache;\nvar Recoil_MapCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MapCache: Recoil_MapCache_1\n});\nconst {\n  LRUCache: LRUCache$2\n} = Recoil_LRUCache$1;\nconst {\n  MapCache: MapCache$1\n} = Recoil_MapCache$1;\nconst defaultPolicy$1 = {\n  equality: 'reference',\n  eviction: 'none',\n  maxSize: Infinity\n};\n\nfunction cacheFromPolicy({\n  equality = defaultPolicy$1.equality,\n  eviction = defaultPolicy$1.eviction,\n  maxSize = defaultPolicy$1.maxSize\n} = defaultPolicy$1) {\n  const valueMapper = getValueMapper$1(equality);\n  const cache = getCache(eviction, maxSize, valueMapper);\n  return cache;\n}\n\nfunction getValueMapper$1(equality) {\n  switch (equality) {\n    case 'reference':\n      return val => val;\n\n    case 'value':\n      return val => Recoil_stableStringify(val);\n  }\n\n  throw Recoil_err(`Unrecognized equality policy ${equality}`);\n}\n\nfunction getCache(eviction, maxSize, mapKey) {\n  switch (eviction) {\n    case 'keep-all':\n      return new MapCache$1({\n        mapKey\n      });\n\n    case 'lru':\n      return new LRUCache$2({\n        mapKey,\n        maxSize: Recoil_nullthrows(maxSize)\n      });\n\n    case 'most-recent':\n      return new LRUCache$2({\n        mapKey,\n        maxSize: 1\n      });\n  }\n\n  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);\n}\n\nvar Recoil_cacheFromPolicy = cacheFromPolicy; // @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';\n\nconst {\n  setConfigDeletionHandler: setConfigDeletionHandler$2\n} = Recoil_Node; // Process scopeRules to handle any entries which are functions taking parameters\n// prettier-ignore\n// @fb-only: function mapScopeRules<P>(\n// @fb-only: scopeRules?: ParameterizedScopeRules<P>,\n// @fb-only: param: P,\n// @fb-only: ): ScopeRules | void {\n// @fb-only: return scopeRules?.map(rule =>\n// @fb-only: Array.isArray(rule)\n// @fb-only: ? rule.map(entry => (typeof entry === 'function' ? entry(param) : entry))\n// @fb-only: : rule,\n// @fb-only: );\n// @fb-only: }\n\n/*\r\nA function which returns an atom based on the input parameter.\r\n\r\nEach unique parameter returns a unique atom. E.g.,\r\n\r\n  const f = atomFamily(...);\r\n  f({a: 1}) => an atom\r\n  f({a: 2}) => a different atom\r\n\r\nThis allows components to persist local, private state using atoms.  Each\r\ninstance of the component may have a different key, which it uses as the\r\nparameter for a family of atoms; in this way, each component will have\r\nits own atom not shared by other instances.  These state keys may be composed\r\ninto children's state keys as well.\r\n*/\n\nfunction atomFamily(options) {\n  var _options$cachePolicyF, _options$cachePolicyF2;\n\n  const atomCache = Recoil_cacheFromPolicy({\n    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : 'value',\n    eviction: 'keep-all'\n  }); // Simple atomFamily implementation to cache individual atoms based\n  // on the parameter value equality.\n\n  return params => {\n    var _stableStringify, _options$effects;\n\n    const cachedAtom = atomCache.get(params);\n\n    if (cachedAtom != null) {\n      return cachedAtom;\n    }\n\n    const {\n      cachePolicyForParams_UNSTABLE,\n      ...atomOptions\n    } = options;\n    const optionsDefault = 'default' in options ? // $FlowIssue[prop-missing] No way to refine in Flow that property is not defined\n    // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined\n    options.default : new Promise(() => {});\n    const newAtom = Recoil_atom({ ...atomOptions,\n      key: `${options.key}__${(_stableStringify = Recoil_stableStringify(params)) !== null && _stableStringify !== void 0 ? _stableStringify : 'void'}`,\n      default: typeof optionsDefault === 'function' ? // The default was parameterized\n      // Flow doesn't know that T isn't a function, so we need to case to any\n      // $FlowIssue[incompatible-use]\n      optionsDefault(params) : // Default may be a static value, promise, or RecoilValue\n      optionsDefault,\n      retainedBy_UNSTABLE: typeof options.retainedBy_UNSTABLE === 'function' ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE,\n      effects: typeof options.effects === 'function' ? options.effects(params) : typeof options.effects_UNSTABLE === 'function' ? options.effects_UNSTABLE(params) : (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE // prettier-ignore\n      // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS: mapScopeRules(\n      // @fb-only: options.scopeRules_APPEND_ONLY_READ_THE_DOCS,\n      // @fb-only: params,\n      // @fb-only: ),\n\n    });\n    atomCache.set(params, newAtom);\n    setConfigDeletionHandler$2(newAtom.key, () => {\n      atomCache.delete(params);\n    });\n    return newAtom;\n  };\n}\n\nvar Recoil_atomFamily = atomFamily;\nconst {\n  setConfigDeletionHandler: setConfigDeletionHandler$3\n} = Recoil_Node; // Keep in mind the parameter needs to be serializable as a cahche key\n// using Recoil_stableStringify\n// Add a unique index to each selector in case the cache implementation allows\n// duplicate keys based on equivalent stringified parameters\n\nlet nextIndex = 0;\n/* eslint-disable no-redeclare */\n// Return a function that returns members of a family of selectors of the same type\n// E.g.,\n//\n// const s = selectorFamily(...);\n// s({a: 1}) => a selector\n// s({a: 2}) => a different selector\n//\n// By default, the selectors are distinguished by distinct values of the\n// parameter based on value equality, not reference equality.  This allows using\n// object literals or other equivalent objects at callsites to not create\n// duplicate cache entries.  This behavior may be overridden with the\n// cacheImplementationForParams option.\n\nfunction selectorFamily(options) {\n  var _options$cachePolicyF, _options$cachePolicyF2;\n\n  const selectorCache = Recoil_cacheFromPolicy({\n    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : 'value',\n    eviction: 'keep-all'\n  });\n  return params => {\n    var _stableStringify; // Throw an error with selector key so that it is clear which\n    // selector is causing an error\n\n\n    let cachedSelector;\n\n    try {\n      cachedSelector = selectorCache.get(params);\n    } catch (error) {\n      throw Recoil_err(`Problem with cache lookup for selector ${options.key}: ${error.message}`);\n    }\n\n    if (cachedSelector != null) {\n      return cachedSelector;\n    }\n\n    const myKey = `${options.key}__selectorFamily/${(_stableStringify = Recoil_stableStringify(params, {\n      // It is possible to use functions in parameters if the user uses\n      // a cache with reference equality thanks to the incrementing index.\n      allowFunctions: true\n    })) !== null && _stableStringify !== void 0 ? _stableStringify : 'void'}/${nextIndex++}`; // Append index in case values serialize to the same key string\n\n    const myGet = callbacks => options.get(params)(callbacks);\n\n    const myCachePolicy = options.cachePolicy_UNSTABLE;\n    const retainedBy = typeof options.retainedBy_UNSTABLE === 'function' ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE;\n    let newSelector;\n\n    if (options.set != null) {\n      const set = options.set;\n\n      const mySet = (callbacks, newValue) => set(params)(callbacks, newValue);\n\n      newSelector = Recoil_selector({\n        key: myKey,\n        get: myGet,\n        set: mySet,\n        cachePolicy_UNSTABLE: myCachePolicy,\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n        retainedBy_UNSTABLE: retainedBy\n      });\n    } else {\n      newSelector = Recoil_selector({\n        key: myKey,\n        get: myGet,\n        cachePolicy_UNSTABLE: myCachePolicy,\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n        retainedBy_UNSTABLE: retainedBy\n      });\n    }\n\n    selectorCache.set(params, newSelector);\n    setConfigDeletionHandler$3(newSelector.key, () => {\n      selectorCache.delete(params);\n    });\n    return newSelector;\n  };\n}\n/* eslint-enable no-redeclare */\n\n\nvar Recoil_selectorFamily = selectorFamily; // flowlint-next-line unclear-type:off\n\nconst constantSelector = Recoil_selectorFamily({\n  key: '__constant',\n  get: constant => () => constant,\n  cachePolicyForParams_UNSTABLE: {\n    equality: 'reference'\n  }\n}); // Function that returns a selector which always produces the\n// same constant value.  It may be called multiple times with the\n// same value, based on reference equality, and will provide the\n// same selector.\n\nfunction constSelector(constant) {\n  return constantSelector(constant);\n}\n\nvar Recoil_constSelector = constSelector; // flowlint-next-line unclear-type:off\n\nconst throwingSelector = Recoil_selectorFamily({\n  key: '__error',\n  get: message => () => {\n    throw Recoil_err(message);\n  },\n  // TODO Why?\n  cachePolicyForParams_UNSTABLE: {\n    equality: 'reference'\n  }\n}); // Function that returns a selector which always throws an error\n// with the provided message.\n\nfunction errorSelector(message) {\n  return throwingSelector(message);\n}\n\nvar Recoil_errorSelector = errorSelector;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * Wraps another recoil value and prevents writing to it.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction readOnlySelector(atom) {\n  // flowlint-next-line unclear-type: off\n  return atom;\n}\n\nvar Recoil_readOnlySelector = readOnlySelector;\nconst {\n  loadableWithError: loadableWithError$3,\n  loadableWithPromise: loadableWithPromise$3,\n  loadableWithValue: loadableWithValue$4\n} = Recoil_Loadable$1; /////////////////\n//  TRUTH TABLE\n/////////////////\n// Dependencies        waitForNone         waitForAny        waitForAll       waitForAllSettled\n//  [loading, loading]  [Promise, Promise]  Promise           Promise         Promise\n//  [value, loading]    [value, Promise]    [value, Promise]  Promise         Promise\n//  [value, value]      [value, value]      [value, value]    [value, value]  [value, value]\n//\n//  [error, loading]    [Error, Promise]    [Error, Promise]  Error           Promise\n//  [error, error]      [Error, Error]      [Error, Error]    Error           [error, error]\n//  [value, error]      [value, Error]      [value, Error]    Error           [value, error]\n// Issue parallel requests for all dependencies and return the current\n// status if they have results, have some error, or are still pending.\n\nfunction concurrentRequests(getRecoilValue, deps) {\n  const results = Array(deps.length).fill(undefined);\n  const exceptions = Array(deps.length).fill(undefined);\n\n  for (const [i, dep] of deps.entries()) {\n    try {\n      results[i] = getRecoilValue(dep);\n    } catch (e) {\n      // exceptions can either be Promises of pending results or real errors\n      exceptions[i] = e;\n    }\n  }\n\n  return [results, exceptions];\n}\n\nfunction isError(exp) {\n  return exp != null && !Recoil_isPromise(exp);\n}\n\nfunction unwrapDependencies(dependencies) {\n  return Array.isArray(dependencies) ? dependencies : Object.getOwnPropertyNames(dependencies).map(key => dependencies[key]);\n}\n\nfunction wrapResults(dependencies,\n/* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\r\n * LTI update could not be added via codemod */\nresults) {\n  return Array.isArray(dependencies) ? results : // Object.getOwnPropertyNames() has consistent key ordering with ES6\n  Object.getOwnPropertyNames(dependencies).reduce((out, key, idx) => ({ ...out,\n    [key]: results[idx]\n  }), {});\n}\n\nfunction wrapLoadables(dependencies, results, exceptions) {\n  const output = exceptions.map((exception, idx) => exception == null ? loadableWithValue$4(results[idx]) : Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));\n  return wrapResults(dependencies, output);\n}\n\nfunction combineAsyncResultsWithSyncResults(syncResults, asyncResults) {\n  return asyncResults.map((result, idx) =>\n  /**\r\n   * it's important we use === undefined as opposed to == null, because the\r\n   * resolved value of the async promise could be `null`, in which case we\r\n   * don't want to use syncResults[idx], which would be undefined. If async\r\n   * promise resolves to `undefined`, that's ok because `syncResults[idx]`\r\n   * will also be `undefined`. That's a little hacky, but it works.\r\n   */\n  result === undefined ? syncResults[idx] : result);\n} // Selector that requests all dependencies in parallel and immediately returns\n// current results without waiting.\n\n\nconst waitForNone = Recoil_selectorFamily({\n  key: '__waitForNone',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // Always return the current status of the results; never block.\n\n    return wrapLoadables(dependencies, results, exceptions);\n  },\n  dangerouslyAllowMutability: true\n}); // Selector that requests all dependencies in parallel and waits for at least\n// one to be available before returning results.  It will only error if all\n// dependencies have errors.\n\nconst waitForAny = Recoil_selectorFamily({\n  key: '__waitForAny',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If any results are available, value or error, return the current status\n\n    if (exceptions.some(exp => !Recoil_isPromise(exp))) {\n      return wrapLoadables(dependencies, results, exceptions);\n    } // Otherwise, return a promise that will resolve when the next result is\n    // available, whichever one happens to be next.  But, if all pending\n    // dependencies end up with errors, then reject the promise.\n\n\n    return new Promise(resolve => {\n      for (const [i, exp] of exceptions.entries()) {\n        if (Recoil_isPromise(exp)) {\n          exp.then(result => {\n            results[i] = result;\n            exceptions[i] = undefined;\n            resolve(wrapLoadables(dependencies, results, exceptions));\n          }).catch(error => {\n            exceptions[i] = error;\n            resolve(wrapLoadables(dependencies, results, exceptions));\n          });\n        }\n      }\n    });\n  },\n  dangerouslyAllowMutability: true\n}); // Selector that requests all dependencies in parallel and waits for all to be\n// available before returning a value.  It will error if any dependencies error.\n\nconst waitForAll = Recoil_selectorFamily({\n  key: '__waitForAll',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results\n\n    if (exceptions.every(exp => exp == null)) {\n      return wrapResults(dependencies, results);\n    } // If we have any errors, throw the first error\n\n\n    const error = exceptions.find(isError);\n\n    if (error != null) {\n      throw error;\n    } // Otherwise, return a promise that will resolve when all results are available\n\n\n    return Promise.all(exceptions).then(exceptionResults => wrapResults(dependencies, combineAsyncResultsWithSyncResults(results, exceptionResults)));\n  },\n  dangerouslyAllowMutability: true\n});\nconst waitForAllSettled = Recoil_selectorFamily({\n  key: '__waitForAllSettled',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results\n\n    if (exceptions.every(exp => !Recoil_isPromise(exp))) {\n      return wrapLoadables(dependencies, results, exceptions);\n    } // Wait for all results to settle\n\n\n    return Promise.all(exceptions.map((exp, i) => Recoil_isPromise(exp) ? exp.then(result => {\n      results[i] = result;\n      exceptions[i] = undefined;\n    }).catch(error => {\n      results[i] = undefined;\n      exceptions[i] = error;\n    }) : null)) // Then wrap them as loadables\n    .then(() => wrapLoadables(dependencies, results, exceptions));\n  },\n  dangerouslyAllowMutability: true\n});\nconst noWait = Recoil_selectorFamily({\n  key: '__noWait',\n  get: dependency => ({\n    get\n  }) => {\n    try {\n      return Recoil_selector.value(loadableWithValue$4(get(dependency)));\n    } catch (exception) {\n      return Recoil_selector.value(Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));\n    }\n  },\n  dangerouslyAllowMutability: true\n});\nvar Recoil_WaitFor = {\n  waitForNone,\n  waitForAny,\n  waitForAll,\n  waitForAllSettled,\n  noWait\n};\nconst {\n  RecoilLoadable\n} = Recoil_Loadable$1;\nconst {\n  DefaultValue: DefaultValue$3\n} = Recoil_Node;\nconst {\n  RecoilRoot: RecoilRoot$2,\n  useRecoilStoreID: useRecoilStoreID$1\n} = Recoil_RecoilRoot;\nconst {\n  isRecoilValue: isRecoilValue$5\n} = Recoil_RecoilValue$1;\nconst {\n  retentionZone: retentionZone$1\n} = Recoil_RetentionZone;\nconst {\n  freshSnapshot: freshSnapshot$2\n} = Recoil_Snapshot$1;\nconst {\n  useRecoilState: useRecoilState$1,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilStateLoadable: useRecoilStateLoadable$1,\n  useRecoilValue: useRecoilValue$1,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilValueLoadable: useRecoilValueLoadable$1,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,\n  useResetRecoilState: useResetRecoilState$1,\n  useSetRecoilState: useSetRecoilState$1\n} = Recoil_Hooks;\nconst {\n  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,\n  useRecoilSnapshot: useRecoilSnapshot$1,\n  useRecoilTransactionObserver: useRecoilTransactionObserver$1\n} = Recoil_SnapshotHooks;\nconst {\n  useRecoilCallback: useRecoilCallback$1\n} = Recoil_useRecoilCallback;\nconst {\n  noWait: noWait$1,\n  waitForAll: waitForAll$1,\n  waitForAllSettled: waitForAllSettled$1,\n  waitForAny: waitForAny$1,\n  waitForNone: waitForNone$1\n} = Recoil_WaitFor;\nvar Recoil_index = {\n  // Types\n  DefaultValue: DefaultValue$3,\n  isRecoilValue: isRecoilValue$5,\n  RecoilLoadable,\n  // Recoil Root\n  RecoilRoot: RecoilRoot$2,\n  useRecoilStoreID: useRecoilStoreID$1,\n  useRecoilBridgeAcrossReactRoots_UNSTABLE: Recoil_useRecoilBridgeAcrossReactRoots,\n  // Atoms/Selectors\n  atom: Recoil_atom,\n  selector: Recoil_selector,\n  // Convenience Atoms/Selectors\n  atomFamily: Recoil_atomFamily,\n  selectorFamily: Recoil_selectorFamily,\n  constSelector: Recoil_constSelector,\n  errorSelector: Recoil_errorSelector,\n  readOnlySelector: Recoil_readOnlySelector,\n  // Concurrency Helpers for Atoms/Selectors\n  noWait: noWait$1,\n  waitForNone: waitForNone$1,\n  waitForAny: waitForAny$1,\n  waitForAll: waitForAll$1,\n  waitForAllSettled: waitForAllSettled$1,\n  // Hooks for Atoms/Selectors\n  useRecoilValue: useRecoilValue$1,\n  useRecoilValueLoadable: useRecoilValueLoadable$1,\n  useRecoilState: useRecoilState$1,\n  useRecoilStateLoadable: useRecoilStateLoadable$1,\n  useSetRecoilState: useSetRecoilState$1,\n  useResetRecoilState: useResetRecoilState$1,\n  useGetRecoilValueInfo_UNSTABLE: Recoil_useGetRecoilValueInfo,\n  useRecoilRefresher_UNSTABLE: Recoil_useRecoilRefresher,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,\n  // Hooks for complex operations\n  useRecoilCallback: useRecoilCallback$1,\n  useRecoilTransaction_UNSTABLE: Recoil_useRecoilTransaction,\n  // Snapshots\n  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,\n  useRecoilSnapshot: useRecoilSnapshot$1,\n  useRecoilTransactionObserver_UNSTABLE: useRecoilTransactionObserver$1,\n  snapshot_UNSTABLE: freshSnapshot$2,\n  // Memory Management\n  useRetain: Recoil_useRetain,\n  retentionZone: retentionZone$1\n};\nvar Recoil_index_1 = Recoil_index.DefaultValue;\nvar Recoil_index_2 = Recoil_index.isRecoilValue;\nvar Recoil_index_3 = Recoil_index.RecoilLoadable;\nvar Recoil_index_4 = Recoil_index.RecoilRoot;\nvar Recoil_index_5 = Recoil_index.useRecoilStoreID;\nvar Recoil_index_6 = Recoil_index.useRecoilBridgeAcrossReactRoots_UNSTABLE;\nvar Recoil_index_7 = Recoil_index.atom;\nvar Recoil_index_8 = Recoil_index.selector;\nvar Recoil_index_9 = Recoil_index.atomFamily;\nvar Recoil_index_10 = Recoil_index.selectorFamily;\nvar Recoil_index_11 = Recoil_index.constSelector;\nvar Recoil_index_12 = Recoil_index.errorSelector;\nvar Recoil_index_13 = Recoil_index.readOnlySelector;\nvar Recoil_index_14 = Recoil_index.noWait;\nvar Recoil_index_15 = Recoil_index.waitForNone;\nvar Recoil_index_16 = Recoil_index.waitForAny;\nvar Recoil_index_17 = Recoil_index.waitForAll;\nvar Recoil_index_18 = Recoil_index.waitForAllSettled;\nvar Recoil_index_19 = Recoil_index.useRecoilValue;\nvar Recoil_index_20 = Recoil_index.useRecoilValueLoadable;\nvar Recoil_index_21 = Recoil_index.useRecoilState;\nvar Recoil_index_22 = Recoil_index.useRecoilStateLoadable;\nvar Recoil_index_23 = Recoil_index.useSetRecoilState;\nvar Recoil_index_24 = Recoil_index.useResetRecoilState;\nvar Recoil_index_25 = Recoil_index.useGetRecoilValueInfo_UNSTABLE;\nvar Recoil_index_26 = Recoil_index.useRecoilRefresher_UNSTABLE;\nvar Recoil_index_27 = Recoil_index.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_28 = Recoil_index.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_29 = Recoil_index.useRecoilState_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_30 = Recoil_index.useRecoilCallback;\nvar Recoil_index_31 = Recoil_index.useRecoilTransaction_UNSTABLE;\nvar Recoil_index_32 = Recoil_index.useGotoRecoilSnapshot;\nvar Recoil_index_33 = Recoil_index.useRecoilSnapshot;\nvar Recoil_index_34 = Recoil_index.useRecoilTransactionObserver_UNSTABLE;\nvar Recoil_index_35 = Recoil_index.snapshot_UNSTABLE;\nvar Recoil_index_36 = Recoil_index.useRetain;\nvar Recoil_index_37 = Recoil_index.retentionZone;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Recoil_index);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM3aEIsMENBQW5DO0FBQ0EsSUFBSWlrQixlQUFlLEdBQUdwQyxZQUFZLENBQUM3YSxpQkFBbkM7QUFDQSxJQUFJa2QsZUFBZSxHQUFHckMsWUFBWSxDQUFDSSw2QkFBbkM7QUFDQSxJQUFJa0MsZUFBZSxHQUFHdEMsWUFBWSxDQUFDeGUscUJBQW5DO0FBQ0EsSUFBSStnQixlQUFlLEdBQUd2QyxZQUFZLENBQUNwZixpQkFBbkM7QUFDQSxJQUFJNGhCLGVBQWUsR0FBR3hDLFlBQVksQ0FBQ0sscUNBQW5DO0FBQ0EsSUFBSW9DLGVBQWUsR0FBR3pDLFlBQVksQ0FBQ00saUJBQW5DO0FBQ0EsSUFBSW9DLGVBQWUsR0FBRzFDLFlBQVksQ0FBQ2xuQixTQUFuQztBQUNBLElBQUk2cEIsZUFBZSxHQUFHM0MsWUFBWSxDQUFDcitCLGFBQW5DO0FBRUEsK0RBQWVxK0IsWUFBZiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVjb2lsL2VzL2luZGV4LmpzPzNhNjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHJlYWN0RG9tIGZyb20gJ3JlYWN0LWRvbSc7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gZXJyKG1lc3NhZ2UpIHtcclxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTsgLy8gSW4gVjgsIEVycm9yIG9iamVjdHMga2VlcCB0aGUgY2xvc3VyZSBzY29wZSBjaGFpbiBhbGl2ZSB1bnRpbCB0aGVcclxuICAvLyBlcnIuc3RhY2sgcHJvcGVydHkgaXMgYWNjZXNzZWQuXHJcblxyXG4gIGlmIChlcnJvci5zdGFjayA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAvLyBJRSBzZXRzIHRoZSBzdGFjayBvbmx5IGlmIGVycm9yIGlzIHRocm93blxyXG4gICAgdHJ5IHtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9IGNhdGNoIChfKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZiLXd3dy9uby11bnVzZWQtY2F0Y2gtYmluZGluZ3MsIG5vLWVtcHR5XHJcblxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVycm9yO1xyXG59XHJcblxyXG52YXIgZXJyXzEgPSBlcnI7XHJcblxyXG4vLyBAb3NzLW9ubHlcclxuXHJcblxyXG52YXIgUmVjb2lsX2VyciA9IGVycl8xO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuXHJcbi8vIFNwbGl0IGRlY2xhcmF0aW9uIGFuZCBpbXBsZW1lbnRhdGlvbiB0byBhbGxvdyB0aGlzIGZ1bmN0aW9uIHRvIHByZXRlbmQgdG9cclxuLy8gY2hlY2sgZm9yIGFjdHVhbCBpbnN0YW5jZSBvZiBQcm9taXNlIGluc3RlYWQgb2Ygc29tZXRoaW5nIHdpdGggYSBgdGhlbmBcclxuLy8gbWV0aG9kLlxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXHJcbmZ1bmN0aW9uIGlzUHJvbWlzZShwKSB7XHJcbiAgcmV0dXJuICEhcCAmJiB0eXBlb2YgcC50aGVuID09PSAnZnVuY3Rpb24nO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX2lzUHJvbWlzZSA9IGlzUHJvbWlzZTtcclxuXHJcbmZ1bmN0aW9uIG51bGx0aHJvd3MoeCwgbWVzc2FnZSkge1xyXG4gIGlmICh4ICE9IG51bGwpIHtcclxuICAgIHJldHVybiB4O1xyXG4gIH1cclxuXHJcbiAgdGhyb3cgUmVjb2lsX2VycihtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAnR290IHVuZXhwZWN0ZWQgbnVsbCBvciB1bmRlZmluZWQnKTtcclxufVxyXG5cclxudmFyIFJlY29pbF9udWxsdGhyb3dzID0gbnVsbHRocm93cztcclxuXHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcclxuICBpZiAoa2V5IGluIG9iaikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIG9ialtrZXldID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG5jbGFzcyBCYXNlTG9hZGFibGUge1xyXG4gIGdldFZhbHVlKCkge1xyXG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XHJcbiAgfVxyXG5cclxuICB0b1Byb21pc2UoKSB7XHJcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcclxuICB9XHJcblxyXG4gIHZhbHVlTWF5YmUoKSB7XHJcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcclxuICB9XHJcblxyXG4gIHZhbHVlT3JUaHJvdygpIHtcclxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxyXG4gICAgdGhyb3cgUmVjb2lsX2VycihgTG9hZGFibGUgZXhwZWN0ZWQgdmFsdWUsIGJ1dCBpbiBcIiR7dGhpcy5zdGF0ZX1cIiBzdGF0ZWApO1xyXG4gIH1cclxuXHJcbiAgcHJvbWlzZU1heWJlKCkge1xyXG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XHJcbiAgfVxyXG5cclxuICBwcm9taXNlT3JUaHJvdygpIHtcclxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxyXG4gICAgdGhyb3cgUmVjb2lsX2VycihgTG9hZGFibGUgZXhwZWN0ZWQgcHJvbWlzZSwgYnV0IGluIFwiJHt0aGlzLnN0YXRlfVwiIHN0YXRlYCk7XHJcbiAgfVxyXG5cclxuICBlcnJvck1heWJlKCkge1xyXG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XHJcbiAgfVxyXG5cclxuICBlcnJvck9yVGhyb3coKSB7XHJcbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cclxuICAgIHRocm93IFJlY29pbF9lcnIoYExvYWRhYmxlIGV4cGVjdGVkIGVycm9yLCBidXQgaW4gXCIke3RoaXMuc3RhdGV9XCIgc3RhdGVgKTtcclxuICB9XHJcblxyXG4gIGlzKG90aGVyKSB7XHJcbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cclxuICAgIHJldHVybiBvdGhlci5zdGF0ZSA9PT0gdGhpcy5zdGF0ZSAmJiBvdGhlci5jb250ZW50cyA9PT0gdGhpcy5jb250ZW50cztcclxuICB9XHJcblxyXG4gIG1hcChfbWFwKSB7XHJcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcclxuICB9XHJcblxyXG59XHJcblxyXG5jbGFzcyBWYWx1ZUxvYWRhYmxlIGV4dGVuZHMgQmFzZUxvYWRhYmxlIHtcclxuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCAnaGFzVmFsdWUnKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZW50c1wiLCB2b2lkIDApO1xyXG5cclxuICAgIHRoaXMuY29udGVudHMgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIGdldFZhbHVlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XHJcbiAgfVxyXG5cclxuICB0b1Byb21pc2UoKSB7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29udGVudHMpO1xyXG4gIH1cclxuXHJcbiAgdmFsdWVNYXliZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzO1xyXG4gIH1cclxuXHJcbiAgdmFsdWVPclRocm93KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XHJcbiAgfVxyXG5cclxuICBwcm9taXNlTWF5YmUoKSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgZXJyb3JNYXliZSgpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBtYXAobWFwKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBuZXh0ID0gbWFwKHRoaXMuY29udGVudHMpO1xyXG4gICAgICByZXR1cm4gUmVjb2lsX2lzUHJvbWlzZShuZXh0KSA/IGxvYWRhYmxlV2l0aFByb21pc2UobmV4dCkgOiBpc0xvYWRhYmxlKG5leHQpID8gbmV4dCA6IGxvYWRhYmxlV2l0aFZhbHVlKG5leHQpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICByZXR1cm4gUmVjb2lsX2lzUHJvbWlzZShlKSA/IC8vIElmIHdlIFwic3VzcGVuZGVkXCIsIHRoZW4gdHJ5IGFnYWluLlxyXG4gICAgICAvLyBlcnJvcnMgYW5kIHN1YnNlcXVlbnQgcmV0cmllcyB3aWxsIGJlIGhhbmRsZWQgaW4gJ2xvYWRpbmcnIGNhc2VcclxuICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXHJcbiAgICAgIGxvYWRhYmxlV2l0aFByb21pc2UoZS5uZXh0KCgpID0+IHRoaXMubWFwKG1hcCkpKSA6IGxvYWRhYmxlV2l0aEVycm9yKGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIEVycm9yTG9hZGFibGUgZXh0ZW5kcyBCYXNlTG9hZGFibGUge1xyXG4gIGNvbnN0cnVjdG9yKGVycm9yKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsICdoYXNFcnJvcicpO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRlbnRzXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy5jb250ZW50cyA9IGVycm9yO1xyXG4gIH1cclxuXHJcbiAgZ2V0VmFsdWUoKSB7XHJcbiAgICB0aHJvdyB0aGlzLmNvbnRlbnRzO1xyXG4gIH1cclxuXHJcbiAgdG9Qcm9taXNlKCkge1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuY29udGVudHMpO1xyXG4gIH1cclxuXHJcbiAgdmFsdWVNYXliZSgpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBwcm9taXNlTWF5YmUoKSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgZXJyb3JNYXliZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzO1xyXG4gIH1cclxuXHJcbiAgZXJyb3JPclRocm93KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XHJcbiAgfVxyXG5cclxuICBtYXAoX21hcCkge1xyXG4gICAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuY2xhc3MgTG9hZGluZ0xvYWRhYmxlIGV4dGVuZHMgQmFzZUxvYWRhYmxlIHtcclxuICBjb25zdHJ1Y3Rvcihwcm9taXNlKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsICdsb2FkaW5nJyk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGVudHNcIiwgdm9pZCAwKTtcclxuXHJcbiAgICB0aGlzLmNvbnRlbnRzID0gcHJvbWlzZTtcclxuICB9XHJcblxyXG4gIGdldFZhbHVlKCkge1xyXG4gICAgdGhyb3cgdGhpcy5jb250ZW50cztcclxuICB9XHJcblxyXG4gIHRvUHJvbWlzZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzO1xyXG4gIH1cclxuXHJcbiAgdmFsdWVNYXliZSgpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBwcm9taXNlTWF5YmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcclxuICB9XHJcblxyXG4gIHByb21pc2VPclRocm93KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XHJcbiAgfVxyXG5cclxuICBlcnJvck1heWJlKCkge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIG1hcChtYXApIHtcclxuICAgIHJldHVybiBsb2FkYWJsZVdpdGhQcm9taXNlKHRoaXMuY29udGVudHMudGhlbih2YWx1ZSA9PiB7XHJcbiAgICAgIGNvbnN0IG5leHQgPSBtYXAodmFsdWUpO1xyXG5cclxuICAgICAgaWYgKGlzTG9hZGFibGUobmV4dCkpIHtcclxuICAgICAgICBjb25zdCBuZXh0TG9hZGFibGUgPSBuZXh0O1xyXG5cclxuICAgICAgICBzd2l0Y2ggKG5leHRMb2FkYWJsZS5zdGF0ZSkge1xyXG4gICAgICAgICAgY2FzZSAnaGFzVmFsdWUnOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV4dExvYWRhYmxlLmNvbnRlbnRzO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ2hhc0Vycm9yJzpcclxuICAgICAgICAgICAgdGhyb3cgbmV4dExvYWRhYmxlLmNvbnRlbnRzO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ2xvYWRpbmcnOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV4dExvYWRhYmxlLmNvbnRlbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgfSAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1yZXR1cm5dXHJcblxyXG5cclxuICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UoZSkpIHtcclxuICAgICAgICAvLyB3ZSB3ZXJlIFwic3VzcGVuZGVkLFwiIHRyeSBhZ2FpblxyXG4gICAgICAgIHJldHVybiBlLnRoZW4oKCkgPT4gdGhpcy5tYXAobWFwKS5jb250ZW50cyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IGU7XHJcbiAgICB9KSk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gbG9hZGFibGVXaXRoVmFsdWUodmFsdWUpIHtcclxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuZXcgVmFsdWVMb2FkYWJsZSh2YWx1ZSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsb2FkYWJsZVdpdGhFcnJvcihlcnJvcikge1xyXG4gIHJldHVybiBPYmplY3QuZnJlZXplKG5ldyBFcnJvckxvYWRhYmxlKGVycm9yKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvYWRhYmxlV2l0aFByb21pc2UocHJvbWlzZSkge1xyXG4gIHJldHVybiBPYmplY3QuZnJlZXplKG5ldyBMb2FkaW5nTG9hZGFibGUocHJvbWlzZSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsb2FkYWJsZUxvYWRpbmcoKSB7XHJcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobmV3IExvYWRpbmdMb2FkYWJsZShuZXcgUHJvbWlzZSgoKSA9PiB7fSkpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbG9hZGFibGVBbGxBcnJheShpbnB1dHMpIHtcclxuICByZXR1cm4gaW5wdXRzLmV2ZXJ5KGkgPT4gaS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJykgPyBsb2FkYWJsZVdpdGhWYWx1ZShpbnB1dHMubWFwKGkgPT4gaS5jb250ZW50cykpIDogaW5wdXRzLnNvbWUoaSA9PiBpLnN0YXRlID09PSAnaGFzRXJyb3InKSA/IGxvYWRhYmxlV2l0aEVycm9yKFJlY29pbF9udWxsdGhyb3dzKGlucHV0cy5maW5kKGkgPT4gaS5zdGF0ZSA9PT0gJ2hhc0Vycm9yJyksICdJbnZhbGlkIGxvYWRhYmxlIHBhc3NlZCB0byBsb2FkYWJsZUFsbCcpLmNvbnRlbnRzKSA6IGxvYWRhYmxlV2l0aFByb21pc2UoUHJvbWlzZS5hbGwoaW5wdXRzLm1hcChpID0+IGkuY29udGVudHMpKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvYWRhYmxlQWxsKGlucHV0cykge1xyXG4gIGNvbnN0IHVud3JhcGVkSW5wdXRzID0gQXJyYXkuaXNBcnJheShpbnB1dHMpID8gaW5wdXRzIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5wdXRzKS5tYXAoa2V5ID0+IGlucHV0c1trZXldKTtcclxuICBjb25zdCBub3JtYWxpemVkSW5wdXRzID0gdW53cmFwZWRJbnB1dHMubWFwKHggPT4gaXNMb2FkYWJsZSh4KSA/IHggOiBSZWNvaWxfaXNQcm9taXNlKHgpID8gbG9hZGFibGVXaXRoUHJvbWlzZSh4KSA6IGxvYWRhYmxlV2l0aFZhbHVlKHgpKTtcclxuICBjb25zdCBvdXRwdXQgPSBsb2FkYWJsZUFsbEFycmF5KG5vcm1hbGl6ZWRJbnB1dHMpO1xyXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0cykgPyAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1yZXR1cm5dXHJcbiAgb3V0cHV0IDogLy8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoKSBoYXMgY29uc2lzdGVudCBrZXkgb3JkZXJpbmcgd2l0aCBFUzZcclxuICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1jYWxsXVxyXG4gIG91dHB1dC5tYXAob3V0cHV0cyA9PiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbnB1dHMpLnJlZHVjZSgob3V0LCBrZXksIGlkeCkgPT4gKHsgLi4ub3V0LFxyXG4gICAgW2tleV06IG91dHB1dHNbaWR4XVxyXG4gIH0pLCB7fSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0xvYWRhYmxlKHgpIHtcclxuICByZXR1cm4geCBpbnN0YW5jZW9mIEJhc2VMb2FkYWJsZTtcclxufVxyXG5cclxuY29uc3QgTG9hZGFibGVTdGF0aWNJbnRlcmZhY2UgPSB7XHJcbiAgb2Y6IHZhbHVlID0+IFJlY29pbF9pc1Byb21pc2UodmFsdWUpID8gbG9hZGFibGVXaXRoUHJvbWlzZSh2YWx1ZSkgOiBpc0xvYWRhYmxlKHZhbHVlKSA/IHZhbHVlIDogbG9hZGFibGVXaXRoVmFsdWUodmFsdWUpLFxyXG4gIGVycm9yOiBlcnJvciA9PiBsb2FkYWJsZVdpdGhFcnJvcihlcnJvciksXHJcbiAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxyXG4gIGxvYWRpbmc6ICgpID0+IGxvYWRhYmxlTG9hZGluZygpLFxyXG4gIC8vICRGbG93SXNzdWVbdW5jbGVhci10eXBlXVxyXG4gIGFsbDogbG9hZGFibGVBbGwsXHJcbiAgaXNMb2FkYWJsZVxyXG59O1xyXG52YXIgUmVjb2lsX0xvYWRhYmxlID0ge1xyXG4gIGxvYWRhYmxlV2l0aFZhbHVlLFxyXG4gIGxvYWRhYmxlV2l0aEVycm9yLFxyXG4gIGxvYWRhYmxlV2l0aFByb21pc2UsXHJcbiAgbG9hZGFibGVMb2FkaW5nLFxyXG4gIGxvYWRhYmxlQWxsLFxyXG4gIGlzTG9hZGFibGUsXHJcbiAgUmVjb2lsTG9hZGFibGU6IExvYWRhYmxlU3RhdGljSW50ZXJmYWNlXHJcbn07XHJcblxyXG52YXIgUmVjb2lsX0xvYWRhYmxlXzEgPSBSZWNvaWxfTG9hZGFibGUubG9hZGFibGVXaXRoVmFsdWU7XHJcbnZhciBSZWNvaWxfTG9hZGFibGVfMiA9IFJlY29pbF9Mb2FkYWJsZS5sb2FkYWJsZVdpdGhFcnJvcjtcclxudmFyIFJlY29pbF9Mb2FkYWJsZV8zID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlV2l0aFByb21pc2U7XHJcbnZhciBSZWNvaWxfTG9hZGFibGVfNCA9IFJlY29pbF9Mb2FkYWJsZS5sb2FkYWJsZUxvYWRpbmc7XHJcbnZhciBSZWNvaWxfTG9hZGFibGVfNSA9IFJlY29pbF9Mb2FkYWJsZS5sb2FkYWJsZUFsbDtcclxudmFyIFJlY29pbF9Mb2FkYWJsZV82ID0gUmVjb2lsX0xvYWRhYmxlLmlzTG9hZGFibGU7XHJcbnZhciBSZWNvaWxfTG9hZGFibGVfNyA9IFJlY29pbF9Mb2FkYWJsZS5SZWNvaWxMb2FkYWJsZTtcclxuXHJcbnZhciBSZWNvaWxfTG9hZGFibGUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgbG9hZGFibGVXaXRoVmFsdWU6IFJlY29pbF9Mb2FkYWJsZV8xLFxyXG4gIGxvYWRhYmxlV2l0aEVycm9yOiBSZWNvaWxfTG9hZGFibGVfMixcclxuICBsb2FkYWJsZVdpdGhQcm9taXNlOiBSZWNvaWxfTG9hZGFibGVfMyxcclxuICBsb2FkYWJsZUxvYWRpbmc6IFJlY29pbF9Mb2FkYWJsZV80LFxyXG4gIGxvYWRhYmxlQWxsOiBSZWNvaWxfTG9hZGFibGVfNSxcclxuICBpc0xvYWRhYmxlOiBSZWNvaWxfTG9hZGFibGVfNixcclxuICBSZWNvaWxMb2FkYWJsZTogUmVjb2lsX0xvYWRhYmxlXzdcclxufSk7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG5cclxuY29uc3QgZ2tzID0gbmV3IE1hcCgpLnNldCgncmVjb2lsX2hhbXRfMjAyMCcsIHRydWUpLnNldCgncmVjb2lsX3N5bmNfZXh0ZXJuYWxfc3RvcmUnLCB0cnVlKS5zZXQoJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycsIHRydWUpLnNldCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnLCB0cnVlKTtcclxuXHJcbmZ1bmN0aW9uIFJlY29pbF9na3hfT1NTKGdrKSB7XHJcbiAgdmFyIF9na3MkZ2V0O1xyXG5cclxuICByZXR1cm4gKF9na3MkZ2V0ID0gZ2tzLmdldChnaykpICE9PSBudWxsICYmIF9na3MkZ2V0ICE9PSB2b2lkIDAgPyBfZ2tzJGdldCA6IGZhbHNlO1xyXG59XHJcblxyXG5SZWNvaWxfZ2t4X09TUy5zZXRQYXNzID0gZ2sgPT4ge1xyXG4gIGdrcy5zZXQoZ2ssIHRydWUpO1xyXG59O1xyXG5cclxuUmVjb2lsX2dreF9PU1Muc2V0RmFpbCA9IGdrID0+IHtcclxuICBna3Muc2V0KGdrLCBmYWxzZSk7XHJcbn07XHJcblxyXG5SZWNvaWxfZ2t4X09TUy5jbGVhciA9ICgpID0+IHtcclxuICBna3MuY2xlYXIoKTtcclxufTtcclxuXHJcbnZhciBSZWNvaWxfZ2t4ID0gUmVjb2lsX2dreF9PU1M7IC8vIEBvc3Mtb25seVxyXG5cclxudmFyIF9jcmVhdGVNdXRhYmxlU291cmNlLCBfdXNlTXV0YWJsZVNvdXJjZSwgX3VzZVN5bmNFeHRlcm5hbFN0b3JlO1xyXG5cclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IGNyZWF0ZU11dGFibGVTb3VyY2UgPSAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxyXG4oX2NyZWF0ZU11dGFibGVTb3VyY2UgPSByZWFjdC5jcmVhdGVNdXRhYmxlU291cmNlKSAhPT0gbnVsbCAmJiBfY3JlYXRlTXV0YWJsZVNvdXJjZSAhPT0gdm9pZCAwID8gX2NyZWF0ZU11dGFibGVTb3VyY2UgOiByZWFjdC51bnN0YWJsZV9jcmVhdGVNdXRhYmxlU291cmNlO1xyXG5jb25zdCB1c2VNdXRhYmxlU291cmNlID0gLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcclxuKF91c2VNdXRhYmxlU291cmNlID0gcmVhY3QudXNlTXV0YWJsZVNvdXJjZSkgIT09IG51bGwgJiYgX3VzZU11dGFibGVTb3VyY2UgIT09IHZvaWQgMCA/IF91c2VNdXRhYmxlU291cmNlIDogcmVhY3QudW5zdGFibGVfdXNlTXV0YWJsZVNvdXJjZTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0d2cvcmVhY3QtMTgvZGlzY3Vzc2lvbnMvODZcclxuXHJcbmNvbnN0IHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcclxuKF91c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IHJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlKSAhPT0gbnVsbCAmJiBfdXNlU3luY0V4dGVybmFsU3RvcmUgIT09IHZvaWQgMCA/IF91c2VTeW5jRXh0ZXJuYWxTdG9yZSA6IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXHJcbnJlYWN0LnVuc3RhYmxlX3VzZVN5bmNFeHRlcm5hbFN0b3JlO1xyXG5cclxuLyoqXHJcbiAqIG1vZGU6IFRoZSBSZWFjdCBBUEkgYW5kIGFwcHJvYWNoIHRvIHVzZSBmb3Igc3luY2luZyBzdGF0ZSB3aXRoIFJlYWN0XHJcbiAqIGVhcmx5OiBSZS1yZW5kZXJzIGZyb20gUmVjb2lsIHVwZGF0ZXMgb2NjdXI6XHJcbiAqICAgIDEpIGVhcmxpZXJcclxuICogICAgMikgaW4gc3luYyB3aXRoIFJlYWN0IHVwZGF0ZXMgaW4gdGhlIHNhbWUgYmF0Y2hcclxuICogICAgMykgYmVmb3JlIHRyYW5zYWN0aW9uIG9ic2VydmVycyBpbnN0ZWFkIG9mIGFmdGVyLlxyXG4gKiBjb25jdXJyZW50OiBJcyB0aGUgY3VycmVudCBtb2RlIGNvbXBhdGlibGUgd2l0aCBDb25jdXJyZW50IE1vZGUgYW5kIHVzZVRyYW5zaXRpb24oKVxyXG4gKi9cclxuZnVuY3Rpb24gcmVhY3RNb2RlKCkge1xyXG4gIC8vIE5PVEU6IFRoaXMgbW9kZSBpcyBjdXJyZW50bHkgYnJva2VuIHdpdGggc29tZSBTdXNwZW5zZSBjYXNlc1xyXG4gIC8vIHNlZSBSZWNvaWxfc2VsZWN0b3ItdGVzdC5qc1xyXG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfdHJhbnNpdGlvbl9zdXBwb3J0JykpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG1vZGU6ICdUUkFOU0lUSU9OX1NVUFBPUlQnLFxyXG4gICAgICBlYXJseTogdHJ1ZSxcclxuICAgICAgY29uY3VycmVudDogdHJ1ZVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfc3luY19leHRlcm5hbF9zdG9yZScpICYmIHVzZVN5bmNFeHRlcm5hbFN0b3JlICE9IG51bGwpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG1vZGU6ICdTWU5DX0VYVEVSTkFMX1NUT1JFJyxcclxuICAgICAgZWFybHk6IHRydWUsXHJcbiAgICAgIGNvbmN1cnJlbnQ6IGZhbHNlXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tdXRhYmxlX3NvdXJjZScpICYmIHVzZU11dGFibGVTb3VyY2UgIT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LiRkaXNhYmxlUmVjb2lsVmFsdWVNdXRhYmxlU291cmNlX1RFTVBfSEFDS19ET19OT1RfVVNFKSB7XHJcbiAgICByZXR1cm4gUmVjb2lsX2dreCgncmVjb2lsX3N1cHByZXNzX3JlcmVuZGVyX2luX2NhbGxiYWNrJykgPyB7XHJcbiAgICAgIG1vZGU6ICdNVVRBQkxFX1NPVVJDRScsXHJcbiAgICAgIGVhcmx5OiB0cnVlLFxyXG4gICAgICBjb25jdXJyZW50OiB0cnVlXHJcbiAgICB9IDoge1xyXG4gICAgICBtb2RlOiAnTVVUQUJMRV9TT1VSQ0UnLFxyXG4gICAgICBlYXJseTogZmFsc2UsXHJcbiAgICAgIGNvbmN1cnJlbnQ6IGZhbHNlXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFJlY29pbF9na3goJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycpID8ge1xyXG4gICAgbW9kZTogJ0xFR0FDWScsXHJcbiAgICBlYXJseTogdHJ1ZSxcclxuICAgIGNvbmN1cnJlbnQ6IGZhbHNlXHJcbiAgfSA6IHtcclxuICAgIG1vZGU6ICdMRUdBQ1knLFxyXG4gICAgZWFybHk6IGZhbHNlLFxyXG4gICAgY29uY3VycmVudDogZmFsc2VcclxuICB9O1xyXG59IC8vIFRPRE8gTmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoZXJlIGlzIGEgc3RhbmRhcmQvb3Blbi1zb3VyY2UgZXF1aXZhbGVudCB0byBzZWUgaWYgaG90IG1vZHVsZSByZXBsYWNlbWVudCBpcyBoYXBwZW5pbmc6XHJcblxyXG5cclxuZnVuY3Rpb24gaXNGYXN0UmVmcmVzaEVuYWJsZWQoKSB7XHJcbiAgLy8gQGZiLW9ubHk6IGNvbnN0IHtpc0FjY2VwdGluZ1VwZGF0ZX0gPSByZXF1aXJlKCdfX2RlYnVnJyk7XHJcbiAgLy8gQGZiLW9ubHk6IHJldHVybiB0eXBlb2YgaXNBY2NlcHRpbmdVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaXNBY2NlcHRpbmdVcGRhdGUoKTtcclxuICByZXR1cm4gZmFsc2U7IC8vIEBvc3Mtb25seVxyXG59XHJcblxyXG52YXIgUmVjb2lsX1JlYWN0TW9kZSA9IHtcclxuICBjcmVhdGVNdXRhYmxlU291cmNlLFxyXG4gIHVzZU11dGFibGVTb3VyY2UsXHJcbiAgdXNlU3luY0V4dGVybmFsU3RvcmUsXHJcbiAgcmVhY3RNb2RlLFxyXG4gIGlzRmFzdFJlZnJlc2hFbmFibGVkXHJcbn07XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXHJcbmNsYXNzIEFic3RyYWN0UmVjb2lsVmFsdWUge1xyXG4gIGNvbnN0cnVjdG9yKG5ld0tleSkge1xyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5XCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy5rZXkgPSBuZXdLZXk7XHJcbiAgfVxyXG5cclxuICB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBrZXk6IHRoaXMua2V5XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIFJlY29pbFN0YXRlIGV4dGVuZHMgQWJzdHJhY3RSZWNvaWxWYWx1ZSB7fVxyXG5cclxuY2xhc3MgUmVjb2lsVmFsdWVSZWFkT25seSBleHRlbmRzIEFic3RyYWN0UmVjb2lsVmFsdWUge31cclxuXHJcbmZ1bmN0aW9uIGlzUmVjb2lsVmFsdWUoeCkge1xyXG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVjb2lsU3RhdGUgfHwgeCBpbnN0YW5jZW9mIFJlY29pbFZhbHVlUmVhZE9ubHk7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfUmVjb2lsVmFsdWUgPSB7XHJcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZSxcclxuICBSZWNvaWxTdGF0ZSxcclxuICBSZWNvaWxWYWx1ZVJlYWRPbmx5LFxyXG4gIGlzUmVjb2lsVmFsdWVcclxufTtcclxuXHJcbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVfMSA9IFJlY29pbF9SZWNvaWxWYWx1ZS5BYnN0cmFjdFJlY29pbFZhbHVlO1xyXG52YXIgUmVjb2lsX1JlY29pbFZhbHVlXzIgPSBSZWNvaWxfUmVjb2lsVmFsdWUuUmVjb2lsU3RhdGU7XHJcbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVfMyA9IFJlY29pbF9SZWNvaWxWYWx1ZS5SZWNvaWxWYWx1ZVJlYWRPbmx5O1xyXG52YXIgUmVjb2lsX1JlY29pbFZhbHVlXzQgPSBSZWNvaWxfUmVjb2lsVmFsdWUuaXNSZWNvaWxWYWx1ZTtcclxuXHJcbnZhciBSZWNvaWxfUmVjb2lsVmFsdWUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZTogUmVjb2lsX1JlY29pbFZhbHVlXzEsXHJcbiAgUmVjb2lsU3RhdGU6IFJlY29pbF9SZWNvaWxWYWx1ZV8yLFxyXG4gIFJlY29pbFZhbHVlUmVhZE9ubHk6IFJlY29pbF9SZWNvaWxWYWx1ZV8zLFxyXG4gIGlzUmVjb2lsVmFsdWU6IFJlY29pbF9SZWNvaWxWYWx1ZV80XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHNwcmludGYoZm9ybWF0LCAuLi5hcmdzKSB7XHJcbiAgbGV0IGluZGV4ID0gMDtcclxuICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoLyVzL2csICgpID0+IFN0cmluZyhhcmdzW2luZGV4KytdKSk7XHJcbn1cclxuXHJcbnZhciBzcHJpbnRmXzEgPSBzcHJpbnRmO1xyXG5cclxuZnVuY3Rpb24gZXhwZWN0YXRpb25WaW9sYXRpb24oZm9ybWF0LCAuLi5hcmdzKSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgY29uc3QgbWVzc2FnZSA9IHNwcmludGZfMS5jYWxsKG51bGwsIGZvcm1hdCwgLi4uYXJncyk7XHJcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIGVycm9yLm5hbWUgPSAnRXhwZWN0YXRpb24gVmlvbGF0aW9uJztcclxuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGV4cGVjdGF0aW9uVmlvbGF0aW9uXzEgPSBleHBlY3RhdGlvblZpb2xhdGlvbjtcclxuXHJcbi8vIEBvc3Mtb25seVxyXG5cclxuXHJcbnZhciBSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24gPSBleHBlY3RhdGlvblZpb2xhdGlvbl8xO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaXRlcmFibGUgd2hvc2Ugb3V0cHV0IGlzIGdlbmVyYXRlZCBieSBwYXNzaW5nIHRoZSBpbnB1dFxyXG4gKiBpdGVyYWJsZSdzIHZhbHVlcyB0aHJvdWdoIHRoZSBtYXBwZXIgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWFwSXRlcmFibGUoaXRlcmFibGUsIGNhbGxiYWNrKSB7XHJcbiAgLy8gVXNlIGdlbmVyYXRvciB0byBjcmVhdGUgaXRlcmFibGUvaXRlcmF0b3JcclxuICByZXR1cm4gZnVuY3Rpb24qICgpIHtcclxuICAgIGxldCBpbmRleCA9IDA7XHJcblxyXG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xyXG4gICAgICB5aWVsZCBjYWxsYmFjayh2YWx1ZSwgaW5kZXgrKyk7XHJcbiAgICB9XHJcbiAgfSgpO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX21hcEl0ZXJhYmxlID0gbWFwSXRlcmFibGU7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcmVjb3ZlcmFibGVWaW9sYXRpb24obWVzc2FnZSwgX3Byb2plY3ROYW1lLCB7XHJcbiAgZXJyb3JcclxufSA9IHt9KSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBlcnJvcik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxudmFyIHJlY292ZXJhYmxlVmlvbGF0aW9uXzEgPSByZWNvdmVyYWJsZVZpb2xhdGlvbjtcclxuXHJcbi8vIEBvc3Mtb25seVxyXG5cclxuXHJcbnZhciBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24gPSByZWNvdmVyYWJsZVZpb2xhdGlvbl8xO1xyXG5cclxuY29uc3Qge1xyXG4gIGlzRmFzdFJlZnJlc2hFbmFibGVkOiBpc0Zhc3RSZWZyZXNoRW5hYmxlZCQxXHJcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgRGVmYXVsdFZhbHVlIHt9XHJcblxyXG5jb25zdCBERUZBVUxUX1ZBTFVFID0gbmV3IERlZmF1bHRWYWx1ZSgpO1xyXG4vLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxyXG5jb25zdCBub2RlcyA9IG5ldyBNYXAoKTsgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcclxuXHJcbmNvbnN0IHJlY29pbFZhbHVlcyA9IG5ldyBNYXAoKTtcclxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVkZWNsYXJlICovXHJcblxyXG5mdW5jdGlvbiByZWNvaWxWYWx1ZXNGb3JLZXlzKGtleXMpIHtcclxuICByZXR1cm4gUmVjb2lsX21hcEl0ZXJhYmxlKGtleXMsIGtleSA9PiBSZWNvaWxfbnVsbHRocm93cyhyZWNvaWxWYWx1ZXMuZ2V0KGtleSkpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVnaXN0ZXJOb2RlKG5vZGUpIHtcclxuICBpZiAobm9kZXMuaGFzKG5vZGUua2V5KSkge1xyXG4gICAgY29uc3QgbWVzc2FnZSA9IGBEdXBsaWNhdGUgYXRvbSBrZXkgXCIke25vZGUua2V5fVwiLiBUaGlzIGlzIGEgRkFUQUwgRVJST1IgaW5cclxuICAgICAgcHJvZHVjdGlvbi4gQnV0IGl0IGlzIHNhZmUgdG8gaWdub3JlIHRoaXMgd2FybmluZyBpZiBpdCBvY2N1cnJlZCBiZWNhdXNlIG9mXHJcbiAgICAgIGhvdCBtb2R1bGUgcmVwbGFjZW1lbnQuYDtcclxuXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgIC8vIFRPRE8gRmlndXJlIHRoaXMgb3V0IGZvciBvcGVuLXNvdXJjZVxyXG4gICAgICBpZiAoIWlzRmFzdFJlZnJlc2hFbmFibGVkJDEoKSkge1xyXG4gICAgICAgIFJlY29pbF9leHBlY3RhdGlvblZpb2xhdGlvbihtZXNzYWdlLCAncmVjb2lsJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEBmYi1vbmx5OiByZWNvdmVyYWJsZVZpb2xhdGlvbihtZXNzYWdlLCAncmVjb2lsJyk7XHJcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTsgLy8gQG9zcy1vbmx5XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBub2Rlcy5zZXQobm9kZS5rZXksIG5vZGUpO1xyXG4gIGNvbnN0IHJlY29pbFZhbHVlID0gbm9kZS5zZXQgPT0gbnVsbCA/IG5ldyBSZWNvaWxfUmVjb2lsVmFsdWUkMS5SZWNvaWxWYWx1ZVJlYWRPbmx5KG5vZGUua2V5KSA6IG5ldyBSZWNvaWxfUmVjb2lsVmFsdWUkMS5SZWNvaWxTdGF0ZShub2RlLmtleSk7XHJcbiAgcmVjb2lsVmFsdWVzLnNldChub2RlLmtleSwgcmVjb2lsVmFsdWUpO1xyXG4gIHJldHVybiByZWNvaWxWYWx1ZTtcclxufVxyXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXJlZGVjbGFyZSAqL1xyXG5cclxuXHJcbmNsYXNzIE5vZGVNaXNzaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7fSAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldE5vZGUoa2V5KSB7XHJcbiAgY29uc3Qgbm9kZSA9IG5vZGVzLmdldChrZXkpO1xyXG5cclxuICBpZiAobm9kZSA9PSBudWxsKSB7XHJcbiAgICB0aHJvdyBuZXcgTm9kZU1pc3NpbmdFcnJvcihgTWlzc2luZyBkZWZpbml0aW9uIGZvciBSZWNvaWxWYWx1ZTogXCIke2tleX1cIlwiYCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbm9kZTtcclxufSAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldE5vZGVNYXliZShrZXkpIHtcclxuICByZXR1cm4gbm9kZXMuZ2V0KGtleSk7XHJcbn1cclxuXHJcbmNvbnN0IGNvbmZpZ0RlbGV0aW9uSGFuZGxlcnMgPSBuZXcgTWFwKCk7XHJcblxyXG5mdW5jdGlvbiBkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZShrZXkpIHtcclxuICB2YXIgX25vZGUkc2hvdWxkRGVsZXRlQ29uO1xyXG5cclxuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGNvbnN0IG5vZGUgPSBub2Rlcy5nZXQoa2V5KTtcclxuXHJcbiAgaWYgKG5vZGUgIT09IG51bGwgJiYgbm9kZSAhPT0gdm9pZCAwICYmIChfbm9kZSRzaG91bGREZWxldGVDb24gPSBub2RlLnNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZSkgIT09IG51bGwgJiYgX25vZGUkc2hvdWxkRGVsZXRlQ29uICE9PSB2b2lkIDAgJiYgX25vZGUkc2hvdWxkRGVsZXRlQ29uLmNhbGwobm9kZSkpIHtcclxuICAgIHZhciBfZ2V0Q29uZmlnRGVsZXRpb25IYW47XHJcblxyXG4gICAgbm9kZXMuZGVsZXRlKGtleSk7XHJcbiAgICAoX2dldENvbmZpZ0RlbGV0aW9uSGFuID0gZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyKGtleSkpID09PSBudWxsIHx8IF9nZXRDb25maWdEZWxldGlvbkhhbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldENvbmZpZ0RlbGV0aW9uSGFuKCk7XHJcbiAgICBjb25maWdEZWxldGlvbkhhbmRsZXJzLmRlbGV0ZShrZXkpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyKGtleSwgZm4pIHtcclxuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlmIChmbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBjb25maWdEZWxldGlvbkhhbmRsZXJzLmRlbGV0ZShrZXkpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25maWdEZWxldGlvbkhhbmRsZXJzLnNldChrZXksIGZuKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlcihrZXkpIHtcclxuICByZXR1cm4gY29uZmlnRGVsZXRpb25IYW5kbGVycy5nZXQoa2V5KTtcclxufVxyXG5cclxudmFyIFJlY29pbF9Ob2RlID0ge1xyXG4gIG5vZGVzLFxyXG4gIHJlY29pbFZhbHVlcyxcclxuICByZWdpc3Rlck5vZGUsXHJcbiAgZ2V0Tm9kZSxcclxuICBnZXROb2RlTWF5YmUsXHJcbiAgZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGUsXHJcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyLFxyXG4gIGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlcixcclxuICByZWNvaWxWYWx1ZXNGb3JLZXlzLFxyXG4gIE5vZGVNaXNzaW5nRXJyb3IsXHJcbiAgRGVmYXVsdFZhbHVlLFxyXG4gIERFRkFVTFRfVkFMVUVcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcblxyXG5mdW5jdGlvbiBlbnF1ZXVlRXhlY3V0aW9uKHMsIGYpIHtcclxuICBmKCk7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfUXVldWUgPSB7XHJcbiAgZW5xdWV1ZUV4ZWN1dGlvblxyXG59O1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xyXG5cdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcclxufVxyXG5cclxudmFyIGhhbXRfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcclxuXHJcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XHJcbn0gOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XHJcbn07XHJcbi8qKlxyXG4gICAgQGZpbGVPdmVydmlldyBIYXNoIEFycmF5IE1hcHBlZCBUcmllLlxyXG5cclxuICAgIENvZGUgYmFzZWQgb246IGh0dHBzOi8vZ2l0aHViLmNvbS9leGNsaXB5L3BkYXRhXHJcbiovXHJcblxyXG5cclxudmFyIGhhbXQgPSB7fTsgLy8gZXhwb3J0XHJcblxyXG4vKiBDb25maWd1cmF0aW9uXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG52YXIgU0laRSA9IDU7XHJcbnZhciBCVUNLRVRfU0laRSA9IE1hdGgucG93KDIsIFNJWkUpO1xyXG52YXIgTUFTSyA9IEJVQ0tFVF9TSVpFIC0gMTtcclxudmFyIE1BWF9JTkRFWF9OT0RFID0gQlVDS0VUX1NJWkUgLyAyO1xyXG52YXIgTUlOX0FSUkFZX05PREUgPSBCVUNLRVRfU0laRSAvIDQ7XHJcbi8qXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG52YXIgbm90aGluZyA9IHt9O1xyXG5cclxudmFyIGNvbnN0YW50ID0gZnVuY3Rpb24gY29uc3RhbnQoeCkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4geDtcclxuICB9O1xyXG59O1xyXG4vKipcclxuICAgIEdldCAzMiBiaXQgaGFzaCBvZiBzdHJpbmcuXHJcblxyXG4gICAgQmFzZWQgb246XHJcbiAgICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc2MTY0NjEvZ2VuZXJhdGUtYS1oYXNoLWZyb20tc3RyaW5nLWluLWphdmFzY3JpcHQtanF1ZXJ5XHJcbiovXHJcblxyXG5cclxudmFyIGhhc2ggPSBoYW10Lmhhc2ggPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihzdHIpO1xyXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJykgcmV0dXJuIHN0cjtcclxuICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHN0ciArPSAnJztcclxuICB2YXIgaGFzaCA9IDA7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgYyB8IDA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaGFzaDtcclxufTtcclxuLyogQml0IE9wc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLyoqXHJcbiAgICBIYW1taW5nIHdlaWdodC5cclxuXHJcbiAgICBUYWtlbiBmcm9tOiBodHRwOi8vanNwZXJmLmNvbS9oYW1taW5nLXdlaWdodFxyXG4qL1xyXG5cclxuXHJcbnZhciBwb3Bjb3VudCA9IGZ1bmN0aW9uIHBvcGNvdW50KHgpIHtcclxuICB4IC09IHggPj4gMSAmIDB4NTU1NTU1NTU7XHJcbiAgeCA9ICh4ICYgMHgzMzMzMzMzMykgKyAoeCA+PiAyICYgMHgzMzMzMzMzMyk7XHJcbiAgeCA9IHggKyAoeCA+PiA0KSAmIDB4MGYwZjBmMGY7XHJcbiAgeCArPSB4ID4+IDg7XHJcbiAgeCArPSB4ID4+IDE2O1xyXG4gIHJldHVybiB4ICYgMHg3ZjtcclxufTtcclxuXHJcbnZhciBoYXNoRnJhZ21lbnQgPSBmdW5jdGlvbiBoYXNoRnJhZ21lbnQoc2hpZnQsIGgpIHtcclxuICByZXR1cm4gaCA+Pj4gc2hpZnQgJiBNQVNLO1xyXG59O1xyXG5cclxudmFyIHRvQml0bWFwID0gZnVuY3Rpb24gdG9CaXRtYXAoeCkge1xyXG4gIHJldHVybiAxIDw8IHg7XHJcbn07XHJcblxyXG52YXIgZnJvbUJpdG1hcCA9IGZ1bmN0aW9uIGZyb21CaXRtYXAoYml0bWFwLCBiaXQpIHtcclxuICByZXR1cm4gcG9wY291bnQoYml0bWFwICYgYml0IC0gMSk7XHJcbn07XHJcbi8qIEFycmF5IE9wc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLyoqXHJcbiAgICBTZXQgYSB2YWx1ZSBpbiBhbiBhcnJheS5cclxuXHJcbiAgICBAcGFyYW0gbXV0YXRlIFNob3VsZCB0aGUgaW5wdXQgYXJyYXkgYmUgbXV0YXRlZD9cclxuICAgIEBwYXJhbSBhdCBJbmRleCB0byBjaGFuZ2UuXHJcbiAgICBAcGFyYW0gdiBOZXcgdmFsdWVcclxuICAgIEBwYXJhbSBhcnIgQXJyYXkuXHJcbiovXHJcblxyXG5cclxudmFyIGFycmF5VXBkYXRlID0gZnVuY3Rpb24gYXJyYXlVcGRhdGUobXV0YXRlLCBhdCwgdiwgYXJyKSB7XHJcbiAgdmFyIG91dCA9IGFycjtcclxuXHJcbiAgaWYgKCFtdXRhdGUpIHtcclxuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gICAgb3V0ID0gbmV3IEFycmF5KGxlbik7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBvdXRbaV0gPSBhcnJbaV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvdXRbYXRdID0gdjtcclxuICByZXR1cm4gb3V0O1xyXG59O1xyXG4vKipcclxuICAgIFJlbW92ZSBhIHZhbHVlIGZyb20gYW4gYXJyYXkuXHJcblxyXG4gICAgQHBhcmFtIG11dGF0ZSBTaG91bGQgdGhlIGlucHV0IGFycmF5IGJlIG11dGF0ZWQ/XHJcbiAgICBAcGFyYW0gYXQgSW5kZXggdG8gcmVtb3ZlLlxyXG4gICAgQHBhcmFtIGFyciBBcnJheS5cclxuKi9cclxuXHJcblxyXG52YXIgYXJyYXlTcGxpY2VPdXQgPSBmdW5jdGlvbiBhcnJheVNwbGljZU91dChtdXRhdGUsIGF0LCBhcnIpIHtcclxuICB2YXIgbmV3TGVuID0gYXJyLmxlbmd0aCAtIDE7XHJcbiAgdmFyIGkgPSAwO1xyXG4gIHZhciBnID0gMDtcclxuICB2YXIgb3V0ID0gYXJyO1xyXG5cclxuICBpZiAobXV0YXRlKSB7XHJcbiAgICBpID0gZyA9IGF0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvdXQgPSBuZXcgQXJyYXkobmV3TGVuKTtcclxuXHJcbiAgICB3aGlsZSAoaSA8IGF0KSB7XHJcbiAgICAgIG91dFtnKytdID0gYXJyW2krK107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICArK2k7XHJcblxyXG4gIHdoaWxlIChpIDw9IG5ld0xlbikge1xyXG4gICAgb3V0W2crK10gPSBhcnJbaSsrXTtcclxuICB9XHJcblxyXG4gIGlmIChtdXRhdGUpIHtcclxuICAgIG91dC5sZW5ndGggPSBuZXdMZW47XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb3V0O1xyXG59O1xyXG4vKipcclxuICAgIEluc2VydCBhIHZhbHVlIGludG8gYW4gYXJyYXkuXHJcblxyXG4gICAgQHBhcmFtIG11dGF0ZSBTaG91bGQgdGhlIGlucHV0IGFycmF5IGJlIG11dGF0ZWQ/XHJcbiAgICBAcGFyYW0gYXQgSW5kZXggdG8gaW5zZXJ0IGF0LlxyXG4gICAgQHBhcmFtIHYgVmFsdWUgdG8gaW5zZXJ0LFxyXG4gICAgQHBhcmFtIGFyciBBcnJheS5cclxuKi9cclxuXHJcblxyXG52YXIgYXJyYXlTcGxpY2VJbiA9IGZ1bmN0aW9uIGFycmF5U3BsaWNlSW4obXV0YXRlLCBhdCwgdiwgYXJyKSB7XHJcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XHJcblxyXG4gIGlmIChtdXRhdGUpIHtcclxuICAgIHZhciBfaSA9IGxlbjtcclxuXHJcbiAgICB3aGlsZSAoX2kgPj0gYXQpIHtcclxuICAgICAgYXJyW19pLS1dID0gYXJyW19pXTtcclxuICAgIH1cclxuXHJcbiAgICBhcnJbYXRdID0gdjtcclxuICAgIHJldHVybiBhcnI7XHJcbiAgfVxyXG5cclxuICB2YXIgaSA9IDAsXHJcbiAgICAgIGcgPSAwO1xyXG4gIHZhciBvdXQgPSBuZXcgQXJyYXkobGVuICsgMSk7XHJcblxyXG4gIHdoaWxlIChpIDwgYXQpIHtcclxuICAgIG91dFtnKytdID0gYXJyW2krK107XHJcbiAgfVxyXG5cclxuICBvdXRbYXRdID0gdjtcclxuXHJcbiAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgIG91dFsrK2ddID0gYXJyW2krK107XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb3V0O1xyXG59O1xyXG4vKiBOb2RlIFN0cnVjdHVyZXNcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG52YXIgTEVBRiA9IDE7XHJcbnZhciBDT0xMSVNJT04gPSAyO1xyXG52YXIgSU5ERVggPSAzO1xyXG52YXIgQVJSQVkgPSA0O1xyXG4vKipcclxuICAgIEVtcHR5IG5vZGUuXHJcbiovXHJcblxyXG52YXIgZW1wdHkgPSB7XHJcbiAgX19oYW10X2lzRW1wdHk6IHRydWVcclxufTtcclxuXHJcbnZhciBpc0VtcHR5Tm9kZSA9IGZ1bmN0aW9uIGlzRW1wdHlOb2RlKHgpIHtcclxuICByZXR1cm4geCA9PT0gZW1wdHkgfHwgeCAmJiB4Ll9faGFtdF9pc0VtcHR5O1xyXG59O1xyXG4vKipcclxuICAgIExlYWYgaG9sZGluZyBhIHZhbHVlLlxyXG5cclxuICAgIEBtZW1iZXIgZWRpdCBFZGl0IG9mIHRoZSBub2RlLlxyXG4gICAgQG1lbWJlciBoYXNoIEhhc2ggb2Yga2V5LlxyXG4gICAgQG1lbWJlciBrZXkgS2V5LlxyXG4gICAgQG1lbWJlciB2YWx1ZSBWYWx1ZSBzdG9yZWQuXHJcbiovXHJcblxyXG5cclxudmFyIExlYWYgPSBmdW5jdGlvbiBMZWFmKGVkaXQsIGhhc2gsIGtleSwgdmFsdWUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogTEVBRixcclxuICAgIGVkaXQ6IGVkaXQsXHJcbiAgICBoYXNoOiBoYXNoLFxyXG4gICAga2V5OiBrZXksXHJcbiAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICBfbW9kaWZ5OiBMZWFmX19tb2RpZnlcclxuICB9O1xyXG59O1xyXG4vKipcclxuICAgIExlYWYgaG9sZGluZyBtdWx0aXBsZSB2YWx1ZXMgd2l0aCB0aGUgc2FtZSBoYXNoIGJ1dCBkaWZmZXJlbnQga2V5cy5cclxuXHJcbiAgICBAbWVtYmVyIGVkaXQgRWRpdCBvZiB0aGUgbm9kZS5cclxuICAgIEBtZW1iZXIgaGFzaCBIYXNoIG9mIGtleS5cclxuICAgIEBtZW1iZXIgY2hpbGRyZW4gQXJyYXkgb2YgY29sbGlzaW9uIGNoaWxkcmVuIG5vZGUuXHJcbiovXHJcblxyXG5cclxudmFyIENvbGxpc2lvbiA9IGZ1bmN0aW9uIENvbGxpc2lvbihlZGl0LCBoYXNoLCBjaGlsZHJlbikge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiBDT0xMSVNJT04sXHJcbiAgICBlZGl0OiBlZGl0LFxyXG4gICAgaGFzaDogaGFzaCxcclxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcclxuICAgIF9tb2RpZnk6IENvbGxpc2lvbl9fbW9kaWZ5XHJcbiAgfTtcclxufTtcclxuLyoqXHJcbiAgICBJbnRlcm5hbCBub2RlIHdpdGggYSBzcGFyc2Ugc2V0IG9mIGNoaWxkcmVuLlxyXG5cclxuICAgIFVzZXMgYSBiaXRtYXAgYW5kIGFycmF5IHRvIHBhY2sgY2hpbGRyZW4uXHJcblxyXG4gIEBtZW1iZXIgZWRpdCBFZGl0IG9mIHRoZSBub2RlLlxyXG4gICAgQG1lbWJlciBtYXNrIEJpdG1hcCB0aGF0IGVuY29kZSB0aGUgcG9zaXRpb25zIG9mIGNoaWxkcmVuIGluIHRoZSBhcnJheS5cclxuICAgIEBtZW1iZXIgY2hpbGRyZW4gQXJyYXkgb2YgY2hpbGQgbm9kZXMuXHJcbiovXHJcblxyXG5cclxudmFyIEluZGV4ZWROb2RlID0gZnVuY3Rpb24gSW5kZXhlZE5vZGUoZWRpdCwgbWFzaywgY2hpbGRyZW4pIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogSU5ERVgsXHJcbiAgICBlZGl0OiBlZGl0LFxyXG4gICAgbWFzazogbWFzayxcclxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcclxuICAgIF9tb2RpZnk6IEluZGV4ZWROb2RlX19tb2RpZnlcclxuICB9O1xyXG59O1xyXG4vKipcclxuICAgIEludGVybmFsIG5vZGUgd2l0aCBtYW55IGNoaWxkcmVuLlxyXG5cclxuICAgIEBtZW1iZXIgZWRpdCBFZGl0IG9mIHRoZSBub2RlLlxyXG4gICAgQG1lbWJlciBzaXplIE51bWJlciBvZiBjaGlsZHJlbi5cclxuICAgIEBtZW1iZXIgY2hpbGRyZW4gQXJyYXkgb2YgY2hpbGQgbm9kZXMuXHJcbiovXHJcblxyXG5cclxudmFyIEFycmF5Tm9kZSA9IGZ1bmN0aW9uIEFycmF5Tm9kZShlZGl0LCBzaXplLCBjaGlsZHJlbikge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiBBUlJBWSxcclxuICAgIGVkaXQ6IGVkaXQsXHJcbiAgICBzaXplOiBzaXplLFxyXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxyXG4gICAgX21vZGlmeTogQXJyYXlOb2RlX19tb2RpZnlcclxuICB9O1xyXG59O1xyXG4vKipcclxuICAgIElzIGBub2RlYCBhIGxlYWYgbm9kZT9cclxuKi9cclxuXHJcblxyXG52YXIgaXNMZWFmID0gZnVuY3Rpb24gaXNMZWFmKG5vZGUpIHtcclxuICByZXR1cm4gbm9kZSA9PT0gZW1wdHkgfHwgbm9kZS50eXBlID09PSBMRUFGIHx8IG5vZGUudHlwZSA9PT0gQ09MTElTSU9OO1xyXG59O1xyXG4vKiBJbnRlcm5hbCBub2RlIG9wZXJhdGlvbnMuXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vKipcclxuICAgIEV4cGFuZCBhbiBpbmRleGVkIG5vZGUgaW50byBhbiBhcnJheSBub2RlLlxyXG5cclxuICBAcGFyYW0gZWRpdCBDdXJyZW50IGVkaXQuXHJcbiAgICBAcGFyYW0gZnJhZyBJbmRleCBvZiBhZGRlZCBjaGlsZC5cclxuICAgIEBwYXJhbSBjaGlsZCBBZGRlZCBjaGlsZC5cclxuICAgIEBwYXJhbSBtYXNrIEluZGV4IG5vZGUgbWFzayBiZWZvcmUgY2hpbGQgYWRkZWQuXHJcbiAgICBAcGFyYW0gc3ViTm9kZXMgSW5kZXggbm9kZSBjaGlsZHJlbiBiZWZvcmUgY2hpbGQgYWRkZWQuXHJcbiovXHJcblxyXG5cclxudmFyIGV4cGFuZCA9IGZ1bmN0aW9uIGV4cGFuZChlZGl0LCBmcmFnLCBjaGlsZCwgYml0bWFwLCBzdWJOb2Rlcykge1xyXG4gIHZhciBhcnIgPSBbXTtcclxuICB2YXIgYml0ID0gYml0bWFwO1xyXG4gIHZhciBjb3VudCA9IDA7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBiaXQ7ICsraSkge1xyXG4gICAgaWYgKGJpdCAmIDEpIGFycltpXSA9IHN1Yk5vZGVzW2NvdW50KytdO1xyXG4gICAgYml0ID4+Pj0gMTtcclxuICB9XHJcblxyXG4gIGFycltmcmFnXSA9IGNoaWxkO1xyXG4gIHJldHVybiBBcnJheU5vZGUoZWRpdCwgY291bnQgKyAxLCBhcnIpO1xyXG59O1xyXG4vKipcclxuICAgIENvbGxhcHNlIGFuIGFycmF5IG5vZGUgaW50byBhIGluZGV4ZWQgbm9kZS5cclxuXHJcbiAgQHBhcmFtIGVkaXQgQ3VycmVudCBlZGl0LlxyXG4gICAgQHBhcmFtIGNvdW50IE51bWJlciBvZiBlbGVtZW50cyBpbiBuZXcgYXJyYXkuXHJcbiAgICBAcGFyYW0gcmVtb3ZlZCBJbmRleCBvZiByZW1vdmVkIGVsZW1lbnQuXHJcbiAgICBAcGFyYW0gZWxlbWVudHMgQXJyYXkgbm9kZSBjaGlsZHJlbiBiZWZvcmUgcmVtb3ZlLlxyXG4qL1xyXG5cclxuXHJcbnZhciBwYWNrID0gZnVuY3Rpb24gcGFjayhlZGl0LCBjb3VudCwgcmVtb3ZlZCwgZWxlbWVudHMpIHtcclxuICB2YXIgY2hpbGRyZW4gPSBuZXcgQXJyYXkoY291bnQgLSAxKTtcclxuICB2YXIgZyA9IDA7XHJcbiAgdmFyIGJpdG1hcCA9IDA7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgaWYgKGkgIT09IHJlbW92ZWQpIHtcclxuICAgICAgdmFyIGVsZW0gPSBlbGVtZW50c1tpXTtcclxuXHJcbiAgICAgIGlmIChlbGVtICYmICFpc0VtcHR5Tm9kZShlbGVtKSkge1xyXG4gICAgICAgIGNoaWxkcmVuW2crK10gPSBlbGVtO1xyXG4gICAgICAgIGJpdG1hcCB8PSAxIDw8IGk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBJbmRleGVkTm9kZShlZGl0LCBiaXRtYXAsIGNoaWxkcmVuKTtcclxufTtcclxuLyoqXHJcbiAgICBNZXJnZSB0d28gbGVhZiBub2Rlcy5cclxuXHJcbiAgICBAcGFyYW0gc2hpZnQgQ3VycmVudCBzaGlmdC5cclxuICAgIEBwYXJhbSBoMSBOb2RlIDEgaGFzaC5cclxuICAgIEBwYXJhbSBuMSBOb2RlIDEuXHJcbiAgICBAcGFyYW0gaDIgTm9kZSAyIGhhc2guXHJcbiAgICBAcGFyYW0gbjIgTm9kZSAyLlxyXG4qL1xyXG5cclxuXHJcbnZhciBtZXJnZUxlYXZlcyA9IGZ1bmN0aW9uIG1lcmdlTGVhdmVzKGVkaXQsIHNoaWZ0LCBoMSwgbjEsIGgyLCBuMikge1xyXG4gIGlmIChoMSA9PT0gaDIpIHJldHVybiBDb2xsaXNpb24oZWRpdCwgaDEsIFtuMiwgbjFdKTtcclxuICB2YXIgc3ViSDEgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGgxKTtcclxuICB2YXIgc3ViSDIgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGgyKTtcclxuICByZXR1cm4gSW5kZXhlZE5vZGUoZWRpdCwgdG9CaXRtYXAoc3ViSDEpIHwgdG9CaXRtYXAoc3ViSDIpLCBzdWJIMSA9PT0gc3ViSDIgPyBbbWVyZ2VMZWF2ZXMoZWRpdCwgc2hpZnQgKyBTSVpFLCBoMSwgbjEsIGgyLCBuMildIDogc3ViSDEgPCBzdWJIMiA/IFtuMSwgbjJdIDogW24yLCBuMV0pO1xyXG59O1xyXG4vKipcclxuICAgIFVwZGF0ZSBhbiBlbnRyeSBpbiBhIGNvbGxpc2lvbiBsaXN0LlxyXG5cclxuICAgIEBwYXJhbSBtdXRhdGUgU2hvdWxkIG11dGF0aW9uIGJlIHVzZWQ/XHJcbiAgICBAcGFyYW0gZWRpdCBDdXJyZW50IGVkaXQuXHJcbiAgICBAcGFyYW0ga2V5RXEgS2V5IGNvbXBhcmUgZnVuY3Rpb24uXHJcbiAgICBAcGFyYW0gaGFzaCBIYXNoIG9mIGNvbGxpc2lvbi5cclxuICAgIEBwYXJhbSBsaXN0IENvbGxpc2lvbiBsaXN0LlxyXG4gICAgQHBhcmFtIGYgVXBkYXRlIGZ1bmN0aW9uLlxyXG4gICAgQHBhcmFtIGsgS2V5IHRvIHVwZGF0ZS5cclxuICAgIEBwYXJhbSBzaXplIFNpemUgcmVmLlxyXG4qL1xyXG5cclxuXHJcbnZhciB1cGRhdGVDb2xsaXNpb25MaXN0ID0gZnVuY3Rpb24gdXBkYXRlQ29sbGlzaW9uTGlzdChtdXRhdGUsIGVkaXQsIGtleUVxLCBoLCBsaXN0LCBmLCBrLCBzaXplKSB7XHJcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICB2YXIgY2hpbGQgPSBsaXN0W2ldO1xyXG5cclxuICAgIGlmIChrZXlFcShrLCBjaGlsZC5rZXkpKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IGNoaWxkLnZhbHVlO1xyXG5cclxuICAgICAgdmFyIF9uZXdWYWx1ZSA9IGYodmFsdWUpO1xyXG5cclxuICAgICAgaWYgKF9uZXdWYWx1ZSA9PT0gdmFsdWUpIHJldHVybiBsaXN0O1xyXG5cclxuICAgICAgaWYgKF9uZXdWYWx1ZSA9PT0gbm90aGluZykge1xyXG4gICAgICAgIC0tc2l6ZS52YWx1ZTtcclxuICAgICAgICByZXR1cm4gYXJyYXlTcGxpY2VPdXQobXV0YXRlLCBpLCBsaXN0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGFycmF5VXBkYXRlKG11dGF0ZSwgaSwgTGVhZihlZGl0LCBoLCBrLCBfbmV3VmFsdWUpLCBsaXN0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBuZXdWYWx1ZSA9IGYoKTtcclxuICBpZiAobmV3VmFsdWUgPT09IG5vdGhpbmcpIHJldHVybiBsaXN0O1xyXG4gICsrc2l6ZS52YWx1ZTtcclxuICByZXR1cm4gYXJyYXlVcGRhdGUobXV0YXRlLCBsZW4sIExlYWYoZWRpdCwgaCwgaywgbmV3VmFsdWUpLCBsaXN0KTtcclxufTtcclxuXHJcbnZhciBjYW5FZGl0Tm9kZSA9IGZ1bmN0aW9uIGNhbkVkaXROb2RlKGVkaXQsIG5vZGUpIHtcclxuICByZXR1cm4gZWRpdCA9PT0gbm9kZS5lZGl0O1xyXG59O1xyXG4vKiBFZGl0aW5nXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxudmFyIExlYWZfX21vZGlmeSA9IGZ1bmN0aW9uIExlYWZfX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQsIGYsIGgsIGssIHNpemUpIHtcclxuICBpZiAoa2V5RXEoaywgdGhpcy5rZXkpKSB7XHJcbiAgICB2YXIgX3YgPSBmKHRoaXMudmFsdWUpO1xyXG5cclxuICAgIGlmIChfdiA9PT0gdGhpcy52YWx1ZSkgcmV0dXJuIHRoaXM7ZWxzZSBpZiAoX3YgPT09IG5vdGhpbmcpIHtcclxuICAgICAgLS1zaXplLnZhbHVlO1xyXG4gICAgICByZXR1cm4gZW1wdHk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNhbkVkaXROb2RlKGVkaXQsIHRoaXMpKSB7XHJcbiAgICAgIHRoaXMudmFsdWUgPSBfdjtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIExlYWYoZWRpdCwgaCwgaywgX3YpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHYgPSBmKCk7XHJcbiAgaWYgKHYgPT09IG5vdGhpbmcpIHJldHVybiB0aGlzO1xyXG4gICsrc2l6ZS52YWx1ZTtcclxuICByZXR1cm4gbWVyZ2VMZWF2ZXMoZWRpdCwgc2hpZnQsIHRoaXMuaGFzaCwgdGhpcywgaCwgTGVhZihlZGl0LCBoLCBrLCB2KSk7XHJcbn07XHJcblxyXG52YXIgQ29sbGlzaW9uX19tb2RpZnkgPSBmdW5jdGlvbiBDb2xsaXNpb25fX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQsIGYsIGgsIGssIHNpemUpIHtcclxuICBpZiAoaCA9PT0gdGhpcy5oYXNoKSB7XHJcbiAgICB2YXIgY2FuRWRpdCA9IGNhbkVkaXROb2RlKGVkaXQsIHRoaXMpO1xyXG4gICAgdmFyIGxpc3QgPSB1cGRhdGVDb2xsaXNpb25MaXN0KGNhbkVkaXQsIGVkaXQsIGtleUVxLCB0aGlzLmhhc2gsIHRoaXMuY2hpbGRyZW4sIGYsIGssIHNpemUpO1xyXG4gICAgaWYgKGxpc3QgPT09IHRoaXMuY2hpbGRyZW4pIHJldHVybiB0aGlzO1xyXG4gICAgcmV0dXJuIGxpc3QubGVuZ3RoID4gMSA/IENvbGxpc2lvbihlZGl0LCB0aGlzLmhhc2gsIGxpc3QpIDogbGlzdFswXTsgLy8gY29sbGFwc2Ugc2luZ2xlIGVsZW1lbnQgY29sbGlzaW9uIGxpc3RcclxuICB9XHJcblxyXG4gIHZhciB2ID0gZigpO1xyXG4gIGlmICh2ID09PSBub3RoaW5nKSByZXR1cm4gdGhpcztcclxuICArK3NpemUudmFsdWU7XHJcbiAgcmV0dXJuIG1lcmdlTGVhdmVzKGVkaXQsIHNoaWZ0LCB0aGlzLmhhc2gsIHRoaXMsIGgsIExlYWYoZWRpdCwgaCwgaywgdikpO1xyXG59O1xyXG5cclxudmFyIEluZGV4ZWROb2RlX19tb2RpZnkgPSBmdW5jdGlvbiBJbmRleGVkTm9kZV9fbW9kaWZ5KGVkaXQsIGtleUVxLCBzaGlmdCwgZiwgaCwgaywgc2l6ZSkge1xyXG4gIHZhciBtYXNrID0gdGhpcy5tYXNrO1xyXG4gIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcbiAgdmFyIGZyYWcgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGgpO1xyXG4gIHZhciBiaXQgPSB0b0JpdG1hcChmcmFnKTtcclxuICB2YXIgaW5keCA9IGZyb21CaXRtYXAobWFzaywgYml0KTtcclxuICB2YXIgZXhpc3RzID0gbWFzayAmIGJpdDtcclxuICB2YXIgY3VycmVudCA9IGV4aXN0cyA/IGNoaWxkcmVuW2luZHhdIDogZW1wdHk7XHJcblxyXG4gIHZhciBjaGlsZCA9IGN1cnJlbnQuX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQgKyBTSVpFLCBmLCBoLCBrLCBzaXplKTtcclxuXHJcbiAgaWYgKGN1cnJlbnQgPT09IGNoaWxkKSByZXR1cm4gdGhpcztcclxuICB2YXIgY2FuRWRpdCA9IGNhbkVkaXROb2RlKGVkaXQsIHRoaXMpO1xyXG4gIHZhciBiaXRtYXAgPSBtYXNrO1xyXG4gIHZhciBuZXdDaGlsZHJlbiA9IHZvaWQgMDtcclxuXHJcbiAgaWYgKGV4aXN0cyAmJiBpc0VtcHR5Tm9kZShjaGlsZCkpIHtcclxuICAgIC8vIHJlbW92ZVxyXG4gICAgYml0bWFwICY9IH5iaXQ7XHJcbiAgICBpZiAoIWJpdG1hcCkgcmV0dXJuIGVtcHR5O1xyXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA8PSAyICYmIGlzTGVhZihjaGlsZHJlbltpbmR4IF4gMV0pKSByZXR1cm4gY2hpbGRyZW5baW5keCBeIDFdOyAvLyBjb2xsYXBzZVxyXG5cclxuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlTcGxpY2VPdXQoY2FuRWRpdCwgaW5keCwgY2hpbGRyZW4pO1xyXG4gIH0gZWxzZSBpZiAoIWV4aXN0cyAmJiAhaXNFbXB0eU5vZGUoY2hpbGQpKSB7XHJcbiAgICAvLyBhZGRcclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPj0gTUFYX0lOREVYX05PREUpIHJldHVybiBleHBhbmQoZWRpdCwgZnJhZywgY2hpbGQsIG1hc2ssIGNoaWxkcmVuKTtcclxuICAgIGJpdG1hcCB8PSBiaXQ7XHJcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5U3BsaWNlSW4oY2FuRWRpdCwgaW5keCwgY2hpbGQsIGNoaWxkcmVuKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gbW9kaWZ5XHJcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5VXBkYXRlKGNhbkVkaXQsIGluZHgsIGNoaWxkLCBjaGlsZHJlbik7XHJcbiAgfVxyXG5cclxuICBpZiAoY2FuRWRpdCkge1xyXG4gICAgdGhpcy5tYXNrID0gYml0bWFwO1xyXG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gSW5kZXhlZE5vZGUoZWRpdCwgYml0bWFwLCBuZXdDaGlsZHJlbik7XHJcbn07XHJcblxyXG52YXIgQXJyYXlOb2RlX19tb2RpZnkgPSBmdW5jdGlvbiBBcnJheU5vZGVfX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQsIGYsIGgsIGssIHNpemUpIHtcclxuICB2YXIgY291bnQgPSB0aGlzLnNpemU7XHJcbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuICB2YXIgZnJhZyA9IGhhc2hGcmFnbWVudChzaGlmdCwgaCk7XHJcbiAgdmFyIGNoaWxkID0gY2hpbGRyZW5bZnJhZ107XHJcblxyXG4gIHZhciBuZXdDaGlsZCA9IChjaGlsZCB8fCBlbXB0eSkuX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQgKyBTSVpFLCBmLCBoLCBrLCBzaXplKTtcclxuXHJcbiAgaWYgKGNoaWxkID09PSBuZXdDaGlsZCkgcmV0dXJuIHRoaXM7XHJcbiAgdmFyIGNhbkVkaXQgPSBjYW5FZGl0Tm9kZShlZGl0LCB0aGlzKTtcclxuICB2YXIgbmV3Q2hpbGRyZW4gPSB2b2lkIDA7XHJcblxyXG4gIGlmIChpc0VtcHR5Tm9kZShjaGlsZCkgJiYgIWlzRW1wdHlOb2RlKG5ld0NoaWxkKSkge1xyXG4gICAgLy8gYWRkXHJcbiAgICArK2NvdW50O1xyXG4gICAgbmV3Q2hpbGRyZW4gPSBhcnJheVVwZGF0ZShjYW5FZGl0LCBmcmFnLCBuZXdDaGlsZCwgY2hpbGRyZW4pO1xyXG4gIH0gZWxzZSBpZiAoIWlzRW1wdHlOb2RlKGNoaWxkKSAmJiBpc0VtcHR5Tm9kZShuZXdDaGlsZCkpIHtcclxuICAgIC8vIHJlbW92ZVxyXG4gICAgLS1jb3VudDtcclxuICAgIGlmIChjb3VudCA8PSBNSU5fQVJSQVlfTk9ERSkgcmV0dXJuIHBhY2soZWRpdCwgY291bnQsIGZyYWcsIGNoaWxkcmVuKTtcclxuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlVcGRhdGUoY2FuRWRpdCwgZnJhZywgZW1wdHksIGNoaWxkcmVuKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gbW9kaWZ5XHJcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5VXBkYXRlKGNhbkVkaXQsIGZyYWcsIG5ld0NoaWxkLCBjaGlsZHJlbik7XHJcbiAgfVxyXG5cclxuICBpZiAoY2FuRWRpdCkge1xyXG4gICAgdGhpcy5zaXplID0gY291bnQ7XHJcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHJldHVybiBBcnJheU5vZGUoZWRpdCwgY291bnQsIG5ld0NoaWxkcmVuKTtcclxufTtcclxuXHJcbmVtcHR5Ll9tb2RpZnkgPSBmdW5jdGlvbiAoZWRpdCwga2V5RXEsIHNoaWZ0LCBmLCBoLCBrLCBzaXplKSB7XHJcbiAgdmFyIHYgPSBmKCk7XHJcbiAgaWYgKHYgPT09IG5vdGhpbmcpIHJldHVybiBlbXB0eTtcclxuICArK3NpemUudmFsdWU7XHJcbiAgcmV0dXJuIExlYWYoZWRpdCwgaCwgaywgdik7XHJcbn07XHJcbi8qXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxuZnVuY3Rpb24gTWFwKGVkaXRhYmxlLCBlZGl0LCBjb25maWcsIHJvb3QsIHNpemUpIHtcclxuICB0aGlzLl9lZGl0YWJsZSA9IGVkaXRhYmxlO1xyXG4gIHRoaXMuX2VkaXQgPSBlZGl0O1xyXG4gIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcclxuICB0aGlzLl9yb290ID0gcm9vdDtcclxuICB0aGlzLl9zaXplID0gc2l6ZTtcclxufVxyXG5cclxuTWFwLnByb3RvdHlwZS5zZXRUcmVlID0gZnVuY3Rpb24gKG5ld1Jvb3QsIG5ld1NpemUpIHtcclxuICBpZiAodGhpcy5fZWRpdGFibGUpIHtcclxuICAgIHRoaXMuX3Jvb3QgPSBuZXdSb290O1xyXG4gICAgdGhpcy5fc2l6ZSA9IG5ld1NpemU7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHJldHVybiBuZXdSb290ID09PSB0aGlzLl9yb290ID8gdGhpcyA6IG5ldyBNYXAodGhpcy5fZWRpdGFibGUsIHRoaXMuX2VkaXQsIHRoaXMuX2NvbmZpZywgbmV3Um9vdCwgbmV3U2l6ZSk7XHJcbn07XHJcbi8qIFF1ZXJpZXNcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8qKlxyXG4gICAgTG9va3VwIHRoZSB2YWx1ZSBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgYSBjdXN0b20gYGhhc2hgLlxyXG5cclxuICAgIFJldHVybnMgdGhlIHZhbHVlIG9yIGBhbHRgIGlmIG5vbmUuXHJcbiovXHJcblxyXG5cclxudmFyIHRyeUdldEhhc2ggPSBoYW10LnRyeUdldEhhc2ggPSBmdW5jdGlvbiAoYWx0LCBoYXNoLCBrZXksIG1hcCkge1xyXG4gIHZhciBub2RlID0gbWFwLl9yb290O1xyXG4gIHZhciBzaGlmdCA9IDA7XHJcbiAgdmFyIGtleUVxID0gbWFwLl9jb25maWcua2V5RXE7XHJcblxyXG4gIHdoaWxlICh0cnVlKSB7XHJcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICBjYXNlIExFQUY6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcmV0dXJuIGtleUVxKGtleSwgbm9kZS5rZXkpID8gbm9kZS52YWx1ZSA6IGFsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICBjYXNlIENPTExJU0lPTjpcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZiAoaGFzaCA9PT0gbm9kZS5oYXNoKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICBpZiAoa2V5RXEoa2V5LCBjaGlsZC5rZXkpKSByZXR1cm4gY2hpbGQudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gYWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIGNhc2UgSU5ERVg6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdmFyIGZyYWcgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGhhc2gpO1xyXG4gICAgICAgICAgdmFyIGJpdCA9IHRvQml0bWFwKGZyYWcpO1xyXG5cclxuICAgICAgICAgIGlmIChub2RlLm1hc2sgJiBiaXQpIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bZnJvbUJpdG1hcChub2RlLm1hc2ssIGJpdCldO1xyXG4gICAgICAgICAgICBzaGlmdCArPSBTSVpFO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gYWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIGNhc2UgQVJSQVk6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5baGFzaEZyYWdtZW50KHNoaWZ0LCBoYXNoKV07XHJcblxyXG4gICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgc2hpZnQgKz0gU0laRTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGFsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBhbHQ7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS50cnlHZXRIYXNoID0gZnVuY3Rpb24gKGFsdCwgaGFzaCwga2V5KSB7XHJcbiAgcmV0dXJuIHRyeUdldEhhc2goYWx0LCBoYXNoLCBrZXksIHRoaXMpO1xyXG59O1xyXG4vKipcclxuICAgIExvb2t1cCB0aGUgdmFsdWUgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGludGVybmFsIGhhc2ggZnVuY3Rpb24uXHJcblxyXG4gICAgQHNlZSBgdHJ5R2V0SGFzaGBcclxuKi9cclxuXHJcblxyXG52YXIgdHJ5R2V0ID0gaGFtdC50cnlHZXQgPSBmdW5jdGlvbiAoYWx0LCBrZXksIG1hcCkge1xyXG4gIHJldHVybiB0cnlHZXRIYXNoKGFsdCwgbWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIG1hcCk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLnRyeUdldCA9IGZ1bmN0aW9uIChhbHQsIGtleSkge1xyXG4gIHJldHVybiB0cnlHZXQoYWx0LCBrZXksIHRoaXMpO1xyXG59O1xyXG4vKipcclxuICAgIExvb2t1cCB0aGUgdmFsdWUgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGEgY3VzdG9tIGBoYXNoYC5cclxuXHJcbiAgICBSZXR1cm5zIHRoZSB2YWx1ZSBvciBgdW5kZWZpbmVkYCBpZiBub25lLlxyXG4qL1xyXG5cclxuXHJcbnZhciBnZXRIYXNoID0gaGFtdC5nZXRIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgbWFwKSB7XHJcbiAgcmV0dXJuIHRyeUdldEhhc2godW5kZWZpbmVkLCBoYXNoLCBrZXksIG1hcCk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLmdldEhhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5KSB7XHJcbiAgcmV0dXJuIGdldEhhc2goaGFzaCwga2V5LCB0aGlzKTtcclxufTtcclxuLyoqXHJcbiAgICBMb29rdXAgdGhlIHZhbHVlIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxyXG5cclxuICAgIEBzZWUgYGdldGBcclxuKi9cclxuXHJcblxyXG52YXIgZ2V0ID0gaGFtdC5nZXQgPSBmdW5jdGlvbiAoa2V5LCBtYXApIHtcclxuICByZXR1cm4gdHJ5R2V0SGFzaCh1bmRlZmluZWQsIG1hcC5fY29uZmlnLmhhc2goa2V5KSwga2V5LCBtYXApO1xyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5LCBhbHQpIHtcclxuICByZXR1cm4gdHJ5R2V0KGFsdCwga2V5LCB0aGlzKTtcclxufTtcclxuLyoqXHJcbiAgICBEb2VzIGFuIGVudHJ5IGV4aXN0IGZvciBga2V5YCBpbiBgbWFwYD8gVXNlcyBjdXN0b20gYGhhc2hgLlxyXG4qL1xyXG5cclxuXHJcbnZhciBoYXNIYXNoID0gaGFtdC5oYXMgPSBmdW5jdGlvbiAoaGFzaCwga2V5LCBtYXApIHtcclxuICByZXR1cm4gdHJ5R2V0SGFzaChub3RoaW5nLCBoYXNoLCBrZXksIG1hcCkgIT09IG5vdGhpbmc7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLmhhc0hhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5KSB7XHJcbiAgcmV0dXJuIGhhc0hhc2goaGFzaCwga2V5LCB0aGlzKTtcclxufTtcclxuLyoqXHJcbiAgICBEb2VzIGFuIGVudHJ5IGV4aXN0IGZvciBga2V5YCBpbiBgbWFwYD8gVXNlcyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxyXG4qL1xyXG5cclxuXHJcbnZhciBoYXMgPSBoYW10LmhhcyA9IGZ1bmN0aW9uIChrZXksIG1hcCkge1xyXG4gIHJldHVybiBoYXNIYXNoKG1hcC5fY29uZmlnLmhhc2goa2V5KSwga2V5LCBtYXApO1xyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgcmV0dXJuIGhhcyhrZXksIHRoaXMpO1xyXG59O1xyXG5cclxudmFyIGRlZktleUNvbXBhcmUgPSBmdW5jdGlvbiBkZWZLZXlDb21wYXJlKHgsIHkpIHtcclxuICByZXR1cm4geCA9PT0geTtcclxufTtcclxuLyoqXHJcbiAgICBDcmVhdGUgYW4gZW1wdHkgbWFwLlxyXG5cclxuICAgIEBwYXJhbSBjb25maWcgQ29uZmlndXJhdGlvbi5cclxuKi9cclxuXHJcblxyXG5oYW10Lm1ha2UgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgcmV0dXJuIG5ldyBNYXAoMCwgMCwge1xyXG4gICAga2V5RXE6IGNvbmZpZyAmJiBjb25maWcua2V5RXEgfHwgZGVmS2V5Q29tcGFyZSxcclxuICAgIGhhc2g6IGNvbmZpZyAmJiBjb25maWcuaGFzaCB8fCBoYXNoXHJcbiAgfSwgZW1wdHksIDApO1xyXG59O1xyXG4vKipcclxuICAgIEVtcHR5IG1hcC5cclxuKi9cclxuXHJcblxyXG5oYW10LmVtcHR5ID0gaGFtdC5tYWtlKCk7XHJcbi8qKlxyXG4gICAgRG9lcyBgbWFwYCBjb250YWluIGFueSBlbGVtZW50cz9cclxuKi9cclxuXHJcbnZhciBpc0VtcHR5ID0gaGFtdC5pc0VtcHR5ID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gIHJldHVybiBtYXAgJiYgISFpc0VtcHR5Tm9kZShtYXAuX3Jvb3QpO1xyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBpc0VtcHR5KHRoaXMpO1xyXG59O1xyXG4vKiBVcGRhdGVzXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vKipcclxuICAgIEFsdGVyIHRoZSB2YWx1ZSBzdG9yZWQgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGZ1bmN0aW9uIGBmYCB1c2luZ1xyXG4gICAgY3VzdG9tIGhhc2guXHJcblxyXG4gICAgYGZgIGlzIGludm9rZWQgd2l0aCB0aGUgY3VycmVudCB2YWx1ZSBmb3IgYGtgIGlmIGl0IGV4aXN0cyxcclxuICAgIG9yIG5vIGFyZ3VtZW50cyBpZiBubyBzdWNoIHZhbHVlIGV4aXN0cy4gYG1vZGlmeWAgd2lsbCBhbHdheXMgZWl0aGVyXHJcbiAgICB1cGRhdGUgb3IgaW5zZXJ0IGEgdmFsdWUgaW50byB0aGUgbWFwLlxyXG5cclxuICAgIFJldHVybnMgYSBtYXAgd2l0aCB0aGUgbW9kaWZpZWQgdmFsdWUuIERvZXMgbm90IGFsdGVyIGBtYXBgLlxyXG4qL1xyXG5cclxuXHJcbnZhciBtb2RpZnlIYXNoID0gaGFtdC5tb2RpZnlIYXNoID0gZnVuY3Rpb24gKGYsIGhhc2gsIGtleSwgbWFwKSB7XHJcbiAgdmFyIHNpemUgPSB7XHJcbiAgICB2YWx1ZTogbWFwLl9zaXplXHJcbiAgfTtcclxuXHJcbiAgdmFyIG5ld1Jvb3QgPSBtYXAuX3Jvb3QuX21vZGlmeShtYXAuX2VkaXRhYmxlID8gbWFwLl9lZGl0IDogTmFOLCBtYXAuX2NvbmZpZy5rZXlFcSwgMCwgZiwgaGFzaCwga2V5LCBzaXplKTtcclxuXHJcbiAgcmV0dXJuIG1hcC5zZXRUcmVlKG5ld1Jvb3QsIHNpemUudmFsdWUpO1xyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS5tb2RpZnlIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgZikge1xyXG4gIHJldHVybiBtb2RpZnlIYXNoKGYsIGhhc2gsIGtleSwgdGhpcyk7XHJcbn07XHJcbi8qKlxyXG4gICAgQWx0ZXIgdGhlIHZhbHVlIHN0b3JlZCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgZnVuY3Rpb24gYGZgIHVzaW5nXHJcbiAgICBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxyXG5cclxuICAgIEBzZWUgYG1vZGlmeUhhc2hgXHJcbiovXHJcblxyXG5cclxudmFyIG1vZGlmeSA9IGhhbXQubW9kaWZ5ID0gZnVuY3Rpb24gKGYsIGtleSwgbWFwKSB7XHJcbiAgcmV0dXJuIG1vZGlmeUhhc2goZiwgbWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIG1hcCk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLm1vZGlmeSA9IGZ1bmN0aW9uIChrZXksIGYpIHtcclxuICByZXR1cm4gbW9kaWZ5KGYsIGtleSwgdGhpcyk7XHJcbn07XHJcbi8qKlxyXG4gICAgU3RvcmUgYHZhbHVlYCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgY3VzdG9tIGBoYXNoYC5cclxuXHJcbiAgICBSZXR1cm5zIGEgbWFwIHdpdGggdGhlIG1vZGlmaWVkIHZhbHVlLiBEb2VzIG5vdCBhbHRlciBgbWFwYC5cclxuKi9cclxuXHJcblxyXG52YXIgc2V0SGFzaCA9IGhhbXQuc2V0SGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXksIHZhbHVlLCBtYXApIHtcclxuICByZXR1cm4gbW9kaWZ5SGFzaChjb25zdGFudCh2YWx1ZSksIGhhc2gsIGtleSwgbWFwKTtcclxufTtcclxuXHJcbk1hcC5wcm90b3R5cGUuc2V0SGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXksIHZhbHVlKSB7XHJcbiAgcmV0dXJuIHNldEhhc2goaGFzaCwga2V5LCB2YWx1ZSwgdGhpcyk7XHJcbn07XHJcbi8qKlxyXG4gICAgU3RvcmUgYHZhbHVlYCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgaW50ZXJuYWwgaGFzaCBmdW5jdGlvbi5cclxuXHJcbiAgICBAc2VlIGBzZXRIYXNoYFxyXG4qL1xyXG5cclxuXHJcbnZhciBzZXQgPSBoYW10LnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBtYXApIHtcclxuICByZXR1cm4gc2V0SGFzaChtYXAuX2NvbmZpZy5oYXNoKGtleSksIGtleSwgdmFsdWUsIG1hcCk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgcmV0dXJuIHNldChrZXksIHZhbHVlLCB0aGlzKTtcclxufTtcclxuLyoqXHJcbiAgICBSZW1vdmUgdGhlIGVudHJ5IGZvciBga2V5YCBpbiBgbWFwYC5cclxuXHJcbiAgICBSZXR1cm5zIGEgbWFwIHdpdGggdGhlIHZhbHVlIHJlbW92ZWQuIERvZXMgbm90IGFsdGVyIGBtYXBgLlxyXG4qL1xyXG5cclxuXHJcbnZhciBkZWwgPSBjb25zdGFudChub3RoaW5nKTtcclxuXHJcbnZhciByZW1vdmVIYXNoID0gaGFtdC5yZW1vdmVIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgbWFwKSB7XHJcbiAgcmV0dXJuIG1vZGlmeUhhc2goZGVsLCBoYXNoLCBrZXksIG1hcCk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLnJlbW92ZUhhc2ggPSBNYXAucHJvdG90eXBlLmRlbGV0ZUhhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5KSB7XHJcbiAgcmV0dXJuIHJlbW92ZUhhc2goaGFzaCwga2V5LCB0aGlzKTtcclxufTtcclxuLyoqXHJcbiAgICBSZW1vdmUgdGhlIGVudHJ5IGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxyXG5cclxuICAgIEBzZWUgYHJlbW92ZUhhc2hgXHJcbiovXHJcblxyXG5cclxudmFyIHJlbW92ZSA9IGhhbXQucmVtb3ZlID0gZnVuY3Rpb24gKGtleSwgbWFwKSB7XHJcbiAgcmV0dXJuIHJlbW92ZUhhc2gobWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIG1hcCk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLnJlbW92ZSA9IE1hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gIHJldHVybiByZW1vdmUoa2V5LCB0aGlzKTtcclxufTtcclxuLyogTXV0YXRpb25cclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8qKlxyXG4gICAgTWFyayBgbWFwYCBhcyBtdXRhYmxlLlxyXG4gKi9cclxuXHJcblxyXG52YXIgYmVnaW5NdXRhdGlvbiA9IGhhbXQuYmVnaW5NdXRhdGlvbiA9IGZ1bmN0aW9uIChtYXApIHtcclxuICByZXR1cm4gbmV3IE1hcChtYXAuX2VkaXRhYmxlICsgMSwgbWFwLl9lZGl0ICsgMSwgbWFwLl9jb25maWcsIG1hcC5fcm9vdCwgbWFwLl9zaXplKTtcclxufTtcclxuXHJcbk1hcC5wcm90b3R5cGUuYmVnaW5NdXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gYmVnaW5NdXRhdGlvbih0aGlzKTtcclxufTtcclxuLyoqXHJcbiAgICBNYXJrIGBtYXBgIGFzIGltbXV0YWJsZS5cclxuICovXHJcblxyXG5cclxudmFyIGVuZE11dGF0aW9uID0gaGFtdC5lbmRNdXRhdGlvbiA9IGZ1bmN0aW9uIChtYXApIHtcclxuICBtYXAuX2VkaXRhYmxlID0gbWFwLl9lZGl0YWJsZSAmJiBtYXAuX2VkaXRhYmxlIC0gMTtcclxuICByZXR1cm4gbWFwO1xyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS5lbmRNdXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gZW5kTXV0YXRpb24odGhpcyk7XHJcbn07XHJcbi8qKlxyXG4gICAgTXV0YXRlIGBtYXBgIHdpdGhpbiB0aGUgY29udGV4dCBvZiBgZmAuXHJcbiAgICBAcGFyYW0gZlxyXG4gICAgQHBhcmFtIG1hcCBIQU1UXHJcbiovXHJcblxyXG5cclxudmFyIG11dGF0ZSA9IGhhbXQubXV0YXRlID0gZnVuY3Rpb24gKGYsIG1hcCkge1xyXG4gIHZhciB0cmFuc2llbnQgPSBiZWdpbk11dGF0aW9uKG1hcCk7XHJcbiAgZih0cmFuc2llbnQpO1xyXG4gIHJldHVybiBlbmRNdXRhdGlvbih0cmFuc2llbnQpO1xyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS5tdXRhdGUgPSBmdW5jdGlvbiAoZikge1xyXG4gIHJldHVybiBtdXRhdGUoZiwgdGhpcyk7XHJcbn07XHJcbi8qIFRyYXZlcnNhbFxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLyoqXHJcbiAgICBBcHBseSBhIGNvbnRpbnVhdGlvbi5cclxuKi9cclxuXHJcblxyXG52YXIgYXBwayA9IGZ1bmN0aW9uIGFwcGsoaykge1xyXG4gIHJldHVybiBrICYmIGxhenlWaXNpdENoaWxkcmVuKGtbMF0sIGtbMV0sIGtbMl0sIGtbM10sIGtbNF0pO1xyXG59O1xyXG4vKipcclxuICAgIFJlY3Vyc2l2ZWx5IHZpc2l0IGFsbCB2YWx1ZXMgc3RvcmVkIGluIGFuIGFycmF5IG9mIG5vZGVzIGxhemlseS5cclxuKi9cclxuXHJcblxyXG52YXIgbGF6eVZpc2l0Q2hpbGRyZW4gPSBmdW5jdGlvbiBsYXp5VmlzaXRDaGlsZHJlbihsZW4sIGNoaWxkcmVuLCBpLCBmLCBrKSB7XHJcbiAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2krK107XHJcbiAgICBpZiAoY2hpbGQgJiYgIWlzRW1wdHlOb2RlKGNoaWxkKSkgcmV0dXJuIGxhenlWaXNpdChjaGlsZCwgZiwgW2xlbiwgY2hpbGRyZW4sIGksIGYsIGtdKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBhcHBrKGspO1xyXG59O1xyXG4vKipcclxuICAgIFJlY3Vyc2l2ZWx5IHZpc2l0IGFsbCB2YWx1ZXMgc3RvcmVkIGluIGBub2RlYCBsYXppbHkuXHJcbiovXHJcblxyXG5cclxudmFyIGxhenlWaXNpdCA9IGZ1bmN0aW9uIGxhenlWaXNpdChub2RlLCBmLCBrKSB7XHJcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgIGNhc2UgTEVBRjpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB2YWx1ZTogZihub2RlKSxcclxuICAgICAgICByZXN0OiBrXHJcbiAgICAgIH07XHJcblxyXG4gICAgY2FzZSBDT0xMSVNJT046XHJcbiAgICBjYXNlIEFSUkFZOlxyXG4gICAgY2FzZSBJTkRFWDpcclxuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcclxuICAgICAgcmV0dXJuIGxhenlWaXNpdENoaWxkcmVuKGNoaWxkcmVuLmxlbmd0aCwgY2hpbGRyZW4sIDAsIGYsIGspO1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBhcHBrKGspO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBET05FID0ge1xyXG4gIGRvbmU6IHRydWVcclxufTtcclxuLyoqXHJcbiAgICBKYXZhc2NyaXB0IGl0ZXJhdG9yIG92ZXIgYSBtYXAuXHJcbiovXHJcblxyXG5mdW5jdGlvbiBNYXBJdGVyYXRvcih2KSB7XHJcbiAgdGhpcy52ID0gdjtcclxufVxyXG5cclxuTWFwSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKCF0aGlzLnYpIHJldHVybiBET05FO1xyXG4gIHZhciB2MCA9IHRoaXMudjtcclxuICB0aGlzLnYgPSBhcHBrKHYwLnJlc3QpO1xyXG4gIHJldHVybiB2MDtcclxufTtcclxuXHJcbk1hcEl0ZXJhdG9yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG4vKipcclxuICAgIExhemlseSB2aXNpdCBlYWNoIHZhbHVlIGluIG1hcCB3aXRoIGZ1bmN0aW9uIGBmYC5cclxuKi9cclxuXHJcblxyXG52YXIgdmlzaXQgPSBmdW5jdGlvbiB2aXNpdChtYXAsIGYpIHtcclxuICByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKGxhenlWaXNpdChtYXAuX3Jvb3QsIGYpKTtcclxufTtcclxuLyoqXHJcbiAgICBHZXQgYSBKYXZhc2NzcmlwdCBpdGVyYXRvciBvZiBgbWFwYC5cclxuXHJcbiAgICBJdGVyYXRlcyBvdmVyIGBba2V5LCB2YWx1ZV1gIGFycmF5cy5cclxuKi9cclxuXHJcblxyXG52YXIgYnVpbGRQYWlycyA9IGZ1bmN0aW9uIGJ1aWxkUGFpcnMoeCkge1xyXG4gIHJldHVybiBbeC5rZXksIHgudmFsdWVdO1xyXG59O1xyXG5cclxudmFyIGVudHJpZXMgPSBoYW10LmVudHJpZXMgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgcmV0dXJuIHZpc2l0KG1hcCwgYnVpbGRQYWlycyk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLmVudHJpZXMgPSBNYXAucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGVudHJpZXModGhpcyk7XHJcbn07XHJcbi8qKlxyXG4gICAgR2V0IGFycmF5IG9mIGFsbCBrZXlzIGluIGBtYXBgLlxyXG5cclxuICAgIE9yZGVyIGlzIG5vdCBndWFyYW50ZWVkLlxyXG4qL1xyXG5cclxuXHJcbnZhciBidWlsZEtleXMgPSBmdW5jdGlvbiBidWlsZEtleXMoeCkge1xyXG4gIHJldHVybiB4LmtleTtcclxufTtcclxuXHJcbnZhciBrZXlzID0gaGFtdC5rZXlzID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gIHJldHVybiB2aXNpdChtYXAsIGJ1aWxkS2V5cyk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGtleXModGhpcyk7XHJcbn07XHJcbi8qKlxyXG4gICAgR2V0IGFycmF5IG9mIGFsbCB2YWx1ZXMgaW4gYG1hcGAuXHJcblxyXG4gICAgT3JkZXIgaXMgbm90IGd1YXJhbnRlZWQsIGR1cGxpY2F0ZXMgYXJlIHByZXNlcnZlZC5cclxuKi9cclxuXHJcblxyXG52YXIgYnVpbGRWYWx1ZXMgPSBmdW5jdGlvbiBidWlsZFZhbHVlcyh4KSB7XHJcbiAgcmV0dXJuIHgudmFsdWU7XHJcbn07XHJcblxyXG52YXIgdmFsdWVzID0gaGFtdC52YWx1ZXMgPSBNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uIChtYXApIHtcclxuICByZXR1cm4gdmlzaXQobWFwLCBidWlsZFZhbHVlcyk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdmFsdWVzKHRoaXMpO1xyXG59O1xyXG4vKiBGb2xkXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vKipcclxuICAgIFZpc2l0IGV2ZXJ5IGVudHJ5IGluIHRoZSBtYXAsIGFnZ3JlZ2F0aW5nIGRhdGEuXHJcblxyXG4gICAgT3JkZXIgb2Ygbm9kZXMgaXMgbm90IGd1YXJhbnRlZWQuXHJcblxyXG4gICAgQHBhcmFtIGYgRnVuY3Rpb24gbWFwcGluZyBhY2N1bXVsYXRlZCB2YWx1ZSwgdmFsdWUsIGFuZCBrZXkgdG8gbmV3IHZhbHVlLlxyXG4gICAgQHBhcmFtIHogU3RhcnRpbmcgdmFsdWUuXHJcbiAgICBAcGFyYW0gbSBIQU1UXHJcbiovXHJcblxyXG5cclxudmFyIGZvbGQgPSBoYW10LmZvbGQgPSBmdW5jdGlvbiAoZiwgeiwgbSkge1xyXG4gIHZhciByb290ID0gbS5fcm9vdDtcclxuICBpZiAocm9vdC50eXBlID09PSBMRUFGKSByZXR1cm4gZih6LCByb290LnZhbHVlLCByb290LmtleSk7XHJcbiAgdmFyIHRvVmlzaXQgPSBbcm9vdC5jaGlsZHJlbl07XHJcbiAgdmFyIGNoaWxkcmVuID0gdm9pZCAwO1xyXG5cclxuICB3aGlsZSAoY2hpbGRyZW4gPSB0b1Zpc2l0LnBvcCgpKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOykge1xyXG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpKytdO1xyXG5cclxuICAgICAgaWYgKGNoaWxkICYmIGNoaWxkLnR5cGUpIHtcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gTEVBRikgeiA9IGYoeiwgY2hpbGQudmFsdWUsIGNoaWxkLmtleSk7ZWxzZSB0b1Zpc2l0LnB1c2goY2hpbGQuY2hpbGRyZW4pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gejtcclxufTtcclxuXHJcbk1hcC5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uIChmLCB6KSB7XHJcbiAgcmV0dXJuIGZvbGQoZiwgeiwgdGhpcyk7XHJcbn07XHJcbi8qKlxyXG4gICAgVmlzaXQgZXZlcnkgZW50cnkgaW4gdGhlIG1hcCwgYWdncmVnYXRpbmcgZGF0YS5cclxuXHJcbiAgICBPcmRlciBvZiBub2RlcyBpcyBub3QgZ3VhcmFudGVlZC5cclxuXHJcbiAgICBAcGFyYW0gZiBGdW5jdGlvbiBpbnZva2VkIHdpdGggdmFsdWUgYW5kIGtleVxyXG4gICAgQHBhcmFtIG1hcCBIQU1UXHJcbiovXHJcblxyXG5cclxudmFyIGZvckVhY2ggPSBoYW10LmZvckVhY2ggPSBmdW5jdGlvbiAoZiwgbWFwKSB7XHJcbiAgcmV0dXJuIGZvbGQoZnVuY3Rpb24gKF8sIHZhbHVlLCBrZXkpIHtcclxuICAgIHJldHVybiBmKHZhbHVlLCBrZXksIG1hcCk7XHJcbiAgfSwgbnVsbCwgbWFwKTtcclxufTtcclxuXHJcbk1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmKSB7XHJcbiAgcmV0dXJuIGZvckVhY2goZiwgdGhpcyk7XHJcbn07XHJcbi8qIEFnZ3JlZ2F0ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLyoqXHJcbiAgICBHZXQgdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIGBtYXBgLlxyXG4qL1xyXG5cclxuXHJcbnZhciBjb3VudCA9IGhhbXQuY291bnQgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgcmV0dXJuIG1hcC5fc2l6ZTtcclxufTtcclxuXHJcbk1hcC5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGNvdW50KHRoaXMpO1xyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcC5wcm90b3R5cGUsICdzaXplJywge1xyXG4gIGdldDogTWFwLnByb3RvdHlwZS5jb3VudFxyXG59KTtcclxuLyogRXhwb3J0XHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5pZiAoIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBoYW10O1xyXG59IGVsc2Uge1xyXG4gIHVuZGVmaW5lZC5oYW10ID0gaGFtdDtcclxufVxyXG59KTtcclxuXHJcbmNsYXNzIEJ1aWx0SW5NYXAge1xyXG4gIGNvbnN0cnVjdG9yKGV4aXN0aW5nKSB7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWFwXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcChleGlzdGluZyA9PT0gbnVsbCB8fCBleGlzdGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhpc3RpbmcuZW50cmllcygpKTtcclxuICB9XHJcblxyXG4gIGtleXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcclxuICB9XHJcblxyXG4gIGVudHJpZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLmVudHJpZXMoKTtcclxuICB9XHJcblxyXG4gIGdldChrKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldChrKTtcclxuICB9XHJcblxyXG4gIGhhcyhrKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyhrKTtcclxuICB9XHJcblxyXG4gIHNldChrLCB2KSB7XHJcbiAgICB0aGlzLl9tYXAuc2V0KGssIHYpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgZGVsZXRlKGspIHtcclxuICAgIHRoaXMuX21hcC5kZWxldGUoayk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBjbG9uZSgpIHtcclxuICAgIHJldHVybiBwZXJzaXN0ZW50TWFwKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgdG9NYXAoKSB7XHJcbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzLl9tYXApO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIEhhc2hBcnJheU1hcHBlZFRyaWVNYXAge1xyXG4gIC8vIEJlY2F1c2UgaGFtdC5lbXB0eSBpcyBub3QgYSBmdW5jdGlvbiB0aGVyZSBpcyBubyB3YXkgdG8gaW50cm9kdWNlIHR5cGVcclxuICAvLyBwYXJhbWV0ZXJzIG9uIGl0LCBzbyBlbXB0eSBpcyB0eXBlZCBhcyBIQU1UUGx1c01hcDxzdHJpbmcsIG1peGVkPi5cclxuICAvLyAkRmxvd0lzc3VlXHJcbiAgY29uc3RydWN0b3IoZXhpc3RpbmcpIHtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9oYW10XCIsIGhhbXRfMS5lbXB0eS5iZWdpbk11dGF0aW9uKCkpO1xyXG5cclxuICAgIGlmIChleGlzdGluZyBpbnN0YW5jZW9mIEhhc2hBcnJheU1hcHBlZFRyaWVNYXApIHtcclxuICAgICAgY29uc3QgaCA9IGV4aXN0aW5nLl9oYW10LmVuZE11dGF0aW9uKCk7XHJcblxyXG4gICAgICBleGlzdGluZy5faGFtdCA9IGguYmVnaW5NdXRhdGlvbigpO1xyXG4gICAgICB0aGlzLl9oYW10ID0gaC5iZWdpbk11dGF0aW9uKCk7XHJcbiAgICB9IGVsc2UgaWYgKGV4aXN0aW5nKSB7XHJcbiAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIGV4aXN0aW5nLmVudHJpZXMoKSkge1xyXG4gICAgICAgIHRoaXMuX2hhbXQuc2V0KGssIHYpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBrZXlzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2hhbXQua2V5cygpO1xyXG4gIH1cclxuXHJcbiAgZW50cmllcygpIHtcclxuICAgIHJldHVybiB0aGlzLl9oYW10LmVudHJpZXMoKTtcclxuICB9XHJcblxyXG4gIGdldChrKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faGFtdC5nZXQoayk7XHJcbiAgfVxyXG5cclxuICBoYXMoaykge1xyXG4gICAgcmV0dXJuIHRoaXMuX2hhbXQuaGFzKGspO1xyXG4gIH1cclxuXHJcbiAgc2V0KGssIHYpIHtcclxuICAgIHRoaXMuX2hhbXQuc2V0KGssIHYpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgZGVsZXRlKGspIHtcclxuICAgIHRoaXMuX2hhbXQuZGVsZXRlKGspO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgY2xvbmUoKSB7XHJcbiAgICByZXR1cm4gcGVyc2lzdGVudE1hcCh0aGlzKTtcclxuICB9XHJcblxyXG4gIHRvTWFwKCkge1xyXG4gICAgcmV0dXJuIG5ldyBNYXAodGhpcy5faGFtdCk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gcGVyc2lzdGVudE1hcChleGlzdGluZykge1xyXG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfaGFtdF8yMDIwJykpIHtcclxuICAgIHJldHVybiBuZXcgSGFzaEFycmF5TWFwcGVkVHJpZU1hcChleGlzdGluZyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBuZXcgQnVpbHRJbk1hcChleGlzdGluZyk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgUmVjb2lsX1BlcnNpc3RlbnRNYXAgPSB7XHJcbiAgcGVyc2lzdGVudE1hcFxyXG59O1xyXG5cclxudmFyIFJlY29pbF9QZXJzaXN0ZW50TWFwXzEgPSBSZWNvaWxfUGVyc2lzdGVudE1hcC5wZXJzaXN0ZW50TWFwO1xyXG5cclxudmFyIFJlY29pbF9QZXJzaXN0ZW50TWFwJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIHBlcnNpc3RlbnRNYXA6IFJlY29pbF9QZXJzaXN0ZW50TWFwXzFcclxufSk7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBhIHNldCBjb250YWluaW5nIGFsbCBvZiB0aGUgdmFsdWVzIGZyb20gdGhlIGZpcnN0IHNldCB0aGF0IGFyZSBub3RcclxuICogcHJlc2VudCBpbiBhbnkgb2YgdGhlIHN1YnNlcXVlbnQgc2V0cy5cclxuICpcclxuICogTm90ZTogdGhpcyBpcyB3cml0dGVuIHByb2NlZHVyYWxseSAoaS5lLiwgd2l0aG91dCBmaWx0ZXJTZXQpIGZvciBwZXJmb3JtYW50XHJcbiAqIHVzZSBpbiB0aWdodCBsb29wcy5cclxuICovXHJcblxyXG5mdW5jdGlvbiBkaWZmZXJlbmNlU2V0cyhzZXQsIC4uLnNldHNXaXRoVmFsdWVzVG9SZW1vdmUpIHtcclxuICBjb25zdCByZXQgPSBuZXcgU2V0KCk7XHJcblxyXG4gIEZJUlNUOiBmb3IgKGNvbnN0IHZhbHVlIG9mIHNldCkge1xyXG4gICAgZm9yIChjb25zdCBvdGhlclNldCBvZiBzZXRzV2l0aFZhbHVlc1RvUmVtb3ZlKSB7XHJcbiAgICAgIGlmIChvdGhlclNldC5oYXModmFsdWUpKSB7XHJcbiAgICAgICAgY29udGludWUgRklSU1Q7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXQuYWRkKHZhbHVlKTtcclxuICB9XHJcblxyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfZGlmZmVyZW5jZVNldHMgPSBkaWZmZXJlbmNlU2V0cztcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbmV3IE1hcCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIHRoZSBvcmlnaW5hbCwgYnV0IHdpdGggdGhlXHJcbiAqIHZhbHVlcyByZXBsYWNlZCB3aXRoIHRoZSBvdXRwdXQgb2YgdGhlIGdpdmVuIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1hcE1hcChtYXAsIGNhbGxiYWNrKSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xyXG4gIG1hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICByZXN1bHQuc2V0KGtleSwgY2FsbGJhY2sodmFsdWUsIGtleSkpO1xyXG4gIH0pO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfbWFwTWFwID0gbWFwTWFwO1xyXG5cclxuZnVuY3Rpb24gbWFrZUdyYXBoKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBub2RlRGVwczogbmV3IE1hcCgpLFxyXG4gICAgbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsb25lR3JhcGgoZ3JhcGgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgbm9kZURlcHM6IFJlY29pbF9tYXBNYXAoZ3JhcGgubm9kZURlcHMsIHMgPT4gbmV3IFNldChzKSksXHJcbiAgICBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uczogUmVjb2lsX21hcE1hcChncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucywgcyA9PiBuZXcgU2V0KHMpKVxyXG4gIH07XHJcbn0gLy8gTm90ZSB0aGF0IHRoaXMgb3ZlcndyaXRlcyB0aGUgZGVwcyBvZiBleGlzdGluZyBub2RlcywgcmF0aGVyIHRoYW4gdW5pb25pbmdcclxuLy8gdGhlIG5ldyBkZXBzIHdpdGggdGhlIG9sZCBkZXBzLlxyXG5cclxuXHJcbmZ1bmN0aW9uIG1lcmdlRGVwc0ludG9HcmFwaChrZXksIG5ld0RlcHMsIGdyYXBoLCAvLyBJZiBvbGRlckdyYXBoIGlzIGdpdmVuIHRoZW4gd2Ugd2lsbCBub3Qgb3ZlcndyaXRlIGNoYW5nZXMgbWFkZSB0byB0aGUgZ2l2ZW5cclxuLy8gZ3JhcGggY29tcGFyZWQgd2l0aCBvbGRlckdyYXBoOlxyXG5vbGRlckdyYXBoKSB7XHJcbiAgY29uc3Qge1xyXG4gICAgbm9kZURlcHMsXHJcbiAgICBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uc1xyXG4gIH0gPSBncmFwaDtcclxuICBjb25zdCBvbGREZXBzID0gbm9kZURlcHMuZ2V0KGtleSk7XHJcblxyXG4gIGlmIChvbGREZXBzICYmIG9sZGVyR3JhcGggJiYgb2xkRGVwcyAhPT0gb2xkZXJHcmFwaC5ub2RlRGVwcy5nZXQoa2V5KSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH0gLy8gVXBkYXRlIG5vZGVEZXBzOlxyXG5cclxuXHJcbiAgbm9kZURlcHMuc2V0KGtleSwgbmV3RGVwcyk7IC8vIEFkZCBuZXcgZGVwcyB0byBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uczpcclxuXHJcbiAgY29uc3QgYWRkZWREZXBzID0gb2xkRGVwcyA9PSBudWxsID8gbmV3RGVwcyA6IFJlY29pbF9kaWZmZXJlbmNlU2V0cyhuZXdEZXBzLCBvbGREZXBzKTtcclxuXHJcbiAgZm9yIChjb25zdCBkZXAgb2YgYWRkZWREZXBzKSB7XHJcbiAgICBpZiAoIW5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmhhcyhkZXApKSB7XHJcbiAgICAgIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zLnNldChkZXAsIG5ldyBTZXQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZXhpc3RpbmcgPSBSZWNvaWxfbnVsbHRocm93cyhub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQoZGVwKSk7XHJcbiAgICBleGlzdGluZy5hZGQoa2V5KTtcclxuICB9IC8vIFJlbW92ZSByZW1vdmVkIGRlcHMgZnJvbSBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uczpcclxuXHJcblxyXG4gIGlmIChvbGREZXBzKSB7XHJcbiAgICBjb25zdCByZW1vdmVkRGVwcyA9IFJlY29pbF9kaWZmZXJlbmNlU2V0cyhvbGREZXBzLCBuZXdEZXBzKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiByZW1vdmVkRGVwcykge1xyXG4gICAgICBpZiAoIW5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmhhcyhkZXApKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBleGlzdGluZyA9IFJlY29pbF9udWxsdGhyb3dzKG5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChkZXApKTtcclxuICAgICAgZXhpc3RpbmcuZGVsZXRlKGtleSk7XHJcblxyXG4gICAgICBpZiAoZXhpc3Rpbmcuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmRlbGV0ZShkZXApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzYXZlRGVwc1RvU3RvcmUoa2V5LCBkZXBzLCBzdG9yZSwgdmVyc2lvbikge1xyXG4gIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZSwgX3N0b3JlU3RhdGUkcHJldmlvdXNULCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QyLCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QzO1xyXG5cclxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgaWYgKCEodmVyc2lvbiA9PT0gc3RvcmVTdGF0ZS5jdXJyZW50VHJlZS52ZXJzaW9uIHx8IHZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkbmV4dFRyZWUudmVyc2lvbikgfHwgdmVyc2lvbiA9PT0gKChfc3RvcmVTdGF0ZSRwcmV2aW91c1QgPSBzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkcHJldmlvdXNUID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRwcmV2aW91c1QudmVyc2lvbikpKSB7XHJcbiAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ1RyaWVkIHRvIHNhdmUgZGVwZW5kZW5jaWVzIHRvIGEgZGlzY2FyZGVkIHRyZWUnKTtcclxuICB9IC8vIE1lcmdlIHRoZSBkZXBlbmRlbmNpZXMgZGlzY292ZXJlZCBpbnRvIHRoZSBzdG9yZSdzIGRlcGVuZGVuY3kgbWFwXHJcbiAgLy8gZm9yIHRoZSB2ZXJzaW9uIHRoYXQgd2FzIHJlYWQ6XHJcblxyXG5cclxuICBjb25zdCBncmFwaCA9IHN0b3JlLmdldEdyYXBoKHZlcnNpb24pO1xyXG4gIG1lcmdlRGVwc0ludG9HcmFwaChrZXksIGRlcHMsIGdyYXBoKTsgLy8gSWYgdGhpcyB2ZXJzaW9uIGlzIG5vdCB0aGUgbGF0ZXN0IHZlcnNpb24sIGFsc28gd3JpdGUgdGhlc2UgZGVwZW5kZW5jaWVzXHJcbiAgLy8gaW50byBsYXRlciB2ZXJzaW9ucyBpZiB0aGV5IGRvbid0IGFscmVhZHkgaGF2ZSB0aGVpciBvd246XHJcblxyXG4gIGlmICh2ZXJzaW9uID09PSAoKF9zdG9yZVN0YXRlJHByZXZpb3VzVDIgPSBzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkcHJldmlvdXNUMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNUMi52ZXJzaW9uKSkge1xyXG4gICAgY29uc3QgY3VycmVudEdyYXBoID0gc3RvcmUuZ2V0R3JhcGgoc3RvcmVTdGF0ZS5jdXJyZW50VHJlZS52ZXJzaW9uKTtcclxuICAgIG1lcmdlRGVwc0ludG9HcmFwaChrZXksIGRlcHMsIGN1cnJlbnRHcmFwaCwgZ3JhcGgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUMyA9IHN0b3JlU3RhdGUucHJldmlvdXNUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRwcmV2aW91c1QzLnZlcnNpb24pIHx8IHZlcnNpb24gPT09IHN0b3JlU3RhdGUuY3VycmVudFRyZWUudmVyc2lvbikge1xyXG4gICAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlMjtcclxuXHJcbiAgICBjb25zdCBuZXh0VmVyc2lvbiA9IChfc3RvcmVTdGF0ZSRuZXh0VHJlZTIgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRuZXh0VHJlZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJG5leHRUcmVlMi52ZXJzaW9uO1xyXG5cclxuICAgIGlmIChuZXh0VmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnN0IG5leHRHcmFwaCA9IHN0b3JlLmdldEdyYXBoKG5leHRWZXJzaW9uKTtcclxuICAgICAgbWVyZ2VEZXBzSW50b0dyYXBoKGtleSwgZGVwcywgbmV4dEdyYXBoLCBncmFwaCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgUmVjb2lsX0dyYXBoID0ge1xyXG4gIGNsb25lR3JhcGgsXHJcbiAgZ3JhcGg6IG1ha2VHcmFwaCxcclxuICBzYXZlRGVwc1RvU3RvcmVcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcblxyXG5sZXQgbmV4dFRyZWVTdGF0ZVZlcnNpb24gPSAwO1xyXG5cclxuY29uc3QgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24gPSAoKSA9PiBuZXh0VHJlZVN0YXRlVmVyc2lvbisrO1xyXG5cclxubGV0IG5leHRTdG9yZUlEID0gMDtcclxuXHJcbmNvbnN0IGdldE5leHRTdG9yZUlEID0gKCkgPT4gbmV4dFN0b3JlSUQrKztcclxuXHJcbmxldCBuZXh0Q29tcG9uZW50SUQgPSAwO1xyXG5cclxuY29uc3QgZ2V0TmV4dENvbXBvbmVudElEID0gKCkgPT4gbmV4dENvbXBvbmVudElEKys7XHJcblxyXG52YXIgUmVjb2lsX0tleXMgPSB7XHJcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24sXHJcbiAgZ2V0TmV4dFN0b3JlSUQsXHJcbiAgZ2V0TmV4dENvbXBvbmVudElEXHJcbn07XHJcblxyXG5jb25zdCB7XHJcbiAgcGVyc2lzdGVudE1hcDogcGVyc2lzdGVudE1hcCQxXHJcbn0gPSBSZWNvaWxfUGVyc2lzdGVudE1hcCQxO1xyXG5cclxuY29uc3Qge1xyXG4gIGdyYXBoXHJcbn0gPSBSZWNvaWxfR3JhcGg7XHJcblxyXG5jb25zdCB7XHJcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb246IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDFcclxufSA9IFJlY29pbF9LZXlzO1xyXG5cclxuZnVuY3Rpb24gbWFrZUVtcHR5VHJlZVN0YXRlKCkge1xyXG4gIGNvbnN0IHZlcnNpb24gPSBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQxKCk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHZlcnNpb24sXHJcbiAgICBzdGF0ZUlEOiB2ZXJzaW9uLFxyXG4gICAgdHJhbnNhY3Rpb25NZXRhZGF0YToge30sXHJcbiAgICBkaXJ0eUF0b21zOiBuZXcgU2V0KCksXHJcbiAgICBhdG9tVmFsdWVzOiBwZXJzaXN0ZW50TWFwJDEoKSxcclxuICAgIG5vbnZhbGlkYXRlZEF0b21zOiBwZXJzaXN0ZW50TWFwJDEoKVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1ha2VFbXB0eVN0b3JlU3RhdGUoKSB7XHJcbiAgY29uc3QgY3VycmVudFRyZWUgPSBtYWtlRW1wdHlUcmVlU3RhdGUoKTtcclxuICByZXR1cm4ge1xyXG4gICAgY3VycmVudFRyZWUsXHJcbiAgICBuZXh0VHJlZTogbnVsbCxcclxuICAgIHByZXZpb3VzVHJlZTogbnVsbCxcclxuICAgIGNvbW1pdERlcHRoOiAwLFxyXG4gICAga25vd25BdG9tczogbmV3IFNldCgpLFxyXG4gICAga25vd25TZWxlY3RvcnM6IG5ldyBTZXQoKSxcclxuICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxyXG4gICAgbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxyXG4gICAgbm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxyXG4gICAgcXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQ6IFtdLFxyXG4gICAgc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzOiBuZXcgU2V0KCksXHJcbiAgICBncmFwaHNCeVZlcnNpb246IG5ldyBNYXAoKS5zZXQoY3VycmVudFRyZWUudmVyc2lvbiwgZ3JhcGgoKSksXHJcbiAgICByZXRlbnRpb246IHtcclxuICAgICAgcmVmZXJlbmNlQ291bnRzOiBuZXcgTWFwKCksXHJcbiAgICAgIG5vZGVzUmV0YWluZWRCeVpvbmU6IG5ldyBNYXAoKSxcclxuICAgICAgcmV0YWluYWJsZXNUb0NoZWNrRm9yUmVsZWFzZTogbmV3IFNldCgpXHJcbiAgICB9LFxyXG4gICAgbm9kZUNsZWFudXBGdW5jdGlvbnM6IG5ldyBNYXAoKVxyXG4gIH07XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfU3RhdGUgPSB7XHJcbiAgbWFrZUVtcHR5VHJlZVN0YXRlLFxyXG4gIG1ha2VFbXB0eVN0b3JlU3RhdGUsXHJcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb246IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDFcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcblxyXG5jbGFzcyBSZXRlbnRpb25ab25lIHt9XHJcblxyXG5mdW5jdGlvbiByZXRlbnRpb25ab25lKCkge1xyXG4gIHJldHVybiBuZXcgUmV0ZW50aW9uWm9uZSgpO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX1JldGVudGlvblpvbmUgPSB7XHJcbiAgUmV0ZW50aW9uWm9uZSxcclxuICByZXRlbnRpb25ab25lXHJcbn07XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFV0aWxpdGllcyBmb3Igd29ya2luZyB3aXRoIGJ1aWx0LWluIE1hcHMgYW5kIFNldHMgd2l0aG91dCBtdXRhdGluZyB0aGVtLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHNldEJ5QWRkaW5nVG9TZXQoc2V0LCB2KSB7XHJcbiAgY29uc3QgbmV4dCA9IG5ldyBTZXQoc2V0KTtcclxuICBuZXh0LmFkZCh2KTtcclxuICByZXR1cm4gbmV4dDtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0QnlEZWxldGluZ0Zyb21TZXQoc2V0LCB2KSB7XHJcbiAgY29uc3QgbmV4dCA9IG5ldyBTZXQoc2V0KTtcclxuICBuZXh0LmRlbGV0ZSh2KTtcclxuICByZXR1cm4gbmV4dDtcclxufVxyXG5cclxuZnVuY3Rpb24gbWFwQnlTZXR0aW5nSW5NYXAobWFwLCBrLCB2KSB7XHJcbiAgY29uc3QgbmV4dCA9IG5ldyBNYXAobWFwKTtcclxuICBuZXh0LnNldChrLCB2KTtcclxuICByZXR1cm4gbmV4dDtcclxufVxyXG5cclxuZnVuY3Rpb24gbWFwQnlVcGRhdGluZ0luTWFwKG1hcCwgaywgdXBkYXRlcikge1xyXG4gIGNvbnN0IG5leHQgPSBuZXcgTWFwKG1hcCk7XHJcbiAgbmV4dC5zZXQoaywgdXBkYXRlcihuZXh0LmdldChrKSkpO1xyXG4gIHJldHVybiBuZXh0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXBCeURlbGV0aW5nRnJvbU1hcChtYXAsIGspIHtcclxuICBjb25zdCBuZXh0ID0gbmV3IE1hcChtYXApO1xyXG4gIG5leHQuZGVsZXRlKGspO1xyXG4gIHJldHVybiBuZXh0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXBCeURlbGV0aW5nTXVsdGlwbGVGcm9tTWFwKG1hcCwga3MpIHtcclxuICBjb25zdCBuZXh0ID0gbmV3IE1hcChtYXApO1xyXG4gIGtzLmZvckVhY2goayA9PiBuZXh0LmRlbGV0ZShrKSk7XHJcbiAgcmV0dXJuIG5leHQ7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfQ29weU9uV3JpdGUgPSB7XHJcbiAgc2V0QnlBZGRpbmdUb1NldCxcclxuICBzZXRCeURlbGV0aW5nRnJvbVNldCxcclxuICBtYXBCeVNldHRpbmdJbk1hcCxcclxuICBtYXBCeVVwZGF0aW5nSW5NYXAsXHJcbiAgbWFwQnlEZWxldGluZ0Zyb21NYXAsXHJcbiAgbWFwQnlEZWxldGluZ011bHRpcGxlRnJvbU1hcFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaXRlcmFibGUgd2hvc2Ugb3V0cHV0IGlzIGdlbmVyYXRlZCBieSBwYXNzaW5nIHRoZSBpbnB1dFxyXG4gKiBpdGVyYWJsZSdzIHZhbHVlcyB0aHJvdWdoIHRoZSBmaWx0ZXIgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24qIGZpbHRlckl0ZXJhYmxlKGl0ZXJhYmxlLCBwcmVkaWNhdGUpIHtcclxuICAvLyBVc2UgZ2VuZXJhdG9yIHRvIGNyZWF0ZSBpdGVyYWJsZS9pdGVyYXRvclxyXG4gIGxldCBpbmRleCA9IDA7XHJcblxyXG4gIGZvciAoY29uc3QgdmFsdWUgb2YgaXRlcmFibGUpIHtcclxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4KyspKSB7XHJcbiAgICAgIHlpZWxkIHZhbHVlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIFJlY29pbF9maWx0ZXJJdGVyYWJsZSA9IGZpbHRlckl0ZXJhYmxlO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybiBhIHByb3h5IG9iamVjdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYmFzZSBhbmQgZmFjdG9yaWVzIG9iamVjdHMuXHJcbiAqIFRoZSBwcm94eSB3aWxsIGluY2x1ZGUgYWxsIHByb3BlcnRpZXMgb2YgdGhlIGJhc2Ugb2JqZWN0IGFzLWlzLlxyXG4gKiBUaGUgZmFjdG9yaWVzIG9iamVjdCBjb250YWlucyBjYWxsYmFja3MgdG8gb2J0YWluIHRoZSB2YWx1ZXMgb2YgdGhlIHByb3Blcmllc1xyXG4gKiBmb3IgaXRzIGtleXMuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBwcm92aWRpbmcgdXNlcnMgYW4gb2JqZWN0IHdoZXJlIHNvbWUgcHJvcGVydGllcyBtYXkgYmVcclxuICogbGF6aWx5IGNvbXB1dGVkIG9ubHkgb24gZmlyc3QgYWNjZXNzLlxyXG4gKi9cclxuLy8gJEZsb3dJc3N1ZVt1bmNsZWFyLXR5cGVdXHJcblxyXG5mdW5jdGlvbiBsYXp5UHJveHkoYmFzZSwgZmFjdG9yaWVzKSB7XHJcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoYmFzZSwge1xyXG4gICAgLy8gQ29tcHV0ZSBhbmQgY2FjaGUgbGF6eSBwcm9wZXJ0eSBpZiBub3QgYWxyZWFkeSBkb25lLlxyXG4gICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XHJcbiAgICAgIGlmICghKHByb3AgaW4gdGFyZ2V0KSAmJiBwcm9wIGluIGZhY3Rvcmllcykge1xyXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IGZhY3Rvcmllc1twcm9wXSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xyXG4gICAgfSxcclxuICAgIC8vIFRoaXMgbWV0aG9kIGFsbG93cyB1c2VyIHRvIGl0ZXJhdGUga2V5cyBhcyBub3JtYWxcclxuICAgIG93bktleXM6IHRhcmdldCA9PiB7XHJcblxyXG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KTtcclxuICAgIH1cclxuICB9KTsgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxyXG5cclxuICByZXR1cm4gcHJveHk7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfbGF6eVByb3h5ID0gbGF6eVByb3h5O1xyXG5cclxuY29uc3Qge1xyXG4gIGdldE5vZGU6IGdldE5vZGUkMSxcclxuICBnZXROb2RlTWF5YmU6IGdldE5vZGVNYXliZSQxLFxyXG4gIHJlY29pbFZhbHVlc0ZvcktleXM6IHJlY29pbFZhbHVlc0ZvcktleXMkMVxyXG59ID0gUmVjb2lsX05vZGU7XHJcblxyXG5jb25zdCB7XHJcbiAgUmV0ZW50aW9uWm9uZTogUmV0ZW50aW9uWm9uZSQxXHJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uWm9uZTtcclxuXHJcbmNvbnN0IHtcclxuICBzZXRCeUFkZGluZ1RvU2V0OiBzZXRCeUFkZGluZ1RvU2V0JDFcclxufSA9IFJlY29pbF9Db3B5T25Xcml0ZTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxyXG5cclxuXHJcbmNvbnN0IGVtcHR5U2V0ID0gT2JqZWN0LmZyZWV6ZShuZXcgU2V0KCkpO1xyXG5cclxuY2xhc3MgUmVhZE9ubHlSZWNvaWxWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige31cclxuXHJcbmZ1bmN0aW9uIGluaXRpYWxpemVSZXRlbnRpb25Gb3JOb2RlKHN0b3JlLCBub2RlS2V5LCByZXRhaW5lZEJ5KSB7XHJcbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XHJcbiAgICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qge1xyXG4gICAgbm9kZXNSZXRhaW5lZEJ5Wm9uZVxyXG4gIH0gPSBzdG9yZS5nZXRTdGF0ZSgpLnJldGVudGlvbjtcclxuXHJcbiAgZnVuY3Rpb24gYWRkVG9ab25lKHpvbmUpIHtcclxuICAgIGxldCBzZXQgPSBub2Rlc1JldGFpbmVkQnlab25lLmdldCh6b25lKTtcclxuXHJcbiAgICBpZiAoIXNldCkge1xyXG4gICAgICBub2Rlc1JldGFpbmVkQnlab25lLnNldCh6b25lLCBzZXQgPSBuZXcgU2V0KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldC5hZGQobm9kZUtleSk7XHJcbiAgfVxyXG5cclxuICBpZiAocmV0YWluZWRCeSBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMSkge1xyXG4gICAgYWRkVG9ab25lKHJldGFpbmVkQnkpO1xyXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRhaW5lZEJ5KSkge1xyXG4gICAgZm9yIChjb25zdCB6b25lIG9mIHJldGFpbmVkQnkpIHtcclxuICAgICAgYWRkVG9ab25lKHpvbmUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuICgpID0+IHtcclxuICAgIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICByZXRlbnRpb25cclxuICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGRlbGV0ZUZyb21ab25lKHpvbmUpIHtcclxuICAgICAgY29uc3Qgc2V0ID0gcmV0ZW50aW9uLm5vZGVzUmV0YWluZWRCeVpvbmUuZ2V0KHpvbmUpO1xyXG4gICAgICBzZXQgPT09IG51bGwgfHwgc2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXQuZGVsZXRlKG5vZGVLZXkpO1xyXG5cclxuICAgICAgaWYgKHNldCAmJiBzZXQuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgIHJldGVudGlvbi5ub2Rlc1JldGFpbmVkQnlab25lLmRlbGV0ZSh6b25lKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZXRhaW5lZEJ5IGluc3RhbmNlb2YgUmV0ZW50aW9uWm9uZSQxKSB7XHJcbiAgICAgIGRlbGV0ZUZyb21ab25lKHJldGFpbmVkQnkpO1xyXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldGFpbmVkQnkpKSB7XHJcbiAgICAgIGZvciAoY29uc3Qgem9uZSBvZiByZXRhaW5lZEJ5KSB7XHJcbiAgICAgICAgZGVsZXRlRnJvbVpvbmUoem9uZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0aWFsaXplTm9kZUlmTmV3VG9TdG9yZShzdG9yZSwgdHJlZVN0YXRlLCBrZXksIHRyaWdnZXIpIHtcclxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgaWYgKHN0b3JlU3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuaGFzKGtleSkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGNvbnN0IG5vZGUgPSBnZXROb2RlJDEoa2V5KTtcclxuICBjb25zdCByZXRlbnRpb25DbGVhbnVwID0gaW5pdGlhbGl6ZVJldGVudGlvbkZvck5vZGUoc3RvcmUsIGtleSwgbm9kZS5yZXRhaW5lZEJ5KTtcclxuICBjb25zdCBub2RlQ2xlYW51cCA9IG5vZGUuaW5pdChzdG9yZSwgdHJlZVN0YXRlLCB0cmlnZ2VyKTtcclxuICBzdG9yZVN0YXRlLm5vZGVDbGVhbnVwRnVuY3Rpb25zLnNldChrZXksICgpID0+IHtcclxuICAgIG5vZGVDbGVhbnVwKCk7XHJcbiAgICByZXRlbnRpb25DbGVhbnVwKCk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRpYWxpemVOb2RlKHN0b3JlLCBrZXksIHRyaWdnZXIpIHtcclxuICBpbml0aWFsaXplTm9kZUlmTmV3VG9TdG9yZShzdG9yZSwgc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSwga2V5LCB0cmlnZ2VyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2xlYW5VcE5vZGUoc3RvcmUsIGtleSkge1xyXG4gIHZhciBfc3RhdGUkbm9kZUNsZWFudXBGdW47XHJcblxyXG4gIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICAoX3N0YXRlJG5vZGVDbGVhbnVwRnVuID0gc3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9zdGF0ZSRub2RlQ2xlYW51cEZ1biA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlJG5vZGVDbGVhbnVwRnVuKCk7XHJcbiAgc3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuZGVsZXRlKGtleSk7XHJcbn0gLy8gR2V0IHRoZSBjdXJyZW50IHZhbHVlIGxvYWRhYmxlIG9mIGEgbm9kZSBhbmQgdXBkYXRlIHRoZSBzdGF0ZS5cclxuLy8gVXBkYXRlIGRlcGVuZGVuY2llcyBhbmQgc3Vic2NyaXB0aW9ucyBmb3Igc2VsZWN0b3JzLlxyXG4vLyBVcGRhdGUgc2F2ZWQgdmFsdWUgdmFsaWRhdGlvbiBmb3IgYXRvbXMuXHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0Tm9kZUxvYWRhYmxlKHN0b3JlLCBzdGF0ZSwga2V5KSB7XHJcbiAgaW5pdGlhbGl6ZU5vZGVJZk5ld1RvU3RvcmUoc3RvcmUsIHN0YXRlLCBrZXksICdnZXQnKTtcclxuICByZXR1cm4gZ2V0Tm9kZSQxKGtleSkuZ2V0KHN0b3JlLCBzdGF0ZSk7XHJcbn0gLy8gUGVlayBhdCB0aGUgY3VycmVudCB2YWx1ZSBsb2FkYWJsZSBmb3IgYSBub2RlIHdpdGhvdXQgYW55IGV2YWx1YXRpb24gb3Igc3RhdGUgY2hhbmdlXHJcblxyXG5cclxuZnVuY3Rpb24gcGVla05vZGVMb2FkYWJsZShzdG9yZSwgc3RhdGUsIGtleSkge1xyXG4gIHJldHVybiBnZXROb2RlJDEoa2V5KS5wZWVrKHN0b3JlLCBzdGF0ZSk7XHJcbn0gLy8gV3JpdGUgdmFsdWUgZGlyZWN0bHkgdG8gc3RhdGUgYnlwYXNzaW5nIHRoZSBOb2RlIGludGVyZmFjZSBhcyB0aGUgbm9kZVxyXG4vLyBkZWZpbml0aW9ucyBtYXkgbm90IGhhdmUgYmVlbiBsb2FkZWQgeWV0IHdoZW4gcHJvY2Vzc2luZyB0aGUgaW5pdGlhbCBzbmFwc2hvdC5cclxuXHJcblxyXG5mdW5jdGlvbiBzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVEKHN0YXRlLCBrZXksIG5ld1ZhbHVlKSB7XHJcbiAgdmFyIF9ub2RlJGludmFsaWRhdGU7XHJcblxyXG4gIGNvbnN0IG5vZGUgPSBnZXROb2RlTWF5YmUkMShrZXkpO1xyXG4gIG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ub2RlJGludmFsaWRhdGUgPSBub2RlLmludmFsaWRhdGUpID09PSBudWxsIHx8IF9ub2RlJGludmFsaWRhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGludmFsaWRhdGUuY2FsbChub2RlLCBzdGF0ZSk7XHJcbiAgcmV0dXJuIHsgLi4uc3RhdGUsXHJcbiAgICBhdG9tVmFsdWVzOiBzdGF0ZS5hdG9tVmFsdWVzLmNsb25lKCkuZGVsZXRlKGtleSksXHJcbiAgICBub252YWxpZGF0ZWRBdG9tczogc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuY2xvbmUoKS5zZXQoa2V5LCBuZXdWYWx1ZSksXHJcbiAgICBkaXJ0eUF0b21zOiBzZXRCeUFkZGluZ1RvU2V0JDEoc3RhdGUuZGlydHlBdG9tcywga2V5KVxyXG4gIH07XHJcbn0gLy8gUmV0dXJuIHRoZSBkaXNjb3ZlcmVkIGRlcGVuZGVuY2llcyBhbmQgdmFsdWVzIHRvIGJlIHdyaXR0ZW4gYnkgc2V0dGluZ1xyXG4vLyBhIG5vZGUgdmFsdWUuIChNdWx0aXBsZSB2YWx1ZXMgbWF5IGJlIHdyaXR0ZW4gZHVlIHRvIHNlbGVjdG9ycyBnZXR0aW5nIHRvXHJcbi8vIHNldCB1cHN0cmVhbXM7IGRlcHMgbWF5IGJlIGRpc2NvdmVyZWQgYmVjYXVzZSBvZiByZWFkcyBpbiB1cGRhdGVyIGZ1bmN0aW9ucy4pXHJcblxyXG5cclxuZnVuY3Rpb24gc2V0Tm9kZVZhbHVlKHN0b3JlLCBzdGF0ZSwga2V5LCBuZXdWYWx1ZSkge1xyXG4gIGNvbnN0IG5vZGUgPSBnZXROb2RlJDEoa2V5KTtcclxuXHJcbiAgaWYgKG5vZGUuc2V0ID09IG51bGwpIHtcclxuICAgIHRocm93IG5ldyBSZWFkT25seVJlY29pbFZhbHVlRXJyb3IoYEF0dGVtcHQgdG8gc2V0IHJlYWQtb25seSBSZWNvaWxWYWx1ZTogJHtrZXl9YCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzZXQgPSBub2RlLnNldDsgLy8gc28gZmxvdyBkb2Vzbid0IGxvc2UgdGhlIGFib3ZlIHJlZmluZW1lbnQuXHJcblxyXG4gIGluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlKHN0b3JlLCBzdGF0ZSwga2V5LCAnc2V0Jyk7XHJcbiAgcmV0dXJuIHNldChzdG9yZSwgc3RhdGUsIG5ld1ZhbHVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGVla05vZGVJbmZvKHN0b3JlLCBzdGF0ZSwga2V5KSB7XHJcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaChzdGF0ZS52ZXJzaW9uKTtcclxuICBjb25zdCB0eXBlID0gZ2V0Tm9kZSQxKGtleSkubm9kZVR5cGU7XHJcbiAgcmV0dXJuIFJlY29pbF9sYXp5UHJveHkoe1xyXG4gICAgdHlwZVxyXG4gIH0sIHtcclxuICAgIGxvYWRhYmxlOiAoKSA9PiBwZWVrTm9kZUxvYWRhYmxlKHN0b3JlLCBzdGF0ZSwga2V5KSxcclxuICAgIGlzQWN0aXZlOiAoKSA9PiBzdG9yZVN0YXRlLmtub3duQXRvbXMuaGFzKGtleSkgfHwgc3RvcmVTdGF0ZS5rbm93blNlbGVjdG9ycy5oYXMoa2V5KSxcclxuICAgIGlzU2V0OiAoKSA9PiB0eXBlID09PSAnc2VsZWN0b3InID8gZmFsc2UgOiBzdGF0ZS5hdG9tVmFsdWVzLmhhcyhrZXkpLFxyXG4gICAgaXNNb2RpZmllZDogKCkgPT4gc3RhdGUuZGlydHlBdG9tcy5oYXMoa2V5KSxcclxuICAgIC8vIFJlcG9ydCBjdXJyZW50IGRlcGVuZGVuY2llcy4gIElmIHRoZSBub2RlIGhhc24ndCBiZWVuIGV2YWx1YXRlZCwgdGhlblxyXG4gICAgLy8gZGVwZW5kZW5jaWVzIG1heSBiZSBtaXNzaW5nIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlLlxyXG4gICAgZGVwczogKCkgPT4ge1xyXG4gICAgICB2YXIgX2dyYXBoJG5vZGVEZXBzJGdldDtcclxuXHJcbiAgICAgIHJldHVybiByZWNvaWxWYWx1ZXNGb3JLZXlzJDEoKF9ncmFwaCRub2RlRGVwcyRnZXQgPSBncmFwaC5ub2RlRGVwcy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX2dyYXBoJG5vZGVEZXBzJGdldCAhPT0gdm9pZCAwID8gX2dyYXBoJG5vZGVEZXBzJGdldCA6IFtdKTtcclxuICAgIH0sXHJcbiAgICAvLyBSZXBvcnRzIGFsbCBcImN1cnJlbnRcIiBzdWJzY3JpYmVycy4gIEV2YWx1YXRpbmcgb3RoZXIgbm9kZXMgb3JcclxuICAgIC8vIHByZXZpb3VzIGluLXByb2dyZXNzIGFzeW5jIGV2YWx1YXRpb25zIG1heSBpbnRyb2R1Y2UgbmV3IHN1YnNjcmliZXJzLlxyXG4gICAgc3Vic2NyaWJlcnM6ICgpID0+IHtcclxuICAgICAgdmFyIF9zdG9yZVN0YXRlJG5vZGVUb0NvbSwgX3N0b3JlU3RhdGUkbm9kZVRvQ29tMjtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9kZXM6IHJlY29pbFZhbHVlc0ZvcktleXMkMShSZWNvaWxfZmlsdGVySXRlcmFibGUoZ2V0RG93bnN0cmVhbU5vZGVzKHN0b3JlLCBzdGF0ZSwgbmV3IFNldChba2V5XSkpLCBub2RlS2V5ID0+IG5vZGVLZXkgIT09IGtleSkpLFxyXG4gICAgICAgIGNvbXBvbmVudHM6IFJlY29pbF9tYXBJdGVyYWJsZSgoX3N0b3JlU3RhdGUkbm9kZVRvQ29tID0gKF9zdG9yZVN0YXRlJG5vZGVUb0NvbTIgPSBzdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJG5vZGVUb0NvbTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJG5vZGVUb0NvbTIudmFsdWVzKCkpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5vZGVUb0NvbSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbm9kZVRvQ29tIDogW10sIChbbmFtZV0pID0+ICh7XHJcbiAgICAgICAgICBuYW1lXHJcbiAgICAgICAgfSkpXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0gLy8gRmluZCBhbGwgb2YgdGhlIHJlY3Vyc2l2ZWx5IGRlcGVuZGVudCBub2Rlc1xyXG5cclxuXHJcbmZ1bmN0aW9uIGdldERvd25zdHJlYW1Ob2RlcyhzdG9yZSwgc3RhdGUsIGtleXMpIHtcclxuICBjb25zdCB2aXNpdGVkTm9kZXMgPSBuZXcgU2V0KCk7XHJcbiAgY29uc3QgdmlzaXRpbmdOb2RlcyA9IEFycmF5LmZyb20oa2V5cyk7XHJcbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaChzdGF0ZS52ZXJzaW9uKTtcclxuXHJcbiAgZm9yIChsZXQga2V5ID0gdmlzaXRpbmdOb2Rlcy5wb3AoKTsga2V5OyBrZXkgPSB2aXNpdGluZ05vZGVzLnBvcCgpKSB7XHJcbiAgICB2YXIgX2dyYXBoJG5vZGVUb05vZGVTdWJzO1xyXG5cclxuICAgIHZpc2l0ZWROb2Rlcy5hZGQoa2V5KTtcclxuICAgIGNvbnN0IHN1YnNjcmliZWROb2RlcyA9IChfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgPSBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX2dyYXBoJG5vZGVUb05vZGVTdWJzICE9PSB2b2lkIDAgPyBfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgOiBlbXB0eVNldDtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGRvd25zdHJlYW1Ob2RlIG9mIHN1YnNjcmliZWROb2Rlcykge1xyXG4gICAgICBpZiAoIXZpc2l0ZWROb2Rlcy5oYXMoZG93bnN0cmVhbU5vZGUpKSB7XHJcbiAgICAgICAgdmlzaXRpbmdOb2Rlcy5wdXNoKGRvd25zdHJlYW1Ob2RlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHZpc2l0ZWROb2RlcztcclxufVxyXG5cclxudmFyIFJlY29pbF9GdW5jdGlvbmFsQ29yZSA9IHtcclxuICBnZXROb2RlTG9hZGFibGUsXHJcbiAgcGVla05vZGVMb2FkYWJsZSxcclxuICBzZXROb2RlVmFsdWUsXHJcbiAgaW5pdGlhbGl6ZU5vZGUsXHJcbiAgY2xlYW5VcE5vZGUsXHJcbiAgc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCxcclxuICBwZWVrTm9kZUluZm8sXHJcbiAgZ2V0RG93bnN0cmVhbU5vZGVzXHJcbn07XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG5cclxubGV0IF9pbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCA9IG51bGw7XHJcblxyXG5mdW5jdGlvbiBzZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdChpbnZhbGlkYXRlKSB7XHJcbiAgX2ludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90ID0gaW52YWxpZGF0ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QoKSB7XHJcbiAgdmFyIF9pbnZhbGlkYXRlTWVtb2l6ZWRTbjtcclxuXHJcbiAgKF9pbnZhbGlkYXRlTWVtb2l6ZWRTbiA9IF9pbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCkgPT09IG51bGwgfHwgX2ludmFsaWRhdGVNZW1vaXplZFNuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW52YWxpZGF0ZU1lbW9pemVkU24oKTtcclxufVxyXG5cclxudmFyIFJlY29pbF9TbmFwc2hvdENhY2hlID0ge1xyXG4gIHNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90LFxyXG4gIGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90XHJcbn07XHJcblxyXG5jb25zdCB7XHJcbiAgZ2V0RG93bnN0cmVhbU5vZGVzOiBnZXREb3duc3RyZWFtTm9kZXMkMSxcclxuICBnZXROb2RlTG9hZGFibGU6IGdldE5vZGVMb2FkYWJsZSQxLFxyXG4gIHNldE5vZGVWYWx1ZTogc2V0Tm9kZVZhbHVlJDFcclxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcclxuXHJcbmNvbnN0IHtcclxuICBnZXROZXh0Q29tcG9uZW50SUQ6IGdldE5leHRDb21wb25lbnRJRCQxXHJcbn0gPSBSZWNvaWxfS2V5cztcclxuXHJcbmNvbnN0IHtcclxuICBnZXROb2RlOiBnZXROb2RlJDIsXHJcbiAgZ2V0Tm9kZU1heWJlOiBnZXROb2RlTWF5YmUkMlxyXG59ID0gUmVjb2lsX05vZGU7XHJcblxyXG5jb25zdCB7XHJcbiAgRGVmYXVsdFZhbHVlOiBEZWZhdWx0VmFsdWUkMVxyXG59ID0gUmVjb2lsX05vZGU7XHJcblxyXG5jb25zdCB7XHJcbiAgcmVhY3RNb2RlOiByZWFjdE1vZGUkMVxyXG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcclxuXHJcbmNvbnN0IHtcclxuICBBYnN0cmFjdFJlY29pbFZhbHVlOiBBYnN0cmFjdFJlY29pbFZhbHVlJDEsXHJcbiAgUmVjb2lsU3RhdGU6IFJlY29pbFN0YXRlJDEsXHJcbiAgUmVjb2lsVmFsdWVSZWFkT25seTogUmVjb2lsVmFsdWVSZWFkT25seSQxLFxyXG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkMVxyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlJDE7XHJcblxyXG5jb25zdCB7XHJcbiAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3Q6IGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDFcclxufSA9IFJlY29pbF9TbmFwc2hvdENhY2hlO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlKHN0b3JlLCB7XHJcbiAga2V5XHJcbn0sIHRyZWVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUpIHtcclxuICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWUsIF9zdG9yZVN0YXRlJHByZXZpb3VzVDtcclxuXHJcbiAgLy8gUmVhZGluZyBmcm9tIGFuIG9sZGVyIHRyZWUgY2FuIGNhdXNlIGJ1Z3MgYmVjYXVzZSB0aGUgZGVwZW5kZW5jaWVzIHRoYXQgd2VcclxuICAvLyBkaXNjb3ZlciBkdXJpbmcgdGhlIHJlYWQgYXJlIGxvc3QuXHJcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gIGlmICghKHRyZWVTdGF0ZS52ZXJzaW9uID09PSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlLnZlcnNpb24gfHwgdHJlZVN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkbmV4dFRyZWUudmVyc2lvbikgfHwgdHJlZVN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUID0gc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJHByZXZpb3VzVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNULnZlcnNpb24pKSkge1xyXG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdUcmllZCB0byByZWFkIGZyb20gYSBkaXNjYXJkZWQgdHJlZScpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgbG9hZGFibGUgPSBnZXROb2RlTG9hZGFibGUkMShzdG9yZSwgdHJlZVN0YXRlLCBrZXkpO1xyXG5cclxuICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xyXG4gICAgbG9hZGFibGUuY29udGVudHMuY2F0Y2goKCkgPT4ge1xyXG4gICAgICAvKipcclxuICAgICAgICogSEFDSzogaW50ZXJjZXB0IHRocm93biBlcnJvciBoZXJlIHRvIHByZXZlbnQgYW4gdW5jYXVnaHQgcHJvbWlzZSBleGNlcHRpb24uIElkZWFsbHkgdGhpcyB3b3VsZCBoYXBwZW4gY2xvc2VyIHRvIHNlbGVjdG9yXHJcbiAgICAgICAqIGV4ZWN1dGlvbiAocGVyaGFwcyBpbnRyb2R1Y2luZyBhIG5ldyBFUlJPUiBjbGFzcyB0byBiZSByZXNvbHZlZCBieSBhc3luYyBzZWxlY3RvcnMgdGhhdCBhcmUgaW4gYW4gZXJyb3Igc3RhdGUpXHJcbiAgICAgICAqL1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBsb2FkYWJsZTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlBdG9tVmFsdWVXcml0ZXMoYXRvbVZhbHVlcywgd3JpdGVzKSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXRvbVZhbHVlcy5jbG9uZSgpO1xyXG4gIHdyaXRlcy5mb3JFYWNoKCh2LCBrKSA9PiB7XHJcbiAgICBpZiAodi5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJyAmJiB2LmNvbnRlbnRzIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDEpIHtcclxuICAgICAgcmVzdWx0LmRlbGV0ZShrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlc3VsdC5zZXQoaywgdik7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gdmFsdWVGcm9tVmFsdWVPclVwZGF0ZXIoc3RvcmUsIHN0YXRlLCB7XHJcbiAga2V5XHJcbn0sIHZhbHVlT3JVcGRhdGVyKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZU9yVXBkYXRlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgLy8gVXBkYXRlciBmb3JtOiBwYXNzIGluIHRoZSBjdXJyZW50IHZhbHVlLiBUaHJvdyBpZiB0aGUgY3VycmVudCB2YWx1ZVxyXG4gICAgLy8gaXMgdW5hdmFpbGFibGUgKG5hbWVseSB3aGVuIHVwZGF0aW5nIGFuIGFzeW5jIHNlbGVjdG9yIHRoYXQnc1xyXG4gICAgLy8gcGVuZGluZyBvciBlcnJvcmVkKTpcclxuICAgIGNvbnN0IGN1cnJlbnQgPSBnZXROb2RlTG9hZGFibGUkMShzdG9yZSwgc3RhdGUsIGtleSk7XHJcblxyXG4gICAgaWYgKGN1cnJlbnQuc3RhdGUgPT09ICdsb2FkaW5nJykge1xyXG4gICAgICBjb25zdCBtc2cgPSBgVHJpZWQgdG8gc2V0IGF0b20gb3Igc2VsZWN0b3IgXCIke2tleX1cIiB1c2luZyBhbiB1cGRhdGVyIGZ1bmN0aW9uIHdoaWxlIHRoZSBjdXJyZW50IHN0YXRlIGlzIHBlbmRpbmcsIHRoaXMgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuYDtcclxuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKG1zZyk7XHJcbiAgICAgIHRocm93IFJlY29pbF9lcnIobXNnKTtcclxuICAgIH0gZWxzZSBpZiAoY3VycmVudC5zdGF0ZSA9PT0gJ2hhc0Vycm9yJykge1xyXG4gICAgICB0aHJvdyBjdXJyZW50LmNvbnRlbnRzO1xyXG4gICAgfSAvLyBUIGl0c2VsZiBtYXkgYmUgYSBmdW5jdGlvbiwgc28gb3VyIHJlZmluZW1lbnQgaXMgbm90IHN1ZmZpY2llbnQ6XHJcblxyXG5cclxuICAgIHJldHVybiB2YWx1ZU9yVXBkYXRlcihjdXJyZW50LmNvbnRlbnRzKTsgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB2YWx1ZU9yVXBkYXRlcjtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5QWN0aW9uKHN0b3JlLCBzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgaWYgKGFjdGlvbi50eXBlID09PSAnc2V0Jykge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICByZWNvaWxWYWx1ZSxcclxuICAgICAgdmFsdWVPclVwZGF0ZXJcclxuICAgIH0gPSBhY3Rpb247XHJcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlRnJvbVZhbHVlT3JVcGRhdGVyKHN0b3JlLCBzdGF0ZSwgcmVjb2lsVmFsdWUsIHZhbHVlT3JVcGRhdGVyKTtcclxuICAgIGNvbnN0IHdyaXRlcyA9IHNldE5vZGVWYWx1ZSQxKHN0b3JlLCBzdGF0ZSwgcmVjb2lsVmFsdWUua2V5LCBuZXdWYWx1ZSk7XHJcblxyXG4gICAgZm9yIChjb25zdCBba2V5LCBsb2FkYWJsZV0gb2Ygd3JpdGVzLmVudHJpZXMoKSkge1xyXG4gICAgICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUoc3RhdGUsIGtleSwgbG9hZGFibGUpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09ICdzZXRMb2FkYWJsZScpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgcmVjb2lsVmFsdWU6IHtcclxuICAgICAgICBrZXlcclxuICAgICAgfSxcclxuICAgICAgbG9hZGFibGVcclxuICAgIH0gPSBhY3Rpb247XHJcbiAgICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUoc3RhdGUsIGtleSwgbG9hZGFibGUpO1xyXG4gIH0gZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09ICdtYXJrTW9kaWZpZWQnKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHJlY29pbFZhbHVlOiB7XHJcbiAgICAgICAga2V5XHJcbiAgICAgIH1cclxuICAgIH0gPSBhY3Rpb247XHJcbiAgICBzdGF0ZS5kaXJ0eUF0b21zLmFkZChrZXkpO1xyXG4gIH0gZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09ICdzZXRVbnZhbGlkYXRlZCcpIHtcclxuICAgIHZhciBfbm9kZSRpbnZhbGlkYXRlO1xyXG5cclxuICAgIC8vIFdyaXRlIHZhbHVlIGRpcmVjdGx5IHRvIHN0YXRlIGJ5cGFzc2luZyB0aGUgTm9kZSBpbnRlcmZhY2UgYXMgdGhlIG5vZGVcclxuICAgIC8vIGRlZmluaXRpb25zIG1heSBub3QgaGF2ZSBiZWVuIGxvYWRlZCB5ZXQgd2hlbiBwcm9jZXNzaW5nIHRoZSBpbml0aWFsIHNuYXBzaG90LlxyXG4gICAgY29uc3Qge1xyXG4gICAgICByZWNvaWxWYWx1ZToge1xyXG4gICAgICAgIGtleVxyXG4gICAgICB9LFxyXG4gICAgICB1bnZhbGlkYXRlZFZhbHVlXHJcbiAgICB9ID0gYWN0aW9uO1xyXG4gICAgY29uc3Qgbm9kZSA9IGdldE5vZGVNYXliZSQyKGtleSk7XHJcbiAgICBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbm9kZSRpbnZhbGlkYXRlID0gbm9kZS5pbnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfbm9kZSRpbnZhbGlkYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRpbnZhbGlkYXRlLmNhbGwobm9kZSwgc3RhdGUpO1xyXG4gICAgc3RhdGUuYXRvbVZhbHVlcy5kZWxldGUoa2V5KTtcclxuICAgIHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLnNldChrZXksIHVudmFsaWRhdGVkVmFsdWUpO1xyXG4gICAgc3RhdGUuZGlydHlBdG9tcy5hZGQoa2V5KTtcclxuICB9IGVsc2Uge1xyXG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKGBVbmtub3duIGFjdGlvbiAke2FjdGlvbi50eXBlfWApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlKHN0YXRlLCBrZXksIGxvYWRhYmxlKSB7XHJcbiAgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnICYmIGxvYWRhYmxlLmNvbnRlbnRzIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDEpIHtcclxuICAgIHN0YXRlLmF0b21WYWx1ZXMuZGVsZXRlKGtleSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHN0YXRlLmF0b21WYWx1ZXMuc2V0KGtleSwgbG9hZGFibGUpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGUuZGlydHlBdG9tcy5hZGQoa2V5KTtcclxuICBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5kZWxldGUoa2V5KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlBY3Rpb25zVG9TdG9yZShzdG9yZSwgYWN0aW9ucykge1xyXG4gIHN0b3JlLnJlcGxhY2VTdGF0ZShzdGF0ZSA9PiB7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IGNvcHlUcmVlU3RhdGUoc3RhdGUpO1xyXG5cclxuICAgIGZvciAoY29uc3QgYWN0aW9uIG9mIGFjdGlvbnMpIHtcclxuICAgICAgYXBwbHlBY3Rpb24oc3RvcmUsIG5ld1N0YXRlLCBhY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGludmFsaWRhdGVEb3duc3RyZWFtcyhzdG9yZSwgbmV3U3RhdGUpO1xyXG4gICAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMSgpO1xyXG4gICAgcmV0dXJuIG5ld1N0YXRlO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdWV1ZU9yUGVyZm9ybVN0YXRlVXBkYXRlKHN0b3JlLCBhY3Rpb24pIHtcclxuICBpZiAoYmF0Y2hTdGFjay5sZW5ndGgpIHtcclxuICAgIGNvbnN0IGFjdGlvbnNCeVN0b3JlID0gYmF0Y2hTdGFja1tiYXRjaFN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgbGV0IGFjdGlvbnMgPSBhY3Rpb25zQnlTdG9yZS5nZXQoc3RvcmUpO1xyXG5cclxuICAgIGlmICghYWN0aW9ucykge1xyXG4gICAgICBhY3Rpb25zQnlTdG9yZS5zZXQoc3RvcmUsIGFjdGlvbnMgPSBbXSk7XHJcbiAgICB9XHJcblxyXG4gICAgYWN0aW9ucy5wdXNoKGFjdGlvbik7XHJcbiAgfSBlbHNlIHtcclxuICAgIGFwcGx5QWN0aW9uc1RvU3RvcmUoc3RvcmUsIFthY3Rpb25dKTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGJhdGNoU3RhY2sgPSBbXTtcclxuXHJcbmZ1bmN0aW9uIGJhdGNoU3RhcnQoKSB7XHJcbiAgY29uc3QgYWN0aW9uc0J5U3RvcmUgPSBuZXcgTWFwKCk7XHJcbiAgYmF0Y2hTdGFjay5wdXNoKGFjdGlvbnNCeVN0b3JlKTtcclxuICByZXR1cm4gKCkgPT4ge1xyXG4gICAgZm9yIChjb25zdCBbc3RvcmUsIGFjdGlvbnNdIG9mIGFjdGlvbnNCeVN0b3JlKSB7XHJcbiAgICAgIGFwcGx5QWN0aW9uc1RvU3RvcmUoc3RvcmUsIGFjdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBvcHBlZCA9IGJhdGNoU3RhY2sucG9wKCk7XHJcblxyXG4gICAgaWYgKHBvcHBlZCAhPT0gYWN0aW9uc0J5U3RvcmUpIHtcclxuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdJbmNvcnJlY3Qgb3JkZXIgb2YgYmF0Y2ggcG9wcGluZycpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvcHlUcmVlU3RhdGUoc3RhdGUpIHtcclxuICByZXR1cm4geyAuLi5zdGF0ZSxcclxuICAgIGF0b21WYWx1ZXM6IHN0YXRlLmF0b21WYWx1ZXMuY2xvbmUoKSxcclxuICAgIG5vbnZhbGlkYXRlZEF0b21zOiBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5jbG9uZSgpLFxyXG4gICAgZGlydHlBdG9tczogbmV3IFNldChzdGF0ZS5kaXJ0eUF0b21zKVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludmFsaWRhdGVEb3duc3RyZWFtcyhzdG9yZSwgc3RhdGUpIHtcclxuICAvLyBJbmZvcm0gYW55IG5vZGVzIHRoYXQgd2VyZSBjaGFuZ2VkIG9yIGRvd25zdHJlYW0gb2YgY2hhbmdlcyBzbyB0aGF0IHRoZXlcclxuICAvLyBjYW4gY2xlYXIgb3V0IGFueSBjYWNoZXMgYXMgbmVlZGVkIGR1ZSB0byB0aGUgdXBkYXRlOlxyXG4gIGNvbnN0IGRvd25zdHJlYW1zID0gZ2V0RG93bnN0cmVhbU5vZGVzJDEoc3RvcmUsIHN0YXRlLCBzdGF0ZS5kaXJ0eUF0b21zKTtcclxuXHJcbiAgZm9yIChjb25zdCBrZXkgb2YgZG93bnN0cmVhbXMpIHtcclxuICAgIHZhciBfZ2V0Tm9kZU1heWJlLCBfZ2V0Tm9kZU1heWJlJGludmFsaWQ7XHJcblxyXG4gICAgKF9nZXROb2RlTWF5YmUgPSBnZXROb2RlTWF5YmUkMihrZXkpKSA9PT0gbnVsbCB8fCBfZ2V0Tm9kZU1heWJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2dldE5vZGVNYXliZSRpbnZhbGlkID0gX2dldE5vZGVNYXliZS5pbnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfZ2V0Tm9kZU1heWJlJGludmFsaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXROb2RlTWF5YmUkaW52YWxpZC5jYWxsKF9nZXROb2RlTWF5YmUsIHN0YXRlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFJlY29pbFZhbHVlKHN0b3JlLCByZWNvaWxWYWx1ZSwgdmFsdWVPclVwZGF0ZXIpIHtcclxuICBxdWV1ZU9yUGVyZm9ybVN0YXRlVXBkYXRlKHN0b3JlLCB7XHJcbiAgICB0eXBlOiAnc2V0JyxcclxuICAgIHJlY29pbFZhbHVlLFxyXG4gICAgdmFsdWVPclVwZGF0ZXJcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0UmVjb2lsVmFsdWVMb2FkYWJsZShzdG9yZSwgcmVjb2lsVmFsdWUsIGxvYWRhYmxlKSB7XHJcbiAgaWYgKGxvYWRhYmxlIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDEpIHtcclxuICAgIHJldHVybiBzZXRSZWNvaWxWYWx1ZShzdG9yZSwgcmVjb2lsVmFsdWUsIGxvYWRhYmxlKTtcclxuICB9XHJcblxyXG4gIHF1ZXVlT3JQZXJmb3JtU3RhdGVVcGRhdGUoc3RvcmUsIHtcclxuICAgIHR5cGU6ICdzZXRMb2FkYWJsZScsXHJcbiAgICByZWNvaWxWYWx1ZSxcclxuICAgIGxvYWRhYmxlOiBsb2FkYWJsZVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZChzdG9yZSwgcmVjb2lsVmFsdWUpIHtcclxuICBxdWV1ZU9yUGVyZm9ybVN0YXRlVXBkYXRlKHN0b3JlLCB7XHJcbiAgICB0eXBlOiAnbWFya01vZGlmaWVkJyxcclxuICAgIHJlY29pbFZhbHVlXHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUoc3RvcmUsIHJlY29pbFZhbHVlLCB1bnZhbGlkYXRlZFZhbHVlKSB7XHJcbiAgcXVldWVPclBlcmZvcm1TdGF0ZVVwZGF0ZShzdG9yZSwge1xyXG4gICAgdHlwZTogJ3NldFVudmFsaWRhdGVkJyxcclxuICAgIHJlY29pbFZhbHVlLFxyXG4gICAgdW52YWxpZGF0ZWRWYWx1ZVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdWJzY3JpYmVUb1JlY29pbFZhbHVlKHN0b3JlLCB7XHJcbiAga2V5XHJcbn0sIGNhbGxiYWNrLCBjb21wb25lbnREZWJ1Z05hbWUgPSBudWxsKSB7XHJcbiAgY29uc3Qgc3ViSUQgPSBnZXROZXh0Q29tcG9uZW50SUQkMSgpO1xyXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICBpZiAoIXN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5oYXMoa2V5KSkge1xyXG4gICAgc3RvcmVTdGF0ZS5ub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zLnNldChrZXksIG5ldyBNYXAoKSk7XHJcbiAgfVxyXG5cclxuICBSZWNvaWxfbnVsbHRocm93cyhzdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZ2V0KGtleSkpLnNldChzdWJJRCwgW2NvbXBvbmVudERlYnVnTmFtZSAhPT0gbnVsbCAmJiBjb21wb25lbnREZWJ1Z05hbWUgIT09IHZvaWQgMCA/IGNvbXBvbmVudERlYnVnTmFtZSA6ICc8bm90IGNhcHR1cmVkPicsIGNhbGxiYWNrXSk7IC8vIEhhbmRsZSB0aGUgY2FzZSB0aGF0LCBkdXJpbmcgdGhlIHNhbWUgdGljayB0aGF0IHdlIGFyZSBzdWJzY3JpYmluZywgYW4gYXRvbVxyXG4gIC8vIGhhcyBiZWVuIHVwZGF0ZWQgYnkgc29tZSBlZmZlY3QgaGFuZGxlci4gT3RoZXJ3aXNlIHdlIHdpbGwgbWlzcyB0aGUgdXBkYXRlLlxyXG5cclxuICBjb25zdCBtb2RlID0gcmVhY3RNb2RlJDEoKTtcclxuXHJcbiAgaWYgKG1vZGUuZWFybHkgJiYgKG1vZGUubW9kZSA9PT0gJ0xFR0FDWScgfHwgbW9kZS5tb2RlID09PSAnTVVUQUJMRV9TT1VSQ0UnKSkge1xyXG4gICAgY29uc3QgbmV4dFRyZWUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlO1xyXG5cclxuICAgIGlmIChuZXh0VHJlZSAmJiBuZXh0VHJlZS5kaXJ0eUF0b21zLmhhcyhrZXkpKSB7XHJcbiAgICAgIGNhbGxiYWNrKG5leHRUcmVlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICByZWxlYXNlOiAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlbGVhc2VTdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgICAgY29uc3Qgc3VicyA9IHJlbGVhc2VTdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZ2V0KGtleSk7XHJcblxyXG4gICAgICBpZiAoc3VicyA9PT0gdW5kZWZpbmVkIHx8ICFzdWJzLmhhcyhzdWJJRCkpIHtcclxuICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oYFN1YnNjcmlwdGlvbiBtaXNzaW5nIGF0IHJlbGVhc2UgdGltZSBmb3IgYXRvbSAke2tleX0uIFRoaXMgaXMgYSBidWcgaW4gUmVjb2lsLmApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3Vicy5kZWxldGUoc3ViSUQpO1xyXG5cclxuICAgICAgaWYgKHN1YnMuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgIHJlbGVhc2VTdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZGVsZXRlKGtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWZyZXNoUmVjb2lsVmFsdWUoc3RvcmUsIHJlY29pbFZhbHVlKSB7XHJcbiAgdmFyIF9ub2RlJGNsZWFyQ2FjaGU7XHJcblxyXG4gIGNvbnN0IHtcclxuICAgIGN1cnJlbnRUcmVlXHJcbiAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcbiAgY29uc3Qgbm9kZSA9IGdldE5vZGUkMihyZWNvaWxWYWx1ZS5rZXkpO1xyXG4gIChfbm9kZSRjbGVhckNhY2hlID0gbm9kZS5jbGVhckNhY2hlKSA9PT0gbnVsbCB8fCBfbm9kZSRjbGVhckNhY2hlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRjbGVhckNhY2hlLmNhbGwobm9kZSwgc3RvcmUsIGN1cnJlbnRUcmVlKTtcclxufVxyXG5cclxudmFyIFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZSA9IHtcclxuICBSZWNvaWxWYWx1ZVJlYWRPbmx5OiBSZWNvaWxWYWx1ZVJlYWRPbmx5JDEsXHJcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZTogQWJzdHJhY3RSZWNvaWxWYWx1ZSQxLFxyXG4gIFJlY29pbFN0YXRlOiBSZWNvaWxTdGF0ZSQxLFxyXG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSxcclxuICBzZXRSZWNvaWxWYWx1ZSxcclxuICBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlLFxyXG4gIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkLFxyXG4gIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUsXHJcbiAgc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSxcclxuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDEsXHJcbiAgYXBwbHlBdG9tVmFsdWVXcml0ZXMsXHJcbiAgLy8gVE9ETyBSZW1vdmUgZXhwb3J0IHdoZW4gZGVwcmVjYXRpbmcgaW5pdGlhbFN0b3JlU3RhdGVfREVQUkVDQVRFRCBpbiBSZWNvaWxSb290XHJcbiAgYmF0Y2hTdGFydCxcclxuICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUsXHJcbiAgaW52YWxpZGF0ZURvd25zdHJlYW1zLFxyXG4gIGNvcHlUcmVlU3RhdGUsXHJcbiAgcmVmcmVzaFJlY29pbFZhbHVlXHJcbn07XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG4vKipcclxuICogVGhlIHNvbWVTZXQoKSBtZXRob2QgdGVzdHMgd2hldGhlciBzb21lIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBTZXQgcGFzcyB0aGVcclxuICogdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gc29tZVNldChzZXQsIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgY29uc3QgaXRlcmF0b3IgPSBzZXQuZW50cmllcygpO1xyXG4gIGxldCBjdXJyZW50ID0gaXRlcmF0b3IubmV4dCgpO1xyXG5cclxuICB3aGlsZSAoIWN1cnJlbnQuZG9uZSkge1xyXG4gICAgY29uc3QgZW50cnkgPSBjdXJyZW50LnZhbHVlO1xyXG5cclxuICAgIGlmIChjYWxsYmFjay5jYWxsKGNvbnRleHQsIGVudHJ5WzFdLCBlbnRyeVswXSwgc2V0KSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBjdXJyZW50ID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX3NvbWVTZXQgPSBzb21lU2V0O1xyXG5cclxuY29uc3Qge1xyXG4gIGNsZWFuVXBOb2RlOiBjbGVhblVwTm9kZSQxXHJcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XHJcblxyXG5jb25zdCB7XHJcbiAgZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGU6IGRlbGV0ZU5vZGVDb25maWdJZlBvc3NpYmxlJDEsXHJcbiAgZ2V0Tm9kZTogZ2V0Tm9kZSQzXHJcbn0gPSBSZWNvaWxfTm9kZTtcclxuXHJcbmNvbnN0IHtcclxuICBSZXRlbnRpb25ab25lOiBSZXRlbnRpb25ab25lJDJcclxufSA9IFJlY29pbF9SZXRlbnRpb25ab25lO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIC8vIENvbXBvbmVudHMgdGhhdCBhcmVuJ3QgbW91bnRlZCBhZnRlciBzdXNwZW5kaW5nIGZvciB0aGlzIGxvbmcgd2lsbCBiZSBhc3N1bWVkXHJcbi8vIHRvIGJlIGRpc2NhcmRlZCBhbmQgdGhlaXIgcmVzb3VyY2VzIHJlbGVhc2VkLlxyXG5cclxuXHJcbmNvbnN0IFNVU1BFTlNFX1RJTUVPVVRfTVMgPSAxMjAwMDA7XHJcbmNvbnN0IGVtcHR5U2V0JDEgPSBuZXcgU2V0KCk7XHJcblxyXG5mdW5jdGlvbiByZWxlYXNlUmV0YWluYWJsZXNOb3dPbkN1cnJlbnRUcmVlKHN0b3JlLCByZXRhaW5hYmxlcykge1xyXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG4gIGNvbnN0IHRyZWVTdGF0ZSA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XHJcblxyXG4gIGlmIChzdG9yZVN0YXRlLm5leHRUcmVlKSB7XHJcbiAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ3JlbGVhc2VOb2Rlc05vd09uQ3VycmVudFRyZWUgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGF0IHRoZSBlbmQgb2YgYSBiYXRjaCcpO1xyXG4gICAgcmV0dXJuOyAvLyBsZWFrIG1lbW9yeSByYXRoZXIgdGhhbiBlcmFzZSBzb21ldGhpbmcgdGhhdCdzIGFib3V0IHRvIGJlIHVzZWQuXHJcbiAgfVxyXG5cclxuICBjb25zdCBub2RlcyA9IG5ldyBTZXQoKTtcclxuXHJcbiAgZm9yIChjb25zdCByIG9mIHJldGFpbmFibGVzKSB7XHJcbiAgICBpZiAociBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMikge1xyXG4gICAgICBmb3IgKGNvbnN0IG4gb2Ygbm9kZXNSZXRhaW5lZEJ5Wm9uZShzdG9yZVN0YXRlLCByKSkge1xyXG4gICAgICAgIG5vZGVzLmFkZChuKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbm9kZXMuYWRkKHIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgcmVsZWFzYWJsZU5vZGVzID0gZmluZFJlbGVhc2FibGVOb2RlcyhzdG9yZSwgbm9kZXMpO1xyXG5cclxuICBmb3IgKGNvbnN0IG5vZGUgb2YgcmVsZWFzYWJsZU5vZGVzKSB7XHJcbiAgICByZWxlYXNlTm9kZShzdG9yZSwgdHJlZVN0YXRlLCBub2RlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbmRSZWxlYXNhYmxlTm9kZXMoc3RvcmUsIHNlYXJjaEZyb21Ob2Rlcykge1xyXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG4gIGNvbnN0IHRyZWVTdGF0ZSA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XHJcbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaCh0cmVlU3RhdGUudmVyc2lvbik7XHJcbiAgY29uc3QgcmVsZWFzYWJsZU5vZGVzID0gbmV3IFNldCgpOyAvLyBtdXRhdGVkIHRvIGNvbGxlY3QgYW5zd2VyXHJcblxyXG4gIGNvbnN0IG5vblJlbGVhc2FibGVOb2RlcyA9IG5ldyBTZXQoKTtcclxuICBmaW5kUmVsZWFzYWJsZU5vZGVzSW5uZXIoc2VhcmNoRnJvbU5vZGVzKTtcclxuICByZXR1cm4gcmVsZWFzYWJsZU5vZGVzO1xyXG5cclxuICBmdW5jdGlvbiBmaW5kUmVsZWFzYWJsZU5vZGVzSW5uZXIoc2VhcmNoRnJvbU5vZGVzKSB7XHJcbiAgICBjb25zdCByZWxlYXNhYmxlTm9kZXNGb3VuZFRoaXNJdGVyYXRpb24gPSBuZXcgU2V0KCk7XHJcbiAgICBjb25zdCBkb3duc3RyZWFtcyA9IGdldERvd25zdHJlYW1Ob2Rlc0luVG9wb2xvZ2ljYWxPcmRlcihzdG9yZSwgdHJlZVN0YXRlLCBzZWFyY2hGcm9tTm9kZXMsIHJlbGVhc2FibGVOb2RlcywgLy8gZG9uJ3QgZGVzY2VuZCBpbnRvIHRoZXNlXHJcbiAgICBub25SZWxlYXNhYmxlTm9kZXMgLy8gZG9uJ3QgZGVzY2VuZCBpbnRvIHRoZXNlXHJcbiAgICApOyAvLyBGaW5kIHdoaWNoIG9mIHRoZSBkb3duc3RyZWFtIG5vZGVzIGFyZSByZWxlYXNhYmxlIGFuZCB3aGljaCBhcmUgbm90OlxyXG5cclxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBkb3duc3RyZWFtcykge1xyXG4gICAgICB2YXIgX3N0b3JlU3RhdGUkcmV0ZW50aW9uO1xyXG5cclxuICAgICAgLy8gTm90IHJlbGVhc2FibGUgaWYgY29uZmlndXJlZCB0byBiZSByZXRhaW5lZCBmb3JldmVyOlxyXG4gICAgICBpZiAoZ2V0Tm9kZSQzKG5vZGUpLnJldGFpbmVkQnkgPT09ICdyZWNvaWxSb290Jykge1xyXG4gICAgICAgIG5vblJlbGVhc2FibGVOb2Rlcy5hZGQobm9kZSk7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH0gLy8gTm90IHJlbGVhc2FibGUgaWYgcmV0YWluZWQgZGlyZWN0bHkgYnkgYSBjb21wb25lbnQ6XHJcblxyXG5cclxuICAgICAgaWYgKCgoX3N0b3JlU3RhdGUkcmV0ZW50aW9uID0gc3RvcmVTdGF0ZS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzLmdldChub2RlKSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkcmV0ZW50aW9uICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRyZXRlbnRpb24gOiAwKSA+IDApIHtcclxuICAgICAgICBub25SZWxlYXNhYmxlTm9kZXMuYWRkKG5vZGUpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9IC8vIE5vdCByZWxlYXNhYmxlIGlmIHJldGFpbmVkIGJ5IGEgem9uZTpcclxuXHJcblxyXG4gICAgICBpZiAoem9uZXNUaGF0Q291bGRSZXRhaW5Ob2RlKG5vZGUpLnNvbWUoeiA9PiBzdG9yZVN0YXRlLnJldGVudGlvbi5yZWZlcmVuY2VDb3VudHMuZ2V0KHopKSkge1xyXG4gICAgICAgIG5vblJlbGVhc2FibGVOb2Rlcy5hZGQobm9kZSk7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH0gLy8gTm90IHJlbGVhc2FibGUgaWYgaXQgaGFzIGEgbm9uLXJlbGVhc2FibGUgY2hpbGQgKHdoaWNoIHdpbGwgYWxyZWFkeSBiZSBpblxyXG4gICAgICAvLyBub25SZWxlYXNhYmxlTm9kZXMgYmVjYXVzZSB3ZSBhcmUgZ29pbmcgaW4gdG9wb2xvZ2ljYWwgb3JkZXIpOlxyXG5cclxuXHJcbiAgICAgIGNvbnN0IG5vZGVDaGlsZHJlbiA9IGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChub2RlKTtcclxuXHJcbiAgICAgIGlmIChub2RlQ2hpbGRyZW4gJiYgUmVjb2lsX3NvbWVTZXQobm9kZUNoaWxkcmVuLCBjaGlsZCA9PiBub25SZWxlYXNhYmxlTm9kZXMuaGFzKGNoaWxkKSkpIHtcclxuICAgICAgICBub25SZWxlYXNhYmxlTm9kZXMuYWRkKG5vZGUpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZWxlYXNhYmxlTm9kZXMuYWRkKG5vZGUpO1xyXG4gICAgICByZWxlYXNhYmxlTm9kZXNGb3VuZFRoaXNJdGVyYXRpb24uYWRkKG5vZGUpO1xyXG4gICAgfSAvLyBJZiB3ZSBmb3VuZCBhbnkgcmVsZWFzYWJsZSBub2Rlcywgd2UgbmVlZCB0byB3YWxrIFVQIGZyb20gdGhvc2Ugbm9kZXMgdG9cclxuICAgIC8vIGZpbmQgd2hldGhlciB0aGVpciBwYXJlbnRzIGNhbiBub3cgYmUgcmVsZWFzZWQgYXMgd2VsbDpcclxuXHJcblxyXG4gICAgY29uc3QgcGFyZW50cyA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgcmVsZWFzYWJsZU5vZGVzRm91bmRUaGlzSXRlcmF0aW9uKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGFyZW50IG9mIChfZ3JhcGgkbm9kZURlcHMkZ2V0ID0gZ3JhcGgubm9kZURlcHMuZ2V0KG5vZGUpKSAhPT0gbnVsbCAmJiBfZ3JhcGgkbm9kZURlcHMkZ2V0ICE9PSB2b2lkIDAgPyBfZ3JhcGgkbm9kZURlcHMkZ2V0IDogZW1wdHlTZXQkMSkge1xyXG4gICAgICAgIHZhciBfZ3JhcGgkbm9kZURlcHMkZ2V0O1xyXG5cclxuICAgICAgICBpZiAoIXJlbGVhc2FibGVOb2Rlcy5oYXMocGFyZW50KSkge1xyXG4gICAgICAgICAgcGFyZW50cy5hZGQocGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocGFyZW50cy5zaXplKSB7XHJcbiAgICAgIGZpbmRSZWxlYXNhYmxlTm9kZXNJbm5lcihwYXJlbnRzKTtcclxuICAgIH1cclxuICB9XHJcbn0gLy8gQ2hpbGRyZW4gYmVmb3JlIHBhcmVudHNcclxuXHJcblxyXG5mdW5jdGlvbiBnZXREb3duc3RyZWFtTm9kZXNJblRvcG9sb2dpY2FsT3JkZXIoc3RvcmUsIHRyZWVTdGF0ZSwgbm9kZXMsIC8vIE11dGFibGUgc2V0IGlzIGRlc3Ryb3llZCBpbiBwbGFjZVxyXG5kb05vdERlc2NlbmRJbnRvMSwgZG9Ob3REZXNjZW5kSW50bzIpIHtcclxuICBjb25zdCBncmFwaCA9IHN0b3JlLmdldEdyYXBoKHRyZWVTdGF0ZS52ZXJzaW9uKTtcclxuICBjb25zdCBhbnN3ZXIgPSBbXTtcclxuICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xyXG5cclxuICB3aGlsZSAobm9kZXMuc2l6ZSA+IDApIHtcclxuICAgIHZpc2l0KFJlY29pbF9udWxsdGhyb3dzKG5vZGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZSkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFuc3dlcjtcclxuXHJcbiAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xyXG4gICAgaWYgKGRvTm90RGVzY2VuZEludG8xLmhhcyhub2RlKSB8fCBkb05vdERlc2NlbmRJbnRvMi5oYXMobm9kZSkpIHtcclxuICAgICAgbm9kZXMuZGVsZXRlKG5vZGUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHZpc2l0ZWQuaGFzKG5vZGUpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChub2RlKTtcclxuXHJcbiAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xyXG4gICAgICAgIHZpc2l0KGNoaWxkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xyXG4gICAgbm9kZXMuZGVsZXRlKG5vZGUpO1xyXG4gICAgYW5zd2VyLnB1c2gobm9kZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZWxlYXNlTm9kZShzdG9yZSwgdHJlZVN0YXRlLCBub2RlKSB7XHJcbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfSAvLyBBdG9tIGVmZmVjdHMsIGluLWNsb3N1cmUgY2FjaGVzLCBldGMuOlxyXG5cclxuXHJcbiAgY2xlYW5VcE5vZGUkMShzdG9yZSwgbm9kZSk7IC8vIERlbGV0ZSBmcm9tIHN0b3JlIHN0YXRlOlxyXG5cclxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICBzdG9yZVN0YXRlLmtub3duQXRvbXMuZGVsZXRlKG5vZGUpO1xyXG4gIHN0b3JlU3RhdGUua25vd25TZWxlY3RvcnMuZGVsZXRlKG5vZGUpO1xyXG4gIHN0b3JlU3RhdGUubm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5kZWxldGUobm9kZSk7XHJcbiAgc3RvcmVTdGF0ZS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzLmRlbGV0ZShub2RlKTtcclxuICBjb25zdCB6b25lcyA9IHpvbmVzVGhhdENvdWxkUmV0YWluTm9kZShub2RlKTtcclxuXHJcbiAgZm9yIChjb25zdCB6b25lIG9mIHpvbmVzKSB7XHJcbiAgICB2YXIgX3N0b3JlU3RhdGUkcmV0ZW50aW9uMjtcclxuXHJcbiAgICAoX3N0b3JlU3RhdGUkcmV0ZW50aW9uMiA9IHN0b3JlU3RhdGUucmV0ZW50aW9uLm5vZGVzUmV0YWluZWRCeVpvbmUuZ2V0KHpvbmUpKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRyZXRlbnRpb24yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRyZXRlbnRpb24yLmRlbGV0ZShub2RlKTtcclxuICB9IC8vIE5vdGUgdGhhdCB3ZSBETyBOT1QgZGVsZXRlIGZyb20gbm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucyBiZWNhdXNlIHRoaXNcclxuICAvLyBhbHJlYWR5IGhhcHBlbnMgd2hlbiB0aGUgbGFzdCBjb21wb25lbnQgdGhhdCB3YXMgcmV0YWluaW5nIHRoZSBub2RlIHVubW91bnRzLFxyXG4gIC8vIGFuZCB0aGlzIGNvdWxkIGhhcHBlbiBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoYXQuXHJcbiAgLy8gRGVsZXRlIGZyb20gVHJlZVN0YXRlIGFuZCBkZXAgZ3JhcGg6XHJcblxyXG5cclxuICB0cmVlU3RhdGUuYXRvbVZhbHVlcy5kZWxldGUobm9kZSk7XHJcbiAgdHJlZVN0YXRlLmRpcnR5QXRvbXMuZGVsZXRlKG5vZGUpO1xyXG4gIHRyZWVTdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5kZWxldGUobm9kZSk7XHJcbiAgY29uc3QgZ3JhcGggPSBzdG9yZVN0YXRlLmdyYXBoc0J5VmVyc2lvbi5nZXQodHJlZVN0YXRlLnZlcnNpb24pO1xyXG5cclxuICBpZiAoZ3JhcGgpIHtcclxuICAgIGNvbnN0IGRlcHMgPSBncmFwaC5ub2RlRGVwcy5nZXQobm9kZSk7XHJcblxyXG4gICAgaWYgKGRlcHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBncmFwaC5ub2RlRGVwcy5kZWxldGUobm9kZSk7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XHJcbiAgICAgICAgdmFyIF9ncmFwaCRub2RlVG9Ob2RlU3VicztcclxuXHJcbiAgICAgICAgKF9ncmFwaCRub2RlVG9Ob2RlU3VicyA9IGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChkZXApKSA9PT0gbnVsbCB8fCBfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ncmFwaCRub2RlVG9Ob2RlU3Vicy5kZWxldGUobm9kZSk7XHJcbiAgICAgIH1cclxuICAgIH0gLy8gTm8gbmVlZCB0byBkZWxldGUgc3ViJ3MgZGVwcyBhcyB0aGVyZSBzaG91bGQgYmUgbm8gc3VicyBhdCB0aGlzIHBvaW50LlxyXG4gICAgLy8gQnV0IGFuIGludmFyaWFudCB3b3VsZCByZXF1aXJlIGRlbGV0aW5nIG5vZGVzIGluIHRvcG9sb2dpY2FsIG9yZGVyLlxyXG5cclxuXHJcbiAgICBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5kZWxldGUobm9kZSk7XHJcbiAgfSAvLyBOb2RlIGNvbmZpZyAoZm9yIGZhbWlseSBtZW1iZXJzIG9ubHkgYXMgdGhlaXIgY29uZmlncyBjYW4gYmUgcmVjcmVhdGVkLCBhbmRcclxuICAvLyBvbmx5IGlmIHRoZXkgYXJlIG5vdCByZXRhaW5lZCB3aXRoaW4gYW55IG90aGVyIFN0b3Jlcyk6XHJcblxyXG5cclxuICBkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZSQxKG5vZGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBub2Rlc1JldGFpbmVkQnlab25lKHN0b3JlU3RhdGUsIHpvbmUpIHtcclxuICB2YXIgX3N0b3JlU3RhdGUkcmV0ZW50aW9uMztcclxuXHJcbiAgcmV0dXJuIChfc3RvcmVTdGF0ZSRyZXRlbnRpb24zID0gc3RvcmVTdGF0ZS5yZXRlbnRpb24ubm9kZXNSZXRhaW5lZEJ5Wm9uZS5nZXQoem9uZSkpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJHJldGVudGlvbjMgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJHJldGVudGlvbjMgOiBlbXB0eVNldCQxO1xyXG59XHJcblxyXG5mdW5jdGlvbiB6b25lc1RoYXRDb3VsZFJldGFpbk5vZGUobm9kZSkge1xyXG4gIGNvbnN0IHJldGFpbmVkQnkgPSBnZXROb2RlJDMobm9kZSkucmV0YWluZWRCeTtcclxuXHJcbiAgaWYgKHJldGFpbmVkQnkgPT09IHVuZGVmaW5lZCB8fCByZXRhaW5lZEJ5ID09PSAnY29tcG9uZW50cycgfHwgcmV0YWluZWRCeSA9PT0gJ3JlY29pbFJvb3QnKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfSBlbHNlIGlmIChyZXRhaW5lZEJ5IGluc3RhbmNlb2YgUmV0ZW50aW9uWm9uZSQyKSB7XHJcbiAgICByZXR1cm4gW3JldGFpbmVkQnldO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gcmV0YWluZWRCeTsgLy8gaXQncyBhbiBhcnJheSBvZiB6b25lc1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2NoZWR1bGVPclBlcmZvcm1Qb3NzaWJsZVJlbGVhc2VPZlJldGFpbmFibGUoc3RvcmUsIHJldGFpbmFibGUpIHtcclxuICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gIGlmIChzdGF0ZS5uZXh0VHJlZSkge1xyXG4gICAgc3RhdGUucmV0ZW50aW9uLnJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2UuYWRkKHJldGFpbmFibGUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZWxlYXNlUmV0YWluYWJsZXNOb3dPbkN1cnJlbnRUcmVlKHN0b3JlLCBuZXcgU2V0KFtyZXRhaW5hYmxlXSkpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlUmV0YWluQ291bnQoc3RvcmUsIHJldGFpbmFibGUsIGRlbHRhKSB7XHJcbiAgdmFyIF9tYXAkZ2V0O1xyXG5cclxuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGNvbnN0IG1hcCA9IHN0b3JlLmdldFN0YXRlKCkucmV0ZW50aW9uLnJlZmVyZW5jZUNvdW50cztcclxuICBjb25zdCBuZXdDb3VudCA9ICgoX21hcCRnZXQgPSBtYXAuZ2V0KHJldGFpbmFibGUpKSAhPT0gbnVsbCAmJiBfbWFwJGdldCAhPT0gdm9pZCAwID8gX21hcCRnZXQgOiAwKSArIGRlbHRhO1xyXG5cclxuICBpZiAobmV3Q291bnQgPT09IDApIHtcclxuICAgIHVwZGF0ZVJldGFpbkNvdW50VG9aZXJvKHN0b3JlLCByZXRhaW5hYmxlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgbWFwLnNldChyZXRhaW5hYmxlLCBuZXdDb3VudCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVSZXRhaW5Db3VudFRvWmVybyhzdG9yZSwgcmV0YWluYWJsZSkge1xyXG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgbWFwID0gc3RvcmUuZ2V0U3RhdGUoKS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzO1xyXG4gIG1hcC5kZWxldGUocmV0YWluYWJsZSk7XHJcbiAgc2NoZWR1bGVPclBlcmZvcm1Qb3NzaWJsZVJlbGVhc2VPZlJldGFpbmFibGUoc3RvcmUsIHJldGFpbmFibGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3coc3RvcmUpIHtcclxuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICByZWxlYXNlUmV0YWluYWJsZXNOb3dPbkN1cnJlbnRUcmVlKHN0b3JlLCBzdGF0ZS5yZXRlbnRpb24ucmV0YWluYWJsZXNUb0NoZWNrRm9yUmVsZWFzZSk7XHJcbiAgc3RhdGUucmV0ZW50aW9uLnJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2UuY2xlYXIoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0KHIpIHtcclxuICAvLyBUaGUgZGVmYXVsdCB3aWxsIGNoYW5nZSBmcm9tICdyZWNvaWxSb290JyB0byAnY29tcG9uZW50cycgaW4gdGhlIGZ1dHVyZS5cclxuICByZXR1cm4gciA9PT0gdW5kZWZpbmVkID8gJ3JlY29pbFJvb3QnIDogcjtcclxufVxyXG5cclxudmFyIFJlY29pbF9SZXRlbnRpb24gPSB7XHJcbiAgU1VTUEVOU0VfVElNRU9VVF9NUyxcclxuICB1cGRhdGVSZXRhaW5Db3VudCxcclxuICB1cGRhdGVSZXRhaW5Db3VudFRvWmVybyxcclxuICByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3csXHJcbiAgcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0XHJcbn07XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdG8gZXhwb3J0IGVzc3RpZW50aWFsIGZ1bmN0aW9ucyBmcm9tIHJlYWN0LWRvbVxyXG4gKiBmb3Igb3VyIHdlYiBidWlsZFxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuY29uc3Qge1xyXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzXHJcbn0gPSByZWFjdERvbTtcclxuXHJcbnZhciBSZWFjdEJhdGNoZWRVcGRhdGVzID0ge1xyXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzXHJcbn07XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdG8gZXhwb3J0IGVzc3RpZW50aWFsIGZ1bmN0aW9ucyBmcm9tIHJlYWN0LWRvbVxyXG4gKiBmb3Igb3VyIHdlYiBidWlsZFxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuLy8gQGZiLW9ubHk6IGNvbnN0IHt1bnN0YWJsZV9iYXRjaGVkVXBkYXRlc30gPSByZXF1aXJlKCdSZWFjdERPTUNvbWV0Jyk7XHJcbi8vIHByZXR0aWVyLWlnbm9yZVxyXG5jb25zdCB7XHJcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDFcclxufSA9IFJlYWN0QmF0Y2hlZFVwZGF0ZXM7IC8vIEBvc3Mtb25seVxyXG5cclxuXHJcbnZhciBSZWNvaWxfUmVhY3RCYXRjaGVkVXBkYXRlcyA9IHtcclxuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMkMVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuY29uc3Qge1xyXG4gIGJhdGNoU3RhcnQ6IGJhdGNoU3RhcnQkMVxyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xyXG5cclxuY29uc3Qge1xyXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQyXHJcbn0gPSBSZWNvaWxfUmVhY3RCYXRjaGVkVXBkYXRlcztcclxuXHJcbmxldCBiYXRjaGVyID0gdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMkMjsgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBwcm92aWRlZCBiYXRjaGVyIGZ1bmN0aW9uIGFzIHRoZSBiYXRjaGVyIGZ1bmN0aW9uIHVzZWQgYnkgUmVjb2lsLlxyXG4gKlxyXG4gKiBTZXQgdGhlIGJhdGNoZXIgdG8gYSBjdXN0b20gYmF0Y2hlciBmb3IgeW91ciByZW5kZXJlcixcclxuICogaWYgeW91IHVzZSBhIHJlbmRlcmVyIG90aGVyIHRoYW4gUmVhY3QgRE9NIG9yIFJlYWN0IE5hdGl2ZS5cclxuICovXHJcbmNvbnN0IHNldEJhdGNoZXIgPSBuZXdCYXRjaGVyID0+IHtcclxuICBiYXRjaGVyID0gbmV3QmF0Y2hlcjtcclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgYmF0Y2hlciBmdW5jdGlvbi5cclxuICovXHJcblxyXG5cclxuY29uc3QgZ2V0QmF0Y2hlciA9ICgpID0+IGJhdGNoZXI7XHJcbi8qKlxyXG4gKiBDYWxscyB0aGUgY3VycmVudCBiYXRjaGVyIGZ1bmN0aW9uIGFuZCBwYXNzZXMgdGhlXHJcbiAqIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcblxyXG5jb25zdCBiYXRjaFVwZGF0ZXMgPSBjYWxsYmFjayA9PiB7XHJcbiAgYmF0Y2hlcigoKSA9PiB7XHJcbiAgICBsZXQgYmF0Y2hFbmQgPSAoKSA9PiB1bmRlZmluZWQ7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgYmF0Y2hFbmQgPSBiYXRjaFN0YXJ0JDEoKTtcclxuICAgICAgY2FsbGJhY2soKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIGJhdGNoRW5kKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn07XHJcblxyXG52YXIgUmVjb2lsX0JhdGNoaW5nID0ge1xyXG4gIGdldEJhdGNoZXIsXHJcbiAgc2V0QmF0Y2hlcixcclxuICBiYXRjaFVwZGF0ZXNcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcbi8qKlxyXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBJdGVyYWJsZXMgaW50byBhIHNpbmdsZSBJdGVyYWJsZS5cclxuICogVHJhdmVyc2VzIHRoZSBpbnB1dCBJdGVyYWJsZXMgaW4gdGhlIG9yZGVyIHByb3ZpZGVkIGFuZCBtYWludGFpbnMgdGhlIG9yZGVyXHJcbiAqIG9mIHRoZWlyIGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKiBgYGBcclxuICogY29uc3QgciA9IEFycmF5LmZyb20oY29uY2F0SXRlcmFibGVzKFsnYScsICdiJ10sIFsnYyddLCBbJ2QnLCAnZScsICdmJ10pKTtcclxuICogciA9PSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJ107XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uKiBjb25jYXRJdGVyYWJsZXMoaXRlcnMpIHtcclxuICBmb3IgKGNvbnN0IGl0ZXIgb2YgaXRlcnMpIHtcclxuICAgIGZvciAoY29uc3QgdmFsIG9mIGl0ZXIpIHtcclxuICAgICAgeWllbGQgdmFsO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIFJlY29pbF9jb25jYXRJdGVyYWJsZXMgPSBjb25jYXRJdGVyYWJsZXM7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvdHlwZW9mLXVuZGVmaW5lZCAqL1xyXG5cclxuY29uc3QgaXNTU1IgPSAvLyAkRmxvd0ZpeE1lKHNpdGU9cmVjb2lsKSBXaW5kb3cgZG9lcyBub3QgaGF2ZSBhIEZsb3dUeXBlIGRlZmluaXRpb24gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzY3MDlcclxudHlwZW9mIFdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XHJcbi8qIGVzbGludC1lbmFibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cclxuXHJcbmNvbnN0IGlzV2luZG93ID0gdmFsdWUgPT4gIWlzU1NSICYmICggLy8gJEZsb3dGaXhNZShzaXRlPXJlY29pbCkgV2luZG93IGRvZXMgbm90IGhhdmUgYSBGbG93VHlwZSBkZWZpbml0aW9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy82NzA5XHJcbnZhbHVlID09PSB3aW5kb3cgfHwgdmFsdWUgaW5zdGFuY2VvZiBXaW5kb3cpO1xyXG5cclxuY29uc3QgaXNSZWFjdE5hdGl2ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkXHJcblxyXG52YXIgUmVjb2lsX0Vudmlyb25tZW50ID0ge1xyXG4gIGlzU1NSLFxyXG4gIGlzUmVhY3ROYXRpdmUsXHJcbiAgaXNXaW5kb3dcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcbi8qKlxyXG4gKiBDYWNoZXMgYSBmdW5jdGlvbidzIHJlc3VsdHMgYmFzZWQgb24gdGhlIGtleSByZXR1cm5lZCBieSB0aGUgcGFzc2VkXHJcbiAqIGhhc2hGdW5jdGlvbi5cclxuICovXHJcblxyXG5mdW5jdGlvbiBtZW1vaXplV2l0aEFyZ3NIYXNoKGZuLCBoYXNoRnVuY3Rpb24pIHtcclxuICBsZXQgY2FjaGU7XHJcblxyXG4gIGNvbnN0IG1lbW9pemVkRm4gPSAoLi4uYXJncykgPT4ge1xyXG4gICAgaWYgKCFjYWNoZSkge1xyXG4gICAgICBjYWNoZSA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGtleSA9IGhhc2hGdW5jdGlvbiguLi5hcmdzKTtcclxuXHJcbiAgICBpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBrZXkpKSB7XHJcbiAgICAgIGNhY2hlW2tleV0gPSBmbiguLi5hcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2FjaGVba2V5XTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gbWVtb2l6ZWRGbjtcclxufVxyXG4vKipcclxuICogQ2FjaGVzIGEgZnVuY3Rpb24ncyByZXN1bHRzIGJhc2VkIG9uIGEgY29tcGFyaXNvbiBvZiB0aGUgYXJndW1lbnRzLlxyXG4gKiBPbmx5IGNhY2hlcyB0aGUgbGFzdCByZXR1cm4gb2YgdGhlIGZ1bmN0aW9uLlxyXG4gKiBEZWZhdWx0cyB0byByZWZlcmVuY2UgZXF1YWxpdHlcclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaChmbiwgaGFzaEZ1bmN0aW9uKSB7XHJcbiAgbGV0IGxhc3RLZXk7XHJcbiAgbGV0IGxhc3RSZXN1bHQ7IC8vIGJyZWFraW5nIGNhY2hlIHdoZW4gYXJndW1lbnRzIGNoYW5nZVxyXG5cclxuICBjb25zdCBtZW1vaXplZEZuID0gKC4uLmFyZ3MpID0+IHtcclxuICAgIGNvbnN0IGtleSA9IGhhc2hGdW5jdGlvbiguLi5hcmdzKTtcclxuXHJcbiAgICBpZiAobGFzdEtleSA9PT0ga2V5KSB7XHJcbiAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGxhc3RLZXkgPSBrZXk7XHJcbiAgICBsYXN0UmVzdWx0ID0gZm4oLi4uYXJncyk7XHJcbiAgICByZXR1cm4gbGFzdFJlc3VsdDtcclxuICB9O1xyXG5cclxuICByZXR1cm4gbWVtb2l6ZWRGbjtcclxufVxyXG4vKipcclxuICogQ2FjaGVzIGEgZnVuY3Rpb24ncyByZXN1bHRzIGJhc2VkIG9uIGEgY29tcGFyaXNvbiBvZiB0aGUgYXJndW1lbnRzLlxyXG4gKiBPbmx5IGNhY2hlcyB0aGUgbGFzdCByZXR1cm4gb2YgdGhlIGZ1bmN0aW9uLlxyXG4gKiBEZWZhdWx0cyB0byByZWZlcmVuY2UgZXF1YWxpdHlcclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaEFuZEludmFsaWRhdGlvbihmbiwgaGFzaEZ1bmN0aW9uKSB7XHJcbiAgbGV0IGxhc3RLZXk7XHJcbiAgbGV0IGxhc3RSZXN1bHQ7IC8vIGJyZWFraW5nIGNhY2hlIHdoZW4gYXJndW1lbnRzIGNoYW5nZVxyXG5cclxuICBjb25zdCBtZW1vaXplZEZuID0gKC4uLmFyZ3MpID0+IHtcclxuICAgIGNvbnN0IGtleSA9IGhhc2hGdW5jdGlvbiguLi5hcmdzKTtcclxuXHJcbiAgICBpZiAobGFzdEtleSA9PT0ga2V5KSB7XHJcbiAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGxhc3RLZXkgPSBrZXk7XHJcbiAgICBsYXN0UmVzdWx0ID0gZm4oLi4uYXJncyk7XHJcbiAgICByZXR1cm4gbGFzdFJlc3VsdDtcclxuICB9O1xyXG5cclxuICBjb25zdCBpbnZhbGlkYXRlID0gKCkgPT4ge1xyXG4gICAgbGFzdEtleSA9IG51bGw7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFttZW1vaXplZEZuLCBpbnZhbGlkYXRlXTtcclxufVxyXG5cclxudmFyIFJlY29pbF9NZW1vaXplID0ge1xyXG4gIG1lbW9pemVXaXRoQXJnc0hhc2gsXHJcbiAgbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaCxcclxuICBtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uXHJcbn07XHJcblxyXG5jb25zdCB7XHJcbiAgYmF0Y2hVcGRhdGVzOiBiYXRjaFVwZGF0ZXMkMVxyXG59ID0gUmVjb2lsX0JhdGNoaW5nO1xyXG5cclxuY29uc3Qge1xyXG4gIGluaXRpYWxpemVOb2RlOiBpbml0aWFsaXplTm9kZSQxLFxyXG4gIHBlZWtOb2RlSW5mbzogcGVla05vZGVJbmZvJDFcclxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcclxuXHJcbmNvbnN0IHtcclxuICBncmFwaDogZ3JhcGgkMVxyXG59ID0gUmVjb2lsX0dyYXBoO1xyXG5cclxuY29uc3Qge1xyXG4gIGdldE5leHRTdG9yZUlEOiBnZXROZXh0U3RvcmVJRCQxXHJcbn0gPSBSZWNvaWxfS2V5cztcclxuXHJcbmNvbnN0IHtcclxuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDEsXHJcbiAgcmVjb2lsVmFsdWVzOiByZWNvaWxWYWx1ZXMkMSxcclxuICByZWNvaWxWYWx1ZXNGb3JLZXlzOiByZWNvaWxWYWx1ZXNGb3JLZXlzJDJcclxufSA9IFJlY29pbF9Ob2RlO1xyXG5cclxuY29uc3Qge1xyXG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkMixcclxuICBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGU6IGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQxLFxyXG4gIHNldFJlY29pbFZhbHVlOiBzZXRSZWNvaWxWYWx1ZSQxLFxyXG4gIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWU6IHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMVxyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xyXG5cclxuY29uc3Qge1xyXG4gIHVwZGF0ZVJldGFpbkNvdW50OiB1cGRhdGVSZXRhaW5Db3VudCQxXHJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xyXG5cclxuY29uc3Qge1xyXG4gIHNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90OiBzZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQxXHJcbn0gPSBSZWNvaWxfU25hcHNob3RDYWNoZTtcclxuXHJcbmNvbnN0IHtcclxuICBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbjogZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMixcclxuICBtYWtlRW1wdHlTdG9yZVN0YXRlOiBtYWtlRW1wdHlTdG9yZVN0YXRlJDFcclxufSA9IFJlY29pbF9TdGF0ZTtcclxuXHJcblxyXG5cclxuY29uc3Qge1xyXG4gIGlzU1NSOiBpc1NTUiQxXHJcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IHtcclxuICBtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uOiBtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uJDFcclxufSA9IFJlY29pbF9NZW1vaXplO1xyXG5cclxuXHJcblxyXG4gLy8gT3BhcXVlIGF0IHRoaXMgc3VyZmFjZSBiZWNhdXNlIGl0J3MgcGFydCBvZiB0aGUgcHVibGljIEFQSSBmcm9tIGhlcmUuXHJcblxyXG5cclxuY29uc3QgcmV0YWluV2FybmluZyA9IGBcclxuUmVjb2lsIFNuYXBzaG90cyBvbmx5IGxhc3QgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgY2FsbGJhY2sgdGhleSBhcmUgcHJvdmlkZWQgdG8uIFRvIGtlZXAgYSBTbmFwc2hvdCBsb25nZXIsIGRvIHRoaXM6XHJcblxyXG4gIGNvbnN0IHJlbGVhc2UgPSBzbmFwc2hvdC5yZXRhaW4oKTtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgZG9Tb21ldGhpbmdXaXRoU25hcHNob3Qoc25hcHNob3QpO1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICByZWxlYXNlKCk7XHJcbiAgfVxyXG5cclxuVGhpcyBpcyBjdXJyZW50bHkgYSBERVYtb25seSB3YXJuaW5nIGJ1dCB3aWxsIGJlY29tZSBhIHRocm93biBleGNlcHRpb24gaW4gdGhlIG5leHQgcmVsZWFzZSBvZiBSZWNvaWwuXHJcbmA7IC8vIEEgXCJTbmFwc2hvdFwiIGlzIFwicmVhZC1vbmx5XCIgYW5kIGNhcHR1cmVzIGEgc3BlY2lmaWMgc2V0IG9mIHZhbHVlcyBvZiBhdG9tcy5cclxuLy8gSG93ZXZlciwgdGhlIGRhdGEtZmxvdy1ncmFwaCBhbmQgc2VsZWN0b3IgdmFsdWVzIG1heSBldm9sdmUgYXMgc2VsZWN0b3JcclxuLy8gZXZhbHVhdGlvbiBmdW5jdGlvbnMgYXJlIGV4ZWN1dGVkIGFuZCBhc3luYyBzZWxlY3RvcnMgcmVzb2x2ZS5cclxuXHJcbmNsYXNzIFNuYXBzaG90IHtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L25vLXVuaW5pdGlhbGl6ZWQtcHJvcGVydGllc1xyXG4gIGNvbnN0cnVjdG9yKHN0b3JlU3RhdGUsIHBhcmVudFN0b3JlSUQpIHtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdG9yZVwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yZWZDb3VudFwiLCAxKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRMb2FkYWJsZVwiLCByZWNvaWxWYWx1ZSA9PiB7XHJcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xyXG4gICAgICByZXR1cm4gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDEodGhpcy5fc3RvcmUsIHJlY29pbFZhbHVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFByb21pc2VcIiwgcmVjb2lsVmFsdWUgPT4ge1xyXG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9hZGFibGUocmVjb2lsVmFsdWUpLnRvUHJvbWlzZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0Tm9kZXNfVU5TVEFCTEVcIiwgb3B0ID0+IHtcclxuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7IC8vIFRPRE8gRGVhbCB3aXRoIG1vZGlmaWVkIHNlbGVjdG9yc1xyXG5cclxuICAgICAgaWYgKChvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuaXNNb2RpZmllZCkgPT09IHRydWUpIHtcclxuICAgICAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5pc0luaXRpYWxpemVkKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlY29pbFZhbHVlc0ZvcktleXMkMihzdGF0ZS5kaXJ0eUF0b21zKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qga25vd25BdG9tcyA9IHRoaXMuX3N0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcztcclxuXHJcbiAgICAgIGNvbnN0IGtub3duU2VsZWN0b3JzID0gdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5rbm93blNlbGVjdG9ycztcclxuXHJcbiAgICAgIHJldHVybiAob3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LmlzSW5pdGlhbGl6ZWQpID09IG51bGwgPyByZWNvaWxWYWx1ZXMkMS52YWx1ZXMoKSA6IG9wdC5pc0luaXRpYWxpemVkID09PSB0cnVlID8gcmVjb2lsVmFsdWVzRm9yS2V5cyQyKFJlY29pbF9jb25jYXRJdGVyYWJsZXMoW2tub3duQXRvbXMsIGtub3duU2VsZWN0b3JzXSkpIDogUmVjb2lsX2ZpbHRlckl0ZXJhYmxlKHJlY29pbFZhbHVlcyQxLnZhbHVlcygpLCAoe1xyXG4gICAgICAgIGtleVxyXG4gICAgICB9KSA9PiAha25vd25BdG9tcy5oYXMoa2V5KSAmJiAha25vd25TZWxlY3RvcnMuaGFzKGtleSkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0SW5mb19VTlNUQUJMRVwiLCAoe1xyXG4gICAgICBrZXlcclxuICAgIH0pID0+IHtcclxuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XHJcbiAgICAgIHJldHVybiBwZWVrTm9kZUluZm8kMSh0aGlzLl9zdG9yZSwgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSwga2V5KTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1hcFwiLCBtYXBwZXIgPT4ge1xyXG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcclxuICAgICAgY29uc3QgbXV0YWJsZVNuYXBzaG90ID0gbmV3IE11dGFibGVTbmFwc2hvdCh0aGlzLCBiYXRjaFVwZGF0ZXMkMSk7XHJcbiAgICAgIG1hcHBlcihtdXRhYmxlU25hcHNob3QpOyAvLyBpZiByZW1vdmluZyBiYXRjaFVwZGF0ZXMgZnJvbSBgc2V0YCBhZGQgaXQgaGVyZVxyXG5cclxuICAgICAgcmV0dXJuIG11dGFibGVTbmFwc2hvdDtcclxuICAgIH0pO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFzeW5jTWFwXCIsIGFzeW5jIG1hcHBlciA9PiB7XHJcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xyXG4gICAgICBjb25zdCBtdXRhYmxlU25hcHNob3QgPSBuZXcgTXV0YWJsZVNuYXBzaG90KHRoaXMsIGJhdGNoVXBkYXRlcyQxKTtcclxuICAgICAgbXV0YWJsZVNuYXBzaG90LnJldGFpbigpOyAvLyBSZXRhaW4gbmV3IHNuYXBzaG90IGR1cmluZyBhc3luYyBtYXBwZXJcclxuXHJcbiAgICAgIGF3YWl0IG1hcHBlcihtdXRhYmxlU25hcHNob3QpOyAvLyBDb250aW51ZSB0byByZXRhaW4gdGhlIG5ldyBzbmFwc2hvdCBmb3IgdGhlIHVzZXIsIGJ1dCBhdXRvLXJlbGVhc2UgaXRcclxuICAgICAgLy8gYWZ0ZXIgdGhlIG5leHQgdGljaywgdGhlIHNhbWUgYXMgYSBuZXcgc3luY2hyb25vdXMgc25hcHNob3QuXHJcblxyXG4gICAgICBtdXRhYmxlU25hcHNob3QuYXV0b1JlbGVhc2VfSU5URVJOQUwoKTtcclxuICAgICAgcmV0dXJuIG11dGFibGVTbmFwc2hvdDtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX3N0b3JlID0ge1xyXG4gICAgICBzdG9yZUlEOiBnZXROZXh0U3RvcmVJRCQxKCksXHJcbiAgICAgIHBhcmVudFN0b3JlSUQsXHJcbiAgICAgIGdldFN0YXRlOiAoKSA9PiBzdG9yZVN0YXRlLFxyXG4gICAgICByZXBsYWNlU3RhdGU6IHJlcGxhY2VyID0+IHtcclxuICAgICAgICAvLyBubyBiYXRjaGluZywgc28gbmV4dFRyZWUgaXMgbmV2ZXIgYWN0aXZlXHJcbiAgICAgICAgc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA9IHJlcGxhY2VyKHN0b3JlU3RhdGUuY3VycmVudFRyZWUpO1xyXG4gICAgICB9LFxyXG4gICAgICBnZXRHcmFwaDogdmVyc2lvbiA9PiB7XHJcbiAgICAgICAgY29uc3QgZ3JhcGhzID0gc3RvcmVTdGF0ZS5ncmFwaHNCeVZlcnNpb247XHJcblxyXG4gICAgICAgIGlmIChncmFwaHMuaGFzKHZlcnNpb24pKSB7XHJcbiAgICAgICAgICByZXR1cm4gUmVjb2lsX251bGx0aHJvd3MoZ3JhcGhzLmdldCh2ZXJzaW9uKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBuZXdHcmFwaCA9IGdyYXBoJDEoKTtcclxuICAgICAgICBncmFwaHMuc2V0KHZlcnNpb24sIG5ld0dyYXBoKTtcclxuICAgICAgICByZXR1cm4gbmV3R3JhcGg7XHJcbiAgICAgIH0sXHJcbiAgICAgIHN1YnNjcmliZVRvVHJhbnNhY3Rpb25zOiAoKSA9PiAoe1xyXG4gICAgICAgIHJlbGVhc2U6ICgpID0+IHt9XHJcbiAgICAgIH0pLFxyXG4gICAgICBhZGRUcmFuc2FjdGlvbk1ldGFkYXRhOiAoKSA9PiB7XHJcbiAgICAgICAgdGhyb3cgUmVjb2lsX2VycignQ2Fubm90IHN1YnNjcmliZSB0byBTbmFwc2hvdHMnKTtcclxuICAgICAgfVxyXG4gICAgfTsgLy8gSW5pdGlhbGl6ZSBhbnkgbm9kZXMgdGhhdCBhcmUgbGl2ZSBpbiB0aGUgcGFyZW50IHN0b3JlIChwcmltYXJpbHkgc28gdGhhdFxyXG4gICAgLy8gdGhpcyBzbmFwc2hvdCBnZXRzIGNvdW50ZWQgdG93YXJkcyB0aGUgbm9kZSdzIGxpdmUgc3RvcmVzIGNvdW50KS5cclxuICAgIC8vIFRPRE8gT3B0aW1pemUgdGhpcyB3aGVuIGNsb25pbmcgc25hcHNob3RzIGZvciBjYWxsYmFja3NcclxuXHJcbiAgICBmb3IgKGNvbnN0IG5vZGVLZXkgb2YgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5rbm93bkF0b21zKSB7XHJcbiAgICAgIGluaXRpYWxpemVOb2RlJDEodGhpcy5fc3RvcmUsIG5vZGVLZXksICdnZXQnKTtcclxuICAgICAgdXBkYXRlUmV0YWluQ291bnQkMSh0aGlzLl9zdG9yZSwgbm9kZUtleSwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hdXRvUmVsZWFzZV9JTlRFUk5BTCgpO1xyXG4gIH1cclxuXHJcbiAgcmV0YWluKCkge1xyXG4gICAgaWYgKHRoaXMuX3JlZkNvdW50IDw9IDApIHtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIHRocm93IFJlY29pbF9lcnIoJ1NuYXBzaG90IGhhcyBhbHJlYWR5IGJlZW4gcmVsZWFzZWQuJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdBdHRlbXB0IHRvIHJldGFpbigpIFNuYXBzaG90IHRoYXQgd2FzIGFscmVhZHkgcmVsZWFzZWQuJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9yZWZDb3VudCsrO1xyXG4gICAgbGV0IHJlbGVhc2VkID0gZmFsc2U7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBpZiAoIXJlbGVhc2VkKSB7XHJcbiAgICAgICAgcmVsZWFzZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLl9yZWxlYXNlKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlbGVhc2UgdGhlIHNuYXBzaG90IG9uIHRoZSBuZXh0IHRpY2suICBUaGlzIG1lYW5zIHRoZSBzbmFwc2hvdCBpcyByZXRhaW5lZFxyXG4gICAqIGR1cmluZyB0aGUgZXhlY3V0aW9uIG9mIHRoZSBjdXJyZW50IGZ1bmN0aW9uIHVzaW5nIGl0LlxyXG4gICAqL1xyXG5cclxuXHJcbiAgYXV0b1JlbGVhc2VfSU5URVJOQUwoKSB7XHJcbiAgICBpZiAoIWlzU1NSJDEpIHtcclxuICAgICAgLy8gVXNlIHRpbWVvdXQgb2YgMTAgdG8gd29ya2Fyb3VuZCBGaXJlZm94IGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tleHBlcmltZW50YWwvUmVjb2lsL2lzc3Vlcy8xOTM2XHJcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuX3JlbGVhc2UoKSwgMTApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3JlbGVhc2UoKSB7XHJcbiAgICB0aGlzLl9yZWZDb3VudC0tO1xyXG5cclxuICAgIGlmICh0aGlzLl9yZWZDb3VudCA9PT0gMCkge1xyXG4gICAgICB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLm5vZGVDbGVhbnVwRnVuY3Rpb25zLmZvckVhY2goY2xlYW51cCA9PiBjbGVhbnVwKCkpO1xyXG5cclxuICAgICAgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5jbGVhcigpO1xyXG5cclxuICAgICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9IC8vIFRlbXBvcmFyaWx5IG5lcmZpbmcgdGhpcyB0byBhbGxvdyB1cyB0byBmaW5kIGJyb2tlbiBjYWxsIHNpdGVzIHdpdGhvdXRcclxuICAgICAgLy8gYWN0dWFsbHkgYnJlYWtpbmcgYW55Ym9keSB5ZXQuXHJcbiAgICAgIC8vIGZvciAoY29uc3QgayBvZiB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMpIHtcclxuICAgICAgLy8gICB1cGRhdGVSZXRhaW5Db3VudFRvWmVybyh0aGlzLl9zdG9yZSwgayk7XHJcbiAgICAgIC8vIH1cclxuXHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3JlZkNvdW50IDwgMCkge1xyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdTbmFwc2hvdCByZWxlYXNlZCBhbiBleHRyYSB0aW1lLicpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpc1JldGFpbmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3JlZkNvdW50ID4gMDtcclxuICB9XHJcblxyXG4gIGNoZWNrUmVmQ291bnRfSU5URVJOQUwoKSB7XHJcbiAgICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSAmJiB0aGlzLl9yZWZDb3VudCA8PSAwKSB7XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24ocmV0YWluV2FybmluZyk7XHJcbiAgICAgIH0gLy8gV2hhdCB3ZSB3aWxsIHNoaXAgbGF0ZXI6XHJcbiAgICAgIC8vIHRocm93IGVycihyZXRhaW5XYXJuaW5nKTtcclxuXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRTdG9yZV9JTlRFUk5BTCgpIHtcclxuICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlO1xyXG4gIH1cclxuXHJcbiAgZ2V0SUQoKSB7XHJcbiAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcclxuICAgIHJldHVybiB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLnN0YXRlSUQ7XHJcbiAgfVxyXG5cclxuICBnZXRTdG9yZUlEKCkge1xyXG4gICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RvcmUuc3RvcmVJRDtcclxuICB9IC8vIFdlIHdhbnQgdG8gYWxsb3cgdGhlIG1ldGhvZHMgdG8gYmUgZGVzdHJ1Y3R1cmVkIGFuZCB1c2VkIGFzIGFjY2Vzc29yc1xyXG5cclxuICAvKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvZXh0cmEtYXJyb3ctaW5pdGlhbGl6ZXIgKi9cclxuXHJcbiAgLyogZXNsaW50LWVuYWJsZSBmYi13d3cvZXh0cmEtYXJyb3ctaW5pdGlhbGl6ZXIgKi9cclxuXHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBjbG9uZVN0b3JlU3RhdGUoc3RvcmUsIHRyZWVTdGF0ZSwgYnVtcFZlcnNpb24gPSBmYWxzZSkge1xyXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG4gIGNvbnN0IHZlcnNpb24gPSBidW1wVmVyc2lvbiA/IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDIoKSA6IHRyZWVTdGF0ZS52ZXJzaW9uO1xyXG4gIHJldHVybiB7XHJcbiAgICAvLyBBbHdheXMgY2xvbmUgdGhlIFRyZWVTdGF0ZSB0byBpc29sYXRlIHN0b3JlcyBmcm9tIGFjY2lkZW50YWwgbXV0YXRpb25zLlxyXG4gICAgLy8gRm9yIGV4YW1wbGUsIHJlYWRpbmcgYSBzZWxlY3RvciBmcm9tIGEgY2xvbmVkIHNuYXBzaG90IHNob3VsZG4ndCBjYWNoZVxyXG4gICAgLy8gaW4gdGhlIG9yaWdpbmFsIHRyZWVzdGF0ZSB3aGljaCBtYXkgY2F1c2UgdGhlIG9yaWdpbmFsIHRvIHNraXBcclxuICAgIC8vIGluaXRpYWxpemF0aW9uIG9mIHVwc3RyZWFtIGF0b21zLlxyXG4gICAgY3VycmVudFRyZWU6IHtcclxuICAgICAgLy8gVE9ETyBzbmFwc2hvdHMgc2hvdWxkbid0IHJlYWxseSBoYXZlIHZlcnNpb25zIGJlY2F1c2UgYSBuZXcgdmVyc2lvbiBudW1iZXJcclxuICAgICAgLy8gaXMgYWx3YXlzIGFzc2lnbmVkIHdoZW4gdGhlIHNuYXBzaG90IGlzIGdvbmUgdG8uXHJcbiAgICAgIHZlcnNpb246IGJ1bXBWZXJzaW9uID8gdmVyc2lvbiA6IHRyZWVTdGF0ZS52ZXJzaW9uLFxyXG4gICAgICBzdGF0ZUlEOiBidW1wVmVyc2lvbiA/IHZlcnNpb24gOiB0cmVlU3RhdGUuc3RhdGVJRCxcclxuICAgICAgdHJhbnNhY3Rpb25NZXRhZGF0YTogeyAuLi50cmVlU3RhdGUudHJhbnNhY3Rpb25NZXRhZGF0YVxyXG4gICAgICB9LFxyXG4gICAgICBkaXJ0eUF0b21zOiBuZXcgU2V0KHRyZWVTdGF0ZS5kaXJ0eUF0b21zKSxcclxuICAgICAgYXRvbVZhbHVlczogdHJlZVN0YXRlLmF0b21WYWx1ZXMuY2xvbmUoKSxcclxuICAgICAgbm9udmFsaWRhdGVkQXRvbXM6IHRyZWVTdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5jbG9uZSgpXHJcbiAgICB9LFxyXG4gICAgY29tbWl0RGVwdGg6IDAsXHJcbiAgICBuZXh0VHJlZTogbnVsbCxcclxuICAgIHByZXZpb3VzVHJlZTogbnVsbCxcclxuICAgIGtub3duQXRvbXM6IG5ldyBTZXQoc3RvcmVTdGF0ZS5rbm93bkF0b21zKSxcclxuICAgIC8vIEZJWE1FIGhlcmUncyBhIGNvcHlcclxuICAgIGtub3duU2VsZWN0b3JzOiBuZXcgU2V0KHN0b3JlU3RhdGUua25vd25TZWxlY3RvcnMpLFxyXG4gICAgLy8gRklYTUUgaGVyZSdzIGEgY29weVxyXG4gICAgdHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXHJcbiAgICBub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXHJcbiAgICBub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXHJcbiAgICBxdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRDogW10sXHJcbiAgICBzdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnM6IG5ldyBTZXQoKSxcclxuICAgIGdyYXBoc0J5VmVyc2lvbjogbmV3IE1hcCgpLnNldCh2ZXJzaW9uLCBzdG9yZS5nZXRHcmFwaCh0cmVlU3RhdGUudmVyc2lvbikpLFxyXG4gICAgcmV0ZW50aW9uOiB7XHJcbiAgICAgIHJlZmVyZW5jZUNvdW50czogbmV3IE1hcCgpLFxyXG4gICAgICBub2Rlc1JldGFpbmVkQnlab25lOiBuZXcgTWFwKCksXHJcbiAgICAgIHJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2U6IG5ldyBTZXQoKVxyXG4gICAgfSxcclxuICAgIC8vIEZJWE1FIGhlcmUncyBhIGNvcHlcclxuICAgIC8vIENyZWF0ZSBibGFuayBjbGVhbnVwIGhhbmRsZXJzIGZvciBhdG9tcyBzbyBzbmFwc2hvdHMgZG9uJ3QgcmUtcnVuXHJcbiAgICAvLyBhdG9tIGVmZmVjdHMuXHJcbiAgICBub2RlQ2xlYW51cEZ1bmN0aW9uczogbmV3IE1hcChSZWNvaWxfbWFwSXRlcmFibGUoc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5lbnRyaWVzKCksIChba2V5XSkgPT4gW2tleSwgKCkgPT4ge31dKSlcclxuICB9O1xyXG59IC8vIEZhY3RvcnkgdG8gYnVpbGQgYSBmcmVzaCBzbmFwc2hvdFxyXG5cclxuXHJcbmZ1bmN0aW9uIGZyZXNoU25hcHNob3QoaW5pdGlhbGl6ZVN0YXRlKSB7XHJcbiAgY29uc3Qgc25hcHNob3QgPSBuZXcgU25hcHNob3QobWFrZUVtcHR5U3RvcmVTdGF0ZSQxKCkpO1xyXG4gIHJldHVybiBpbml0aWFsaXplU3RhdGUgIT0gbnVsbCA/IHNuYXBzaG90Lm1hcChpbml0aWFsaXplU3RhdGUpIDogc25hcHNob3Q7XHJcbn0gLy8gRmFjdG9yeSB0byBjbG9uZSBhIHNuYXBzaG90IHN0YXRlXHJcblxyXG5cclxuY29uc3QgW21lbW9pemVkQ2xvbmVTbmFwc2hvdCwgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMl0gPSBtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uJDEoKHN0b3JlLCB2ZXJzaW9uKSA9PiB7XHJcbiAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlO1xyXG5cclxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICBjb25zdCB0cmVlU3RhdGUgPSB2ZXJzaW9uID09PSAnbGF0ZXN0JyA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBSZWNvaWxfbnVsbHRocm93cyhzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSk7XHJcbiAgcmV0dXJuIG5ldyBTbmFwc2hvdChjbG9uZVN0b3JlU3RhdGUoc3RvcmUsIHRyZWVTdGF0ZSksIHN0b3JlLnN0b3JlSUQpO1xyXG59LCAoc3RvcmUsIHZlcnNpb24pID0+IHtcclxuICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRULCBfc3RvcmUkZ2V0U3RhdGUkcHJldmk7XHJcblxyXG4gIHJldHVybiBTdHJpbmcodmVyc2lvbikgKyBTdHJpbmcoc3RvcmUuc3RvcmVJRCkgKyBTdHJpbmcoKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA9IHN0b3JlLmdldFN0YXRlKCkubmV4dFRyZWUpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlJGdldFN0YXRlJG5leHRULnZlcnNpb24pICsgU3RyaW5nKHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUudmVyc2lvbikgKyBTdHJpbmcoKF9zdG9yZSRnZXRTdGF0ZSRwcmV2aSA9IHN0b3JlLmdldFN0YXRlKCkucHJldmlvdXNUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUkcHJldmkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZSRnZXRTdGF0ZSRwcmV2aS52ZXJzaW9uKTtcclxufSk7IC8vIEF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xyXG5cclxuc2V0SW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMShpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQyKTtcclxuXHJcbmZ1bmN0aW9uIGNsb25lU25hcHNob3Qoc3RvcmUsIHZlcnNpb24gPSAnbGF0ZXN0Jykge1xyXG4gIGNvbnN0IHNuYXBzaG90ID0gbWVtb2l6ZWRDbG9uZVNuYXBzaG90KHN0b3JlLCB2ZXJzaW9uKTtcclxuXHJcbiAgaWYgKCFzbmFwc2hvdC5pc1JldGFpbmVkKCkpIHtcclxuICAgIGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDIoKTtcclxuICAgIHJldHVybiBtZW1vaXplZENsb25lU25hcHNob3Qoc3RvcmUsIHZlcnNpb24pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNuYXBzaG90O1xyXG59XHJcblxyXG5jbGFzcyBNdXRhYmxlU25hcHNob3QgZXh0ZW5kcyBTbmFwc2hvdCB7XHJcbiAgY29uc3RydWN0b3Ioc25hcHNob3QsIGJhdGNoKSB7XHJcbiAgICBzdXBlcihjbG9uZVN0b3JlU3RhdGUoc25hcHNob3QuZ2V0U3RvcmVfSU5URVJOQUwoKSwgc25hcHNob3QuZ2V0U3RvcmVfSU5URVJOQUwoKS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLCB0cnVlKSwgc25hcHNob3QuZ2V0U3RvcmVJRCgpKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYmF0Y2hcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRcIiwgKHJlY29pbFN0YXRlLCBuZXdWYWx1ZU9yVXBkYXRlcikgPT4ge1xyXG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcclxuICAgICAgY29uc3Qgc3RvcmUgPSB0aGlzLmdldFN0b3JlX0lOVEVSTkFMKCk7IC8vIFRoaXMgYmF0Y2hVcGRhdGVzIGVuc3VyZXMgdGhpcyBgc2V0YCBpcyBhcHBsaWVkIGltbWVkaWF0ZWx5IGFuZCB5b3UgY2FuXHJcbiAgICAgIC8vIHJlYWQgdGhlIHdyaXR0ZW4gdmFsdWUgYWZ0ZXIgY2FsbGluZyBgc2V0YC4gSSB3b3VsZCBsaWtlIHRvIHJlbW92ZSB0aGlzXHJcbiAgICAgIC8vIGJlaGF2aW9yIGFuZCBvbmx5IGJhdGNoIGluIGBTbmFwc2hvdC5tYXBgLCBidXQgdGhpcyB3b3VsZCBiZSBhIGJyZWFraW5nXHJcbiAgICAgIC8vIGNoYW5nZSBwb3RlbnRpYWxseS5cclxuXHJcbiAgICAgIHRoaXMuX2JhdGNoKCgpID0+IHtcclxuICAgICAgICB1cGRhdGVSZXRhaW5Db3VudCQxKHN0b3JlLCByZWNvaWxTdGF0ZS5rZXksIDEpO1xyXG4gICAgICAgIHNldFJlY29pbFZhbHVlJDEodGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpLCByZWNvaWxTdGF0ZSwgbmV3VmFsdWVPclVwZGF0ZXIpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc2V0XCIsIHJlY29pbFN0YXRlID0+IHtcclxuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpOyAvLyBTZWUgbm90ZSBhdCBgc2V0YCBhYm91dCBiYXRjaGVkIHVwZGF0ZXMuXHJcblxyXG4gICAgICB0aGlzLl9iYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMShzdG9yZSwgcmVjb2lsU3RhdGUua2V5LCAxKTtcclxuICAgICAgICBzZXRSZWNvaWxWYWx1ZSQxKHRoaXMuZ2V0U3RvcmVfSU5URVJOQUwoKSwgcmVjb2lsU3RhdGUsIERFRkFVTFRfVkFMVUUkMSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzX0RFUFJFQ0FURURcIiwgdmFsdWVzID0+IHtcclxuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpOyAvLyBTZWUgbm90ZSBhdCBgc2V0YCBhYm91dCBiYXRjaGVkIHVwZGF0ZXMuXHJcblxyXG4gICAgICBiYXRjaFVwZGF0ZXMkMSgoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdmFsdWVzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMShzdG9yZSwgaywgMSk7XHJcbiAgICAgICAgICBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlJDEoc3RvcmUsIG5ldyBBYnN0cmFjdFJlY29pbFZhbHVlJDIoayksIHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9iYXRjaCA9IGJhdGNoO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbnZhciBSZWNvaWxfU25hcHNob3QgPSB7XHJcbiAgU25hcHNob3QsXHJcbiAgTXV0YWJsZVNuYXBzaG90LFxyXG4gIGZyZXNoU25hcHNob3QsXHJcbiAgY2xvbmVTbmFwc2hvdFxyXG59O1xyXG5cclxudmFyIFJlY29pbF9TbmFwc2hvdF8xID0gUmVjb2lsX1NuYXBzaG90LlNuYXBzaG90O1xyXG52YXIgUmVjb2lsX1NuYXBzaG90XzIgPSBSZWNvaWxfU25hcHNob3QuTXV0YWJsZVNuYXBzaG90O1xyXG52YXIgUmVjb2lsX1NuYXBzaG90XzMgPSBSZWNvaWxfU25hcHNob3QuZnJlc2hTbmFwc2hvdDtcclxudmFyIFJlY29pbF9TbmFwc2hvdF80ID0gUmVjb2lsX1NuYXBzaG90LmNsb25lU25hcHNob3Q7XHJcblxyXG52YXIgUmVjb2lsX1NuYXBzaG90JDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIFNuYXBzaG90OiBSZWNvaWxfU25hcHNob3RfMSxcclxuICBNdXRhYmxlU25hcHNob3Q6IFJlY29pbF9TbmFwc2hvdF8yLFxyXG4gIGZyZXNoU25hcHNob3Q6IFJlY29pbF9TbmFwc2hvdF8zLFxyXG4gIGNsb25lU25hcHNob3Q6IFJlY29pbF9TbmFwc2hvdF80XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHVuaW9uU2V0cyguLi5zZXRzKSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xyXG5cclxuICBmb3IgKGNvbnN0IHNldCBvZiBzZXRzKSB7XHJcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHNldCkge1xyXG4gICAgICByZXN1bHQuYWRkKHZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfdW5pb25TZXRzID0gdW5pb25TZXRzO1xyXG5cclxuY29uc3Qge1xyXG4gIHVzZVJlZlxyXG59ID0gcmVhY3Q7XHJcbi8qKlxyXG4gKiBUaGUgc2FtZSBhcyBgdXNlUmVmKClgIGV4Y2VwdCB0aGF0IGlmIGEgZnVuY3Rpb24gaXMgc3BlY2lmaWVkIHRoZW4gaXQgd2lsbFxyXG4gKiBjYWxsIHRoYXQgZnVuY3Rpb24gdG8gZ2V0IHRoZSB2YWx1ZSB0byBpbml0aWFsaXplIHRoZSByZWZlcmVuY2Ugd2l0aC5cclxuICogVGhpcyBpcyBzaW1pbGFyIHRvIGhvdyBgdXNlU3RhdGUoKWAgYmVoYXZlcyB3aGVuIGdpdmVuIGEgZnVuY3Rpb24uICBJdCBhbGxvd3NcclxuICogdGhlIHVzZXIgdG8gYXZvaWQgZ2VuZXJhdGluZyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3Igc3Vic2VxdWVudCByZW5kZXJzLlxyXG4gKiBUaGUgdHJhZGVvZmYgaXMgdGhhdCB0byBzZXQgdGhlIHJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIGl0c2VsZiB5b3UgbmVlZCB0b1xyXG4gKiBuZXN0IGl0OiB1c2VSZWZJbml0T25jZSgoKSA9PiAoKSA9PiB7Li4ufSk7XHJcbiAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIHVzZVJlZkluaXRPbmNlKGluaXRpYWxWYWx1ZSkge1xyXG4gIC8vICRGbG93RXhwZWN0ZWRFcnJvcltpbmNvbXBhdGlibGUtY2FsbF1cclxuICBjb25zdCByZWYgPSB1c2VSZWYoaW5pdGlhbFZhbHVlKTtcclxuXHJcbiAgaWYgKHJlZi5jdXJyZW50ID09PSBpbml0aWFsVmFsdWUgJiYgdHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yW2luY29tcGF0aWJsZS11c2VdXHJcbiAgICByZWYuY3VycmVudCA9IGluaXRpYWxWYWx1ZSgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlZjtcclxufVxyXG5cclxudmFyIFJlY29pbF91c2VSZWZJbml0T25jZSA9IHVzZVJlZkluaXRPbmNlO1xyXG5cclxuLy8gQGZiLW9ubHk6IGNvbnN0IFJlY29pbHVzYWdlbG9nRXZlbnQgPSByZXF1aXJlKCdSZWNvaWx1c2FnZWxvZ0V2ZW50Jyk7XHJcbi8vIEBmYi1vbmx5OiBjb25zdCBSZWNvaWxVc2FnZUxvZ0ZhbGNvRXZlbnQgPSByZXF1aXJlKCdSZWNvaWxVc2FnZUxvZ0ZhbGNvRXZlbnQnKTtcclxuLy8gQGZiLW9ubHk6IGNvbnN0IFVSSSA9IHJlcXVpcmUoJ1VSSScpO1xyXG5cclxuXHJcbmNvbnN0IHtcclxuICBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbjogZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMyxcclxuICBtYWtlRW1wdHlTdG9yZVN0YXRlOiBtYWtlRW1wdHlTdG9yZVN0YXRlJDJcclxufSA9IFJlY29pbF9TdGF0ZTtcclxuXHJcbmNvbnN0IHtcclxuICBjbGVhblVwTm9kZTogY2xlYW5VcE5vZGUkMixcclxuICBnZXREb3duc3RyZWFtTm9kZXM6IGdldERvd25zdHJlYW1Ob2RlcyQyLFxyXG4gIGluaXRpYWxpemVOb2RlOiBpbml0aWFsaXplTm9kZSQyLFxyXG4gIHNldE5vZGVWYWx1ZTogc2V0Tm9kZVZhbHVlJDIsXHJcbiAgc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRDogc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCQxXHJcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XHJcblxyXG5jb25zdCB7XHJcbiAgZ3JhcGg6IGdyYXBoJDJcclxufSA9IFJlY29pbF9HcmFwaDtcclxuXHJcbmNvbnN0IHtcclxuICBjbG9uZUdyYXBoOiBjbG9uZUdyYXBoJDFcclxufSA9IFJlY29pbF9HcmFwaDtcclxuXHJcbmNvbnN0IHtcclxuICBnZXROZXh0U3RvcmVJRDogZ2V0TmV4dFN0b3JlSUQkMlxyXG59ID0gUmVjb2lsX0tleXM7XHJcblxyXG5jb25zdCB7XHJcbiAgY3JlYXRlTXV0YWJsZVNvdXJjZTogY3JlYXRlTXV0YWJsZVNvdXJjZSQxLFxyXG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDJcclxufSA9IFJlY29pbF9SZWFjdE1vZGU7XHJcblxyXG5jb25zdCB7XHJcbiAgYXBwbHlBdG9tVmFsdWVXcml0ZXM6IGFwcGx5QXRvbVZhbHVlV3JpdGVzJDFcclxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcclxuXHJcbmNvbnN0IHtcclxuICByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3c6IHJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdyQxXHJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xyXG5cclxuY29uc3Qge1xyXG4gIGZyZXNoU25hcHNob3Q6IGZyZXNoU25hcHNob3QkMVxyXG59ID0gUmVjb2lsX1NuYXBzaG90JDE7XHJcblxyXG5cclxuXHJcbmNvbnN0IHtcclxuICB1c2VDYWxsYmFjayxcclxuICB1c2VDb250ZXh0LFxyXG4gIHVzZUVmZmVjdCxcclxuICB1c2VNZW1vLFxyXG4gIHVzZVJlZjogdXNlUmVmJDEsXHJcbiAgdXNlU3RhdGVcclxufSA9IHJlYWN0O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBub3RJbkFDb250ZXh0KCkge1xyXG4gIHRocm93IFJlY29pbF9lcnIoJ1RoaXMgY29tcG9uZW50IG11c3QgYmUgdXNlZCBpbnNpZGUgYSA8UmVjb2lsUm9vdD4gY29tcG9uZW50LicpO1xyXG59XHJcblxyXG5jb25zdCBkZWZhdWx0U3RvcmUgPSBPYmplY3QuZnJlZXplKHtcclxuICBzdG9yZUlEOiBnZXROZXh0U3RvcmVJRCQyKCksXHJcbiAgZ2V0U3RhdGU6IG5vdEluQUNvbnRleHQsXHJcbiAgcmVwbGFjZVN0YXRlOiBub3RJbkFDb250ZXh0LFxyXG4gIGdldEdyYXBoOiBub3RJbkFDb250ZXh0LFxyXG4gIHN1YnNjcmliZVRvVHJhbnNhY3Rpb25zOiBub3RJbkFDb250ZXh0LFxyXG4gIGFkZFRyYW5zYWN0aW9uTWV0YWRhdGE6IG5vdEluQUNvbnRleHRcclxufSk7XHJcbmxldCBzdGF0ZVJlcGxhY2VySXNCZWluZ0V4ZWN1dGVkID0gZmFsc2U7XHJcblxyXG5mdW5jdGlvbiBzdGFydE5leHRUcmVlSWZOZWVkZWQoc3RvcmUpIHtcclxuICBpZiAoc3RhdGVSZXBsYWNlcklzQmVpbmdFeGVjdXRlZCkge1xyXG4gICAgdGhyb3cgUmVjb2lsX2VycignQW4gYXRvbSB1cGRhdGUgd2FzIHRyaWdnZXJlZCB3aXRoaW4gdGhlIGV4ZWN1dGlvbiBvZiBhIHN0YXRlIHVwZGF0ZXIgZnVuY3Rpb24uIFN0YXRlIHVwZGF0ZXIgZnVuY3Rpb25zIHByb3ZpZGVkIHRvIFJlY29pbCBtdXN0IGJlIHB1cmUgZnVuY3Rpb25zLicpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gIGlmIChzdG9yZVN0YXRlLm5leHRUcmVlID09PSBudWxsKSB7XHJcbiAgICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSAmJiBSZWNvaWxfZ2t4KCdyZWNvaWxfcmVsZWFzZV9vbl9jYXNjYWRpbmdfdXBkYXRlX2tpbGxzd2l0Y2hfMjAyMScpKSB7XHJcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjYXNjYWRpbmcgdXBkYXRlICh0aGF0IGlzLCByZW5kZXJpbmcgZHVlIHRvIG9uZSBzdGF0ZSBjaGFuZ2VcclxuICAgICAgLy8gaW52b2tlcyBhIHNlY29uZCBzdGF0ZSBjaGFuZ2UpLCB3ZSB3b24ndCBoYXZlIGNsZWFuZWQgdXAgcmV0YWluYWJsZXMgeWV0XHJcbiAgICAgIC8vIGJlY2F1c2UgdGhpcyBub3JtYWxseSBoYXBwZW5zIGFmdGVyIG5vdGlmeWluZyBjb21wb25lbnRzLiBEbyBpdCBiZWZvcmVcclxuICAgICAgLy8gcHJvY2VlZGluZyB3aXRoIHRoZSBjYXNjYWRpbmcgdXBkYXRlIHNvIHRoYXQgaXQgcmVtYWlucyBwcmVkaWN0YWJsZTpcclxuICAgICAgaWYgKHN0b3JlU3RhdGUuY29tbWl0RGVwdGggPiAwKSB7XHJcbiAgICAgICAgcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93JDEoc3RvcmUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdmVyc2lvbiA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWUudmVyc2lvbjtcclxuICAgIGNvbnN0IG5leHRWZXJzaW9uID0gZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMygpO1xyXG4gICAgc3RvcmVTdGF0ZS5uZXh0VHJlZSA9IHsgLi4uc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSxcclxuICAgICAgdmVyc2lvbjogbmV4dFZlcnNpb24sXHJcbiAgICAgIHN0YXRlSUQ6IG5leHRWZXJzaW9uLFxyXG4gICAgICBkaXJ0eUF0b21zOiBuZXcgU2V0KCksXHJcbiAgICAgIHRyYW5zYWN0aW9uTWV0YWRhdGE6IHt9XHJcbiAgICB9O1xyXG4gICAgc3RvcmVTdGF0ZS5ncmFwaHNCeVZlcnNpb24uc2V0KG5leHRWZXJzaW9uLCBjbG9uZUdyYXBoJDEoUmVjb2lsX251bGx0aHJvd3Moc3RvcmVTdGF0ZS5ncmFwaHNCeVZlcnNpb24uZ2V0KHZlcnNpb24pKSkpO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgQXBwQ29udGV4dCA9IHJlYWN0LmNyZWF0ZUNvbnRleHQoe1xyXG4gIGN1cnJlbnQ6IGRlZmF1bHRTdG9yZVxyXG59KTtcclxuXHJcbmNvbnN0IHVzZVN0b3JlUmVmID0gKCkgPT4gdXNlQ29udGV4dChBcHBDb250ZXh0KTsgLy8gJEZsb3dFeHBlY3RlZEVycm9yW2luY29tcGF0aWJsZS1jYWxsXVxyXG5cclxuXHJcbmNvbnN0IE11dGFibGVTb3VyY2VDb250ZXh0ID0gcmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbE11dGFibGVTb3VyY2UoKSB7XHJcbiAgY29uc3QgbXV0YWJsZVNvdXJjZSA9IHVzZUNvbnRleHQoTXV0YWJsZVNvdXJjZUNvbnRleHQpO1xyXG5cclxuICBpZiAobXV0YWJsZVNvdXJjZSA9PSBudWxsKSB7XHJcbiAgICBSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24oJ0F0dGVtcHRlZCB0byB1c2UgYSBSZWNvaWwgaG9vayBvdXRzaWRlIG9mIGEgPFJlY29pbFJvb3Q+LiAnICsgJzxSZWNvaWxSb290PiBtdXN0IGJlIGFuIGFuY2VzdG9yIG9mIGFueSBjb21wb25lbnQgdGhhdCB1c2VzICcgKyAnUmVjb2lsIGhvb2tzLicpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG11dGFibGVTb3VyY2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vdGlmeUNvbXBvbmVudHMoc3RvcmUsIHN0b3JlU3RhdGUsIHRyZWVTdGF0ZSkge1xyXG4gIGNvbnN0IGRlcGVuZGVudE5vZGVzID0gZ2V0RG93bnN0cmVhbU5vZGVzJDIoc3RvcmUsIHRyZWVTdGF0ZSwgdHJlZVN0YXRlLmRpcnR5QXRvbXMpO1xyXG5cclxuICBmb3IgKGNvbnN0IGtleSBvZiBkZXBlbmRlbnROb2Rlcykge1xyXG4gICAgY29uc3QgY29tcHMgPSBzdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZ2V0KGtleSk7XHJcblxyXG4gICAgaWYgKGNvbXBzKSB7XHJcbiAgICAgIGZvciAoY29uc3QgW19zdWJJRCwgW19kZWJ1Z05hbWUsIGNhbGxiYWNrXV0gb2YgY29tcHMpIHtcclxuICAgICAgICBjYWxsYmFjayh0cmVlU3RhdGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnMoc3RvcmUpIHtcclxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICBjb25zdCB0cmVlU3RhdGUgPSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlOyAvLyBJbmZvcm0gdHJhbnNhY3Rpb24gc3Vic2NyaWJlcnMgb2YgdGhlIHRyYW5zYWN0aW9uOlxyXG5cclxuICBjb25zdCBkaXJ0eUF0b21zID0gdHJlZVN0YXRlLmRpcnR5QXRvbXM7XHJcblxyXG4gIGlmIChkaXJ0eUF0b21zLnNpemUpIHtcclxuICAgIC8vIEV4ZWN1dGUgTm9kZS1zcGVjaWZpYyBzdWJzY3JpYmVycyBiZWZvcmUgZ2xvYmFsIHN1YnNjcmliZXJzXHJcbiAgICBmb3IgKGNvbnN0IFtrZXksIHN1YnNjcmlwdGlvbnNdIG9mIHN0b3JlU3RhdGUubm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucykge1xyXG4gICAgICBpZiAoZGlydHlBdG9tcy5oYXMoa2V5KSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgW18sIHN1YnNjcmlwdGlvbl0gb2Ygc3Vic2NyaXB0aW9ucykge1xyXG4gICAgICAgICAgc3Vic2NyaXB0aW9uKHN0b3JlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGNvbnN0IFtfLCBzdWJzY3JpcHRpb25dIG9mIHN0b3JlU3RhdGUudHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zKSB7XHJcbiAgICAgIHN1YnNjcmlwdGlvbihzdG9yZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFyZWFjdE1vZGUkMigpLmVhcmx5IHx8IHN0b3JlU3RhdGUuc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzLnNpemUgPiAwKSB7XHJcbiAgICAgIC8vIE5vdGlmeWluZyBjb21wb25lbnRzIGlzIG5lZWRlZCB0byB3YWtlIGZyb20gc3VzcGVuc2UsIGV2ZW4gd2hlbiB1c2luZ1xyXG4gICAgICAvLyBlYXJseSByZW5kZXJpbmcuXHJcbiAgICAgIG5vdGlmeUNvbXBvbmVudHMoc3RvcmUsIHN0b3JlU3RhdGUsIHRyZWVTdGF0ZSk7IC8vIFdha2UgYWxsIHN1c3BlbmRlZCBjb21wb25lbnRzIHNvIHRoZSByaWdodCBvbmUocykgY2FuIHRyeSB0byByZS1yZW5kZXIuXHJcbiAgICAgIC8vIFdlIG5lZWQgdG8gd2FrZSB1cCBjb21wb25lbnRzIG5vdCBqdXN0IHdoZW4gc29tZSBhc3luY2hyb25vdXMgc2VsZWN0b3JcclxuICAgICAgLy8gcmVzb2x2ZWQsIGJ1dCBhbHNvIHdoZW4gY2hhbmdpbmcgc3luY2hyb25vdXMgdmFsdWVzIGJlY2F1c2UgdGhpcyBtYXkgY2F1c2VcclxuICAgICAgLy8gYSBzZWxlY3RvciB0byBjaGFuZ2UgZnJvbSBhc3luY2hyb25vdXMgdG8gc3luY2hyb25vdXMsIGluIHdoaWNoIGNhc2UgdGhlcmVcclxuICAgICAgLy8gd291bGQgYmUgbm8gZm9sbG93LXVwIGFzeW5jaHJvbm91cyByZXNvbHV0aW9uIHRvIHdha2UgdXMgdXAuXHJcbiAgICAgIC8vIFRPRE8gT1BUSU1JWkFUSU9OIE9ubHkgd2FrZSB1cCByZWxhdGVkIGRvd25zdHJlYW0gY29tcG9uZW50c1xyXG5cclxuICAgICAgc3RvcmVTdGF0ZS5zdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMuZm9yRWFjaChjYiA9PiBjYigpKTtcclxuICAgICAgc3RvcmVTdGF0ZS5zdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMuY2xlYXIoKTtcclxuICAgIH1cclxuICB9IC8vIFNwZWNpYWwgYmVoYXZpb3IgT05MWSBpbnZva2VkIGJ5IHVzZUludGVyZmFjZS5cclxuICAvLyBGSVhNRSBkZWxldGUgcXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQgd2hlbiBkZWxldGluZyB1c2VJbnRlcmZhY2UuXHJcblxyXG5cclxuICBzdG9yZVN0YXRlLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELmZvckVhY2goY2IgPT4gY2IodHJlZVN0YXRlKSk7XHJcbiAgc3RvcmVTdGF0ZS5xdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRC5zcGxpY2UoMCwgc3RvcmVTdGF0ZS5xdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRC5sZW5ndGgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbmRCYXRjaChzdG9yZSkge1xyXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG4gIHN0b3JlU3RhdGUuY29tbWl0RGVwdGgrKztcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgbmV4dFRyZWVcclxuICAgIH0gPSBzdG9yZVN0YXRlOyAvLyBJZ25vcmUgY29tbWl0cyB0aGF0IGFyZSBub3QgYmVjYXVzZSBvZiBSZWNvaWwgdHJhbnNhY3Rpb25zIC0tIG5hbWVseSxcclxuICAgIC8vIGJlY2F1c2Ugc29tZXRoaW5nIGFib3ZlIFJlY29pbFJvb3QgcmUtcmVuZGVyZWQ6XHJcblxyXG4gICAgaWYgKG5leHRUcmVlID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSAvLyBuZXh0VHJlZSBpcyBub3cgY29tbWl0dGVkIC0tIG5vdGUgdGhhdCBjb3B5aW5nIGFuZCByZXNldCBvY2N1cnMgd2hlblxyXG4gICAgLy8gYSB0cmFuc2FjdGlvbiBiZWdpbnMsIGluIHN0YXJ0TmV4dFRyZWVJZk5lZWRlZDpcclxuXHJcblxyXG4gICAgc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUgPSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xyXG4gICAgc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA9IG5leHRUcmVlO1xyXG4gICAgc3RvcmVTdGF0ZS5uZXh0VHJlZSA9IG51bGw7XHJcbiAgICBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnMoc3RvcmUpO1xyXG5cclxuICAgIGlmIChzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSAhPSBudWxsKSB7XHJcbiAgICAgIHN0b3JlU3RhdGUuZ3JhcGhzQnlWZXJzaW9uLmRlbGV0ZShzdG9yZVN0YXRlLnByZXZpb3VzVHJlZS52ZXJzaW9uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignRW5kZWQgYmF0Y2ggd2l0aCBubyBwcmV2aW91cyBzdGF0ZSwgd2hpY2ggaXMgdW5leHBlY3RlZCcsICdyZWNvaWwnKTtcclxuICAgIH1cclxuXHJcbiAgICBzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSA9IG51bGw7XHJcblxyXG4gICAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcclxuICAgICAgLy8gT25seSByZWxlYXNlIHJldGFpbmFibGVzIGlmIHRoZXJlIHdlcmUgbm8gd3JpdGVzIGR1cmluZyB0aGUgZW5kIG9mIHRoZVxyXG4gICAgICAvLyBiYXRjaC4gIFRoaXMgYXZvaWRzIHJlbGVhc2luZyBzb21ldGhpbmcgd2UgbWlnaHQgYmUgYWJvdXQgdG8gdXNlLlxyXG4gICAgICBpZiAobmV4dFRyZWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdyQxKHN0b3JlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZmluYWxseSB7XHJcbiAgICBzdG9yZVN0YXRlLmNvbW1pdERlcHRoLS07XHJcbiAgfVxyXG59XHJcbi8qXHJcbiAqIFRoZSBwdXJwb3NlIG9mIHRoZSBCYXRjaGVyIGlzIHRvIG9ic2VydmUgd2hlbiBSZWFjdCBiYXRjaGVzIGVuZCBzbyB0aGF0XHJcbiAqIFJlY29pbCBzdGF0ZSBjaGFuZ2VzIGNhbiBiZSBiYXRjaGVkLiBXaGVuZXZlciBSZWNvaWwgc3RhdGUgY2hhbmdlcywgd2UgY2FsbFxyXG4gKiBzZXRTdGF0ZSBvbiB0aGUgYmF0Y2hlci4gVGhlbiB3ZSB3YWl0IGZvciB0aGF0IGNoYW5nZSB0byBiZSBjb21taXR0ZWQsIHdoaWNoXHJcbiAqIHNpZ25pZmllcyB0aGUgZW5kIG9mIHRoZSBiYXRjaC4gVGhhdCdzIHdoZW4gd2UgcmVzcG9uZCB0byB0aGUgUmVjb2lsIGNoYW5nZS5cclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gQmF0Y2hlcih7XHJcbiAgc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlXHJcbn0pIHtcclxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmKCk7XHJcbiAgY29uc3QgWywgc2V0U3RhdGVdID0gdXNlU3RhdGUoW10pO1xyXG4gIHNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZSgoKSA9PiBzZXRTdGF0ZSh7fSkpO1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2UoKCkgPT4gc2V0U3RhdGUoe30pKTsgLy8gSWYgYW4gYXN5bmNocm9ub3VzIHNlbGVjdG9yIHJlc29sdmVzIGFmdGVyIHRoZSBCYXRjaGVyIGlzIHVubW91bnRlZCxcclxuICAgIC8vIG5vdGlmeUJhdGNoZXJPZkNoYW5nZSB3aWxsIHN0aWxsIGJlIGNhbGxlZC4gQW4gZXJyb3IgZ2V0cyB0aHJvd24gd2hlbmV2ZXJcclxuICAgIC8vIHNldFN0YXRlIGlzIGNhbGxlZCBhZnRlciBhIGNvbXBvbmVudCBpcyBhbHJlYWR5IHVubW91bnRlZCwgc28gdGhpcyBzZXRzXHJcbiAgICAvLyBub3RpZnlCYXRjaGVyT2ZDaGFuZ2UgdG8gYmUgYSBuby1vcC5cclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2UoKCkgPT4ge30pO1xyXG4gICAgfTtcclxuICB9LCBbc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlXSk7XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIC8vIGVucXVldWVFeGVjdXRpb24gcnVucyB0aGlzIGZ1bmN0aW9uIGltbWVkaWF0ZWx5OyBpdCBpcyBvbmx5IHVzZWQgdG9cclxuICAgIC8vIG1hbmlwdWxhdGUgdGhlIG9yZGVyIG9mIHVzZUVmZmVjdHMgZHVyaW5nIHRlc3RzLCBzaW5jZSBSZWFjdCBzZWVtcyB0b1xyXG4gICAgLy8gY2FsbCB1c2VFZmZlY3QgaW4gYW4gdW5wcmVkaWN0YWJsZSBvcmRlciBzb21ldGltZXMuXHJcbiAgICBSZWNvaWxfUXVldWUuZW5xdWV1ZUV4ZWN1dGlvbignQmF0Y2hlcicsICgpID0+IHtcclxuICAgICAgZW5kQmF0Y2goc3RvcmVSZWYuY3VycmVudCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LiRyZWNvaWxEZWJ1Z1N0YXRlcykge1xyXG4gICAgd2luZG93LiRyZWNvaWxEZWJ1Z1N0YXRlcyA9IFtdO1xyXG4gIH1cclxufSAvLyBXaGVuIHJlbW92aW5nIHRoaXMgZGVwcmVjYXRlZCBmdW5jdGlvbiwgcmVtb3ZlIHN0YXRlQnlTZXR0aW5nUmVjb2lsVmFsdWVcclxuLy8gd2hpY2ggd2lsbCBubyBsb25nZXIgYmUgbmVlZGVkLlxyXG5cclxuXHJcbmZ1bmN0aW9uIGluaXRpYWxTdG9yZVN0YXRlX0RFUFJFQ0FURUQoc3RvcmUsIGluaXRpYWxpemVTdGF0ZSkge1xyXG4gIGNvbnN0IGluaXRpYWwgPSBtYWtlRW1wdHlTdG9yZVN0YXRlJDIoKTtcclxuICBpbml0aWFsaXplU3RhdGUoe1xyXG4gICAgc2V0OiAoYXRvbSwgdmFsdWUpID0+IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSBpbml0aWFsLmN1cnJlbnRUcmVlO1xyXG4gICAgICBjb25zdCB3cml0ZXMgPSBzZXROb2RlVmFsdWUkMihzdG9yZSwgc3RhdGUsIGF0b20ua2V5LCB2YWx1ZSk7XHJcbiAgICAgIGNvbnN0IHdyaXR0ZW5Ob2RlcyA9IG5ldyBTZXQod3JpdGVzLmtleXMoKSk7XHJcbiAgICAgIGNvbnN0IG5vbnZhbGlkYXRlZEF0b21zID0gc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuY2xvbmUoKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgbiBvZiB3cml0dGVuTm9kZXMpIHtcclxuICAgICAgICBub252YWxpZGF0ZWRBdG9tcy5kZWxldGUobik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGluaXRpYWwuY3VycmVudFRyZWUgPSB7IC4uLnN0YXRlLFxyXG4gICAgICAgIGRpcnR5QXRvbXM6IFJlY29pbF91bmlvblNldHMoc3RhdGUuZGlydHlBdG9tcywgd3JpdHRlbk5vZGVzKSxcclxuICAgICAgICBhdG9tVmFsdWVzOiBhcHBseUF0b21WYWx1ZVdyaXRlcyQxKHN0YXRlLmF0b21WYWx1ZXMsIHdyaXRlcyksXHJcbiAgICAgICAgLy8gTkI6IFBMRUFTRSB1bi1leHBvcnQgYXBwbHlBdG9tVmFsdWVXcml0ZXMgd2hlbiBkZWxldGluZyB0aGlzIGNvZGVcclxuICAgICAgICBub252YWxpZGF0ZWRBdG9tc1xyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgIHNldFVudmFsaWRhdGVkQXRvbVZhbHVlczogYXRvbVZhbHVlcyA9PiB7XHJcbiAgICAgIC8vIEZJWE1FIHJlcGxhY2UgdGhpcyB3aXRoIGEgbXV0YXRpdmUgbG9vcFxyXG4gICAgICBhdG9tVmFsdWVzLmZvckVhY2goKHYsIGspID0+IHtcclxuICAgICAgICBpbml0aWFsLmN1cnJlbnRUcmVlID0gc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCQxKGluaXRpYWwuY3VycmVudFRyZWUsIGssIHYpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gaW5pdGlhbDtcclxufSAvLyBJbml0aWFsaXplIHN0YXRlIHNuYXBzaG90IGZvciA8UmVjb2lsUm9vdD4gZm9yIHRoZSBpbml0aWFsaXplU3RhdGUgcHJvcC5cclxuLy8gQXRvbSBlZmZlY3QgaW5pdGlhbGl6YXRpb24gdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgcHJvcC5cclxuLy8gQW55IGF0b20gZWZmZWN0cyB3aWxsIGJlIHJ1biBiZWZvcmUgaW5pdGlhbGl6YXRpb24sIGJ1dCB0aGVuIGNsZWFuZWQgdXAsXHJcbi8vIHRoZXkgYXJlIHRoZW4gcmUtcnVuIHdoZW4gdXNlZCBhcyBwYXJ0IG9mIHJlbmRlcmluZy4gIFRoZXNlIHNlbWFudGljcyBhcmVcclxuLy8gY29tcGF0aWJsZSB3aXRoIFJlYWN0IFN0cmljdE1vZGUgd2hlcmUgZWZmZWN0cyBtYXkgYmUgcmUtcnVuIG11bHRpcGxlIHRpbWVzXHJcbi8vIGJ1dCBzdGF0ZSBpbml0aWFsaXphdGlvbiBvbmx5IGhhcHBlbnMgb25jZSB0aGUgZmlyc3QgdGltZS5cclxuXHJcblxyXG5mdW5jdGlvbiBpbml0aWFsU3RvcmVTdGF0ZShpbml0aWFsaXplU3RhdGUpIHtcclxuICAvLyBJbml0aWFsaXplIGEgc25hcHNob3QgYW5kIGdldCBpdHMgc3RvcmVcclxuICBjb25zdCBzbmFwc2hvdCA9IGZyZXNoU25hcHNob3QkMShpbml0aWFsaXplU3RhdGUpO1xyXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzbmFwc2hvdC5nZXRTdG9yZV9JTlRFUk5BTCgpLmdldFN0YXRlKCk7IC8vIENvdW50ZXJhY3QgdGhlIHNuYXBzaG90IGF1dG8tcmVsZWFzZVxyXG5cclxuICBzbmFwc2hvdC5yZXRhaW4oKTsgLy8gQ2xlYW51cCBhbnkgZWZmZWN0cyBydW4gZHVyaW5nIGluaXRpYWxpemF0aW9uIGFuZCBjbGVhciB0aGUgaGFuZGxlcnMgc29cclxuICAvLyB0aGV5IHdpbGwgcmUtaW5pdGlhbGl6ZSBpZiB1c2VkIGR1cmluZyByZW5kZXJpbmcuICBUaGlzIGFsbG93cyBhdG9tIGVmZmVjdFxyXG4gIC8vIGluaXRpYWxpemF0aW9uIHRvIHRha2UgcHJlY2VkZW5jZSBvdmVyIGluaXRpYWxpemVTdGF0ZSBhbmQgYmUgY29tcGF0aWJsZVxyXG4gIC8vIHdpdGggU3RyaWN0TW9kZSBzZW1hbnRpY3MuXHJcblxyXG4gIHN0b3JlU3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuZm9yRWFjaChjbGVhbnVwID0+IGNsZWFudXAoKSk7XHJcbiAgc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5jbGVhcigpO1xyXG4gIHJldHVybiBzdG9yZVN0YXRlO1xyXG59XHJcblxyXG5sZXQgbmV4dElEID0gMDtcclxuXHJcbmZ1bmN0aW9uIFJlY29pbFJvb3RfSU5URVJOQUwoe1xyXG4gIGluaXRpYWxpemVTdGF0ZV9ERVBSRUNBVEVELFxyXG4gIGluaXRpYWxpemVTdGF0ZSxcclxuICBzdG9yZV9JTlRFUk5BTDogc3RvcmVQcm9wLFxyXG4gIC8vIEZvciB1c2Ugd2l0aCBSZWFjdCBcImNvbnRleHQgYnJpZGdpbmdcIlxyXG4gIGNoaWxkcmVuXHJcbn0pIHtcclxuICAvLyBwcmV0dGllci1pZ25vcmVcclxuICAvLyBAZmItb25seTogdXNlRWZmZWN0KCgpID0+IHtcclxuICAvLyBAZmItb25seTogaWYgKGdreCgncmVjb2lsX3VzYWdlX2xvZ2dpbmcnKSkge1xyXG4gIC8vIEBmYi1vbmx5OiB0cnkge1xyXG4gIC8vIEBmYi1vbmx5OiBSZWNvaWxVc2FnZUxvZ0ZhbGNvRXZlbnQubG9nKCgpID0+ICh7XHJcbiAgLy8gQGZiLW9ubHk6IHR5cGU6IFJlY29pbHVzYWdlbG9nRXZlbnQuUkVDT0lMX1JPT1RfTU9VTlRFRCxcclxuICAvLyBAZmItb25seTogcGF0aDogVVJJLmdldFJlcXVlc3RVUkkoKS5nZXRQYXRoKCksXHJcbiAgLy8gQGZiLW9ubHk6IH0pKTtcclxuICAvLyBAZmItb25seTogfSBjYXRjaCB7XHJcbiAgLy8gQGZiLW9ubHk6IHJlY292ZXJhYmxlVmlvbGF0aW9uKFxyXG4gIC8vIEBmYi1vbmx5OiAnRXJyb3Igd2hlbiBsb2dnaW5nIFJlY29pbCBVc2FnZSBldmVudCcsXHJcbiAgLy8gQGZiLW9ubHk6ICdyZWNvaWwnLFxyXG4gIC8vIEBmYi1vbmx5OiApO1xyXG4gIC8vIEBmYi1vbmx5OiB9XHJcbiAgLy8gQGZiLW9ubHk6IH1cclxuICAvLyBAZmItb25seTogfSwgW10pO1xyXG4gIGxldCBzdG9yZVN0YXRlUmVmOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1jb25zdFxyXG5cclxuICBjb25zdCBnZXRHcmFwaCA9IHZlcnNpb24gPT4ge1xyXG4gICAgY29uc3QgZ3JhcGhzID0gc3RvcmVTdGF0ZVJlZi5jdXJyZW50LmdyYXBoc0J5VmVyc2lvbjtcclxuXHJcbiAgICBpZiAoZ3JhcGhzLmhhcyh2ZXJzaW9uKSkge1xyXG4gICAgICByZXR1cm4gUmVjb2lsX251bGx0aHJvd3MoZ3JhcGhzLmdldCh2ZXJzaW9uKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbmV3R3JhcGggPSBncmFwaCQyKCk7XHJcbiAgICBncmFwaHMuc2V0KHZlcnNpb24sIG5ld0dyYXBoKTtcclxuICAgIHJldHVybiBuZXdHcmFwaDtcclxuICB9O1xyXG5cclxuICBjb25zdCBzdWJzY3JpYmVUb1RyYW5zYWN0aW9ucyA9IChjYWxsYmFjaywga2V5KSA9PiB7XHJcbiAgICBpZiAoa2V5ID09IG51bGwpIHtcclxuICAgICAgLy8gR2xvYmFsIHRyYW5zYWN0aW9uIHN1YnNjcmlwdGlvbnNcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uc1xyXG4gICAgICB9ID0gc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpO1xyXG4gICAgICBjb25zdCBpZCA9IG5leHRJRCsrO1xyXG4gICAgICB0cmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuc2V0KGlkLCBjYWxsYmFjayk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVsZWFzZTogKCkgPT4ge1xyXG4gICAgICAgICAgdHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gTm9kZS1zcGVjaWZpYyB0cmFuc2FjdGlvbiBzdWJzY3JpcHRpb25zOlxyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uc1xyXG4gICAgICB9ID0gc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgaWYgKCFub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5zZXQoa2V5LCBuZXcgTWFwKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBpZCA9IG5leHRJRCsrO1xyXG4gICAgICBSZWNvaWxfbnVsbHRocm93cyhub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLmdldChrZXkpKS5zZXQoaWQsIGNhbGxiYWNrKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICByZWxlYXNlOiAoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBzdWJzID0gbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5nZXQoa2V5KTtcclxuXHJcbiAgICAgICAgICBpZiAoc3Vicykge1xyXG4gICAgICAgICAgICBzdWJzLmRlbGV0ZShpZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3Vicy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBhZGRUcmFuc2FjdGlvbk1ldGFkYXRhID0gbWV0YWRhdGEgPT4ge1xyXG4gICAgc3RhcnROZXh0VHJlZUlmTmVlZGVkKHN0b3JlUmVmLmN1cnJlbnQpO1xyXG5cclxuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhtZXRhZGF0YSkpIHtcclxuICAgICAgUmVjb2lsX251bGx0aHJvd3Moc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpLm5leHRUcmVlKS50cmFuc2FjdGlvbk1ldGFkYXRhW2tdID0gbWV0YWRhdGFba107XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgcmVwbGFjZVN0YXRlID0gcmVwbGFjZXIgPT4ge1xyXG4gICAgc3RhcnROZXh0VHJlZUlmTmVlZGVkKHN0b3JlUmVmLmN1cnJlbnQpOyAvLyBVc2UgcmVwbGFjZXIgdG8gZ2V0IHRoZSBuZXh0IHN0YXRlOlxyXG5cclxuICAgIGNvbnN0IG5leHRUcmVlID0gUmVjb2lsX251bGx0aHJvd3Moc3RvcmVTdGF0ZVJlZi5jdXJyZW50Lm5leHRUcmVlKTtcclxuICAgIGxldCByZXBsYWNlZDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBzdGF0ZVJlcGxhY2VySXNCZWluZ0V4ZWN1dGVkID0gdHJ1ZTtcclxuICAgICAgcmVwbGFjZWQgPSByZXBsYWNlcihuZXh0VHJlZSk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzdGF0ZVJlcGxhY2VySXNCZWluZ0V4ZWN1dGVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlcGxhY2VkID09PSBuZXh0VHJlZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB3aW5kb3cuJHJlY29pbERlYnVnU3RhdGVzLnB1c2gocmVwbGFjZWQpOyAvLyBUT0RPIHRoaXMgc2hvdWxkbid0IGhhcHBlbiBoZXJlIGJlY2F1c2UgaXQncyBub3QgYmF0Y2hlZFxyXG4gICAgICB9XHJcbiAgICB9IC8vIFNhdmUgY2hhbmdlcyB0byBuZXh0VHJlZSBhbmQgc2NoZWR1bGUgYSBSZWFjdCB1cGRhdGU6XHJcblxyXG5cclxuICAgIHN0b3JlU3RhdGVSZWYuY3VycmVudC5uZXh0VHJlZSA9IHJlcGxhY2VkO1xyXG5cclxuICAgIGlmIChyZWFjdE1vZGUkMigpLmVhcmx5KSB7XHJcbiAgICAgIG5vdGlmeUNvbXBvbmVudHMoc3RvcmVSZWYuY3VycmVudCwgc3RvcmVTdGF0ZVJlZi5jdXJyZW50LCByZXBsYWNlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgUmVjb2lsX251bGx0aHJvd3Mobm90aWZ5QmF0Y2hlck9mQ2hhbmdlLmN1cnJlbnQpKCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgbm90aWZ5QmF0Y2hlck9mQ2hhbmdlID0gdXNlUmVmJDEobnVsbCk7XHJcbiAgY29uc3Qgc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlID0gdXNlQ2FsbGJhY2soeCA9PiB7XHJcbiAgICBub3RpZnlCYXRjaGVyT2ZDaGFuZ2UuY3VycmVudCA9IHg7XHJcbiAgfSwgW25vdGlmeUJhdGNoZXJPZkNoYW5nZV0pO1xyXG4gIGNvbnN0IHN0b3JlUmVmID0gUmVjb2lsX3VzZVJlZkluaXRPbmNlKCgpID0+IHN0b3JlUHJvcCAhPT0gbnVsbCAmJiBzdG9yZVByb3AgIT09IHZvaWQgMCA/IHN0b3JlUHJvcCA6IHtcclxuICAgIHN0b3JlSUQ6IGdldE5leHRTdG9yZUlEJDIoKSxcclxuICAgIGdldFN0YXRlOiAoKSA9PiBzdG9yZVN0YXRlUmVmLmN1cnJlbnQsXHJcbiAgICByZXBsYWNlU3RhdGUsXHJcbiAgICBnZXRHcmFwaCxcclxuICAgIHN1YnNjcmliZVRvVHJhbnNhY3Rpb25zLFxyXG4gICAgYWRkVHJhbnNhY3Rpb25NZXRhZGF0YVxyXG4gIH0pO1xyXG5cclxuICBpZiAoc3RvcmVQcm9wICE9IG51bGwpIHtcclxuICAgIHN0b3JlUmVmLmN1cnJlbnQgPSBzdG9yZVByb3A7XHJcbiAgfVxyXG5cclxuICBzdG9yZVN0YXRlUmVmID0gUmVjb2lsX3VzZVJlZkluaXRPbmNlKCgpID0+IGluaXRpYWxpemVTdGF0ZV9ERVBSRUNBVEVEICE9IG51bGwgPyBpbml0aWFsU3RvcmVTdGF0ZV9ERVBSRUNBVEVEKHN0b3JlUmVmLmN1cnJlbnQsIGluaXRpYWxpemVTdGF0ZV9ERVBSRUNBVEVEKSA6IGluaXRpYWxpemVTdGF0ZSAhPSBudWxsID8gaW5pdGlhbFN0b3JlU3RhdGUoaW5pdGlhbGl6ZVN0YXRlKSA6IG1ha2VFbXB0eVN0b3JlU3RhdGUkMigpKTtcclxuICBjb25zdCBtdXRhYmxlU291cmNlID0gdXNlTWVtbygoKSA9PiBjcmVhdGVNdXRhYmxlU291cmNlJDEgPT09IG51bGwgfHwgY3JlYXRlTXV0YWJsZVNvdXJjZSQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjcmVhdGVNdXRhYmxlU291cmNlJDEoc3RvcmVTdGF0ZVJlZiwgKCkgPT4gc3RvcmVTdGF0ZVJlZi5jdXJyZW50LmN1cnJlbnRUcmVlLnZlcnNpb24pLCBbc3RvcmVTdGF0ZVJlZl0pOyAvLyBDbGVhbnVwIHdoZW4gdGhlIDxSZWNvaWxSb290PiBpcyB1bm1vdW50ZWRcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIC8vIFJlYWN0IGlzIGZyZWUgdG8gY2FsbCBlZmZlY3QgY2xlYW51cCBoYW5kbGVycyBhbmQgZWZmZWN0cyBhdCB3aWxsLCB0aGVcclxuICAgIC8vIGRlcHMgYXJyYXkgaXMgb25seSBhbiBvcHRpbWl6YXRpb24uICBGb3IgZXhhbXBsZSwgUmVhY3Qgc3RyaWN0IG1vZGVcclxuICAgIC8vIHdpbGwgZXhlY3V0ZSBlYWNoIGVmZmVjdCB0d2ljZSBmb3IgdGVzdGluZy4gIFRoZXJlZm9yZSwgd2UgbmVlZCBzeW1tZXRyeVxyXG4gICAgLy8gdG8gcmUtaW5pdGlhbGl6ZSBhbGwga25vd24gYXRvbXMgYWZ0ZXIgdGhleSB3ZXJlIGNsZWFuZWQgdXAuXHJcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XHJcblxyXG4gICAgZm9yIChjb25zdCBhdG9tS2V5IG9mIG5ldyBTZXQoc3RvcmUuZ2V0U3RhdGUoKS5rbm93bkF0b21zKSkge1xyXG4gICAgICBpbml0aWFsaXplTm9kZSQyKHN0b3JlLCBhdG9tS2V5LCAnZ2V0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgZm9yIChjb25zdCBhdG9tS2V5IG9mIHN0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcykge1xyXG4gICAgICAgIGNsZWFuVXBOb2RlJDIoc3RvcmUsIGF0b21LZXkpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFtzdG9yZVJlZl0pO1xyXG4gIHJldHVybiAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChBcHBDb250ZXh0LlByb3ZpZGVyLCB7XHJcbiAgICB2YWx1ZTogc3RvcmVSZWZcclxuICB9LCAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChNdXRhYmxlU291cmNlQ29udGV4dC5Qcm92aWRlciwge1xyXG4gICAgdmFsdWU6IG11dGFibGVTb3VyY2VcclxuICB9LCAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChCYXRjaGVyLCB7XHJcbiAgICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2U6IHNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZVxyXG4gIH0pLCBjaGlsZHJlbikpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBSZWNvaWxSb290KHByb3BzKSB7XHJcbiAgY29uc3Qge1xyXG4gICAgb3ZlcnJpZGUsXHJcbiAgICAuLi5wcm9wc0V4Y2VwdE92ZXJyaWRlXHJcbiAgfSA9IHByb3BzO1xyXG4gIGNvbnN0IGFuY2VzdG9yU3RvcmVSZWYgPSB1c2VTdG9yZVJlZigpO1xyXG5cclxuICBpZiAob3ZlcnJpZGUgPT09IGZhbHNlICYmIGFuY2VzdG9yU3RvcmVSZWYuY3VycmVudCAhPT0gZGVmYXVsdFN0b3JlKSB7XHJcbiAgICAvLyBJZiBhbmNlc3RvclN0b3JlUmVmLmN1cnJlbnQgIT09IGRlZmF1bHRTdG9yZSwgaXQgbWVhbnMgdGhhdCB0aGlzXHJcbiAgICAvLyBSZWNvaWxSb290IGlzIG5vdCBuZXN0ZWQgd2l0aGluIGFub3RoZXIuXHJcbiAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XHJcbiAgfVxyXG5cclxuICByZXR1cm4gLyojX19QVVJFX18qL3JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVjb2lsUm9vdF9JTlRFUk5BTCwgcHJvcHNFeGNlcHRPdmVycmlkZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbFN0b3JlSUQoKSB7XHJcbiAgcmV0dXJuIHVzZVN0b3JlUmVmKCkuY3VycmVudC5zdG9yZUlEO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX1JlY29pbFJvb3QgPSB7XHJcbiAgUmVjb2lsUm9vdCxcclxuICB1c2VTdG9yZVJlZixcclxuICB1c2VSZWNvaWxNdXRhYmxlU291cmNlLFxyXG4gIHVzZVJlY29pbFN0b3JlSUQsXHJcbiAgbm90aWZ5Q29tcG9uZW50c19GT1JfVEVTVElORzogbm90aWZ5Q29tcG9uZW50cyxcclxuICBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnNfRk9SX1RFU1RJTkc6IHNlbmRFbmRPZkJhdGNoTm90aWZpY2F0aW9uc1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHNoYWxsb3dBcnJheUVxdWFsKGEsIGIpIHtcclxuICBpZiAoYSA9PT0gYikge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmb3IgKGxldCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxudmFyIFJlY29pbF9zaGFsbG93QXJyYXlFcXVhbCA9IHNoYWxsb3dBcnJheUVxdWFsO1xyXG5cclxuY29uc3Qge1xyXG4gIHVzZUVmZmVjdDogdXNlRWZmZWN0JDEsXHJcbiAgdXNlUmVmOiB1c2VSZWYkMlxyXG59ID0gcmVhY3Q7XHJcblxyXG5mdW5jdGlvbiB1c2VQcmV2aW91cyh2YWx1ZSkge1xyXG4gIGNvbnN0IHJlZiA9IHVzZVJlZiQyKCk7XHJcbiAgdXNlRWZmZWN0JDEoKCkgPT4ge1xyXG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcclxuICB9KTtcclxuICByZXR1cm4gcmVmLmN1cnJlbnQ7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfdXNlUHJldmlvdXMgPSB1c2VQcmV2aW91cztcclxuXHJcbmNvbnN0IHtcclxuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkMVxyXG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XHJcblxyXG5jb25zdCB7XHJcbiAgU1VTUEVOU0VfVElNRU9VVF9NUzogU1VTUEVOU0VfVElNRU9VVF9NUyQxXHJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xyXG5cclxuY29uc3Qge1xyXG4gIHVwZGF0ZVJldGFpbkNvdW50OiB1cGRhdGVSZXRhaW5Db3VudCQyXHJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xyXG5cclxuY29uc3Qge1xyXG4gIFJldGVudGlvblpvbmU6IFJldGVudGlvblpvbmUkM1xyXG59ID0gUmVjb2lsX1JldGVudGlvblpvbmU7XHJcblxyXG5jb25zdCB7XHJcbiAgdXNlRWZmZWN0OiB1c2VFZmZlY3QkMixcclxuICB1c2VSZWY6IHVzZVJlZiQzXHJcbn0gPSByZWFjdDtcclxuXHJcbmNvbnN0IHtcclxuICBpc1NTUjogaXNTU1IkMlxyXG59ID0gUmVjb2lsX0Vudmlyb25tZW50O1xyXG5cclxuXHJcblxyXG5cclxuXHJcbiAvLyBJIGRvbid0IHNlZSBhIHdheSB0byBhdm9pZCB0aGUgYW55IHR5cGUgaGVyZSBiZWNhdXNlIHdlIHdhbnQgdG8gYWNjZXB0IHJlYWRhYmxlXHJcbi8vIGFuZCB3cml0YWJsZSB2YWx1ZXMgd2l0aCBhbnkgdHlwZSBwYXJhbWV0ZXIsIGJ1dCBub3JtYWxseSB3aXRoIHdyaXRhYmxlIG9uZXNcclxuLy8gUmVjb2lsU3RhdGU8U29tZVQ+IGlzIG5vdCBhIHN1YnR5cGUgb2YgUmVjb2lsU3RhdGU8bWl4ZWQ+LlxyXG5cclxuXHJcbi8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxyXG5mdW5jdGlvbiB1c2VSZXRhaW4odG9SZXRhaW4pIHtcclxuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcclxuICAgIHJldHVybjtcclxuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvcmVhY3QtaG9va3NcclxuXHJcblxyXG4gIHJldHVybiB1c2VSZXRhaW5fQUNUVUFMKHRvUmV0YWluKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXNlUmV0YWluX0FDVFVBTCh0b1JldGFpbikge1xyXG4gIGNvbnN0IGFycmF5ID0gQXJyYXkuaXNBcnJheSh0b1JldGFpbikgPyB0b1JldGFpbiA6IFt0b1JldGFpbl07XHJcbiAgY29uc3QgcmV0YWluYWJsZXMgPSBhcnJheS5tYXAoYSA9PiBhIGluc3RhbmNlb2YgUmV0ZW50aW9uWm9uZSQzID8gYSA6IGEua2V5KTtcclxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDEoKTtcclxuICB1c2VFZmZlY3QkMigoKSA9PiB7XHJcbiAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcclxuXHJcbiAgICBpZiAodGltZW91dElELmN1cnJlbnQgJiYgIWlzU1NSJDIpIHtcclxuICAgICAgLy8gQWxyZWFkeSBwZXJmb3JtZWQgYSB0ZW1wb3JhcnkgcmV0YWluIG9uIHJlbmRlciwgc2ltcGx5IGNhbmNlbCB0aGUgcmVsZWFzZVxyXG4gICAgICAvLyBvZiB0aGF0IHRlbXBvcmFyeSByZXRhaW4uXHJcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElELmN1cnJlbnQpO1xyXG4gICAgICB0aW1lb3V0SUQuY3VycmVudCA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcclxuICAgICAgICB1cGRhdGVSZXRhaW5Db3VudCQyKHN0b3JlLCByLCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGZvciAoY29uc3QgciBvZiByZXRhaW5hYmxlcykge1xyXG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIC0xKTtcclxuICAgICAgfVxyXG4gICAgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9yZWFjdC1ob29rcy1kZXBzXHJcbiAgfSwgW3N0b3JlUmVmLCAuLi5yZXRhaW5hYmxlc10pOyAvLyBXZSB3YW50IHRvIHJldGFpbiBpZiB0aGUgY29tcG9uZW50IHN1c3BlbmRzLiBUaGlzIGlzIHRlcnJpYmxlIGJ1dCB0aGUgU3VzcGVuc2VcclxuICAvLyBBUEkgYWZmb3JkcyB1cyBubyBiZXR0ZXIgb3B0aW9uLiBJZiB3ZSBzdXNwZW5kIGFuZCBuZXZlciBjb21taXQgYWZ0ZXIgc29tZVxyXG4gIC8vIHNlY29uZHMsIHRoZW4gcmVsZWFzZS4gVGhlICdhY3R1YWwnIHJldGFpbi9yZWxlYXNlIGluIHRoZSBlZmZlY3QgYWJvdmVcclxuICAvLyBjYW5jZWxzIHRoaXMuXHJcblxyXG4gIGNvbnN0IHRpbWVvdXRJRCA9IHVzZVJlZiQzKCk7XHJcbiAgY29uc3QgcHJldmlvdXNSZXRhaW5hYmxlcyA9IFJlY29pbF91c2VQcmV2aW91cyhyZXRhaW5hYmxlcyk7XHJcblxyXG4gIGlmICghaXNTU1IkMiAmJiAocHJldmlvdXNSZXRhaW5hYmxlcyA9PT0gdW5kZWZpbmVkIHx8ICFSZWNvaWxfc2hhbGxvd0FycmF5RXF1YWwocHJldmlvdXNSZXRhaW5hYmxlcywgcmV0YWluYWJsZXMpKSkge1xyXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xyXG5cclxuICAgIGZvciAoY29uc3QgciBvZiByZXRhaW5hYmxlcykge1xyXG4gICAgICB1cGRhdGVSZXRhaW5Db3VudCQyKHN0b3JlLCByLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocHJldmlvdXNSZXRhaW5hYmxlcykge1xyXG4gICAgICBmb3IgKGNvbnN0IHIgb2YgcHJldmlvdXNSZXRhaW5hYmxlcykge1xyXG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIC0xKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aW1lb3V0SUQuY3VycmVudCkge1xyXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcclxuICAgIH1cclxuXHJcbiAgICB0aW1lb3V0SUQuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGltZW91dElELmN1cnJlbnQgPSBudWxsO1xyXG5cclxuICAgICAgZm9yIChjb25zdCByIG9mIHJldGFpbmFibGVzKSB7XHJcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMihzdG9yZSwgciwgLTEpO1xyXG4gICAgICB9XHJcbiAgICB9LCBTVVNQRU5TRV9USU1FT1VUX01TJDEpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIFJlY29pbF91c2VSZXRhaW4gPSB1c2VSZXRhaW47XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG4vKipcclxuICogVEhJUyBDT0RFIEhBUyBCRUVOIENPTU1FTlRFRCBPVVQgSU5URU5USU9OQUxMWVxyXG4gKlxyXG4gKiBUaGlzIHRlY2huaXF1ZSBvZiBnZXR0aW5nIHRoZSBjb21wb25lbnQgbmFtZSBpcyBpbXBlcmZlY3QsIHNpbmNlIGl0IGJvdGggb25seVxyXG4gKiB3b3JrcyBpbiBhIG5vbi1taW5pZmllZCBjb2RlIGJhc2UsIGFuZCBtb3JlIGltcG9ydGFudGx5IGludHJvZHVjZXMgcGVyZm9ybWFuY2VcclxuICogcHJvYmxlbXMgc2luY2UgaXQgcmVsaWVzIGluIHRocm93aW5nIGVycm9ycyB3aGljaCBpcyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBBdCBzb21lIHBvaW50IHdlIG1heSB3YW50IHRvIHJlZXZhbHVhdGUgdGhpcyB0ZWNobmlxdWUgaGVuY2Ugd2h5IHdlIGhhdmUgY29tbWVudGVkXHJcbiAqIHRoaXMgY29kZSBvdXQsIHJhdGhlciB0aGFuIGRlbGV0ZSBpdCBhbGwgdG9nZXRoZXIuXHJcbiAqL1xyXG4vLyBjb25zdCB7dXNlUmVmfSA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcbi8vIGNvbnN0IGdreCA9IHJlcXVpcmUoJ3JlY29pbC1zaGFyZWQvdXRpbC9SZWNvaWxfZ2t4Jyk7XHJcbi8vIGNvbnN0IHN0YWNrVHJhY2VQYXJzZXIgPSByZXF1aXJlKCdyZWNvaWwtc2hhcmVkL3V0aWwvUmVjb2lsX3N0YWNrVHJhY2VQYXJzZXInKTtcclxuXHJcbmZ1bmN0aW9uIHVzZUNvbXBvbmVudE5hbWUoKSB7XHJcbiAgLy8gY29uc3QgbmFtZVJlZiA9IHVzZVJlZigpO1xyXG4gIC8vIGlmIChfX0RFVl9fKSB7XHJcbiAgLy8gICBpZiAoZ2t4KCdyZWNvaWxfaW5mZXJfY29tcG9uZW50X25hbWVzJykpIHtcclxuICAvLyAgICAgaWYgKG5hbWVSZWYuY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgLy8gICAgICAgLy8gVGhlcmUgaXMgbm8gYmxlc3NlZCB3YXkgdG8gZGV0ZXJtaW5lIHRoZSBjYWxsaW5nIFJlYWN0IGNvbXBvbmVudCBmcm9tXHJcbiAgLy8gICAgICAgLy8gd2l0aGluIGEgaG9vay4gVGhpcyBoYWNrIHVzZXMgdGhlIGZhY3QgdGhhdCBob29rcyBtdXN0IHN0YXJ0IHdpdGggJ3VzZSdcclxuICAvLyAgICAgICAvLyBhbmQgdGhhdCBob29rcyBhcmUgZWl0aGVyIGNhbGxlZCBieSBSZWFjdCBDb21wb25lbnRzIG9yIG90aGVyIGhvb2tzLiBJdFxyXG4gIC8vICAgICAgIC8vIGZvbGxvd3MgdGhlcmVmb3JlLCB0aGF0IHRvIGZpbmQgdGhlIGNhbGxpbmcgY29tcG9uZW50LCB5b3Ugc2ltcGx5IG5lZWRcclxuICAvLyAgICAgICAvLyB0byBsb29rIGRvd24gdGhlIHN0YWNrIGFuZCBmaW5kIHRoZSBmaXJzdCBmdW5jdGlvbiB3aGljaCBkb2Vzbid0IHN0YXJ0XHJcbiAgLy8gICAgICAgLy8gd2l0aCAndXNlJy4gV2UgYXJlIG9ubHkgZW5hYmxpbmcgdGhpcyBpbiBkZXYgZm9yIG5vdywgc2luY2Ugb25jZSB0aGVcclxuICAvLyAgICAgICAvLyBjb2RlYmFzZSBpcyBtaW5pZmllZCwgdGhlIG5hbWluZyBhc3N1bXB0aW9ucyBubyBsb25nZXIgaG9sZCB0cnVlLlxyXG4gIC8vICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvbm8tbmV3LWVycm9yXHJcbiAgLy8gICAgICAgY29uc3QgZnJhbWVzID0gc3RhY2tUcmFjZVBhcnNlcihuZXcgRXJyb3IoKS5zdGFjayk7XHJcbiAgLy8gICAgICAgZm9yIChjb25zdCB7bWV0aG9kTmFtZX0gb2YgZnJhbWVzKSB7XHJcbiAgLy8gICAgICAgICAvLyBJIG9ic2VydmVkIGNhc2VzIHdoZXJlIHRoZSBmcmFtZSB3YXMgb2YgdGhlIGZvcm0gJ09iamVjdC51c2VYWFgnXHJcbiAgLy8gICAgICAgICAvLyBoZW5jZSB3aHkgSSdtIHNlYXJjaGluZyBmb3IgaG9va3MgZm9sbG93aW5nIGEgd29yZCBib3VuZGFyeVxyXG4gIC8vICAgICAgICAgaWYgKCFtZXRob2ROYW1lLm1hdGNoKC9cXGJ1c2VbXlxcYl0rJC8pKSB7XHJcbiAgLy8gICAgICAgICAgIHJldHVybiAobmFtZVJlZi5jdXJyZW50ID0gbWV0aG9kTmFtZSk7XHJcbiAgLy8gICAgICAgICB9XHJcbiAgLy8gICAgICAgfVxyXG4gIC8vICAgICAgIG5hbWVSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgLy8gICAgIH1cclxuICAvLyAgICAgcmV0dXJuIG5hbWVSZWYuY3VycmVudCA/PyAnPHVuYWJsZSB0byBkZXRlcm1pbmUgY29tcG9uZW50IG5hbWU+JztcclxuICAvLyAgIH1cclxuICAvLyB9XHJcbiAgLy8gQGZiLW9ubHk6IHJldHVybiBcIjxjb21wb25lbnQgbmFtZSBvbmx5IGF2YWlsYWJsZSB3aGVuIGJvdGggaW4gZGV2IG1vZGUgYW5kIHdoZW4gcGFzc2luZyBHSyAncmVjb2lsX2luZmVyX2NvbXBvbmVudF9uYW1lcyc+XCI7XHJcbiAgcmV0dXJuICc8Y29tcG9uZW50IG5hbWUgbm90IGF2YWlsYWJsZT4nOyAvLyBAb3NzLW9ubHlcclxufVxyXG5cclxudmFyIFJlY29pbF91c2VDb21wb25lbnROYW1lID0gdXNlQ29tcG9uZW50TmFtZTtcclxuXHJcbmNvbnN0IHtcclxuICBiYXRjaFVwZGF0ZXM6IGJhdGNoVXBkYXRlcyQyXHJcbn0gPSBSZWNvaWxfQmF0Y2hpbmc7XHJcblxyXG5jb25zdCB7XHJcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQyXHJcbn0gPSBSZWNvaWxfTm9kZTtcclxuXHJcbmNvbnN0IHtcclxuICByZWFjdE1vZGU6IHJlYWN0TW9kZSQzLFxyXG4gIHVzZU11dGFibGVTb3VyY2U6IHVzZU11dGFibGVTb3VyY2UkMSxcclxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdXNlU3luY0V4dGVybmFsU3RvcmUkMVxyXG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcclxuXHJcbmNvbnN0IHtcclxuICB1c2VSZWNvaWxNdXRhYmxlU291cmNlOiB1c2VSZWNvaWxNdXRhYmxlU291cmNlJDEsXHJcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDJcclxufSA9IFJlY29pbF9SZWNvaWxSb290O1xyXG5cclxuY29uc3Qge1xyXG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkMlxyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlJDE7XHJcblxyXG5jb25zdCB7XHJcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZTogQWJzdHJhY3RSZWNvaWxWYWx1ZSQzLFxyXG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZTogZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIsXHJcbiAgc2V0UmVjb2lsVmFsdWU6IHNldFJlY29pbFZhbHVlJDIsXHJcbiAgc2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZTogc2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZSQyLFxyXG4gIHN1YnNjcmliZVRvUmVjb2lsVmFsdWU6IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMVxyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xyXG5cclxuXHJcblxyXG5jb25zdCB7XHJcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrJDEsXHJcbiAgdXNlRWZmZWN0OiB1c2VFZmZlY3QkMyxcclxuICB1c2VNZW1vOiB1c2VNZW1vJDEsXHJcbiAgdXNlUmVmOiB1c2VSZWYkNCxcclxuICB1c2VTdGF0ZTogdXNlU3RhdGUkMVxyXG59ID0gcmVhY3Q7XHJcblxyXG5jb25zdCB7XHJcbiAgc2V0QnlBZGRpbmdUb1NldDogc2V0QnlBZGRpbmdUb1NldCQyXHJcbn0gPSBSZWNvaWxfQ29weU9uV3JpdGU7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBoYW5kbGVMb2FkYWJsZShsb2FkYWJsZSwgcmVjb2lsVmFsdWUsIHN0b3JlUmVmKSB7XHJcbiAgLy8gV2UgY2FuJ3QganVzdCB0aHJvdyB0aGUgcHJvbWlzZSB3ZSBhcmUgd2FpdGluZyBvbiB0byBTdXNwZW5zZS4gIElmIHRoZVxyXG4gIC8vIHVwc3RyZWFtIGRlcGVuZGVuY2llcyBjaGFuZ2UgaXQgbWF5IHByb2R1Y2UgYSBzdGF0ZSBpbiB3aGljaCB0aGUgY29tcG9uZW50XHJcbiAgLy8gY2FuIHJlbmRlciwgYnV0IGl0IHdvdWxkIHN0aWxsIGJlIHN1c3BlbmRlZCBvbiBhIFByb21pc2UgdGhhdCBtYXkgbmV2ZXIgcmVzb2x2ZS5cclxuICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScpIHtcclxuICAgIHJldHVybiBsb2FkYWJsZS5jb250ZW50cztcclxuICB9IGVsc2UgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnbG9hZGluZycpIHtcclxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpLnN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVycy5hZGQocmVzb2x2ZSk7XHJcbiAgICB9KTsgLy8gJEZsb3dFeHBlY3RlZEVycm9yIEZsb3cocHJvcC1taXNzaW5nKSBmb3IgaW50ZWdyYXRpbmcgd2l0aCB0b29scyB0aGF0IGluc3BlY3QgdGhyb3duIHByb21pc2VzIEBmYi1vbmx5XHJcbiAgICAvLyBAZmItb25seTogcHJvbWlzZS5kaXNwbGF5TmFtZSA9IGBSZWNvaWwgU3RhdGU6ICR7cmVjb2lsVmFsdWUua2V5fWA7XHJcblxyXG4gICAgdGhyb3cgcHJvbWlzZTtcclxuICB9IGVsc2UgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzRXJyb3InKSB7XHJcbiAgICB0aHJvdyBsb2FkYWJsZS5jb250ZW50cztcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgUmVjb2lsX2VycihgSW52YWxpZCB2YWx1ZSBvZiBsb2FkYWJsZSBhdG9tIFwiJHtyZWNvaWxWYWx1ZS5rZXl9XCJgKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsIGhvb2tOYW1lKSB7XHJcbiAgaWYgKCFpc1JlY29pbFZhbHVlJDIocmVjb2lsVmFsdWUpKSB7XHJcbiAgICB0aHJvdyBSZWNvaWxfZXJyKGBJbnZhbGlkIGFyZ3VtZW50IHRvICR7aG9va05hbWV9OiBleHBlY3RlZCBhbiBhdG9tIG9yIHNlbGVjdG9yIGJ1dCBnb3QgJHtTdHJpbmcocmVjb2lsVmFsdWUpfWApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZhcmlvdXMgdGhpbmdzIGFyZSBicm9rZW4gd2l0aCB1c2VSZWNvaWxJbnRlcmZhY2UsIHBhcnRpY3VsYXJseSBjb25jdXJyZW50XHJcbiAqIG1vZGUsIFJlYWN0IHN0cmljdCBtb2RlLCBhbmQgbWVtb3J5IG1hbmFnZW1lbnQuIFRoZXkgd2lsbCBub3QgYmUgZml4ZWQuXHJcbiAqICovXHJcbmZ1bmN0aW9uIHVzZVJlY29pbEludGVyZmFjZV9ERVBSRUNBVEVEKCkge1xyXG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBSZWNvaWxfdXNlQ29tcG9uZW50TmFtZSgpO1xyXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xyXG4gIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVN0YXRlJDEoW10pO1xyXG4gIGNvbnN0IHJlY29pbFZhbHVlc1VzZWQgPSB1c2VSZWYkNChuZXcgU2V0KCkpO1xyXG4gIHJlY29pbFZhbHVlc1VzZWQuY3VycmVudCA9IG5ldyBTZXQoKTsgLy8gVHJhY2sgdGhlIFJlY29pbFZhbHVlcyB1c2VkIGp1c3QgZHVyaW5nIHRoaXMgcmVuZGVyXHJcblxyXG4gIGNvbnN0IHByZXZpb3VzU3Vic2NyaXB0aW9ucyA9IHVzZVJlZiQ0KG5ldyBTZXQoKSk7XHJcbiAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHVzZVJlZiQ0KG5ldyBNYXAoKSk7XHJcbiAgY29uc3QgdW5zdWJzY3JpYmVGcm9tID0gdXNlQ2FsbGJhY2skMShrZXkgPT4ge1xyXG4gICAgY29uc3Qgc3ViID0gc3Vic2NyaXB0aW9ucy5jdXJyZW50LmdldChrZXkpO1xyXG5cclxuICAgIGlmIChzdWIpIHtcclxuICAgICAgc3ViLnJlbGVhc2UoKTtcclxuICAgICAgc3Vic2NyaXB0aW9ucy5jdXJyZW50LmRlbGV0ZShrZXkpO1xyXG4gICAgfVxyXG4gIH0sIFtzdWJzY3JpcHRpb25zXSk7XHJcbiAgY29uc3QgdXBkYXRlU3RhdGUgPSB1c2VDYWxsYmFjayQxKChfc3RhdGUsIGtleSkgPT4ge1xyXG4gICAgaWYgKHN1YnNjcmlwdGlvbnMuY3VycmVudC5oYXMoa2V5KSkge1xyXG4gICAgICBmb3JjZVVwZGF0ZShbXSk7XHJcbiAgICB9XHJcbiAgfSwgW10pOyAvLyBFZmZlY3QgdG8gYWRkL3JlbW92ZSBzdWJzY3JpcHRpb25zIGFzIG5vZGVzIGFyZSB1c2VkXHJcblxyXG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcclxuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcclxuICAgIFJlY29pbF9kaWZmZXJlbmNlU2V0cyhyZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQsIHByZXZpb3VzU3Vic2NyaXB0aW9ucy5jdXJyZW50KS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIGlmIChzdWJzY3JpcHRpb25zLmN1cnJlbnQuaGFzKGtleSkpIHtcclxuICAgICAgICBSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24oYERvdWJsZSBzdWJzY3JpcHRpb24gdG8gUmVjb2lsVmFsdWUgXCIke2tleX1cImApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgc3ViID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlLCBuZXcgQWJzdHJhY3RSZWNvaWxWYWx1ZSQzKGtleSksIHN0YXRlID0+IHVwZGF0ZVN0YXRlKHN0YXRlLCBrZXkpLCBjb21wb25lbnROYW1lKTtcclxuICAgICAgc3Vic2NyaXB0aW9ucy5jdXJyZW50LnNldChrZXksIHN1Yik7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBTaW5jZSB3ZSdyZSBzdWJzY3JpYmluZyBpbiBhbiBlZmZlY3Qgd2UgbmVlZCB0byB1cGRhdGUgdG8gdGhlIGxhdGVzdFxyXG4gICAgICAgKiB2YWx1ZSBvZiB0aGUgYXRvbSBzaW5jZSBpdCBtYXkgaGF2ZSBjaGFuZ2VkIHNpbmNlIHdlIHJlbmRlcmVkLiBXZSBjYW5cclxuICAgICAgICogZ28gYWhlYWQgYW5kIGRvIHRoYXQgbm93LCB1bmxlc3Mgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIGJhdGNoIC0tXHJcbiAgICAgICAqIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGRvIGl0IGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLCBkdWUgdG8gdGhlXHJcbiAgICAgICAqIGZvbGxvd2luZyBlZGdlIGNhc2U6IFN1cHBvc2UgYW4gYXRvbSBpcyB1cGRhdGVkIGluIGFub3RoZXIgdXNlRWZmZWN0XHJcbiAgICAgICAqIG9mIHRoaXMgc2FtZSBjb21wb25lbnQuIFRoZW4gdGhlIGZvbGxvd2luZyBzZXF1ZW5jZSBvZiBldmVudHMgb2NjdXI6XHJcbiAgICAgICAqIDEuIEF0b20gaXMgdXBkYXRlZCBhbmQgc3VicyBmaXJlZCAoYnV0IHdlIG1heSBub3QgYmUgc3Vic2NyaWJlZFxyXG4gICAgICAgKiAgICB5ZXQgZGVwZW5kaW5nIG9uIG9yZGVyIG9mIGVmZmVjdHMsIHNvIHdlIG1pc3MgdGhpcykgVXBkYXRlZCB2YWx1ZVxyXG4gICAgICAgKiAgICBpcyBub3cgaW4gbmV4dFRyZWUsIGJ1dCBub3QgY3VycmVudFRyZWUuXHJcbiAgICAgICAqIDIuIFRoaXMgZWZmZWN0IGhhcHBlbnMuIFdlIHN1YnNjcmliZSBhbmQgdXBkYXRlLlxyXG4gICAgICAgKiAzLiBGcm9tIHRoZSB1cGRhdGUgd2UgcmUtcmVuZGVyIGFuZCByZWFkIGN1cnJlbnRUcmVlLCB3aXRoIG9sZCB2YWx1ZS5cclxuICAgICAgICogNC4gQmF0Y2hlcidzIGVmZmVjdCBzZXRzIGN1cnJlbnRUcmVlIHRvIG5leHRUcmVlLlxyXG4gICAgICAgKiBJbiB0aGlzIHNlcXVlbmNlIHdlIG1pc3MgdGhlIHVwZGF0ZS4gVG8gYXZvaWQgdGhhdCwgYWRkIHRoZSB1cGRhdGVcclxuICAgICAgICogdG8gcXVldWVkQ29tcG9uZW50Q2FsbGJhY2sgaWYgYSBiYXRjaCBpcyBpbiBwcm9ncmVzcy5cclxuICAgICAgICovXHJcbiAgICAgIC8vIEZJWE1FIGRlbGV0ZSBxdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRCB3aGVuIGRlbGV0aW5nIHVzZUludGVyZmFjZS5cclxuXHJcbiAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIGlmIChzdGF0ZS5uZXh0VHJlZSkge1xyXG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkucXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQucHVzaCgoKSA9PiB7XHJcbiAgICAgICAgICB1cGRhdGVTdGF0ZShzdG9yZS5nZXRTdGF0ZSgpLCBrZXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVwZGF0ZVN0YXRlKHN0b3JlLmdldFN0YXRlKCksIGtleSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgUmVjb2lsX2RpZmZlcmVuY2VTZXRzKHByZXZpb3VzU3Vic2NyaXB0aW9ucy5jdXJyZW50LCByZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgdW5zdWJzY3JpYmVGcm9tKGtleSk7XHJcbiAgICB9KTtcclxuICAgIHByZXZpb3VzU3Vic2NyaXB0aW9ucy5jdXJyZW50ID0gcmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50O1xyXG4gIH0pOyAvLyBFZmZlY3QgdG8gdW5zdWJzY3JpYmUgZnJvbSBhbGwgd2hlbiB1bm1vdW50aW5nXHJcblxyXG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcclxuICAgIGNvbnN0IGN1cnJlbnRTdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucy5jdXJyZW50OyAvLyBSZXN0b3JlIHN1YnNjcmlwdGlvbnMgdGhhdCB3ZXJlIGNsZWFyZWQgZHVlIHRvIFN0cmljdE1vZGUgcnVubmluZyB0aGlzIGVmZmVjdCB0d2ljZVxyXG5cclxuICAgIFJlY29pbF9kaWZmZXJlbmNlU2V0cyhyZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQsIG5ldyBTZXQoY3VycmVudFN1YnNjcmlwdGlvbnMua2V5cygpKSkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICBjb25zdCBzdWIgPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmVSZWYuY3VycmVudCwgbmV3IEFic3RyYWN0UmVjb2lsVmFsdWUkMyhrZXkpLCBzdGF0ZSA9PiB1cGRhdGVTdGF0ZShzdGF0ZSwga2V5KSwgY29tcG9uZW50TmFtZSk7XHJcbiAgICAgIGN1cnJlbnRTdWJzY3JpcHRpb25zLnNldChrZXksIHN1Yik7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiAoKSA9PiBjdXJyZW50U3Vic2NyaXB0aW9ucy5mb3JFYWNoKChfLCBrZXkpID0+IHVuc3Vic2NyaWJlRnJvbShrZXkpKTtcclxuICB9LCBbY29tcG9uZW50TmFtZSwgc3RvcmVSZWYsIHVuc3Vic2NyaWJlRnJvbSwgdXBkYXRlU3RhdGVdKTtcclxuICByZXR1cm4gdXNlTWVtbyQxKCgpID0+IHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcclxuICAgIGZ1bmN0aW9uIHVzZVNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlKSB7XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlU2V0UmVjb2lsU3RhdGUnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5ld1ZhbHVlT3JVcGRhdGVyID0+IHtcclxuICAgICAgICBzZXRSZWNvaWxWYWx1ZSQyKHN0b3JlUmVmLmN1cnJlbnQsIHJlY29pbFN0YXRlLCBuZXdWYWx1ZU9yVXBkYXRlcik7XHJcbiAgICAgIH07XHJcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlUmVzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlc2V0UmVjb2lsU3RhdGUnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuICgpID0+IHNldFJlY29pbFZhbHVlJDIoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsU3RhdGUsIERFRkFVTFRfVkFMVUUkMik7XHJcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZShyZWNvaWxWYWx1ZSkge1xyXG4gICAgICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWU7XHJcblxyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSwgJ3VzZVJlY29pbFZhbHVlTG9hZGFibGUnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFyZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQuaGFzKHJlY29pbFZhbHVlLmtleSkpIHtcclxuICAgICAgICByZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQgPSBzZXRCeUFkZGluZ1RvU2V0JDIocmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50LCByZWNvaWxWYWx1ZS5rZXkpO1xyXG4gICAgICB9IC8vIFRPRE8gUmVzdG9yZSBvcHRpbWl6YXRpb24gdG8gbWVtb2l6ZSBsb29rdXBcclxuXHJcblxyXG4gICAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpO1xyXG4gICAgICByZXR1cm4gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsVmFsdWUsIHJlYWN0TW9kZSQzKCkuZWFybHkgPyAoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSk7XHJcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUpIHtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBsb2FkYWJsZSA9IHVzZVJlY29pbFZhbHVlTG9hZGFibGUocmVjb2lsVmFsdWUpO1xyXG4gICAgICByZXR1cm4gaGFuZGxlTG9hZGFibGUobG9hZGFibGUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZik7XHJcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlUmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZWNvaWxTdGF0ZScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gW3VzZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcclxuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlKHJlY29pbFN0YXRlKSB7XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlUmVjb2lsU3RhdGVMb2FkYWJsZScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gW3VzZVJlY29pbFZhbHVlTG9hZGFibGUocmVjb2lsU3RhdGUpLCB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSldO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGdldFJlY29pbFZhbHVlOiB1c2VSZWNvaWxWYWx1ZSxcclxuICAgICAgZ2V0UmVjb2lsVmFsdWVMb2FkYWJsZTogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZSxcclxuICAgICAgZ2V0UmVjb2lsU3RhdGU6IHVzZVJlY29pbFN0YXRlLFxyXG4gICAgICBnZXRSZWNvaWxTdGF0ZUxvYWRhYmxlOiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlLFxyXG4gICAgICBnZXRTZXRSZWNvaWxTdGF0ZTogdXNlU2V0UmVjb2lsU3RhdGUsXHJcbiAgICAgIGdldFJlc2V0UmVjb2lsU3RhdGU6IHVzZVJlc2V0UmVjb2lsU3RhdGVcclxuICAgIH07XHJcbiAgfSwgW3JlY29pbFZhbHVlc1VzZWQsIHN0b3JlUmVmXSk7XHJcbn1cclxuXHJcbmNvbnN0IHJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkcgPSB7XHJcbiAgY3VycmVudDogMFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9TWU5DX0VYVEVSTkFMX1NUT1JFKHJlY29pbFZhbHVlKSB7XHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XHJcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7XHJcbiAgY29uc3QgZ2V0U25hcHNob3QgPSB1c2VDYWxsYmFjayQxKCgpID0+IHtcclxuICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTI7XHJcblxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICByZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HLmN1cnJlbnQrKztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XHJcbiAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgIGNvbnN0IHRyZWVTdGF0ZSA9IHJlYWN0TW9kZSQzKCkuZWFybHkgPyAoX3N0b3JlU3RhdGUkbmV4dFRyZWUyID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWUyICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZTIgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcclxuICAgIGNvbnN0IGxvYWRhYmxlID0gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIoc3RvcmUsIHJlY29pbFZhbHVlLCB0cmVlU3RhdGUpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbG9hZGFibGUsXHJcbiAgICAgIGtleTogcmVjb2lsVmFsdWUua2V5XHJcbiAgICB9O1xyXG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsVmFsdWVdKTsgLy8gTWVtb2l6ZSB0aGUgc3RhdGUgdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmVyZW5kZXJzXHJcblxyXG4gIGNvbnN0IG1lbW9pemVQcmV2aW91c1NuYXBzaG90ID0gdXNlQ2FsbGJhY2skMShnZXRTdGF0ZSA9PiB7XHJcbiAgICBsZXQgcHJldlN0YXRlO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgdmFyIF9wcmV2U3RhdGUsIF9wcmV2U3RhdGUyO1xyXG5cclxuICAgICAgY29uc3QgbmV4dFN0YXRlID0gZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIGlmICgoX3ByZXZTdGF0ZSA9IHByZXZTdGF0ZSkgIT09IG51bGwgJiYgX3ByZXZTdGF0ZSAhPT0gdm9pZCAwICYmIF9wcmV2U3RhdGUubG9hZGFibGUuaXMobmV4dFN0YXRlLmxvYWRhYmxlKSAmJiAoKF9wcmV2U3RhdGUyID0gcHJldlN0YXRlKSA9PT0gbnVsbCB8fCBfcHJldlN0YXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ByZXZTdGF0ZTIua2V5KSA9PT0gbmV4dFN0YXRlLmtleSkge1xyXG4gICAgICAgIHJldHVybiBwcmV2U3RhdGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByZXZTdGF0ZSA9IG5leHRTdGF0ZTtcclxuICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcclxuICAgIH07XHJcbiAgfSwgW10pO1xyXG4gIGNvbnN0IGdldE1lbW9pemVkU25hcHNob3QgPSB1c2VNZW1vJDEoKCkgPT4gbWVtb2l6ZVByZXZpb3VzU25hcHNob3QoZ2V0U25hcHNob3QpLCBbZ2V0U25hcHNob3QsIG1lbW9pemVQcmV2aW91c1NuYXBzaG90XSk7XHJcbiAgY29uc3Qgc3Vic2NyaWJlID0gdXNlQ2FsbGJhY2skMShub3RpZnkgPT4ge1xyXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xyXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlLCByZWNvaWxWYWx1ZSwgbm90aWZ5LCBjb21wb25lbnROYW1lKTtcclxuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucmVsZWFzZTtcclxuICB9LCBbc3RvcmVSZWYsIHJlY29pbFZhbHVlLCBjb21wb25lbnROYW1lXSk7XHJcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDEoc3Vic2NyaWJlLCBnZXRNZW1vaXplZFNuYXBzaG90LCAvLyBnZXRTbmFwc2hvdCgpXHJcbiAgZ2V0TWVtb2l6ZWRTbmFwc2hvdCAvLyBnZXRTZXJ2ZXJTbmFwc2hvdCgpIGZvciBTU1Igc3VwcG9ydFxyXG4gICkubG9hZGFibGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfTVVUQUJMRV9TT1VSQ0UocmVjb2lsVmFsdWUpIHtcclxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcclxuICBjb25zdCBnZXRMb2FkYWJsZSA9IHVzZUNhbGxiYWNrJDEoKCkgPT4ge1xyXG4gICAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlMztcclxuXHJcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XHJcbiAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgIGNvbnN0IHRyZWVTdGF0ZSA9IHJlYWN0TW9kZSQzKCkuZWFybHkgPyAoX3N0b3JlU3RhdGUkbmV4dFRyZWUzID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWUzICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZTMgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcclxuICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMihzdG9yZSwgcmVjb2lsVmFsdWUsIHRyZWVTdGF0ZSk7XHJcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZV0pO1xyXG4gIGNvbnN0IGdldExvYWRhYmxlV2l0aFRlc3RpbmcgPSB1c2VDYWxsYmFjayQxKCgpID0+IHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgcmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORy5jdXJyZW50Kys7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGdldExvYWRhYmxlKCk7XHJcbiAgfSwgW2dldExvYWRhYmxlXSk7XHJcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7XHJcbiAgY29uc3Qgc3Vic2NyaWJlID0gdXNlQ2FsbGJhY2skMSgoX3N0b3JlU3RhdGUsIG5vdGlmeSkgPT4ge1xyXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xyXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlLCByZWNvaWxWYWx1ZSwgKCkgPT4ge1xyXG4gICAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vdGlmeSgpO1xyXG4gICAgICB9IC8vIE9ubHkgcmUtcmVuZGVyIGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZC5cclxuICAgICAgLy8gVGhpcyB3aWxsIGV2YWx1YXRlIHRoZSBhdG9tL3NlbGVjdG9yIG5vdyBhcyB3ZWxsIGFzIHdoZW4gdGhlXHJcbiAgICAgIC8vIGNvbXBvbmVudCByZW5kZXJzLCBidXQgdGhhdCBtYXkgaGVscCB3aXRoIHByZWZldGNoaW5nLlxyXG5cclxuXHJcbiAgICAgIGNvbnN0IG5ld0xvYWRhYmxlID0gZ2V0TG9hZGFibGUoKTtcclxuXHJcbiAgICAgIGlmICghcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQuaXMobmV3TG9hZGFibGUpKSB7XHJcbiAgICAgICAgbm90aWZ5KCk7XHJcbiAgICAgIH0gLy8gSWYgdGhlIGNvbXBvbmVudCBpcyBzdXNwZW5kZWQgdGhlbiB0aGUgZWZmZWN0IHNldHRpbmcgcHJldkxvYWRhYmxlUmVmXHJcbiAgICAgIC8vIHdpbGwgbm90IHJ1bi4gIFNvLCBzZXQgdGhlIHByZXZpb3VzIHZhbHVlIGhlcmUgd2hlbiBpdHMgc3Vic2NyaXB0aW9uXHJcbiAgICAgIC8vIGlzIGZpcmVkIHRvIHdha2UgaXQgdXAuICBXZSBjYW4ndCBqdXN0IHJlbHkgb24gdGhpcywgdGhvdWdoLCBiZWNhdXNlXHJcbiAgICAgIC8vIHRoaXMgb25seSBleGVjdXRlcyB3aGVuIGFuIGF0b20vc2VsZWN0b3IgaXMgZGlydHkgYW5kIHRoZSBhdG9tL3NlbGVjdG9yXHJcbiAgICAgIC8vIHBhc3NlZCB0byB0aGUgaG9vayBjYW4gZHluYW1pY2FsbHkgY2hhbmdlLlxyXG5cclxuXHJcbiAgICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbmV3TG9hZGFibGU7XHJcbiAgICB9LCBjb21wb25lbnROYW1lKTtcclxuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucmVsZWFzZTtcclxuICB9LCBbc3RvcmVSZWYsIHJlY29pbFZhbHVlLCBjb21wb25lbnROYW1lLCBnZXRMb2FkYWJsZV0pO1xyXG4gIGNvbnN0IHNvdXJjZSA9IHVzZVJlY29pbE11dGFibGVTb3VyY2UkMSgpO1xyXG5cclxuICBpZiAoc291cmNlID09IG51bGwpIHtcclxuICAgIHRocm93IFJlY29pbF9lcnIoJ1JlY29pbCBob29rcyBtdXN0IGJlIHVzZWQgaW4gY29tcG9uZW50cyBjb250YWluZWQgd2l0aGluIGEgPFJlY29pbFJvb3Q+IGNvbXBvbmVudC4nKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGxvYWRhYmxlID0gdXNlTXV0YWJsZVNvdXJjZSQxKHNvdXJjZSwgZ2V0TG9hZGFibGVXaXRoVGVzdGluZywgc3Vic2NyaWJlKTtcclxuICBjb25zdCBwcmV2TG9hZGFibGVSZWYgPSB1c2VSZWYkNChsb2FkYWJsZSk7XHJcbiAgdXNlRWZmZWN0JDMoKCkgPT4ge1xyXG4gICAgcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQgPSBsb2FkYWJsZTtcclxuICB9KTtcclxuICByZXR1cm4gbG9hZGFibGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUKHJlY29pbFZhbHVlKSB7XHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XHJcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7IC8vIEFjY2Vzc29ycyB0byBnZXQgdGhlIGN1cnJlbnQgc3RhdGVcclxuXHJcbiAgY29uc3QgZ2V0TG9hZGFibGUgPSB1c2VDYWxsYmFjayQxKCgpID0+IHtcclxuICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTQ7XHJcblxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICByZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HLmN1cnJlbnQrKztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XHJcbiAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgIGNvbnN0IHRyZWVTdGF0ZSA9IHJlYWN0TW9kZSQzKCkuZWFybHkgPyAoX3N0b3JlU3RhdGUkbmV4dFRyZWU0ID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWU0ICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZTQgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcclxuICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMihzdG9yZSwgcmVjb2lsVmFsdWUsIHRyZWVTdGF0ZSk7XHJcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZV0pO1xyXG4gIGNvbnN0IGdldFN0YXRlID0gdXNlQ2FsbGJhY2skMSgoKSA9PiAoe1xyXG4gICAgbG9hZGFibGU6IGdldExvYWRhYmxlKCksXHJcbiAgICBrZXk6IHJlY29pbFZhbHVlLmtleVxyXG4gIH0pLCBbZ2V0TG9hZGFibGUsIHJlY29pbFZhbHVlLmtleV0pOyAvLyBNZW1vaXplIHN0YXRlIHNuYXBzaG90c1xyXG5cclxuICBjb25zdCB1cGRhdGVTdGF0ZSA9IHVzZUNhbGxiYWNrJDEocHJldlN0YXRlID0+IHtcclxuICAgIGNvbnN0IG5leHRTdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICByZXR1cm4gcHJldlN0YXRlLmxvYWRhYmxlLmlzKG5leHRTdGF0ZS5sb2FkYWJsZSkgJiYgcHJldlN0YXRlLmtleSA9PT0gbmV4dFN0YXRlLmtleSA/IHByZXZTdGF0ZSA6IG5leHRTdGF0ZTtcclxuICB9LCBbZ2V0U3RhdGVdKTsgLy8gU3Vic2NyaWJlIHRvIFJlY29pbCBzdGF0ZSBjaGFuZ2VzXHJcblxyXG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcclxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMShzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxWYWx1ZSwgX3N0YXRlID0+IHtcclxuICAgICAgc2V0U3RhdGUodXBkYXRlU3RhdGUpO1xyXG4gICAgfSwgY29tcG9uZW50TmFtZSk7IC8vIFVwZGF0ZSBzdGF0ZSBpbiBjYXNlIHdlIGFyZSB1c2luZyBhIGRpZmZlcmVudCBrZXlcclxuXHJcbiAgICBzZXRTdGF0ZSh1cGRhdGVTdGF0ZSk7XHJcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uLnJlbGVhc2U7XHJcbiAgfSwgW2NvbXBvbmVudE5hbWUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZiwgdXBkYXRlU3RhdGVdKTsgLy8gR2V0IHRoZSBjdXJyZW50IHN0YXRlXHJcblxyXG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUkMShnZXRTdGF0ZSk7IC8vIElmIHdlIGNoYW5nZWQga2V5cywgdGhlbiByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgbmV3IGtleS5cclxuICAvLyBUaGlzIGlzIGltcG9ydGFudCBpbiBjYXNlIHRoZSBvbGQga2V5IHdvdWxkIGNhdXNlIHRoZSBjb21wb25lbnQgdG8gc3VzcGVuZC5cclxuICAvLyBXZSBkb24ndCBoYXZlIHRvIHNldCB0aGUgbmV3IHN0YXRlIGhlcmUgc2luY2UgdGhlIHN1YnNjcmliaW5nIGVmZmVjdCBhYm92ZVxyXG4gIC8vIHdpbGwgZG8gdGhhdC5cclxuXHJcbiAgcmV0dXJuIHN0YXRlLmtleSAhPT0gcmVjb2lsVmFsdWUua2V5ID8gZ2V0U3RhdGUoKS5sb2FkYWJsZSA6IHN0YXRlLmxvYWRhYmxlO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX0xFR0FDWShyZWNvaWxWYWx1ZSkge1xyXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xyXG4gIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVN0YXRlJDEoW10pO1xyXG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBSZWNvaWxfdXNlQ29tcG9uZW50TmFtZSgpO1xyXG4gIGNvbnN0IGdldExvYWRhYmxlID0gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XHJcbiAgICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWU1O1xyXG5cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgcmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORy5jdXJyZW50Kys7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xyXG4gICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICBjb25zdCB0cmVlU3RhdGUgPSByZWFjdE1vZGUkMygpLmVhcmx5ID8gKF9zdG9yZVN0YXRlJG5leHRUcmVlNSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlNSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWU1IDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XHJcbiAgICByZXR1cm4gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIoc3RvcmUsIHJlY29pbFZhbHVlLCB0cmVlU3RhdGUpO1xyXG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsVmFsdWVdKTtcclxuICBjb25zdCBsb2FkYWJsZSA9IGdldExvYWRhYmxlKCk7XHJcbiAgY29uc3QgcHJldkxvYWRhYmxlUmVmID0gdXNlUmVmJDQobG9hZGFibGUpO1xyXG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcclxuICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbG9hZGFibGU7XHJcbiAgfSk7XHJcbiAgdXNlRWZmZWN0JDMoKCkgPT4ge1xyXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xyXG4gICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmUsIHJlY29pbFZhbHVlLCBfc3RhdGUgPT4ge1xyXG4gICAgICB2YXIgX3ByZXZMb2FkYWJsZVJlZiRjdXJyO1xyXG5cclxuICAgICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snKSkge1xyXG4gICAgICAgIHJldHVybiBmb3JjZVVwZGF0ZShbXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG5ld0xvYWRhYmxlID0gZ2V0TG9hZGFibGUoKTtcclxuXHJcbiAgICAgIGlmICghKChfcHJldkxvYWRhYmxlUmVmJGN1cnIgPSBwcmV2TG9hZGFibGVSZWYuY3VycmVudCkgIT09IG51bGwgJiYgX3ByZXZMb2FkYWJsZVJlZiRjdXJyICE9PSB2b2lkIDAgJiYgX3ByZXZMb2FkYWJsZVJlZiRjdXJyLmlzKG5ld0xvYWRhYmxlKSkpIHtcclxuICAgICAgICBmb3JjZVVwZGF0ZShuZXdMb2FkYWJsZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbmV3TG9hZGFibGU7XHJcbiAgICB9LCBjb21wb25lbnROYW1lKTtcclxuICAgIC8qKlxyXG4gICAgICogU2luY2Ugd2UncmUgc3Vic2NyaWJpbmcgaW4gYW4gZWZmZWN0IHdlIG5lZWQgdG8gdXBkYXRlIHRvIHRoZSBsYXRlc3RcclxuICAgICAqIHZhbHVlIG9mIHRoZSBhdG9tIHNpbmNlIGl0IG1heSBoYXZlIGNoYW5nZWQgc2luY2Ugd2UgcmVuZGVyZWQuIFdlIGNhblxyXG4gICAgICogZ28gYWhlYWQgYW5kIGRvIHRoYXQgbm93LCB1bmxlc3Mgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIGJhdGNoIC0tXHJcbiAgICAgKiBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBkbyBpdCBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaCwgZHVlIHRvIHRoZVxyXG4gICAgICogZm9sbG93aW5nIGVkZ2UgY2FzZTogU3VwcG9zZSBhbiBhdG9tIGlzIHVwZGF0ZWQgaW4gYW5vdGhlciB1c2VFZmZlY3RcclxuICAgICAqIG9mIHRoaXMgc2FtZSBjb21wb25lbnQuIFRoZW4gdGhlIGZvbGxvd2luZyBzZXF1ZW5jZSBvZiBldmVudHMgb2NjdXI6XHJcbiAgICAgKiAxLiBBdG9tIGlzIHVwZGF0ZWQgYW5kIHN1YnMgZmlyZWQgKGJ1dCB3ZSBtYXkgbm90IGJlIHN1YnNjcmliZWRcclxuICAgICAqICAgIHlldCBkZXBlbmRpbmcgb24gb3JkZXIgb2YgZWZmZWN0cywgc28gd2UgbWlzcyB0aGlzKSBVcGRhdGVkIHZhbHVlXHJcbiAgICAgKiAgICBpcyBub3cgaW4gbmV4dFRyZWUsIGJ1dCBub3QgY3VycmVudFRyZWUuXHJcbiAgICAgKiAyLiBUaGlzIGVmZmVjdCBoYXBwZW5zLiBXZSBzdWJzY3JpYmUgYW5kIHVwZGF0ZS5cclxuICAgICAqIDMuIEZyb20gdGhlIHVwZGF0ZSB3ZSByZS1yZW5kZXIgYW5kIHJlYWQgY3VycmVudFRyZWUsIHdpdGggb2xkIHZhbHVlLlxyXG4gICAgICogNC4gQmF0Y2hlcidzIGVmZmVjdCBzZXRzIGN1cnJlbnRUcmVlIHRvIG5leHRUcmVlLlxyXG4gICAgICogSW4gdGhpcyBzZXF1ZW5jZSB3ZSBtaXNzIHRoZSB1cGRhdGUuIFRvIGF2b2lkIHRoYXQsIGFkZCB0aGUgdXBkYXRlXHJcbiAgICAgKiB0byBxdWV1ZWRDb21wb25lbnRDYWxsYmFjayBpZiBhIGJhdGNoIGlzIGluIHByb2dyZXNzLlxyXG4gICAgICovXHJcblxyXG4gICAgaWYgKHN0b3JlU3RhdGUubmV4dFRyZWUpIHtcclxuICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5xdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRC5wdXNoKCgpID0+IHtcclxuICAgICAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgZm9yY2VVcGRhdGUoW10pO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBfcHJldkxvYWRhYmxlUmVmJGN1cnIyO1xyXG5cclxuICAgICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snKSkge1xyXG4gICAgICAgIHJldHVybiBmb3JjZVVwZGF0ZShbXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG5ld0xvYWRhYmxlID0gZ2V0TG9hZGFibGUoKTtcclxuXHJcbiAgICAgIGlmICghKChfcHJldkxvYWRhYmxlUmVmJGN1cnIyID0gcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQpICE9PSBudWxsICYmIF9wcmV2TG9hZGFibGVSZWYkY3VycjIgIT09IHZvaWQgMCAmJiBfcHJldkxvYWRhYmxlUmVmJGN1cnIyLmlzKG5ld0xvYWRhYmxlKSkpIHtcclxuICAgICAgICBmb3JjZVVwZGF0ZShuZXdMb2FkYWJsZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbmV3TG9hZGFibGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbi5yZWxlYXNlO1xyXG4gIH0sIFtjb21wb25lbnROYW1lLCBnZXRMb2FkYWJsZSwgcmVjb2lsVmFsdWUsIHN0b3JlUmVmXSk7XHJcbiAgcmV0dXJuIGxvYWRhYmxlO1xyXG59XHJcbi8qKlxyXG4gIExpa2UgdXNlUmVjb2lsVmFsdWUoKSwgYnV0IGVpdGhlciByZXR1cm5zIHRoZSB2YWx1ZSBpZiBhdmFpbGFibGUgb3JcclxuICBqdXN0IHVuZGVmaW5lZCBpZiBub3QgYXZhaWxhYmxlIGZvciBhbnkgcmVhc29uLCBzdWNoIGFzIHBlbmRpbmcgb3IgZXJyb3IuXHJcbiovXHJcblxyXG5cclxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZShyZWNvaWxWYWx1ZSkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9yZWFjdC1ob29rc1xyXG4gICAgUmVjb2lsX3VzZVJldGFpbihyZWNvaWxWYWx1ZSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgVFJBTlNJVElPTl9TVVBQT1JUOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVCxcclxuICAgIFNZTkNfRVhURVJOQUxfU1RPUkU6IHVzZVJlY29pbFZhbHVlTG9hZGFibGVfU1lOQ19FWFRFUk5BTF9TVE9SRSxcclxuICAgIE1VVEFCTEVfU09VUkNFOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX01VVEFCTEVfU09VUkNFLFxyXG4gICAgTEVHQUNZOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX0xFR0FDWVxyXG4gIH1bcmVhY3RNb2RlJDMoKS5tb2RlXShyZWNvaWxWYWx1ZSk7XHJcbn1cclxuLyoqXHJcbiAgUmV0dXJucyB0aGUgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIFJlY29pbFZhbHVlLlxyXG4gIElmIHRoZSB2YWx1ZSBpcyBwZW5kaW5nLCBpdCB3aWxsIHRocm93IGEgUHJvbWlzZSB0byBzdXNwZW5kIHRoZSBjb21wb25lbnQsXHJcbiAgaWYgdGhlIHZhbHVlIGlzIGFuIGVycm9yIGl0IHdpbGwgdGhyb3cgaXQgZm9yIHRoZSBuZWFyZXN0IFJlYWN0IGVycm9yIGJvdW5kYXJ5LlxyXG4gIFRoaXMgd2lsbCBhbHNvIHN1YnNjcmliZSB0aGUgY29tcG9uZW50IGZvciBhbnkgdXBkYXRlcyBpbiB0aGUgdmFsdWUuXHJcbiAgKi9cclxuXHJcblxyXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZScpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XHJcbiAgY29uc3QgbG9hZGFibGUgPSB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFZhbHVlKTtcclxuICByZXR1cm4gaGFuZGxlTG9hZGFibGUobG9hZGFibGUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZik7XHJcbn1cclxuLyoqXHJcbiAgUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHRoZSB2YWx1ZSBvZiBhIFJlY29pbFN0YXRlIHRvIGJlIHVwZGF0ZWQsIGJ1dCBkb2VzXHJcbiAgbm90IHN1YnNjcmliZSB0aGUgY29tcG9uZW50IHRvIGNoYW5nZXMgdG8gdGhhdCBSZWNvaWxTdGF0ZS5cclxuKi9cclxuXHJcblxyXG5mdW5jdGlvbiB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VTZXRSZWNvaWxTdGF0ZScpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XHJcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDEobmV3VmFsdWVPclVwZGF0ZXIgPT4ge1xyXG4gICAgc2V0UmVjb2lsVmFsdWUkMihzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxTdGF0ZSwgbmV3VmFsdWVPclVwZGF0ZXIpO1xyXG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsU3RhdGVdKTtcclxufVxyXG4vKipcclxuICBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlc2V0IHRoZSB2YWx1ZSBvZiBhIFJlY29pbFN0YXRlIHRvIGl0cyBkZWZhdWx0XHJcbiovXHJcblxyXG5cclxuZnVuY3Rpb24gdXNlUmVzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZXNldFJlY29pbFN0YXRlJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcclxuICByZXR1cm4gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XHJcbiAgICBzZXRSZWNvaWxWYWx1ZSQyKHN0b3JlUmVmLmN1cnJlbnQsIHJlY29pbFN0YXRlLCBERUZBVUxUX1ZBTFVFJDIpO1xyXG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsU3RhdGVdKTtcclxufVxyXG4vKipcclxuICBFcXVpdmFsZW50IHRvIHVzZVN0YXRlKCkuIEFsbG93cyB0aGUgdmFsdWUgb2YgdGhlIFJlY29pbFN0YXRlIHRvIGJlIHJlYWQgYW5kIHdyaXR0ZW4uXHJcbiAgU3Vic2VxdWVudCB1cGRhdGVzIHRvIHRoZSBSZWNvaWxTdGF0ZSB3aWxsIGNhdXNlIHRoZSBjb21wb25lbnQgdG8gcmUtcmVuZGVyLiBJZiB0aGVcclxuICBSZWNvaWxTdGF0ZSBpcyBwZW5kaW5nLCB0aGlzIHdpbGwgc3VzcGVuZCB0aGUgY29tcG9uZW50IGFuZCBpbml0aWF0ZSB0aGVcclxuICByZXRyaWV2YWwgb2YgdGhlIHZhbHVlLiBJZiBldmFsdWF0aW5nIHRoZSBSZWNvaWxTdGF0ZSByZXN1bHRlZCBpbiBhbiBlcnJvciwgdGhpcyB3aWxsXHJcbiAgdGhyb3cgdGhlIGVycm9yIHNvIHRoYXQgdGhlIG5lYXJlc3QgUmVhY3QgZXJyb3IgYm91bmRhcnkgY2FuIGNhdGNoIGl0LlxyXG4qL1xyXG5cclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbFN0YXRlKHJlY29pbFN0YXRlKSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlY29pbFN0YXRlJyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gW3VzZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcclxufVxyXG4vKipcclxuICBMaWtlIHVzZVJlY29pbFN0YXRlKCksIGJ1dCBkb2VzIG5vdCBjYXVzZSBTdXNwZW5zZSBvciBSZWFjdCBlcnJvciBoYW5kbGluZy4gUmV0dXJuc1xyXG4gIGFuIG9iamVjdCB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBSZWNvaWxTdGF0ZSBpcyBhdmFpbGFibGUsIHBlbmRpbmcsIG9yXHJcbiAgdW5hdmFpbGFibGUgZHVlIHRvIGFuIGVycm9yLlxyXG4qL1xyXG5cclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbFN0YXRlTG9hZGFibGUocmVjb2lsU3RhdGUpIHtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlUmVjb2lsU3RhdGVMb2FkYWJsZScpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFt1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzKCkge1xyXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xyXG4gIHJldHVybiAodmFsdWVzLCB0cmFuc2FjdGlvbk1ldGFkYXRhID0ge30pID0+IHtcclxuICAgIGJhdGNoVXBkYXRlcyQyKCgpID0+IHtcclxuICAgICAgc3RvcmVSZWYuY3VycmVudC5hZGRUcmFuc2FjdGlvbk1ldGFkYXRhKHRyYW5zYWN0aW9uTWV0YWRhdGEpO1xyXG4gICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gc2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZSQyKHN0b3JlUmVmLmN1cnJlbnQsIG5ldyBBYnN0cmFjdFJlY29pbFZhbHVlJDMoa2V5KSwgdmFsdWUpKTtcclxuICAgIH0pO1xyXG4gIH07XHJcbn1cclxuLyoqXHJcbiAqIEV4cGVyaW1lbnRhbCB2YXJpYW50cyBvZiBob29rcyB3aXRoIHN1cHBvcnQgZm9yIHVzZVRyYW5zaXRpb24oKVxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRShyZWNvaWxWYWx1ZSkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRScpO1xyXG5cclxuICAgIGlmICghcmVhY3RNb2RlJDMoKS5lYXJseSkge1xyXG4gICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ0F0dGVwbXQgdG8gdXNlIGEgaG9vayB3aXRoIFVOU1RBQkxFX1RSQU5TSVRJT05fU1VQUE9SVCBpbiBhIHJlbmRlcmluZyBtb2RlIGluY29tcGF0aWJsZSB3aXRoIGNvbmN1cnJlbnQgcmVuZGVyaW5nLiAgVHJ5IGVuYWJsaW5nIHRoZSByZWNvaWxfc3luY19leHRlcm5hbF9zdG9yZSBvciByZWNvaWxfdHJhbnNpdGlvbl9zdXBwb3J0IEdLcy4nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L3JlYWN0LWhvb2tzXHJcbiAgICBSZWNvaWxfdXNlUmV0YWluKHJlY29pbFZhbHVlKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVChyZWNvaWxWYWx1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRShyZWNvaWxWYWx1ZSkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUnKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xyXG4gIGNvbnN0IGxvYWRhYmxlID0gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsVmFsdWUpO1xyXG4gIHJldHVybiBoYW5kbGVMb2FkYWJsZShsb2FkYWJsZSwgcmVjb2lsVmFsdWUsIHN0b3JlUmVmKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFKHJlY29pbFN0YXRlKSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRScpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFt1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsU3RhdGUpLCB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSldO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX0hvb2tzID0ge1xyXG4gIHJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkcsXHJcbiAgdXNlUmVjb2lsSW50ZXJmYWNlOiB1c2VSZWNvaWxJbnRlcmZhY2VfREVQUkVDQVRFRCxcclxuICB1c2VSZWNvaWxTdGF0ZSxcclxuICB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlLFxyXG4gIHVzZVJlY29pbFZhbHVlLFxyXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGUsXHJcbiAgdXNlUmVzZXRSZWNvaWxTdGF0ZSxcclxuICB1c2VTZXRSZWNvaWxTdGF0ZSxcclxuICB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMsXHJcbiAgdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUsXHJcbiAgdXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFLFxyXG4gIHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYSBtYXAgY29udGFpbmluZyBhbGwgb2YgdGhlIGtleXMgKyB2YWx1ZXMgZnJvbSB0aGUgb3JpZ2luYWwgbWFwIHdoZXJlXHJcbiAqIHRoZSBnaXZlbiBjYWxsYmFjayByZXR1cm5lZCB0cnVlLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGZpbHRlck1hcChtYXAsIGNhbGxiYWNrKSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xyXG5cclxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXApIHtcclxuICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5KSkge1xyXG4gICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxudmFyIFJlY29pbF9maWx0ZXJNYXAgPSBmaWx0ZXJNYXA7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBhIHNldCBjb250YWluaW5nIGFsbCBvZiB0aGUgdmFsdWVzIGZyb20gdGhlIG9yaWdpbmFsIHNldCB3aGVyZVxyXG4gKiB0aGUgZ2l2ZW4gY2FsbGJhY2sgcmV0dXJuZWQgdHJ1ZS5cclxuICovXHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJTZXQoc2V0LCBjYWxsYmFjaykge1xyXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcclxuXHJcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBzZXQpIHtcclxuICAgIGlmIChjYWxsYmFjayh2YWx1ZSkpIHtcclxuICAgICAgcmVzdWx0LmFkZCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG52YXIgUmVjb2lsX2ZpbHRlclNldCA9IGZpbHRlclNldDtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcblxyXG5mdW5jdGlvbiBtZXJnZU1hcHMoLi4ubWFwcykge1xyXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBpdGVyYXRvciA9IG1hcHNbaV0ua2V5cygpO1xyXG4gICAgbGV0IG5leHRLZXk7XHJcblxyXG4gICAgd2hpbGUgKCEobmV4dEtleSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xyXG4gICAgICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1jYWxsXSAtIG1hcC9pdGVyYXRvciBrbm93cyBub3RoaW5nIGFib3V0IGZsb3cgdHlwZXNcclxuICAgICAgcmVzdWx0LnNldChuZXh0S2V5LnZhbHVlLCBtYXBzW2ldLmdldChuZXh0S2V5LnZhbHVlKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG52YXIgUmVjb2lsX21lcmdlTWFwcyA9IG1lcmdlTWFwcztcclxuXHJcbmNvbnN0IHtcclxuICBiYXRjaFVwZGF0ZXM6IGJhdGNoVXBkYXRlcyQzXHJcbn0gPSBSZWNvaWxfQmF0Y2hpbmc7XHJcblxyXG5jb25zdCB7XHJcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQzLFxyXG4gIGdldE5vZGU6IGdldE5vZGUkNCxcclxuICBub2Rlczogbm9kZXMkMVxyXG59ID0gUmVjb2lsX05vZGU7XHJcblxyXG5jb25zdCB7XHJcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDNcclxufSA9IFJlY29pbF9SZWNvaWxSb290O1xyXG5cclxuY29uc3Qge1xyXG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkNCxcclxuICBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlOiBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlJDFcclxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcclxuXHJcbmNvbnN0IHtcclxuICBTVVNQRU5TRV9USU1FT1VUX01TOiBTVVNQRU5TRV9USU1FT1VUX01TJDJcclxufSA9IFJlY29pbF9SZXRlbnRpb247XHJcblxyXG5jb25zdCB7XHJcbiAgY2xvbmVTbmFwc2hvdDogY2xvbmVTbmFwc2hvdCQxXHJcbn0gPSBSZWNvaWxfU25hcHNob3QkMTtcclxuXHJcbmNvbnN0IHtcclxuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2skMixcclxuICB1c2VFZmZlY3Q6IHVzZUVmZmVjdCQ0LFxyXG4gIHVzZVJlZjogdXNlUmVmJDUsXHJcbiAgdXNlU3RhdGU6IHVzZVN0YXRlJDJcclxufSA9IHJlYWN0O1xyXG5cclxuY29uc3Qge1xyXG4gIGlzU1NSOiBpc1NTUiQzXHJcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIHVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uKGNhbGxiYWNrKSB7XHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQzKCk7XHJcbiAgdXNlRWZmZWN0JDQoKCkgPT4ge1xyXG4gICAgY29uc3Qgc3ViID0gc3RvcmVSZWYuY3VycmVudC5zdWJzY3JpYmVUb1RyYW5zYWN0aW9ucyhjYWxsYmFjayk7XHJcbiAgICByZXR1cm4gc3ViLnJlbGVhc2U7XHJcbiAgfSwgW2NhbGxiYWNrLCBzdG9yZVJlZl0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBleHRlcm5hbGx5VmlzaWJsZUF0b21WYWx1ZXNJblN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgYXRvbVZhbHVlcyA9IHN0YXRlLmF0b21WYWx1ZXMudG9NYXAoKTtcclxuICBjb25zdCBwZXJzaXN0ZWRBdG9tQ29udGVudHNWYWx1ZXMgPSBSZWNvaWxfbWFwTWFwKFJlY29pbF9maWx0ZXJNYXAoYXRvbVZhbHVlcywgKHYsIGspID0+IHtcclxuICAgIGNvbnN0IG5vZGUgPSBnZXROb2RlJDQoayk7XHJcbiAgICBjb25zdCBwZXJzaXN0ZW5jZSA9IG5vZGUucGVyc2lzdGVuY2VfVU5TVEFCTEU7XHJcbiAgICByZXR1cm4gcGVyc2lzdGVuY2UgIT0gbnVsbCAmJiBwZXJzaXN0ZW5jZS50eXBlICE9PSAnbm9uZScgJiYgdi5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJztcclxuICB9KSwgdiA9PiB2LmNvbnRlbnRzKTsgLy8gTWVyZ2UgaW4gbm9udmFsaWRhdGVkIGF0b21zOyB3ZSBtYXkgbm90IGhhdmUgZGVmcyBmb3IgdGhlbSBidXQgdGhleSB3aWxsXHJcbiAgLy8gYWxsIGhhdmUgcGVyc2lzdGVuY2Ugb24gb3IgdGhleSB3b3VsZG4ndCBiZSB0aGVyZSBpbiB0aGUgZmlyc3QgcGxhY2UuXHJcblxyXG4gIHJldHVybiBSZWNvaWxfbWVyZ2VNYXBzKHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLnRvTWFwKCksIHBlcnNpc3RlZEF0b21Db250ZW50c1ZhbHVlcyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gIENhbGxzIHRoZSBnaXZlbiBjYWxsYmFjayBhZnRlciBhbnkgYXRvbXMgaGF2ZSBiZWVuIG1vZGlmaWVkIGFuZCB0aGUgY29uc2VxdWVudFxyXG4gIGNvbXBvbmVudCByZS1yZW5kZXJzIGhhdmUgYmVlbiBjb21taXR0ZWQuIFRoaXMgaXMgaW50ZW5kZWQgZm9yIHBlcnNpc3RpbmdcclxuICB0aGUgdmFsdWVzIG9mIHRoZSBhdG9tcyB0byBzdG9yYWdlLiBUaGUgc3RvcmVkIHZhbHVlcyBjYW4gdGhlbiBiZSByZXN0b3JlZFxyXG4gIHVzaW5nIHRoZSB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMgaG9vay5cclxuXHJcbiAgVGhlIGNhbGxiYWNrIHJlY2VpdmVzIHRoZSBmb2xsb3dpbmcgaW5mbzpcclxuXHJcbiAgYXRvbVZhbHVlczogVGhlIGN1cnJlbnQgdmFsdWUgb2YgZXZlcnkgYXRvbSB0aGF0IGlzIGJvdGggcGVyc2lzdGFibGUgKHBlcnNpc3RlbmNlXHJcbiAgICAgICAgICAgICAgdHlwZSBub3Qgc2V0IHRvICdub25lJykgYW5kIHdob3NlIHZhbHVlIGlzIGF2YWlsYWJsZSAobm90IGluIGFuXHJcbiAgICAgICAgICAgICAgZXJyb3Igb3IgbG9hZGluZyBzdGF0ZSkuXHJcblxyXG4gIHByZXZpb3VzQXRvbVZhbHVlczogVGhlIHZhbHVlIG9mIGV2ZXJ5IHBlcnNpc3RhYmxlIGFuZCBhdmFpbGFibGUgYXRvbSBiZWZvcmVcclxuICAgICAgICAgICAgICAgdGhlIHRyYW5zYWN0aW9uIGJlZ2FuLlxyXG5cclxuICBhdG9tSW5mbzogQSBtYXAgY29udGFpbmluZyB0aGUgcGVyc2lzdGVuY2Ugc2V0dGluZ3MgZm9yIGVhY2ggYXRvbS4gRXZlcnkga2V5XHJcbiAgICAgICAgICAgIHRoYXQgZXhpc3RzIGluIGF0b21WYWx1ZXMgd2lsbCBhbHNvIGV4aXN0IGluIGF0b21JbmZvLlxyXG5cclxuICBtb2RpZmllZEF0b21zOiBUaGUgc2V0IG9mIGF0b21zIHRoYXQgd2VyZSB3cml0dGVuIHRvIGR1cmluZyB0aGUgdHJhbnNhY3Rpb24uXHJcblxyXG4gIHRyYW5zYWN0aW9uTWV0YWRhdGE6IEFyYml0cmFyeSBpbmZvcm1hdGlvbiB0aGF0IHdhcyBhZGRlZCB2aWEgdGhlXHJcbiAgICAgICAgICB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMgaG9vay4gVXNlZnVsIGZvciBpZ25vcmluZyB0aGUgdXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzXHJcbiAgICAgICAgICB0cmFuc2FjdGlvbiwgdG8gYXZvaWQgbG9vcHMuXHJcbiovXHJcbmZ1bmN0aW9uIHVzZVRyYW5zYWN0aW9uT2JzZXJ2YXRpb25fREVQUkVDQVRFRChjYWxsYmFjaykge1xyXG4gIHVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uKHVzZUNhbGxiYWNrJDIoc3RvcmUgPT4ge1xyXG4gICAgbGV0IHByZXZpb3VzVHJlZSA9IHN0b3JlLmdldFN0YXRlKCkucHJldmlvdXNUcmVlO1xyXG4gICAgY29uc3QgY3VycmVudFRyZWUgPSBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xyXG5cclxuICAgIGlmICghcHJldmlvdXNUcmVlKSB7XHJcbiAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignVHJhbnNhY3Rpb24gc3Vic2NyaWJlcnMgbm90aWZpZWQgd2l0aG91dCBhIHByZXZpb3VzIHRyZWUgYmVpbmcgcHJlc2VudCAtLSB0aGlzIGlzIGEgYnVnIGluIFJlY29pbCcpO1xyXG4gICAgICBwcmV2aW91c1RyZWUgPSBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlOyAvLyBhdHRlbXB0IHRvIHRydW5kbGUgb25cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhdG9tVmFsdWVzID0gZXh0ZXJuYWxseVZpc2libGVBdG9tVmFsdWVzSW5TdGF0ZShjdXJyZW50VHJlZSk7XHJcbiAgICBjb25zdCBwcmV2aW91c0F0b21WYWx1ZXMgPSBleHRlcm5hbGx5VmlzaWJsZUF0b21WYWx1ZXNJblN0YXRlKHByZXZpb3VzVHJlZSk7XHJcbiAgICBjb25zdCBhdG9tSW5mbyA9IFJlY29pbF9tYXBNYXAobm9kZXMkMSwgbm9kZSA9PiB7XHJcbiAgICAgIHZhciBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMsIF9ub2RlJHBlcnNpc3RlbmNlX1VOUzIsIF9ub2RlJHBlcnNpc3RlbmNlX1VOUzMsIF9ub2RlJHBlcnNpc3RlbmNlX1VOUzQ7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHBlcnNpc3RlbmNlX1VOU1RBQkxFOiB7XHJcbiAgICAgICAgICB0eXBlOiAoX25vZGUkcGVyc2lzdGVuY2VfVU5TID0gKF9ub2RlJHBlcnNpc3RlbmNlX1VOUzIgPSBub2RlLnBlcnNpc3RlbmNlX1VOU1RBQkxFKSA9PT0gbnVsbCB8fCBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMyLnR5cGUpICE9PSBudWxsICYmIF9ub2RlJHBlcnNpc3RlbmNlX1VOUyAhPT0gdm9pZCAwID8gX25vZGUkcGVyc2lzdGVuY2VfVU5TIDogJ25vbmUnLFxyXG4gICAgICAgICAgYmFja0J1dHRvbjogKF9ub2RlJHBlcnNpc3RlbmNlX1VOUzMgPSAoX25vZGUkcGVyc2lzdGVuY2VfVU5TNCA9IG5vZGUucGVyc2lzdGVuY2VfVU5TVEFCTEUpID09PSBudWxsIHx8IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzQuYmFja0J1dHRvbikgIT09IG51bGwgJiYgX25vZGUkcGVyc2lzdGVuY2VfVU5TMyAhPT0gdm9pZCAwID8gX25vZGUkcGVyc2lzdGVuY2VfVU5TMyA6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSk7IC8vIEZpbHRlciBvbiBleGlzdGFuY2UgaW4gYXRvbVZhbHVlcyBzbyB0aGF0IGV4dGVybmFsbHktdmlzaWJsZSBydWxlc1xyXG4gICAgLy8gYXJlIGFsc28gYXBwbGllZCB0byBtb2RpZmllZCBhdG9tcyAoc3BlY2lmaWNhbGx5IGV4Y2x1ZGUgc2VsZWN0b3JzKTpcclxuXHJcbiAgICBjb25zdCBtb2RpZmllZEF0b21zID0gUmVjb2lsX2ZpbHRlclNldChjdXJyZW50VHJlZS5kaXJ0eUF0b21zLCBrID0+IGF0b21WYWx1ZXMuaGFzKGspIHx8IHByZXZpb3VzQXRvbVZhbHVlcy5oYXMoaykpO1xyXG4gICAgY2FsbGJhY2soe1xyXG4gICAgICBhdG9tVmFsdWVzLFxyXG4gICAgICBwcmV2aW91c0F0b21WYWx1ZXMsXHJcbiAgICAgIGF0b21JbmZvLFxyXG4gICAgICBtb2RpZmllZEF0b21zLFxyXG4gICAgICB0cmFuc2FjdGlvbk1ldGFkYXRhOiB7IC4uLmN1cnJlbnRUcmVlLnRyYW5zYWN0aW9uTWV0YWRhdGFcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSwgW2NhbGxiYWNrXSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XHJcbiAgdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb24odXNlQ2FsbGJhY2skMihzdG9yZSA9PiB7XHJcbiAgICBjb25zdCBzbmFwc2hvdCA9IGNsb25lU25hcHNob3QkMShzdG9yZSwgJ2xhdGVzdCcpO1xyXG4gICAgY29uc3QgcHJldmlvdXNTbmFwc2hvdCA9IGNsb25lU25hcHNob3QkMShzdG9yZSwgJ3ByZXZpb3VzJyk7XHJcbiAgICBjYWxsYmFjayh7XHJcbiAgICAgIHNuYXBzaG90LFxyXG4gICAgICBwcmV2aW91c1NuYXBzaG90XHJcbiAgICB9KTtcclxuICB9LCBbY2FsbGJhY2tdKSk7XHJcbn0gLy8gUmV0dXJuIGEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHN1YnNjcmliZSB0byBhbGwgc3RhdGUgY2hhbmdlc1xyXG5cclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbFNuYXBzaG90KCkge1xyXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMygpO1xyXG4gIGNvbnN0IFtzbmFwc2hvdCwgc2V0U25hcHNob3RdID0gdXNlU3RhdGUkMigoKSA9PiBjbG9uZVNuYXBzaG90JDEoc3RvcmVSZWYuY3VycmVudCkpO1xyXG4gIGNvbnN0IHByZXZpb3VzU25hcHNob3QgPSBSZWNvaWxfdXNlUHJldmlvdXMoc25hcHNob3QpO1xyXG4gIGNvbnN0IHRpbWVvdXRJRCA9IHVzZVJlZiQ1KCk7XHJcbiAgY29uc3QgcmVsZWFzZVJlZiA9IHVzZVJlZiQ1KCk7XHJcbiAgdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb24odXNlQ2FsbGJhY2skMihzdG9yZSA9PiBzZXRTbmFwc2hvdChjbG9uZVNuYXBzaG90JDEoc3RvcmUpKSwgW10pKTsgLy8gUmV0YWluIHNuYXBzaG90IGZvciBkdXJhdGlvbiBjb21wb25lbnQgaXMgbW91bnRlZFxyXG5cclxuICB1c2VFZmZlY3QkNCgoKSA9PiB7XHJcbiAgICBjb25zdCByZWxlYXNlID0gc25hcHNob3QucmV0YWluKCk7IC8vIFJlbGVhc2UgdGhlIHJldGFpbiBmcm9tIHRoZSByZW5kZXJpbmcgY2FsbFxyXG5cclxuICAgIGlmICh0aW1lb3V0SUQuY3VycmVudCAmJiAhaXNTU1IkMykge1xyXG4gICAgICB2YXIgX3JlbGVhc2VSZWYkY3VycmVudDtcclxuXHJcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElELmN1cnJlbnQpO1xyXG4gICAgICB0aW1lb3V0SUQuY3VycmVudCA9IG51bGw7XHJcbiAgICAgIChfcmVsZWFzZVJlZiRjdXJyZW50ID0gcmVsZWFzZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfcmVsZWFzZVJlZiRjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsZWFzZVJlZiRjdXJyZW50LmNhbGwocmVsZWFzZVJlZik7XHJcbiAgICAgIHJlbGVhc2VSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgLy8gRGVmZXIgdGhlIHJlbGVhc2UuICBJZiBcIkZhc3QgUmVmcmVzaFwiXCIgaXMgdXNlZCB0aGVuIHRoZSBjb21wb25lbnQgbWF5XHJcbiAgICAgIC8vIHJlLXJlbmRlciB3aXRoIHRoZSBzYW1lIHN0YXRlLiAgVGhlIHByZXZpb3VzIGNsZWFudXAgd2lsbCB0aGVuIHJ1biBhbmRcclxuICAgICAgLy8gdGhlbiB0aGUgbmV3IGVmZmVjdCB3aWxsIHJ1bi4gV2UgZG9uJ3Qgd2FudCB0aGUgc25hcHNob3QgdG8gYmUgcmVsZWFzZWRcclxuICAgICAgLy8gYnkgdGhhdCBjbGVhbnVwIGJlZm9yZSB0aGUgbmV3IGVmZmVjdCBoYXMgYSBjaGFuY2UgdG8gcmV0YWluIGl0IGFnYWluLlxyXG4gICAgICAvLyBVc2UgdGltZW91dCBvZiAxMCB0byB3b3JrYXJvdW5kIEZpcmVmb3ggaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2V4cGVyaW1lbnRhbC9SZWNvaWwvaXNzdWVzLzE5MzZcclxuICAgICAgd2luZG93LnNldFRpbWVvdXQocmVsZWFzZSwgMTApO1xyXG4gICAgfTtcclxuICB9LCBbc25hcHNob3RdKTsgLy8gUmV0YWluIHNuYXBzaG90IHVudGlsIGFib3ZlIGVmZmVjdCBpcyBydW4uXHJcbiAgLy8gUmVsZWFzZSBhZnRlciBhIHRocmVzaG9sZCBpbiBjYXNlIGNvbXBvbmVudCBpcyBzdXNwZW5kZWQuXHJcblxyXG4gIGlmIChwcmV2aW91c1NuYXBzaG90ICE9PSBzbmFwc2hvdCAmJiAhaXNTU1IkMykge1xyXG4gICAgLy8gUmVsZWFzZSB0aGUgcHJldmlvdXMgc25hcHNob3RcclxuICAgIGlmICh0aW1lb3V0SUQuY3VycmVudCkge1xyXG4gICAgICB2YXIgX3JlbGVhc2VSZWYkY3VycmVudDI7XHJcblxyXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcclxuICAgICAgdGltZW91dElELmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAoX3JlbGVhc2VSZWYkY3VycmVudDIgPSByZWxlYXNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9yZWxlYXNlUmVmJGN1cnJlbnQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsZWFzZVJlZiRjdXJyZW50Mi5jYWxsKHJlbGVhc2VSZWYpO1xyXG4gICAgICByZWxlYXNlUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbGVhc2VSZWYuY3VycmVudCA9IHNuYXBzaG90LnJldGFpbigpO1xyXG4gICAgdGltZW91dElELmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHZhciBfcmVsZWFzZVJlZiRjdXJyZW50MztcclxuXHJcbiAgICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgKF9yZWxlYXNlUmVmJGN1cnJlbnQzID0gcmVsZWFzZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfcmVsZWFzZVJlZiRjdXJyZW50MyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbGVhc2VSZWYkY3VycmVudDMuY2FsbChyZWxlYXNlUmVmKTtcclxuICAgICAgcmVsZWFzZVJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgIH0sIFNVU1BFTlNFX1RJTUVPVVRfTVMkMik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc25hcHNob3Q7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdvdG9TbmFwc2hvdChzdG9yZSwgc25hcHNob3QpIHtcclxuICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWU7XHJcblxyXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG4gIGNvbnN0IHByZXYgPSAoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xyXG4gIGNvbnN0IG5leHQgPSBzbmFwc2hvdC5nZXRTdG9yZV9JTlRFUk5BTCgpLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XHJcbiAgYmF0Y2hVcGRhdGVzJDMoKCkgPT4ge1xyXG4gICAgY29uc3Qga2V5c1RvVXBkYXRlID0gbmV3IFNldCgpO1xyXG5cclxuICAgIGZvciAoY29uc3Qga2V5cyBvZiBbcHJldi5hdG9tVmFsdWVzLmtleXMoKSwgbmV4dC5hdG9tVmFsdWVzLmtleXMoKV0pIHtcclxuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xyXG4gICAgICAgIHZhciBfcHJldiRhdG9tVmFsdWVzJGdldCwgX25leHQkYXRvbVZhbHVlcyRnZXQ7XHJcblxyXG4gICAgICAgIGlmICgoKF9wcmV2JGF0b21WYWx1ZXMkZ2V0ID0gcHJldi5hdG9tVmFsdWVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfcHJldiRhdG9tVmFsdWVzJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ByZXYkYXRvbVZhbHVlcyRnZXQuY29udGVudHMpICE9PSAoKF9uZXh0JGF0b21WYWx1ZXMkZ2V0ID0gbmV4dC5hdG9tVmFsdWVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfbmV4dCRhdG9tVmFsdWVzJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25leHQkYXRvbVZhbHVlcyRnZXQuY29udGVudHMpICYmIGdldE5vZGUkNChrZXkpLnNob3VsZFJlc3RvcmVGcm9tU25hcHNob3RzKSB7XHJcbiAgICAgICAgICBrZXlzVG9VcGRhdGUuYWRkKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAga2V5c1RvVXBkYXRlLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQxKHN0b3JlLCBuZXcgQWJzdHJhY3RSZWNvaWxWYWx1ZSQ0KGtleSksIG5leHQuYXRvbVZhbHVlcy5oYXMoa2V5KSA/IFJlY29pbF9udWxsdGhyb3dzKG5leHQuYXRvbVZhbHVlcy5nZXQoa2V5KSkgOiBERUZBVUxUX1ZBTFVFJDMpO1xyXG4gICAgfSk7XHJcbiAgICBzdG9yZS5yZXBsYWNlU3RhdGUoc3RhdGUgPT4gKHsgLi4uc3RhdGUsXHJcbiAgICAgIHN0YXRlSUQ6IHNuYXBzaG90LmdldElEKClcclxuICAgIH0pKTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXNlR290b1JlY29pbFNuYXBzaG90KCkge1xyXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMygpO1xyXG4gIHJldHVybiB1c2VDYWxsYmFjayQyKHNuYXBzaG90ID0+IGdvdG9TbmFwc2hvdChzdG9yZVJlZi5jdXJyZW50LCBzbmFwc2hvdCksIFtzdG9yZVJlZl0pO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX1NuYXBzaG90SG9va3MgPSB7XHJcbiAgdXNlUmVjb2lsU25hcHNob3QsXHJcbiAgZ290b1NuYXBzaG90LFxyXG4gIHVzZUdvdG9SZWNvaWxTbmFwc2hvdCxcclxuICB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyLFxyXG4gIHVzZVRyYW5zYWN0aW9uT2JzZXJ2YXRpb25fREVQUkVDQVRFRCxcclxuICB1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvbl9ERVBSRUNBVEVEOiB1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvblxyXG59O1xyXG5cclxuY29uc3Qge1xyXG4gIHBlZWtOb2RlSW5mbzogcGVla05vZGVJbmZvJDJcclxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcclxuXHJcbmNvbnN0IHtcclxuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkNFxyXG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XHJcblxyXG5mdW5jdGlvbiB1c2VHZXRSZWNvaWxWYWx1ZUluZm8oKSB7XHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQ0KCk7XHJcbiAgcmV0dXJuICh7XHJcbiAgICBrZXlcclxuICB9KSA9PiBwZWVrTm9kZUluZm8kMihzdG9yZVJlZi5jdXJyZW50LCBzdG9yZVJlZi5jdXJyZW50LmdldFN0YXRlKCkuY3VycmVudFRyZWUsIGtleSk7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfdXNlR2V0UmVjb2lsVmFsdWVJbmZvID0gdXNlR2V0UmVjb2lsVmFsdWVJbmZvO1xyXG5cclxuY29uc3Qge1xyXG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDRcclxufSA9IFJlY29pbF9SZWFjdE1vZGU7XHJcblxyXG5jb25zdCB7XHJcbiAgUmVjb2lsUm9vdDogUmVjb2lsUm9vdCQxLFxyXG4gIHVzZVN0b3JlUmVmOiB1c2VTdG9yZVJlZiQ1XHJcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcclxuXHJcblxyXG5cclxuY29uc3Qge1xyXG4gIHVzZU1lbW86IHVzZU1lbW8kMlxyXG59ID0gcmVhY3Q7XHJcblxyXG5mdW5jdGlvbiB1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzKCkge1xyXG4gIC8vIFRoZSB0ZXN0IGZhaWxzIHdoZW4gdXNpbmcgdXNlTXV0YWJsZVNvdXJjZSgpLCBidXQgb25seSBpZiBhY3QoKSBpcyB1c2VkXHJcbiAgLy8gZm9yIHRoZSBuZXN0ZWQgcm9vdC4gIFNvLCB0aGlzIG1heSBvbmx5IGJlIGEgdGVzdGluZyBlbnZpcm9ubWVudCBpc3N1ZS5cclxuICBpZiAocmVhY3RNb2RlJDQoKS5tb2RlID09PSAnTVVUQUJMRV9TT1VSQ0UnKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L25vLWNvbnNvbGVcclxuICAgIGNvbnNvbGUud2FybignV2FybmluZzogVGhlcmUgYXJlIGtub3duIGlzc3VlcyB1c2luZyB1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzKCkgaW4gcmVjb2lsX211dGFibGVfc291cmNlIHJlbmRlcmluZyBtb2RlLiAgUGxlYXNlIGNvbnNpZGVyIHVwZ3JhZGluZyB0byByZWNvaWxfc3luY19leHRlcm5hbF9zdG9yZSBtb2RlLicpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZVJlZiQ1KCkuY3VycmVudDtcclxuICByZXR1cm4gdXNlTWVtbyQyKCgpID0+IHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcclxuICAgIGZ1bmN0aW9uIFJlY29pbEJyaWRnZSh7XHJcbiAgICAgIGNoaWxkcmVuXHJcbiAgICB9KSB7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChSZWNvaWxSb290JDEsIHtcclxuICAgICAgICBzdG9yZV9JTlRFUk5BTDogc3RvcmVcclxuICAgICAgfSwgY2hpbGRyZW4pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBSZWNvaWxCcmlkZ2U7XHJcbiAgfSwgW3N0b3JlXSk7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cyA9IHVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHM7XHJcblxyXG5jb25zdCB7XHJcbiAgbG9hZGFibGVXaXRoVmFsdWU6IGxvYWRhYmxlV2l0aFZhbHVlJDFcclxufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xyXG5cclxuY29uc3Qge1xyXG4gIGluaXRpYWxpemVOb2RlOiBpbml0aWFsaXplTm9kZSQzXHJcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XHJcblxyXG5jb25zdCB7XHJcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQ0LFxyXG4gIGdldE5vZGU6IGdldE5vZGUkNVxyXG59ID0gUmVjb2lsX05vZGU7XHJcblxyXG5jb25zdCB7XHJcbiAgY29weVRyZWVTdGF0ZTogY29weVRyZWVTdGF0ZSQxLFxyXG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZTogZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDMsXHJcbiAgaW52YWxpZGF0ZURvd25zdHJlYW1zOiBpbnZhbGlkYXRlRG93bnN0cmVhbXMkMSxcclxuICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGU6IHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZSQxXHJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGlzQXRvbShyZWNvaWxWYWx1ZSkge1xyXG4gIHJldHVybiBnZXROb2RlJDUocmVjb2lsVmFsdWUua2V5KS5ub2RlVHlwZSA9PT0gJ2F0b20nO1xyXG59XHJcblxyXG5jbGFzcyBUcmFuc2FjdGlvbkludGVyZmFjZUltcGwge1xyXG4gIGNvbnN0cnVjdG9yKHN0b3JlLCB0cmVlU3RhdGUpIHtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdG9yZVwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90cmVlU3RhdGVcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2hhbmdlc1wiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFwiLCByZWNvaWxWYWx1ZSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLl9jaGFuZ2VzLmhhcyhyZWNvaWxWYWx1ZS5rZXkpKSB7XHJcbiAgICAgICAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VzLmdldChyZWNvaWxWYWx1ZS5rZXkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWlzQXRvbShyZWNvaWxWYWx1ZSkpIHtcclxuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdSZWFkaW5nIHNlbGVjdG9ycyB3aXRoaW4gYXRvbWljVXBkYXRlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbG9hZGFibGUgPSBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMyh0aGlzLl9zdG9yZSwgcmVjb2lsVmFsdWUsIHRoaXMuX3RyZWVTdGF0ZSk7XHJcblxyXG4gICAgICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScpIHtcclxuICAgICAgICByZXR1cm4gbG9hZGFibGUuY29udGVudHM7XHJcbiAgICAgIH0gZWxzZSBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNFcnJvcicpIHtcclxuICAgICAgICB0aHJvdyBsb2FkYWJsZS5jb250ZW50cztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKGBFeHBlY3RlZCBSZWNvaWwgYXRvbSAke3JlY29pbFZhbHVlLmtleX0gdG8gaGF2ZSBhIHZhbHVlLCBidXQgaXQgaXMgaW4gYSBsb2FkaW5nIHN0YXRlLmApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRcIiwgKHJlY29pbFN0YXRlLCB2YWx1ZU9yVXBkYXRlcikgPT4ge1xyXG4gICAgICBpZiAoIWlzQXRvbShyZWNvaWxTdGF0ZSkpIHtcclxuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdTZXR0aW5nIHNlbGVjdG9ycyB3aXRoaW4gYXRvbWljVXBkYXRlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZU9yVXBkYXRlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmdldChyZWNvaWxTdGF0ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2NoYW5nZXMuc2V0KHJlY29pbFN0YXRlLmtleSwgdmFsdWVPclVwZGF0ZXIoY3VycmVudCkpOyAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhdG9tIGFuZCBydW4gZWZmZWN0cyBpZiBub3QgaW5pdGlhbGl6ZWQgeWV0XHJcbiAgICAgICAgaW5pdGlhbGl6ZU5vZGUkMyh0aGlzLl9zdG9yZSwgcmVjb2lsU3RhdGUua2V5LCAnc2V0Jyk7XHJcblxyXG4gICAgICAgIHRoaXMuX2NoYW5nZXMuc2V0KHJlY29pbFN0YXRlLmtleSwgdmFsdWVPclVwZGF0ZXIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNldFwiLCByZWNvaWxTdGF0ZSA9PiB7XHJcbiAgICAgIHRoaXMuc2V0KHJlY29pbFN0YXRlLCBERUZBVUxUX1ZBTFVFJDQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fc3RvcmUgPSBzdG9yZTtcclxuICAgIHRoaXMuX3RyZWVTdGF0ZSA9IHRyZWVTdGF0ZTtcclxuICAgIHRoaXMuX2NoYW5nZXMgPSBuZXcgTWFwKCk7XHJcbiAgfSAvLyBBbGxvdyBkZXN0cnVjdGluZ1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvZXh0cmEtYXJyb3ctaW5pdGlhbGl6ZXJcclxuXHJcblxyXG4gIG5ld1RyZWVTdGF0ZV9JTlRFUk5BTCgpIHtcclxuICAgIGlmICh0aGlzLl9jaGFuZ2VzLnNpemUgPT09IDApIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3RyZWVTdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IGNvcHlUcmVlU3RhdGUkMSh0aGlzLl90cmVlU3RhdGUpO1xyXG5cclxuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHRoaXMuX2NoYW5nZXMpIHtcclxuICAgICAgd3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlJDEobmV3U3RhdGUsIGssIGxvYWRhYmxlV2l0aFZhbHVlJDEodikpO1xyXG4gICAgfVxyXG5cclxuICAgIGludmFsaWRhdGVEb3duc3RyZWFtcyQxKHRoaXMuX3N0b3JlLCBuZXdTdGF0ZSk7XHJcbiAgICByZXR1cm4gbmV3U3RhdGU7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gYXRvbWljVXBkYXRlcihzdG9yZSkge1xyXG4gIHJldHVybiBmbiA9PiB7XHJcbiAgICBzdG9yZS5yZXBsYWNlU3RhdGUodHJlZVN0YXRlID0+IHtcclxuICAgICAgY29uc3QgY2hhbmdlc2V0ID0gbmV3IFRyYW5zYWN0aW9uSW50ZXJmYWNlSW1wbChzdG9yZSwgdHJlZVN0YXRlKTtcclxuICAgICAgZm4oY2hhbmdlc2V0KTtcclxuICAgICAgcmV0dXJuIGNoYW5nZXNldC5uZXdUcmVlU3RhdGVfSU5URVJOQUwoKTtcclxuICAgIH0pO1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfQXRvbWljVXBkYXRlcyA9IHtcclxuICBhdG9taWNVcGRhdGVyXHJcbn07XHJcblxyXG52YXIgUmVjb2lsX0F0b21pY1VwZGF0ZXNfMSA9IFJlY29pbF9BdG9taWNVcGRhdGVzLmF0b21pY1VwZGF0ZXI7XHJcblxyXG52YXIgUmVjb2lsX0F0b21pY1VwZGF0ZXMkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgYXRvbWljVXBkYXRlcjogUmVjb2lsX0F0b21pY1VwZGF0ZXNfMVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcblxyXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcbiAgaWYgKCFjb25kaXRpb24pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBpbnZhcmlhbnRfMSA9IGludmFyaWFudDtcclxuXHJcbi8vIEBvc3Mtb25seVxyXG5cclxuXHJcbnZhciBSZWNvaWxfaW52YXJpYW50ID0gaW52YXJpYW50XzE7XHJcblxyXG5jb25zdCB7XHJcbiAgYXRvbWljVXBkYXRlcjogYXRvbWljVXBkYXRlciQxXHJcbn0gPSBSZWNvaWxfQXRvbWljVXBkYXRlcyQxO1xyXG5cclxuY29uc3Qge1xyXG4gIGJhdGNoVXBkYXRlczogYmF0Y2hVcGRhdGVzJDRcclxufSA9IFJlY29pbF9CYXRjaGluZztcclxuXHJcbmNvbnN0IHtcclxuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDVcclxufSA9IFJlY29pbF9Ob2RlO1xyXG5cclxuY29uc3Qge1xyXG4gIHVzZVN0b3JlUmVmOiB1c2VTdG9yZVJlZiQ2XHJcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcclxuXHJcbmNvbnN0IHtcclxuICByZWZyZXNoUmVjb2lsVmFsdWU6IHJlZnJlc2hSZWNvaWxWYWx1ZSQxLFxyXG4gIHNldFJlY29pbFZhbHVlOiBzZXRSZWNvaWxWYWx1ZSQzXHJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XHJcblxyXG5jb25zdCB7XHJcbiAgY2xvbmVTbmFwc2hvdDogY2xvbmVTbmFwc2hvdCQyXHJcbn0gPSBSZWNvaWxfU25hcHNob3QkMTtcclxuXHJcbmNvbnN0IHtcclxuICBnb3RvU25hcHNob3Q6IGdvdG9TbmFwc2hvdCQxXHJcbn0gPSBSZWNvaWxfU25hcHNob3RIb29rcztcclxuXHJcbmNvbnN0IHtcclxuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2skM1xyXG59ID0gcmVhY3Q7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIFNlbnRpbmVsIHt9XHJcblxyXG5jb25zdCBTRU5USU5FTCA9IG5ldyBTZW50aW5lbCgpO1xyXG5cclxuZnVuY3Rpb24gcmVjb2lsQ2FsbGJhY2soc3RvcmUsIGZuLCBhcmdzLCBleHRyYUludGVyZmFjZSkge1xyXG4gIGxldCByZXQgPSBTRU5USU5FTDtcclxuICBsZXQgcmVsZWFzZVNuYXBzaG90O1xyXG4gIGJhdGNoVXBkYXRlcyQ0KCgpID0+IHtcclxuICAgIGNvbnN0IGVyck1zZyA9ICd1c2VSZWNvaWxDYWxsYmFjaygpIGV4cGVjdHMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbjogJyArICdpdCBhY2NlcHRzIGEgZnVuY3Rpb24gb2YgdGhlIHR5cGUgKFJlY29pbEludGVyZmFjZSkgPT4gKEFyZ3MpID0+IFJldHVyblR5cGUgJyArICdhbmQgcmV0dXJucyBhIGNhbGxiYWNrIGZ1bmN0aW9uIChBcmdzKSA9PiBSZXR1cm5UeXBlLCB3aGVyZSBSZWNvaWxJbnRlcmZhY2UgaXMgJyArICdhbiBvYmplY3Qge3NuYXBzaG90LCBzZXQsIC4uLn0gYW5kIEFyZ3MgYW5kIFJldHVyblR5cGUgYXJlIHRoZSBhcmd1bWVudCBhbmQgcmV0dXJuICcgKyAndHlwZXMgb2YgdGhlIGNhbGxiYWNrIHlvdSB3YW50IHRvIGNyZWF0ZS4gIFBsZWFzZSBzZWUgdGhlIGRvY3MgJyArICdhdCByZWNvaWxqcy5vcmcgZm9yIGRldGFpbHMuJztcclxuXHJcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IFJlY29pbF9lcnIoZXJyTXNnKTtcclxuICAgIH0gLy8gQ2xvbmUgdGhlIHNuYXBzaG90IGxhemlseSB0byBhdm9pZCBvdmVyaGVhZCBpZiB0aGUgY2FsbGJhY2sgZG9lcyBub3QgdXNlIGl0LlxyXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgbWVhbnMgdGhlIHNuYXBzaG90IG1heSByZXByZXNlbnQgbGF0ZXIgc3RhdGUgZnJvbSB3aGVuXHJcbiAgICAvLyB0aGUgY2FsbGJhY2sgd2FzIGNhbGxlZCBpZiBpdCBmaXJzdCBhY2Nlc3NlcyB0aGUgc25hcHNob3QgYXN5bmNocm9ub3VzbHkuXHJcblxyXG5cclxuICAgIGNvbnN0IGNhbGxiYWNrSW50ZXJmYWNlID0gUmVjb2lsX2xhenlQcm94eSh7IC4uLihleHRyYUludGVyZmFjZSAhPT0gbnVsbCAmJiBleHRyYUludGVyZmFjZSAhPT0gdm9pZCAwID8gZXh0cmFJbnRlcmZhY2UgOiB7fSksXHJcbiAgICAgIC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxyXG4gICAgICBzZXQ6IChub2RlLCBuZXdWYWx1ZSkgPT4gc2V0UmVjb2lsVmFsdWUkMyhzdG9yZSwgbm9kZSwgbmV3VmFsdWUpLFxyXG4gICAgICByZXNldDogbm9kZSA9PiBzZXRSZWNvaWxWYWx1ZSQzKHN0b3JlLCBub2RlLCBERUZBVUxUX1ZBTFVFJDUpLFxyXG4gICAgICByZWZyZXNoOiBub2RlID0+IHJlZnJlc2hSZWNvaWxWYWx1ZSQxKHN0b3JlLCBub2RlKSxcclxuICAgICAgZ290b1NuYXBzaG90OiBzbmFwc2hvdCA9PiBnb3RvU25hcHNob3QkMShzdG9yZSwgc25hcHNob3QpLFxyXG4gICAgICB0cmFuc2FjdF9VTlNUQUJMRTogdHJhbnNhY3Rpb24gPT4gYXRvbWljVXBkYXRlciQxKHN0b3JlKSh0cmFuc2FjdGlvbilcclxuICAgIH0sIHtcclxuICAgICAgc25hcHNob3Q6ICgpID0+IHtcclxuICAgICAgICBjb25zdCBzbmFwc2hvdCA9IGNsb25lU25hcHNob3QkMihzdG9yZSk7XHJcbiAgICAgICAgcmVsZWFzZVNuYXBzaG90ID0gc25hcHNob3QucmV0YWluKCk7XHJcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGNhbGxiYWNrID0gZm4oY2FsbGJhY2tJbnRlcmZhY2UpO1xyXG5cclxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgUmVjb2lsX2VycihlcnJNc2cpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldCA9IGNhbGxiYWNrKC4uLmFyZ3MpO1xyXG4gIH0pO1xyXG4gICEhKHJldCBpbnN0YW5jZW9mIFNlbnRpbmVsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UsICdiYXRjaFVwZGF0ZXMgc2hvdWxkIHJldHVybiBpbW1lZGlhdGVseScpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcblxyXG4gIGlmIChSZWNvaWxfaXNQcm9taXNlKHJldCkpIHtcclxuICAgIHJldC5maW5hbGx5KCgpID0+IHtcclxuICAgICAgdmFyIF9yZWxlYXNlU25hcHNob3Q7XHJcblxyXG4gICAgICAoX3JlbGVhc2VTbmFwc2hvdCA9IHJlbGVhc2VTbmFwc2hvdCkgPT09IG51bGwgfHwgX3JlbGVhc2VTbmFwc2hvdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbGVhc2VTbmFwc2hvdCgpO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBfcmVsZWFzZVNuYXBzaG90MjtcclxuXHJcbiAgICAoX3JlbGVhc2VTbmFwc2hvdDIgPSByZWxlYXNlU25hcHNob3QpID09PSBudWxsIHx8IF9yZWxlYXNlU25hcHNob3QyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsZWFzZVNuYXBzaG90MigpO1xyXG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF1cclxuXHJcblxyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbENhbGxiYWNrKGZuLCBkZXBzKSB7XHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQ2KCk7XHJcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDMoIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLWNhbGxdXHJcbiAgKC4uLmFyZ3MpID0+IHtcclxuICAgIHJldHVybiByZWNvaWxDYWxsYmFjayhzdG9yZVJlZi5jdXJyZW50LCBmbiwgYXJncyk7XHJcbiAgfSwgZGVwcyAhPSBudWxsID8gWy4uLmRlcHMsIHN0b3JlUmVmXSA6IHVuZGVmaW5lZCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZiLXd3dy9yZWFjdC1ob29rcy1kZXBzXHJcbiAgKTtcclxufVxyXG5cclxudmFyIFJlY29pbF91c2VSZWNvaWxDYWxsYmFjayA9IHtcclxuICByZWNvaWxDYWxsYmFjayxcclxuICB1c2VSZWNvaWxDYWxsYmFja1xyXG59O1xyXG5cclxuY29uc3Qge1xyXG4gIHVzZVN0b3JlUmVmOiB1c2VTdG9yZVJlZiQ3XHJcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcclxuXHJcbmNvbnN0IHtcclxuICByZWZyZXNoUmVjb2lsVmFsdWU6IHJlZnJlc2hSZWNvaWxWYWx1ZSQyXHJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XHJcblxyXG5jb25zdCB7XHJcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrJDRcclxufSA9IHJlYWN0O1xyXG5cclxuZnVuY3Rpb24gdXNlUmVjb2lsUmVmcmVzaGVyKHJlY29pbFZhbHVlKSB7XHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQ3KCk7XHJcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDQoKCkgPT4ge1xyXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xyXG4gICAgcmVmcmVzaFJlY29pbFZhbHVlJDIoc3RvcmUsIHJlY29pbFZhbHVlKTtcclxuICB9LCBbcmVjb2lsVmFsdWUsIHN0b3JlUmVmXSk7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfdXNlUmVjb2lsUmVmcmVzaGVyID0gdXNlUmVjb2lsUmVmcmVzaGVyO1xyXG5cclxuY29uc3Qge1xyXG4gIGF0b21pY1VwZGF0ZXI6IGF0b21pY1VwZGF0ZXIkMlxyXG59ID0gUmVjb2lsX0F0b21pY1VwZGF0ZXMkMTtcclxuXHJcbmNvbnN0IHtcclxuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkOFxyXG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XHJcblxyXG5jb25zdCB7XHJcbiAgdXNlTWVtbzogdXNlTWVtbyQzXHJcbn0gPSByZWFjdDtcclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbFRyYW5zYWN0aW9uKGZuLCBkZXBzKSB7XHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQ4KCk7XHJcbiAgcmV0dXJuIHVzZU1lbW8kMygoKSA9PiAoLi4uYXJncykgPT4ge1xyXG4gICAgY29uc3QgYXRvbWljVXBkYXRlID0gYXRvbWljVXBkYXRlciQyKHN0b3JlUmVmLmN1cnJlbnQpO1xyXG4gICAgYXRvbWljVXBkYXRlKHRyYW5zYWN0aW9uSW50ZXJmYWNlID0+IHtcclxuICAgICAgZm4odHJhbnNhY3Rpb25JbnRlcmZhY2UpKC4uLmFyZ3MpO1xyXG4gICAgfSk7XHJcbiAgfSwgZGVwcyAhPSBudWxsID8gWy4uLmRlcHMsIHN0b3JlUmVmXSA6IHVuZGVmaW5lZCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZiLXd3dy9yZWFjdC1ob29rcy1kZXBzXHJcbiAgKTtcclxufVxyXG5cclxudmFyIFJlY29pbF91c2VSZWNvaWxUcmFuc2FjdGlvbiA9IHVzZVJlY29pbFRyYW5zYWN0aW9uO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuXHJcbmNsYXNzIFdyYXBwZWRWYWx1ZSB7XHJcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbnZhciBSZWNvaWxfV3JhcHBlciA9IHtcclxuICBXcmFwcGVkVmFsdWVcclxufTtcclxuXHJcbnZhciBSZWNvaWxfV3JhcHBlcl8xID0gUmVjb2lsX1dyYXBwZXIuV3JhcHBlZFZhbHVlO1xyXG5cclxudmFyIFJlY29pbF9XcmFwcGVyJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIFdyYXBwZWRWYWx1ZTogUmVjb2lsX1dyYXBwZXJfMVxyXG59KTtcclxuXHJcbmNvbnN0IHtcclxuICBpc0Zhc3RSZWZyZXNoRW5hYmxlZDogaXNGYXN0UmVmcmVzaEVuYWJsZWQkMlxyXG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcclxuXHJcblxyXG5cclxuY2xhc3MgQ2hhbmdlZFBhdGhFcnJvciBleHRlbmRzIEVycm9yIHt9XHJcblxyXG5jbGFzcyBUcmVlQ2FjaGUge1xyXG4gIC8vICRGbG93SXNzdWVbdW5jbGVhci10eXBlXVxyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgIHZhciBfb3B0aW9ucyRvbkhpdCwgX29wdGlvbnMkb25TZXQsIF9vcHRpb25zJG1hcE5vZGVWYWx1ZTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbmFtZVwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9udW1MZWFmc1wiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yb290XCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29uSGl0XCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29uU2V0XCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX21hcE5vZGVWYWx1ZVwiLCB2b2lkIDApO1xyXG5cclxuICAgIHRoaXMuX25hbWUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubmFtZTtcclxuICAgIHRoaXMuX251bUxlYWZzID0gMDtcclxuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xyXG4gICAgdGhpcy5fb25IaXQgPSAoX29wdGlvbnMkb25IaXQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25IaXQpICE9PSBudWxsICYmIF9vcHRpb25zJG9uSGl0ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRvbkhpdCA6ICgpID0+IHt9O1xyXG4gICAgdGhpcy5fb25TZXQgPSAoX29wdGlvbnMkb25TZXQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25TZXQpICE9PSBudWxsICYmIF9vcHRpb25zJG9uU2V0ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRvblNldCA6ICgpID0+IHt9O1xyXG4gICAgdGhpcy5fbWFwTm9kZVZhbHVlID0gKF9vcHRpb25zJG1hcE5vZGVWYWx1ZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXBOb2RlVmFsdWUpICE9PSBudWxsICYmIF9vcHRpb25zJG1hcE5vZGVWYWx1ZSAhPT0gdm9pZCAwID8gX29wdGlvbnMkbWFwTm9kZVZhbHVlIDogdmFsID0+IHZhbDtcclxuICB9XHJcblxyXG4gIHNpemUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbnVtTGVhZnM7XHJcbiAgfSAvLyAkRmxvd0lzc3VlW3VuY2xlYXItdHlwZV1cclxuXHJcblxyXG4gIHJvb3QoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcm9vdDtcclxuICB9XHJcblxyXG4gIGdldChnZXROb2RlVmFsdWUsIGhhbmRsZXJzKSB7XHJcbiAgICB2YXIgX3RoaXMkZ2V0TGVhZk5vZGU7XHJcblxyXG4gICAgcmV0dXJuIChfdGhpcyRnZXRMZWFmTm9kZSA9IHRoaXMuZ2V0TGVhZk5vZGUoZ2V0Tm9kZVZhbHVlLCBoYW5kbGVycykpID09PSBudWxsIHx8IF90aGlzJGdldExlYWZOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRMZWFmTm9kZS52YWx1ZTtcclxuICB9XHJcblxyXG4gIGdldExlYWZOb2RlKGdldE5vZGVWYWx1ZSwgaGFuZGxlcnMpIHtcclxuICAgIGlmICh0aGlzLl9yb290ID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH0gLy8gSXRlcmF0ZSBkb3duIHRoZSB0cmVlIGJhc2VkIG9uIHRoZSBjdXJyZW50IG5vZGUgdmFsdWVzIHVudGlsIHdlIGhpdCBhIGxlYWZcclxuICAgIC8vICRGbG93SXNzdWVbdW5jbGVhci10eXBlXVxyXG5cclxuXHJcbiAgICBsZXQgbm9kZSA9IHRoaXMuX3Jvb3Q7XHJcblxyXG4gICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgaGFuZGxlcnMgPT09IG51bGwgfHwgaGFuZGxlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uTm9kZVZpc2l0KG5vZGUpO1xyXG5cclxuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2xlYWYnKSB7XHJcbiAgICAgICAgdGhpcy5fb25IaXQobm9kZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBub2RlVmFsdWUgPSB0aGlzLl9tYXBOb2RlVmFsdWUoZ2V0Tm9kZVZhbHVlKG5vZGUubm9kZUtleSkpO1xyXG5cclxuICAgICAgbm9kZSA9IG5vZGUuYnJhbmNoZXMuZ2V0KG5vZGVWYWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIHNldChyb3V0ZSwgdmFsdWUsIGhhbmRsZXJzKSB7XHJcbiAgICBjb25zdCBhZGRMZWFmID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX25vZGUyLCBfbm9kZTMsIF90aGlzJF9yb290MiwgX2hhbmRsZXJzJG9uTm9kZVZpc2l0MjtcclxuXHJcbiAgICAgIC8vIEZpcnN0LCBzZXR1cCB0aGUgYnJhbmNoIG5vZGVzIGZvciB0aGUgcm91dGU6XHJcbiAgICAgIC8vIEl0ZXJhdGUgZG93biB0aGUgdHJlZSB0byBmaW5kIG9yIGFkZCBicmFuY2ggbm9kZXMgZm9sbG93aW5nIHRoZSByb3V0ZVxyXG4gICAgICBsZXQgbm9kZTtcclxuICAgICAgbGV0IGJyYW5jaEtleTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgW25vZGVLZXksIG5vZGVWYWx1ZV0gb2Ygcm91dGUpIHtcclxuICAgICAgICB2YXIgX25vZGUsIF9oYW5kbGVycyRvbk5vZGVWaXNpdCwgX3RoaXMkX3Jvb3Q7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyByb290IHdhcyBhIGxlYWYsIHdoaWxlIHdlIG5vdCBoYXZlIGEgZ2V0KCksIGl0IG1lYW5zXHJcbiAgICAgICAgLy8gdGhlIHNlbGVjdG9yIGhhcyBpbmNvbnNpc3RlbnQgdmFsdWVzIG9yIGltcGxlbWVudGF0aW9uIGNoYW5nZWQuXHJcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuX3Jvb3Q7XHJcblxyXG4gICAgICAgIGlmICgocm9vdCA9PT0gbnVsbCB8fCByb290ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb290LnR5cGUpID09PSAnbGVhZicpIHtcclxuICAgICAgICAgIHRocm93IHRoaXMuaW52YWxpZENhY2hlRXJyb3IoKTtcclxuICAgICAgICB9IC8vIG5vZGUgbm93IHJlZmVycyB0byB0aGUgbmV4dCBub2RlIGRvd24gaW4gdGhlIHRyZWVcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGU7IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxyXG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdXHJcblxyXG4gICAgICAgIG5vZGUgPSBwYXJlbnQgPyBwYXJlbnQuYnJhbmNoZXMuZ2V0KGJyYW5jaEtleSkgOiByb290OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cclxuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXVxyXG5cclxuICAgICAgICBub2RlID0gKF9ub2RlID0gbm9kZSkgIT09IG51bGwgJiYgX25vZGUgIT09IHZvaWQgMCA/IF9ub2RlIDoge1xyXG4gICAgICAgICAgdHlwZTogJ2JyYW5jaCcsXHJcbiAgICAgICAgICBub2RlS2V5LFxyXG4gICAgICAgICAgcGFyZW50LFxyXG4gICAgICAgICAgYnJhbmNoZXM6IG5ldyBNYXAoKSxcclxuICAgICAgICAgIGJyYW5jaEtleVxyXG4gICAgICAgIH07IC8vIElmIHdlIGZvdW5kIGFuIGV4aXN0aW5nIG5vZGUsIGNvbmZpcm0gaXQgaGFzIGEgY29uc2lzdGVudCB2YWx1ZVxyXG5cclxuICAgICAgICBpZiAobm9kZS50eXBlICE9PSAnYnJhbmNoJyB8fCBub2RlLm5vZGVLZXkgIT09IG5vZGVLZXkpIHtcclxuICAgICAgICAgIHRocm93IHRoaXMuaW52YWxpZENhY2hlRXJyb3IoKTtcclxuICAgICAgICB9IC8vIEFkZCB0aGUgYnJhbmNoIG5vZGUgdG8gdGhlIHRyZWVcclxuXHJcblxyXG4gICAgICAgIHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5icmFuY2hlcy5zZXQoYnJhbmNoS2V5LCBub2RlKTtcclxuICAgICAgICBoYW5kbGVycyA9PT0gbnVsbCB8fCBoYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9oYW5kbGVycyRvbk5vZGVWaXNpdCA9IGhhbmRsZXJzLm9uTm9kZVZpc2l0KSA9PT0gbnVsbCB8fCBfaGFuZGxlcnMkb25Ob2RlVmlzaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oYW5kbGVycyRvbk5vZGVWaXNpdC5jYWxsKGhhbmRsZXJzLCBub2RlKTsgLy8gUHJlcGFyZSBmb3IgbmV4dCBpdGVyYXRpb24gYW5kIGluc3RhbGwgcm9vdCBpZiBpdCBpcyBuZXcuXHJcblxyXG4gICAgICAgIGJyYW5jaEtleSA9IHRoaXMuX21hcE5vZGVWYWx1ZShub2RlVmFsdWUpO1xyXG4gICAgICAgIHRoaXMuX3Jvb3QgPSAoX3RoaXMkX3Jvb3QgPSB0aGlzLl9yb290KSAhPT0gbnVsbCAmJiBfdGhpcyRfcm9vdCAhPT0gdm9pZCAwID8gX3RoaXMkX3Jvb3QgOiBub2RlO1xyXG4gICAgICB9IC8vIFNlY29uZCwgc2V0dXAgdGhlIGxlYWYgbm9kZTpcclxuICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgbGVhZiBmb3IgdGhpcyByb3V0ZSBjb25maXJtIGl0IGlzIGNvbnNpc3RlbnRcclxuXHJcblxyXG4gICAgICBjb25zdCBvbGRMZWFmID0gbm9kZSA/IChfbm9kZTIgPSBub2RlKSA9PT0gbnVsbCB8fCBfbm9kZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlMi5icmFuY2hlcy5nZXQoYnJhbmNoS2V5KSA6IHRoaXMuX3Jvb3Q7XHJcblxyXG4gICAgICBpZiAob2xkTGVhZiAhPSBudWxsICYmIChvbGRMZWFmLnR5cGUgIT09ICdsZWFmJyB8fCBvbGRMZWFmLmJyYW5jaEtleSAhPT0gYnJhbmNoS2V5KSkge1xyXG4gICAgICAgIHRocm93IHRoaXMuaW52YWxpZENhY2hlRXJyb3IoKTtcclxuICAgICAgfSAvLyBDcmVhdGUgYSBuZXcgb3IgcmVwbGFjZW1lbnQgbGVhZi5cclxuXHJcblxyXG4gICAgICBjb25zdCBsZWFmTm9kZSA9IHtcclxuICAgICAgICB0eXBlOiAnbGVhZicsXHJcbiAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgcGFyZW50OiBub2RlLFxyXG4gICAgICAgIGJyYW5jaEtleVxyXG4gICAgICB9OyAvLyBJbnN0YWxsIHRoZSBsZWFmIGFuZCBjYWxsIGhhbmRsZXJzXHJcblxyXG4gICAgICAoX25vZGUzID0gbm9kZSkgPT09IG51bGwgfHwgX25vZGUzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZTMuYnJhbmNoZXMuc2V0KGJyYW5jaEtleSwgbGVhZk5vZGUpO1xyXG4gICAgICB0aGlzLl9yb290ID0gKF90aGlzJF9yb290MiA9IHRoaXMuX3Jvb3QpICE9PSBudWxsICYmIF90aGlzJF9yb290MiAhPT0gdm9pZCAwID8gX3RoaXMkX3Jvb3QyIDogbGVhZk5vZGU7XHJcbiAgICAgIHRoaXMuX251bUxlYWZzKys7XHJcblxyXG4gICAgICB0aGlzLl9vblNldChsZWFmTm9kZSk7XHJcblxyXG4gICAgICBoYW5kbGVycyA9PT0gbnVsbCB8fCBoYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9oYW5kbGVycyRvbk5vZGVWaXNpdDIgPSBoYW5kbGVycy5vbk5vZGVWaXNpdCkgPT09IG51bGwgfHwgX2hhbmRsZXJzJG9uTm9kZVZpc2l0MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2hhbmRsZXJzJG9uTm9kZVZpc2l0Mi5jYWxsKGhhbmRsZXJzLCBsZWFmTm9kZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGFkZExlYWYoKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIC8vIElmIHRoZSBjYWNoZSB3YXMgc3RhbGUgb3Igb2JzZXJ2ZWQgaW5jb25zaXN0ZW50IHZhbHVlcywgc3VjaCBhcyB3aXRoXHJcbiAgICAgIC8vIEZhc3QgUmVmcmVzaCwgdGhlbiBjbGVhciBpdCBhbmQgcmVidWlsZCB3aXRoIHRoZSBuZXcgdmFsdWVzLlxyXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDaGFuZ2VkUGF0aEVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgIGFkZExlYWYoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gLy8gUmV0dXJucyB0cnVlIGlmIGxlYWYgd2FzIGFjdHVhbGx5IGRlbGV0ZWQgZnJvbSB0aGUgdHJlZVxyXG5cclxuXHJcbiAgZGVsZXRlKGxlYWYpIHtcclxuICAgIGNvbnN0IHJvb3QgPSB0aGlzLnJvb3QoKTtcclxuXHJcbiAgICBpZiAoIXJvb3QpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChsZWFmID09PSByb290KSB7XHJcbiAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xyXG4gICAgICB0aGlzLl9udW1MZWFmcyA9IDA7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSAvLyBJdGVyYXRlIHVwIGZyb20gdGhlIGxlYWYgZGVsZXRlaW5nIGl0IGZyb20gaXQncyBwYXJlbnQncyBicmFuY2hlcy5cclxuXHJcblxyXG4gICAgbGV0IG5vZGUgPSBsZWFmLnBhcmVudDtcclxuICAgIGxldCBicmFuY2hLZXkgPSBsZWFmLmJyYW5jaEtleTtcclxuXHJcbiAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICB2YXIgX25vZGU0O1xyXG5cclxuICAgICAgbm9kZS5icmFuY2hlcy5kZWxldGUoYnJhbmNoS2V5KTsgLy8gU3RvcCBpdGVyYXRpbmcgaWYgd2UgaGl0IHRoZSByb290LlxyXG5cclxuICAgICAgaWYgKG5vZGUgPT09IHJvb3QpIHtcclxuICAgICAgICBpZiAobm9kZS5icmFuY2hlcy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcclxuICAgICAgICAgIHRoaXMuX251bUxlYWZzID0gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5fbnVtTGVhZnMtLTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9IC8vIFN0b3AgaXRlcmF0aW5nIGlmIHRoZXJlIGFyZSBvdGhlciBicmFuY2hlcyBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvXHJcbiAgICAgIC8vIHJlbW92ZSBhbnkgbW9yZSBub2Rlcy5cclxuXHJcblxyXG4gICAgICBpZiAobm9kZS5icmFuY2hlcy5zaXplID4gMCkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9IC8vIEl0ZXJhdGUgdXAgdG8gb3VyIHBhcmVudFxyXG5cclxuXHJcbiAgICAgIGJyYW5jaEtleSA9IChfbm9kZTQgPSBub2RlKSA9PT0gbnVsbCB8fCBfbm9kZTQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlNC5icmFuY2hLZXk7XHJcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgIH0gLy8gQ29uZmlybSB0aGF0IHRoZSBsZWFmIHdlIGFyZSBkZWxldGluZyBpcyBhY3R1YWxseSBhdHRhY2hlZCB0byBvdXIgdHJlZVxyXG5cclxuXHJcbiAgICBmb3IgKDsgbm9kZSAhPT0gcm9vdDsgbm9kZSA9IG5vZGUucGFyZW50KSB7XHJcbiAgICAgIGlmIChub2RlID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9udW1MZWFmcy0tO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBjbGVhcigpIHtcclxuICAgIHRoaXMuX251bUxlYWZzID0gMDtcclxuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgaW52YWxpZENhY2hlRXJyb3IoKSB7XHJcbiAgICBjb25zdCBDSEFOR0VEX1BBVEhfRVJST1JfTUVTU0FHRSA9IGlzRmFzdFJlZnJlc2hFbmFibGVkJDIoKSA/ICdQb3NzaWJsZSBGYXN0IFJlZnJlc2ggbW9kdWxlIHJlbG9hZCBkZXRlY3RlZC4gICcgKyAnVGhpcyBtYXkgYWxzbyBiZSBjYXVzZWQgYnkgYW4gc2VsZWN0b3IgcmV0dXJuaW5nIGluY29uc2lzdGVudCB2YWx1ZXMuICcgKyAnUmVzZXR0aW5nIGNhY2hlLicgOiAnSW52YWxpZCBjYWNoZSB2YWx1ZXMuICBUaGlzIGhhcHBlbnMgd2hlbiBzZWxlY3RvcnMgZG8gbm90IHJldHVybiAnICsgJ2NvbnNpc3RlbnQgdmFsdWVzIGZvciB0aGUgc2FtZSBpbnB1dCBkZXBlbmRlbmN5IHZhbHVlcy4gIFRoYXQgbWF5IGFsc28gJyArICdiZSBjYXVzZWQgd2hlbiB1c2luZyBGYXN0IFJlZnJlc2ggdG8gY2hhbmdlIGEgc2VsZWN0b3IgaW1wbGVtZW50YXRpb24uICAnICsgJ1Jlc2V0dGluZyBjYWNoZS4nO1xyXG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKENIQU5HRURfUEFUSF9FUlJPUl9NRVNTQUdFICsgKHRoaXMuX25hbWUgIT0gbnVsbCA/IGAgLSAke3RoaXMuX25hbWV9YCA6ICcnKSk7XHJcbiAgICB0aHJvdyBuZXcgQ2hhbmdlZFBhdGhFcnJvcigpO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbnZhciBSZWNvaWxfVHJlZUNhY2hlID0ge1xyXG4gIFRyZWVDYWNoZVxyXG59O1xyXG5cclxudmFyIFJlY29pbF9UcmVlQ2FjaGVfMSA9IFJlY29pbF9UcmVlQ2FjaGUuVHJlZUNhY2hlO1xyXG5cclxudmFyIFJlY29pbF9UcmVlQ2FjaGUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgVHJlZUNhY2hlOiBSZWNvaWxfVHJlZUNhY2hlXzFcclxufSk7XHJcblxyXG5jbGFzcyBMUlVDYWNoZSB7XHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgdmFyIF9vcHRpb25zJG1hcEtleTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWF4U2l6ZVwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zaXplXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2hlYWRcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGFpbFwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tYXBcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfa2V5TWFwcGVyXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy5fbWF4U2l6ZSA9IG9wdGlvbnMubWF4U2l6ZTtcclxuICAgIHRoaXMuX3NpemUgPSAwO1xyXG4gICAgdGhpcy5faGVhZCA9IG51bGw7XHJcbiAgICB0aGlzLl90YWlsID0gbnVsbDtcclxuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuX2tleU1hcHBlciA9IChfb3B0aW9ucyRtYXBLZXkgPSBvcHRpb25zLm1hcEtleSkgIT09IG51bGwgJiYgX29wdGlvbnMkbWFwS2V5ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRtYXBLZXkgOiB2ID0+IHY7XHJcbiAgfVxyXG5cclxuICBoZWFkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2hlYWQ7XHJcbiAgfVxyXG5cclxuICB0YWlsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3RhaWw7XHJcbiAgfVxyXG5cclxuICBzaXplKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XHJcbiAgfVxyXG5cclxuICBtYXhTaXplKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21heFNpemU7XHJcbiAgfVxyXG5cclxuICBoYXMoa2V5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyh0aGlzLl9rZXlNYXBwZXIoa2V5KSk7XHJcbiAgfVxyXG5cclxuICBnZXQoa2V5KSB7XHJcbiAgICBjb25zdCBtYXBwZWRLZXkgPSB0aGlzLl9rZXlNYXBwZXIoa2V5KTtcclxuXHJcbiAgICBjb25zdCBub2RlID0gdGhpcy5fbWFwLmdldChtYXBwZWRLZXkpO1xyXG5cclxuICAgIGlmICghbm9kZSkge1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2V0KGtleSwgbm9kZS52YWx1ZSk7XHJcbiAgICByZXR1cm4gbm9kZS52YWx1ZTtcclxuICB9XHJcblxyXG4gIHNldChrZXksIHZhbCkge1xyXG4gICAgY29uc3QgbWFwcGVkS2V5ID0gdGhpcy5fa2V5TWFwcGVyKGtleSk7XHJcblxyXG4gICAgY29uc3QgZXhpc3RpbmdOb2RlID0gdGhpcy5fbWFwLmdldChtYXBwZWRLZXkpO1xyXG5cclxuICAgIGlmIChleGlzdGluZ05vZGUpIHtcclxuICAgICAgdGhpcy5kZWxldGUoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoZWFkID0gdGhpcy5oZWFkKCk7XHJcbiAgICBjb25zdCBub2RlID0ge1xyXG4gICAgICBrZXksXHJcbiAgICAgIHJpZ2h0OiBoZWFkLFxyXG4gICAgICBsZWZ0OiBudWxsLFxyXG4gICAgICB2YWx1ZTogdmFsXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChoZWFkKSB7XHJcbiAgICAgIGhlYWQubGVmdCA9IG5vZGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl90YWlsID0gbm9kZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9tYXAuc2V0KG1hcHBlZEtleSwgbm9kZSk7XHJcblxyXG4gICAgdGhpcy5faGVhZCA9IG5vZGU7XHJcbiAgICB0aGlzLl9zaXplKys7XHJcblxyXG4gICAgdGhpcy5fbWF5YmVEZWxldGVMUlUoKTtcclxuICB9XHJcblxyXG4gIF9tYXliZURlbGV0ZUxSVSgpIHtcclxuICAgIGlmICh0aGlzLnNpemUoKSA+IHRoaXMubWF4U2l6ZSgpKSB7XHJcbiAgICAgIHRoaXMuZGVsZXRlTHJ1KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZWxldGVMcnUoKSB7XHJcbiAgICBjb25zdCB0YWlsID0gdGhpcy50YWlsKCk7XHJcblxyXG4gICAgaWYgKHRhaWwpIHtcclxuICAgICAgdGhpcy5kZWxldGUodGFpbC5rZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVsZXRlKGtleSkge1xyXG4gICAgY29uc3QgbWFwcGVkS2V5ID0gdGhpcy5fa2V5TWFwcGVyKGtleSk7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9zaXplIHx8ICF0aGlzLl9tYXAuaGFzKG1hcHBlZEtleSkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5vZGUgPSBSZWNvaWxfbnVsbHRocm93cyh0aGlzLl9tYXAuZ2V0KG1hcHBlZEtleSkpO1xyXG4gICAgY29uc3QgcmlnaHQgPSBub2RlLnJpZ2h0O1xyXG4gICAgY29uc3QgbGVmdCA9IG5vZGUubGVmdDtcclxuXHJcbiAgICBpZiAocmlnaHQpIHtcclxuICAgICAgcmlnaHQubGVmdCA9IG5vZGUubGVmdDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobGVmdCkge1xyXG4gICAgICBsZWZ0LnJpZ2h0ID0gbm9kZS5yaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKCkpIHtcclxuICAgICAgdGhpcy5faGVhZCA9IHJpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChub2RlID09PSB0aGlzLnRhaWwoKSkge1xyXG4gICAgICB0aGlzLl90YWlsID0gbGVmdDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9tYXAuZGVsZXRlKG1hcHBlZEtleSk7XHJcblxyXG4gICAgdGhpcy5fc2l6ZS0tO1xyXG4gIH1cclxuXHJcbiAgY2xlYXIoKSB7XHJcbiAgICB0aGlzLl9zaXplID0gMDtcclxuICAgIHRoaXMuX2hlYWQgPSBudWxsO1xyXG4gICAgdGhpcy5fdGFpbCA9IG51bGw7XHJcbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxudmFyIFJlY29pbF9MUlVDYWNoZSA9IHtcclxuICBMUlVDYWNoZVxyXG59O1xyXG5cclxudmFyIFJlY29pbF9MUlVDYWNoZV8xID0gUmVjb2lsX0xSVUNhY2hlLkxSVUNhY2hlO1xyXG5cclxudmFyIFJlY29pbF9MUlVDYWNoZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xyXG4gIF9fcHJvdG9fXzogbnVsbCxcclxuICBMUlVDYWNoZTogUmVjb2lsX0xSVUNhY2hlXzFcclxufSk7XHJcblxyXG5jb25zdCB7XHJcbiAgTFJVQ2FjaGU6IExSVUNhY2hlJDFcclxufSA9IFJlY29pbF9MUlVDYWNoZSQxO1xyXG5cclxuY29uc3Qge1xyXG4gIFRyZWVDYWNoZTogVHJlZUNhY2hlJDFcclxufSA9IFJlY29pbF9UcmVlQ2FjaGUkMTtcclxuXHJcbmZ1bmN0aW9uIHRyZWVDYWNoZUxSVSh7XHJcbiAgbmFtZSxcclxuICBtYXhTaXplLFxyXG4gIG1hcE5vZGVWYWx1ZSA9IHYgPT4gdlxyXG59KSB7XHJcbiAgY29uc3QgbHJ1Q2FjaGUgPSBuZXcgTFJVQ2FjaGUkMSh7XHJcbiAgICBtYXhTaXplXHJcbiAgfSk7XHJcbiAgY29uc3QgY2FjaGUgPSBuZXcgVHJlZUNhY2hlJDEoe1xyXG4gICAgbmFtZSxcclxuICAgIG1hcE5vZGVWYWx1ZSxcclxuICAgIG9uSGl0OiBub2RlID0+IHtcclxuICAgICAgbHJ1Q2FjaGUuc2V0KG5vZGUsIHRydWUpO1xyXG4gICAgfSxcclxuICAgIG9uU2V0OiBub2RlID0+IHtcclxuICAgICAgY29uc3QgbHJ1Tm9kZSA9IGxydUNhY2hlLnRhaWwoKTtcclxuICAgICAgbHJ1Q2FjaGUuc2V0KG5vZGUsIHRydWUpO1xyXG5cclxuICAgICAgaWYgKGxydU5vZGUgJiYgY2FjaGUuc2l6ZSgpID4gbWF4U2l6ZSkge1xyXG4gICAgICAgIGNhY2hlLmRlbGV0ZShscnVOb2RlLmtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gY2FjaGU7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfdHJlZUNhY2hlTFJVID0gdHJlZUNhY2hlTFJVO1xyXG5cclxuY29uc3QgVElNRV9XQVJOSU5HX1RIUkVTSE9MRF9NUyA9IDE1O1xyXG5cclxuZnVuY3Rpb24gc3RyaW5naWZ5KHgsIG9wdCwga2V5KSB7XHJcbiAgLy8gQSBvcHRpbWl6YXRpb24gdG8gYXZvaWQgdGhlIG1vcmUgZXhwZW5zaXZlIEpTT04uc3RyaW5naWZ5KCkgZm9yIHNpbXBsZSBzdHJpbmdzXHJcbiAgLy8gVGhpcyBtYXkgbG9zZSBwcm90ZWN0aW9uIGZvciB1MjAyOCBhbmQgdTIwMjksIHRob3VnaC5cclxuICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnICYmICF4LmluY2x1ZGVzKCdcIicpICYmICF4LmluY2x1ZGVzKCdcXFxcJykpIHtcclxuICAgIHJldHVybiBgXCIke3h9XCJgO1xyXG4gIH0gLy8gSGFuZGxlIHByaW1pdGl2ZSB0eXBlc1xyXG5cclxuXHJcbiAgc3dpdGNoICh0eXBlb2YgeCkge1xyXG4gICAgY2FzZSAndW5kZWZpbmVkJzpcclxuICAgICAgcmV0dXJuICcnO1xyXG4gICAgLy8gSlNPTi5zdHJpbmdpZnkodW5kZWZpbmVkKSByZXR1cm5zIHVuZGVmaW5lZCwgYnV0IHdlIGFsd2F5cyB3YW50IHRvIHJldHVybiBhIHN0cmluZ1xyXG5cclxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICByZXR1cm4geCA/ICd0cnVlJyA6ICdmYWxzZSc7XHJcblxyXG4gICAgY2FzZSAnbnVtYmVyJzpcclxuICAgIGNhc2UgJ3N5bWJvbCc6XHJcbiAgICAgIC8vIGNhc2UgJ2JpZ2ludCc6IC8vIEJpZ0ludCBpcyBub3Qgc3VwcG9ydGVkIGluIHd3d1xyXG4gICAgICByZXR1cm4gU3RyaW5nKHgpO1xyXG5cclxuICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgIC8vIEFkZCBzdXJyb3VuZGluZyBxdW90ZXMgYW5kIGVzY2FwZSBpbnRlcm5hbCBxdW90ZXNcclxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHgpO1xyXG5cclxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuICAgICAgaWYgKChvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuYWxsb3dGdW5jdGlvbnMpICE9PSB0cnVlKSB7XHJcbiAgICAgICAgdGhyb3cgUmVjb2lsX2VycignQXR0ZW1wdCB0byBzZXJpYWxpemUgZnVuY3Rpb24gaW4gYSBSZWNvaWwgY2FjaGUga2V5Jyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBgX19GVU5DVElPTigke3gubmFtZX0pX19gO1xyXG4gIH1cclxuXHJcbiAgaWYgKHggPT09IG51bGwpIHtcclxuICAgIHJldHVybiAnbnVsbCc7XHJcbiAgfSAvLyBGYWxsYmFjayBjYXNlIGZvciB1bmtub3duIHR5cGVzXHJcblxyXG5cclxuICBpZiAodHlwZW9mIHggIT09ICdvYmplY3QnKSB7XHJcbiAgICB2YXIgX0pTT04kc3RyaW5naWZ5O1xyXG5cclxuICAgIHJldHVybiAoX0pTT04kc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnkoeCkpICE9PSBudWxsICYmIF9KU09OJHN0cmluZ2lmeSAhPT0gdm9pZCAwID8gX0pTT04kc3RyaW5naWZ5IDogJyc7XHJcbiAgfSAvLyBEZWFsIHdpdGggYWxsIHByb21pc2VzIGFzIGVxdWl2YWxlbnQgZm9yIG5vdy5cclxuXHJcblxyXG4gIGlmIChSZWNvaWxfaXNQcm9taXNlKHgpKSB7XHJcbiAgICByZXR1cm4gJ19fUFJPTUlTRV9fJztcclxuICB9IC8vIEFycmF5cyBoYW5kbGUgcmVjdXJzaXZlIHN0cmluZ2lmaWNhdGlvblxyXG5cclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcclxuICAgIHJldHVybiBgWyR7eC5tYXAoKHYsIGkpID0+IHN0cmluZ2lmeSh2LCBvcHQsIGkudG9TdHJpbmcoKSkpfV1gO1xyXG4gIH0gLy8gSWYgYW4gb2JqZWN0IGRlZmluZXMgYSB0b0pTT04oKSBtZXRob2QsIHRoZW4gdXNlIHRoYXQgdG8gb3ZlcnJpZGUgdGhlXHJcbiAgLy8gc2VyaWFsaXphdGlvbi4gIFRoaXMgbWF0Y2hlcyB0aGUgYmVoYXZpb3Igb2YgSlNPTi5zdHJpbmdpZnkoKS5cclxuICAvLyBQYXNzIHRoZSBrZXkgZm9yIGNvbXBhdGliaWxpdHkuXHJcbiAgLy8gSW1tdXRhYmxlLmpzIGNvbGxlY3Rpb25zIGRlZmluZSB0aGlzIG1ldGhvZCB0byBhbGxvdyB1cyB0byBzZXJpYWxpemUgdGhlbS5cclxuXHJcblxyXG4gIGlmICh0eXBlb2YgeC50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcclxuICAgIC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxyXG4gICAgcmV0dXJuIHN0cmluZ2lmeSh4LnRvSlNPTihrZXkpLCBvcHQsIGtleSk7XHJcbiAgfSAvLyBGb3IgYnVpbHQtaW4gTWFwcywgc29ydCB0aGUga2V5cyBpbiBhIHN0YWJsZSBvcmRlciBpbnN0ZWFkIG9mIHRoZVxyXG4gIC8vIGRlZmF1bHQgaW5zZXJ0aW9uIG9yZGVyLiAgU3VwcG9ydCBub24tc3RyaW5nIGtleXMuXHJcblxyXG5cclxuICBpZiAoeCBpbnN0YW5jZW9mIE1hcCkge1xyXG4gICAgY29uc3Qgb2JqID0ge307XHJcblxyXG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgeCkge1xyXG4gICAgICAvLyBTdHJpbmdpZnkgd2lsbCBlc2NhcGUgYW55IG5lc3RlZCBxdW90ZXNcclxuICAgICAgb2JqW3R5cGVvZiBrID09PSAnc3RyaW5nJyA/IGsgOiBzdHJpbmdpZnkoaywgb3B0KV0gPSB2O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHJpbmdpZnkob2JqLCBvcHQsIGtleSk7XHJcbiAgfSAvLyBGb3IgYnVpbHQtaW4gU2V0cywgc29ydCB0aGUga2V5cyBpbiBhIHN0YWJsZSBvcmRlciBpbnN0ZWFkIG9mIHRoZVxyXG4gIC8vIGRlZmF1bHQgaW5zZXJ0aW9uIG9yZGVyLlxyXG5cclxuXHJcbiAgaWYgKHggaW5zdGFuY2VvZiBTZXQpIHtcclxuICAgIHJldHVybiBzdHJpbmdpZnkoQXJyYXkuZnJvbSh4KS5zb3J0KChhLCBiKSA9PiBzdHJpbmdpZnkoYSwgb3B0KS5sb2NhbGVDb21wYXJlKHN0cmluZ2lmeShiLCBvcHQpKSksIG9wdCwga2V5KTtcclxuICB9IC8vIEFueXRoaW5nIGVsc2UgdGhhdCBpcyBpdGVyYWJsZSBzZXJpYWxpemUgYXMgYW4gQXJyYXkuXHJcblxyXG5cclxuICBpZiAoU3ltYm9sICE9PSB1bmRlZmluZWQgJiYgeFtTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgJiYgdHlwZW9mIHhbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTogb2ZmXHJcbiAgICByZXR1cm4gc3RyaW5naWZ5KEFycmF5LmZyb20oeCksIG9wdCwga2V5KTtcclxuICB9IC8vIEZvciBhbGwgb3RoZXIgT2JqZWN0cywgc29ydCB0aGUga2V5cyBpbiBhIHN0YWJsZSBvcmRlci5cclxuXHJcblxyXG4gIHJldHVybiBgeyR7T2JqZWN0LmtleXMoeCkuZmlsdGVyKGsgPT4geFtrXSAhPT0gdW5kZWZpbmVkKS5zb3J0KCkgLy8gc3RyaW5naWZ5IHRoZSBrZXkgdG8gYWRkIHF1b3RlcyBhbmQgZXNjYXBlIGFueSBuZXN0ZWQgc2xhc2hlcyBvciBxdW90ZXMuXHJcbiAgLm1hcChrID0+IGAke3N0cmluZ2lmeShrLCBvcHQpfToke3N0cmluZ2lmeSh4W2tdLCBvcHQsIGspfWApLmpvaW4oJywnKX19YDtcclxufSAvLyBVdGlsaXR5IHNpbWlsYXIgdG8gSlNPTi5zdHJpbmdpZnkoKSBleGNlcHQ6XHJcbi8vICogU2VyaWFsaXplIGJ1aWx0LWluIFNldHMgYXMgYW4gQXJyYXlcclxuLy8gKiBTZXJpYWxpemUgYnVpbHQtaW4gTWFwcyBhcyBhbiBPYmplY3QuICBTdXBwb3J0cyBub24tc3RyaW5nIGtleXMuXHJcbi8vICogU2VyaWFsaXplIG90aGVyIGl0ZXJhYmxlcyBhcyBhcnJheXNcclxuLy8gKiBTb3J0IHRoZSBrZXlzIG9mIE9iamVjdHMgYW5kIE1hcHMgdG8gaGF2ZSBhIHN0YWJsZSBvcmRlciBiYXNlZCBvbiBzdHJpbmcgY29udmVyc2lvbi5cclxuLy8gICAgVGhpcyBvdmVycmlkZXMgdGhlaXIgZGVmYXVsdCBpbnNlcnRpb24gb3JkZXIuXHJcbi8vICogU3RpbGwgdXNlcyB0b0pTT04oKSBvZiBhbnkgb2JqZWN0IHRvIG92ZXJyaWRlIHNlcmlhbGl6YXRpb25cclxuLy8gKiBTdXBwb3J0IFN5bWJvbHMgKHRob3VnaCBkb24ndCBndWFyYW50ZWUgdW5pcXVlbmVzcylcclxuLy8gKiBXZSBjb3VsZCBzdXBwb3J0IEJpZ0ludCwgYnV0IEZsb3cgZG9lc24ndCBzZWVtIHRvIGxpa2UgaXQuXHJcbi8vIFNlZSBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5LXRlc3QuanMgZm9yIGV4YW1wbGVzXHJcblxyXG5cclxuZnVuY3Rpb24gc3RhYmxlU3RyaW5naWZ5KHgsIG9wdCA9IHtcclxuICBhbGxvd0Z1bmN0aW9uczogZmFsc2VcclxufSkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2UgPyB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOiAwO1xyXG4gICAgICBjb25zdCBzdHIgPSBzdHJpbmdpZnkoeCwgb3B0KTtcclxuICAgICAgY29uc3QgZW5kVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6IDA7XHJcblxyXG4gICAgICBpZiAoZW5kVGltZSAtIHN0YXJ0VGltZSA+IFRJTUVfV0FSTklOR19USFJFU0hPTERfTVMpIHtcclxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvbm8tY29uc29sZSAqL1xyXG4gICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoYFJlY29pbDogU3BlbnQgJHtlbmRUaW1lIC0gc3RhcnRUaW1lfW1zIGNvbXB1dGluZyBhIGNhY2hlIGtleWApO1xyXG4gICAgICAgIGNvbnNvbGUud2Fybih4LCBzdHIpO1xyXG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcclxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGZiLXd3dy9uby1jb25zb2xlICovXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyaW5naWZ5KHgsIG9wdCk7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5ID0gc3RhYmxlU3RyaW5naWZ5O1xyXG5cclxuY29uc3Qge1xyXG4gIFRyZWVDYWNoZTogVHJlZUNhY2hlJDJcclxufSA9IFJlY29pbF9UcmVlQ2FjaGUkMTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY29uc3QgZGVmYXVsdFBvbGljeSA9IHtcclxuICBlcXVhbGl0eTogJ3JlZmVyZW5jZScsXHJcbiAgZXZpY3Rpb246ICdrZWVwLWFsbCcsXHJcbiAgbWF4U2l6ZTogSW5maW5pdHlcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyZWVDYWNoZUZyb21Qb2xpY3koe1xyXG4gIGVxdWFsaXR5ID0gZGVmYXVsdFBvbGljeS5lcXVhbGl0eSxcclxuICBldmljdGlvbiA9IGRlZmF1bHRQb2xpY3kuZXZpY3Rpb24sXHJcbiAgbWF4U2l6ZSA9IGRlZmF1bHRQb2xpY3kubWF4U2l6ZVxyXG59ID0gZGVmYXVsdFBvbGljeSwgbmFtZSkge1xyXG4gIGNvbnN0IHZhbHVlTWFwcGVyID0gZ2V0VmFsdWVNYXBwZXIoZXF1YWxpdHkpO1xyXG4gIHJldHVybiBnZXRUcmVlQ2FjaGUoZXZpY3Rpb24sIG1heFNpemUsIHZhbHVlTWFwcGVyLCBuYW1lKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VmFsdWVNYXBwZXIoZXF1YWxpdHkpIHtcclxuICBzd2l0Y2ggKGVxdWFsaXR5KSB7XHJcbiAgICBjYXNlICdyZWZlcmVuY2UnOlxyXG4gICAgICByZXR1cm4gdmFsID0+IHZhbDtcclxuXHJcbiAgICBjYXNlICd2YWx1ZSc6XHJcbiAgICAgIHJldHVybiB2YWwgPT4gUmVjb2lsX3N0YWJsZVN0cmluZ2lmeSh2YWwpO1xyXG4gIH1cclxuXHJcbiAgdGhyb3cgUmVjb2lsX2VycihgVW5yZWNvZ25pemVkIGVxdWFsaXR5IHBvbGljeSAke2VxdWFsaXR5fWApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUcmVlQ2FjaGUoZXZpY3Rpb24sIG1heFNpemUsIG1hcE5vZGVWYWx1ZSwgbmFtZSkge1xyXG4gIHN3aXRjaCAoZXZpY3Rpb24pIHtcclxuICAgIGNhc2UgJ2tlZXAtYWxsJzpcclxuICAgICAgcmV0dXJuIG5ldyBUcmVlQ2FjaGUkMih7XHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBtYXBOb2RlVmFsdWVcclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSAnbHJ1JzpcclxuICAgICAgcmV0dXJuIFJlY29pbF90cmVlQ2FjaGVMUlUoe1xyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgbWF4U2l6ZTogUmVjb2lsX251bGx0aHJvd3MobWF4U2l6ZSksXHJcbiAgICAgICAgbWFwTm9kZVZhbHVlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgJ21vc3QtcmVjZW50JzpcclxuICAgICAgcmV0dXJuIFJlY29pbF90cmVlQ2FjaGVMUlUoe1xyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgbWF4U2l6ZTogMSxcclxuICAgICAgICBtYXBOb2RlVmFsdWVcclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICB0aHJvdyBSZWNvaWxfZXJyKGBVbnJlY29nbml6ZWQgZXZpY3Rpb24gcG9saWN5ICR7ZXZpY3Rpb259YCk7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfdHJlZUNhY2hlRnJvbVBvbGljeSA9IHRyZWVDYWNoZUZyb21Qb2xpY3k7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xyXG4gIHZhciBfb3duZXJEb2N1bWVudCwgX2RvYyRkZWZhdWx0VmlldztcclxuXHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBjb25zdCBkb2MgPSBvYmplY3QgIT0gbnVsbCA/IChfb3duZXJEb2N1bWVudCA9IG9iamVjdC5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfb3duZXJEb2N1bWVudCAhPT0gdm9pZCAwID8gX293bmVyRG9jdW1lbnQgOiBvYmplY3QgOiBkb2N1bWVudDtcclxuICBjb25zdCBkZWZhdWx0VmlldyA9IChfZG9jJGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3KSAhPT0gbnVsbCAmJiBfZG9jJGRlZmF1bHRWaWV3ICE9PSB2b2lkIDAgPyBfZG9jJGRlZmF1bHRWaWV3IDogd2luZG93O1xyXG4gIHJldHVybiAhIShvYmplY3QgIT0gbnVsbCAmJiAodHlwZW9mIGRlZmF1bHRWaWV3Lk5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBkZWZhdWx0Vmlldy5Ob2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcclxufVxyXG5cclxudmFyIFJlY29pbF9pc05vZGUgPSBpc05vZGU7XHJcblxyXG5jb25zdCB7XHJcbiAgaXNSZWFjdE5hdGl2ZTogaXNSZWFjdE5hdGl2ZSQxLFxyXG4gIGlzV2luZG93OiBpc1dpbmRvdyQxXHJcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XHJcblxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gc2hvdWxkTm90QmVGcm96ZW4odmFsdWUpIHtcclxuICAvLyBQcmltaXRpdmVzIGFuZCBmdW5jdGlvbnM6XHJcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gLy8gUmVhY3QgZWxlbWVudHM6XHJcblxyXG5cclxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZS4kJHR5cGVvZikge1xyXG4gICAgY2FzZSAnc3ltYm9sJzpcclxuICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgfSAvLyBJbW11dGFibGUgc3RydWN0dXJlczpcclxuXHJcblxyXG4gIGlmICh2YWx1ZVsnQEBfX0lNTVVUQUJMRV9JVEVSQUJMRV9fQEAnXSAhPSBudWxsIHx8IHZhbHVlWydAQF9fSU1NVVRBQkxFX0tFWUVEX19AQCddICE9IG51bGwgfHwgdmFsdWVbJ0BAX19JTU1VVEFCTEVfSU5ERVhFRF9fQEAnXSAhPSBudWxsIHx8IHZhbHVlWydAQF9fSU1NVVRBQkxFX09SREVSRURfX0BAJ10gIT0gbnVsbCB8fCB2YWx1ZVsnQEBfX0lNTVVUQUJMRV9SRUNPUkRfX0BAJ10gIT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSAvLyBET00gbm9kZXM6XHJcblxyXG5cclxuICBpZiAoUmVjb2lsX2lzTm9kZSh2YWx1ZSkpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKFJlY29pbF9pc1Byb21pc2UodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IC8vIFNvbWUgZW52aXJvbm1lbnRzLCBqdXN0IGFzIEplc3QsIGRvbid0IHdvcmsgd2l0aCB0aGUgaW5zdGFuY2VvZiBjaGVja1xyXG5cclxuXHJcbiAgaWYgKCFpc1JlYWN0TmF0aXZlJDEgJiYgaXNXaW5kb3ckMSh2YWx1ZSkpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59IC8vIFJlY3Vyc2l2ZWx5IGZyZWV6ZSBhIHZhbHVlIHRvIGVuZm9yY2UgaXQgaXMgcmVhZC1vbmx5LlxyXG4vLyBUaGlzIG1heSBhbHNvIGhhdmUgbWluaW1hbCBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudHMgZm9yIGVudW1lcmF0aW5nXHJcbi8vIG9iamVjdHMgKGJhc2VkIG9uIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zLCBvZiBjb3Vyc2UpXHJcblxyXG5cclxuZnVuY3Rpb24gZGVlcEZyZWV6ZVZhbHVlKHZhbHVlKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgc2hvdWxkTm90QmVGcm96ZW4odmFsdWUpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBPYmplY3QuZnJlZXplKHZhbHVlKTsgLy8gTWFrZSBhbGwgcHJvcGVydGllcyByZWFkLW9ubHlcclxuXHJcbiAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcclxuICAgIC8vICRGbG93SXNzdWVbbWV0aG9kLXVuYmluZGluZ10gYWRkZWQgd2hlbiBpbXByb3ZpbmcgdHlwaW5nIGZvciB0aGlzIHBhcmFtZXRlcnNcclxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcclxuICAgICAgY29uc3QgcHJvcCA9IHZhbHVlW2tleV07IC8vIFByZXZlbnQgaW5maW5pdGUgcmVjdXJzc2lvbiBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcy5cclxuXHJcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ29iamVjdCcgJiYgcHJvcCAhPSBudWxsICYmICFPYmplY3QuaXNGcm96ZW4ocHJvcCkpIHtcclxuICAgICAgICBkZWVwRnJlZXplVmFsdWUocHJvcCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIE9iamVjdC5zZWFsKHZhbHVlKTsgLy8gVGhpcyBhbHNvIG1ha2VzIGV4aXN0aW5nIHByb3BlcnRpZXMgbm9uLWNvbmZpZ3VyYWJsZS5cclxufVxyXG5cclxudmFyIFJlY29pbF9kZWVwRnJlZXplVmFsdWUgPSBkZWVwRnJlZXplVmFsdWU7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFRoaXMgaXMgYSBzdHViIGZvciBzb21lIGludGVncmF0aW9uIGludG8gRkIgaW50ZXJuYWwgc3R1ZmZcclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcbmZ1bmN0aW9uIHN0YXJ0UGVyZkJsb2NrKF9pZCkge1xyXG4gIHJldHVybiAoKSA9PiBudWxsO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX1BlcmZvcm1hbmNlVGltaW5ncyA9IHtcclxuICBzdGFydFBlcmZCbG9ja1xyXG59O1xyXG5cclxuY29uc3Qge1xyXG4gIGlzTG9hZGFibGU6IGlzTG9hZGFibGUkMSxcclxuICBsb2FkYWJsZVdpdGhFcnJvcjogbG9hZGFibGVXaXRoRXJyb3IkMSxcclxuICBsb2FkYWJsZVdpdGhQcm9taXNlOiBsb2FkYWJsZVdpdGhQcm9taXNlJDEsXHJcbiAgbG9hZGFibGVXaXRoVmFsdWU6IGxvYWRhYmxlV2l0aFZhbHVlJDJcclxufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xyXG5cclxuY29uc3Qge1xyXG4gIFdyYXBwZWRWYWx1ZTogV3JhcHBlZFZhbHVlJDFcclxufSA9IFJlY29pbF9XcmFwcGVyJDE7XHJcblxyXG5cclxuXHJcbmNvbnN0IHtcclxuICBnZXROb2RlTG9hZGFibGU6IGdldE5vZGVMb2FkYWJsZSQyLFxyXG4gIHBlZWtOb2RlTG9hZGFibGU6IHBlZWtOb2RlTG9hZGFibGUkMSxcclxuICBzZXROb2RlVmFsdWU6IHNldE5vZGVWYWx1ZSQzXHJcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XHJcblxyXG5jb25zdCB7XHJcbiAgc2F2ZURlcHNUb1N0b3JlOiBzYXZlRGVwc1RvU3RvcmUkMVxyXG59ID0gUmVjb2lsX0dyYXBoO1xyXG5cclxuY29uc3Qge1xyXG4gIERFRkFVTFRfVkFMVUU6IERFRkFVTFRfVkFMVUUkNixcclxuICBnZXRDb25maWdEZWxldGlvbkhhbmRsZXI6IGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQxLFxyXG4gIGdldE5vZGU6IGdldE5vZGUkNixcclxuICByZWdpc3Rlck5vZGU6IHJlZ2lzdGVyTm9kZSQxXHJcbn0gPSBSZWNvaWxfTm9kZTtcclxuXHJcbmNvbnN0IHtcclxuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDNcclxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xyXG5cclxuY29uc3Qge1xyXG4gIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkOiBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQxXHJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XHJcblxyXG5jb25zdCB7XHJcbiAgcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0OiByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQkMVxyXG59ID0gUmVjb2lsX1JldGVudGlvbjtcclxuXHJcbmNvbnN0IHtcclxuICByZWNvaWxDYWxsYmFjazogcmVjb2lsQ2FsbGJhY2skMVxyXG59ID0gUmVjb2lsX3VzZVJlY29pbENhbGxiYWNrO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY29uc3Qge1xyXG4gIHN0YXJ0UGVyZkJsb2NrOiBzdGFydFBlcmZCbG9jayQxXHJcbn0gPSBSZWNvaWxfUGVyZm9ybWFuY2VUaW1pbmdzO1xyXG5cclxuXHJcblxyXG5jbGFzcyBDYW5jZWxlZCB7fVxyXG5cclxuY29uc3QgQ0FOQ0VMRUQgPSBuZXcgQ2FuY2VsZWQoKTtcclxuLyoqXHJcbiAqIEFuIEV4ZWN1dGlvbklEIGlzIGFuIGFyYml0cmFyeSBJRCB0aGF0IGxldHMgdXMgZGlzdGluZ3Vpc2ggZXhlY3V0aW9ucyBmcm9tXHJcbiAqIGVhY2ggb3RoZXIuIFRoaXMgaXMgbmVjZXNzYXJ5IGFzIHdlIG5lZWQgYSB3YXkgb2Ygc29sdmluZyB0aGlzIHByb2JsZW06XHJcbiAqIFwiZ2l2ZW4gMyBhc3luYyBleGVjdXRpb25zLCBvbmx5IHVwZGF0ZSBzdGF0ZSBmb3IgdGhlICdsYXRlc3QnIGV4ZWN1dGlvbiB3aGVuXHJcbiAqIGl0IGZpbmlzaGVzIHJ1bm5pbmcgcmVnYXJkbGVzcyBvZiB3aGVuIHRoZSBvdGhlciAyIGZpbmlzaFwiLiBFeGVjdXRpb25JRHNcclxuICogcHJvdmlkZSBhIGNvbnZlbmllbnQgd2F5IG9mIGlkZW50aWZ5aW5nIGV4ZWN1dGlvbnMgc28gdGhhdCB3ZSBjYW4gdHJhY2sgYW5kXHJcbiAqIG1hbmFnZSB0aGVtIG92ZXIgdGltZS5cclxuICovXHJcblxyXG5jb25zdCBkZXBlbmRlbmN5U3RhY2sgPSBbXTsgLy8gZm9yIGRldGVjdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXHJcblxyXG5jb25zdCB3YWl0aW5nU3RvcmVzID0gbmV3IE1hcCgpO1xyXG5cclxuY29uc3QgZ2V0TmV3RXhlY3V0aW9uSUQgPSAoKCkgPT4ge1xyXG4gIGxldCBleGVjdXRpb25JRCA9IDA7XHJcbiAgcmV0dXJuICgpID0+IGV4ZWN1dGlvbklEKys7XHJcbn0pKCk7XHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIHNlbGVjdG9yKG9wdGlvbnMpIHtcclxuICBsZXQgcmVjb2lsVmFsdWUgPSBudWxsO1xyXG4gIGNvbnN0IHtcclxuICAgIGtleSxcclxuICAgIGdldCxcclxuICAgIGNhY2hlUG9saWN5X1VOU1RBQkxFOiBjYWNoZVBvbGljeVxyXG4gIH0gPSBvcHRpb25zO1xyXG4gIGNvbnN0IHNldCA9IG9wdGlvbnMuc2V0ICE9IG51bGwgPyBvcHRpb25zLnNldCA6IHVuZGVmaW5lZDsgLy8gZmxvd1xyXG5cclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgUmVjb2lsX2VycignQSBrZXkgb3B0aW9uIHdpdGggYSB1bmlxdWUgc3RyaW5nIHZhbHVlIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBjcmVhdGluZyBhIHNlbGVjdG9yLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IFJlY29pbF9lcnIoJ1NlbGVjdG9ycyBtdXN0IHNwZWNpZnkgYSBnZXQgY2FsbGJhY2sgb3B0aW9uIHRvIGdldCB0aGUgc2VsZWN0b3IgdmFsdWUuJyk7XHJcbiAgICB9XHJcbiAgfSAvLyBUaGlzIGlzIGV2ZXJ5IGRpc2NvdmVyZWQgZGVwZW5kZW5jeSBhY3Jvc3MgYWxsIGV4ZWN1dGlvbnNcclxuXHJcblxyXG4gIGNvbnN0IGRpc2NvdmVyZWREZXBlbmRlbmN5Tm9kZUtleXMgPSBuZXcgU2V0KCk7XHJcbiAgY29uc3QgY2FjaGUgPSBSZWNvaWxfdHJlZUNhY2hlRnJvbVBvbGljeShjYWNoZVBvbGljeSAhPT0gbnVsbCAmJiBjYWNoZVBvbGljeSAhPT0gdm9pZCAwID8gY2FjaGVQb2xpY3kgOiB7XHJcbiAgICBlcXVhbGl0eTogJ3JlZmVyZW5jZScsXHJcbiAgICBldmljdGlvbjogJ2tlZXAtYWxsJ1xyXG4gIH0sIGtleSk7XHJcbiAgY29uc3QgcmV0YWluZWRCeSA9IHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCQxKG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSk7XHJcbiAgY29uc3QgZXhlY3V0aW9uSW5mb01hcCA9IG5ldyBNYXAoKTtcclxuICBsZXQgbGl2ZVN0b3Jlc0NvdW50ID0gMDtcclxuXHJcbiAgZnVuY3Rpb24gc2VsZWN0b3JJc0xpdmUoKSB7XHJcbiAgICByZXR1cm4gIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykgfHwgbGl2ZVN0b3Jlc0NvdW50ID4gMDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNlbGVjdG9ySW5pdChzdG9yZSkge1xyXG4gICAgc3RvcmUuZ2V0U3RhdGUoKS5rbm93blNlbGVjdG9ycy5hZGQoa2V5KTtcclxuICAgIGxpdmVTdG9yZXNDb3VudCsrO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgbGl2ZVN0b3Jlc0NvdW50LS07XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2VsZWN0b3JTaG91bGREZWxldGVDb25maWdPblJlbGVhc2UoKSB7XHJcbiAgICByZXR1cm4gZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDEoa2V5KSAhPT0gdW5kZWZpbmVkICYmICFzZWxlY3RvcklzTGl2ZSgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVzb2x2ZUFzeW5jKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpIHtcclxuICAgIHNldENhY2hlKHN0YXRlLCBsb2FkYWJsZSwgZGVwVmFsdWVzKTtcclxuICAgIG5vdGlmeVN0b3Jlc09mUmVzb2x2ZWRBc3luYyhzdG9yZSwgZXhlY3V0aW9uSUQpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbm90aWZ5U3RvcmVzT2ZSZXNvbHZlZEFzeW5jKHN0b3JlLCBleGVjdXRpb25JRCkge1xyXG4gICAgaWYgKGlzTGF0ZXN0RXhlY3V0aW9uKHN0b3JlLCBleGVjdXRpb25JRCkpIHtcclxuICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcclxuICAgIH1cclxuXHJcbiAgICBub3RpZnlXYWl0aW5nU3RvcmVzKGV4ZWN1dGlvbklELCB0cnVlKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogTm90aWZ5IHN0b3JlcyB0byBwdWxsIHRoZSBzZWxlY3RvciBhZ2FpbiBpZiBhIG5ldyBhc3luYyBkZXAgd2FzIGRpc2NvdmVyZWQuXHJcbiAgICogMSkgQXN5bmMgc2VsZWN0b3IgYWRkcyBhIG5ldyBkZXAgYnV0IGRvZXNuJ3QgcmVzb2x2ZSB5ZXQuXHJcbiAgICogICAgTm90ZSB0aGF0IGRlcHMgZm9yIGFuIGFzeW5jIHNlbGVjdG9yIGFyZSBiYXNlZCBvbiB0aGUgc3RhdGUgd2hlbiB0aGVcclxuICAgKiAgICBldmFsdWF0aW9uIHN0YXJ0ZWQsIGluIG9yZGVyIHRvIHByb3ZpZGUgYSBjb25zaXN0ZW50IHBpY3R1cmUgb2Ygc3RhdGUuXHJcbiAgICogMikgQnV0LCBuZXcgdmFsdWUgb2YgZGVwIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIG1pZ2h0IGNhdXNlIHRoZSBzZWxlY3RvclxyXG4gICAqICAgIHRvIHJlc29sdmUgb3IgcmVzb2x2ZSBkaWZmZXJlbnRseS5cclxuICAgKiAzKSBUaGVyZWZvcmUsIHRoaXMgbm90aWZpY2F0aW9uIHdpbGwgcHVsbCB0aGUgc2VsZWN0b3IgYmFzZWQgb24gdGhlIGN1cnJlbnRcclxuICAgKiAgICBzdGF0ZSBmb3IgdGhlIGNvbXBvbmVudHNcclxuICAgKi9cclxuXHJcblxyXG4gIGZ1bmN0aW9uIG5vdGlmeVN0b3Jlc09mTmV3QXN5bmNEZXAoc3RvcmUsIGV4ZWN1dGlvbklEKSB7XHJcbiAgICBpZiAoaXNMYXRlc3RFeGVjdXRpb24oc3RvcmUsIGV4ZWN1dGlvbklEKSkge1xyXG4gICAgICBjb25zdCBleGVjdXRpb25JbmZvID0gUmVjb2lsX251bGx0aHJvd3MoZ2V0RXhlY3V0aW9uSW5mbyhzdG9yZSkpO1xyXG4gICAgICBleGVjdXRpb25JbmZvLnN0YXRlVmVyc2lvbnMuY2xlYXIoKTtcclxuICAgICAgbm90aWZ5V2FpdGluZ1N0b3JlcyhleGVjdXRpb25JRCwgZmFsc2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbm90aWZ5V2FpdGluZ1N0b3JlcyhleGVjdXRpb25JRCwgY2xlYXJXYWl0bGlzdCkge1xyXG4gICAgY29uc3Qgc3RvcmVzID0gd2FpdGluZ1N0b3Jlcy5nZXQoZXhlY3V0aW9uSUQpO1xyXG5cclxuICAgIGlmIChzdG9yZXMgIT0gbnVsbCkge1xyXG4gICAgICBmb3IgKGNvbnN0IHdhaXRpbmdTdG9yZSBvZiBzdG9yZXMpIHtcclxuICAgICAgICBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQxKHdhaXRpbmdTdG9yZSwgUmVjb2lsX251bGx0aHJvd3MocmVjb2lsVmFsdWUpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNsZWFyV2FpdGxpc3QpIHtcclxuICAgICAgICB3YWl0aW5nU3RvcmVzLmRlbGV0ZShleGVjdXRpb25JRCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG1hcmtTdG9yZVdhaXRpbmdGb3JSZXNvbHZlZEFzeW5jKHN0b3JlLCBleGVjdXRpb25JRCkge1xyXG4gICAgbGV0IHN0b3JlcyA9IHdhaXRpbmdTdG9yZXMuZ2V0KGV4ZWN1dGlvbklEKTtcclxuXHJcbiAgICBpZiAoc3RvcmVzID09IG51bGwpIHtcclxuICAgICAgd2FpdGluZ1N0b3Jlcy5zZXQoZXhlY3V0aW9uSUQsIHN0b3JlcyA9IG5ldyBTZXQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RvcmVzLmFkZChzdG9yZSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gYXR0YWNoZXMgYSB0aGVuKCkgYW5kIGEgY2F0Y2goKSB0byBhIHByb21pc2UgdGhhdCB3YXNcclxuICAgKiByZXR1cm5lZCBmcm9tIGEgc2VsZWN0b3IncyBnZXQoKSAoZWl0aGVyIGV4cGxpY2l0bHkgb3IgaW1wbGljaXRseSBieVxyXG4gICAqIHJ1bm5pbmcgYSBmdW5jdGlvbiB0aGF0IHVzZXMgdGhlIFwiYXN5bmNcIiBrZXl3b3JkKS4gSWYgYSBzZWxlY3RvcidzIGdldCgpXHJcbiAgICogcmV0dXJucyBhIHByb21pc2UsIHdlIGhhdmUgdHdvIHBvc3NpYmlsaXRpZXM6XHJcbiAgICpcclxuICAgKiAxLiBUaGUgcHJvbWlzZSB3aWxsIHJlc29sdmUsIGluIHdoaWNoIGNhc2UgaXQgd2lsbCBoYXZlIGNvbXBsZXRlbHkgZmluaXNoZWRcclxuICAgKiAgICBleGVjdXRpbmcgd2l0aG91dCBhbnkgcmVtYWluaW5nIHBlbmRpbmcgZGVwZW5kZW5jaWVzLiBObyBtb3JlIHJldHJpZXNcclxuICAgKiAgICBhcmUgbmVlZGVkIGFuZCB3ZSBjYW4gcHJvY2VlZCB3aXRoIHVwZGF0aW5nIHRoZSBjYWNoZSBhbmQgbm90aWZ5aW5nXHJcbiAgICogICAgc3Vic2NyaWJlcnMgKGlmIGl0IGlzIHRoZSBsYXRlc3QgZXhlY3V0aW9uLCBvdGhlcndpc2Ugb25seSB0aGUgY2FjaGVcclxuICAgKiAgICB3aWxsIGJlIHVwZGF0ZWQgYW5kIHN1YnNjcmlwdGlvbnMgd2lsbCBub3QgYmUgZmlyZWQpLiBUaGlzIGlzIHRoZSBjYXNlXHJcbiAgICogICAgaGFuZGxlZCBieSB0aGUgYXR0YWNoZWQgdGhlbigpIGhhbmRsZXIuXHJcbiAgICpcclxuICAgKiAyLiBUaGUgcHJvbWlzZSB3aWxsIHRocm93IGJlY2F1c2UgaXQgZWl0aGVyIGhhcyBhbiBlcnJvciBvciBpdCBjYW1lIGFjcm9zc1xyXG4gICAqICAgIGFuIGFzeW5jIGRlcGVuZGVuY3kgdGhhdCBoYXMgbm90IHlldCByZXNvbHZlZCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsXHJcbiAgICogICAgY2FsbCB3cmFwRGVwZGVuY3lQcm9taXNlKCksIHdob3NlIHJlc3BvbnNpYmlsaXR5IGlzIHRvIGhhbmRsZSBkZXBlbmRlbmN5XHJcbiAgICogICAgcHJvbWlzZXMuIFRoaXMgY2FzZSBpcyBoYW5kbGVkIGJ5IHRoZSBhdHRhY2hlZCBjYXRjaCgpIGhhbmRsZXIuXHJcbiAgICpcclxuICAgKiBCb3RoIGJyYW5jaGVzIHdpbGwgZXZlbnR1YWxseSByZXNvbHZlIHRvIHRoZSBmaW5hbCByZXN1bHQgb2YgdGhlIHNlbGVjdG9yXHJcbiAgICogKG9yIGFuIGVycm9yIGlmIGEgcmVhbCBlcnJvciBvY2N1cnJlZCkuXHJcbiAgICpcclxuICAgKiBUaGUgZXhlY3V0aW9uIHdpbGwgcnVuIHRvIGNvbXBsZXRpb24gZXZlbiBpZiBpdCBpcyBzdGFsZSwgYW5kIGl0cyB2YWx1ZVxyXG4gICAqIHdpbGwgYmUgY2FjaGVkLiBCdXQgc3RhbGUgZXhlY3V0aW9ucyB3aWxsIG5vdCB1cGRhdGUgZ2xvYmFsIHN0YXRlIG9yIHVwZGF0ZVxyXG4gICAqIGV4ZWN1dGlvbkluZm8gYXMgdGhhdCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlICdsYXRlc3QnIGV4ZWN1dGlvbi5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIHBhc3NlZCBhIHByb21pc2UgdGhhdCB3YXMgdGhyb3duLS1BS0EgYVxyXG4gICAqIGRlcGVuZGVuY3kgcHJvbWlzZS4gRGVwZW5kZW5jeSBwcm9taXNlcyBzaG91bGQgYmUgcGFzc2VkIHRvXHJcbiAgICogd3JhcFBlbmRpbmdEZXBlbmRlbmN5UHJvbWlzZSgpKS5cclxuICAgKi9cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHdyYXBSZXN1bHRQcm9taXNlKHN0b3JlLCBwcm9taXNlLCBzdGF0ZSwgZGVwVmFsdWVzLCBleGVjdXRpb25JRCwgbG9hZGluZ0RlcHNTdGF0ZSkge1xyXG4gICAgcmV0dXJuIHByb21pc2UudGhlbih2YWx1ZSA9PiB7XHJcbiAgICAgIGlmICghc2VsZWN0b3JJc0xpdmUoKSkge1xyXG4gICAgICAgIC8vIFRoZSBzZWxlY3RvciB3YXMgcmVsZWFzZWQgc2luY2UgdGhlIHJlcXVlc3QgYmVnYW47IGlnbm9yZSB0aGUgcmVzcG9uc2UuXHJcbiAgICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcclxuICAgICAgICB0aHJvdyBDQU5DRUxFRDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbG9hZGFibGUgPSBsb2FkYWJsZVdpdGhWYWx1ZSQyKHZhbHVlKTtcclxuICAgICAgcmVzb2x2ZUFzeW5jKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9KS5jYXRjaChlcnJvck9yUHJvbWlzZSA9PiB7XHJcbiAgICAgIGlmICghc2VsZWN0b3JJc0xpdmUoKSkge1xyXG4gICAgICAgIC8vIFRoZSBzZWxlY3RvciB3YXMgcmVsZWFzZWQgc2luY2UgdGhlIHJlcXVlc3QgYmVnYW47IGlnbm9yZSB0aGUgcmVzcG9uc2UuXHJcbiAgICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcclxuICAgICAgICB0aHJvdyBDQU5DRUxFRDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UoZXJyb3JPclByb21pc2UpKSB7XHJcbiAgICAgICAgcmV0dXJuIHdyYXBQZW5kaW5nRGVwZW5kZW5jeVByb21pc2Uoc3RvcmUsIGVycm9yT3JQcm9taXNlLCBzdGF0ZSwgZGVwVmFsdWVzLCBleGVjdXRpb25JRCwgbG9hZGluZ0RlcHNTdGF0ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGxvYWRhYmxlID0gbG9hZGFibGVXaXRoRXJyb3IkMShlcnJvck9yUHJvbWlzZSk7XHJcbiAgICAgIHJlc29sdmVBc3luYyhzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklELCBsb2FkYWJsZSwgZGVwVmFsdWVzKTtcclxuICAgICAgdGhyb3cgZXJyb3JPclByb21pc2U7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogVGhpcyBmdW5jdGlvbiBhdHRhY2hlcyBhIHRoZW4oKSBhbmQgYSBjYXRjaCgpIHRvIGEgcHJvbWlzZSB0aGF0IHdhc1xyXG4gICAqIHRocm93biBmcm9tIGEgc2VsZWN0b3IncyBnZXQoKS4gSWYgYSBzZWxlY3RvcidzIGdldCgpIHRocm93cyBhIHByb21pc2UsXHJcbiAgICogd2UgaGF2ZSB0d28gcG9zc2liaWxpdGllczpcclxuICAgKlxyXG4gICAqIDEuIFRoZSBwcm9taXNlIHdpbGwgcmVzb2x2ZSwgbWVhbmluZyBvbmUgb2Ygb3VyIHNlbGVjdG9yJ3MgZGVwZW5kZW5jaWVzIGlzXHJcbiAgICogICAgbm93IGF2YWlsYWJsZSBhbmQgd2Ugc2hvdWxkIFwicmV0cnlcIiBvdXIgZ2V0KCkgYnkgcnVubmluZyBpdCBhZ2Fpbi4gVGhpc1xyXG4gICAqICAgIGlzIHRoZSBjYXNlIGhhbmRsZWQgYnkgdGhlIGF0dGFjaGVkIHRoZW4oKSBoYW5kbGVyLlxyXG4gICAqXHJcbiAgICogMi4gVGhlIHByb21pc2Ugd2lsbCB0aHJvdyBiZWNhdXNlIHNvbWV0aGluZyB3ZW50IHdyb25nIHdpdGggdGhlIGRlcGVuZGVuY3lcclxuICAgKiAgICBwcm9taXNlIChpbiBvdGhlciB3b3JkcyBhIHJlYWwgZXJyb3Igb2NjdXJyZWQpLiBUaGlzIGNhc2UgaXMgaGFuZGxlZCBieVxyXG4gICAqICAgIHRoZSBhdHRhY2hlZCBjYXRjaCgpIGhhbmRsZXIuIElmIHRoZSBkZXBlbmRlbmN5IHByb21pc2UgdGhyb3dzLCBpdCBpc1xyXG4gICAqICAgIF9hbHdheXNfIGEgcmVhbCBlcnJvciBhbmQgbm90IGFub3RoZXIgZGVwZW5kZW5jeSBwcm9taXNlIChhbnkgZGVwZW5kZW5jeVxyXG4gICAqICAgIHByb21pc2VzIHdvdWxkIGhhdmUgYmVlbiBoYW5kbGVkIHVwc3RyZWFtKS5cclxuICAgKlxyXG4gICAqIFRoZSB0aGVuKCkgYnJhbmNoIHdpbGwgZXZlbnR1YWxseSByZXNvbHZlIHRvIHRoZSBmaW5hbCByZXN1bHQgb2YgdGhlXHJcbiAgICogc2VsZWN0b3IgKG9yIGFuIGVycm9yIGlmIGEgcmVhbCBlcnJvciBvY2N1cnMpLCBhbmQgdGhlIGNhdGNoKCkgd2lsbCBhbHdheXNcclxuICAgKiByZXNvbHZlIHRvIGFuIGVycm9yIGJlY2F1c2UgdGhlIGRlcGVuZGVuY3kgcHJvbWlzZSBpcyBhIHByb21pc2UgdGhhdCB3YXNcclxuICAgKiB3cmFwcGVkIHVwc3RyZWFtLCBtZWFuaW5nIGl0IHdpbGwgb25seSByZXNvbHZlIHRvIGl0cyByZWFsIHZhbHVlIG9yIHRvIGFcclxuICAgKiByZWFsIGVycm9yLlxyXG4gICAqXHJcbiAgICogVGhlIGV4ZWN1dGlvbiB3aWxsIHJ1biB0byBjb21wbGV0aW9uIGV2ZW4gaWYgaXQgaXMgc3RhbGUsIGFuZCBpdHMgdmFsdWVcclxuICAgKiB3aWxsIGJlIGNhY2hlZC4gQnV0IHN0YWxlIGV4ZWN1dGlvbnMgd2lsbCBub3QgdXBkYXRlIGdsb2JhbCBzdGF0ZSBvciB1cGRhdGVcclxuICAgKiBleGVjdXRpb25JbmZvIGFzIHRoYXQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSAnbGF0ZXN0JyBleGVjdXRpb24uXHJcbiAgICpcclxuICAgKiBOb3RlIHRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBwYXNzZWQgYSBwcm9taXNlIHRoYXQgd2FzIHJldHVybmVkIGZyb21cclxuICAgKiBnZXQoKS4gVGhlIGludGVudGlvbiBpcyB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgb25seSBwYXNzZWQgcHJvbWlzZXMgdGhhdFxyXG4gICAqIHdlcmUgdGhyb3duIGR1ZSB0byBhIHBlbmRpbmcgZGVwZW5kZW5jeS4gUHJvbWlzZXMgcmV0dXJuZWQgYnkgZ2V0KCkgc2hvdWxkXHJcbiAgICogYmUgcGFzc2VkIHRvIHdyYXBSZXN1bHRQcm9taXNlKCkgaW5zdGVhZC5cclxuICAgKi9cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHdyYXBQZW5kaW5nRGVwZW5kZW5jeVByb21pc2Uoc3RvcmUsIHByb21pc2UsIHN0YXRlLCBleGlzdGluZ0RlcHMsIGV4ZWN1dGlvbklELCBsb2FkaW5nRGVwc1N0YXRlKSB7XHJcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKHJlc29sdmVkRGVwID0+IHtcclxuICAgICAgaWYgKCFzZWxlY3RvcklzTGl2ZSgpKSB7XHJcbiAgICAgICAgLy8gVGhlIHNlbGVjdG9yIHdhcyByZWxlYXNlZCBzaW5jZSB0aGUgcmVxdWVzdCBiZWdhbjsgaWdub3JlIHRoZSByZXNwb25zZS5cclxuICAgICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xyXG4gICAgICAgIHRocm93IENBTkNFTEVEO1xyXG4gICAgICB9IC8vIENoZWNrIGlmIHdlIGFyZSBoYW5kbGluZyBhIHBlbmRpbmcgUmVjb2lsIGRlcGVuZGVuY3kgb3IgaWYgdGhlIHVzZXJcclxuICAgICAgLy8gdGhyZXcgdGhlaXIgb3duIFByb21pc2UgdG8gXCJzdXNwZW5kXCIgYSBzZWxlY3RvciBldmFsdWF0aW9uLiAgV2UgbmVlZFxyXG4gICAgICAvLyB0byBjaGVjayB0aGF0IHRoZSBsb2FkaW5nRGVwUHJvbWlzZSBhY3R1YWxseSBtYXRjaGVzIHRoZSBwcm9taXNlIHRoYXRcclxuICAgICAgLy8gd2UgY2F1Z2h0IGluIGNhc2UgdGhlIHNlbGVjdG9yIGhhcHBlbmVkIHRvIGNhdGNoIHRoZSBwcm9taXNlIHdlIHRocmV3XHJcbiAgICAgIC8vIGZvciBhIHBlbmRpbmcgUmVjb2lsIGRlcGVuZGVuY3kgZnJvbSBgZ2V0UmVjb2lsVmFsdWUoKWAgYW5kIHRocmV3XHJcbiAgICAgIC8vIHRoZWlyIG93biBwcm9taXNlIGluc3RlYWQuXHJcblxyXG5cclxuICAgICAgaWYgKGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcEtleSAhPSBudWxsICYmIGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcFByb21pc2UgPT09IHByb21pc2UpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOb3RlIGZvciBhc3luYyBhdG9tcywgdGhpcyBtZWFucyB3ZSBhcmUgY2hhbmdpbmcgdGhlIGF0b20ncyB2YWx1ZVxyXG4gICAgICAgICAqIGluIHRoZSBzdG9yZSBmb3IgdGhlIGdpdmVuIHZlcnNpb24uIFRoaXMgc2hvdWxkIGJlIGFscmlnaHQgYmVjYXVzZVxyXG4gICAgICAgICAqIHRoZSB2ZXJzaW9uIG9mIHN0YXRlIGlzIG5vdyBzdGFsZSBhbmQgYSBuZXcgdmVyc2lvbiB3aWxsIGhhdmVcclxuICAgICAgICAgKiBhbHJlYWR5IGJlZW4gdHJpZ2dlcmVkIGJ5IHRoZSBhdG9tIGJlaW5nIHJlc29sdmVkIChzZWUgdGhpcyBsb2dpY1xyXG4gICAgICAgICAqIGluIFJlY29pbF9hdG9tLmpzKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRlLmF0b21WYWx1ZXMuc2V0KGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcEtleSwgbG9hZGFibGVXaXRoVmFsdWUkMihyZXNvbHZlZERlcCkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHJlc29sdmVkRGVwS2V5IGlzIG5vdCBkZWZpbmVkLCB0aGUgcHJvbWlzZSB3YXMgYSB1c2VyLXRocm93blxyXG4gICAgICAgICAqIHByb21pc2UuIFVzZXItdGhyb3duIHByb21pc2VzIGFyZSBhbiBhZHZhbmNlZCBmZWF0dXJlIGFuZCB0aGV5XHJcbiAgICAgICAgICogc2hvdWxkIGJlIGF2b2lkZWQgaW4gYWxtb3N0IGFsbCBjYXNlcy4gVXNpbmcgYGxvYWRhYmxlLm1hcCgpYCBpbnNpZGVcclxuICAgICAgICAgKiBvZiBzZWxlY3RvcnMgZm9yIGxvYWRpbmcgbG9hZGFibGVzIGFuZCB0aGVuIHRocm93aW5nIHRoYXQgbWFwcGVkXHJcbiAgICAgICAgICogbG9hZGFibGUncyBwcm9taXNlIGlzIGFuIGV4YW1wbGUgb2YgYSB1c2VyLXRocm93biBwcm9taXNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiB3ZSBoaXQgYSB1c2VyLXRocm93biBwcm9taXNlLCB3ZSBoYXZlIHRvIGJhaWwgb3V0IG9mIGFuIG9wdGltaXphdGlvblxyXG4gICAgICAgICAqIHdoZXJlIHdlIGJ5cGFzcyBjYWxjdWxhdGluZyBzZWxlY3RvciBjYWNoZSBrZXlzIGZvciBzZWxlY3RvcnMgdGhhdFxyXG4gICAgICAgICAqIGhhdmUgYmVlbiBwcmV2aW91c2x5IHNlZW4gZm9yIGEgZ2l2ZW4gc3RhdGUgKHRoZXNlIHNlbGVjdG9ycyBhcmUgc2F2ZWQgaW5cclxuICAgICAgICAgKiBzdGF0ZS5hdG9tVmFsdWVzKSB0byBhdm9pZCBzdGFsZSBzdGF0ZSBhcyB3ZSBoYXZlIG5vIHdheSBvZiBrbm93aW5nXHJcbiAgICAgICAgICogd2hhdCBzdGF0ZSBjaGFuZ2VzIGhhcHBlbmVkIChpZiBhbnkpIGluIHJlc3VsdCB0byB0aGUgcHJvbWlzZSByZXNvbHZpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJZGVhbGx5IHdlIHdvdWxkIG9ubHkgYmFpbCBvdXQgc2VsZWN0b3JzIHRoYXQgYXJlIGluIHRoZSBjaGFpbiBvZlxyXG4gICAgICAgICAqIGRlcGVuZGVuY2llcyBmb3IgdGhpcyBzZWxlY3RvciwgYnV0IHRoZXJlJ3MgY3VycmVudGx5IG5vIHdheSB0byBnZXRcclxuICAgICAgICAgKiBhIGZ1bGwgbGlzdCBvZiBhIHNlbGVjdG9yJ3MgZG93bnN0cmVhbSBub2RlcyBiZWNhdXNlIHRoZSBzdGF0ZSB0aGF0XHJcbiAgICAgICAgICogaXMgZXhlY3V0aW5nIG1heSBiZSBhIGRpc2NhcmRlZCB0cmVlIChzbyBzdG9yZS5nZXRHcmFwaChzdGF0ZS52ZXJzaW9uKVxyXG4gICAgICAgICAqIHdpbGwgYmUgZW1wdHkpLCBhbmQgdGhlIGZ1bGwgZGVwIHRyZWUgbWF5IG5vdCBiZSBpbiB0aGUgc2VsZWN0b3JcclxuICAgICAgICAgKiBjYWNoZXMgaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHNlbGVjdG9yJ3MgY2FjaGUgd2FzIGNsZWFyZWQuIFRvIHNvbHZlXHJcbiAgICAgICAgICogZm9yIHRoaXMgd2Ugd291bGQgaGF2ZSB0byBrZWVwIHRyYWNrIG9mIGFsbCBydW5uaW5nIHNlbGVjdG9yXHJcbiAgICAgICAgICogZXhlY3V0aW9ucyBhbmQgdGhlaXIgZG93bnN0cmVhbSBkZXBzLiBCZWNhdXNlIHRoaXMgb25seSBjb3ZlcnMgZWRnZVxyXG4gICAgICAgICAqIGNhc2VzLCB0aGF0IGNvbXBsZXhpdHkgbWlnaHQgbm90IGJlIGp1c3RpZnlhYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkua25vd25TZWxlY3RvcnMuZm9yRWFjaChub2RlS2V5ID0+IHtcclxuICAgICAgICAgIHN0YXRlLmF0b21WYWx1ZXMuZGVsZXRlKG5vZGVLZXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBPcHRpbWl6YXRpb246IE5vdyB0aGF0IHRoZSBkZXBlbmRlbmN5IGhhcyByZXNvbHZlZCwgbGV0J3MgdHJ5IGhpdHRpbmdcclxuICAgICAgICogdGhlIGNhY2hlIGluIGNhc2UgdGhlIGRlcCByZXNvbHZlZCB0byBhIHZhbHVlIHdlIGhhdmUgcHJldmlvdXNseSBzZWVuLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBUT0RPOlxyXG4gICAgICAgKiBOb3RlIHRoaXMgb3B0aW1pemF0aW9uIGlzIG5vdCBwZXJmZWN0IGJlY2F1c2UgaXQgb25seSBwcmV2ZW50cyByZS1leGVjdXRpb25zXHJcbiAgICAgICAqIF9hZnRlcl8gdGhlIHBvaW50IHdoZXJlIGFuIGFzeW5jIGRlcGVuZGVuY3kgaXMgZm91bmQuIEFueSBjb2RlIGxlYWRpbmdcclxuICAgICAgICogdXAgdG8gdGhlIGFzeW5jIGRlcGVuZGVuY3kgbWF5IGhhdmUgcnVuIHVubmVjZXNzYXJpbHkuIFRoZSBpZGVhbCBjYXNlXHJcbiAgICAgICAqIHdvdWxkIGJlIHRvIHdhaXQgZm9yIHRoZSBhc3luYyBkZXBlbmRlbmN5IHRvIHJlc29sdmUgZmlyc3QsIGNoZWNrIHRoZVxyXG4gICAgICAgKiBjYWNoZSwgYW5kIHByZXZlbnQgX2FueV8gZXhlY3V0aW9uIG9mIHRoZSBzZWxlY3RvciBpZiB0aGUgcmVzdWx0aW5nXHJcbiAgICAgICAqIHZhbHVlIG9mIHRoZSBkZXBlbmRlbmN5IGxlYWRzIHRvIGEgcGF0aCB0aGF0IGlzIGZvdW5kIGluIHRoZSBjYWNoZS5cclxuICAgICAgICogVGhlIGlkZWFsIGNhc2UgaXMgbW9yZSBkaWZmaWN1bHQgdG8gaW1wbGVtZW50IGFzIGl0IHdvdWxkIHJlcXVpcmUgdGhhdFxyXG4gICAgICAgKiB3ZSBjYXB0dXJlIGFuZCB3YWl0IGZvciB0aGUgdGhlIGFzeW5jIGRlcGVuZGVuY3kgcmlnaHQgYWZ0ZXIgY2hlY2tpbmdcclxuICAgICAgICogdGhlIGNhY2hlLiBUaGUgY3VycmVudCBhcHByb2FjaCB0YWtlcyBhZHZhbnRhZ2Ugb2YgdGhlIGZhY3QgdGhhdCBydW5uaW5nXHJcbiAgICAgICAqIHRoZSBzZWxlY3RvciBhbHJlYWR5IGhhcyBhIGNvZGUgcGF0aCB0aGF0IGxldHMgdXMgZXhpdCBlYXJseSB3aGVuXHJcbiAgICAgICAqIGFuIGFzeW5jIGRlcCByZXNvbHZlcy5cclxuICAgICAgICovXHJcblxyXG5cclxuICAgICAgY29uc3QgY2FjaGVkTG9hZGFibGUgPSBnZXRMb2FkYWJsZUZyb21DYWNoZUFuZFVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlKTtcclxuXHJcbiAgICAgIGlmIChjYWNoZWRMb2FkYWJsZSAmJiBjYWNoZWRMb2FkYWJsZS5zdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBoYXMgdG8gbm90aWZ5IHN0b3JlcyBvZiBhIHJlc29sdmVkIGFzeW5jLCBldmVuIGlmIHRoZXJlIGlzIG5vXHJcbiAgICAgICAgICogY3VycmVudCBwZW5kaW5nIGV4ZWN1dGlvbiBmb3IgdGhlIGZvbGxvd2luZyBjYXNlOlxyXG4gICAgICAgICAqIDEpIEEgY29tcG9uZW50IHJlbmRlcnMgd2l0aCB0aGlzIHBlbmRpbmcgbG9hZGFibGUuXHJcbiAgICAgICAgICogMikgVGhlIHVwc3RyZWFtIGRlcGVuZGVuY3kgcmVzb2x2ZXMuXHJcbiAgICAgICAgICogMykgV2hpbGUgcHJvY2Vzc2luZyBzb21lIG90aGVyIHNlbGVjdG9yIGl0IHJlYWRzIHRoaXMgb25lLCBzdWNoIGFzXHJcbiAgICAgICAgICogICAgd2hpbGUgdHJhdmVyc2luZyBpdHMgZGVwZW5kZW5jaWVzLiAgQXQgdGhpcyBwb2ludCBpdCBnZXRzIHRoZVxyXG4gICAgICAgICAqICAgIG5ldyByZXNvbHZlZCB2YWx1ZSBzeW5jaHJvbm91c2x5IGFuZCBjbGVhcnMgdGhlIGN1cnJlbnRcclxuICAgICAgICAgKiAgICBleGVjdXRpb24gSUQuICBUaGUgY29tcG9uZW50IHdhc24ndCBnZXR0aW5nIHRoZSB2YWx1ZSBpdHNlbGYsXHJcbiAgICAgICAgICogICAgdGhvdWdoLCBzbyBpdCBzdGlsbCBoYXMgdGhlIHBlbmRpbmcgbG9hZGFibGUuXHJcbiAgICAgICAgICogNCkgV2hlbiB0aGlzIGNvZGUgZXhlY3V0ZXMgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGlkIHdhcyBjbGVhcmVkXHJcbiAgICAgICAgICogICAgYW5kIGl0IHdvdWxkbid0IG5vdGlmeSB0aGUgY29tcG9uZW50IG9mIHRoZSBuZXcgdmFsdWUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJIHRoaW5rIHRoaXMgaXMgb25seSBhbiBpc3N1ZSB3aXRoIFwiZWFybHlcIiByZW5kZXJpbmcgc2luY2UgdGhlXHJcbiAgICAgICAgICogY29tcG9uZW50cyBnb3QgdGhlaXIgdmFsdWUgdXNpbmcgdGhlIGluLXByb2dyZXNzIGV4ZWN1dGlvbi5cclxuICAgICAgICAgKiBXZSBkb24ndCBoYXZlIGEgdW5pdCB0ZXN0IGZvciB0aGlzIGNhc2UgeWV0LiAgSSdtIG5vdCBzdXJlIGl0IGlzXHJcbiAgICAgICAgICogbmVjZXNzYXJ5IHdpdGggcmVjb2lsX3RyYW5zaXRpb25fc3VwcG9ydCBtb2RlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmIChpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpIHx8IGdldEV4ZWN1dGlvbkluZm8oc3RvcmUpID09IG51bGwpIHtcclxuICAgICAgICAgIG5vdGlmeVN0b3Jlc09mUmVzb2x2ZWRBc3luYyhzdG9yZSwgZXhlY3V0aW9uSUQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhY2hlZExvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnKSB7XHJcbiAgICAgICAgICByZXR1cm4gY2FjaGVkTG9hZGFibGUuY29udGVudHM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRocm93IGNhY2hlZExvYWRhYmxlLmNvbnRlbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvKipcclxuICAgICAgICogSWYgdGhpcyBleGVjdXRpb24gaXMgc3RhbGUsIGxldCdzIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBzb21lIGluXHJcbiAgICAgICAqIHByb2dyZXNzIGV4ZWN1dGlvbiB3aXRoIGEgbWF0Y2hpbmcgc3RhdGUuIElmIHdlIGZpbmQgYSBtYXRjaCwgdGhlblxyXG4gICAgICAgKiB3ZSBjYW4gdGFrZSB0aGUgdmFsdWUgZnJvbSB0aGF0IGluLXByb2dyZXNzIGV4ZWN1dGlvbi4gTm90ZSB0aGlzIG1heVxyXG4gICAgICAgKiBzb3VuZCBsaWtlIGFuIGVkZ2UgY2FzZSwgYnV0IG1heSBiZSB2ZXJ5IGNvbW1vbiBpbiBjYXNlcyB3aGVyZSBhXHJcbiAgICAgICAqIGxvYWRpbmcgZGVwZW5kZW5jeSByZXNvbHZlcyBmcm9tIGxvYWRpbmcgdG8gaGF2aW5nIGEgdmFsdWUgKHRodXNcclxuICAgICAgICogcG9zc2libHkgdHJpZ2dlcmluZyBhIHJlLXJlbmRlciksIGFuZCBSZWFjdCByZS1yZW5kZXJzIGJlZm9yZSB0aGVcclxuICAgICAgICogY2hhaW5lZCAudGhlbigpIGZ1bmN0aW9ucyBydW4sIHRodXMgc3RhcnRpbmcgYSBuZXcgZXhlY3V0aW9uIGFzIHRoZVxyXG4gICAgICAgKiBkZXAgaGFzIGNoYW5nZWQgdmFsdWUuIFdpdGhvdXQgdGhpcyBjaGVjayB3ZSB3aWxsIHJ1biB0aGUgc2VsZWN0b3JcclxuICAgICAgICogdHdpY2UgKG9uY2UgaW4gdGhlIG5ldyBleGVjdXRpb24gYW5kIG9uY2UgYWdhaW4gaW4gdGhpcyAudGhlbigpLCBzb1xyXG4gICAgICAgKiB0aGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBrZWVwIHVubmVjZXNzYXJ5IHJlLWV4ZWN1dGlvbnMgdG8gYVxyXG4gICAgICAgKiBtaW5pbXVtKS5cclxuICAgICAgICpcclxuICAgICAgICogQWxzbyBub3RlIHRoaXMgY29kZSBkb2VzIG5vdCBjaGVjayBhY3Jvc3MgYWxsIGV4ZWN1dGlvbnMgdGhhdCBtYXkgYmVcclxuICAgICAgICogcnVubmluZy4gSXQgb25seSBvcHRpbWl6ZXMgZm9yIHRoZSBfbGF0ZXN0XyBleGVjdXRpb24gcGVyIHN0b3JlIGFzXHJcbiAgICAgICAqIHdlIGN1cnJlbnRseSBkbyBub3QgbWFpbnRhaW4gYSBsaXN0IG9mIGFsbCBjdXJyZW50bHkgcnVubmluZyBleGVjdXRpb25zLlxyXG4gICAgICAgKiBUaGlzIG1lYW5zIGluIHNvbWUgY2FzZXMgd2UgbWF5IHJ1biBzZWxlY3RvcnMgbW9yZSB0aGFuIHN0cmljdGx5XHJcbiAgICAgICAqIG5lY2Vzc2FyeSB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBleGVjdXRpb25zIHJ1bm5pbmcgZm9yIHRoZSBzYW1lXHJcbiAgICAgICAqIHNlbGVjdG9yLiBUaGlzIG1heSBiZSBhIHZhbGlkIHRyYWRlb2ZmIGFzIGNoZWNraW5nIGZvciBkZXAgY2hhbmdlc1xyXG4gICAgICAgKiBhY3Jvc3MgYWxsIGluLXByb2dyZXNzIGV4ZWN1dGlvbnMgbWF5IHRha2UgbG9uZ2VyIHRoYW4ganVzdFxyXG4gICAgICAgKiByZS1ydW5uaW5nIHRoZSBzZWxlY3Rvci4gVGhpcyB3aWxsIGJlIGFwcC1kZXBlbmRlbnQsIGFuZCBtYXliZSBpbiB0aGVcclxuICAgICAgICogZnV0dXJlIHdlIGNhbiBtYWtlIHRoZSBiZWhhdmlvciBjb25maWd1cmFibGUuIEFuIGlkZWFsIGZpeCBtYXkgYmVcclxuICAgICAgICogdG8gZXh0ZW5kIHRoZSB0cmVlIGNhY2hlIHRvIHN1cHBvcnQgY2FjaGluZyBsb2FkaW5nIHN0YXRlcy5cclxuICAgICAgICovXHJcblxyXG5cclxuICAgICAgaWYgKCFpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpKSB7XHJcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uSW5mbyA9IGdldEluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvKHN0b3JlLCBzdGF0ZSk7XHJcblxyXG4gICAgICAgIGlmIChleGVjdXRpb25JbmZvICE9IG51bGwpIHtcclxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogUmV0dXJuaW5nIHByb21pc2UgaGVyZSB3aXRob3V0IHdyYXBwaW5nIGFzIHRoZSB3cmFwcGVyIGxvZ2ljIHdhc1xyXG4gICAgICAgICAgICogYWxyZWFkeSBkb25lIHVwc3RyZWFtIHdoZW4gdGhpcyBwcm9taXNlIHdhcyBnZW5lcmF0ZWQuXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIHJldHVybiBleGVjdXRpb25JbmZvLmxvYWRpbmdMb2FkYWJsZS5jb250ZW50cztcclxuICAgICAgICB9XHJcbiAgICAgIH0gLy8gUmV0cnkgdGhlIHNlbGVjdG9yIGV2YWx1YXRpb24gbm93IHRoYXQgdGhlIGRlcGVuZGVuY3kgaGFzIHJlc29sdmVkXHJcblxyXG5cclxuICAgICAgY29uc3QgW2xvYWRhYmxlLCBkZXBWYWx1ZXNdID0gZXZhbHVhdGVTZWxlY3RvckdldHRlcihzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklEKTtcclxuXHJcbiAgICAgIGlmIChsb2FkYWJsZS5zdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XHJcbiAgICAgICAgcmVzb2x2ZUFzeW5jKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNFcnJvcicpIHtcclxuICAgICAgICB0aHJvdyBsb2FkYWJsZS5jb250ZW50cztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGxvYWRhYmxlLmNvbnRlbnRzO1xyXG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAvLyBUaGUgc2VsZWN0b3Igd2FzIHJlbGVhc2VkIHNpbmNlIHRoZSByZXF1ZXN0IGJlZ2FuOyBpZ25vcmUgdGhlIHJlc3BvbnNlLlxyXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDYW5jZWxlZCkge1xyXG4gICAgICAgIHRocm93IENBTkNFTEVEO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXNlbGVjdG9ySXNMaXZlKCkpIHtcclxuICAgICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xyXG4gICAgICAgIHRocm93IENBTkNFTEVEO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBsb2FkYWJsZSA9IGxvYWRhYmxlV2l0aEVycm9yJDEoZXJyb3IpO1xyXG4gICAgICByZXNvbHZlQXN5bmMoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCwgbG9hZGFibGUsIGV4aXN0aW5nRGVwcyk7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1cGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSwgZGVwcywgZXhlY3V0aW9uSUQpIHtcclxuICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUsIF9zdG9yZSRnZXRTdGF0ZSRjdXJyZSwgX3N0b3JlJGdldFN0YXRlMiwgX3N0b3JlJGdldFN0YXRlMiRuZXh0O1xyXG5cclxuICAgIGlmIChpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpIHx8IHN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlJGdldFN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3N0b3JlJGdldFN0YXRlJGN1cnJlID0gX3N0b3JlJGdldFN0YXRlLmN1cnJlbnRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUkY3VycmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZSRnZXRTdGF0ZSRjdXJyZS52ZXJzaW9uKSB8fCBzdGF0ZS52ZXJzaW9uID09PSAoKF9zdG9yZSRnZXRTdGF0ZTIgPSBzdG9yZS5nZXRTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3N0b3JlJGdldFN0YXRlMiRuZXh0ID0gX3N0b3JlJGdldFN0YXRlMi5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlMiRuZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUyJG5leHQudmVyc2lvbikpIHtcclxuICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCwgX3N0b3JlJGdldFN0YXRlMywgX3N0b3JlJGdldFN0YXRlMyRuZXh0O1xyXG5cclxuICAgICAgc2F2ZURlcHNUb1N0b3JlJDEoa2V5LCBkZXBzLCBzdG9yZSwgKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA9IChfc3RvcmUkZ2V0U3RhdGUzID0gc3RvcmUuZ2V0U3RhdGUoKSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zdG9yZSRnZXRTdGF0ZTMkbmV4dCA9IF9zdG9yZSRnZXRTdGF0ZTMubmV4dFRyZWUpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZTMkbmV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlJGdldFN0YXRlMyRuZXh0LnZlcnNpb24pICE9PSBudWxsICYmIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCAhPT0gdm9pZCAwID8gX3N0b3JlJGdldFN0YXRlJG5leHRUIDogc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZS52ZXJzaW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGNvbnN0IG5vZGVLZXkgb2YgZGVwcykge1xyXG4gICAgICBkaXNjb3ZlcmVkRGVwZW5kZW5jeU5vZGVLZXlzLmFkZChub2RlS2V5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGV2YWx1YXRlU2VsZWN0b3JHZXR0ZXIoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCkge1xyXG4gICAgY29uc3QgZW5kUGVyZkJsb2NrID0gc3RhcnRQZXJmQmxvY2skMShrZXkpOyAvLyBUT0RPIFQ2Mzk2NTg2NjogdXNlIGV4ZWN1dGlvbiBJRCBoZXJlXHJcblxyXG4gICAgbGV0IGR1cmluZ1N5bmNocm9ub3VzRXhlY3V0aW9uID0gdHJ1ZTtcclxuICAgIGxldCBkdXJpbmdBc3luY2hyb25vdXNFeGVjdXRpb24gPSB0cnVlO1xyXG5cclxuICAgIGNvbnN0IGZpbmlzaEV2YWx1YXRpb24gPSAoKSA9PiB7XHJcbiAgICAgIGVuZFBlcmZCbG9jaygpO1xyXG4gICAgICBkdXJpbmdBc3luY2hyb25vdXNFeGVjdXRpb24gPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgbGV0IHJlc3VsdDtcclxuICAgIGxldCByZXN1bHRJc0Vycm9yID0gZmFsc2U7XHJcbiAgICBsZXQgbG9hZGFibGU7XHJcbiAgICBjb25zdCBsb2FkaW5nRGVwc1N0YXRlID0ge1xyXG4gICAgICBsb2FkaW5nRGVwS2V5OiBudWxsLFxyXG4gICAgICBsb2FkaW5nRGVwUHJvbWlzZTogbnVsbFxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRpbmcgYSBmcmVzaCBzZXQgb2YgZGVwcyB0aGF0IHdlJ2xsIGJlIHVzaW5nIHRvIHVwZGF0ZSBzdGF0ZS4gV2UncmVcclxuICAgICAqIHN0YXJ0aW5nIGEgbmV3IHNldCB2ZXJzdXMgYWRkaW5nIGl0IGluIGV4aXN0aW5nIHN0YXRlIGRlcHMgYmVjYXVzZVxyXG4gICAgICogdGhlIHZlcnNpb24gb2Ygc3RhdGUgdGhhdCB3ZSB1cGRhdGUgZGVwcyBmb3IgbWF5IGJlIGEgbW9yZSByZWNlbnQgdmVyc2lvblxyXG4gICAgICogdGhhbiB0aGUgdmVyc2lvbiB0aGUgc2VsZWN0b3Igd2FzIGNhbGxlZCB3aXRoLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGxhdGVzdFxyXG4gICAgICogZXhlY3V0aW9uIHdpbGwgdXBkYXRlIHRoZSBkZXBzIG9mIHRoZSBjdXJyZW50L2xhdGVzdCB2ZXJzaW9uIG9mIHN0YXRlXHJcbiAgICAgKiAoVGhpcyBpcyBzYWZlIHRvIGRvIGJlY2F1c2UgdGhlIGZhY3QgdGhhdCB0aGUgc2VsZWN0b3IgaXMgdGhlIGxhdGVzdFxyXG4gICAgICogZXhlY3V0aW9uIG1lYW5zIHRoZSBkZXBzIHdlIGRpc2NvdmVyIGJlbG93IGFyZSBvdXIgYmVzdCBndWVzcyBhdCB0aGVcclxuICAgICAqIGRlcHMgZm9yIHRoZSBjdXJyZW50L2xhdGVzdCBzdGF0ZSBpbiB0aGUgc3RvcmUpXHJcbiAgICAgKi9cclxuXHJcbiAgICBjb25zdCBkZXBWYWx1ZXMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UmVjb2lsVmFsdWUoe1xyXG4gICAgICBrZXk6IGRlcEtleVxyXG4gICAgfSkge1xyXG4gICAgICBjb25zdCBkZXBMb2FkYWJsZSA9IGdldE5vZGVMb2FkYWJsZSQyKHN0b3JlLCBzdGF0ZSwgZGVwS2V5KTtcclxuICAgICAgZGVwVmFsdWVzLnNldChkZXBLZXksIGRlcExvYWRhYmxlKTsgLy8gV2UgbmVlZCB0byB1cGRhdGUgYXN5bmNocm9ub3VzIGRlcGVuZGVuY2llcyBhcyB3ZSBnbyBzbyB0aGUgc2VsZWN0b3JcclxuICAgICAgLy8ga25vd3MgaWYgaXQgaGFzIHRvIHJlc3RhcnQgZXZhbHVhdGlvbiBpZiBvbmUgb2YgdGhlbSBpcyB1cGRhdGVkIGJlZm9yZVxyXG4gICAgICAvLyB0aGUgYXN5bmNocm9ub3VzIHNlbGVjdG9yIGNvbXBsZXRlbHkgcmVzb2x2ZXMuXHJcblxyXG4gICAgICBpZiAoIWR1cmluZ1N5bmNocm9ub3VzRXhlY3V0aW9uKSB7XHJcbiAgICAgICAgdXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUsIG5ldyBTZXQoZGVwVmFsdWVzLmtleXMoKSksIGV4ZWN1dGlvbklEKTtcclxuICAgICAgICBub3RpZnlTdG9yZXNPZk5ld0FzeW5jRGVwKHN0b3JlLCBleGVjdXRpb25JRCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN3aXRjaCAoZGVwTG9hZGFibGUuc3RhdGUpIHtcclxuICAgICAgICBjYXNlICdoYXNWYWx1ZSc6XHJcbiAgICAgICAgICByZXR1cm4gZGVwTG9hZGFibGUuY29udGVudHM7XHJcblxyXG4gICAgICAgIGNhc2UgJ2hhc0Vycm9yJzpcclxuICAgICAgICAgIHRocm93IGRlcExvYWRhYmxlLmNvbnRlbnRzO1xyXG5cclxuICAgICAgICBjYXNlICdsb2FkaW5nJzpcclxuICAgICAgICAgIGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcEtleSA9IGRlcEtleTtcclxuICAgICAgICAgIGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcFByb21pc2UgPSBkZXBMb2FkYWJsZS5jb250ZW50cztcclxuICAgICAgICAgIHRocm93IGRlcExvYWRhYmxlLmNvbnRlbnRzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKCdJbnZhbGlkIExvYWRhYmxlIHN0YXRlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZ2V0Q2FsbGJhY2sgPSBmbiA9PiB7XHJcbiAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIGlmIChkdXJpbmdBc3luY2hyb25vdXNFeGVjdXRpb24pIHtcclxuICAgICAgICAgIHRocm93IFJlY29pbF9lcnIoJ0NhbGxiYWNrcyBmcm9tIGdldENhbGxiYWNrKCkgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSBzZWxlY3RvciBpcyBldmFsdXRhdGVkLiAgSXQgY2FuIGJlIHVzZWQgZm9yIHNlbGVjdG9ycyB0byByZXR1cm4gb2JqZWN0cyB3aXRoIGNhbGxiYWNrcyB0aGF0IGNhbiB3b3JrIHdpdGggUmVjb2lsIHN0YXRlIHdpdGhvdXQgYSBzdWJzY3JpcHRpb24uJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAhKHJlY29pbFZhbHVlICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ1JlY29pbCBWYWx1ZSBjYW4gbmV2ZXIgYmUgbnVsbCcpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcbiAgICAgICAgcmV0dXJuIHJlY29pbENhbGxiYWNrJDEoc3RvcmUsIGZuLCBhcmdzLCB7XHJcbiAgICAgICAgICBub2RlOiByZWNvaWxWYWx1ZVxyXG4gICAgICAgIH0gLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXHJcbiAgICAgICAgKTtcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgcmVzdWx0ID0gZ2V0KHtcclxuICAgICAgICBnZXQ6IGdldFJlY29pbFZhbHVlLFxyXG4gICAgICAgIGdldENhbGxiYWNrXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXN1bHQgPSBpc1JlY29pbFZhbHVlJDMocmVzdWx0KSA/IGdldFJlY29pbFZhbHVlKHJlc3VsdCkgOiByZXN1bHQ7XHJcblxyXG4gICAgICBpZiAoaXNMb2FkYWJsZSQxKHJlc3VsdCkpIHtcclxuICAgICAgICBpZiAocmVzdWx0LnN0YXRlID09PSAnaGFzRXJyb3InKSB7XHJcbiAgICAgICAgICByZXN1bHRJc0Vycm9yID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb250ZW50cztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UocmVzdWx0KSkge1xyXG4gICAgICAgIHJlc3VsdCA9IHdyYXBSZXN1bHRQcm9taXNlKHN0b3JlLCByZXN1bHQsIHN0YXRlLCBkZXBWYWx1ZXMsIGV4ZWN1dGlvbklELCBsb2FkaW5nRGVwc1N0YXRlKS5maW5hbGx5KGZpbmlzaEV2YWx1YXRpb24pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZpbmlzaEV2YWx1YXRpb24oKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVzdWx0ID0gcmVzdWx0IGluc3RhbmNlb2YgV3JhcHBlZFZhbHVlJDEgPyByZXN1bHQudmFsdWUgOiByZXN1bHQ7XHJcbiAgICB9IGNhdGNoIChlcnJvck9yRGVwUHJvbWlzZSkge1xyXG4gICAgICByZXN1bHQgPSBlcnJvck9yRGVwUHJvbWlzZTtcclxuXHJcbiAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKHJlc3VsdCkpIHtcclxuICAgICAgICByZXN1bHQgPSB3cmFwUGVuZGluZ0RlcGVuZGVuY3lQcm9taXNlKHN0b3JlLCByZXN1bHQsIHN0YXRlLCBkZXBWYWx1ZXMsIGV4ZWN1dGlvbklELCBsb2FkaW5nRGVwc1N0YXRlKS5maW5hbGx5KGZpbmlzaEV2YWx1YXRpb24pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdElzRXJyb3IgPSB0cnVlO1xyXG4gICAgICAgIGZpbmlzaEV2YWx1YXRpb24oKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZXN1bHRJc0Vycm9yKSB7XHJcbiAgICAgIGxvYWRhYmxlID0gbG9hZGFibGVXaXRoRXJyb3IkMShyZXN1bHQpO1xyXG4gICAgfSBlbHNlIGlmIChSZWNvaWxfaXNQcm9taXNlKHJlc3VsdCkpIHtcclxuICAgICAgbG9hZGFibGUgPSBsb2FkYWJsZVdpdGhQcm9taXNlJDEocmVzdWx0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxvYWRhYmxlID0gbG9hZGFibGVXaXRoVmFsdWUkMihyZXN1bHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGR1cmluZ1N5bmNocm9ub3VzRXhlY3V0aW9uID0gZmFsc2U7XHJcbiAgICB1cGRhdGVFeGVjdXRpb25JbmZvRGVwVmFsdWVzKHN0b3JlLCBleGVjdXRpb25JRCwgZGVwVmFsdWVzKTtcclxuICAgIHVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlLCBuZXcgU2V0KGRlcFZhbHVlcy5rZXlzKCkpLCBleGVjdXRpb25JRCk7XHJcbiAgICByZXR1cm4gW2xvYWRhYmxlLCBkZXBWYWx1ZXNdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0TG9hZGFibGVGcm9tQ2FjaGVBbmRVcGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSkge1xyXG4gICAgLy8gRmlyc3QsIGxvb2sgdXAgaW4gdGhlIHN0YXRlIGNhY2hlXHJcbiAgICAvLyBJZiBpdCdzIGhlcmUsIHRoZW4gdGhlIGRlcHMgaW4gdGhlIHN0b3JlIHNob3VsZCBhbHJlYWR5IGJlIHZhbGlkLlxyXG4gICAgbGV0IGNhY2hlZExvYWRhYmxlID0gc3RhdGUuYXRvbVZhbHVlcy5nZXQoa2V5KTtcclxuXHJcbiAgICBpZiAoY2FjaGVkTG9hZGFibGUgIT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gY2FjaGVkTG9hZGFibGU7XHJcbiAgICB9IC8vIFNlY29uZCwgbG9vayB1cCBpbiB0aGUgc2VsZWN0b3IgY2FjaGUgYW5kIHVwZGF0ZSB0aGUgZGVwcyBpbiB0aGUgc3RvcmVcclxuXHJcblxyXG4gICAgY29uc3QgZGVwc0FmdGVyQ2FjaGVMb29rdXAgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY2FjaGVkTG9hZGFibGUgPSBjYWNoZS5nZXQobm9kZUtleSA9PiB7XHJcbiAgICAgICAgISh0eXBlb2Ygbm9kZUtleSA9PT0gJ3N0cmluZycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ0NhY2hlIG5vZGVLZXkgaXMgdHlwZSBzdHJpbmcnKSA6IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gICAgICAgIHJldHVybiBnZXROb2RlTG9hZGFibGUkMihzdG9yZSwgc3RhdGUsIG5vZGVLZXkpLmNvbnRlbnRzO1xyXG4gICAgICB9LCB7XHJcbiAgICAgICAgb25Ob2RlVmlzaXQ6IG5vZGUgPT4ge1xyXG4gICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2JyYW5jaCcgJiYgbm9kZS5ub2RlS2V5ICE9PSBrZXkpIHtcclxuICAgICAgICAgICAgZGVwc0FmdGVyQ2FjaGVMb29rdXAuYWRkKG5vZGUubm9kZUtleSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRocm93IFJlY29pbF9lcnIoYFByb2JsZW0gd2l0aCBjYWNoZSBsb29rdXAgZm9yIHNlbGVjdG9yIFwiJHtrZXl9XCI6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FjaGVkTG9hZGFibGUpIHtcclxuICAgICAgdmFyIF9nZXRFeGVjdXRpb25JbmZvO1xyXG5cclxuICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdHMgaW4gdGhlIHN0YXRlIHRvIGFsbG93IGZvciBjaGVhcGVyIGxvb2t1cCB0aGFuXHJcbiAgICAgIC8vIGl0ZXJhdGluZyB0aGUgdHJlZSBjYWNoZSBvZiBkZXBlbmRlbmNpZXMuXHJcbiAgICAgIHN0YXRlLmF0b21WYWx1ZXMuc2V0KGtleSwgY2FjaGVkTG9hZGFibGUpO1xyXG4gICAgICAvKipcclxuICAgICAgICogRW5zdXJlIHN0b3JlIGNvbnRhaW5zIGNvcnJlY3QgZGVwZW5kZW5jaWVzIGlmIHdlIGhpdCB0aGUgY2FjaGUgc28gdGhhdFxyXG4gICAgICAgKiB0aGUgc3RvcmUgZGVwcyBhbmQgY2FjaGUgYXJlIGluIHN5bmMgZm9yIGEgZ2l2ZW4gc3RhdGUuIFRoaXMgaXMgaW1wb3J0YW50XHJcbiAgICAgICAqIGJlY2F1c2Ugc3RvcmUgZGVwcyBhcmUgbm9ybWFsbHkgdXBkYXRlZCB3aGVuIG5ldyBleGVjdXRpb25zIGFyZSBjcmVhdGVkLFxyXG4gICAgICAgKiBidXQgY2FjaGUgaGl0cyBkb24ndCB0cmlnZ2VyIG5ldyBleGVjdXRpb25zIGJ1dCB0aGV5IHN0aWxsIF9tYXlfIHNpZ25pZnlcclxuICAgICAgICogYSBjaGFuZ2UgaW4gZGVwcyBpbiB0aGUgc3RvcmUgaWYgdGhlIHN0b3JlIGRlcHMgZm9yIHRoaXMgc3RhdGUgYXJlIGVtcHR5XHJcbiAgICAgICAqIG9yIHN0YWxlLlxyXG4gICAgICAgKi9cclxuXHJcbiAgICAgIHVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlLCBkZXBzQWZ0ZXJDYWNoZUxvb2t1cCwgKF9nZXRFeGVjdXRpb25JbmZvID0gZ2V0RXhlY3V0aW9uSW5mbyhzdG9yZSkpID09PSBudWxsIHx8IF9nZXRFeGVjdXRpb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0RXhlY3V0aW9uSW5mby5leGVjdXRpb25JRCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNhY2hlZExvYWRhYmxlO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBHaXZlbiBhIHRyZWUgc3RhdGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIExvYWRhYmxlIG9mIHRoZSBjdXJyZW50IHN0YXRlLlxyXG4gICAqXHJcbiAgICogVGhlIHNlbGVjdG9yJ3MgZ2V0KCkgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIHJlLWV2YWx1YXRlZCBpZiBfYm90aF8gb2YgdGhlXHJcbiAgICogZm9sbG93aW5nIHN0YXRlbWVudHMgYXJlIHRydWU6XHJcbiAgICpcclxuICAgKiAxLiBUaGUgY3VycmVudCBkZXAgdmFsdWVzIGZyb20gdGhlIGdpdmVuIHN0YXRlIHByb2R1Y2VkIGEgY2FjaGUga2V5IHRoYXRcclxuICAgKiAgICB3YXMgbm90IGZvdW5kIGluIHRoZSBjYWNoZS5cclxuICAgKiAyLiBUaGVyZSBpcyBubyBjdXJyZW50bHkgcnVubmluZyBhc3luYyBleGVjdXRpb24gT1IgdGhlcmUgaXMgYW5cclxuICAgKiAgICBhc3luYyBleGVjdXRpb24gdGhhdCBpcyBydW5uaW5nLCBidXQgYWZ0ZXIgY29tcGFyaW5nIHRoZSBkZXAgdmFsdWVzIGluXHJcbiAgICogICAgdGhlIGdpdmVuIHN0YXRlIHdpdGggdGhlIGRlcCB2YWx1ZXMgdGhhdCB0aGUgZXhlY3V0aW9uIGhhcyBkaXNjb3ZlcmVkIHNvXHJcbiAgICogICAgZmFyIHdlIGZpbmQgdGhhdCBhdCBsZWFzdCBvbmUgZGVwIHZhbHVlIGhhcyBjaGFuZ2VkLCBpbiB3aGljaCBjYXNlIHdlXHJcbiAgICogICAgc3RhcnQgYSBuZXcgZXhlY3V0aW9uICh0aGUgcHJldmlvdXNseSBydW5uaW5nIGV4ZWN1dGlvbiB3aWxsIGNvbnRpbnVlIHRvXHJcbiAgICogICAgcnVuIHRvIGNvbXBsZXRpb24sIGJ1dCBvbmx5IHRoZSBuZXcgZXhlY3V0aW9uIHdpbGwgYmUgZGVlbWVkIHRoZVxyXG4gICAqICAgICdsYXRlc3QnIGV4ZWN1dGlvbiwgbWVhbmluZyBpdCB3aWxsIGJlIHRoZSBvbmx5IGV4ZWN1dGlvbiB0aGF0IHdpbGxcclxuICAgKiAgICB1cGRhdGUgZ2xvYmFsIHN0YXRlIHdoZW4gaXQgaXMgZmluaXNoZWQuIEFueSBub24tbGF0ZXN0IGV4ZWN1dGlvbnMgd2lsbFxyXG4gICAqICAgIHJ1biB0byBjb21wbGV0aW9uIGFuZCB1cGRhdGUgdGhlIHNlbGVjdG9yIGNhY2hlIGJ1dCBub3QgZ2xvYmFsIHN0YXRlKS5cclxuICAgKi9cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9yTG9hZGFibGVBbmRVcGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSkge1xyXG4gICAgLy8gRmlyc3QsIHNlZSBpZiBvdXIgY3VycmVudCBzdGF0ZSBpcyBjYWNoZWRcclxuICAgIGNvbnN0IGNhY2hlZFZhbCA9IGdldExvYWRhYmxlRnJvbUNhY2hlQW5kVXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUpO1xyXG5cclxuICAgIGlmIChjYWNoZWRWYWwgIT0gbnVsbCkge1xyXG4gICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xyXG4gICAgICByZXR1cm4gY2FjaGVkVmFsO1xyXG4gICAgfSAvLyBTZWNvbmQsIGNoZWNrIGlmIHRoZXJlIGlzIGFscmVhZHkgYW4gb25nb2luZyBleGVjdXRpb24gYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGVcclxuXHJcblxyXG4gICAgY29uc3QgaW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8gPSBnZXRJblByb2dyZXNzRXhlY3V0aW9uSW5mbyhzdG9yZSwgc3RhdGUpO1xyXG5cclxuICAgIGlmIChpblByb2dyZXNzRXhlY3V0aW9uSW5mbyAhPSBudWxsKSB7XHJcbiAgICAgIHZhciBfaW5Qcm9ncmVzc0V4ZWN1dGlvbkk7XHJcblxyXG4gICAgICBpZiAoKChfaW5Qcm9ncmVzc0V4ZWN1dGlvbkkgPSBpblByb2dyZXNzRXhlY3V0aW9uSW5mby5sb2FkaW5nTG9hZGFibGUpID09PSBudWxsIHx8IF9pblByb2dyZXNzRXhlY3V0aW9uSSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2luUHJvZ3Jlc3NFeGVjdXRpb25JLnN0YXRlKSA9PT0gJ2xvYWRpbmcnKSB7XHJcbiAgICAgICAgbWFya1N0b3JlV2FpdGluZ0ZvclJlc29sdmVkQXN5bmMoc3RvcmUsIGluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvLmV4ZWN1dGlvbklEKTtcclxuICAgICAgfSAvLyBGSVhNRTogY2hlY2sgYWZ0ZXIgdGhlIGZhY3QgdG8gc2VlIGlmIHdlIG1hZGUgdGhlIHJpZ2h0IGNob2ljZSBieSB3YWl0aW5nXHJcblxyXG5cclxuICAgICAgcmV0dXJuIGluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvLmxvYWRpbmdMb2FkYWJsZTtcclxuICAgIH0gLy8gVGhpcmQsIHN0YXJ0IGEgbmV3IGV2YWx1YXRpb24gb2YgdGhlIHNlbGVjdG9yXHJcblxyXG5cclxuICAgIGNvbnN0IG5ld0V4ZWN1dGlvbklEID0gZ2V0TmV3RXhlY3V0aW9uSUQoKTtcclxuICAgIGNvbnN0IFtsb2FkYWJsZSwgbmV3RGVwVmFsdWVzXSA9IGV2YWx1YXRlU2VsZWN0b3JHZXR0ZXIoc3RvcmUsIHN0YXRlLCBuZXdFeGVjdXRpb25JRCk7XHJcbiAgICAvKipcclxuICAgICAqIENvbmRpdGlvbmFsbHkgdXBkYXRlcyB0aGUgY2FjaGUgd2l0aCBhIGdpdmVuIGxvYWRhYmxlLlxyXG4gICAgICpcclxuICAgICAqIFdlIG9ubHkgY2FjaGUgbG9hZGFibGVzIHRoYXQgYXJlIG5vdCBsb2FkaW5nIGJlY2F1c2Ugb3VyIGNhY2hlIGtleXMgYXJlXHJcbiAgICAgKiBiYXNlZCBvbiBkZXAgdmFsdWVzLCB3aGljaCBhcmUgaW4gYW4gdW5maW5pc2hlZCBzdGF0ZSBmb3IgbG9hZGFibGVzIHRoYXRcclxuICAgICAqIGhhdmUgYSAnbG9hZGluZycgc3RhdGUgKG5ldyBkZXBzIG1heSBiZSBkaXNjb3ZlcmVkIHdoaWxlIHRoZSBzZWxlY3RvclxyXG4gICAgICogcnVucyBpdHMgYXN5bmMgY29kZSkuIFdlIG5ldmVyIHdhbnQgdG8gY2FjaGUgcGFydGlhbCBkZXBlbmRlbmNpZXMgYi9jIGl0XHJcbiAgICAgKiBjb3VsZCBsZWFkIHRvIGVycm9ycywgc3VjaCBhcyBwcmVtYXR1cmVseSByZXR1cm5pbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiBhXHJcbiAgICAgKiBwYXJ0aWFsIGxpc3Qgb2YgZGVwcy0tIHdlIG5lZWQgdGhlIGZ1bGwgbGlzdCBvZiBkZXBzIHRvIGVuc3VyZSB0aGF0IHdlXHJcbiAgICAgKiBhcmUgcmV0dXJuaW5nIHRoZSBjb3JyZWN0IHJlc3VsdCBmcm9tIGNhY2hlLlxyXG4gICAgICovXHJcblxyXG4gICAgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnbG9hZGluZycpIHtcclxuICAgICAgc2V0RXhlY3V0aW9uSW5mbyhzdG9yZSwgbmV3RXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBuZXdEZXBWYWx1ZXMsIHN0YXRlKTtcclxuICAgICAgbWFya1N0b3JlV2FpdGluZ0ZvclJlc29sdmVkQXN5bmMoc3RvcmUsIG5ld0V4ZWN1dGlvbklEKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSk7XHJcbiAgICAgIHNldENhY2hlKHN0YXRlLCBsb2FkYWJsZSwgbmV3RGVwVmFsdWVzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbG9hZGFibGU7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFNlYXJjaGVzIGV4ZWN1dGlvbiBpbmZvIGFjcm9zcyBhbGwgc3RvcmVzIHRvIHNlZSBpZiB0aGVyZSBpcyBhbiBpbi1wcm9ncmVzc1xyXG4gICAqIGV4ZWN1dGlvbiB3aG9zZSBkZXBlbmRlbmN5IHZhbHVlcyBtYXRjaCB0aGUgdmFsdWVzIG9mIHRoZSByZXF1ZXN0aW5nIHN0b3JlLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgZnVuY3Rpb24gZ2V0SW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8oc3RvcmUsIHN0YXRlKSB7XHJcbiAgICAvLyBTb3J0IHRoZSBwZW5kaW5nIGV4ZWN1dGlvbnMgc28gdGhhdCBvdXIgY3VycmVudCBzdG9yZSBpcyBjaGVja2VkIGZpcnN0LlxyXG4gICAgY29uc3QgcGVuZGluZ0V4ZWN1dGlvbnMgPSBSZWNvaWxfY29uY2F0SXRlcmFibGVzKFtleGVjdXRpb25JbmZvTWFwLmhhcyhzdG9yZSkgPyBbUmVjb2lsX251bGx0aHJvd3MoZXhlY3V0aW9uSW5mb01hcC5nZXQoc3RvcmUpKV0gOiBbXSwgUmVjb2lsX21hcEl0ZXJhYmxlKFJlY29pbF9maWx0ZXJJdGVyYWJsZShleGVjdXRpb25JbmZvTWFwLCAoW3NdKSA9PiBzICE9PSBzdG9yZSksIChbLCBleGVjSW5mb10pID0+IGV4ZWNJbmZvKV0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGFueURlcENoYW5nZWQoZXhlY0RlcFZhbHVlcykge1xyXG4gICAgICBmb3IgKGNvbnN0IFtkZXBLZXksIGV4ZWNMb2FkYWJsZV0gb2YgZXhlY0RlcFZhbHVlcykge1xyXG4gICAgICAgIGlmICghZ2V0Tm9kZUxvYWRhYmxlJDIoc3RvcmUsIHN0YXRlLCBkZXBLZXkpLmlzKGV4ZWNMb2FkYWJsZSkpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoY29uc3QgZXhlY0luZm8gb2YgcGVuZGluZ0V4ZWN1dGlvbnMpIHtcclxuICAgICAgaWYgKCAvLyBJZiB0aGlzIGV4ZWN1dGlvbiB3YXMgYWxyZWFkeSBjaGVja2VkIHRvIGJlIHZhbGlkIHdpdGggdGhpcyB2ZXJzaW9uXHJcbiAgICAgIC8vIG9mIHN0YXRlLCB0aGVuIGxldCdzIHVzZSBpdCFcclxuICAgICAgZXhlY0luZm8uc3RhdGVWZXJzaW9ucy5nZXQoc3RhdGUudmVyc2lvbikgfHwgLy8gSWYgdGhlIGRlcHMgZm9yIHRoZSBleGVjdXRpb24gbWF0Y2ggb3VyIGN1cnJlbnQgc3RhdGUsIHRoZW4gaXQncyB2YWxpZFxyXG4gICAgICAhYW55RGVwQ2hhbmdlZChleGVjSW5mby5kZXBWYWx1ZXNEaXNjb3ZlcmVkU29GYXJEdXJpbmdBc3luY1dvcmspKSB7XHJcbiAgICAgICAgZXhlY0luZm8uc3RhdGVWZXJzaW9ucy5zZXQoc3RhdGUudmVyc2lvbiwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGV4ZWNJbmZvO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGV4ZWNJbmZvLnN0YXRlVmVyc2lvbnMuc2V0KHN0YXRlLnZlcnNpb24sIGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRFeGVjdXRpb25JbmZvKHN0b3JlKSB7XHJcbiAgICByZXR1cm4gZXhlY3V0aW9uSW5mb01hcC5nZXQoc3RvcmUpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdXBkYXRlIHRoZSBzZWxlY3RvcidzIGV4ZWN1dGlvbiBpbmZvIHdoZW4gdGhlIHNlbGVjdG9yXHJcbiAgICogaGFzIGVpdGhlciBmaW5pc2hlZCBydW5uaW5nIGFuIGV4ZWN1dGlvbiBvciBoYXMgc3RhcnRlZCBhIG5ldyBleGVjdXRpb24uIElmXHJcbiAgICogdGhlIGdpdmVuIGxvYWRhYmxlIGlzIGluIGEgJ2xvYWRpbmcnIHN0YXRlLCB0aGUgaW50ZW50aW9uIGlzIHRoYXQgYSBuZXdcclxuICAgKiBleGVjdXRpb24gaGFzIHN0YXJ0ZWQuIE90aGVyd2lzZSwgdGhlIGludGVudGlvbiBpcyB0aGF0IGFuIGV4ZWN1dGlvbiBoYXNcclxuICAgKiBqdXN0IGZpbmlzaGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgZnVuY3Rpb24gc2V0RXhlY3V0aW9uSW5mbyhzdG9yZSwgbmV3RXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMsIHN0YXRlKSB7XHJcbiAgICBleGVjdXRpb25JbmZvTWFwLnNldChzdG9yZSwge1xyXG4gICAgICBkZXBWYWx1ZXNEaXNjb3ZlcmVkU29GYXJEdXJpbmdBc3luY1dvcms6IGRlcFZhbHVlcyxcclxuICAgICAgZXhlY3V0aW9uSUQ6IG5ld0V4ZWN1dGlvbklELFxyXG4gICAgICBsb2FkaW5nTG9hZGFibGU6IGxvYWRhYmxlLFxyXG4gICAgICBzdGF0ZVZlcnNpb25zOiBuZXcgTWFwKFtbc3RhdGUudmVyc2lvbiwgdHJ1ZV1dKVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1cGRhdGVFeGVjdXRpb25JbmZvRGVwVmFsdWVzKHN0b3JlLCBleGVjdXRpb25JRCwgZGVwVmFsdWVzKSB7XHJcbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gYm90aGVyIHVwZGF0aW5nIHRoZSBkZXBzIGZvciB0aGUgbGF0ZXN0IGV4ZWN1dGlvbiBiZWNhdXNlXHJcbiAgICAvLyB0aGF0J3MgYWxsIGdldEluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvKCkgd2lsbCBiZSBsb29raW5nIGZvci5cclxuICAgIGlmIChpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpKSB7XHJcbiAgICAgIGNvbnN0IGV4ZWN1dGlvbkluZm8gPSBnZXRFeGVjdXRpb25JbmZvKHN0b3JlKTtcclxuXHJcbiAgICAgIGlmIChleGVjdXRpb25JbmZvICE9IG51bGwpIHtcclxuICAgICAgICBleGVjdXRpb25JbmZvLmRlcFZhbHVlc0Rpc2NvdmVyZWRTb0ZhckR1cmluZ0FzeW5jV29yayA9IGRlcFZhbHVlcztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKSB7XHJcbiAgICBleGVjdXRpb25JbmZvTWFwLmRlbGV0ZShzdG9yZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpIHtcclxuICAgIHZhciBfZ2V0RXhlY3V0aW9uSW5mbzI7XHJcblxyXG4gICAgcmV0dXJuIGV4ZWN1dGlvbklEID09PSAoKF9nZXRFeGVjdXRpb25JbmZvMiA9IGdldEV4ZWN1dGlvbkluZm8oc3RvcmUpKSA9PT0gbnVsbCB8fCBfZ2V0RXhlY3V0aW9uSW5mbzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRFeGVjdXRpb25JbmZvMi5leGVjdXRpb25JRCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEZJWE1FOiBkZXAga2V5cyBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgdGhlIHN0YXRlIG9mIHRoZSBsb2FkYWJsZSB0b1xyXG4gICAqIHByZXZlbnQgdGhlIGVkZ2UgY2FzZSB3aGVyZSBhIGxvYWRhYmxlIHdpdGggYW4gZXJyb3IgYW5kIGEgbG9hZGFibGUgd2l0aFxyXG4gICAqIGFuIGVycm9yIGFzIGEgdmFsdWUgYXJlIHRyZWF0ZWQgYXMgdGhlIHNhbWUgdGhpbmcgaW5jb3JyZWN0bHkuIEZvciBleGFtcGxlXHJcbiAgICogdGhlc2UgdHdvIHNob3VsZCBiZSB0cmVhdGVkIGRpZmZlcmVudGx5OlxyXG4gICAqXHJcbiAgICogc2VsZWN0b3Ioe2tleTogJycsIGdldDogKCkgPT4gbmV3IEVycm9yKCdoaScpfSk7XHJcbiAgICogc2VsZWN0b3Ioe2tleTogJycsIGdldCAoKSA9PiB7dGhyb3cgbmV3IEVycm9yKCdoaScpfX0pO1xyXG4gICAqXHJcbiAgICogV2l0aCBjdXJyZW50IGltcGxlbWVudGF0aW9uIHRoZXkgYXJlIHRyZWF0ZWQgdGhlIHNhbWVcclxuICAgKi9cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGRlcFZhbHVlc1RvRGVwUm91dGUoZGVwVmFsdWVzKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbShkZXBWYWx1ZXMuZW50cmllcygpKS5tYXAoKFtkZXBLZXksIHZhbExvYWRhYmxlXSkgPT4gW2RlcEtleSwgdmFsTG9hZGFibGUuY29udGVudHNdKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldENhY2hlKHN0YXRlLCBsb2FkYWJsZSwgZGVwVmFsdWVzKSB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgIGlmIChsb2FkYWJsZS5zdGF0ZSAhPT0gJ2xvYWRpbmcnICYmIEJvb2xlYW4ob3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgUmVjb2lsX2RlZXBGcmVlemVWYWx1ZShsb2FkYWJsZS5jb250ZW50cyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0ZS5hdG9tVmFsdWVzLnNldChrZXksIGxvYWRhYmxlKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjYWNoZS5zZXQoZGVwVmFsdWVzVG9EZXBSb3V0ZShkZXBWYWx1ZXMpLCBsb2FkYWJsZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKGBQcm9ibGVtIHdpdGggc2V0dGluZyBjYWNoZSBmb3Igc2VsZWN0b3IgXCIke2tleX1cIjogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGV0ZWN0Q2lyY3VsYXJEZXBlbmRlbmNpZXMoZm4pIHtcclxuICAgIGlmIChkZXBlbmRlbmN5U3RhY2suaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICBjb25zdCBtZXNzYWdlID0gYFJlY29pbCBzZWxlY3RvciBoYXMgY2lyY3VsYXIgZGVwZW5kZW5jaWVzOiAke2RlcGVuZGVuY3lTdGFjay5zbGljZShkZXBlbmRlbmN5U3RhY2suaW5kZXhPZihrZXkpKS5qb2luKCcgXFx1MjE5MiAnKX1gO1xyXG4gICAgICByZXR1cm4gbG9hZGFibGVXaXRoRXJyb3IkMShSZWNvaWxfZXJyKG1lc3NhZ2UpKTtcclxuICAgIH1cclxuXHJcbiAgICBkZXBlbmRlbmN5U3RhY2sucHVzaChrZXkpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBmbigpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgZGVwZW5kZW5jeVN0YWNrLnBvcCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2VsZWN0b3JQZWVrKHN0b3JlLCBzdGF0ZSkge1xyXG4gICAgY29uc3QgY2FjaGVkTG9hZGFibGUgPSBzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpO1xyXG5cclxuICAgIGlmIChjYWNoZWRMb2FkYWJsZSAhPSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBjYWNoZWRMb2FkYWJsZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2FjaGUuZ2V0KG5vZGVLZXkgPT4ge1xyXG4gICAgICB2YXIgX3BlZWtOb2RlTG9hZGFibGU7XHJcblxyXG4gICAgICAhKHR5cGVvZiBub2RlS2V5ID09PSAnc3RyaW5nJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBSZWNvaWxfaW52YXJpYW50KGZhbHNlLCAnQ2FjaGUgbm9kZUtleSBpcyB0eXBlIHN0cmluZycpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcbiAgICAgIHJldHVybiAoX3BlZWtOb2RlTG9hZGFibGUgPSBwZWVrTm9kZUxvYWRhYmxlJDEoc3RvcmUsIHN0YXRlLCBub2RlS2V5KSkgPT09IG51bGwgfHwgX3BlZWtOb2RlTG9hZGFibGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wZWVrTm9kZUxvYWRhYmxlLmNvbnRlbnRzO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZWxlY3RvckdldChzdG9yZSwgc3RhdGUpIHtcclxuICAgIHJldHVybiBkZXRlY3RDaXJjdWxhckRlcGVuZGVuY2llcygoKSA9PiBnZXRTZWxlY3RvckxvYWRhYmxlQW5kVXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUpKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGludmFsaWRhdGVTZWxlY3RvcihzdGF0ZSkge1xyXG4gICAgc3RhdGUuYXRvbVZhbHVlcy5kZWxldGUoa2V5KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsZWFyU2VsZWN0b3JDYWNoZShzdG9yZSwgdHJlZVN0YXRlKSB7XHJcbiAgICAhKHJlY29pbFZhbHVlICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ1JlY29pbCBWYWx1ZSBjYW4gbmV2ZXIgYmUgbnVsbCcpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcblxyXG4gICAgZm9yIChjb25zdCBub2RlS2V5IG9mIGRpc2NvdmVyZWREZXBlbmRlbmN5Tm9kZUtleXMpIHtcclxuICAgICAgdmFyIF9ub2RlJGNsZWFyQ2FjaGU7XHJcblxyXG4gICAgICBjb25zdCBub2RlID0gZ2V0Tm9kZSQ2KG5vZGVLZXkpO1xyXG4gICAgICAoX25vZGUkY2xlYXJDYWNoZSA9IG5vZGUuY2xlYXJDYWNoZSkgPT09IG51bGwgfHwgX25vZGUkY2xlYXJDYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkY2xlYXJDYWNoZS5jYWxsKG5vZGUsIHN0b3JlLCB0cmVlU3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc2NvdmVyZWREZXBlbmRlbmN5Tm9kZUtleXMuY2xlYXIoKTtcclxuICAgIGludmFsaWRhdGVTZWxlY3Rvcih0cmVlU3RhdGUpO1xyXG4gICAgY2FjaGUuY2xlYXIoKTtcclxuICAgIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDEoc3RvcmUsIHJlY29pbFZhbHVlKTtcclxuICB9XHJcblxyXG4gIGlmIChzZXQgIT0gbnVsbCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBFUzUgc3RyaWN0IG1vZGUgcHJvaGliaXRzIGRlZmluaW5nIG5vbi10b3AtbGV2ZWwgZnVuY3Rpb24gZGVjbGFyYXRpb25zLFxyXG4gICAgICogc28gZG9uJ3QgdXNlIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIHN5bnRheCBoZXJlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHNlbGVjdG9yU2V0ID0gKHN0b3JlLCBzdGF0ZSwgbmV3VmFsdWUpID0+IHtcclxuICAgICAgbGV0IHN5bmNTZWxlY3RvclNldEZpbmlzaGVkID0gZmFsc2U7XHJcbiAgICAgIGNvbnN0IHdyaXRlcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGdldFJlY29pbFZhbHVlKHtcclxuICAgICAgICBrZXk6IGRlcEtleVxyXG4gICAgICB9KSB7XHJcbiAgICAgICAgaWYgKHN5bmNTZWxlY3RvclNldEZpbmlzaGVkKSB7XHJcbiAgICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdSZWNvaWw6IEFzeW5jIHNlbGVjdG9yIHNldHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbG9hZGFibGUgPSBnZXROb2RlTG9hZGFibGUkMihzdG9yZSwgc3RhdGUsIGRlcEtleSk7XHJcblxyXG4gICAgICAgIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJykge1xyXG4gICAgICAgICAgcmV0dXJuIGxvYWRhYmxlLmNvbnRlbnRzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xyXG4gICAgICAgICAgY29uc3QgbXNnID0gYEdldHRpbmcgdmFsdWUgb2YgYXN5bmNocm9ub3VzIGF0b20gb3Igc2VsZWN0b3IgXCIke2RlcEtleX1cIiBpbiBhIHBlbmRpbmcgc3RhdGUgd2hpbGUgc2V0dGluZyBzZWxlY3RvciBcIiR7a2V5fVwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLmA7XHJcbiAgICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24obXNnKTtcclxuICAgICAgICAgIHRocm93IFJlY29pbF9lcnIobXNnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgbG9hZGFibGUuY29udGVudHM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSwgdmFsdWVPclVwZGF0ZXIpIHtcclxuICAgICAgICBpZiAoc3luY1NlbGVjdG9yU2V0RmluaXNoZWQpIHtcclxuICAgICAgICAgIGNvbnN0IG1zZyA9ICdSZWNvaWw6IEFzeW5jIHNlbGVjdG9yIHNldHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLic7XHJcbiAgICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24obXNnKTtcclxuICAgICAgICAgIHRocm93IFJlY29pbF9lcnIobXNnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNldFZhbHVlID0gdHlwZW9mIHZhbHVlT3JVcGRhdGVyID09PSAnZnVuY3Rpb24nID8gLy8gY2FzdCB0byBhbnkgYmVjYXVzZSB3ZSBjYW4ndCByZXN0cmljdCB0eXBlIFMgZnJvbSBiZWluZyBhIGZ1bmN0aW9uIGl0c2VsZiB3aXRob3V0IGxvc2luZyBzdXBwb3J0IGZvciBvcGFxdWUgdHlwZXNcclxuICAgICAgICAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxyXG4gICAgICAgIHZhbHVlT3JVcGRhdGVyKGdldFJlY29pbFZhbHVlKHJlY29pbFN0YXRlKSkgOiB2YWx1ZU9yVXBkYXRlcjtcclxuICAgICAgICBjb25zdCB1cHN0cmVhbVdyaXRlcyA9IHNldE5vZGVWYWx1ZSQzKHN0b3JlLCBzdGF0ZSwgcmVjb2lsU3RhdGUua2V5LCBzZXRWYWx1ZSk7XHJcbiAgICAgICAgdXBzdHJlYW1Xcml0ZXMuZm9yRWFjaCgodiwgaykgPT4gd3JpdGVzLnNldChrLCB2KSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHJlc2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcclxuICAgICAgICBzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSwgREVGQVVMVF9WQUxVRSQ2KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcmV0ID0gc2V0KHtcclxuICAgICAgICBzZXQ6IHNldFJlY29pbFN0YXRlLFxyXG4gICAgICAgIGdldDogZ2V0UmVjb2lsVmFsdWUsXHJcbiAgICAgICAgcmVzZXQ6IHJlc2V0UmVjb2lsU3RhdGVcclxuICAgICAgfSwgbmV3VmFsdWUpOyAvLyBzZXQgc2hvdWxkIGJlIGEgdm9pZCBtZXRob2QsIGJ1dCBpZiB0aGUgdXNlciBtYWtlcyBpdCBgYXN5bmNgLCB0aGVuIGl0XHJcbiAgICAgIC8vIHdpbGwgcmV0dXJuIGEgUHJvbWlzZSwgd2hpY2ggd2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQuXHJcblxyXG4gICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyBSZWNvaWxfaXNQcm9taXNlKHJldCkgPyBSZWNvaWxfZXJyKCdSZWNvaWw6IEFzeW5jIHNlbGVjdG9yIHNldHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLicpIDogUmVjb2lsX2VycignUmVjb2lsOiBzZWxlY3RvciBzZXQgc2hvdWxkIGJlIGEgdm9pZCBmdW5jdGlvbi4nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3luY1NlbGVjdG9yU2V0RmluaXNoZWQgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gd3JpdGVzO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gcmVjb2lsVmFsdWUgPSByZWdpc3Rlck5vZGUkMSh7XHJcbiAgICAgIGtleSxcclxuICAgICAgbm9kZVR5cGU6ICdzZWxlY3RvcicsXHJcbiAgICAgIHBlZWs6IHNlbGVjdG9yUGVlayxcclxuICAgICAgZ2V0OiBzZWxlY3RvckdldCxcclxuICAgICAgc2V0OiBzZWxlY3RvclNldCxcclxuICAgICAgaW5pdDogc2VsZWN0b3JJbml0LFxyXG4gICAgICBpbnZhbGlkYXRlOiBpbnZhbGlkYXRlU2VsZWN0b3IsXHJcbiAgICAgIGNsZWFyQ2FjaGU6IGNsZWFyU2VsZWN0b3JDYWNoZSxcclxuICAgICAgc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlOiBzZWxlY3RvclNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZSxcclxuICAgICAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHksXHJcbiAgICAgIHNob3VsZFJlc3RvcmVGcm9tU25hcHNob3RzOiBmYWxzZSxcclxuICAgICAgcmV0YWluZWRCeVxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiByZWNvaWxWYWx1ZSA9IHJlZ2lzdGVyTm9kZSQxKHtcclxuICAgICAga2V5LFxyXG4gICAgICBub2RlVHlwZTogJ3NlbGVjdG9yJyxcclxuICAgICAgcGVlazogc2VsZWN0b3JQZWVrLFxyXG4gICAgICBnZXQ6IHNlbGVjdG9yR2V0LFxyXG4gICAgICBpbml0OiBzZWxlY3RvckluaXQsXHJcbiAgICAgIGludmFsaWRhdGU6IGludmFsaWRhdGVTZWxlY3RvcixcclxuICAgICAgY2xlYXJDYWNoZTogY2xlYXJTZWxlY3RvckNhY2hlLFxyXG4gICAgICBzaG91bGREZWxldGVDb25maWdPblJlbGVhc2U6IHNlbGVjdG9yU2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlLFxyXG4gICAgICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSxcclxuICAgICAgc2hvdWxkUmVzdG9yZUZyb21TbmFwc2hvdHM6IGZhbHNlLFxyXG4gICAgICByZXRhaW5lZEJ5XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuLyogZXNsaW50LWVuYWJsZSBuby1yZWRlY2xhcmUgKi9cclxuLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtdXNlXVxyXG5cclxuXHJcbnNlbGVjdG9yLnZhbHVlID0gdmFsdWUgPT4gbmV3IFdyYXBwZWRWYWx1ZSQxKHZhbHVlKTtcclxuXHJcbnZhciBSZWNvaWxfc2VsZWN0b3IgPSBzZWxlY3RvcjtcclxuXHJcbi8vIEBmYi1vbmx5OiBpbXBvcnQgdHlwZSB7U2NvcGVSdWxlc30gZnJvbSAnUmVjb2lsX1Njb3BlZEF0b20nO1xyXG4vLyBAZmItb25seTogY29uc3Qge3Njb3BlZEF0b219ID0gcmVxdWlyZSgnUmVjb2lsX1Njb3BlZEF0b20nKTtcclxuY29uc3Qge1xyXG4gIGlzTG9hZGFibGU6IGlzTG9hZGFibGUkMixcclxuICBsb2FkYWJsZVdpdGhFcnJvcjogbG9hZGFibGVXaXRoRXJyb3IkMixcclxuICBsb2FkYWJsZVdpdGhQcm9taXNlOiBsb2FkYWJsZVdpdGhQcm9taXNlJDIsXHJcbiAgbG9hZGFibGVXaXRoVmFsdWU6IGxvYWRhYmxlV2l0aFZhbHVlJDNcclxufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xyXG5cclxuY29uc3Qge1xyXG4gIFdyYXBwZWRWYWx1ZTogV3JhcHBlZFZhbHVlJDJcclxufSA9IFJlY29pbF9XcmFwcGVyJDE7XHJcblxyXG5jb25zdCB7XHJcbiAgcGVla05vZGVJbmZvOiBwZWVrTm9kZUluZm8kM1xyXG59ID0gUmVjb2lsX0Z1bmN0aW9uYWxDb3JlO1xyXG5cclxuY29uc3Qge1xyXG4gIERFRkFVTFRfVkFMVUU6IERFRkFVTFRfVkFMVUUkNyxcclxuICBEZWZhdWx0VmFsdWU6IERlZmF1bHRWYWx1ZSQyLFxyXG4gIGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlcjogZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDIsXHJcbiAgcmVnaXN0ZXJOb2RlOiByZWdpc3Rlck5vZGUkMixcclxuICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXI6IHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQxXHJcbn0gPSBSZWNvaWxfTm9kZTtcclxuXHJcbmNvbnN0IHtcclxuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDRcclxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xyXG5cclxuY29uc3Qge1xyXG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZTogZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDQsXHJcbiAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQ6IG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDIsXHJcbiAgc2V0UmVjb2lsVmFsdWU6IHNldFJlY29pbFZhbHVlJDQsXHJcbiAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZTogc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQyXHJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XHJcblxyXG5jb25zdCB7XHJcbiAgcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0OiByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQkMlxyXG59ID0gUmVjb2lsX1JldGVudGlvbjtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY29uc3QgdW53cmFwID0geCA9PiB4IGluc3RhbmNlb2YgV3JhcHBlZFZhbHVlJDIgPyB4LnZhbHVlIDogeDtcclxuXHJcbmZ1bmN0aW9uIGJhc2VBdG9tKG9wdGlvbnMpIHtcclxuICBjb25zdCB7XHJcbiAgICBrZXksXHJcbiAgICBwZXJzaXN0ZW5jZV9VTlNUQUJMRTogcGVyc2lzdGVuY2VcclxuICB9ID0gb3B0aW9ucztcclxuICBjb25zdCByZXRhaW5lZEJ5ID0gcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0JDIob3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFKTtcclxuICBsZXQgbGl2ZVN0b3Jlc0NvdW50ID0gMDtcclxuXHJcbiAgZnVuY3Rpb24gdW53cmFwUHJvbWlzZShwcm9taXNlKSB7XHJcbiAgICByZXR1cm4gbG9hZGFibGVXaXRoUHJvbWlzZSQyKHByb21pc2UudGhlbih2YWx1ZSA9PiB7XHJcbiAgICAgIGRlZmF1bHRMb2FkYWJsZSA9IGxvYWRhYmxlV2l0aFZhbHVlJDModmFsdWUpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgIGRlZmF1bHRMb2FkYWJsZSA9IGxvYWRhYmxlV2l0aEVycm9yJDIoZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gIGxldCBkZWZhdWx0TG9hZGFibGUgPSBSZWNvaWxfaXNQcm9taXNlKG9wdGlvbnMuZGVmYXVsdCkgPyB1bndyYXBQcm9taXNlKG9wdGlvbnMuZGVmYXVsdCkgOiBpc0xvYWRhYmxlJDIob3B0aW9ucy5kZWZhdWx0KSA/IG9wdGlvbnMuZGVmYXVsdC5zdGF0ZSA9PT0gJ2xvYWRpbmcnID8gdW53cmFwUHJvbWlzZShvcHRpb25zLmRlZmF1bHQuY29udGVudHMpIDogb3B0aW9ucy5kZWZhdWx0IDogbG9hZGFibGVXaXRoVmFsdWUkMyh1bndyYXAob3B0aW9ucy5kZWZhdWx0KSk7XHJcbiAgbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZShkZWZhdWx0TG9hZGFibGUuY29udGVudHMpO1xyXG4gIGxldCBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlID0gdW5kZWZpbmVkOyAvLyBDbGVhbnVwIGhhbmRsZXJzIGZvciB0aGlzIGF0b21cclxuICAvLyBSZWx5IG9uIHN0YWJsZSByZWZlcmVuY2UgZXF1YWxpdHkgb2YgdGhlIHN0b3JlIHRvIHVzZSBpdCBhcyBhIGtleSBwZXIgPFJlY29pbFJvb3Q+XHJcblxyXG4gIGNvbnN0IGNsZWFudXBFZmZlY3RzQnlTdG9yZSA9IG5ldyBNYXAoKTtcclxuXHJcbiAgZnVuY3Rpb24gbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZSh2YWx1ZU9yUHJvbWlzZSkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICBpZiAob3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKHZhbHVlT3JQcm9taXNlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlT3JQcm9taXNlLnRoZW4odmFsdWUgPT4ge1xyXG4gICAgICAgICAgICBSZWNvaWxfZGVlcEZyZWV6ZVZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIFJlY29pbF9kZWVwRnJlZXplVmFsdWUodmFsdWVPclByb21pc2UpO1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlT3JQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZU9yUHJvbWlzZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHdyYXBQZW5kaW5nUHJvbWlzZShzdG9yZSwgcHJvbWlzZSkge1xyXG4gICAgY29uc3Qgd3JhcHBlZFByb21pc2UgPSBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xyXG4gICAgICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRULCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQ7XHJcblxyXG4gICAgICBjb25zdCBzdGF0ZSA9IChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgIT09IHZvaWQgMCA/IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA6IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XHJcblxyXG4gICAgICBpZiAoKChfc3RhdGUkYXRvbVZhbHVlcyRnZXQgPSBzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZSRhdG9tVmFsdWVzJGdldC5jb250ZW50cykgPT09IHdyYXBwZWRQcm9taXNlKSB7XHJcbiAgICAgICAgc2V0UmVjb2lsVmFsdWUkNChzdG9yZSwgbm9kZSwgdmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQyLCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQyO1xyXG5cclxuICAgICAgY29uc3Qgc3RhdGUgPSAoX3N0b3JlJGdldFN0YXRlJG5leHRUMiA9IHN0b3JlLmdldFN0YXRlKCkubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDIgIT09IHZvaWQgMCA/IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDIgOiBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xyXG5cclxuICAgICAgaWYgKCgoX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MiA9IHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9zdGF0ZSRhdG9tVmFsdWVzJGdldDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZSRhdG9tVmFsdWVzJGdldDIuY29udGVudHMpID09PSB3cmFwcGVkUHJvbWlzZSkge1xyXG4gICAgICAgIHNldFJlY29pbFZhbHVlTG9hZGFibGUkMihzdG9yZSwgbm9kZSwgbG9hZGFibGVXaXRoRXJyb3IkMihlcnJvcikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHdyYXBwZWRQcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5pdEF0b20oc3RvcmUsIGluaXRTdGF0ZSwgdHJpZ2dlcikge1xyXG4gICAgdmFyIF9vcHRpb25zJGVmZmVjdHM7XHJcblxyXG4gICAgbGl2ZVN0b3Jlc0NvdW50Kys7XHJcblxyXG4gICAgY29uc3QgY2xlYW51cEF0b20gPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfY2xlYW51cEVmZmVjdHNCeVN0b3I7XHJcblxyXG4gICAgICBsaXZlU3RvcmVzQ291bnQtLTtcclxuICAgICAgKF9jbGVhbnVwRWZmZWN0c0J5U3RvciA9IGNsZWFudXBFZmZlY3RzQnlTdG9yZS5nZXQoc3RvcmUpKSA9PT0gbnVsbCB8fCBfY2xlYW51cEVmZmVjdHNCeVN0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jbGVhbnVwRWZmZWN0c0J5U3Rvci5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcclxuICAgICAgY2xlYW51cEVmZmVjdHNCeVN0b3JlLmRlbGV0ZShzdG9yZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHN0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcy5hZGQoa2V5KTsgLy8gU2V0dXAgYXN5bmMgZGVmYXVsdHMgdG8gbm90aWZ5IHN1YnNjcmliZXJzIHdoZW4gdGhleSByZXNvbHZlXHJcblxyXG4gICAgaWYgKGRlZmF1bHRMb2FkYWJsZS5zdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XHJcbiAgICAgIGNvbnN0IG5vdGlmeURlZmF1bHRTdWJzY3JpYmVycyA9ICgpID0+IHtcclxuICAgICAgICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRUMztcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSAoX3N0b3JlJGdldFN0YXRlJG5leHRUMyA9IHN0b3JlLmdldFN0YXRlKCkubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDMgIT09IHZvaWQgMCA/IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDMgOiBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xyXG5cclxuICAgICAgICBpZiAoIXN0YXRlLmF0b21WYWx1ZXMuaGFzKGtleSkpIHtcclxuICAgICAgICAgIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDIoc3RvcmUsIG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIGRlZmF1bHRMb2FkYWJsZS5jb250ZW50cy5maW5hbGx5KG5vdGlmeURlZmF1bHRTdWJzY3JpYmVycyk7XHJcbiAgICB9IC8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIC8vIFJ1biBBdG9tIEVmZmVjdHNcclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblxyXG4gICAgY29uc3QgZWZmZWN0cyA9IChfb3B0aW9ucyRlZmZlY3RzID0gb3B0aW9ucy5lZmZlY3RzKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRlZmZlY3RzICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRlZmZlY3RzIDogb3B0aW9ucy5lZmZlY3RzX1VOU1RBQkxFO1xyXG5cclxuICAgIGlmIChlZmZlY3RzICE9IG51bGwpIHtcclxuICAgICAgLy8gVGhpcyBzdGF0ZSBpcyBzY29wZWQgYnkgU3RvcmUsIHNpbmNlIHRoaXMgaXMgaW4gdGhlIGluaXRBdG9tKCkgY2xvc3VyZVxyXG4gICAgICBsZXQgaW5pdFZhbHVlID0gREVGQVVMVF9WQUxVRSQ3O1xyXG4gICAgICBsZXQgaXNEdXJpbmdJbml0ID0gdHJ1ZTtcclxuICAgICAgbGV0IGlzSW5pdEVycm9yID0gZmFsc2U7XHJcbiAgICAgIGxldCBwZW5kaW5nU2V0U2VsZiA9IG51bGw7XHJcblxyXG4gICAgICBmdW5jdGlvbiBnZXRMb2FkYWJsZShyZWNvaWxWYWx1ZSkge1xyXG4gICAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBqdXN0IGdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiBhbm90aGVyIGF0b20uXHJcbiAgICAgICAgLy8gQnV0IGZvciBvdXIgb3duIHZhbHVlIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgYSBwZW5kaW5nXHJcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQgdmFsdWUgb3IgZ2V0IHRoZSBmYWxsYmFjayBkZWZhdWx0IHZhbHVlLlxyXG4gICAgICAgIGlmIChpc0R1cmluZ0luaXQgJiYgcmVjb2lsVmFsdWUua2V5ID09PSBrZXkpIHtcclxuICAgICAgICAgIC8vIENhc3QgVCB0byBTXHJcbiAgICAgICAgICBjb25zdCByZXRWYWx1ZSA9IGluaXRWYWx1ZTsgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXHJcblxyXG4gICAgICAgICAgcmV0dXJuIHJldFZhbHVlIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDIgPyBwZWVrQXRvbShzdG9yZSwgaW5pdFN0YXRlKSAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcclxuICAgICAgICAgIDogUmVjb2lsX2lzUHJvbWlzZShyZXRWYWx1ZSkgPyBsb2FkYWJsZVdpdGhQcm9taXNlJDIocmV0VmFsdWUudGhlbih2ID0+IHYgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IC8vIENhc3QgVCB0byBTXHJcbiAgICAgICAgICBkZWZhdWx0TG9hZGFibGUudG9Qcm9taXNlKCkgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXHJcbiAgICAgICAgICA6IHYpKSA6IGxvYWRhYmxlV2l0aFZhbHVlJDMocmV0VmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQ0KHN0b3JlLCByZWNvaWxWYWx1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGdldFByb21pc2UocmVjb2lsVmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TG9hZGFibGUocmVjb2lsVmFsdWUpLnRvUHJvbWlzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBnZXRJbmZvX1VOU1RBQkxFKHJlY29pbFZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDQ7XHJcblxyXG4gICAgICAgIGNvbnN0IGluZm8gPSBwZWVrTm9kZUluZm8kMyhzdG9yZSwgKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDQgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ0ICE9PSB2b2lkIDAgPyBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ0IDogc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSwgcmVjb2lsVmFsdWUua2V5KTtcclxuICAgICAgICByZXR1cm4gaXNEdXJpbmdJbml0ICYmIHJlY29pbFZhbHVlLmtleSA9PT0ga2V5ICYmICEoaW5pdFZhbHVlIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDIpID8geyAuLi5pbmZvLFxyXG4gICAgICAgICAgaXNTZXQ6IHRydWUsXHJcbiAgICAgICAgICBsb2FkYWJsZTogZ2V0TG9hZGFibGUocmVjb2lsVmFsdWUpXHJcbiAgICAgICAgfSA6IGluZm87XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHNldFNlbGYgPSBlZmZlY3QgPT4gdmFsdWVPclVwZGF0ZXIgPT4ge1xyXG4gICAgICAgIGlmIChpc0R1cmluZ0luaXQpIHtcclxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRMb2FkYWJsZSA9IGdldExvYWRhYmxlKG5vZGUpO1xyXG4gICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gY3VycmVudExvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnID8gY3VycmVudExvYWRhYmxlLmNvbnRlbnRzIDogREVGQVVMVF9WQUxVRSQ3O1xyXG4gICAgICAgICAgaW5pdFZhbHVlID0gdHlwZW9mIHZhbHVlT3JVcGRhdGVyID09PSAnZnVuY3Rpb24nID8gLy8gY2FzdCB0byBhbnkgYmVjYXVzZSB3ZSBjYW4ndCByZXN0cmljdCBUIGZyb20gYmVpbmcgYSBmdW5jdGlvbiB3aXRob3V0IGxvc2luZyBzdXBwb3J0IGZvciBvcGFxdWUgdHlwZXNcclxuICAgICAgICAgIHZhbHVlT3JVcGRhdGVyKGN1cnJlbnRWYWx1ZSkgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXHJcbiAgICAgICAgICA6IHZhbHVlT3JVcGRhdGVyO1xyXG5cclxuICAgICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKGluaXRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgaW5pdFZhbHVlID0gaW5pdFZhbHVlLnRoZW4odmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAgIC8vIEF2b2lkIGNhbGxpbmcgb25TZXQoKSB3aGVuIHNldFNlbGYoKSBpbml0aWFsaXplcyB3aXRoIGEgUHJvbWlzZVxyXG4gICAgICAgICAgICAgIHBlbmRpbmdTZXRTZWxmID0ge1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0LFxyXG4gICAgICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKHZhbHVlT3JVcGRhdGVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdTZXR0aW5nIGF0b21zIHRvIGFzeW5jIHZhbHVlcyBpcyBub3QgaW1wbGVtZW50ZWQuJyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZU9yVXBkYXRlciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBwZW5kaW5nU2V0U2VsZiA9IHtcclxuICAgICAgICAgICAgICBlZmZlY3QsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHVud3JhcCh2YWx1ZU9yVXBkYXRlcilcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzZXRSZWNvaWxWYWx1ZSQ0KHN0b3JlLCBub2RlLCB0eXBlb2YgdmFsdWVPclVwZGF0ZXIgPT09ICdmdW5jdGlvbicgPyBjdXJyZW50VmFsdWUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHVud3JhcCggLy8gY2FzdCB0byBhbnkgYmVjYXVzZSB3ZSBjYW4ndCByZXN0cmljdCBUIGZyb20gYmVpbmcgYSBmdW5jdGlvbiB3aXRob3V0IGxvc2luZyBzdXBwb3J0IGZvciBvcGFxdWUgdHlwZXNcclxuICAgICAgICAgICAgdmFsdWVPclVwZGF0ZXIoY3VycmVudFZhbHVlKSAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcGVuZGluZ1NldFNlbGYgPSB7XHJcbiAgICAgICAgICAgICAgZWZmZWN0LFxyXG4gICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3VmFsdWU7XHJcbiAgICAgICAgICB9IDogdW53cmFwKHZhbHVlT3JVcGRhdGVyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3QgcmVzZXRTZWxmID0gZWZmZWN0ID0+ICgpID0+IHNldFNlbGYoZWZmZWN0KShERUZBVUxUX1ZBTFVFJDcpO1xyXG5cclxuICAgICAgY29uc3Qgb25TZXQgPSBlZmZlY3QgPT4gaGFuZGxlciA9PiB7XHJcbiAgICAgICAgdmFyIF9jbGVhbnVwRWZmZWN0c0J5U3RvcjI7XHJcblxyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgIHJlbGVhc2VcclxuICAgICAgICB9ID0gc3RvcmUuc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnMoY3VycmVudFN0b3JlID0+IHtcclxuICAgICAgICAgIHZhciBfY3VycmVudFRyZWUkYXRvbVZhbHU7XHJcblxyXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxyXG4gICAgICAgICAgbGV0IHtcclxuICAgICAgICAgICAgY3VycmVudFRyZWUsXHJcbiAgICAgICAgICAgIHByZXZpb3VzVHJlZVxyXG4gICAgICAgICAgfSA9IGN1cnJlbnRTdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgICAgIGlmICghcHJldmlvdXNUcmVlKSB7XHJcbiAgICAgICAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignVHJhbnNhY3Rpb24gc3Vic2NyaWJlcnMgbm90aWZpZWQgd2l0aG91dCBhIG5leHQgdHJlZSBiZWluZyBwcmVzZW50IC0tIHRoaXMgaXMgYSBidWcgaW4gUmVjb2lsJyk7XHJcbiAgICAgICAgICAgIHByZXZpb3VzVHJlZSA9IGN1cnJlbnRUcmVlOyAvLyBhdHRlbXB0IHRvIHRydW5kbGUgb25cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb25zdCBuZXdMb2FkYWJsZSA9IChfY3VycmVudFRyZWUkYXRvbVZhbHUgPSBjdXJyZW50VHJlZS5hdG9tVmFsdWVzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfY3VycmVudFRyZWUkYXRvbVZhbHUgIT09IHZvaWQgMCA/IF9jdXJyZW50VHJlZSRhdG9tVmFsdSA6IGRlZmF1bHRMb2FkYWJsZTtcclxuXHJcbiAgICAgICAgICBpZiAobmV3TG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScpIHtcclxuICAgICAgICAgICAgdmFyIF9wcmV2aW91c1RyZWUkYXRvbVZhbCwgX3BlbmRpbmdTZXRTZWxmLCBfcGVuZGluZ1NldFNlbGYyLCBfcGVuZGluZ1NldFNlbGYzO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBuZXdMb2FkYWJsZS5jb250ZW50cztcclxuICAgICAgICAgICAgY29uc3Qgb2xkTG9hZGFibGUgPSAoX3ByZXZpb3VzVHJlZSRhdG9tVmFsID0gcHJldmlvdXNUcmVlLmF0b21WYWx1ZXMuZ2V0KGtleSkpICE9PSBudWxsICYmIF9wcmV2aW91c1RyZWUkYXRvbVZhbCAhPT0gdm9pZCAwID8gX3ByZXZpb3VzVHJlZSRhdG9tVmFsIDogZGVmYXVsdExvYWRhYmxlO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IG9sZExvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnID8gb2xkTG9hZGFibGUuY29udGVudHMgOiBERUZBVUxUX1ZBTFVFJDc7IC8vIFRPRE8gVGhpcyBpc24ndCBhY3R1YWxseSB2YWxpZCwgdXNlIGFzIGEgcGxhY2Vob2xkZXIgZm9yIG5vdy5cclxuICAgICAgICAgICAgLy8gSWdub3JlIGF0b20gdmFsdWUgY2hhbmdlcyB0aGF0IHdlcmUgc2V0IHZpYSBzZXRTZWxmKCkgaW4gdGhlIHNhbWUgZWZmZWN0LlxyXG4gICAgICAgICAgICAvLyBXZSB3aWxsIHN0aWxsIHByb3Blcmx5IGNhbGwgdGhlIGhhbmRsZXIgaWYgdGhlcmUgd2FzIGEgc3Vic2VxdWVudFxyXG4gICAgICAgICAgICAvLyBzZXQgZnJvbSBzb21ldGhpbmcgb3RoZXIgdGhhbiBhbiBhdG9tIGVmZmVjdCB3aGljaCB3YXMgYmF0Y2hlZFxyXG4gICAgICAgICAgICAvLyB3aXRoIHRoZSBgc2V0U2VsZigpYCBjYWxsLiAgSG93ZXZlciwgd2UgbWF5IGluY29ycmVjdGx5IGlnbm9yZVxyXG4gICAgICAgICAgICAvLyB0aGUgaGFuZGxlciBpZiB0aGUgc3Vic2VxdWVudCBiYXRjaGVkIGNhbGwgaGFwcGVucyB0byBzZXQgdGhlXHJcbiAgICAgICAgICAgIC8vIGF0b20gdG8gdGhlIGV4YWN0IHNhbWUgdmFsdWUgYXMgdGhlIGBzZXRTZWxmKClgLiAgIEJ1dCwgaW4gdGhhdFxyXG4gICAgICAgICAgICAvLyBjYXNlLCBpdCB3YXMga2luZCBvZiBhIG5vb3AsIHNvIHRoZSBzZW1hbnRpY3MgYXJlIGRlYmF0YWJsZS4uXHJcblxyXG4gICAgICAgICAgICBpZiAoKChfcGVuZGluZ1NldFNlbGYgPSBwZW5kaW5nU2V0U2VsZikgPT09IG51bGwgfHwgX3BlbmRpbmdTZXRTZWxmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ1NldFNlbGYuZWZmZWN0KSAhPT0gZWZmZWN0IHx8ICgoX3BlbmRpbmdTZXRTZWxmMiA9IHBlbmRpbmdTZXRTZWxmKSA9PT0gbnVsbCB8fCBfcGVuZGluZ1NldFNlbGYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ1NldFNlbGYyLnZhbHVlKSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICBoYW5kbGVyKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgIWN1cnJlbnRUcmVlLmF0b21WYWx1ZXMuaGFzKGtleSkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoX3BlbmRpbmdTZXRTZWxmMyA9IHBlbmRpbmdTZXRTZWxmKSA9PT0gbnVsbCB8fCBfcGVuZGluZ1NldFNlbGYzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ1NldFNlbGYzLmVmZmVjdCkgPT09IGVmZmVjdCkge1xyXG4gICAgICAgICAgICAgIHBlbmRpbmdTZXRTZWxmID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIGtleSk7XHJcbiAgICAgICAgY2xlYW51cEVmZmVjdHNCeVN0b3JlLnNldChzdG9yZSwgWy4uLigoX2NsZWFudXBFZmZlY3RzQnlTdG9yMiA9IGNsZWFudXBFZmZlY3RzQnlTdG9yZS5nZXQoc3RvcmUpKSAhPT0gbnVsbCAmJiBfY2xlYW51cEVmZmVjdHNCeVN0b3IyICE9PSB2b2lkIDAgPyBfY2xlYW51cEVmZmVjdHNCeVN0b3IyIDogW10pLCByZWxlYXNlXSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBlZmZlY3Qoe1xyXG4gICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICBzdG9yZUlEOiBzdG9yZS5zdG9yZUlELFxyXG4gICAgICAgICAgICBwYXJlbnRTdG9yZUlEX1VOU1RBQkxFOiBzdG9yZS5wYXJlbnRTdG9yZUlELFxyXG4gICAgICAgICAgICB0cmlnZ2VyLFxyXG4gICAgICAgICAgICBzZXRTZWxmOiBzZXRTZWxmKGVmZmVjdCksXHJcbiAgICAgICAgICAgIHJlc2V0U2VsZjogcmVzZXRTZWxmKGVmZmVjdCksXHJcbiAgICAgICAgICAgIG9uU2V0OiBvblNldChlZmZlY3QpLFxyXG4gICAgICAgICAgICBnZXRQcm9taXNlLFxyXG4gICAgICAgICAgICBnZXRMb2FkYWJsZSxcclxuICAgICAgICAgICAgZ2V0SW5mb19VTlNUQUJMRVxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaWYgKGNsZWFudXAgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgX2NsZWFudXBFZmZlY3RzQnlTdG9yMztcclxuXHJcbiAgICAgICAgICAgIGNsZWFudXBFZmZlY3RzQnlTdG9yZS5zZXQoc3RvcmUsIFsuLi4oKF9jbGVhbnVwRWZmZWN0c0J5U3RvcjMgPSBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuZ2V0KHN0b3JlKSkgIT09IG51bGwgJiYgX2NsZWFudXBFZmZlY3RzQnlTdG9yMyAhPT0gdm9pZCAwID8gX2NsZWFudXBFZmZlY3RzQnlTdG9yMyA6IFtdKSwgY2xlYW51cF0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBpbml0VmFsdWUgPSBlcnJvcjtcclxuICAgICAgICAgIGlzSW5pdEVycm9yID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlzRHVyaW5nSW5pdCA9IGZhbHNlOyAvLyBNdXRhdGUgaW5pdGlhbCBzdGF0ZSBpbiBwbGFjZSBzaW5jZSB3ZSBrbm93IHRoZXJlIGFyZSBubyBvdGhlciBzdWJzY3JpYmVyc1xyXG4gICAgICAvLyBzaW5jZSB3ZSBhcmUgdGhlIG9uZXMgaW5pdGlhbGl6aW5nIG9uIGZpcnN0IHVzZS5cclxuXHJcbiAgICAgIGlmICghKGluaXRWYWx1ZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyKSkge1xyXG4gICAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1O1xyXG5cclxuICAgICAgICBjb25zdCBpbml0TG9hZGFibGUgPSBpc0luaXRFcnJvciA/IGxvYWRhYmxlV2l0aEVycm9yJDIoaW5pdFZhbHVlKSA6IFJlY29pbF9pc1Byb21pc2UoaW5pdFZhbHVlKSA/IGxvYWRhYmxlV2l0aFByb21pc2UkMih3cmFwUGVuZGluZ1Byb21pc2Uoc3RvcmUsIGluaXRWYWx1ZSkpIDogbG9hZGFibGVXaXRoVmFsdWUkMyh1bndyYXAoaW5pdFZhbHVlKSk7XHJcbiAgICAgICAgbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZShpbml0TG9hZGFibGUuY29udGVudHMpO1xyXG4gICAgICAgIGluaXRTdGF0ZS5hdG9tVmFsdWVzLnNldChrZXksIGluaXRMb2FkYWJsZSk7IC8vIElmIHRoZXJlIGlzIGEgcGVuZGluZyB0cmFuc2FjdGlvbiwgdGhlbiBhbHNvIG11dGF0ZSB0aGUgbmV4dCBzdGF0ZSB0cmVlLlxyXG4gICAgICAgIC8vIFRoaXMgY291bGQgaGFwcGVuIGlmIHRoZSBhdG9tIHdhcyBmaXJzdCBpbml0aWFsaXplZCBpbiBhbiBhY3Rpb24gdGhhdFxyXG4gICAgICAgIC8vIGFsc28gdXBkYXRlZCBzb21lIG90aGVyIGF0b20ncyBzdGF0ZS5cclxuXHJcbiAgICAgICAgKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1LmF0b21WYWx1ZXMuc2V0KGtleSwgaW5pdExvYWRhYmxlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjbGVhbnVwQXRvbTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBlZWtBdG9tKF9zdG9yZSwgc3RhdGUpIHtcclxuICAgIHZhciBfcmVmLCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQzO1xyXG5cclxuICAgIHJldHVybiAoX3JlZiA9IChfc3RhdGUkYXRvbVZhbHVlcyRnZXQzID0gc3RhdGUuYXRvbVZhbHVlcy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MyAhPT0gdm9pZCAwID8gX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MyA6IGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWUpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiBkZWZhdWx0TG9hZGFibGU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRBdG9tKF9zdG9yZSwgc3RhdGUpIHtcclxuICAgIGlmIChzdGF0ZS5hdG9tVmFsdWVzLmhhcyhrZXkpKSB7XHJcbiAgICAgIC8vIEF0b20gdmFsdWUgaXMgc3RvcmVkIGluIHN0YXRlOlxyXG4gICAgICByZXR1cm4gUmVjb2lsX251bGx0aHJvd3Moc3RhdGUuYXRvbVZhbHVlcy5nZXQoa2V5KSk7XHJcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmhhcyhrZXkpKSB7XHJcbiAgICAgIC8vIEF0b20gdmFsdWUgaXMgc3RvcmVkIGJ1dCBuZWVkcyB2YWxpZGF0aW9uIGJlZm9yZSB1c2UuXHJcbiAgICAgIC8vIFdlIG1pZ2h0IGhhdmUgYWxyZWFkeSB2YWxpZGF0ZWQgaXQgYW5kIGhhdmUgYSBjYWNoZWQgdmFsaWRhdGVkIHZhbHVlOlxyXG4gICAgICBpZiAoY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwZXJzaXN0ZW5jZSA9PSBudWxsKSB7XHJcbiAgICAgICAgUmVjb2lsX2V4cGVjdGF0aW9uVmlvbGF0aW9uKGBUcmllZCB0byByZXN0b3JlIGEgcGVyc2lzdGVkIHZhbHVlIGZvciBhdG9tICR7a2V5fSBidXQgaXQgaGFzIG5vIHBlcnNpc3RlbmNlIHNldHRpbmdzLmApO1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9hZGFibGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG5vbnZhbGlkYXRlZFZhbHVlID0gc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuZ2V0KGtleSk7XHJcbiAgICAgIGNvbnN0IHZhbGlkYXRvclJlc3VsdCA9IHBlcnNpc3RlbmNlLnZhbGlkYXRvcihub252YWxpZGF0ZWRWYWx1ZSwgREVGQVVMVF9WQUxVRSQ3KTtcclxuICAgICAgY29uc3QgdmFsaWRhdGVkVmFsdWVMb2FkYWJsZSA9IHZhbGlkYXRvclJlc3VsdCBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyID8gZGVmYXVsdExvYWRhYmxlIDogbG9hZGFibGVXaXRoVmFsdWUkMyh2YWxpZGF0b3JSZXN1bHQpO1xyXG4gICAgICBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlID0gdmFsaWRhdGVkVmFsdWVMb2FkYWJsZTtcclxuICAgICAgcmV0dXJuIGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZGVmYXVsdExvYWRhYmxlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW52YWxpZGF0ZUF0b20oKSB7XHJcbiAgICBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0QXRvbShfc3RvcmUsIHN0YXRlLCBuZXdWYWx1ZSkge1xyXG4gICAgLy8gQmFpbCBvdXQgaWYgd2UncmUgYmVpbmcgc2V0IHRvIHRoZSBleGlzdGluZyB2YWx1ZSwgb3IgaWYgd2UncmUgYmVpbmdcclxuICAgIC8vIHJlc2V0IGJ1dCBoYXZlIG5vIHN0b3JlZCB2YWx1ZSAodmFsaWRhdGVkIG9yIHVudmFsaWRhdGVkKSB0byByZXNldCBmcm9tOlxyXG4gICAgaWYgKHN0YXRlLmF0b21WYWx1ZXMuaGFzKGtleSkpIHtcclxuICAgICAgY29uc3QgZXhpc3RpbmcgPSBSZWNvaWxfbnVsbHRocm93cyhzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpKTtcclxuXHJcbiAgICAgIGlmIChleGlzdGluZy5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJyAmJiBuZXdWYWx1ZSA9PT0gZXhpc3RpbmcuY29udGVudHMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKCFzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5oYXMoa2V5KSAmJiBuZXdWYWx1ZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyKSB7XHJcbiAgICAgIHJldHVybiBuZXcgTWFwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZShuZXdWYWx1ZSk7XHJcbiAgICBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlID0gdW5kZWZpbmVkOyAvLyBjYW4gYmUgcmVsZWFzZWQgbm93IGlmIGl0IHdhcyBwcmV2aW91c2x5IGluIHVzZVxyXG5cclxuICAgIHJldHVybiBuZXcgTWFwKCkuc2V0KGtleSwgbG9hZGFibGVXaXRoVmFsdWUkMyhuZXdWYWx1ZSkpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlQXRvbSgpIHtcclxuICAgIHJldHVybiBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMihrZXkpICE9PSB1bmRlZmluZWQgJiYgbGl2ZVN0b3Jlc0NvdW50IDw9IDA7XHJcbiAgfVxyXG5cclxuICBjb25zdCBub2RlID0gcmVnaXN0ZXJOb2RlJDIoe1xyXG4gICAga2V5LFxyXG4gICAgbm9kZVR5cGU6ICdhdG9tJyxcclxuICAgIHBlZWs6IHBlZWtBdG9tLFxyXG4gICAgZ2V0OiBnZXRBdG9tLFxyXG4gICAgc2V0OiBzZXRBdG9tLFxyXG4gICAgaW5pdDogaW5pdEF0b20sXHJcbiAgICBpbnZhbGlkYXRlOiBpbnZhbGlkYXRlQXRvbSxcclxuICAgIHNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZTogc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlQXRvbSxcclxuICAgIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiBvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5LFxyXG4gICAgcGVyc2lzdGVuY2VfVU5TVEFCTEU6IG9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUgPyB7XHJcbiAgICAgIHR5cGU6IG9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUudHlwZSxcclxuICAgICAgYmFja0J1dHRvbjogb3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRS5iYWNrQnV0dG9uXHJcbiAgICB9IDogdW5kZWZpbmVkLFxyXG4gICAgc2hvdWxkUmVzdG9yZUZyb21TbmFwc2hvdHM6IHRydWUsXHJcbiAgICByZXRhaW5lZEJ5XHJcbiAgfSk7XHJcbiAgcmV0dXJuIG5vZGU7XHJcbn0gLy8gcHJldHRpZXItaWdub3JlXHJcblxyXG5cclxuZnVuY3Rpb24gYXRvbShvcHRpb25zKSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmtleSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgUmVjb2lsX2VycignQSBrZXkgb3B0aW9uIHdpdGggYSB1bmlxdWUgc3RyaW5nIHZhbHVlIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBjcmVhdGluZyBhbiBhdG9tLicpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgeyAvLyBAZmItb25seTogc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTLFxyXG4gICAgLi4ucmVzdE9wdGlvbnNcclxuICB9ID0gb3B0aW9ucztcclxuICBjb25zdCBvcHRpb25zRGVmYXVsdCA9ICdkZWZhdWx0JyBpbiBvcHRpb25zID8gLy8gJEZsb3dJc3N1ZVtwcm9wLW1pc3NpbmddIE5vIHdheSB0byByZWZpbmUgaW4gRmxvdyB0aGF0IHByb3BlcnR5IGlzIG5vdCBkZWZpbmVkXHJcbiAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtdHlwZV0gTm8gd2F5IHRvIHJlZmluZSBpbiBGbG93IHRoYXQgcHJvcGVydHkgaXMgbm90IGRlZmluZWRcclxuICBvcHRpb25zLmRlZmF1bHQgOiBuZXcgUHJvbWlzZSgoKSA9PiB7fSk7XHJcblxyXG4gIGlmIChpc1JlY29pbFZhbHVlJDQob3B0aW9uc0RlZmF1bHQpIC8vIENvbnRpbnVlIHRvIHVzZSBhdG9tV2l0aEZhbGxiYWNrIGZvciBwcm9taXNlIGRlZmF1bHRzIGZvciBzY29wZWQgYXRvbXNcclxuICAvLyBmb3Igbm93LCBzaW5jZSBzY29wZWQgYXRvbXMgZG9uJ3Qgc3VwcG9ydCBhc3luYyBkZWZhdWx0c1xyXG4gIC8vIEBmYi1vbmx5OiB8fCAoaXNQcm9taXNlKG9wdGlvbnNEZWZhdWx0KSAmJiBzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1MpXHJcbiAgLy8gQGZiLW9ubHk6IHx8IChpc0xvYWRhYmxlKG9wdGlvbnNEZWZhdWx0KSAmJiBzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1MpXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gYXRvbVdpdGhGYWxsYmFjayh7IC4uLnJlc3RPcHRpb25zLFxyXG4gICAgICBkZWZhdWx0OiBvcHRpb25zRGVmYXVsdCAvLyBAZmItb25seTogc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTLFxyXG5cclxuICAgIH0pOyAvLyBAZmItb25seTogfSBlbHNlIGlmIChzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1NcclxuICAgIC8vIEBmYi1vbmx5OiAmJiAhaXNQcm9taXNlKG9wdGlvbnNEZWZhdWx0KVxyXG4gICAgLy8gQGZiLW9ubHk6ICYmICFpc0xvYWRhYmxlKG9wdGlvbnNEZWZhdWx0KVxyXG4gICAgLy8gQGZiLW9ubHk6ICkge1xyXG4gICAgLy8gQGZiLW9ubHk6IHJldHVybiBzY29wZWRBdG9tPFQ+KHtcclxuICAgIC8vIEBmYi1vbmx5OiAuLi5yZXN0T3B0aW9ucyxcclxuICAgIC8vIEBmYi1vbmx5OiBkZWZhdWx0OiB1bndyYXA8VD4ob3B0aW9uc0RlZmF1bHQpLFxyXG4gICAgLy8gQGZiLW9ubHk6IHNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUyxcclxuICAgIC8vIEBmYi1vbmx5OiB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGJhc2VBdG9tKHsgLi4ucmVzdE9wdGlvbnMsXHJcbiAgICAgIGRlZmF1bHQ6IG9wdGlvbnNEZWZhdWx0XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGF0b21XaXRoRmFsbGJhY2sob3B0aW9ucykge1xyXG4gIGNvbnN0IGJhc2UgPSBhdG9tKHsgLi4ub3B0aW9ucyxcclxuICAgIGRlZmF1bHQ6IERFRkFVTFRfVkFMVUUkNyxcclxuICAgIHBlcnNpc3RlbmNlX1VOU1RBQkxFOiBvcHRpb25zLnBlcnNpc3RlbmNlX1VOU1RBQkxFID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB7IC4uLm9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUsXHJcbiAgICAgIHZhbGlkYXRvcjogc3RvcmVkVmFsdWUgPT4gc3RvcmVkVmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IHN0b3JlZFZhbHVlIDogUmVjb2lsX251bGx0aHJvd3Mob3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRSkudmFsaWRhdG9yKHN0b3JlZFZhbHVlLCBERUZBVUxUX1ZBTFVFJDcpXHJcbiAgICB9LFxyXG4gICAgLy8gVE9ETyBIYWNrIGZvciBub3cuXHJcbiAgICBlZmZlY3RzOiBvcHRpb25zLmVmZmVjdHMsXHJcbiAgICAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTogb2ZmXHJcbiAgICBlZmZlY3RzX1VOU1RBQkxFOiBvcHRpb25zLmVmZmVjdHNfVU5TVEFCTEUgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxyXG5cclxuICB9KTtcclxuICBjb25zdCBzZWwgPSBSZWNvaWxfc2VsZWN0b3Ioe1xyXG4gICAga2V5OiBgJHtvcHRpb25zLmtleX1fX3dpdGhGYWxsYmFja2AsXHJcbiAgICBnZXQ6ICh7XHJcbiAgICAgIGdldFxyXG4gICAgfSkgPT4ge1xyXG4gICAgICBjb25zdCBiYXNlVmFsdWUgPSBnZXQoYmFzZSk7XHJcbiAgICAgIHJldHVybiBiYXNlVmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IG9wdGlvbnMuZGVmYXVsdCA6IGJhc2VWYWx1ZTtcclxuICAgIH0sXHJcbiAgICBzZXQ6ICh7XHJcbiAgICAgIHNldFxyXG4gICAgfSwgbmV3VmFsdWUpID0+IHNldChiYXNlLCBuZXdWYWx1ZSksXHJcbiAgICAvLyBUaGlzIHNlbGVjdG9yIGRvZXMgbm90IG5lZWQgdG8gY2FjaGUgYXMgaXQgaXMgYSB3cmFwcGVyIHNlbGVjdG9yXHJcbiAgICAvLyBhbmQgdGhlIHNlbGVjdG9yIHdpdGhpbiB0aGUgd3JhcHBlciBzZWxlY3RvciB3aWxsIGhhdmUgYSBjYWNoZVxyXG4gICAgLy8gb3B0aW9uIGJ5IGRlZmF1bHRcclxuICAgIGNhY2hlUG9saWN5X1VOU1RBQkxFOiB7XHJcbiAgICAgIGV2aWN0aW9uOiAnbW9zdC1yZWNlbnQnXHJcbiAgICB9LFxyXG4gICAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHlcclxuICB9KTtcclxuICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMShzZWwua2V5LCBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMihvcHRpb25zLmtleSkpO1xyXG4gIHJldHVybiBzZWw7XHJcbn1cclxuXHJcbmF0b20udmFsdWUgPSB2YWx1ZSA9PiBuZXcgV3JhcHBlZFZhbHVlJDIodmFsdWUpO1xyXG5cclxudmFyIFJlY29pbF9hdG9tID0gYXRvbTtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcblxyXG5jbGFzcyBNYXBDYWNoZSB7XHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgdmFyIF9vcHRpb25zJG1hcEtleTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWFwXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2tleU1hcHBlclwiLCB2b2lkIDApO1xyXG5cclxuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuX2tleU1hcHBlciA9IChfb3B0aW9ucyRtYXBLZXkgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWFwS2V5KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRtYXBLZXkgIT09IHZvaWQgMCA/IF9vcHRpb25zJG1hcEtleSA6IHYgPT4gdjtcclxuICB9XHJcblxyXG4gIHNpemUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLnNpemU7XHJcbiAgfVxyXG5cclxuICBoYXMoa2V5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyh0aGlzLl9rZXlNYXBwZXIoa2V5KSk7XHJcbiAgfVxyXG5cclxuICBnZXQoa2V5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldCh0aGlzLl9rZXlNYXBwZXIoa2V5KSk7XHJcbiAgfVxyXG5cclxuICBzZXQoa2V5LCB2YWwpIHtcclxuICAgIHRoaXMuX21hcC5zZXQodGhpcy5fa2V5TWFwcGVyKGtleSksIHZhbCk7XHJcbiAgfVxyXG5cclxuICBkZWxldGUoa2V5KSB7XHJcbiAgICB0aGlzLl9tYXAuZGVsZXRlKHRoaXMuX2tleU1hcHBlcihrZXkpKTtcclxuICB9XHJcblxyXG4gIGNsZWFyKCkge1xyXG4gICAgdGhpcy5fbWFwLmNsZWFyKCk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxudmFyIFJlY29pbF9NYXBDYWNoZSA9IHtcclxuICBNYXBDYWNoZVxyXG59O1xyXG5cclxudmFyIFJlY29pbF9NYXBDYWNoZV8xID0gUmVjb2lsX01hcENhY2hlLk1hcENhY2hlO1xyXG5cclxudmFyIFJlY29pbF9NYXBDYWNoZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xyXG4gIF9fcHJvdG9fXzogbnVsbCxcclxuICBNYXBDYWNoZTogUmVjb2lsX01hcENhY2hlXzFcclxufSk7XHJcblxyXG5jb25zdCB7XHJcbiAgTFJVQ2FjaGU6IExSVUNhY2hlJDJcclxufSA9IFJlY29pbF9MUlVDYWNoZSQxO1xyXG5cclxuY29uc3Qge1xyXG4gIE1hcENhY2hlOiBNYXBDYWNoZSQxXHJcbn0gPSBSZWNvaWxfTWFwQ2FjaGUkMTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IGRlZmF1bHRQb2xpY3kkMSA9IHtcclxuICBlcXVhbGl0eTogJ3JlZmVyZW5jZScsXHJcbiAgZXZpY3Rpb246ICdub25lJyxcclxuICBtYXhTaXplOiBJbmZpbml0eVxyXG59O1xyXG5cclxuZnVuY3Rpb24gY2FjaGVGcm9tUG9saWN5KHtcclxuICBlcXVhbGl0eSA9IGRlZmF1bHRQb2xpY3kkMS5lcXVhbGl0eSxcclxuICBldmljdGlvbiA9IGRlZmF1bHRQb2xpY3kkMS5ldmljdGlvbixcclxuICBtYXhTaXplID0gZGVmYXVsdFBvbGljeSQxLm1heFNpemVcclxufSA9IGRlZmF1bHRQb2xpY3kkMSkge1xyXG4gIGNvbnN0IHZhbHVlTWFwcGVyID0gZ2V0VmFsdWVNYXBwZXIkMShlcXVhbGl0eSk7XHJcbiAgY29uc3QgY2FjaGUgPSBnZXRDYWNoZShldmljdGlvbiwgbWF4U2l6ZSwgdmFsdWVNYXBwZXIpO1xyXG4gIHJldHVybiBjYWNoZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VmFsdWVNYXBwZXIkMShlcXVhbGl0eSkge1xyXG4gIHN3aXRjaCAoZXF1YWxpdHkpIHtcclxuICAgIGNhc2UgJ3JlZmVyZW5jZSc6XHJcbiAgICAgIHJldHVybiB2YWwgPT4gdmFsO1xyXG5cclxuICAgIGNhc2UgJ3ZhbHVlJzpcclxuICAgICAgcmV0dXJuIHZhbCA9PiBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5KHZhbCk7XHJcbiAgfVxyXG5cclxuICB0aHJvdyBSZWNvaWxfZXJyKGBVbnJlY29nbml6ZWQgZXF1YWxpdHkgcG9saWN5ICR7ZXF1YWxpdHl9YCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldENhY2hlKGV2aWN0aW9uLCBtYXhTaXplLCBtYXBLZXkpIHtcclxuICBzd2l0Y2ggKGV2aWN0aW9uKSB7XHJcbiAgICBjYXNlICdrZWVwLWFsbCc6XHJcbiAgICAgIHJldHVybiBuZXcgTWFwQ2FjaGUkMSh7XHJcbiAgICAgICAgbWFwS2V5XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgJ2xydSc6XHJcbiAgICAgIHJldHVybiBuZXcgTFJVQ2FjaGUkMih7XHJcbiAgICAgICAgbWFwS2V5LFxyXG4gICAgICAgIG1heFNpemU6IFJlY29pbF9udWxsdGhyb3dzKG1heFNpemUpXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgJ21vc3QtcmVjZW50JzpcclxuICAgICAgcmV0dXJuIG5ldyBMUlVDYWNoZSQyKHtcclxuICAgICAgICBtYXBLZXksXHJcbiAgICAgICAgbWF4U2l6ZTogMVxyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIHRocm93IFJlY29pbF9lcnIoYFVucmVjb2duaXplZCBldmljdGlvbiBwb2xpY3kgJHtldmljdGlvbn1gKTtcclxufVxyXG5cclxudmFyIFJlY29pbF9jYWNoZUZyb21Qb2xpY3kgPSBjYWNoZUZyb21Qb2xpY3k7XHJcblxyXG4vLyBAZmItb25seTogaW1wb3J0IHR5cGUge1Njb3BlUnVsZXN9IGZyb20gJ1JlY29pbF9TY29wZWRBdG9tJztcclxuXHJcblxyXG5jb25zdCB7XHJcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyOiBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMlxyXG59ID0gUmVjb2lsX05vZGU7XHJcblxyXG5cclxuXHJcblxyXG5cclxuLy8gUHJvY2VzcyBzY29wZVJ1bGVzIHRvIGhhbmRsZSBhbnkgZW50cmllcyB3aGljaCBhcmUgZnVuY3Rpb25zIHRha2luZyBwYXJhbWV0ZXJzXHJcbi8vIHByZXR0aWVyLWlnbm9yZVxyXG4vLyBAZmItb25seTogZnVuY3Rpb24gbWFwU2NvcGVSdWxlczxQPihcclxuLy8gQGZiLW9ubHk6IHNjb3BlUnVsZXM/OiBQYXJhbWV0ZXJpemVkU2NvcGVSdWxlczxQPixcclxuLy8gQGZiLW9ubHk6IHBhcmFtOiBQLFxyXG4vLyBAZmItb25seTogKTogU2NvcGVSdWxlcyB8IHZvaWQge1xyXG4vLyBAZmItb25seTogcmV0dXJuIHNjb3BlUnVsZXM/Lm1hcChydWxlID0+XHJcbi8vIEBmYi1vbmx5OiBBcnJheS5pc0FycmF5KHJ1bGUpXHJcbi8vIEBmYi1vbmx5OiA/IHJ1bGUubWFwKGVudHJ5ID0+ICh0eXBlb2YgZW50cnkgPT09ICdmdW5jdGlvbicgPyBlbnRyeShwYXJhbSkgOiBlbnRyeSkpXHJcbi8vIEBmYi1vbmx5OiA6IHJ1bGUsXHJcbi8vIEBmYi1vbmx5OiApO1xyXG4vLyBAZmItb25seTogfVxyXG5cclxuLypcclxuQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIGF0b20gYmFzZWQgb24gdGhlIGlucHV0IHBhcmFtZXRlci5cclxuXHJcbkVhY2ggdW5pcXVlIHBhcmFtZXRlciByZXR1cm5zIGEgdW5pcXVlIGF0b20uIEUuZy4sXHJcblxyXG4gIGNvbnN0IGYgPSBhdG9tRmFtaWx5KC4uLik7XHJcbiAgZih7YTogMX0pID0+IGFuIGF0b21cclxuICBmKHthOiAyfSkgPT4gYSBkaWZmZXJlbnQgYXRvbVxyXG5cclxuVGhpcyBhbGxvd3MgY29tcG9uZW50cyB0byBwZXJzaXN0IGxvY2FsLCBwcml2YXRlIHN0YXRlIHVzaW5nIGF0b21zLiAgRWFjaFxyXG5pbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50IG1heSBoYXZlIGEgZGlmZmVyZW50IGtleSwgd2hpY2ggaXQgdXNlcyBhcyB0aGVcclxucGFyYW1ldGVyIGZvciBhIGZhbWlseSBvZiBhdG9tczsgaW4gdGhpcyB3YXksIGVhY2ggY29tcG9uZW50IHdpbGwgaGF2ZVxyXG5pdHMgb3duIGF0b20gbm90IHNoYXJlZCBieSBvdGhlciBpbnN0YW5jZXMuICBUaGVzZSBzdGF0ZSBrZXlzIG1heSBiZSBjb21wb3NlZFxyXG5pbnRvIGNoaWxkcmVuJ3Mgc3RhdGUga2V5cyBhcyB3ZWxsLlxyXG4qL1xyXG5mdW5jdGlvbiBhdG9tRmFtaWx5KG9wdGlvbnMpIHtcclxuICB2YXIgX29wdGlvbnMkY2FjaGVQb2xpY3lGLCBfb3B0aW9ucyRjYWNoZVBvbGljeUYyO1xyXG5cclxuICBjb25zdCBhdG9tQ2FjaGUgPSBSZWNvaWxfY2FjaGVGcm9tUG9saWN5KHtcclxuICAgIGVxdWFsaXR5OiAoX29wdGlvbnMkY2FjaGVQb2xpY3lGID0gKF9vcHRpb25zJGNhY2hlUG9saWN5RjIgPSBvcHRpb25zLmNhY2hlUG9saWN5Rm9yUGFyYW1zX1VOU1RBQkxFKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRjYWNoZVBvbGljeUYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRjYWNoZVBvbGljeUYyLmVxdWFsaXR5KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRjYWNoZVBvbGljeUYgIT09IHZvaWQgMCA/IF9vcHRpb25zJGNhY2hlUG9saWN5RiA6ICd2YWx1ZScsXHJcbiAgICBldmljdGlvbjogJ2tlZXAtYWxsJ1xyXG4gIH0pOyAvLyBTaW1wbGUgYXRvbUZhbWlseSBpbXBsZW1lbnRhdGlvbiB0byBjYWNoZSBpbmRpdmlkdWFsIGF0b21zIGJhc2VkXHJcbiAgLy8gb24gdGhlIHBhcmFtZXRlciB2YWx1ZSBlcXVhbGl0eS5cclxuXHJcbiAgcmV0dXJuIHBhcmFtcyA9PiB7XHJcbiAgICB2YXIgX3N0YWJsZVN0cmluZ2lmeSwgX29wdGlvbnMkZWZmZWN0cztcclxuXHJcbiAgICBjb25zdCBjYWNoZWRBdG9tID0gYXRvbUNhY2hlLmdldChwYXJhbXMpO1xyXG5cclxuICAgIGlmIChjYWNoZWRBdG9tICE9IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGNhY2hlZEF0b207XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICBjYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRSxcclxuICAgICAgLi4uYXRvbU9wdGlvbnNcclxuICAgIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3Qgb3B0aW9uc0RlZmF1bHQgPSAnZGVmYXVsdCcgaW4gb3B0aW9ucyA/IC8vICRGbG93SXNzdWVbcHJvcC1taXNzaW5nXSBObyB3YXkgdG8gcmVmaW5lIGluIEZsb3cgdGhhdCBwcm9wZXJ0eSBpcyBub3QgZGVmaW5lZFxyXG4gICAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtdHlwZV0gTm8gd2F5IHRvIHJlZmluZSBpbiBGbG93IHRoYXQgcHJvcGVydHkgaXMgbm90IGRlZmluZWRcclxuICAgIG9wdGlvbnMuZGVmYXVsdCA6IG5ldyBQcm9taXNlKCgpID0+IHt9KTtcclxuICAgIGNvbnN0IG5ld0F0b20gPSBSZWNvaWxfYXRvbSh7IC4uLmF0b21PcHRpb25zLFxyXG4gICAgICBrZXk6IGAke29wdGlvbnMua2V5fV9fJHsoX3N0YWJsZVN0cmluZ2lmeSA9IFJlY29pbF9zdGFibGVTdHJpbmdpZnkocGFyYW1zKSkgIT09IG51bGwgJiYgX3N0YWJsZVN0cmluZ2lmeSAhPT0gdm9pZCAwID8gX3N0YWJsZVN0cmluZ2lmeSA6ICd2b2lkJ31gLFxyXG4gICAgICBkZWZhdWx0OiB0eXBlb2Ygb3B0aW9uc0RlZmF1bHQgPT09ICdmdW5jdGlvbicgPyAvLyBUaGUgZGVmYXVsdCB3YXMgcGFyYW1ldGVyaXplZFxyXG4gICAgICAvLyBGbG93IGRvZXNuJ3Qga25vdyB0aGF0IFQgaXNuJ3QgYSBmdW5jdGlvbiwgc28gd2UgbmVlZCB0byBjYXNlIHRvIGFueVxyXG4gICAgICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS11c2VdXHJcbiAgICAgIG9wdGlvbnNEZWZhdWx0KHBhcmFtcykgOiAvLyBEZWZhdWx0IG1heSBiZSBhIHN0YXRpYyB2YWx1ZSwgcHJvbWlzZSwgb3IgUmVjb2lsVmFsdWVcclxuICAgICAgb3B0aW9uc0RlZmF1bHQsXHJcbiAgICAgIHJldGFpbmVkQnlfVU5TVEFCTEU6IHR5cGVvZiBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUocGFyYW1zKSA6IG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSxcclxuICAgICAgZWZmZWN0czogdHlwZW9mIG9wdGlvbnMuZWZmZWN0cyA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZWZmZWN0cyhwYXJhbXMpIDogdHlwZW9mIG9wdGlvbnMuZWZmZWN0c19VTlNUQUJMRSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZWZmZWN0c19VTlNUQUJMRShwYXJhbXMpIDogKF9vcHRpb25zJGVmZmVjdHMgPSBvcHRpb25zLmVmZmVjdHMpICE9PSBudWxsICYmIF9vcHRpb25zJGVmZmVjdHMgIT09IHZvaWQgMCA/IF9vcHRpb25zJGVmZmVjdHMgOiBvcHRpb25zLmVmZmVjdHNfVU5TVEFCTEUgLy8gcHJldHRpZXItaWdub3JlXHJcbiAgICAgIC8vIEBmYi1vbmx5OiBzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1M6IG1hcFNjb3BlUnVsZXMoXHJcbiAgICAgIC8vIEBmYi1vbmx5OiBvcHRpb25zLnNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUyxcclxuICAgICAgLy8gQGZiLW9ubHk6IHBhcmFtcyxcclxuICAgICAgLy8gQGZiLW9ubHk6ICksXHJcblxyXG4gICAgfSk7XHJcbiAgICBhdG9tQ2FjaGUuc2V0KHBhcmFtcywgbmV3QXRvbSk7XHJcbiAgICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMihuZXdBdG9tLmtleSwgKCkgPT4ge1xyXG4gICAgICBhdG9tQ2FjaGUuZGVsZXRlKHBhcmFtcyk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXdBdG9tO1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfYXRvbUZhbWlseSA9IGF0b21GYW1pbHk7XHJcblxyXG5jb25zdCB7XHJcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyOiBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkM1xyXG59ID0gUmVjb2lsX05vZGU7XHJcblxyXG5cclxuXHJcblxyXG5cclxuIC8vIEtlZXAgaW4gbWluZCB0aGUgcGFyYW1ldGVyIG5lZWRzIHRvIGJlIHNlcmlhbGl6YWJsZSBhcyBhIGNhaGNoZSBrZXlcclxuLy8gdXNpbmcgUmVjb2lsX3N0YWJsZVN0cmluZ2lmeVxyXG5cclxuXHJcbi8vIEFkZCBhIHVuaXF1ZSBpbmRleCB0byBlYWNoIHNlbGVjdG9yIGluIGNhc2UgdGhlIGNhY2hlIGltcGxlbWVudGF0aW9uIGFsbG93c1xyXG4vLyBkdXBsaWNhdGUga2V5cyBiYXNlZCBvbiBlcXVpdmFsZW50IHN0cmluZ2lmaWVkIHBhcmFtZXRlcnNcclxubGV0IG5leHRJbmRleCA9IDA7XHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xyXG5cclxuLy8gUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG1lbWJlcnMgb2YgYSBmYW1pbHkgb2Ygc2VsZWN0b3JzIG9mIHRoZSBzYW1lIHR5cGVcclxuLy8gRS5nLixcclxuLy9cclxuLy8gY29uc3QgcyA9IHNlbGVjdG9yRmFtaWx5KC4uLik7XHJcbi8vIHMoe2E6IDF9KSA9PiBhIHNlbGVjdG9yXHJcbi8vIHMoe2E6IDJ9KSA9PiBhIGRpZmZlcmVudCBzZWxlY3RvclxyXG4vL1xyXG4vLyBCeSBkZWZhdWx0LCB0aGUgc2VsZWN0b3JzIGFyZSBkaXN0aW5ndWlzaGVkIGJ5IGRpc3RpbmN0IHZhbHVlcyBvZiB0aGVcclxuLy8gcGFyYW1ldGVyIGJhc2VkIG9uIHZhbHVlIGVxdWFsaXR5LCBub3QgcmVmZXJlbmNlIGVxdWFsaXR5LiAgVGhpcyBhbGxvd3MgdXNpbmdcclxuLy8gb2JqZWN0IGxpdGVyYWxzIG9yIG90aGVyIGVxdWl2YWxlbnQgb2JqZWN0cyBhdCBjYWxsc2l0ZXMgdG8gbm90IGNyZWF0ZVxyXG4vLyBkdXBsaWNhdGUgY2FjaGUgZW50cmllcy4gIFRoaXMgYmVoYXZpb3IgbWF5IGJlIG92ZXJyaWRkZW4gd2l0aCB0aGVcclxuLy8gY2FjaGVJbXBsZW1lbnRhdGlvbkZvclBhcmFtcyBvcHRpb24uXHJcbmZ1bmN0aW9uIHNlbGVjdG9yRmFtaWx5KG9wdGlvbnMpIHtcclxuICB2YXIgX29wdGlvbnMkY2FjaGVQb2xpY3lGLCBfb3B0aW9ucyRjYWNoZVBvbGljeUYyO1xyXG5cclxuICBjb25zdCBzZWxlY3RvckNhY2hlID0gUmVjb2lsX2NhY2hlRnJvbVBvbGljeSh7XHJcbiAgICBlcXVhbGl0eTogKF9vcHRpb25zJGNhY2hlUG9saWN5RiA9IChfb3B0aW9ucyRjYWNoZVBvbGljeUYyID0gb3B0aW9ucy5jYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRSkgPT09IG51bGwgfHwgX29wdGlvbnMkY2FjaGVQb2xpY3lGMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkY2FjaGVQb2xpY3lGMi5lcXVhbGl0eSkgIT09IG51bGwgJiYgX29wdGlvbnMkY2FjaGVQb2xpY3lGICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRjYWNoZVBvbGljeUYgOiAndmFsdWUnLFxyXG4gICAgZXZpY3Rpb246ICdrZWVwLWFsbCdcclxuICB9KTtcclxuICByZXR1cm4gcGFyYW1zID0+IHtcclxuICAgIHZhciBfc3RhYmxlU3RyaW5naWZ5O1xyXG5cclxuICAgIC8vIFRocm93IGFuIGVycm9yIHdpdGggc2VsZWN0b3Iga2V5IHNvIHRoYXQgaXQgaXMgY2xlYXIgd2hpY2hcclxuICAgIC8vIHNlbGVjdG9yIGlzIGNhdXNpbmcgYW4gZXJyb3JcclxuICAgIGxldCBjYWNoZWRTZWxlY3RvcjtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjYWNoZWRTZWxlY3RvciA9IHNlbGVjdG9yQ2FjaGUuZ2V0KHBhcmFtcyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKGBQcm9ibGVtIHdpdGggY2FjaGUgbG9va3VwIGZvciBzZWxlY3RvciAke29wdGlvbnMua2V5fTogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjYWNoZWRTZWxlY3RvciAhPSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBjYWNoZWRTZWxlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBteUtleSA9IGAke29wdGlvbnMua2V5fV9fc2VsZWN0b3JGYW1pbHkvJHsoX3N0YWJsZVN0cmluZ2lmeSA9IFJlY29pbF9zdGFibGVTdHJpbmdpZnkocGFyYW1zLCB7XHJcbiAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRvIHVzZSBmdW5jdGlvbnMgaW4gcGFyYW1ldGVycyBpZiB0aGUgdXNlciB1c2VzXHJcbiAgICAgIC8vIGEgY2FjaGUgd2l0aCByZWZlcmVuY2UgZXF1YWxpdHkgdGhhbmtzIHRvIHRoZSBpbmNyZW1lbnRpbmcgaW5kZXguXHJcbiAgICAgIGFsbG93RnVuY3Rpb25zOiB0cnVlXHJcbiAgICB9KSkgIT09IG51bGwgJiYgX3N0YWJsZVN0cmluZ2lmeSAhPT0gdm9pZCAwID8gX3N0YWJsZVN0cmluZ2lmeSA6ICd2b2lkJ30vJHtuZXh0SW5kZXgrK31gOyAvLyBBcHBlbmQgaW5kZXggaW4gY2FzZSB2YWx1ZXMgc2VyaWFsaXplIHRvIHRoZSBzYW1lIGtleSBzdHJpbmdcclxuXHJcbiAgICBjb25zdCBteUdldCA9IGNhbGxiYWNrcyA9PiBvcHRpb25zLmdldChwYXJhbXMpKGNhbGxiYWNrcyk7XHJcblxyXG4gICAgY29uc3QgbXlDYWNoZVBvbGljeSA9IG9wdGlvbnMuY2FjaGVQb2xpY3lfVU5TVEFCTEU7XHJcbiAgICBjb25zdCByZXRhaW5lZEJ5ID0gdHlwZW9mIG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRShwYXJhbXMpIDogb3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFO1xyXG4gICAgbGV0IG5ld1NlbGVjdG9yO1xyXG5cclxuICAgIGlmIChvcHRpb25zLnNldCAhPSBudWxsKSB7XHJcbiAgICAgIGNvbnN0IHNldCA9IG9wdGlvbnMuc2V0O1xyXG5cclxuICAgICAgY29uc3QgbXlTZXQgPSAoY2FsbGJhY2tzLCBuZXdWYWx1ZSkgPT4gc2V0KHBhcmFtcykoY2FsbGJhY2tzLCBuZXdWYWx1ZSk7XHJcblxyXG4gICAgICBuZXdTZWxlY3RvciA9IFJlY29pbF9zZWxlY3Rvcih7XHJcbiAgICAgICAga2V5OiBteUtleSxcclxuICAgICAgICBnZXQ6IG15R2V0LFxyXG4gICAgICAgIHNldDogbXlTZXQsXHJcbiAgICAgICAgY2FjaGVQb2xpY3lfVU5TVEFCTEU6IG15Q2FjaGVQb2xpY3ksXHJcbiAgICAgICAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHksXHJcbiAgICAgICAgcmV0YWluZWRCeV9VTlNUQUJMRTogcmV0YWluZWRCeVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG5ld1NlbGVjdG9yID0gUmVjb2lsX3NlbGVjdG9yKHtcclxuICAgICAgICBrZXk6IG15S2V5LFxyXG4gICAgICAgIGdldDogbXlHZXQsXHJcbiAgICAgICAgY2FjaGVQb2xpY3lfVU5TVEFCTEU6IG15Q2FjaGVQb2xpY3ksXHJcbiAgICAgICAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHksXHJcbiAgICAgICAgcmV0YWluZWRCeV9VTlNUQUJMRTogcmV0YWluZWRCeVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3RvckNhY2hlLnNldChwYXJhbXMsIG5ld1NlbGVjdG9yKTtcclxuICAgIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQzKG5ld1NlbGVjdG9yLmtleSwgKCkgPT4ge1xyXG4gICAgICBzZWxlY3RvckNhY2hlLmRlbGV0ZShwYXJhbXMpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbmV3U2VsZWN0b3I7XHJcbiAgfTtcclxufVxyXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXJlZGVjbGFyZSAqL1xyXG5cclxuXHJcbnZhciBSZWNvaWxfc2VsZWN0b3JGYW1pbHkgPSBzZWxlY3RvckZhbWlseTtcclxuXHJcbi8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXHJcblxyXG5cclxuY29uc3QgY29uc3RhbnRTZWxlY3RvciA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XHJcbiAga2V5OiAnX19jb25zdGFudCcsXHJcbiAgZ2V0OiBjb25zdGFudCA9PiAoKSA9PiBjb25zdGFudCxcclxuICBjYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRToge1xyXG4gICAgZXF1YWxpdHk6ICdyZWZlcmVuY2UnXHJcbiAgfVxyXG59KTsgLy8gRnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2VsZWN0b3Igd2hpY2ggYWx3YXlzIHByb2R1Y2VzIHRoZVxyXG4vLyBzYW1lIGNvbnN0YW50IHZhbHVlLiAgSXQgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIHRoZVxyXG4vLyBzYW1lIHZhbHVlLCBiYXNlZCBvbiByZWZlcmVuY2UgZXF1YWxpdHksIGFuZCB3aWxsIHByb3ZpZGUgdGhlXHJcbi8vIHNhbWUgc2VsZWN0b3IuXHJcblxyXG5mdW5jdGlvbiBjb25zdFNlbGVjdG9yKGNvbnN0YW50KSB7XHJcbiAgcmV0dXJuIGNvbnN0YW50U2VsZWN0b3IoY29uc3RhbnQpO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX2NvbnN0U2VsZWN0b3IgPSBjb25zdFNlbGVjdG9yO1xyXG5cclxuLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcclxuXHJcblxyXG5jb25zdCB0aHJvd2luZ1NlbGVjdG9yID0gUmVjb2lsX3NlbGVjdG9yRmFtaWx5KHtcclxuICBrZXk6ICdfX2Vycm9yJyxcclxuICBnZXQ6IG1lc3NhZ2UgPT4gKCkgPT4ge1xyXG4gICAgdGhyb3cgUmVjb2lsX2VycihtZXNzYWdlKTtcclxuICB9LFxyXG4gIC8vIFRPRE8gV2h5P1xyXG4gIGNhY2hlUG9saWN5Rm9yUGFyYW1zX1VOU1RBQkxFOiB7XHJcbiAgICBlcXVhbGl0eTogJ3JlZmVyZW5jZSdcclxuICB9XHJcbn0pOyAvLyBGdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZWxlY3RvciB3aGljaCBhbHdheXMgdGhyb3dzIGFuIGVycm9yXHJcbi8vIHdpdGggdGhlIHByb3ZpZGVkIG1lc3NhZ2UuXHJcblxyXG5mdW5jdGlvbiBlcnJvclNlbGVjdG9yKG1lc3NhZ2UpIHtcclxuICByZXR1cm4gdGhyb3dpbmdTZWxlY3RvcihtZXNzYWdlKTtcclxufVxyXG5cclxudmFyIFJlY29pbF9lcnJvclNlbGVjdG9yID0gZXJyb3JTZWxlY3RvcjtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogV3JhcHMgYW5vdGhlciByZWNvaWwgdmFsdWUgYW5kIHByZXZlbnRzIHdyaXRpbmcgdG8gaXQuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcmVhZE9ubHlTZWxlY3RvcihhdG9tKSB7XHJcbiAgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTogb2ZmXHJcbiAgcmV0dXJuIGF0b207XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfcmVhZE9ubHlTZWxlY3RvciA9IHJlYWRPbmx5U2VsZWN0b3I7XHJcblxyXG5jb25zdCB7XHJcbiAgbG9hZGFibGVXaXRoRXJyb3I6IGxvYWRhYmxlV2l0aEVycm9yJDMsXHJcbiAgbG9hZGFibGVXaXRoUHJvbWlzZTogbG9hZGFibGVXaXRoUHJvbWlzZSQzLFxyXG4gIGxvYWRhYmxlV2l0aFZhbHVlOiBsb2FkYWJsZVdpdGhWYWx1ZSQ0XHJcbn0gPSBSZWNvaWxfTG9hZGFibGUkMTtcclxuXHJcblxyXG5cclxuXHJcblxyXG4gLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gIFRSVVRIIFRBQkxFXHJcbi8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIERlcGVuZGVuY2llcyAgICAgICAgd2FpdEZvck5vbmUgICAgICAgICB3YWl0Rm9yQW55ICAgICAgICB3YWl0Rm9yQWxsICAgICAgIHdhaXRGb3JBbGxTZXR0bGVkXHJcbi8vICBbbG9hZGluZywgbG9hZGluZ10gIFtQcm9taXNlLCBQcm9taXNlXSAgUHJvbWlzZSAgICAgICAgICAgUHJvbWlzZSAgICAgICAgIFByb21pc2VcclxuLy8gIFt2YWx1ZSwgbG9hZGluZ10gICAgW3ZhbHVlLCBQcm9taXNlXSAgICBbdmFsdWUsIFByb21pc2VdICBQcm9taXNlICAgICAgICAgUHJvbWlzZVxyXG4vLyAgW3ZhbHVlLCB2YWx1ZV0gICAgICBbdmFsdWUsIHZhbHVlXSAgICAgIFt2YWx1ZSwgdmFsdWVdICAgIFt2YWx1ZSwgdmFsdWVdICBbdmFsdWUsIHZhbHVlXVxyXG4vL1xyXG4vLyAgW2Vycm9yLCBsb2FkaW5nXSAgICBbRXJyb3IsIFByb21pc2VdICAgIFtFcnJvciwgUHJvbWlzZV0gIEVycm9yICAgICAgICAgICBQcm9taXNlXHJcbi8vICBbZXJyb3IsIGVycm9yXSAgICAgIFtFcnJvciwgRXJyb3JdICAgICAgW0Vycm9yLCBFcnJvcl0gICAgRXJyb3IgICAgICAgICAgIFtlcnJvciwgZXJyb3JdXHJcbi8vICBbdmFsdWUsIGVycm9yXSAgICAgIFt2YWx1ZSwgRXJyb3JdICAgICAgW3ZhbHVlLCBFcnJvcl0gICAgRXJyb3IgICAgICAgICAgIFt2YWx1ZSwgZXJyb3JdXHJcbi8vIElzc3VlIHBhcmFsbGVsIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGFuZCByZXR1cm4gdGhlIGN1cnJlbnRcclxuLy8gc3RhdHVzIGlmIHRoZXkgaGF2ZSByZXN1bHRzLCBoYXZlIHNvbWUgZXJyb3IsIG9yIGFyZSBzdGlsbCBwZW5kaW5nLlxyXG5cclxuXHJcbmZ1bmN0aW9uIGNvbmN1cnJlbnRSZXF1ZXN0cyhnZXRSZWNvaWxWYWx1ZSwgZGVwcykge1xyXG4gIGNvbnN0IHJlc3VsdHMgPSBBcnJheShkZXBzLmxlbmd0aCkuZmlsbCh1bmRlZmluZWQpO1xyXG4gIGNvbnN0IGV4Y2VwdGlvbnMgPSBBcnJheShkZXBzLmxlbmd0aCkuZmlsbCh1bmRlZmluZWQpO1xyXG5cclxuICBmb3IgKGNvbnN0IFtpLCBkZXBdIG9mIGRlcHMuZW50cmllcygpKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXN1bHRzW2ldID0gZ2V0UmVjb2lsVmFsdWUoZGVwKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgLy8gZXhjZXB0aW9ucyBjYW4gZWl0aGVyIGJlIFByb21pc2VzIG9mIHBlbmRpbmcgcmVzdWx0cyBvciByZWFsIGVycm9yc1xyXG4gICAgICBleGNlcHRpb25zW2ldID0gZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBbcmVzdWx0cywgZXhjZXB0aW9uc107XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRXJyb3IoZXhwKSB7XHJcbiAgcmV0dXJuIGV4cCAhPSBudWxsICYmICFSZWNvaWxfaXNQcm9taXNlKGV4cCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVud3JhcERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpIHtcclxuICByZXR1cm4gQXJyYXkuaXNBcnJheShkZXBlbmRlbmNpZXMpID8gZGVwZW5kZW5jaWVzIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGVwZW5kZW5jaWVzKS5tYXAoa2V5ID0+IGRlcGVuZGVuY2llc1trZXldKTtcclxufVxyXG5cclxuZnVuY3Rpb24gd3JhcFJlc3VsdHMoZGVwZW5kZW5jaWVzLFxyXG4vKiAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdIFRoZSB0eXBlIGFubm90YXRpb24ocykgcmVxdWlyZWQgYnkgRmxvdydzXHJcbiAqIExUSSB1cGRhdGUgY291bGQgbm90IGJlIGFkZGVkIHZpYSBjb2RlbW9kICovXHJcbnJlc3VsdHMpIHtcclxuICByZXR1cm4gQXJyYXkuaXNBcnJheShkZXBlbmRlbmNpZXMpID8gcmVzdWx0cyA6IC8vIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCkgaGFzIGNvbnNpc3RlbnQga2V5IG9yZGVyaW5nIHdpdGggRVM2XHJcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGVwZW5kZW5jaWVzKS5yZWR1Y2UoKG91dCwga2V5LCBpZHgpID0+ICh7IC4uLm91dCxcclxuICAgIFtrZXldOiByZXN1bHRzW2lkeF1cclxuICB9KSwge30pO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucykge1xyXG4gIGNvbnN0IG91dHB1dCA9IGV4Y2VwdGlvbnMubWFwKChleGNlcHRpb24sIGlkeCkgPT4gZXhjZXB0aW9uID09IG51bGwgPyBsb2FkYWJsZVdpdGhWYWx1ZSQ0KHJlc3VsdHNbaWR4XSkgOiBSZWNvaWxfaXNQcm9taXNlKGV4Y2VwdGlvbikgPyBsb2FkYWJsZVdpdGhQcm9taXNlJDMoZXhjZXB0aW9uKSA6IGxvYWRhYmxlV2l0aEVycm9yJDMoZXhjZXB0aW9uKSk7XHJcbiAgcmV0dXJuIHdyYXBSZXN1bHRzKGRlcGVuZGVuY2llcywgb3V0cHV0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tYmluZUFzeW5jUmVzdWx0c1dpdGhTeW5jUmVzdWx0cyhzeW5jUmVzdWx0cywgYXN5bmNSZXN1bHRzKSB7XHJcbiAgcmV0dXJuIGFzeW5jUmVzdWx0cy5tYXAoKHJlc3VsdCwgaWR4KSA9PlxyXG4gIC8qKlxyXG4gICAqIGl0J3MgaW1wb3J0YW50IHdlIHVzZSA9PT0gdW5kZWZpbmVkIGFzIG9wcG9zZWQgdG8gPT0gbnVsbCwgYmVjYXVzZSB0aGVcclxuICAgKiByZXNvbHZlZCB2YWx1ZSBvZiB0aGUgYXN5bmMgcHJvbWlzZSBjb3VsZCBiZSBgbnVsbGAsIGluIHdoaWNoIGNhc2Ugd2VcclxuICAgKiBkb24ndCB3YW50IHRvIHVzZSBzeW5jUmVzdWx0c1tpZHhdLCB3aGljaCB3b3VsZCBiZSB1bmRlZmluZWQuIElmIGFzeW5jXHJcbiAgICogcHJvbWlzZSByZXNvbHZlcyB0byBgdW5kZWZpbmVkYCwgdGhhdCdzIG9rIGJlY2F1c2UgYHN5bmNSZXN1bHRzW2lkeF1gXHJcbiAgICogd2lsbCBhbHNvIGJlIGB1bmRlZmluZWRgLiBUaGF0J3MgYSBsaXR0bGUgaGFja3ksIGJ1dCBpdCB3b3Jrcy5cclxuICAgKi9cclxuICByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHN5bmNSZXN1bHRzW2lkeF0gOiByZXN1bHQpO1xyXG59IC8vIFNlbGVjdG9yIHRoYXQgcmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbCBhbmQgaW1tZWRpYXRlbHkgcmV0dXJuc1xyXG4vLyBjdXJyZW50IHJlc3VsdHMgd2l0aG91dCB3YWl0aW5nLlxyXG5cclxuXHJcbmNvbnN0IHdhaXRGb3JOb25lID0gUmVjb2lsX3NlbGVjdG9yRmFtaWx5KHtcclxuICBrZXk6ICdfX3dhaXRGb3JOb25lJyxcclxuICBnZXQ6IGRlcGVuZGVuY2llcyA9PiAoe1xyXG4gICAgZ2V0XHJcbiAgfSkgPT4ge1xyXG4gICAgLy8gSXNzdWUgcmVxdWVzdHMgZm9yIGFsbCBkZXBlbmRlbmNpZXMgaW4gcGFyYWxsZWwuXHJcbiAgICBjb25zdCBkZXBzID0gdW53cmFwRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XHJcbiAgICBjb25zdCBbcmVzdWx0cywgZXhjZXB0aW9uc10gPSBjb25jdXJyZW50UmVxdWVzdHMoZ2V0LCBkZXBzKTsgLy8gQWx3YXlzIHJldHVybiB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIHJlc3VsdHM7IG5ldmVyIGJsb2NrLlxyXG5cclxuICAgIHJldHVybiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucyk7XHJcbiAgfSxcclxuICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogdHJ1ZVxyXG59KTsgLy8gU2VsZWN0b3IgdGhhdCByZXF1ZXN0cyBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsIGFuZCB3YWl0cyBmb3IgYXQgbGVhc3RcclxuLy8gb25lIHRvIGJlIGF2YWlsYWJsZSBiZWZvcmUgcmV0dXJuaW5nIHJlc3VsdHMuICBJdCB3aWxsIG9ubHkgZXJyb3IgaWYgYWxsXHJcbi8vIGRlcGVuZGVuY2llcyBoYXZlIGVycm9ycy5cclxuXHJcbmNvbnN0IHdhaXRGb3JBbnkgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xyXG4gIGtleTogJ19fd2FpdEZvckFueScsXHJcbiAgZ2V0OiBkZXBlbmRlbmNpZXMgPT4gKHtcclxuICAgIGdldFxyXG4gIH0pID0+IHtcclxuICAgIC8vIElzc3VlIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsLlxyXG4gICAgLy8gRXhjZXB0aW9ucyBjYW4gZWl0aGVyIGJlIFByb21pc2VzIG9mIHBlbmRpbmcgcmVzdWx0cyBvciByZWFsIGVycm9yc1xyXG4gICAgY29uc3QgZGVwcyA9IHVud3JhcERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpO1xyXG4gICAgY29uc3QgW3Jlc3VsdHMsIGV4Y2VwdGlvbnNdID0gY29uY3VycmVudFJlcXVlc3RzKGdldCwgZGVwcyk7IC8vIElmIGFueSByZXN1bHRzIGFyZSBhdmFpbGFibGUsIHZhbHVlIG9yIGVycm9yLCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdHVzXHJcblxyXG4gICAgaWYgKGV4Y2VwdGlvbnMuc29tZShleHAgPT4gIVJlY29pbF9pc1Byb21pc2UoZXhwKSkpIHtcclxuICAgICAgcmV0dXJuIHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKTtcclxuICAgIH0gLy8gT3RoZXJ3aXNlLCByZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gdGhlIG5leHQgcmVzdWx0IGlzXHJcbiAgICAvLyBhdmFpbGFibGUsIHdoaWNoZXZlciBvbmUgaGFwcGVucyB0byBiZSBuZXh0LiAgQnV0LCBpZiBhbGwgcGVuZGluZ1xyXG4gICAgLy8gZGVwZW5kZW5jaWVzIGVuZCB1cCB3aXRoIGVycm9ycywgdGhlbiByZWplY3QgdGhlIHByb21pc2UuXHJcblxyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgZm9yIChjb25zdCBbaSwgZXhwXSBvZiBleGNlcHRpb25zLmVudHJpZXMoKSkge1xyXG4gICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKGV4cCkpIHtcclxuICAgICAgICAgIGV4cC50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHJlc3VsdHNbaV0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIGV4Y2VwdGlvbnNbaV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHJlc29sdmUod3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpKTtcclxuICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgZXhjZXB0aW9uc1tpXSA9IGVycm9yO1xyXG4gICAgICAgICAgICByZXNvbHZlKHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IHRydWVcclxufSk7IC8vIFNlbGVjdG9yIHRoYXQgcmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbCBhbmQgd2FpdHMgZm9yIGFsbCB0byBiZVxyXG4vLyBhdmFpbGFibGUgYmVmb3JlIHJldHVybmluZyBhIHZhbHVlLiAgSXQgd2lsbCBlcnJvciBpZiBhbnkgZGVwZW5kZW5jaWVzIGVycm9yLlxyXG5cclxuY29uc3Qgd2FpdEZvckFsbCA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XHJcbiAga2V5OiAnX193YWl0Rm9yQWxsJyxcclxuICBnZXQ6IGRlcGVuZGVuY2llcyA9PiAoe1xyXG4gICAgZ2V0XHJcbiAgfSkgPT4ge1xyXG4gICAgLy8gSXNzdWUgcmVxdWVzdHMgZm9yIGFsbCBkZXBlbmRlbmNpZXMgaW4gcGFyYWxsZWwuXHJcbiAgICAvLyBFeGNlcHRpb25zIGNhbiBlaXRoZXIgYmUgUHJvbWlzZXMgb2YgcGVuZGluZyByZXN1bHRzIG9yIHJlYWwgZXJyb3JzXHJcbiAgICBjb25zdCBkZXBzID0gdW53cmFwRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XHJcbiAgICBjb25zdCBbcmVzdWx0cywgZXhjZXB0aW9uc10gPSBjb25jdXJyZW50UmVxdWVzdHMoZ2V0LCBkZXBzKTsgLy8gSWYgYWxsIHJlc3VsdHMgYXJlIGF2YWlsYWJsZSwgcmV0dXJuIHRoZSByZXN1bHRzXHJcblxyXG4gICAgaWYgKGV4Y2VwdGlvbnMuZXZlcnkoZXhwID0+IGV4cCA9PSBudWxsKSkge1xyXG4gICAgICByZXR1cm4gd3JhcFJlc3VsdHMoZGVwZW5kZW5jaWVzLCByZXN1bHRzKTtcclxuICAgIH0gLy8gSWYgd2UgaGF2ZSBhbnkgZXJyb3JzLCB0aHJvdyB0aGUgZmlyc3QgZXJyb3JcclxuXHJcblxyXG4gICAgY29uc3QgZXJyb3IgPSBleGNlcHRpb25zLmZpbmQoaXNFcnJvcik7XHJcblxyXG4gICAgaWYgKGVycm9yICE9IG51bGwpIHtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9IC8vIE90aGVyd2lzZSwgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIGFsbCByZXN1bHRzIGFyZSBhdmFpbGFibGVcclxuXHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGV4Y2VwdGlvbnMpLnRoZW4oZXhjZXB0aW9uUmVzdWx0cyA9PiB3cmFwUmVzdWx0cyhkZXBlbmRlbmNpZXMsIGNvbWJpbmVBc3luY1Jlc3VsdHNXaXRoU3luY1Jlc3VsdHMocmVzdWx0cywgZXhjZXB0aW9uUmVzdWx0cykpKTtcclxuICB9LFxyXG4gIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiB0cnVlXHJcbn0pO1xyXG5jb25zdCB3YWl0Rm9yQWxsU2V0dGxlZCA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XHJcbiAga2V5OiAnX193YWl0Rm9yQWxsU2V0dGxlZCcsXHJcbiAgZ2V0OiBkZXBlbmRlbmNpZXMgPT4gKHtcclxuICAgIGdldFxyXG4gIH0pID0+IHtcclxuICAgIC8vIElzc3VlIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsLlxyXG4gICAgLy8gRXhjZXB0aW9ucyBjYW4gZWl0aGVyIGJlIFByb21pc2VzIG9mIHBlbmRpbmcgcmVzdWx0cyBvciByZWFsIGVycm9yc1xyXG4gICAgY29uc3QgZGVwcyA9IHVud3JhcERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpO1xyXG4gICAgY29uc3QgW3Jlc3VsdHMsIGV4Y2VwdGlvbnNdID0gY29uY3VycmVudFJlcXVlc3RzKGdldCwgZGVwcyk7IC8vIElmIGFsbCByZXN1bHRzIGFyZSBhdmFpbGFibGUsIHJldHVybiB0aGUgcmVzdWx0c1xyXG5cclxuICAgIGlmIChleGNlcHRpb25zLmV2ZXJ5KGV4cCA9PiAhUmVjb2lsX2lzUHJvbWlzZShleHApKSkge1xyXG4gICAgICByZXR1cm4gd3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpO1xyXG4gICAgfSAvLyBXYWl0IGZvciBhbGwgcmVzdWx0cyB0byBzZXR0bGVcclxuXHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGV4Y2VwdGlvbnMubWFwKChleHAsIGkpID0+IFJlY29pbF9pc1Byb21pc2UoZXhwKSA/IGV4cC50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgIHJlc3VsdHNbaV0gPSByZXN1bHQ7XHJcbiAgICAgIGV4Y2VwdGlvbnNbaV0gPSB1bmRlZmluZWQ7XHJcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgIHJlc3VsdHNbaV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgIGV4Y2VwdGlvbnNbaV0gPSBlcnJvcjtcclxuICAgIH0pIDogbnVsbCkpIC8vIFRoZW4gd3JhcCB0aGVtIGFzIGxvYWRhYmxlc1xyXG4gICAgLnRoZW4oKCkgPT4gd3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpKTtcclxuICB9LFxyXG4gIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiB0cnVlXHJcbn0pO1xyXG5jb25zdCBub1dhaXQgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xyXG4gIGtleTogJ19fbm9XYWl0JyxcclxuICBnZXQ6IGRlcGVuZGVuY3kgPT4gKHtcclxuICAgIGdldFxyXG4gIH0pID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBSZWNvaWxfc2VsZWN0b3IudmFsdWUobG9hZGFibGVXaXRoVmFsdWUkNChnZXQoZGVwZW5kZW5jeSkpKTtcclxuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xyXG4gICAgICByZXR1cm4gUmVjb2lsX3NlbGVjdG9yLnZhbHVlKFJlY29pbF9pc1Byb21pc2UoZXhjZXB0aW9uKSA/IGxvYWRhYmxlV2l0aFByb21pc2UkMyhleGNlcHRpb24pIDogbG9hZGFibGVXaXRoRXJyb3IkMyhleGNlcHRpb24pKTtcclxuICAgIH1cclxuICB9LFxyXG4gIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiB0cnVlXHJcbn0pO1xyXG52YXIgUmVjb2lsX1dhaXRGb3IgPSB7XHJcbiAgd2FpdEZvck5vbmUsXHJcbiAgd2FpdEZvckFueSxcclxuICB3YWl0Rm9yQWxsLFxyXG4gIHdhaXRGb3JBbGxTZXR0bGVkLFxyXG4gIG5vV2FpdFxyXG59O1xyXG5cclxuY29uc3Qge1xyXG4gIFJlY29pbExvYWRhYmxlXHJcbn0gPSBSZWNvaWxfTG9hZGFibGUkMTtcclxuXHJcbmNvbnN0IHtcclxuICBEZWZhdWx0VmFsdWU6IERlZmF1bHRWYWx1ZSQzXHJcbn0gPSBSZWNvaWxfTm9kZTtcclxuXHJcbmNvbnN0IHtcclxuICBSZWNvaWxSb290OiBSZWNvaWxSb290JDIsXHJcbiAgdXNlUmVjb2lsU3RvcmVJRDogdXNlUmVjb2lsU3RvcmVJRCQxXHJcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcclxuXHJcbmNvbnN0IHtcclxuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDVcclxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xyXG5cclxuY29uc3Qge1xyXG4gIHJldGVudGlvblpvbmU6IHJldGVudGlvblpvbmUkMVxyXG59ID0gUmVjb2lsX1JldGVudGlvblpvbmU7XHJcblxyXG5jb25zdCB7XHJcbiAgZnJlc2hTbmFwc2hvdDogZnJlc2hTbmFwc2hvdCQyXHJcbn0gPSBSZWNvaWxfU25hcHNob3QkMTtcclxuXHJcbmNvbnN0IHtcclxuICB1c2VSZWNvaWxTdGF0ZTogdXNlUmVjb2lsU3RhdGUkMSxcclxuICB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxyXG4gIHVzZVJlY29pbFN0YXRlTG9hZGFibGU6IHVzZVJlY29pbFN0YXRlTG9hZGFibGUkMSxcclxuICB1c2VSZWNvaWxWYWx1ZTogdXNlUmVjb2lsVmFsdWUkMSxcclxuICB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxyXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGU6IHVzZVJlY29pbFZhbHVlTG9hZGFibGUkMSxcclxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSxcclxuICB1c2VSZXNldFJlY29pbFN0YXRlOiB1c2VSZXNldFJlY29pbFN0YXRlJDEsXHJcbiAgdXNlU2V0UmVjb2lsU3RhdGU6IHVzZVNldFJlY29pbFN0YXRlJDFcclxufSA9IFJlY29pbF9Ib29rcztcclxuXHJcbmNvbnN0IHtcclxuICB1c2VHb3RvUmVjb2lsU25hcHNob3Q6IHVzZUdvdG9SZWNvaWxTbmFwc2hvdCQxLFxyXG4gIHVzZVJlY29pbFNuYXBzaG90OiB1c2VSZWNvaWxTbmFwc2hvdCQxLFxyXG4gIHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXI6IHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXIkMVxyXG59ID0gUmVjb2lsX1NuYXBzaG90SG9va3M7XHJcblxyXG5cclxuXHJcblxyXG5cclxuY29uc3Qge1xyXG4gIHVzZVJlY29pbENhbGxiYWNrOiB1c2VSZWNvaWxDYWxsYmFjayQxXHJcbn0gPSBSZWNvaWxfdXNlUmVjb2lsQ2FsbGJhY2s7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IHtcclxuICBub1dhaXQ6IG5vV2FpdCQxLFxyXG4gIHdhaXRGb3JBbGw6IHdhaXRGb3JBbGwkMSxcclxuICB3YWl0Rm9yQWxsU2V0dGxlZDogd2FpdEZvckFsbFNldHRsZWQkMSxcclxuICB3YWl0Rm9yQW55OiB3YWl0Rm9yQW55JDEsXHJcbiAgd2FpdEZvck5vbmU6IHdhaXRGb3JOb25lJDFcclxufSA9IFJlY29pbF9XYWl0Rm9yO1xyXG5cclxudmFyIFJlY29pbF9pbmRleCA9IHtcclxuICAvLyBUeXBlc1xyXG4gIERlZmF1bHRWYWx1ZTogRGVmYXVsdFZhbHVlJDMsXHJcbiAgaXNSZWNvaWxWYWx1ZTogaXNSZWNvaWxWYWx1ZSQ1LFxyXG4gIFJlY29pbExvYWRhYmxlLFxyXG4gIC8vIFJlY29pbCBSb290XHJcbiAgUmVjb2lsUm9vdDogUmVjb2lsUm9vdCQyLFxyXG4gIHVzZVJlY29pbFN0b3JlSUQ6IHVzZVJlY29pbFN0b3JlSUQkMSxcclxuICB1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzX1VOU1RBQkxFOiBSZWNvaWxfdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cyxcclxuICAvLyBBdG9tcy9TZWxlY3RvcnNcclxuICBhdG9tOiBSZWNvaWxfYXRvbSxcclxuICBzZWxlY3RvcjogUmVjb2lsX3NlbGVjdG9yLFxyXG4gIC8vIENvbnZlbmllbmNlIEF0b21zL1NlbGVjdG9yc1xyXG4gIGF0b21GYW1pbHk6IFJlY29pbF9hdG9tRmFtaWx5LFxyXG4gIHNlbGVjdG9yRmFtaWx5OiBSZWNvaWxfc2VsZWN0b3JGYW1pbHksXHJcbiAgY29uc3RTZWxlY3RvcjogUmVjb2lsX2NvbnN0U2VsZWN0b3IsXHJcbiAgZXJyb3JTZWxlY3RvcjogUmVjb2lsX2Vycm9yU2VsZWN0b3IsXHJcbiAgcmVhZE9ubHlTZWxlY3RvcjogUmVjb2lsX3JlYWRPbmx5U2VsZWN0b3IsXHJcbiAgLy8gQ29uY3VycmVuY3kgSGVscGVycyBmb3IgQXRvbXMvU2VsZWN0b3JzXHJcbiAgbm9XYWl0OiBub1dhaXQkMSxcclxuICB3YWl0Rm9yTm9uZTogd2FpdEZvck5vbmUkMSxcclxuICB3YWl0Rm9yQW55OiB3YWl0Rm9yQW55JDEsXHJcbiAgd2FpdEZvckFsbDogd2FpdEZvckFsbCQxLFxyXG4gIHdhaXRGb3JBbGxTZXR0bGVkOiB3YWl0Rm9yQWxsU2V0dGxlZCQxLFxyXG4gIC8vIEhvb2tzIGZvciBBdG9tcy9TZWxlY3RvcnNcclxuICB1c2VSZWNvaWxWYWx1ZTogdXNlUmVjb2lsVmFsdWUkMSxcclxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlJDEsXHJcbiAgdXNlUmVjb2lsU3RhdGU6IHVzZVJlY29pbFN0YXRlJDEsXHJcbiAgdXNlUmVjb2lsU3RhdGVMb2FkYWJsZTogdXNlUmVjb2lsU3RhdGVMb2FkYWJsZSQxLFxyXG4gIHVzZVNldFJlY29pbFN0YXRlOiB1c2VTZXRSZWNvaWxTdGF0ZSQxLFxyXG4gIHVzZVJlc2V0UmVjb2lsU3RhdGU6IHVzZVJlc2V0UmVjb2lsU3RhdGUkMSxcclxuICB1c2VHZXRSZWNvaWxWYWx1ZUluZm9fVU5TVEFCTEU6IFJlY29pbF91c2VHZXRSZWNvaWxWYWx1ZUluZm8sXHJcbiAgdXNlUmVjb2lsUmVmcmVzaGVyX1VOU1RBQkxFOiBSZWNvaWxfdXNlUmVjb2lsUmVmcmVzaGVyLFxyXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxyXG4gIHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTogdXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEsXHJcbiAgdXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFOiB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSxcclxuICAvLyBIb29rcyBmb3IgY29tcGxleCBvcGVyYXRpb25zXHJcbiAgdXNlUmVjb2lsQ2FsbGJhY2s6IHVzZVJlY29pbENhbGxiYWNrJDEsXHJcbiAgdXNlUmVjb2lsVHJhbnNhY3Rpb25fVU5TVEFCTEU6IFJlY29pbF91c2VSZWNvaWxUcmFuc2FjdGlvbixcclxuICAvLyBTbmFwc2hvdHNcclxuICB1c2VHb3RvUmVjb2lsU25hcHNob3Q6IHVzZUdvdG9SZWNvaWxTbmFwc2hvdCQxLFxyXG4gIHVzZVJlY29pbFNuYXBzaG90OiB1c2VSZWNvaWxTbmFwc2hvdCQxLFxyXG4gIHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXJfVU5TVEFCTEU6IHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXIkMSxcclxuICBzbmFwc2hvdF9VTlNUQUJMRTogZnJlc2hTbmFwc2hvdCQyLFxyXG4gIC8vIE1lbW9yeSBNYW5hZ2VtZW50XHJcbiAgdXNlUmV0YWluOiBSZWNvaWxfdXNlUmV0YWluLFxyXG4gIHJldGVudGlvblpvbmU6IHJldGVudGlvblpvbmUkMVxyXG59O1xyXG52YXIgUmVjb2lsX2luZGV4XzEgPSBSZWNvaWxfaW5kZXguRGVmYXVsdFZhbHVlO1xyXG52YXIgUmVjb2lsX2luZGV4XzIgPSBSZWNvaWxfaW5kZXguaXNSZWNvaWxWYWx1ZTtcclxudmFyIFJlY29pbF9pbmRleF8zID0gUmVjb2lsX2luZGV4LlJlY29pbExvYWRhYmxlO1xyXG52YXIgUmVjb2lsX2luZGV4XzQgPSBSZWNvaWxfaW5kZXguUmVjb2lsUm9vdDtcclxudmFyIFJlY29pbF9pbmRleF81ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFN0b3JlSUQ7XHJcbnZhciBSZWNvaWxfaW5kZXhfNiA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzX1VOU1RBQkxFO1xyXG52YXIgUmVjb2lsX2luZGV4XzcgPSBSZWNvaWxfaW5kZXguYXRvbTtcclxudmFyIFJlY29pbF9pbmRleF84ID0gUmVjb2lsX2luZGV4LnNlbGVjdG9yO1xyXG52YXIgUmVjb2lsX2luZGV4XzkgPSBSZWNvaWxfaW5kZXguYXRvbUZhbWlseTtcclxudmFyIFJlY29pbF9pbmRleF8xMCA9IFJlY29pbF9pbmRleC5zZWxlY3RvckZhbWlseTtcclxudmFyIFJlY29pbF9pbmRleF8xMSA9IFJlY29pbF9pbmRleC5jb25zdFNlbGVjdG9yO1xyXG52YXIgUmVjb2lsX2luZGV4XzEyID0gUmVjb2lsX2luZGV4LmVycm9yU2VsZWN0b3I7XHJcbnZhciBSZWNvaWxfaW5kZXhfMTMgPSBSZWNvaWxfaW5kZXgucmVhZE9ubHlTZWxlY3RvcjtcclxudmFyIFJlY29pbF9pbmRleF8xNCA9IFJlY29pbF9pbmRleC5ub1dhaXQ7XHJcbnZhciBSZWNvaWxfaW5kZXhfMTUgPSBSZWNvaWxfaW5kZXgud2FpdEZvck5vbmU7XHJcbnZhciBSZWNvaWxfaW5kZXhfMTYgPSBSZWNvaWxfaW5kZXgud2FpdEZvckFueTtcclxudmFyIFJlY29pbF9pbmRleF8xNyA9IFJlY29pbF9pbmRleC53YWl0Rm9yQWxsO1xyXG52YXIgUmVjb2lsX2luZGV4XzE4ID0gUmVjb2lsX2luZGV4LndhaXRGb3JBbGxTZXR0bGVkO1xyXG52YXIgUmVjb2lsX2luZGV4XzE5ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFZhbHVlO1xyXG52YXIgUmVjb2lsX2luZGV4XzIwID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFZhbHVlTG9hZGFibGU7XHJcbnZhciBSZWNvaWxfaW5kZXhfMjEgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU3RhdGU7XHJcbnZhciBSZWNvaWxfaW5kZXhfMjIgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU3RhdGVMb2FkYWJsZTtcclxudmFyIFJlY29pbF9pbmRleF8yMyA9IFJlY29pbF9pbmRleC51c2VTZXRSZWNvaWxTdGF0ZTtcclxudmFyIFJlY29pbF9pbmRleF8yNCA9IFJlY29pbF9pbmRleC51c2VSZXNldFJlY29pbFN0YXRlO1xyXG52YXIgUmVjb2lsX2luZGV4XzI1ID0gUmVjb2lsX2luZGV4LnVzZUdldFJlY29pbFZhbHVlSW5mb19VTlNUQUJMRTtcclxudmFyIFJlY29pbF9pbmRleF8yNiA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxSZWZyZXNoZXJfVU5TVEFCTEU7XHJcbnZhciBSZWNvaWxfaW5kZXhfMjcgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU7XHJcbnZhciBSZWNvaWxfaW5kZXhfMjggPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFO1xyXG52YXIgUmVjb2lsX2luZGV4XzI5ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTtcclxudmFyIFJlY29pbF9pbmRleF8zMCA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxDYWxsYmFjaztcclxudmFyIFJlY29pbF9pbmRleF8zMSA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxUcmFuc2FjdGlvbl9VTlNUQUJMRTtcclxudmFyIFJlY29pbF9pbmRleF8zMiA9IFJlY29pbF9pbmRleC51c2VHb3RvUmVjb2lsU25hcHNob3Q7XHJcbnZhciBSZWNvaWxfaW5kZXhfMzMgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU25hcHNob3Q7XHJcbnZhciBSZWNvaWxfaW5kZXhfMzQgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlcl9VTlNUQUJMRTtcclxudmFyIFJlY29pbF9pbmRleF8zNSA9IFJlY29pbF9pbmRleC5zbmFwc2hvdF9VTlNUQUJMRTtcclxudmFyIFJlY29pbF9pbmRleF8zNiA9IFJlY29pbF9pbmRleC51c2VSZXRhaW47XHJcbnZhciBSZWNvaWxfaW5kZXhfMzcgPSBSZWNvaWxfaW5kZXgucmV0ZW50aW9uWm9uZTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJlY29pbF9pbmRleDtcclxuZXhwb3J0IHsgUmVjb2lsX2luZGV4XzEgYXMgRGVmYXVsdFZhbHVlLCBSZWNvaWxfaW5kZXhfMyBhcyBSZWNvaWxMb2FkYWJsZSwgUmVjb2lsX2luZGV4XzQgYXMgUmVjb2lsUm9vdCwgUmVjb2lsX2luZGV4XzcgYXMgYXRvbSwgUmVjb2lsX2luZGV4XzkgYXMgYXRvbUZhbWlseSwgUmVjb2lsX2luZGV4XzExIGFzIGNvbnN0U2VsZWN0b3IsIFJlY29pbF9pbmRleF8xMiBhcyBlcnJvclNlbGVjdG9yLCBSZWNvaWxfaW5kZXhfMiBhcyBpc1JlY29pbFZhbHVlLCBSZWNvaWxfaW5kZXhfMTQgYXMgbm9XYWl0LCBSZWNvaWxfaW5kZXhfMTMgYXMgcmVhZE9ubHlTZWxlY3RvciwgUmVjb2lsX2luZGV4XzM3IGFzIHJldGVudGlvblpvbmUsIFJlY29pbF9pbmRleF84IGFzIHNlbGVjdG9yLCBSZWNvaWxfaW5kZXhfMTAgYXMgc2VsZWN0b3JGYW1pbHksIFJlY29pbF9pbmRleF8zNSBhcyBzbmFwc2hvdF9VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzI1IGFzIHVzZUdldFJlY29pbFZhbHVlSW5mb19VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzMyIGFzIHVzZUdvdG9SZWNvaWxTbmFwc2hvdCwgUmVjb2lsX2luZGV4XzYgYXMgdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290c19VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzMwIGFzIHVzZVJlY29pbENhbGxiYWNrLCBSZWNvaWxfaW5kZXhfMjYgYXMgdXNlUmVjb2lsUmVmcmVzaGVyX1VOU1RBQkxFLCBSZWNvaWxfaW5kZXhfMzMgYXMgdXNlUmVjb2lsU25hcHNob3QsIFJlY29pbF9pbmRleF8yMSBhcyB1c2VSZWNvaWxTdGF0ZSwgUmVjb2lsX2luZGV4XzIyIGFzIHVzZVJlY29pbFN0YXRlTG9hZGFibGUsIFJlY29pbF9pbmRleF8yOSBhcyB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUsIFJlY29pbF9pbmRleF81IGFzIHVzZVJlY29pbFN0b3JlSUQsIFJlY29pbF9pbmRleF8zNCBhcyB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyX1VOU1RBQkxFLCBSZWNvaWxfaW5kZXhfMzEgYXMgdXNlUmVjb2lsVHJhbnNhY3Rpb25fVU5TVEFCTEUsIFJlY29pbF9pbmRleF8xOSBhcyB1c2VSZWNvaWxWYWx1ZSwgUmVjb2lsX2luZGV4XzIwIGFzIHVzZVJlY29pbFZhbHVlTG9hZGFibGUsIFJlY29pbF9pbmRleF8yNyBhcyB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzI4IGFzIHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzI0IGFzIHVzZVJlc2V0UmVjb2lsU3RhdGUsIFJlY29pbF9pbmRleF8zNiBhcyB1c2VSZXRhaW4sIFJlY29pbF9pbmRleF8yMyBhcyB1c2VTZXRSZWNvaWxTdGF0ZSwgUmVjb2lsX2luZGV4XzE3IGFzIHdhaXRGb3JBbGwsIFJlY29pbF9pbmRleF8xOCBhcyB3YWl0Rm9yQWxsU2V0dGxlZCwgUmVjb2lsX2luZGV4XzE2IGFzIHdhaXRGb3JBbnksIFJlY29pbF9pbmRleF8xNSBhcyB3YWl0Rm9yTm9uZSB9O1xyXG4iXSwibmFtZXMiOlsicmVhY3QiLCJyZWFjdERvbSIsImVyciIsIm1lc3NhZ2UiLCJlcnJvciIsIkVycm9yIiwic3RhY2siLCJ1bmRlZmluZWQiLCJfIiwiZXJyXzEiLCJSZWNvaWxfZXJyIiwiaXNQcm9taXNlIiwicCIsInRoZW4iLCJSZWNvaWxfaXNQcm9taXNlIiwibnVsbHRocm93cyIsIngiLCJSZWNvaWxfbnVsbHRocm93cyIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJCYXNlTG9hZGFibGUiLCJnZXRWYWx1ZSIsInRvUHJvbWlzZSIsInZhbHVlTWF5YmUiLCJ2YWx1ZU9yVGhyb3ciLCJzdGF0ZSIsInByb21pc2VNYXliZSIsInByb21pc2VPclRocm93IiwiZXJyb3JNYXliZSIsImVycm9yT3JUaHJvdyIsImlzIiwib3RoZXIiLCJjb250ZW50cyIsIm1hcCIsIl9tYXAiLCJWYWx1ZUxvYWRhYmxlIiwiY29uc3RydWN0b3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm5leHQiLCJsb2FkYWJsZVdpdGhQcm9taXNlIiwiaXNMb2FkYWJsZSIsImxvYWRhYmxlV2l0aFZhbHVlIiwiZSIsImxvYWRhYmxlV2l0aEVycm9yIiwiRXJyb3JMb2FkYWJsZSIsInJlamVjdCIsIkxvYWRpbmdMb2FkYWJsZSIsInByb21pc2UiLCJuZXh0TG9hZGFibGUiLCJjYXRjaCIsImZyZWV6ZSIsImxvYWRhYmxlTG9hZGluZyIsImxvYWRhYmxlQWxsQXJyYXkiLCJpbnB1dHMiLCJldmVyeSIsImkiLCJzb21lIiwiZmluZCIsImFsbCIsImxvYWRhYmxlQWxsIiwidW53cmFwZWRJbnB1dHMiLCJBcnJheSIsImlzQXJyYXkiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwibm9ybWFsaXplZElucHV0cyIsIm91dHB1dCIsIm91dHB1dHMiLCJyZWR1Y2UiLCJvdXQiLCJpZHgiLCJMb2FkYWJsZVN0YXRpY0ludGVyZmFjZSIsIm9mIiwibG9hZGluZyIsIlJlY29pbF9Mb2FkYWJsZSIsIlJlY29pbExvYWRhYmxlIiwiUmVjb2lsX0xvYWRhYmxlXzEiLCJSZWNvaWxfTG9hZGFibGVfMiIsIlJlY29pbF9Mb2FkYWJsZV8zIiwiUmVjb2lsX0xvYWRhYmxlXzQiLCJSZWNvaWxfTG9hZGFibGVfNSIsIlJlY29pbF9Mb2FkYWJsZV82IiwiUmVjb2lsX0xvYWRhYmxlXzciLCJSZWNvaWxfTG9hZGFibGUkMSIsIl9fcHJvdG9fXyIsImdrcyIsIk1hcCIsInNldCIsIlJlY29pbF9na3hfT1NTIiwiZ2siLCJfZ2tzJGdldCIsImdldCIsInNldFBhc3MiLCJzZXRGYWlsIiwiY2xlYXIiLCJSZWNvaWxfZ2t4IiwiX2NyZWF0ZU11dGFibGVTb3VyY2UiLCJfdXNlTXV0YWJsZVNvdXJjZSIsIl91c2VTeW5jRXh0ZXJuYWxTdG9yZSIsImNyZWF0ZU11dGFibGVTb3VyY2UiLCJ1bnN0YWJsZV9jcmVhdGVNdXRhYmxlU291cmNlIiwidXNlTXV0YWJsZVNvdXJjZSIsInVuc3RhYmxlX3VzZU11dGFibGVTb3VyY2UiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVuc3RhYmxlX3VzZVN5bmNFeHRlcm5hbFN0b3JlIiwicmVhY3RNb2RlIiwibW9kZSIsImVhcmx5IiwiY29uY3VycmVudCIsIndpbmRvdyIsIiRkaXNhYmxlUmVjb2lsVmFsdWVNdXRhYmxlU291cmNlX1RFTVBfSEFDS19ET19OT1RfVVNFIiwiaXNGYXN0UmVmcmVzaEVuYWJsZWQiLCJSZWNvaWxfUmVhY3RNb2RlIiwiQWJzdHJhY3RSZWNvaWxWYWx1ZSIsIm5ld0tleSIsInRvSlNPTiIsIlJlY29pbFN0YXRlIiwiUmVjb2lsVmFsdWVSZWFkT25seSIsImlzUmVjb2lsVmFsdWUiLCJSZWNvaWxfUmVjb2lsVmFsdWUiLCJSZWNvaWxfUmVjb2lsVmFsdWVfMSIsIlJlY29pbF9SZWNvaWxWYWx1ZV8yIiwiUmVjb2lsX1JlY29pbFZhbHVlXzMiLCJSZWNvaWxfUmVjb2lsVmFsdWVfNCIsIlJlY29pbF9SZWNvaWxWYWx1ZSQxIiwic3ByaW50ZiIsImZvcm1hdCIsImFyZ3MiLCJpbmRleCIsInJlcGxhY2UiLCJTdHJpbmciLCJzcHJpbnRmXzEiLCJleHBlY3RhdGlvblZpb2xhdGlvbiIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImNhbGwiLCJuYW1lIiwiY29uc29sZSIsImV4cGVjdGF0aW9uVmlvbGF0aW9uXzEiLCJSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24iLCJtYXBJdGVyYWJsZSIsIml0ZXJhYmxlIiwiY2FsbGJhY2siLCJSZWNvaWxfbWFwSXRlcmFibGUiLCJyZWNvdmVyYWJsZVZpb2xhdGlvbiIsIl9wcm9qZWN0TmFtZSIsInJlY292ZXJhYmxlVmlvbGF0aW9uXzEiLCJSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24iLCJpc0Zhc3RSZWZyZXNoRW5hYmxlZCQxIiwiRGVmYXVsdFZhbHVlIiwiREVGQVVMVF9WQUxVRSIsIm5vZGVzIiwicmVjb2lsVmFsdWVzIiwicmVjb2lsVmFsdWVzRm9yS2V5cyIsImtleXMiLCJyZWdpc3Rlck5vZGUiLCJub2RlIiwiaGFzIiwid2FybiIsInJlY29pbFZhbHVlIiwiTm9kZU1pc3NpbmdFcnJvciIsImdldE5vZGUiLCJnZXROb2RlTWF5YmUiLCJjb25maWdEZWxldGlvbkhhbmRsZXJzIiwiZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGUiLCJfbm9kZSRzaG91bGREZWxldGVDb24iLCJzaG91bGREZWxldGVDb25maWdPblJlbGVhc2UiLCJfZ2V0Q29uZmlnRGVsZXRpb25IYW4iLCJkZWxldGUiLCJnZXRDb25maWdEZWxldGlvbkhhbmRsZXIiLCJzZXRDb25maWdEZWxldGlvbkhhbmRsZXIiLCJmbiIsIlJlY29pbF9Ob2RlIiwiZW5xdWV1ZUV4ZWN1dGlvbiIsInMiLCJmIiwiUmVjb2lsX1F1ZXVlIiwiY3JlYXRlQ29tbW9uanNNb2R1bGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiaGFtdF8xIiwiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiaGFtdCIsIlNJWkUiLCJCVUNLRVRfU0laRSIsIk1hdGgiLCJwb3ciLCJNQVNLIiwiTUFYX0lOREVYX05PREUiLCJNSU5fQVJSQVlfTk9ERSIsIm5vdGhpbmciLCJjb25zdGFudCIsImhhc2giLCJzdHIiLCJ0eXBlIiwibGVuIiwibGVuZ3RoIiwiYyIsImNoYXJDb2RlQXQiLCJwb3Bjb3VudCIsImhhc2hGcmFnbWVudCIsInNoaWZ0IiwiaCIsInRvQml0bWFwIiwiZnJvbUJpdG1hcCIsImJpdG1hcCIsImJpdCIsImFycmF5VXBkYXRlIiwibXV0YXRlIiwiYXQiLCJ2IiwiYXJyIiwiYXJyYXlTcGxpY2VPdXQiLCJuZXdMZW4iLCJnIiwiYXJyYXlTcGxpY2VJbiIsIl9pIiwiTEVBRiIsIkNPTExJU0lPTiIsIklOREVYIiwiQVJSQVkiLCJlbXB0eSIsIl9faGFtdF9pc0VtcHR5IiwiaXNFbXB0eU5vZGUiLCJMZWFmIiwiZWRpdCIsIl9tb2RpZnkiLCJMZWFmX19tb2RpZnkiLCJDb2xsaXNpb24iLCJjaGlsZHJlbiIsIkNvbGxpc2lvbl9fbW9kaWZ5IiwiSW5kZXhlZE5vZGUiLCJtYXNrIiwiSW5kZXhlZE5vZGVfX21vZGlmeSIsIkFycmF5Tm9kZSIsInNpemUiLCJBcnJheU5vZGVfX21vZGlmeSIsImlzTGVhZiIsImV4cGFuZCIsImZyYWciLCJjaGlsZCIsInN1Yk5vZGVzIiwiY291bnQiLCJwYWNrIiwicmVtb3ZlZCIsImVsZW1lbnRzIiwiZWxlbSIsIm1lcmdlTGVhdmVzIiwiaDEiLCJuMSIsImgyIiwibjIiLCJzdWJIMSIsInN1YkgyIiwidXBkYXRlQ29sbGlzaW9uTGlzdCIsImtleUVxIiwibGlzdCIsImsiLCJfbmV3VmFsdWUiLCJuZXdWYWx1ZSIsImNhbkVkaXROb2RlIiwiX3YiLCJjYW5FZGl0IiwiaW5keCIsImV4aXN0cyIsImN1cnJlbnQiLCJuZXdDaGlsZHJlbiIsIm5ld0NoaWxkIiwiZWRpdGFibGUiLCJjb25maWciLCJyb290IiwiX2VkaXRhYmxlIiwiX2VkaXQiLCJfY29uZmlnIiwiX3Jvb3QiLCJfc2l6ZSIsInNldFRyZWUiLCJuZXdSb290IiwibmV3U2l6ZSIsInRyeUdldEhhc2giLCJhbHQiLCJ0cnlHZXQiLCJnZXRIYXNoIiwiaGFzSGFzaCIsImRlZktleUNvbXBhcmUiLCJ5IiwibWFrZSIsImlzRW1wdHkiLCJtb2RpZnlIYXNoIiwiTmFOIiwibW9kaWZ5Iiwic2V0SGFzaCIsImRlbCIsInJlbW92ZUhhc2giLCJkZWxldGVIYXNoIiwicmVtb3ZlIiwiYmVnaW5NdXRhdGlvbiIsImVuZE11dGF0aW9uIiwidHJhbnNpZW50IiwiYXBwayIsImxhenlWaXNpdENoaWxkcmVuIiwibGF6eVZpc2l0IiwicmVzdCIsIkRPTkUiLCJkb25lIiwiTWFwSXRlcmF0b3IiLCJ2MCIsInZpc2l0IiwiYnVpbGRQYWlycyIsImVudHJpZXMiLCJidWlsZEtleXMiLCJidWlsZFZhbHVlcyIsInZhbHVlcyIsImZvbGQiLCJ6IiwibSIsInRvVmlzaXQiLCJwb3AiLCJwdXNoIiwiZm9yRWFjaCIsIkJ1aWx0SW5NYXAiLCJleGlzdGluZyIsImNsb25lIiwicGVyc2lzdGVudE1hcCIsInRvTWFwIiwiSGFzaEFycmF5TWFwcGVkVHJpZU1hcCIsIl9oYW10IiwiUmVjb2lsX1BlcnNpc3RlbnRNYXAiLCJSZWNvaWxfUGVyc2lzdGVudE1hcF8xIiwiUmVjb2lsX1BlcnNpc3RlbnRNYXAkMSIsImRpZmZlcmVuY2VTZXRzIiwic2V0c1dpdGhWYWx1ZXNUb1JlbW92ZSIsInJldCIsIlNldCIsIkZJUlNUIiwib3RoZXJTZXQiLCJhZGQiLCJSZWNvaWxfZGlmZmVyZW5jZVNldHMiLCJtYXBNYXAiLCJyZXN1bHQiLCJSZWNvaWxfbWFwTWFwIiwibWFrZUdyYXBoIiwibm9kZURlcHMiLCJub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucyIsImNsb25lR3JhcGgiLCJncmFwaCIsIm1lcmdlRGVwc0ludG9HcmFwaCIsIm5ld0RlcHMiLCJvbGRlckdyYXBoIiwib2xkRGVwcyIsImFkZGVkRGVwcyIsImRlcCIsInJlbW92ZWREZXBzIiwic2F2ZURlcHNUb1N0b3JlIiwiZGVwcyIsInN0b3JlIiwidmVyc2lvbiIsIl9zdG9yZVN0YXRlJG5leHRUcmVlIiwiX3N0b3JlU3RhdGUkcHJldmlvdXNUIiwiX3N0b3JlU3RhdGUkcHJldmlvdXNUMiIsIl9zdG9yZVN0YXRlJHByZXZpb3VzVDMiLCJzdG9yZVN0YXRlIiwiZ2V0U3RhdGUiLCJjdXJyZW50VHJlZSIsIm5leHRUcmVlIiwicHJldmlvdXNUcmVlIiwiZ2V0R3JhcGgiLCJjdXJyZW50R3JhcGgiLCJfc3RvcmVTdGF0ZSRuZXh0VHJlZTIiLCJuZXh0VmVyc2lvbiIsIm5leHRHcmFwaCIsIlJlY29pbF9HcmFwaCIsIm5leHRUcmVlU3RhdGVWZXJzaW9uIiwiZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24iLCJuZXh0U3RvcmVJRCIsImdldE5leHRTdG9yZUlEIiwibmV4dENvbXBvbmVudElEIiwiZ2V0TmV4dENvbXBvbmVudElEIiwiUmVjb2lsX0tleXMiLCJwZXJzaXN0ZW50TWFwJDEiLCJnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQxIiwibWFrZUVtcHR5VHJlZVN0YXRlIiwic3RhdGVJRCIsInRyYW5zYWN0aW9uTWV0YWRhdGEiLCJkaXJ0eUF0b21zIiwiYXRvbVZhbHVlcyIsIm5vbnZhbGlkYXRlZEF0b21zIiwibWFrZUVtcHR5U3RvcmVTdGF0ZSIsImNvbW1pdERlcHRoIiwia25vd25BdG9tcyIsImtub3duU2VsZWN0b3JzIiwidHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zIiwibm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucyIsIm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMiLCJxdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRCIsInN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVycyIsImdyYXBoc0J5VmVyc2lvbiIsInJldGVudGlvbiIsInJlZmVyZW5jZUNvdW50cyIsIm5vZGVzUmV0YWluZWRCeVpvbmUiLCJyZXRhaW5hYmxlc1RvQ2hlY2tGb3JSZWxlYXNlIiwibm9kZUNsZWFudXBGdW5jdGlvbnMiLCJSZWNvaWxfU3RhdGUiLCJSZXRlbnRpb25ab25lIiwicmV0ZW50aW9uWm9uZSIsIlJlY29pbF9SZXRlbnRpb25ab25lIiwic2V0QnlBZGRpbmdUb1NldCIsInNldEJ5RGVsZXRpbmdGcm9tU2V0IiwibWFwQnlTZXR0aW5nSW5NYXAiLCJtYXBCeVVwZGF0aW5nSW5NYXAiLCJ1cGRhdGVyIiwibWFwQnlEZWxldGluZ0Zyb21NYXAiLCJtYXBCeURlbGV0aW5nTXVsdGlwbGVGcm9tTWFwIiwia3MiLCJSZWNvaWxfQ29weU9uV3JpdGUiLCJmaWx0ZXJJdGVyYWJsZSIsInByZWRpY2F0ZSIsIlJlY29pbF9maWx0ZXJJdGVyYWJsZSIsImxhenlQcm94eSIsImJhc2UiLCJmYWN0b3JpZXMiLCJwcm94eSIsIlByb3h5IiwidGFyZ2V0IiwicHJvcCIsIm93bktleXMiLCJSZWNvaWxfbGF6eVByb3h5IiwiZ2V0Tm9kZSQxIiwiZ2V0Tm9kZU1heWJlJDEiLCJyZWNvaWxWYWx1ZXNGb3JLZXlzJDEiLCJSZXRlbnRpb25ab25lJDEiLCJzZXRCeUFkZGluZ1RvU2V0JDEiLCJlbXB0eVNldCIsIlJlYWRPbmx5UmVjb2lsVmFsdWVFcnJvciIsImluaXRpYWxpemVSZXRlbnRpb25Gb3JOb2RlIiwibm9kZUtleSIsInJldGFpbmVkQnkiLCJhZGRUb1pvbmUiLCJ6b25lIiwiZGVsZXRlRnJvbVpvbmUiLCJpbml0aWFsaXplTm9kZUlmTmV3VG9TdG9yZSIsInRyZWVTdGF0ZSIsInRyaWdnZXIiLCJyZXRlbnRpb25DbGVhbnVwIiwibm9kZUNsZWFudXAiLCJpbml0IiwiaW5pdGlhbGl6ZU5vZGUiLCJjbGVhblVwTm9kZSIsIl9zdGF0ZSRub2RlQ2xlYW51cEZ1biIsImdldE5vZGVMb2FkYWJsZSIsInBlZWtOb2RlTG9hZGFibGUiLCJwZWVrIiwic2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCIsIl9ub2RlJGludmFsaWRhdGUiLCJpbnZhbGlkYXRlIiwic2V0Tm9kZVZhbHVlIiwicGVla05vZGVJbmZvIiwibm9kZVR5cGUiLCJsb2FkYWJsZSIsImlzQWN0aXZlIiwiaXNTZXQiLCJpc01vZGlmaWVkIiwiX2dyYXBoJG5vZGVEZXBzJGdldCIsInN1YnNjcmliZXJzIiwiX3N0b3JlU3RhdGUkbm9kZVRvQ29tIiwiX3N0b3JlU3RhdGUkbm9kZVRvQ29tMiIsImdldERvd25zdHJlYW1Ob2RlcyIsImNvbXBvbmVudHMiLCJ2aXNpdGVkTm9kZXMiLCJ2aXNpdGluZ05vZGVzIiwiZnJvbSIsIl9ncmFwaCRub2RlVG9Ob2RlU3VicyIsInN1YnNjcmliZWROb2RlcyIsImRvd25zdHJlYW1Ob2RlIiwiUmVjb2lsX0Z1bmN0aW9uYWxDb3JlIiwiX2ludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90Iiwic2V0SW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QiLCJpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCIsIl9pbnZhbGlkYXRlTWVtb2l6ZWRTbiIsIlJlY29pbF9TbmFwc2hvdENhY2hlIiwiZ2V0RG93bnN0cmVhbU5vZGVzJDEiLCJnZXROb2RlTG9hZGFibGUkMSIsInNldE5vZGVWYWx1ZSQxIiwiZ2V0TmV4dENvbXBvbmVudElEJDEiLCJnZXROb2RlJDIiLCJnZXROb2RlTWF5YmUkMiIsIkRlZmF1bHRWYWx1ZSQxIiwicmVhY3RNb2RlJDEiLCJBYnN0cmFjdFJlY29pbFZhbHVlJDEiLCJSZWNvaWxTdGF0ZSQxIiwiUmVjb2lsVmFsdWVSZWFkT25seSQxIiwiaXNSZWNvaWxWYWx1ZSQxIiwiaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMSIsImdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSIsImFwcGx5QXRvbVZhbHVlV3JpdGVzIiwid3JpdGVzIiwidmFsdWVGcm9tVmFsdWVPclVwZGF0ZXIiLCJ2YWx1ZU9yVXBkYXRlciIsIm1zZyIsImFwcGx5QWN0aW9uIiwiYWN0aW9uIiwid3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlIiwidW52YWxpZGF0ZWRWYWx1ZSIsImFwcGx5QWN0aW9uc1RvU3RvcmUiLCJhY3Rpb25zIiwicmVwbGFjZVN0YXRlIiwibmV3U3RhdGUiLCJjb3B5VHJlZVN0YXRlIiwiaW52YWxpZGF0ZURvd25zdHJlYW1zIiwicXVldWVPclBlcmZvcm1TdGF0ZVVwZGF0ZSIsImJhdGNoU3RhY2siLCJhY3Rpb25zQnlTdG9yZSIsImJhdGNoU3RhcnQiLCJwb3BwZWQiLCJkb3duc3RyZWFtcyIsIl9nZXROb2RlTWF5YmUiLCJfZ2V0Tm9kZU1heWJlJGludmFsaWQiLCJzZXRSZWNvaWxWYWx1ZSIsInNldFJlY29pbFZhbHVlTG9hZGFibGUiLCJtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCIsInNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUiLCJzdWJzY3JpYmVUb1JlY29pbFZhbHVlIiwiY29tcG9uZW50RGVidWdOYW1lIiwic3ViSUQiLCJyZWxlYXNlIiwicmVsZWFzZVN0b3JlU3RhdGUiLCJzdWJzIiwicmVmcmVzaFJlY29pbFZhbHVlIiwiX25vZGUkY2xlYXJDYWNoZSIsImNsZWFyQ2FjaGUiLCJSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2UiLCJzb21lU2V0IiwiY29udGV4dCIsImVudHJ5IiwiUmVjb2lsX3NvbWVTZXQiLCJjbGVhblVwTm9kZSQxIiwiZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGUkMSIsImdldE5vZGUkMyIsIlJldGVudGlvblpvbmUkMiIsIlNVU1BFTlNFX1RJTUVPVVRfTVMiLCJlbXB0eVNldCQxIiwicmVsZWFzZVJldGFpbmFibGVzTm93T25DdXJyZW50VHJlZSIsInJldGFpbmFibGVzIiwiciIsIm4iLCJyZWxlYXNhYmxlTm9kZXMiLCJmaW5kUmVsZWFzYWJsZU5vZGVzIiwicmVsZWFzZU5vZGUiLCJzZWFyY2hGcm9tTm9kZXMiLCJub25SZWxlYXNhYmxlTm9kZXMiLCJmaW5kUmVsZWFzYWJsZU5vZGVzSW5uZXIiLCJyZWxlYXNhYmxlTm9kZXNGb3VuZFRoaXNJdGVyYXRpb24iLCJnZXREb3duc3RyZWFtTm9kZXNJblRvcG9sb2dpY2FsT3JkZXIiLCJfc3RvcmVTdGF0ZSRyZXRlbnRpb24iLCJ6b25lc1RoYXRDb3VsZFJldGFpbk5vZGUiLCJub2RlQ2hpbGRyZW4iLCJwYXJlbnRzIiwicGFyZW50IiwiZG9Ob3REZXNjZW5kSW50bzEiLCJkb05vdERlc2NlbmRJbnRvMiIsImFuc3dlciIsInZpc2l0ZWQiLCJ6b25lcyIsIl9zdG9yZVN0YXRlJHJldGVudGlvbjIiLCJfc3RvcmVTdGF0ZSRyZXRlbnRpb24zIiwic2NoZWR1bGVPclBlcmZvcm1Qb3NzaWJsZVJlbGVhc2VPZlJldGFpbmFibGUiLCJyZXRhaW5hYmxlIiwidXBkYXRlUmV0YWluQ291bnQiLCJkZWx0YSIsIl9tYXAkZ2V0IiwibmV3Q291bnQiLCJ1cGRhdGVSZXRhaW5Db3VudFRvWmVybyIsInJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdyIsInJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCIsIlJlY29pbF9SZXRlbnRpb24iLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsIlJlYWN0QmF0Y2hlZFVwZGF0ZXMiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQxIiwiUmVjb2lsX1JlYWN0QmF0Y2hlZFVwZGF0ZXMiLCJiYXRjaFN0YXJ0JDEiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQyIiwiYmF0Y2hlciIsInNldEJhdGNoZXIiLCJuZXdCYXRjaGVyIiwiZ2V0QmF0Y2hlciIsImJhdGNoVXBkYXRlcyIsImJhdGNoRW5kIiwiUmVjb2lsX0JhdGNoaW5nIiwiY29uY2F0SXRlcmFibGVzIiwiaXRlcnMiLCJpdGVyIiwidmFsIiwiUmVjb2lsX2NvbmNhdEl0ZXJhYmxlcyIsImlzU1NSIiwiV2luZG93IiwiaXNXaW5kb3ciLCJpc1JlYWN0TmF0aXZlIiwibmF2aWdhdG9yIiwicHJvZHVjdCIsIlJlY29pbF9FbnZpcm9ubWVudCIsIm1lbW9pemVXaXRoQXJnc0hhc2giLCJoYXNoRnVuY3Rpb24iLCJjYWNoZSIsIm1lbW9pemVkRm4iLCJoYXNPd25Qcm9wZXJ0eSIsIm1lbW9pemVPbmVXaXRoQXJnc0hhc2giLCJsYXN0S2V5IiwibGFzdFJlc3VsdCIsIm1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb24iLCJSZWNvaWxfTWVtb2l6ZSIsImJhdGNoVXBkYXRlcyQxIiwiaW5pdGlhbGl6ZU5vZGUkMSIsInBlZWtOb2RlSW5mbyQxIiwiZ3JhcGgkMSIsImdldE5leHRTdG9yZUlEJDEiLCJERUZBVUxUX1ZBTFVFJDEiLCJyZWNvaWxWYWx1ZXMkMSIsInJlY29pbFZhbHVlc0ZvcktleXMkMiIsIkFic3RyYWN0UmVjb2lsVmFsdWUkMiIsImdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQxIiwic2V0UmVjb2lsVmFsdWUkMSIsInNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMSIsInVwZGF0ZVJldGFpbkNvdW50JDEiLCJzZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQxIiwiZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMiIsIm1ha2VFbXB0eVN0b3JlU3RhdGUkMSIsImlzU1NSJDEiLCJtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uJDEiLCJyZXRhaW5XYXJuaW5nIiwiU25hcHNob3QiLCJwYXJlbnRTdG9yZUlEIiwiY2hlY2tSZWZDb3VudF9JTlRFUk5BTCIsIl9zdG9yZSIsImdldExvYWRhYmxlIiwib3B0IiwiaXNJbml0aWFsaXplZCIsIm1hcHBlciIsIm11dGFibGVTbmFwc2hvdCIsIk11dGFibGVTbmFwc2hvdCIsInJldGFpbiIsImF1dG9SZWxlYXNlX0lOVEVSTkFMIiwic3RvcmVJRCIsInJlcGxhY2VyIiwiZ3JhcGhzIiwibmV3R3JhcGgiLCJzdWJzY3JpYmVUb1RyYW5zYWN0aW9ucyIsImFkZFRyYW5zYWN0aW9uTWV0YWRhdGEiLCJfcmVmQ291bnQiLCJyZWxlYXNlZCIsIl9yZWxlYXNlIiwic2V0VGltZW91dCIsImNsZWFudXAiLCJpc1JldGFpbmVkIiwiZ2V0U3RvcmVfSU5URVJOQUwiLCJnZXRJRCIsImdldFN0b3JlSUQiLCJjbG9uZVN0b3JlU3RhdGUiLCJidW1wVmVyc2lvbiIsImZyZXNoU25hcHNob3QiLCJpbml0aWFsaXplU3RhdGUiLCJzbmFwc2hvdCIsIm1lbW9pemVkQ2xvbmVTbmFwc2hvdCIsImludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDIiLCJfc3RvcmUkZ2V0U3RhdGUkbmV4dFQiLCJfc3RvcmUkZ2V0U3RhdGUkcHJldmkiLCJjbG9uZVNuYXBzaG90IiwiYmF0Y2giLCJyZWNvaWxTdGF0ZSIsIm5ld1ZhbHVlT3JVcGRhdGVyIiwiX2JhdGNoIiwiUmVjb2lsX1NuYXBzaG90IiwiUmVjb2lsX1NuYXBzaG90XzEiLCJSZWNvaWxfU25hcHNob3RfMiIsIlJlY29pbF9TbmFwc2hvdF8zIiwiUmVjb2lsX1NuYXBzaG90XzQiLCJSZWNvaWxfU25hcHNob3QkMSIsInVuaW9uU2V0cyIsInNldHMiLCJSZWNvaWxfdW5pb25TZXRzIiwidXNlUmVmIiwidXNlUmVmSW5pdE9uY2UiLCJpbml0aWFsVmFsdWUiLCJyZWYiLCJSZWNvaWxfdXNlUmVmSW5pdE9uY2UiLCJnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQzIiwibWFrZUVtcHR5U3RvcmVTdGF0ZSQyIiwiY2xlYW5VcE5vZGUkMiIsImdldERvd25zdHJlYW1Ob2RlcyQyIiwiaW5pdGlhbGl6ZU5vZGUkMiIsInNldE5vZGVWYWx1ZSQyIiwic2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCQxIiwiZ3JhcGgkMiIsImNsb25lR3JhcGgkMSIsImdldE5leHRTdG9yZUlEJDIiLCJjcmVhdGVNdXRhYmxlU291cmNlJDEiLCJyZWFjdE1vZGUkMiIsImFwcGx5QXRvbVZhbHVlV3JpdGVzJDEiLCJyZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3ckMSIsImZyZXNoU25hcHNob3QkMSIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYkMSIsInVzZVN0YXRlIiwibm90SW5BQ29udGV4dCIsImRlZmF1bHRTdG9yZSIsInN0YXRlUmVwbGFjZXJJc0JlaW5nRXhlY3V0ZWQiLCJzdGFydE5leHRUcmVlSWZOZWVkZWQiLCJBcHBDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInVzZVN0b3JlUmVmIiwiTXV0YWJsZVNvdXJjZUNvbnRleHQiLCJ1c2VSZWNvaWxNdXRhYmxlU291cmNlIiwibXV0YWJsZVNvdXJjZSIsIm5vdGlmeUNvbXBvbmVudHMiLCJkZXBlbmRlbnROb2RlcyIsImNvbXBzIiwiX3N1YklEIiwiX2RlYnVnTmFtZSIsInNlbmRFbmRPZkJhdGNoTm90aWZpY2F0aW9ucyIsInN1YnNjcmlwdGlvbnMiLCJzdWJzY3JpcHRpb24iLCJjYiIsInNwbGljZSIsImVuZEJhdGNoIiwiQmF0Y2hlciIsInNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZSIsInN0b3JlUmVmIiwic2V0U3RhdGUiLCIkcmVjb2lsRGVidWdTdGF0ZXMiLCJpbml0aWFsU3RvcmVTdGF0ZV9ERVBSRUNBVEVEIiwiaW5pdGlhbCIsImF0b20iLCJ3cml0dGVuTm9kZXMiLCJzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMiLCJpbml0aWFsU3RvcmVTdGF0ZSIsIm5leHRJRCIsIlJlY29pbFJvb3RfSU5URVJOQUwiLCJpbml0aWFsaXplU3RhdGVfREVQUkVDQVRFRCIsInN0b3JlX0lOVEVSTkFMIiwic3RvcmVQcm9wIiwic3RvcmVTdGF0ZVJlZiIsImlkIiwibWV0YWRhdGEiLCJyZXBsYWNlZCIsIm5vdGlmeUJhdGNoZXJPZkNoYW5nZSIsImF0b21LZXkiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJSZWNvaWxSb290IiwicHJvcHMiLCJvdmVycmlkZSIsInByb3BzRXhjZXB0T3ZlcnJpZGUiLCJhbmNlc3RvclN0b3JlUmVmIiwidXNlUmVjb2lsU3RvcmVJRCIsIlJlY29pbF9SZWNvaWxSb290Iiwibm90aWZ5Q29tcG9uZW50c19GT1JfVEVTVElORyIsInNlbmRFbmRPZkJhdGNoTm90aWZpY2F0aW9uc19GT1JfVEVTVElORyIsInNoYWxsb3dBcnJheUVxdWFsIiwiYSIsImIiLCJsIiwiUmVjb2lsX3NoYWxsb3dBcnJheUVxdWFsIiwidXNlRWZmZWN0JDEiLCJ1c2VSZWYkMiIsInVzZVByZXZpb3VzIiwiUmVjb2lsX3VzZVByZXZpb3VzIiwidXNlU3RvcmVSZWYkMSIsIlNVU1BFTlNFX1RJTUVPVVRfTVMkMSIsInVwZGF0ZVJldGFpbkNvdW50JDIiLCJSZXRlbnRpb25ab25lJDMiLCJ1c2VFZmZlY3QkMiIsInVzZVJlZiQzIiwiaXNTU1IkMiIsInVzZVJldGFpbiIsInRvUmV0YWluIiwidXNlUmV0YWluX0FDVFVBTCIsImFycmF5IiwidGltZW91dElEIiwiY2xlYXJUaW1lb3V0IiwicHJldmlvdXNSZXRhaW5hYmxlcyIsIlJlY29pbF91c2VSZXRhaW4iLCJ1c2VDb21wb25lbnROYW1lIiwiUmVjb2lsX3VzZUNvbXBvbmVudE5hbWUiLCJiYXRjaFVwZGF0ZXMkMiIsIkRFRkFVTFRfVkFMVUUkMiIsInJlYWN0TW9kZSQzIiwidXNlTXV0YWJsZVNvdXJjZSQxIiwidXNlU3luY0V4dGVybmFsU3RvcmUkMSIsInVzZVJlY29pbE11dGFibGVTb3VyY2UkMSIsInVzZVN0b3JlUmVmJDIiLCJpc1JlY29pbFZhbHVlJDIiLCJBYnN0cmFjdFJlY29pbFZhbHVlJDMiLCJnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMiIsInNldFJlY29pbFZhbHVlJDIiLCJzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlJDIiLCJzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEiLCJ1c2VDYWxsYmFjayQxIiwidXNlRWZmZWN0JDMiLCJ1c2VNZW1vJDEiLCJ1c2VSZWYkNCIsInVzZVN0YXRlJDEiLCJzZXRCeUFkZGluZ1RvU2V0JDIiLCJoYW5kbGVMb2FkYWJsZSIsInZhbGlkYXRlUmVjb2lsVmFsdWUiLCJob29rTmFtZSIsInVzZVJlY29pbEludGVyZmFjZV9ERVBSRUNBVEVEIiwiY29tcG9uZW50TmFtZSIsImZvcmNlVXBkYXRlIiwicmVjb2lsVmFsdWVzVXNlZCIsInByZXZpb3VzU3Vic2NyaXB0aW9ucyIsInVuc3Vic2NyaWJlRnJvbSIsInN1YiIsInVwZGF0ZVN0YXRlIiwiX3N0YXRlIiwiY3VycmVudFN1YnNjcmlwdGlvbnMiLCJ1c2VTZXRSZWNvaWxTdGF0ZSIsInVzZVJlc2V0UmVjb2lsU3RhdGUiLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlIiwidXNlUmVjb2lsVmFsdWUiLCJ1c2VSZWNvaWxTdGF0ZSIsInVzZVJlY29pbFN0YXRlTG9hZGFibGUiLCJnZXRSZWNvaWxWYWx1ZSIsImdldFJlY29pbFZhbHVlTG9hZGFibGUiLCJnZXRSZWNvaWxTdGF0ZSIsImdldFJlY29pbFN0YXRlTG9hZGFibGUiLCJnZXRTZXRSZWNvaWxTdGF0ZSIsImdldFJlc2V0UmVjb2lsU3RhdGUiLCJyZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HIiwidXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9TWU5DX0VYVEVSTkFMX1NUT1JFIiwiZ2V0U25hcHNob3QiLCJtZW1vaXplUHJldmlvdXNTbmFwc2hvdCIsInByZXZTdGF0ZSIsIl9wcmV2U3RhdGUiLCJfcHJldlN0YXRlMiIsIm5leHRTdGF0ZSIsImdldE1lbW9pemVkU25hcHNob3QiLCJzdWJzY3JpYmUiLCJub3RpZnkiLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX01VVEFCTEVfU09VUkNFIiwiX3N0b3JlU3RhdGUkbmV4dFRyZWUzIiwiZ2V0TG9hZGFibGVXaXRoVGVzdGluZyIsIl9zdG9yZVN0YXRlIiwibmV3TG9hZGFibGUiLCJwcmV2TG9hZGFibGVSZWYiLCJzb3VyY2UiLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVCIsIl9zdG9yZVN0YXRlJG5leHRUcmVlNCIsInVzZVJlY29pbFZhbHVlTG9hZGFibGVfTEVHQUNZIiwiX3N0b3JlU3RhdGUkbmV4dFRyZWU1IiwiX3ByZXZMb2FkYWJsZVJlZiRjdXJyIiwiX3ByZXZMb2FkYWJsZVJlZiRjdXJyMiIsIlRSQU5TSVRJT05fU1VQUE9SVCIsIlNZTkNfRVhURVJOQUxfU1RPUkUiLCJNVVRBQkxFX1NPVVJDRSIsIkxFR0FDWSIsInVzZVNldFVudmFsaWRhdGVkQXRvbVZhbHVlcyIsInVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFIiwidXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFIiwidXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFIiwiUmVjb2lsX0hvb2tzIiwidXNlUmVjb2lsSW50ZXJmYWNlIiwiZmlsdGVyTWFwIiwiUmVjb2lsX2ZpbHRlck1hcCIsImZpbHRlclNldCIsIlJlY29pbF9maWx0ZXJTZXQiLCJtZXJnZU1hcHMiLCJtYXBzIiwibmV4dEtleSIsIlJlY29pbF9tZXJnZU1hcHMiLCJiYXRjaFVwZGF0ZXMkMyIsIkRFRkFVTFRfVkFMVUUkMyIsImdldE5vZGUkNCIsIm5vZGVzJDEiLCJ1c2VTdG9yZVJlZiQzIiwiQWJzdHJhY3RSZWNvaWxWYWx1ZSQ0Iiwic2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQxIiwiU1VTUEVOU0VfVElNRU9VVF9NUyQyIiwiY2xvbmVTbmFwc2hvdCQxIiwidXNlQ2FsbGJhY2skMiIsInVzZUVmZmVjdCQ0IiwidXNlUmVmJDUiLCJ1c2VTdGF0ZSQyIiwiaXNTU1IkMyIsInVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uIiwiZXh0ZXJuYWxseVZpc2libGVBdG9tVmFsdWVzSW5TdGF0ZSIsInBlcnNpc3RlZEF0b21Db250ZW50c1ZhbHVlcyIsInBlcnNpc3RlbmNlIiwicGVyc2lzdGVuY2VfVU5TVEFCTEUiLCJ1c2VUcmFuc2FjdGlvbk9ic2VydmF0aW9uX0RFUFJFQ0FURUQiLCJwcmV2aW91c0F0b21WYWx1ZXMiLCJhdG9tSW5mbyIsIl9ub2RlJHBlcnNpc3RlbmNlX1VOUyIsIl9ub2RlJHBlcnNpc3RlbmNlX1VOUzIiLCJfbm9kZSRwZXJzaXN0ZW5jZV9VTlMzIiwiX25vZGUkcGVyc2lzdGVuY2VfVU5TNCIsImJhY2tCdXR0b24iLCJtb2RpZmllZEF0b21zIiwidXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlciIsInByZXZpb3VzU25hcHNob3QiLCJ1c2VSZWNvaWxTbmFwc2hvdCIsInNldFNuYXBzaG90IiwicmVsZWFzZVJlZiIsIl9yZWxlYXNlUmVmJGN1cnJlbnQiLCJfcmVsZWFzZVJlZiRjdXJyZW50MiIsIl9yZWxlYXNlUmVmJGN1cnJlbnQzIiwiZ290b1NuYXBzaG90IiwicHJldiIsImtleXNUb1VwZGF0ZSIsIl9wcmV2JGF0b21WYWx1ZXMkZ2V0IiwiX25leHQkYXRvbVZhbHVlcyRnZXQiLCJzaG91bGRSZXN0b3JlRnJvbVNuYXBzaG90cyIsInVzZUdvdG9SZWNvaWxTbmFwc2hvdCIsIlJlY29pbF9TbmFwc2hvdEhvb2tzIiwidXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25fREVQUkVDQVRFRCIsInBlZWtOb2RlSW5mbyQyIiwidXNlU3RvcmVSZWYkNCIsInVzZUdldFJlY29pbFZhbHVlSW5mbyIsIlJlY29pbF91c2VHZXRSZWNvaWxWYWx1ZUluZm8iLCJyZWFjdE1vZGUkNCIsIlJlY29pbFJvb3QkMSIsInVzZVN0b3JlUmVmJDUiLCJ1c2VNZW1vJDIiLCJ1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzIiwiUmVjb2lsQnJpZGdlIiwiUmVjb2lsX3VzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHMiLCJsb2FkYWJsZVdpdGhWYWx1ZSQxIiwiaW5pdGlhbGl6ZU5vZGUkMyIsIkRFRkFVTFRfVkFMVUUkNCIsImdldE5vZGUkNSIsImNvcHlUcmVlU3RhdGUkMSIsImdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQzIiwiaW52YWxpZGF0ZURvd25zdHJlYW1zJDEiLCJ3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUkMSIsImlzQXRvbSIsIlRyYW5zYWN0aW9uSW50ZXJmYWNlSW1wbCIsIl9jaGFuZ2VzIiwiX3RyZWVTdGF0ZSIsIm5ld1RyZWVTdGF0ZV9JTlRFUk5BTCIsImF0b21pY1VwZGF0ZXIiLCJjaGFuZ2VzZXQiLCJSZWNvaWxfQXRvbWljVXBkYXRlcyIsIlJlY29pbF9BdG9taWNVcGRhdGVzXzEiLCJSZWNvaWxfQXRvbWljVXBkYXRlcyQxIiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwiaW52YXJpYW50XzEiLCJSZWNvaWxfaW52YXJpYW50IiwiYXRvbWljVXBkYXRlciQxIiwiYmF0Y2hVcGRhdGVzJDQiLCJERUZBVUxUX1ZBTFVFJDUiLCJ1c2VTdG9yZVJlZiQ2IiwicmVmcmVzaFJlY29pbFZhbHVlJDEiLCJzZXRSZWNvaWxWYWx1ZSQzIiwiY2xvbmVTbmFwc2hvdCQyIiwiZ290b1NuYXBzaG90JDEiLCJ1c2VDYWxsYmFjayQzIiwiU2VudGluZWwiLCJTRU5USU5FTCIsInJlY29pbENhbGxiYWNrIiwiZXh0cmFJbnRlcmZhY2UiLCJyZWxlYXNlU25hcHNob3QiLCJlcnJNc2ciLCJjYWxsYmFja0ludGVyZmFjZSIsInJlc2V0IiwicmVmcmVzaCIsInRyYW5zYWN0X1VOU1RBQkxFIiwidHJhbnNhY3Rpb24iLCJmaW5hbGx5IiwiX3JlbGVhc2VTbmFwc2hvdCIsIl9yZWxlYXNlU25hcHNob3QyIiwidXNlUmVjb2lsQ2FsbGJhY2siLCJSZWNvaWxfdXNlUmVjb2lsQ2FsbGJhY2siLCJ1c2VTdG9yZVJlZiQ3IiwicmVmcmVzaFJlY29pbFZhbHVlJDIiLCJ1c2VDYWxsYmFjayQ0IiwidXNlUmVjb2lsUmVmcmVzaGVyIiwiUmVjb2lsX3VzZVJlY29pbFJlZnJlc2hlciIsImF0b21pY1VwZGF0ZXIkMiIsInVzZVN0b3JlUmVmJDgiLCJ1c2VNZW1vJDMiLCJ1c2VSZWNvaWxUcmFuc2FjdGlvbiIsImF0b21pY1VwZGF0ZSIsInRyYW5zYWN0aW9uSW50ZXJmYWNlIiwiUmVjb2lsX3VzZVJlY29pbFRyYW5zYWN0aW9uIiwiV3JhcHBlZFZhbHVlIiwiUmVjb2lsX1dyYXBwZXIiLCJSZWNvaWxfV3JhcHBlcl8xIiwiUmVjb2lsX1dyYXBwZXIkMSIsImlzRmFzdFJlZnJlc2hFbmFibGVkJDIiLCJDaGFuZ2VkUGF0aEVycm9yIiwiVHJlZUNhY2hlIiwib3B0aW9ucyIsIl9vcHRpb25zJG9uSGl0IiwiX29wdGlvbnMkb25TZXQiLCJfb3B0aW9ucyRtYXBOb2RlVmFsdWUiLCJfbmFtZSIsIl9udW1MZWFmcyIsIl9vbkhpdCIsIm9uSGl0IiwiX29uU2V0Iiwib25TZXQiLCJfbWFwTm9kZVZhbHVlIiwibWFwTm9kZVZhbHVlIiwiZ2V0Tm9kZVZhbHVlIiwiaGFuZGxlcnMiLCJfdGhpcyRnZXRMZWFmTm9kZSIsImdldExlYWZOb2RlIiwib25Ob2RlVmlzaXQiLCJub2RlVmFsdWUiLCJicmFuY2hlcyIsInJvdXRlIiwiYWRkTGVhZiIsIl9ub2RlMiIsIl9ub2RlMyIsIl90aGlzJF9yb290MiIsIl9oYW5kbGVycyRvbk5vZGVWaXNpdDIiLCJicmFuY2hLZXkiLCJfbm9kZSIsIl9oYW5kbGVycyRvbk5vZGVWaXNpdCIsIl90aGlzJF9yb290IiwiaW52YWxpZENhY2hlRXJyb3IiLCJvbGRMZWFmIiwibGVhZk5vZGUiLCJsZWFmIiwiX25vZGU0IiwiQ0hBTkdFRF9QQVRIX0VSUk9SX01FU1NBR0UiLCJSZWNvaWxfVHJlZUNhY2hlIiwiUmVjb2lsX1RyZWVDYWNoZV8xIiwiUmVjb2lsX1RyZWVDYWNoZSQxIiwiTFJVQ2FjaGUiLCJfb3B0aW9ucyRtYXBLZXkiLCJfbWF4U2l6ZSIsIm1heFNpemUiLCJfaGVhZCIsIl90YWlsIiwiX2tleU1hcHBlciIsIm1hcEtleSIsImhlYWQiLCJ0YWlsIiwibWFwcGVkS2V5IiwiZXhpc3RpbmdOb2RlIiwicmlnaHQiLCJsZWZ0IiwiX21heWJlRGVsZXRlTFJVIiwiZGVsZXRlTHJ1IiwiUmVjb2lsX0xSVUNhY2hlIiwiUmVjb2lsX0xSVUNhY2hlXzEiLCJSZWNvaWxfTFJVQ2FjaGUkMSIsIkxSVUNhY2hlJDEiLCJUcmVlQ2FjaGUkMSIsInRyZWVDYWNoZUxSVSIsImxydUNhY2hlIiwibHJ1Tm9kZSIsIlJlY29pbF90cmVlQ2FjaGVMUlUiLCJUSU1FX1dBUk5JTkdfVEhSRVNIT0xEX01TIiwic3RyaW5naWZ5IiwiaW5jbHVkZXMiLCJKU09OIiwiYWxsb3dGdW5jdGlvbnMiLCJfSlNPTiRzdHJpbmdpZnkiLCJ0b1N0cmluZyIsInNvcnQiLCJsb2NhbGVDb21wYXJlIiwiZmlsdGVyIiwiam9pbiIsInN0YWJsZVN0cmluZ2lmeSIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZW5kVGltZSIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJSZWNvaWxfc3RhYmxlU3RyaW5naWZ5IiwiVHJlZUNhY2hlJDIiLCJkZWZhdWx0UG9saWN5IiwiZXF1YWxpdHkiLCJldmljdGlvbiIsIkluZmluaXR5IiwidHJlZUNhY2hlRnJvbVBvbGljeSIsInZhbHVlTWFwcGVyIiwiZ2V0VmFsdWVNYXBwZXIiLCJnZXRUcmVlQ2FjaGUiLCJSZWNvaWxfdHJlZUNhY2hlRnJvbVBvbGljeSIsImlzTm9kZSIsIm9iamVjdCIsIl9vd25lckRvY3VtZW50IiwiX2RvYyRkZWZhdWx0VmlldyIsImRvYyIsIm93bmVyRG9jdW1lbnQiLCJkb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiTm9kZSIsIm5vZGVOYW1lIiwiUmVjb2lsX2lzTm9kZSIsImlzUmVhY3ROYXRpdmUkMSIsImlzV2luZG93JDEiLCJzaG91bGROb3RCZUZyb3plbiIsIiQkdHlwZW9mIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJkZWVwRnJlZXplVmFsdWUiLCJpc0Zyb3plbiIsInNlYWwiLCJSZWNvaWxfZGVlcEZyZWV6ZVZhbHVlIiwic3RhcnRQZXJmQmxvY2siLCJfaWQiLCJSZWNvaWxfUGVyZm9ybWFuY2VUaW1pbmdzIiwiaXNMb2FkYWJsZSQxIiwibG9hZGFibGVXaXRoRXJyb3IkMSIsImxvYWRhYmxlV2l0aFByb21pc2UkMSIsImxvYWRhYmxlV2l0aFZhbHVlJDIiLCJXcmFwcGVkVmFsdWUkMSIsImdldE5vZGVMb2FkYWJsZSQyIiwicGVla05vZGVMb2FkYWJsZSQxIiwic2V0Tm9kZVZhbHVlJDMiLCJzYXZlRGVwc1RvU3RvcmUkMSIsIkRFRkFVTFRfVkFMVUUkNiIsImdldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQxIiwiZ2V0Tm9kZSQ2IiwicmVnaXN0ZXJOb2RlJDEiLCJpc1JlY29pbFZhbHVlJDMiLCJtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQxIiwicmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0JDEiLCJyZWNvaWxDYWxsYmFjayQxIiwic3RhcnRQZXJmQmxvY2skMSIsIkNhbmNlbGVkIiwiQ0FOQ0VMRUQiLCJkZXBlbmRlbmN5U3RhY2siLCJ3YWl0aW5nU3RvcmVzIiwiZ2V0TmV3RXhlY3V0aW9uSUQiLCJleGVjdXRpb25JRCIsInNlbGVjdG9yIiwiY2FjaGVQb2xpY3lfVU5TVEFCTEUiLCJjYWNoZVBvbGljeSIsImRpc2NvdmVyZWREZXBlbmRlbmN5Tm9kZUtleXMiLCJyZXRhaW5lZEJ5X1VOU1RBQkxFIiwiZXhlY3V0aW9uSW5mb01hcCIsImxpdmVTdG9yZXNDb3VudCIsInNlbGVjdG9ySXNMaXZlIiwic2VsZWN0b3JJbml0Iiwic2VsZWN0b3JTaG91bGREZWxldGVDb25maWdPblJlbGVhc2UiLCJyZXNvbHZlQXN5bmMiLCJkZXBWYWx1ZXMiLCJzZXRDYWNoZSIsIm5vdGlmeVN0b3Jlc09mUmVzb2x2ZWRBc3luYyIsImlzTGF0ZXN0RXhlY3V0aW9uIiwiY2xlYXJFeGVjdXRpb25JbmZvIiwibm90aWZ5V2FpdGluZ1N0b3JlcyIsIm5vdGlmeVN0b3Jlc09mTmV3QXN5bmNEZXAiLCJleGVjdXRpb25JbmZvIiwiZ2V0RXhlY3V0aW9uSW5mbyIsInN0YXRlVmVyc2lvbnMiLCJjbGVhcldhaXRsaXN0Iiwic3RvcmVzIiwid2FpdGluZ1N0b3JlIiwibWFya1N0b3JlV2FpdGluZ0ZvclJlc29sdmVkQXN5bmMiLCJ3cmFwUmVzdWx0UHJvbWlzZSIsImxvYWRpbmdEZXBzU3RhdGUiLCJlcnJvck9yUHJvbWlzZSIsIndyYXBQZW5kaW5nRGVwZW5kZW5jeVByb21pc2UiLCJleGlzdGluZ0RlcHMiLCJyZXNvbHZlZERlcCIsImxvYWRpbmdEZXBLZXkiLCJsb2FkaW5nRGVwUHJvbWlzZSIsImNhY2hlZExvYWRhYmxlIiwiZ2V0TG9hZGFibGVGcm9tQ2FjaGVBbmRVcGRhdGVEZXBzIiwiZ2V0SW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8iLCJsb2FkaW5nTG9hZGFibGUiLCJldmFsdWF0ZVNlbGVjdG9yR2V0dGVyIiwidXBkYXRlRGVwcyIsIl9zdG9yZSRnZXRTdGF0ZSIsIl9zdG9yZSRnZXRTdGF0ZSRjdXJyZSIsIl9zdG9yZSRnZXRTdGF0ZTIiLCJfc3RvcmUkZ2V0U3RhdGUyJG5leHQiLCJfc3RvcmUkZ2V0U3RhdGUzIiwiX3N0b3JlJGdldFN0YXRlMyRuZXh0IiwiZW5kUGVyZkJsb2NrIiwiZHVyaW5nU3luY2hyb25vdXNFeGVjdXRpb24iLCJkdXJpbmdBc3luY2hyb25vdXNFeGVjdXRpb24iLCJmaW5pc2hFdmFsdWF0aW9uIiwicmVzdWx0SXNFcnJvciIsImRlcEtleSIsImRlcExvYWRhYmxlIiwiZ2V0Q2FsbGJhY2siLCJlcnJvck9yRGVwUHJvbWlzZSIsInVwZGF0ZUV4ZWN1dGlvbkluZm9EZXBWYWx1ZXMiLCJkZXBzQWZ0ZXJDYWNoZUxvb2t1cCIsIl9nZXRFeGVjdXRpb25JbmZvIiwiZ2V0U2VsZWN0b3JMb2FkYWJsZUFuZFVwZGF0ZURlcHMiLCJjYWNoZWRWYWwiLCJpblByb2dyZXNzRXhlY3V0aW9uSW5mbyIsIl9pblByb2dyZXNzRXhlY3V0aW9uSSIsIm5ld0V4ZWN1dGlvbklEIiwibmV3RGVwVmFsdWVzIiwic2V0RXhlY3V0aW9uSW5mbyIsInBlbmRpbmdFeGVjdXRpb25zIiwiZXhlY0luZm8iLCJhbnlEZXBDaGFuZ2VkIiwiZXhlY0RlcFZhbHVlcyIsImV4ZWNMb2FkYWJsZSIsImRlcFZhbHVlc0Rpc2NvdmVyZWRTb0ZhckR1cmluZ0FzeW5jV29yayIsIl9nZXRFeGVjdXRpb25JbmZvMiIsImRlcFZhbHVlc1RvRGVwUm91dGUiLCJ2YWxMb2FkYWJsZSIsIkJvb2xlYW4iLCJkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSIsImRldGVjdENpcmN1bGFyRGVwZW5kZW5jaWVzIiwic2xpY2UiLCJpbmRleE9mIiwic2VsZWN0b3JQZWVrIiwiX3BlZWtOb2RlTG9hZGFibGUiLCJzZWxlY3RvckdldCIsImludmFsaWRhdGVTZWxlY3RvciIsImNsZWFyU2VsZWN0b3JDYWNoZSIsInNlbGVjdG9yU2V0Iiwic3luY1NlbGVjdG9yU2V0RmluaXNoZWQiLCJzZXRSZWNvaWxTdGF0ZSIsInNldFZhbHVlIiwidXBzdHJlYW1Xcml0ZXMiLCJyZXNldFJlY29pbFN0YXRlIiwiUmVjb2lsX3NlbGVjdG9yIiwiaXNMb2FkYWJsZSQyIiwibG9hZGFibGVXaXRoRXJyb3IkMiIsImxvYWRhYmxlV2l0aFByb21pc2UkMiIsImxvYWRhYmxlV2l0aFZhbHVlJDMiLCJXcmFwcGVkVmFsdWUkMiIsInBlZWtOb2RlSW5mbyQzIiwiREVGQVVMVF9WQUxVRSQ3IiwiRGVmYXVsdFZhbHVlJDIiLCJnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMiIsInJlZ2lzdGVyTm9kZSQyIiwic2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDEiLCJpc1JlY29pbFZhbHVlJDQiLCJnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkNCIsIm1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDIiLCJzZXRSZWNvaWxWYWx1ZSQ0Iiwic2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQyIiwicmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0JDIiLCJ1bndyYXAiLCJiYXNlQXRvbSIsInVud3JhcFByb21pc2UiLCJkZWZhdWx0TG9hZGFibGUiLCJkZWZhdWx0IiwibWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZSIsImNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWUiLCJjbGVhbnVwRWZmZWN0c0J5U3RvcmUiLCJ2YWx1ZU9yUHJvbWlzZSIsIndyYXBQZW5kaW5nUHJvbWlzZSIsIndyYXBwZWRQcm9taXNlIiwiX3N0YXRlJGF0b21WYWx1ZXMkZ2V0IiwiX3N0b3JlJGdldFN0YXRlJG5leHRUMiIsIl9zdGF0ZSRhdG9tVmFsdWVzJGdldDIiLCJpbml0QXRvbSIsImluaXRTdGF0ZSIsIl9vcHRpb25zJGVmZmVjdHMiLCJjbGVhbnVwQXRvbSIsIl9jbGVhbnVwRWZmZWN0c0J5U3RvciIsIm5vdGlmeURlZmF1bHRTdWJzY3JpYmVycyIsIl9zdG9yZSRnZXRTdGF0ZSRuZXh0VDMiLCJlZmZlY3RzIiwiZWZmZWN0c19VTlNUQUJMRSIsImluaXRWYWx1ZSIsImlzRHVyaW5nSW5pdCIsImlzSW5pdEVycm9yIiwicGVuZGluZ1NldFNlbGYiLCJyZXRWYWx1ZSIsInBlZWtBdG9tIiwiZ2V0UHJvbWlzZSIsImdldEluZm9fVU5TVEFCTEUiLCJfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ0IiwiaW5mbyIsInNldFNlbGYiLCJlZmZlY3QiLCJjdXJyZW50TG9hZGFibGUiLCJjdXJyZW50VmFsdWUiLCJyZXNldFNlbGYiLCJoYW5kbGVyIiwiX2NsZWFudXBFZmZlY3RzQnlTdG9yMiIsImN1cnJlbnRTdG9yZSIsIl9jdXJyZW50VHJlZSRhdG9tVmFsdSIsIl9wcmV2aW91c1RyZWUkYXRvbVZhbCIsIl9wZW5kaW5nU2V0U2VsZiIsIl9wZW5kaW5nU2V0U2VsZjIiLCJfcGVuZGluZ1NldFNlbGYzIiwib2xkTG9hZGFibGUiLCJvbGRWYWx1ZSIsInBhcmVudFN0b3JlSURfVU5TVEFCTEUiLCJfY2xlYW51cEVmZmVjdHNCeVN0b3IzIiwiX3N0b3JlJGdldFN0YXRlJG5leHRUNSIsImluaXRMb2FkYWJsZSIsIl9yZWYiLCJfc3RhdGUkYXRvbVZhbHVlcyRnZXQzIiwiZ2V0QXRvbSIsIm5vbnZhbGlkYXRlZFZhbHVlIiwidmFsaWRhdG9yUmVzdWx0IiwidmFsaWRhdG9yIiwidmFsaWRhdGVkVmFsdWVMb2FkYWJsZSIsImludmFsaWRhdGVBdG9tIiwic2V0QXRvbSIsInNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZUF0b20iLCJyZXN0T3B0aW9ucyIsIm9wdGlvbnNEZWZhdWx0IiwiYXRvbVdpdGhGYWxsYmFjayIsInN0b3JlZFZhbHVlIiwic2VsIiwiYmFzZVZhbHVlIiwiUmVjb2lsX2F0b20iLCJNYXBDYWNoZSIsIlJlY29pbF9NYXBDYWNoZSIsIlJlY29pbF9NYXBDYWNoZV8xIiwiUmVjb2lsX01hcENhY2hlJDEiLCJMUlVDYWNoZSQyIiwiTWFwQ2FjaGUkMSIsImRlZmF1bHRQb2xpY3kkMSIsImNhY2hlRnJvbVBvbGljeSIsImdldFZhbHVlTWFwcGVyJDEiLCJnZXRDYWNoZSIsIlJlY29pbF9jYWNoZUZyb21Qb2xpY3kiLCJzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMiIsImF0b21GYW1pbHkiLCJfb3B0aW9ucyRjYWNoZVBvbGljeUYiLCJfb3B0aW9ucyRjYWNoZVBvbGljeUYyIiwiYXRvbUNhY2hlIiwiY2FjaGVQb2xpY3lGb3JQYXJhbXNfVU5TVEFCTEUiLCJwYXJhbXMiLCJfc3RhYmxlU3RyaW5naWZ5IiwiY2FjaGVkQXRvbSIsImF0b21PcHRpb25zIiwibmV3QXRvbSIsIlJlY29pbF9hdG9tRmFtaWx5Iiwic2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDMiLCJuZXh0SW5kZXgiLCJzZWxlY3RvckZhbWlseSIsInNlbGVjdG9yQ2FjaGUiLCJjYWNoZWRTZWxlY3RvciIsIm15S2V5IiwibXlHZXQiLCJjYWxsYmFja3MiLCJteUNhY2hlUG9saWN5IiwibmV3U2VsZWN0b3IiLCJteVNldCIsIlJlY29pbF9zZWxlY3RvckZhbWlseSIsImNvbnN0YW50U2VsZWN0b3IiLCJjb25zdFNlbGVjdG9yIiwiUmVjb2lsX2NvbnN0U2VsZWN0b3IiLCJ0aHJvd2luZ1NlbGVjdG9yIiwiZXJyb3JTZWxlY3RvciIsIlJlY29pbF9lcnJvclNlbGVjdG9yIiwicmVhZE9ubHlTZWxlY3RvciIsIlJlY29pbF9yZWFkT25seVNlbGVjdG9yIiwibG9hZGFibGVXaXRoRXJyb3IkMyIsImxvYWRhYmxlV2l0aFByb21pc2UkMyIsImxvYWRhYmxlV2l0aFZhbHVlJDQiLCJjb25jdXJyZW50UmVxdWVzdHMiLCJyZXN1bHRzIiwiZmlsbCIsImV4Y2VwdGlvbnMiLCJpc0Vycm9yIiwiZXhwIiwidW53cmFwRGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jaWVzIiwid3JhcFJlc3VsdHMiLCJ3cmFwTG9hZGFibGVzIiwiZXhjZXB0aW9uIiwiY29tYmluZUFzeW5jUmVzdWx0c1dpdGhTeW5jUmVzdWx0cyIsInN5bmNSZXN1bHRzIiwiYXN5bmNSZXN1bHRzIiwid2FpdEZvck5vbmUiLCJ3YWl0Rm9yQW55Iiwid2FpdEZvckFsbCIsImV4Y2VwdGlvblJlc3VsdHMiLCJ3YWl0Rm9yQWxsU2V0dGxlZCIsIm5vV2FpdCIsImRlcGVuZGVuY3kiLCJSZWNvaWxfV2FpdEZvciIsIkRlZmF1bHRWYWx1ZSQzIiwiUmVjb2lsUm9vdCQyIiwidXNlUmVjb2lsU3RvcmVJRCQxIiwiaXNSZWNvaWxWYWx1ZSQ1IiwicmV0ZW50aW9uWm9uZSQxIiwiZnJlc2hTbmFwc2hvdCQyIiwidXNlUmVjb2lsU3RhdGUkMSIsInVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxIiwidXNlUmVjb2lsU3RhdGVMb2FkYWJsZSQxIiwidXNlUmVjb2lsVmFsdWUkMSIsInVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxIiwidXNlUmVjb2lsVmFsdWVMb2FkYWJsZSQxIiwidXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSIsInVzZVJlc2V0UmVjb2lsU3RhdGUkMSIsInVzZVNldFJlY29pbFN0YXRlJDEiLCJ1c2VHb3RvUmVjb2lsU25hcHNob3QkMSIsInVzZVJlY29pbFNuYXBzaG90JDEiLCJ1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyJDEiLCJ1c2VSZWNvaWxDYWxsYmFjayQxIiwibm9XYWl0JDEiLCJ3YWl0Rm9yQWxsJDEiLCJ3YWl0Rm9yQWxsU2V0dGxlZCQxIiwid2FpdEZvckFueSQxIiwid2FpdEZvck5vbmUkMSIsIlJlY29pbF9pbmRleCIsInVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHNfVU5TVEFCTEUiLCJ1c2VHZXRSZWNvaWxWYWx1ZUluZm9fVU5TVEFCTEUiLCJ1c2VSZWNvaWxSZWZyZXNoZXJfVU5TVEFCTEUiLCJ1c2VSZWNvaWxUcmFuc2FjdGlvbl9VTlNUQUJMRSIsInVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXJfVU5TVEFCTEUiLCJzbmFwc2hvdF9VTlNUQUJMRSIsIlJlY29pbF9pbmRleF8xIiwiUmVjb2lsX2luZGV4XzIiLCJSZWNvaWxfaW5kZXhfMyIsIlJlY29pbF9pbmRleF80IiwiUmVjb2lsX2luZGV4XzUiLCJSZWNvaWxfaW5kZXhfNiIsIlJlY29pbF9pbmRleF83IiwiUmVjb2lsX2luZGV4XzgiLCJSZWNvaWxfaW5kZXhfOSIsIlJlY29pbF9pbmRleF8xMCIsIlJlY29pbF9pbmRleF8xMSIsIlJlY29pbF9pbmRleF8xMiIsIlJlY29pbF9pbmRleF8xMyIsIlJlY29pbF9pbmRleF8xNCIsIlJlY29pbF9pbmRleF8xNSIsIlJlY29pbF9pbmRleF8xNiIsIlJlY29pbF9pbmRleF8xNyIsIlJlY29pbF9pbmRleF8xOCIsIlJlY29pbF9pbmRleF8xOSIsIlJlY29pbF9pbmRleF8yMCIsIlJlY29pbF9pbmRleF8yMSIsIlJlY29pbF9pbmRleF8yMiIsIlJlY29pbF9pbmRleF8yMyIsIlJlY29pbF9pbmRleF8yNCIsIlJlY29pbF9pbmRleF8yNSIsIlJlY29pbF9pbmRleF8yNiIsIlJlY29pbF9pbmRleF8yNyIsIlJlY29pbF9pbmRleF8yOCIsIlJlY29pbF9pbmRleF8yOSIsIlJlY29pbF9pbmRleF8zMCIsIlJlY29pbF9pbmRleF8zMSIsIlJlY29pbF9pbmRleF8zMiIsIlJlY29pbF9pbmRleF8zMyIsIlJlY29pbF9pbmRleF8zNCIsIlJlY29pbF9pbmRleF8zNSIsIlJlY29pbF9pbmRleF8zNiIsIlJlY29pbF9pbmRleF8zNyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recoil/es/index.js\n"));

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\r\n * Copyright (c) 2014-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\nvar runtime = function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function (obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n    return generator;\n  }\n\n  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n\n  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n\n\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"); // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n    // do is to check its .name property.\n    (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n  };\n\n  exports.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  }; // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n\n\n  exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n\n        if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function (value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function (err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function (unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function (error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = // If enqueue has been called before, then we want to wait until\n      // all previous Promises have been resolved before calling invoke,\n      // so that results are always delivered in the correct order. If\n      // enqueue has not been called before, then it is important to\n      // call invoke immediately, without waiting on a callback to fire,\n      // so that the async generator function has the opportunity to do\n      // any necessary setup in a predictable way. This predictability\n      // is why the Promise constructor synchronously invokes its\n      // executor callback, and why async functions synchronously\n      // execute code before the first await. Since we implement simple\n      // async functions in terms of async generators, it is especially\n      // important to get this right, even though it requires care.\n      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n      // invocations of the iterator.\n      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    } // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n\n\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n\n  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n    : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        } // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n        var record = tryCatch(innerFn, self, context);\n\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted; // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  } // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (!info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n      context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    } // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n\n\n    context.delegate = null;\n    return ContinueSentinel;\n  } // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n\n\n  defineIteratorMethods(Gp);\n  define(Gp, toStringTagSymbol, \"Generator\"); // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n  define(Gp, iteratorSymbol, function () {\n    return this;\n  });\n  define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    keys.reverse(); // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      } // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n\n\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n          return next;\n        };\n\n        return next.next = next;\n      }\n    } // Return an iterator with no values.\n\n\n    return {\n      next: doneResult\n    };\n  }\n\n  exports.values = values;\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n    reset: function (skipTempReset) {\n      this.prev = 0;\n      this.next = 0; // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n      this.method = \"next\";\n      this.arg = undefined;\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n    stop: function () {\n      this.done = true;\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n    dispatchException: function (exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n    abrupt: function (type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n    complete: function (record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" || record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n    finish: function (finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n    \"catch\": function (tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      } // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function (iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  }; // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n\n  return exports;\n}( // If this script is executing as a CommonJS module, use module.exports\n// as the regeneratorRuntime namespace. Otherwise create a new empty\n// object. Either way, the resulting object will be used to initialize\n// the regeneratorRuntime variable at the top of this file.\n true ? module.exports : 0);\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLElBQUlBLE9BQU8sR0FBSSxVQUFVQyxPQUFWLEVBQW1CO0VBQ2hDOztFQUVBLElBQUlDLEVBQUUsR0FBR0MsTUFBTSxDQUFDQyxTQUFoQjtFQUNBLElBQUlDLE1BQU0sR0FBR0gsRUFBRSxDQUFDSSxjQUFoQjtFQUNBLElBQUlDLFNBQUosQ0FMZ0MsQ0FLakI7O0VBQ2YsSUFBSUMsT0FBTyxHQUFHLE9BQU9DLE1BQVAsS0FBa0IsVUFBbEIsR0FBK0JBLE1BQS9CLEdBQXdDLEVBQXREO0VBQ0EsSUFBSUMsY0FBYyxHQUFHRixPQUFPLENBQUNHLFFBQVIsSUFBb0IsWUFBekM7RUFDQSxJQUFJQyxtQkFBbUIsR0FBR0osT0FBTyxDQUFDSyxhQUFSLElBQXlCLGlCQUFuRDtFQUNBLElBQUlDLGlCQUFpQixHQUFHTixPQUFPLENBQUNPLFdBQVIsSUFBdUIsZUFBL0M7O0VBRUEsU0FBU0MsTUFBVCxDQUFnQkMsR0FBaEIsRUFBcUJDLEdBQXJCLEVBQTBCQyxLQUExQixFQUFpQztJQUMvQmhCLE1BQU0sQ0FBQ2lCLGNBQVAsQ0FBc0JILEdBQXRCLEVBQTJCQyxHQUEzQixFQUFnQztNQUM5QkMsS0FBSyxFQUFFQSxLQUR1QjtNQUU5QkUsVUFBVSxFQUFFLElBRmtCO01BRzlCQyxZQUFZLEVBQUUsSUFIZ0I7TUFJOUJDLFFBQVEsRUFBRTtJQUpvQixDQUFoQztJQU1BLE9BQU9OLEdBQUcsQ0FBQ0MsR0FBRCxDQUFWO0VBQ0Q7O0VBQ0QsSUFBSTtJQUNGO0lBQ0FGLE1BQU0sQ0FBQyxFQUFELEVBQUssRUFBTCxDQUFOO0VBQ0QsQ0FIRCxDQUdFLE9BQU9RLEdBQVAsRUFBWTtJQUNaUixNQUFNLEdBQUcsVUFBU0MsR0FBVCxFQUFjQyxHQUFkLEVBQW1CQyxLQUFuQixFQUEwQjtNQUNqQyxPQUFPRixHQUFH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SSxPQUFwQyxHQUE4QyxDQXJ0QmpDLENBQWY7O0FBd3RCQSxJQUFJO0VBQ0Y4SSxrQkFBa0IsR0FBRy9JLE9BQXJCO0FBQ0QsQ0FGRCxDQUVFLE9BQU9nSixvQkFBUCxFQUE2QjtFQUM3QjtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksT0FBT0MsVUFBUCxLQUFzQixRQUExQixFQUFvQztJQUNsQ0EsVUFBVSxDQUFDRixrQkFBWCxHQUFnQy9JLE9BQWhDO0VBQ0QsQ0FGRCxNQUVPO0lBQ0xrSixRQUFRLENBQUMsR0FBRCxFQUFNLHdCQUFOLENBQVIsQ0FBd0NsSixPQUF4QztFQUNEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcz9jNTZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICovXHJcblxyXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xyXG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcclxuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cclxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xyXG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XHJcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcclxuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xyXG5cclxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBvYmpba2V5XTtcclxuICB9XHJcbiAgdHJ5IHtcclxuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXHJcbiAgICBkZWZpbmUoe30sIFwiXCIpO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcclxuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxyXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XHJcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xyXG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XHJcblxyXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxyXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxyXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xyXG5cclxuICAgIHJldHVybiBnZW5lcmF0b3I7XHJcbiAgfVxyXG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XHJcblxyXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxyXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxyXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxyXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcclxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXHJcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xyXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXHJcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXHJcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxyXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cclxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcclxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcclxuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xyXG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XHJcblxyXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcclxuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXHJcbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcclxuXHJcbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXHJcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXHJcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcclxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxyXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XHJcbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxyXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cclxuXHJcbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxyXG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXHJcbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XHJcbiAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSk7XHJcblxyXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcclxuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XHJcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXHJcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxyXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XHJcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxyXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxyXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcclxuICB9XHJcblxyXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XHJcbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XHJcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XHJcbiAgZGVmaW5lKEdwLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcclxuICBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pO1xyXG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKFxyXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXHJcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcclxuICAgIFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxyXG4gICk7XHJcblxyXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXHJcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cclxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XHJcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcclxuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xyXG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xyXG4gICAgcmV0dXJuIGN0b3JcclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxyXG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cclxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXHJcbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXHJcbiAgICAgIDogZmFsc2U7XHJcbiAgfTtcclxuXHJcbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XHJcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XHJcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcclxuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XHJcbiAgICB9XHJcbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XHJcbiAgICByZXR1cm4gZ2VuRnVuO1xyXG4gIH07XHJcblxyXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xyXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XHJcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xyXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXHJcbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xyXG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XHJcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcclxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcclxuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcclxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xyXG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XHJcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xyXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXHJcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cclxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcclxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcclxuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cclxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XHJcblxyXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xyXG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cclxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXHJcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXHJcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxyXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXHJcbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXHJcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cclxuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XHJcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcclxuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxyXG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXHJcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcclxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXHJcbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXHJcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcclxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXHJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXHJcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xyXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXHJcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cclxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XHJcbiAgfVxyXG5cclxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xyXG4gIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSk7XHJcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcclxuXHJcbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxyXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxyXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxyXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcclxuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XHJcblxyXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcclxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXHJcbiAgICAgIFByb21pc2VJbXBsXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcclxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cclxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcclxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcclxuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcclxuICAgICAgICAgIHRocm93IGFyZztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxyXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xyXG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcclxuXHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcclxuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcclxuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcclxuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xyXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XHJcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcclxuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcclxuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcclxuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XHJcblxyXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcclxuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cclxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cclxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXHJcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcclxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xyXG5cclxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxyXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xyXG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcclxuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcclxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXHJcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcclxuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcclxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXHJcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXHJcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXHJcbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xyXG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcclxuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcclxuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cclxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XHJcblxyXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xyXG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXHJcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XHJcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXHJcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXHJcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XHJcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XHJcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXHJcbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxyXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xyXG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcclxuXHJcbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xyXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcclxuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xyXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcclxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xyXG5cclxuICAgIGlmICghIGluZm8pIHtcclxuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XHJcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xyXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcclxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGluZm8uZG9uZSkge1xyXG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxyXG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxyXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcclxuXHJcbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cclxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcclxuXHJcbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxyXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXHJcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXHJcbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xyXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxyXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXHJcbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xyXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XHJcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXHJcbiAgICAgIHJldHVybiBpbmZvO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXHJcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxyXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XHJcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcclxuICB9XHJcblxyXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXHJcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxyXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XHJcblxyXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xyXG5cclxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxyXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXHJcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cclxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cclxuICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0pO1xyXG5cclxuICBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcclxuICB9KTtcclxuXHJcbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcclxuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XHJcblxyXG4gICAgaWYgKDEgaW4gbG9jcykge1xyXG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKDIgaW4gbG9jcykge1xyXG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcclxuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcclxuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xyXG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xyXG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XHJcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xyXG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXHJcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXHJcbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXHJcbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xyXG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xyXG4gICAgdGhpcy5yZXNldCh0cnVlKTtcclxuICB9XHJcblxyXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xyXG4gICAgdmFyIGtleXMgPSBbXTtcclxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcclxuICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICB9XHJcbiAgICBrZXlzLnJldmVyc2UoKTtcclxuXHJcbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxyXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cclxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcclxuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xyXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcclxuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcclxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcclxuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXHJcbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XHJcbiAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcclxuICAgIGlmIChpdGVyYWJsZSkge1xyXG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XHJcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xyXG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICByZXR1cm4gaXRlcmFibGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xyXG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XHJcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xyXG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXHJcbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XHJcbiAgfVxyXG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xyXG5cclxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xyXG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xyXG4gIH1cclxuXHJcbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XHJcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xyXG4gICAgICB0aGlzLnByZXYgPSAwO1xyXG4gICAgICB0aGlzLm5leHQgPSAwO1xyXG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xyXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxyXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcclxuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XHJcblxyXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xyXG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xyXG5cclxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XHJcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxyXG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxyXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXHJcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xyXG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcclxuXHJcbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XHJcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XHJcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xyXG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XHJcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcclxuICAgICAgICB0aHJvdyBleGNlcHRpb247XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcclxuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XHJcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XHJcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcclxuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XHJcblxyXG4gICAgICAgIGlmIChjYXVnaHQpIHtcclxuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXHJcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxyXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcclxuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcclxuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcclxuXHJcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcclxuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXHJcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cclxuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXHJcbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcclxuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xyXG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xyXG5cclxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcclxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxyXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXHJcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcclxuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxyXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxyXG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcclxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXHJcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcclxuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXHJcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxyXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xyXG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XHJcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XHJcblxyXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XHJcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcclxuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcclxuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcclxuICAgIH0sXHJcblxyXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcclxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcclxuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxyXG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xyXG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XHJcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcclxuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XHJcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xyXG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XHJcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcclxuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XHJcbiAgICB9LFxyXG5cclxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xyXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xyXG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XHJcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcclxuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xyXG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XHJcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XHJcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcclxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XHJcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xyXG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB0aHJvd247XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cclxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XHJcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XHJcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXHJcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcclxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XHJcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcclxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXHJcbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcclxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcclxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcclxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxyXG4gIHJldHVybiBleHBvcnRzO1xyXG5cclxufShcclxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xyXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XHJcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxyXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXHJcbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cclxuKSk7XHJcblxyXG50cnkge1xyXG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XHJcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XHJcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcclxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcclxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIGluIG1vZGVybiBlbmdpbmVzXHJcbiAgLy8gd2UgY2FuIGV4cGxpY2l0bHkgYWNjZXNzIGdsb2JhbFRoaXMuIEluIG9sZGVyIGVuZ2luZXMgd2UgY2FuIGVzY2FwZVxyXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxyXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxyXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXHJcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcclxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcclxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cclxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIGdsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcclxuICB9IGVsc2Uge1xyXG4gICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJleHBvcnRzIiwiT3AiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsInVuZGVmaW5lZCIsIiRTeW1ib2wiLCJTeW1ib2wiLCJpdGVyYXRvclN5bWJvbCIsIml0ZXJhdG9yIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsInRvU3RyaW5nVGFnIiwiZGVmaW5lIiwib2JqIiwia2V5IiwidmFsdWUiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImVyciIsIndyYXAiLCJpbm5lckZuIiwib3V0ZXJGbiIsInNlbGYiLCJ0cnlMb2NzTGlzdCIsInByb3RvR2VuZXJhdG9yIiwiR2VuZXJhdG9yIiwiZ2VuZXJhdG9yIiwiY3JlYXRlIiwiY29udGV4dCIsIkNvbnRleHQiLCJfaW52b2tlIiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiZm4iLCJhcmciLCJ0eXBlIiwiY2FsbCIsIkdlblN0YXRlU3VzcGVuZGVkU3RhcnQiLCJHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkIiwiR2VuU3RhdGVFeGVjdXRpbmciLCJHZW5TdGF0ZUNvbXBsZXRlZCIsIkNvbnRpbnVlU2VudGluZWwiLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJnZXRQcm90byIsImdldFByb3RvdHlwZU9mIiwiTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUiLCJ2YWx1ZXMiLCJHcCIsImRpc3BsYXlOYW1lIiwiZGVmaW5lSXRlcmF0b3JNZXRob2RzIiwiZm9yRWFjaCIsIm1ldGhvZCIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5GdW4iLCJjdG9yIiwiY29uc3RydWN0b3IiLCJuYW1lIiwibWFyayIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiYXdyYXAiLCJfX2F3YWl0IiwiQXN5bmNJdGVyYXRvciIsIlByb21pc2VJbXBsIiwiaW52b2tlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlY29yZCIsInJlc3VsdCIsInRoZW4iLCJ1bndyYXBwZWQiLCJlcnJvciIsInByZXZpb3VzUHJvbWlzZSIsImVucXVldWUiLCJjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyIsImFzeW5jIiwiUHJvbWlzZSIsIml0ZXIiLCJuZXh0IiwiZG9uZSIsInN0YXRlIiwiRXJyb3IiLCJkb25lUmVzdWx0IiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZVJlc3VsdCIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsIlR5cGVFcnJvciIsImluZm8iLCJyZXN1bHROYW1lIiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJlbnRyeSIsInRyeUxvYyIsImNhdGNoTG9jIiwiZmluYWxseUxvYyIsImFmdGVyTG9jIiwidHJ5RW50cmllcyIsInB1c2giLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0Iiwia2V5cyIsIm9iamVjdCIsInJldmVyc2UiLCJsZW5ndGgiLCJwb3AiLCJpdGVyYWJsZSIsIml0ZXJhdG9yTWV0aG9kIiwiaXNOYU4iLCJpIiwic2tpcFRlbXBSZXNldCIsInByZXYiLCJjaGFyQXQiLCJzbGljZSIsInN0b3AiLCJyb290RW50cnkiLCJyb290UmVjb3JkIiwicnZhbCIsImV4Y2VwdGlvbiIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsImhhc0NhdGNoIiwiaGFzRmluYWxseSIsImZpbmFsbHlFbnRyeSIsImNvbXBsZXRlIiwiZmluaXNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsIm1vZHVsZSIsInJlZ2VuZXJhdG9yUnVudGltZSIsImFjY2lkZW50YWxTdHJpY3RNb2RlIiwiZ2xvYmFsVGhpcyIsIkZ1bmN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css":
/*!********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css ***!
  \********************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*\\n! tailwindcss v3.1.8 | MIT License | https://tailwindcss.com\\n*//*\\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\\n*/\\n\\n*,\\n::before,\\n::after {\\n  box-sizing: border-box; /* 1 */\\n  border-width: 0; /* 2 */\\n  border-style: solid; /* 2 */\\n  border-color: #e5e7eb; /* 2 */\\n}\\n\\n::before,\\n::after {\\n  --tw-content: '';\\n}\\n\\n/*\\n1. Use a consistent sensible line-height in all browsers.\\n2. Prevent adjustments of font size after orientation changes in iOS.\\n3. Use a more readable tab size.\\n4. Use the user's configured `sans` font-family by default.\\n*/\\n\\nhtml {\\n  line-height: 1.5; /* 1 */\\n  -webkit-text-size-adjust: 100%; /* 2 */\\n  -moz-tab-size: 4; /* 3 */\\n  -o-tab-size: 4;\\n     tab-size: 4; /* 3 */\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\"; /* 4 */\\n}\\n\\n/*\\n1. Remove the margin in all browsers.\\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\\n*/\\n\\nbody {\\n  margin: 0; /* 1 */\\n  line-height: inherit; /* 2 */\\n}\\n\\n/*\\n1. Add the correct height in Firefox.\\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\\n3. Ensure horizontal rules are visible by default.\\n*/\\n\\nhr {\\n  height: 0; /* 1 */\\n  color: inherit; /* 2 */\\n  border-top-width: 1px; /* 3 */\\n}\\n\\n/*\\nAdd the correct text decoration in Chrome, Edge, and Safari.\\n*/\\n\\nabbr:where([title]) {\\n  -webkit-text-decoration: underline dotted;\\n          text-decoration: underline dotted;\\n}\\n\\n/*\\nRemove the default font size and weight for headings.\\n*/\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  font-size: inherit;\\n  font-weight: inherit;\\n}\\n\\n/*\\nReset links to optimize for opt-in styling instead of opt-out.\\n*/\\n\\na {\\n  color: inherit;\\n  text-decoration: inherit;\\n}\\n\\n/*\\nAdd the correct font weight in Edge and Safari.\\n*/\\n\\nb,\\nstrong {\\n  font-weight: bolder;\\n}\\n\\n/*\\n1. Use the user's configured `mono` font family by default.\\n2. Correct the odd `em` font sizing in all browsers.\\n*/\\n\\ncode,\\nkbd,\\nsamp,\\npre {\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace; /* 1 */\\n  font-size: 1em; /* 2 */\\n}\\n\\n/*\\nAdd the correct font size in all browsers.\\n*/\\n\\nsmall {\\n  font-size: 80%;\\n}\\n\\n/*\\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\\n*/\\n\\nsub,\\nsup {\\n  font-size: 75%;\\n  line-height: 0;\\n  position: relative;\\n  vertical-align: baseline;\\n}\\n\\nsub {\\n  bottom: -0.25em;\\n}\\n\\nsup {\\n  top: -0.5em;\\n}\\n\\n/*\\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\\n3. Remove gaps between table borders by default.\\n*/\\n\\ntable {\\n  text-indent: 0; /* 1 */\\n  border-color: inherit; /* 2 */\\n  border-collapse: collapse; /* 3 */\\n}\\n\\n/*\\n1. Change the font styles in all browsers.\\n2. Remove the margin in Firefox and Safari.\\n3. Remove default padding in all browsers.\\n*/\\n\\nbutton,\\ninput,\\noptgroup,\\nselect,\\ntextarea {\\n  font-family: inherit; /* 1 */\\n  font-size: 100%; /* 1 */\\n  font-weight: inherit; /* 1 */\\n  line-height: inherit; /* 1 */\\n  color: inherit; /* 1 */\\n  margin: 0; /* 2 */\\n  padding: 0; /* 3 */\\n}\\n\\n/*\\nRemove the inheritance of text transform in Edge and Firefox.\\n*/\\n\\nbutton,\\nselect {\\n  text-transform: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Remove default button styles.\\n*/\\n\\nbutton,\\n[type='button'],\\n[type='reset'],\\n[type='submit'] {\\n  -webkit-appearance: button; /* 1 */\\n  background-color: transparent; /* 2 */\\n  background-image: none; /* 2 */\\n}\\n\\n/*\\nUse the modern Firefox focus style for all focusable elements.\\n*/\\n\\n:-moz-focusring {\\n  outline: auto;\\n}\\n\\n/*\\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\\n*/\\n\\n:-moz-ui-invalid {\\n  box-shadow: none;\\n}\\n\\n/*\\nAdd the correct vertical alignment in Chrome and Firefox.\\n*/\\n\\nprogress {\\n  vertical-align: baseline;\\n}\\n\\n/*\\nCorrect the cursor style of increment and decrement buttons in Safari.\\n*/\\n\\n::-webkit-inner-spin-button,\\n::-webkit-outer-spin-button {\\n  height: auto;\\n}\\n\\n/*\\n1. Correct the odd appearance in Chrome and Safari.\\n2. Correct the outline style in Safari.\\n*/\\n\\n[type='search'] {\\n  -webkit-appearance: textfield; /* 1 */\\n  outline-offset: -2px; /* 2 */\\n}\\n\\n/*\\nRemove the inner padding in Chrome and Safari on macOS.\\n*/\\n\\n::-webkit-search-decoration {\\n  -webkit-appearance: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Change font properties to `inherit` in Safari.\\n*/\\n\\n::-webkit-file-upload-button {\\n  -webkit-appearance: button; /* 1 */\\n  font: inherit; /* 2 */\\n}\\n\\n/*\\nAdd the correct display in Chrome and Safari.\\n*/\\n\\nsummary {\\n  display: list-item;\\n}\\n\\n/*\\nRemoves the default spacing and border for appropriate elements.\\n*/\\n\\nblockquote,\\ndl,\\ndd,\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\nhr,\\nfigure,\\np,\\npre {\\n  margin: 0;\\n}\\n\\nfieldset {\\n  margin: 0;\\n  padding: 0;\\n}\\n\\nlegend {\\n  padding: 0;\\n}\\n\\nol,\\nul,\\nmenu {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n/*\\nPrevent resizing textareas horizontally by default.\\n*/\\n\\ntextarea {\\n  resize: vertical;\\n}\\n\\n/*\\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\\n2. Set the default placeholder color to the user's configured gray 400 color.\\n*/\\n\\ninput::-moz-placeholder, textarea::-moz-placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\ninput::placeholder,\\ntextarea::placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\n/*\\nSet the default cursor for buttons.\\n*/\\n\\nbutton,\\n[role=\\\"button\\\"] {\\n  cursor: pointer;\\n}\\n\\n/*\\nMake sure disabled buttons don't get the pointer cursor.\\n*/\\n:disabled {\\n  cursor: default;\\n}\\n\\n/*\\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\\n   This can trigger a poorly considered lint error in some tools but is included by design.\\n*/\\n\\nimg,\\nsvg,\\nvideo,\\ncanvas,\\naudio,\\niframe,\\nembed,\\nobject {\\n  display: block; /* 1 */\\n  vertical-align: middle; /* 2 */\\n}\\n\\n/*\\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\\n*/\\n\\nimg,\\nvideo {\\n  max-width: 100%;\\n  height: auto;\\n}\\n\\n*, ::before, ::after {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\n\\n::backdrop {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\r\\n.pointer-events-none {\\n  pointer-events: none;\\n}\\r\\n.fixed {\\n  position: fixed;\\n}\\r\\n.absolute {\\n  position: absolute;\\n}\\r\\n.relative {\\n  position: relative;\\n}\\r\\n.-top-3 {\\n  top: -0.75rem;\\n}\\r\\n.-top-5 {\\n  top: -1.25rem;\\n}\\r\\n.-top-16 {\\n  top: -4rem;\\n}\\r\\n.bottom-\\\\[16\\\\.2rem\\\\] {\\n  bottom: 16.2rem;\\n}\\r\\n.right-0 {\\n  right: 0px;\\n}\\r\\n.right-24 {\\n  right: 6rem;\\n}\\r\\n.left-1\\\\/2 {\\n  left: 50%;\\n}\\r\\n.right-1\\\\/2 {\\n  right: 50%;\\n}\\r\\n.bottom-36 {\\n  bottom: 9rem;\\n}\\r\\n.top-\\\\[85\\\\%\\\\] {\\n  top: 85%;\\n}\\r\\n.bottom-\\\\[17\\\\.2rem\\\\] {\\n  bottom: 17.2rem;\\n}\\r\\n.bottom-0 {\\n  bottom: 0px;\\n}\\r\\n.top-0 {\\n  top: 0px;\\n}\\r\\n.right-9 {\\n  right: 2.25rem;\\n}\\r\\n.left-0 {\\n  left: 0px;\\n}\\r\\n.z-10 {\\n  z-index: 10;\\n}\\r\\n.z-20 {\\n  z-index: 20;\\n}\\r\\n.col-span-2 {\\n  grid-column: span 2 / span 2;\\n}\\r\\n.col-span-3 {\\n  grid-column: span 3 / span 3;\\n}\\r\\n.col-span-12 {\\n  grid-column: span 12 / span 12;\\n}\\r\\n.col-span-10 {\\n  grid-column: span 10 / span 10;\\n}\\r\\n.col-span-4 {\\n  grid-column: span 4 / span 4;\\n}\\r\\n.col-span-6 {\\n  grid-column: span 6 / span 6;\\n}\\r\\n.col-span-7 {\\n  grid-column: span 7 / span 7;\\n}\\r\\n.row-span-3 {\\n  grid-row: span 3 / span 3;\\n}\\r\\n.my-2 {\\n  margin-top: 0.5rem;\\n  margin-bottom: 0.5rem;\\n}\\r\\n.mx-auto {\\n  margin-left: auto;\\n  margin-right: auto;\\n}\\r\\n.mx-3 {\\n  margin-left: 0.75rem;\\n  margin-right: 0.75rem;\\n}\\r\\n.mx-5 {\\n  margin-left: 1.25rem;\\n  margin-right: 1.25rem;\\n}\\r\\n.mx-1 {\\n  margin-left: 0.25rem;\\n  margin-right: 0.25rem;\\n}\\r\\n.my-1 {\\n  margin-top: 0.25rem;\\n  margin-bottom: 0.25rem;\\n}\\r\\n.mx-2 {\\n  margin-left: 0.5rem;\\n  margin-right: 0.5rem;\\n}\\r\\n.my-7 {\\n  margin-top: 1.75rem;\\n  margin-bottom: 1.75rem;\\n}\\r\\n.mx-\\\\[0\\\\.35rem\\\\] {\\n  margin-left: 0.35rem;\\n  margin-right: 0.35rem;\\n}\\r\\n.my-3 {\\n  margin-top: 0.75rem;\\n  margin-bottom: 0.75rem;\\n}\\r\\n.mx-10 {\\n  margin-left: 2.5rem;\\n  margin-right: 2.5rem;\\n}\\r\\n.mx-8 {\\n  margin-left: 2rem;\\n  margin-right: 2rem;\\n}\\r\\n.my-12 {\\n  margin-top: 3rem;\\n  margin-bottom: 3rem;\\n}\\r\\n.mt-16 {\\n  margin-top: 4rem;\\n}\\r\\n.mt-12 {\\n  margin-top: 3rem;\\n}\\r\\n.mt-8 {\\n  margin-top: 2rem;\\n}\\r\\n.mt-2 {\\n  margin-top: 0.5rem;\\n}\\r\\n.mr-5 {\\n  margin-right: 1.25rem;\\n}\\r\\n.mt-5 {\\n  margin-top: 1.25rem;\\n}\\r\\n.-mt-14 {\\n  margin-top: -3.5rem;\\n}\\r\\n.-mb-5 {\\n  margin-bottom: -1.25rem;\\n}\\r\\n.mb-5 {\\n  margin-bottom: 1.25rem;\\n}\\r\\n.mt-3 {\\n  margin-top: 0.75rem;\\n}\\r\\n.mt-10 {\\n  margin-top: 2.5rem;\\n}\\r\\n.mt-7 {\\n  margin-top: 1.75rem;\\n}\\r\\n.mb-10 {\\n  margin-bottom: 2.5rem;\\n}\\r\\n.mt-1 {\\n  margin-top: 0.25rem;\\n}\\r\\n.mt-4 {\\n  margin-top: 1rem;\\n}\\r\\n.ml-1 {\\n  margin-left: 0.25rem;\\n}\\r\\n.mb-7 {\\n  margin-bottom: 1.75rem;\\n}\\r\\n.mb-2 {\\n  margin-bottom: 0.5rem;\\n}\\r\\n.mr-16 {\\n  margin-right: 4rem;\\n}\\r\\n.ml-5 {\\n  margin-left: 1.25rem;\\n}\\r\\n.mt-\\\\[15px\\\\] {\\n  margin-top: 15px;\\n}\\r\\n.mt-\\\\[0\\\\.8px\\\\] {\\n  margin-top: 0.8px;\\n}\\r\\n.mt-6 {\\n  margin-top: 1.5rem;\\n}\\r\\n.mb-4 {\\n  margin-bottom: 1rem;\\n}\\r\\n.-mb-1 {\\n  margin-bottom: -0.25rem;\\n}\\r\\n.-ml-\\\\[100\\\\%\\\\] {\\n  margin-left: -100%;\\n}\\r\\n.-ml-\\\\[0\\\\%\\\\] {\\n  margin-left: -0%;\\n}\\r\\n.-ml-\\\\[200\\\\%\\\\] {\\n  margin-left: -200%;\\n}\\r\\n.-ml-\\\\[300\\\\%\\\\] {\\n  margin-left: -300%;\\n}\\r\\n.-ml-\\\\[50vw\\\\] {\\n  margin-left: -50vw;\\n}\\r\\n.-mr-\\\\[50vw\\\\] {\\n  margin-right: -50vw;\\n}\\r\\n.mr-\\\\[0\\\\.35rem\\\\] {\\n  margin-right: 0.35rem;\\n}\\r\\n.ml-3 {\\n  margin-left: 0.75rem;\\n}\\r\\n.mr-3 {\\n  margin-right: 0.75rem;\\n}\\r\\n.mb-1 {\\n  margin-bottom: 0.25rem;\\n}\\r\\n.mb-8 {\\n  margin-bottom: 2rem;\\n}\\r\\n.block {\\n  display: block;\\n}\\r\\n.inline-block {\\n  display: inline-block;\\n}\\r\\n.flex {\\n  display: flex;\\n}\\r\\n.inline-flex {\\n  display: inline-flex;\\n}\\r\\n.table {\\n  display: table;\\n}\\r\\n.grid {\\n  display: grid;\\n}\\r\\n.hidden {\\n  display: none;\\n}\\r\\n.aspect-square {\\n  aspect-ratio: 1 / 1;\\n}\\r\\n.h-5 {\\n  height: 1.25rem;\\n}\\r\\n.h-24 {\\n  height: 6rem;\\n}\\r\\n.h-72 {\\n  height: 18rem;\\n}\\r\\n.h-fit {\\n  height: -moz-fit-content;\\n  height: fit-content;\\n}\\r\\n.h-\\\\[330px\\\\] {\\n  height: 330px;\\n}\\r\\n.h-12 {\\n  height: 3rem;\\n}\\r\\n.h-max {\\n  height: -moz-max-content;\\n  height: max-content;\\n}\\r\\n.h-\\\\[190\\\\] {\\n  height: 190;\\n}\\r\\n.h-\\\\[467px\\\\] {\\n  height: 467px;\\n}\\r\\n.h-6 {\\n  height: 1.5rem;\\n}\\r\\n.h-full {\\n  height: 100%;\\n}\\r\\n.h-\\\\[30px\\\\] {\\n  height: 30px;\\n}\\r\\n.h-56 {\\n  height: 14rem;\\n}\\r\\n.h-\\\\[45vh\\\\] {\\n  height: 45vh;\\n}\\r\\n.h-\\\\[250px\\\\] {\\n  height: 250px;\\n}\\r\\n.h-4 {\\n  height: 1rem;\\n}\\r\\n.h-\\\\[166px\\\\] {\\n  height: 166px;\\n}\\r\\n.h-\\\\[199\\\\.69px\\\\] {\\n  height: 199.69px;\\n}\\r\\n.h-\\\\[60px\\\\] {\\n  height: 60px;\\n}\\r\\n.h-48 {\\n  height: 12rem;\\n}\\r\\n.max-h-fit {\\n  max-height: -moz-fit-content;\\n  max-height: fit-content;\\n}\\r\\n.max-h-\\\\[250px\\\\] {\\n  max-height: 250px;\\n}\\r\\n.max-h-\\\\[24px\\\\] {\\n  max-height: 24px;\\n}\\r\\n.min-h-screen {\\n  min-height: 100vh;\\n}\\r\\n.min-h-\\\\[100vh\\\\] {\\n  min-height: 100vh;\\n}\\r\\n.min-h-\\\\[330px\\\\] {\\n  min-height: 330px;\\n}\\r\\n.min-h-\\\\[213px\\\\] {\\n  min-height: 213px;\\n}\\r\\n.w-full {\\n  width: 100%;\\n}\\r\\n.w-5 {\\n  width: 1.25rem;\\n}\\r\\n.w-3\\\\/4 {\\n  width: 75%;\\n}\\r\\n.w-24 {\\n  width: 6rem;\\n}\\r\\n.w-8 {\\n  width: 2rem;\\n}\\r\\n.w-\\\\[90vw\\\\] {\\n  width: 90vw;\\n}\\r\\n.w-12 {\\n  width: 3rem;\\n}\\r\\n.w-\\\\[48\\\\%\\\\] {\\n  width: 48%;\\n}\\r\\n.w-fit {\\n  width: -moz-fit-content;\\n  width: fit-content;\\n}\\r\\n.w-2\\\\/3 {\\n  width: 66.666667%;\\n}\\r\\n.w-\\\\[144px\\\\] {\\n  width: 144px;\\n}\\r\\n.w-80 {\\n  width: 20rem;\\n}\\r\\n.w-\\\\[100vw\\\\] {\\n  width: 100vw;\\n}\\r\\n.w-6 {\\n  width: 1.5rem;\\n}\\r\\n.w-\\\\[30px\\\\] {\\n  width: 30px;\\n}\\r\\n.w-\\\\[300\\\\%\\\\] {\\n  width: 300%;\\n}\\r\\n.w-\\\\[100\\\\%\\\\] {\\n  width: 100%;\\n}\\r\\n.w-4 {\\n  width: 1rem;\\n}\\r\\n.w-\\\\[108px\\\\] {\\n  width: 108px;\\n}\\r\\n.w-\\\\[142px\\\\] {\\n  width: 142px;\\n}\\r\\n.w-\\\\[4\\\\.2rem\\\\] {\\n  width: 4.2rem;\\n}\\r\\n.w-20 {\\n  width: 5rem;\\n}\\r\\n.w-2\\\\/4 {\\n  width: 50%;\\n}\\r\\n.min-w-\\\\[300px\\\\] {\\n  min-width: 300px;\\n}\\r\\n.min-w-\\\\[50px\\\\] {\\n  min-width: 50px;\\n}\\r\\n.min-w-\\\\[78px\\\\] {\\n  min-width: 78px;\\n}\\r\\n.min-w-\\\\[108px\\\\] {\\n  min-width: 108px;\\n}\\r\\n.min-w-\\\\[26px\\\\] {\\n  min-width: 26px;\\n}\\r\\n.max-w-\\\\[1200px\\\\] {\\n  max-width: 1200px;\\n}\\r\\n.max-w-\\\\[1500px\\\\] {\\n  max-width: 1500px;\\n}\\r\\n.max-w-\\\\[1300px\\\\] {\\n  max-width: 1300px;\\n}\\r\\n.max-w-\\\\[1100px\\\\] {\\n  max-width: 1100px;\\n}\\r\\n.max-w-\\\\[581px\\\\] {\\n  max-width: 581px;\\n}\\r\\n.-translate-x-1\\\\/2 {\\n  --tw-translate-x: -50%;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\r\\n.cursor-pointer {\\n  cursor: pointer;\\n}\\r\\n.select-none {\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n          user-select: none;\\n}\\r\\n.appearance-none {\\n  -webkit-appearance: none;\\n     -moz-appearance: none;\\n          appearance: none;\\n}\\r\\n.grid-cols-2 {\\n  grid-template-columns: repeat(2, minmax(0, 1fr));\\n}\\r\\n.grid-cols-1 {\\n  grid-template-columns: repeat(1, minmax(0, 1fr));\\n}\\r\\n.grid-cols-4 {\\n  grid-template-columns: repeat(4, minmax(0, 1fr));\\n}\\r\\n.grid-cols-12 {\\n  grid-template-columns: repeat(12, minmax(0, 1fr));\\n}\\r\\n.grid-cols-10 {\\n  grid-template-columns: repeat(10, minmax(0, 1fr));\\n}\\r\\n.flex-col {\\n  flex-direction: column;\\n}\\r\\n.flex-wrap {\\n  flex-wrap: wrap;\\n}\\r\\n.place-content-between {\\n  place-content: space-between;\\n}\\r\\n.items-end {\\n  align-items: flex-end;\\n}\\r\\n.items-center {\\n  align-items: center;\\n}\\r\\n.justify-end {\\n  justify-content: flex-end;\\n}\\r\\n.justify-center {\\n  justify-content: center;\\n}\\r\\n.justify-between {\\n  justify-content: space-between;\\n}\\r\\n.gap-3 {\\n  gap: 0.75rem;\\n}\\r\\n.gap-10 {\\n  gap: 2.5rem;\\n}\\r\\n.gap-4 {\\n  gap: 1rem;\\n}\\r\\n.space-y-4 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-y-reverse: 0;\\n  margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));\\n  margin-bottom: calc(1rem * var(--tw-space-y-reverse));\\n}\\r\\n.space-x-3 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(0.75rem * var(--tw-space-x-reverse));\\n  margin-left: calc(0.75rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\r\\n.space-x-2 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(0.5rem * var(--tw-space-x-reverse));\\n  margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\r\\n.space-x-5 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(1.25rem * var(--tw-space-x-reverse));\\n  margin-left: calc(1.25rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\r\\n.space-x-8 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(2rem * var(--tw-space-x-reverse));\\n  margin-left: calc(2rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\r\\n.divide-solid > :not([hidden]) ~ :not([hidden]) {\\n  border-style: solid;\\n}\\r\\n.overflow-hidden {\\n  overflow: hidden;\\n}\\r\\n.overflow-x-auto {\\n  overflow-x: auto;\\n}\\r\\n.whitespace-nowrap {\\n  white-space: nowrap;\\n}\\r\\n.whitespace-pre-wrap {\\n  white-space: pre-wrap;\\n}\\r\\n.rounded-md {\\n  border-radius: 0.375rem;\\n}\\r\\n.rounded-3xl {\\n  border-radius: 1.5rem;\\n}\\r\\n.rounded-xl {\\n  border-radius: 0.75rem;\\n}\\r\\n.rounded-full {\\n  border-radius: 9999px;\\n}\\r\\n.rounded-lg {\\n  border-radius: 0.5rem;\\n}\\r\\n.rounded {\\n  border-radius: 0.25rem;\\n}\\r\\n.rounded-l-md {\\n  border-top-left-radius: 0.375rem;\\n  border-bottom-left-radius: 0.375rem;\\n}\\r\\n.rounded-l-none {\\n  border-top-left-radius: 0px;\\n  border-bottom-left-radius: 0px;\\n}\\r\\n.border {\\n  border-width: 1px;\\n}\\r\\n.border-\\\\[0\\\\.5px\\\\] {\\n  border-width: 0.5px;\\n}\\r\\n.border-2 {\\n  border-width: 2px;\\n}\\r\\n.border-\\\\[1px\\\\] {\\n  border-width: 1px;\\n}\\r\\n.border-4 {\\n  border-width: 4px;\\n}\\r\\n.border-b {\\n  border-bottom-width: 1px;\\n}\\r\\n.border-b-2 {\\n  border-bottom-width: 2px;\\n}\\r\\n.border-t {\\n  border-top-width: 1px;\\n}\\r\\n.border-b-\\\\[1px\\\\] {\\n  border-bottom-width: 1px;\\n}\\r\\n.border-t-2 {\\n  border-top-width: 2px;\\n}\\r\\n.border-t-\\\\[1px\\\\] {\\n  border-top-width: 1px;\\n}\\r\\n.border-r-0 {\\n  border-right-width: 0px;\\n}\\r\\n.border-solid {\\n  border-style: solid;\\n}\\r\\n.border-dashed {\\n  border-style: dashed;\\n}\\r\\n.border-blue-400 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(96 165 250 / var(--tw-border-opacity));\\n}\\r\\n.border-transparent {\\n  border-color: transparent;\\n}\\r\\n.border-gray-300 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(209 213 219 / var(--tw-border-opacity));\\n}\\r\\n.border-\\\\[\\\\#BBBBBB\\\\] {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(187 187 187 / var(--tw-border-opacity));\\n}\\r\\n.border-\\\\[\\\\#e2e2e2\\\\] {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(226 226 226 / var(--tw-border-opacity));\\n}\\r\\n.border-blue-800 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(30 64 175 / var(--tw-border-opacity));\\n}\\r\\n.bg-white {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\\n}\\r\\n.bg-slate-400 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(148 163 184 / var(--tw-bg-opacity));\\n}\\r\\n.bg-blue-500 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(59 130 246 / var(--tw-bg-opacity));\\n}\\r\\n.bg-zinc-300 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(212 212 216 / var(--tw-bg-opacity));\\n}\\r\\n.bg-zinc-400 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(161 161 170 / var(--tw-bg-opacity));\\n}\\r\\n.bg-yellow-500 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(234 179 8 / var(--tw-bg-opacity));\\n}\\r\\n.bg-indigo-500 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(99 102 241 / var(--tw-bg-opacity));\\n}\\r\\n.bg-teal-500 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(20 184 166 / var(--tw-bg-opacity));\\n}\\r\\n.bg-blue-200 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(191 219 254 / var(--tw-bg-opacity));\\n}\\r\\n.bg-\\\\[\\\\#3D414D\\\\] {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(61 65 77 / var(--tw-bg-opacity));\\n}\\r\\n.bg-gray-200 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(229 231 235 / var(--tw-bg-opacity));\\n}\\r\\n.bg-black {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(0 0 0 / var(--tw-bg-opacity));\\n}\\r\\n.bg-red-200 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(254 202 202 / var(--tw-bg-opacity));\\n}\\r\\n.bg-slate-300 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(203 213 225 / var(--tw-bg-opacity));\\n}\\r\\n.bg-slate-100 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(241 245 249 / var(--tw-bg-opacity));\\n}\\r\\n.bg-gray-50 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(249 250 251 / var(--tw-bg-opacity));\\n}\\r\\n.object-cover {\\n  -o-object-fit: cover;\\n     object-fit: cover;\\n}\\r\\n.p-6 {\\n  padding: 1.5rem;\\n}\\r\\n.p-3 {\\n  padding: 0.75rem;\\n}\\r\\n.p-2 {\\n  padding: 0.5rem;\\n}\\r\\n.p-\\\\[0\\\\.12rem\\\\] {\\n  padding: 0.12rem;\\n}\\r\\n.p-1 {\\n  padding: 0.25rem;\\n}\\r\\n.p-\\\\[0\\\\.2rem\\\\] {\\n  padding: 0.2rem;\\n}\\r\\n.p-0 {\\n  padding: 0px;\\n}\\r\\n.px-4 {\\n  padding-left: 1rem;\\n  padding-right: 1rem;\\n}\\r\\n.px-2 {\\n  padding-left: 0.5rem;\\n  padding-right: 0.5rem;\\n}\\r\\n.py-2 {\\n  padding-top: 0.5rem;\\n  padding-bottom: 0.5rem;\\n}\\r\\n.py-4 {\\n  padding-top: 1rem;\\n  padding-bottom: 1rem;\\n}\\r\\n.py-20 {\\n  padding-top: 5rem;\\n  padding-bottom: 5rem;\\n}\\r\\n.px-20 {\\n  padding-left: 5rem;\\n  padding-right: 5rem;\\n}\\r\\n.px-8 {\\n  padding-left: 2rem;\\n  padding-right: 2rem;\\n}\\r\\n.py-3 {\\n  padding-top: 0.75rem;\\n  padding-bottom: 0.75rem;\\n}\\r\\n.px-3 {\\n  padding-left: 0.75rem;\\n  padding-right: 0.75rem;\\n}\\r\\n.px-1 {\\n  padding-left: 0.25rem;\\n  padding-right: 0.25rem;\\n}\\r\\n.py-\\\\[5px\\\\] {\\n  padding-top: 5px;\\n  padding-bottom: 5px;\\n}\\r\\n.py-5 {\\n  padding-top: 1.25rem;\\n  padding-bottom: 1.25rem;\\n}\\r\\n.px-10 {\\n  padding-left: 2.5rem;\\n  padding-right: 2.5rem;\\n}\\r\\n.py-1 {\\n  padding-top: 0.25rem;\\n  padding-bottom: 0.25rem;\\n}\\r\\n.pb-4 {\\n  padding-bottom: 1rem;\\n}\\r\\n.pt-2 {\\n  padding-top: 0.5rem;\\n}\\r\\n.pb-14 {\\n  padding-bottom: 3.5rem;\\n}\\r\\n.pb-\\\\[60px\\\\] {\\n  padding-bottom: 60px;\\n}\\r\\n.pb-3 {\\n  padding-bottom: 0.75rem;\\n}\\r\\n.pt-1 {\\n  padding-top: 0.25rem;\\n}\\r\\n.pt-3 {\\n  padding-top: 0.75rem;\\n}\\r\\n.pb-1 {\\n  padding-bottom: 0.25rem;\\n}\\r\\n.pb-2 {\\n  padding-bottom: 0.5rem;\\n}\\r\\n.pl-6 {\\n  padding-left: 1.5rem;\\n}\\r\\n.pl-3 {\\n  padding-left: 0.75rem;\\n}\\r\\n.pl-7 {\\n  padding-left: 1.75rem;\\n}\\r\\n.pr-3 {\\n  padding-right: 0.75rem;\\n}\\r\\n.text-center {\\n  text-align: center;\\n}\\r\\n.font-sans {\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\";\\n}\\r\\n.text-3xl {\\n  font-size: 1.875rem;\\n  line-height: 2.25rem;\\n}\\r\\n.text-sm {\\n  font-size: 0.875rem;\\n  line-height: 1.25rem;\\n}\\r\\n.text-xl {\\n  font-size: 1.25rem;\\n  line-height: 1.75rem;\\n}\\r\\n.text-2xl {\\n  font-size: 1.5rem;\\n  line-height: 2rem;\\n}\\r\\n.text-xs {\\n  font-size: 0.75rem;\\n  line-height: 1rem;\\n}\\r\\n.text-lg {\\n  font-size: 1.125rem;\\n  line-height: 1.75rem;\\n}\\r\\n.text-base {\\n  font-size: 1rem;\\n  line-height: 1.5rem;\\n}\\r\\n.font-bold {\\n  font-weight: 700;\\n}\\r\\n.font-medium {\\n  font-weight: 500;\\n}\\r\\n.font-semibold {\\n  font-weight: 600;\\n}\\r\\n.uppercase {\\n  text-transform: uppercase;\\n}\\r\\n.leading-7 {\\n  line-height: 1.75rem;\\n}\\r\\n.leading-\\\\[1\\\\.8rem\\\\] {\\n  line-height: 1.8rem;\\n}\\r\\n.text-gray-500 {\\n  --tw-text-opacity: 1;\\n  color: rgb(107 114 128 / var(--tw-text-opacity));\\n}\\r\\n.text-blue-300 {\\n  --tw-text-opacity: 1;\\n  color: rgb(147 197 253 / var(--tw-text-opacity));\\n}\\r\\n.text-white {\\n  --tw-text-opacity: 1;\\n  color: rgb(255 255 255 / var(--tw-text-opacity));\\n}\\r\\n.text-gray-600 {\\n  --tw-text-opacity: 1;\\n  color: rgb(75 85 99 / var(--tw-text-opacity));\\n}\\r\\n.text-\\\\[\\\\#666676\\\\] {\\n  --tw-text-opacity: 1;\\n  color: rgb(102 102 118 / var(--tw-text-opacity));\\n}\\r\\n.text-gray-400 {\\n  --tw-text-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-text-opacity));\\n}\\r\\n.text-red-400 {\\n  --tw-text-opacity: 1;\\n  color: rgb(248 113 113 / var(--tw-text-opacity));\\n}\\r\\n.text-blue-500 {\\n  --tw-text-opacity: 1;\\n  color: rgb(59 130 246 / var(--tw-text-opacity));\\n}\\r\\n.text-blue-400 {\\n  --tw-text-opacity: 1;\\n  color: rgb(96 165 250 / var(--tw-text-opacity));\\n}\\r\\n.text-gray-700 {\\n  --tw-text-opacity: 1;\\n  color: rgb(55 65 81 / var(--tw-text-opacity));\\n}\\r\\n.text-black {\\n  --tw-text-opacity: 1;\\n  color: rgb(0 0 0 / var(--tw-text-opacity));\\n}\\r\\n.placeholder-gray-400::-moz-placeholder {\\n  --tw-placeholder-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-placeholder-opacity));\\n}\\r\\n.placeholder-gray-400::placeholder {\\n  --tw-placeholder-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-placeholder-opacity));\\n}\\r\\n.opacity-60 {\\n  opacity: 0.6;\\n}\\r\\n.shadow-sm {\\n  --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);\\n  --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\r\\n.shadow-xl {\\n  --tw-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);\\n  --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\r\\n.ring-2 {\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\n}\\r\\n.ring-yellow-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(234 179 8 / var(--tw-ring-opacity));\\n}\\r\\n.ring-indigo-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(99 102 241 / var(--tw-ring-opacity));\\n}\\r\\n.ring-teal-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(20 184 166 / var(--tw-ring-opacity));\\n}\\r\\n.ring-gray-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(107 114 128 / var(--tw-ring-opacity));\\n}\\r\\n.ring-black {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(0 0 0 / var(--tw-ring-opacity));\\n}\\r\\n.ring-red-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(239 68 68 / var(--tw-ring-opacity));\\n}\\r\\n.ring-blue-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(59 130 246 / var(--tw-ring-opacity));\\n}\\r\\n.ring-offset-2 {\\n  --tw-ring-offset-width: 2px;\\n}\\r\\n.ring-offset-1 {\\n  --tw-ring-offset-width: 1px;\\n}\\r\\n.filter {\\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n}\\r\\n.transition {\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\r\\n.transition-all {\\n  transition-property: all;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\r\\n.duration-\\\\[0ms\\\\] {\\n  transition-duration: 0ms;\\n}\\r\\n.duration-1000 {\\n  transition-duration: 1000ms;\\n}\\r\\n.last\\\\:border-b-0:last-child {\\n  border-bottom-width: 0px;\\n}\\r\\n.odd\\\\:bg-blue-50:nth-child(odd) {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(239 246 255 / var(--tw-bg-opacity));\\n}\\r\\n.hover\\\\:cursor-pointer:hover {\\n  cursor: pointer;\\n}\\r\\n.hover\\\\:border-blue-500:hover {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(59 130 246 / var(--tw-border-opacity));\\n}\\r\\n.hover\\\\:border-gray-400:hover {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(156 163 175 / var(--tw-border-opacity));\\n}\\r\\n.hover\\\\:border-gray-300:hover {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(209 213 219 / var(--tw-border-opacity));\\n}\\r\\n.hover\\\\:bg-gray-50:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(249 250 251 / var(--tw-bg-opacity));\\n}\\r\\n.hover\\\\:bg-teal-500:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(20 184 166 / var(--tw-bg-opacity));\\n}\\r\\n.hover\\\\:bg-gray-200:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(229 231 235 / var(--tw-bg-opacity));\\n}\\r\\n.hover\\\\:bg-gray-100:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(243 244 246 / var(--tw-bg-opacity));\\n}\\r\\n.hover\\\\:bg-white:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\\n}\\r\\n.hover\\\\:text-gray-400:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-text-opacity));\\n}\\r\\n.hover\\\\:text-black:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(0 0 0 / var(--tw-text-opacity));\\n}\\r\\n.hover\\\\:text-blue-500:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(59 130 246 / var(--tw-text-opacity));\\n}\\r\\n.hover\\\\:text-red-500:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(239 68 68 / var(--tw-text-opacity));\\n}\\r\\n.hover\\\\:text-gray-500:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(107 114 128 / var(--tw-text-opacity));\\n}\\r\\n.hover\\\\:text-blue-400:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(96 165 250 / var(--tw-text-opacity));\\n}\\r\\n.hover\\\\:underline:hover {\\n  text-decoration-line: underline;\\n}\\r\\n.focus\\\\:border-blue-400:focus {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(96 165 250 / var(--tw-border-opacity));\\n}\\r\\n.focus\\\\:border-orange-500:focus {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(249 115 22 / var(--tw-border-opacity));\\n}\\r\\n.focus\\\\:bg-red-500:focus {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(239 68 68 / var(--tw-bg-opacity));\\n}\\r\\n.focus\\\\:outline-none:focus {\\n  outline: 2px solid transparent;\\n  outline-offset: 2px;\\n}\\r\\n.focus\\\\:ring-2:focus {\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\n}\\r\\n.focus\\\\:ring-blue-500:focus {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(59 130 246 / var(--tw-ring-opacity));\\n}\\r\\n.focus\\\\:ring-blue-400:focus {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(96 165 250 / var(--tw-ring-opacity));\\n}\\r\\n.focus\\\\:ring-orange-500:focus {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(249 115 22 / var(--tw-ring-opacity));\\n}\\r\\n.focus\\\\:ring-offset-2:focus {\\n  --tw-ring-offset-width: 2px;\\n}\\r\\n.active\\\\:bg-yellow-500:active {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(234 179 8 / var(--tw-bg-opacity));\\n}\\r\\n.peer:checked ~ .peer-checked\\\\:bg-blue-600 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(37 99 235 / var(--tw-bg-opacity));\\n}\\r\\n.peer:checked ~ .peer-checked\\\\:text-white {\\n  --tw-text-opacity: 1;\\n  color: rgb(255 255 255 / var(--tw-text-opacity));\\n}\\r\\n@media (min-width: 640px) {\\n\\n  .sm\\\\:col-span-10 {\\n    grid-column: span 10 / span 10;\\n  }\\n\\n  .sm\\\\:mt-7 {\\n    margin-top: 1.75rem;\\n  }\\n\\n  .sm\\\\:grid {\\n    display: grid;\\n  }\\n\\n  .sm\\\\:max-w-\\\\[380px\\\\] {\\n    max-width: 380px;\\n  }\\n\\n  .sm\\\\:grid-cols-5 {\\n    grid-template-columns: repeat(5, minmax(0, 1fr));\\n  }\\n\\n  .sm\\\\:grid-cols-1 {\\n    grid-template-columns: repeat(1, minmax(0, 1fr));\\n  }\\n\\n  .sm\\\\:grid-cols-3 {\\n    grid-template-columns: repeat(3, minmax(0, 1fr));\\n  }\\n\\n  .sm\\\\:grid-cols-10 {\\n    grid-template-columns: repeat(10, minmax(0, 1fr));\\n  }\\n\\n  .sm\\\\:pl-5 {\\n    padding-left: 1.25rem;\\n  }\\n}\\r\\n@media (min-width: 768px) {\\n\\n  .md\\\\:grid-cols-5 {\\n    grid-template-columns: repeat(5, minmax(0, 1fr));\\n  }\\n\\n  .md\\\\:grid-cols-4 {\\n    grid-template-columns: repeat(4, minmax(0, 1fr));\\n  }\\n\\n  .md\\\\:grid-cols-3 {\\n    grid-template-columns: repeat(3, minmax(0, 1fr));\\n  }\\n\\n  .md\\\\:grid-cols-2 {\\n    grid-template-columns: repeat(2, minmax(0, 1fr));\\n  }\\n}\\r\\n@media (min-width: 1024px) {\\n\\n  .lg\\\\:col-span-1 {\\n    grid-column: span 1 / span 1;\\n  }\\n\\n  .lg\\\\:col-span-10 {\\n    grid-column: span 10 / span 10;\\n  }\\n\\n  .lg\\\\:col-span-5 {\\n    grid-column: span 5 / span 5;\\n  }\\n\\n  .lg\\\\:grid-cols-8 {\\n    grid-template-columns: repeat(8, minmax(0, 1fr));\\n  }\\n\\n  .lg\\\\:grid-cols-6 {\\n    grid-template-columns: repeat(6, minmax(0, 1fr));\\n  }\\n\\n  .lg\\\\:grid-cols-4 {\\n    grid-template-columns: repeat(4, minmax(0, 1fr));\\n  }\\n\\n  .lg\\\\:grid-rows-5 {\\n    grid-template-rows: repeat(5, minmax(0, 1fr));\\n  }\\n\\n  .lg\\\\:px-5 {\\n    padding-left: 1.25rem;\\n    padding-right: 1.25rem;\\n  }\\n\\n  .lg\\\\:px-0 {\\n    padding-left: 0px;\\n    padding-right: 0px;\\n  }\\n}\\r\\n@media (min-width: 1280px) {\\n\\n  .xl\\\\:grid-cols-5 {\\n    grid-template-columns: repeat(5, minmax(0, 1fr));\\n  }\\n\\n  .xl\\\\:grid-cols-3 {\\n    grid-template-columns: repeat(3, minmax(0, 1fr));\\n  }\\n}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://styles/globals.css\",\"<no source>\"],\"names\":[],\"mappings\":\"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AAAmB;AAAnB;EAAA,mBAAmB;EAAnB;AAAmB;AAAnB;EAAA,mBAAmB;EAAnB;AAAmB;AAAnB;EAAA,mBAAmB;EAAnB;AAAmB;AAAnB;EAAA,oBAAmB;EAAnB;AAAmB;AAAnB;EAAA,mBAAmB;EAAnB;AAAmB;AAAnB;EAAA,mBAAmB;EAAnB;AAAmB;AAAnB;EAAA,iBAAmB;EAAnB;AAAmB;AAAnB;EAAA,gBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,wBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,wBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA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CCAA;ADAA;EAAA,uBCAA;EDAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA;CCAA;ADAA;EAAA,uBCAA;EDAA;CCAA;ADAA;EAAA,uBCAA;EDAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,+BCAA;EDAA;CCAA;ADAA;EAAA,4GCAA;EDAA,0GCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;;EAAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;CAAA;ADAA;;EAAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;CAAA;ADAA;;EAAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA,sBCAA;IDAA;GCAA;;EDAA;IAAA,kBCAA;IDAA;GCAA;CAAA;ADAA;;EAAA;IAAA;GCAA;;EDAA;IAAA;GCAA;CAAA\",\"sourcesContent\":[\"@tailwind base;\\r\\n@tailwind components;\\r\\n@tailwind utilities;\\r\\n\",null],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls4XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOF0udXNlWzJdIS4vc3R5bGVzL2dsb2JhbHMuY3NzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ3dIO0FBQ3hILDhCQUE4QixrSEFBMkI7QUFDekQ7QUFDQSwwWEFBMFgsNEJBQTRCLDRCQUE0QixnQ0FBZ0Msa0NBQWtDLFVBQVUsd0JBQXdCLHFCQUFxQixHQUFHLHFQQUFxUCxzQkFBc0IsMkNBQTJDLDZCQUE2QiwwQkFBMEIsb0JBQW9CLHVQQUF1UCxVQUFVLGdLQUFnSyxlQUFlLGlDQUFpQyxVQUFVLDJOQUEyTixlQUFlLDJCQUEyQixrQ0FBa0MsVUFBVSxpR0FBaUcsOENBQThDLDhDQUE4QyxHQUFHLGtHQUFrRyx1QkFBdUIseUJBQXlCLEdBQUcsaUZBQWlGLG1CQUFtQiw2QkFBNkIsR0FBRywyRUFBMkUsd0JBQXdCLEdBQUcsMEpBQTBKLHlIQUF5SCwyQkFBMkIsVUFBVSxpRUFBaUUsbUJBQW1CLEdBQUcsMkdBQTJHLG1CQUFtQixtQkFBbUIsdUJBQXVCLDZCQUE2QixHQUFHLFNBQVMsb0JBQW9CLEdBQUcsU0FBUyxnQkFBZ0IsR0FBRyxnYkFBZ2Isb0JBQW9CLGtDQUFrQyxzQ0FBc0MsVUFBVSxrTUFBa00sMEJBQTBCLDRCQUE0QixpQ0FBaUMsaUNBQWlDLDJCQUEyQixzQkFBc0IsdUJBQXVCLFVBQVUsOEZBQThGLHlCQUF5QixHQUFHLG1MQUFtTCxnQ0FBZ0MsMENBQTBDLG1DQUFtQyxVQUFVLCtGQUErRixrQkFBa0IsR0FBRywrTUFBK00scUJBQXFCLEdBQUcsbUZBQW1GLDZC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QUFxQixxQkFBcUIsb0JBQW9CLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sTUFBTSxXQUFXLE1BQU0sT0FBTyxNQUFNLFFBQVEscUJBQXFCLHFCQUFxQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sS0FBSyxVQUFVLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLE1BQU0sT0FBTyxNQUFNLEtBQUsscUJBQXFCLHFCQUFxQixNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxPQUFPLE1BQU0sS0FBSyxxQkFBcUIsb0JBQW9CLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE1BQU0sTUFBTSxpQkFBaUIsVUFBVSxNQUFNLEtBQUssVUFBVSxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sT0FBTyxXQUFXLFVBQVUsVUFBVSxNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxPQUFPLE1BQU0sS0FBSyxvQkFBb0Isb0JBQW9CLE1BQU0sTUFBTSxvQkFBb0Isb0JBQW9CLE1BQU0sTUFBTSxNQUFNLE1BQU0sVUFBVSxNQUFNLE1BQU0sS0FBSyxLQUFLLFVBQVUsTUFBTSxRQUFRLE1BQU0sWUFBWSxvQkFBb0IscUJBQXFCLE1BQU0sTUFBTSxNQUFNLE1BQU0sVUFBVSxVQUFVLE1BQU0sS0FBSyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLEtBQUssTUFBTSxLQUFLLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxXQUFXLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLGFBQWEsYUFBYSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssV0FBVyxLQUFLLE1BQU0sS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLEtBQUssd0NBQXdDLHlCQUF5Qix3QkFBd0IsNEJBQTRCO0FBQzdsNUM7QUFDQSwrREFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zdHlsZXMvZ2xvYmFscy5jc3M/NGJhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLypcXG4hIHRhaWx3aW5kY3NzIHYzLjEuOCB8IE1JVCBMaWNlbnNlIHwgaHR0cHM6Ly90YWlsd2luZGNzcy5jb21cXG4qLy8qXFxuMS4gUHJldmVudCBwYWRkaW5nIGFuZCBib3JkZXIgZnJvbSBhZmZlY3RpbmcgZWxlbWVudCB3aWR0aC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3pkZXZzL2Nzc3JlbWVkeS9pc3N1ZXMvNClcXG4yLiBBbGxvdyBhZGRpbmcgYSBib3JkZXIgdG8gYW4gZWxlbWVudCBieSBqdXN0IGFkZGluZyBhIGJvcmRlci13aWR0aC4gKGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGNzcy90YWlsd2luZGNzcy9wdWxsLzExNilcXG4qL1xcblxcbiosXFxuOjpiZWZvcmUsXFxuOjphZnRlciB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyAvKiAxICovXFxuICBib3JkZXItd2lkdGg6IDA7IC8qIDIgKi9cXG4gIGJvcmRlci1zdHlsZTogc29saWQ7IC8qIDIgKi9cXG4gIGJvcmRlci1jb2xvcjogI2U1ZTdlYjsgLyogMiAqL1xcbn1cXG5cXG46OmJlZm9yZSxcXG46OmFmdGVyIHtcXG4gIC0tdHctY29udGVudDogJyc7XFxufVxcblxcbi8qXFxuMS4gVXNlIGEgY29uc2lzdGVudCBzZW5zaWJsZSBsaW5lLWhlaWdodCBpbiBhbGwgYnJvd3NlcnMuXFxuMi4gUHJldmVudCBhZGp1c3RtZW50cyBvZiBmb250IHNpemUgYWZ0ZXIgb3JpZW50YXRpb24gY2hhbmdlcyBpbiBpT1MuXFxuMy4gVXNlIGEgbW9yZSByZWFkYWJsZSB0YWIgc2l6ZS5cXG40LiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIGBzYW5zYCBmb250LWZhbWlseSBieSBkZWZhdWx0LlxcbiovXFxuXFxuaHRtbCB7XFxuICBsaW5lLWhlaWdodDogMS41OyAvKiAxICovXFxuICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7IC8qIDIgKi9cXG4gIC1tb3otdGFiLXNpemU6IDQ7IC8qIDMgKi9cXG4gIC1vLXRhYi1zaXplOiA0O1xcbiAgICAgdGFiLXNpemU6IDQ7IC8qIDMgKi9cXG4gIGZvbnQtZmFtaWx5OiB1aS1zYW5zLXNlcmlmLCBzeXN0ZW0tdWksIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXFxcIlNlZ29lIFVJXFxcIiwgUm9ib3RvLCBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBBcmlhbCwgXFxcIk5vdG8gU2Fuc1xcXCIsIHNhbnMtc2VyaWYsIFxcXCJBcHBsZSBDb2xvciBFbW9qaVxcXCIsIFxcXCJTZWdvZSBVSSBFbW9qaVxcXCIsIFxcXCJTZWdvZSBVSSBTeW1ib2xcXFwiLCBcXFwiTm90byBDb2xvciBFbW9qaVxcXCI7IC8qIDQgKi9cXG59XFxuXFxuLypcXG4xLiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBhbGwgYnJvd3NlcnMuXFxuMi4gSW5oZXJpdCBsaW5lLWhlaWdodCBmcm9tIGBodG1sYCBzbyB1c2VycyBjYW4gc2V0IHRoZW0gYXMgYSBjbGFzcyBkaXJlY3RseSBvbiB0aGUgYGh0bWxgIGVsZW1lbnQuXFxuKi9cXG5cXG5ib2R5IHtcXG4gIG1hcmdpbjogMDsgLyogMSAqL1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IC8qIDIgKi9cXG59XFxuXFxuLypcXG4xLiBBZGQgdGhlIGNvcnJlY3QgaGVpZ2h0IGluIEZpcmVmb3guXFxuMi4gQ29ycmVjdCB0aGUgaW5oZXJpdGFuY2Ugb2YgYm9yZGVyIGNvbG9yIGluIEZpcmVmb3guIChodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xOTA2NTUpXFxuMy4gRW5zdXJlIGhvcml6b250YWwgcnVsZXMgYXJlIHZpc2libGUgYnkgZGVmYXVsdC5cXG4qL1xcblxcbmhyIHtcXG4gIGhlaWdodDogMDsgLyogMSAqL1xcbiAgY29sb3I6IGluaGVyaXQ7IC8qIDIgKi9cXG4gIGJvcmRlci10b3Atd2lkdGg6IDFweDsgLyogMyAqL1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCB0ZXh0IGRlY29yYXRpb24gaW4gQ2hyb21lLCBFZGdlLCBhbmQgU2FmYXJpLlxcbiovXFxuXFxuYWJicjp3aGVyZShbdGl0bGVdKSB7XFxuICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbn1cXG5cXG4vKlxcblJlbW92ZSB0aGUgZGVmYXVsdCBmb250IHNpemUgYW5kIHdlaWdodCBmb3IgaGVhZGluZ3MuXFxuKi9cXG5cXG5oMSxcXG5oMixcXG5oMyxcXG5oNCxcXG5oNSxcXG5oNiB7XFxuICBmb250LXNpemU6IGluaGVyaXQ7XFxuICBmb250LXdlaWdodDogaW5oZXJpdDtcXG59XFxuXFxuLypcXG5SZXNldCBsaW5rcyB0byBvcHRpbWl6ZSBmb3Igb3B0LWluIHN0eWxpbmcgaW5zdGVhZCBvZiBvcHQtb3V0LlxcbiovXFxuXFxuYSB7XFxuICBjb2xvcjogaW5oZXJpdDtcXG4gIHRleHQtZGVjb3JhdGlvbjogaW5oZXJpdDtcXG59XFxuXFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgZm9udCB3ZWlnaHQgaW4gRWRnZSBhbmQgU2FmYXJpLlxcbiovXFxuXFxuYixcXG5zdHJvbmcge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG59XFxuXFxuLypcXG4xLiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIGBtb25vYCBmb250IGZhbWlseSBieSBkZWZhdWx0LlxcbjIuIENvcnJlY3QgdGhlIG9kZCBgZW1gIGZvbnQgc2l6aW5nIGluIGFsbCBicm93c2Vycy5cXG4qL1xcblxcbmNvZGUsXFxua2JkLFxcbnNhbXAsXFxucHJlIHtcXG4gIGZvbnQtZmFtaWx5OiB1aS1tb25vc3BhY2UsIFNGTW9uby1SZWd1bGFyLCBNZW5sbywgTW9uYWNvLCBDb25zb2xhcywgXFxcIkxpYmVyYXRpb24gTW9ub1xcXCIsIFxcXCJDb3VyaWVyIE5ld1xcXCIsIG1vbm9zcGFjZTsgLyogMSAqL1xcbiAgZm9udC1zaXplOiAxZW07IC8qIDIgKi9cXG59XFxuXFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cXG4qL1xcblxcbnNtYWxsIHtcXG4gIGZvbnQtc2l6ZTogODAlO1xcbn1cXG5cXG4vKlxcblByZXZlbnQgYHN1YmAgYW5kIGBzdXBgIGVsZW1lbnRzIGZyb20gYWZmZWN0aW5nIHRoZSBsaW5lIGhlaWdodCBpbiBhbGwgYnJvd3NlcnMuXFxuKi9cXG5cXG5zdWIsXFxuc3VwIHtcXG4gIGZvbnQtc2l6ZTogNzUlO1xcbiAgbGluZS1oZWlnaHQ6IDA7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxufVxcblxcbnN1YiB7XFxuICBib3R0b206IC0wLjI1ZW07XFxufVxcblxcbnN1cCB7XFxuICB0b3A6IC0wLjVlbTtcXG59XFxuXFxuLypcXG4xLiBSZW1vdmUgdGV4dCBpbmRlbnRhdGlvbiBmcm9tIHRhYmxlIGNvbnRlbnRzIGluIENocm9tZSBhbmQgU2FmYXJpLiAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTk5MDg4LCBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjAxMjk3KVxcbjIuIENvcnJlY3QgdGFibGUgYm9yZGVyIGNvbG9yIGluaGVyaXRhbmNlIGluIGFsbCBDaHJvbWUgYW5kIFNhZmFyaS4gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTkzNTcyOSwgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE5NTAxNilcXG4zLiBSZW1vdmUgZ2FwcyBiZXR3ZWVuIHRhYmxlIGJvcmRlcnMgYnkgZGVmYXVsdC5cXG4qL1xcblxcbnRhYmxlIHtcXG4gIHRleHQtaW5kZW50OiAwOyAvKiAxICovXFxuICBib3JkZXItY29sb3I6IGluaGVyaXQ7IC8qIDIgKi9cXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7IC8qIDMgKi9cXG59XFxuXFxuLypcXG4xLiBDaGFuZ2UgdGhlIGZvbnQgc3R5bGVzIGluIGFsbCBicm93c2Vycy5cXG4yLiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBGaXJlZm94IGFuZCBTYWZhcmkuXFxuMy4gUmVtb3ZlIGRlZmF1bHQgcGFkZGluZyBpbiBhbGwgYnJvd3NlcnMuXFxuKi9cXG5cXG5idXR0b24sXFxuaW5wdXQsXFxub3B0Z3JvdXAsXFxuc2VsZWN0LFxcbnRleHRhcmVhIHtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0OyAvKiAxICovXFxuICBmb250LXNpemU6IDEwMCU7IC8qIDEgKi9cXG4gIGZvbnQtd2VpZ2h0OiBpbmhlcml0OyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgLyogMSAqL1xcbiAgY29sb3I6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIG1hcmdpbjogMDsgLyogMiAqL1xcbiAgcGFkZGluZzogMDsgLyogMyAqL1xcbn1cXG5cXG4vKlxcblJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRWRnZSBhbmQgRmlyZWZveC5cXG4qL1xcblxcbmJ1dHRvbixcXG5zZWxlY3Qge1xcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxufVxcblxcbi8qXFxuMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4yLiBSZW1vdmUgZGVmYXVsdCBidXR0b24gc3R5bGVzLlxcbiovXFxuXFxuYnV0dG9uLFxcblt0eXBlPSdidXR0b24nXSxcXG5bdHlwZT0ncmVzZXQnXSxcXG5bdHlwZT0nc3VibWl0J10ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247IC8qIDEgKi9cXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyAvKiAyICovXFxuICBiYWNrZ3JvdW5kLWltYWdlOiBub25lOyAvKiAyICovXFxufVxcblxcbi8qXFxuVXNlIHRoZSBtb2Rlcm4gRmlyZWZveCBmb2N1cyBzdHlsZSBmb3IgYWxsIGZvY3VzYWJsZSBlbGVtZW50cy5cXG4qL1xcblxcbjotbW96LWZvY3VzcmluZyB7XFxuICBvdXRsaW5lOiBhdXRvO1xcbn1cXG5cXG4vKlxcblJlbW92ZSB0aGUgYWRkaXRpb25hbCBgOmludmFsaWRgIHN0eWxlcyBpbiBGaXJlZm94LiAoaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvZ2Vja28tZGV2L2Jsb2IvMmY5ZWFjZDlkM2Q5OTVjOTM3YjQyNTFhNTU1N2Q5NWQ0OTRjOWJlMS9sYXlvdXQvc3R5bGUvcmVzL2Zvcm1zLmNzcyNMNzI4LUw3MzcpXFxuKi9cXG5cXG46LW1vei11aS1pbnZhbGlkIHtcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxufVxcblxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IHZlcnRpY2FsIGFsaWdubWVudCBpbiBDaHJvbWUgYW5kIEZpcmVmb3guXFxuKi9cXG5cXG5wcm9ncmVzcyB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxufVxcblxcbi8qXFxuQ29ycmVjdCB0aGUgY3Vyc29yIHN0eWxlIG9mIGluY3JlbWVudCBhbmQgZGVjcmVtZW50IGJ1dHRvbnMgaW4gU2FmYXJpLlxcbiovXFxuXFxuOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxcbjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XFxuICBoZWlnaHQ6IGF1dG87XFxufVxcblxcbi8qXFxuMS4gQ29ycmVjdCB0aGUgb2RkIGFwcGVhcmFuY2UgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXFxuMi4gQ29ycmVjdCB0aGUgb3V0bGluZSBzdHlsZSBpbiBTYWZhcmkuXFxuKi9cXG5cXG5bdHlwZT0nc2VhcmNoJ10ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7IC8qIDEgKi9cXG4gIG91dGxpbmUtb2Zmc2V0OiAtMnB4OyAvKiAyICovXFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBpbm5lciBwYWRkaW5nIGluIENocm9tZSBhbmQgU2FmYXJpIG9uIG1hY09TLlxcbiovXFxuXFxuOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG59XFxuXFxuLypcXG4xLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxcbjIuIENoYW5nZSBmb250IHByb3BlcnRpZXMgdG8gYGluaGVyaXRgIGluIFNhZmFyaS5cXG4qL1xcblxcbjo6LXdlYmtpdC1maWxlLXVwbG9hZC1idXR0b24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247IC8qIDEgKi9cXG4gIGZvbnQ6IGluaGVyaXQ7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBDaHJvbWUgYW5kIFNhZmFyaS5cXG4qL1xcblxcbnN1bW1hcnkge1xcbiAgZGlzcGxheTogbGlzdC1pdGVtO1xcbn1cXG5cXG4vKlxcblJlbW92ZXMgdGhlIGRlZmF1bHQgc3BhY2luZyBhbmQgYm9yZGVyIGZvciBhcHByb3ByaWF0ZSBlbGVtZW50cy5cXG4qL1xcblxcbmJsb2NrcXVvdGUsXFxuZGwsXFxuZGQsXFxuaDEsXFxuaDIsXFxuaDMsXFxuaDQsXFxuaDUsXFxuaDYsXFxuaHIsXFxuZmlndXJlLFxcbnAsXFxucHJlIHtcXG4gIG1hcmdpbjogMDtcXG59XFxuXFxuZmllbGRzZXQge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxubGVnZW5kIHtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbm9sLFxcbnVsLFxcbm1lbnUge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbi8qXFxuUHJldmVudCByZXNpemluZyB0ZXh0YXJlYXMgaG9yaXpvbnRhbGx5IGJ5IGRlZmF1bHQuXFxuKi9cXG5cXG50ZXh0YXJlYSB7XFxuICByZXNpemU6IHZlcnRpY2FsO1xcbn1cXG5cXG4vKlxcbjEuIFJlc2V0IHRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIG9wYWNpdHkgaW4gRmlyZWZveC4gKGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MvaXNzdWVzLzMzMDApXFxuMi4gU2V0IHRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIGNvbG9yIHRvIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBncmF5IDQwMCBjb2xvci5cXG4qL1xcblxcbmlucHV0OjotbW96LXBsYWNlaG9sZGVyLCB0ZXh0YXJlYTo6LW1vei1wbGFjZWhvbGRlciB7XFxuICBvcGFjaXR5OiAxOyAvKiAxICovXFxuICBjb2xvcjogIzljYTNhZjsgLyogMiAqL1xcbn1cXG5cXG5pbnB1dDo6cGxhY2Vob2xkZXIsXFxudGV4dGFyZWE6OnBsYWNlaG9sZGVyIHtcXG4gIG9wYWNpdHk6IDE7IC8qIDEgKi9cXG4gIGNvbG9yOiAjOWNhM2FmOyAvKiAyICovXFxufVxcblxcbi8qXFxuU2V0IHRoZSBkZWZhdWx0IGN1cnNvciBmb3IgYnV0dG9ucy5cXG4qL1xcblxcbmJ1dHRvbixcXG5bcm9sZT1cXFwiYnV0dG9uXFxcIl0ge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4vKlxcbk1ha2Ugc3VyZSBkaXNhYmxlZCBidXR0b25zIGRvbid0IGdldCB0aGUgcG9pbnRlciBjdXJzb3IuXFxuKi9cXG46ZGlzYWJsZWQge1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG5cXG4vKlxcbjEuIE1ha2UgcmVwbGFjZWQgZWxlbWVudHMgYGRpc3BsYXk6IGJsb2NrYCBieSBkZWZhdWx0LiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy8xNClcXG4yLiBBZGQgYHZlcnRpY2FsLWFsaWduOiBtaWRkbGVgIHRvIGFsaWduIHJlcGxhY2VkIGVsZW1lbnRzIG1vcmUgc2Vuc2libHkgYnkgZGVmYXVsdC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9qZW5zaW1tb25zL2Nzc3JlbWVkeS9pc3N1ZXMvMTQjaXNzdWVjb21tZW50LTYzNDkzNDIxMClcXG4gICBUaGlzIGNhbiB0cmlnZ2VyIGEgcG9vcmx5IGNvbnNpZGVyZWQgbGludCBlcnJvciBpbiBzb21lIHRvb2xzIGJ1dCBpcyBpbmNsdWRlZCBieSBkZXNpZ24uXFxuKi9cXG5cXG5pbWcsXFxuc3ZnLFxcbnZpZGVvLFxcbmNhbnZhcyxcXG5hdWRpbyxcXG5pZnJhbWUsXFxuZW1iZWQsXFxub2JqZWN0IHtcXG4gIGRpc3BsYXk6IGJsb2NrOyAvKiAxICovXFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyAvKiAyICovXFxufVxcblxcbi8qXFxuQ29uc3RyYWluIGltYWdlcyBhbmQgdmlkZW9zIHRvIHRoZSBwYXJlbnQgd2lkdGggYW5kIHByZXNlcnZlIHRoZWlyIGludHJpbnNpYyBhc3BlY3QgcmF0aW8uIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzE0KVxcbiovXFxuXFxuaW1nLFxcbnZpZGVvIHtcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuKiwgOjpiZWZvcmUsIDo6YWZ0ZXIge1xcbiAgLS10dy1ib3JkZXItc3BhY2luZy14OiAwO1xcbiAgLS10dy1ib3JkZXItc3BhY2luZy15OiAwO1xcbiAgLS10dy10cmFuc2xhdGUteDogMDtcXG4gIC0tdHctdHJhbnNsYXRlLXk6IDA7XFxuICAtLXR3LXJvdGF0ZTogMDtcXG4gIC0tdHctc2tldy14OiAwO1xcbiAgLS10dy1za2V3LXk6IDA7XFxuICAtLXR3LXNjYWxlLXg6IDE7XFxuICAtLXR3LXNjYWxlLXk6IDE7XFxuICAtLXR3LXBhbi14OiAgO1xcbiAgLS10dy1wYW4teTogIDtcXG4gIC0tdHctcGluY2gtem9vbTogIDtcXG4gIC0tdHctc2Nyb2xsLXNuYXAtc3RyaWN0bmVzczogcHJveGltaXR5O1xcbiAgLS10dy1vcmRpbmFsOiAgO1xcbiAgLS10dy1zbGFzaGVkLXplcm86ICA7XFxuICAtLXR3LW51bWVyaWMtZmlndXJlOiAgO1xcbiAgLS10dy1udW1lcmljLXNwYWNpbmc6ICA7XFxuICAtLXR3LW51bWVyaWMtZnJhY3Rpb246ICA7XFxuICAtLXR3LXJpbmctaW5zZXQ6ICA7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAwcHg7XFxuICAtLXR3LXJpbmctb2Zmc2V0LWNvbG9yOiAjZmZmO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIDAuNSk7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1yaW5nLXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMCAjMDAwMDtcXG4gIC0tdHctYmx1cjogIDtcXG4gIC0tdHctYnJpZ2h0bmVzczogIDtcXG4gIC0tdHctY29udHJhc3Q6ICA7XFxuICAtLXR3LWdyYXlzY2FsZTogIDtcXG4gIC0tdHctaHVlLXJvdGF0ZTogIDtcXG4gIC0tdHctaW52ZXJ0OiAgO1xcbiAgLS10dy1zYXR1cmF0ZTogIDtcXG4gIC0tdHctc2VwaWE6ICA7XFxuICAtLXR3LWRyb3Atc2hhZG93OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1ibHVyOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1jb250cmFzdDogIDtcXG4gIC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1odWUtcm90YXRlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1pbnZlcnQ6ICA7XFxuICAtLXR3LWJhY2tkcm9wLW9wYWNpdHk6ICA7XFxuICAtLXR3LWJhY2tkcm9wLXNhdHVyYXRlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1zZXBpYTogIDtcXG59XFxuXFxuOjpiYWNrZHJvcCB7XFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXg6IDA7XFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXk6IDA7XFxuICAtLXR3LXRyYW5zbGF0ZS14OiAwO1xcbiAgLS10dy10cmFuc2xhdGUteTogMDtcXG4gIC0tdHctcm90YXRlOiAwO1xcbiAgLS10dy1za2V3LXg6IDA7XFxuICAtLXR3LXNrZXcteTogMDtcXG4gIC0tdHctc2NhbGUteDogMTtcXG4gIC0tdHctc2NhbGUteTogMTtcXG4gIC0tdHctcGFuLXg6ICA7XFxuICAtLXR3LXBhbi15OiAgO1xcbiAgLS10dy1waW5jaC16b29tOiAgO1xcbiAgLS10dy1zY3JvbGwtc25hcC1zdHJpY3RuZXNzOiBwcm94aW1pdHk7XFxuICAtLXR3LW9yZGluYWw6ICA7XFxuICAtLXR3LXNsYXNoZWQtemVybzogIDtcXG4gIC0tdHctbnVtZXJpYy1maWd1cmU6ICA7XFxuICAtLXR3LW51bWVyaWMtc3BhY2luZzogIDtcXG4gIC0tdHctbnVtZXJpYy1mcmFjdGlvbjogIDtcXG4gIC0tdHctcmluZy1pbnNldDogIDtcXG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDBweDtcXG4gIC0tdHctcmluZy1vZmZzZXQtY29sb3I6ICNmZmY7XFxuICAtLXR3LXJpbmctY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gMC41KTtcXG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXJpbmctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAwICMwMDAwO1xcbiAgLS10dy1ibHVyOiAgO1xcbiAgLS10dy1icmlnaHRuZXNzOiAgO1xcbiAgLS10dy1jb250cmFzdDogIDtcXG4gIC0tdHctZ3JheXNjYWxlOiAgO1xcbiAgLS10dy1odWUtcm90YXRlOiAgO1xcbiAgLS10dy1pbnZlcnQ6ICA7XFxuICAtLXR3LXNhdHVyYXRlOiAgO1xcbiAgLS10dy1zZXBpYTogIDtcXG4gIC0tdHctZHJvcC1zaGFkb3c6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWJsdXI6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3M6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWNvbnRyYXN0OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1ncmF5c2NhbGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWludmVydDogIDtcXG4gIC0tdHctYmFja2Ryb3Atb3BhY2l0eTogIDtcXG4gIC0tdHctYmFja2Ryb3Atc2F0dXJhdGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLXNlcGlhOiAgO1xcbn1cXHJcXG4ucG9pbnRlci1ldmVudHMtbm9uZSB7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxyXFxuLmZpeGVkIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG59XFxyXFxuLmFic29sdXRlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxyXFxuLnJlbGF0aXZlIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxyXFxuLi10b3AtMyB7XFxuICB0b3A6IC0wLjc1cmVtO1xcbn1cXHJcXG4uLXRvcC01IHtcXG4gIHRvcDogLTEuMjVyZW07XFxufVxcclxcbi4tdG9wLTE2IHtcXG4gIHRvcDogLTRyZW07XFxufVxcclxcbi5ib3R0b20tXFxcXFsxNlxcXFwuMnJlbVxcXFxdIHtcXG4gIGJvdHRvbTogMTYuMnJlbTtcXG59XFxyXFxuLnJpZ2h0LTAge1xcbiAgcmlnaHQ6IDBweDtcXG59XFxyXFxuLnJpZ2h0LTI0IHtcXG4gIHJpZ2h0OiA2cmVtO1xcbn1cXHJcXG4ubGVmdC0xXFxcXC8yIHtcXG4gIGxlZnQ6IDUwJTtcXG59XFxyXFxuLnJpZ2h0LTFcXFxcLzIge1xcbiAgcmlnaHQ6IDUwJTtcXG59XFxyXFxuLmJvdHRvbS0zNiB7XFxuICBib3R0b206IDlyZW07XFxufVxcclxcbi50b3AtXFxcXFs4NVxcXFwlXFxcXF0ge1xcbiAgdG9wOiA4NSU7XFxufVxcclxcbi5ib3R0b20tXFxcXFsxN1xcXFwuMnJlbVxcXFxdIHtcXG4gIGJvdHRvbTogMTcuMnJlbTtcXG59XFxyXFxuLmJvdHRvbS0wIHtcXG4gIGJvdHRvbTogMHB4O1xcbn1cXHJcXG4udG9wLTAge1xcbiAgdG9wOiAwcHg7XFxufVxcclxcbi5yaWdodC05IHtcXG4gIHJpZ2h0OiAyLjI1cmVtO1xcbn1cXHJcXG4ubGVmdC0wIHtcXG4gIGxlZnQ6IDBweDtcXG59XFxyXFxuLnotMTAge1xcbiAgei1pbmRleDogMTA7XFxufVxcclxcbi56LTIwIHtcXG4gIHotaW5kZXg6IDIwO1xcbn1cXHJcXG4uY29sLXNwYW4tMiB7XFxuICBncmlkLWNvbHVtbjogc3BhbiAyIC8gc3BhbiAyO1xcbn1cXHJcXG4uY29sLXNwYW4tMyB7XFxuICBncmlkLWNvbHVtbjogc3BhbiAzIC8gc3BhbiAzO1xcbn1cXHJcXG4uY29sLXNwYW4tMTIge1xcbiAgZ3JpZC1jb2x1bW46IHNwYW4gMTIgLyBzcGFuIDEyO1xcbn1cXHJcXG4uY29sLXNwYW4tMTAge1xcbiAgZ3JpZC1jb2x1bW46IHNwYW4gMTAgLyBzcGFuIDEwO1xcbn1cXHJcXG4uY29sLXNwYW4tNCB7XFxuICBncmlkLWNvbHVtbjogc3BhbiA0IC8gc3BhbiA0O1xcbn1cXHJcXG4uY29sLXNwYW4tNiB7XFxuICBncmlkLWNvbHVtbjogc3BhbiA2IC8gc3BhbiA2O1xcbn1cXHJcXG4uY29sLXNwYW4tNyB7XFxuICBncmlkLWNvbHVtbjogc3BhbiA3IC8gc3BhbiA3O1xcbn1cXHJcXG4ucm93LXNwYW4tMyB7XFxuICBncmlkLXJvdzogc3BhbiAzIC8gc3BhbiAzO1xcbn1cXHJcXG4ubXktMiB7XFxuICBtYXJnaW4tdG9wOiAwLjVyZW07XFxuICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxufVxcclxcbi5teC1hdXRvIHtcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbn1cXHJcXG4ubXgtMyB7XFxuICBtYXJnaW4tbGVmdDogMC43NXJlbTtcXG4gIG1hcmdpbi1yaWdodDogMC43NXJlbTtcXG59XFxyXFxuLm14LTUge1xcbiAgbWFyZ2luLWxlZnQ6IDEuMjVyZW07XFxuICBtYXJnaW4tcmlnaHQ6IDEuMjVyZW07XFxufVxcclxcbi5teC0xIHtcXG4gIG1hcmdpbi1sZWZ0OiAwLjI1cmVtO1xcbiAgbWFyZ2luLXJpZ2h0OiAwLjI1cmVtO1xcbn1cXHJcXG4ubXktMSB7XFxuICBtYXJnaW4tdG9wOiAwLjI1cmVtO1xcbiAgbWFyZ2luLWJvdHRvbTogMC4yNXJlbTtcXG59XFxyXFxuLm14LTIge1xcbiAgbWFyZ2luLWxlZnQ6IDAuNXJlbTtcXG4gIG1hcmdpbi1yaWdodDogMC41cmVtO1xcbn1cXHJcXG4ubXktNyB7XFxuICBtYXJnaW4tdG9wOiAxLjc1cmVtO1xcbiAgbWFyZ2luLWJvdHRvbTogMS43NXJlbTtcXG59XFxyXFxuLm14LVxcXFxbMFxcXFwuMzVyZW1cXFxcXSB7XFxuICBtYXJnaW4tbGVmdDogMC4zNXJlbTtcXG4gIG1hcmdpbi1yaWdodDogMC4zNXJlbTtcXG59XFxyXFxuLm15LTMge1xcbiAgbWFyZ2luLXRvcDogMC43NXJlbTtcXG4gIG1hcmdpbi1ib3R0b206IDAuNzVyZW07XFxufVxcclxcbi5teC0xMCB7XFxuICBtYXJnaW4tbGVmdDogMi41cmVtO1xcbiAgbWFyZ2luLXJpZ2h0OiAyLjVyZW07XFxufVxcclxcbi5teC04IHtcXG4gIG1hcmdpbi1sZWZ0OiAycmVtO1xcbiAgbWFyZ2luLXJpZ2h0OiAycmVtO1xcbn1cXHJcXG4ubXktMTIge1xcbiAgbWFyZ2luLXRvcDogM3JlbTtcXG4gIG1hcmdpbi1ib3R0b206IDNyZW07XFxufVxcclxcbi5tdC0xNiB7XFxuICBtYXJnaW4tdG9wOiA0cmVtO1xcbn1cXHJcXG4ubXQtMTIge1xcbiAgbWFyZ2luLXRvcDogM3JlbTtcXG59XFxyXFxuLm10LTgge1xcbiAgbWFyZ2luLXRvcDogMnJlbTtcXG59XFxyXFxuLm10LTIge1xcbiAgbWFyZ2luLXRvcDogMC41cmVtO1xcbn1cXHJcXG4ubXItNSB7XFxuICBtYXJnaW4tcmlnaHQ6IDEuMjVyZW07XFxufVxcclxcbi5tdC01IHtcXG4gIG1hcmdpbi10b3A6IDEuMjVyZW07XFxufVxcclxcbi4tbXQtMTQge1xcbiAgbWFyZ2luLXRvcDogLTMuNXJlbTtcXG59XFxyXFxuLi1tYi01IHtcXG4gIG1hcmdpbi1ib3R0b206IC0xLjI1cmVtO1xcbn1cXHJcXG4ubWItNSB7XFxuICBtYXJnaW4tYm90dG9tOiAxLjI1cmVtO1xcbn1cXHJcXG4ubXQtMyB7XFxuICBtYXJnaW4tdG9wOiAwLjc1cmVtO1xcbn1cXHJcXG4ubXQtMTAge1xcbiAgbWFyZ2luLXRvcDogMi41cmVtO1xcbn1cXHJcXG4ubXQtNyB7XFxuICBtYXJnaW4tdG9wOiAxLjc1cmVtO1xcbn1cXHJcXG4ubWItMTAge1xcbiAgbWFyZ2luLWJvdHRvbTogMi41cmVtO1xcbn1cXHJcXG4ubXQtMSB7XFxuICBtYXJnaW4tdG9wOiAwLjI1cmVtO1xcbn1cXHJcXG4ubXQtNCB7XFxuICBtYXJnaW4tdG9wOiAxcmVtO1xcbn1cXHJcXG4ubWwtMSB7XFxuICBtYXJnaW4tbGVmdDogMC4yNXJlbTtcXG59XFxyXFxuLm1iLTcge1xcbiAgbWFyZ2luLWJvdHRvbTogMS43NXJlbTtcXG59XFxyXFxuLm1iLTIge1xcbiAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbn1cXHJcXG4ubXItMTYge1xcbiAgbWFyZ2luLXJpZ2h0OiA0cmVtO1xcbn1cXHJcXG4ubWwtNSB7XFxuICBtYXJnaW4tbGVmdDogMS4yNXJlbTtcXG59XFxyXFxuLm10LVxcXFxbMTVweFxcXFxdIHtcXG4gIG1hcmdpbi10b3A6IDE1cHg7XFxufVxcclxcbi5tdC1cXFxcWzBcXFxcLjhweFxcXFxdIHtcXG4gIG1hcmdpbi10b3A6IDAuOHB4O1xcbn1cXHJcXG4ubXQtNiB7XFxuICBtYXJnaW4tdG9wOiAxLjVyZW07XFxufVxcclxcbi5tYi00IHtcXG4gIG1hcmdpbi1ib3R0b206IDFyZW07XFxufVxcclxcbi4tbWItMSB7XFxuICBtYXJnaW4tYm90dG9tOiAtMC4yNXJlbTtcXG59XFxyXFxuLi1tbC1cXFxcWzEwMFxcXFwlXFxcXF0ge1xcbiAgbWFyZ2luLWxlZnQ6IC0xMDAlO1xcbn1cXHJcXG4uLW1sLVxcXFxbMFxcXFwlXFxcXF0ge1xcbiAgbWFyZ2luLWxlZnQ6IC0wJTtcXG59XFxyXFxuLi1tbC1cXFxcWzIwMFxcXFwlXFxcXF0ge1xcbiAgbWFyZ2luLWxlZnQ6IC0yMDAlO1xcbn1cXHJcXG4uLW1sLVxcXFxbMzAwXFxcXCVcXFxcXSB7XFxuICBtYXJnaW4tbGVmdDogLTMwMCU7XFxufVxcclxcbi4tbWwtXFxcXFs1MHZ3XFxcXF0ge1xcbiAgbWFyZ2luLWxlZnQ6IC01MHZ3O1xcbn1cXHJcXG4uLW1yLVxcXFxbNTB2d1xcXFxdIHtcXG4gIG1hcmdpbi1yaWdodDogLTUwdnc7XFxufVxcclxcbi5tci1cXFxcWzBcXFxcLjM1cmVtXFxcXF0ge1xcbiAgbWFyZ2luLXJpZ2h0OiAwLjM1cmVtO1xcbn1cXHJcXG4ubWwtMyB7XFxuICBtYXJnaW4tbGVmdDogMC43NXJlbTtcXG59XFxyXFxuLm1yLTMge1xcbiAgbWFyZ2luLXJpZ2h0OiAwLjc1cmVtO1xcbn1cXHJcXG4ubWItMSB7XFxuICBtYXJnaW4tYm90dG9tOiAwLjI1cmVtO1xcbn1cXHJcXG4ubWItOCB7XFxuICBtYXJnaW4tYm90dG9tOiAycmVtO1xcbn1cXHJcXG4uYmxvY2sge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcclxcbi5pbmxpbmUtYmxvY2sge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXHJcXG4uZmxleCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbn1cXHJcXG4uaW5saW5lLWZsZXgge1xcbiAgZGlzcGxheTogaW5saW5lLWZsZXg7XFxufVxcclxcbi50YWJsZSB7XFxuICBkaXNwbGF5OiB0YWJsZTtcXG59XFxyXFxuLmdyaWQge1xcbiAgZGlzcGxheTogZ3JpZDtcXG59XFxyXFxuLmhpZGRlbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXHJcXG4uYXNwZWN0LXNxdWFyZSB7XFxuICBhc3BlY3QtcmF0aW86IDEgLyAxO1xcbn1cXHJcXG4uaC01IHtcXG4gIGhlaWdodDogMS4yNXJlbTtcXG59XFxyXFxuLmgtMjQge1xcbiAgaGVpZ2h0OiA2cmVtO1xcbn1cXHJcXG4uaC03MiB7XFxuICBoZWlnaHQ6IDE4cmVtO1xcbn1cXHJcXG4uaC1maXQge1xcbiAgaGVpZ2h0OiAtbW96LWZpdC1jb250ZW50O1xcbiAgaGVpZ2h0OiBmaXQtY29udGVudDtcXG59XFxyXFxuLmgtXFxcXFszMzBweFxcXFxdIHtcXG4gIGhlaWdodDogMzMwcHg7XFxufVxcclxcbi5oLTEyIHtcXG4gIGhlaWdodDogM3JlbTtcXG59XFxyXFxuLmgtbWF4IHtcXG4gIGhlaWdodDogLW1vei1tYXgtY29udGVudDtcXG4gIGhlaWdodDogbWF4LWNvbnRlbnQ7XFxufVxcclxcbi5oLVxcXFxbMTkwXFxcXF0ge1xcbiAgaGVpZ2h0OiAxOTA7XFxufVxcclxcbi5oLVxcXFxbNDY3cHhcXFxcXSB7XFxuICBoZWlnaHQ6IDQ2N3B4O1xcbn1cXHJcXG4uaC02IHtcXG4gIGhlaWdodDogMS41cmVtO1xcbn1cXHJcXG4uaC1mdWxsIHtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxyXFxuLmgtXFxcXFszMHB4XFxcXF0ge1xcbiAgaGVpZ2h0OiAzMHB4O1xcbn1cXHJcXG4uaC01NiB7XFxuICBoZWlnaHQ6IDE0cmVtO1xcbn1cXHJcXG4uaC1cXFxcWzQ1dmhcXFxcXSB7XFxuICBoZWlnaHQ6IDQ1dmg7XFxufVxcclxcbi5oLVxcXFxbMjUwcHhcXFxcXSB7XFxuICBoZWlnaHQ6IDI1MHB4O1xcbn1cXHJcXG4uaC00IHtcXG4gIGhlaWdodDogMXJlbTtcXG59XFxyXFxuLmgtXFxcXFsxNjZweFxcXFxdIHtcXG4gIGhlaWdodDogMTY2cHg7XFxufVxcclxcbi5oLVxcXFxbMTk5XFxcXC42OXB4XFxcXF0ge1xcbiAgaGVpZ2h0OiAxOTkuNjlweDtcXG59XFxyXFxuLmgtXFxcXFs2MHB4XFxcXF0ge1xcbiAgaGVpZ2h0OiA2MHB4O1xcbn1cXHJcXG4uaC00OCB7XFxuICBoZWlnaHQ6IDEycmVtO1xcbn1cXHJcXG4ubWF4LWgtZml0IHtcXG4gIG1heC1oZWlnaHQ6IC1tb3otZml0LWNvbnRlbnQ7XFxuICBtYXgtaGVpZ2h0OiBmaXQtY29udGVudDtcXG59XFxyXFxuLm1heC1oLVxcXFxbMjUwcHhcXFxcXSB7XFxuICBtYXgtaGVpZ2h0OiAyNTBweDtcXG59XFxyXFxuLm1heC1oLVxcXFxbMjRweFxcXFxdIHtcXG4gIG1heC1oZWlnaHQ6IDI0cHg7XFxufVxcclxcbi5taW4taC1zY3JlZW4ge1xcbiAgbWluLWhlaWdodDogMTAwdmg7XFxufVxcclxcbi5taW4taC1cXFxcWzEwMHZoXFxcXF0ge1xcbiAgbWluLWhlaWdodDogMTAwdmg7XFxufVxcclxcbi5taW4taC1cXFxcWzMzMHB4XFxcXF0ge1xcbiAgbWluLWhlaWdodDogMzMwcHg7XFxufVxcclxcbi5taW4taC1cXFxcWzIxM3B4XFxcXF0ge1xcbiAgbWluLWhlaWdodDogMjEzcHg7XFxufVxcclxcbi53LWZ1bGwge1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcclxcbi53LTUge1xcbiAgd2lkdGg6IDEuMjVyZW07XFxufVxcclxcbi53LTNcXFxcLzQge1xcbiAgd2lkdGg6IDc1JTtcXG59XFxyXFxuLnctMjQge1xcbiAgd2lkdGg6IDZyZW07XFxufVxcclxcbi53LTgge1xcbiAgd2lkdGg6IDJyZW07XFxufVxcclxcbi53LVxcXFxbOTB2d1xcXFxdIHtcXG4gIHdpZHRoOiA5MHZ3O1xcbn1cXHJcXG4udy0xMiB7XFxuICB3aWR0aDogM3JlbTtcXG59XFxyXFxuLnctXFxcXFs0OFxcXFwlXFxcXF0ge1xcbiAgd2lkdGg6IDQ4JTtcXG59XFxyXFxuLnctZml0IHtcXG4gIHdpZHRoOiAtbW96LWZpdC1jb250ZW50O1xcbiAgd2lkdGg6IGZpdC1jb250ZW50O1xcbn1cXHJcXG4udy0yXFxcXC8zIHtcXG4gIHdpZHRoOiA2Ni42NjY2NjclO1xcbn1cXHJcXG4udy1cXFxcWzE0NHB4XFxcXF0ge1xcbiAgd2lkdGg6IDE0NHB4O1xcbn1cXHJcXG4udy04MCB7XFxuICB3aWR0aDogMjByZW07XFxufVxcclxcbi53LVxcXFxbMTAwdndcXFxcXSB7XFxuICB3aWR0aDogMTAwdnc7XFxufVxcclxcbi53LTYge1xcbiAgd2lkdGg6IDEuNXJlbTtcXG59XFxyXFxuLnctXFxcXFszMHB4XFxcXF0ge1xcbiAgd2lkdGg6IDMwcHg7XFxufVxcclxcbi53LVxcXFxbMzAwXFxcXCVcXFxcXSB7XFxuICB3aWR0aDogMzAwJTtcXG59XFxyXFxuLnctXFxcXFsxMDBcXFxcJVxcXFxdIHtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXHJcXG4udy00IHtcXG4gIHdpZHRoOiAxcmVtO1xcbn1cXHJcXG4udy1cXFxcWzEwOHB4XFxcXF0ge1xcbiAgd2lkdGg6IDEwOHB4O1xcbn1cXHJcXG4udy1cXFxcWzE0MnB4XFxcXF0ge1xcbiAgd2lkdGg6IDE0MnB4O1xcbn1cXHJcXG4udy1cXFxcWzRcXFxcLjJyZW1cXFxcXSB7XFxuICB3aWR0aDogNC4ycmVtO1xcbn1cXHJcXG4udy0yMCB7XFxuICB3aWR0aDogNXJlbTtcXG59XFxyXFxuLnctMlxcXFwvNCB7XFxuICB3aWR0aDogNTAlO1xcbn1cXHJcXG4ubWluLXctXFxcXFszMDBweFxcXFxdIHtcXG4gIG1pbi13aWR0aDogMzAwcHg7XFxufVxcclxcbi5taW4tdy1cXFxcWzUwcHhcXFxcXSB7XFxuICBtaW4td2lkdGg6IDUwcHg7XFxufVxcclxcbi5taW4tdy1cXFxcWzc4cHhcXFxcXSB7XFxuICBtaW4td2lkdGg6IDc4cHg7XFxufVxcclxcbi5taW4tdy1cXFxcWzEwOHB4XFxcXF0ge1xcbiAgbWluLXdpZHRoOiAxMDhweDtcXG59XFxyXFxuLm1pbi13LVxcXFxbMjZweFxcXFxdIHtcXG4gIG1pbi13aWR0aDogMjZweDtcXG59XFxyXFxuLm1heC13LVxcXFxbMTIwMHB4XFxcXF0ge1xcbiAgbWF4LXdpZHRoOiAxMjAwcHg7XFxufVxcclxcbi5tYXgtdy1cXFxcWzE1MDBweFxcXFxdIHtcXG4gIG1heC13aWR0aDogMTUwMHB4O1xcbn1cXHJcXG4ubWF4LXctXFxcXFsxMzAwcHhcXFxcXSB7XFxuICBtYXgtd2lkdGg6IDEzMDBweDtcXG59XFxyXFxuLm1heC13LVxcXFxbMTEwMHB4XFxcXF0ge1xcbiAgbWF4LXdpZHRoOiAxMTAwcHg7XFxufVxcclxcbi5tYXgtdy1cXFxcWzU4MXB4XFxcXF0ge1xcbiAgbWF4LXdpZHRoOiA1ODFweDtcXG59XFxyXFxuLi10cmFuc2xhdGUteC0xXFxcXC8yIHtcXG4gIC0tdHctdHJhbnNsYXRlLXg6IC01MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh2YXIoLS10dy10cmFuc2xhdGUteCksIHZhcigtLXR3LXRyYW5zbGF0ZS15KSkgcm90YXRlKHZhcigtLXR3LXJvdGF0ZSkpIHNrZXdYKHZhcigtLXR3LXNrZXcteCkpIHNrZXdZKHZhcigtLXR3LXNrZXcteSkpIHNjYWxlWCh2YXIoLS10dy1zY2FsZS14KSkgc2NhbGVZKHZhcigtLXR3LXNjYWxlLXkpKTtcXG59XFxyXFxuLmN1cnNvci1wb2ludGVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxyXFxuLnNlbGVjdC1ub25lIHtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxyXFxuLmFwcGVhcmFuY2Utbm9uZSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAtbW96LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICAgIGFwcGVhcmFuY2U6IG5vbmU7XFxufVxcclxcbi5ncmlkLWNvbHMtMiB7XFxuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgyLCBtaW5tYXgoMCwgMWZyKSk7XFxufVxcclxcbi5ncmlkLWNvbHMtMSB7XFxuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgxLCBtaW5tYXgoMCwgMWZyKSk7XFxufVxcclxcbi5ncmlkLWNvbHMtNCB7XFxuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg0LCBtaW5tYXgoMCwgMWZyKSk7XFxufVxcclxcbi5ncmlkLWNvbHMtMTIge1xcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMTIsIG1pbm1heCgwLCAxZnIpKTtcXG59XFxyXFxuLmdyaWQtY29scy0xMCB7XFxuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgxMCwgbWlubWF4KDAsIDFmcikpO1xcbn1cXHJcXG4uZmxleC1jb2wge1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxyXFxuLmZsZXgtd3JhcCB7XFxuICBmbGV4LXdyYXA6IHdyYXA7XFxufVxcclxcbi5wbGFjZS1jb250ZW50LWJldHdlZW4ge1xcbiAgcGxhY2UtY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG59XFxyXFxuLml0ZW1zLWVuZCB7XFxuICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XFxufVxcclxcbi5pdGVtcy1jZW50ZXIge1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxyXFxuLmp1c3RpZnktZW5kIHtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxufVxcclxcbi5qdXN0aWZ5LWNlbnRlciB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxyXFxuLmp1c3RpZnktYmV0d2VlbiB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxufVxcclxcbi5nYXAtMyB7XFxuICBnYXA6IDAuNzVyZW07XFxufVxcclxcbi5nYXAtMTAge1xcbiAgZ2FwOiAyLjVyZW07XFxufVxcclxcbi5nYXAtNCB7XFxuICBnYXA6IDFyZW07XFxufVxcclxcbi5zcGFjZS15LTQgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXG4gIC0tdHctc3BhY2UteS1yZXZlcnNlOiAwO1xcbiAgbWFyZ2luLXRvcDogY2FsYygxcmVtICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSkpO1xcbiAgbWFyZ2luLWJvdHRvbTogY2FsYygxcmVtICogdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSk7XFxufVxcclxcbi5zcGFjZS14LTMgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXG4gIC0tdHctc3BhY2UteC1yZXZlcnNlOiAwO1xcbiAgbWFyZ2luLXJpZ2h0OiBjYWxjKDAuNzVyZW0gKiB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKTtcXG4gIG1hcmdpbi1sZWZ0OiBjYWxjKDAuNzVyZW0gKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKSk7XFxufVxcclxcbi5zcGFjZS14LTIgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXG4gIC0tdHctc3BhY2UteC1yZXZlcnNlOiAwO1xcbiAgbWFyZ2luLXJpZ2h0OiBjYWxjKDAuNXJlbSAqIHZhcigtLXR3LXNwYWNlLXgtcmV2ZXJzZSkpO1xcbiAgbWFyZ2luLWxlZnQ6IGNhbGMoMC41cmVtICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSkpO1xcbn1cXHJcXG4uc3BhY2UteC01ID4gOm5vdChbaGlkZGVuXSkgfiA6bm90KFtoaWRkZW5dKSB7XFxuICAtLXR3LXNwYWNlLXgtcmV2ZXJzZTogMDtcXG4gIG1hcmdpbi1yaWdodDogY2FsYygxLjI1cmVtICogdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSk7XFxuICBtYXJnaW4tbGVmdDogY2FsYygxLjI1cmVtICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSkpO1xcbn1cXHJcXG4uc3BhY2UteC04ID4gOm5vdChbaGlkZGVuXSkgfiA6bm90KFtoaWRkZW5dKSB7XFxuICAtLXR3LXNwYWNlLXgtcmV2ZXJzZTogMDtcXG4gIG1hcmdpbi1yaWdodDogY2FsYygycmVtICogdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSk7XFxuICBtYXJnaW4tbGVmdDogY2FsYygycmVtICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSkpO1xcbn1cXHJcXG4uZGl2aWRlLXNvbGlkID4gOm5vdChbaGlkZGVuXSkgfiA6bm90KFtoaWRkZW5dKSB7XFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbn1cXHJcXG4ub3ZlcmZsb3ctaGlkZGVuIHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcclxcbi5vdmVyZmxvdy14LWF1dG8ge1xcbiAgb3ZlcmZsb3cteDogYXV0bztcXG59XFxyXFxuLndoaXRlc3BhY2Utbm93cmFwIHtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcclxcbi53aGl0ZXNwYWNlLXByZS13cmFwIHtcXG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG59XFxyXFxuLnJvdW5kZWQtbWQge1xcbiAgYm9yZGVyLXJhZGl1czogMC4zNzVyZW07XFxufVxcclxcbi5yb3VuZGVkLTN4bCB7XFxuICBib3JkZXItcmFkaXVzOiAxLjVyZW07XFxufVxcclxcbi5yb3VuZGVkLXhsIHtcXG4gIGJvcmRlci1yYWRpdXM6IDAuNzVyZW07XFxufVxcclxcbi5yb3VuZGVkLWZ1bGwge1xcbiAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xcbn1cXHJcXG4ucm91bmRlZC1sZyB7XFxuICBib3JkZXItcmFkaXVzOiAwLjVyZW07XFxufVxcclxcbi5yb3VuZGVkIHtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjVyZW07XFxufVxcclxcbi5yb3VuZGVkLWwtbWQge1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMC4zNzVyZW07XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwLjM3NXJlbTtcXG59XFxyXFxuLnJvdW5kZWQtbC1ub25lIHtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDBweDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDBweDtcXG59XFxyXFxuLmJvcmRlciB7XFxuICBib3JkZXItd2lkdGg6IDFweDtcXG59XFxyXFxuLmJvcmRlci1cXFxcWzBcXFxcLjVweFxcXFxdIHtcXG4gIGJvcmRlci13aWR0aDogMC41cHg7XFxufVxcclxcbi5ib3JkZXItMiB7XFxuICBib3JkZXItd2lkdGg6IDJweDtcXG59XFxyXFxuLmJvcmRlci1cXFxcWzFweFxcXFxdIHtcXG4gIGJvcmRlci13aWR0aDogMXB4O1xcbn1cXHJcXG4uYm9yZGVyLTQge1xcbiAgYm9yZGVyLXdpZHRoOiA0cHg7XFxufVxcclxcbi5ib3JkZXItYiB7XFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAxcHg7XFxufVxcclxcbi5ib3JkZXItYi0yIHtcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDJweDtcXG59XFxyXFxuLmJvcmRlci10IHtcXG4gIGJvcmRlci10b3Atd2lkdGg6IDFweDtcXG59XFxyXFxuLmJvcmRlci1iLVxcXFxbMXB4XFxcXF0ge1xcbiAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4O1xcbn1cXHJcXG4uYm9yZGVyLXQtMiB7XFxuICBib3JkZXItdG9wLXdpZHRoOiAycHg7XFxufVxcclxcbi5ib3JkZXItdC1cXFxcWzFweFxcXFxdIHtcXG4gIGJvcmRlci10b3Atd2lkdGg6IDFweDtcXG59XFxyXFxuLmJvcmRlci1yLTAge1xcbiAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwcHg7XFxufVxcclxcbi5ib3JkZXItc29saWQge1xcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG59XFxyXFxuLmJvcmRlci1kYXNoZWQge1xcbiAgYm9yZGVyLXN0eWxlOiBkYXNoZWQ7XFxufVxcclxcbi5ib3JkZXItYmx1ZS00MDAge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDk2IDE2NSAyNTAgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXHJcXG4uYm9yZGVyLXRyYW5zcGFyZW50IHtcXG4gIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcclxcbi5ib3JkZXItZ3JheS0zMDAge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDIwOSAyMTMgMjE5IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJvcmRlci1cXFxcW1xcXFwjQkJCQkJCXFxcXF0ge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDE4NyAxODcgMTg3IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJvcmRlci1cXFxcW1xcXFwjZTJlMmUyXFxcXF0ge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDIyNiAyMjYgMjI2IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJvcmRlci1ibHVlLTgwMCB7XFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMzAgNjQgMTc1IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLXdoaXRlIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNTUgMjU1IDI1NSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLXNsYXRlLTQwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMTQ4IDE2MyAxODQgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1ibHVlLTUwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLXppbmMtMzAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMTIgMjEyIDIxNiAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLXppbmMtNDAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigxNjEgMTYxIDE3MCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLXllbGxvdy01MDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIzNCAxNzkgOCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLWluZGlnby01MDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDk5IDEwMiAyNDEgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy10ZWFsLTUwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjAgMTg0IDE2NiAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLWJsdWUtMjAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigxOTEgMjE5IDI1NCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLVxcXFxbXFxcXCMzRDQxNERcXFxcXSB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoNjEgNjUgNzcgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1ncmF5LTIwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjI5IDIzMSAyMzUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1ibGFjayB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCAwIDAgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1yZWQtMjAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNTQgMjAyIDIwMiAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLXNsYXRlLTMwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjAzIDIxMyAyMjUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1zbGF0ZS0xMDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI0MSAyNDUgMjQ5IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uYmctZ3JheS01MCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjQ5IDI1MCAyNTEgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5vYmplY3QtY292ZXIge1xcbiAgLW8tb2JqZWN0LWZpdDogY292ZXI7XFxuICAgICBvYmplY3QtZml0OiBjb3ZlcjtcXG59XFxyXFxuLnAtNiB7XFxuICBwYWRkaW5nOiAxLjVyZW07XFxufVxcclxcbi5wLTMge1xcbiAgcGFkZGluZzogMC43NXJlbTtcXG59XFxyXFxuLnAtMiB7XFxuICBwYWRkaW5nOiAwLjVyZW07XFxufVxcclxcbi5wLVxcXFxbMFxcXFwuMTJyZW1cXFxcXSB7XFxuICBwYWRkaW5nOiAwLjEycmVtO1xcbn1cXHJcXG4ucC0xIHtcXG4gIHBhZGRpbmc6IDAuMjVyZW07XFxufVxcclxcbi5wLVxcXFxbMFxcXFwuMnJlbVxcXFxdIHtcXG4gIHBhZGRpbmc6IDAuMnJlbTtcXG59XFxyXFxuLnAtMCB7XFxuICBwYWRkaW5nOiAwcHg7XFxufVxcclxcbi5weC00IHtcXG4gIHBhZGRpbmctbGVmdDogMXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDFyZW07XFxufVxcclxcbi5weC0yIHtcXG4gIHBhZGRpbmctbGVmdDogMC41cmVtO1xcbiAgcGFkZGluZy1yaWdodDogMC41cmVtO1xcbn1cXHJcXG4ucHktMiB7XFxuICBwYWRkaW5nLXRvcDogMC41cmVtO1xcbiAgcGFkZGluZy1ib3R0b206IDAuNXJlbTtcXG59XFxyXFxuLnB5LTQge1xcbiAgcGFkZGluZy10b3A6IDFyZW07XFxuICBwYWRkaW5nLWJvdHRvbTogMXJlbTtcXG59XFxyXFxuLnB5LTIwIHtcXG4gIHBhZGRpbmctdG9wOiA1cmVtO1xcbiAgcGFkZGluZy1ib3R0b206IDVyZW07XFxufVxcclxcbi5weC0yMCB7XFxuICBwYWRkaW5nLWxlZnQ6IDVyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiA1cmVtO1xcbn1cXHJcXG4ucHgtOCB7XFxuICBwYWRkaW5nLWxlZnQ6IDJyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAycmVtO1xcbn1cXHJcXG4ucHktMyB7XFxuICBwYWRkaW5nLXRvcDogMC43NXJlbTtcXG4gIHBhZGRpbmctYm90dG9tOiAwLjc1cmVtO1xcbn1cXHJcXG4ucHgtMyB7XFxuICBwYWRkaW5nLWxlZnQ6IDAuNzVyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAwLjc1cmVtO1xcbn1cXHJcXG4ucHgtMSB7XFxuICBwYWRkaW5nLWxlZnQ6IDAuMjVyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAwLjI1cmVtO1xcbn1cXHJcXG4ucHktXFxcXFs1cHhcXFxcXSB7XFxuICBwYWRkaW5nLXRvcDogNXB4O1xcbiAgcGFkZGluZy1ib3R0b206IDVweDtcXG59XFxyXFxuLnB5LTUge1xcbiAgcGFkZGluZy10b3A6IDEuMjVyZW07XFxuICBwYWRkaW5nLWJvdHRvbTogMS4yNXJlbTtcXG59XFxyXFxuLnB4LTEwIHtcXG4gIHBhZGRpbmctbGVmdDogMi41cmVtO1xcbiAgcGFkZGluZy1yaWdodDogMi41cmVtO1xcbn1cXHJcXG4ucHktMSB7XFxuICBwYWRkaW5nLXRvcDogMC4yNXJlbTtcXG4gIHBhZGRpbmctYm90dG9tOiAwLjI1cmVtO1xcbn1cXHJcXG4ucGItNCB7XFxuICBwYWRkaW5nLWJvdHRvbTogMXJlbTtcXG59XFxyXFxuLnB0LTIge1xcbiAgcGFkZGluZy10b3A6IDAuNXJlbTtcXG59XFxyXFxuLnBiLTE0IHtcXG4gIHBhZGRpbmctYm90dG9tOiAzLjVyZW07XFxufVxcclxcbi5wYi1cXFxcWzYwcHhcXFxcXSB7XFxuICBwYWRkaW5nLWJvdHRvbTogNjBweDtcXG59XFxyXFxuLnBiLTMge1xcbiAgcGFkZGluZy1ib3R0b206IDAuNzVyZW07XFxufVxcclxcbi5wdC0xIHtcXG4gIHBhZGRpbmctdG9wOiAwLjI1cmVtO1xcbn1cXHJcXG4ucHQtMyB7XFxuICBwYWRkaW5nLXRvcDogMC43NXJlbTtcXG59XFxyXFxuLnBiLTEge1xcbiAgcGFkZGluZy1ib3R0b206IDAuMjVyZW07XFxufVxcclxcbi5wYi0yIHtcXG4gIHBhZGRpbmctYm90dG9tOiAwLjVyZW07XFxufVxcclxcbi5wbC02IHtcXG4gIHBhZGRpbmctbGVmdDogMS41cmVtO1xcbn1cXHJcXG4ucGwtMyB7XFxuICBwYWRkaW5nLWxlZnQ6IDAuNzVyZW07XFxufVxcclxcbi5wbC03IHtcXG4gIHBhZGRpbmctbGVmdDogMS43NXJlbTtcXG59XFxyXFxuLnByLTMge1xcbiAgcGFkZGluZy1yaWdodDogMC43NXJlbTtcXG59XFxyXFxuLnRleHQtY2VudGVyIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxyXFxuLmZvbnQtc2FucyB7XFxuICBmb250LWZhbWlseTogdWktc2Fucy1zZXJpZiwgc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFxcXCJTZWdvZSBVSVxcXCIsIFJvYm90bywgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgQXJpYWwsIFxcXCJOb3RvIFNhbnNcXFwiLCBzYW5zLXNlcmlmLCBcXFwiQXBwbGUgQ29sb3IgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgU3ltYm9sXFxcIiwgXFxcIk5vdG8gQ29sb3IgRW1vamlcXFwiO1xcbn1cXHJcXG4udGV4dC0zeGwge1xcbiAgZm9udC1zaXplOiAxLjg3NXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAyLjI1cmVtO1xcbn1cXHJcXG4udGV4dC1zbSB7XFxuICBmb250LXNpemU6IDAuODc1cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuMjVyZW07XFxufVxcclxcbi50ZXh0LXhsIHtcXG4gIGZvbnQtc2l6ZTogMS4yNXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjc1cmVtO1xcbn1cXHJcXG4udGV4dC0yeGwge1xcbiAgZm9udC1zaXplOiAxLjVyZW07XFxuICBsaW5lLWhlaWdodDogMnJlbTtcXG59XFxyXFxuLnRleHQteHMge1xcbiAgZm9udC1zaXplOiAwLjc1cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDFyZW07XFxufVxcclxcbi50ZXh0LWxnIHtcXG4gIGZvbnQtc2l6ZTogMS4xMjVyZW07XFxuICBsaW5lLWhlaWdodDogMS43NXJlbTtcXG59XFxyXFxuLnRleHQtYmFzZSB7XFxuICBmb250LXNpemU6IDFyZW07XFxuICBsaW5lLWhlaWdodDogMS41cmVtO1xcbn1cXHJcXG4uZm9udC1ib2xkIHtcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxufVxcclxcbi5mb250LW1lZGl1bSB7XFxuICBmb250LXdlaWdodDogNTAwO1xcbn1cXHJcXG4uZm9udC1zZW1pYm9sZCB7XFxuICBmb250LXdlaWdodDogNjAwO1xcbn1cXHJcXG4udXBwZXJjYXNlIHtcXG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxufVxcclxcbi5sZWFkaW5nLTcge1xcbiAgbGluZS1oZWlnaHQ6IDEuNzVyZW07XFxufVxcclxcbi5sZWFkaW5nLVxcXFxbMVxcXFwuOHJlbVxcXFxdIHtcXG4gIGxpbmUtaGVpZ2h0OiAxLjhyZW07XFxufVxcclxcbi50ZXh0LWdyYXktNTAwIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigxMDcgMTE0IDEyOCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4udGV4dC1ibHVlLTMwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMTQ3IDE5NyAyNTMgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxyXFxuLnRleHQtd2hpdGUge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcclxcbi50ZXh0LWdyYXktNjAwIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYig3NSA4NSA5OSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4udGV4dC1cXFxcW1xcXFwjNjY2Njc2XFxcXF0ge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDEwMiAxMDIgMTE4IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcclxcbi50ZXh0LWdyYXktNDAwIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigxNTYgMTYzIDE3NSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4udGV4dC1yZWQtNDAwIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigyNDggMTEzIDExMyAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4udGV4dC1ibHVlLTUwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4udGV4dC1ibHVlLTQwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoOTYgMTY1IDI1MCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4udGV4dC1ncmF5LTcwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoNTUgNjUgODEgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxyXFxuLnRleHQtYmxhY2sge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDAgMCAwIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcclxcbi5wbGFjZWhvbGRlci1ncmF5LTQwMDo6LW1vei1wbGFjZWhvbGRlciB7XFxuICAtLXR3LXBsYWNlaG9sZGVyLW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDE1NiAxNjMgMTc1IC8gdmFyKC0tdHctcGxhY2Vob2xkZXItb3BhY2l0eSkpO1xcbn1cXHJcXG4ucGxhY2Vob2xkZXItZ3JheS00MDA6OnBsYWNlaG9sZGVyIHtcXG4gIC0tdHctcGxhY2Vob2xkZXItb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMTU2IDE2MyAxNzUgLyB2YXIoLS10dy1wbGFjZWhvbGRlci1vcGFjaXR5KSk7XFxufVxcclxcbi5vcGFjaXR5LTYwIHtcXG4gIG9wYWNpdHk6IDAuNjtcXG59XFxyXFxuLnNoYWRvdy1zbSB7XFxuICAtLXR3LXNoYWRvdzogMCAxcHggMnB4IDAgcmdiKDAgMCAwIC8gMC4wNSk7XFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDFweCAycHggMCB2YXIoLS10dy1zaGFkb3ctY29sb3IpO1xcbiAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1yaW5nLXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctc2hhZG93KTtcXG59XFxyXFxuLnNoYWRvdy14bCB7XFxuICAtLXR3LXNoYWRvdzogMCAyMHB4IDI1cHggLTVweCByZ2IoMCAwIDAgLyAwLjEpLCAwIDhweCAxMHB4IC02cHggcmdiKDAgMCAwIC8gMC4xKTtcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMjBweCAyNXB4IC01cHggdmFyKC0tdHctc2hhZG93LWNvbG9yKSwgMCA4cHggMTBweCAtNnB4IHZhcigtLXR3LXNoYWRvdy1jb2xvcik7XFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXJpbmctc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1zaGFkb3cpO1xcbn1cXHJcXG4ucmluZy0yIHtcXG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiB2YXIoLS10dy1yaW5nLWluc2V0KSAwIDAgMCB2YXIoLS10dy1yaW5nLW9mZnNldC13aWR0aCkgdmFyKC0tdHctcmluZy1vZmZzZXQtY29sb3IpO1xcbiAgLS10dy1yaW5nLXNoYWRvdzogdmFyKC0tdHctcmluZy1pbnNldCkgMCAwIDAgY2FsYygycHggKyB2YXIoLS10dy1yaW5nLW9mZnNldC13aWR0aCkpIHZhcigtLXR3LXJpbmctY29sb3IpO1xcbiAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93KSwgdmFyKC0tdHctcmluZy1zaGFkb3cpLCB2YXIoLS10dy1zaGFkb3csIDAgMCAjMDAwMCk7XFxufVxcclxcbi5yaW5nLXllbGxvdy01MDAge1xcbiAgLS10dy1yaW5nLW9wYWNpdHk6IDE7XFxuICAtLXR3LXJpbmctY29sb3I6IHJnYigyMzQgMTc5IDggLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXG59XFxyXFxuLnJpbmctaW5kaWdvLTUwMCB7XFxuICAtLXR3LXJpbmctb3BhY2l0eTogMTtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDk5IDEwMiAyNDEgLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXG59XFxyXFxuLnJpbmctdGVhbC01MDAge1xcbiAgLS10dy1yaW5nLW9wYWNpdHk6IDE7XFxuICAtLXR3LXJpbmctY29sb3I6IHJnYigyMCAxODQgMTY2IC8gdmFyKC0tdHctcmluZy1vcGFjaXR5KSk7XFxufVxcclxcbi5yaW5nLWdyYXktNTAwIHtcXG4gIC0tdHctcmluZy1vcGFjaXR5OiAxO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoMTA3IDExNCAxMjggLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXG59XFxyXFxuLnJpbmctYmxhY2sge1xcbiAgLS10dy1yaW5nLW9wYWNpdHk6IDE7XFxuICAtLXR3LXJpbmctY29sb3I6IHJnYigwIDAgMCAvIHZhcigtLXR3LXJpbmctb3BhY2l0eSkpO1xcbn1cXHJcXG4ucmluZy1yZWQtNTAwIHtcXG4gIC0tdHctcmluZy1vcGFjaXR5OiAxO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoMjM5IDY4IDY4IC8gdmFyKC0tdHctcmluZy1vcGFjaXR5KSk7XFxufVxcclxcbi5yaW5nLWJsdWUtNTAwIHtcXG4gIC0tdHctcmluZy1vcGFjaXR5OiAxO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIHZhcigtLXR3LXJpbmctb3BhY2l0eSkpO1xcbn1cXHJcXG4ucmluZy1vZmZzZXQtMiB7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAycHg7XFxufVxcclxcbi5yaW5nLW9mZnNldC0xIHtcXG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDFweDtcXG59XFxyXFxuLmZpbHRlciB7XFxuICBmaWx0ZXI6IHZhcigtLXR3LWJsdXIpIHZhcigtLXR3LWJyaWdodG5lc3MpIHZhcigtLXR3LWNvbnRyYXN0KSB2YXIoLS10dy1ncmF5c2NhbGUpIHZhcigtLXR3LWh1ZS1yb3RhdGUpIHZhcigtLXR3LWludmVydCkgdmFyKC0tdHctc2F0dXJhdGUpIHZhcigtLXR3LXNlcGlhKSB2YXIoLS10dy1kcm9wLXNoYWRvdyk7XFxufVxcclxcbi50cmFuc2l0aW9uIHtcXG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IGNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXItY29sb3IsIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgZmlsbCwgc3Ryb2tlLCBvcGFjaXR5LCBib3gtc2hhZG93LCB0cmFuc2Zvcm0sIGZpbHRlciwgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI7XFxuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBjb2xvciwgYmFja2dyb3VuZC1jb2xvciwgYm9yZGVyLWNvbG9yLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIGZpbGwsIHN0cm9rZSwgb3BhY2l0eSwgYm94LXNoYWRvdywgdHJhbnNmb3JtLCBmaWx0ZXIsIGJhY2tkcm9wLWZpbHRlcjtcXG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IGNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXItY29sb3IsIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgZmlsbCwgc3Ryb2tlLCBvcGFjaXR5LCBib3gtc2hhZG93LCB0cmFuc2Zvcm0sIGZpbHRlciwgYmFja2Ryb3AtZmlsdGVyLCAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjtcXG4gIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO1xcbiAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMTUwbXM7XFxufVxcclxcbi50cmFuc2l0aW9uLWFsbCB7XFxuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBhbGw7XFxuICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtcXG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDE1MG1zO1xcbn1cXHJcXG4uZHVyYXRpb24tXFxcXFswbXNcXFxcXSB7XFxuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAwbXM7XFxufVxcclxcbi5kdXJhdGlvbi0xMDAwIHtcXG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDEwMDBtcztcXG59XFxyXFxuLmxhc3RcXFxcOmJvcmRlci1iLTA6bGFzdC1jaGlsZCB7XFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAwcHg7XFxufVxcclxcbi5vZGRcXFxcOmJnLWJsdWUtNTA6bnRoLWNoaWxkKG9kZCkge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIzOSAyNDYgMjU1IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOmN1cnNvci1wb2ludGVyOmhvdmVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxyXFxuLmhvdmVyXFxcXDpib3JkZXItYmx1ZS01MDA6aG92ZXIge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDU5IDEzMCAyNDYgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOmJvcmRlci1ncmF5LTQwMDpob3ZlciB7XFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMTU2IDE2MyAxNzUgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOmJvcmRlci1ncmF5LTMwMDpob3ZlciB7XFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMjA5IDIxMyAyMTkgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOmJnLWdyYXktNTA6aG92ZXIge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI0OSAyNTAgMjUxIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOmJnLXRlYWwtNTAwOmhvdmVyIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMCAxODQgMTY2IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOmJnLWdyYXktMjAwOmhvdmVyIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMjkgMjMxIDIzNSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmhvdmVyXFxcXDpiZy1ncmF5LTEwMDpob3ZlciB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjQzIDI0NCAyNDYgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5ob3ZlclxcXFw6Ymctd2hpdGU6aG92ZXIge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOnRleHQtZ3JheS00MDA6aG92ZXIge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDE1NiAxNjMgMTc1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcclxcbi5ob3ZlclxcXFw6dGV4dC1ibGFjazpob3ZlciB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMCAwIDAgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxyXFxuLmhvdmVyXFxcXDp0ZXh0LWJsdWUtNTAwOmhvdmVyIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcclxcbi5ob3ZlclxcXFw6dGV4dC1yZWQtNTAwOmhvdmVyIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigyMzkgNjggNjggLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxyXFxuLmhvdmVyXFxcXDp0ZXh0LWdyYXktNTAwOmhvdmVyIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigxMDcgMTE0IDEyOCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOnRleHQtYmx1ZS00MDA6aG92ZXIge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDk2IDE2NSAyNTAgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxyXFxuLmhvdmVyXFxcXDp1bmRlcmxpbmU6aG92ZXIge1xcbiAgdGV4dC1kZWNvcmF0aW9uLWxpbmU6IHVuZGVybGluZTtcXG59XFxyXFxuLmZvY3VzXFxcXDpib3JkZXItYmx1ZS00MDA6Zm9jdXMge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDk2IDE2NSAyNTAgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXHJcXG4uZm9jdXNcXFxcOmJvcmRlci1vcmFuZ2UtNTAwOmZvY3VzIHtcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICBib3JkZXItY29sb3I6IHJnYigyNDkgMTE1IDIyIC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxyXFxuLmZvY3VzXFxcXDpiZy1yZWQtNTAwOmZvY3VzIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMzkgNjggNjggLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5mb2N1c1xcXFw6b3V0bGluZS1ub25lOmZvY3VzIHtcXG4gIG91dGxpbmU6IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIG91dGxpbmUtb2Zmc2V0OiAycHg7XFxufVxcclxcbi5mb2N1c1xcXFw6cmluZy0yOmZvY3VzIHtcXG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiB2YXIoLS10dy1yaW5nLWluc2V0KSAwIDAgMCB2YXIoLS10dy1yaW5nLW9mZnNldC13aWR0aCkgdmFyKC0tdHctcmluZy1vZmZzZXQtY29sb3IpO1xcbiAgLS10dy1yaW5nLXNoYWRvdzogdmFyKC0tdHctcmluZy1pbnNldCkgMCAwIDAgY2FsYygycHggKyB2YXIoLS10dy1yaW5nLW9mZnNldC13aWR0aCkpIHZhcigtLXR3LXJpbmctY29sb3IpO1xcbiAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93KSwgdmFyKC0tdHctcmluZy1zaGFkb3cpLCB2YXIoLS10dy1zaGFkb3csIDAgMCAjMDAwMCk7XFxufVxcclxcbi5mb2N1c1xcXFw6cmluZy1ibHVlLTUwMDpmb2N1cyB7XFxuICAtLXR3LXJpbmctb3BhY2l0eTogMTtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDU5IDEzMCAyNDYgLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXG59XFxyXFxuLmZvY3VzXFxcXDpyaW5nLWJsdWUtNDAwOmZvY3VzIHtcXG4gIC0tdHctcmluZy1vcGFjaXR5OiAxO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoOTYgMTY1IDI1MCAvIHZhcigtLXR3LXJpbmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uZm9jdXNcXFxcOnJpbmctb3JhbmdlLTUwMDpmb2N1cyB7XFxuICAtLXR3LXJpbmctb3BhY2l0eTogMTtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDI0OSAxMTUgMjIgLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXG59XFxyXFxuLmZvY3VzXFxcXDpyaW5nLW9mZnNldC0yOmZvY3VzIHtcXG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDJweDtcXG59XFxyXFxuLmFjdGl2ZVxcXFw6YmcteWVsbG93LTUwMDphY3RpdmUge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIzNCAxNzkgOCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLnBlZXI6Y2hlY2tlZCB+IC5wZWVyLWNoZWNrZWRcXFxcOmJnLWJsdWUtNjAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigzNyA5OSAyMzUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5wZWVyOmNoZWNrZWQgfiAucGVlci1jaGVja2VkXFxcXDp0ZXh0LXdoaXRlIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigyNTUgMjU1IDI1NSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogNjQwcHgpIHtcXG5cXG4gIC5zbVxcXFw6Y29sLXNwYW4tMTAge1xcbiAgICBncmlkLWNvbHVtbjogc3BhbiAxMCAvIHNwYW4gMTA7XFxuICB9XFxuXFxuICAuc21cXFxcOm10LTcge1xcbiAgICBtYXJnaW4tdG9wOiAxLjc1cmVtO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpncmlkIHtcXG4gICAgZGlzcGxheTogZ3JpZDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWF4LXctXFxcXFszODBweFxcXFxdIHtcXG4gICAgbWF4LXdpZHRoOiAzODBweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Z3JpZC1jb2xzLTUge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg1LCBtaW5tYXgoMCwgMWZyKSk7XFxuICB9XFxuXFxuICAuc21cXFxcOmdyaWQtY29scy0xIHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMSwgbWlubWF4KDAsIDFmcikpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpncmlkLWNvbHMtMyB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDMsIG1pbm1heCgwLCAxZnIpKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Z3JpZC1jb2xzLTEwIHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMTAsIG1pbm1heCgwLCAxZnIpKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGwtNSB7XFxuICAgIHBhZGRpbmctbGVmdDogMS4yNXJlbTtcXG4gIH1cXG59XFxyXFxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuXFxuICAubWRcXFxcOmdyaWQtY29scy01IHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoNSwgbWlubWF4KDAsIDFmcikpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpncmlkLWNvbHMtNCB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDQsIG1pbm1heCgwLCAxZnIpKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Z3JpZC1jb2xzLTMge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgzLCBtaW5tYXgoMCwgMWZyKSk7XFxuICB9XFxuXFxuICAubWRcXFxcOmdyaWQtY29scy0yIHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMiwgbWlubWF4KDAsIDFmcikpO1xcbiAgfVxcbn1cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogMTAyNHB4KSB7XFxuXFxuICAubGdcXFxcOmNvbC1zcGFuLTEge1xcbiAgICBncmlkLWNvbHVtbjogc3BhbiAxIC8gc3BhbiAxO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpjb2wtc3Bhbi0xMCB7XFxuICAgIGdyaWQtY29sdW1uOiBzcGFuIDEwIC8gc3BhbiAxMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Y29sLXNwYW4tNSB7XFxuICAgIGdyaWQtY29sdW1uOiBzcGFuIDUgLyBzcGFuIDU7XFxuICB9XFxuXFxuICAubGdcXFxcOmdyaWQtY29scy04IHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoOCwgbWlubWF4KDAsIDFmcikpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpncmlkLWNvbHMtNiB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDYsIG1pbm1heCgwLCAxZnIpKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Z3JpZC1jb2xzLTQge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg0LCBtaW5tYXgoMCwgMWZyKSk7XFxuICB9XFxuXFxuICAubGdcXFxcOmdyaWQtcm93cy01IHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiByZXBlYXQoNSwgbWlubWF4KDAsIDFmcikpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpweC01IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxLjI1cmVtO1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxLjI1cmVtO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpweC0wIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAwcHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDBweDtcXG4gIH1cXG59XFxyXFxuQG1lZGlhIChtaW4td2lkdGg6IDEyODBweCkge1xcblxcbiAgLnhsXFxcXDpncmlkLWNvbHMtNSB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDUsIG1pbm1heCgwLCAxZnIpKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Z3JpZC1jb2xzLTMge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgzLCBtaW5tYXgoMCwgMWZyKSk7XFxuICB9XFxufVxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zdHlsZXMvZ2xvYmFscy5jc3NcIixcIjxubyBzb3VyY2U+XCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBOztDQUFjLENBQWQ7OztDQUFjOztBQUFkOzs7RUFBQSxzQkFBYyxFQUFkLE1BQWM7RUFBZCxlQUFjLEVBQWQsTUFBYztFQUFkLG1CQUFjLEVBQWQsTUFBYztFQUFkLHFCQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztFQUFBLGdCQUFjO0FBQUE7O0FBQWQ7Ozs7O0NBQWM7O0FBQWQ7RUFBQSxnQkFBYyxFQUFkLE1BQWM7RUFBZCw4QkFBYyxFQUFkLE1BQWM7RUFBZCxnQkFBYyxFQUFkLE1BQWM7RUFBZCxjQUFjO0tBQWQsV0FBYyxFQUFkLE1BQWM7RUFBZCw0TkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7RUFBQSxTQUFjLEVBQWQsTUFBYztFQUFkLG9CQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOzs7O0NBQWM7O0FBQWQ7RUFBQSxTQUFjLEVBQWQsTUFBYztFQUFkLGNBQWMsRUFBZCxNQUFjO0VBQWQscUJBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSx5Q0FBYztVQUFkLGlDQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7Ozs7OztFQUFBLGtCQUFjO0VBQWQsb0JBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGNBQWM7RUFBZCx3QkFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLG1CQUFjO0FBQUE7O0FBQWQ7OztDQUFjOztBQUFkOzs7O0VBQUEsK0dBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGNBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDs7RUFBQSxjQUFjO0VBQWQsY0FBYztFQUFkLGtCQUFjO0VBQWQsd0JBQWM7QUFBQTs7QUFBZDtFQUFBLGVBQWM7QUFBQTs7QUFBZDtFQUFBLFdBQWM7QUFBQTs7QUFBZDs7OztDQUFjOztBQUFkO0VBQUEsY0FBYyxFQUFkLE1BQWM7RUFBZCxxQkFBYyxFQUFkLE1BQWM7RUFBZCx5QkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7OztDQUFjOztBQUFkOzs7OztFQUFBLG9CQUFjLEVBQWQsTUFBYztFQUFkLGVBQWMsRUFBZCxNQUFjO0VBQWQsb0JBQWMsRUFBZCxNQUFjO0VBQWQsb0JBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYyxFQUFkLE1BQWM7RUFBZCxTQUFjLEVBQWQsTUFBYztFQUFkLFVBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7O0VBQUEsb0JBQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7Ozs7RUFBQSwwQkFBYyxFQUFkLE1BQWM7RUFBZCw2QkFBYyxFQUFkLE1BQWM7RUFBZCxzQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGFBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGdCQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSx3QkFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLFlBQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7RUFBQSw2QkFBYyxFQUFkLE1BQWM7RUFBZCxvQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLHdCQUFjO0FBQUE7O0FBQWQ7OztDQUFjOztBQUFkO0VBQUEsMEJBQWMsRUFBZCxNQUFjO0VBQWQsYUFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGtCQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7Ozs7Ozs7Ozs7Ozs7RUFBQSxTQUFjO0FBQUE7O0FBQWQ7RUFBQSxTQUFjO0VBQWQsVUFBYztBQUFBOztBQUFkO0VBQUEsVUFBYztBQUFBOztBQUFkOzs7RUFBQSxnQkFBYztFQUFkLFNBQWM7RUFBZCxVQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSxnQkFBYztBQUFBOztBQUFkOzs7Q0FBYzs7QUFBZDtFQUFBLFVBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7RUFBQSxVQUFjLEVBQWQsTUFBYztFQUFkLGNBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7O0VBQUEsZUFBYztBQUFBOztBQUFkOztDQUFjO0FBQWQ7RUFBQSxlQUFjO0FBQUE7O0FBQWQ7Ozs7Q0FBYzs7QUFBZDs7Ozs7Ozs7RUFBQSxjQUFjLEVBQWQsTUFBYztFQUFkLHNCQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLGVBQWM7RUFBZCxZQUFjO0FBQUE7O0FBQWQ7RUFBQSx3QkFBYztFQUFkLHdCQUFjO0VBQWQsbUJBQWM7RUFBZCxtQkFBYztFQUFkLGNBQWM7RUFBZCxjQUFjO0VBQWQsY0FBYztFQUFkLGVBQWM7RUFBZCxlQUFjO0VBQWQsYUFBYztFQUFkLGFBQWM7RUFBZCxrQkFBYztFQUFkLHNDQUFjO0VBQWQsZUFBYztFQUFkLG9CQUFjO0VBQWQsc0JBQWM7RUFBZCx1QkFBYztFQUFkLHdCQUFjO0VBQWQsa0JBQWM7RUFBZCwyQkFBYztFQUFkLDRCQUFjO0VBQWQsc0NBQWM7RUFBZCxrQ0FBYztFQUFkLDJCQUFjO0VBQWQsc0JBQWM7RUFBZCw4QkFBYztFQUFkLFlBQWM7RUFBZCxrQkFBYztFQUFkLGdCQUFjO0VBQWQsaUJBQWM7RUFBZCxrQkFBYztFQUFkLGNBQWM7RUFBZCxnQkFBYztFQUFkLGFBQWM7RUFBZCxtQkFBYztFQUFkLHFCQUFjO0VBQWQsMkJBQWM7RUFBZCx5QkFBYztFQUFkLDBCQUFjO0VBQWQsMkJBQWM7RUFBZCx1QkFBYztFQUFkLHdCQUFjO0VBQWQseUJBQWM7RUFBZDtBQUFjOztBQUFkO0VBQUEsd0JBQWM7RUFBZCx3QkFBYztFQUFkLG1CQUFjO0VBQWQsbUJBQWM7RUFBZCxjQUFjO0VBQWQsY0FBYztFQUFkLGNBQWM7RUFBZCxlQUFjO0VBQWQsZUFBYztFQUFkLGFBQWM7RUFBZCxhQUFjO0VBQWQsa0JBQWM7RUFBZCxzQ0FBYztFQUFkLGVBQWM7RUFBZCxvQkFBYztFQUFkLHNCQUFjO0VBQWQsdUJBQWM7RUFBZCx3QkFBYztFQUFkLGtCQUFjO0VBQWQsMkJBQWM7RUFBZCw0QkFBYztFQUFkLHNDQUFjO0VBQWQsa0NBQWM7RUFBZCwyQkFBYztFQUFkLHNCQUFjO0VBQWQsOEJBQWM7RUFBZCxZQUFjO0VBQWQsa0JBQWM7RUFBZCxnQkFBYztFQUFkLGlCQUFjO0VBQWQsa0JBQWM7RUFBZCxjQUFjO0VBQWQsZ0JBQWM7RUFBZCxhQUFjO0VBQWQsbUJBQWM7RUFBZCxxQkFBYztFQUFkLDJCQUFjO0VBQWQseUJBQWM7RUFBZCwwQkFBYztFQUFkLDJCQUFjO0VBQWQsdUJBQWM7RUFBZCx3QkFBYztFQUFkLHlCQUFjO0VBQWQ7QUFBYztBQUVkO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGlCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG1CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG1CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG1CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG1CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG1CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGlCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGdCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSx3QkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsd0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSw0QkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSx5QkFBbUI7S0FBbkIsc0JBQW1CO1VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsd0JBQW1CO0tBQW5CLHFCQUFtQjtVQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CLDREQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQix1REFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkIsc0RBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CLHVEQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQixvREFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsZ0NBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsMkJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0tBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxxQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxxQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxnQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxlQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDJCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDJCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsMENBQW1CO0VBQW5CLHVEQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGdGQUFtQjtFQUFuQixvR0FBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSwyR0FBbUI7RUFBbkIseUdBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsZ0tBQW1CO0VBQW5CLHdKQUFtQjtFQUFuQixpTEFBbUI7RUFBbkIsd0RBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsd0JBQW1CO0VBQW5CLHdEQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFGbkI7RUFBQTtDQ0FBO0FEQUE7RUFBQSxtQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBO0NDQUE7QURBQTtFQUFBLHVCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEsdUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSx1QkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLG1CQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEsbUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxtQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLG1CQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEsbUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxxQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHFCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEscUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxxQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHFCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEscUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQTtDQ0FBO0FEQUE7RUFBQSx1QkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHVCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEsbUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSwrQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLDRHQ0FBO0VEQUEsMEdDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxxQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHFCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEscUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQTtDQ0FBO0FEQUE7RUFBQSxtQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLG1CQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEscUJDQUE7RURBQTtDQ0FBO0FEQUE7O0VBQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7Q0FBQTtBREFBOztFQUFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTtDQUFBO0FEQUE7O0VBQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUEsc0JDQUE7SURBQTtHQ0FBOztFREFBO0lBQUEsa0JDQUE7SURBQTtHQ0FBO0NBQUE7QURBQTs7RUFBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBO0NBQUFcIixcInNvdXJjZXNDb250ZW50XCI6W1wiQHRhaWx3aW5kIGJhc2U7XFxyXFxuQHRhaWx3aW5kIGNvbXBvbmVudHM7XFxyXFxuQHRhaWx3aW5kIHV0aWxpdGllcztcXHJcXG5cIixudWxsXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app! ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"./pages/_app.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1wcml2YXRlLW5leHQtcGFnZXMlMkZfYXBwJnBhZ2U9JTJGX2FwcCEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxpREFBeUI7QUFDaEQ7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzY3ODIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHBcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL19hcHBcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!\n"));

/***/ }),

/***/ "./public/fdb_logo.png":
/*!*****************************!*\
  !*** ./public/fdb_logo.png ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/fdb_logo.a5ea18a4.png\",\"height\":143,\"width\":173,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ffdb_logo.a5ea18a4.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":7});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wdWJsaWMvZmRiX2xvZ28ucG5nLmpzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLG9NQUFvTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvZmRiX2xvZ28ucG5nPzZlMjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1wic3JjXCI6XCIvX25leHQvc3RhdGljL21lZGlhL2ZkYl9sb2dvLmE1ZWExOGE0LnBuZ1wiLFwiaGVpZ2h0XCI6MTQzLFwid2lkdGhcIjoxNzMsXCJibHVyRGF0YVVSTFwiOlwiL19uZXh0L2ltYWdlP3VybD0lMkZfbmV4dCUyRnN0YXRpYyUyRm1lZGlhJTJGZmRiX2xvZ28uYTVlYTE4YTQucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjd9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./public/fdb_logo.png\n"));

/***/ }),

/***/ "./styles/globals.css":
/*!****************************!*\
  !*** ./styles/globals.css ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvZ2xvYmFscy5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLG9OQUF3RztBQUMxSCwwQkFBMEIsbUJBQU8sQ0FBQyx1ZUFBK087O0FBRWpSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZCx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpQkFBaUI7QUFDckIsTUFBTSx1ZUFBK087QUFDclA7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyx1ZUFBK087O0FBRXpROztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9nbG9iYWxzLmNzcz9jOTgzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls4XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzhdLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBzdHlsZS1sb2FkZXIgaW5qZWN0cyBDU1MgaW50byB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIDxoZWFkPi4gVGhpcyBjYXVzZXMgb3JkZXJpbmcgcHJvYmxlbXMgYmV0d2VlbiBkZXZcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb2QuIFRvIGZpeCB0aGlzLCB3ZSByZW5kZXIgYSA8bm9zY3JpcHQ+IHRhZyBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBhbmNob3IgZm9yIHRoZSBzdHlsZXMgdG8gYmUgcGxhY2VkIGJlZm9yZS4gVGhlc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBfYmVmb3JlXyA8c3R5bGUganN4IGdsb2JhbD4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNfX25leHRfY3NzX19ET19OT1RfVVNFX19cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls4XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzhdLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls4XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzhdLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nconst isOldIE = function isOldIE() {\n    let memo;\n    return function memorize() {\n        if (typeof memo === \"undefined\") {\n            // Test for IE <= 9 as proposed by Browserhacks\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n            // Tests for existence of standard globals is to allow style-loader\n            // to operate correctly into non-standard environments\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\n            memo = Boolean(window && document && document.all && !window.atob);\n        }\n        return memo;\n    };\n}();\nconst getTarget = function getTarget() {\n    const memo = {};\n    return function memorize(target) {\n        if (typeof memo[target] === \"undefined\") {\n            let styleTarget = document.querySelector(target);\n            // Special case to return head of iframe instead of iframe itself\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n                try {\n                    // This will throw an exception if access to iframe is blocked\n                    // due to cross-origin restrictions\n                    styleTarget = styleTarget.contentDocument.head;\n                } catch (e) {\n                    // istanbul ignore next\n                    styleTarget = null;\n                }\n            }\n            memo[target] = styleTarget;\n        }\n        return memo[target];\n    };\n}();\nconst stylesInDom = [];\nfunction getIndexByIdentifier(identifier) {\n    let result = -1;\n    for(let i = 0; i < stylesInDom.length; i++){\n        if (stylesInDom[i].identifier === identifier) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\nfunction modulesToDom(list, options) {\n    const idCountMap = {};\n    const identifiers = [];\n    for(let i = 0; i < list.length; i++){\n        const item = list[i];\n        const id = options.base ? item[0] + options.base : item[0];\n        const count = idCountMap[id] || 0;\n        const identifier = id + \" \" + count.toString();\n        idCountMap[id] = count + 1;\n        const index = getIndexByIdentifier(identifier);\n        const obj = {\n            css: item[1],\n            media: item[2],\n            sourceMap: item[3]\n        };\n        if (index !== -1) {\n            stylesInDom[index].references++;\n            stylesInDom[index].updater(obj);\n        } else {\n            stylesInDom.push({\n                identifier: identifier,\n                updater: addStyle(obj, options),\n                references: 1\n            });\n        }\n        identifiers.push(identifier);\n    }\n    return identifiers;\n}\nfunction insertStyleElement(options) {\n    const style = document.createElement(\"style\");\n    const attributes = options.attributes || {};\n    if (typeof attributes.nonce === \"undefined\") {\n        const nonce = // eslint-disable-next-line no-undef\n         true ? __webpack_require__.nc : 0;\n        if (nonce) {\n            attributes.nonce = nonce;\n        }\n    }\n    Object.keys(attributes).forEach(function(key) {\n        style.setAttribute(key, attributes[key]);\n    });\n    if (typeof options.insert === \"function\") {\n        options.insert(style);\n    } else {\n        const target = getTarget(options.insert || \"head\");\n        if (!target) {\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        }\n        target.appendChild(style);\n    }\n    return style;\n}\nfunction removeStyleElement(style) {\n    // istanbul ignore if\n    if (style.parentNode === null) {\n        return false;\n    }\n    style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */ const replaceText = function replaceText() {\n    const textStore = [];\n    return function replace(index, replacement) {\n        textStore[index] = replacement;\n        return textStore.filter(Boolean).join(\"\\n\");\n    };\n}();\nfunction applyToSingletonTag(style, index, remove, obj) {\n    const css = remove ? \"\" : obj.media ? \"@media \" + obj.media + \" {\" + obj.css + \"}\" : obj.css;\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = replaceText(index, css);\n    } else {\n        const cssNode = document.createTextNode(css);\n        const childNodes = style.childNodes;\n        if (childNodes[index]) {\n            style.removeChild(childNodes[index]);\n        }\n        if (childNodes.length) {\n            style.insertBefore(cssNode, childNodes[index]);\n        } else {\n            style.appendChild(cssNode);\n        }\n    }\n}\nfunction applyToTag(style, options, obj) {\n    let css = obj.css;\n    const media = obj.media;\n    const sourceMap = obj.sourceMap;\n    if (media) {\n        style.setAttribute(\"media\", media);\n    } else {\n        style.removeAttribute(\"media\");\n    }\n    if (sourceMap && typeof btoa !== \"undefined\") {\n        css += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n    }\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        while(style.firstChild){\n            style.removeChild(style.firstChild);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n}\nlet singleton = null;\nlet singletonCounter = 0;\nfunction addStyle(obj, options) {\n    let style;\n    let update;\n    let remove;\n    if (options.singleton) {\n        const styleIndex = singletonCounter++;\n        style = singleton || (singleton = insertStyleElement(options));\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n    } else {\n        style = insertStyleElement(options);\n        update = applyToTag.bind(null, style, options);\n        remove = function() {\n            removeStyleElement(style);\n        };\n    }\n    update(obj);\n    return function updateStyle(newObj) {\n        if (newObj) {\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n                return;\n            }\n            update(obj = newObj);\n        } else {\n            remove();\n        }\n    };\n}\nmodule.exports = function(list, options) {\n    options = options || {};\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n    // tags it will allow on a page\n    if (!options.singleton && typeof options.singleton !== \"boolean\") {\n        options.singleton = isOldIE();\n    }\n    list = list || [];\n    let lastIdentifiers = modulesToDom(list, options);\n    return function update(newList) {\n        newList = newList || [];\n        if (Object.prototype.toString.call(newList) !== \"[object Array]\") {\n            return;\n        }\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            stylesInDom[index].references--;\n        }\n        const newLastIdentifiers = modulesToDom(newList, options);\n        for(let i1 = 0; i1 < lastIdentifiers.length; i1++){\n            const identifier = lastIdentifiers[i1];\n            const index = getIndexByIdentifier(identifier);\n            if (stylesInDom[index].references === 0) {\n                stylesInDom[index].updater();\n                stylesInDom.splice(index, 1);\n            }\n        }\n        lastIdentifiers = newLastIdentifiers;\n    };\n};\n\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUVBQXFFLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yNmVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gICAgbGV0IG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgICAgICBpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAgICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAgICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG59KCk7XG5jb25zdCBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gICAgY29uc3QgbWVtbyA9IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG4gICAgICAgICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICAgIH07XG59KCk7XG5jb25zdCBzdHlsZXNJbkRvbSA9IFtdO1xuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICAgIGxldCByZXN1bHQgPSAtMTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGlkQ291bnRNYXAgPSB7fTtcbiAgICBjb25zdCBpZGVudGlmaWVycyA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgIGNvbnN0IGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgICAgIGNvbnN0IGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGlkICsgXCIgXCIgKyBjb3VudC50b1N0cmluZygpO1xuICAgICAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3Qgb2JqID0ge1xuICAgICAgICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICAgICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBub25jZSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQob3B0aW9ucy5pbnNlcnQgfHwgXCJoZWFkXCIpO1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG59XG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovIGNvbnN0IHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gICAgY29uc3QgdGV4dFN0b3JlID0gW107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKTtcbiAgICB9O1xufSgpO1xuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gICAgY29uc3QgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiICsgb2JqLm1lZGlhICsgXCIge1wiICsgb2JqLmNzcyArIFwifVwiIDogb2JqLmNzcztcbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG4gICAgICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gICAgbGV0IGNzcyA9IG9iai5jc3M7XG4gICAgY29uc3QgbWVkaWEgPSBvYmoubWVkaWE7XG4gICAgY29uc3Qgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpO1xuICAgIH1cbiAgICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcbiAgICB9XG4gICAgLy8gRm9yIG9sZCBJRVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpe1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgfVxufVxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5sZXQgc2luZ2xldG9uQ291bnRlciA9IDA7XG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgICBsZXQgc3R5bGU7XG4gICAgbGV0IHVwZGF0ZTtcbiAgICBsZXQgcmVtb3ZlO1xuICAgIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgICAgICBjb25zdCBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgICAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgICAgIHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlKG9iaik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgICAgICBpZiAobmV3T2JqKSB7XG4gICAgICAgICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG4gICAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICAgIH1cbiAgICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgICBsZXQgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgICAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuICAgICAgICBmb3IobGV0IGkxID0gMDsgaTEgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpMSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaTFdO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIGlmIChzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKCk7XG4gICAgICAgICAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gICAgfTtcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n"));

/***/ }),

/***/ "./components/Footer.tsx":
/*!*******************************!*\
  !*** ./components/Footer.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Footer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction Footer() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"footer\", {\n        className: \" mt-10 px-10 text-center absolute bottom-0 h-[60px] w-full \",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: \"Copyright \\xa9 Sagan Jung 2022. All rights reserved.\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Footer.tsx\",\n                lineNumber: 4,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: \"contact - mk44879@gmail.com\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Footer.tsx\",\n                lineNumber: 5,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Footer.tsx\",\n        lineNumber: 3,\n        columnNumber: 5\n    }, this);\n}\n_c = Footer;\nvar _c;\n$RefreshReg$(_c, \"Footer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0Zvb3Rlci50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFBZSxTQUFTQSxNQUFNLEdBQUc7SUFDL0IscUJBQ0UsOERBQUNDLFFBQU07UUFBQ0MsU0FBUyxFQUFDLDZEQUE2RDs7MEJBQzdFLDhEQUFDQyxHQUFDOzBCQUFDLHNEQUFpRDs7Ozs7b0JBQUk7MEJBQ3hELDhEQUFDQSxHQUFDOzBCQUFDLDZCQUEyQjs7Ozs7b0JBQUk7Ozs7OztZQUMzQixDQUNUO0FBQ0osQ0FBQztBQVB1QkgsS0FBQUEsTUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Zvb3Rlci50c3g/YTc5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGb290ZXIoKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxmb290ZXIgY2xhc3NOYW1lPVwiIG10LTEwIHB4LTEwIHRleHQtY2VudGVyIGFic29sdXRlIGJvdHRvbS0wIGgtWzYwcHhdIHctZnVsbCBcIj5cclxuICAgICAgPHA+Q29weXJpZ2h0IMKpIFNhZ2FuIEp1bmcgMjAyMi4gQWxsIHJpZ2h0cyByZXNlcnZlZC48L3A+XHJcbiAgICAgIDxwPmNvbnRhY3QgLSBtazQ0ODc5QGdtYWlsLmNvbTwvcD5cclxuICAgIDwvZm9vdGVyPlxyXG4gICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbIkZvb3RlciIsImZvb3RlciIsImNsYXNzTmFtZSIsInAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Footer.tsx\n"));

/***/ }),

/***/ "./components/Gnb.tsx":
/*!****************************!*\
  !*** ./components/Gnb.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Gnb; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next-auth/react */ \"./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _libs_client_useUser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/client/useUser */ \"./libs/client/useUser.tsx\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _public_fdb_logo_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../public/fdb_logo.png */ \"./public/fdb_logo.png\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction Gnb() {\n    _s();\n    var ref = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_2__.useSession)(), nextSession = ref.data;\n    var ref1 = (0,_libs_client_useUser__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(), user = ref1.user, isLoading = ref1.isLoading;\n    var _image, _id;\n    // const { data: CredentailSession } = useSWR(\"/api/users/me\");\n    // console.log(user);\n    // console.log(nextSession);\n    // useEffect(() => {\n    //   if (data && !data.ok) {\n    //     router.replace(\"/enter\");\n    //   }\n    // }, [data, router]);\n    // console.log(data);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n        className: \"flex bg-blue-200 fixed top-0 w-full py-2 z-20\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n            className: \"flex w-full justify-between items-center\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                    className: \"flex uppercase font-bold \",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \" ml-3 mr-3 cursor-pointer\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                className: \" \",\n                                href: \"/\",\n                                passHref: true,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    className: \" flex items-center \",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_4___default()), {\n                                        className: \" rounded-xl border-blue-800 border-4 border-solid\",\n                                        src: _public_fdb_logo_png__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n                                        width: 26,\n                                        height: 26\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                        lineNumber: 26,\n                                        columnNumber: 17\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 25,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 24,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 23,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"mr-3\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                href: \"/fictions/all/all/all/1/all\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    children: \"작품\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 37,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 36,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 35,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"mr-3\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                href: \"/authors/1\",\n                                passHref: true,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    children: \"작가\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 42,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 41,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 40,\n                            columnNumber: 11\n                        }, this),\n                        user ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"mr-3\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                href: \"/fictions/create\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    children: \"Create\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 51,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 50,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 49,\n                            columnNumber: 13\n                        }, this) : null\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                    lineNumber: 22,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                    className: \" flex font-bold items-center\",\n                    children: [\n                        user ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"mr-3\",\n                            children: \"Admin\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 57,\n                            columnNumber: 19\n                        }, this) : null,\n                        nextSession ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \" mr-3 p-0 flex items-center cursor-pointer min-w-[26px]\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                className: \" rounded-full\",\n                                href: \"/profile\",\n                                passHref: true,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    className: \" flex items-center\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_4___default()), {\n                                        className: \" rounded-full\",\n                                        src: (_image = nextSession.user.image) !== null && _image !== void 0 ? _image : \"\",\n                                        width: 26,\n                                        height: 26,\n                                        alt: (_id = nextSession.user.id) !== null && _id !== void 0 ? _id : \"\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                        lineNumber: 62,\n                                        columnNumber: 19\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 61,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 60,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 59,\n                            columnNumber: 13\n                        }, this) : null,\n                        nextSession ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            className: \" mr-5 font-bold\",\n                            onClick: function() {\n                                return (0,next_auth_react__WEBPACK_IMPORTED_MODULE_2__.signOut)();\n                            },\n                            children: \"Sign out\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 74,\n                            columnNumber: 13\n                        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                href: \"/enter\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    className: \" mr-5 hover:cursor-pointer\",\n                                    children: \"Enter\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 80,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 79,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 78,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                    lineNumber: 56,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n            lineNumber: 21,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n        lineNumber: 20,\n        columnNumber: 5\n    }, this);\n}\n_s(Gnb, \"hok5D1BpjBZA3UVuT/spEw5bbE0=\", false, function() {\n    return [\n        next_auth_react__WEBPACK_IMPORTED_MODULE_2__.useSession,\n        _libs_client_useUser__WEBPACK_IMPORTED_MODULE_3__[\"default\"]\n    ];\n});\n_c = Gnb;\nvar _c;\n$RefreshReg$(_c, \"Gnb\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBdUIsR0FBSSxFQUFFO3dDQUNsQ1ksS0FBSyxFQUFFLEVBQUU7d0NBQ1RDLE1BQU0sRUFBRSxFQUFFO3dDQUNWRSxHQUFHLEVBQUVmLENBQUFBLEdBQW9CLEdBQXBCQSxXQUFXLENBQUNDLElBQUksQ0FBRWUsRUFBRSxjQUFwQmhCLEdBQW9CLGNBQXBCQSxHQUFvQixHQUFJLEVBQUU7Ozs7OzRDQUN4Qjs7Ozs7d0NBQ1A7Ozs7O29DQUNDOzs7OztnQ0FDSixHQUNILElBQUk7d0JBQ1BBLFdBQVcsaUJBQ1YsOERBQUNpQixRQUFNOzRCQUFDYixTQUFTLEVBQUMsaUJBQWlCOzRCQUFDYyxPQUFPLEVBQUU7dUNBQU14Qix3REFBTyxFQUFFOzZCQUFBO3NDQUFFLFVBRTlEOzs7OztnQ0FBUyxpQkFFVCw4REFBQ2EsSUFBRTtzQ0FDRCw0RUFBQ2Ysa0RBQUk7Z0NBQUNnQixJQUFJLEVBQUMsUUFBUTswQ0FDakIsNEVBQUNFLEdBQUM7b0NBQUNOLFNBQVMsRUFBQyw0QkFBNEI7OENBQUMsT0FBSzs7Ozs7d0NBQUk7Ozs7O29DQUM5Qzs7Ozs7Z0NBQ0o7Ozs7Ozt3QkFFSjs7Ozs7O2dCQUNEOzs7OztZQUNDLENBQ1Q7QUFDSixDQUFDO0dBakZ1Qk4sR0FBRzs7UUFDS0wsdURBQVU7UUFDWkUsNERBQU87OztBQUZiRyxLQUFBQSxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvR25iLnRzeD81YzhlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMaW5rIGZyb20gXCJuZXh0L2xpbmtcIjtcclxuaW1wb3J0IHsgdXNlU2Vzc2lvbiwgc2lnbkluLCBzaWduT3V0IH0gZnJvbSBcIm5leHQtYXV0aC9yZWFjdFwiO1xyXG5pbXBvcnQgdXNlVXNlciBmcm9tIFwiQGxpYnMvY2xpZW50L3VzZVVzZXJcIjtcclxuaW1wb3J0IEltYWdlIGZyb20gXCJuZXh0L2ltYWdlXCI7XHJcbmltcG9ydCBsb2dvIGZyb20gXCIuLi9wdWJsaWMvZmRiX2xvZ28ucG5nXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBHbmIoKSB7XHJcbiAgY29uc3QgeyBkYXRhOiBuZXh0U2Vzc2lvbiB9ID0gdXNlU2Vzc2lvbigpO1xyXG4gIGNvbnN0IHsgdXNlciwgaXNMb2FkaW5nIH0gPSB1c2VVc2VyKCk7XHJcbiAgLy8gY29uc3QgeyBkYXRhOiBDcmVkZW50YWlsU2Vzc2lvbiB9ID0gdXNlU1dSKFwiL2FwaS91c2Vycy9tZVwiKTtcclxuICAvLyBjb25zb2xlLmxvZyh1c2VyKTtcclxuICAvLyBjb25zb2xlLmxvZyhuZXh0U2Vzc2lvbik7XHJcbiAgLy8gdXNlRWZmZWN0KCgpID0+IHtcclxuICAvLyAgIGlmIChkYXRhICYmICFkYXRhLm9rKSB7XHJcbiAgLy8gICAgIHJvdXRlci5yZXBsYWNlKFwiL2VudGVyXCIpO1xyXG4gIC8vICAgfVxyXG4gIC8vIH0sIFtkYXRhLCByb3V0ZXJdKTtcclxuICAvLyBjb25zb2xlLmxvZyhkYXRhKTtcclxuICByZXR1cm4gKFxyXG4gICAgPGhlYWRlciBjbGFzc05hbWU9XCJmbGV4IGJnLWJsdWUtMjAwIGZpeGVkIHRvcC0wIHctZnVsbCBweS0yIHotMjBcIj5cclxuICAgICAgPG5hdiBjbGFzc05hbWU9XCJmbGV4IHctZnVsbCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyXCI+XHJcbiAgICAgICAgPHVsIGNsYXNzTmFtZT1cImZsZXggdXBwZXJjYXNlIGZvbnQtYm9sZCBcIj5cclxuICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCIgbWwtMyBtci0zIGN1cnNvci1wb2ludGVyXCI+XHJcbiAgICAgICAgICAgIDxMaW5rIGNsYXNzTmFtZT1cIiBcIiBocmVmPVwiL1wiIHBhc3NIcmVmPlxyXG4gICAgICAgICAgICAgIDxhIGNsYXNzTmFtZT1cIiBmbGV4IGl0ZW1zLWNlbnRlciBcIj5cclxuICAgICAgICAgICAgICAgIDxJbWFnZVxyXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCIgcm91bmRlZC14bCBib3JkZXItYmx1ZS04MDAgYm9yZGVyLTQgYm9yZGVyLXNvbGlkXCJcclxuICAgICAgICAgICAgICAgICAgc3JjPXtsb2dvfVxyXG4gICAgICAgICAgICAgICAgICB3aWR0aD17MjZ9XHJcbiAgICAgICAgICAgICAgICAgIGhlaWdodD17MjZ9XHJcbiAgICAgICAgICAgICAgICA+PC9JbWFnZT5cclxuICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibXItM1wiPlxyXG4gICAgICAgICAgICA8TGluayBocmVmPVwiL2ZpY3Rpb25zL2FsbC9hbGwvYWxsLzEvYWxsXCI+XHJcbiAgICAgICAgICAgICAgPGE+7J6R7ZKIPC9hPlxyXG4gICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm1yLTNcIj5cclxuICAgICAgICAgICAgPExpbmsgaHJlZj1cIi9hdXRob3JzLzFcIiBwYXNzSHJlZj5cclxuICAgICAgICAgICAgICA8YT7snpHqsIA8L2E+XHJcbiAgICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICB7LyogPExpbmsgaHJlZj1cIi9yYW5raW5nXCI+XHJcbiAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJtci0zXCI+UmFua2luZzwvbGk+XHJcbiAgICAgICAgICA8L0xpbms+ICovfVxyXG4gICAgICAgICAge3VzZXIgPyAoXHJcbiAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJtci0zXCI+XHJcbiAgICAgICAgICAgICAgPExpbmsgaHJlZj1cIi9maWN0aW9ucy9jcmVhdGVcIj5cclxuICAgICAgICAgICAgICAgIDxhPkNyZWF0ZTwvYT5cclxuICAgICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICApIDogbnVsbH1cclxuICAgICAgICA8L3VsPlxyXG4gICAgICAgIDx1bCBjbGFzc05hbWU9XCIgZmxleCBmb250LWJvbGQgaXRlbXMtY2VudGVyXCI+XHJcbiAgICAgICAgICB7dXNlciA/IDxsaSBjbGFzc05hbWU9XCJtci0zXCI+QWRtaW48L2xpPiA6IG51bGx9XHJcbiAgICAgICAgICB7bmV4dFNlc3Npb24gPyAoXHJcbiAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCIgbXItMyBwLTAgZmxleCBpdGVtcy1jZW50ZXIgY3Vyc29yLXBvaW50ZXIgbWluLXctWzI2cHhdXCI+XHJcbiAgICAgICAgICAgICAgPExpbmsgY2xhc3NOYW1lPVwiIHJvdW5kZWQtZnVsbFwiIGhyZWY9XCIvcHJvZmlsZVwiIHBhc3NIcmVmPlxyXG4gICAgICAgICAgICAgICAgPGEgY2xhc3NOYW1lPVwiIGZsZXggaXRlbXMtY2VudGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxJbWFnZVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIiByb3VuZGVkLWZ1bGxcIlxyXG4gICAgICAgICAgICAgICAgICAgIHNyYz17bmV4dFNlc3Npb24udXNlciEuaW1hZ2UgPz8gXCJcIn1cclxuICAgICAgICAgICAgICAgICAgICB3aWR0aD17MjZ9XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PXsyNn1cclxuICAgICAgICAgICAgICAgICAgICBhbHQ9e25leHRTZXNzaW9uLnVzZXIhLmlkID8/IFwiXCJ9XHJcbiAgICAgICAgICAgICAgICAgID48L0ltYWdlPlxyXG4gICAgICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICkgOiBudWxsfVxyXG4gICAgICAgICAge25leHRTZXNzaW9uID8gKFxyXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cIiBtci01IGZvbnQtYm9sZFwiIG9uQ2xpY2s9eygpID0+IHNpZ25PdXQoKX0+XHJcbiAgICAgICAgICAgICAgU2lnbiBvdXRcclxuICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICApIDogKFxyXG4gICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgPExpbmsgaHJlZj1cIi9lbnRlclwiPlxyXG4gICAgICAgICAgICAgICAgPGEgY2xhc3NOYW1lPVwiIG1yLTUgaG92ZXI6Y3Vyc29yLXBvaW50ZXJcIj5FbnRlcjwvYT5cclxuICAgICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICApfVxyXG4gICAgICAgIDwvdWw+XHJcbiAgICAgIDwvbmF2PlxyXG4gICAgPC9oZWFkZXI+XHJcbiAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsiTGluayIsInVzZVNlc3Npb24iLCJzaWduT3V0IiwidXNlVXNlciIsIkltYWdlIiwibG9nbyIsIkduYiIsImRhdGEiLCJuZXh0U2Vzc2lvbiIsInVzZXIiLCJpc0xvYWRpbmciLCJoZWFkZXIiLCJjbGFzc05hbWUiLCJuYXYiLCJ1bCIsImxpIiwiaHJlZiIsInBhc3NIcmVmIiwiYSIsInNyYyIsIndpZHRoIiwiaGVpZ2h0IiwiaW1hZ2UiLCJhbHQiLCJpZCIsImJ1dHRvbiIsIm9uQ2xpY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Gnb.tsx\n"));

/***/ }),

/***/ "./components/Top.tsx":
/*!****************************!*\
  !*** ./components/Top.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Top; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Gnb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Gnb */ \"./components/Gnb.tsx\");\n\n\nfunction Top() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Gnb__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Top.tsx\",\n        lineNumber: 4,\n        columnNumber: 10\n    }, this);\n}\n_c = Top;\nvar _c;\n$RefreshReg$(_c, \"Top\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1RvcC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQXdCO0FBRVQsU0FBU0MsR0FBRyxHQUFHO0lBQzVCLHFCQUFPLDhEQUFDRCw0Q0FBRzs7OztZQUFHLENBQUM7QUFDakIsQ0FBQztBQUZ1QkMsS0FBQUEsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1RvcC50c3g/MWY1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR25iIGZyb20gXCIuL0duYlwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVG9wKCkge1xyXG4gIHJldHVybiA8R25iIC8+O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJHbmIiLCJUb3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Top.tsx\n"));

/***/ }),

/***/ "./libs/client/useUser.tsx":
/*!*********************************!*\
  !*** ./libs/client/useUser.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ useUser; }\n/* harmony export */ });\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! swr */ \"./node_modules/swr/dist/index.mjs\");\nvar _s = $RefreshSig$();\n\n\n\nfunction useUser() {\n    _s();\n    var ref = (0,swr__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"/api/users/me\"), data = ref.data, error = ref.error;\n    // const { data: session } = useSession();\n    var router = (0,next_router__WEBPACK_IMPORTED_MODULE_0__.useRouter)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (data && !data.ok) {\n        // router.replace(\"/enter\");\n        }\n    }, [\n        data,\n        router\n    ]);\n    //   return router.replace(\"/enter\");\n    return {\n        user: data === null || data === void 0 ? void 0 : data.profile,\n        isLoading: !data && !error\n    };\n}\n_s(useUser, \"4W9O7/pgHSLAxPizl2rA7NDDAiw=\", false, function() {\n    return [\n        swr__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n        next_router__WEBPACK_IMPORTED_MODULE_0__.useRouter\n    ];\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL2NsaWVudC91c2VVc2VyLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUF3QztBQUNOO0FBQ1Q7QUFFVixTQUFTRyxPQUFPLEdBQUc7O0lBQ2hDLElBQXdCRCxHQUF1QixHQUF2QkEsK0NBQU0sQ0FBQyxlQUFlLENBQUMsRUFBdkNFLElBQUksR0FBWUYsR0FBdUIsQ0FBdkNFLElBQUksRUFBRUMsS0FBSyxHQUFLSCxHQUF1QixDQUFqQ0csS0FBSztJQUNuQiwwQ0FBMEM7SUFDMUMsSUFBTUMsTUFBTSxHQUFHTixzREFBUyxFQUFFO0lBQzFCQyxnREFBUyxDQUFDLFdBQU07UUFDZCxJQUFJRyxJQUFJLElBQUksQ0FBQ0EsSUFBSSxDQUFDRyxFQUFFLEVBQUU7UUFDcEIsNEJBQTRCO1FBQzlCLENBQUM7SUFDSCxDQUFDLEVBQUU7UUFBQ0gsSUFBSTtRQUFFRSxNQUFNO0tBQUMsQ0FBQyxDQUFDO0lBRW5CLHFDQUFxQztJQUVyQyxPQUFPO1FBQUVFLElBQUksRUFBRUosSUFBSSxhQUFKQSxJQUFJLFdBQVMsR0FBYkEsS0FBQUEsQ0FBYSxHQUFiQSxJQUFJLENBQUVLLE9BQU87UUFBRUMsU0FBUyxFQUFFLENBQUNOLElBQUksSUFBSSxDQUFDQyxLQUFLO0tBQUUsQ0FBQztBQUM3RCxDQUFDO0dBYnVCRixPQUFPOztRQUNMRCwyQ0FBTTtRQUVmRixrREFBUyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWJzL2NsaWVudC91c2VVc2VyLnRzeD9jNjdlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L3JvdXRlclwiO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHVzZVNXUiBmcm9tIFwic3dyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VVc2VyKCkge1xyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHVzZVNXUihcIi9hcGkvdXNlcnMvbWVcIik7XHJcbiAgLy8gY29uc3QgeyBkYXRhOiBzZXNzaW9uIH0gPSB1c2VTZXNzaW9uKCk7XHJcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChkYXRhICYmICFkYXRhLm9rKSB7XHJcbiAgICAgIC8vIHJvdXRlci5yZXBsYWNlKFwiL2VudGVyXCIpO1xyXG4gICAgfVxyXG4gIH0sIFtkYXRhLCByb3V0ZXJdKTtcclxuXHJcbiAgLy8gICByZXR1cm4gcm91dGVyLnJlcGxhY2UoXCIvZW50ZXJcIik7XHJcblxyXG4gIHJldHVybiB7IHVzZXI6IGRhdGE/LnByb2ZpbGUsIGlzTG9hZGluZzogIWRhdGEgJiYgIWVycm9yIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZVJvdXRlciIsInVzZUVmZmVjdCIsInVzZVNXUiIsInVzZVVzZXIiLCJkYXRhIiwiZXJyb3IiLCJyb3V0ZXIiLCJvayIsInVzZXIiLCJwcm9maWxlIiwiaXNMb2FkaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/client/useUser.tsx\n"));

/***/ }),

/***/ "./pages/_app.tsx":
/*!************************!*\
  !*** ./pages/_app.tsx ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/src/_object_spread.mjs */ \"./node_modules/@swc/helpers/src/_object_spread.mjs\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../styles/globals.css */ \"./styles/globals.css\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_styles_globals_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Top__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @components/Top */ \"./components/Top.tsx\");\n/* harmony import */ var _components_Footer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @components/Footer */ \"./components/Footer.tsx\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next-auth/react */ \"./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! swr */ \"./node_modules/swr/dist/index.mjs\");\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! recoil */ \"./node_modules/recoil/es/index.js\");\n\n\n\n\n\n\n\n\n// const { data: session } = useSession();\nfunction MyApp(param) {\n    var Component = param.Component, pageProps = param.pageProps;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_auth_react__WEBPACK_IMPORTED_MODULE_4__.SessionProvider, {\n        session: pageProps.session,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(swr__WEBPACK_IMPORTED_MODULE_5__.SWRConfig, {\n            value: {\n                fetcher: function(url) {\n                    return fetch(url).then(function(response) {\n                        return response.json();\n                    });\n                }\n            },\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(recoil__WEBPACK_IMPORTED_MODULE_6__.RecoilRoot, {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \" min-w-[300px] max-h-fit flex flex-col items-center min-h-[100vh] relative\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Top__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                            lineNumber: 28,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                            className: \" mt-10 mx-3 flex-column items-center pb-[60px]\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, (0,_swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({}, pageProps), void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                                lineNumber: 30,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                            lineNumber: 29,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Footer__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                            lineNumber: 32,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                    lineNumber: 27,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                lineNumber: 26,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n            lineNumber: 20,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n        lineNumber: 19,\n        columnNumber: 5\n    }, this);\n}\n_c = MyApp;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MyApp);\nvar _c;\n$RefreshReg$(_c, \"MyApp\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9fYXBwLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7QUFBK0I7QUFFRztBQUNNO0FBQ3NCO0FBQzlCO0FBQ0k7QUFHcEMsMENBQTBDO0FBRTFDLFNBQVNLLEtBQUssQ0FBQyxLQUtiLEVBQUU7UUFKRkMsU0FBUyxHQURJLEtBS2IsQ0FKQUEsU0FBUyxFQUNUQyxTQUFTLEdBRkksS0FLYixDQUhBQSxTQUFTO0lBSVQscUJBQ0UsOERBQUNMLDREQUFlO1FBQUNNLE9BQU8sRUFBRUQsU0FBUyxDQUFDQyxPQUFPO2tCQUN6Qyw0RUFBQ0wsMENBQVM7WUFDUk0sS0FBSyxFQUFFO2dCQUNMQyxPQUFPLEVBQUUsU0FBQ0MsR0FBVzsyQkFDbkJDLEtBQUssQ0FBQ0QsR0FBRyxDQUFDLENBQUNFLElBQUksQ0FBQyxTQUFDQyxRQUFROytCQUFLQSxRQUFRLENBQUNDLElBQUksRUFBRTtxQkFBQSxDQUFDO2lCQUFBO2FBQ2pEO3NCQUVELDRFQUFDWCw4Q0FBVTswQkFDVCw0RUFBQ1ksS0FBRztvQkFBQ0MsU0FBUyxFQUFDLDRFQUE2RTs7c0NBQzFGLDhEQUFDakIsdURBQUc7Ozs7Z0NBQUc7c0NBQ1AsOERBQUNrQixTQUFPOzRCQUFDRCxTQUFTLEVBQUMsZ0RBQWdEO3NDQUNqRSw0RUFBQ1gsU0FBUyxxRkFBS0MsU0FBUzs7OztvQ0FBSTs7Ozs7Z0NBQ3BCO3NDQUNWLDhEQUFDTiwwREFBTTs7OztnQ0FBRzs7Ozs7O3dCQUNOOzs7OztvQkFDSzs7Ozs7Z0JBQ0g7Ozs7O1lBQ0ksQ0FDbEI7QUFDSixDQUFDO0FBMUJRSSxLQUFBQSxLQUFLO0FBNEJkLCtEQUFlQSxLQUFLLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvX2FwcC50c3g/MmZiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCIuLi9zdHlsZXMvZ2xvYmFscy5jc3NcIjtcclxuaW1wb3J0IHR5cGUgeyBBcHBQcm9wcyB9IGZyb20gXCJuZXh0L2FwcFwiO1xyXG5pbXBvcnQgVG9wIGZyb20gXCJAY29tcG9uZW50cy9Ub3BcIjtcclxuaW1wb3J0IEZvb3RlciBmcm9tIFwiQGNvbXBvbmVudHMvRm9vdGVyXCI7XHJcbmltcG9ydCB7IFNlc3Npb25Qcm92aWRlciwgdXNlU2Vzc2lvbiB9IGZyb20gXCJuZXh0LWF1dGgvcmVhY3RcIjtcclxuaW1wb3J0IHsgU1dSQ29uZmlnIH0gZnJvbSBcInN3clwiO1xyXG5pbXBvcnQgeyBSZWNvaWxSb290IH0gZnJvbSBcInJlY29pbFwiO1xyXG5pbXBvcnQgeyBTZXNzaW9uIH0gZnJvbSBcIm5leHQtYXV0aFwiO1xyXG5cclxuLy8gY29uc3QgeyBkYXRhOiBzZXNzaW9uIH0gPSB1c2VTZXNzaW9uKCk7XHJcblxyXG5mdW5jdGlvbiBNeUFwcCh7XHJcbiAgQ29tcG9uZW50LFxyXG4gIHBhZ2VQcm9wcyxcclxufTogQXBwUHJvcHM8e1xyXG4gIHNlc3Npb246IFNlc3Npb247XHJcbn0+KSB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxTZXNzaW9uUHJvdmlkZXIgc2Vzc2lvbj17cGFnZVByb3BzLnNlc3Npb259PlxyXG4gICAgICA8U1dSQ29uZmlnXHJcbiAgICAgICAgdmFsdWU9e3tcclxuICAgICAgICAgIGZldGNoZXI6ICh1cmw6IHN0cmluZykgPT5cclxuICAgICAgICAgICAgZmV0Y2godXJsKS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKSxcclxuICAgICAgICB9fVxyXG4gICAgICA+XHJcbiAgICAgICAgPFJlY29pbFJvb3Q+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIiBtaW4tdy1bMzAwcHhdICBtYXgtaC1maXQgZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgbWluLWgtWzEwMHZoXSByZWxhdGl2ZVwiPlxyXG4gICAgICAgICAgICA8VG9wIC8+XHJcbiAgICAgICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cIiBtdC0xMCBteC0zIGZsZXgtY29sdW1uIGl0ZW1zLWNlbnRlciBwYi1bNjBweF1cIj5cclxuICAgICAgICAgICAgICA8Q29tcG9uZW50IHsuLi5wYWdlUHJvcHN9IC8+XHJcbiAgICAgICAgICAgIDwvc2VjdGlvbj5cclxuICAgICAgICAgICAgPEZvb3RlciAvPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9SZWNvaWxSb290PlxyXG4gICAgICA8L1NXUkNvbmZpZz5cclxuICAgIDwvU2Vzc2lvblByb3ZpZGVyPlxyXG4gICk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE15QXBwO1xyXG4iXSwibmFtZXMiOlsiVG9wIiwiRm9vdGVyIiwiU2Vzc2lvblByb3ZpZGVyIiwiU1dSQ29uZmlnIiwiUmVjb2lsUm9vdCIsIk15QXBwIiwiQ29tcG9uZW50IiwicGFnZVByb3BzIiwic2Vzc2lvbiIsInZhbHVlIiwiZmV0Y2hlciIsInVybCIsImZldGNoIiwidGhlbiIsInJlc3BvbnNlIiwianNvbiIsImRpdiIsImNsYXNzTmFtZSIsInNlY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/_app.tsx\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_define_property.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_define_property.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _defineProperty; }\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fZGVmaW5lX3Byb3BlcnR5Lm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWUsU0FBU0EsZUFBVCxDQUF5QkMsR0FBekIsRUFBOEJDLEdBQTlCLEVBQW1DQyxLQUFuQyxFQUEwQztFQUN2RCxJQUFJRCxHQUFHLElBQUlELEdBQVgsRUFBZ0I7SUFDZEcsTUFBTSxDQUFDQyxjQUFQLENBQXNCSixHQUF0QixFQUEyQkMsR0FBM0IsRUFBZ0M7TUFDOUJDLEtBQUssRUFBRUEsS0FEdUI7TUFFOUJHLFVBQVUsRUFBRSxJQUZrQjtNQUc5QkMsWUFBWSxFQUFFLElBSGdCO01BSTlCQyxRQUFRLEVBQUU7SUFKb0IsQ0FBaEM7RUFNRCxDQVBELE1BT087SUFDTFAsR0FBRyxDQUFDQyxHQUFELENBQUgsR0FBV0MsS0FBWDtFQUNEOztFQUVELE9BQU9GLEdBQVA7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fZGVmaW5lX3Byb3BlcnR5Lm1qcz9iNTEyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuIl0sIm5hbWVzIjpbIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_define_property.mjs\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_object_spread.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_object_spread.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectSpread; }\n/* harmony export */ });\n/* harmony import */ var _define_property_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_define_property.mjs */ \"./node_modules/@swc/helpers/src/_define_property.mjs\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      (0,_define_property_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]);\n    });\n  }\n\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fb2JqZWN0X3NwcmVhZC5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUVlLFNBQVNDLGFBQVQsQ0FBdUJDLE1BQXZCLEVBQStCO0VBQzVDLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0MsU0FBUyxDQUFDQyxNQUE5QixFQUFzQ0YsQ0FBQyxFQUF2QyxFQUEyQztJQUN6QyxJQUFJRyxNQUFNLEdBQUdGLFNBQVMsQ0FBQ0QsQ0FBRCxDQUFULElBQWdCLElBQWhCLEdBQXVCQyxTQUFTLENBQUNELENBQUQsQ0FBaEMsR0FBc0MsRUFBbkQ7SUFDQSxJQUFJSSxPQUFPLEdBQUdDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZSCxNQUFaLENBQWQ7O0lBRUEsSUFBSSxPQUFPRSxNQUFNLENBQUNFLHFCQUFkLEtBQXdDLFVBQTVDLEVBQXdEO01BQ3RESCxPQUFPLEdBQUdBLE9BQU8sQ0FBQ0ksTUFBUixDQUFlSCxNQUFNLENBQUNFLHFCQUFQLENBQTZCSixNQUE3QixFQUFxQ00sTUFBckMsQ0FBNEMsVUFBVUMsR0FBVixFQUFlO1FBQ2xGLE9BQU9MLE1BQU0sQ0FBQ00sd0JBQVAsQ0FBZ0NSLE1BQWhDLEVBQXdDTyxHQUF4QyxFQUE2Q0UsVUFBcEQ7TUFDRCxDQUZ3QixDQUFmLENBQVY7SUFHRDs7SUFFRFIsT0FBTyxDQUFDUyxPQUFSLENBQWdCLFVBQVVDLEdBQVYsRUFBZTtNQUM3QmpCLGdFQUFjLENBQUNFLE1BQUQsRUFBU2UsR0FBVCxFQUFjWCxNQUFNLENBQUNXLEdBQUQsQ0FBcEIsQ0FBZDtJQUNELENBRkQ7RUFHRDs7RUFFRCxPQUFPZixNQUFQO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9zcmMvX29iamVjdF9zcHJlYWQubWpzPzdkNDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gJy4vX2RlZmluZV9wcm9wZXJ0eS5tanMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59Il0sIm5hbWVzIjpbImRlZmluZVByb3BlcnR5IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJvd25LZXlzIiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImNvbmNhdCIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJmb3JFYWNoIiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_object_spread.mjs\n"));

/***/ }),

/***/ "./node_modules/swr/dist/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/swr/dist/index.mjs ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SWRConfig\": function() { return /* binding */ SWRConfig; },\n/* harmony export */   \"default\": function() { return /* binding */ useSWR; },\n/* harmony export */   \"mutate\": function() { return /* binding */ mutate; },\n/* harmony export */   \"unstable_serialize\": function() { return /* binding */ unstable_serialize; },\n/* harmony export */   \"useSWRConfig\": function() { return /* binding */ useSWRConfig; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nvar noop = function () {}; // Using noop() as the undefined value as undefined can possibly be replaced\n// by something else.  Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\n\n\nvar UNDEFINED =\n/*#__NOINLINE__*/\nnoop();\nvar OBJECT = Object;\n\nvar isUndefined = function (v) {\n  return v === UNDEFINED;\n};\n\nvar isFunction = function (v) {\n  return typeof v == 'function';\n};\n\nvar mergeObjects = function (a, b) {\n  return OBJECT.assign({}, a, b);\n};\n\nvar STR_UNDEFINED = 'undefined'; // NOTE: Use function to guarantee it's re-evaluated between jsdom and node runtime for tests.\n\nvar hasWindow = function () {\n  return typeof window != STR_UNDEFINED;\n};\n\nvar hasDocument = function () {\n  return typeof document != STR_UNDEFINED;\n};\n\nvar hasRequestAnimationFrame = function () {\n  return hasWindow() && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\n}; // use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\n\n\nvar table = new WeakMap(); // counter of the key\n\nvar counter = 0; // A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsible.\n\nvar stableHash = function (arg) {\n  var type = typeof arg;\n  var constructor = arg && arg.constructor;\n  var isDate = constructor == Date;\n  var result;\n  var index;\n\n  if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n    // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n    // If it's already hashed, directly return the result.\n    result = table.get(arg);\n    if (result) return result; // Store the hash first for circular reference detection before entering the\n    // recursive `stableHash` calls.\n    // For other objects like set and map, we use this id directly as the hash.\n\n    result = ++counter + '~';\n    table.set(arg, result);\n\n    if (constructor == Array) {\n      // Array.\n      result = '@';\n\n      for (index = 0; index < arg.length; index++) {\n        result += stableHash(arg[index]) + ',';\n      }\n\n      table.set(arg, result);\n    }\n\n    if (constructor == OBJECT) {\n      // Object, sort keys.\n      result = '#';\n      var keys = OBJECT.keys(arg).sort();\n\n      while (!isUndefined(index = keys.pop())) {\n        if (!isUndefined(arg[index])) {\n          result += index + ':' + stableHash(arg[index]) + ',';\n        }\n      }\n\n      table.set(arg, result);\n    }\n  } else {\n    result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n  }\n\n  return result;\n};\n/**\r\n * Due to bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\r\n * it's not reliable to detect if the browser is currently online or offline\r\n * based on `navigator.onLine`.\r\n * As a work around, we always assume it's online on first load, and change\r\n * the status upon `online` or `offline` events.\r\n */\n\n\nvar online = true;\n\nvar isOnline = function () {\n  return online;\n};\n\nvar hasWin = hasWindow();\nvar hasDoc = hasDocument(); // For node and React Native, `add/removeEventListener` doesn't exist on window.\n\nvar onWindowEvent = hasWin && window.addEventListener ? window.addEventListener.bind(window) : noop;\nvar onDocumentEvent = hasDoc ? document.addEventListener.bind(document) : noop;\nvar offWindowEvent = hasWin && window.removeEventListener ? window.removeEventListener.bind(window) : noop;\nvar offDocumentEvent = hasDoc ? document.removeEventListener.bind(document) : noop;\n\nvar isVisible = function () {\n  var visibilityState = hasDoc && document.visibilityState;\n  return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\n\nvar initFocus = function (callback) {\n  // focus revalidate\n  onDocumentEvent('visibilitychange', callback);\n  onWindowEvent('focus', callback);\n  return function () {\n    offDocumentEvent('visibilitychange', callback);\n    offWindowEvent('focus', callback);\n  };\n};\n\nvar initReconnect = function (callback) {\n  // revalidate on reconnected\n  var onOnline = function () {\n    online = true;\n    callback();\n  }; // nothing to revalidate, just update the status\n\n\n  var onOffline = function () {\n    online = false;\n  };\n\n  onWindowEvent('online', onOnline);\n  onWindowEvent('offline', onOffline);\n  return function () {\n    offWindowEvent('online', onOnline);\n    offWindowEvent('offline', onOffline);\n  };\n};\n\nvar preset = {\n  isOnline: isOnline,\n  isVisible: isVisible\n};\nvar defaultConfigOptions = {\n  initFocus: initFocus,\n  initReconnect: initReconnect\n};\nvar IS_SERVER = !hasWindow() || 'Deno' in window; // Polyfill requestAnimationFrame\n\nvar rAF = function (f) {\n  return hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);\n}; // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\n\n\nvar useIsomorphicLayoutEffect = IS_SERVER ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect; // This assignment is to extend the Navigator type to use effectiveType.\n\nvar navigatorConnection = typeof navigator !== 'undefined' && navigator.connection; // Adjust the config based on slow connection status (<= 70Kbps).\n\nvar slowConnection = !IS_SERVER && navigatorConnection && (['slow-2g', '2g'].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\n\nvar serialize = function (key) {\n  if (isFunction(key)) {\n    try {\n      key = key();\n    } catch (err) {\n      // dependencies not ready\n      key = '';\n    }\n  }\n\n  var args = [].concat(key); // If key is not falsy, or not an empty array, hash it.\n\n  key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n  var infoKey = key ? '$swr$' + key : '';\n  return [key, args, infoKey];\n}; // Global state used to deduplicate requests and store listeners\n\n\nvar SWRGlobalState = new WeakMap();\nvar FOCUS_EVENT = 0;\nvar RECONNECT_EVENT = 1;\nvar MUTATE_EVENT = 2;\n\nvar broadcastState = function (cache, key, data, error, isValidating, revalidate, broadcast) {\n  if (broadcast === void 0) {\n    broadcast = true;\n  }\n\n  var _a = SWRGlobalState.get(cache),\n      EVENT_REVALIDATORS = _a[0],\n      STATE_UPDATERS = _a[1],\n      FETCH = _a[3];\n\n  var revalidators = EVENT_REVALIDATORS[key];\n  var updaters = STATE_UPDATERS[key]; // Cache was populated, update states of all hooks.\n\n  if (broadcast && updaters) {\n    for (var i = 0; i < updaters.length; ++i) {\n      updaters[i](data, error, isValidating);\n    }\n  } // If we also need to revalidate, only do it for the first hook.\n\n\n  if (revalidate) {\n    // Invalidate the key by deleting the concurrent request markers so new\n    // requests will not be deduped.\n    delete FETCH[key];\n\n    if (revalidators && revalidators[0]) {\n      return revalidators[0](MUTATE_EVENT).then(function () {\n        return cache.get(key);\n      });\n    }\n  }\n\n  return cache.get(key);\n}; // Global timestamp.\n\n\nvar __timestamp = 0;\n\nvar getTimestamp = function () {\n  return ++__timestamp;\n};\n\nvar internalMutate = function () {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  return __awaiter(void 0, void 0, void 0, function () {\n    var cache, _key, _data, _opts, options, populateCache, revalidate, rollbackOnError, customOptimisticData, _a, key, keyInfo, _b, MUTATION, data, error, beforeMutationTs, hasCustomOptimisticData, rollbackData, optimisticData, res;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          cache = args[0], _key = args[1], _data = args[2], _opts = args[3];\n          options = typeof _opts === 'boolean' ? {\n            revalidate: _opts\n          } : _opts || {};\n          populateCache = isUndefined(options.populateCache) ? true : options.populateCache;\n          revalidate = options.revalidate !== false;\n          rollbackOnError = options.rollbackOnError !== false;\n          customOptimisticData = options.optimisticData;\n          _a = serialize(_key), key = _a[0], keyInfo = _a[2];\n          if (!key) return [2\n          /*return*/\n          ];\n          _b = SWRGlobalState.get(cache), MUTATION = _b[2]; // If there is no new data provided, revalidate the key with current state.\n\n          if (args.length < 3) {\n            // Revalidate and broadcast state.\n            return [2\n            /*return*/\n            , broadcastState(cache, key, cache.get(key), UNDEFINED, UNDEFINED, revalidate, true)];\n          }\n\n          data = _data;\n          beforeMutationTs = getTimestamp();\n          MUTATION[key] = [beforeMutationTs, 0];\n          hasCustomOptimisticData = !isUndefined(customOptimisticData);\n          rollbackData = cache.get(key); // Do optimistic data update.\n\n          if (hasCustomOptimisticData) {\n            optimisticData = isFunction(customOptimisticData) ? customOptimisticData(rollbackData) : customOptimisticData;\n            cache.set(key, optimisticData);\n            broadcastState(cache, key, optimisticData);\n          }\n\n          if (isFunction(data)) {\n            // `data` is a function, call it passing current cache value.\n            try {\n              data = data(cache.get(key));\n            } catch (err) {\n              // If it throws an error synchronously, we shouldn't update the cache.\n              error = err;\n            }\n          }\n\n          if (!(data && isFunction(data.then))) return [3\n          /*break*/\n          , 2];\n          return [4\n          /*yield*/\n          , data.catch(function (err) {\n            error = err;\n          }) // Check if other mutations have occurred since we've started this mutation.\n          // If there's a race we don't update cache or broadcast the change,\n          // just return the data.\n          ];\n\n        case 1:\n          // This means that the mutation is async, we need to check timestamps to\n          // avoid race conditions.\n          data = _c.sent(); // Check if other mutations have occurred since we've started this mutation.\n          // If there's a race we don't update cache or broadcast the change,\n          // just return the data.\n\n          if (beforeMutationTs !== MUTATION[key][0]) {\n            if (error) throw error;\n            return [2\n            /*return*/\n            , data];\n          } else if (error && hasCustomOptimisticData && rollbackOnError) {\n            // Rollback. Always populate the cache in this case but without\n            // transforming the data.\n            populateCache = true;\n            data = rollbackData;\n            cache.set(key, rollbackData);\n          }\n\n          _c.label = 2;\n\n        case 2:\n          // If we should write back the cache after request.\n          if (populateCache) {\n            if (!error) {\n              // Transform the result into data.\n              if (isFunction(populateCache)) {\n                data = populateCache(data, rollbackData);\n              } // Only update cached data if there's no error. Data can be `undefined` here.\n\n\n              cache.set(key, data);\n            } // Always update or reset the error.\n\n\n            cache.set(keyInfo, mergeObjects(cache.get(keyInfo), {\n              error: error\n            }));\n          } // Reset the timestamp to mark the mutation has ended.\n\n\n          MUTATION[key][1] = getTimestamp();\n          return [4\n          /*yield*/\n          , broadcastState(cache, key, data, error, UNDEFINED, revalidate, !!populateCache) // Throw error or return data\n          ];\n\n        case 3:\n          res = _c.sent(); // Throw error or return data\n\n          if (error) throw error;\n          return [2\n          /*return*/\n          , populateCache ? res : data];\n      }\n    });\n  });\n};\n\nvar revalidateAllKeys = function (revalidators, type) {\n  for (var key in revalidators) {\n    if (revalidators[key][0]) revalidators[key][0](type);\n  }\n};\n\nvar initCache = function (provider, options) {\n  // The global state for a specific provider will be used to deduplicate\n  // requests and store listeners. As well as a mutate function that bound to\n  // the cache.\n  // Provider's global state might be already initialized. Let's try to get the\n  // global state associated with the provider first.\n  if (!SWRGlobalState.has(provider)) {\n    var opts = mergeObjects(defaultConfigOptions, options); // If there's no global state bound to the provider, create a new one with the\n    // new mutate function.\n\n    var EVENT_REVALIDATORS = {};\n    var mutate = internalMutate.bind(UNDEFINED, provider);\n    var unmount = noop; // Update the state if it's new, or the provider has been extended.\n\n    SWRGlobalState.set(provider, [EVENT_REVALIDATORS, {}, {}, {}, mutate]); // This is a new provider, we need to initialize it and setup DOM events\n    // listeners for `focus` and `reconnect` actions.\n\n    if (!IS_SERVER) {\n      // When listening to the native events for auto revalidations,\n      // we intentionally put a delay (setTimeout) here to make sure they are\n      // fired after immediate JavaScript executions, which can possibly be\n      // React's state updates.\n      // This avoids some unnecessary revalidations such as\n      // https://github.com/vercel/swr/issues/1680.\n      var releaseFocus_1 = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n      var releaseReconnect_1 = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n\n      unmount = function () {\n        releaseFocus_1 && releaseFocus_1();\n        releaseReconnect_1 && releaseReconnect_1(); // When un-mounting, we need to remove the cache provider from the state\n        // storage too because it's a side-effect. Otherwise when re-mounting we\n        // will not re-register those event listeners.\n\n        SWRGlobalState.delete(provider);\n      };\n    } // We might want to inject an extra layer on top of `provider` in the future,\n    // such as key serialization, auto GC, etc.\n    // For now, it's just a `Map` interface without any modifications.\n\n\n    return [provider, mutate, unmount];\n  }\n\n  return [provider, SWRGlobalState.get(provider)[4]];\n}; // error retry\n\n\nvar onErrorRetry = function (_, __, config, revalidate, opts) {\n  var maxRetryCount = config.errorRetryCount;\n  var currentRetryCount = opts.retryCount; // Exponential backoff\n\n  var timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n\n  if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n    return;\n  }\n\n  setTimeout(revalidate, timeout, opts);\n}; // Default cache provider\n\n\nvar _a = initCache(new Map()),\n    cache = _a[0],\n    mutate = _a[1]; // Default config\n\n\nvar defaultConfig = mergeObjects({\n  // events\n  onLoadingSlow: noop,\n  onSuccess: noop,\n  onError: noop,\n  onErrorRetry: onErrorRetry,\n  onDiscarded: noop,\n  // switches\n  revalidateOnFocus: true,\n  revalidateOnReconnect: true,\n  revalidateIfStale: true,\n  shouldRetryOnError: true,\n  // timeouts\n  errorRetryInterval: slowConnection ? 10000 : 5000,\n  focusThrottleInterval: 5 * 1000,\n  dedupingInterval: 2 * 1000,\n  loadingTimeout: slowConnection ? 5000 : 3000,\n  // providers\n  compare: function (currentData, newData) {\n    return stableHash(currentData) == stableHash(newData);\n  },\n  isPaused: function () {\n    return false;\n  },\n  cache: cache,\n  mutate: mutate,\n  fallback: {}\n}, // use web preset by default\npreset);\n\nvar mergeConfigs = function (a, b) {\n  // Need to create a new object to avoid mutating the original here.\n  var v = mergeObjects(a, b); // If two configs are provided, merge their `use` and `fallback` options.\n\n  if (b) {\n    var u1 = a.use,\n        f1 = a.fallback;\n    var u2 = b.use,\n        f2 = b.fallback;\n\n    if (u1 && u2) {\n      v.use = u1.concat(u2);\n    }\n\n    if (f1 && f2) {\n      v.fallback = mergeObjects(f1, f2);\n    }\n  }\n\n  return v;\n};\n\nvar SWRConfigContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\n\nvar SWRConfig$1 = function (props) {\n  var value = props.value; // Extend parent context values and middleware.\n\n  var extendedConfig = mergeConfigs((0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext), value); // Should not use the inherited provider.\n\n  var provider = value && value.provider; // Use a lazy initialized state to create the cache on first access.\n\n  var cacheContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function () {\n    return provider ? initCache(provider(extendedConfig.cache || cache), value) : UNDEFINED;\n  })[0]; // Override the cache if a new provider is given.\n\n  if (cacheContext) {\n    extendedConfig.cache = cacheContext[0];\n    extendedConfig.mutate = cacheContext[1];\n  } // Unsubscribe events.\n\n\n  useIsomorphicLayoutEffect(function () {\n    return cacheContext ? cacheContext[2] : UNDEFINED;\n  }, []);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SWRConfigContext.Provider, mergeObjects(props, {\n    value: extendedConfig\n  }));\n};\n/**\r\n * An implementation of state with dependency-tracking.\r\n */\n\n\nvar useStateWithDeps = function (state, unmountedRef) {\n  var rerender = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({})[1];\n  var stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state); // If a state property (data, error or isValidating) is accessed by the render\n  // function, we mark the property as a dependency so if it is updated again\n  // in the future, we trigger a rerender.\n  // This is also known as dependency-tracking.\n\n  var stateDependenciesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    data: false,\n    error: false,\n    isValidating: false\n  });\n  /**\r\n   * @param payload To change stateRef, pass the values explicitly to setState:\r\n   * @example\r\n   * ```js\r\n   * setState({\r\n   *   isValidating: false\r\n   *   data: newData // set data to newData\r\n   *   error: undefined // set error to undefined\r\n   * })\r\n   *\r\n   * setState({\r\n   *   isValidating: false\r\n   *   data: undefined // set data to undefined\r\n   *   error: err // set error to err\r\n   * })\r\n   * ```\r\n   */\n\n  var setState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (payload) {\n    var shouldRerender = false;\n    var currentState = stateRef.current;\n\n    for (var _ in payload) {\n      var k = _; // If the property has changed, update the state and mark rerender as\n      // needed.\n\n      if (currentState[k] !== payload[k]) {\n        currentState[k] = payload[k]; // If the property is accessed by the component, a rerender should be\n        // triggered.\n\n        if (stateDependenciesRef.current[k]) {\n          shouldRerender = true;\n        }\n      }\n    }\n\n    if (shouldRerender && !unmountedRef.current) {\n      rerender({});\n    }\n  }, // config.suspense isn't allowed to change during the lifecycle\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []); // Always update the state reference.\n\n  useIsomorphicLayoutEffect(function () {\n    stateRef.current = state;\n  });\n  return [stateRef, stateDependenciesRef.current, setState];\n};\n\nvar normalize = function (args) {\n  return isFunction(args[1]) ? [args[0], args[1], args[2] || {}] : [args[0], null, (args[1] === null ? args[2] : args[1]) || {}];\n};\n\nvar useSWRConfig = function () {\n  return mergeObjects(defaultConfig, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext));\n}; // It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\n\n\nvar withArgs = function (hook) {\n  return function useSWRArgs() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    } // Get the default and inherited configuration.\n\n\n    var fallbackConfig = useSWRConfig(); // Normalize arguments.\n\n    var _a = normalize(args),\n        key = _a[0],\n        fn = _a[1],\n        _config = _a[2]; // Merge configurations.\n\n\n    var config = mergeConfigs(fallbackConfig, _config); // Apply middleware\n\n    var next = hook;\n    var use = config.use;\n\n    if (use) {\n      for (var i = use.length; i-- > 0;) {\n        next = use[i](next);\n      }\n    }\n\n    return next(key, fn || config.fetcher, config);\n  };\n}; // Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\n\n\nvar subscribeCallback = function (key, callbacks, callback) {\n  var keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n  keyedRevalidators.push(callback);\n  return function () {\n    var index = keyedRevalidators.indexOf(callback);\n\n    if (index >= 0) {\n      // O(1): faster than splice\n      keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n      keyedRevalidators.pop();\n    }\n  };\n};\n\nvar WITH_DEDUPE = {\n  dedupe: true\n};\n\nvar useSWRHandler = function (_key, fetcher, config) {\n  var cache = config.cache,\n      compare = config.compare,\n      fallbackData = config.fallbackData,\n      suspense = config.suspense,\n      revalidateOnMount = config.revalidateOnMount,\n      refreshInterval = config.refreshInterval,\n      refreshWhenHidden = config.refreshWhenHidden,\n      refreshWhenOffline = config.refreshWhenOffline;\n\n  var _a = SWRGlobalState.get(cache),\n      EVENT_REVALIDATORS = _a[0],\n      STATE_UPDATERS = _a[1],\n      MUTATION = _a[2],\n      FETCH = _a[3]; // `key` is the identifier of the SWR `data` state, `keyInfo` holds extra\n  // states such as `error` and `isValidating` inside,\n  // all of them are derived from `_key`.\n  // `fnArgs` is an array of arguments parsed from the key, which will be passed\n  // to the fetcher.\n\n\n  var _b = serialize(_key),\n      key = _b[0],\n      fnArgs = _b[1],\n      keyInfo = _b[2]; // If it's the initial render of this hook.\n\n\n  var initialMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false); // If the hook is unmounted already. This will be used to prevent some effects\n  // to be called after unmounting.\n\n  var unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false); // Refs to keep the key and config.\n\n  var keyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(key);\n  var fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fetcher);\n  var configRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(config);\n\n  var getConfig = function () {\n    return configRef.current;\n  };\n\n  var isActive = function () {\n    return getConfig().isVisible() && getConfig().isOnline();\n  };\n\n  var patchFetchInfo = function (info) {\n    return cache.set(keyInfo, mergeObjects(cache.get(keyInfo), info));\n  }; // Get the current state that SWR should return.\n\n\n  var cached = cache.get(key);\n  var fallback = isUndefined(fallbackData) ? config.fallback[key] : fallbackData;\n  var data = isUndefined(cached) ? fallback : cached;\n  var info = cache.get(keyInfo) || {};\n  var error = info.error;\n  var isInitialMount = !initialMountedRef.current; // - Suspense mode and there's stale data for the initial render.\n  // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.\n  // - `revalidateIfStale` is enabled but `data` is not defined.\n\n  var shouldRevalidate = function () {\n    // If `revalidateOnMount` is set, we take the value directly.\n    if (isInitialMount && !isUndefined(revalidateOnMount)) return revalidateOnMount; // If it's paused, we skip revalidation.\n\n    if (getConfig().isPaused()) return false; // Under suspense mode, it will always fetch on render if there is no\n    // stale data so no need to revalidate immediately on mount again.\n    // If data exists, only revalidate if `revalidateIfStale` is true.\n\n    if (suspense) return isUndefined(data) ? false : config.revalidateIfStale; // If there is no stale data, we need to revalidate on mount;\n    // If `revalidateIfStale` is set to true, we will always revalidate.\n\n    return isUndefined(data) || config.revalidateIfStale;\n  }; // Resolve the current validating state.\n\n\n  var resolveValidating = function () {\n    if (!key || !fetcher) return false;\n    if (info.isValidating) return true; // If it's not mounted yet and it should revalidate on mount, revalidate.\n\n    return isInitialMount && shouldRevalidate();\n  };\n\n  var isValidating = resolveValidating();\n\n  var _c = useStateWithDeps({\n    data: data,\n    error: error,\n    isValidating: isValidating\n  }, unmountedRef),\n      stateRef = _c[0],\n      stateDependencies = _c[1],\n      setState = _c[2]; // The revalidation function is a carefully crafted wrapper of the original\n  // `fetcher`, to correctly handle the many edge cases.\n\n\n  var revalidate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (revalidateOpts) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var currentFetcher, newData, startAt, loading, opts, shouldStartNewRequest, isCurrentKeyMounted, cleanupState, newState, finishRequestAndUpdateState, mutationInfo, err_1;\n\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            currentFetcher = fetcherRef.current;\n\n            if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {\n              return [2\n              /*return*/\n              , false];\n            }\n\n            loading = true;\n            opts = revalidateOpts || {};\n            shouldStartNewRequest = !FETCH[key] || !opts.dedupe;\n\n            isCurrentKeyMounted = function () {\n              return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;\n            };\n\n            cleanupState = function () {\n              // Check if it's still the same request before deleting.\n              var requestInfo = FETCH[key];\n\n              if (requestInfo && requestInfo[1] === startAt) {\n                delete FETCH[key];\n              }\n            };\n\n            newState = {\n              isValidating: false\n            };\n\n            finishRequestAndUpdateState = function () {\n              patchFetchInfo({\n                isValidating: false\n              }); // We can only set state if it's safe (still mounted with the same key).\n\n              if (isCurrentKeyMounted()) {\n                setState(newState);\n              }\n            }; // Start fetching. Change the `isValidating` state, update the cache.\n\n\n            patchFetchInfo({\n              isValidating: true\n            });\n            setState({\n              isValidating: true\n            });\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n\n            if (shouldStartNewRequest) {\n              // Tell all other hooks to change the `isValidating` state.\n              broadcastState(cache, key, stateRef.current.data, stateRef.current.error, true); // If no cache being rendered currently (it shows a blank page),\n              // we trigger the loading slow event.\n\n              if (config.loadingTimeout && !cache.get(key)) {\n                setTimeout(function () {\n                  if (loading && isCurrentKeyMounted()) {\n                    getConfig().onLoadingSlow(key, config);\n                  }\n                }, config.loadingTimeout);\n              } // Start the request and save the timestamp.\n\n\n              FETCH[key] = [currentFetcher.apply(void 0, fnArgs), getTimestamp()];\n            }\n\n            _a = FETCH[key], newData = _a[0], startAt = _a[1];\n            return [4\n            /*yield*/\n            , newData];\n\n          case 2:\n            newData = _b.sent();\n\n            if (shouldStartNewRequest) {\n              // If the request isn't interrupted, clean it up after the\n              // deduplication interval.\n              setTimeout(cleanupState, config.dedupingInterval);\n            } // If there're other ongoing request(s), started after the current one,\n            // we need to ignore the current one to avoid possible race conditions:\n            //   req1------------------>res1        (current one)\n            //        req2---------------->res2\n            // the request that fired later will always be kept.\n            // The timestamp maybe be `undefined` or a number\n\n\n            if (!FETCH[key] || FETCH[key][1] !== startAt) {\n              if (shouldStartNewRequest) {\n                if (isCurrentKeyMounted()) {\n                  getConfig().onDiscarded(key);\n                }\n              }\n\n              return [2\n              /*return*/\n              , false];\n            } // Clear error.\n\n\n            patchFetchInfo({\n              error: UNDEFINED\n            });\n            newState.error = UNDEFINED;\n            mutationInfo = MUTATION[key];\n\n            if (!isUndefined(mutationInfo) && ( // case 1\n            startAt <= mutationInfo[0] || // case 2\n            startAt <= mutationInfo[1] || // case 3\n            mutationInfo[1] === 0)) {\n              finishRequestAndUpdateState();\n\n              if (shouldStartNewRequest) {\n                if (isCurrentKeyMounted()) {\n                  getConfig().onDiscarded(key);\n                }\n              }\n\n              return [2\n              /*return*/\n              , false];\n            } // Deep compare with latest state to avoid extra re-renders.\n            // For local state, compare and assign.\n\n\n            if (!compare(stateRef.current.data, newData)) {\n              newState.data = newData;\n            } else {\n              // data and newData are deeply equal\n              // it should be safe to broadcast the stale data\n              newState.data = stateRef.current.data; // At the end of this function, `brocastState` invokes the `onStateUpdate` function,\n              // which takes care of avoiding the re-render\n            } // For global state, it's possible that the key has changed.\n            // https://github.com/vercel/swr/pull/1058\n\n\n            if (!compare(cache.get(key), newData)) {\n              cache.set(key, newData);\n            } // Trigger the successful callback if it's the original request.\n\n\n            if (shouldStartNewRequest) {\n              if (isCurrentKeyMounted()) {\n                getConfig().onSuccess(newData, key, config);\n              }\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            err_1 = _b.sent();\n            cleanupState(); // Not paused, we continue handling the error. Otherwise discard it.\n\n            if (!getConfig().isPaused()) {\n              // Get a new error, don't use deep comparison for errors.\n              patchFetchInfo({\n                error: err_1\n              });\n              newState.error = err_1; // Error event and retry logic. Only for the actual request, not\n              // deduped ones.\n\n              if (shouldStartNewRequest && isCurrentKeyMounted()) {\n                getConfig().onError(err_1, key, config);\n\n                if (typeof config.shouldRetryOnError === 'boolean' && config.shouldRetryOnError || isFunction(config.shouldRetryOnError) && config.shouldRetryOnError(err_1)) {\n                  // When retrying, dedupe is always enabled\n                  if (isActive()) {\n                    // If it's active, stop. It will auto revalidate when refocusing\n                    // or reconnecting.\n                    getConfig().onErrorRetry(err_1, key, config, revalidate, {\n                      retryCount: (opts.retryCount || 0) + 1,\n                      dedupe: true\n                    });\n                  }\n                }\n              }\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            // Mark loading as stopped.\n            loading = false; // Update the current hook's state.\n\n            finishRequestAndUpdateState(); // Here is the source of the request, need to tell all other hooks to\n            // update their states.\n\n            if (isCurrentKeyMounted() && shouldStartNewRequest) {\n              broadcastState(cache, key, newState.data, newState.error, false);\n            }\n\n            return [2\n            /*return*/\n            , true];\n        }\n      });\n    });\n  }, // `setState` is immutable, and `eventsCallback`, `fnArgs`, `keyInfo`,\n  // and `keyValidating` are depending on `key`, so we can exclude them from\n  // the deps array.\n  //\n  // FIXME:\n  // `fn` and `config` might be changed during the lifecycle,\n  // but they might be changed every render like this.\n  // `useSWR('key', () => fetch('/api/'), { suspense: true })`\n  // So we omit the values from the deps array\n  // even though it might cause unexpected behaviors.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [key]); // Similar to the global mutate, but bound to the current cache and key.\n  // `cache` isn't allowed to change during the lifecycle.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  var boundMutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)( // By using `bind` we don't need to modify the size of the rest arguments.\n  // Due to https://github.com/microsoft/TypeScript/issues/37181, we have to\n  // cast it to any for now.\n  internalMutate.bind(UNDEFINED, cache, function () {\n    return keyRef.current;\n  }), // eslint-disable-next-line react-hooks/exhaustive-deps\n  []); // Always update fetcher and config refs.\n\n  useIsomorphicLayoutEffect(function () {\n    fetcherRef.current = fetcher;\n    configRef.current = config;\n  }); // After mounted or key changed.\n\n  useIsomorphicLayoutEffect(function () {\n    if (!key) return;\n    var keyChanged = key !== keyRef.current;\n    var softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE); // Expose state updater to global event listeners. So we can update hook's\n    // internal state from the outside.\n\n    var onStateUpdate = function (updatedData, updatedError, updatedIsValidating) {\n      setState(mergeObjects({\n        error: updatedError,\n        isValidating: updatedIsValidating\n      }, // Since `setState` only shallowly compares states, we do a deep\n      // comparison here.\n      compare(stateRef.current.data, updatedData) ? UNDEFINED : {\n        data: updatedData\n      }));\n    }; // Expose revalidators to global event listeners. So we can trigger\n    // revalidation from the outside.\n\n\n    var nextFocusRevalidatedAt = 0;\n\n    var onRevalidate = function (type) {\n      if (type == FOCUS_EVENT) {\n        var now = Date.now();\n\n        if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {\n          nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;\n          softRevalidate();\n        }\n      } else if (type == RECONNECT_EVENT) {\n        if (getConfig().revalidateOnReconnect && isActive()) {\n          softRevalidate();\n        }\n      } else if (type == MUTATE_EVENT) {\n        return revalidate();\n      }\n\n      return;\n    };\n\n    var unsubUpdate = subscribeCallback(key, STATE_UPDATERS, onStateUpdate);\n    var unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate); // Mark the component as mounted and update corresponding refs.\n\n    unmountedRef.current = false;\n    keyRef.current = key;\n    initialMountedRef.current = true; // When `key` updates, reset the state to the initial value\n    // and trigger a rerender if necessary.\n\n    if (keyChanged) {\n      setState({\n        data: data,\n        error: error,\n        isValidating: isValidating\n      });\n    } // Trigger a revalidation.\n\n\n    if (shouldRevalidate()) {\n      if (isUndefined(data) || IS_SERVER) {\n        // Revalidate immediately.\n        softRevalidate();\n      } else {\n        // Delay the revalidate if we have data to return so we won't block\n        // rendering.\n        rAF(softRevalidate);\n      }\n    }\n\n    return function () {\n      // Mark it as unmounted.\n      unmountedRef.current = true;\n      unsubUpdate();\n      unsubEvents();\n    };\n  }, [key, revalidate]); // Polling\n\n  useIsomorphicLayoutEffect(function () {\n    var timer;\n\n    function next() {\n      // Use the passed interval\n      // ...or invoke the function with the updated data to get the interval\n      var interval = isFunction(refreshInterval) ? refreshInterval(data) : refreshInterval; // We only start next interval if `refreshInterval` is not 0, and:\n      // - `force` is true, which is the start of polling\n      // - or `timer` is not 0, which means the effect wasn't canceled\n\n      if (interval && timer !== -1) {\n        timer = setTimeout(execute, interval);\n      }\n    }\n\n    function execute() {\n      // Check if it's OK to execute:\n      // Only revalidate when the page is visible, online and not errored.\n      if (!stateRef.current.error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {\n        revalidate(WITH_DEDUPE).then(next);\n      } else {\n        // Schedule next interval to check again.\n        next();\n      }\n    }\n\n    next();\n    return function () {\n      if (timer) {\n        clearTimeout(timer);\n        timer = -1;\n      }\n    };\n  }, [refreshInterval, refreshWhenHidden, refreshWhenOffline, revalidate]); // Display debug info in React DevTools.\n\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(data); // In Suspense mode, we can't return the empty `data` state.\n  // If there is `error`, the `error` needs to be thrown to the error boundary.\n  // If there is no `error`, the `revalidation` promise needs to be thrown to\n  // the suspense boundary.\n\n  if (suspense && isUndefined(data) && key) {\n    // Always update fetcher and config refs even with the Suspense mode.\n    fetcherRef.current = fetcher;\n    configRef.current = config;\n    unmountedRef.current = false;\n    throw isUndefined(error) ? revalidate(WITH_DEDUPE) : error;\n  }\n\n  return {\n    mutate: boundMutate,\n\n    get data() {\n      stateDependencies.data = true;\n      return data;\n    },\n\n    get error() {\n      stateDependencies.error = true;\n      return error;\n    },\n\n    get isValidating() {\n      stateDependencies.isValidating = true;\n      return isValidating;\n    }\n\n  };\n};\n\nvar SWRConfig = OBJECT.defineProperty(SWRConfig$1, 'default', {\n  value: defaultConfig\n});\n\nvar unstable_serialize = function (key) {\n  return serialize(key)[0];\n};\n\nvar useSWR = withArgs(useSWRHandler); // useSWR\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3dyL2Rpc3QvaW5kZXgubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTUyxTQUFULENBQW1CQyxPQUFuQixFQUE0QkMsVUFBNUIsRUFBd0NDLENBQXhDLEVBQTJDQyxTQUEzQyxFQUFzRDtFQUNsRCxTQUFTQyxLQUFULENBQWVDLEtBQWYsRUFBc0I7SUFBRSxPQUFPQSxLQUFLLFlBQVlILENBQWpCLEdBQXFCRyxLQUFyQixHQUE2QixJQUFJSCxDQUFKLENBQU0sVUFBVUksT0FBVixFQUFtQjtNQUFFQSxPQUFPLENBQUNELEtBQUQsQ0FBUDtJQUFpQixDQUE1QyxDQUFwQztFQUFvRjs7RUFDNUcsT0FBTyxLQUFLSCxDQUFDLEtBQUtBLENBQUMsR0FBR0ssT0FBVCxDQUFOLEVBQXlCLFVBQVVELE9BQVYsRUFBbUJFLE1BQW5CLEVBQTJCO0lBQ3ZELFNBQVNDLFNBQVQsQ0FBbUJKLEtBQW5CLEVBQTBCO01BQUUsSUFBSTtRQUFFSyxJQUFJLENBQUNQLFNBQVMsQ0FBQ1EsSUFBVixDQUFlTixLQUFmLENBQUQsQ0FBSjtNQUE4QixDQUFwQyxDQUFxQyxPQUFPTyxDQUFQLEVBQVU7UUFBRUosTUFBTSxDQUFDSSxDQUFELENBQU47TUFBWTtJQUFFOztJQUMzRixTQUFTQyxRQUFULENBQWtCUixLQUFsQixFQUF5QjtNQUFFLElBQUk7UUFBRUssSUFBSSxDQUFDUCxTQUFTLENBQUMsT0FBRCxDQUFULENBQW1CRSxLQUFuQixDQUFELENBQUo7TUFBa0MsQ0FBeEMsQ0FBeUMsT0FBT08sQ0FBUCxFQUFVO1FBQUVKLE1BQU0sQ0FBQ0ksQ0FBRCxDQUFOO01BQVk7SUFBRTs7SUFDOUYsU0FBU0YsSUFBVCxDQUFjSSxNQUFkLEVBQXNCO01BQUVBLE1BQU0sQ0FBQ0MsSUFBUCxHQUFjVCxPQUFPLENBQUNRLE1BQU0sQ0FBQ1QsS0FBUixDQUFyQixHQUFzQ0QsS0FBSyxDQUFDVSxNQUFNLENBQUNULEtBQVIsQ0FBTCxDQUFvQlcsSUFBcEIsQ0FBeUJQLFNBQXpCLEVBQW9DSSxRQUFwQyxDQUF0QztJQUFzRjs7SUFDOUdILElBQUksQ0FBQyxDQUFDUCxTQUFTLEdBQUdBLFNBQVMsQ0FBQ2MsS0FBVixDQUFnQmpCLE9BQWhCLEVBQXlCQyxVQUFVLElBQUksRUFBdkMsQ0FBYixFQUF5RFUsSUFBekQsRUFBRCxDQUFKO0VBQ0gsQ0FMTSxDQUFQO0FBTUg7O0FBRUQsU0FBU08sV0FBVCxDQUFxQmxCLE9BQXJCLEVBQThCbUIsSUFBOUIsRUFBb0M7RUFDaEMsSUFBSUMsQ0FBQyxHQUFHO0lBQUVDLEtBQUssRUFBRSxDQUFUO0lBQVlDLElBQUksRUFBRSxZQUFXO01BQUUsSUFBSUMsQ0FBQyxDQUFDLENBQUQsQ0FBRCxHQUFPLENBQVgsRUFBYyxNQUFNQSxDQUFDLENBQUMsQ0FBRCxDQUFQO01BQVksT0FBT0EsQ0FBQyxDQUFDLENBQUQsQ0FBUjtJQUFjLENBQXZFO0lBQXlFQyxJQUFJLEVBQUUsRUFBL0U7SUFBbUZDLEdBQUcsRUFBRTtFQUF4RixDQUFSO0VBQUEsSUFBc0dDLENBQXRHO0VBQUEsSUFBeUdDLENBQXpHO0VBQUEsSUFBNEdKLENBQTVHO0VBQUEsSUFBK0dLLENBQS9HO0VBQ0EsT0FBT0EsQ0FBQyxHQUFHO0lBQUVqQixJQUFJLEVBQUVrQixJQUFJLENBQUMsQ0FBRCxDQUFaO0lBQWlCLFNBQVNBLElBQUksQ0FBQyxDQUFELENBQTlCO0lBQW1DLFVBQVVBLElBQUksQ0FBQyxDQUFEO0VBQWpELENBQUosRUFBNEQsT0FBT0MsTUFBUCxLQUFrQixVQUFsQixLQUFpQ0YsQ0FBQyxDQUFDRSxNQUFNLENBQUNDLFFBQVIsQ0FBRCxHQUFxQixZQUFXO0lBQUUsT0FBTyxJQUFQO0VBQWMsQ0FBakYsQ0FBNUQsRUFBZ0pILENBQXZKOztFQUNBLFNBQVNDLElBQVQsQ0FBY0csQ0FBZCxFQUFpQjtJQUFFLE9BQU8sVUFBVUMsQ0FBVixFQUFhO01BQUUsT0FBT3ZCLElBQUksQ0FBQyxDQUFDc0IsQ0FBRCxFQUFJQyxDQUFKLENBQUQsQ0FBWDtJQUFzQixDQUE1QztFQUErQzs7RUFDbEUsU0FBU3ZCLElBQVQsQ0FBY3dCLEVBQWQsRUFBa0I7SUFDZCxJQUFJUixDQUFKLEVBQU8sTUFBTSxJQUFJUyxTQUFKLENBQWMsaUNBQWQsQ0FBTjs7SUFDUCxPQUFPZixDQUFQLEVBQVUsSUFBSTtNQUNWLElBQUlNLENBQUMsR0FBRyxDQUFKLEVBQU9DLENBQUMsS0FBS0osQ0FBQyxHQUFHVyxFQUFFLENBQUMsQ0FBRCxDQUFGLEdBQVEsQ0FBUixHQUFZUCxDQUFDLENBQUMsUUFBRCxDQUFiLEdBQTBCTyxFQUFFLENBQUMsQ0FBRCxDQUFGLEdBQVFQLENBQUMsQ0FBQyxPQUFELENBQUQsS0FBZSxDQUFDSixDQUFDLEdBQUdJLENBQUMsQ0FBQyxRQUFELENBQU4sS0FBcUJKLENBQUMsQ0FBQ2EsSUFBRixDQUFPVCxDQUFQLENBQXJCLEVBQWdDLENBQS9DLENBQVIsR0FBNERBLENBQUMsQ0FBQ2hCLElBQWpHLENBQUQsSUFBMkcsQ0FBQyxDQUFDWSxDQUFDLEdBQUdBLENBQUMsQ0FBQ2EsSUFBRixDQUFPVCxDQUFQLEVBQVVPLEVBQUUsQ0FBQyxDQUFELENBQVosQ0FBTCxFQUF1Qm5CLElBQTlJLEVBQW9KLE9BQU9RLENBQVA7TUFDcEosSUFBSUksQ0FBQyxHQUFHLENBQUosRUFBT0osQ0FBWCxFQUFjVyxFQUFFLEdBQUcsQ0FBQ0EsRUFBRSxDQUFDLENBQUQsQ0FBRixHQUFRLENBQVQsRUFBWVgsQ0FBQyxDQUFDbEIsS0FBZCxDQUFMOztNQUNkLFFBQVE2QixFQUFFLENBQUMsQ0FBRCxDQUFWO1FBQ0ksS0FBSyxDQUFMO1FBQVEsS0FBSyxDQUFMO1VBQVFYLENBQUMsR0FBR1csRUFBSjtVQUFROztRQUN4QixLQUFLLENBQUw7VUFBUWQsQ0FBQyxDQUFDQyxLQUFGO1VBQVcsT0FBTztZQUFFaEIsS0FBSyxFQUFFNkIsRUFBRSxDQUFDLENBQUQsQ0FBWDtZQUFnQm5CLElBQUksRUFBRTtVQUF0QixDQUFQOztRQUNuQixLQUFLLENBQUw7VUFBUUssQ0FBQyxDQUFDQyxLQUFGO1VBQVdNLENBQUMsR0FBR08sRUFBRSxDQUFDLENBQUQsQ0FBTjtVQUFXQSxFQUFFLEdBQUcsQ0FBQyxDQUFELENBQUw7VUFBVTs7UUFDeEMsS0FBSyxDQUFMO1VBQVFBLEVBQUUsR0FBR2QsQ0FBQyxDQUFDSyxHQUFGLENBQU1ZLEdBQU4sRUFBTDs7VUFBa0JqQixDQUFDLENBQUNJLElBQUYsQ0FBT2EsR0FBUDs7VUFBYzs7UUFDeEM7VUFDSSxJQUFJLEVBQUVkLENBQUMsR0FBR0gsQ0FBQyxDQUFDSSxJQUFOLEVBQVlELENBQUMsR0FBR0EsQ0FBQyxDQUFDZSxNQUFGLEdBQVcsQ0FBWCxJQUFnQmYsQ0FBQyxDQUFDQSxDQUFDLENBQUNlLE1BQUYsR0FBVyxDQUFaLENBQW5DLE1BQXVESixFQUFFLENBQUMsQ0FBRCxDQUFGLEtBQVUsQ0FBVixJQUFlQSxFQUFFLENBQUMsQ0FBRCxDQUFGLEtBQVUsQ0FBaEYsQ0FBSixFQUF3RjtZQUFFZCxDQUFDLEdBQUcsQ0FBSjtZQUFPO1VBQVc7O1VBQzVHLElBQUljLEVBQUUsQ0FBQyxDQUFELENBQUYsS0FBVSxDQUFWLEtBQWdCLENBQUNYLENBQUQsSUFBT1csRUFBRSxDQUFDLENBQUQsQ0FBRixHQUFRWCxDQUFDLENBQUMsQ0FBRCxDQUFULElBQWdCVyxFQUFFLENBQUMsQ0FBRCxDQUFGLEdBQVFYLENBQUMsQ0FBQyxDQUFELENBQWhELENBQUosRUFBMkQ7WUFBRUgsQ0FBQyxDQUFDQyxLQUFGLEdBQVVhLEVBQUUsQ0FBQyxDQUFELENBQVo7WUFBaUI7VUFBUTs7VUFDdEYsSUFBSUEsRUFBRSxDQUFDLENBQUQsQ0FBRixLQUFVLENBQVYsSUFBZWQsQ0FBQyxDQUFDQyxLQUFGLEdBQVVFLENBQUMsQ0FBQyxDQUFELENBQTlCLEVBQW1DO1lBQUVILENBQUMsQ0FBQ0MsS0FBRixHQUFVRSxDQUFDLENBQUMsQ0FBRCxDQUFYO1lBQWdCQSxDQUFDLEdBQUdXLEVBQUo7WUFBUTtVQUFROztVQUNyRSxJQUFJWCxDQUFDLElBQUlILENBQUMsQ0FBQ0MsS0FBRixHQUFVRSxDQUFDLENBQUMsQ0FBRCxDQUFwQixFQUF5QjtZQUFFSCxDQUFDLENBQUNDLEtBQUYsR0FBVUUsQ0FBQyxDQUFDLENBQUQsQ0FBWDs7WUFBZ0JILENBQUMsQ0FBQ0ssR0FBRixDQUFNYyxJQUFOLENBQVdMLEVBQVg7O1lBQWdCO1VBQVE7O1VBQ25FLElBQUlYLENBQUMsQ0FBQyxDQUFELENBQUwsRUFBVUgsQ0FBQyxDQUFDSyxHQUFGLENBQU1ZLEdBQU47O1VBQ1ZqQixDQUFDLENBQUNJLElBQUYsQ0FBT2EsR0FBUDs7VUFBYztNQVh0Qjs7TUFhQUgsRUFBRSxHQUFHZixJQUFJLENBQUNpQixJQUFMLENBQVVwQyxPQUFWLEVBQW1Cb0IsQ0FBbkIsQ0FBTDtJQUNILENBakJTLENBaUJSLE9BQU9SLENBQVAsRUFBVTtNQUFFc0IsRUFBRSxHQUFHLENBQUMsQ0FBRCxFQUFJdEIsQ0FBSixDQUFMO01BQWFlLENBQUMsR0FBRyxDQUFKO0lBQVEsQ0FqQnpCLFNBaUJrQztNQUFFRCxDQUFDLEdBQUdILENBQUMsR0FBRyxDQUFSO0lBQVk7O0lBQzFELElBQUlXLEVBQUUsQ0FBQyxDQUFELENBQUYsR0FBUSxDQUFaLEVBQWUsTUFBTUEsRUFBRSxDQUFDLENBQUQsQ0FBUjtJQUFhLE9BQU87TUFBRTdCLEtBQUssRUFBRTZCLEVBQUUsQ0FBQyxDQUFELENBQUYsR0FBUUEsRUFBRSxDQUFDLENBQUQsQ0FBVixHQUFnQixLQUFLLENBQTlCO01BQWlDbkIsSUFBSSxFQUFFO0lBQXZDLENBQVA7RUFDL0I7QUFDSjs7QUFFRCxJQUFJeUIsSUFBSSxHQUFHLFlBQVksQ0FBRyxDQUExQixFQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxJQUFJQyxTQUFTO0FBQUs7QUFBaUJELElBQUksRUFBdkM7QUFDQSxJQUFJRSxNQUFNLEdBQUdDLE1BQWI7O0FBQ0EsSUFBSUMsV0FBVyxHQUFHLFVBQVVYLENBQVYsRUFBYTtFQUFFLE9BQU9BLENBQUMsS0FBS1EsU0FBYjtBQUF5QixDQUExRDs7QUFDQSxJQUFJSSxVQUFVLEdBQUcsVUFBVVosQ0FBVixFQUFhO0VBQUUsT0FBTyxPQUFPQSxDQUFQLElBQVksVUFBbkI7QUFBZ0MsQ0FBaEU7O0FBQ0EsSUFBSWEsWUFBWSxHQUFHLFVBQVVDLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtFQUFFLE9BQU9OLE1BQU0sQ0FBQ08sTUFBUCxDQUFjLEVBQWQsRUFBa0JGLENBQWxCLEVBQXFCQyxDQUFyQixDQUFQO0FBQWlDLENBQXRFOztBQUNBLElBQUlFLGFBQWEsR0FBRyxXQUFwQixFQUNBOztBQUNBLElBQUlDLFNBQVMsR0FBRyxZQUFZO0VBQUUsT0FBTyxPQUFPQyxNQUFQLElBQWlCRixhQUF4QjtBQUF3QyxDQUF0RTs7QUFDQSxJQUFJRyxXQUFXLEdBQUcsWUFBWTtFQUFFLE9BQU8sT0FBT0MsUUFBUCxJQUFtQkosYUFBMUI7QUFBMEMsQ0FBMUU7O0FBQ0EsSUFBSUssd0JBQXdCLEdBQUcsWUFBWTtFQUN2QyxPQUFPSixTQUFTLE1BQU0sT0FBT0MsTUFBTSxDQUFDLHVCQUFELENBQWIsSUFBMENGLGFBQWhFO0FBQ0gsQ0FGRCxFQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxJQUFJTSxLQUFLLEdBQUcsSUFBSUMsT0FBSixFQUFaLEVBQ0E7O0FBQ0EsSUFBSUMsT0FBTyxHQUFHLENBQWQsRUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLElBQUlDLFVBQVUsR0FBRyxVQUFVQyxHQUFWLEVBQWU7RUFDNUIsSUFBSUMsSUFBSSxHQUFHLE9BQU9ELEdBQWxCO0VBQ0EsSUFBSUUsV0FBVyxHQUFHRixHQUFHLElBQUlBLEdBQUcsQ0FBQ0UsV0FBN0I7RUFDQSxJQUFJQyxNQUFNLEdBQUdELFdBQVcsSUFBSUUsSUFBNUI7RUFDQSxJQUFJbEQsTUFBSjtFQUNBLElBQUltRCxLQUFKOztFQUNBLElBQUl2QixNQUFNLENBQUNrQixHQUFELENBQU4sS0FBZ0JBLEdBQWhCLElBQXVCLENBQUNHLE1BQXhCLElBQWtDRCxXQUFXLElBQUlJLE1BQXJELEVBQTZEO0lBQ3pEO0lBQ0E7SUFDQXBELE1BQU0sR0FBRzBDLEtBQUssQ0FBQ1csR0FBTixDQUFVUCxHQUFWLENBQVQ7SUFDQSxJQUFJOUMsTUFBSixFQUNJLE9BQU9BLE1BQVAsQ0FMcUQsQ0FNekQ7SUFDQTtJQUNBOztJQUNBQSxNQUFNLEdBQUcsRUFBRTRDLE9BQUYsR0FBWSxHQUFyQjtJQUNBRixLQUFLLENBQUNZLEdBQU4sQ0FBVVIsR0FBVixFQUFlOUMsTUFBZjs7SUFDQSxJQUFJZ0QsV0FBVyxJQUFJTyxLQUFuQixFQUEwQjtNQUN0QjtNQUNBdkQsTUFBTSxHQUFHLEdBQVQ7O01BQ0EsS0FBS21ELEtBQUssR0FBRyxDQUFiLEVBQWdCQSxLQUFLLEdBQUdMLEdBQUcsQ0FBQ3RCLE1BQTVCLEVBQW9DMkIsS0FBSyxFQUF6QyxFQUE2QztRQUN6Q25ELE1BQU0sSUFBSTZDLFVBQVUsQ0FBQ0MsR0FBRyxDQUFDSyxLQUFELENBQUosQ0FBVixHQUF5QixHQUFuQztNQUNIOztNQUNEVCxLQUFLLENBQUNZLEdBQU4sQ0FBVVIsR0FBVixFQUFlOUMsTUFBZjtJQUNIOztJQUNELElBQUlnRCxXQUFXLElBQUlwQixNQUFuQixFQUEyQjtNQUN2QjtNQUNBNUIsTUFBTSxHQUFHLEdBQVQ7TUFDQSxJQUFJd0QsSUFBSSxHQUFHNUIsTUFBTSxDQUFDNEIsSUFBUCxDQUFZVixHQUFaLEVBQWlCVyxJQUFqQixFQUFYOztNQUNBLE9BQU8sQ0FBQzNCLFdBQVcsQ0FBRXFCLEtBQUssR0FBR0ssSUFBSSxDQUFDakMsR0FBTCxFQUFWLENBQW5CLEVBQTJDO1FBQ3ZDLElBQUksQ0FBQ08sV0FBVyxDQUFDZ0IsR0FBRyxDQUFDSyxLQUFELENBQUosQ0FBaEIsRUFBOEI7VUFDMUJuRCxNQUFNLElBQUltRCxLQUFLLEdBQUcsR0FBUixHQUFjTixVQUFVLENBQUNDLEdBQUcsQ0FBQ0ssS0FBRCxDQUFKLENBQXhCLEdBQXVDLEdBQWpEO1FBQ0g7TUFDSjs7TUFDRFQsS0FBSyxDQUFDWSxHQUFOLENBQVVSLEdBQVYsRUFBZTlDLE1BQWY7SUFDSDtFQUNKLENBOUJELE1BK0JLO0lBQ0RBLE1BQU0sR0FBR2lELE1BQU0sR0FDVEgsR0FBRyxDQUFDWSxNQUFKLEVBRFMsR0FFVFgsSUFBSSxJQUFJLFFBQVIsR0FDSUQsR0FBRyxDQUFDYSxRQUFKLEVBREosR0FFSVosSUFBSSxJQUFJLFFBQVIsR0FDSWEsSUFBSSxDQUFDQyxTQUFMLENBQWVmLEdBQWYsQ0FESixHQUVJLEtBQUtBLEdBTm5CO0VBT0g7O0VBQ0QsT0FBTzlDLE1BQVA7QUFDSCxDQS9DRDtBQWlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsSUFBSThELE1BQU0sR0FBRyxJQUFiOztBQUNBLElBQUlDLFFBQVEsR0FBRyxZQUFZO0VBQUUsT0FBT0QsTUFBUDtBQUFnQixDQUE3Qzs7QUFDQSxJQUFJRSxNQUFNLEdBQUczQixTQUFTLEVBQXRCO0FBQ0EsSUFBSTRCLE1BQU0sR0FBRzFCLFdBQVcsRUFBeEIsRUFDQTs7QUFDQSxJQUFJMkIsYUFBYSxHQUFHRixNQUFNLElBQUkxQixNQUFNLENBQUM2QixnQkFBakIsR0FDZDdCLE1BQU0sQ0FBQzZCLGdCQUFQLENBQXdCQyxJQUF4QixDQUE2QjlCLE1BQTdCLENBRGMsR0FFZFosSUFGTjtBQUdBLElBQUkyQyxlQUFlLEdBQUdKLE1BQU0sR0FBR3pCLFFBQVEsQ0FBQzJCLGdCQUFULENBQTBCQyxJQUExQixDQUErQjVCLFFBQS9CLENBQUgsR0FBOENkLElBQTFFO0FBQ0EsSUFBSTRDLGNBQWMsR0FBR04sTUFBTSxJQUFJMUIsTUFBTSxDQUFDaUMsbUJBQWpCLEdBQ2ZqQyxNQUFNLENBQUNpQyxtQkFBUCxDQUEyQkgsSUFBM0IsQ0FBZ0M5QixNQUFoQyxDQURlLEdBRWZaLElBRk47QUFHQSxJQUFJOEMsZ0JBQWdCLEdBQUdQLE1BQU0sR0FDdkJ6QixRQUFRLENBQUMrQixtQkFBVCxDQUE2QkgsSUFBN0IsQ0FBa0M1QixRQUFsQyxDQUR1QixHQUV2QmQsSUFGTjs7QUFHQSxJQUFJK0MsU0FBUyxHQUFHLFlBQVk7RUFDeEIsSUFBSUMsZUFBZSxHQUFHVCxNQUFNLElBQUl6QixRQUFRLENBQUNrQyxlQUF6QztFQUNBLE9BQU81QyxXQUFXLENBQUM0QyxlQUFELENBQVgsSUFBZ0NBLGVBQWUsS0FBSyxRQUEzRDtBQUNILENBSEQ7O0FBSUEsSUFBSUMsU0FBUyxHQUFHLFVBQVVDLFFBQVYsRUFBb0I7RUFDaEM7RUFDQVAsZUFBZSxDQUFDLGtCQUFELEVBQXFCTyxRQUFyQixDQUFmO0VBQ0FWLGFBQWEsQ0FBQyxPQUFELEVBQVVVLFFBQVYsQ0FBYjtFQUNBLE9BQU8sWUFBWTtJQUNmSixnQkFBZ0IsQ0FBQyxrQkFBRCxFQUFxQkksUUFBckIsQ0FBaEI7SUFDQU4sY0FBYyxDQUFDLE9BQUQsRUFBVU0sUUFBVixDQUFkO0VBQ0gsQ0FIRDtBQUlILENBUkQ7O0FBU0EsSUFBSUMsYUFBYSxHQUFHLFVBQVVELFFBQVYsRUFBb0I7RUFDcEM7RUFDQSxJQUFJRSxRQUFRLEdBQUcsWUFBWTtJQUN2QmhCLE1BQU0sR0FBRyxJQUFUO0lBQ0FjLFFBQVE7RUFDWCxDQUhELENBRm9DLENBTXBDOzs7RUFDQSxJQUFJRyxTQUFTLEdBQUcsWUFBWTtJQUN4QmpCLE1BQU0sR0FBRyxLQUFUO0VBQ0gsQ0FGRDs7RUFHQUksYUFBYSxDQUFDLFFBQUQsRUFBV1ksUUFBWCxDQUFiO0VBQ0FaLGFBQWEsQ0FBQyxTQUFELEVBQVlhLFNBQVosQ0FBYjtFQUNBLE9BQU8sWUFBWTtJQUNmVCxjQUFjLENBQUMsUUFBRCxFQUFXUSxRQUFYLENBQWQ7SUFDQVIsY0FBYyxDQUFDLFNBQUQsRUFBWVMsU0FBWixDQUFkO0VBQ0gsQ0FIRDtBQUlILENBaEJEOztBQWlCQSxJQUFJQyxNQUFNLEdBQUc7RUFDVGpCLFFBQVEsRUFBRUEsUUFERDtFQUVUVSxTQUFTLEVBQUVBO0FBRkYsQ0FBYjtBQUlBLElBQUlRLG9CQUFvQixHQUFHO0VBQ3ZCTixTQUFTLEVBQUVBLFNBRFk7RUFFdkJFLGFBQWEsRUFBRUE7QUFGUSxDQUEzQjtBQUtBLElBQUlLLFNBQVMsR0FBRyxDQUFDN0MsU0FBUyxFQUFWLElBQWdCLFVBQVVDLE1BQTFDLEVBQ0E7O0FBQ0EsSUFBSTZDLEdBQUcsR0FBRyxVQUFVdkUsQ0FBVixFQUFhO0VBQ25CLE9BQU82Qix3QkFBd0IsS0FBS0gsTUFBTSxDQUFDLHVCQUFELENBQU4sQ0FBZ0MxQixDQUFoQyxDQUFMLEdBQTBDd0UsVUFBVSxDQUFDeEUsQ0FBRCxFQUFJLENBQUosQ0FBbkY7QUFDSCxDQUZELEVBR0E7QUFDQTtBQUNBOzs7QUFDQSxJQUFJeUUseUJBQXlCLEdBQUdILFNBQVMsR0FBRzFHLDRDQUFILEdBQWVDLGtEQUF4RCxFQUNBOztBQUNBLElBQUk2RyxtQkFBbUIsR0FBRyxPQUFPQyxTQUFQLEtBQXFCLFdBQXJCLElBQ3RCQSxTQUFTLENBQUNDLFVBRGQsRUFFQTs7QUFDQSxJQUFJQyxjQUFjLEdBQUcsQ0FBQ1AsU0FBRCxJQUNqQkksbUJBRGlCLEtBRWhCLENBQUMsU0FBRCxFQUFZLElBQVosRUFBa0JJLFFBQWxCLENBQTJCSixtQkFBbUIsQ0FBQ0ssYUFBL0MsS0FDR0wsbUJBQW1CLENBQUNNLFFBSFAsQ0FBckI7O0FBS0EsSUFBSUMsU0FBUyxHQUFHLFVBQVVDLEdBQVYsRUFBZTtFQUMzQixJQUFJL0QsVUFBVSxDQUFDK0QsR0FBRCxDQUFkLEVBQXFCO0lBQ2pCLElBQUk7TUFDQUEsR0FBRyxHQUFHQSxHQUFHLEVBQVQ7SUFDSCxDQUZELENBR0EsT0FBT0MsR0FBUCxFQUFZO01BQ1I7TUFDQUQsR0FBRyxHQUFHLEVBQU47SUFDSDtFQUNKOztFQUNELElBQUlFLElBQUksR0FBRyxHQUFHQyxNQUFILENBQVVILEdBQVYsQ0FBWCxDQVYyQixDQVczQjs7RUFDQUEsR0FBRyxHQUNDLE9BQU9BLEdBQVAsSUFBYyxRQUFkLEdBQ01BLEdBRE4sR0FFTSxDQUFDdkMsS0FBSyxDQUFDMkMsT0FBTixDQUFjSixHQUFkLElBQXFCQSxHQUFHLENBQUN0RSxNQUF6QixHQUFrQ3NFLEdBQW5DLElBQ0lqRCxVQUFVLENBQUNpRCxHQUFELENBRGQsR0FFSSxFQUxkO0VBTUEsSUFBSUssT0FBTyxHQUFHTCxHQUFHLEdBQUcsVUFBVUEsR0FBYixHQUFtQixFQUFwQztFQUNBLE9BQU8sQ0FBQ0EsR0FBRCxFQUFNRSxJQUFOLEVBQVlHLE9BQVosQ0FBUDtBQUNILENBcEJELEVBc0JBOzs7QUFDQSxJQUFJQyxjQUFjLEdBQUcsSUFBSXpELE9BQUosRUFBckI7QUFFQSxJQUFJMEQsV0FBVyxHQUFHLENBQWxCO0FBQ0EsSUFBSUMsZUFBZSxHQUFHLENBQXRCO0FBQ0EsSUFBSUMsWUFBWSxHQUFHLENBQW5COztBQUVBLElBQUlDLGNBQWMsR0FBRyxVQUFVQyxLQUFWLEVBQWlCWCxHQUFqQixFQUFzQlksSUFBdEIsRUFBNEJDLEtBQTVCLEVBQW1DQyxZQUFuQyxFQUFpREMsVUFBakQsRUFBNkRDLFNBQTdELEVBQXdFO0VBQ3pGLElBQUlBLFNBQVMsS0FBSyxLQUFLLENBQXZCLEVBQTBCO0lBQUVBLFNBQVMsR0FBRyxJQUFaO0VBQW1COztFQUMvQyxJQUFJQyxFQUFFLEdBQUdYLGNBQWMsQ0FBQy9DLEdBQWYsQ0FBbUJvRCxLQUFuQixDQUFUO0VBQUEsSUFBb0NPLGtCQUFrQixHQUFHRCxFQUFFLENBQUMsQ0FBRCxDQUEzRDtFQUFBLElBQWdFRSxjQUFjLEdBQUdGLEVBQUUsQ0FBQyxDQUFELENBQW5GO0VBQUEsSUFBd0ZHLEtBQUssR0FBR0gsRUFBRSxDQUFDLENBQUQsQ0FBbEc7O0VBQ0EsSUFBSUksWUFBWSxHQUFHSCxrQkFBa0IsQ0FBQ2xCLEdBQUQsQ0FBckM7RUFDQSxJQUFJc0IsUUFBUSxHQUFHSCxjQUFjLENBQUNuQixHQUFELENBQTdCLENBSnlGLENBS3pGOztFQUNBLElBQUlnQixTQUFTLElBQUlNLFFBQWpCLEVBQTJCO0lBQ3ZCLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsUUFBUSxDQUFDNUYsTUFBN0IsRUFBcUMsRUFBRTZGLENBQXZDLEVBQTBDO01BQ3RDRCxRQUFRLENBQUNDLENBQUQsQ0FBUixDQUFZWCxJQUFaLEVBQWtCQyxLQUFsQixFQUF5QkMsWUFBekI7SUFDSDtFQUNKLENBVndGLENBV3pGOzs7RUFDQSxJQUFJQyxVQUFKLEVBQWdCO0lBQ1o7SUFDQTtJQUNBLE9BQU9LLEtBQUssQ0FBQ3BCLEdBQUQsQ0FBWjs7SUFDQSxJQUFJcUIsWUFBWSxJQUFJQSxZQUFZLENBQUMsQ0FBRCxDQUFoQyxFQUFxQztNQUNqQyxPQUFPQSxZQUFZLENBQUMsQ0FBRCxDQUFaLENBQWdCWixZQUFoQixFQUE4QnJHLElBQTlCLENBQW1DLFlBQVk7UUFDbEQsT0FBT3VHLEtBQUssQ0FBQ3BELEdBQU4sQ0FBVXlDLEdBQVYsQ0FBUDtNQUNILENBRk0sQ0FBUDtJQUdIO0VBQ0o7O0VBQ0QsT0FBT1csS0FBSyxDQUFDcEQsR0FBTixDQUFVeUMsR0FBVixDQUFQO0FBQ0gsQ0F2QkQsRUF5QkE7OztBQUNBLElBQUl3QixXQUFXLEdBQUcsQ0FBbEI7O0FBQ0EsSUFBSUMsWUFBWSxHQUFHLFlBQVk7RUFBRSxPQUFPLEVBQUVELFdBQVQ7QUFBdUIsQ0FBeEQ7O0FBRUEsSUFBSUUsY0FBYyxHQUFHLFlBQVk7RUFDN0IsSUFBSXhCLElBQUksR0FBRyxFQUFYOztFQUNBLEtBQUssSUFBSXlCLEVBQUUsR0FBRyxDQUFkLEVBQWlCQSxFQUFFLEdBQUdDLFNBQVMsQ0FBQ2xHLE1BQWhDLEVBQXdDaUcsRUFBRSxFQUExQyxFQUE4QztJQUMxQ3pCLElBQUksQ0FBQ3lCLEVBQUQsQ0FBSixHQUFXQyxTQUFTLENBQUNELEVBQUQsQ0FBcEI7RUFDSDs7RUFDRCxPQUFPeEksU0FBUyxDQUFDLEtBQUssQ0FBTixFQUFTLEtBQUssQ0FBZCxFQUFpQixLQUFLLENBQXRCLEVBQXlCLFlBQVk7SUFDakQsSUFBSXdILEtBQUosRUFBV2tCLElBQVgsRUFBaUJDLEtBQWpCLEVBQXdCQyxLQUF4QixFQUErQkMsT0FBL0IsRUFBd0NDLGFBQXhDLEVBQXVEbEIsVUFBdkQsRUFBbUVtQixlQUFuRSxFQUFvRkMsb0JBQXBGLEVBQTBHbEIsRUFBMUcsRUFBOEdqQixHQUE5RyxFQUFtSG9DLE9BQW5ILEVBQTRIQyxFQUE1SCxFQUFnSUMsUUFBaEksRUFBMEkxQixJQUExSSxFQUFnSkMsS0FBaEosRUFBdUowQixnQkFBdkosRUFBeUtDLHVCQUF6SyxFQUFrTUMsWUFBbE0sRUFBZ05DLGNBQWhOLEVBQWdPQyxHQUFoTzs7SUFDQSxPQUFPckksV0FBVyxDQUFDLElBQUQsRUFBTyxVQUFVc0ksRUFBVixFQUFjO01BQ25DLFFBQVFBLEVBQUUsQ0FBQ25JLEtBQVg7UUFDSSxLQUFLLENBQUw7VUFDSWtHLEtBQUssR0FBR1QsSUFBSSxDQUFDLENBQUQsQ0FBWixFQUFpQjJCLElBQUksR0FBRzNCLElBQUksQ0FBQyxDQUFELENBQTVCLEVBQWlDNEIsS0FBSyxHQUFHNUIsSUFBSSxDQUFDLENBQUQsQ0FBN0MsRUFBa0Q2QixLQUFLLEdBQUc3QixJQUFJLENBQUMsQ0FBRCxDQUE5RDtVQUNBOEIsT0FBTyxHQUFHLE9BQU9ELEtBQVAsS0FBaUIsU0FBakIsR0FBNkI7WUFBRWhCLFVBQVUsRUFBRWdCO1VBQWQsQ0FBN0IsR0FBcURBLEtBQUssSUFBSSxFQUF4RTtVQUNBRSxhQUFhLEdBQUdqRyxXQUFXLENBQUNnRyxPQUFPLENBQUNDLGFBQVQsQ0FBWCxHQUNWLElBRFUsR0FFVkQsT0FBTyxDQUFDQyxhQUZkO1VBR0FsQixVQUFVLEdBQUdpQixPQUFPLENBQUNqQixVQUFSLEtBQXVCLEtBQXBDO1VBQ0FtQixlQUFlLEdBQUdGLE9BQU8sQ0FBQ0UsZUFBUixLQUE0QixLQUE5QztVQUNBQyxvQkFBb0IsR0FBR0gsT0FBTyxDQUFDVSxjQUEvQjtVQUNBekIsRUFBRSxHQUFHbEIsU0FBUyxDQUFDOEIsSUFBRCxDQUFkLEVBQXNCN0IsR0FBRyxHQUFHaUIsRUFBRSxDQUFDLENBQUQsQ0FBOUIsRUFBbUNtQixPQUFPLEdBQUduQixFQUFFLENBQUMsQ0FBRCxDQUEvQztVQUNBLElBQUksQ0FBQ2pCLEdBQUwsRUFDSSxPQUFPLENBQUM7VUFBRTtVQUFILENBQVA7VUFDSnFDLEVBQUUsR0FBRy9CLGNBQWMsQ0FBQy9DLEdBQWYsQ0FBbUJvRCxLQUFuQixDQUFMLEVBQWdDMkIsUUFBUSxHQUFHRCxFQUFFLENBQUMsQ0FBRCxDQUE3QyxDQVpKLENBYUk7O1VBQ0EsSUFBSW5DLElBQUksQ0FBQ3hFLE1BQUwsR0FBYyxDQUFsQixFQUFxQjtZQUNqQjtZQUNBLE9BQU8sQ0FBQztZQUFFO1lBQUgsRUFBZWdGLGNBQWMsQ0FBQ0MsS0FBRCxFQUFRWCxHQUFSLEVBQWFXLEtBQUssQ0FBQ3BELEdBQU4sQ0FBVXlDLEdBQVYsQ0FBYixFQUE2Qm5FLFNBQTdCLEVBQXdDQSxTQUF4QyxFQUFtRGtGLFVBQW5ELEVBQStELElBQS9ELENBQTdCLENBQVA7VUFDSDs7VUFDREgsSUFBSSxHQUFHa0IsS0FBUDtVQUNBUyxnQkFBZ0IsR0FBR2QsWUFBWSxFQUEvQjtVQUNBYSxRQUFRLENBQUN0QyxHQUFELENBQVIsR0FBZ0IsQ0FBQ3VDLGdCQUFELEVBQW1CLENBQW5CLENBQWhCO1VBQ0FDLHVCQUF1QixHQUFHLENBQUN4RyxXQUFXLENBQUNtRyxvQkFBRCxDQUF0QztVQUNBTSxZQUFZLEdBQUc5QixLQUFLLENBQUNwRCxHQUFOLENBQVV5QyxHQUFWLENBQWYsQ0F0QkosQ0F1Qkk7O1VBQ0EsSUFBSXdDLHVCQUFKLEVBQTZCO1lBQ3pCRSxjQUFjLEdBQUd6RyxVQUFVLENBQUNrRyxvQkFBRCxDQUFWLEdBQ1hBLG9CQUFvQixDQUFDTSxZQUFELENBRFQsR0FFWE4sb0JBRk47WUFHQXhCLEtBQUssQ0FBQ25ELEdBQU4sQ0FBVXdDLEdBQVYsRUFBZTBDLGNBQWY7WUFDQWhDLGNBQWMsQ0FBQ0MsS0FBRCxFQUFRWCxHQUFSLEVBQWEwQyxjQUFiLENBQWQ7VUFDSDs7VUFDRCxJQUFJekcsVUFBVSxDQUFDMkUsSUFBRCxDQUFkLEVBQXNCO1lBQ2xCO1lBQ0EsSUFBSTtjQUNBQSxJQUFJLEdBQUdBLElBQUksQ0FBQ0QsS0FBSyxDQUFDcEQsR0FBTixDQUFVeUMsR0FBVixDQUFELENBQVg7WUFDSCxDQUZELENBR0EsT0FBT0MsR0FBUCxFQUFZO2NBQ1I7Y0FDQVksS0FBSyxHQUFHWixHQUFSO1lBQ0g7VUFDSjs7VUFDRCxJQUFJLEVBQUVXLElBQUksSUFBSTNFLFVBQVUsQ0FBQzJFLElBQUksQ0FBQ3hHLElBQU4sQ0FBcEIsQ0FBSixFQUFzQyxPQUFPLENBQUM7VUFBRTtVQUFILEVBQWMsQ0FBZCxDQUFQO1VBQ3RDLE9BQU8sQ0FBQztVQUFFO1VBQUgsRUFBY3dHLElBQUksQ0FBQ2lDLEtBQUwsQ0FBVyxVQUFVNUMsR0FBVixFQUFlO1lBQ3ZDWSxLQUFLLEdBQUdaLEdBQVI7VUFDSCxDQUZnQixDQUFkLENBR0g7VUFDQTtVQUNBO1VBTEcsQ0FBUDs7UUFPSixLQUFLLENBQUw7VUFDSTtVQUNBO1VBQ0FXLElBQUksR0FBR2dDLEVBQUUsQ0FBQ2xJLElBQUgsRUFBUCxDQUhKLENBSUk7VUFDQTtVQUNBOztVQUNBLElBQUk2SCxnQkFBZ0IsS0FBS0QsUUFBUSxDQUFDdEMsR0FBRCxDQUFSLENBQWMsQ0FBZCxDQUF6QixFQUEyQztZQUN2QyxJQUFJYSxLQUFKLEVBQ0ksTUFBTUEsS0FBTjtZQUNKLE9BQU8sQ0FBQztZQUFFO1lBQUgsRUFBZUQsSUFBZixDQUFQO1VBQ0gsQ0FKRCxNQUtLLElBQUlDLEtBQUssSUFBSTJCLHVCQUFULElBQW9DTixlQUF4QyxFQUF5RDtZQUMxRDtZQUNBO1lBQ0FELGFBQWEsR0FBRyxJQUFoQjtZQUNBckIsSUFBSSxHQUFHNkIsWUFBUDtZQUNBOUIsS0FBSyxDQUFDbkQsR0FBTixDQUFVd0MsR0FBVixFQUFleUMsWUFBZjtVQUNIOztVQUNERyxFQUFFLENBQUNuSSxLQUFILEdBQVcsQ0FBWDs7UUFDSixLQUFLLENBQUw7VUFDSTtVQUNBLElBQUl3SCxhQUFKLEVBQW1CO1lBQ2YsSUFBSSxDQUFDcEIsS0FBTCxFQUFZO2NBQ1I7Y0FDQSxJQUFJNUUsVUFBVSxDQUFDZ0csYUFBRCxDQUFkLEVBQStCO2dCQUMzQnJCLElBQUksR0FBR3FCLGFBQWEsQ0FBQ3JCLElBQUQsRUFBTzZCLFlBQVAsQ0FBcEI7Y0FDSCxDQUpPLENBS1I7OztjQUNBOUIsS0FBSyxDQUFDbkQsR0FBTixDQUFVd0MsR0FBVixFQUFlWSxJQUFmO1lBQ0gsQ0FSYyxDQVNmOzs7WUFDQUQsS0FBSyxDQUFDbkQsR0FBTixDQUFVNEUsT0FBVixFQUFtQmxHLFlBQVksQ0FBQ3lFLEtBQUssQ0FBQ3BELEdBQU4sQ0FBVTZFLE9BQVYsQ0FBRCxFQUFxQjtjQUFFdkIsS0FBSyxFQUFFQTtZQUFULENBQXJCLENBQS9CO1VBQ0gsQ0FiTCxDQWNJOzs7VUFDQXlCLFFBQVEsQ0FBQ3RDLEdBQUQsQ0FBUixDQUFjLENBQWQsSUFBbUJ5QixZQUFZLEVBQS9CO1VBQ0EsT0FBTyxDQUFDO1VBQUU7VUFBSCxFQUFjZixjQUFjLENBQUNDLEtBQUQsRUFBUVgsR0FBUixFQUFhWSxJQUFiLEVBQW1CQyxLQUFuQixFQUEwQmhGLFNBQTFCLEVBQXFDa0YsVUFBckMsRUFBaUQsQ0FBQyxDQUFDa0IsYUFBbkQsQ0FBNUIsQ0FDSDtVQURHLENBQVA7O1FBR0osS0FBSyxDQUFMO1VBQ0lVLEdBQUcsR0FBR0MsRUFBRSxDQUFDbEksSUFBSCxFQUFOLENBREosQ0FFSTs7VUFDQSxJQUFJbUcsS0FBSixFQUNJLE1BQU1BLEtBQU47VUFDSixPQUFPLENBQUM7VUFBRTtVQUFILEVBQWVvQixhQUFhLEdBQUdVLEdBQUgsR0FBUy9CLElBQXJDLENBQVA7TUE5RlI7SUFnR0gsQ0FqR2lCLENBQWxCO0VBa0dILENBcEdlLENBQWhCO0FBcUdILENBMUdEOztBQTRHQSxJQUFJa0MsaUJBQWlCLEdBQUcsVUFBVXpCLFlBQVYsRUFBd0JwRSxJQUF4QixFQUE4QjtFQUNsRCxLQUFLLElBQUkrQyxHQUFULElBQWdCcUIsWUFBaEIsRUFBOEI7SUFDMUIsSUFBSUEsWUFBWSxDQUFDckIsR0FBRCxDQUFaLENBQWtCLENBQWxCLENBQUosRUFDSXFCLFlBQVksQ0FBQ3JCLEdBQUQsQ0FBWixDQUFrQixDQUFsQixFQUFxQi9DLElBQXJCO0VBQ1A7QUFDSixDQUxEOztBQU1BLElBQUk4RixTQUFTLEdBQUcsVUFBVUMsUUFBVixFQUFvQmhCLE9BQXBCLEVBQTZCO0VBQ3pDO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLENBQUMxQixjQUFjLENBQUMyQyxHQUFmLENBQW1CRCxRQUFuQixDQUFMLEVBQW1DO0lBQy9CLElBQUlFLElBQUksR0FBR2hILFlBQVksQ0FBQ2lELG9CQUFELEVBQXVCNkMsT0FBdkIsQ0FBdkIsQ0FEK0IsQ0FFL0I7SUFDQTs7SUFDQSxJQUFJZCxrQkFBa0IsR0FBRyxFQUF6QjtJQUNBLElBQUlpQyxNQUFNLEdBQUd6QixjQUFjLENBQUNwRCxJQUFmLENBQW9CekMsU0FBcEIsRUFBK0JtSCxRQUEvQixDQUFiO0lBQ0EsSUFBSUksT0FBTyxHQUFHeEgsSUFBZCxDQU4rQixDQU8vQjs7SUFDQTBFLGNBQWMsQ0FBQzlDLEdBQWYsQ0FBbUJ3RixRQUFuQixFQUE2QixDQUFDOUIsa0JBQUQsRUFBcUIsRUFBckIsRUFBeUIsRUFBekIsRUFBNkIsRUFBN0IsRUFBaUNpQyxNQUFqQyxDQUE3QixFQVIrQixDQVMvQjtJQUNBOztJQUNBLElBQUksQ0FBQy9ELFNBQUwsRUFBZ0I7TUFDWjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQSxJQUFJaUUsY0FBYyxHQUFHSCxJQUFJLENBQUNyRSxTQUFMLENBQWVTLFVBQVUsQ0FBQ2hCLElBQVgsQ0FBZ0J6QyxTQUFoQixFQUEyQmlILGlCQUFpQixDQUFDeEUsSUFBbEIsQ0FBdUJ6QyxTQUF2QixFQUFrQ3FGLGtCQUFsQyxFQUFzRFgsV0FBdEQsQ0FBM0IsQ0FBZixDQUFyQjtNQUNBLElBQUkrQyxrQkFBa0IsR0FBR0osSUFBSSxDQUFDbkUsYUFBTCxDQUFtQk8sVUFBVSxDQUFDaEIsSUFBWCxDQUFnQnpDLFNBQWhCLEVBQTJCaUgsaUJBQWlCLENBQUN4RSxJQUFsQixDQUF1QnpDLFNBQXZCLEVBQWtDcUYsa0JBQWxDLEVBQXNEVixlQUF0RCxDQUEzQixDQUFuQixDQUF6Qjs7TUFDQTRDLE9BQU8sR0FBRyxZQUFZO1FBQ2xCQyxjQUFjLElBQUlBLGNBQWMsRUFBaEM7UUFDQUMsa0JBQWtCLElBQUlBLGtCQUFrQixFQUF4QyxDQUZrQixDQUdsQjtRQUNBO1FBQ0E7O1FBQ0FoRCxjQUFjLENBQUNpRCxNQUFmLENBQXNCUCxRQUF0QjtNQUNILENBUEQ7SUFRSCxDQTVCOEIsQ0E2Qi9CO0lBQ0E7SUFDQTs7O0lBQ0EsT0FBTyxDQUFDQSxRQUFELEVBQVdHLE1BQVgsRUFBbUJDLE9BQW5CLENBQVA7RUFDSDs7RUFDRCxPQUFPLENBQUNKLFFBQUQsRUFBVzFDLGNBQWMsQ0FBQy9DLEdBQWYsQ0FBbUJ5RixRQUFuQixFQUE2QixDQUE3QixDQUFYLENBQVA7QUFDSCxDQXpDRCxFQTJDQTs7O0FBQ0EsSUFBSVEsWUFBWSxHQUFHLFVBQVVoSixDQUFWLEVBQWFpSixFQUFiLEVBQWlCQyxNQUFqQixFQUF5QjNDLFVBQXpCLEVBQXFDbUMsSUFBckMsRUFBMkM7RUFDMUQsSUFBSVMsYUFBYSxHQUFHRCxNQUFNLENBQUNFLGVBQTNCO0VBQ0EsSUFBSUMsaUJBQWlCLEdBQUdYLElBQUksQ0FBQ1ksVUFBN0IsQ0FGMEQsQ0FHMUQ7O0VBQ0EsSUFBSUMsT0FBTyxHQUFHLENBQUMsRUFBRSxDQUFDQyxJQUFJLENBQUNDLE1BQUwsS0FBZ0IsR0FBakIsS0FDWixNQUFNSixpQkFBaUIsR0FBRyxDQUFwQixHQUF3QkEsaUJBQXhCLEdBQTRDLENBQWxELENBRFksQ0FBRixDQUFELEdBQ2dESCxNQUFNLENBQUNRLGtCQURyRTs7RUFFQSxJQUFJLENBQUNsSSxXQUFXLENBQUMySCxhQUFELENBQVosSUFBK0JFLGlCQUFpQixHQUFHRixhQUF2RCxFQUFzRTtJQUNsRTtFQUNIOztFQUNEckUsVUFBVSxDQUFDeUIsVUFBRCxFQUFhZ0QsT0FBYixFQUFzQmIsSUFBdEIsQ0FBVjtBQUNILENBVkQsRUFXQTs7O0FBQ0EsSUFBSWpDLEVBQUUsR0FBRzhCLFNBQVMsQ0FBQyxJQUFJb0IsR0FBSixFQUFELENBQWxCO0FBQUEsSUFBK0J4RCxLQUFLLEdBQUdNLEVBQUUsQ0FBQyxDQUFELENBQXpDO0FBQUEsSUFBOENrQyxNQUFNLEdBQUdsQyxFQUFFLENBQUMsQ0FBRCxDQUF6RCxFQUNBOzs7QUFDQSxJQUFJbUQsYUFBYSxHQUFHbEksWUFBWSxDQUFDO0VBQzdCO0VBQ0FtSSxhQUFhLEVBQUV6SSxJQUZjO0VBRzdCMEksU0FBUyxFQUFFMUksSUFIa0I7RUFJN0IySSxPQUFPLEVBQUUzSSxJQUpvQjtFQUs3QjRILFlBQVksRUFBRUEsWUFMZTtFQU03QmdCLFdBQVcsRUFBRTVJLElBTmdCO0VBTzdCO0VBQ0E2SSxpQkFBaUIsRUFBRSxJQVJVO0VBUzdCQyxxQkFBcUIsRUFBRSxJQVRNO0VBVTdCQyxpQkFBaUIsRUFBRSxJQVZVO0VBVzdCQyxrQkFBa0IsRUFBRSxJQVhTO0VBWTdCO0VBQ0FWLGtCQUFrQixFQUFFdkUsY0FBYyxHQUFHLEtBQUgsR0FBVyxJQWJoQjtFQWM3QmtGLHFCQUFxQixFQUFFLElBQUksSUFkRTtFQWU3QkMsZ0JBQWdCLEVBQUUsSUFBSSxJQWZPO0VBZ0I3QkMsY0FBYyxFQUFFcEYsY0FBYyxHQUFHLElBQUgsR0FBVSxJQWhCWDtFQWlCN0I7RUFDQXFGLE9BQU8sRUFBRSxVQUFVQyxXQUFWLEVBQXVCQyxPQUF2QixFQUFnQztJQUNyQyxPQUFPbkksVUFBVSxDQUFDa0ksV0FBRCxDQUFWLElBQTJCbEksVUFBVSxDQUFDbUksT0FBRCxDQUE1QztFQUNILENBcEI0QjtFQXFCN0JDLFFBQVEsRUFBRSxZQUFZO0lBQUUsT0FBTyxLQUFQO0VBQWUsQ0FyQlY7RUFzQjdCeEUsS0FBSyxFQUFFQSxLQXRCc0I7RUF1QjdCd0MsTUFBTSxFQUFFQSxNQXZCcUI7RUF3QjdCaUMsUUFBUSxFQUFFO0FBeEJtQixDQUFELEVBMEJoQztBQUNBbEcsTUEzQmdDLENBQWhDOztBQTZCQSxJQUFJbUcsWUFBWSxHQUFHLFVBQVVsSixDQUFWLEVBQWFDLENBQWIsRUFBZ0I7RUFDL0I7RUFDQSxJQUFJZixDQUFDLEdBQUdhLFlBQVksQ0FBQ0MsQ0FBRCxFQUFJQyxDQUFKLENBQXBCLENBRitCLENBRy9COztFQUNBLElBQUlBLENBQUosRUFBTztJQUNILElBQUlrSixFQUFFLEdBQUduSixDQUFDLENBQUNvSixHQUFYO0lBQUEsSUFBZ0JDLEVBQUUsR0FBR3JKLENBQUMsQ0FBQ2lKLFFBQXZCO0lBQ0EsSUFBSUssRUFBRSxHQUFHckosQ0FBQyxDQUFDbUosR0FBWDtJQUFBLElBQWdCRyxFQUFFLEdBQUd0SixDQUFDLENBQUNnSixRQUF2Qjs7SUFDQSxJQUFJRSxFQUFFLElBQUlHLEVBQVYsRUFBYztNQUNWcEssQ0FBQyxDQUFDa0ssR0FBRixHQUFRRCxFQUFFLENBQUNuRixNQUFILENBQVVzRixFQUFWLENBQVI7SUFDSDs7SUFDRCxJQUFJRCxFQUFFLElBQUlFLEVBQVYsRUFBYztNQUNWckssQ0FBQyxDQUFDK0osUUFBRixHQUFhbEosWUFBWSxDQUFDc0osRUFBRCxFQUFLRSxFQUFMLENBQXpCO0lBQ0g7RUFDSjs7RUFDRCxPQUFPckssQ0FBUDtBQUNILENBZkQ7O0FBaUJBLElBQUlzSyxnQkFBZ0IsR0FBRy9NLG9EQUFhLENBQUMsRUFBRCxDQUFwQzs7QUFDQSxJQUFJZ04sV0FBVyxHQUFHLFVBQVVDLEtBQVYsRUFBaUI7RUFDL0IsSUFBSXBNLEtBQUssR0FBR29NLEtBQUssQ0FBQ3BNLEtBQWxCLENBRCtCLENBRS9COztFQUNBLElBQUlxTSxjQUFjLEdBQUdULFlBQVksQ0FBQ3hNLGlEQUFVLENBQUM4TSxnQkFBRCxDQUFYLEVBQStCbE0sS0FBL0IsQ0FBakMsQ0FIK0IsQ0FJL0I7O0VBQ0EsSUFBSXVKLFFBQVEsR0FBR3ZKLEtBQUssSUFBSUEsS0FBSyxDQUFDdUosUUFBOUIsQ0FMK0IsQ0FNL0I7O0VBQ0EsSUFBSStDLFlBQVksR0FBR2pOLCtDQUFRLENBQUMsWUFBWTtJQUNwQyxPQUFPa0ssUUFBUSxHQUNURCxTQUFTLENBQUNDLFFBQVEsQ0FBQzhDLGNBQWMsQ0FBQ25GLEtBQWYsSUFBd0JBLEtBQXpCLENBQVQsRUFBMENsSCxLQUExQyxDQURBLEdBRVRvQyxTQUZOO0VBR0gsQ0FKMEIsQ0FBUixDQUloQixDQUpnQixDQUFuQixDQVArQixDQVkvQjs7RUFDQSxJQUFJa0ssWUFBSixFQUFrQjtJQUNkRCxjQUFjLENBQUNuRixLQUFmLEdBQXVCb0YsWUFBWSxDQUFDLENBQUQsQ0FBbkM7SUFDQUQsY0FBYyxDQUFDM0MsTUFBZixHQUF3QjRDLFlBQVksQ0FBQyxDQUFELENBQXBDO0VBQ0gsQ0FoQjhCLENBaUIvQjs7O0VBQ0F4Ryx5QkFBeUIsQ0FBQyxZQUFZO0lBQUUsT0FBUXdHLFlBQVksR0FBR0EsWUFBWSxDQUFDLENBQUQsQ0FBZixHQUFxQmxLLFNBQXpDO0VBQXNELENBQXJFLEVBQXVFLEVBQXZFLENBQXpCO0VBQ0EsT0FBTzlDLG9EQUFhLENBQUM0TSxnQkFBZ0IsQ0FBQ0ssUUFBbEIsRUFBNEI5SixZQUFZLENBQUMySixLQUFELEVBQVE7SUFDaEVwTSxLQUFLLEVBQUVxTTtFQUR5RCxDQUFSLENBQXhDLENBQXBCO0FBR0gsQ0F0QkQ7QUF3QkE7QUFDQTtBQUNBOzs7QUFDQSxJQUFJRyxnQkFBZ0IsR0FBRyxVQUFVQyxLQUFWLEVBQWlCQyxZQUFqQixFQUErQjtFQUNsRCxJQUFJQyxRQUFRLEdBQUd0TiwrQ0FBUSxDQUFDLEVBQUQsQ0FBUixDQUFhLENBQWIsQ0FBZjtFQUNBLElBQUl1TixRQUFRLEdBQUdyTiw2Q0FBTSxDQUFDa04sS0FBRCxDQUFyQixDQUZrRCxDQUdsRDtFQUNBO0VBQ0E7RUFDQTs7RUFDQSxJQUFJSSxvQkFBb0IsR0FBR3ROLDZDQUFNLENBQUM7SUFDOUI0SCxJQUFJLEVBQUUsS0FEd0I7SUFFOUJDLEtBQUssRUFBRSxLQUZ1QjtJQUc5QkMsWUFBWSxFQUFFO0VBSGdCLENBQUQsQ0FBakM7RUFLQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztFQUNJLElBQUl5RixRQUFRLEdBQUd0TixrREFBVyxDQUFDLFVBQVV1TixPQUFWLEVBQW1CO0lBQzFDLElBQUlDLGNBQWMsR0FBRyxLQUFyQjtJQUNBLElBQUlDLFlBQVksR0FBR0wsUUFBUSxDQUFDTSxPQUE1Qjs7SUFDQSxLQUFLLElBQUluTSxDQUFULElBQWNnTSxPQUFkLEVBQXVCO01BQ25CLElBQUlJLENBQUMsR0FBR3BNLENBQVIsQ0FEbUIsQ0FFbkI7TUFDQTs7TUFDQSxJQUFJa00sWUFBWSxDQUFDRSxDQUFELENBQVosS0FBb0JKLE9BQU8sQ0FBQ0ksQ0FBRCxDQUEvQixFQUFvQztRQUNoQ0YsWUFBWSxDQUFDRSxDQUFELENBQVosR0FBa0JKLE9BQU8sQ0FBQ0ksQ0FBRCxDQUF6QixDQURnQyxDQUVoQztRQUNBOztRQUNBLElBQUlOLG9CQUFvQixDQUFDSyxPQUFyQixDQUE2QkMsQ0FBN0IsQ0FBSixFQUFxQztVQUNqQ0gsY0FBYyxHQUFHLElBQWpCO1FBQ0g7TUFDSjtJQUNKOztJQUNELElBQUlBLGNBQWMsSUFBSSxDQUFDTixZQUFZLENBQUNRLE9BQXBDLEVBQTZDO01BQ3pDUCxRQUFRLENBQUMsRUFBRCxDQUFSO0lBQ0g7RUFDSixDQW5CeUIsRUFvQjFCO0VBQ0E7RUFDQSxFQXRCMEIsQ0FBMUIsQ0E3QmtELENBb0RsRDs7RUFDQTdHLHlCQUF5QixDQUFDLFlBQVk7SUFDbEM4RyxRQUFRLENBQUNNLE9BQVQsR0FBbUJULEtBQW5CO0VBQ0gsQ0FGd0IsQ0FBekI7RUFHQSxPQUFPLENBQUNHLFFBQUQsRUFBV0Msb0JBQW9CLENBQUNLLE9BQWhDLEVBQXlDSixRQUF6QyxDQUFQO0FBQ0gsQ0F6REQ7O0FBMkRBLElBQUlNLFNBQVMsR0FBRyxVQUFVM0csSUFBVixFQUFnQjtFQUM1QixPQUFPakUsVUFBVSxDQUFDaUUsSUFBSSxDQUFDLENBQUQsQ0FBTCxDQUFWLEdBQ0QsQ0FBQ0EsSUFBSSxDQUFDLENBQUQsQ0FBTCxFQUFVQSxJQUFJLENBQUMsQ0FBRCxDQUFkLEVBQW1CQSxJQUFJLENBQUMsQ0FBRCxDQUFKLElBQVcsRUFBOUIsQ0FEQyxHQUVELENBQUNBLElBQUksQ0FBQyxDQUFELENBQUwsRUFBVSxJQUFWLEVBQWdCLENBQUNBLElBQUksQ0FBQyxDQUFELENBQUosS0FBWSxJQUFaLEdBQW1CQSxJQUFJLENBQUMsQ0FBRCxDQUF2QixHQUE2QkEsSUFBSSxDQUFDLENBQUQsQ0FBbEMsS0FBMEMsRUFBMUQsQ0FGTjtBQUdILENBSkQ7O0FBTUEsSUFBSTRHLFlBQVksR0FBRyxZQUFZO0VBQzNCLE9BQU81SyxZQUFZLENBQUNrSSxhQUFELEVBQWdCdkwsaURBQVUsQ0FBQzhNLGdCQUFELENBQTFCLENBQW5CO0FBQ0gsQ0FGRCxFQUlBO0FBQ0E7OztBQUNBLElBQUlvQixRQUFRLEdBQUcsVUFBVUMsSUFBVixFQUFnQjtFQUMzQixPQUFPLFNBQVNDLFVBQVQsR0FBc0I7SUFDekIsSUFBSS9HLElBQUksR0FBRyxFQUFYOztJQUNBLEtBQUssSUFBSXlCLEVBQUUsR0FBRyxDQUFkLEVBQWlCQSxFQUFFLEdBQUdDLFNBQVMsQ0FBQ2xHLE1BQWhDLEVBQXdDaUcsRUFBRSxFQUExQyxFQUE4QztNQUMxQ3pCLElBQUksQ0FBQ3lCLEVBQUQsQ0FBSixHQUFXQyxTQUFTLENBQUNELEVBQUQsQ0FBcEI7SUFDSCxDQUp3QixDQUt6Qjs7O0lBQ0EsSUFBSXVGLGNBQWMsR0FBR0osWUFBWSxFQUFqQyxDQU55QixDQU96Qjs7SUFDQSxJQUFJN0YsRUFBRSxHQUFHNEYsU0FBUyxDQUFDM0csSUFBRCxDQUFsQjtJQUFBLElBQTBCRixHQUFHLEdBQUdpQixFQUFFLENBQUMsQ0FBRCxDQUFsQztJQUFBLElBQXVDa0csRUFBRSxHQUFHbEcsRUFBRSxDQUFDLENBQUQsQ0FBOUM7SUFBQSxJQUFtRG1HLE9BQU8sR0FBR25HLEVBQUUsQ0FBQyxDQUFELENBQS9ELENBUnlCLENBU3pCOzs7SUFDQSxJQUFJeUMsTUFBTSxHQUFHMkIsWUFBWSxDQUFDNkIsY0FBRCxFQUFpQkUsT0FBakIsQ0FBekIsQ0FWeUIsQ0FXekI7O0lBQ0EsSUFBSXJOLElBQUksR0FBR2lOLElBQVg7SUFDQSxJQUFJekIsR0FBRyxHQUFHN0IsTUFBTSxDQUFDNkIsR0FBakI7O0lBQ0EsSUFBSUEsR0FBSixFQUFTO01BQ0wsS0FBSyxJQUFJaEUsQ0FBQyxHQUFHZ0UsR0FBRyxDQUFDN0osTUFBakIsRUFBeUI2RixDQUFDLEtBQUssQ0FBL0IsR0FBbUM7UUFDL0J4SCxJQUFJLEdBQUd3TCxHQUFHLENBQUNoRSxDQUFELENBQUgsQ0FBT3hILElBQVAsQ0FBUDtNQUNIO0lBQ0o7O0lBQ0QsT0FBT0EsSUFBSSxDQUFDaUcsR0FBRCxFQUFNbUgsRUFBRSxJQUFJekQsTUFBTSxDQUFDMkQsT0FBbkIsRUFBNEIzRCxNQUE1QixDQUFYO0VBQ0gsQ0FwQkQ7QUFxQkgsQ0F0QkQsRUF3QkE7QUFDQTs7O0FBQ0EsSUFBSTRELGlCQUFpQixHQUFHLFVBQVV0SCxHQUFWLEVBQWV1SCxTQUFmLEVBQTBCekksUUFBMUIsRUFBb0M7RUFDeEQsSUFBSTBJLGlCQUFpQixHQUFHRCxTQUFTLENBQUN2SCxHQUFELENBQVQsS0FBbUJ1SCxTQUFTLENBQUN2SCxHQUFELENBQVQsR0FBaUIsRUFBcEMsQ0FBeEI7RUFDQXdILGlCQUFpQixDQUFDN0wsSUFBbEIsQ0FBdUJtRCxRQUF2QjtFQUNBLE9BQU8sWUFBWTtJQUNmLElBQUl6QixLQUFLLEdBQUdtSyxpQkFBaUIsQ0FBQ0MsT0FBbEIsQ0FBMEIzSSxRQUExQixDQUFaOztJQUNBLElBQUl6QixLQUFLLElBQUksQ0FBYixFQUFnQjtNQUNaO01BQ0FtSyxpQkFBaUIsQ0FBQ25LLEtBQUQsQ0FBakIsR0FBMkJtSyxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUM5TCxNQUFsQixHQUEyQixDQUE1QixDQUE1QztNQUNBOEwsaUJBQWlCLENBQUMvTCxHQUFsQjtJQUNIO0VBQ0osQ0FQRDtBQVFILENBWEQ7O0FBYUEsSUFBSWlNLFdBQVcsR0FBRztFQUFFQyxNQUFNLEVBQUU7QUFBVixDQUFsQjs7QUFDQSxJQUFJQyxhQUFhLEdBQUcsVUFBVS9GLElBQVYsRUFBZ0J3RixPQUFoQixFQUF5QjNELE1BQXpCLEVBQWlDO0VBQ2pELElBQUkvQyxLQUFLLEdBQUcrQyxNQUFNLENBQUMvQyxLQUFuQjtFQUFBLElBQTBCcUUsT0FBTyxHQUFHdEIsTUFBTSxDQUFDc0IsT0FBM0M7RUFBQSxJQUFvRDZDLFlBQVksR0FBR25FLE1BQU0sQ0FBQ21FLFlBQTFFO0VBQUEsSUFBd0ZDLFFBQVEsR0FBR3BFLE1BQU0sQ0FBQ29FLFFBQTFHO0VBQUEsSUFBb0hDLGlCQUFpQixHQUFHckUsTUFBTSxDQUFDcUUsaUJBQS9JO0VBQUEsSUFBa0tDLGVBQWUsR0FBR3RFLE1BQU0sQ0FBQ3NFLGVBQTNMO0VBQUEsSUFBNE1DLGlCQUFpQixHQUFHdkUsTUFBTSxDQUFDdUUsaUJBQXZPO0VBQUEsSUFBMFBDLGtCQUFrQixHQUFHeEUsTUFBTSxDQUFDd0Usa0JBQXRSOztFQUNBLElBQUlqSCxFQUFFLEdBQUdYLGNBQWMsQ0FBQy9DLEdBQWYsQ0FBbUJvRCxLQUFuQixDQUFUO0VBQUEsSUFBb0NPLGtCQUFrQixHQUFHRCxFQUFFLENBQUMsQ0FBRCxDQUEzRDtFQUFBLElBQWdFRSxjQUFjLEdBQUdGLEVBQUUsQ0FBQyxDQUFELENBQW5GO0VBQUEsSUFBd0ZxQixRQUFRLEdBQUdyQixFQUFFLENBQUMsQ0FBRCxDQUFyRztFQUFBLElBQTBHRyxLQUFLLEdBQUdILEVBQUUsQ0FBQyxDQUFELENBQXBILENBRmlELENBR2pEO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7OztFQUNBLElBQUlvQixFQUFFLEdBQUd0QyxTQUFTLENBQUM4QixJQUFELENBQWxCO0VBQUEsSUFBMEI3QixHQUFHLEdBQUdxQyxFQUFFLENBQUMsQ0FBRCxDQUFsQztFQUFBLElBQXVDOEYsTUFBTSxHQUFHOUYsRUFBRSxDQUFDLENBQUQsQ0FBbEQ7RUFBQSxJQUF1REQsT0FBTyxHQUFHQyxFQUFFLENBQUMsQ0FBRCxDQUFuRSxDQVJpRCxDQVNqRDs7O0VBQ0EsSUFBSStGLGlCQUFpQixHQUFHcFAsNkNBQU0sQ0FBQyxLQUFELENBQTlCLENBVmlELENBV2pEO0VBQ0E7O0VBQ0EsSUFBSW1OLFlBQVksR0FBR25OLDZDQUFNLENBQUMsS0FBRCxDQUF6QixDQWJpRCxDQWNqRDs7RUFDQSxJQUFJcVAsTUFBTSxHQUFHclAsNkNBQU0sQ0FBQ2dILEdBQUQsQ0FBbkI7RUFDQSxJQUFJc0ksVUFBVSxHQUFHdFAsNkNBQU0sQ0FBQ3FPLE9BQUQsQ0FBdkI7RUFDQSxJQUFJa0IsU0FBUyxHQUFHdlAsNkNBQU0sQ0FBQzBLLE1BQUQsQ0FBdEI7O0VBQ0EsSUFBSThFLFNBQVMsR0FBRyxZQUFZO0lBQUUsT0FBT0QsU0FBUyxDQUFDNUIsT0FBakI7RUFBMkIsQ0FBekQ7O0VBQ0EsSUFBSThCLFFBQVEsR0FBRyxZQUFZO0lBQUUsT0FBT0QsU0FBUyxHQUFHN0osU0FBWixNQUEyQjZKLFNBQVMsR0FBR3ZLLFFBQVosRUFBbEM7RUFBMkQsQ0FBeEY7O0VBQ0EsSUFBSXlLLGNBQWMsR0FBRyxVQUFVQyxJQUFWLEVBQWdCO0lBQ2pDLE9BQU9oSSxLQUFLLENBQUNuRCxHQUFOLENBQVU0RSxPQUFWLEVBQW1CbEcsWUFBWSxDQUFDeUUsS0FBSyxDQUFDcEQsR0FBTixDQUFVNkUsT0FBVixDQUFELEVBQXFCdUcsSUFBckIsQ0FBL0IsQ0FBUDtFQUNILENBRkQsQ0FwQmlELENBdUJqRDs7O0VBQ0EsSUFBSUMsTUFBTSxHQUFHakksS0FBSyxDQUFDcEQsR0FBTixDQUFVeUMsR0FBVixDQUFiO0VBQ0EsSUFBSW9GLFFBQVEsR0FBR3BKLFdBQVcsQ0FBQzZMLFlBQUQsQ0FBWCxHQUNUbkUsTUFBTSxDQUFDMEIsUUFBUCxDQUFnQnBGLEdBQWhCLENBRFMsR0FFVDZILFlBRk47RUFHQSxJQUFJakgsSUFBSSxHQUFHNUUsV0FBVyxDQUFDNE0sTUFBRCxDQUFYLEdBQXNCeEQsUUFBdEIsR0FBaUN3RCxNQUE1QztFQUNBLElBQUlELElBQUksR0FBR2hJLEtBQUssQ0FBQ3BELEdBQU4sQ0FBVTZFLE9BQVYsS0FBc0IsRUFBakM7RUFDQSxJQUFJdkIsS0FBSyxHQUFHOEgsSUFBSSxDQUFDOUgsS0FBakI7RUFDQSxJQUFJZ0ksY0FBYyxHQUFHLENBQUNULGlCQUFpQixDQUFDekIsT0FBeEMsQ0EvQmlELENBZ0NqRDtFQUNBO0VBQ0E7O0VBQ0EsSUFBSW1DLGdCQUFnQixHQUFHLFlBQVk7SUFDL0I7SUFDQSxJQUFJRCxjQUFjLElBQUksQ0FBQzdNLFdBQVcsQ0FBQytMLGlCQUFELENBQWxDLEVBQ0ksT0FBT0EsaUJBQVAsQ0FIMkIsQ0FJL0I7O0lBQ0EsSUFBSVMsU0FBUyxHQUFHckQsUUFBWixFQUFKLEVBQ0ksT0FBTyxLQUFQLENBTjJCLENBTy9CO0lBQ0E7SUFDQTs7SUFDQSxJQUFJMkMsUUFBSixFQUNJLE9BQU85TCxXQUFXLENBQUM0RSxJQUFELENBQVgsR0FBb0IsS0FBcEIsR0FBNEI4QyxNQUFNLENBQUNpQixpQkFBMUMsQ0FYMkIsQ0FZL0I7SUFDQTs7SUFDQSxPQUFPM0ksV0FBVyxDQUFDNEUsSUFBRCxDQUFYLElBQXFCOEMsTUFBTSxDQUFDaUIsaUJBQW5DO0VBQ0gsQ0FmRCxDQW5DaUQsQ0FtRGpEOzs7RUFDQSxJQUFJb0UsaUJBQWlCLEdBQUcsWUFBWTtJQUNoQyxJQUFJLENBQUMvSSxHQUFELElBQVEsQ0FBQ3FILE9BQWIsRUFDSSxPQUFPLEtBQVA7SUFDSixJQUFJc0IsSUFBSSxDQUFDN0gsWUFBVCxFQUNJLE9BQU8sSUFBUCxDQUo0QixDQUtoQzs7SUFDQSxPQUFPK0gsY0FBYyxJQUFJQyxnQkFBZ0IsRUFBekM7RUFDSCxDQVBEOztFQVFBLElBQUloSSxZQUFZLEdBQUdpSSxpQkFBaUIsRUFBcEM7O0VBQ0EsSUFBSW5HLEVBQUUsR0FBR3FELGdCQUFnQixDQUFDO0lBQ3RCckYsSUFBSSxFQUFFQSxJQURnQjtJQUV0QkMsS0FBSyxFQUFFQSxLQUZlO0lBR3RCQyxZQUFZLEVBQUVBO0VBSFEsQ0FBRCxFQUl0QnFGLFlBSnNCLENBQXpCO0VBQUEsSUFJa0JFLFFBQVEsR0FBR3pELEVBQUUsQ0FBQyxDQUFELENBSi9CO0VBQUEsSUFJb0NvRyxpQkFBaUIsR0FBR3BHLEVBQUUsQ0FBQyxDQUFELENBSjFEO0VBQUEsSUFJK0QyRCxRQUFRLEdBQUczRCxFQUFFLENBQUMsQ0FBRCxDQUo1RSxDQTdEaUQsQ0FrRWpEO0VBQ0E7OztFQUNBLElBQUk3QixVQUFVLEdBQUc5SCxrREFBVyxDQUFDLFVBQVVnUSxjQUFWLEVBQTBCO0lBQUUsT0FBTzlQLFNBQVMsQ0FBQyxLQUFLLENBQU4sRUFBUyxLQUFLLENBQWQsRUFBaUIsS0FBSyxDQUF0QixFQUF5QixZQUFZO01BQzFHLElBQUkrUCxjQUFKLEVBQW9CaEUsT0FBcEIsRUFBNkJpRSxPQUE3QixFQUFzQ0MsT0FBdEMsRUFBK0NsRyxJQUEvQyxFQUFxRG1HLHFCQUFyRCxFQUE0RUMsbUJBQTVFLEVBQWlHQyxZQUFqRyxFQUErR0MsUUFBL0csRUFBeUhDLDJCQUF6SCxFQUFzSkMsWUFBdEosRUFBb0tDLEtBQXBLOztNQUNBLElBQUkxSSxFQUFKOztNQUNBLE9BQU8zRyxXQUFXLENBQUMsSUFBRCxFQUFPLFVBQVUrSCxFQUFWLEVBQWM7UUFDbkMsUUFBUUEsRUFBRSxDQUFDNUgsS0FBWDtVQUNJLEtBQUssQ0FBTDtZQUNJeU8sY0FBYyxHQUFHWixVQUFVLENBQUMzQixPQUE1Qjs7WUFDQSxJQUFJLENBQUMzRyxHQUFELElBQ0EsQ0FBQ2tKLGNBREQsSUFFQS9DLFlBQVksQ0FBQ1EsT0FGYixJQUdBNkIsU0FBUyxHQUFHckQsUUFBWixFQUhKLEVBRzRCO2NBQ3hCLE9BQU8sQ0FBQztjQUFFO2NBQUgsRUFBZSxLQUFmLENBQVA7WUFDSDs7WUFDRGlFLE9BQU8sR0FBRyxJQUFWO1lBQ0FsRyxJQUFJLEdBQUcrRixjQUFjLElBQUksRUFBekI7WUFDQUkscUJBQXFCLEdBQUcsQ0FBQ2pJLEtBQUssQ0FBQ3BCLEdBQUQsQ0FBTixJQUFlLENBQUNrRCxJQUFJLENBQUN5RSxNQUE3Qzs7WUFDQTJCLG1CQUFtQixHQUFHLFlBQVk7Y0FDOUIsT0FBTyxDQUFDbkQsWUFBWSxDQUFDUSxPQUFkLElBQ0gzRyxHQUFHLEtBQUtxSSxNQUFNLENBQUMxQixPQURaLElBRUh5QixpQkFBaUIsQ0FBQ3pCLE9BRnRCO1lBR0gsQ0FKRDs7WUFLQTRDLFlBQVksR0FBRyxZQUFZO2NBQ3ZCO2NBQ0EsSUFBSUssV0FBVyxHQUFHeEksS0FBSyxDQUFDcEIsR0FBRCxDQUF2Qjs7Y0FDQSxJQUFJNEosV0FBVyxJQUFJQSxXQUFXLENBQUMsQ0FBRCxDQUFYLEtBQW1CVCxPQUF0QyxFQUErQztnQkFDM0MsT0FBTy9ILEtBQUssQ0FBQ3BCLEdBQUQsQ0FBWjtjQUNIO1lBQ0osQ0FORDs7WUFPQXdKLFFBQVEsR0FBRztjQUFFMUksWUFBWSxFQUFFO1lBQWhCLENBQVg7O1lBQ0EySSwyQkFBMkIsR0FBRyxZQUFZO2NBQ3RDZixjQUFjLENBQUM7Z0JBQUU1SCxZQUFZLEVBQUU7Y0FBaEIsQ0FBRCxDQUFkLENBRHNDLENBRXRDOztjQUNBLElBQUl3SSxtQkFBbUIsRUFBdkIsRUFBMkI7Z0JBQ3ZCL0MsUUFBUSxDQUFDaUQsUUFBRCxDQUFSO2NBQ0g7WUFDSixDQU5ELENBeEJKLENBK0JJOzs7WUFDQWQsY0FBYyxDQUFDO2NBQ1g1SCxZQUFZLEVBQUU7WUFESCxDQUFELENBQWQ7WUFHQXlGLFFBQVEsQ0FBQztjQUFFekYsWUFBWSxFQUFFO1lBQWhCLENBQUQsQ0FBUjtZQUNBdUIsRUFBRSxDQUFDNUgsS0FBSCxHQUFXLENBQVg7O1VBQ0osS0FBSyxDQUFMO1lBQ0k0SCxFQUFFLENBQUN6SCxJQUFILENBQVFlLElBQVIsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEdBQVMsQ0FBVCxDQUFiOztZQUNBLElBQUkwTixxQkFBSixFQUEyQjtjQUN2QjtjQUNBM0ksY0FBYyxDQUFDQyxLQUFELEVBQVFYLEdBQVIsRUFBYXFHLFFBQVEsQ0FBQ00sT0FBVCxDQUFpQi9GLElBQTlCLEVBQW9DeUYsUUFBUSxDQUFDTSxPQUFULENBQWlCOUYsS0FBckQsRUFBNEQsSUFBNUQsQ0FBZCxDQUZ1QixDQUd2QjtjQUNBOztjQUNBLElBQUk2QyxNQUFNLENBQUNxQixjQUFQLElBQXlCLENBQUNwRSxLQUFLLENBQUNwRCxHQUFOLENBQVV5QyxHQUFWLENBQTlCLEVBQThDO2dCQUMxQ1YsVUFBVSxDQUFDLFlBQVk7a0JBQ25CLElBQUk4SixPQUFPLElBQUlFLG1CQUFtQixFQUFsQyxFQUFzQztvQkFDbENkLFNBQVMsR0FBR25FLGFBQVosQ0FBMEJyRSxHQUExQixFQUErQjBELE1BQS9CO2tCQUNIO2dCQUNKLENBSlMsRUFJUEEsTUFBTSxDQUFDcUIsY0FKQSxDQUFWO2NBS0gsQ0FYc0IsQ0FZdkI7OztjQUNBM0QsS0FBSyxDQUFDcEIsR0FBRCxDQUFMLEdBQWEsQ0FBQ2tKLGNBQWMsQ0FBQzdPLEtBQWYsQ0FBcUIsS0FBSyxDQUExQixFQUE2QjhOLE1BQTdCLENBQUQsRUFBdUMxRyxZQUFZLEVBQW5ELENBQWI7WUFDSDs7WUFDRFIsRUFBRSxHQUFHRyxLQUFLLENBQUNwQixHQUFELENBQVYsRUFBaUJrRixPQUFPLEdBQUdqRSxFQUFFLENBQUMsQ0FBRCxDQUE3QixFQUFrQ2tJLE9BQU8sR0FBR2xJLEVBQUUsQ0FBQyxDQUFELENBQTlDO1lBQ0EsT0FBTyxDQUFDO1lBQUU7WUFBSCxFQUFjaUUsT0FBZCxDQUFQOztVQUNKLEtBQUssQ0FBTDtZQUNJQSxPQUFPLEdBQUc3QyxFQUFFLENBQUMzSCxJQUFILEVBQVY7O1lBQ0EsSUFBSTJPLHFCQUFKLEVBQTJCO2NBQ3ZCO2NBQ0E7Y0FDQS9KLFVBQVUsQ0FBQ2lLLFlBQUQsRUFBZTdGLE1BQU0sQ0FBQ29CLGdCQUF0QixDQUFWO1lBQ0gsQ0FOTCxDQU9JO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTs7O1lBQ0EsSUFBSSxDQUFDMUQsS0FBSyxDQUFDcEIsR0FBRCxDQUFOLElBQWVvQixLQUFLLENBQUNwQixHQUFELENBQUwsQ0FBVyxDQUFYLE1BQWtCbUosT0FBckMsRUFBOEM7Y0FDMUMsSUFBSUUscUJBQUosRUFBMkI7Z0JBQ3ZCLElBQUlDLG1CQUFtQixFQUF2QixFQUEyQjtrQkFDdkJkLFNBQVMsR0FBR2hFLFdBQVosQ0FBd0J4RSxHQUF4QjtnQkFDSDtjQUNKOztjQUNELE9BQU8sQ0FBQztjQUFFO2NBQUgsRUFBZSxLQUFmLENBQVA7WUFDSCxDQXBCTCxDQXFCSTs7O1lBQ0EwSSxjQUFjLENBQUM7Y0FDWDdILEtBQUssRUFBRWhGO1lBREksQ0FBRCxDQUFkO1lBR0EyTixRQUFRLENBQUMzSSxLQUFULEdBQWlCaEYsU0FBakI7WUFDQTZOLFlBQVksR0FBR3BILFFBQVEsQ0FBQ3RDLEdBQUQsQ0FBdkI7O1lBQ0EsSUFBSSxDQUFDaEUsV0FBVyxDQUFDME4sWUFBRCxDQUFaLE1BQ0E7WUFDQ1AsT0FBTyxJQUFJTyxZQUFZLENBQUMsQ0FBRCxDQUF2QixJQUNHO1lBQ0FQLE9BQU8sSUFBSU8sWUFBWSxDQUFDLENBQUQsQ0FGMUIsSUFHRztZQUNBQSxZQUFZLENBQUMsQ0FBRCxDQUFaLEtBQW9CLENBTnhCLENBQUosRUFNZ0M7Y0FDNUJELDJCQUEyQjs7Y0FDM0IsSUFBSUoscUJBQUosRUFBMkI7Z0JBQ3ZCLElBQUlDLG1CQUFtQixFQUF2QixFQUEyQjtrQkFDdkJkLFNBQVMsR0FBR2hFLFdBQVosQ0FBd0J4RSxHQUF4QjtnQkFDSDtjQUNKOztjQUNELE9BQU8sQ0FBQztjQUFFO2NBQUgsRUFBZSxLQUFmLENBQVA7WUFDSCxDQXpDTCxDQTBDSTtZQUNBOzs7WUFDQSxJQUFJLENBQUNnRixPQUFPLENBQUNxQixRQUFRLENBQUNNLE9BQVQsQ0FBaUIvRixJQUFsQixFQUF3QnNFLE9BQXhCLENBQVosRUFBOEM7Y0FDMUNzRSxRQUFRLENBQUM1SSxJQUFULEdBQWdCc0UsT0FBaEI7WUFDSCxDQUZELE1BR0s7Y0FDRDtjQUNBO2NBQ0FzRSxRQUFRLENBQUM1SSxJQUFULEdBQWdCeUYsUUFBUSxDQUFDTSxPQUFULENBQWlCL0YsSUFBakMsQ0FIQyxDQUlEO2NBQ0E7WUFDSCxDQXJETCxDQXNESTtZQUNBOzs7WUFDQSxJQUFJLENBQUNvRSxPQUFPLENBQUNyRSxLQUFLLENBQUNwRCxHQUFOLENBQVV5QyxHQUFWLENBQUQsRUFBaUJrRixPQUFqQixDQUFaLEVBQXVDO2NBQ25DdkUsS0FBSyxDQUFDbkQsR0FBTixDQUFVd0MsR0FBVixFQUFla0YsT0FBZjtZQUNILENBMURMLENBMkRJOzs7WUFDQSxJQUFJbUUscUJBQUosRUFBMkI7Y0FDdkIsSUFBSUMsbUJBQW1CLEVBQXZCLEVBQTJCO2dCQUN2QmQsU0FBUyxHQUFHbEUsU0FBWixDQUFzQlksT0FBdEIsRUFBK0JsRixHQUEvQixFQUFvQzBELE1BQXBDO2NBQ0g7WUFDSjs7WUFDRCxPQUFPLENBQUM7WUFBRTtZQUFILEVBQWMsQ0FBZCxDQUFQOztVQUNKLEtBQUssQ0FBTDtZQUNJaUcsS0FBSyxHQUFHdEgsRUFBRSxDQUFDM0gsSUFBSCxFQUFSO1lBQ0E2TyxZQUFZLEdBRmhCLENBR0k7O1lBQ0EsSUFBSSxDQUFDZixTQUFTLEdBQUdyRCxRQUFaLEVBQUwsRUFBNkI7Y0FDekI7Y0FDQXVELGNBQWMsQ0FBQztnQkFBRTdILEtBQUssRUFBRThJO2NBQVQsQ0FBRCxDQUFkO2NBQ0FILFFBQVEsQ0FBQzNJLEtBQVQsR0FBaUI4SSxLQUFqQixDQUh5QixDQUl6QjtjQUNBOztjQUNBLElBQUlOLHFCQUFxQixJQUFJQyxtQkFBbUIsRUFBaEQsRUFBb0Q7Z0JBQ2hEZCxTQUFTLEdBQUdqRSxPQUFaLENBQW9Cb0YsS0FBcEIsRUFBMkIzSixHQUEzQixFQUFnQzBELE1BQWhDOztnQkFDQSxJQUFLLE9BQU9BLE1BQU0sQ0FBQ2tCLGtCQUFkLEtBQXFDLFNBQXJDLElBQ0RsQixNQUFNLENBQUNrQixrQkFEUCxJQUVDM0ksVUFBVSxDQUFDeUgsTUFBTSxDQUFDa0Isa0JBQVIsQ0FBVixJQUNHbEIsTUFBTSxDQUFDa0Isa0JBQVAsQ0FBMEIrRSxLQUExQixDQUhSLEVBRzJDO2tCQUN2QztrQkFDQSxJQUFJbEIsUUFBUSxFQUFaLEVBQWdCO29CQUNaO29CQUNBO29CQUNBRCxTQUFTLEdBQUdoRixZQUFaLENBQXlCbUcsS0FBekIsRUFBZ0MzSixHQUFoQyxFQUFxQzBELE1BQXJDLEVBQTZDM0MsVUFBN0MsRUFBeUQ7c0JBQ3JEK0MsVUFBVSxFQUFFLENBQUNaLElBQUksQ0FBQ1ksVUFBTCxJQUFtQixDQUFwQixJQUF5QixDQURnQjtzQkFFckQ2RCxNQUFNLEVBQUU7b0JBRjZDLENBQXpEO2tCQUlIO2dCQUNKO2NBQ0o7WUFDSjs7WUFDRCxPQUFPLENBQUM7WUFBRTtZQUFILEVBQWMsQ0FBZCxDQUFQOztVQUNKLEtBQUssQ0FBTDtZQUNJO1lBQ0F5QixPQUFPLEdBQUcsS0FBVixDQUZKLENBR0k7O1lBQ0FLLDJCQUEyQixHQUovQixDQUtJO1lBQ0E7O1lBQ0EsSUFBSUgsbUJBQW1CLE1BQU1ELHFCQUE3QixFQUFvRDtjQUNoRDNJLGNBQWMsQ0FBQ0MsS0FBRCxFQUFRWCxHQUFSLEVBQWF3SixRQUFRLENBQUM1SSxJQUF0QixFQUE0QjRJLFFBQVEsQ0FBQzNJLEtBQXJDLEVBQTRDLEtBQTVDLENBQWQ7WUFDSDs7WUFDRCxPQUFPLENBQUM7WUFBRTtZQUFILEVBQWUsSUFBZixDQUFQO1FBbEtSO01Bb0tILENBcktpQixDQUFsQjtJQXNLSCxDQXpLd0UsQ0FBaEI7RUF5S3BELENBekt1QixFQTBLNUI7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLENBQUNiLEdBQUQsQ0FyTDRCLENBQTVCLENBcEVpRCxDQTBQakQ7RUFDQTtFQUNBOztFQUNBLElBQUk2SixXQUFXLEdBQUc1USxrREFBVyxFQUM3QjtFQUNBO0VBQ0E7RUFDQXlJLGNBQWMsQ0FBQ3BELElBQWYsQ0FBb0J6QyxTQUFwQixFQUErQjhFLEtBQS9CLEVBQXNDLFlBQVk7SUFBRSxPQUFPMEgsTUFBTSxDQUFDMUIsT0FBZDtFQUF3QixDQUE1RSxDQUo2QixFQUs3QjtFQUNBLEVBTjZCLENBQTdCLENBN1BpRCxDQW9RakQ7O0VBQ0FwSCx5QkFBeUIsQ0FBQyxZQUFZO0lBQ2xDK0ksVUFBVSxDQUFDM0IsT0FBWCxHQUFxQlUsT0FBckI7SUFDQWtCLFNBQVMsQ0FBQzVCLE9BQVYsR0FBb0JqRCxNQUFwQjtFQUNILENBSHdCLENBQXpCLENBclFpRCxDQXlRakQ7O0VBQ0FuRSx5QkFBeUIsQ0FBQyxZQUFZO0lBQ2xDLElBQUksQ0FBQ1MsR0FBTCxFQUNJO0lBQ0osSUFBSThKLFVBQVUsR0FBRzlKLEdBQUcsS0FBS3FJLE1BQU0sQ0FBQzFCLE9BQWhDO0lBQ0EsSUFBSW9ELGNBQWMsR0FBR2hKLFVBQVUsQ0FBQ3pDLElBQVgsQ0FBZ0J6QyxTQUFoQixFQUEyQjZMLFdBQTNCLENBQXJCLENBSmtDLENBS2xDO0lBQ0E7O0lBQ0EsSUFBSXNDLGFBQWEsR0FBRyxVQUFVQyxXQUFWLEVBQXVCQyxZQUF2QixFQUFxQ0MsbUJBQXJDLEVBQTBEO01BQzFFNUQsUUFBUSxDQUFDckssWUFBWSxDQUFDO1FBQ2xCMkUsS0FBSyxFQUFFcUosWUFEVztRQUVsQnBKLFlBQVksRUFBRXFKO01BRkksQ0FBRCxFQUlyQjtNQUNBO01BQ0FuRixPQUFPLENBQUNxQixRQUFRLENBQUNNLE9BQVQsQ0FBaUIvRixJQUFsQixFQUF3QnFKLFdBQXhCLENBQVAsR0FDTXBPLFNBRE4sR0FFTTtRQUNFK0UsSUFBSSxFQUFFcUo7TUFEUixDQVJlLENBQWIsQ0FBUjtJQVdILENBWkQsQ0FQa0MsQ0FvQmxDO0lBQ0E7OztJQUNBLElBQUlHLHNCQUFzQixHQUFHLENBQTdCOztJQUNBLElBQUlDLFlBQVksR0FBRyxVQUFVcE4sSUFBVixFQUFnQjtNQUMvQixJQUFJQSxJQUFJLElBQUlzRCxXQUFaLEVBQXlCO1FBQ3JCLElBQUkrSixHQUFHLEdBQUdsTixJQUFJLENBQUNrTixHQUFMLEVBQVY7O1FBQ0EsSUFBSTlCLFNBQVMsR0FBRy9ELGlCQUFaLElBQ0E2RixHQUFHLEdBQUdGLHNCQUROLElBRUEzQixRQUFRLEVBRlosRUFFZ0I7VUFDWjJCLHNCQUFzQixHQUFHRSxHQUFHLEdBQUc5QixTQUFTLEdBQUczRCxxQkFBM0M7VUFDQWtGLGNBQWM7UUFDakI7TUFDSixDQVJELE1BU0ssSUFBSTlNLElBQUksSUFBSXVELGVBQVosRUFBNkI7UUFDOUIsSUFBSWdJLFNBQVMsR0FBRzlELHFCQUFaLElBQXFDK0QsUUFBUSxFQUFqRCxFQUFxRDtVQUNqRHNCLGNBQWM7UUFDakI7TUFDSixDQUpJLE1BS0EsSUFBSTlNLElBQUksSUFBSXdELFlBQVosRUFBMEI7UUFDM0IsT0FBT00sVUFBVSxFQUFqQjtNQUNIOztNQUNEO0lBQ0gsQ0FuQkQ7O0lBb0JBLElBQUl3SixXQUFXLEdBQUdqRCxpQkFBaUIsQ0FBQ3RILEdBQUQsRUFBTW1CLGNBQU4sRUFBc0I2SSxhQUF0QixDQUFuQztJQUNBLElBQUlRLFdBQVcsR0FBR2xELGlCQUFpQixDQUFDdEgsR0FBRCxFQUFNa0Isa0JBQU4sRUFBMEJtSixZQUExQixDQUFuQyxDQTVDa0MsQ0E2Q2xDOztJQUNBbEUsWUFBWSxDQUFDUSxPQUFiLEdBQXVCLEtBQXZCO0lBQ0EwQixNQUFNLENBQUMxQixPQUFQLEdBQWlCM0csR0FBakI7SUFDQW9JLGlCQUFpQixDQUFDekIsT0FBbEIsR0FBNEIsSUFBNUIsQ0FoRGtDLENBaURsQztJQUNBOztJQUNBLElBQUltRCxVQUFKLEVBQWdCO01BQ1p2RCxRQUFRLENBQUM7UUFDTDNGLElBQUksRUFBRUEsSUFERDtRQUVMQyxLQUFLLEVBQUVBLEtBRkY7UUFHTEMsWUFBWSxFQUFFQTtNQUhULENBQUQsQ0FBUjtJQUtILENBekRpQyxDQTBEbEM7OztJQUNBLElBQUlnSSxnQkFBZ0IsRUFBcEIsRUFBd0I7TUFDcEIsSUFBSTlNLFdBQVcsQ0FBQzRFLElBQUQsQ0FBWCxJQUFxQnhCLFNBQXpCLEVBQW9DO1FBQ2hDO1FBQ0EySyxjQUFjO01BQ2pCLENBSEQsTUFJSztRQUNEO1FBQ0E7UUFDQTFLLEdBQUcsQ0FBQzBLLGNBQUQsQ0FBSDtNQUNIO0lBQ0o7O0lBQ0QsT0FBTyxZQUFZO01BQ2Y7TUFDQTVELFlBQVksQ0FBQ1EsT0FBYixHQUF1QixJQUF2QjtNQUNBNEQsV0FBVztNQUNYQyxXQUFXO0lBQ2QsQ0FMRDtFQU1ILENBNUV3QixFQTRFdEIsQ0FBQ3hLLEdBQUQsRUFBTWUsVUFBTixDQTVFc0IsQ0FBekIsQ0ExUWlELENBdVZqRDs7RUFDQXhCLHlCQUF5QixDQUFDLFlBQVk7SUFDbEMsSUFBSWtMLEtBQUo7O0lBQ0EsU0FBUzFRLElBQVQsR0FBZ0I7TUFDWjtNQUNBO01BQ0EsSUFBSTJRLFFBQVEsR0FBR3pPLFVBQVUsQ0FBQytMLGVBQUQsQ0FBVixHQUNUQSxlQUFlLENBQUNwSCxJQUFELENBRE4sR0FFVG9ILGVBRk4sQ0FIWSxDQU1aO01BQ0E7TUFDQTs7TUFDQSxJQUFJMEMsUUFBUSxJQUFJRCxLQUFLLEtBQUssQ0FBQyxDQUEzQixFQUE4QjtRQUMxQkEsS0FBSyxHQUFHbkwsVUFBVSxDQUFDcUwsT0FBRCxFQUFVRCxRQUFWLENBQWxCO01BQ0g7SUFDSjs7SUFDRCxTQUFTQyxPQUFULEdBQW1CO01BQ2Y7TUFDQTtNQUNBLElBQUksQ0FBQ3RFLFFBQVEsQ0FBQ00sT0FBVCxDQUFpQjlGLEtBQWxCLEtBQ0NvSCxpQkFBaUIsSUFBSU8sU0FBUyxHQUFHN0osU0FBWixFQUR0QixNQUVDdUosa0JBQWtCLElBQUlNLFNBQVMsR0FBR3ZLLFFBQVosRUFGdkIsQ0FBSixFQUVvRDtRQUNoRDhDLFVBQVUsQ0FBQzJHLFdBQUQsQ0FBVixDQUF3QnROLElBQXhCLENBQTZCTCxJQUE3QjtNQUNILENBSkQsTUFLSztRQUNEO1FBQ0FBLElBQUk7TUFDUDtJQUNKOztJQUNEQSxJQUFJO0lBQ0osT0FBTyxZQUFZO01BQ2YsSUFBSTBRLEtBQUosRUFBVztRQUNQRyxZQUFZLENBQUNILEtBQUQsQ0FBWjtRQUNBQSxLQUFLLEdBQUcsQ0FBQyxDQUFUO01BQ0g7SUFDSixDQUxEO0VBTUgsQ0FuQ3dCLEVBbUN0QixDQUFDekMsZUFBRCxFQUFrQkMsaUJBQWxCLEVBQXFDQyxrQkFBckMsRUFBeURuSCxVQUF6RCxDQW5Dc0IsQ0FBekIsQ0F4VmlELENBNFhqRDs7RUFDQTdILG9EQUFhLENBQUMwSCxJQUFELENBQWIsQ0E3WGlELENBOFhqRDtFQUNBO0VBQ0E7RUFDQTs7RUFDQSxJQUFJa0gsUUFBUSxJQUFJOUwsV0FBVyxDQUFDNEUsSUFBRCxDQUF2QixJQUFpQ1osR0FBckMsRUFBMEM7SUFDdEM7SUFDQXNJLFVBQVUsQ0FBQzNCLE9BQVgsR0FBcUJVLE9BQXJCO0lBQ0FrQixTQUFTLENBQUM1QixPQUFWLEdBQW9CakQsTUFBcEI7SUFDQXlDLFlBQVksQ0FBQ1EsT0FBYixHQUF1QixLQUF2QjtJQUNBLE1BQU0zSyxXQUFXLENBQUM2RSxLQUFELENBQVgsR0FBcUJFLFVBQVUsQ0FBQzJHLFdBQUQsQ0FBL0IsR0FBK0M3RyxLQUFyRDtFQUNIOztFQUNELE9BQU87SUFDSHNDLE1BQU0sRUFBRTBHLFdBREw7O0lBRUgsSUFBSWpKLElBQUosR0FBVztNQUNQb0ksaUJBQWlCLENBQUNwSSxJQUFsQixHQUF5QixJQUF6QjtNQUNBLE9BQU9BLElBQVA7SUFDSCxDQUxFOztJQU1ILElBQUlDLEtBQUosR0FBWTtNQUNSbUksaUJBQWlCLENBQUNuSSxLQUFsQixHQUEwQixJQUExQjtNQUNBLE9BQU9BLEtBQVA7SUFDSCxDQVRFOztJQVVILElBQUlDLFlBQUosR0FBbUI7TUFDZmtJLGlCQUFpQixDQUFDbEksWUFBbEIsR0FBaUMsSUFBakM7TUFDQSxPQUFPQSxZQUFQO0lBQ0g7O0VBYkUsQ0FBUDtBQWVILENBeFpEOztBQXlaQSxJQUFJK0osU0FBUyxHQUFHL08sTUFBTSxDQUFDZ1AsY0FBUCxDQUFzQmxGLFdBQXRCLEVBQW1DLFNBQW5DLEVBQThDO0VBQzFEbk0sS0FBSyxFQUFFMks7QUFEbUQsQ0FBOUMsQ0FBaEI7O0FBR0EsSUFBSTJHLGtCQUFrQixHQUFHLFVBQVUvSyxHQUFWLEVBQWU7RUFBRSxPQUFPRCxTQUFTLENBQUNDLEdBQUQsQ0FBVCxDQUFlLENBQWYsQ0FBUDtBQUEyQixDQUFyRTs7QUFDQSxJQUFJZ0wsTUFBTSxHQUFHakUsUUFBUSxDQUFDYSxhQUFELENBQXJCLEVBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N3ci9kaXN0L2luZGV4Lm1qcz82MmUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgY3JlYXRlRWxlbWVudCwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlRGVidWdWYWx1ZSB9IGZyb20gJ3JlYWN0JztcclxuXHJcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XHJcbi8vIFVzaW5nIG5vb3AoKSBhcyB0aGUgdW5kZWZpbmVkIHZhbHVlIGFzIHVuZGVmaW5lZCBjYW4gcG9zc2libHkgYmUgcmVwbGFjZWRcclxuLy8gYnkgc29tZXRoaW5nIGVsc2UuICBQcmV0dGllciBpZ25vcmUgYW5kIGV4dHJhIHBhcmVudGhlc2VzIGFyZSBuZWNlc3NhcnkgaGVyZVxyXG4vLyB0byBlbnN1cmUgdGhhdCB0c2MgZG9lc24ndCByZW1vdmUgdGhlIF9fTk9JTkxJTkVfXyBjb21tZW50LlxyXG4vLyBwcmV0dGllci1pZ25vcmVcclxudmFyIFVOREVGSU5FRCA9ICggLyojX19OT0lOTElORV9fKi9ub29wKCkpO1xyXG52YXIgT0JKRUNUID0gT2JqZWN0O1xyXG52YXIgaXNVbmRlZmluZWQgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdiA9PT0gVU5ERUZJTkVEOyB9O1xyXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0eXBlb2YgdiA9PSAnZnVuY3Rpb24nOyB9O1xyXG52YXIgbWVyZ2VPYmplY3RzID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIE9CSkVDVC5hc3NpZ24oe30sIGEsIGIpOyB9O1xyXG52YXIgU1RSX1VOREVGSU5FRCA9ICd1bmRlZmluZWQnO1xyXG4vLyBOT1RFOiBVc2UgZnVuY3Rpb24gdG8gZ3VhcmFudGVlIGl0J3MgcmUtZXZhbHVhdGVkIGJldHdlZW4ganNkb20gYW5kIG5vZGUgcnVudGltZSBmb3IgdGVzdHMuXHJcbnZhciBoYXNXaW5kb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlb2Ygd2luZG93ICE9IFNUUl9VTkRFRklORUQ7IH07XHJcbnZhciBoYXNEb2N1bWVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPSBTVFJfVU5ERUZJTkVEOyB9O1xyXG52YXIgaGFzUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGhhc1dpbmRvdygpICYmIHR5cGVvZiB3aW5kb3dbJ3JlcXVlc3RBbmltYXRpb25GcmFtZSddICE9IFNUUl9VTkRFRklORUQ7XHJcbn07XHJcblxyXG4vLyB1c2UgV2Vha01hcCB0byBzdG9yZSB0aGUgb2JqZWN0LT5rZXkgbWFwcGluZ1xyXG4vLyBzbyB0aGUgb2JqZWN0cyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXHJcbi8vIFdlYWtNYXAgdXNlcyBhIGhhc2h0YWJsZSB1bmRlciB0aGUgaG9vZCwgc28gdGhlIGxvb2t1cFxyXG4vLyBjb21wbGV4aXR5IGlzIGFsbW9zdCBPKDEpLlxyXG52YXIgdGFibGUgPSBuZXcgV2Vha01hcCgpO1xyXG4vLyBjb3VudGVyIG9mIHRoZSBrZXlcclxudmFyIGNvdW50ZXIgPSAwO1xyXG4vLyBBIHN0YWJsZSBoYXNoIGltcGxlbWVudGF0aW9uIHRoYXQgc3VwcG9ydHM6XHJcbi8vIC0gRmFzdCBhbmQgZW5zdXJlcyB1bmlxdWUgaGFzaCBwcm9wZXJ0aWVzXHJcbi8vIC0gSGFuZGxlcyB1bnNlcmlhbGl6YWJsZSB2YWx1ZXNcclxuLy8gLSBIYW5kbGVzIG9iamVjdCBrZXkgb3JkZXJpbmdcclxuLy8gLSBHZW5lcmF0ZXMgc2hvcnQgcmVzdWx0c1xyXG4vL1xyXG4vLyBUaGlzIGlzIG5vdCBhIHNlcmlhbGl6YXRpb24gZnVuY3Rpb24sIGFuZCB0aGUgcmVzdWx0IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlXHJcbi8vIHBhcnNpYmxlLlxyXG52YXIgc3RhYmxlSGFzaCA9IGZ1bmN0aW9uIChhcmcpIHtcclxuICAgIHZhciB0eXBlID0gdHlwZW9mIGFyZztcclxuICAgIHZhciBjb25zdHJ1Y3RvciA9IGFyZyAmJiBhcmcuY29uc3RydWN0b3I7XHJcbiAgICB2YXIgaXNEYXRlID0gY29uc3RydWN0b3IgPT0gRGF0ZTtcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICB2YXIgaW5kZXg7XHJcbiAgICBpZiAoT0JKRUNUKGFyZykgPT09IGFyZyAmJiAhaXNEYXRlICYmIGNvbnN0cnVjdG9yICE9IFJlZ0V4cCkge1xyXG4gICAgICAgIC8vIE9iamVjdC9mdW5jdGlvbiwgbm90IG51bGwvZGF0ZS9yZWdleHAuIFVzZSBXZWFrTWFwIHRvIHN0b3JlIHRoZSBpZCBmaXJzdC5cclxuICAgICAgICAvLyBJZiBpdCdzIGFscmVhZHkgaGFzaGVkLCBkaXJlY3RseSByZXR1cm4gdGhlIHJlc3VsdC5cclxuICAgICAgICByZXN1bHQgPSB0YWJsZS5nZXQoYXJnKTtcclxuICAgICAgICBpZiAocmVzdWx0KVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIC8vIFN0b3JlIHRoZSBoYXNoIGZpcnN0IGZvciBjaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0aW9uIGJlZm9yZSBlbnRlcmluZyB0aGVcclxuICAgICAgICAvLyByZWN1cnNpdmUgYHN0YWJsZUhhc2hgIGNhbGxzLlxyXG4gICAgICAgIC8vIEZvciBvdGhlciBvYmplY3RzIGxpa2Ugc2V0IGFuZCBtYXAsIHdlIHVzZSB0aGlzIGlkIGRpcmVjdGx5IGFzIHRoZSBoYXNoLlxyXG4gICAgICAgIHJlc3VsdCA9ICsrY291bnRlciArICd+JztcclxuICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xyXG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PSBBcnJheSkge1xyXG4gICAgICAgICAgICAvLyBBcnJheS5cclxuICAgICAgICAgICAgcmVzdWx0ID0gJ0AnO1xyXG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBhcmcubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RhYmxlSGFzaChhcmdbaW5kZXhdKSArICcsJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT0gT0JKRUNUKSB7XHJcbiAgICAgICAgICAgIC8vIE9iamVjdCwgc29ydCBrZXlzLlxyXG4gICAgICAgICAgICByZXN1bHQgPSAnIyc7XHJcbiAgICAgICAgICAgIHZhciBrZXlzID0gT0JKRUNULmtleXMoYXJnKS5zb3J0KCk7XHJcbiAgICAgICAgICAgIHdoaWxlICghaXNVbmRlZmluZWQoKGluZGV4ID0ga2V5cy5wb3AoKSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGFyZ1tpbmRleF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGluZGV4ICsgJzonICsgc3RhYmxlSGFzaChhcmdbaW5kZXhdKSArICcsJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCA9IGlzRGF0ZVxyXG4gICAgICAgICAgICA/IGFyZy50b0pTT04oKVxyXG4gICAgICAgICAgICA6IHR5cGUgPT0gJ3N5bWJvbCdcclxuICAgICAgICAgICAgICAgID8gYXJnLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgICAgIDogdHlwZSA9PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoYXJnKVxyXG4gICAgICAgICAgICAgICAgICAgIDogJycgKyBhcmc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIER1ZSB0byBidWcgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Njc4MDc1LFxyXG4gKiBpdCdzIG5vdCByZWxpYWJsZSB0byBkZXRlY3QgaWYgdGhlIGJyb3dzZXIgaXMgY3VycmVudGx5IG9ubGluZSBvciBvZmZsaW5lXHJcbiAqIGJhc2VkIG9uIGBuYXZpZ2F0b3Iub25MaW5lYC5cclxuICogQXMgYSB3b3JrIGFyb3VuZCwgd2UgYWx3YXlzIGFzc3VtZSBpdCdzIG9ubGluZSBvbiBmaXJzdCBsb2FkLCBhbmQgY2hhbmdlXHJcbiAqIHRoZSBzdGF0dXMgdXBvbiBgb25saW5lYCBvciBgb2ZmbGluZWAgZXZlbnRzLlxyXG4gKi9cclxudmFyIG9ubGluZSA9IHRydWU7XHJcbnZhciBpc09ubGluZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ubGluZTsgfTtcclxudmFyIGhhc1dpbiA9IGhhc1dpbmRvdygpO1xyXG52YXIgaGFzRG9jID0gaGFzRG9jdW1lbnQoKTtcclxuLy8gRm9yIG5vZGUgYW5kIFJlYWN0IE5hdGl2ZSwgYGFkZC9yZW1vdmVFdmVudExpc3RlbmVyYCBkb2Vzbid0IGV4aXN0IG9uIHdpbmRvdy5cclxudmFyIG9uV2luZG93RXZlbnQgPSBoYXNXaW4gJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcclxuICAgID8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIuYmluZCh3aW5kb3cpXHJcbiAgICA6IG5vb3A7XHJcbnZhciBvbkRvY3VtZW50RXZlbnQgPSBoYXNEb2MgPyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLmJpbmQoZG9jdW1lbnQpIDogbm9vcDtcclxudmFyIG9mZldpbmRvd0V2ZW50ID0gaGFzV2luICYmIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyXHJcbiAgICA/IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQod2luZG93KVxyXG4gICAgOiBub29wO1xyXG52YXIgb2ZmRG9jdW1lbnRFdmVudCA9IGhhc0RvY1xyXG4gICAgPyBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQoZG9jdW1lbnQpXHJcbiAgICA6IG5vb3A7XHJcbnZhciBpc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdmlzaWJpbGl0eVN0YXRlID0gaGFzRG9jICYmIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZTtcclxuICAgIHJldHVybiBpc1VuZGVmaW5lZCh2aXNpYmlsaXR5U3RhdGUpIHx8IHZpc2liaWxpdHlTdGF0ZSAhPT0gJ2hpZGRlbic7XHJcbn07XHJcbnZhciBpbml0Rm9jdXMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgIC8vIGZvY3VzIHJldmFsaWRhdGVcclxuICAgIG9uRG9jdW1lbnRFdmVudCgndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKTtcclxuICAgIG9uV2luZG93RXZlbnQoJ2ZvY3VzJywgY2FsbGJhY2spO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvZmZEb2N1bWVudEV2ZW50KCd2aXNpYmlsaXR5Y2hhbmdlJywgY2FsbGJhY2spO1xyXG4gICAgICAgIG9mZldpbmRvd0V2ZW50KCdmb2N1cycsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbn07XHJcbnZhciBpbml0UmVjb25uZWN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAvLyByZXZhbGlkYXRlIG9uIHJlY29ubmVjdGVkXHJcbiAgICB2YXIgb25PbmxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb25saW5lID0gdHJ1ZTtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgfTtcclxuICAgIC8vIG5vdGhpbmcgdG8gcmV2YWxpZGF0ZSwganVzdCB1cGRhdGUgdGhlIHN0YXR1c1xyXG4gICAgdmFyIG9uT2ZmbGluZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvbmxpbmUgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICBvbldpbmRvd0V2ZW50KCdvbmxpbmUnLCBvbk9ubGluZSk7XHJcbiAgICBvbldpbmRvd0V2ZW50KCdvZmZsaW5lJywgb25PZmZsaW5lKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb2ZmV2luZG93RXZlbnQoJ29ubGluZScsIG9uT25saW5lKTtcclxuICAgICAgICBvZmZXaW5kb3dFdmVudCgnb2ZmbGluZScsIG9uT2ZmbGluZSk7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgcHJlc2V0ID0ge1xyXG4gICAgaXNPbmxpbmU6IGlzT25saW5lLFxyXG4gICAgaXNWaXNpYmxlOiBpc1Zpc2libGVcclxufTtcclxudmFyIGRlZmF1bHRDb25maWdPcHRpb25zID0ge1xyXG4gICAgaW5pdEZvY3VzOiBpbml0Rm9jdXMsXHJcbiAgICBpbml0UmVjb25uZWN0OiBpbml0UmVjb25uZWN0XHJcbn07XHJcblxyXG52YXIgSVNfU0VSVkVSID0gIWhhc1dpbmRvdygpIHx8ICdEZW5vJyBpbiB3aW5kb3c7XHJcbi8vIFBvbHlmaWxsIHJlcXVlc3RBbmltYXRpb25GcmFtZVxyXG52YXIgckFGID0gZnVuY3Rpb24gKGYpIHtcclxuICAgIHJldHVybiBoYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSA/IHdpbmRvd1sncmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10oZikgOiBzZXRUaW1lb3V0KGYsIDEpO1xyXG59O1xyXG4vLyBSZWFjdCBjdXJyZW50bHkgdGhyb3dzIGEgd2FybmluZyB3aGVuIHVzaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgc2VydmVyLlxyXG4vLyBUbyBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxyXG4vLyB1c2VMYXlvdXRFZmZlY3QgaW4gdGhlIGJyb3dzZXIuXHJcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gSVNfU0VSVkVSID8gdXNlRWZmZWN0IDogdXNlTGF5b3V0RWZmZWN0O1xyXG4vLyBUaGlzIGFzc2lnbm1lbnQgaXMgdG8gZXh0ZW5kIHRoZSBOYXZpZ2F0b3IgdHlwZSB0byB1c2UgZWZmZWN0aXZlVHlwZS5cclxudmFyIG5hdmlnYXRvckNvbm5lY3Rpb24gPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgbmF2aWdhdG9yLmNvbm5lY3Rpb247XHJcbi8vIEFkanVzdCB0aGUgY29uZmlnIGJhc2VkIG9uIHNsb3cgY29ubmVjdGlvbiBzdGF0dXMgKDw9IDcwS2JwcykuXHJcbnZhciBzbG93Q29ubmVjdGlvbiA9ICFJU19TRVJWRVIgJiZcclxuICAgIG5hdmlnYXRvckNvbm5lY3Rpb24gJiZcclxuICAgIChbJ3Nsb3ctMmcnLCAnMmcnXS5pbmNsdWRlcyhuYXZpZ2F0b3JDb25uZWN0aW9uLmVmZmVjdGl2ZVR5cGUpIHx8XHJcbiAgICAgICAgbmF2aWdhdG9yQ29ubmVjdGlvbi5zYXZlRGF0YSk7XHJcblxyXG52YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oa2V5KSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGtleSA9IGtleSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIC8vIGRlcGVuZGVuY2llcyBub3QgcmVhZHlcclxuICAgICAgICAgICAga2V5ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGFyZ3MgPSBbXS5jb25jYXQoa2V5KTtcclxuICAgIC8vIElmIGtleSBpcyBub3QgZmFsc3ksIG9yIG5vdCBhbiBlbXB0eSBhcnJheSwgaGFzaCBpdC5cclxuICAgIGtleSA9XHJcbiAgICAgICAgdHlwZW9mIGtleSA9PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICA/IGtleVxyXG4gICAgICAgICAgICA6IChBcnJheS5pc0FycmF5KGtleSkgPyBrZXkubGVuZ3RoIDoga2V5KVxyXG4gICAgICAgICAgICAgICAgPyBzdGFibGVIYXNoKGtleSlcclxuICAgICAgICAgICAgICAgIDogJyc7XHJcbiAgICB2YXIgaW5mb0tleSA9IGtleSA/ICckc3dyJCcgKyBrZXkgOiAnJztcclxuICAgIHJldHVybiBba2V5LCBhcmdzLCBpbmZvS2V5XTtcclxufTtcclxuXHJcbi8vIEdsb2JhbCBzdGF0ZSB1c2VkIHRvIGRlZHVwbGljYXRlIHJlcXVlc3RzIGFuZCBzdG9yZSBsaXN0ZW5lcnNcclxudmFyIFNXUkdsb2JhbFN0YXRlID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbnZhciBGT0NVU19FVkVOVCA9IDA7XHJcbnZhciBSRUNPTk5FQ1RfRVZFTlQgPSAxO1xyXG52YXIgTVVUQVRFX0VWRU5UID0gMjtcclxuXHJcbnZhciBicm9hZGNhc3RTdGF0ZSA9IGZ1bmN0aW9uIChjYWNoZSwga2V5LCBkYXRhLCBlcnJvciwgaXNWYWxpZGF0aW5nLCByZXZhbGlkYXRlLCBicm9hZGNhc3QpIHtcclxuICAgIGlmIChicm9hZGNhc3QgPT09IHZvaWQgMCkgeyBicm9hZGNhc3QgPSB0cnVlOyB9XHJcbiAgICB2YXIgX2EgPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpLCBFVkVOVF9SRVZBTElEQVRPUlMgPSBfYVswXSwgU1RBVEVfVVBEQVRFUlMgPSBfYVsxXSwgRkVUQ0ggPSBfYVszXTtcclxuICAgIHZhciByZXZhbGlkYXRvcnMgPSBFVkVOVF9SRVZBTElEQVRPUlNba2V5XTtcclxuICAgIHZhciB1cGRhdGVycyA9IFNUQVRFX1VQREFURVJTW2tleV07XHJcbiAgICAvLyBDYWNoZSB3YXMgcG9wdWxhdGVkLCB1cGRhdGUgc3RhdGVzIG9mIGFsbCBob29rcy5cclxuICAgIGlmIChicm9hZGNhc3QgJiYgdXBkYXRlcnMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXJzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZXJzW2ldKGRhdGEsIGVycm9yLCBpc1ZhbGlkYXRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIElmIHdlIGFsc28gbmVlZCB0byByZXZhbGlkYXRlLCBvbmx5IGRvIGl0IGZvciB0aGUgZmlyc3QgaG9vay5cclxuICAgIGlmIChyZXZhbGlkYXRlKSB7XHJcbiAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUga2V5IGJ5IGRlbGV0aW5nIHRoZSBjb25jdXJyZW50IHJlcXVlc3QgbWFya2VycyBzbyBuZXdcclxuICAgICAgICAvLyByZXF1ZXN0cyB3aWxsIG5vdCBiZSBkZWR1cGVkLlxyXG4gICAgICAgIGRlbGV0ZSBGRVRDSFtrZXldO1xyXG4gICAgICAgIGlmIChyZXZhbGlkYXRvcnMgJiYgcmV2YWxpZGF0b3JzWzBdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXZhbGlkYXRvcnNbMF0oTVVUQVRFX0VWRU5UKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xyXG59O1xyXG5cclxuLy8gR2xvYmFsIHRpbWVzdGFtcC5cclxudmFyIF9fdGltZXN0YW1wID0gMDtcclxudmFyIGdldFRpbWVzdGFtcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICsrX190aW1lc3RhbXA7IH07XHJcblxyXG52YXIgaW50ZXJuYWxNdXRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2FjaGUsIF9rZXksIF9kYXRhLCBfb3B0cywgb3B0aW9ucywgcG9wdWxhdGVDYWNoZSwgcmV2YWxpZGF0ZSwgcm9sbGJhY2tPbkVycm9yLCBjdXN0b21PcHRpbWlzdGljRGF0YSwgX2EsIGtleSwga2V5SW5mbywgX2IsIE1VVEFUSU9OLCBkYXRhLCBlcnJvciwgYmVmb3JlTXV0YXRpb25UcywgaGFzQ3VzdG9tT3B0aW1pc3RpY0RhdGEsIHJvbGxiYWNrRGF0YSwgb3B0aW1pc3RpY0RhdGEsIHJlcztcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IGFyZ3NbMF0sIF9rZXkgPSBhcmdzWzFdLCBfZGF0YSA9IGFyZ3NbMl0sIF9vcHRzID0gYXJnc1szXTtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIF9vcHRzID09PSAnYm9vbGVhbicgPyB7IHJldmFsaWRhdGU6IF9vcHRzIH0gOiBfb3B0cyB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICBwb3B1bGF0ZUNhY2hlID0gaXNVbmRlZmluZWQob3B0aW9ucy5wb3B1bGF0ZUNhY2hlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcHRpb25zLnBvcHVsYXRlQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZSA9IG9wdGlvbnMucmV2YWxpZGF0ZSAhPT0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9sbGJhY2tPbkVycm9yID0gb3B0aW9ucy5yb2xsYmFja09uRXJyb3IgIT09IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbU9wdGltaXN0aWNEYXRhID0gb3B0aW9ucy5vcHRpbWlzdGljRGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBfYSA9IHNlcmlhbGl6ZShfa2V5KSwga2V5ID0gX2FbMF0sIGtleUluZm8gPSBfYVsyXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWtleSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgICAgIF9iID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKSwgTVVUQVRJT04gPSBfYlsyXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBuZXcgZGF0YSBwcm92aWRlZCwgcmV2YWxpZGF0ZSB0aGUga2V5IHdpdGggY3VycmVudCBzdGF0ZS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldmFsaWRhdGUgYW5kIGJyb2FkY2FzdCBzdGF0ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJyb2FkY2FzdFN0YXRlKGNhY2hlLCBrZXksIGNhY2hlLmdldChrZXkpLCBVTkRFRklORUQsIFVOREVGSU5FRCwgcmV2YWxpZGF0ZSwgdHJ1ZSldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2RhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlTXV0YXRpb25UcyA9IGdldFRpbWVzdGFtcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIE1VVEFUSU9OW2tleV0gPSBbYmVmb3JlTXV0YXRpb25UcywgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzQ3VzdG9tT3B0aW1pc3RpY0RhdGEgPSAhaXNVbmRlZmluZWQoY3VzdG9tT3B0aW1pc3RpY0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvbGxiYWNrRGF0YSA9IGNhY2hlLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG9wdGltaXN0aWMgZGF0YSB1cGRhdGUuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0N1c3RvbU9wdGltaXN0aWNEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWNEYXRhID0gaXNGdW5jdGlvbihjdXN0b21PcHRpbWlzdGljRGF0YSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY3VzdG9tT3B0aW1pc3RpY0RhdGEocm9sbGJhY2tEYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXN0b21PcHRpbWlzdGljRGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgb3B0aW1pc3RpY0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBvcHRpbWlzdGljRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBkYXRhYCBpcyBhIGZ1bmN0aW9uLCBjYWxsIGl0IHBhc3NpbmcgY3VycmVudCBjYWNoZSB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhKGNhY2hlLmdldChrZXkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCB0aHJvd3MgYW4gZXJyb3Igc3luY2hyb25vdXNseSwgd2Ugc2hvdWxkbid0IHVwZGF0ZSB0aGUgY2FjaGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShkYXRhICYmIGlzRnVuY3Rpb24oZGF0YS50aGVuKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGRhdGEuY2F0Y2goZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG90aGVyIG11dGF0aW9ucyBoYXZlIG9jY3VycmVkIHNpbmNlIHdlJ3ZlIHN0YXJ0ZWQgdGhpcyBtdXRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHJhY2Ugd2UgZG9uJ3QgdXBkYXRlIGNhY2hlIG9yIGJyb2FkY2FzdCB0aGUgY2hhbmdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHJldHVybiB0aGUgZGF0YS5cclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgbXV0YXRpb24gaXMgYXN5bmMsIHdlIG5lZWQgdG8gY2hlY2sgdGltZXN0YW1wcyB0b1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGF2b2lkIHJhY2UgY29uZGl0aW9ucy5cclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG90aGVyIG11dGF0aW9ucyBoYXZlIG9jY3VycmVkIHNpbmNlIHdlJ3ZlIHN0YXJ0ZWQgdGhpcyBtdXRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcmFjZSB3ZSBkb24ndCB1cGRhdGUgY2FjaGUgb3IgYnJvYWRjYXN0IHRoZSBjaGFuZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCByZXR1cm4gdGhlIGRhdGEuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZU11dGF0aW9uVHMgIT09IE1VVEFUSU9OW2tleV1bMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgaGFzQ3VzdG9tT3B0aW1pc3RpY0RhdGEgJiYgcm9sbGJhY2tPbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvbGxiYWNrLiBBbHdheXMgcG9wdWxhdGUgdGhlIGNhY2hlIGluIHRoaXMgY2FzZSBidXQgd2l0aG91dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm1pbmcgdGhlIGRhdGEuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlQ2FjaGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcm9sbGJhY2tEYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCByb2xsYmFja0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2Ugc2hvdWxkIHdyaXRlIGJhY2sgdGhlIGNhY2hlIGFmdGVyIHJlcXVlc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcHVsYXRlQ2FjaGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSByZXN1bHQgaW50byBkYXRhLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocG9wdWxhdGVDYWNoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcG9wdWxhdGVDYWNoZShkYXRhLCByb2xsYmFja0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgY2FjaGVkIGRhdGEgaWYgdGhlcmUncyBubyBlcnJvci4gRGF0YSBjYW4gYmUgYHVuZGVmaW5lZGAgaGVyZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldChrZXksIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyB1cGRhdGUgb3IgcmVzZXQgdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5SW5mbywgbWVyZ2VPYmplY3RzKGNhY2hlLmdldChrZXlJbmZvKSwgeyBlcnJvcjogZXJyb3IgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdGltZXN0YW1wIHRvIG1hcmsgdGhlIG11dGF0aW9uIGhhcyBlbmRlZC5cclxuICAgICAgICAgICAgICAgICAgICBNVVRBVElPTltrZXldWzFdID0gZ2V0VGltZXN0YW1wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgZGF0YSwgZXJyb3IsIFVOREVGSU5FRCwgcmV2YWxpZGF0ZSwgISFwb3B1bGF0ZUNhY2hlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBlcnJvciBvciByZXR1cm4gZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRocm93IGVycm9yIG9yIHJldHVybiBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcG9wdWxhdGVDYWNoZSA/IHJlcyA6IGRhdGFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbnZhciByZXZhbGlkYXRlQWxsS2V5cyA9IGZ1bmN0aW9uIChyZXZhbGlkYXRvcnMsIHR5cGUpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiByZXZhbGlkYXRvcnMpIHtcclxuICAgICAgICBpZiAocmV2YWxpZGF0b3JzW2tleV1bMF0pXHJcbiAgICAgICAgICAgIHJldmFsaWRhdG9yc1trZXldWzBdKHR5cGUpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgaW5pdENhY2hlID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBvcHRpb25zKSB7XHJcbiAgICAvLyBUaGUgZ2xvYmFsIHN0YXRlIGZvciBhIHNwZWNpZmljIHByb3ZpZGVyIHdpbGwgYmUgdXNlZCB0byBkZWR1cGxpY2F0ZVxyXG4gICAgLy8gcmVxdWVzdHMgYW5kIHN0b3JlIGxpc3RlbmVycy4gQXMgd2VsbCBhcyBhIG11dGF0ZSBmdW5jdGlvbiB0aGF0IGJvdW5kIHRvXHJcbiAgICAvLyB0aGUgY2FjaGUuXHJcbiAgICAvLyBQcm92aWRlcidzIGdsb2JhbCBzdGF0ZSBtaWdodCBiZSBhbHJlYWR5IGluaXRpYWxpemVkLiBMZXQncyB0cnkgdG8gZ2V0IHRoZVxyXG4gICAgLy8gZ2xvYmFsIHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZXIgZmlyc3QuXHJcbiAgICBpZiAoIVNXUkdsb2JhbFN0YXRlLmhhcyhwcm92aWRlcikpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0Q29uZmlnT3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBnbG9iYWwgc3RhdGUgYm91bmQgdG8gdGhlIHByb3ZpZGVyLCBjcmVhdGUgYSBuZXcgb25lIHdpdGggdGhlXHJcbiAgICAgICAgLy8gbmV3IG11dGF0ZSBmdW5jdGlvbi5cclxuICAgICAgICB2YXIgRVZFTlRfUkVWQUxJREFUT1JTID0ge307XHJcbiAgICAgICAgdmFyIG11dGF0ZSA9IGludGVybmFsTXV0YXRlLmJpbmQoVU5ERUZJTkVELCBwcm92aWRlcik7XHJcbiAgICAgICAgdmFyIHVubW91bnQgPSBub29wO1xyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RhdGUgaWYgaXQncyBuZXcsIG9yIHRoZSBwcm92aWRlciBoYXMgYmVlbiBleHRlbmRlZC5cclxuICAgICAgICBTV1JHbG9iYWxTdGF0ZS5zZXQocHJvdmlkZXIsIFtFVkVOVF9SRVZBTElEQVRPUlMsIHt9LCB7fSwge30sIG11dGF0ZV0pO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgcHJvdmlkZXIsIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSBpdCBhbmQgc2V0dXAgRE9NIGV2ZW50c1xyXG4gICAgICAgIC8vIGxpc3RlbmVycyBmb3IgYGZvY3VzYCBhbmQgYHJlY29ubmVjdGAgYWN0aW9ucy5cclxuICAgICAgICBpZiAoIUlTX1NFUlZFUikge1xyXG4gICAgICAgICAgICAvLyBXaGVuIGxpc3RlbmluZyB0byB0aGUgbmF0aXZlIGV2ZW50cyBmb3IgYXV0byByZXZhbGlkYXRpb25zLFxyXG4gICAgICAgICAgICAvLyB3ZSBpbnRlbnRpb25hbGx5IHB1dCBhIGRlbGF5IChzZXRUaW1lb3V0KSBoZXJlIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZVxyXG4gICAgICAgICAgICAvLyBmaXJlZCBhZnRlciBpbW1lZGlhdGUgSmF2YVNjcmlwdCBleGVjdXRpb25zLCB3aGljaCBjYW4gcG9zc2libHkgYmVcclxuICAgICAgICAgICAgLy8gUmVhY3QncyBzdGF0ZSB1cGRhdGVzLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGF2b2lkcyBzb21lIHVubmVjZXNzYXJ5IHJldmFsaWRhdGlvbnMgc3VjaCBhc1xyXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL3N3ci9pc3N1ZXMvMTY4MC5cclxuICAgICAgICAgICAgdmFyIHJlbGVhc2VGb2N1c18xID0gb3B0cy5pbml0Rm9jdXMoc2V0VGltZW91dC5iaW5kKFVOREVGSU5FRCwgcmV2YWxpZGF0ZUFsbEtleXMuYmluZChVTkRFRklORUQsIEVWRU5UX1JFVkFMSURBVE9SUywgRk9DVVNfRVZFTlQpKSk7XHJcbiAgICAgICAgICAgIHZhciByZWxlYXNlUmVjb25uZWN0XzEgPSBvcHRzLmluaXRSZWNvbm5lY3Qoc2V0VGltZW91dC5iaW5kKFVOREVGSU5FRCwgcmV2YWxpZGF0ZUFsbEtleXMuYmluZChVTkRFRklORUQsIEVWRU5UX1JFVkFMSURBVE9SUywgUkVDT05ORUNUX0VWRU5UKSkpO1xyXG4gICAgICAgICAgICB1bm1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmVsZWFzZUZvY3VzXzEgJiYgcmVsZWFzZUZvY3VzXzEoKTtcclxuICAgICAgICAgICAgICAgIHJlbGVhc2VSZWNvbm5lY3RfMSAmJiByZWxlYXNlUmVjb25uZWN0XzEoKTtcclxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdW4tbW91bnRpbmcsIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBjYWNoZSBwcm92aWRlciBmcm9tIHRoZSBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgLy8gc3RvcmFnZSB0b28gYmVjYXVzZSBpdCdzIGEgc2lkZS1lZmZlY3QuIE90aGVyd2lzZSB3aGVuIHJlLW1vdW50aW5nIHdlXHJcbiAgICAgICAgICAgICAgICAvLyB3aWxsIG5vdCByZS1yZWdpc3RlciB0aG9zZSBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgICAgICBTV1JHbG9iYWxTdGF0ZS5kZWxldGUocHJvdmlkZXIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBtaWdodCB3YW50IHRvIGluamVjdCBhbiBleHRyYSBsYXllciBvbiB0b3Agb2YgYHByb3ZpZGVyYCBpbiB0aGUgZnV0dXJlLFxyXG4gICAgICAgIC8vIHN1Y2ggYXMga2V5IHNlcmlhbGl6YXRpb24sIGF1dG8gR0MsIGV0Yy5cclxuICAgICAgICAvLyBGb3Igbm93LCBpdCdzIGp1c3QgYSBgTWFwYCBpbnRlcmZhY2Ugd2l0aG91dCBhbnkgbW9kaWZpY2F0aW9ucy5cclxuICAgICAgICByZXR1cm4gW3Byb3ZpZGVyLCBtdXRhdGUsIHVubW91bnRdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtwcm92aWRlciwgU1dSR2xvYmFsU3RhdGUuZ2V0KHByb3ZpZGVyKVs0XV07XHJcbn07XHJcblxyXG4vLyBlcnJvciByZXRyeVxyXG52YXIgb25FcnJvclJldHJ5ID0gZnVuY3Rpb24gKF8sIF9fLCBjb25maWcsIHJldmFsaWRhdGUsIG9wdHMpIHtcclxuICAgIHZhciBtYXhSZXRyeUNvdW50ID0gY29uZmlnLmVycm9yUmV0cnlDb3VudDtcclxuICAgIHZhciBjdXJyZW50UmV0cnlDb3VudCA9IG9wdHMucmV0cnlDb3VudDtcclxuICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcclxuICAgIHZhciB0aW1lb3V0ID0gfn4oKE1hdGgucmFuZG9tKCkgKyAwLjUpICpcclxuICAgICAgICAoMSA8PCAoY3VycmVudFJldHJ5Q291bnQgPCA4ID8gY3VycmVudFJldHJ5Q291bnQgOiA4KSkpICogY29uZmlnLmVycm9yUmV0cnlJbnRlcnZhbDtcclxuICAgIGlmICghaXNVbmRlZmluZWQobWF4UmV0cnlDb3VudCkgJiYgY3VycmVudFJldHJ5Q291bnQgPiBtYXhSZXRyeUNvdW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgc2V0VGltZW91dChyZXZhbGlkYXRlLCB0aW1lb3V0LCBvcHRzKTtcclxufTtcclxuLy8gRGVmYXVsdCBjYWNoZSBwcm92aWRlclxyXG52YXIgX2EgPSBpbml0Q2FjaGUobmV3IE1hcCgpKSwgY2FjaGUgPSBfYVswXSwgbXV0YXRlID0gX2FbMV07XHJcbi8vIERlZmF1bHQgY29uZmlnXHJcbnZhciBkZWZhdWx0Q29uZmlnID0gbWVyZ2VPYmplY3RzKHtcclxuICAgIC8vIGV2ZW50c1xyXG4gICAgb25Mb2FkaW5nU2xvdzogbm9vcCxcclxuICAgIG9uU3VjY2Vzczogbm9vcCxcclxuICAgIG9uRXJyb3I6IG5vb3AsXHJcbiAgICBvbkVycm9yUmV0cnk6IG9uRXJyb3JSZXRyeSxcclxuICAgIG9uRGlzY2FyZGVkOiBub29wLFxyXG4gICAgLy8gc3dpdGNoZXNcclxuICAgIHJldmFsaWRhdGVPbkZvY3VzOiB0cnVlLFxyXG4gICAgcmV2YWxpZGF0ZU9uUmVjb25uZWN0OiB0cnVlLFxyXG4gICAgcmV2YWxpZGF0ZUlmU3RhbGU6IHRydWUsXHJcbiAgICBzaG91bGRSZXRyeU9uRXJyb3I6IHRydWUsXHJcbiAgICAvLyB0aW1lb3V0c1xyXG4gICAgZXJyb3JSZXRyeUludGVydmFsOiBzbG93Q29ubmVjdGlvbiA/IDEwMDAwIDogNTAwMCxcclxuICAgIGZvY3VzVGhyb3R0bGVJbnRlcnZhbDogNSAqIDEwMDAsXHJcbiAgICBkZWR1cGluZ0ludGVydmFsOiAyICogMTAwMCxcclxuICAgIGxvYWRpbmdUaW1lb3V0OiBzbG93Q29ubmVjdGlvbiA/IDUwMDAgOiAzMDAwLFxyXG4gICAgLy8gcHJvdmlkZXJzXHJcbiAgICBjb21wYXJlOiBmdW5jdGlvbiAoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcclxuICAgICAgICByZXR1cm4gc3RhYmxlSGFzaChjdXJyZW50RGF0YSkgPT0gc3RhYmxlSGFzaChuZXdEYXRhKTtcclxuICAgIH0sXHJcbiAgICBpc1BhdXNlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0sXHJcbiAgICBjYWNoZTogY2FjaGUsXHJcbiAgICBtdXRhdGU6IG11dGF0ZSxcclxuICAgIGZhbGxiYWNrOiB7fVxyXG59LCBcclxuLy8gdXNlIHdlYiBwcmVzZXQgYnkgZGVmYXVsdFxyXG5wcmVzZXQpO1xyXG5cclxudmFyIG1lcmdlQ29uZmlncyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAvLyBOZWVkIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3QgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIGhlcmUuXHJcbiAgICB2YXIgdiA9IG1lcmdlT2JqZWN0cyhhLCBiKTtcclxuICAgIC8vIElmIHR3byBjb25maWdzIGFyZSBwcm92aWRlZCwgbWVyZ2UgdGhlaXIgYHVzZWAgYW5kIGBmYWxsYmFja2Agb3B0aW9ucy5cclxuICAgIGlmIChiKSB7XHJcbiAgICAgICAgdmFyIHUxID0gYS51c2UsIGYxID0gYS5mYWxsYmFjaztcclxuICAgICAgICB2YXIgdTIgPSBiLnVzZSwgZjIgPSBiLmZhbGxiYWNrO1xyXG4gICAgICAgIGlmICh1MSAmJiB1Mikge1xyXG4gICAgICAgICAgICB2LnVzZSA9IHUxLmNvbmNhdCh1Mik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmMSAmJiBmMikge1xyXG4gICAgICAgICAgICB2LmZhbGxiYWNrID0gbWVyZ2VPYmplY3RzKGYxLCBmMik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHY7XHJcbn07XHJcblxyXG52YXIgU1dSQ29uZmlnQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xyXG52YXIgU1dSQ29uZmlnJDEgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xyXG4gICAgLy8gRXh0ZW5kIHBhcmVudCBjb250ZXh0IHZhbHVlcyBhbmQgbWlkZGxld2FyZS5cclxuICAgIHZhciBleHRlbmRlZENvbmZpZyA9IG1lcmdlQ29uZmlncyh1c2VDb250ZXh0KFNXUkNvbmZpZ0NvbnRleHQpLCB2YWx1ZSk7XHJcbiAgICAvLyBTaG91bGQgbm90IHVzZSB0aGUgaW5oZXJpdGVkIHByb3ZpZGVyLlxyXG4gICAgdmFyIHByb3ZpZGVyID0gdmFsdWUgJiYgdmFsdWUucHJvdmlkZXI7XHJcbiAgICAvLyBVc2UgYSBsYXp5IGluaXRpYWxpemVkIHN0YXRlIHRvIGNyZWF0ZSB0aGUgY2FjaGUgb24gZmlyc3QgYWNjZXNzLlxyXG4gICAgdmFyIGNhY2hlQ29udGV4dCA9IHVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gcHJvdmlkZXJcclxuICAgICAgICAgICAgPyBpbml0Q2FjaGUocHJvdmlkZXIoZXh0ZW5kZWRDb25maWcuY2FjaGUgfHwgY2FjaGUpLCB2YWx1ZSlcclxuICAgICAgICAgICAgOiBVTkRFRklORUQ7XHJcbiAgICB9KVswXTtcclxuICAgIC8vIE92ZXJyaWRlIHRoZSBjYWNoZSBpZiBhIG5ldyBwcm92aWRlciBpcyBnaXZlbi5cclxuICAgIGlmIChjYWNoZUNvbnRleHQpIHtcclxuICAgICAgICBleHRlbmRlZENvbmZpZy5jYWNoZSA9IGNhY2hlQ29udGV4dFswXTtcclxuICAgICAgICBleHRlbmRlZENvbmZpZy5tdXRhdGUgPSBjYWNoZUNvbnRleHRbMV07XHJcbiAgICB9XHJcbiAgICAvLyBVbnN1YnNjcmliZSBldmVudHMuXHJcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIChjYWNoZUNvbnRleHQgPyBjYWNoZUNvbnRleHRbMl0gOiBVTkRFRklORUQpOyB9LCBbXSk7XHJcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChTV1JDb25maWdDb250ZXh0LlByb3ZpZGVyLCBtZXJnZU9iamVjdHMocHJvcHMsIHtcclxuICAgICAgICB2YWx1ZTogZXh0ZW5kZWRDb25maWdcclxuICAgIH0pKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBzdGF0ZSB3aXRoIGRlcGVuZGVuY3ktdHJhY2tpbmcuXHJcbiAqL1xyXG52YXIgdXNlU3RhdGVXaXRoRGVwcyA9IGZ1bmN0aW9uIChzdGF0ZSwgdW5tb3VudGVkUmVmKSB7XHJcbiAgICB2YXIgcmVyZW5kZXIgPSB1c2VTdGF0ZSh7fSlbMV07XHJcbiAgICB2YXIgc3RhdGVSZWYgPSB1c2VSZWYoc3RhdGUpO1xyXG4gICAgLy8gSWYgYSBzdGF0ZSBwcm9wZXJ0eSAoZGF0YSwgZXJyb3Igb3IgaXNWYWxpZGF0aW5nKSBpcyBhY2Nlc3NlZCBieSB0aGUgcmVuZGVyXHJcbiAgICAvLyBmdW5jdGlvbiwgd2UgbWFyayB0aGUgcHJvcGVydHkgYXMgYSBkZXBlbmRlbmN5IHNvIGlmIGl0IGlzIHVwZGF0ZWQgYWdhaW5cclxuICAgIC8vIGluIHRoZSBmdXR1cmUsIHdlIHRyaWdnZXIgYSByZXJlbmRlci5cclxuICAgIC8vIFRoaXMgaXMgYWxzbyBrbm93biBhcyBkZXBlbmRlbmN5LXRyYWNraW5nLlxyXG4gICAgdmFyIHN0YXRlRGVwZW5kZW5jaWVzUmVmID0gdXNlUmVmKHtcclxuICAgICAgICBkYXRhOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogZmFsc2UsXHJcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFRvIGNoYW5nZSBzdGF0ZVJlZiwgcGFzcyB0aGUgdmFsdWVzIGV4cGxpY2l0bHkgdG8gc2V0U3RhdGU6XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBganNcclxuICAgICAqIHNldFN0YXRlKHtcclxuICAgICAqICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxyXG4gICAgICogICBkYXRhOiBuZXdEYXRhIC8vIHNldCBkYXRhIHRvIG5ld0RhdGFcclxuICAgICAqICAgZXJyb3I6IHVuZGVmaW5lZCAvLyBzZXQgZXJyb3IgdG8gdW5kZWZpbmVkXHJcbiAgICAgKiB9KVxyXG4gICAgICpcclxuICAgICAqIHNldFN0YXRlKHtcclxuICAgICAqICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxyXG4gICAgICogICBkYXRhOiB1bmRlZmluZWQgLy8gc2V0IGRhdGEgdG8gdW5kZWZpbmVkXHJcbiAgICAgKiAgIGVycm9yOiBlcnIgLy8gc2V0IGVycm9yIHRvIGVyclxyXG4gICAgICogfSlcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICB2YXIgc2V0U3RhdGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAocGF5bG9hZCkge1xyXG4gICAgICAgIHZhciBzaG91bGRSZXJlbmRlciA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBzdGF0ZVJlZi5jdXJyZW50O1xyXG4gICAgICAgIGZvciAodmFyIF8gaW4gcGF5bG9hZCkge1xyXG4gICAgICAgICAgICB2YXIgayA9IF87XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBoYXMgY2hhbmdlZCwgdXBkYXRlIHRoZSBzdGF0ZSBhbmQgbWFyayByZXJlbmRlciBhc1xyXG4gICAgICAgICAgICAvLyBuZWVkZWQuXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGVba10gIT09IHBheWxvYWRba10pIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZVtrXSA9IHBheWxvYWRba107XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQgYnkgdGhlIGNvbXBvbmVudCwgYSByZXJlbmRlciBzaG91bGQgYmVcclxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXJlZC5cclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZURlcGVuZGVuY2llc1JlZi5jdXJyZW50W2tdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVyZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaG91bGRSZXJlbmRlciAmJiAhdW5tb3VudGVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgcmVyZW5kZXIoe30pO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFxyXG4gICAgLy8gY29uZmlnLnN1c3BlbnNlIGlzbid0IGFsbG93ZWQgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZWN5Y2xlXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICBbXSk7XHJcbiAgICAvLyBBbHdheXMgdXBkYXRlIHRoZSBzdGF0ZSByZWZlcmVuY2UuXHJcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzdGF0ZVJlZi5jdXJyZW50ID0gc3RhdGU7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBbc3RhdGVSZWYsIHN0YXRlRGVwZW5kZW5jaWVzUmVmLmN1cnJlbnQsIHNldFN0YXRlXTtcclxufTtcclxuXHJcbnZhciBub3JtYWxpemUgPSBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oYXJnc1sxXSlcclxuICAgICAgICA/IFthcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdIHx8IHt9XVxyXG4gICAgICAgIDogW2FyZ3NbMF0sIG51bGwsIChhcmdzWzFdID09PSBudWxsID8gYXJnc1syXSA6IGFyZ3NbMV0pIHx8IHt9XTtcclxufTtcclxuXHJcbnZhciB1c2VTV1JDb25maWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RzKGRlZmF1bHRDb25maWcsIHVzZUNvbnRleHQoU1dSQ29uZmlnQ29udGV4dCkpO1xyXG59O1xyXG5cclxuLy8gSXQncyB0cmlja3kgdG8gcGFzcyBnZW5lcmljIHR5cGVzIGFzIHBhcmFtZXRlcnMsIHNvIHdlIGp1c3QgZGlyZWN0bHkgb3ZlcnJpZGVcclxuLy8gdGhlIHR5cGVzIGhlcmUuXHJcbnZhciB3aXRoQXJncyA9IGZ1bmN0aW9uIChob29rKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gdXNlU1dSQXJncygpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2V0IHRoZSBkZWZhdWx0IGFuZCBpbmhlcml0ZWQgY29uZmlndXJhdGlvbi5cclxuICAgICAgICB2YXIgZmFsbGJhY2tDb25maWcgPSB1c2VTV1JDb25maWcoKTtcclxuICAgICAgICAvLyBOb3JtYWxpemUgYXJndW1lbnRzLlxyXG4gICAgICAgIHZhciBfYSA9IG5vcm1hbGl6ZShhcmdzKSwga2V5ID0gX2FbMF0sIGZuID0gX2FbMV0sIF9jb25maWcgPSBfYVsyXTtcclxuICAgICAgICAvLyBNZXJnZSBjb25maWd1cmF0aW9ucy5cclxuICAgICAgICB2YXIgY29uZmlnID0gbWVyZ2VDb25maWdzKGZhbGxiYWNrQ29uZmlnLCBfY29uZmlnKTtcclxuICAgICAgICAvLyBBcHBseSBtaWRkbGV3YXJlXHJcbiAgICAgICAgdmFyIG5leHQgPSBob29rO1xyXG4gICAgICAgIHZhciB1c2UgPSBjb25maWcudXNlO1xyXG4gICAgICAgIGlmICh1c2UpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHVzZS5sZW5ndGg7IGktLSA+IDA7KSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gdXNlW2ldKG5leHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXh0KGtleSwgZm4gfHwgY29uZmlnLmZldGNoZXIsIGNvbmZpZyk7XHJcbiAgICB9O1xyXG59O1xyXG5cclxuLy8gQWRkIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYSBsaXN0IG9mIGtleWVkIGNhbGxiYWNrIGZ1bmN0aW9ucyBhbmQgcmV0dXJuXHJcbi8vIHRoZSB1bnN1YnNjcmliZSBmdW5jdGlvbi5cclxudmFyIHN1YnNjcmliZUNhbGxiYWNrID0gZnVuY3Rpb24gKGtleSwgY2FsbGJhY2tzLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIGtleWVkUmV2YWxpZGF0b3JzID0gY2FsbGJhY2tzW2tleV0gfHwgKGNhbGxiYWNrc1trZXldID0gW10pO1xyXG4gICAga2V5ZWRSZXZhbGlkYXRvcnMucHVzaChjYWxsYmFjayk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IGtleWVkUmV2YWxpZGF0b3JzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIE8oMSk6IGZhc3RlciB0aGFuIHNwbGljZVxyXG4gICAgICAgICAgICBrZXllZFJldmFsaWRhdG9yc1tpbmRleF0gPSBrZXllZFJldmFsaWRhdG9yc1trZXllZFJldmFsaWRhdG9ycy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAga2V5ZWRSZXZhbGlkYXRvcnMucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcbnZhciBXSVRIX0RFRFVQRSA9IHsgZGVkdXBlOiB0cnVlIH07XHJcbnZhciB1c2VTV1JIYW5kbGVyID0gZnVuY3Rpb24gKF9rZXksIGZldGNoZXIsIGNvbmZpZykge1xyXG4gICAgdmFyIGNhY2hlID0gY29uZmlnLmNhY2hlLCBjb21wYXJlID0gY29uZmlnLmNvbXBhcmUsIGZhbGxiYWNrRGF0YSA9IGNvbmZpZy5mYWxsYmFja0RhdGEsIHN1c3BlbnNlID0gY29uZmlnLnN1c3BlbnNlLCByZXZhbGlkYXRlT25Nb3VudCA9IGNvbmZpZy5yZXZhbGlkYXRlT25Nb3VudCwgcmVmcmVzaEludGVydmFsID0gY29uZmlnLnJlZnJlc2hJbnRlcnZhbCwgcmVmcmVzaFdoZW5IaWRkZW4gPSBjb25maWcucmVmcmVzaFdoZW5IaWRkZW4sIHJlZnJlc2hXaGVuT2ZmbGluZSA9IGNvbmZpZy5yZWZyZXNoV2hlbk9mZmxpbmU7XHJcbiAgICB2YXIgX2EgPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpLCBFVkVOVF9SRVZBTElEQVRPUlMgPSBfYVswXSwgU1RBVEVfVVBEQVRFUlMgPSBfYVsxXSwgTVVUQVRJT04gPSBfYVsyXSwgRkVUQ0ggPSBfYVszXTtcclxuICAgIC8vIGBrZXlgIGlzIHRoZSBpZGVudGlmaWVyIG9mIHRoZSBTV1IgYGRhdGFgIHN0YXRlLCBga2V5SW5mb2AgaG9sZHMgZXh0cmFcclxuICAgIC8vIHN0YXRlcyBzdWNoIGFzIGBlcnJvcmAgYW5kIGBpc1ZhbGlkYXRpbmdgIGluc2lkZSxcclxuICAgIC8vIGFsbCBvZiB0aGVtIGFyZSBkZXJpdmVkIGZyb20gYF9rZXlgLlxyXG4gICAgLy8gYGZuQXJnc2AgaXMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIHBhcnNlZCBmcm9tIHRoZSBrZXksIHdoaWNoIHdpbGwgYmUgcGFzc2VkXHJcbiAgICAvLyB0byB0aGUgZmV0Y2hlci5cclxuICAgIHZhciBfYiA9IHNlcmlhbGl6ZShfa2V5KSwga2V5ID0gX2JbMF0sIGZuQXJncyA9IF9iWzFdLCBrZXlJbmZvID0gX2JbMl07XHJcbiAgICAvLyBJZiBpdCdzIHRoZSBpbml0aWFsIHJlbmRlciBvZiB0aGlzIGhvb2suXHJcbiAgICB2YXIgaW5pdGlhbE1vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xyXG4gICAgLy8gSWYgdGhlIGhvb2sgaXMgdW5tb3VudGVkIGFscmVhZHkuIFRoaXMgd2lsbCBiZSB1c2VkIHRvIHByZXZlbnQgc29tZSBlZmZlY3RzXHJcbiAgICAvLyB0byBiZSBjYWxsZWQgYWZ0ZXIgdW5tb3VudGluZy5cclxuICAgIHZhciB1bm1vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xyXG4gICAgLy8gUmVmcyB0byBrZWVwIHRoZSBrZXkgYW5kIGNvbmZpZy5cclxuICAgIHZhciBrZXlSZWYgPSB1c2VSZWYoa2V5KTtcclxuICAgIHZhciBmZXRjaGVyUmVmID0gdXNlUmVmKGZldGNoZXIpO1xyXG4gICAgdmFyIGNvbmZpZ1JlZiA9IHVzZVJlZihjb25maWcpO1xyXG4gICAgdmFyIGdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZ1JlZi5jdXJyZW50OyB9O1xyXG4gICAgdmFyIGlzQWN0aXZlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0Q29uZmlnKCkuaXNWaXNpYmxlKCkgJiYgZ2V0Q29uZmlnKCkuaXNPbmxpbmUoKTsgfTtcclxuICAgIHZhciBwYXRjaEZldGNoSW5mbyA9IGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlLnNldChrZXlJbmZvLCBtZXJnZU9iamVjdHMoY2FjaGUuZ2V0KGtleUluZm8pLCBpbmZvKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0YXRlIHRoYXQgU1dSIHNob3VsZCByZXR1cm4uXHJcbiAgICB2YXIgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XHJcbiAgICB2YXIgZmFsbGJhY2sgPSBpc1VuZGVmaW5lZChmYWxsYmFja0RhdGEpXHJcbiAgICAgICAgPyBjb25maWcuZmFsbGJhY2tba2V5XVxyXG4gICAgICAgIDogZmFsbGJhY2tEYXRhO1xyXG4gICAgdmFyIGRhdGEgPSBpc1VuZGVmaW5lZChjYWNoZWQpID8gZmFsbGJhY2sgOiBjYWNoZWQ7XHJcbiAgICB2YXIgaW5mbyA9IGNhY2hlLmdldChrZXlJbmZvKSB8fCB7fTtcclxuICAgIHZhciBlcnJvciA9IGluZm8uZXJyb3I7XHJcbiAgICB2YXIgaXNJbml0aWFsTW91bnQgPSAhaW5pdGlhbE1vdW50ZWRSZWYuY3VycmVudDtcclxuICAgIC8vIC0gU3VzcGVuc2UgbW9kZSBhbmQgdGhlcmUncyBzdGFsZSBkYXRhIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXHJcbiAgICAvLyAtIE5vdCBzdXNwZW5zZSBtb2RlIGFuZCB0aGVyZSBpcyBubyBmYWxsYmFjayBkYXRhIGFuZCBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIGVuYWJsZWQuXHJcbiAgICAvLyAtIGByZXZhbGlkYXRlSWZTdGFsZWAgaXMgZW5hYmxlZCBidXQgYGRhdGFgIGlzIG5vdCBkZWZpbmVkLlxyXG4gICAgdmFyIHNob3VsZFJldmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gSWYgYHJldmFsaWRhdGVPbk1vdW50YCBpcyBzZXQsIHdlIHRha2UgdGhlIHZhbHVlIGRpcmVjdGx5LlxyXG4gICAgICAgIGlmIChpc0luaXRpYWxNb3VudCAmJiAhaXNVbmRlZmluZWQocmV2YWxpZGF0ZU9uTW91bnQpKVxyXG4gICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0ZU9uTW91bnQ7XHJcbiAgICAgICAgLy8gSWYgaXQncyBwYXVzZWQsIHdlIHNraXAgcmV2YWxpZGF0aW9uLlxyXG4gICAgICAgIGlmIChnZXRDb25maWcoKS5pc1BhdXNlZCgpKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgLy8gVW5kZXIgc3VzcGVuc2UgbW9kZSwgaXQgd2lsbCBhbHdheXMgZmV0Y2ggb24gcmVuZGVyIGlmIHRoZXJlIGlzIG5vXHJcbiAgICAgICAgLy8gc3RhbGUgZGF0YSBzbyBubyBuZWVkIHRvIHJldmFsaWRhdGUgaW1tZWRpYXRlbHkgb24gbW91bnQgYWdhaW4uXHJcbiAgICAgICAgLy8gSWYgZGF0YSBleGlzdHMsIG9ubHkgcmV2YWxpZGF0ZSBpZiBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIHRydWUuXHJcbiAgICAgICAgaWYgKHN1c3BlbnNlKVxyXG4gICAgICAgICAgICByZXR1cm4gaXNVbmRlZmluZWQoZGF0YSkgPyBmYWxzZSA6IGNvbmZpZy5yZXZhbGlkYXRlSWZTdGFsZTtcclxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBzdGFsZSBkYXRhLCB3ZSBuZWVkIHRvIHJldmFsaWRhdGUgb24gbW91bnQ7XHJcbiAgICAgICAgLy8gSWYgYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBzZXQgdG8gdHJ1ZSwgd2Ugd2lsbCBhbHdheXMgcmV2YWxpZGF0ZS5cclxuICAgICAgICByZXR1cm4gaXNVbmRlZmluZWQoZGF0YSkgfHwgY29uZmlnLnJldmFsaWRhdGVJZlN0YWxlO1xyXG4gICAgfTtcclxuICAgIC8vIFJlc29sdmUgdGhlIGN1cnJlbnQgdmFsaWRhdGluZyBzdGF0ZS5cclxuICAgIHZhciByZXNvbHZlVmFsaWRhdGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIWtleSB8fCAhZmV0Y2hlcilcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChpbmZvLmlzVmFsaWRhdGluZylcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgLy8gSWYgaXQncyBub3QgbW91bnRlZCB5ZXQgYW5kIGl0IHNob3VsZCByZXZhbGlkYXRlIG9uIG1vdW50LCByZXZhbGlkYXRlLlxyXG4gICAgICAgIHJldHVybiBpc0luaXRpYWxNb3VudCAmJiBzaG91bGRSZXZhbGlkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGlzVmFsaWRhdGluZyA9IHJlc29sdmVWYWxpZGF0aW5nKCk7XHJcbiAgICB2YXIgX2MgPSB1c2VTdGF0ZVdpdGhEZXBzKHtcclxuICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgIGVycm9yOiBlcnJvcixcclxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGlzVmFsaWRhdGluZ1xyXG4gICAgfSwgdW5tb3VudGVkUmVmKSwgc3RhdGVSZWYgPSBfY1swXSwgc3RhdGVEZXBlbmRlbmNpZXMgPSBfY1sxXSwgc2V0U3RhdGUgPSBfY1syXTtcclxuICAgIC8vIFRoZSByZXZhbGlkYXRpb24gZnVuY3Rpb24gaXMgYSBjYXJlZnVsbHkgY3JhZnRlZCB3cmFwcGVyIG9mIHRoZSBvcmlnaW5hbFxyXG4gICAgLy8gYGZldGNoZXJgLCB0byBjb3JyZWN0bHkgaGFuZGxlIHRoZSBtYW55IGVkZ2UgY2FzZXMuXHJcbiAgICB2YXIgcmV2YWxpZGF0ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChyZXZhbGlkYXRlT3B0cykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY3VycmVudEZldGNoZXIsIG5ld0RhdGEsIHN0YXJ0QXQsIGxvYWRpbmcsIG9wdHMsIHNob3VsZFN0YXJ0TmV3UmVxdWVzdCwgaXNDdXJyZW50S2V5TW91bnRlZCwgY2xlYW51cFN0YXRlLCBuZXdTdGF0ZSwgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlLCBtdXRhdGlvbkluZm8sIGVycl8xO1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RmV0Y2hlciA9IGZldGNoZXJSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWtleSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhY3VycmVudEZldGNoZXIgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkuaXNQYXVzZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBvcHRzID0gcmV2YWxpZGF0ZU9wdHMgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RhcnROZXdSZXF1ZXN0ID0gIUZFVENIW2tleV0gfHwgIW9wdHMuZGVkdXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQ3VycmVudEtleU1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhdW5tb3VudGVkUmVmLmN1cnJlbnQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9PT0ga2V5UmVmLmN1cnJlbnQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwU3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3Mgc3RpbGwgdGhlIHNhbWUgcmVxdWVzdCBiZWZvcmUgZGVsZXRpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0SW5mbyA9IEZFVENIW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0SW5mbyAmJiByZXF1ZXN0SW5mb1sxXSA9PT0gc3RhcnRBdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIEZFVENIW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0geyBpc1ZhbGlkYXRpbmc6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaEZldGNoSW5mbyh7IGlzVmFsaWRhdGluZzogZmFsc2UgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBvbmx5IHNldCBzdGF0ZSBpZiBpdCdzIHNhZmUgKHN0aWxsIG1vdW50ZWQgd2l0aCB0aGUgc2FtZSBrZXkpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTdGF0ZShuZXdTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGZldGNoaW5nLiBDaGFuZ2UgdGhlIGBpc1ZhbGlkYXRpbmdgIHN0YXRlLCB1cGRhdGUgdGhlIGNhY2hlLlxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmV0Y2hJbmZvKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdGUoeyBpc1ZhbGlkYXRpbmc6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUZWxsIGFsbCBvdGhlciBob29rcyB0byBjaGFuZ2UgdGhlIGBpc1ZhbGlkYXRpbmdgIHN0YXRlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBzdGF0ZVJlZi5jdXJyZW50LmRhdGEsIHN0YXRlUmVmLmN1cnJlbnQuZXJyb3IsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBjYWNoZSBiZWluZyByZW5kZXJlZCBjdXJyZW50bHkgKGl0IHNob3dzIGEgYmxhbmsgcGFnZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHRyaWdnZXIgdGhlIGxvYWRpbmcgc2xvdyBldmVudC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2FkaW5nVGltZW91dCAmJiAhY2FjaGUuZ2V0KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2FkaW5nICYmIGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vbkxvYWRpbmdTbG93KGtleSwgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjb25maWcubG9hZGluZ1RpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSByZXF1ZXN0IGFuZCBzYXZlIHRoZSB0aW1lc3RhbXAuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZFVENIW2tleV0gPSBbY3VycmVudEZldGNoZXIuYXBwbHkodm9pZCAwLCBmbkFyZ3MpLCBnZXRUaW1lc3RhbXAoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF9hID0gRkVUQ0hba2V5XSwgbmV3RGF0YSA9IF9hWzBdLCBzdGFydEF0ID0gX2FbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbmV3RGF0YV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IGlzbid0IGludGVycnVwdGVkLCBjbGVhbiBpdCB1cCBhZnRlciB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVkdXBsaWNhdGlvbiBpbnRlcnZhbC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjbGVhbnVwU3RhdGUsIGNvbmZpZy5kZWR1cGluZ0ludGVydmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncmUgb3RoZXIgb25nb2luZyByZXF1ZXN0KHMpLCBzdGFydGVkIGFmdGVyIHRoZSBjdXJyZW50IG9uZSxcclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGlnbm9yZSB0aGUgY3VycmVudCBvbmUgdG8gYXZvaWQgcG9zc2libGUgcmFjZSBjb25kaXRpb25zOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgcmVxMS0tLS0tLS0tLS0tLS0tLS0tLT5yZXMxICAgICAgICAoY3VycmVudCBvbmUpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgIHJlcTItLS0tLS0tLS0tLS0tLS0tPnJlczJcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCB0aGF0IGZpcmVkIGxhdGVyIHdpbGwgYWx3YXlzIGJlIGtlcHQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRpbWVzdGFtcCBtYXliZSBiZSBgdW5kZWZpbmVkYCBvciBhIG51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghRkVUQ0hba2V5XSB8fCBGRVRDSFtrZXldWzFdICE9PSBzdGFydEF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRLZXlNb3VudGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vbkRpc2NhcmRlZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmYWxzZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmV0Y2hJbmZvKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFVOREVGSU5FRFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmVycm9yID0gVU5ERUZJTkVEO1xyXG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSW5mbyA9IE1VVEFUSU9OW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChtdXRhdGlvbkluZm8pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhcnRBdCA8PSBtdXRhdGlvbkluZm9bMF0gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRBdCA8PSBtdXRhdGlvbkluZm9bMV0gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgM1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25JbmZvWzFdID09PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRGlzY2FyZGVkKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVlcCBjb21wYXJlIHdpdGggbGF0ZXN0IHN0YXRlIHRvIGF2b2lkIGV4dHJhIHJlLXJlbmRlcnMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGxvY2FsIHN0YXRlLCBjb21wYXJlIGFuZCBhc3NpZ24uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKHN0YXRlUmVmLmN1cnJlbnQuZGF0YSwgbmV3RGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUuZGF0YSA9IG5ld0RhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkYXRhIGFuZCBuZXdEYXRhIGFyZSBkZWVwbHkgZXF1YWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIGJlIHNhZmUgdG8gYnJvYWRjYXN0IHRoZSBzdGFsZSBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmRhdGEgPSBzdGF0ZVJlZi5jdXJyZW50LmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0IHRoZSBlbmQgb2YgdGhpcyBmdW5jdGlvbiwgYGJyb2Nhc3RTdGF0ZWAgaW52b2tlcyB0aGUgYG9uU3RhdGVVcGRhdGVgIGZ1bmN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB0YWtlcyBjYXJlIG9mIGF2b2lkaW5nIHRoZSByZS1yZW5kZXJcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGdsb2JhbCBzdGF0ZSwgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBrZXkgaGFzIGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9zd3IvcHVsbC8xMDU4XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKGNhY2hlLmdldChrZXkpLCBuZXdEYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCBuZXdEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciB0aGUgc3VjY2Vzc2Z1bCBjYWxsYmFjayBpZiBpdCdzIHRoZSBvcmlnaW5hbCByZXF1ZXN0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25TdWNjZXNzKG5ld0RhdGEsIGtleSwgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBlcnJfMSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwU3RhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgcGF1c2VkLCB3ZSBjb250aW51ZSBoYW5kbGluZyB0aGUgZXJyb3IuIE90aGVyd2lzZSBkaXNjYXJkIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2V0Q29uZmlnKCkuaXNQYXVzZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBuZXcgZXJyb3IsIGRvbid0IHVzZSBkZWVwIGNvbXBhcmlzb24gZm9yIGVycm9ycy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hGZXRjaEluZm8oeyBlcnJvcjogZXJyXzEgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmVycm9yID0gZXJyXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9yIGV2ZW50IGFuZCByZXRyeSBsb2dpYy4gT25seSBmb3IgdGhlIGFjdHVhbCByZXF1ZXN0LCBub3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVkdXBlZCBvbmVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0ICYmIGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25FcnJvcihlcnJfMSwga2V5LCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgY29uZmlnLnNob3VsZFJldHJ5T25FcnJvciA9PT0gJ2Jvb2xlYW4nICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnNob3VsZFJldHJ5T25FcnJvcikgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNGdW5jdGlvbihjb25maWcuc2hvdWxkUmV0cnlPbkVycm9yKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc2hvdWxkUmV0cnlPbkVycm9yKGVycl8xKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHJldHJ5aW5nLCBkZWR1cGUgaXMgYWx3YXlzIGVuYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGFjdGl2ZSwgc3RvcC4gSXQgd2lsbCBhdXRvIHJldmFsaWRhdGUgd2hlbiByZWZvY3VzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIHJlY29ubmVjdGluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25FcnJvclJldHJ5KGVycl8xLCBrZXksIGNvbmZpZywgcmV2YWxpZGF0ZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudDogKG9wdHMucmV0cnlDb3VudCB8fCAwKSArIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWR1cGU6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hcmsgbG9hZGluZyBhcyBzdG9wcGVkLlxyXG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgaG9vaydzIHN0YXRlLlxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhlcmUgaXMgdGhlIHNvdXJjZSBvZiB0aGUgcmVxdWVzdCwgbmVlZCB0byB0ZWxsIGFsbCBvdGhlciBob29rcyB0b1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGVpciBzdGF0ZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEtleU1vdW50ZWQoKSAmJiBzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgbmV3U3RhdGUuZGF0YSwgbmV3U3RhdGUuZXJyb3IsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRydWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTsgfSwgXHJcbiAgICAvLyBgc2V0U3RhdGVgIGlzIGltbXV0YWJsZSwgYW5kIGBldmVudHNDYWxsYmFja2AsIGBmbkFyZ3NgLCBga2V5SW5mb2AsXHJcbiAgICAvLyBhbmQgYGtleVZhbGlkYXRpbmdgIGFyZSBkZXBlbmRpbmcgb24gYGtleWAsIHNvIHdlIGNhbiBleGNsdWRlIHRoZW0gZnJvbVxyXG4gICAgLy8gdGhlIGRlcHMgYXJyYXkuXHJcbiAgICAvL1xyXG4gICAgLy8gRklYTUU6XHJcbiAgICAvLyBgZm5gIGFuZCBgY29uZmlnYCBtaWdodCBiZSBjaGFuZ2VkIGR1cmluZyB0aGUgbGlmZWN5Y2xlLFxyXG4gICAgLy8gYnV0IHRoZXkgbWlnaHQgYmUgY2hhbmdlZCBldmVyeSByZW5kZXIgbGlrZSB0aGlzLlxyXG4gICAgLy8gYHVzZVNXUigna2V5JywgKCkgPT4gZmV0Y2goJy9hcGkvJyksIHsgc3VzcGVuc2U6IHRydWUgfSlgXHJcbiAgICAvLyBTbyB3ZSBvbWl0IHRoZSB2YWx1ZXMgZnJvbSB0aGUgZGVwcyBhcnJheVxyXG4gICAgLy8gZXZlbiB0aG91Z2ggaXQgbWlnaHQgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvcnMuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICBba2V5XSk7XHJcbiAgICAvLyBTaW1pbGFyIHRvIHRoZSBnbG9iYWwgbXV0YXRlLCBidXQgYm91bmQgdG8gdGhlIGN1cnJlbnQgY2FjaGUgYW5kIGtleS5cclxuICAgIC8vIGBjYWNoZWAgaXNuJ3QgYWxsb3dlZCB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZlY3ljbGUuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICB2YXIgYm91bmRNdXRhdGUgPSB1c2VDYWxsYmFjayhcclxuICAgIC8vIEJ5IHVzaW5nIGBiaW5kYCB3ZSBkb24ndCBuZWVkIHRvIG1vZGlmeSB0aGUgc2l6ZSBvZiB0aGUgcmVzdCBhcmd1bWVudHMuXHJcbiAgICAvLyBEdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zNzE4MSwgd2UgaGF2ZSB0b1xyXG4gICAgLy8gY2FzdCBpdCB0byBhbnkgZm9yIG5vdy5cclxuICAgIGludGVybmFsTXV0YXRlLmJpbmQoVU5ERUZJTkVELCBjYWNoZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4ga2V5UmVmLmN1cnJlbnQ7IH0pLCBcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcclxuICAgIFtdKTtcclxuICAgIC8vIEFsd2F5cyB1cGRhdGUgZmV0Y2hlciBhbmQgY29uZmlnIHJlZnMuXHJcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmZXRjaGVyUmVmLmN1cnJlbnQgPSBmZXRjaGVyO1xyXG4gICAgICAgIGNvbmZpZ1JlZi5jdXJyZW50ID0gY29uZmlnO1xyXG4gICAgfSk7XHJcbiAgICAvLyBBZnRlciBtb3VudGVkIG9yIGtleSBjaGFuZ2VkLlxyXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFrZXkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIga2V5Q2hhbmdlZCA9IGtleSAhPT0ga2V5UmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgdmFyIHNvZnRSZXZhbGlkYXRlID0gcmV2YWxpZGF0ZS5iaW5kKFVOREVGSU5FRCwgV0lUSF9ERURVUEUpO1xyXG4gICAgICAgIC8vIEV4cG9zZSBzdGF0ZSB1cGRhdGVyIHRvIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMuIFNvIHdlIGNhbiB1cGRhdGUgaG9vaydzXHJcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGUgZnJvbSB0aGUgb3V0c2lkZS5cclxuICAgICAgICB2YXIgb25TdGF0ZVVwZGF0ZSA9IGZ1bmN0aW9uICh1cGRhdGVkRGF0YSwgdXBkYXRlZEVycm9yLCB1cGRhdGVkSXNWYWxpZGF0aW5nKSB7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKG1lcmdlT2JqZWN0cyh7XHJcbiAgICAgICAgICAgICAgICBlcnJvcjogdXBkYXRlZEVycm9yLFxyXG4gICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiB1cGRhdGVkSXNWYWxpZGF0aW5nXHJcbiAgICAgICAgICAgIH0sIFxyXG4gICAgICAgICAgICAvLyBTaW5jZSBgc2V0U3RhdGVgIG9ubHkgc2hhbGxvd2x5IGNvbXBhcmVzIHN0YXRlcywgd2UgZG8gYSBkZWVwXHJcbiAgICAgICAgICAgIC8vIGNvbXBhcmlzb24gaGVyZS5cclxuICAgICAgICAgICAgY29tcGFyZShzdGF0ZVJlZi5jdXJyZW50LmRhdGEsIHVwZGF0ZWREYXRhKVxyXG4gICAgICAgICAgICAgICAgPyBVTkRFRklORURcclxuICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHVwZGF0ZWREYXRhXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBFeHBvc2UgcmV2YWxpZGF0b3JzIHRvIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMuIFNvIHdlIGNhbiB0cmlnZ2VyXHJcbiAgICAgICAgLy8gcmV2YWxpZGF0aW9uIGZyb20gdGhlIG91dHNpZGUuXHJcbiAgICAgICAgdmFyIG5leHRGb2N1c1JldmFsaWRhdGVkQXQgPSAwO1xyXG4gICAgICAgIHZhciBvblJldmFsaWRhdGUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PSBGT0NVU19FVkVOVCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Q29uZmlnKCkucmV2YWxpZGF0ZU9uRm9jdXMgJiZcclxuICAgICAgICAgICAgICAgICAgICBub3cgPiBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRGb2N1c1JldmFsaWRhdGVkQXQgPSBub3cgKyBnZXRDb25maWcoKS5mb2N1c1Rocm90dGxlSW50ZXJ2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFJFQ09OTkVDVF9FVkVOVCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdldENvbmZpZygpLnJldmFsaWRhdGVPblJlY29ubmVjdCAmJiBpc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IE1VVEFURV9FVkVOVCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdW5zdWJVcGRhdGUgPSBzdWJzY3JpYmVDYWxsYmFjayhrZXksIFNUQVRFX1VQREFURVJTLCBvblN0YXRlVXBkYXRlKTtcclxuICAgICAgICB2YXIgdW5zdWJFdmVudHMgPSBzdWJzY3JpYmVDYWxsYmFjayhrZXksIEVWRU5UX1JFVkFMSURBVE9SUywgb25SZXZhbGlkYXRlKTtcclxuICAgICAgICAvLyBNYXJrIHRoZSBjb21wb25lbnQgYXMgbW91bnRlZCBhbmQgdXBkYXRlIGNvcnJlc3BvbmRpbmcgcmVmcy5cclxuICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICAgIGtleVJlZi5jdXJyZW50ID0ga2V5O1xyXG4gICAgICAgIGluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgIC8vIFdoZW4gYGtleWAgdXBkYXRlcywgcmVzZXQgdGhlIHN0YXRlIHRvIHRoZSBpbml0aWFsIHZhbHVlXHJcbiAgICAgICAgLy8gYW5kIHRyaWdnZXIgYSByZXJlbmRlciBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgaWYgKGtleUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcclxuICAgICAgICAgICAgICAgIGlzVmFsaWRhdGluZzogaXNWYWxpZGF0aW5nXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcmlnZ2VyIGEgcmV2YWxpZGF0aW9uLlxyXG4gICAgICAgIGlmIChzaG91bGRSZXZhbGlkYXRlKCkpIHtcclxuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGRhdGEpIHx8IElTX1NFUlZFUikge1xyXG4gICAgICAgICAgICAgICAgLy8gUmV2YWxpZGF0ZSBpbW1lZGlhdGVseS5cclxuICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEZWxheSB0aGUgcmV2YWxpZGF0ZSBpZiB3ZSBoYXZlIGRhdGEgdG8gcmV0dXJuIHNvIHdlIHdvbid0IGJsb2NrXHJcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJpbmcuXHJcbiAgICAgICAgICAgICAgICByQUYoc29mdFJldmFsaWRhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIE1hcmsgaXQgYXMgdW5tb3VudGVkLlxyXG4gICAgICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIHVuc3ViVXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHVuc3ViRXZlbnRzKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtrZXksIHJldmFsaWRhdGVdKTtcclxuICAgIC8vIFBvbGxpbmdcclxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aW1lcjtcclxuICAgICAgICBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgICAgICAgICAvLyBVc2UgdGhlIHBhc3NlZCBpbnRlcnZhbFxyXG4gICAgICAgICAgICAvLyAuLi5vciBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHVwZGF0ZWQgZGF0YSB0byBnZXQgdGhlIGludGVydmFsXHJcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IGlzRnVuY3Rpb24ocmVmcmVzaEludGVydmFsKVxyXG4gICAgICAgICAgICAgICAgPyByZWZyZXNoSW50ZXJ2YWwoZGF0YSlcclxuICAgICAgICAgICAgICAgIDogcmVmcmVzaEludGVydmFsO1xyXG4gICAgICAgICAgICAvLyBXZSBvbmx5IHN0YXJ0IG5leHQgaW50ZXJ2YWwgaWYgYHJlZnJlc2hJbnRlcnZhbGAgaXMgbm90IDAsIGFuZDpcclxuICAgICAgICAgICAgLy8gLSBgZm9yY2VgIGlzIHRydWUsIHdoaWNoIGlzIHRoZSBzdGFydCBvZiBwb2xsaW5nXHJcbiAgICAgICAgICAgIC8vIC0gb3IgYHRpbWVyYCBpcyBub3QgMCwgd2hpY2ggbWVhbnMgdGhlIGVmZmVjdCB3YXNuJ3QgY2FuY2VsZWRcclxuICAgICAgICAgICAgaWYgKGludGVydmFsICYmIHRpbWVyICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWN1dGUsIGludGVydmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlKCkge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIE9LIHRvIGV4ZWN1dGU6XHJcbiAgICAgICAgICAgIC8vIE9ubHkgcmV2YWxpZGF0ZSB3aGVuIHRoZSBwYWdlIGlzIHZpc2libGUsIG9ubGluZSBhbmQgbm90IGVycm9yZWQuXHJcbiAgICAgICAgICAgIGlmICghc3RhdGVSZWYuY3VycmVudC5lcnJvciAmJlxyXG4gICAgICAgICAgICAgICAgKHJlZnJlc2hXaGVuSGlkZGVuIHx8IGdldENvbmZpZygpLmlzVmlzaWJsZSgpKSAmJlxyXG4gICAgICAgICAgICAgICAgKHJlZnJlc2hXaGVuT2ZmbGluZSB8fCBnZXRDb25maWcoKS5pc09ubGluZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZShXSVRIX0RFRFVQRSkudGhlbihuZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIG5leHQgaW50ZXJ2YWwgdG8gY2hlY2sgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICBuZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbmV4dCgpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICAgICAgICAgIHRpbWVyID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSwgW3JlZnJlc2hJbnRlcnZhbCwgcmVmcmVzaFdoZW5IaWRkZW4sIHJlZnJlc2hXaGVuT2ZmbGluZSwgcmV2YWxpZGF0ZV0pO1xyXG4gICAgLy8gRGlzcGxheSBkZWJ1ZyBpbmZvIGluIFJlYWN0IERldlRvb2xzLlxyXG4gICAgdXNlRGVidWdWYWx1ZShkYXRhKTtcclxuICAgIC8vIEluIFN1c3BlbnNlIG1vZGUsIHdlIGNhbid0IHJldHVybiB0aGUgZW1wdHkgYGRhdGFgIHN0YXRlLlxyXG4gICAgLy8gSWYgdGhlcmUgaXMgYGVycm9yYCwgdGhlIGBlcnJvcmAgbmVlZHMgdG8gYmUgdGhyb3duIHRvIHRoZSBlcnJvciBib3VuZGFyeS5cclxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGBlcnJvcmAsIHRoZSBgcmV2YWxpZGF0aW9uYCBwcm9taXNlIG5lZWRzIHRvIGJlIHRocm93biB0b1xyXG4gICAgLy8gdGhlIHN1c3BlbnNlIGJvdW5kYXJ5LlxyXG4gICAgaWYgKHN1c3BlbnNlICYmIGlzVW5kZWZpbmVkKGRhdGEpICYmIGtleSkge1xyXG4gICAgICAgIC8vIEFsd2F5cyB1cGRhdGUgZmV0Y2hlciBhbmQgY29uZmlnIHJlZnMgZXZlbiB3aXRoIHRoZSBTdXNwZW5zZSBtb2RlLlxyXG4gICAgICAgIGZldGNoZXJSZWYuY3VycmVudCA9IGZldGNoZXI7XHJcbiAgICAgICAgY29uZmlnUmVmLmN1cnJlbnQgPSBjb25maWc7XHJcbiAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICB0aHJvdyBpc1VuZGVmaW5lZChlcnJvcikgPyByZXZhbGlkYXRlKFdJVEhfREVEVVBFKSA6IGVycm9yO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtdXRhdGU6IGJvdW5kTXV0YXRlLFxyXG4gICAgICAgIGdldCBkYXRhKCkge1xyXG4gICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5kYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgZXJyb3IoKSB7XHJcbiAgICAgICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzLmVycm9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IGlzVmFsaWRhdGluZygpIHtcclxuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuaXNWYWxpZGF0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRhdGluZztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG52YXIgU1dSQ29uZmlnID0gT0JKRUNULmRlZmluZVByb3BlcnR5KFNXUkNvbmZpZyQxLCAnZGVmYXVsdCcsIHtcclxuICAgIHZhbHVlOiBkZWZhdWx0Q29uZmlnXHJcbn0pO1xyXG52YXIgdW5zdGFibGVfc2VyaWFsaXplID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc2VyaWFsaXplKGtleSlbMF07IH07XHJcbnZhciB1c2VTV1IgPSB3aXRoQXJncyh1c2VTV1JIYW5kbGVyKTtcclxuXHJcbi8vIHVzZVNXUlxyXG5cclxuZXhwb3J0IHsgU1dSQ29uZmlnLCB1c2VTV1IgYXMgZGVmYXVsdCwgbXV0YXRlLCB1bnN0YWJsZV9zZXJpYWxpemUsIHVzZVNXUkNvbmZpZyB9O1xyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsInVzZURlYnVnVmFsdWUiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJfX2dlbmVyYXRvciIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidCIsInRyeXMiLCJvcHMiLCJmIiwieSIsImciLCJ2ZXJiIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJuIiwidiIsIm9wIiwiVHlwZUVycm9yIiwiY2FsbCIsInBvcCIsImxlbmd0aCIsInB1c2giLCJub29wIiwiVU5ERUZJTkVEIiwiT0JKRUNUIiwiT2JqZWN0IiwiaXNVbmRlZmluZWQiLCJpc0Z1bmN0aW9uIiwibWVyZ2VPYmplY3RzIiwiYSIsImIiLCJhc3NpZ24iLCJTVFJfVU5ERUZJTkVEIiwiaGFzV2luZG93Iiwid2luZG93IiwiaGFzRG9jdW1lbnQiLCJkb2N1bWVudCIsImhhc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsInRhYmxlIiwiV2Vha01hcCIsImNvdW50ZXIiLCJzdGFibGVIYXNoIiwiYXJnIiwidHlwZSIsImNvbnN0cnVjdG9yIiwiaXNEYXRlIiwiRGF0ZSIsImluZGV4IiwiUmVnRXhwIiwiZ2V0Iiwic2V0IiwiQXJyYXkiLCJrZXlzIiwic29ydCIsInRvSlNPTiIsInRvU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsIm9ubGluZSIsImlzT25saW5lIiwiaGFzV2luIiwiaGFzRG9jIiwib25XaW5kb3dFdmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJiaW5kIiwib25Eb2N1bWVudEV2ZW50Iiwib2ZmV2luZG93RXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib2ZmRG9jdW1lbnRFdmVudCIsImlzVmlzaWJsZSIsInZpc2liaWxpdHlTdGF0ZSIsImluaXRGb2N1cyIsImNhbGxiYWNrIiwiaW5pdFJlY29ubmVjdCIsIm9uT25saW5lIiwib25PZmZsaW5lIiwicHJlc2V0IiwiZGVmYXVsdENvbmZpZ09wdGlvbnMiLCJJU19TRVJWRVIiLCJyQUYiLCJzZXRUaW1lb3V0IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIm5hdmlnYXRvckNvbm5lY3Rpb24iLCJuYXZpZ2F0b3IiLCJjb25uZWN0aW9uIiwic2xvd0Nvbm5lY3Rpb24iLCJpbmNsdWRlcyIsImVmZmVjdGl2ZVR5cGUiLCJzYXZlRGF0YSIsInNlcmlhbGl6ZSIsImtleSIsImVyciIsImFyZ3MiLCJjb25jYXQiLCJpc0FycmF5IiwiaW5mb0tleSIsIlNXUkdsb2JhbFN0YXRlIiwiRk9DVVNfRVZFTlQiLCJSRUNPTk5FQ1RfRVZFTlQiLCJNVVRBVEVfRVZFTlQiLCJicm9hZGNhc3RTdGF0ZSIsImNhY2hlIiwiZGF0YSIsImVycm9yIiwiaXNWYWxpZGF0aW5nIiwicmV2YWxpZGF0ZSIsImJyb2FkY2FzdCIsIl9hIiwiRVZFTlRfUkVWQUxJREFUT1JTIiwiU1RBVEVfVVBEQVRFUlMiLCJGRVRDSCIsInJldmFsaWRhdG9ycyIsInVwZGF0ZXJzIiwiaSIsIl9fdGltZXN0YW1wIiwiZ2V0VGltZXN0YW1wIiwiaW50ZXJuYWxNdXRhdGUiLCJfaSIsImFyZ3VtZW50cyIsIl9rZXkiLCJfZGF0YSIsIl9vcHRzIiwib3B0aW9ucyIsInBvcHVsYXRlQ2FjaGUiLCJyb2xsYmFja09uRXJyb3IiLCJjdXN0b21PcHRpbWlzdGljRGF0YSIsImtleUluZm8iLCJfYiIsIk1VVEFUSU9OIiwiYmVmb3JlTXV0YXRpb25UcyIsImhhc0N1c3RvbU9wdGltaXN0aWNEYXRhIiwicm9sbGJhY2tEYXRhIiwib3B0aW1pc3RpY0RhdGEiLCJyZXMiLCJfYyIsImNhdGNoIiwicmV2YWxpZGF0ZUFsbEtleXMiLCJpbml0Q2FjaGUiLCJwcm92aWRlciIsImhhcyIsIm9wdHMiLCJtdXRhdGUiLCJ1bm1vdW50IiwicmVsZWFzZUZvY3VzXzEiLCJyZWxlYXNlUmVjb25uZWN0XzEiLCJkZWxldGUiLCJvbkVycm9yUmV0cnkiLCJfXyIsImNvbmZpZyIsIm1heFJldHJ5Q291bnQiLCJlcnJvclJldHJ5Q291bnQiLCJjdXJyZW50UmV0cnlDb3VudCIsInJldHJ5Q291bnQiLCJ0aW1lb3V0IiwiTWF0aCIsInJhbmRvbSIsImVycm9yUmV0cnlJbnRlcnZhbCIsIk1hcCIsImRlZmF1bHRDb25maWciLCJvbkxvYWRpbmdTbG93Iiwib25TdWNjZXNzIiwib25FcnJvciIsIm9uRGlzY2FyZGVkIiwicmV2YWxpZGF0ZU9uRm9jdXMiLCJyZXZhbGlkYXRlT25SZWNvbm5lY3QiLCJyZXZhbGlkYXRlSWZTdGFsZSIsInNob3VsZFJldHJ5T25FcnJvciIsImZvY3VzVGhyb3R0bGVJbnRlcnZhbCIsImRlZHVwaW5nSW50ZXJ2YWwiLCJsb2FkaW5nVGltZW91dCIsImNvbXBhcmUiLCJjdXJyZW50RGF0YSIsIm5ld0RhdGEiLCJpc1BhdXNlZCIsImZhbGxiYWNrIiwibWVyZ2VDb25maWdzIiwidTEiLCJ1c2UiLCJmMSIsInUyIiwiZjIiLCJTV1JDb25maWdDb250ZXh0IiwiU1dSQ29uZmlnJDEiLCJwcm9wcyIsImV4dGVuZGVkQ29uZmlnIiwiY2FjaGVDb250ZXh0IiwiUHJvdmlkZXIiLCJ1c2VTdGF0ZVdpdGhEZXBzIiwic3RhdGUiLCJ1bm1vdW50ZWRSZWYiLCJyZXJlbmRlciIsInN0YXRlUmVmIiwic3RhdGVEZXBlbmRlbmNpZXNSZWYiLCJzZXRTdGF0ZSIsInBheWxvYWQiLCJzaG91bGRSZXJlbmRlciIsImN1cnJlbnRTdGF0ZSIsImN1cnJlbnQiLCJrIiwibm9ybWFsaXplIiwidXNlU1dSQ29uZmlnIiwid2l0aEFyZ3MiLCJob29rIiwidXNlU1dSQXJncyIsImZhbGxiYWNrQ29uZmlnIiwiZm4iLCJfY29uZmlnIiwiZmV0Y2hlciIsInN1YnNjcmliZUNhbGxiYWNrIiwiY2FsbGJhY2tzIiwia2V5ZWRSZXZhbGlkYXRvcnMiLCJpbmRleE9mIiwiV0lUSF9ERURVUEUiLCJkZWR1cGUiLCJ1c2VTV1JIYW5kbGVyIiwiZmFsbGJhY2tEYXRhIiwic3VzcGVuc2UiLCJyZXZhbGlkYXRlT25Nb3VudCIsInJlZnJlc2hJbnRlcnZhbCIsInJlZnJlc2hXaGVuSGlkZGVuIiwicmVmcmVzaFdoZW5PZmZsaW5lIiwiZm5BcmdzIiwiaW5pdGlhbE1vdW50ZWRSZWYiLCJrZXlSZWYiLCJmZXRjaGVyUmVmIiwiY29uZmlnUmVmIiwiZ2V0Q29uZmlnIiwiaXNBY3RpdmUiLCJwYXRjaEZldGNoSW5mbyIsImluZm8iLCJjYWNoZWQiLCJpc0luaXRpYWxNb3VudCIsInNob3VsZFJldmFsaWRhdGUiLCJyZXNvbHZlVmFsaWRhdGluZyIsInN0YXRlRGVwZW5kZW5jaWVzIiwicmV2YWxpZGF0ZU9wdHMiLCJjdXJyZW50RmV0Y2hlciIsInN0YXJ0QXQiLCJsb2FkaW5nIiwic2hvdWxkU3RhcnROZXdSZXF1ZXN0IiwiaXNDdXJyZW50S2V5TW91bnRlZCIsImNsZWFudXBTdGF0ZSIsIm5ld1N0YXRlIiwiZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlIiwibXV0YXRpb25JbmZvIiwiZXJyXzEiLCJyZXF1ZXN0SW5mbyIsImJvdW5kTXV0YXRlIiwia2V5Q2hhbmdlZCIsInNvZnRSZXZhbGlkYXRlIiwib25TdGF0ZVVwZGF0ZSIsInVwZGF0ZWREYXRhIiwidXBkYXRlZEVycm9yIiwidXBkYXRlZElzVmFsaWRhdGluZyIsIm5leHRGb2N1c1JldmFsaWRhdGVkQXQiLCJvblJldmFsaWRhdGUiLCJub3ciLCJ1bnN1YlVwZGF0ZSIsInVuc3ViRXZlbnRzIiwidGltZXIiLCJpbnRlcnZhbCIsImV4ZWN1dGUiLCJjbGVhclRpbWVvdXQiLCJTV1JDb25maWciLCJkZWZpbmVQcm9wZXJ0eSIsInVuc3RhYmxlX3NlcmlhbGl6ZSIsInVzZVNXUiIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/swr/dist/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!"), __webpack_exec__("./node_modules/next/dist/client/router.js"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);