/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLGlCQUFULENBQTJCQyxHQUEzQixFQUFnQ0MsR0FBaEMsRUFBcUM7RUFDbkMsSUFBSUEsR0FBRyxJQUFJLElBQVAsSUFBZUEsR0FBRyxHQUFHRCxHQUFHLENBQUNFLE1BQTdCLEVBQXFDRCxHQUFHLEdBQUdELEdBQUcsQ0FBQ0UsTUFBVjs7RUFFckMsS0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBUixFQUFXQyxJQUFJLEdBQUcsSUFBSUMsS0FBSixDQUFVSixHQUFWLENBQXZCLEVBQXVDRSxDQUFDLEdBQUdGLEdBQTNDLEVBQWdERSxDQUFDLEVBQWpELEVBQXFEO0lBQ25EQyxJQUFJLENBQUNELENBQUQsQ0FBSixHQUFVSCxHQUFHLENBQUNHLENBQUQsQ0FBYjtFQUNEOztFQUVELE9BQU9DLElBQVA7QUFDRDs7QUFFREUsTUFBTSxDQUFDQyxPQUFQLEdBQWlCUixpQkFBakIsRUFBb0NPLHlCQUFBLEdBQTRCLElBQWhFLEVBQXNFQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF6RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzP2NmMDkiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcclxuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFycjI7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2FycmF5TGlrZVRvQXJyYXkiLCJhcnIiLCJsZW4iLCJsZW5ndGgiLCJpIiwiYXJyMiIsIkFycmF5IiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/arrayLikeToArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxHQUF6QixFQUE4QjtFQUM1QixJQUFJQyxLQUFLLENBQUNDLE9BQU4sQ0FBY0YsR0FBZCxDQUFKLEVBQXdCLE9BQU9BLEdBQVA7QUFDekI7O0FBRURHLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsZUFBakIsRUFBa0NJLHlCQUFBLEdBQTRCLElBQTlELEVBQW9FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF2RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcz9hNTI1Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfYXJyYXlXaXRoSG9sZXMiLCJhcnIiLCJBcnJheSIsImlzQXJyYXkiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/arrayWithHoles.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0Esc0JBQVQsQ0FBZ0NDLElBQWhDLEVBQXNDO0VBQ3BDLElBQUlBLElBQUksS0FBSyxLQUFLLENBQWxCLEVBQXFCO0lBQ25CLE1BQU0sSUFBSUMsY0FBSixDQUFtQiwyREFBbkIsQ0FBTjtFQUNEOztFQUVELE9BQU9ELElBQVA7QUFDRDs7QUFFREUsTUFBTSxDQUFDQyxPQUFQLEdBQWlCSixzQkFBakIsRUFBeUNHLHlCQUFBLEdBQTRCLElBQXJFLEVBQTJFQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUE5RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/MjAxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcclxuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XHJcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc2VsZjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/assertThisInitialized.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLGtCQUFULENBQTRCQyxHQUE1QixFQUFpQ0MsT0FBakMsRUFBMENDLE1BQTFDLEVBQWtEQyxLQUFsRCxFQUF5REMsTUFBekQsRUFBaUVDLEdBQWpFLEVBQXNFQyxHQUF0RSxFQUEyRTtFQUN6RSxJQUFJO0lBQ0YsSUFBSUMsSUFBSSxHQUFHUCxHQUFHLENBQUNLLEdBQUQsQ0FBSCxDQUFTQyxHQUFULENBQVg7SUFDQSxJQUFJRSxLQUFLLEdBQUdELElBQUksQ0FBQ0MsS0FBakI7RUFDRCxDQUhELENBR0UsT0FBT0MsS0FBUCxFQUFjO0lBQ2RQLE1BQU0sQ0FBQ08sS0FBRCxDQUFOO0lBQ0E7RUFDRDs7RUFFRCxJQUFJRixJQUFJLENBQUNHLElBQVQsRUFBZTtJQUNiVCxPQUFPLENBQUNPLEtBQUQsQ0FBUDtFQUNELENBRkQsTUFFTztJQUNMRyxPQUFPLENBQUNWLE9BQVIsQ0FBZ0JPLEtBQWhCLEVBQXVCSSxJQUF2QixDQUE0QlQsS0FBNUIsRUFBbUNDLE1BQW5DO0VBQ0Q7QUFDRjs7QUFFRCxTQUFTUyxpQkFBVCxDQUEyQkMsRUFBM0IsRUFBK0I7RUFDN0IsT0FBTyxZQUFZO0lBQ2pCLElBQUlDLElBQUksR0FBRyxJQUFYO0lBQUEsSUFDSUMsSUFBSSxHQUFHQyxTQURYO0lBRUEsT0FBTyxJQUFJTixPQUFKLENBQVksVUFBVVYsT0FBVixFQUFtQkMsTUFBbkIsRUFBMkI7TUFDNUMsSUFBSUYsR0FBRyxHQUFHYyxFQUFFLENBQUNJLEtBQUgsQ0FBU0gsSUFBVCxFQUFlQyxJQUFmLENBQVY7O01BRUEsU0FBU2IsS0FBVCxDQUFlSyxLQUFmLEVBQXNCO1FBQ3BCVCxrQkFBa0IsQ0FBQ0MsR0FBRCxFQUFNQyxPQUFOLEVBQWVDLE1BQWYsRUFBdUJDLEtBQXZCLEVBQThCQyxNQUE5QixFQUFzQyxNQUF0QyxFQUE4Q0ksS0FBOUMsQ0FBbEI7TUFDRDs7TUFFRCxTQUFTSixNQUFULENBQWdCZSxHQUFoQixFQUFxQjtRQUNuQnBCLGtCQUFrQixDQUFDQyxHQUFELEVBQU1DLE9BQU4sRUFBZUMsTUFBZixFQUF1QkMsS0FBdkIsRUFBOEJDLE1BQTlCLEVBQXNDLE9BQXRDLEVBQStDZSxHQUEvQyxDQUFsQjtNQUNEOztNQUVEaEIsS0FBSyxDQUFDaUIsU0FBRCxDQUFMO0lBQ0QsQ0FaTSxDQUFQO0VBYUQsQ0FoQkQ7QUFpQkQ7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQlQsaUJBQWpCLEVBQW9DUSx5QkFBQSxHQUE0QixJQUFoRSxFQUFzRUEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBekciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcz9kMzEyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcclxuICB0cnkge1xyXG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xyXG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmVqZWN0KGVycm9yKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlmIChpbmZvLmRvbmUpIHtcclxuICAgIHJlc29sdmUodmFsdWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XHJcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XHJcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XHJcbiAgICB9KTtcclxuICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbImFzeW5jR2VuZXJhdG9yU3RlcCIsImdlbiIsInJlc29sdmUiLCJyZWplY3QiLCJfbmV4dCIsIl90aHJvdyIsImtleSIsImFyZyIsImluZm8iLCJ2YWx1ZSIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJmbiIsInNlbGYiLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJlcnIiLCJ1bmRlZmluZWQiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/asyncToGenerator.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxRQUF6QixFQUFtQ0MsV0FBbkMsRUFBZ0Q7RUFDOUMsSUFBSSxFQUFFRCxRQUFRLFlBQVlDLFdBQXRCLENBQUosRUFBd0M7SUFDdEMsTUFBTSxJQUFJQyxTQUFKLENBQWMsbUNBQWQsQ0FBTjtFQUNEO0FBQ0Y7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsZUFBakIsRUFBa0NJLHlCQUFBLEdBQTRCLElBQTlELEVBQW9FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF2RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcz9iN2FlIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcclxuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/classCallCheck.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nvar isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct.js */ \"./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js\");\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsY0FBYyxHQUFHQyxtQkFBTyxDQUFDLG9GQUFELENBQTVCOztBQUVBLElBQUlDLHdCQUF3QixHQUFHRCxtQkFBTyxDQUFDLHdHQUFELENBQXRDOztBQUVBLFNBQVNFLFVBQVQsQ0FBb0JDLE1BQXBCLEVBQTRCQyxJQUE1QixFQUFrQ0MsS0FBbEMsRUFBeUM7RUFDdkMsSUFBSUosd0JBQXdCLEVBQTVCLEVBQWdDO0lBQzlCSyxNQUFNLENBQUNDLE9BQVAsR0FBaUJMLFVBQVUsR0FBR00sT0FBTyxDQUFDQyxTQUF0QyxFQUFpREgseUJBQUEsR0FBNEIsSUFBN0UsRUFBbUZBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQXRIO0VBQ0QsQ0FGRCxNQUVPO0lBQ0xELE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsVUFBVSxHQUFHLFNBQVNBLFVBQVQsQ0FBb0JDLE1BQXBCLEVBQTRCQyxJQUE1QixFQUFrQ0MsS0FBbEMsRUFBeUM7TUFDckUsSUFBSU0sQ0FBQyxHQUFHLENBQUMsSUFBRCxDQUFSO01BQ0FBLENBQUMsQ0FBQ0MsSUFBRixDQUFPQyxLQUFQLENBQWFGLENBQWIsRUFBZ0JQLElBQWhCO01BQ0EsSUFBSVUsV0FBVyxHQUFHQyxRQUFRLENBQUNDLElBQVQsQ0FBY0gsS0FBZCxDQUFvQlYsTUFBcEIsRUFBNEJRLENBQTVCLENBQWxCO01BQ0EsSUFBSU0sUUFBUSxHQUFHLElBQUlILFdBQUosRUFBZjtNQUNBLElBQUlULEtBQUosRUFBV04sY0FBYyxDQUFDa0IsUUFBRCxFQUFXWixLQUFLLENBQUNhLFNBQWpCLENBQWQ7TUFDWCxPQUFPRCxRQUFQO0lBQ0QsQ0FQRCxFQU9HWCx5QkFBQSxHQUE0QixJQVAvQixFQU9xQ0EseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FQeEU7RUFRRDs7RUFFRCxPQUFPTCxVQUFVLENBQUNXLEtBQVgsQ0FBaUIsSUFBakIsRUFBdUJNLFNBQXZCLENBQVA7QUFDRDs7QUFFRGIsTUFBTSxDQUFDQyxPQUFQLEdBQWlCTCxVQUFqQixFQUE2QkkseUJBQUEsR0FBNEIsSUFBekQsRUFBK0RBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQWxHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcz8yOTFlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xyXG5cclxudmFyIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHJlcXVpcmUoXCIuL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qc1wiKTtcclxuXHJcbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xyXG4gIGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3QsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcclxuICB9IGVsc2Uge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XHJcbiAgICAgIHZhciBhID0gW251bGxdO1xyXG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XHJcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcclxuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XHJcbiAgICAgIGlmIChDbGFzcykgc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XHJcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcclxuICB9XHJcblxyXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJzZXRQcm90b3R5cGVPZiIsInJlcXVpcmUiLCJpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY29uc3RydWN0IiwiUGFyZW50IiwiYXJncyIsIkNsYXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJfX2VzTW9kdWxlIiwiYSIsInB1c2giLCJhcHBseSIsIkNvbnN0cnVjdG9yIiwiRnVuY3Rpb24iLCJiaW5kIiwiaW5zdGFuY2UiLCJwcm90b3R5cGUiLCJhcmd1bWVudHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/construct.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxpQkFBVCxDQUEyQkMsTUFBM0IsRUFBbUNDLEtBQW5DLEVBQTBDO0VBQ3hDLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsS0FBSyxDQUFDRSxNQUExQixFQUFrQ0QsQ0FBQyxFQUFuQyxFQUF1QztJQUNyQyxJQUFJRSxVQUFVLEdBQUdILEtBQUssQ0FBQ0MsQ0FBRCxDQUF0QjtJQUNBRSxVQUFVLENBQUNDLFVBQVgsR0FBd0JELFVBQVUsQ0FBQ0MsVUFBWCxJQUF5QixLQUFqRDtJQUNBRCxVQUFVLENBQUNFLFlBQVgsR0FBMEIsSUFBMUI7SUFDQSxJQUFJLFdBQVdGLFVBQWYsRUFBMkJBLFVBQVUsQ0FBQ0csUUFBWCxHQUFzQixJQUF0QjtJQUMzQkMsTUFBTSxDQUFDQyxjQUFQLENBQXNCVCxNQUF0QixFQUE4QkksVUFBVSxDQUFDTSxHQUF6QyxFQUE4Q04sVUFBOUM7RUFDRDtBQUNGOztBQUVELFNBQVNPLFlBQVQsQ0FBc0JDLFdBQXRCLEVBQW1DQyxVQUFuQyxFQUErQ0MsV0FBL0MsRUFBNEQ7RUFDMUQsSUFBSUQsVUFBSixFQUFnQmQsaUJBQWlCLENBQUNhLFdBQVcsQ0FBQ0csU0FBYixFQUF3QkYsVUFBeEIsQ0FBakI7RUFDaEIsSUFBSUMsV0FBSixFQUFpQmYsaUJBQWlCLENBQUNhLFdBQUQsRUFBY0UsV0FBZCxDQUFqQjtFQUNqQk4sTUFBTSxDQUFDQyxjQUFQLENBQXNCRyxXQUF0QixFQUFtQyxXQUFuQyxFQUFnRDtJQUM5Q0wsUUFBUSxFQUFFO0VBRG9DLENBQWhEO0VBR0EsT0FBT0ssV0FBUDtBQUNEOztBQUVESSxNQUFNLENBQUNDLE9BQVAsR0FBaUJOLFlBQWpCLEVBQStCSyx5QkFBQSxHQUE0QixJQUEzRCxFQUFpRUEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBcEciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanM/NTQ2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcclxuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcclxuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcclxuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XHJcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XHJcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xyXG4gICAgd3JpdGFibGU6IGZhbHNlXHJcbiAgfSk7XHJcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsIl9jcmVhdGVDbGFzcyIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicHJvdG90eXBlIiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/createClass.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxHQUF6QixFQUE4QkMsR0FBOUIsRUFBbUNDLEtBQW5DLEVBQTBDO0VBQ3hDLElBQUlELEdBQUcsSUFBSUQsR0FBWCxFQUFnQjtJQUNkRyxNQUFNLENBQUNDLGNBQVAsQ0FBc0JKLEdBQXRCLEVBQTJCQyxHQUEzQixFQUFnQztNQUM5QkMsS0FBSyxFQUFFQSxLQUR1QjtNQUU5QkcsVUFBVSxFQUFFLElBRmtCO01BRzlCQyxZQUFZLEVBQUUsSUFIZ0I7TUFJOUJDLFFBQVEsRUFBRTtJQUpvQixDQUFoQztFQU1ELENBUEQsTUFPTztJQUNMUCxHQUFHLENBQUNDLEdBQUQsQ0FBSCxHQUFXQyxLQUFYO0VBQ0Q7O0VBRUQsT0FBT0YsR0FBUDtBQUNEOztBQUVEUSxNQUFNLENBQUNDLE9BQVAsR0FBaUJWLGVBQWpCLEVBQWtDUyx5QkFBQSxHQUE0QixJQUE5RCxFQUFvRUEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBdkciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanM/ZDk0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XHJcbiAgaWYgKGtleSBpbiBvYmopIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xyXG4gICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/defineProperty.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxDQUF6QixFQUE0QjtFQUMxQkMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCSCxlQUFlLEdBQUdJLE1BQU0sQ0FBQ0MsY0FBUCxHQUF3QkQsTUFBTSxDQUFDRSxjQUEvQixHQUFnRCxTQUFTTixlQUFULENBQXlCQyxDQUF6QixFQUE0QjtJQUM3RyxPQUFPQSxDQUFDLENBQUNNLFNBQUYsSUFBZUgsTUFBTSxDQUFDRSxjQUFQLENBQXNCTCxDQUF0QixDQUF0QjtFQUNELENBRkQsRUFFR0MseUJBQUEsR0FBNEIsSUFGL0IsRUFFcUNBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BRnhFO0VBR0EsT0FBT0gsZUFBZSxDQUFDQyxDQUFELENBQXRCO0FBQ0Q7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkgsZUFBakIsRUFBa0NFLHlCQUFBLEdBQTRCLElBQTlELEVBQW9FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF2RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcz85MDAzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xyXG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcclxuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XHJcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2dldFByb3RvdHlwZU9mIiwibyIsIm1vZHVsZSIsImV4cG9ydHMiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/getPrototypeOf.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxjQUFjLEdBQUdDLG1CQUFPLENBQUMsb0ZBQUQsQ0FBNUI7O0FBRUEsU0FBU0MsU0FBVCxDQUFtQkMsUUFBbkIsRUFBNkJDLFVBQTdCLEVBQXlDO0VBQ3ZDLElBQUksT0FBT0EsVUFBUCxLQUFzQixVQUF0QixJQUFvQ0EsVUFBVSxLQUFLLElBQXZELEVBQTZEO0lBQzNELE1BQU0sSUFBSUMsU0FBSixDQUFjLG9EQUFkLENBQU47RUFDRDs7RUFFREYsUUFBUSxDQUFDRyxTQUFULEdBQXFCQyxNQUFNLENBQUNDLE1BQVAsQ0FBY0osVUFBVSxJQUFJQSxVQUFVLENBQUNFLFNBQXZDLEVBQWtEO0lBQ3JFRyxXQUFXLEVBQUU7TUFDWEMsS0FBSyxFQUFFUCxRQURJO01BRVhRLFFBQVEsRUFBRSxJQUZDO01BR1hDLFlBQVksRUFBRTtJQUhIO0VBRHdELENBQWxELENBQXJCO0VBT0FMLE1BQU0sQ0FBQ00sY0FBUCxDQUFzQlYsUUFBdEIsRUFBZ0MsV0FBaEMsRUFBNkM7SUFDM0NRLFFBQVEsRUFBRTtFQURpQyxDQUE3QztFQUdBLElBQUlQLFVBQUosRUFBZ0JKLGNBQWMsQ0FBQ0csUUFBRCxFQUFXQyxVQUFYLENBQWQ7QUFDakI7O0FBRURVLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQmIsU0FBakIsRUFBNEJZLHlCQUFBLEdBQTRCLElBQXhELEVBQThEQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUFqRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcz9mMzViIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xyXG5cclxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XHJcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xyXG4gIH1cclxuXHJcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XHJcbiAgICBjb25zdHJ1Y3Rvcjoge1xyXG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXHJcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH1cclxuICB9KTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcclxuICAgIHdyaXRhYmxlOiBmYWxzZVxyXG4gIH0pO1xyXG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbInNldFByb3RvdHlwZU9mIiwicmVxdWlyZSIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsIlR5cGVFcnJvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwidmFsdWUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImRlZmluZVByb3BlcnR5IiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/inherits.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0Esc0JBQVQsQ0FBZ0NDLEdBQWhDLEVBQXFDO0VBQ25DLE9BQU9BLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFYLEdBQXdCRCxHQUF4QixHQUE4QjtJQUNuQyxXQUFXQTtFQUR3QixDQUFyQztBQUdEOztBQUVERSxNQUFNLENBQUNDLE9BQVAsR0FBaUJKLHNCQUFqQixFQUF5Q0cseUJBQUEsR0FBNEIsSUFBckUsRUFBMkVBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQTlHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcz9lZThjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XHJcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcclxuICAgIFwiZGVmYXVsdFwiOiBvYmpcclxuICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/interopRequireDefault.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeFunction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeFunction.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nmodule.exports = _isNativeFunction, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZUZ1bmN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLGlCQUFULENBQTJCQyxFQUEzQixFQUErQjtFQUM3QixPQUFPQyxRQUFRLENBQUNDLFFBQVQsQ0FBa0JDLElBQWxCLENBQXVCSCxFQUF2QixFQUEyQkksT0FBM0IsQ0FBbUMsZUFBbkMsTUFBd0QsQ0FBQyxDQUFoRTtBQUNEOztBQUVEQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJQLGlCQUFqQixFQUFvQ00seUJBQUEsR0FBNEIsSUFBaEUsRUFBc0VBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQXpHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlRnVuY3Rpb24uanM/OGM4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xyXG4gIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlRnVuY3Rpb24sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2lzTmF0aXZlRnVuY3Rpb24iLCJmbiIsIkZ1bmN0aW9uIiwidG9TdHJpbmciLCJjYWxsIiwiaW5kZXhPZiIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/isNativeFunction.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nmodule.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EseUJBQVQsR0FBcUM7RUFDbkMsSUFBSSxPQUFPQyxPQUFQLEtBQW1CLFdBQW5CLElBQWtDLENBQUNBLE9BQU8sQ0FBQ0MsU0FBL0MsRUFBMEQsT0FBTyxLQUFQO0VBQzFELElBQUlELE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkMsSUFBdEIsRUFBNEIsT0FBTyxLQUFQO0VBQzVCLElBQUksT0FBT0MsS0FBUCxLQUFpQixVQUFyQixFQUFpQyxPQUFPLElBQVA7O0VBRWpDLElBQUk7SUFDRkMsT0FBTyxDQUFDQyxTQUFSLENBQWtCQyxPQUFsQixDQUEwQkMsSUFBMUIsQ0FBK0JQLE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkcsT0FBbEIsRUFBMkIsRUFBM0IsRUFBK0IsWUFBWSxDQUFFLENBQTdDLENBQS9CO0lBQ0EsT0FBTyxJQUFQO0VBQ0QsQ0FIRCxDQUdFLE9BQU9JLENBQVAsRUFBVTtJQUNWLE9BQU8sS0FBUDtFQUNEO0FBQ0Y7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQlgseUJBQWpCLEVBQTRDVSx5QkFBQSxHQUE0QixJQUF4RSxFQUE4RUEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBakgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzPzFkNTQiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcclxuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XHJcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcclxuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xyXG5cclxuICB0cnkge1xyXG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInByb3RvdHlwZSIsInZhbHVlT2YiLCJjYWxsIiwiZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxxQkFBVCxDQUErQkMsR0FBL0IsRUFBb0NDLENBQXBDLEVBQXVDO0VBQ3JDLElBQUlDLEVBQUUsR0FBR0YsR0FBRyxJQUFJLElBQVAsR0FBYyxJQUFkLEdBQXFCLE9BQU9HLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNILEdBQUcsQ0FBQ0csTUFBTSxDQUFDQyxRQUFSLENBQXBDLElBQXlESixHQUFHLENBQUMsWUFBRCxDQUExRjs7RUFFQSxJQUFJRSxFQUFFLElBQUksSUFBVixFQUFnQjtFQUNoQixJQUFJRyxJQUFJLEdBQUcsRUFBWDtFQUNBLElBQUlDLEVBQUUsR0FBRyxJQUFUO0VBQ0EsSUFBSUMsRUFBRSxHQUFHLEtBQVQ7O0VBRUEsSUFBSUMsRUFBSixFQUFRQyxFQUFSOztFQUVBLElBQUk7SUFDRixLQUFLUCxFQUFFLEdBQUdBLEVBQUUsQ0FBQ1EsSUFBSCxDQUFRVixHQUFSLENBQVYsRUFBd0IsRUFBRU0sRUFBRSxHQUFHLENBQUNFLEVBQUUsR0FBR04sRUFBRSxDQUFDUyxJQUFILEVBQU4sRUFBaUJDLElBQXhCLENBQXhCLEVBQXVETixFQUFFLEdBQUcsSUFBNUQsRUFBa0U7TUFDaEVELElBQUksQ0FBQ1EsSUFBTCxDQUFVTCxFQUFFLENBQUNNLEtBQWI7O01BRUEsSUFBSWIsQ0FBQyxJQUFJSSxJQUFJLENBQUNVLE1BQUwsS0FBZ0JkLENBQXpCLEVBQTRCO0lBQzdCO0VBQ0YsQ0FORCxDQU1FLE9BQU9lLEdBQVAsRUFBWTtJQUNaVCxFQUFFLEdBQUcsSUFBTDtJQUNBRSxFQUFFLEdBQUdPLEdBQUw7RUFDRCxDQVRELFNBU1U7SUFDUixJQUFJO01BQ0YsSUFBSSxDQUFDVixFQUFELElBQU9KLEVBQUUsQ0FBQyxRQUFELENBQUYsSUFBZ0IsSUFBM0IsRUFBaUNBLEVBQUUsQ0FBQyxRQUFELENBQUY7SUFDbEMsQ0FGRCxTQUVVO01BQ1IsSUFBSUssRUFBSixFQUFRLE1BQU1FLEVBQU47SUFDVDtFQUNGOztFQUVELE9BQU9KLElBQVA7QUFDRDs7QUFFRFksTUFBTSxDQUFDQyxPQUFQLEdBQWlCbkIscUJBQWpCLEVBQXdDa0IseUJBQUEsR0FBNEIsSUFBcEUsRUFBMEVBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQTdHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzP2FmZTciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xyXG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcclxuXHJcbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcclxuICB2YXIgX2FyciA9IFtdO1xyXG4gIHZhciBfbiA9IHRydWU7XHJcbiAgdmFyIF9kID0gZmFsc2U7XHJcblxyXG4gIHZhciBfcywgX2U7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XHJcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XHJcblxyXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBfZCA9IHRydWU7XHJcbiAgICBfZSA9IGVycjtcclxuICB9IGZpbmFsbHkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBfYXJyO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJhcnIiLCJpIiwiX2kiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9hcnIiLCJfbiIsIl9kIiwiX3MiLCJfZSIsImNhbGwiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImxlbmd0aCIsImVyciIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EsZ0JBQVQsR0FBNEI7RUFDMUIsTUFBTSxJQUFJQyxTQUFKLENBQWMsMklBQWQsQ0FBTjtBQUNEOztBQUVEQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJILGdCQUFqQixFQUFtQ0UseUJBQUEsR0FBNEIsSUFBL0QsRUFBcUVBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQXhHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcz80YzIwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XHJcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/nonIterableRest.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\n\nvar assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized.js */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLE9BQU8sR0FBR0Msc0dBQWQ7O0FBRUEsSUFBSUMscUJBQXFCLEdBQUdELG1CQUFPLENBQUMsa0dBQUQsQ0FBbkM7O0FBRUEsU0FBU0UsMEJBQVQsQ0FBb0NDLElBQXBDLEVBQTBDQyxJQUExQyxFQUFnRDtFQUM5QyxJQUFJQSxJQUFJLEtBQUtMLE9BQU8sQ0FBQ0ssSUFBRCxDQUFQLEtBQWtCLFFBQWxCLElBQThCLE9BQU9BLElBQVAsS0FBZ0IsVUFBbkQsQ0FBUixFQUF3RTtJQUN0RSxPQUFPQSxJQUFQO0VBQ0QsQ0FGRCxNQUVPLElBQUlBLElBQUksS0FBSyxLQUFLLENBQWxCLEVBQXFCO0lBQzFCLE1BQU0sSUFBSUMsU0FBSixDQUFjLDBEQUFkLENBQU47RUFDRDs7RUFFRCxPQUFPSixxQkFBcUIsQ0FBQ0UsSUFBRCxDQUE1QjtBQUNEOztBQUVERyxNQUFNLENBQUNDLE9BQVAsR0FBaUJMLDBCQUFqQixFQUE2Q0kseUJBQUEsR0FBNEIsSUFBekUsRUFBK0VBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQWxIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanM/MGViOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XHJcblxyXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzXCIpO1xyXG5cclxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xyXG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XHJcbiAgICByZXR1cm4gY2FsbDtcclxuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwicmVxdWlyZSIsImFzc2VydFRoaXNJbml0aWFsaXplZCIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic2VsZiIsImNhbGwiLCJUeXBlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxDQUF6QixFQUE0QkMsQ0FBNUIsRUFBK0I7RUFDN0JDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkosZUFBZSxHQUFHSyxNQUFNLENBQUNDLGNBQVAsSUFBeUIsU0FBU04sZUFBVCxDQUF5QkMsQ0FBekIsRUFBNEJDLENBQTVCLEVBQStCO0lBQ3pGRCxDQUFDLENBQUNNLFNBQUYsR0FBY0wsQ0FBZDtJQUNBLE9BQU9ELENBQVA7RUFDRCxDQUhELEVBR0dFLHlCQUFBLEdBQTRCLElBSC9CLEVBR3FDQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUh4RTtFQUlBLE9BQU9KLGVBQWUsQ0FBQ0MsQ0FBRCxFQUFJQyxDQUFKLENBQXRCO0FBQ0Q7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkosZUFBakIsRUFBa0NHLHlCQUFBLEdBQTRCLElBQTlELEVBQW9FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF2RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcz8wNTI2Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcclxuICAgIG8uX19wcm90b19fID0gcDtcclxuICAgIHJldHVybiBvO1xyXG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcclxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfc2V0UHJvdG90eXBlT2YiLCJvIiwicCIsIm1vZHVsZSIsImV4cG9ydHMiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/setPrototypeOf.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles.js */ \"./node_modules/@babel/runtime/helpers/arrayWithHoles.js\");\n\nvar iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit.js */ \"./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\");\n\nvar unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ \"./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\");\n\nvar nonIterableRest = __webpack_require__(/*! ./nonIterableRest.js */ \"./node_modules/@babel/runtime/helpers/nonIterableRest.js\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLGNBQWMsR0FBR0MsbUJBQU8sQ0FBQyxvRkFBRCxDQUE1Qjs7QUFFQSxJQUFJQyxvQkFBb0IsR0FBR0QsbUJBQU8sQ0FBQyxnR0FBRCxDQUFsQzs7QUFFQSxJQUFJRSwwQkFBMEIsR0FBR0YsbUJBQU8sQ0FBQyw0R0FBRCxDQUF4Qzs7QUFFQSxJQUFJRyxlQUFlLEdBQUdILG1CQUFPLENBQUMsc0ZBQUQsQ0FBN0I7O0FBRUEsU0FBU0ksY0FBVCxDQUF3QkMsR0FBeEIsRUFBNkJDLENBQTdCLEVBQWdDO0VBQzlCLE9BQU9QLGNBQWMsQ0FBQ00sR0FBRCxDQUFkLElBQXVCSixvQkFBb0IsQ0FBQ0ksR0FBRCxFQUFNQyxDQUFOLENBQTNDLElBQXVESiwwQkFBMEIsQ0FBQ0csR0FBRCxFQUFNQyxDQUFOLENBQWpGLElBQTZGSCxlQUFlLEVBQW5IO0FBQ0Q7O0FBRURJLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkosY0FBakIsRUFBaUNHLHlCQUFBLEdBQTRCLElBQTdELEVBQW1FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF0RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzP2Y1MGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXMuanNcIik7XHJcblxyXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1wiKTtcclxuXHJcbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCIpO1xyXG5cclxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdC5qc1wiKTtcclxuXHJcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xyXG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJhcnJheVdpdGhIb2xlcyIsInJlcXVpcmUiLCJpdGVyYWJsZVRvQXJyYXlMaW1pdCIsInVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5Iiwibm9uSXRlcmFibGVSZXN0IiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJpIiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/slicedToArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(obj);\n}\n\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0I7RUFDcEI7O0VBRUEsT0FBTyxDQUFDQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJILE9BQU8sR0FBRyxjQUFjLE9BQU9JLE1BQXJCLElBQStCLFlBQVksT0FBT0EsTUFBTSxDQUFDQyxRQUF6RCxHQUFvRSxVQUFVSixHQUFWLEVBQWU7SUFDcEgsT0FBTyxPQUFPQSxHQUFkO0VBQ0QsQ0FGa0MsR0FFL0IsVUFBVUEsR0FBVixFQUFlO0lBQ2pCLE9BQU9BLEdBQUcsSUFBSSxjQUFjLE9BQU9HLE1BQTVCLElBQXNDSCxHQUFHLENBQUNLLFdBQUosS0FBb0JGLE1BQTFELElBQW9FSCxHQUFHLEtBQUtHLE1BQU0sQ0FBQ0csU0FBbkYsR0FBK0YsUUFBL0YsR0FBMEcsT0FBT04sR0FBeEg7RUFDRCxDQUpPLEVBSUxDLHlCQUFBLEdBQTRCLElBSnZCLEVBSTZCQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUpqRSxHQUkyRUgsT0FBTyxDQUFDQyxHQUFELENBSnpGO0FBS0Q7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkgsT0FBakIsRUFBMEJFLHlCQUFBLEdBQTRCLElBQXRELEVBQTREQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUEvRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanM/ZjMzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xyXG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcclxuXHJcbiAgcmV0dXJuIChtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcclxuICB9IDogZnVuY3Rpb24gKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcclxuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMpLCBfdHlwZW9mKG9iaik7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwib2JqIiwibW9kdWxlIiwiZXhwb3J0cyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/typeof.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ \"./node_modules/@babel/runtime/helpers/arrayLikeToArray.js\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxnQkFBZ0IsR0FBR0MsbUJBQU8sQ0FBQyx3RkFBRCxDQUE5Qjs7QUFFQSxTQUFTQywyQkFBVCxDQUFxQ0MsQ0FBckMsRUFBd0NDLE1BQXhDLEVBQWdEO0VBQzlDLElBQUksQ0FBQ0QsQ0FBTCxFQUFRO0VBQ1IsSUFBSSxPQUFPQSxDQUFQLEtBQWEsUUFBakIsRUFBMkIsT0FBT0gsZ0JBQWdCLENBQUNHLENBQUQsRUFBSUMsTUFBSixDQUF2QjtFQUMzQixJQUFJQyxDQUFDLEdBQUdDLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkMsUUFBakIsQ0FBMEJDLElBQTFCLENBQStCTixDQUEvQixFQUFrQ08sS0FBbEMsQ0FBd0MsQ0FBeEMsRUFBMkMsQ0FBQyxDQUE1QyxDQUFSO0VBQ0EsSUFBSUwsQ0FBQyxLQUFLLFFBQU4sSUFBa0JGLENBQUMsQ0FBQ1EsV0FBeEIsRUFBcUNOLENBQUMsR0FBR0YsQ0FBQyxDQUFDUSxXQUFGLENBQWNDLElBQWxCO0VBQ3JDLElBQUlQLENBQUMsS0FBSyxLQUFOLElBQWVBLENBQUMsS0FBSyxLQUF6QixFQUFnQyxPQUFPUSxLQUFLLENBQUNDLElBQU4sQ0FBV1gsQ0FBWCxDQUFQO0VBQ2hDLElBQUlFLENBQUMsS0FBSyxXQUFOLElBQXFCLDJDQUEyQ1UsSUFBM0MsQ0FBZ0RWLENBQWhELENBQXpCLEVBQTZFLE9BQU9MLGdCQUFnQixDQUFDRyxDQUFELEVBQUlDLE1BQUosQ0FBdkI7QUFDOUU7O0FBRURZLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQmYsMkJBQWpCLEVBQThDYyx5QkFBQSxHQUE0QixJQUExRSxFQUFnRkEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBbkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanM/ZGE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XHJcblxyXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XHJcbiAgaWYgKCFvKSByZXR1cm47XHJcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xyXG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcclxuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xyXG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJhcnJheUxpa2VUb0FycmF5IiwicmVxdWlyZSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm8iLCJtaW5MZW4iLCJuIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/wrapNativeSuper.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\n\nvar setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nvar isNativeFunction = __webpack_require__(/*! ./isNativeFunction.js */ \"./node_modules/@babel/runtime/helpers/isNativeFunction.js\");\n\nvar construct = __webpack_require__(/*! ./construct.js */ \"./node_modules/@babel/runtime/helpers/construct.js\");\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _wrapNativeSuper(Class);\n}\n\nmodule.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsY0FBYyxHQUFHQyxtQkFBTyxDQUFDLG9GQUFELENBQTVCOztBQUVBLElBQUlDLGNBQWMsR0FBR0QsbUJBQU8sQ0FBQyxvRkFBRCxDQUE1Qjs7QUFFQSxJQUFJRSxnQkFBZ0IsR0FBR0YsbUJBQU8sQ0FBQyx3RkFBRCxDQUE5Qjs7QUFFQSxJQUFJRyxTQUFTLEdBQUdILG1CQUFPLENBQUMsMEVBQUQsQ0FBdkI7O0FBRUEsU0FBU0ksZ0JBQVQsQ0FBMEJDLEtBQTFCLEVBQWlDO0VBQy9CLElBQUlDLE1BQU0sR0FBRyxPQUFPQyxHQUFQLEtBQWUsVUFBZixHQUE0QixJQUFJQSxHQUFKLEVBQTVCLEdBQXdDQyxTQUFyRDs7RUFFQUMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCTixnQkFBZ0IsR0FBRyxTQUFTQSxnQkFBVCxDQUEwQkMsS0FBMUIsRUFBaUM7SUFDbkUsSUFBSUEsS0FBSyxLQUFLLElBQVYsSUFBa0IsQ0FBQ0gsZ0JBQWdCLENBQUNHLEtBQUQsQ0FBdkMsRUFBZ0QsT0FBT0EsS0FBUDs7SUFFaEQsSUFBSSxPQUFPQSxLQUFQLEtBQWlCLFVBQXJCLEVBQWlDO01BQy9CLE1BQU0sSUFBSU0sU0FBSixDQUFjLG9EQUFkLENBQU47SUFDRDs7SUFFRCxJQUFJLE9BQU9MLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7TUFDakMsSUFBSUEsTUFBTSxDQUFDTSxHQUFQLENBQVdQLEtBQVgsQ0FBSixFQUF1QixPQUFPQyxNQUFNLENBQUNPLEdBQVAsQ0FBV1IsS0FBWCxDQUFQOztNQUV2QkMsTUFBTSxDQUFDUSxHQUFQLENBQVdULEtBQVgsRUFBa0JVLE9BQWxCO0lBQ0Q7O0lBRUQsU0FBU0EsT0FBVCxHQUFtQjtNQUNqQixPQUFPWixTQUFTLENBQUNFLEtBQUQsRUFBUVcsU0FBUixFQUFtQmpCLGNBQWMsQ0FBQyxJQUFELENBQWQsQ0FBcUJrQixXQUF4QyxDQUFoQjtJQUNEOztJQUVERixPQUFPLENBQUNHLFNBQVIsR0FBb0JDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjZixLQUFLLENBQUNhLFNBQXBCLEVBQStCO01BQ2pERCxXQUFXLEVBQUU7UUFDWEksS0FBSyxFQUFFTixPQURJO1FBRVhPLFVBQVUsRUFBRSxLQUZEO1FBR1hDLFFBQVEsRUFBRSxJQUhDO1FBSVhDLFlBQVksRUFBRTtNQUpIO0lBRG9DLENBQS9CLENBQXBCO0lBUUEsT0FBT3ZCLGNBQWMsQ0FBQ2MsT0FBRCxFQUFVVixLQUFWLENBQXJCO0VBQ0QsQ0ExQkQsRUEwQkdJLHlCQUFBLEdBQTRCLElBMUIvQixFQTBCcUNBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BMUJ4RTtFQTJCQSxPQUFPTixnQkFBZ0IsQ0FBQ0MsS0FBRCxDQUF2QjtBQUNEOztBQUVESSxNQUFNLENBQUNDLE9BQVAsR0FBaUJOLGdCQUFqQixFQUFtQ0sseUJBQUEsR0FBNEIsSUFBL0QsRUFBcUVBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQXhHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlci5qcz9mNTIxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mLmpzXCIpO1xyXG5cclxudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2YuanNcIik7XHJcblxyXG52YXIgaXNOYXRpdmVGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2lzTmF0aXZlRnVuY3Rpb24uanNcIik7XHJcblxyXG52YXIgY29uc3RydWN0ID0gcmVxdWlyZShcIi4vY29uc3RydWN0LmpzXCIpO1xyXG5cclxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xyXG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XHJcblxyXG4gIG1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcclxuICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcclxuXHJcbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xyXG5cclxuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcclxuICAgICAgcmV0dXJuIGNvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBnZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XHJcbiAgICB9XHJcblxyXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xyXG4gICAgICBjb25zdHJ1Y3Rvcjoge1xyXG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XHJcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xyXG4gIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfd3JhcE5hdGl2ZVN1cGVyLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbImdldFByb3RvdHlwZU9mIiwicmVxdWlyZSIsInNldFByb3RvdHlwZU9mIiwiaXNOYXRpdmVGdW5jdGlvbiIsImNvbnN0cnVjdCIsIl93cmFwTmF0aXZlU3VwZXIiLCJDbGFzcyIsIl9jYWNoZSIsIk1hcCIsInVuZGVmaW5lZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJUeXBlRXJyb3IiLCJoYXMiLCJnZXQiLCJzZXQiLCJXcmFwcGVyIiwiYXJndW1lbnRzIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/wrapNativeSuper.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUFBLGdIQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcz84MTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XHJcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/regenerator/index.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/client/_utils.js":
/*!*************************************************!*\
  !*** ./node_modules/next-auth/client/_utils.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BroadcastChannel = BroadcastChannel;\nexports.apiBaseUrl = apiBaseUrl;\nexports.fetchData = fetchData;\nexports.now = now;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction fetchData(_x, _x2, _x3) {\n  return _fetchData.apply(this, arguments);\n}\n\nfunction _fetchData() {\n  _fetchData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(path, __NEXTAUTH, logger) {\n    var _ref,\n        ctx,\n        _ref$req,\n        req,\n        url,\n        options,\n        res,\n        data,\n        _args = arguments;\n\n    return _regenerator.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref = _args.length > 3 && _args[3] !== undefined ? _args[3] : {}, ctx = _ref.ctx, _ref$req = _ref.req, req = _ref$req === void 0 ? ctx === null || ctx === void 0 ? void 0 : ctx.req : _ref$req;\n            url = \"\".concat(apiBaseUrl(__NEXTAUTH), \"/\").concat(path);\n            _context.prev = 2;\n            options = req !== null && req !== void 0 && req.headers.cookie ? {\n              headers: {\n                cookie: req.headers.cookie\n              }\n            } : {};\n            _context.next = 6;\n            return fetch(url, options);\n\n          case 6:\n            res = _context.sent;\n            _context.next = 9;\n            return res.json();\n\n          case 9:\n            data = _context.sent;\n\n            if (res.ok) {\n              _context.next = 12;\n              break;\n            }\n\n            throw data;\n\n          case 12:\n            return _context.abrupt(\"return\", Object.keys(data).length > 0 ? data : null);\n\n          case 15:\n            _context.prev = 15;\n            _context.t0 = _context[\"catch\"](2);\n            logger.error(\"CLIENT_FETCH_ERROR\", {\n              error: _context.t0,\n              url: url\n            });\n            return _context.abrupt(\"return\", null);\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[2, 15]]);\n  }));\n  return _fetchData.apply(this, arguments);\n}\n\nfunction apiBaseUrl(__NEXTAUTH) {\n  if (typeof window === \"undefined\") {\n    return \"\".concat(__NEXTAUTH.baseUrlServer).concat(__NEXTAUTH.basePathServer);\n  }\n\n  return __NEXTAUTH.basePath;\n}\n\nfunction now() {\n  return Math.floor(Date.now() / 1000);\n}\n\nfunction BroadcastChannel() {\n  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"nextauth.message\";\n  return {\n    receive: function receive(onReceive) {\n      var handler = function handler(event) {\n        var _event$newValue;\n\n        if (event.key !== name) return;\n        var message = JSON.parse((_event$newValue = event.newValue) !== null && _event$newValue !== void 0 ? _event$newValue : \"{}\");\n        if ((message === null || message === void 0 ? void 0 : message.event) !== \"session\" || !(message !== null && message !== void 0 && message.data)) return;\n        onReceive(message);\n      };\n\n      window.addEventListener(\"storage\", handler);\n      return function () {\n        return window.removeEventListener(\"storage\", handler);\n      };\n    },\n    post: function post(message) {\n      if (typeof window === \"undefined\") return;\n      localStorage.setItem(name, JSON.stringify(_objectSpread(_objectSpread({}, message), {}, {\n        timestamp: now()\n      })));\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2NsaWVudC9fdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSUEsc0JBQXNCLEdBQUdDLG1CQUFPLENBQUMsb0hBQUQsQ0FBcEM7O0FBRUFDLDhDQUE2QztFQUMzQ0csS0FBSyxFQUFFO0FBRG9DLENBQTdDO0FBR0FELHdCQUFBLEdBQTJCRSxnQkFBM0I7QUFDQUYsa0JBQUEsR0FBcUJHLFVBQXJCO0FBQ0FILGlCQUFBLEdBQW9CSSxTQUFwQjtBQUNBSixXQUFBLEdBQWNLLEdBQWQ7O0FBRUEsSUFBSUMsWUFBWSxHQUFHVixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxzRkFBRCxDQUFSLENBQXpDOztBQUVBLElBQUlVLGdCQUFnQixHQUFHWCxzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxzR0FBRCxDQUFSLENBQTdDOztBQUVBLElBQUlXLGtCQUFrQixHQUFHWixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQywwR0FBRCxDQUFSLENBQS9DOztBQUVBLFNBQVNZLE9BQVQsQ0FBaUJDLE1BQWpCLEVBQXlCQyxjQUF6QixFQUF5QztFQUFFLElBQUlDLElBQUksR0FBR2QsTUFBTSxDQUFDYyxJQUFQLENBQVlGLE1BQVosQ0FBWDs7RUFBZ0MsSUFBSVosTUFBTSxDQUFDZSxxQkFBWCxFQUFrQztJQUFFLElBQUlDLE9BQU8sR0FBR2hCLE1BQU0sQ0FBQ2UscUJBQVAsQ0FBNkJILE1BQTdCLENBQWQ7SUFBb0RDLGNBQWMsS0FBS0csT0FBTyxHQUFHQSxPQUFPLENBQUNDLE1BQVIsQ0FBZSxVQUFVQyxHQUFWLEVBQWU7TUFBRSxPQUFPbEIsTUFBTSxDQUFDbUIsd0JBQVAsQ0FBZ0NQLE1BQWhDLEVBQXdDTSxHQUF4QyxFQUE2Q0UsVUFBcEQ7SUFBaUUsQ0FBakcsQ0FBZixDQUFkLEVBQWtJTixJQUFJLENBQUNPLElBQUwsQ0FBVUMsS0FBVixDQUFnQlIsSUFBaEIsRUFBc0JFLE9BQXRCLENBQWxJO0VBQW1LOztFQUFDLE9BQU9GLElBQVA7QUFBYzs7QUFFclYsU0FBU1MsYUFBVCxDQUF1QkMsTUFBdkIsRUFBK0I7RUFBRSxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdDLFNBQVMsQ0FBQ0MsTUFBOUIsRUFBc0NGLENBQUMsRUFBdkMsRUFBMkM7SUFBRSxJQUFJRyxNQUFNLEdBQUcsUUFBUUYsU0FBUyxDQUFDRCxDQUFELENBQWpCLEdBQXVCQyxTQUFTLENBQUNELENBQUQsQ0FBaEMsR0FBc0MsRUFBbkQ7SUFBdURBLENBQUMsR0FBRyxDQUFKLEdBQVFkLE9BQU8sQ0FBQ1gsTUFBTSxDQUFDNEIsTUFBRCxDQUFQLEVBQWlCLENBQUMsQ0FBbEIsQ0FBUCxDQUE0QkMsT0FBNUIsQ0FBb0MsVUFBVUMsR0FBVixFQUFlO01BQUUsQ0FBQyxHQUFHckIsZ0JBQWdCLENBQUNzQixPQUFyQixFQUE4QlAsTUFBOUIsRUFBc0NNLEdBQXRDLEVBQTJDRixNQUFNLENBQUNFLEdBQUQsQ0FBakQ7SUFBMEQsQ0FBL0csQ0FBUixHQUEySDlCLE1BQU0sQ0FBQ2dDLHlCQUFQLEdBQW1DaEMsTUFBTSxDQUFDaUMsZ0JBQVAsQ0FBd0JULE1BQXhCLEVBQWdDeEIsTUFBTSxDQUFDZ0MseUJBQVAsQ0FBaUNKLE1BQWpDLENBQWhDLENBQW5DLEdBQStHakIsT0FBTyxDQUFDWCxNQUFNLENBQUM0QixNQUFELENBQVAsQ0FBUCxDQUF3QkMsT0FBeEIsQ0FBZ0MsVUFBVUMsR0FBVixFQUFlO01BQUU5QixNQUFNLENBQUNDLGNBQVAsQ0FBc0J1QixNQUF0QixFQUE4Qk0sR0FBOUIsRUFBbUM5QixNQUFNLENBQUNtQix3QkFBUCxDQUFnQ1MsTUFBaEMsRUFBd0NFLEdBQXhDLENBQW5DO0lBQW1GLENBQXBJLENBQTFPO0VBQWtYOztFQUFDLE9BQU9OLE1BQVA7QUFBZ0I7O0FBRXhnQixTQUFTbEIsU0FBVCxDQUFtQjRCLEVBQW5CLEVBQXVCQyxHQUF2QixFQUE0QkMsR0FBNUIsRUFBaUM7RUFDL0IsT0FBT0MsVUFBVSxDQUFDZixLQUFYLENBQWlCLElBQWpCLEVBQXVCSSxTQUF2QixDQUFQO0FBQ0Q7O0FBRUQsU0FBU1csVUFBVCxHQUFzQjtFQUNwQkEsVUFBVSxHQUFHLENBQUMsR0FBRzNCLGtCQUFrQixDQUFDcUIsT0FBdkIsRUFBZ0N2QixZQUFZLENBQUN1QixPQUFiLENBQXFCTyxJQUFyQixDQUEwQixTQUFTQyxPQUFULENBQWlCQyxJQUFqQixFQUF1QkMsVUFBdkIsRUFBbUNDLE1BQW5DLEVBQTJDO0lBQ2hILElBQUlDLElBQUo7SUFBQSxJQUNJQyxHQURKO0lBQUEsSUFFSUMsUUFGSjtJQUFBLElBR0lDLEdBSEo7SUFBQSxJQUlJQyxHQUpKO0lBQUEsSUFLSUMsT0FMSjtJQUFBLElBTUlDLEdBTko7SUFBQSxJQU9JQyxJQVBKO0lBQUEsSUFRSUMsS0FBSyxHQUFHekIsU0FSWjs7SUFVQSxPQUFPbEIsWUFBWSxDQUFDdUIsT0FBYixDQUFxQnFCLElBQXJCLENBQTBCLFNBQVNDLFFBQVQsQ0FBa0JDLFFBQWxCLEVBQTRCO01BQzNELE9BQU8sQ0FBUCxFQUFVO1FBQ1IsUUFBUUEsUUFBUSxDQUFDQyxJQUFULEdBQWdCRCxRQUFRLENBQUNFLElBQWpDO1VBQ0UsS0FBSyxDQUFMO1lBQ0ViLElBQUksR0FBR1EsS0FBSyxDQUFDeEIsTUFBTixHQUFlLENBQWYsSUFBb0J3QixLQUFLLENBQUMsQ0FBRCxDQUFMLEtBQWFNLFNBQWpDLEdBQTZDTixLQUFLLENBQUMsQ0FBRCxDQUFsRCxHQUF3RCxFQUEvRCxFQUFtRVAsR0FBRyxHQUFHRCxJQUFJLENBQUNDLEdBQTlFLEVBQW1GQyxRQUFRLEdBQUdGLElBQUksQ0FBQ0csR0FBbkcsRUFBd0dBLEdBQUcsR0FBR0QsUUFBUSxLQUFLLEtBQUssQ0FBbEIsR0FBc0JELEdBQUcsS0FBSyxJQUFSLElBQWdCQSxHQUFHLEtBQUssS0FBSyxDQUE3QixHQUFpQyxLQUFLLENBQXRDLEdBQTBDQSxHQUFHLENBQUNFLEdBQXBFLEdBQTBFRCxRQUF4TDtZQUNBRSxHQUFHLEdBQUcsR0FBR1csTUFBSCxDQUFVckQsVUFBVSxDQUFDb0MsVUFBRCxDQUFwQixFQUFrQyxHQUFsQyxFQUF1Q2lCLE1BQXZDLENBQThDbEIsSUFBOUMsQ0FBTjtZQUNBYyxRQUFRLENBQUNDLElBQVQsR0FBZ0IsQ0FBaEI7WUFDQVAsT0FBTyxHQUFHRixHQUFHLEtBQUssSUFBUixJQUFnQkEsR0FBRyxLQUFLLEtBQUssQ0FBN0IsSUFBa0NBLEdBQUcsQ0FBQ2EsT0FBSixDQUFZQyxNQUE5QyxHQUF1RDtjQUMvREQsT0FBTyxFQUFFO2dCQUNQQyxNQUFNLEVBQUVkLEdBQUcsQ0FBQ2EsT0FBSixDQUFZQztjQURiO1lBRHNELENBQXZELEdBSU4sRUFKSjtZQUtBTixRQUFRLENBQUNFLElBQVQsR0FBZ0IsQ0FBaEI7WUFDQSxPQUFPSyxLQUFLLENBQUNkLEdBQUQsRUFBTUMsT0FBTixDQUFaOztVQUVGLEtBQUssQ0FBTDtZQUNFQyxHQUFHLEdBQUdLLFFBQVEsQ0FBQ1EsSUFBZjtZQUNBUixRQUFRLENBQUNFLElBQVQsR0FBZ0IsQ0FBaEI7WUFDQSxPQUFPUCxHQUFHLENBQUNjLElBQUosRUFBUDs7VUFFRixLQUFLLENBQUw7WUFDRWIsSUFBSSxHQUFHSSxRQUFRLENBQUNRLElBQWhCOztZQUVBLElBQUliLEdBQUcsQ0FBQ2UsRUFBUixFQUFZO2NBQ1ZWLFFBQVEsQ0FBQ0UsSUFBVCxHQUFnQixFQUFoQjtjQUNBO1lBQ0Q7O1lBRUQsTUFBTU4sSUFBTjs7VUFFRixLQUFLLEVBQUw7WUFDRSxPQUFPSSxRQUFRLENBQUNXLE1BQVQsQ0FBZ0IsUUFBaEIsRUFBMEJqRSxNQUFNLENBQUNjLElBQVAsQ0FBWW9DLElBQVosRUFBa0J2QixNQUFsQixHQUEyQixDQUEzQixHQUErQnVCLElBQS9CLEdBQXNDLElBQWhFLENBQVA7O1VBRUYsS0FBSyxFQUFMO1lBQ0VJLFFBQVEsQ0FBQ0MsSUFBVCxHQUFnQixFQUFoQjtZQUNBRCxRQUFRLENBQUNZLEVBQVQsR0FBY1osUUFBUSxDQUFDLE9BQUQsQ0FBUixDQUFrQixDQUFsQixDQUFkO1lBQ0FaLE1BQU0sQ0FBQ3lCLEtBQVAsQ0FBYSxvQkFBYixFQUFtQztjQUNqQ0EsS0FBSyxFQUFFYixRQUFRLENBQUNZLEVBRGlCO2NBRWpDbkIsR0FBRyxFQUFFQTtZQUY0QixDQUFuQztZQUlBLE9BQU9PLFFBQVEsQ0FBQ1csTUFBVCxDQUFnQixRQUFoQixFQUEwQixJQUExQixDQUFQOztVQUVGLEtBQUssRUFBTDtVQUNBLEtBQUssS0FBTDtZQUNFLE9BQU9YLFFBQVEsQ0FBQ2MsSUFBVCxFQUFQO1FBMUNKO01BNENEO0lBQ0YsQ0EvQ00sRUErQ0o3QixPQS9DSSxFQStDSyxJQS9DTCxFQStDVyxDQUFDLENBQUMsQ0FBRCxFQUFJLEVBQUosQ0FBRCxDQS9DWCxDQUFQO0VBZ0RELENBM0Q0QyxDQUFoQyxDQUFiO0VBNERBLE9BQU9GLFVBQVUsQ0FBQ2YsS0FBWCxDQUFpQixJQUFqQixFQUF1QkksU0FBdkIsQ0FBUDtBQUNEOztBQUVELFNBQVNyQixVQUFULENBQW9Cb0MsVUFBcEIsRUFBZ0M7RUFDOUIsSUFBSSxPQUFPNEIsTUFBUCxLQUFrQixXQUF0QixFQUFtQztJQUNqQyxPQUFPLEdBQUdYLE1BQUgsQ0FBVWpCLFVBQVUsQ0FBQzZCLGFBQXJCLEVBQW9DWixNQUFwQyxDQUEyQ2pCLFVBQVUsQ0FBQzhCLGNBQXRELENBQVA7RUFDRDs7RUFFRCxPQUFPOUIsVUFBVSxDQUFDK0IsUUFBbEI7QUFDRDs7QUFFRCxTQUFTakUsR0FBVCxHQUFlO0VBQ2IsT0FBT2tFLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxJQUFJLENBQUNwRSxHQUFMLEtBQWEsSUFBeEIsQ0FBUDtBQUNEOztBQUVELFNBQVNILGdCQUFULEdBQTRCO0VBQzFCLElBQUl3RSxJQUFJLEdBQUdsRCxTQUFTLENBQUNDLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JELFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIrQixTQUF6QyxHQUFxRC9CLFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLGtCQUEvRTtFQUNBLE9BQU87SUFDTG1ELE9BQU8sRUFBRSxTQUFTQSxPQUFULENBQWlCQyxTQUFqQixFQUE0QjtNQUNuQyxJQUFJQyxPQUFPLEdBQUcsU0FBU0EsT0FBVCxDQUFpQkMsS0FBakIsRUFBd0I7UUFDcEMsSUFBSUMsZUFBSjs7UUFFQSxJQUFJRCxLQUFLLENBQUNsRCxHQUFOLEtBQWM4QyxJQUFsQixFQUF3QjtRQUN4QixJQUFJTSxPQUFPLEdBQUdDLElBQUksQ0FBQ0MsS0FBTCxDQUFXLENBQUNILGVBQWUsR0FBR0QsS0FBSyxDQUFDSyxRQUF6QixNQUF1QyxJQUF2QyxJQUErQ0osZUFBZSxLQUFLLEtBQUssQ0FBeEUsR0FBNEVBLGVBQTVFLEdBQThGLElBQXpHLENBQWQ7UUFDQSxJQUFJLENBQUNDLE9BQU8sS0FBSyxJQUFaLElBQW9CQSxPQUFPLEtBQUssS0FBSyxDQUFyQyxHQUF5QyxLQUFLLENBQTlDLEdBQWtEQSxPQUFPLENBQUNGLEtBQTNELE1BQXNFLFNBQXRFLElBQW1GLEVBQUVFLE9BQU8sS0FBSyxJQUFaLElBQW9CQSxPQUFPLEtBQUssS0FBSyxDQUFyQyxJQUEwQ0EsT0FBTyxDQUFDaEMsSUFBcEQsQ0FBdkYsRUFBa0o7UUFDbEo0QixTQUFTLENBQUNJLE9BQUQsQ0FBVDtNQUNELENBUEQ7O01BU0FiLE1BQU0sQ0FBQ2lCLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DUCxPQUFuQztNQUNBLE9BQU8sWUFBWTtRQUNqQixPQUFPVixNQUFNLENBQUNrQixtQkFBUCxDQUEyQixTQUEzQixFQUFzQ1IsT0FBdEMsQ0FBUDtNQUNELENBRkQ7SUFHRCxDQWZJO0lBZ0JMUyxJQUFJLEVBQUUsU0FBU0EsSUFBVCxDQUFjTixPQUFkLEVBQXVCO01BQzNCLElBQUksT0FBT2IsTUFBUCxLQUFrQixXQUF0QixFQUFtQztNQUNuQ29CLFlBQVksQ0FBQ0MsT0FBYixDQUFxQmQsSUFBckIsRUFBMkJPLElBQUksQ0FBQ1EsU0FBTCxDQUFlcEUsYUFBYSxDQUFDQSxhQUFhLENBQUMsRUFBRCxFQUFLMkQsT0FBTCxDQUFkLEVBQTZCLEVBQTdCLEVBQWlDO1FBQ3RGVSxTQUFTLEVBQUVyRixHQUFHO01BRHdFLENBQWpDLENBQTVCLENBQTNCO0lBR0Q7RUFyQkksQ0FBUDtBQXVCRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2NsaWVudC9fdXRpbHMuanM/MGRhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuQnJvYWRjYXN0Q2hhbm5lbCA9IEJyb2FkY2FzdENoYW5uZWw7XHJcbmV4cG9ydHMuYXBpQmFzZVVybCA9IGFwaUJhc2VVcmw7XHJcbmV4cG9ydHMuZmV0Y2hEYXRhID0gZmV0Y2hEYXRhO1xyXG5leHBvcnRzLm5vdyA9IG5vdztcclxuXHJcbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XHJcblxyXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xyXG5cclxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XHJcblxyXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxyXG5cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5cclxuZnVuY3Rpb24gZmV0Y2hEYXRhKF94LCBfeDIsIF94Mykge1xyXG4gIHJldHVybiBfZmV0Y2hEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9mZXRjaERhdGEoKSB7XHJcbiAgX2ZldGNoRGF0YSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKHBhdGgsIF9fTkVYVEFVVEgsIGxvZ2dlcikge1xyXG4gICAgdmFyIF9yZWYsXHJcbiAgICAgICAgY3R4LFxyXG4gICAgICAgIF9yZWYkcmVxLFxyXG4gICAgICAgIHJlcSxcclxuICAgICAgICB1cmwsXHJcbiAgICAgICAgb3B0aW9ucyxcclxuICAgICAgICByZXMsXHJcbiAgICAgICAgZGF0YSxcclxuICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcclxuXHJcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xyXG4gICAgICB3aGlsZSAoMSkge1xyXG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcclxuICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgX3JlZiA9IF9hcmdzLmxlbmd0aCA+IDMgJiYgX2FyZ3NbM10gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzNdIDoge30sIGN0eCA9IF9yZWYuY3R4LCBfcmVmJHJlcSA9IF9yZWYucmVxLCByZXEgPSBfcmVmJHJlcSA9PT0gdm9pZCAwID8gY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnJlcSA6IF9yZWYkcmVxO1xyXG4gICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdChhcGlCYXNlVXJsKF9fTkVYVEFVVEgpLCBcIi9cIikuY29uY2F0KHBhdGgpO1xyXG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlcSAhPT0gbnVsbCAmJiByZXEgIT09IHZvaWQgMCAmJiByZXEuaGVhZGVycy5jb29raWUgPyB7XHJcbiAgICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgY29va2llOiByZXEuaGVhZGVycy5jb29raWVcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gOiB7fTtcclxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XHJcbiAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQuc2VudDtcclxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXMuanNvbigpO1xyXG5cclxuICAgICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0LnNlbnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzLm9rKSB7XHJcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aHJvdyBkYXRhO1xyXG5cclxuICAgICAgICAgIGNhc2UgMTI6XHJcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgT2JqZWN0LmtleXMoZGF0YSkubGVuZ3RoID4gMCA/IGRhdGEgOiBudWxsKTtcclxuXHJcbiAgICAgICAgICBjYXNlIDE1OlxyXG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTU7XHJcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgyKTtcclxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiQ0xJRU5UX0ZFVENIX0VSUk9SXCIsIHtcclxuICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQudDAsXHJcbiAgICAgICAgICAgICAgdXJsOiB1cmxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XHJcblxyXG4gICAgICAgICAgY2FzZSAxOTpcclxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcclxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMiwgMTVdXSk7XHJcbiAgfSkpO1xyXG4gIHJldHVybiBfZmV0Y2hEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwaUJhc2VVcmwoX19ORVhUQVVUSCkge1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoX19ORVhUQVVUSC5iYXNlVXJsU2VydmVyKS5jb25jYXQoX19ORVhUQVVUSC5iYXNlUGF0aFNlcnZlcik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gX19ORVhUQVVUSC5iYXNlUGF0aDtcclxufVxyXG5cclxuZnVuY3Rpb24gbm93KCkge1xyXG4gIHJldHVybiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gQnJvYWRjYXN0Q2hhbm5lbCgpIHtcclxuICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJuZXh0YXV0aC5tZXNzYWdlXCI7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlY2VpdmU6IGZ1bmN0aW9uIHJlY2VpdmUob25SZWNlaXZlKSB7XHJcbiAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xyXG4gICAgICAgIHZhciBfZXZlbnQkbmV3VmFsdWU7XHJcblxyXG4gICAgICAgIGlmIChldmVudC5rZXkgIT09IG5hbWUpIHJldHVybjtcclxuICAgICAgICB2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoKF9ldmVudCRuZXdWYWx1ZSA9IGV2ZW50Lm5ld1ZhbHVlKSAhPT0gbnVsbCAmJiBfZXZlbnQkbmV3VmFsdWUgIT09IHZvaWQgMCA/IF9ldmVudCRuZXdWYWx1ZSA6IFwie31cIik7XHJcbiAgICAgICAgaWYgKChtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2UuZXZlbnQpICE9PSBcInNlc3Npb25cIiB8fCAhKG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwICYmIG1lc3NhZ2UuZGF0YSkpIHJldHVybjtcclxuICAgICAgICBvblJlY2VpdmUobWVzc2FnZSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInN0b3JhZ2VcIiwgaGFuZGxlcik7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwic3RvcmFnZVwiLCBoYW5kbGVyKTtcclxuICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBwb3N0OiBmdW5jdGlvbiBwb3N0KG1lc3NhZ2UpIHtcclxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obmFtZSwgSlNPTi5zdHJpbmdpZnkoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBtZXNzYWdlKSwge30sIHtcclxuICAgICAgICB0aW1lc3RhbXA6IG5vdygpXHJcbiAgICAgIH0pKSk7XHJcbiAgICB9XHJcbiAgfTtcclxufSJdLCJuYW1lcyI6WyJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQnJvYWRjYXN0Q2hhbm5lbCIsImFwaUJhc2VVcmwiLCJmZXRjaERhdGEiLCJub3ciLCJfcmVnZW5lcmF0b3IiLCJfZGVmaW5lUHJvcGVydHkyIiwiX2FzeW5jVG9HZW5lcmF0b3IyIiwib3duS2V5cyIsIm9iamVjdCIsImVudW1lcmFibGVPbmx5Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJmb3JFYWNoIiwia2V5IiwiZGVmYXVsdCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3giLCJfeDIiLCJfeDMiLCJfZmV0Y2hEYXRhIiwibWFyayIsIl9jYWxsZWUiLCJwYXRoIiwiX19ORVhUQVVUSCIsImxvZ2dlciIsIl9yZWYiLCJjdHgiLCJfcmVmJHJlcSIsInJlcSIsInVybCIsIm9wdGlvbnMiLCJyZXMiLCJkYXRhIiwiX2FyZ3MiLCJ3cmFwIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsInByZXYiLCJuZXh0IiwidW5kZWZpbmVkIiwiY29uY2F0IiwiaGVhZGVycyIsImNvb2tpZSIsImZldGNoIiwic2VudCIsImpzb24iLCJvayIsImFicnVwdCIsInQwIiwiZXJyb3IiLCJzdG9wIiwid2luZG93IiwiYmFzZVVybFNlcnZlciIsImJhc2VQYXRoU2VydmVyIiwiYmFzZVBhdGgiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIiwibmFtZSIsInJlY2VpdmUiLCJvblJlY2VpdmUiLCJoYW5kbGVyIiwiZXZlbnQiLCJfZXZlbnQkbmV3VmFsdWUiLCJtZXNzYWdlIiwiSlNPTiIsInBhcnNlIiwibmV3VmFsdWUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInBvc3QiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwidGltZXN0YW1wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next-auth/client/_utils.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/core/errors.js":
/*!***********************************************!*\
  !*** ./node_modules/next-auth/core/errors.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.UnsupportedStrategy = exports.UnknownError = exports.OAuthCallbackError = exports.MissingSecret = exports.MissingAuthorize = exports.MissingAdapter = exports.MissingAPIRoute = exports.InvalidCallbackUrl = exports.AccountNotLinkedError = void 0;\nexports.adapterErrorHandler = adapterErrorHandler;\nexports.capitalize = capitalize;\nexports.eventsErrorHandler = eventsErrorHandler;\nexports.upperSnake = upperSnake;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ \"./node_modules/@babel/runtime/helpers/wrapNativeSuper.js\"));\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar UnknownError = function (_Error) {\n  (0, _inherits2.default)(UnknownError, _Error);\n\n  var _super = _createSuper(UnknownError);\n\n  function UnknownError(error) {\n    var _message;\n\n    var _this;\n\n    (0, _classCallCheck2.default)(this, UnknownError);\n    _this = _super.call(this, (_message = error === null || error === void 0 ? void 0 : error.message) !== null && _message !== void 0 ? _message : error);\n    _this.name = \"UnknownError\";\n    _this.code = error.code;\n\n    if (error instanceof Error) {\n      _this.stack = error.stack;\n    }\n\n    return _this;\n  }\n\n  (0, _createClass2.default)(UnknownError, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        name: this.name,\n        message: this.message,\n        stack: this.stack\n      };\n    }\n  }]);\n  return UnknownError;\n}((0, _wrapNativeSuper2.default)(Error));\n\nexports.UnknownError = UnknownError;\n\nvar OAuthCallbackError = function (_UnknownError) {\n  (0, _inherits2.default)(OAuthCallbackError, _UnknownError);\n\n  var _super2 = _createSuper(OAuthCallbackError);\n\n  function OAuthCallbackError() {\n    var _this2;\n\n    (0, _classCallCheck2.default)(this, OAuthCallbackError);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this2 = _super2.call.apply(_super2, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), \"name\", \"OAuthCallbackError\");\n    return _this2;\n  }\n\n  return (0, _createClass2.default)(OAuthCallbackError);\n}(UnknownError);\n\nexports.OAuthCallbackError = OAuthCallbackError;\n\nvar AccountNotLinkedError = function (_UnknownError2) {\n  (0, _inherits2.default)(AccountNotLinkedError, _UnknownError2);\n\n  var _super3 = _createSuper(AccountNotLinkedError);\n\n  function AccountNotLinkedError() {\n    var _this3;\n\n    (0, _classCallCheck2.default)(this, AccountNotLinkedError);\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    _this3 = _super3.call.apply(_super3, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this3), \"name\", \"AccountNotLinkedError\");\n    return _this3;\n  }\n\n  return (0, _createClass2.default)(AccountNotLinkedError);\n}(UnknownError);\n\nexports.AccountNotLinkedError = AccountNotLinkedError;\n\nvar MissingAPIRoute = function (_UnknownError3) {\n  (0, _inherits2.default)(MissingAPIRoute, _UnknownError3);\n\n  var _super4 = _createSuper(MissingAPIRoute);\n\n  function MissingAPIRoute() {\n    var _this4;\n\n    (0, _classCallCheck2.default)(this, MissingAPIRoute);\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    _this4 = _super4.call.apply(_super4, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), \"name\", \"MissingAPIRouteError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), \"code\", \"MISSING_NEXTAUTH_API_ROUTE_ERROR\");\n    return _this4;\n  }\n\n  return (0, _createClass2.default)(MissingAPIRoute);\n}(UnknownError);\n\nexports.MissingAPIRoute = MissingAPIRoute;\n\nvar MissingSecret = function (_UnknownError4) {\n  (0, _inherits2.default)(MissingSecret, _UnknownError4);\n\n  var _super5 = _createSuper(MissingSecret);\n\n  function MissingSecret() {\n    var _this5;\n\n    (0, _classCallCheck2.default)(this, MissingSecret);\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    _this5 = _super5.call.apply(_super5, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), \"name\", \"MissingSecretError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), \"code\", \"NO_SECRET\");\n    return _this5;\n  }\n\n  return (0, _createClass2.default)(MissingSecret);\n}(UnknownError);\n\nexports.MissingSecret = MissingSecret;\n\nvar MissingAuthorize = function (_UnknownError5) {\n  (0, _inherits2.default)(MissingAuthorize, _UnknownError5);\n\n  var _super6 = _createSuper(MissingAuthorize);\n\n  function MissingAuthorize() {\n    var _this6;\n\n    (0, _classCallCheck2.default)(this, MissingAuthorize);\n\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    _this6 = _super6.call.apply(_super6, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), \"name\", \"MissingAuthorizeError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), \"code\", \"CALLBACK_CREDENTIALS_HANDLER_ERROR\");\n    return _this6;\n  }\n\n  return (0, _createClass2.default)(MissingAuthorize);\n}(UnknownError);\n\nexports.MissingAuthorize = MissingAuthorize;\n\nvar MissingAdapter = function (_UnknownError6) {\n  (0, _inherits2.default)(MissingAdapter, _UnknownError6);\n\n  var _super7 = _createSuper(MissingAdapter);\n\n  function MissingAdapter() {\n    var _this7;\n\n    (0, _classCallCheck2.default)(this, MissingAdapter);\n\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    _this7 = _super7.call.apply(_super7, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), \"name\", \"MissingAdapterError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), \"code\", \"EMAIL_REQUIRES_ADAPTER_ERROR\");\n    return _this7;\n  }\n\n  return (0, _createClass2.default)(MissingAdapter);\n}(UnknownError);\n\nexports.MissingAdapter = MissingAdapter;\n\nvar UnsupportedStrategy = function (_UnknownError7) {\n  (0, _inherits2.default)(UnsupportedStrategy, _UnknownError7);\n\n  var _super8 = _createSuper(UnsupportedStrategy);\n\n  function UnsupportedStrategy() {\n    var _this8;\n\n    (0, _classCallCheck2.default)(this, UnsupportedStrategy);\n\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    _this8 = _super8.call.apply(_super8, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this8), \"name\", \"UnsupportedStrategyError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this8), \"code\", \"CALLBACK_CREDENTIALS_JWT_ERROR\");\n    return _this8;\n  }\n\n  return (0, _createClass2.default)(UnsupportedStrategy);\n}(UnknownError);\n\nexports.UnsupportedStrategy = UnsupportedStrategy;\n\nvar InvalidCallbackUrl = function (_UnknownError8) {\n  (0, _inherits2.default)(InvalidCallbackUrl, _UnknownError8);\n\n  var _super9 = _createSuper(InvalidCallbackUrl);\n\n  function InvalidCallbackUrl() {\n    var _this9;\n\n    (0, _classCallCheck2.default)(this, InvalidCallbackUrl);\n\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n\n    _this9 = _super9.call.apply(_super9, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this9), \"name\", \"InvalidCallbackUrl\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this9), \"code\", \"INVALID_CALLBACK_URL_ERROR\");\n    return _this9;\n  }\n\n  return (0, _createClass2.default)(InvalidCallbackUrl);\n}(UnknownError);\n\nexports.InvalidCallbackUrl = InvalidCallbackUrl;\n\nfunction upperSnake(s) {\n  return s.replace(/([A-Z])/g, \"_$1\").toUpperCase();\n}\n\nfunction capitalize(s) {\n  return \"\".concat(s[0].toUpperCase()).concat(s.slice(1));\n}\n\nfunction eventsErrorHandler(methods, logger) {\n  return Object.keys(methods).reduce(function (acc, name) {\n    acc[name] = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {\n      var method,\n          _args = arguments;\n      return _regenerator.default.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              method = methods[name];\n              _context.next = 4;\n              return method.apply(void 0, _args);\n\n            case 4:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 7:\n              _context.prev = 7;\n              _context.t0 = _context[\"catch\"](0);\n              logger.error(\"\".concat(upperSnake(name), \"_EVENT_ERROR\"), _context.t0);\n\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 7]]);\n    }));\n    return acc;\n  }, {});\n}\n\nfunction adapterErrorHandler(adapter, logger) {\n  if (!adapter) return;\n  return Object.keys(adapter).reduce(function (acc, name) {\n    acc[name] = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {\n      var _len9,\n          args,\n          _key9,\n          method,\n          e,\n          _args2 = arguments;\n\n      return _regenerator.default.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n\n              for (_len9 = _args2.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n                args[_key9] = _args2[_key9];\n              }\n\n              logger.debug(\"adapter_\".concat(name), {\n                args: args\n              });\n              method = adapter[name];\n              _context2.next = 6;\n              return method.apply(void 0, args);\n\n            case 6:\n              return _context2.abrupt(\"return\", _context2.sent);\n\n            case 9:\n              _context2.prev = 9;\n              _context2.t0 = _context2[\"catch\"](0);\n              logger.error(\"adapter_error_\".concat(name), _context2.t0);\n              e = new UnknownError(_context2.t0);\n              e.name = \"\".concat(capitalize(name), \"Error\");\n              throw e;\n\n            case 15:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[0, 9]]);\n    }));\n    return acc;\n  }, {});\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2NvcmUvZXJyb3JzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUlBLHNCQUFzQixHQUFHQyxtQkFBTyxDQUFDLG9IQUFELENBQXBDOztBQUVBQyw4Q0FBNkM7RUFDM0NHLEtBQUssRUFBRTtBQURvQyxDQUE3QztBQUdBRCwyQkFBQSxHQUE4QkEsb0JBQUEsR0FBdUJBLDBCQUFBLEdBQTZCQSxxQkFBQSxHQUF3QkEsd0JBQUEsR0FBMkJBLHNCQUFBLEdBQXlCQSx1QkFBQSxHQUEwQkEsMEJBQUEsR0FBNkJBLDZCQUFBLEdBQWdDLEtBQUssQ0FBMVA7QUFDQUEsMkJBQUEsR0FBOEJXLG1CQUE5QjtBQUNBWCxrQkFBQSxHQUFxQlksVUFBckI7QUFDQVosMEJBQUEsR0FBNkJhLGtCQUE3QjtBQUNBYixrQkFBQSxHQUFxQmMsVUFBckI7O0FBRUEsSUFBSUMsWUFBWSxHQUFHbkIsc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsc0ZBQUQsQ0FBUixDQUF6Qzs7QUFFQSxJQUFJbUIsa0JBQWtCLEdBQUdwQixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQywwR0FBRCxDQUFSLENBQS9DOztBQUVBLElBQUlvQix1QkFBdUIsR0FBR3JCLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLG9IQUFELENBQVIsQ0FBcEQ7O0FBRUEsSUFBSXFCLGdCQUFnQixHQUFHdEIsc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsc0dBQUQsQ0FBUixDQUE3Qzs7QUFFQSxJQUFJc0IsZ0JBQWdCLEdBQUd2QixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxzR0FBRCxDQUFSLENBQTdDOztBQUVBLElBQUl1QixhQUFhLEdBQUd4QixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxnR0FBRCxDQUFSLENBQTFDOztBQUVBLElBQUl3QixVQUFVLEdBQUd6QixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQywwRkFBRCxDQUFSLENBQXZDOztBQUVBLElBQUl5QiwyQkFBMkIsR0FB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QUEzQixDQUFKO2NBQ0E3RSxDQUFDLENBQUNPLElBQUYsR0FBUyxHQUFHYyxNQUFILENBQVV0RCxVQUFVLENBQUN3QyxJQUFELENBQXBCLEVBQTRCLE9BQTVCLENBQVQ7Y0FDQSxNQUFNUCxDQUFOOztZQUVGLEtBQUssRUFBTDtZQUNBLEtBQUssS0FBTDtjQUNFLE9BQU9xRixTQUFTLENBQUNQLElBQVYsRUFBUDtVQTVCSjtRQThCRDtNQUNGLENBakNNLEVBaUNKRSxRQWpDSSxFQWlDTSxJQWpDTixFQWlDWSxDQUFDLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBRCxDQWpDWixDQUFQO0lBa0NELENBMUMyQyxDQUFoQyxDQUFaO0lBMkNBLE9BQU9mLEdBQVA7RUFDRCxDQTdDTSxFQTZDSixFQTdDSSxDQUFQO0FBOENEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvY29yZS9lcnJvcnMuanM/ZGRjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuVW5zdXBwb3J0ZWRTdHJhdGVneSA9IGV4cG9ydHMuVW5rbm93bkVycm9yID0gZXhwb3J0cy5PQXV0aENhbGxiYWNrRXJyb3IgPSBleHBvcnRzLk1pc3NpbmdTZWNyZXQgPSBleHBvcnRzLk1pc3NpbmdBdXRob3JpemUgPSBleHBvcnRzLk1pc3NpbmdBZGFwdGVyID0gZXhwb3J0cy5NaXNzaW5nQVBJUm91dGUgPSBleHBvcnRzLkludmFsaWRDYWxsYmFja1VybCA9IGV4cG9ydHMuQWNjb3VudE5vdExpbmtlZEVycm9yID0gdm9pZCAwO1xyXG5leHBvcnRzLmFkYXB0ZXJFcnJvckhhbmRsZXIgPSBhZGFwdGVyRXJyb3JIYW5kbGVyO1xyXG5leHBvcnRzLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xyXG5leHBvcnRzLmV2ZW50c0Vycm9ySGFuZGxlciA9IGV2ZW50c0Vycm9ySGFuZGxlcjtcclxuZXhwb3J0cy51cHBlclNuYWtlID0gdXBwZXJTbmFrZTtcclxuXHJcbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XHJcblxyXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcclxuXHJcbnZhciBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpKTtcclxuXHJcbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XHJcblxyXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xyXG5cclxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcclxuXHJcbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XHJcblxyXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcclxuXHJcbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XHJcblxyXG52YXIgX3dyYXBOYXRpdmVTdXBlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlclwiKSk7XHJcblxyXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgcmVzdWx0KTsgfTsgfVxyXG5cclxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XHJcblxyXG52YXIgVW5rbm93bkVycm9yID0gZnVuY3Rpb24gKF9FcnJvcikge1xyXG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFVua25vd25FcnJvciwgX0Vycm9yKTtcclxuXHJcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihVbmtub3duRXJyb3IpO1xyXG5cclxuICBmdW5jdGlvbiBVbmtub3duRXJyb3IoZXJyb3IpIHtcclxuICAgIHZhciBfbWVzc2FnZTtcclxuXHJcbiAgICB2YXIgX3RoaXM7XHJcblxyXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVW5rbm93bkVycm9yKTtcclxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgKF9tZXNzYWdlID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpICE9PSBudWxsICYmIF9tZXNzYWdlICE9PSB2b2lkIDAgPyBfbWVzc2FnZSA6IGVycm9yKTtcclxuICAgIF90aGlzLm5hbWUgPSBcIlVua25vd25FcnJvclwiO1xyXG4gICAgX3RoaXMuY29kZSA9IGVycm9yLmNvZGU7XHJcblxyXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgX3RoaXMuc3RhY2sgPSBlcnJvci5zdGFjaztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gX3RoaXM7XHJcbiAgfVxyXG5cclxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShVbmtub3duRXJyb3IsIFt7XHJcbiAgICBrZXk6IFwidG9KU09OXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXHJcbiAgICAgICAgc3RhY2s6IHRoaXMuc3RhY2tcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XSk7XHJcbiAgcmV0dXJuIFVua25vd25FcnJvcjtcclxufSgoMCwgX3dyYXBOYXRpdmVTdXBlcjIuZGVmYXVsdCkoRXJyb3IpKTtcclxuXHJcbmV4cG9ydHMuVW5rbm93bkVycm9yID0gVW5rbm93bkVycm9yO1xyXG5cclxudmFyIE9BdXRoQ2FsbGJhY2tFcnJvciA9IGZ1bmN0aW9uIChfVW5rbm93bkVycm9yKSB7XHJcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoT0F1dGhDYWxsYmFja0Vycm9yLCBfVW5rbm93bkVycm9yKTtcclxuXHJcbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoT0F1dGhDYWxsYmFja0Vycm9yKTtcclxuXHJcbiAgZnVuY3Rpb24gT0F1dGhDYWxsYmFja0Vycm9yKCkge1xyXG4gICAgdmFyIF90aGlzMjtcclxuXHJcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBPQXV0aENhbGxiYWNrRXJyb3IpO1xyXG5cclxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xyXG4gICAgfVxyXG5cclxuICAgIF90aGlzMiA9IF9zdXBlcjIuY2FsbC5hcHBseShfc3VwZXIyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcclxuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczIpLCBcIm5hbWVcIiwgXCJPQXV0aENhbGxiYWNrRXJyb3JcIik7XHJcbiAgICByZXR1cm4gX3RoaXMyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKE9BdXRoQ2FsbGJhY2tFcnJvcik7XHJcbn0oVW5rbm93bkVycm9yKTtcclxuXHJcbmV4cG9ydHMuT0F1dGhDYWxsYmFja0Vycm9yID0gT0F1dGhDYWxsYmFja0Vycm9yO1xyXG5cclxudmFyIEFjY291bnROb3RMaW5rZWRFcnJvciA9IGZ1bmN0aW9uIChfVW5rbm93bkVycm9yMikge1xyXG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEFjY291bnROb3RMaW5rZWRFcnJvciwgX1Vua25vd25FcnJvcjIpO1xyXG5cclxuICB2YXIgX3N1cGVyMyA9IF9jcmVhdGVTdXBlcihBY2NvdW50Tm90TGlua2VkRXJyb3IpO1xyXG5cclxuICBmdW5jdGlvbiBBY2NvdW50Tm90TGlua2VkRXJyb3IoKSB7XHJcbiAgICB2YXIgX3RoaXMzO1xyXG5cclxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEFjY291bnROb3RMaW5rZWRFcnJvcik7XHJcblxyXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XHJcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcclxuICAgIH1cclxuXHJcbiAgICBfdGhpczMgPSBfc3VwZXIzLmNhbGwuYXBwbHkoX3N1cGVyMywgW3RoaXNdLmNvbmNhdChhcmdzKSk7XHJcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXMzKSwgXCJuYW1lXCIsIFwiQWNjb3VudE5vdExpbmtlZEVycm9yXCIpO1xyXG4gICAgcmV0dXJuIF90aGlzMztcclxuICB9XHJcblxyXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShBY2NvdW50Tm90TGlua2VkRXJyb3IpO1xyXG59KFVua25vd25FcnJvcik7XHJcblxyXG5leHBvcnRzLkFjY291bnROb3RMaW5rZWRFcnJvciA9IEFjY291bnROb3RMaW5rZWRFcnJvcjtcclxuXHJcbnZhciBNaXNzaW5nQVBJUm91dGUgPSBmdW5jdGlvbiAoX1Vua25vd25FcnJvcjMpIHtcclxuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShNaXNzaW5nQVBJUm91dGUsIF9Vbmtub3duRXJyb3IzKTtcclxuXHJcbiAgdmFyIF9zdXBlcjQgPSBfY3JlYXRlU3VwZXIoTWlzc2luZ0FQSVJvdXRlKTtcclxuXHJcbiAgZnVuY3Rpb24gTWlzc2luZ0FQSVJvdXRlKCkge1xyXG4gICAgdmFyIF90aGlzNDtcclxuXHJcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBNaXNzaW5nQVBJUm91dGUpO1xyXG5cclxuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xyXG4gICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XHJcbiAgICB9XHJcblxyXG4gICAgX3RoaXM0ID0gX3N1cGVyNC5jYWxsLmFwcGx5KF9zdXBlcjQsIFt0aGlzXS5jb25jYXQoYXJncykpO1xyXG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNCksIFwibmFtZVwiLCBcIk1pc3NpbmdBUElSb3V0ZUVycm9yXCIpO1xyXG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNCksIFwiY29kZVwiLCBcIk1JU1NJTkdfTkVYVEFVVEhfQVBJX1JPVVRFX0VSUk9SXCIpO1xyXG4gICAgcmV0dXJuIF90aGlzNDtcclxuICB9XHJcblxyXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShNaXNzaW5nQVBJUm91dGUpO1xyXG59KFVua25vd25FcnJvcik7XHJcblxyXG5leHBvcnRzLk1pc3NpbmdBUElSb3V0ZSA9IE1pc3NpbmdBUElSb3V0ZTtcclxuXHJcbnZhciBNaXNzaW5nU2VjcmV0ID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3I0KSB7XHJcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoTWlzc2luZ1NlY3JldCwgX1Vua25vd25FcnJvcjQpO1xyXG5cclxuICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihNaXNzaW5nU2VjcmV0KTtcclxuXHJcbiAgZnVuY3Rpb24gTWlzc2luZ1NlY3JldCgpIHtcclxuICAgIHZhciBfdGhpczU7XHJcblxyXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgTWlzc2luZ1NlY3JldCk7XHJcblxyXG4gICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XHJcbiAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcclxuICAgIH1cclxuXHJcbiAgICBfdGhpczUgPSBfc3VwZXI1LmNhbGwuYXBwbHkoX3N1cGVyNSwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XHJcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM1KSwgXCJuYW1lXCIsIFwiTWlzc2luZ1NlY3JldEVycm9yXCIpO1xyXG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNSksIFwiY29kZVwiLCBcIk5PX1NFQ1JFVFwiKTtcclxuICAgIHJldHVybiBfdGhpczU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoTWlzc2luZ1NlY3JldCk7XHJcbn0oVW5rbm93bkVycm9yKTtcclxuXHJcbmV4cG9ydHMuTWlzc2luZ1NlY3JldCA9IE1pc3NpbmdTZWNyZXQ7XHJcblxyXG52YXIgTWlzc2luZ0F1dGhvcml6ZSA9IGZ1bmN0aW9uIChfVW5rbm93bkVycm9yNSkge1xyXG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKE1pc3NpbmdBdXRob3JpemUsIF9Vbmtub3duRXJyb3I1KTtcclxuXHJcbiAgdmFyIF9zdXBlcjYgPSBfY3JlYXRlU3VwZXIoTWlzc2luZ0F1dGhvcml6ZSk7XHJcblxyXG4gIGZ1bmN0aW9uIE1pc3NpbmdBdXRob3JpemUoKSB7XHJcbiAgICB2YXIgX3RoaXM2O1xyXG5cclxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIE1pc3NpbmdBdXRob3JpemUpO1xyXG5cclxuICAgIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSksIF9rZXk1ID0gMDsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xyXG4gICAgICBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XHJcbiAgICB9XHJcblxyXG4gICAgX3RoaXM2ID0gX3N1cGVyNi5jYWxsLmFwcGx5KF9zdXBlcjYsIFt0aGlzXS5jb25jYXQoYXJncykpO1xyXG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNiksIFwibmFtZVwiLCBcIk1pc3NpbmdBdXRob3JpemVFcnJvclwiKTtcclxuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczYpLCBcImNvZGVcIiwgXCJDQUxMQkFDS19DUkVERU5USUFMU19IQU5ETEVSX0VSUk9SXCIpO1xyXG4gICAgcmV0dXJuIF90aGlzNjtcclxuICB9XHJcblxyXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShNaXNzaW5nQXV0aG9yaXplKTtcclxufShVbmtub3duRXJyb3IpO1xyXG5cclxuZXhwb3J0cy5NaXNzaW5nQXV0aG9yaXplID0gTWlzc2luZ0F1dGhvcml6ZTtcclxuXHJcbnZhciBNaXNzaW5nQWRhcHRlciA9IGZ1bmN0aW9uIChfVW5rbm93bkVycm9yNikge1xyXG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKE1pc3NpbmdBZGFwdGVyLCBfVW5rbm93bkVycm9yNik7XHJcblxyXG4gIHZhciBfc3VwZXI3ID0gX2NyZWF0ZVN1cGVyKE1pc3NpbmdBZGFwdGVyKTtcclxuXHJcbiAgZnVuY3Rpb24gTWlzc2luZ0FkYXB0ZXIoKSB7XHJcbiAgICB2YXIgX3RoaXM3O1xyXG5cclxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIE1pc3NpbmdBZGFwdGVyKTtcclxuXHJcbiAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcclxuICAgICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xyXG4gICAgfVxyXG5cclxuICAgIF90aGlzNyA9IF9zdXBlcjcuY2FsbC5hcHBseShfc3VwZXI3LCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcclxuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczcpLCBcIm5hbWVcIiwgXCJNaXNzaW5nQWRhcHRlckVycm9yXCIpO1xyXG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNyksIFwiY29kZVwiLCBcIkVNQUlMX1JFUVVJUkVTX0FEQVBURVJfRVJST1JcIik7XHJcbiAgICByZXR1cm4gX3RoaXM3O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKE1pc3NpbmdBZGFwdGVyKTtcclxufShVbmtub3duRXJyb3IpO1xyXG5cclxuZXhwb3J0cy5NaXNzaW5nQWRhcHRlciA9IE1pc3NpbmdBZGFwdGVyO1xyXG5cclxudmFyIFVuc3VwcG9ydGVkU3RyYXRlZ3kgPSBmdW5jdGlvbiAoX1Vua25vd25FcnJvcjcpIHtcclxuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShVbnN1cHBvcnRlZFN0cmF0ZWd5LCBfVW5rbm93bkVycm9yNyk7XHJcblxyXG4gIHZhciBfc3VwZXI4ID0gX2NyZWF0ZVN1cGVyKFVuc3VwcG9ydGVkU3RyYXRlZ3kpO1xyXG5cclxuICBmdW5jdGlvbiBVbnN1cHBvcnRlZFN0cmF0ZWd5KCkge1xyXG4gICAgdmFyIF90aGlzODtcclxuXHJcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBVbnN1cHBvcnRlZFN0cmF0ZWd5KTtcclxuXHJcbiAgICBmb3IgKHZhciBfbGVuNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcpLCBfa2V5NyA9IDA7IF9rZXk3IDwgX2xlbjc7IF9rZXk3KyspIHtcclxuICAgICAgYXJnc1tfa2V5N10gPSBhcmd1bWVudHNbX2tleTddO1xyXG4gICAgfVxyXG5cclxuICAgIF90aGlzOCA9IF9zdXBlcjguY2FsbC5hcHBseShfc3VwZXI4LCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcclxuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczgpLCBcIm5hbWVcIiwgXCJVbnN1cHBvcnRlZFN0cmF0ZWd5RXJyb3JcIik7XHJcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM4KSwgXCJjb2RlXCIsIFwiQ0FMTEJBQ0tfQ1JFREVOVElBTFNfSldUX0VSUk9SXCIpO1xyXG4gICAgcmV0dXJuIF90aGlzODtcclxuICB9XHJcblxyXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShVbnN1cHBvcnRlZFN0cmF0ZWd5KTtcclxufShVbmtub3duRXJyb3IpO1xyXG5cclxuZXhwb3J0cy5VbnN1cHBvcnRlZFN0cmF0ZWd5ID0gVW5zdXBwb3J0ZWRTdHJhdGVneTtcclxuXHJcbnZhciBJbnZhbGlkQ2FsbGJhY2tVcmwgPSBmdW5jdGlvbiAoX1Vua25vd25FcnJvcjgpIHtcclxuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShJbnZhbGlkQ2FsbGJhY2tVcmwsIF9Vbmtub3duRXJyb3I4KTtcclxuXHJcbiAgdmFyIF9zdXBlcjkgPSBfY3JlYXRlU3VwZXIoSW52YWxpZENhbGxiYWNrVXJsKTtcclxuXHJcbiAgZnVuY3Rpb24gSW52YWxpZENhbGxiYWNrVXJsKCkge1xyXG4gICAgdmFyIF90aGlzOTtcclxuXHJcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBJbnZhbGlkQ2FsbGJhY2tVcmwpO1xyXG5cclxuICAgIGZvciAodmFyIF9sZW44ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuOCksIF9rZXk4ID0gMDsgX2tleTggPCBfbGVuODsgX2tleTgrKykge1xyXG4gICAgICBhcmdzW19rZXk4XSA9IGFyZ3VtZW50c1tfa2V5OF07XHJcbiAgICB9XHJcblxyXG4gICAgX3RoaXM5ID0gX3N1cGVyOS5jYWxsLmFwcGx5KF9zdXBlcjksIFt0aGlzXS5jb25jYXQoYXJncykpO1xyXG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzOSksIFwibmFtZVwiLCBcIkludmFsaWRDYWxsYmFja1VybFwiKTtcclxuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczkpLCBcImNvZGVcIiwgXCJJTlZBTElEX0NBTExCQUNLX1VSTF9FUlJPUlwiKTtcclxuICAgIHJldHVybiBfdGhpczk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoSW52YWxpZENhbGxiYWNrVXJsKTtcclxufShVbmtub3duRXJyb3IpO1xyXG5cclxuZXhwb3J0cy5JbnZhbGlkQ2FsbGJhY2tVcmwgPSBJbnZhbGlkQ2FsbGJhY2tVcmw7XHJcblxyXG5mdW5jdGlvbiB1cHBlclNuYWtlKHMpIHtcclxuICByZXR1cm4gcy5yZXBsYWNlKC8oW0EtWl0pL2csIFwiXyQxXCIpLnRvVXBwZXJDYXNlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhcGl0YWxpemUocykge1xyXG4gIHJldHVybiBcIlwiLmNvbmNhdChzWzBdLnRvVXBwZXJDYXNlKCkpLmNvbmNhdChzLnNsaWNlKDEpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXZlbnRzRXJyb3JIYW5kbGVyKG1ldGhvZHMsIGxvZ2dlcikge1xyXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXRob2RzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbmFtZSkge1xyXG4gICAgYWNjW25hbWVdID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XHJcbiAgICAgIHZhciBtZXRob2QsXHJcbiAgICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcclxuICAgICAgICB3aGlsZSAoMSkge1xyXG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XHJcbiAgICAgICAgICAgICAgbWV0aG9kID0gbWV0aG9kc1tuYW1lXTtcclxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcclxuICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHZvaWQgMCwgX2FyZ3MpO1xyXG5cclxuICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDc7XHJcbiAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xyXG4gICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIlwiLmNvbmNhdCh1cHBlclNuYWtlKG5hbWUpLCBcIl9FVkVOVF9FUlJPUlwiKSwgX2NvbnRleHQudDApO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAxMDpcclxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxyXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzAsIDddXSk7XHJcbiAgICB9KSk7XHJcbiAgICByZXR1cm4gYWNjO1xyXG4gIH0sIHt9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRhcHRlckVycm9ySGFuZGxlcihhZGFwdGVyLCBsb2dnZXIpIHtcclxuICBpZiAoIWFkYXB0ZXIpIHJldHVybjtcclxuICByZXR1cm4gT2JqZWN0LmtleXMoYWRhcHRlcikucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5hbWUpIHtcclxuICAgIGFjY1tuYW1lXSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcclxuICAgICAgdmFyIF9sZW45LFxyXG4gICAgICAgICAgYXJncyxcclxuICAgICAgICAgIF9rZXk5LFxyXG4gICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgZSxcclxuICAgICAgICAgIF9hcmdzMiA9IGFyZ3VtZW50cztcclxuXHJcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcclxuICAgICAgICB3aGlsZSAoMSkge1xyXG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDA7XHJcblxyXG4gICAgICAgICAgICAgIGZvciAoX2xlbjkgPSBfYXJnczIubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW45KSwgX2tleTkgPSAwOyBfa2V5OSA8IF9sZW45OyBfa2V5OSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19rZXk5XSA9IF9hcmdzMltfa2V5OV07XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJhZGFwdGVyX1wiLmNvbmNhdChuYW1lKSwge1xyXG4gICAgICAgICAgICAgICAgYXJnczogYXJnc1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIG1ldGhvZCA9IGFkYXB0ZXJbbmFtZV07XHJcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xyXG4gICAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodm9pZCAwLCBhcmdzKTtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDk6XHJcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA5O1xyXG4gICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDApO1xyXG4gICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcImFkYXB0ZXJfZXJyb3JfXCIuY29uY2F0KG5hbWUpLCBfY29udGV4dDIudDApO1xyXG4gICAgICAgICAgICAgIGUgPSBuZXcgVW5rbm93bkVycm9yKF9jb250ZXh0Mi50MCk7XHJcbiAgICAgICAgICAgICAgZS5uYW1lID0gXCJcIi5jb25jYXQoY2FwaXRhbGl6ZShuYW1lKSwgXCJFcnJvclwiKTtcclxuICAgICAgICAgICAgICB0aHJvdyBlO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAxNTpcclxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxyXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbMCwgOV1dKTtcclxuICAgIH0pKTtcclxuICAgIHJldHVybiBhY2M7XHJcbiAgfSwge30pO1xyXG59Il0sIm5hbWVzIjpbIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJVbnN1cHBvcnRlZFN0cmF0ZWd5IiwiVW5rbm93bkVycm9yIiwiT0F1dGhDYWxsYmFja0Vycm9yIiwiTWlzc2luZ1NlY3JldCIsIk1pc3NpbmdBdXRob3JpemUiLCJNaXNzaW5nQWRhcHRlciIsIk1pc3NpbmdBUElSb3V0ZSIsIkludmFsaWRDYWxsYmFja1VybCIsIkFjY291bnROb3RMaW5rZWRFcnJvciIsImFkYXB0ZXJFcnJvckhhbmRsZXIiLCJjYXBpdGFsaXplIiwiZXZlbnRzRXJyb3JIYW5kbGVyIiwidXBwZXJTbmFrZSIsIl9yZWdlbmVyYXRvciIsIl9hc3luY1RvR2VuZXJhdG9yMiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyIiwiX2RlZmluZVByb3BlcnR5MiIsIl9jbGFzc0NhbGxDaGVjazIiLCJfY3JlYXRlQ2xhc3MyIiwiX2luaGVyaXRzMiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiIsIl9nZXRQcm90b3R5cGVPZjIiLCJfd3JhcE5hdGl2ZVN1cGVyMiIsIl9jcmVhdGVTdXBlciIsIkRlcml2ZWQiLCJoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9jcmVhdGVTdXBlckludGVybmFsIiwiU3VwZXIiLCJkZWZhdWx0IiwicmVzdWx0IiwiTmV3VGFyZ2V0IiwiY29uc3RydWN0b3IiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiYXJndW1lbnRzIiwiYXBwbHkiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwicHJvdG90eXBlIiwidmFsdWVPZiIsImNhbGwiLCJlIiwiX0Vycm9yIiwiX3N1cGVyIiwiZXJyb3IiLCJfbWVzc2FnZSIsIl90aGlzIiwibWVzc2FnZSIsIm5hbWUiLCJjb2RlIiwiRXJyb3IiLCJzdGFjayIsImtleSIsInRvSlNPTiIsIl9Vbmtub3duRXJyb3IiLCJfc3VwZXIyIiwiX3RoaXMyIiwiX2xlbiIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJjb25jYXQiLCJfVW5rbm93bkVycm9yMiIsIl9zdXBlcjMiLCJfdGhpczMiLCJfbGVuMiIsIl9rZXkyIiwiX1Vua25vd25FcnJvcjMiLCJfc3VwZXI0IiwiX3RoaXM0IiwiX2xlbjMiLCJfa2V5MyIsIl9Vbmtub3duRXJyb3I0IiwiX3N1cGVyNSIsIl90aGlzNSIsIl9sZW40IiwiX2tleTQiLCJfVW5rbm93bkVycm9yNSIsIl9zdXBlcjYiLCJfdGhpczYiLCJfbGVuNSIsIl9rZXk1IiwiX1Vua25vd25FcnJvcjYiLCJfc3VwZXI3IiwiX3RoaXM3IiwiX2xlbjYiLCJfa2V5NiIsIl9Vbmtub3duRXJyb3I3IiwiX3N1cGVyOCIsIl90aGlzOCIsIl9sZW43IiwiX2tleTciLCJfVW5rbm93bkVycm9yOCIsIl9zdXBlcjkiLCJfdGhpczkiLCJfbGVuOCIsIl9rZXk4IiwicyIsInJlcGxhY2UiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwibWV0aG9kcyIsImxvZ2dlciIsImtleXMiLCJyZWR1Y2UiLCJhY2MiLCJtYXJrIiwiX2NhbGxlZSIsIm1ldGhvZCIsIl9hcmdzIiwid3JhcCIsIl9jYWxsZWUkIiwiX2NvbnRleHQiLCJwcmV2IiwibmV4dCIsImFicnVwdCIsInNlbnQiLCJ0MCIsInN0b3AiLCJhZGFwdGVyIiwiX2NhbGxlZTIiLCJfbGVuOSIsIl9rZXk5IiwiX2FyZ3MyIiwiX2NhbGxlZTIkIiwiX2NvbnRleHQyIiwiZGVidWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next-auth/core/errors.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/react/index.js":
/*!***********************************************!*\
  !*** ./node_modules/next-auth/react/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar _exportNames = {\n  useSession: true,\n  getSession: true,\n  getCsrfToken: true,\n  getProviders: true,\n  signIn: true,\n  signOut: true,\n  SessionProvider: true\n};\nexports.SessionProvider = SessionProvider;\nexports.getCsrfToken = getCsrfToken;\nexports.getProviders = getProviders;\nexports.getSession = getSession;\nexports.signIn = signIn;\nexports.signOut = signOut;\nexports.useSession = useSession;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _logger2 = _interopRequireWildcard(__webpack_require__(/*! ../utils/logger */ \"./node_modules/next-auth/utils/logger.js\"));\n\nvar _parseUrl = _interopRequireDefault(__webpack_require__(/*! ../utils/parse-url */ \"./node_modules/next-auth/utils/parse-url.js\"));\n\nvar _utils = __webpack_require__(/*! ../client/_utils */ \"./node_modules/next-auth/client/_utils.js\");\n\nvar _jsxRuntime = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/next-auth/react/types.js\");\n\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _types[key];\n    }\n  });\n});\n\nvar _process$env$NEXTAUTH, _ref, _process$env$NEXTAUTH2, _process$env$NEXTAUTH3;\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nvar __NEXTAUTH = {\n  baseUrl: (0, _parseUrl.default)((_process$env$NEXTAUTH = process.env.NEXTAUTH_URL) !== null && _process$env$NEXTAUTH !== void 0 ? _process$env$NEXTAUTH : process.env.VERCEL_URL).origin,\n  basePath: (0, _parseUrl.default)(process.env.NEXTAUTH_URL).path,\n  baseUrlServer: (0, _parseUrl.default)((_ref = (_process$env$NEXTAUTH2 = process.env.NEXTAUTH_URL_INTERNAL) !== null && _process$env$NEXTAUTH2 !== void 0 ? _process$env$NEXTAUTH2 : process.env.NEXTAUTH_URL) !== null && _ref !== void 0 ? _ref : process.env.VERCEL_URL).origin,\n  basePathServer: (0, _parseUrl.default)((_process$env$NEXTAUTH3 = process.env.NEXTAUTH_URL_INTERNAL) !== null && _process$env$NEXTAUTH3 !== void 0 ? _process$env$NEXTAUTH3 : process.env.NEXTAUTH_URL).path,\n  _lastSync: 0,\n  _session: undefined,\n  _getSession: function _getSession() {}\n};\nvar broadcast = (0, _utils.BroadcastChannel)();\nvar logger = (0, _logger2.proxyLogger)(_logger2.default, __NEXTAUTH.basePath);\nvar SessionContext = React.createContext(undefined);\n\nfunction useSession(options) {\n  var value = React.useContext(SessionContext);\n\n  if (!value && \"development\" !== \"production\") {\n    throw new Error(\"[next-auth]: `useSession` must be wrapped in a <SessionProvider />\");\n  }\n\n  var _ref2 = options !== null && options !== void 0 ? options : {},\n      required = _ref2.required,\n      onUnauthenticated = _ref2.onUnauthenticated;\n\n  var requiredAndNotLoading = required && value.status === \"unauthenticated\";\n  React.useEffect(function () {\n    if (requiredAndNotLoading) {\n      var url = \"/api/auth/signin?\".concat(new URLSearchParams({\n        error: \"SessionRequired\",\n        callbackUrl: window.location.href\n      }));\n      if (onUnauthenticated) onUnauthenticated();else window.location.href = url;\n    }\n  }, [requiredAndNotLoading, onUnauthenticated]);\n\n  if (requiredAndNotLoading) {\n    return {\n      data: value.data,\n      status: \"loading\"\n    };\n  }\n\n  return value;\n}\n\nfunction getSession(_x) {\n  return _getSession2.apply(this, arguments);\n}\n\nfunction _getSession2() {\n  _getSession2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(params) {\n    var _params$broadcast;\n\n    var session;\n    return _regenerator.default.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return (0, _utils.fetchData)(\"session\", __NEXTAUTH, logger, params);\n\n          case 2:\n            session = _context2.sent;\n\n            if ((_params$broadcast = params === null || params === void 0 ? void 0 : params.broadcast) !== null && _params$broadcast !== void 0 ? _params$broadcast : true) {\n              broadcast.post({\n                event: \"session\",\n                data: {\n                  trigger: \"getSession\"\n                }\n              });\n            }\n\n            return _context2.abrupt(\"return\", session);\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getSession2.apply(this, arguments);\n}\n\nfunction getCsrfToken(_x2) {\n  return _getCsrfToken.apply(this, arguments);\n}\n\nfunction _getCsrfToken() {\n  _getCsrfToken = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(params) {\n    var response;\n    return _regenerator.default.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return (0, _utils.fetchData)(\"csrf\", __NEXTAUTH, logger, params);\n\n          case 2:\n            response = _context3.sent;\n            return _context3.abrupt(\"return\", response === null || response === void 0 ? void 0 : response.csrfToken);\n\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getCsrfToken.apply(this, arguments);\n}\n\nfunction getProviders() {\n  return _getProviders.apply(this, arguments);\n}\n\nfunction _getProviders() {\n  _getProviders = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4() {\n    return _regenerator.default.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return (0, _utils.fetchData)(\"providers\", __NEXTAUTH, logger);\n\n          case 2:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 3:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _getProviders.apply(this, arguments);\n}\n\nfunction signIn(_x3, _x4, _x5) {\n  return _signIn.apply(this, arguments);\n}\n\nfunction _signIn() {\n  _signIn = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5(provider, options, authorizationParams) {\n    var _ref5, _ref5$callbackUrl, callbackUrl, _ref5$redirect, redirect, baseUrl, providers, isCredentials, isEmail, isSupportingReturn, signInUrl, _signInUrl, res, data, _data$url, url, error;\n\n    return _regenerator.default.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _ref5 = options !== null && options !== void 0 ? options : {}, _ref5$callbackUrl = _ref5.callbackUrl, callbackUrl = _ref5$callbackUrl === void 0 ? window.location.href : _ref5$callbackUrl, _ref5$redirect = _ref5.redirect, redirect = _ref5$redirect === void 0 ? true : _ref5$redirect;\n            baseUrl = (0, _utils.apiBaseUrl)(__NEXTAUTH);\n            _context5.next = 4;\n            return getProviders();\n\n          case 4:\n            providers = _context5.sent;\n\n            if (providers) {\n              _context5.next = 8;\n              break;\n            }\n\n            window.location.href = \"\".concat(baseUrl, \"/error\");\n            return _context5.abrupt(\"return\");\n\n          case 8:\n            if (!(!provider || !(provider in providers))) {\n              _context5.next = 11;\n              break;\n            }\n\n            window.location.href = \"\".concat(baseUrl, \"/signin?\").concat(new URLSearchParams({\n              callbackUrl: callbackUrl\n            }));\n            return _context5.abrupt(\"return\");\n\n          case 11:\n            isCredentials = providers[provider].type === \"credentials\";\n            isEmail = providers[provider].type === \"email\";\n            isSupportingReturn = isCredentials || isEmail;\n            signInUrl = \"\".concat(baseUrl, \"/\").concat(isCredentials ? \"callback\" : \"signin\", \"/\").concat(provider);\n            _signInUrl = \"\".concat(signInUrl, \"?\").concat(new URLSearchParams(authorizationParams));\n            _context5.t0 = fetch;\n            _context5.t1 = _signInUrl;\n            _context5.t2 = {\n              \"Content-Type\": \"application/x-www-form-urlencoded\"\n            };\n            _context5.t3 = URLSearchParams;\n            _context5.t4 = _objectSpread;\n            _context5.t5 = _objectSpread({}, options);\n            _context5.t6 = {};\n            _context5.next = 25;\n            return getCsrfToken();\n\n          case 25:\n            _context5.t7 = _context5.sent;\n            _context5.t8 = callbackUrl;\n            _context5.t9 = {\n              csrfToken: _context5.t7,\n              callbackUrl: _context5.t8,\n              json: true\n            };\n            _context5.t10 = (0, _context5.t4)(_context5.t5, _context5.t6, _context5.t9);\n            _context5.t11 = new _context5.t3(_context5.t10);\n            _context5.t12 = {\n              method: \"post\",\n              headers: _context5.t2,\n              body: _context5.t11\n            };\n            _context5.next = 33;\n            return (0, _context5.t0)(_context5.t1, _context5.t12);\n\n          case 33:\n            res = _context5.sent;\n            _context5.next = 36;\n            return res.json();\n\n          case 36:\n            data = _context5.sent;\n\n            if (!(redirect || !isSupportingReturn)) {\n              _context5.next = 42;\n              break;\n            }\n\n            url = (_data$url = data.url) !== null && _data$url !== void 0 ? _data$url : callbackUrl;\n            window.location.href = url;\n            if (url.includes(\"#\")) window.location.reload();\n            return _context5.abrupt(\"return\");\n\n          case 42:\n            error = new URL(data.url).searchParams.get(\"error\");\n\n            if (!res.ok) {\n              _context5.next = 46;\n              break;\n            }\n\n            _context5.next = 46;\n            return __NEXTAUTH._getSession({\n              event: \"storage\"\n            });\n\n          case 46:\n            return _context5.abrupt(\"return\", {\n              error: error,\n              status: res.status,\n              ok: res.ok,\n              url: error ? null : data.url\n            });\n\n          case 47:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _signIn.apply(this, arguments);\n}\n\nfunction signOut(_x6) {\n  return _signOut.apply(this, arguments);\n}\n\nfunction _signOut() {\n  _signOut = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee6(options) {\n    var _options$redirect;\n\n    var _ref6, _ref6$callbackUrl, callbackUrl, baseUrl, fetchOptions, res, data, _data$url2, url;\n\n    return _regenerator.default.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _ref6 = options !== null && options !== void 0 ? options : {}, _ref6$callbackUrl = _ref6.callbackUrl, callbackUrl = _ref6$callbackUrl === void 0 ? window.location.href : _ref6$callbackUrl;\n            baseUrl = (0, _utils.apiBaseUrl)(__NEXTAUTH);\n            _context6.t0 = {\n              \"Content-Type\": \"application/x-www-form-urlencoded\"\n            };\n            _context6.t1 = URLSearchParams;\n            _context6.next = 6;\n            return getCsrfToken();\n\n          case 6:\n            _context6.t2 = _context6.sent;\n            _context6.t3 = callbackUrl;\n            _context6.t4 = {\n              csrfToken: _context6.t2,\n              callbackUrl: _context6.t3,\n              json: true\n            };\n            _context6.t5 = new _context6.t1(_context6.t4);\n            fetchOptions = {\n              method: \"post\",\n              headers: _context6.t0,\n              body: _context6.t5\n            };\n            _context6.next = 13;\n            return fetch(\"\".concat(baseUrl, \"/signout\"), fetchOptions);\n\n          case 13:\n            res = _context6.sent;\n            _context6.next = 16;\n            return res.json();\n\n          case 16:\n            data = _context6.sent;\n            broadcast.post({\n              event: \"session\",\n              data: {\n                trigger: \"signout\"\n              }\n            });\n\n            if (!((_options$redirect = options === null || options === void 0 ? void 0 : options.redirect) !== null && _options$redirect !== void 0 ? _options$redirect : true)) {\n              _context6.next = 23;\n              break;\n            }\n\n            url = (_data$url2 = data.url) !== null && _data$url2 !== void 0 ? _data$url2 : callbackUrl;\n            window.location.href = url;\n            if (url.includes(\"#\")) window.location.reload();\n            return _context6.abrupt(\"return\");\n\n          case 23:\n            _context6.next = 25;\n            return __NEXTAUTH._getSession({\n              event: \"storage\"\n            });\n\n          case 25:\n            return _context6.abrupt(\"return\", data);\n\n          case 26:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _signOut.apply(this, arguments);\n}\n\nfunction SessionProvider(props) {\n  var children = props.children,\n      basePath = props.basePath;\n  if (basePath) __NEXTAUTH.basePath = basePath;\n  var hasInitialSession = props.session !== undefined;\n  __NEXTAUTH._lastSync = hasInitialSession ? (0, _utils.now)() : 0;\n\n  var _React$useState = React.useState(function () {\n    if (hasInitialSession) __NEXTAUTH._session = props.session;\n    return props.session;\n  }),\n      _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),\n      session = _React$useState2[0],\n      setSession = _React$useState2[1];\n\n  var _React$useState3 = React.useState(!hasInitialSession),\n      _React$useState4 = (0, _slicedToArray2.default)(_React$useState3, 2),\n      loading = _React$useState4[0],\n      setLoading = _React$useState4[1];\n\n  React.useEffect(function () {\n    __NEXTAUTH._getSession = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {\n      var _ref4,\n          event,\n          storageEvent,\n          _args = arguments;\n\n      return _regenerator.default.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _ref4 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, event = _ref4.event;\n              _context.prev = 1;\n              storageEvent = event === \"storage\";\n\n              if (!(storageEvent || __NEXTAUTH._session === undefined)) {\n                _context.next = 10;\n                break;\n              }\n\n              __NEXTAUTH._lastSync = (0, _utils.now)();\n              _context.next = 7;\n              return getSession({\n                broadcast: !storageEvent\n              });\n\n            case 7:\n              __NEXTAUTH._session = _context.sent;\n              setSession(__NEXTAUTH._session);\n              return _context.abrupt(\"return\");\n\n            case 10:\n              if (!(!event || __NEXTAUTH._session === null || (0, _utils.now)() < __NEXTAUTH._lastSync)) {\n                _context.next = 12;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 12:\n              __NEXTAUTH._lastSync = (0, _utils.now)();\n              _context.next = 15;\n              return getSession();\n\n            case 15:\n              __NEXTAUTH._session = _context.sent;\n              setSession(__NEXTAUTH._session);\n              _context.next = 22;\n              break;\n\n            case 19:\n              _context.prev = 19;\n              _context.t0 = _context[\"catch\"](1);\n              logger.error(\"CLIENT_SESSION_ERROR\", _context.t0);\n\n            case 22:\n              _context.prev = 22;\n              setLoading(false);\n              return _context.finish(22);\n\n            case 25:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 19, 22, 25]]);\n    }));\n\n    __NEXTAUTH._getSession();\n\n    return function () {\n      __NEXTAUTH._lastSync = 0;\n      __NEXTAUTH._session = undefined;\n\n      __NEXTAUTH._getSession = function () {};\n    };\n  }, []);\n  React.useEffect(function () {\n    var unsubscribe = broadcast.receive(function () {\n      return __NEXTAUTH._getSession({\n        event: \"storage\"\n      });\n    });\n    return function () {\n      return unsubscribe();\n    };\n  }, []);\n  React.useEffect(function () {\n    var _props$refetchOnWindo = props.refetchOnWindowFocus,\n        refetchOnWindowFocus = _props$refetchOnWindo === void 0 ? true : _props$refetchOnWindo;\n\n    var visibilityHandler = function visibilityHandler() {\n      if (refetchOnWindowFocus && document.visibilityState === \"visible\") __NEXTAUTH._getSession({\n        event: \"visibilitychange\"\n      });\n    };\n\n    document.addEventListener(\"visibilitychange\", visibilityHandler, false);\n    return function () {\n      return document.removeEventListener(\"visibilitychange\", visibilityHandler, false);\n    };\n  }, [props.refetchOnWindowFocus]);\n  React.useEffect(function () {\n    var refetchInterval = props.refetchInterval;\n\n    if (refetchInterval) {\n      var refetchIntervalTimer = setInterval(function () {\n        if (__NEXTAUTH._session) {\n          __NEXTAUTH._getSession({\n            event: \"poll\"\n          });\n        }\n      }, refetchInterval * 1000);\n      return function () {\n        return clearInterval(refetchIntervalTimer);\n      };\n    }\n  }, [props.refetchInterval]);\n  var value = React.useMemo(function () {\n    return {\n      data: session,\n      status: loading ? \"loading\" : session ? \"authenticated\" : \"unauthenticated\"\n    };\n  }, [session, loading]);\n  return (0, _jsxRuntime.jsx)(SessionContext.Provider, {\n    value: value,\n    children: children\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTs7QUFFYixJQUFJQSxzQkFBc0IsR0FBR0MsbUJBQU8sQ0FBQyxvSEFBRCxDQUFwQzs7QUFFQSxJQUFJQyxPQUFPLEdBQUdELG1CQUFPLENBQUMsc0ZBQUQsQ0FBckI7O0FBRUFFLDhDQUE2QztFQUMzQ0csS0FBSyxFQUFFO0FBRG9DLENBQTdDO0FBR0EsSUFBSUMsWUFBWSxHQUFHO0VBQ2pCQyxVQUFVLEVBQUUsSUFESztFQUVqQkMsVUFBVSxFQUFFLElBRks7RUFHakJDLFlBQVksRUFBRSxJQUhHO0VBSWpCQyxZQUFZLEVBQUUsSUFKRztFQUtqQkMsTUFBTSxFQUFFLElBTFM7RUFNakJDLE9BQU8sRUFBRSxJQU5RO0VBT2pCQyxlQUFlLEVBQUU7QUFQQSxDQUFuQjtBQVNBVCx1QkFBQSxHQUEwQlMsZUFBMUI7QUFDQVQsb0JBQUEsR0FBdUJLLFlBQXZCO0FBQ0FMLG9CQUFBLEdBQXVCTSxZQUF2QjtBQUNBTixrQkFBQSxHQUFxQkksVUFBckI7QUFDQUosY0FBQSxHQUFpQk8sTUFBakI7QUFDQVAsZUFBQSxHQUFrQlEsT0FBbEI7QUFDQVIsa0JBQUEsR0FBcUJHLFVBQXJCOztBQUVBLElBQUlPLFlBQVksR0FBR2Ysc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsc0ZBQUQsQ0FBUixDQUF6Qzs7QUFFQSxJQUFJZSxnQkFBZ0IsR0FBR2hCLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLHNHQUFELENBQVIsQ0FBN0M7O0FBRUEsSUFBSWdCLGVBQWUsR0FBR2pCLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLG9HQUFELENBQVIsQ0FBNUM7O0FBRUEsSUFBSWlCLGtCQUFrQixHQUFHbEIsc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsMEdBQUQsQ0FBUixDQUEvQzs7QUFFQSxJQUFJa0IsS0FBSyxHQUFHQyx1QkFBdUIsQ0FBQ25CLG1CQUFPLENBQUMsNENBQUQsQ0FBUixD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MUIsSUFBSTRILGVBQWUsR0FBRzVCLEtBQUssQ0FBQzRCLGVBQTVCOztJQUVBLElBQUlBLGVBQUosRUFBcUI7TUFDbkIsSUFBSUMsb0JBQW9CLEdBQUdDLFdBQVcsQ0FBQyxZQUFZO1FBQ2pELElBQUk3SixVQUFVLENBQUNhLFFBQWYsRUFBeUI7VUFDdkJiLFVBQVUsQ0FBQ2UsV0FBWCxDQUF1QjtZQUNyQnlDLEtBQUssRUFBRTtVQURjLENBQXZCO1FBR0Q7TUFDRixDQU5xQyxFQU1uQ21HLGVBQWUsR0FBRyxJQU5pQixDQUF0QztNQU9BLE9BQU8sWUFBWTtRQUNqQixPQUFPRyxhQUFhLENBQUNGLG9CQUFELENBQXBCO01BQ0QsQ0FGRDtJQUdEO0VBQ0YsQ0FmRCxFQWVHLENBQUM3QixLQUFLLENBQUM0QixlQUFQLENBZkg7RUFnQkEsSUFBSTNOLEtBQUssR0FBR2EsS0FBSyxDQUFDa04sT0FBTixDQUFjLFlBQVk7SUFDcEMsT0FBTztNQUNMdkgsSUFBSSxFQUFFTyxPQUREO01BRUxqQixNQUFNLEVBQUUyRyxPQUFPLEdBQUcsU0FBSCxHQUFlMUYsT0FBTyxHQUFHLGVBQUgsR0FBcUI7SUFGckQsQ0FBUDtFQUlELENBTFcsRUFLVCxDQUFDQSxPQUFELEVBQVUwRixPQUFWLENBTFMsQ0FBWjtFQU1BLE9BQU8sQ0FBQyxHQUFHdkwsV0FBVyxDQUFDOE0sR0FBaEIsRUFBcUI1SSxjQUFjLENBQUM2SSxRQUFwQyxFQUE4QztJQUNuRGpPLEtBQUssRUFBRUEsS0FENEM7SUFFbkRnTSxRQUFRLEVBQUVBO0VBRnlDLENBQTlDLENBQVA7QUFJRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0L2luZGV4LmpzP2MxOWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcclxuXHJcbnZhciBfdHlwZW9mID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbnZhciBfZXhwb3J0TmFtZXMgPSB7XHJcbiAgdXNlU2Vzc2lvbjogdHJ1ZSxcclxuICBnZXRTZXNzaW9uOiB0cnVlLFxyXG4gIGdldENzcmZUb2tlbjogdHJ1ZSxcclxuICBnZXRQcm92aWRlcnM6IHRydWUsXHJcbiAgc2lnbkluOiB0cnVlLFxyXG4gIHNpZ25PdXQ6IHRydWUsXHJcbiAgU2Vzc2lvblByb3ZpZGVyOiB0cnVlXHJcbn07XHJcbmV4cG9ydHMuU2Vzc2lvblByb3ZpZGVyID0gU2Vzc2lvblByb3ZpZGVyO1xyXG5leHBvcnRzLmdldENzcmZUb2tlbiA9IGdldENzcmZUb2tlbjtcclxuZXhwb3J0cy5nZXRQcm92aWRlcnMgPSBnZXRQcm92aWRlcnM7XHJcbmV4cG9ydHMuZ2V0U2Vzc2lvbiA9IGdldFNlc3Npb247XHJcbmV4cG9ydHMuc2lnbkluID0gc2lnbkluO1xyXG5leHBvcnRzLnNpZ25PdXQgPSBzaWduT3V0O1xyXG5leHBvcnRzLnVzZVNlc3Npb24gPSB1c2VTZXNzaW9uO1xyXG5cclxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcclxuXHJcbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XHJcblxyXG52YXIgX3NsaWNlZFRvQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5XCIpKTtcclxuXHJcbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xyXG5cclxudmFyIFJlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcclxuXHJcbnZhciBfbG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuLi91dGlscy9sb2dnZXJcIikpO1xyXG5cclxudmFyIF9wYXJzZVVybCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzL3BhcnNlLXVybFwiKSk7XHJcblxyXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL2NsaWVudC9fdXRpbHNcIik7XHJcblxyXG52YXIgX2pzeFJ1bnRpbWUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XHJcblxyXG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XHJcblxyXG5PYmplY3Qua2V5cyhfdHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xyXG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF90eXBlc1trZXldKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICByZXR1cm4gX3R5cGVzW2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9wcm9jZXNzJGVudiRORVhUQVVUSCwgX3JlZiwgX3Byb2Nlc3MkZW52JE5FWFRBVVRIMiwgX3Byb2Nlc3MkZW52JE5FWFRBVVRIMztcclxuXHJcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XHJcblxyXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxyXG5cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5cclxudmFyIF9fTkVYVEFVVEggPSB7XHJcbiAgYmFzZVVybDogKDAsIF9wYXJzZVVybC5kZWZhdWx0KSgoX3Byb2Nlc3MkZW52JE5FWFRBVVRIID0gcHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMKSAhPT0gbnVsbCAmJiBfcHJvY2VzcyRlbnYkTkVYVEFVVEggIT09IHZvaWQgMCA/IF9wcm9jZXNzJGVudiRORVhUQVVUSCA6IHByb2Nlc3MuZW52LlZFUkNFTF9VUkwpLm9yaWdpbixcclxuICBiYXNlUGF0aDogKDAsIF9wYXJzZVVybC5kZWZhdWx0KShwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkwpLnBhdGgsXHJcbiAgYmFzZVVybFNlcnZlcjogKDAsIF9wYXJzZVVybC5kZWZhdWx0KSgoX3JlZiA9IChfcHJvY2VzcyRlbnYkTkVYVEFVVEgyID0gcHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMX0lOVEVSTkFMKSAhPT0gbnVsbCAmJiBfcHJvY2VzcyRlbnYkTkVYVEFVVEgyICE9PSB2b2lkIDAgPyBfcHJvY2VzcyRlbnYkTkVYVEFVVEgyIDogcHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogcHJvY2Vzcy5lbnYuVkVSQ0VMX1VSTCkub3JpZ2luLFxyXG4gIGJhc2VQYXRoU2VydmVyOiAoMCwgX3BhcnNlVXJsLmRlZmF1bHQpKChfcHJvY2VzcyRlbnYkTkVYVEFVVEgzID0gcHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMX0lOVEVSTkFMKSAhPT0gbnVsbCAmJiBfcHJvY2VzcyRlbnYkTkVYVEFVVEgzICE9PSB2b2lkIDAgPyBfcHJvY2VzcyRlbnYkTkVYVEFVVEgzIDogcHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMKS5wYXRoLFxyXG4gIF9sYXN0U3luYzogMCxcclxuICBfc2Vzc2lvbjogdW5kZWZpbmVkLFxyXG4gIF9nZXRTZXNzaW9uOiBmdW5jdGlvbiBfZ2V0U2Vzc2lvbigpIHt9XHJcbn07XHJcbnZhciBicm9hZGNhc3QgPSAoMCwgX3V0aWxzLkJyb2FkY2FzdENoYW5uZWwpKCk7XHJcbnZhciBsb2dnZXIgPSAoMCwgX2xvZ2dlcjIucHJveHlMb2dnZXIpKF9sb2dnZXIyLmRlZmF1bHQsIF9fTkVYVEFVVEguYmFzZVBhdGgpO1xyXG52YXIgU2Vzc2lvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XHJcblxyXG5mdW5jdGlvbiB1c2VTZXNzaW9uKG9wdGlvbnMpIHtcclxuICB2YXIgdmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KFNlc3Npb25Db250ZXh0KTtcclxuXHJcbiAgaWYgKCF2YWx1ZSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIltuZXh0LWF1dGhdOiBgdXNlU2Vzc2lvbmAgbXVzdCBiZSB3cmFwcGVkIGluIGEgPFNlc3Npb25Qcm92aWRlciAvPlwiKTtcclxuICB9XHJcblxyXG4gIHZhciBfcmVmMiA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LFxyXG4gICAgICByZXF1aXJlZCA9IF9yZWYyLnJlcXVpcmVkLFxyXG4gICAgICBvblVuYXV0aGVudGljYXRlZCA9IF9yZWYyLm9uVW5hdXRoZW50aWNhdGVkO1xyXG5cclxuICB2YXIgcmVxdWlyZWRBbmROb3RMb2FkaW5nID0gcmVxdWlyZWQgJiYgdmFsdWUuc3RhdHVzID09PSBcInVuYXV0aGVudGljYXRlZFwiO1xyXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAocmVxdWlyZWRBbmROb3RMb2FkaW5nKSB7XHJcbiAgICAgIHZhciB1cmwgPSBcIi9hcGkvYXV0aC9zaWduaW4/XCIuY29uY2F0KG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xyXG4gICAgICAgIGVycm9yOiBcIlNlc3Npb25SZXF1aXJlZFwiLFxyXG4gICAgICAgIGNhbGxiYWNrVXJsOiB3aW5kb3cubG9jYXRpb24uaHJlZlxyXG4gICAgICB9KSk7XHJcbiAgICAgIGlmIChvblVuYXV0aGVudGljYXRlZCkgb25VbmF1dGhlbnRpY2F0ZWQoKTtlbHNlIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xyXG4gICAgfVxyXG4gIH0sIFtyZXF1aXJlZEFuZE5vdExvYWRpbmcsIG9uVW5hdXRoZW50aWNhdGVkXSk7XHJcblxyXG4gIGlmIChyZXF1aXJlZEFuZE5vdExvYWRpbmcpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRhdGE6IHZhbHVlLmRhdGEsXHJcbiAgICAgIHN0YXR1czogXCJsb2FkaW5nXCJcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdmFsdWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNlc3Npb24oX3gpIHtcclxuICByZXR1cm4gX2dldFNlc3Npb24yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9nZXRTZXNzaW9uMigpIHtcclxuICBfZ2V0U2Vzc2lvbjIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIocGFyYW1zKSB7XHJcbiAgICB2YXIgX3BhcmFtcyRicm9hZGNhc3Q7XHJcblxyXG4gICAgdmFyIHNlc3Npb247XHJcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XHJcbiAgICAgIHdoaWxlICgxKSB7XHJcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XHJcbiAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcclxuICAgICAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMuZmV0Y2hEYXRhKShcInNlc3Npb25cIiwgX19ORVhUQVVUSCwgbG9nZ2VyLCBwYXJhbXMpO1xyXG5cclxuICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgc2Vzc2lvbiA9IF9jb250ZXh0Mi5zZW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKChfcGFyYW1zJGJyb2FkY2FzdCA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5icm9hZGNhc3QpICE9PSBudWxsICYmIF9wYXJhbXMkYnJvYWRjYXN0ICE9PSB2b2lkIDAgPyBfcGFyYW1zJGJyb2FkY2FzdCA6IHRydWUpIHtcclxuICAgICAgICAgICAgICBicm9hZGNhc3QucG9zdCh7XHJcbiAgICAgICAgICAgICAgICBldmVudDogXCJzZXNzaW9uXCIsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IFwiZ2V0U2Vzc2lvblwiXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHNlc3Npb24pO1xyXG5cclxuICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcclxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LCBfY2FsbGVlMik7XHJcbiAgfSkpO1xyXG4gIHJldHVybiBfZ2V0U2Vzc2lvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Q3NyZlRva2VuKF94Mikge1xyXG4gIHJldHVybiBfZ2V0Q3NyZlRva2VuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9nZXRDc3JmVG9rZW4oKSB7XHJcbiAgX2dldENzcmZUb2tlbiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhwYXJhbXMpIHtcclxuICAgIHZhciByZXNwb25zZTtcclxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcclxuICAgICAgd2hpbGUgKDEpIHtcclxuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcclxuICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyO1xyXG4gICAgICAgICAgICByZXR1cm4gKDAsIF91dGlscy5mZXRjaERhdGEpKFwiY3NyZlwiLCBfX05FWFRBVVRILCBsb2dnZXIsIHBhcmFtcyk7XHJcblxyXG4gICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0My5zZW50O1xyXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuY3NyZlRva2VuKTtcclxuXHJcbiAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSwgX2NhbGxlZTMpO1xyXG4gIH0pKTtcclxuICByZXR1cm4gX2dldENzcmZUb2tlbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRQcm92aWRlcnMoKSB7XHJcbiAgcmV0dXJuIF9nZXRQcm92aWRlcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX2dldFByb3ZpZGVycygpIHtcclxuICBfZ2V0UHJvdmlkZXJzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KCkge1xyXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xyXG4gICAgICB3aGlsZSAoMSkge1xyXG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xyXG4gICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XHJcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmZldGNoRGF0YSkoXCJwcm92aWRlcnNcIiwgX19ORVhUQVVUSCwgbG9nZ2VyKTtcclxuXHJcbiAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NC5zZW50KTtcclxuXHJcbiAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSwgX2NhbGxlZTQpO1xyXG4gIH0pKTtcclxuICByZXR1cm4gX2dldFByb3ZpZGVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaWduSW4oX3gzLCBfeDQsIF94NSkge1xyXG4gIHJldHVybiBfc2lnbkluLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9zaWduSW4oKSB7XHJcbiAgX3NpZ25JbiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNShwcm92aWRlciwgb3B0aW9ucywgYXV0aG9yaXphdGlvblBhcmFtcykge1xyXG4gICAgdmFyIF9yZWY1LCBfcmVmNSRjYWxsYmFja1VybCwgY2FsbGJhY2tVcmwsIF9yZWY1JHJlZGlyZWN0LCByZWRpcmVjdCwgYmFzZVVybCwgcHJvdmlkZXJzLCBpc0NyZWRlbnRpYWxzLCBpc0VtYWlsLCBpc1N1cHBvcnRpbmdSZXR1cm4sIHNpZ25JblVybCwgX3NpZ25JblVybCwgcmVzLCBkYXRhLCBfZGF0YSR1cmwsIHVybCwgZXJyb3I7XHJcblxyXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xyXG4gICAgICB3aGlsZSAoMSkge1xyXG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xyXG4gICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICBfcmVmNSA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCBfcmVmNSRjYWxsYmFja1VybCA9IF9yZWY1LmNhbGxiYWNrVXJsLCBjYWxsYmFja1VybCA9IF9yZWY1JGNhbGxiYWNrVXJsID09PSB2b2lkIDAgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6IF9yZWY1JGNhbGxiYWNrVXJsLCBfcmVmNSRyZWRpcmVjdCA9IF9yZWY1LnJlZGlyZWN0LCByZWRpcmVjdCA9IF9yZWY1JHJlZGlyZWN0ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjUkcmVkaXJlY3Q7XHJcbiAgICAgICAgICAgIGJhc2VVcmwgPSAoMCwgX3V0aWxzLmFwaUJhc2VVcmwpKF9fTkVYVEFVVEgpO1xyXG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQ7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRQcm92aWRlcnMoKTtcclxuXHJcbiAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIHByb3ZpZGVycyA9IF9jb250ZXh0NS5zZW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKHByb3ZpZGVycykge1xyXG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gODtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBcIlwiLmNvbmNhdChiYXNlVXJsLCBcIi9lcnJvclwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIik7XHJcblxyXG4gICAgICAgICAgY2FzZSA4OlxyXG4gICAgICAgICAgICBpZiAoISghcHJvdmlkZXIgfHwgIShwcm92aWRlciBpbiBwcm92aWRlcnMpKSkge1xyXG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTE7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gXCJcIi5jb25jYXQoYmFzZVVybCwgXCIvc2lnbmluP1wiKS5jb25jYXQobmV3IFVSTFNlYXJjaFBhcmFtcyh7XHJcbiAgICAgICAgICAgICAgY2FsbGJhY2tVcmw6IGNhbGxiYWNrVXJsXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIik7XHJcblxyXG4gICAgICAgICAgY2FzZSAxMTpcclxuICAgICAgICAgICAgaXNDcmVkZW50aWFscyA9IHByb3ZpZGVyc1twcm92aWRlcl0udHlwZSA9PT0gXCJjcmVkZW50aWFsc1wiO1xyXG4gICAgICAgICAgICBpc0VtYWlsID0gcHJvdmlkZXJzW3Byb3ZpZGVyXS50eXBlID09PSBcImVtYWlsXCI7XHJcbiAgICAgICAgICAgIGlzU3VwcG9ydGluZ1JldHVybiA9IGlzQ3JlZGVudGlhbHMgfHwgaXNFbWFpbDtcclxuICAgICAgICAgICAgc2lnbkluVXJsID0gXCJcIi5jb25jYXQoYmFzZVVybCwgXCIvXCIpLmNvbmNhdChpc0NyZWRlbnRpYWxzID8gXCJjYWxsYmFja1wiIDogXCJzaWduaW5cIiwgXCIvXCIpLmNvbmNhdChwcm92aWRlcik7XHJcbiAgICAgICAgICAgIF9zaWduSW5VcmwgPSBcIlwiLmNvbmNhdChzaWduSW5VcmwsIFwiP1wiKS5jb25jYXQobmV3IFVSTFNlYXJjaFBhcmFtcyhhdXRob3JpemF0aW9uUGFyYW1zKSk7XHJcbiAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IGZldGNoO1xyXG4gICAgICAgICAgICBfY29udGV4dDUudDEgPSBfc2lnbkluVXJsO1xyXG4gICAgICAgICAgICBfY29udGV4dDUudDIgPSB7XHJcbiAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfY29udGV4dDUudDMgPSBVUkxTZWFyY2hQYXJhbXM7XHJcbiAgICAgICAgICAgIF9jb250ZXh0NS50NCA9IF9vYmplY3RTcHJlYWQ7XHJcbiAgICAgICAgICAgIF9jb250ZXh0NS50NSA9IF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBfY29udGV4dDUudDYgPSB7fTtcclxuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAyNTtcclxuICAgICAgICAgICAgcmV0dXJuIGdldENzcmZUb2tlbigpO1xyXG5cclxuICAgICAgICAgIGNhc2UgMjU6XHJcbiAgICAgICAgICAgIF9jb250ZXh0NS50NyA9IF9jb250ZXh0NS5zZW50O1xyXG4gICAgICAgICAgICBfY29udGV4dDUudDggPSBjYWxsYmFja1VybDtcclxuICAgICAgICAgICAgX2NvbnRleHQ1LnQ5ID0ge1xyXG4gICAgICAgICAgICAgIGNzcmZUb2tlbjogX2NvbnRleHQ1LnQ3LFxyXG4gICAgICAgICAgICAgIGNhbGxiYWNrVXJsOiBfY29udGV4dDUudDgsXHJcbiAgICAgICAgICAgICAganNvbjogdHJ1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfY29udGV4dDUudDEwID0gKDAsIF9jb250ZXh0NS50NCkoX2NvbnRleHQ1LnQ1LCBfY29udGV4dDUudDYsIF9jb250ZXh0NS50OSk7XHJcbiAgICAgICAgICAgIF9jb250ZXh0NS50MTEgPSBuZXcgX2NvbnRleHQ1LnQzKF9jb250ZXh0NS50MTApO1xyXG4gICAgICAgICAgICBfY29udGV4dDUudDEyID0ge1xyXG4gICAgICAgICAgICAgIG1ldGhvZDogXCJwb3N0XCIsXHJcbiAgICAgICAgICAgICAgaGVhZGVyczogX2NvbnRleHQ1LnQyLFxyXG4gICAgICAgICAgICAgIGJvZHk6IF9jb250ZXh0NS50MTFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzMztcclxuICAgICAgICAgICAgcmV0dXJuICgwLCBfY29udGV4dDUudDApKF9jb250ZXh0NS50MSwgX2NvbnRleHQ1LnQxMik7XHJcblxyXG4gICAgICAgICAgY2FzZSAzMzpcclxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQ1LnNlbnQ7XHJcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMzY7XHJcbiAgICAgICAgICAgIHJldHVybiByZXMuanNvbigpO1xyXG5cclxuICAgICAgICAgIGNhc2UgMzY6XHJcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDUuc2VudDtcclxuXHJcbiAgICAgICAgICAgIGlmICghKHJlZGlyZWN0IHx8ICFpc1N1cHBvcnRpbmdSZXR1cm4pKSB7XHJcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0MjtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdXJsID0gKF9kYXRhJHVybCA9IGRhdGEudXJsKSAhPT0gbnVsbCAmJiBfZGF0YSR1cmwgIT09IHZvaWQgMCA/IF9kYXRhJHVybCA6IGNhbGxiYWNrVXJsO1xyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcclxuICAgICAgICAgICAgaWYgKHVybC5pbmNsdWRlcyhcIiNcIikpIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIik7XHJcblxyXG4gICAgICAgICAgY2FzZSA0MjpcclxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgVVJMKGRhdGEudXJsKS5zZWFyY2hQYXJhbXMuZ2V0KFwiZXJyb3JcIik7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXJlcy5vaykge1xyXG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNDY7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNDY7XHJcbiAgICAgICAgICAgIHJldHVybiBfX05FWFRBVVRILl9nZXRTZXNzaW9uKHtcclxuICAgICAgICAgICAgICBldmVudDogXCJzdG9yYWdlXCJcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgY2FzZSA0NjpcclxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xyXG4gICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcclxuICAgICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXHJcbiAgICAgICAgICAgICAgb2s6IHJlcy5vayxcclxuICAgICAgICAgICAgICB1cmw6IGVycm9yID8gbnVsbCA6IGRhdGEudXJsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGNhc2UgNDc6XHJcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSwgX2NhbGxlZTUpO1xyXG4gIH0pKTtcclxuICByZXR1cm4gX3NpZ25Jbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaWduT3V0KF94Nikge1xyXG4gIHJldHVybiBfc2lnbk91dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfc2lnbk91dCgpIHtcclxuICBfc2lnbk91dCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNihvcHRpb25zKSB7XHJcbiAgICB2YXIgX29wdGlvbnMkcmVkaXJlY3Q7XHJcblxyXG4gICAgdmFyIF9yZWY2LCBfcmVmNiRjYWxsYmFja1VybCwgY2FsbGJhY2tVcmwsIGJhc2VVcmwsIGZldGNoT3B0aW9ucywgcmVzLCBkYXRhLCBfZGF0YSR1cmwyLCB1cmw7XHJcblxyXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xyXG4gICAgICB3aGlsZSAoMSkge1xyXG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xyXG4gICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICBfcmVmNiA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCBfcmVmNiRjYWxsYmFja1VybCA9IF9yZWY2LmNhbGxiYWNrVXJsLCBjYWxsYmFja1VybCA9IF9yZWY2JGNhbGxiYWNrVXJsID09PSB2b2lkIDAgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6IF9yZWY2JGNhbGxiYWNrVXJsO1xyXG4gICAgICAgICAgICBiYXNlVXJsID0gKDAsIF91dGlscy5hcGlCYXNlVXJsKShfX05FWFRBVVRIKTtcclxuICAgICAgICAgICAgX2NvbnRleHQ2LnQwID0ge1xyXG4gICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX2NvbnRleHQ2LnQxID0gVVJMU2VhcmNoUGFyYW1zO1xyXG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDY7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRDc3JmVG9rZW4oKTtcclxuXHJcbiAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgIF9jb250ZXh0Ni50MiA9IF9jb250ZXh0Ni5zZW50O1xyXG4gICAgICAgICAgICBfY29udGV4dDYudDMgPSBjYWxsYmFja1VybDtcclxuICAgICAgICAgICAgX2NvbnRleHQ2LnQ0ID0ge1xyXG4gICAgICAgICAgICAgIGNzcmZUb2tlbjogX2NvbnRleHQ2LnQyLFxyXG4gICAgICAgICAgICAgIGNhbGxiYWNrVXJsOiBfY29udGV4dDYudDMsXHJcbiAgICAgICAgICAgICAganNvbjogdHJ1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfY29udGV4dDYudDUgPSBuZXcgX2NvbnRleHQ2LnQxKF9jb250ZXh0Ni50NCk7XHJcbiAgICAgICAgICAgIGZldGNoT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxyXG4gICAgICAgICAgICAgIGhlYWRlcnM6IF9jb250ZXh0Ni50MCxcclxuICAgICAgICAgICAgICBib2R5OiBfY29udGV4dDYudDVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxMztcclxuICAgICAgICAgICAgcmV0dXJuIGZldGNoKFwiXCIuY29uY2F0KGJhc2VVcmwsIFwiL3NpZ25vdXRcIiksIGZldGNoT3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgY2FzZSAxMzpcclxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQ2LnNlbnQ7XHJcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTY7XHJcbiAgICAgICAgICAgIHJldHVybiByZXMuanNvbigpO1xyXG5cclxuICAgICAgICAgIGNhc2UgMTY6XHJcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDYuc2VudDtcclxuICAgICAgICAgICAgYnJvYWRjYXN0LnBvc3Qoe1xyXG4gICAgICAgICAgICAgIGV2ZW50OiBcInNlc3Npb25cIixcclxuICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBcInNpZ25vdXRcIlxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoISgoX29wdGlvbnMkcmVkaXJlY3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVkaXJlY3QpICE9PSBudWxsICYmIF9vcHRpb25zJHJlZGlyZWN0ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRyZWRpcmVjdCA6IHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAyMztcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdXJsID0gKF9kYXRhJHVybDIgPSBkYXRhLnVybCkgIT09IG51bGwgJiYgX2RhdGEkdXJsMiAhPT0gdm9pZCAwID8gX2RhdGEkdXJsMiA6IGNhbGxiYWNrVXJsO1xyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcclxuICAgICAgICAgICAgaWYgKHVybC5pbmNsdWRlcyhcIiNcIikpIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIik7XHJcblxyXG4gICAgICAgICAgY2FzZSAyMzpcclxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAyNTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fTkVYVEFVVEguX2dldFNlc3Npb24oe1xyXG4gICAgICAgICAgICAgIGV2ZW50OiBcInN0b3JhZ2VcIlxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBjYXNlIDI1OlxyXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBkYXRhKTtcclxuXHJcbiAgICAgICAgICBjYXNlIDI2OlxyXG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sIF9jYWxsZWU2KTtcclxuICB9KSk7XHJcbiAgcmV0dXJuIF9zaWduT3V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFNlc3Npb25Qcm92aWRlcihwcm9wcykge1xyXG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxyXG4gICAgICBiYXNlUGF0aCA9IHByb3BzLmJhc2VQYXRoO1xyXG4gIGlmIChiYXNlUGF0aCkgX19ORVhUQVVUSC5iYXNlUGF0aCA9IGJhc2VQYXRoO1xyXG4gIHZhciBoYXNJbml0aWFsU2Vzc2lvbiA9IHByb3BzLnNlc3Npb24gIT09IHVuZGVmaW5lZDtcclxuICBfX05FWFRBVVRILl9sYXN0U3luYyA9IGhhc0luaXRpYWxTZXNzaW9uID8gKDAsIF91dGlscy5ub3cpKCkgOiAwO1xyXG5cclxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGhhc0luaXRpYWxTZXNzaW9uKSBfX05FWFRBVVRILl9zZXNzaW9uID0gcHJvcHMuc2Vzc2lvbjtcclxuICAgIHJldHVybiBwcm9wcy5zZXNzaW9uO1xyXG4gIH0pLFxyXG4gICAgICBfUmVhY3QkdXNlU3RhdGUyID0gKDAsIF9zbGljZWRUb0FycmF5Mi5kZWZhdWx0KShfUmVhY3QkdXNlU3RhdGUsIDIpLFxyXG4gICAgICBzZXNzaW9uID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcclxuICAgICAgc2V0U2Vzc2lvbiA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XHJcblxyXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoIWhhc0luaXRpYWxTZXNzaW9uKSxcclxuICAgICAgX1JlYWN0JHVzZVN0YXRlNCA9ICgwLCBfc2xpY2VkVG9BcnJheTIuZGVmYXVsdCkoX1JlYWN0JHVzZVN0YXRlMywgMiksXHJcbiAgICAgIGxvYWRpbmcgPSBfUmVhY3QkdXNlU3RhdGU0WzBdLFxyXG4gICAgICBzZXRMb2FkaW5nID0gX1JlYWN0JHVzZVN0YXRlNFsxXTtcclxuXHJcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgIF9fTkVYVEFVVEguX2dldFNlc3Npb24gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcclxuICAgICAgdmFyIF9yZWY0LFxyXG4gICAgICAgICAgZXZlbnQsXHJcbiAgICAgICAgICBzdG9yYWdlRXZlbnQsXHJcbiAgICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcclxuXHJcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XHJcbiAgICAgICAgd2hpbGUgKDEpIHtcclxuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgIF9yZWY0ID0gX2FyZ3MubGVuZ3RoID4gMCAmJiBfYXJnc1swXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMF0gOiB7fSwgZXZlbnQgPSBfcmVmNC5ldmVudDtcclxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTtcclxuICAgICAgICAgICAgICBzdG9yYWdlRXZlbnQgPSBldmVudCA9PT0gXCJzdG9yYWdlXCI7XHJcblxyXG4gICAgICAgICAgICAgIGlmICghKHN0b3JhZ2VFdmVudCB8fCBfX05FWFRBVVRILl9zZXNzaW9uID09PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIF9fTkVYVEFVVEguX2xhc3RTeW5jID0gKDAsIF91dGlscy5ub3cpKCk7XHJcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGdldFNlc3Npb24oe1xyXG4gICAgICAgICAgICAgICAgYnJvYWRjYXN0OiAhc3RvcmFnZUV2ZW50XHJcbiAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgX19ORVhUQVVUSC5fc2Vzc2lvbiA9IF9jb250ZXh0LnNlbnQ7XHJcbiAgICAgICAgICAgICAgc2V0U2Vzc2lvbihfX05FWFRBVVRILl9zZXNzaW9uKTtcclxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAxMDpcclxuICAgICAgICAgICAgICBpZiAoISghZXZlbnQgfHwgX19ORVhUQVVUSC5fc2Vzc2lvbiA9PT0gbnVsbCB8fCAoMCwgX3V0aWxzLm5vdykoKSA8IF9fTkVYVEFVVEguX2xhc3RTeW5jKSkge1xyXG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAxMjpcclxuICAgICAgICAgICAgICBfX05FWFRBVVRILl9sYXN0U3luYyA9ICgwLCBfdXRpbHMubm93KSgpO1xyXG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTtcclxuICAgICAgICAgICAgICByZXR1cm4gZ2V0U2Vzc2lvbigpO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAxNTpcclxuICAgICAgICAgICAgICBfX05FWFRBVVRILl9zZXNzaW9uID0gX2NvbnRleHQuc2VudDtcclxuICAgICAgICAgICAgICBzZXRTZXNzaW9uKF9fTkVYVEFVVEguX3Nlc3Npb24pO1xyXG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMjtcclxuICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMTk6XHJcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE5O1xyXG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcclxuICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJDTElFTlRfU0VTU0lPTl9FUlJPUlwiLCBfY29udGV4dC50MCk7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDIyOlxyXG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyMjtcclxuICAgICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDIyKTtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMjU6XHJcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcclxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1sxLCAxOSwgMjIsIDI1XV0pO1xyXG4gICAgfSkpO1xyXG5cclxuICAgIF9fTkVYVEFVVEguX2dldFNlc3Npb24oKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICBfX05FWFRBVVRILl9sYXN0U3luYyA9IDA7XHJcbiAgICAgIF9fTkVYVEFVVEguX3Nlc3Npb24gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICBfX05FWFRBVVRILl9nZXRTZXNzaW9uID0gZnVuY3Rpb24gKCkge307XHJcbiAgICB9O1xyXG4gIH0sIFtdKTtcclxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHVuc3Vic2NyaWJlID0gYnJvYWRjYXN0LnJlY2VpdmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7XHJcbiAgICAgICAgZXZlbnQ6IFwic3RvcmFnZVwiXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdW5zdWJzY3JpYmUoKTtcclxuICAgIH07XHJcbiAgfSwgW10pO1xyXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgX3Byb3BzJHJlZmV0Y2hPbldpbmRvID0gcHJvcHMucmVmZXRjaE9uV2luZG93Rm9jdXMsXHJcbiAgICAgICAgcmVmZXRjaE9uV2luZG93Rm9jdXMgPSBfcHJvcHMkcmVmZXRjaE9uV2luZG8gPT09IHZvaWQgMCA/IHRydWUgOiBfcHJvcHMkcmVmZXRjaE9uV2luZG87XHJcblxyXG4gICAgdmFyIHZpc2liaWxpdHlIYW5kbGVyID0gZnVuY3Rpb24gdmlzaWJpbGl0eUhhbmRsZXIoKSB7XHJcbiAgICAgIGlmIChyZWZldGNoT25XaW5kb3dGb2N1cyAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKSBfX05FWFRBVVRILl9nZXRTZXNzaW9uKHtcclxuICAgICAgICBldmVudDogXCJ2aXNpYmlsaXR5Y2hhbmdlXCJcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHZpc2liaWxpdHlIYW5kbGVyLCBmYWxzZSk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgdmlzaWJpbGl0eUhhbmRsZXIsIGZhbHNlKTtcclxuICAgIH07XHJcbiAgfSwgW3Byb3BzLnJlZmV0Y2hPbldpbmRvd0ZvY3VzXSk7XHJcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciByZWZldGNoSW50ZXJ2YWwgPSBwcm9wcy5yZWZldGNoSW50ZXJ2YWw7XHJcblxyXG4gICAgaWYgKHJlZmV0Y2hJbnRlcnZhbCkge1xyXG4gICAgICB2YXIgcmVmZXRjaEludGVydmFsVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF9fTkVYVEFVVEguX3Nlc3Npb24pIHtcclxuICAgICAgICAgIF9fTkVYVEFVVEguX2dldFNlc3Npb24oe1xyXG4gICAgICAgICAgICBldmVudDogXCJwb2xsXCJcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgcmVmZXRjaEludGVydmFsICogMTAwMCk7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNsZWFySW50ZXJ2YWwocmVmZXRjaEludGVydmFsVGltZXIpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0sIFtwcm9wcy5yZWZldGNoSW50ZXJ2YWxdKTtcclxuICB2YXIgdmFsdWUgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRhdGE6IHNlc3Npb24sXHJcbiAgICAgIHN0YXR1czogbG9hZGluZyA/IFwibG9hZGluZ1wiIDogc2Vzc2lvbiA/IFwiYXV0aGVudGljYXRlZFwiIDogXCJ1bmF1dGhlbnRpY2F0ZWRcIlxyXG4gICAgfTtcclxuICB9LCBbc2Vzc2lvbiwgbG9hZGluZ10pO1xyXG4gIHJldHVybiAoMCwgX2pzeFJ1bnRpbWUuanN4KShTZXNzaW9uQ29udGV4dC5Qcm92aWRlciwge1xyXG4gICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXHJcbiAgfSk7XHJcbn0iXSwibmFtZXMiOlsiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfdHlwZW9mIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfZXhwb3J0TmFtZXMiLCJ1c2VTZXNzaW9uIiwiZ2V0U2Vzc2lvbiIsImdldENzcmZUb2tlbiIsImdldFByb3ZpZGVycyIsInNpZ25JbiIsInNpZ25PdXQiLCJTZXNzaW9uUHJvdmlkZXIiLCJfcmVnZW5lcmF0b3IiLCJfZGVmaW5lUHJvcGVydHkyIiwiX3NsaWNlZFRvQXJyYXkyIiwiX2FzeW5jVG9HZW5lcmF0b3IyIiwiUmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsIl9sb2dnZXIyIiwiX3BhcnNlVXJsIiwiX3V0aWxzIiwiX2pzeFJ1bnRpbWUiLCJfdHlwZXMiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImVudW1lcmFibGUiLCJnZXQiLCJfcHJvY2VzcyRlbnYkTkVYVEFVVEgiLCJfcmVmIiwiX3Byb2Nlc3MkZW52JE5FWFRBVVRIMiIsIl9wcm9jZXNzJGVudiRORVhUQVVUSDMiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJub2RlSW50ZXJvcCIsIldlYWtNYXAiLCJjYWNoZUJhYmVsSW50ZXJvcCIsImNhY2hlTm9kZUludGVyb3AiLCJvYmoiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsImNhY2hlIiwiaGFzIiwibmV3T2JqIiwiaGFzUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVzYyIsInNldCIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX19ORVhUQVVUSCIsImJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVEFVVEhfVVJMIiwiVkVSQ0VMX1VSTCIsIm9yaWdpbiIsImJhc2VQYXRoIiwicGF0aCIsImJhc2VVcmxTZXJ2ZXIiLCJORVhUQVVUSF9VUkxfSU5URVJOQUwiLCJiYXNlUGF0aFNlcnZlciIsIl9sYXN0U3luYyIsIl9zZXNzaW9uIiwidW5kZWZpbmVkIiwiX2dldFNlc3Npb24iLCJicm9hZGNhc3QiLCJCcm9hZGNhc3RDaGFubmVsIiwibG9nZ2VyIiwicHJveHlMb2dnZXIiLCJTZXNzaW9uQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJvcHRpb25zIiwidXNlQ29udGV4dCIsIk5PREVfRU5WIiwiRXJyb3IiLCJfcmVmMiIsInJlcXVpcmVkIiwib25VbmF1dGhlbnRpY2F0ZWQiLCJyZXF1aXJlZEFuZE5vdExvYWRpbmciLCJzdGF0dXMiLCJ1c2VFZmZlY3QiLCJ1cmwiLCJjb25jYXQiLCJVUkxTZWFyY2hQYXJhbXMiLCJlcnJvciIsImNhbGxiYWNrVXJsIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiZGF0YSIsIl94IiwiX2dldFNlc3Npb24yIiwibWFyayIsIl9jYWxsZWUyIiwicGFyYW1zIiwiX3BhcmFtcyRicm9hZGNhc3QiLCJzZXNzaW9uIiwid3JhcCIsIl9jYWxsZWUyJCIsIl9jb250ZXh0MiIsInByZXYiLCJuZXh0IiwiZmV0Y2hEYXRhIiwic2VudCIsInBvc3QiLCJldmVudCIsInRyaWdnZXIiLCJhYnJ1cHQiLCJzdG9wIiwiX3gyIiwiX2dldENzcmZUb2tlbiIsIl9jYWxsZWUzIiwicmVzcG9uc2UiLCJfY2FsbGVlMyQiLCJfY29udGV4dDMiLCJjc3JmVG9rZW4iLCJfZ2V0UHJvdmlkZXJzIiwiX2NhbGxlZTQiLCJfY2FsbGVlNCQiLCJfY29udGV4dDQiLCJfeDMiLCJfeDQiLCJfeDUiLCJfc2lnbkluIiwiX2NhbGxlZTUiLCJwcm92aWRlciIsImF1dGhvcml6YXRpb25QYXJhbXMiLCJfcmVmNSIsIl9yZWY1JGNhbGxiYWNrVXJsIiwiX3JlZjUkcmVkaXJlY3QiLCJyZWRpcmVjdCIsInByb3ZpZGVycyIsImlzQ3JlZGVudGlhbHMiLCJpc0VtYWlsIiwiaXNTdXBwb3J0aW5nUmV0dXJuIiwic2lnbkluVXJsIiwiX3NpZ25JblVybCIsInJlcyIsIl9kYXRhJHVybCIsIl9jYWxsZWU1JCIsIl9jb250ZXh0NSIsImFwaUJhc2VVcmwiLCJ0eXBlIiwidDAiLCJmZXRjaCIsInQxIiwidDIiLCJ0MyIsInQ0IiwidDUiLCJ0NiIsInQ3IiwidDgiLCJ0OSIsImpzb24iLCJ0MTAiLCJ0MTEiLCJ0MTIiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsImluY2x1ZGVzIiwicmVsb2FkIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwib2siLCJfeDYiLCJfc2lnbk91dCIsIl9jYWxsZWU2IiwiX29wdGlvbnMkcmVkaXJlY3QiLCJfcmVmNiIsIl9yZWY2JGNhbGxiYWNrVXJsIiwiZmV0Y2hPcHRpb25zIiwiX2RhdGEkdXJsMiIsIl9jYWxsZWU2JCIsIl9jb250ZXh0NiIsInByb3BzIiwiY2hpbGRyZW4iLCJoYXNJbml0aWFsU2Vzc2lvbiIsIm5vdyIsIl9SZWFjdCR1c2VTdGF0ZSIsInVzZVN0YXRlIiwiX1JlYWN0JHVzZVN0YXRlMiIsInNldFNlc3Npb24iLCJfUmVhY3QkdXNlU3RhdGUzIiwiX1JlYWN0JHVzZVN0YXRlNCIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiX2NhbGxlZSIsIl9yZWY0Iiwic3RvcmFnZUV2ZW50IiwiX2FyZ3MiLCJfY2FsbGVlJCIsIl9jb250ZXh0IiwiZmluaXNoIiwidW5zdWJzY3JpYmUiLCJyZWNlaXZlIiwiX3Byb3BzJHJlZmV0Y2hPbldpbmRvIiwicmVmZXRjaE9uV2luZG93Rm9jdXMiLCJ2aXNpYmlsaXR5SGFuZGxlciIsImRvY3VtZW50IiwidmlzaWJpbGl0eVN0YXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZWZldGNoSW50ZXJ2YWwiLCJyZWZldGNoSW50ZXJ2YWxUaW1lciIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInVzZU1lbW8iLCJqc3giLCJQcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next-auth/react/index.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/react/types.js":
/*!***********************************************!*\
  !*** ./node_modules/next-auth/react/types.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0L3R5cGVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViQSw4Q0FBNkM7RUFDM0NHLEtBQUssRUFBRTtBQURvQyxDQUE3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0L3R5cGVzLmpzPzFlNWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next-auth/react/types.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/utils/logger.js":
/*!************************************************!*\
  !*** ./node_modules/next-auth/utils/logger.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nexports.proxyLogger = proxyLogger;\nexports.setLogger = setLogger;\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _errors = __webpack_require__(/*! ../core/errors */ \"./node_modules/next-auth/core/errors.js\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction formatError(o) {\n  if (o instanceof Error && !(o instanceof _errors.UnknownError)) {\n    return {\n      message: o.message,\n      stack: o.stack,\n      name: o.name\n    };\n  }\n\n  if (hasErrorProperty(o)) {\n    var _o$message;\n\n    o.error = formatError(o.error);\n    o.message = (_o$message = o.message) !== null && _o$message !== void 0 ? _o$message : o.error.message;\n  }\n\n  return o;\n}\n\nfunction hasErrorProperty(x) {\n  return !!(x !== null && x !== void 0 && x.error);\n}\n\nvar _logger = {\n  error: function error(code, metadata) {\n    metadata = formatError(metadata);\n    console.error(\"[next-auth][error][\".concat(code, \"]\"), \"\\nhttps://next-auth.js.org/errors#\".concat(code.toLowerCase()), metadata.message, metadata);\n  },\n  warn: function warn(code) {\n    console.warn(\"[next-auth][warn][\".concat(code, \"]\"), \"\\nhttps://next-auth.js.org/warnings#\".concat(code.toLowerCase()));\n  },\n  debug: function debug(code, metadata) {\n    console.log(\"[next-auth][debug][\".concat(code, \"]\"), metadata);\n  }\n};\n\nfunction setLogger() {\n  var newLogger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var debug = arguments.length > 1 ? arguments[1] : undefined;\n  if (!debug) _logger.debug = function () {};\n  if (newLogger.error) _logger.error = newLogger.error;\n  if (newLogger.warn) _logger.warn = newLogger.warn;\n  if (newLogger.debug) _logger.debug = newLogger.debug;\n}\n\nvar _default = _logger;\nexports[\"default\"] = _default;\n\nfunction proxyLogger() {\n  var logger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _logger;\n  var basePath = arguments.length > 1 ? arguments[1] : undefined;\n\n  try {\n    if (typeof window === \"undefined\") {\n      return logger;\n    }\n\n    var clientLogger = {};\n\n    var _loop = function _loop(level) {\n      clientLogger[level] = function (code, metadata) {\n        _logger[level](code, metadata);\n\n        if (level === \"error\") {\n          metadata = formatError(metadata);\n        }\n\n        ;\n        metadata.client = true;\n        var url = \"\".concat(basePath, \"/_log\");\n        var body = new URLSearchParams(_objectSpread({\n          level: level,\n          code: code\n        }, metadata));\n\n        if (navigator.sendBeacon) {\n          return navigator.sendBeacon(url, body);\n        }\n\n        return fetch(url, {\n          method: \"POST\",\n          body: body,\n          keepalive: true\n        });\n      };\n    };\n\n    for (var level in logger) {\n      _loop(level);\n    }\n\n    return clientLogger;\n  } catch (_unused) {\n    return _logger;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3V0aWxzL2xvZ2dlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJQSxzQkFBc0IsR0FBR0MsbUJBQU8sQ0FBQyxvSEFBRCxDQUFwQzs7QUFFQUMsOENBQTZDO0VBQzNDRyxLQUFLLEVBQUU7QUFEb0MsQ0FBN0M7QUFHQUQsa0JBQUEsR0FBa0IsS0FBSyxDQUF2QjtBQUNBQSxtQkFBQSxHQUFzQkcsV0FBdEI7QUFDQUgsaUJBQUEsR0FBb0JJLFNBQXBCOztBQUVBLElBQUlDLGdCQUFnQixHQUFHVCxzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxzR0FBRCxDQUFSLENBQTdDOztBQUVBLElBQUlTLE9BQU8sR0FBR1QsbUJBQU8sQ0FBQywrREFBRCxDQUFyQjs7QUFFQSxTQUFTVSxPQUFULENBQWlCQyxNQUFqQixFQUF5QkMsY0FBekIsRUFBeUM7RUFBRSxJQUFJQyxJQUFJLEdBQUdaLE1BQU0sQ0FBQ1ksSUFBUCxDQUFZRixNQUFaLENBQVg7O0VBQWdDLElBQUlWLE1BQU0sQ0FBQ2EscUJBQVgsRUFBa0M7SUFBRSxJQUFJQyxPQUFPLEdBQUdkLE1BQU0sQ0FBQ2EscUJBQVAsQ0FBNkJILE1BQTdCLENBQWQ7SUFBb0RDLGNBQWMsS0FBS0csT0FBTyxHQUFHQSxPQUFPLENBQUNDLE1BQVIsQ0FBZSxVQUFVQyxHQUFWLEVBQWU7TUFBRSxPQUFPaEIsTUFBTSxDQUFDaUIsd0JBQVAsQ0FBZ0NQLE1BQWhDLEVBQXdDTSxHQUF4QyxFQUE2Q0UsVUFBcEQ7SUFBaUUsQ0FBakcsQ0FBZixDQUFkLEVBQWtJTixJQUFJLENBQUNPLElBQUwsQ0FBVUMsS0FBVixDQUFnQlIsSUFBaEIsRUFBc0JFLE9BQXRCLENBQWxJO0VBQW1LOztFQUFDLE9BQU9GLElBQVA7QUFBYzs7QUFFclYsU0FBU1MsYUFBVCxDQUF1QkMsTUFBdkIsRUFBK0I7RUFBRSxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdDLFNB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aEJMLElBQUksRUFBRUEsSUFGVTtVQUdoQk0sU0FBUyxFQUFFO1FBSEssQ0FBTixDQUFaO01BS0QsQ0F4QkQ7SUF5QkQsQ0ExQkQ7O0lBNEJBLEtBQUssSUFBSVQsS0FBVCxJQUFrQkwsTUFBbEIsRUFBMEI7TUFDeEJJLEtBQUssQ0FBQ0MsS0FBRCxDQUFMO0lBQ0Q7O0lBRUQsT0FBT0YsWUFBUDtFQUNELENBeENELENBd0NFLE9BQU9ZLE9BQVAsRUFBZ0I7SUFDaEIsT0FBTzNCLE9BQVA7RUFDRDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvdXRpbHMvbG9nZ2VyLmpzP2YyOTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XHJcbmV4cG9ydHMucHJveHlMb2dnZXIgPSBwcm94eUxvZ2dlcjtcclxuZXhwb3J0cy5zZXRMb2dnZXIgPSBzZXRMb2dnZXI7XHJcblxyXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xyXG5cclxudmFyIF9lcnJvcnMgPSByZXF1aXJlKFwiLi4vY29yZS9lcnJvcnNcIik7XHJcblxyXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxyXG5cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0RXJyb3Iobykge1xyXG4gIGlmIChvIGluc3RhbmNlb2YgRXJyb3IgJiYgIShvIGluc3RhbmNlb2YgX2Vycm9ycy5Vbmtub3duRXJyb3IpKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBtZXNzYWdlOiBvLm1lc3NhZ2UsXHJcbiAgICAgIHN0YWNrOiBvLnN0YWNrLFxyXG4gICAgICBuYW1lOiBvLm5hbWVcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBpZiAoaGFzRXJyb3JQcm9wZXJ0eShvKSkge1xyXG4gICAgdmFyIF9vJG1lc3NhZ2U7XHJcblxyXG4gICAgby5lcnJvciA9IGZvcm1hdEVycm9yKG8uZXJyb3IpO1xyXG4gICAgby5tZXNzYWdlID0gKF9vJG1lc3NhZ2UgPSBvLm1lc3NhZ2UpICE9PSBudWxsICYmIF9vJG1lc3NhZ2UgIT09IHZvaWQgMCA/IF9vJG1lc3NhZ2UgOiBvLmVycm9yLm1lc3NhZ2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbztcclxufVxyXG5cclxuZnVuY3Rpb24gaGFzRXJyb3JQcm9wZXJ0eSh4KSB7XHJcbiAgcmV0dXJuICEhKHggIT09IG51bGwgJiYgeCAhPT0gdm9pZCAwICYmIHguZXJyb3IpO1xyXG59XHJcblxyXG52YXIgX2xvZ2dlciA9IHtcclxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoY29kZSwgbWV0YWRhdGEpIHtcclxuICAgIG1ldGFkYXRhID0gZm9ybWF0RXJyb3IobWV0YWRhdGEpO1xyXG4gICAgY29uc29sZS5lcnJvcihcIltuZXh0LWF1dGhdW2Vycm9yXVtcIi5jb25jYXQoY29kZSwgXCJdXCIpLCBcIlxcbmh0dHBzOi8vbmV4dC1hdXRoLmpzLm9yZy9lcnJvcnMjXCIuY29uY2F0KGNvZGUudG9Mb3dlckNhc2UoKSksIG1ldGFkYXRhLm1lc3NhZ2UsIG1ldGFkYXRhKTtcclxuICB9LFxyXG4gIHdhcm46IGZ1bmN0aW9uIHdhcm4oY29kZSkge1xyXG4gICAgY29uc29sZS53YXJuKFwiW25leHQtYXV0aF1bd2Fybl1bXCIuY29uY2F0KGNvZGUsIFwiXVwiKSwgXCJcXG5odHRwczovL25leHQtYXV0aC5qcy5vcmcvd2FybmluZ3MjXCIuY29uY2F0KGNvZGUudG9Mb3dlckNhc2UoKSkpO1xyXG4gIH0sXHJcbiAgZGVidWc6IGZ1bmN0aW9uIGRlYnVnKGNvZGUsIG1ldGFkYXRhKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIltuZXh0LWF1dGhdW2RlYnVnXVtcIi5jb25jYXQoY29kZSwgXCJdXCIpLCBtZXRhZGF0YSk7XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gc2V0TG9nZ2VyKCkge1xyXG4gIHZhciBuZXdMb2dnZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xyXG4gIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xyXG4gIGlmICghZGVidWcpIF9sb2dnZXIuZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcclxuICBpZiAobmV3TG9nZ2VyLmVycm9yKSBfbG9nZ2VyLmVycm9yID0gbmV3TG9nZ2VyLmVycm9yO1xyXG4gIGlmIChuZXdMb2dnZXIud2FybikgX2xvZ2dlci53YXJuID0gbmV3TG9nZ2VyLndhcm47XHJcbiAgaWYgKG5ld0xvZ2dlci5kZWJ1ZykgX2xvZ2dlci5kZWJ1ZyA9IG5ld0xvZ2dlci5kZWJ1ZztcclxufVxyXG5cclxudmFyIF9kZWZhdWx0ID0gX2xvZ2dlcjtcclxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XHJcblxyXG5mdW5jdGlvbiBwcm94eUxvZ2dlcigpIHtcclxuICB2YXIgbG9nZ2VyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBfbG9nZ2VyO1xyXG4gIHZhciBiYXNlUGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xyXG5cclxuICB0cnkge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgcmV0dXJuIGxvZ2dlcjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2xpZW50TG9nZ2VyID0ge307XHJcblxyXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AobGV2ZWwpIHtcclxuICAgICAgY2xpZW50TG9nZ2VyW2xldmVsXSA9IGZ1bmN0aW9uIChjb2RlLCBtZXRhZGF0YSkge1xyXG4gICAgICAgIF9sb2dnZXJbbGV2ZWxdKGNvZGUsIG1ldGFkYXRhKTtcclxuXHJcbiAgICAgICAgaWYgKGxldmVsID09PSBcImVycm9yXCIpIHtcclxuICAgICAgICAgIG1ldGFkYXRhID0gZm9ybWF0RXJyb3IobWV0YWRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgO1xyXG4gICAgICAgIG1ldGFkYXRhLmNsaWVudCA9IHRydWU7XHJcbiAgICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KGJhc2VQYXRoLCBcIi9fbG9nXCIpO1xyXG4gICAgICAgIHZhciBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhfb2JqZWN0U3ByZWFkKHtcclxuICAgICAgICAgIGxldmVsOiBsZXZlbCxcclxuICAgICAgICAgIGNvZGU6IGNvZGVcclxuICAgICAgICB9LCBtZXRhZGF0YSkpO1xyXG5cclxuICAgICAgICBpZiAobmF2aWdhdG9yLnNlbmRCZWFjb24pIHtcclxuICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3Iuc2VuZEJlYWNvbih1cmwsIGJvZHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZldGNoKHVybCwge1xyXG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgICAgIGJvZHk6IGJvZHksXHJcbiAgICAgICAgICBrZWVwYWxpdmU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgZm9yICh2YXIgbGV2ZWwgaW4gbG9nZ2VyKSB7XHJcbiAgICAgIF9sb29wKGxldmVsKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2xpZW50TG9nZ2VyO1xyXG4gIH0gY2F0Y2ggKF91bnVzZWQpIHtcclxuICAgIHJldHVybiBfbG9nZ2VyO1xyXG4gIH1cclxufSJdLCJuYW1lcyI6WyJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsInByb3h5TG9nZ2VyIiwic2V0TG9nZ2VyIiwiX2RlZmluZVByb3BlcnR5MiIsIl9lcnJvcnMiLCJvd25LZXlzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImZvckVhY2giLCJrZXkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImZvcm1hdEVycm9yIiwibyIsIkVycm9yIiwiVW5rbm93bkVycm9yIiwibWVzc2FnZSIsInN0YWNrIiwibmFtZSIsImhhc0Vycm9yUHJvcGVydHkiLCJfbyRtZXNzYWdlIiwiZXJyb3IiLCJ4IiwiX2xvZ2dlciIsImNvZGUiLCJtZXRhZGF0YSIsImNvbnNvbGUiLCJjb25jYXQiLCJ0b0xvd2VyQ2FzZSIsIndhcm4iLCJkZWJ1ZyIsImxvZyIsIm5ld0xvZ2dlciIsInVuZGVmaW5lZCIsIl9kZWZhdWx0IiwibG9nZ2VyIiwiYmFzZVBhdGgiLCJ3aW5kb3ciLCJjbGllbnRMb2dnZXIiLCJfbG9vcCIsImxldmVsIiwiY2xpZW50IiwidXJsIiwiYm9keSIsIlVSTFNlYXJjaFBhcmFtcyIsIm5hdmlnYXRvciIsInNlbmRCZWFjb24iLCJmZXRjaCIsIm1ldGhvZCIsImtlZXBhbGl2ZSIsIl91bnVzZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next-auth/utils/logger.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/utils/parse-url.js":
/*!***************************************************!*\
  !*** ./node_modules/next-auth/utils/parse-url.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = parseUrl;\n\nfunction parseUrl(url) {\n  var _url2;\n\n  const defaultUrl = new URL(\"http://localhost:3000/api/auth\");\n\n  if (url && !url.startsWith(\"http\")) {\n    url = `https://${url}`;\n  }\n\n  const _url = new URL((_url2 = url) !== null && _url2 !== void 0 ? _url2 : defaultUrl);\n\n  const path = (_url.pathname === \"/\" ? defaultUrl.pathname : _url.pathname).replace(/\\/$/, \"\");\n  const base = `${_url.origin}${path}`;\n  return {\n    origin: _url.origin,\n    host: _url.host,\n    path,\n    base,\n    toString: () => base\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3V0aWxzL3BhcnNlLXVybC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYkEsOENBQTZDO0VBQzNDRyxLQUFLLEVBQUU7QUFEb0MsQ0FBN0M7QUFHQUQsa0JBQUEsR0FBa0JHLFFBQWxCOztBQUVBLFNBQVNBLFFBQVQsQ0FBa0JDLEdBQWxCLEVBQXVCO0VBQ3JCLElBQUlDLEtBQUo7O0VBRUEsTUFBTUMsVUFBVSxHQUFHLElBQUlDLEdBQUosQ0FBUSxnQ0FBUixDQUFuQjs7RUFFQSxJQUFJSCxHQUFHLElBQUksQ0FBQ0EsR0FBRyxDQUFDSSxVQUFKLENBQWUsTUFBZixDQUFaLEVBQW9DO0lBQ2xDSixHQUFHLEdBQUksV0FBVUEsR0FBSSxFQUFyQjtFQUNEOztFQUVELE1BQU1LLElBQUksR0FBRyxJQUFJRixHQUFKLENBQVEsQ0FBQ0YsS0FBSyxHQUFHRCxHQUFULE1BQWtCLElBQWxCLElBQTBCQyxLQUFLLEtBQUssS0FBSyxDQUF6QyxHQUE2Q0EsS0FBN0MsR0FBcURDLFVBQTdELENBQWI7O0VBRUEsTUFBTUksSUFBSSxHQUFHLENBQUNELElBQUksQ0FBQ0UsUUFBTCxLQUFrQixHQUFsQixHQUF3QkwsVUFBVSxDQUFDSyxRQUFuQyxHQUE4Q0YsSUFBSSxDQUFDRSxRQUFwRCxFQUE4REMsT0FBOUQsQ0FBc0UsS0FBdEUsRUFBNkUsRUFBN0UsQ0FBYjtFQUNBLE1BQU1DLElBQUksR0FBSSxHQUFFSixJQUFJLENBQUNLLE1BQU8sR0FBRUosSUFBSyxFQUFuQztFQUNBLE9BQU87SUFDTEksTUFBTSxFQUFFTCxJQUFJLENBQUNLLE1BRFI7SUFFTEMsSUFBSSxFQUFFTixJQUFJLENBQUNNLElBRk47SUFHTEwsSUFISztJQUlMRyxJQUpLO0lBS0xHLFFBQVEsRUFBRSxNQUFNSDtFQUxYLENBQVA7QUFPRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3V0aWxzL3BhcnNlLXVybC5qcz9jMzM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlVXJsO1xyXG5cclxuZnVuY3Rpb24gcGFyc2VVcmwodXJsKSB7XHJcbiAgdmFyIF91cmwyO1xyXG5cclxuICBjb25zdCBkZWZhdWx0VXJsID0gbmV3IFVSTChcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aFwiKTtcclxuXHJcbiAgaWYgKHVybCAmJiAhdXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XHJcbiAgICB1cmwgPSBgaHR0cHM6Ly8ke3VybH1gO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgX3VybCA9IG5ldyBVUkwoKF91cmwyID0gdXJsKSAhPT0gbnVsbCAmJiBfdXJsMiAhPT0gdm9pZCAwID8gX3VybDIgOiBkZWZhdWx0VXJsKTtcclxuXHJcbiAgY29uc3QgcGF0aCA9IChfdXJsLnBhdGhuYW1lID09PSBcIi9cIiA/IGRlZmF1bHRVcmwucGF0aG5hbWUgOiBfdXJsLnBhdGhuYW1lKS5yZXBsYWNlKC9cXC8kLywgXCJcIik7XHJcbiAgY29uc3QgYmFzZSA9IGAke191cmwub3JpZ2lufSR7cGF0aH1gO1xyXG4gIHJldHVybiB7XHJcbiAgICBvcmlnaW46IF91cmwub3JpZ2luLFxyXG4gICAgaG9zdDogX3VybC5ob3N0LFxyXG4gICAgcGF0aCxcclxuICAgIGJhc2UsXHJcbiAgICB0b1N0cmluZzogKCkgPT4gYmFzZVxyXG4gIH07XHJcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwicGFyc2VVcmwiLCJ1cmwiLCJfdXJsMiIsImRlZmF1bHRVcmwiLCJVUkwiLCJzdGFydHNXaXRoIiwiX3VybCIsInBhdGgiLCJwYXRobmFtZSIsInJlcGxhY2UiLCJiYXNlIiwib3JpZ2luIiwiaG9zdCIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next-auth/utils/parse-url.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar ref, ref1;\nmodule.exports = ((ref = __webpack_require__.g.process) == null ? void 0 : ref.env) && typeof ((ref1 = __webpack_require__.g.process) == null ? void 0 : ref1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! ../../compiled/process */ \"./node_modules/next/dist/compiled/process/browser.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBQTs7SUFDRUMsS0FBOEJBO0FBRGhDRCxNQUFNLENBQUNFLE9BQVBGLEdBQ0VDLEtBQWMsR0FBZEEscUJBQU0sQ0FBQ0UsT0FBUEYsS0FBYyxJQUFkQSxlQUFjLENBQUVHLEdBQWhCSCxLQUF1QixRQUFPQSxLQUFjLEdBQWRBLHFCQUFNLENBQUNFLE9BQVBGLEtBQWMsSUFBZEEsZ0JBQWMsQ0FBRUcsR0FBdkIsTUFBK0IsUUFBdERILEdBQ0lBLHFCQUFNLENBQUNFLE9BRFhGLEdBRUlJLG1CQUFPLENBQUMsb0ZBQUQsQ0FIYkwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzPzkyOWIiXSwibmFtZXMiOlsibW9kdWxlIiwiZ2xvYmFsIiwiZXhwb3J0cyIsInByb2Nlc3MiLCJlbnYiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/*\r\n  MIT License http://www.opensource.org/licenses/mit-license.php\r\n  Author Tobias Koppers @sokra\r\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function (useSourceMap) {\n  var list = [] // return the list of modules as css string\n  ;\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  } // import a list of modules into the list\n  ; // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \"\" // eslint-disable-next-line prefer-destructuring\n  ;\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \"function\") {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFNQUE7QUFOQTs7OztBQUlBO0FBQ0E7O0FBQ0FBLE1BQU0sQ0FBQ0MsT0FBUEQsR0FBaUIsVUFBVUUsWUFBVixFQUF3QjtFQUN2QyxJQUFJQyxJQUFJLEdBQUcsRUFBWCxDQUFjO0VBQWQ7O0VBRUFBLElBQUksQ0FBQ0MsUUFBTEQsR0FBZ0IsU0FBU0MsUUFBVCxHQUFvQjtJQUNsQyxPQUFPLEtBQUtDLEdBQUwsQ0FBUyxVQUFVQyxJQUFWLEVBQWdCO01BQzlCLElBQUlDLE9BQU8sR0FBR0Msc0JBQXNCLENBQUNGLElBQUQsRUFBT0osWUFBUCxDQUFwQzs7TUFFQSxJQUFJSSxJQUFJLENBQUMsQ0FBRCxDQUFSLEVBQWE7UUFDWCxPQUFPLFVBQVVHLE1BQVYsQ0FBaUJILElBQUksQ0FBQyxDQUFELENBQXJCLEVBQTBCLElBQTFCLEVBQWdDRyxNQUFoQyxDQUF1Q0YsT0FBdkMsRUFBZ0QsR0FBaEQsQ0FBUDtNQUNEOztNQUVELE9BQU9BLE9BQVA7SUFDRCxDQVJNLEVBUUpHLElBUkksQ0FRQyxFQVJELENBQVA7RUFTRCxDQVZEUCxDQVVFO0VBVkZBLENBSHVDLENBY3ZDOzs7RUFFQUEsSUFBSSxDQUFDUSxDQUFMUixHQUFTLFVBQVVTLE9BQVYsRUFBbUJDLFVBQW5CLEVBQStCQyxNQUEvQixFQUF1QztJQUM5QyxJQUFJLE9BQU9GLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7TUFDL0I7TUFDQUEsT0FBTyxHQUFHLENBQUMsQ0FBQyxJQUFELEVBQU9BLE9BQVAsRUFBZ0IsRUFBaEIsQ0FBRCxDQUFWQTtJQUNEOztJQUVELElBQUlHLHNCQUFzQixHQUFHLEVBQTdCOztJQUVBLElBQUlELE1BQUosRUFBWTtNQUNWLEtBQUssSUFBSUgsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLSyxNQUF6QixFQUFpQ0wsQ0FBQyxFQUFsQyxFQUFzQztRQUNwQztRQUNBLElBQUlNLEVBQUUsR0FBRyxLQUFLTixDQUFMLEVBQVEsQ0FBUixDQUFUOztRQUVBLElBQUlNLEVBQUUsSUFBSSxJQUFWLEVBQWdCO1VBQ2RGLHNCQUFzQixDQUFDRSxFQUFELENBQXRCRixHQUE2QixJQUE3QkE7UUFDRDtNQUNGO0lBQ0Y7O0lBRUQsS0FBSyxJQUFJRyxFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxHQUFHTixPQUFPLENBQUNJLE1BQTlCLEVBQXNDRSxFQUFFLEVBQXhDLEVBQTRDO01BQzFDLElBQUlaLElBQUksR0FBRyxHQUFHRyxNQUFILENBQVVHLE9BQU8sQ0FBQ00sRUFBRCxDQUFqQixDQUFYOztNQUVBLElBQUlKLE1BQU0sSUFBSUMsc0JBQXNCLENBQUNULElBQUksQ0FBQyxDQUFELENBQUwsQ0FBcEMsRUFBK0M7UUFFN0M7TUFDRDs7TUFFRCxJQUFJTyxVQUFKLEVBQWdCO1FBQ2QsSUFBSSxDQUFDUCxJQUFJLENBQUMsQ0FBRCxDQUFULEVBQWM7VUFDWkEsSUFBSSxDQUFDLENBQUQsQ0FBSkEsR0FBVU8sVUFBVlA7UUFDRCxDQUZELE1BRU87VUFDTEEsSUFBSSxDQUFDLENBQUQsQ0FBSkEsR0FBVSxHQUFHRyxNQUFILENBQVVJLFVBQVYsRUFBc0IsT0FBdEIsRUFBK0JKLE1BQS9CLENBQXNDSCxJQUFJLENBQUMsQ0FBRCxDQUExQyxDQUFWQTtRQUNEO01BQ0Y7O01BRURILElBQUksQ0FBQ2dCLElBQUxoQixDQUFVRyxJQUFWSDtJQUNEO0VBQ0YsQ0FyQ0RBOztFQXVDQSxPQUFPQSxJQUFQO0FBQ0QsQ0F4RERIOztBQTBEQSxTQUFTUSxzQkFBVCxDQUFnQ0YsSUFBaEMsRUFBc0NKLFlBQXRDLEVBQW9EO0VBQ2xELElBQUlLLE9BQU8sR0FBR0QsSUFBSSxDQUFDLENBQUQsQ0FBSkEsSUFBVyxFQUF6QixDQUE0QjtFQUE1QjtFQUVBLElBQUljLFVBQVUsR0FBR2QsSUFBSSxDQUFDLENBQUQsQ0FBckI7O0VBRUEsSUFBSSxDQUFDYyxVQUFMLEVBQWlCO0lBQ2YsT0FBT2IsT0FBUDtFQUNEOztFQUVELElBQUlMLFlBQVksSUFBSSxPQUFPbUIsSUFBUCxLQUFnQixVQUFwQyxFQUFnRDtJQUM5QyxJQUFJQyxhQUFhLEdBQUdDLFNBQVMsQ0FBQ0gsVUFBRCxDQUE3QjtJQUNBLElBQUlJLFVBQVUsR0FBR0osVUFBVSxDQUFDSyxPQUFYTCxDQUFtQmYsR0FBbkJlLENBQXVCLFVBQVVNLE1BQVYsRUFBa0I7TUFDeEQsT0FBTyxpQkFDSmpCLE1BREksQ0FDR1csVUFBVSxDQUFDTyxVQUFYUCxJQUF5QixFQUQ1QixFQUVKWCxNQUZJLENBRUdpQixNQUZILEVBRVcsS0FGWCxDQUFQO0lBR0QsQ0FKZ0JOLENBQWpCO0lBS0EsT0FBTyxDQUFDYixPQUFELEVBQVVFLE1BQVYsQ0FBaUJlLFVBQWpCLEVBQTZCZixNQUE3QixDQUFvQyxDQUFDYSxhQUFELENBQXBDLEVBQXFEWixJQUFyRCxDQUEwRCxJQUExRCxDQUFQO0VBQ0Q7O0VBRUQsT0FBTyxDQUFDSCxPQUFELEVBQVVHLElBQVYsQ0FBZSxJQUFmLENBQVA7QUFDRCxDLENBQUM7OztBQUVGLFNBQVNhLFNBQVQsQ0FBbUJLLFNBQW5CLEVBQThCO0VBQzVCO0VBQ0EsSUFBSUMsTUFBTSxHQUFHUixJQUFJLENBQUNTLFFBQVEsQ0FBQ0Msa0JBQWtCLENBQUNDLElBQUksQ0FBQ0MsU0FBTEQsQ0FBZUosU0FBZkksQ0FBRCxDQUFuQixDQUFULENBQWpCO0VBQ0EsSUFBSUUsSUFBSSxHQUNOLCtEQUErRHpCLE1BQS9ELENBQ0VvQixNQURGLENBREY7RUFJQSxPQUFPLE9BQU9wQixNQUFQLENBQWN5QixJQUFkLEVBQW9CLEtBQXBCLENBQVA7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzP2NjZmMiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVzZVNvdXJjZU1hcCIsImxpc3QiLCJ0b1N0cmluZyIsIm1hcCIsIml0ZW0iLCJjb250ZW50IiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsImNvbmNhdCIsImpvaW4iLCJpIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJkZWR1cGUiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwibGVuZ3RoIiwiaWQiLCJfaSIsInB1c2giLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZSIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getDomainLocale = getDomainLocale;\nvar basePath =  false || \"\";\n\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n  if (false) { var finalLocale, proto, domain, target, detectDomainLocale, normalizeLocalePath; } else {\n    return false;\n  }\n}\n\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n  Object.defineProperty(exports.default, \"__esModule\", {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0NILEVBQUFBO0FBR0FFLHVCQUFBQSxHQUEwQkUsZUFBMUJGO0FBQ0EsSUFBTUcsUUFBUSxHQUFHQyxNQUFBQSxJQUFzQyxFQUF2RDs7QUFDQSxTQUFTRixlQUFULENBQXlCSyxJQUF6QixFQUErQkMsTUFBL0IsRUFBdUNDLE9BQXZDLEVBQWdEQyxhQUFoRCxFQUErRDtFQUMzRCxJQUFJTixLQUFKLEVBQXFDLG9GQUFyQyxNQVdPO0lBQ0gsT0FBTyxLQUFQO0VBQ0g7QUFDSjs7QUFFRCxJQUFJLENBQUMsT0FBT0osT0FBTyxDQUFDd0IsT0FBZixLQUEyQixVQUEzQixJQUEwQyxPQUFPeEIsT0FBTyxDQUFDd0IsT0FBZixLQUEyQixRQUEzQixJQUF1Q3hCLE9BQU8sQ0FBQ3dCLE9BQVJ4QixLQUFvQixJQUF0RyxLQUFnSCxPQUFPQSxPQUFPLENBQUN3QixPQUFSeEIsQ0FBZ0J5QixVQUF2QixLQUFzQyxXQUExSixFQUF1SztFQUNySzNCLE1BQU0sQ0FBQ0MsY0FBUEQsQ0FBc0JFLE9BQU8sQ0FBQ3dCLE9BQTlCMUIsRUFBdUMsWUFBdkNBLEVBQXFEO0lBQUVHLEtBQUssRUFBRTtFQUFULENBQXJESDtFQUNBQSxNQUFNLENBQUM0QixNQUFQNUIsQ0FBY0UsT0FBTyxDQUFDd0IsT0FBdEIxQixFQUErQkUsT0FBL0JGO0VBQ0E2QixNQUFNLENBQUMzQixPQUFQMkIsR0FBaUIzQixPQUFPLENBQUN3QixPQUF6Qkc7QUFDRCxDLENBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZ2V0LWRvbWFpbi1sb2NhbGUuanM/NWMyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5nZXREb21haW5Mb2NhbGUgPSBnZXREb21haW5Mb2NhbGU7XHJcbmNvbnN0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCAnJztcclxuZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKHBhdGgsIGxvY2FsZSwgbG9jYWxlcywgZG9tYWluTG9jYWxlcykge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcclxuICAgICAgICBjb25zdCBub3JtYWxpemVMb2NhbGVQYXRoID0gcmVxdWlyZSgnLi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnKS5ub3JtYWxpemVMb2NhbGVQYXRoO1xyXG4gICAgICAgIGNvbnN0IGRldGVjdERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoJy4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKS5kZXRlY3REb21haW5Mb2NhbGU7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbG9jYWxlIHx8IG5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aCwgbG9jYWxlcykuZGV0ZWN0ZWRMb2NhbGU7XHJcbiAgICAgICAgY29uc3QgZG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgdGFyZ2V0KTtcclxuICAgICAgICBpZiAoZG9tYWluKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3RvID0gYGh0dHAke2RvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vYDtcclxuICAgICAgICAgICAgY29uc3QgZmluYWxMb2NhbGUgPSB0YXJnZXQgPT09IGRvbWFpbi5kZWZhdWx0TG9jYWxlID8gJycgOiBgLyR7dGFyZ2V0fWA7XHJcbiAgICAgICAgICAgIHJldHVybiBgJHtwcm90b30ke2RvbWFpbi5kb21haW59JHtiYXNlUGF0aH0ke2ZpbmFsTG9jYWxlfSR7cGF0aH1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cclxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcclxuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcclxufVxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWRvbWFpbi1sb2NhbGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0RG9tYWluTG9jYWxlIiwiYmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInBhdGgiLCJsb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwicmVxdWlyZSIsImRldGVjdERvbWFpbkxvY2FsZSIsInRhcmdldCIsImRldGVjdGVkTG9jYWxlIiwiZG9tYWluIiwidW5kZWZpbmVkIiwicHJvdG8iLCJjb25jYXQiLCJodHRwIiwiZmluYWxMb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/image.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/image.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _define_property = (__webpack_require__(/*! @swc/helpers/lib/_define_property.js */ \"./node_modules/@swc/helpers/lib/_define_property.js\")[\"default\"]);\n\nvar _sliced_to_array = (__webpack_require__(/*! @swc/helpers/lib/_sliced_to_array.js */ \"./node_modules/@swc/helpers/lib/_sliced_to_array.js\")[\"default\"]);\n\nvar _to_consumable_array = (__webpack_require__(/*! @swc/helpers/lib/_to_consumable_array.js */ \"./node_modules/@swc/helpers/lib/_to_consumable_array.js\")[\"default\"]);\n\nvar _s = $RefreshSig$(),\n    _s1 = $RefreshSig$();\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = Image;\n\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _head = _interopRequireDefault(__webpack_require__(/*! ../shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\"));\n\nvar _imageConfig = __webpack_require__(/*! ../shared/lib/image-config */ \"./node_modules/next/dist/shared/lib/image-config.js\");\n\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\n\nvar _imageConfigContext = __webpack_require__(/*! ../shared/lib/image-config-context */ \"./node_modules/next/dist/shared/lib/image-config-context.js\");\n\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\n\nvar _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\n\nfunction Image(_param) {\n  _s();\n\n  var src = _param.src,\n      sizes = _param.sizes,\n      _unoptimized = _param.unoptimized,\n      unoptimized = _unoptimized === void 0 ? false : _unoptimized,\n      _priority = _param.priority,\n      priority = _priority === void 0 ? false : _priority,\n      loading = _param.loading,\n      _lazyRoot = _param.lazyRoot,\n      lazyRoot = _lazyRoot === void 0 ? null : _lazyRoot,\n      lazyBoundary = _param.lazyBoundary,\n      className = _param.className,\n      quality = _param.quality,\n      width = _param.width,\n      height = _param.height,\n      style = _param.style,\n      objectFit = _param.objectFit,\n      objectPosition = _param.objectPosition,\n      onLoadingComplete = _param.onLoadingComplete,\n      _placeholder = _param.placeholder,\n      placeholder = _placeholder === void 0 ? \"empty\" : _placeholder,\n      blurDataURL = _param.blurDataURL,\n      all = _objectWithoutPropertiesLoose(_param, [\"src\", \"sizes\", \"unoptimized\", \"priority\", \"loading\", \"lazyRoot\", \"lazyBoundary\", \"className\", \"quality\", \"width\", \"height\", \"style\", \"objectFit\", \"objectPosition\", \"onLoadingComplete\", \"placeholder\", \"blurDataURL\"]);\n\n  var configContext = (0, _react).useContext(_imageConfigContext.ImageConfigContext);\n  var config = (0, _react).useMemo(function () {\n    var c = configEnv || configContext || _imageConfig.imageConfigDefault;\n\n    var allSizes = _to_consumable_array(c.deviceSizes).concat(_to_consumable_array(c.imageSizes)).sort(function (a, b) {\n      return a - b;\n    });\n\n    var deviceSizes = c.deviceSizes.sort(function (a, b) {\n      return a - b;\n    });\n    return _extends({}, c, {\n      allSizes: allSizes,\n      deviceSizes: deviceSizes\n    });\n  }, [configContext]);\n  var rest = all;\n  var layout = sizes ? \"responsive\" : \"intrinsic\";\n\n  if (\"layout\" in rest) {\n    // Override default layout if the user specified one:\n    if (rest.layout) layout = rest.layout; // Remove property so it's not spread on <img>:\n\n    delete rest.layout;\n  }\n\n  var loader = defaultImageLoader;\n\n  if (\"loader\" in rest) {\n    if (rest.loader) {\n      var customImageLoader = rest.loader;\n\n      var _tmp;\n\n      _tmp = function (obj) {\n        var _ = obj.config,\n            opts = _objectWithoutPropertiesLoose(obj, [\"config\"]); // The config object is internal only so we must\n        // not pass it to the user-defined loader()\n\n\n        return customImageLoader(opts);\n      }, loader = _tmp, _tmp;\n    } // Remove property so it's not spread on <img>\n\n\n    delete rest.loader;\n  }\n\n  var staticSrc = \"\";\n\n  if (isStaticImport(src)) {\n    var staticImageData = isStaticRequire(src) ? src.default : src;\n\n    if (!staticImageData.src) {\n      throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \".concat(JSON.stringify(staticImageData)));\n    }\n\n    blurDataURL = blurDataURL || staticImageData.blurDataURL;\n    staticSrc = staticImageData.src;\n\n    if (!layout || layout !== \"fill\") {\n      height = height || staticImageData.height;\n      width = width || staticImageData.width;\n\n      if (!staticImageData.height || !staticImageData.width) {\n        throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \".concat(JSON.stringify(staticImageData)));\n      }\n    }\n  }\n\n  src = typeof src === \"string\" ? src : staticSrc;\n  var widthInt = getInt(width);\n  var heightInt = getInt(height);\n  var qualityInt = getInt(quality);\n  var isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n\n  if (src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n    unoptimized = true;\n    isLazy = false;\n  }\n\n  if ( true && loadedImageURLs.has(src)) {\n    isLazy = false;\n  }\n\n  if (experimentalUnoptimized) {\n    unoptimized = true;\n  }\n\n  var ref = _sliced_to_array((0, _react).useState(false), 2),\n      blurComplete = ref[0],\n      setBlurComplete = ref[1];\n\n  var ref1 = _sliced_to_array((0, _useIntersection).useIntersection({\n    rootRef: lazyRoot,\n    rootMargin: lazyBoundary || \"200px\",\n    disabled: !isLazy\n  }), 3),\n      setIntersection = ref1[0],\n      isIntersected = ref1[1],\n      resetIntersected = ref1[2];\n\n  var isVisible = !isLazy || isIntersected;\n  var wrapperStyle = {\n    boxSizing: \"border-box\",\n    display: \"block\",\n    overflow: \"hidden\",\n    width: \"initial\",\n    height: \"initial\",\n    background: \"none\",\n    opacity: 1,\n    border: 0,\n    margin: 0,\n    padding: 0\n  };\n  var sizerStyle = {\n    boxSizing: \"border-box\",\n    display: \"block\",\n    width: \"initial\",\n    height: \"initial\",\n    background: \"none\",\n    opacity: 1,\n    border: 0,\n    margin: 0,\n    padding: 0\n  };\n  var hasSizer = false;\n  var sizerSvgUrl;\n  var layoutStyle = {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0,\n    boxSizing: \"border-box\",\n    padding: 0,\n    border: \"none\",\n    margin: \"auto\",\n    display: \"block\",\n    width: 0,\n    height: 0,\n    minWidth: \"100%\",\n    maxWidth: \"100%\",\n    minHeight: \"100%\",\n    maxHeight: \"100%\",\n    objectFit: objectFit,\n    objectPosition: objectPosition\n  };\n\n  if (true) {\n    if (!src) {\n      throw new Error('Image is missing required \"src\" property. Make sure you pass \"src\" in props to the `next/image` component. Received: '.concat(JSON.stringify({\n        width: width,\n        height: height,\n        quality: quality\n      })));\n    }\n\n    if (!VALID_LAYOUT_VALUES.includes(layout)) {\n      if (layout === \"raw\") {\n        throw new Error('The layout=\"raw\" experiment has been moved to a new module. Please import `next/future/image` instead.');\n      }\n\n      throw new Error('Image with src \"'.concat(src, '\" has invalid \"layout\" property. Provided \"').concat(layout, '\" should be one of ').concat(VALID_LAYOUT_VALUES.map(String).join(\",\"), \".\"));\n    }\n\n    if (typeof widthInt !== \"undefined\" && isNaN(widthInt) || typeof heightInt !== \"undefined\" && isNaN(heightInt)) {\n      throw new Error('Image with src \"'.concat(src, '\" has invalid \"width\" or \"height\" property. These should be numeric values.'));\n    }\n\n    if (layout === \"fill\" && (width || height)) {\n      (0, _utils).warnOnce('Image with src \"'.concat(src, '\" and \"layout=\\'fill\\'\" has unused properties assigned. Please remove \"width\" and \"height\".'));\n    }\n\n    if (!VALID_LOADING_VALUES.includes(loading)) {\n      throw new Error('Image with src \"'.concat(src, '\" has invalid \"loading\" property. Provided \"').concat(loading, '\" should be one of ').concat(VALID_LOADING_VALUES.map(String).join(\",\"), \".\"));\n    }\n\n    if (priority && loading === \"lazy\") {\n      throw new Error('Image with src \"'.concat(src, '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.'));\n    }\n\n    if (sizes && layout !== \"fill\" && layout !== \"responsive\") {\n      (0, _utils).warnOnce('Image with src \"'.concat(src, '\" has \"sizes\" property but it will be ignored. Only use \"sizes\" with \"layout=\\'fill\\'\" or \"layout=\\'responsive\\'\"'));\n    }\n\n    if (placeholder === \"blur\") {\n      if (layout !== \"fill\" && (widthInt || 0) * (heightInt || 0) < 1600) {\n        (0, _utils).warnOnce('Image with src \"'.concat(src, '\" is smaller than 40x40. Consider removing the \"placeholder=\\'blur\\'\" property to improve performance.'));\n      }\n\n      if (!blurDataURL) {\n        var VALID_BLUR_EXT = [\"jpeg\", \"png\", \"webp\", \"avif\"] // should match next-image-loader\n        ;\n        throw new Error('Image with src \"'.concat(src, '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n          Possible solutions:\\n            - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n            - Change the \"src\" property to a static import with one of the supported file types: ').concat(VALID_BLUR_EXT.join(\",\"), '\\n            - Remove the \"placeholder\" property, effectively no blur effect\\n          Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url'));\n      }\n    }\n\n    if (\"ref\" in rest) {\n      (0, _utils).warnOnce('Image with src \"'.concat(src, '\" is using unsupported \"ref\" property. Consider using the \"onLoadingComplete\" property instead.'));\n    }\n\n    if (!unoptimized && loader !== defaultImageLoader) {\n      var urlStr = loader({\n        config: config,\n        src: src,\n        width: widthInt || 400,\n        quality: qualityInt || 75\n      });\n      var url;\n\n      try {\n        url = new URL(urlStr);\n      } catch (err) {}\n\n      if (urlStr === src || url && url.pathname === src && !url.search) {\n        (0, _utils).warnOnce('Image with src \"'.concat(src, '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.') + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n      }\n    }\n\n    if (style) {\n      var overwrittenStyles = Object.keys(style).filter(function (key) {\n        return key in layoutStyle;\n      });\n\n      if (overwrittenStyles.length) {\n        (0, _utils).warnOnce(\"Image with src \".concat(src, \" is assigned the following styles, which are overwritten by automatically-generated styles: \").concat(overwrittenStyles.join(\", \")));\n      }\n    }\n\n    if ( true && !perfObserver && window.PerformanceObserver) {\n      perfObserver = new PerformanceObserver(function (entryList) {\n        var _iteratorNormalCompletion = true,\n            _didIteratorError = false,\n            _iteratorError = undefined;\n\n        try {\n          for (var _iterator = entryList.getEntries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var entry = _step.value;\n            var ref; // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n\n            var imgSrc = (entry == null ? void 0 : (ref = entry.element) == null ? void 0 : ref.src) || \"\";\n            var lcpImage = allImgs.get(imgSrc);\n\n            if (lcpImage && !lcpImage.priority && lcpImage.placeholder !== \"blur\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n              // https://web.dev/lcp/#measure-lcp-in-javascript\n              (0, _utils).warnOnce('Image with src \"'.concat(lcpImage.src, '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.') + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      });\n\n      try {\n        perfObserver.observe({\n          type: \"largest-contentful-paint\",\n          buffered: true\n        });\n      } catch (err1) {\n        // Log error but don't crash the app\n        console.error(err1);\n      }\n    }\n  }\n\n  var imgStyle = Object.assign({}, style, layoutStyle);\n  var blurStyle = placeholder === \"blur\" && !blurComplete ? {\n    backgroundSize: objectFit || \"cover\",\n    backgroundPosition: objectPosition || \"0% 0%\",\n    filter: \"blur(20px)\",\n    backgroundImage: 'url(\"'.concat(blurDataURL, '\")')\n  } : {};\n\n  if (layout === \"fill\") {\n    // <Image src=\"i.png\" layout=\"fill\" />\n    wrapperStyle.display = \"block\";\n    wrapperStyle.position = \"absolute\";\n    wrapperStyle.top = 0;\n    wrapperStyle.left = 0;\n    wrapperStyle.bottom = 0;\n    wrapperStyle.right = 0;\n  } else if (typeof widthInt !== \"undefined\" && typeof heightInt !== \"undefined\") {\n    // <Image src=\"i.png\" width=\"100\" height=\"100\" />\n    var quotient = heightInt / widthInt;\n    var paddingTop = isNaN(quotient) ? \"100%\" : \"\".concat(quotient * 100, \"%\");\n\n    if (layout === \"responsive\") {\n      // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"responsive\" />\n      wrapperStyle.display = \"block\";\n      wrapperStyle.position = \"relative\";\n      hasSizer = true;\n      sizerStyle.paddingTop = paddingTop;\n    } else if (layout === \"intrinsic\") {\n      // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"intrinsic\" />\n      wrapperStyle.display = \"inline-block\";\n      wrapperStyle.position = \"relative\";\n      wrapperStyle.maxWidth = \"100%\";\n      hasSizer = true;\n      sizerStyle.maxWidth = \"100%\";\n      sizerSvgUrl = \"data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27\".concat(widthInt, \"%27%20height=%27\").concat(heightInt, \"%27/%3e\");\n    } else if (layout === \"fixed\") {\n      // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"fixed\" />\n      wrapperStyle.display = \"inline-block\";\n      wrapperStyle.position = \"relative\";\n      wrapperStyle.width = widthInt;\n      wrapperStyle.height = heightInt;\n    }\n  } else {\n    // <Image src=\"i.png\" />\n    if (true) {\n      throw new Error('Image with src \"'.concat(src, '\" must use \"width\" and \"height\" properties or \"layout=\\'fill\\'\" property.'));\n    }\n  }\n\n  var imgAttributes = {\n    src: emptyDataURL,\n    srcSet: undefined,\n    sizes: undefined\n  };\n\n  if (isVisible) {\n    imgAttributes = generateImgAttrs({\n      config: config,\n      src: src,\n      unoptimized: unoptimized,\n      layout: layout,\n      width: widthInt,\n      quality: qualityInt,\n      sizes: sizes,\n      loader: loader\n    });\n  }\n\n  var srcString = src;\n\n  if (true) {\n    if (true) {\n      var fullUrl;\n\n      try {\n        fullUrl = new URL(imgAttributes.src);\n      } catch (e) {\n        fullUrl = new URL(imgAttributes.src, window.location.href);\n      }\n\n      allImgs.set(fullUrl.href, {\n        src: src,\n        priority: priority,\n        placeholder: placeholder\n      });\n    }\n  }\n\n  var imageSrcSetPropName = \"imagesrcset\";\n  var imageSizesPropName = \"imagesizes\";\n\n  if (false) {}\n\n  var _obj;\n\n  var linkProps = (_obj = {}, // Note: imagesrcset and imagesizes are not in the link element type with react 17.\n  _define_property(_obj, imageSrcSetPropName, imgAttributes.srcSet), _define_property(_obj, imageSizesPropName, imgAttributes.sizes), _obj);\n  var useLayoutEffect =  false ? 0 : _react.default.useLayoutEffect;\n  var onLoadingCompleteRef = (0, _react).useRef(onLoadingComplete);\n  var previousImageSrc = (0, _react).useRef(src);\n  (0, _react).useEffect(function () {\n    onLoadingCompleteRef.current = onLoadingComplete;\n  }, [onLoadingComplete]);\n  useLayoutEffect(function () {\n    if (previousImageSrc.current !== src) {\n      resetIntersected();\n      previousImageSrc.current = src;\n    }\n  }, [resetIntersected, src]);\n\n  var imgElementArgs = _extends({\n    isLazy: isLazy,\n    imgAttributes: imgAttributes,\n    heightInt: heightInt,\n    widthInt: widthInt,\n    qualityInt: qualityInt,\n    layout: layout,\n    className: className,\n    imgStyle: imgStyle,\n    blurStyle: blurStyle,\n    loading: loading,\n    config: config,\n    unoptimized: unoptimized,\n    placeholder: placeholder,\n    loader: loader,\n    srcString: srcString,\n    onLoadingCompleteRef: onLoadingCompleteRef,\n    setBlurComplete: setBlurComplete,\n    setIntersection: setIntersection,\n    isVisible: isVisible,\n    noscriptSizes: sizes\n  }, rest);\n\n  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"span\", {\n    style: wrapperStyle\n  }, hasSizer ? /*#__PURE__*/_react.default.createElement(\"span\", {\n    style: sizerStyle\n  }, sizerSvgUrl ? /*#__PURE__*/_react.default.createElement(\"img\", {\n    style: {\n      display: \"block\",\n      maxWidth: \"100%\",\n      width: \"initial\",\n      height: \"initial\",\n      background: \"none\",\n      opacity: 1,\n      border: 0,\n      margin: 0,\n      padding: 0\n    },\n    alt: \"\",\n    \"aria-hidden\": true,\n    src: sizerSvgUrl\n  }) : null) : null, /*#__PURE__*/_react.default.createElement(ImageElement, Object.assign({}, imgElementArgs))), priority ? // for browsers that do not support `imagesrcset`, and in those cases\n  // it would likely cause the incorrect image to be preloaded.\n  //\n  // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n\n  /*#__PURE__*/\n  _react.default.createElement(_head.default, null, /*#__PURE__*/_react.default.createElement(\"link\", Object.assign({\n    key: \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes,\n    rel: \"preload\",\n    as: \"image\",\n    href: imgAttributes.srcSet ? undefined : imgAttributes.src\n  }, linkProps))) : null);\n}\n\n_s(Image, \"JC32V8ZswcgqIp1SSTncST29uwM=\");\n\n_c = Image;\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar ref = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"experimentalLayoutRaw\":false,\"domains\":[\"lh3.googleusercontent.com\",\"avatars.githubusercontent.com\",\"imagedelivery.net\"],\"experimentalRemotePatterns\":[]} || {},\n    _experimentalRemotePatterns = ref.experimentalRemotePatterns,\n    experimentalRemotePatterns = _experimentalRemotePatterns === void 0 ? [] : _experimentalRemotePatterns,\n    experimentalUnoptimized = ref.experimentalUnoptimized;\nvar configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"experimentalLayoutRaw\":false,\"domains\":[\"lh3.googleusercontent.com\",\"avatars.githubusercontent.com\",\"imagedelivery.net\"],\"experimentalRemotePatterns\":[]};\nvar loadedImageURLs = new Set();\nvar allImgs = new Map();\nvar perfObserver;\nvar emptyDataURL = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n\nif (false) {}\n\nvar VALID_LOADING_VALUES = [\"lazy\", \"eager\", undefined];\nvar loaders = new Map([[\"default\", defaultLoader], [\"imgix\", imgixLoader], [\"cloudinary\", cloudinaryLoader], [\"akamai\", akamaiLoader], [\"custom\", customLoader]]);\nvar VALID_LAYOUT_VALUES = [\"fill\", \"fixed\", \"intrinsic\", \"responsive\", undefined];\n\nfunction isStaticRequire(src) {\n  return src.default !== undefined;\n}\n\nfunction isStaticImageData(src) {\n  return src.src !== undefined;\n}\n\nfunction isStaticImport(src) {\n  return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\n\nfunction getWidths(param, width, layout, sizes) {\n  var deviceSizes = param.deviceSizes,\n      allSizes = param.allSizes;\n\n  if (sizes && (layout === \"fill\" || layout === \"responsive\")) {\n    // Find all the \"vw\" percent sizes used in the sizes prop\n    var viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n    var percentSizes = [];\n\n    for (var match; match = viewportWidthRe.exec(sizes); match) {\n      percentSizes.push(parseInt(match[2]));\n    }\n\n    if (percentSizes.length) {\n      var _Math;\n\n      var smallestRatio = (_Math = Math).min.apply(_Math, _to_consumable_array(percentSizes)) * 0.01;\n      return {\n        widths: allSizes.filter(function (s) {\n          return s >= deviceSizes[0] * smallestRatio;\n        }),\n        kind: \"w\"\n      };\n    }\n\n    return {\n      widths: allSizes,\n      kind: \"w\"\n    };\n  }\n\n  if (typeof width !== \"number\" || layout === \"fill\" || layout === \"responsive\") {\n    return {\n      widths: deviceSizes,\n      kind: \"w\"\n    };\n  }\n\n  var widths = _to_consumable_array(new Set( // > are actually 3x in the green color, but only 1.5x in the red and\n  // > blue colors. Showing a 3x resolution image in the app vs a 2x\n  // > resolution image will be visually the same, though the 3x image\n  // > takes significantly more data. Even true 3x resolution screens are\n  // > wasteful as the human eye cannot see that level of detail without\n  // > something like a magnifying glass.\n  // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n  [width, width * 2\n  /*, width * 3*/\n  ].map(function (w) {\n    return allSizes.find(function (p) {\n      return p >= w;\n    }) || allSizes[allSizes.length - 1];\n  })));\n\n  return {\n    widths: widths,\n    kind: \"x\"\n  };\n}\n\nfunction generateImgAttrs(param) {\n  var config = param.config,\n      src = param.src,\n      unoptimized = param.unoptimized,\n      layout = param.layout,\n      width = param.width,\n      quality = param.quality,\n      sizes = param.sizes,\n      loader = param.loader;\n\n  if (unoptimized) {\n    return {\n      src: src,\n      srcSet: undefined,\n      sizes: undefined\n    };\n  }\n\n  var ref = getWidths(config, width, layout, sizes),\n      widths = ref.widths,\n      kind = ref.kind;\n  var last = widths.length - 1;\n  return {\n    sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n    srcSet: widths.map(function (w, i) {\n      return \"\".concat(loader({\n        config: config,\n        src: src,\n        quality: quality,\n        width: w\n      }), \" \").concat(kind === \"w\" ? w : i + 1).concat(kind);\n    }).join(\", \"),\n    // It's intended to keep `src` the last attribute because React updates\n    // attributes in order. If we keep `src` the first one, Safari will\n    // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n    // updated by React. That causes multiple unnecessary requests if `srcSet`\n    // and `sizes` are defined.\n    // This bug cannot be reproduced in Chrome or Firefox.\n    src: loader({\n      config: config,\n      src: src,\n      quality: quality,\n      width: widths[last]\n    })\n  };\n}\n\nfunction getInt(x) {\n  if (typeof x === \"number\") {\n    return x;\n  }\n\n  if (typeof x === \"string\") {\n    return parseInt(x, 10);\n  }\n\n  return undefined;\n}\n\nfunction defaultImageLoader(loaderProps) {\n  var ref;\n  var loaderKey = ((ref = loaderProps.config) == null ? void 0 : ref.loader) || \"default\";\n  var load = loaders.get(loaderKey);\n\n  if (load) {\n    return load(loaderProps);\n  }\n\n  throw new Error('Unknown \"loader\" found in \"next.config.js\". Expected: '.concat(_imageConfig.VALID_LOADERS.join(\", \"), \". Received: \").concat(loaderKey));\n} // See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\n\n\nfunction handleLoading(img, src, layout, placeholder, onLoadingCompleteRef, setBlurComplete) {\n  if (!img || img.src === emptyDataURL || img[\"data-loaded-src\"] === src) {\n    return;\n  }\n\n  img[\"data-loaded-src\"] = src;\n  var p = \"decode\" in img ? img.decode() : Promise.resolve();\n  p.catch(function () {}).then(function () {\n    if (!img.parentNode) {\n      // Exit early in case of race condition:\n      // - onload() is called\n      // - decode() is called but incomplete\n      // - unmount is called\n      // - decode() completes\n      return;\n    }\n\n    loadedImageURLs.add(src);\n\n    if (placeholder === \"blur\") {\n      setBlurComplete(true);\n    }\n\n    if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n      var naturalWidth = img.naturalWidth,\n          naturalHeight = img.naturalHeight; // Pass back read-only primitive values but not the\n      // underlying DOM element because it could be misused.\n\n      onLoadingCompleteRef.current({\n        naturalWidth: naturalWidth,\n        naturalHeight: naturalHeight\n      });\n    }\n\n    if (true) {\n      var ref;\n\n      if ((ref = img.parentElement) == null ? void 0 : ref.parentElement) {\n        var parent = getComputedStyle(img.parentElement.parentElement);\n\n        if (!parent.position) {// The parent has not been rendered to the dom yet and therefore it has no position. Skip the warnings for such cases.\n        } else if (layout === \"responsive\" && parent.display === \"flex\") {\n          (0, _utils).warnOnce('Image with src \"'.concat(src, '\" may not render properly as a child of a flex container. Consider wrapping the image with a div to configure the width.'));\n        } else if (layout === \"fill\" && parent.position !== \"relative\" && parent.position !== \"fixed\" && parent.position !== \"absolute\") {\n          (0, _utils).warnOnce('Image with src \"'.concat(src, '\" may not render properly with a parent using position:\"').concat(parent.position, '\". Consider changing the parent style to position:\"relative\" with a width and height.'));\n        }\n      }\n    }\n  });\n}\n\nvar ImageElement = function (_param) {\n  _s1();\n\n  var imgAttributes = _param.imgAttributes,\n      heightInt = _param.heightInt,\n      widthInt = _param.widthInt,\n      qualityInt = _param.qualityInt,\n      layout = _param.layout,\n      className = _param.className,\n      imgStyle = _param.imgStyle,\n      blurStyle = _param.blurStyle,\n      isLazy = _param.isLazy,\n      placeholder = _param.placeholder,\n      loading = _param.loading,\n      srcString = _param.srcString,\n      config = _param.config,\n      unoptimized = _param.unoptimized,\n      loader = _param.loader,\n      onLoadingCompleteRef = _param.onLoadingCompleteRef,\n      setBlurComplete = _param.setBlurComplete,\n      setIntersection = _param.setIntersection,\n      onLoad = _param.onLoad,\n      onError = _param.onError,\n      isVisible = _param.isVisible,\n      noscriptSizes = _param.noscriptSizes,\n      rest = _objectWithoutPropertiesLoose(_param, [\"imgAttributes\", \"heightInt\", \"widthInt\", \"qualityInt\", \"layout\", \"className\", \"imgStyle\", \"blurStyle\", \"isLazy\", \"placeholder\", \"loading\", \"srcString\", \"config\", \"unoptimized\", \"loader\", \"onLoadingCompleteRef\", \"setBlurComplete\", \"setIntersection\", \"onLoad\", \"onError\", \"isVisible\", \"noscriptSizes\"]);\n\n  loading = isLazy ? \"lazy\" : loading;\n  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"img\", Object.assign({}, rest, imgAttributes, {\n    decoding: \"async\",\n    \"data-nimg\": layout,\n    className: className,\n    style: _extends({}, imgStyle, blurStyle),\n    ref: (0, _react).useCallback(function (img) {\n      setIntersection(img);\n\n      if (img == null ? void 0 : img.complete) {\n        handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);\n      }\n    }, [setIntersection, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete]),\n    onLoad: function (event) {\n      var img = event.currentTarget;\n      handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);\n\n      if (onLoad) {\n        onLoad(event);\n      }\n    },\n    onError: function (event) {\n      if (placeholder === \"blur\") {\n        // If the real image fails to load, this will still remove the placeholder.\n        setBlurComplete(true);\n      }\n\n      if (onError) {\n        onError(event);\n      }\n    }\n  })), (isLazy || placeholder === \"blur\") && /*#__PURE__*/_react.default.createElement(\"noscript\", null, /*#__PURE__*/_react.default.createElement(\"img\", Object.assign({}, rest, generateImgAttrs({\n    config: config,\n    src: srcString,\n    unoptimized: unoptimized,\n    layout: layout,\n    width: widthInt,\n    quality: qualityInt,\n    sizes: noscriptSizes,\n    loader: loader\n  }), {\n    decoding: \"async\",\n    \"data-nimg\": layout,\n    style: imgStyle,\n    className: className,\n    // @ts-ignore - TODO: upgrade to `@types/react@17`\n    loading: loading\n  }))));\n};\n\n_s1(ImageElement, \"epj4qY15NHsef74wNqHIp5fdZmg=\");\n\n_c1 = ImageElement;\n\nfunction normalizeSrc(src) {\n  return src[0] === \"/\" ? src.slice(1) : src;\n}\n\nfunction imgixLoader(param) {\n  var config = param.config,\n      src = param.src,\n      width = param.width,\n      quality = param.quality; // Demo: https://static.imgix.net/daisy.png?auto=format&fit=max&w=300\n\n  var url = new URL(\"\".concat(config.path).concat(normalizeSrc(src)));\n  var params = url.searchParams;\n  params.set(\"auto\", params.get(\"auto\") || \"format\");\n  params.set(\"fit\", params.get(\"fit\") || \"max\");\n  params.set(\"w\", params.get(\"w\") || width.toString());\n\n  if (quality) {\n    params.set(\"q\", quality.toString());\n  }\n\n  return url.href;\n}\n\nfunction akamaiLoader(param) {\n  var config = param.config,\n      src = param.src,\n      width = param.width;\n  return \"\".concat(config.path).concat(normalizeSrc(src), \"?imwidth=\").concat(width);\n}\n\nfunction cloudinaryLoader(param) {\n  var config = param.config,\n      src = param.src,\n      width = param.width,\n      quality = param.quality; // Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg\n\n  var params = [\"f_auto\", \"c_limit\", \"w_\" + width, \"q_\" + (quality || \"auto\")];\n  var paramsString = params.join(\",\") + \"/\";\n  return \"\".concat(config.path).concat(paramsString).concat(normalizeSrc(src));\n}\n\nfunction customLoader(param) {\n  var src = param.src;\n  throw new Error('Image with src \"'.concat(src, '\" is missing \"loader\" prop.') + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n}\n\nfunction defaultLoader(param) {\n  var config = param.config,\n      src = param.src,\n      width = param.width,\n      quality = param.quality;\n\n  if (true) {\n    var missingValues = []; // these should always be provided but make sure they are\n\n    if (!src) missingValues.push(\"src\");\n    if (!width) missingValues.push(\"width\");\n\n    if (missingValues.length > 0) {\n      throw new Error(\"Next Image Optimization requires \".concat(missingValues.join(\", \"), \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \").concat(JSON.stringify({\n        src: src,\n        width: width,\n        quality: quality\n      })));\n    }\n\n    if (src.startsWith(\"//\")) {\n      throw new Error('Failed to parse src \"'.concat(src, '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)'));\n    }\n\n    if (!src.startsWith(\"/\") && (config.domains || experimentalRemotePatterns)) {\n      var parsedSrc;\n\n      try {\n        parsedSrc = new URL(src);\n      } catch (err) {\n        console.error(err);\n        throw new Error('Failed to parse src \"'.concat(src, '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)'));\n      }\n\n      if (true) {\n        // We use dynamic require because this should only error in development\n        var hasMatch = (__webpack_require__(/*! ../shared/lib/match-remote-pattern */ \"./node_modules/next/dist/shared/lib/match-remote-pattern.js\").hasMatch);\n\n        if (!hasMatch(config.domains, experimentalRemotePatterns, parsedSrc)) {\n          throw new Error(\"Invalid src prop (\".concat(src, ') on `next/image`, hostname \"').concat(parsedSrc.hostname, '\" is not configured under images in your `next.config.js`\\n') + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n        }\n      }\n    }\n  }\n\n  if (src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n    // Special case to make svg serve as-is to avoid proxying\n    // through the built-in Image Optimization API.\n    return src;\n  }\n\n  return \"\".concat((0, _normalizeTrailingSlash).normalizePathTrailingSlash(config.path), \"?url=\").concat(encodeURIComponent(src), \"&w=\").concat(width, \"&q=\").concat(quality || 75);\n}\n\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n  Object.defineProperty(exports.default, \"__esModule\", {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n} //# sourceMappingURL=image.js.map\n\n\nvar _c, _c1;\n\n$RefreshReg$(_c, \"Image\");\n$RefreshReg$(_c1, \"ImageElement\");\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7Ozs7Ozs7Ozs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0NILEVBQUFBO0FBR0FFLGtCQUFBQSxHQUFrQkcsS0FBbEJIOztBQUNBLElBQUlJLE1BQU0sR0FBR0MsdUJBQXVCLENBQUNDLG1CQUFPLENBQUMsNENBQUQsQ0FBUixDQUFwQzs7QUFDQSxJQUFJQyxLQUFLLEdBQUdDLHNCQUFzQixDQUFDRixtQkFBTyxDQUFDLHVFQUFELENBQVIsQ0FBbEM7O0FBQ0EsSUFBSUcsWUFBWSxHQUFHSCxtQkFBTyxDQUFDLHVGQUFELENBQTFCOztBQUNBLElBQUlJLGdCQUFnQixHQUFHSixtQkFBTyxDQUFDLCtFQUFELENBQTlCOztBQUNBLElBQUlLLG1CQUFtQixHQUFHTCxtQkFBTyxDQUFDLHVHQUFELENBQWpDOztBQUNBLElBQUlNLE1BQU0sR0FBR04sbUJBQU8sQ0FBQyx5RUFBRCxDQUFwQjs7QUFDQSxJQUFJTyx1QkFBdUIsR0FBR1AsbUJBQU8sQ0FBQywrRkFBRCxDQUFyQzs7QUFDQSxTQUFTSCxLQUFULENBQWVXLE1BQWYsRUFBdUI7OztFQUNuQixJQUFNQyxHQUFHLEdBQW9PRCxNQUFNLENBQTdPQyxHQUFOO0VBQUEsSUFBWUMsS0FBSyxHQUE0TkYsTUFBTSxDQUF2T0UsS0FBWjtFQUFBLElBQWlCQyxlQUE0TkgsTUFBTSxDQUEvTkksV0FBcEI7RUFBQSxJQUFvQkEsV0FBVyw2QkFBRSxLQUFGLEdBQU9ELFlBQXRDO0VBQUEsSUFBc0NFLFlBQXVNTCxNQUFNLENBQTFNTSxRQUF6QztFQUFBLElBQXlDQSxRQUFRLDBCQUFFLEtBQUYsR0FBT0QsU0FBeEQ7RUFBQSxJQUEyREUsT0FBTyxHQUEyS1AsTUFBTSxDQUF4TE8sT0FBM0Q7RUFBQSxJQUFrRUMsWUFBMktSLE1BQU0sQ0FBOUtTLFFBQXJFO0VBQUEsSUFBcUVBLFFBQVEs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K0VxUSxrQkFBa0IsQ0FBQ2pSLEdBQUQsQ0FBakcsRUFBdUcsS0FBdkcsRUFBdUhXLE1BQXZILENBQTRHQyxLQUE1RyxFQUFrSCxLQUFsSCxFQUFxSXdDLE1BQXJJLENBQXVIekMsT0FBTyxJQUFJLEVBQWxJLENBQVA7QUFDSDs7QUFFRCxJQUFJLENBQUMsT0FBTzFCLE9BQU8sQ0FBQ0UsT0FBZixLQUEyQixVQUEzQixJQUEwQyxPQUFPRixPQUFPLENBQUNFLE9BQWYsS0FBMkIsUUFBM0IsSUFBdUNGLE9BQU8sQ0FBQ0UsT0FBUkYsS0FBb0IsSUFBdEcsS0FBZ0gsT0FBT0EsT0FBTyxDQUFDRSxPQUFSRixDQUFnQjZNLFVBQXZCLEtBQXNDLFdBQTFKLEVBQXVLO0VBQ3JLL00sTUFBTSxDQUFDQyxjQUFQRCxDQUFzQkUsT0FBTyxDQUFDRSxPQUE5QkosRUFBdUMsWUFBdkNBLEVBQXFEO0lBQUVHLEtBQUssRUFBRTtFQUFULENBQXJESDtFQUNBQSxNQUFNLENBQUNnSyxNQUFQaEssQ0FBY0UsT0FBTyxDQUFDRSxPQUF0QkosRUFBK0JFLE9BQS9CRjtFQUNBb1MsTUFBTSxDQUFDbFMsT0FBUGtTLEdBQWlCbFMsT0FBTyxDQUFDRSxPQUF6QmdTO0FBQ0QsQyxDQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLmpzPzgyZjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gICAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEltYWdlO1xyXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9oZWFkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9oZWFkXCIpKTtcclxudmFyIF9pbWFnZUNvbmZpZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZ1wiKTtcclxudmFyIF91c2VJbnRlcnNlY3Rpb24gPSByZXF1aXJlKFwiLi91c2UtaW50ZXJzZWN0aW9uXCIpO1xyXG52YXIgX2ltYWdlQ29uZmlnQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0XCIpO1xyXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvdXRpbHNcIik7XHJcbnZhciBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaFwiKTtcclxuZnVuY3Rpb24gSW1hZ2UoX3BhcmFtKSB7XHJcbiAgICB2YXIgeyBzcmMgLCBzaXplcyAsIHVub3B0aW1pemVkID1mYWxzZSAsIHByaW9yaXR5ID1mYWxzZSAsIGxvYWRpbmcgLCBsYXp5Um9vdCA9bnVsbCAsIGxhenlCb3VuZGFyeSAsIGNsYXNzTmFtZSAsIHF1YWxpdHkgLCB3aWR0aCAsIGhlaWdodCAsIHN0eWxlICwgb2JqZWN0Rml0ICwgb2JqZWN0UG9zaXRpb24gLCBvbkxvYWRpbmdDb21wbGV0ZSAsIHBsYWNlaG9sZGVyID0nZW1wdHknICwgYmx1ckRhdGFVUkwgIH0gPSBfcGFyYW0sIGFsbCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9wYXJhbSwgW1xyXG4gICAgICAgIFwic3JjXCIsXHJcbiAgICAgICAgXCJzaXplc1wiLFxyXG4gICAgICAgIFwidW5vcHRpbWl6ZWRcIixcclxuICAgICAgICBcInByaW9yaXR5XCIsXHJcbiAgICAgICAgXCJsb2FkaW5nXCIsXHJcbiAgICAgICAgXCJsYXp5Um9vdFwiLFxyXG4gICAgICAgIFwibGF6eUJvdW5kYXJ5XCIsXHJcbiAgICAgICAgXCJjbGFzc05hbWVcIixcclxuICAgICAgICBcInF1YWxpdHlcIixcclxuICAgICAgICBcIndpZHRoXCIsXHJcbiAgICAgICAgXCJoZWlnaHRcIixcclxuICAgICAgICBcInN0eWxlXCIsXHJcbiAgICAgICAgXCJvYmplY3RGaXRcIixcclxuICAgICAgICBcIm9iamVjdFBvc2l0aW9uXCIsXHJcbiAgICAgICAgXCJvbkxvYWRpbmdDb21wbGV0ZVwiLFxyXG4gICAgICAgIFwicGxhY2Vob2xkZXJcIixcclxuICAgICAgICBcImJsdXJEYXRhVVJMXCJcclxuICAgIF0pO1xyXG4gICAgY29uc3QgY29uZmlnQ29udGV4dCA9ICgwLCBfcmVhY3QpLnVzZUNvbnRleHQoX2ltYWdlQ29uZmlnQ29udGV4dC5JbWFnZUNvbmZpZ0NvbnRleHQpO1xyXG4gICAgY29uc3QgY29uZmlnID0gKDAsIF9yZWFjdCkudXNlTWVtbygoKT0+e1xyXG4gICAgICAgIGNvbnN0IGMgPSBjb25maWdFbnYgfHwgY29uZmlnQ29udGV4dCB8fCBfaW1hZ2VDb25maWcuaW1hZ2VDb25maWdEZWZhdWx0O1xyXG4gICAgICAgIGNvbnN0IGFsbFNpemVzID0gW1xyXG4gICAgICAgICAgICAuLi5jLmRldmljZVNpemVzLFxyXG4gICAgICAgICAgICAuLi5jLmltYWdlU2l6ZXNcclxuICAgICAgICBdLnNvcnQoKGEsIGIpPT5hIC0gYik7XHJcbiAgICAgICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBjLmRldmljZVNpemVzLnNvcnQoKGEsIGIpPT5hIC0gYik7XHJcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBjLCB7XHJcbiAgICAgICAgICAgIGFsbFNpemVzLFxyXG4gICAgICAgICAgICBkZXZpY2VTaXplc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgW1xyXG4gICAgICAgIGNvbmZpZ0NvbnRleHRcclxuICAgIF0pO1xyXG4gICAgbGV0IHJlc3QgPSBhbGw7XHJcbiAgICBsZXQgbGF5b3V0ID0gc2l6ZXMgPyAncmVzcG9uc2l2ZScgOiAnaW50cmluc2ljJztcclxuICAgIGlmICgnbGF5b3V0JyBpbiByZXN0KSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdCBsYXlvdXQgaWYgdGhlIHVzZXIgc3BlY2lmaWVkIG9uZTpcclxuICAgICAgICBpZiAocmVzdC5sYXlvdXQpIGxheW91dCA9IHJlc3QubGF5b3V0O1xyXG4gICAgICAgIC8vIFJlbW92ZSBwcm9wZXJ0eSBzbyBpdCdzIG5vdCBzcHJlYWQgb24gPGltZz46XHJcbiAgICAgICAgZGVsZXRlIHJlc3QubGF5b3V0O1xyXG4gICAgfVxyXG4gICAgbGV0IGxvYWRlciA9IGRlZmF1bHRJbWFnZUxvYWRlcjtcclxuICAgIGlmICgnbG9hZGVyJyBpbiByZXN0KSB7XHJcbiAgICAgICAgaWYgKHJlc3QubG9hZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUltYWdlTG9hZGVyID0gcmVzdC5sb2FkZXI7XHJcbiAgICAgICAgICAgIHZhciBfdG1wO1xyXG4gICAgICAgICAgICBfdG1wID0gKG9iaik9PntcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29uZmlnOiBfICB9ID0gb2JqLCBvcHRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uob2JqLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjb25maWdcIlxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29uZmlnIG9iamVjdCBpcyBpbnRlcm5hbCBvbmx5IHNvIHdlIG11c3RcclxuICAgICAgICAgICAgICAgIC8vIG5vdCBwYXNzIGl0IHRvIHRoZSB1c2VyLWRlZmluZWQgbG9hZGVyKClcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21JbWFnZUxvYWRlcihvcHRzKTtcclxuICAgICAgICAgICAgfSwgbG9hZGVyID0gX3RtcCwgX3RtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIHByb3BlcnR5IHNvIGl0J3Mgbm90IHNwcmVhZCBvbiA8aW1nPlxyXG4gICAgICAgIGRlbGV0ZSByZXN0LmxvYWRlcjtcclxuICAgIH1cclxuICAgIGxldCBzdGF0aWNTcmMgPSAnJztcclxuICAgIGlmIChpc1N0YXRpY0ltcG9ydChzcmMpKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGljSW1hZ2VEYXRhID0gaXNTdGF0aWNSZXF1aXJlKHNyYykgPyBzcmMuZGVmYXVsdCA6IHNyYztcclxuICAgICAgICBpZiAoIXN0YXRpY0ltYWdlRGF0YS5zcmMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIHNyYy4gUmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShzdGF0aWNJbWFnZURhdGEpfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBibHVyRGF0YVVSTCA9IGJsdXJEYXRhVVJMIHx8IHN0YXRpY0ltYWdlRGF0YS5ibHVyRGF0YVVSTDtcclxuICAgICAgICBzdGF0aWNTcmMgPSBzdGF0aWNJbWFnZURhdGEuc3JjO1xyXG4gICAgICAgIGlmICghbGF5b3V0IHx8IGxheW91dCAhPT0gJ2ZpbGwnKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCBzdGF0aWNJbWFnZURhdGEuaGVpZ2h0O1xyXG4gICAgICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHN0YXRpY0ltYWdlRGF0YS53aWR0aDtcclxuICAgICAgICAgICAgaWYgKCFzdGF0aWNJbWFnZURhdGEuaGVpZ2h0IHx8ICFzdGF0aWNJbWFnZURhdGEud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBoZWlnaHQgYW5kIHdpZHRoLiBSZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHN0YXRpY0ltYWdlRGF0YSl9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzcmMgPSB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyA/IHNyYyA6IHN0YXRpY1NyYztcclxuICAgIGNvbnN0IHdpZHRoSW50ID0gZ2V0SW50KHdpZHRoKTtcclxuICAgIGNvbnN0IGhlaWdodEludCA9IGdldEludChoZWlnaHQpO1xyXG4gICAgY29uc3QgcXVhbGl0eUludCA9IGdldEludChxdWFsaXR5KTtcclxuICAgIGxldCBpc0xhenkgPSAhcHJpb3JpdHkgJiYgKGxvYWRpbmcgPT09ICdsYXp5JyB8fCB0eXBlb2YgbG9hZGluZyA9PT0gJ3VuZGVmaW5lZCcpO1xyXG4gICAgaWYgKHNyYy5zdGFydHNXaXRoKCdkYXRhOicpIHx8IHNyYy5zdGFydHNXaXRoKCdibG9iOicpKSB7XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9EYXRhX1VSSXNcclxuICAgICAgICB1bm9wdGltaXplZCA9IHRydWU7XHJcbiAgICAgICAgaXNMYXp5ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9hZGVkSW1hZ2VVUkxzLmhhcyhzcmMpKSB7XHJcbiAgICAgICAgaXNMYXp5ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoZXhwZXJpbWVudGFsVW5vcHRpbWl6ZWQpIHtcclxuICAgICAgICB1bm9wdGltaXplZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBbYmx1ckNvbXBsZXRlLCBzZXRCbHVyQ29tcGxldGVdID0gKDAsIF9yZWFjdCkudXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW3NldEludGVyc2VjdGlvbiwgaXNJbnRlcnNlY3RlZCwgcmVzZXRJbnRlcnNlY3RlZF0gPSAoMCwgX3VzZUludGVyc2VjdGlvbikudXNlSW50ZXJzZWN0aW9uKHtcclxuICAgICAgICByb290UmVmOiBsYXp5Um9vdCxcclxuICAgICAgICByb290TWFyZ2luOiBsYXp5Qm91bmRhcnkgfHwgJzIwMHB4JyxcclxuICAgICAgICBkaXNhYmxlZDogIWlzTGF6eVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBpc1Zpc2libGUgPSAhaXNMYXp5IHx8IGlzSW50ZXJzZWN0ZWQ7XHJcbiAgICBjb25zdCB3cmFwcGVyU3R5bGUgPSB7XHJcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXHJcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcclxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXHJcbiAgICAgICAgd2lkdGg6ICdpbml0aWFsJyxcclxuICAgICAgICBoZWlnaHQ6ICdpbml0aWFsJyxcclxuICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXHJcbiAgICAgICAgb3BhY2l0eTogMSxcclxuICAgICAgICBib3JkZXI6IDAsXHJcbiAgICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICAgIHBhZGRpbmc6IDBcclxuICAgIH07XHJcbiAgICBjb25zdCBzaXplclN0eWxlID0ge1xyXG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxyXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXHJcbiAgICAgICAgd2lkdGg6ICdpbml0aWFsJyxcclxuICAgICAgICBoZWlnaHQ6ICdpbml0aWFsJyxcclxuICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXHJcbiAgICAgICAgb3BhY2l0eTogMSxcclxuICAgICAgICBib3JkZXI6IDAsXHJcbiAgICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICAgIHBhZGRpbmc6IDBcclxuICAgIH07XHJcbiAgICBsZXQgaGFzU2l6ZXIgPSBmYWxzZTtcclxuICAgIGxldCBzaXplclN2Z1VybDtcclxuICAgIGNvbnN0IGxheW91dFN0eWxlID0ge1xyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICByaWdodDogMCxcclxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcclxuICAgICAgICBwYWRkaW5nOiAwLFxyXG4gICAgICAgIGJvcmRlcjogJ25vbmUnLFxyXG4gICAgICAgIG1hcmdpbjogJ2F1dG8nLFxyXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXHJcbiAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgaGVpZ2h0OiAwLFxyXG4gICAgICAgIG1pbldpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcclxuICAgICAgICBtaW5IZWlnaHQ6ICcxMDAlJyxcclxuICAgICAgICBtYXhIZWlnaHQ6ICcxMDAlJyxcclxuICAgICAgICBvYmplY3RGaXQsXHJcbiAgICAgICAgb2JqZWN0UG9zaXRpb25cclxuICAgIH07XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGlmICghc3JjKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcInNyY1wiIHByb3BlcnR5LiBNYWtlIHN1cmUgeW91IHBhc3MgXCJzcmNcIiBpbiBwcm9wcyB0byB0aGUgXFxgbmV4dC9pbWFnZVxcYCBjb21wb25lbnQuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgIHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgcXVhbGl0eVxyXG4gICAgICAgICAgICB9KX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFWQUxJRF9MQVlPVVRfVkFMVUVTLmluY2x1ZGVzKGxheW91dCkpIHtcclxuICAgICAgICAgICAgaWYgKGxheW91dCA9PT0gJ3JhdycpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGxheW91dD1cInJhd1wiIGV4cGVyaW1lbnQgaGFzIGJlZW4gbW92ZWQgdG8gYSBuZXcgbW9kdWxlLiBQbGVhc2UgaW1wb3J0IFxcYG5leHQvZnV0dXJlL2ltYWdlXFxgIGluc3RlYWQuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwibGF5b3V0XCIgcHJvcGVydHkuIFByb3ZpZGVkIFwiJHtsYXlvdXR9XCIgc2hvdWxkIGJlIG9uZSBvZiAke1ZBTElEX0xBWU9VVF9WQUxVRVMubWFwKFN0cmluZykuam9pbignLCcpfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aEludCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYU4od2lkdGhJbnQpIHx8IHR5cGVvZiBoZWlnaHRJbnQgIT09ICd1bmRlZmluZWQnICYmIGlzTmFOKGhlaWdodEludCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwid2lkdGhcIiBvciBcImhlaWdodFwiIHByb3BlcnR5LiBUaGVzZSBzaG91bGQgYmUgbnVtZXJpYyB2YWx1ZXMuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYXlvdXQgPT09ICdmaWxsJyAmJiAod2lkdGggfHwgaGVpZ2h0KSkge1xyXG4gICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBhbmQgXCJsYXlvdXQ9J2ZpbGwnXCIgaGFzIHVudXNlZCBwcm9wZXJ0aWVzIGFzc2lnbmVkLiBQbGVhc2UgcmVtb3ZlIFwid2lkdGhcIiBhbmQgXCJoZWlnaHRcIi5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFWQUxJRF9MT0FESU5HX1ZBTFVFUy5pbmNsdWRlcyhsb2FkaW5nKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGludmFsaWQgXCJsb2FkaW5nXCIgcHJvcGVydHkuIFByb3ZpZGVkIFwiJHtsb2FkaW5nfVwiIHNob3VsZCBiZSBvbmUgb2YgJHtWQUxJRF9MT0FESU5HX1ZBTFVFUy5tYXAoU3RyaW5nKS5qb2luKCcsJyl9LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJpb3JpdHkgJiYgbG9hZGluZyA9PT0gJ2xhenknKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYm90aCBcInByaW9yaXR5XCIgYW5kIFwibG9hZGluZz0nbGF6eSdcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNpemVzICYmIGxheW91dCAhPT0gJ2ZpbGwnICYmIGxheW91dCAhPT0gJ3Jlc3BvbnNpdmUnKSB7XHJcbiAgICAgICAgICAgICgwLCBfdXRpbHMpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBcInNpemVzXCIgcHJvcGVydHkgYnV0IGl0IHdpbGwgYmUgaWdub3JlZC4gT25seSB1c2UgXCJzaXplc1wiIHdpdGggXCJsYXlvdXQ9J2ZpbGwnXCIgb3IgXCJsYXlvdXQ9J3Jlc3BvbnNpdmUnXCJgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyID09PSAnYmx1cicpIHtcclxuICAgICAgICAgICAgaWYgKGxheW91dCAhPT0gJ2ZpbGwnICYmICh3aWR0aEludCB8fCAwKSAqIChoZWlnaHRJbnQgfHwgMCkgPCAxNjAwKSB7XHJcbiAgICAgICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyBzbWFsbGVyIHRoYW4gNDB4NDAuIENvbnNpZGVyIHJlbW92aW5nIHRoZSBcInBsYWNlaG9sZGVyPSdibHVyJ1wiIHByb3BlcnR5IHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFibHVyRGF0YVVSTCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgVkFMSURfQkxVUl9FWFQgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2pwZWcnLFxyXG4gICAgICAgICAgICAgICAgICAgICdwbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgICd3ZWJwJyxcclxuICAgICAgICAgICAgICAgICAgICAnYXZpZidcclxuICAgICAgICAgICAgICAgIF0gLy8gc2hvdWxkIG1hdGNoIG5leHQtaW1hZ2UtbG9hZGVyXHJcbiAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIFwicGxhY2Vob2xkZXI9J2JsdXInXCIgcHJvcGVydHkgYnV0IGlzIG1pc3NpbmcgdGhlIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eS5cclxuICAgICAgICAgIFBvc3NpYmxlIHNvbHV0aW9uczpcclxuICAgICAgICAgICAgLSBBZGQgYSBcImJsdXJEYXRhVVJMXCIgcHJvcGVydHksIHRoZSBjb250ZW50cyBzaG91bGQgYmUgYSBzbWFsbCBEYXRhIFVSTCB0byByZXByZXNlbnQgdGhlIGltYWdlXHJcbiAgICAgICAgICAgIC0gQ2hhbmdlIHRoZSBcInNyY1wiIHByb3BlcnR5IHRvIGEgc3RhdGljIGltcG9ydCB3aXRoIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZpbGUgdHlwZXM6ICR7VkFMSURfQkxVUl9FWFQuam9pbignLCcpfVxyXG4gICAgICAgICAgICAtIFJlbW92ZSB0aGUgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5LCBlZmZlY3RpdmVseSBubyBibHVyIGVmZmVjdFxyXG4gICAgICAgICAgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wbGFjZWhvbGRlci1ibHVyLWRhdGEtdXJsYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCdyZWYnIGluIHJlc3QpIHtcclxuICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgdXNpbmcgdW5zdXBwb3J0ZWQgXCJyZWZcIiBwcm9wZXJ0eS4gQ29uc2lkZXIgdXNpbmcgdGhlIFwib25Mb2FkaW5nQ29tcGxldGVcIiBwcm9wZXJ0eSBpbnN0ZWFkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXVub3B0aW1pemVkICYmIGxvYWRlciAhPT0gZGVmYXVsdEltYWdlTG9hZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVybFN0ciA9IGxvYWRlcih7XHJcbiAgICAgICAgICAgICAgICBjb25maWcsXHJcbiAgICAgICAgICAgICAgICBzcmMsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGhJbnQgfHwgNDAwLFxyXG4gICAgICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCB8fCA3NVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGV0IHVybDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHVybCA9IG5ldyBVUkwodXJsU3RyKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxyXG4gICAgICAgICAgICBpZiAodXJsU3RyID09PSBzcmMgfHwgdXJsICYmIHVybC5wYXRobmFtZSA9PT0gc3JjICYmICF1cmwuc2VhcmNoKSB7XHJcbiAgICAgICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYSBcImxvYWRlclwiIHByb3BlcnR5IHRoYXQgZG9lcyBub3QgaW1wbGVtZW50IHdpZHRoLiBQbGVhc2UgaW1wbGVtZW50IGl0IG9yIHVzZSB0aGUgXCJ1bm9wdGltaXplZFwiIHByb3BlcnR5IGluc3RlYWQuYCArIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtbWlzc2luZy1sb2FkZXItd2lkdGhgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3R5bGUpIHtcclxuICAgICAgICAgICAgbGV0IG92ZXJ3cml0dGVuU3R5bGVzID0gT2JqZWN0LmtleXMoc3R5bGUpLmZpbHRlcigoa2V5KT0+a2V5IGluIGxheW91dFN0eWxlKTtcclxuICAgICAgICAgICAgaWYgKG92ZXJ3cml0dGVuU3R5bGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjICR7c3JjfSBpcyBhc3NpZ25lZCB0aGUgZm9sbG93aW5nIHN0eWxlcywgd2hpY2ggYXJlIG92ZXJ3cml0dGVuIGJ5IGF1dG9tYXRpY2FsbHktZ2VuZXJhdGVkIHN0eWxlczogJHtvdmVyd3JpdHRlblN0eWxlcy5qb2luKCcsICcpfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhcGVyZk9ic2VydmVyICYmIHdpbmRvdy5QZXJmb3JtYW5jZU9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHBlcmZPYnNlcnZlciA9IG5ldyBQZXJmb3JtYW5jZU9ic2VydmVyKChlbnRyeUxpc3QpPT57XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJ5TGlzdC5nZXRFbnRyaWVzKCkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIG1pc3NpbmcgXCJMYXJnZXN0Q29udGVudGZ1bFBhaW50XCIgY2xhc3Mgd2l0aCBcImVsZW1lbnRcIiBwcm9wXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1nU3JjID0gKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiAocmVmID0gZW50cnkuZWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5zcmMpIHx8ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxjcEltYWdlID0gYWxsSW1ncy5nZXQoaW1nU3JjKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGNwSW1hZ2UgJiYgIWxjcEltYWdlLnByaW9yaXR5ICYmIGxjcEltYWdlLnBsYWNlaG9sZGVyICE9PSAnYmx1cicgJiYgIWxjcEltYWdlLnNyYy5zdGFydHNXaXRoKCdkYXRhOicpICYmICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aCgnYmxvYjonKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3dlYi5kZXYvbGNwLyNtZWFzdXJlLWxjcC1pbi1qYXZhc2NyaXB0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbHMpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7bGNwSW1hZ2Uuc3JjfVwiIHdhcyBkZXRlY3RlZCBhcyB0aGUgTGFyZ2VzdCBDb250ZW50ZnVsIFBhaW50IChMQ1ApLiBQbGVhc2UgYWRkIHRoZSBcInByaW9yaXR5XCIgcHJvcGVydHkgaWYgdGhpcyBpbWFnZSBpcyBhYm92ZSB0aGUgZm9sZC5gICsgYFxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3ByaW9yaXR5YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHBlcmZPYnNlcnZlci5vYnNlcnZlKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGFyZ2VzdC1jb250ZW50ZnVsLXBhaW50JyxcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXJlZDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgLy8gTG9nIGVycm9yIGJ1dCBkb24ndCBjcmFzaCB0aGUgYXBwXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbWdTdHlsZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0eWxlLCBsYXlvdXRTdHlsZSk7XHJcbiAgICBjb25zdCBibHVyU3R5bGUgPSBwbGFjZWhvbGRlciA9PT0gJ2JsdXInICYmICFibHVyQ29tcGxldGUgPyB7XHJcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IG9iamVjdEZpdCB8fCAnY292ZXInLFxyXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogb2JqZWN0UG9zaXRpb24gfHwgJzAlIDAlJyxcclxuICAgICAgICBmaWx0ZXI6ICdibHVyKDIwcHgpJyxcclxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoXCIke2JsdXJEYXRhVVJMfVwiKWBcclxuICAgIH0gOiB7fTtcclxuICAgIGlmIChsYXlvdXQgPT09ICdmaWxsJykge1xyXG4gICAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIGxheW91dD1cImZpbGxcIiAvPlxyXG4gICAgICAgIHdyYXBwZXJTdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICB3cmFwcGVyU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIHdyYXBwZXJTdHlsZS50b3AgPSAwO1xyXG4gICAgICAgIHdyYXBwZXJTdHlsZS5sZWZ0ID0gMDtcclxuICAgICAgICB3cmFwcGVyU3R5bGUuYm90dG9tID0gMDtcclxuICAgICAgICB3cmFwcGVyU3R5bGUucmlnaHQgPSAwO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2lkdGhJbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBoZWlnaHRJbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiAvPlxyXG4gICAgICAgIGNvbnN0IHF1b3RpZW50ID0gaGVpZ2h0SW50IC8gd2lkdGhJbnQ7XHJcbiAgICAgICAgY29uc3QgcGFkZGluZ1RvcCA9IGlzTmFOKHF1b3RpZW50KSA/ICcxMDAlJyA6IGAke3F1b3RpZW50ICogMTAwfSVgO1xyXG4gICAgICAgIGlmIChsYXlvdXQgPT09ICdyZXNwb25zaXZlJykge1xyXG4gICAgICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIGxheW91dD1cInJlc3BvbnNpdmVcIiAvPlxyXG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcbiAgICAgICAgICAgIGhhc1NpemVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2l6ZXJTdHlsZS5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcDtcclxuICAgICAgICB9IGVsc2UgaWYgKGxheW91dCA9PT0gJ2ludHJpbnNpYycpIHtcclxuICAgICAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiBsYXlvdXQ9XCJpbnRyaW5zaWNcIiAvPlxyXG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xyXG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUubWF4V2lkdGggPSAnMTAwJSc7XHJcbiAgICAgICAgICAgIGhhc1NpemVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2l6ZXJTdHlsZS5tYXhXaWR0aCA9ICcxMDAlJztcclxuICAgICAgICAgICAgc2l6ZXJTdmdVcmwgPSBgZGF0YTppbWFnZS9zdmcreG1sLCUzY3N2ZyUyMHhtbG5zPSUyN2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJTI3JTIwdmVyc2lvbj0lMjcxLjElMjclMjB3aWR0aD0lMjcke3dpZHRoSW50fSUyNyUyMGhlaWdodD0lMjcke2hlaWdodEludH0lMjcvJTNlYDtcclxuICAgICAgICB9IGVsc2UgaWYgKGxheW91dCA9PT0gJ2ZpeGVkJykge1xyXG4gICAgICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIGxheW91dD1cImZpeGVkXCIgLz5cclxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcclxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLndpZHRoID0gd2lkdGhJbnQ7XHJcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5oZWlnaHQgPSBoZWlnaHRJbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiAvPlxyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBtdXN0IHVzZSBcIndpZHRoXCIgYW5kIFwiaGVpZ2h0XCIgcHJvcGVydGllcyBvciBcImxheW91dD0nZmlsbCdcIiBwcm9wZXJ0eS5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgaW1nQXR0cmlidXRlcyA9IHtcclxuICAgICAgICBzcmM6IGVtcHR5RGF0YVVSTCxcclxuICAgICAgICBzcmNTZXQ6IHVuZGVmaW5lZCxcclxuICAgICAgICBzaXplczogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG4gICAgaWYgKGlzVmlzaWJsZSkge1xyXG4gICAgICAgIGltZ0F0dHJpYnV0ZXMgPSBnZW5lcmF0ZUltZ0F0dHJzKHtcclxuICAgICAgICAgICAgY29uZmlnLFxyXG4gICAgICAgICAgICBzcmMsXHJcbiAgICAgICAgICAgIHVub3B0aW1pemVkLFxyXG4gICAgICAgICAgICBsYXlvdXQsXHJcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aEludCxcclxuICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCxcclxuICAgICAgICAgICAgc2l6ZXMsXHJcbiAgICAgICAgICAgIGxvYWRlclxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbGV0IHNyY1N0cmluZyA9IHNyYztcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGxldCBmdWxsVXJsO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZnVsbFVybCA9IG5ldyBVUkwoaW1nQXR0cmlidXRlcy5zcmMpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBmdWxsVXJsID0gbmV3IFVSTChpbWdBdHRyaWJ1dGVzLnNyYywgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFsbEltZ3Muc2V0KGZ1bGxVcmwuaHJlZiwge1xyXG4gICAgICAgICAgICAgICAgc3JjLFxyXG4gICAgICAgICAgICAgICAgcHJpb3JpdHksXHJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgaW1hZ2VTcmNTZXRQcm9wTmFtZSA9ICdpbWFnZXNyY3NldCc7XHJcbiAgICBsZXQgaW1hZ2VTaXplc1Byb3BOYW1lID0gJ2ltYWdlc2l6ZXMnO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9SRUFDVF9ST09UKSB7XHJcbiAgICAgICAgaW1hZ2VTcmNTZXRQcm9wTmFtZSA9ICdpbWFnZVNyY1NldCc7XHJcbiAgICAgICAgaW1hZ2VTaXplc1Byb3BOYW1lID0gJ2ltYWdlU2l6ZXMnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGlua1Byb3BzID0ge1xyXG4gICAgICAgIC8vIE5vdGU6IGltYWdlc3Jjc2V0IGFuZCBpbWFnZXNpemVzIGFyZSBub3QgaW4gdGhlIGxpbmsgZWxlbWVudCB0eXBlIHdpdGggcmVhY3QgMTcuXHJcbiAgICAgICAgW2ltYWdlU3JjU2V0UHJvcE5hbWVdOiBpbWdBdHRyaWJ1dGVzLnNyY1NldCxcclxuICAgICAgICBbaW1hZ2VTaXplc1Byb3BOYW1lXTogaW1nQXR0cmlidXRlcy5zaXplc1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHVzZUxheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0IDogX3JlYWN0LmRlZmF1bHQudXNlTGF5b3V0RWZmZWN0O1xyXG4gICAgY29uc3Qgb25Mb2FkaW5nQ29tcGxldGVSZWYgPSAoMCwgX3JlYWN0KS51c2VSZWYob25Mb2FkaW5nQ29tcGxldGUpO1xyXG4gICAgY29uc3QgcHJldmlvdXNJbWFnZVNyYyA9ICgwLCBfcmVhY3QpLnVzZVJlZihzcmMpO1xyXG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XHJcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYuY3VycmVudCA9IG9uTG9hZGluZ0NvbXBsZXRlO1xyXG4gICAgfSwgW1xyXG4gICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlXHJcbiAgICBdKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKT0+e1xyXG4gICAgICAgIGlmIChwcmV2aW91c0ltYWdlU3JjLmN1cnJlbnQgIT09IHNyYykge1xyXG4gICAgICAgICAgICByZXNldEludGVyc2VjdGVkKCk7XHJcbiAgICAgICAgICAgIHByZXZpb3VzSW1hZ2VTcmMuY3VycmVudCA9IHNyYztcclxuICAgICAgICB9XHJcbiAgICB9LCBbXHJcbiAgICAgICAgcmVzZXRJbnRlcnNlY3RlZCxcclxuICAgICAgICBzcmNcclxuICAgIF0pO1xyXG4gICAgY29uc3QgaW1nRWxlbWVudEFyZ3MgPSBfZXh0ZW5kcyh7XHJcbiAgICAgICAgaXNMYXp5LFxyXG4gICAgICAgIGltZ0F0dHJpYnV0ZXMsXHJcbiAgICAgICAgaGVpZ2h0SW50LFxyXG4gICAgICAgIHdpZHRoSW50LFxyXG4gICAgICAgIHF1YWxpdHlJbnQsXHJcbiAgICAgICAgbGF5b3V0LFxyXG4gICAgICAgIGNsYXNzTmFtZSxcclxuICAgICAgICBpbWdTdHlsZSxcclxuICAgICAgICBibHVyU3R5bGUsXHJcbiAgICAgICAgbG9hZGluZyxcclxuICAgICAgICBjb25maWcsXHJcbiAgICAgICAgdW5vcHRpbWl6ZWQsXHJcbiAgICAgICAgcGxhY2Vob2xkZXIsXHJcbiAgICAgICAgbG9hZGVyLFxyXG4gICAgICAgIHNyY1N0cmluZyxcclxuICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcclxuICAgICAgICBzZXRCbHVyQ29tcGxldGUsXHJcbiAgICAgICAgc2V0SW50ZXJzZWN0aW9uLFxyXG4gICAgICAgIGlzVmlzaWJsZSxcclxuICAgICAgICBub3NjcmlwdFNpemVzOiBzaXplc1xyXG4gICAgfSwgcmVzdCk7XHJcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcclxuICAgICAgICBzdHlsZTogd3JhcHBlclN0eWxlXHJcbiAgICB9LCBoYXNTaXplciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xyXG4gICAgICAgIHN0eWxlOiBzaXplclN0eWxlXHJcbiAgICB9LCBzaXplclN2Z1VybCA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7XHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcclxuICAgICAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgd2lkdGg6ICdpbml0aWFsJyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAnaW5pdGlhbCcsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcclxuICAgICAgICAgICAgb3BhY2l0eTogMSxcclxuICAgICAgICAgICAgYm9yZGVyOiAwLFxyXG4gICAgICAgICAgICBtYXJnaW46IDAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFsdDogXCJcIixcclxuICAgICAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXHJcbiAgICAgICAgc3JjOiBzaXplclN2Z1VybFxyXG4gICAgfSkgOiBudWxsKSA6IG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChJbWFnZUVsZW1lbnQsIE9iamVjdC5hc3NpZ24oe30sIGltZ0VsZW1lbnRBcmdzKSkpLCBwcmlvcml0eSA/IC8vIE5vdGUgaG93IHdlIG9taXQgdGhlIGBocmVmYCBhdHRyaWJ1dGUsIGFzIGl0IHdvdWxkIG9ubHkgYmUgcmVsZXZhbnRcclxuICAgIC8vIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGBpbWFnZXNyY3NldGAsIGFuZCBpbiB0aG9zZSBjYXNlc1xyXG4gICAgLy8gaXQgd291bGQgbGlrZWx5IGNhdXNlIHRoZSBpbmNvcnJlY3QgaW1hZ2UgdG8gYmUgcHJlbG9hZGVkLlxyXG4gICAgLy9cclxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI2F0dHItbGluay1pbWFnZXNyY3NldFxyXG4gICAgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9oZWFkLmRlZmF1bHQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAga2V5OiAnX19uaW1nLScgKyBpbWdBdHRyaWJ1dGVzLnNyYyArIGltZ0F0dHJpYnV0ZXMuc3JjU2V0ICsgaW1nQXR0cmlidXRlcy5zaXplcyxcclxuICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxyXG4gICAgICAgIGFzOiBcImltYWdlXCIsXHJcbiAgICAgICAgaHJlZjogaW1nQXR0cmlidXRlcy5zcmNTZXQgPyB1bmRlZmluZWQgOiBpbWdBdHRyaWJ1dGVzLnNyY1xyXG4gICAgfSwgbGlua1Byb3BzKSkpIDogbnVsbCk7XHJcbn1cclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XHJcbiAgICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSl7XHJcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcclxuICAgICAgICBkZWZhdWx0OiBvYmpcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xyXG4gICAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xyXG4gICAgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcclxuICAgIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gY2FjaGU7XHJcbn1cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7XHJcbiAgICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkZWZhdWx0OiBvYmpcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7XHJcbiAgICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XHJcbiAgICB9XHJcbiAgICB2YXIgbmV3T2JqID0ge307XHJcbiAgICB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XHJcbiAgICBmb3IodmFyIGtleSBpbiBvYmope1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xyXG4gICAgICAgICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xyXG4gICAgaWYgKGNhY2hlKSB7XHJcbiAgICAgICAgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdPYmo7XHJcbn1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xyXG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XHJcbiAgICB2YXIgdGFyZ2V0ID0ge307XHJcbiAgICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XHJcbiAgICB2YXIga2V5LCBpO1xyXG4gICAgZm9yKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcclxuICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xyXG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcbmNvbnN0IHsgZXhwZXJpbWVudGFsUmVtb3RlUGF0dGVybnMgPVtdICwgZXhwZXJpbWVudGFsVW5vcHRpbWl6ZWQgIH0gPSBwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUUyB8fCB7fTtcclxuY29uc3QgY29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFM7XHJcbmNvbnN0IGxvYWRlZEltYWdlVVJMcyA9IG5ldyBTZXQoKTtcclxuY29uc3QgYWxsSW1ncyA9IG5ldyBNYXAoKTtcclxubGV0IHBlcmZPYnNlcnZlcjtcclxuY29uc3QgZW1wdHlEYXRhVVJMID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBNyc7XHJcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgZ2xvYmFsLl9fTkVYVF9JTUFHRV9JTVBPUlRFRCA9IHRydWU7XHJcbn1cclxuY29uc3QgVkFMSURfTE9BRElOR19WQUxVRVMgPSBbXHJcbiAgICAnbGF6eScsXHJcbiAgICAnZWFnZXInLFxyXG4gICAgdW5kZWZpbmVkXHJcbl07XHJcbmNvbnN0IGxvYWRlcnMgPSBuZXcgTWFwKFtcclxuICAgIFtcclxuICAgICAgICAnZGVmYXVsdCcsXHJcbiAgICAgICAgZGVmYXVsdExvYWRlclxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAnaW1naXgnLFxyXG4gICAgICAgIGltZ2l4TG9hZGVyXHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgICdjbG91ZGluYXJ5JyxcclxuICAgICAgICBjbG91ZGluYXJ5TG9hZGVyXHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgICdha2FtYWknLFxyXG4gICAgICAgIGFrYW1haUxvYWRlclxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAnY3VzdG9tJyxcclxuICAgICAgICBjdXN0b21Mb2FkZXJcclxuICAgIF0sIFxyXG5dKTtcclxuY29uc3QgVkFMSURfTEFZT1VUX1ZBTFVFUyA9IFtcclxuICAgICdmaWxsJyxcclxuICAgICdmaXhlZCcsXHJcbiAgICAnaW50cmluc2ljJyxcclxuICAgICdyZXNwb25zaXZlJyxcclxuICAgIHVuZGVmaW5lZCwgXHJcbl07XHJcbmZ1bmN0aW9uIGlzU3RhdGljUmVxdWlyZShzcmMpIHtcclxuICAgIHJldHVybiBzcmMuZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3RhdGljSW1hZ2VEYXRhKHNyYykge1xyXG4gICAgcmV0dXJuIHNyYy5zcmMgIT09IHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBpc1N0YXRpY0ltcG9ydChzcmMpIHtcclxuICAgIHJldHVybiB0eXBlb2Ygc3JjID09PSAnb2JqZWN0JyAmJiAoaXNTdGF0aWNSZXF1aXJlKHNyYykgfHwgaXNTdGF0aWNJbWFnZURhdGEoc3JjKSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0V2lkdGhzKHsgZGV2aWNlU2l6ZXMgLCBhbGxTaXplcyAgfSwgd2lkdGgsIGxheW91dCwgc2l6ZXMpIHtcclxuICAgIGlmIChzaXplcyAmJiAobGF5b3V0ID09PSAnZmlsbCcgfHwgbGF5b3V0ID09PSAncmVzcG9uc2l2ZScpKSB7XHJcbiAgICAgICAgLy8gRmluZCBhbGwgdGhlIFwidndcIiBwZXJjZW50IHNpemVzIHVzZWQgaW4gdGhlIHNpemVzIHByb3BcclxuICAgICAgICBjb25zdCB2aWV3cG9ydFdpZHRoUmUgPSAvKF58XFxzKSgxP1xcZD9cXGQpdncvZztcclxuICAgICAgICBjb25zdCBwZXJjZW50U2l6ZXMgPSBbXTtcclxuICAgICAgICBmb3IobGV0IG1hdGNoOyBtYXRjaCA9IHZpZXdwb3J0V2lkdGhSZS5leGVjKHNpemVzKTsgbWF0Y2gpe1xyXG4gICAgICAgICAgICBwZXJjZW50U2l6ZXMucHVzaChwYXJzZUludChtYXRjaFsyXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGVyY2VudFNpemVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBzbWFsbGVzdFJhdGlvID0gTWF0aC5taW4oLi4ucGVyY2VudFNpemVzKSAqIDAuMDE7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aHM6IGFsbFNpemVzLmZpbHRlcigocyk9PnMgPj0gZGV2aWNlU2l6ZXNbMF0gKiBzbWFsbGVzdFJhdGlvKSxcclxuICAgICAgICAgICAgICAgIGtpbmQ6ICd3J1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB3aWR0aHM6IGFsbFNpemVzLFxyXG4gICAgICAgICAgICBraW5kOiAndydcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ251bWJlcicgfHwgbGF5b3V0ID09PSAnZmlsbCcgfHwgbGF5b3V0ID09PSAncmVzcG9uc2l2ZScpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB3aWR0aHM6IGRldmljZVNpemVzLFxyXG4gICAgICAgICAgICBraW5kOiAndydcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3Qgd2lkdGhzID0gW1xyXG4gICAgICAgIC4uLm5ldyBTZXQoLy8gPiBUaGlzIG1lYW5zIHRoYXQgbW9zdCBPTEVEIHNjcmVlbnMgdGhhdCBzYXkgdGhleSBhcmUgM3ggcmVzb2x1dGlvbixcclxuICAgICAgICAvLyA+IGFyZSBhY3R1YWxseSAzeCBpbiB0aGUgZ3JlZW4gY29sb3IsIGJ1dCBvbmx5IDEuNXggaW4gdGhlIHJlZCBhbmRcclxuICAgICAgICAvLyA+IGJsdWUgY29sb3JzLiBTaG93aW5nIGEgM3ggcmVzb2x1dGlvbiBpbWFnZSBpbiB0aGUgYXBwIHZzIGEgMnhcclxuICAgICAgICAvLyA+IHJlc29sdXRpb24gaW1hZ2Ugd2lsbCBiZSB2aXN1YWxseSB0aGUgc2FtZSwgdGhvdWdoIHRoZSAzeCBpbWFnZVxyXG4gICAgICAgIC8vID4gdGFrZXMgc2lnbmlmaWNhbnRseSBtb3JlIGRhdGEuIEV2ZW4gdHJ1ZSAzeCByZXNvbHV0aW9uIHNjcmVlbnMgYXJlXHJcbiAgICAgICAgLy8gPiB3YXN0ZWZ1bCBhcyB0aGUgaHVtYW4gZXllIGNhbm5vdCBzZWUgdGhhdCBsZXZlbCBvZiBkZXRhaWwgd2l0aG91dFxyXG4gICAgICAgIC8vID4gc29tZXRoaW5nIGxpa2UgYSBtYWduaWZ5aW5nIGdsYXNzLlxyXG4gICAgICAgIC8vIGh0dHBzOi8vYmxvZy50d2l0dGVyLmNvbS9lbmdpbmVlcmluZy9lbl91cy90b3BpY3MvaW5mcmFzdHJ1Y3R1cmUvMjAxOS9jYXBwaW5nLWltYWdlLWZpZGVsaXR5LW9uLXVsdHJhLWhpZ2gtcmVzb2x1dGlvbi1kZXZpY2VzLmh0bWxcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgIHdpZHRoLFxyXG4gICAgICAgICAgICB3aWR0aCAqIDIgLyosIHdpZHRoICogMyovIFxyXG4gICAgICAgIF0ubWFwKCh3KT0+YWxsU2l6ZXMuZmluZCgocCk9PnAgPj0gdykgfHwgYWxsU2l6ZXNbYWxsU2l6ZXMubGVuZ3RoIC0gMV0pKSwgXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB3aWR0aHMsXHJcbiAgICAgICAga2luZDogJ3gnXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdlbmVyYXRlSW1nQXR0cnMoeyBjb25maWcgLCBzcmMgLCB1bm9wdGltaXplZCAsIGxheW91dCAsIHdpZHRoICwgcXVhbGl0eSAsIHNpemVzICwgbG9hZGVyICB9KSB7XHJcbiAgICBpZiAodW5vcHRpbWl6ZWQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzcmMsXHJcbiAgICAgICAgICAgIHNyY1NldDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBzaXplczogdW5kZWZpbmVkXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgd2lkdGhzICwga2luZCAgfSA9IGdldFdpZHRocyhjb25maWcsIHdpZHRoLCBsYXlvdXQsIHNpemVzKTtcclxuICAgIGNvbnN0IGxhc3QgPSB3aWR0aHMubGVuZ3RoIC0gMTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2l6ZXM6ICFzaXplcyAmJiBraW5kID09PSAndycgPyAnMTAwdncnIDogc2l6ZXMsXHJcbiAgICAgICAgc3JjU2V0OiB3aWR0aHMubWFwKCh3LCBpKT0+YCR7bG9hZGVyKHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZyxcclxuICAgICAgICAgICAgICAgIHNyYyxcclxuICAgICAgICAgICAgICAgIHF1YWxpdHksXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogd1xyXG4gICAgICAgICAgICB9KX0gJHtraW5kID09PSAndycgPyB3IDogaSArIDF9JHtraW5kfWApLmpvaW4oJywgJyksXHJcbiAgICAgICAgLy8gSXQncyBpbnRlbmRlZCB0byBrZWVwIGBzcmNgIHRoZSBsYXN0IGF0dHJpYnV0ZSBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcclxuICAgICAgICAvLyBhdHRyaWJ1dGVzIGluIG9yZGVyLiBJZiB3ZSBrZWVwIGBzcmNgIHRoZSBmaXJzdCBvbmUsIFNhZmFyaSB3aWxsXHJcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgc3RhcnQgdG8gZmV0Y2ggYHNyY2AsIGJlZm9yZSBgc2l6ZXNgIGFuZCBgc3JjU2V0YCBhcmUgZXZlblxyXG4gICAgICAgIC8vIHVwZGF0ZWQgYnkgUmVhY3QuIFRoYXQgY2F1c2VzIG11bHRpcGxlIHVubmVjZXNzYXJ5IHJlcXVlc3RzIGlmIGBzcmNTZXRgXHJcbiAgICAgICAgLy8gYW5kIGBzaXplc2AgYXJlIGRlZmluZWQuXHJcbiAgICAgICAgLy8gVGhpcyBidWcgY2Fubm90IGJlIHJlcHJvZHVjZWQgaW4gQ2hyb21lIG9yIEZpcmVmb3guXHJcbiAgICAgICAgc3JjOiBsb2FkZXIoe1xyXG4gICAgICAgICAgICBjb25maWcsXHJcbiAgICAgICAgICAgIHNyYyxcclxuICAgICAgICAgICAgcXVhbGl0eSxcclxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoc1tsYXN0XVxyXG4gICAgICAgIH0pXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldEludCh4KSB7XHJcbiAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHgsIDEwKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuZnVuY3Rpb24gZGVmYXVsdEltYWdlTG9hZGVyKGxvYWRlclByb3BzKSB7XHJcbiAgICB2YXIgcmVmO1xyXG4gICAgY29uc3QgbG9hZGVyS2V5ID0gKChyZWYgPSBsb2FkZXJQcm9wcy5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiByZWYubG9hZGVyKSB8fCAnZGVmYXVsdCc7XHJcbiAgICBjb25zdCBsb2FkID0gbG9hZGVycy5nZXQobG9hZGVyS2V5KTtcclxuICAgIGlmIChsb2FkKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvYWQobG9hZGVyUHJvcHMpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFwibG9hZGVyXCIgZm91bmQgaW4gXCJuZXh0LmNvbmZpZy5qc1wiLiBFeHBlY3RlZDogJHtfaW1hZ2VDb25maWcuVkFMSURfTE9BREVSUy5qb2luKCcsICcpfS4gUmVjZWl2ZWQ6ICR7bG9hZGVyS2V5fWApO1xyXG59XHJcbi8vIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzk3Nzc4MzMvMjY2NTM1IGZvciB3aHkgd2UgdXNlIHRoaXMgcmVmXHJcbi8vIGhhbmRsZXIgaW5zdGVhZCBvZiB0aGUgaW1nJ3Mgb25Mb2FkIGF0dHJpYnV0ZS5cclxuZnVuY3Rpb24gaGFuZGxlTG9hZGluZyhpbWcsIHNyYywgbGF5b3V0LCBwbGFjZWhvbGRlciwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSkge1xyXG4gICAgaWYgKCFpbWcgfHwgaW1nLnNyYyA9PT0gZW1wdHlEYXRhVVJMIHx8IGltZ1snZGF0YS1sb2FkZWQtc3JjJ10gPT09IHNyYykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGltZ1snZGF0YS1sb2FkZWQtc3JjJ10gPSBzcmM7XHJcbiAgICBjb25zdCBwID0gJ2RlY29kZScgaW4gaW1nID8gaW1nLmRlY29kZSgpIDogUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICBwLmNhdGNoKCgpPT57fSkudGhlbigoKT0+e1xyXG4gICAgICAgIGlmICghaW1nLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpbiBjYXNlIG9mIHJhY2UgY29uZGl0aW9uOlxyXG4gICAgICAgICAgICAvLyAtIG9ubG9hZCgpIGlzIGNhbGxlZFxyXG4gICAgICAgICAgICAvLyAtIGRlY29kZSgpIGlzIGNhbGxlZCBidXQgaW5jb21wbGV0ZVxyXG4gICAgICAgICAgICAvLyAtIHVubW91bnQgaXMgY2FsbGVkXHJcbiAgICAgICAgICAgIC8vIC0gZGVjb2RlKCkgY29tcGxldGVzXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9hZGVkSW1hZ2VVUkxzLmFkZChzcmMpO1xyXG4gICAgICAgIGlmIChwbGFjZWhvbGRlciA9PT0gJ2JsdXInKSB7XHJcbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9uTG9hZGluZ0NvbXBsZXRlUmVmID09IG51bGwgPyB2b2lkIDAgOiBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbmF0dXJhbFdpZHRoICwgbmF0dXJhbEhlaWdodCAgfSA9IGltZztcclxuICAgICAgICAgICAgLy8gUGFzcyBiYWNrIHJlYWQtb25seSBwcmltaXRpdmUgdmFsdWVzIGJ1dCBub3QgdGhlXHJcbiAgICAgICAgICAgIC8vIHVuZGVybHlpbmcgRE9NIGVsZW1lbnQgYmVjYXVzZSBpdCBjb3VsZCBiZSBtaXN1c2VkLlxyXG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50KHtcclxuICAgICAgICAgICAgICAgIG5hdHVyYWxXaWR0aCxcclxuICAgICAgICAgICAgICAgIG5hdHVyYWxIZWlnaHRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHZhciByZWY7XHJcbiAgICAgICAgICAgIGlmICgocmVmID0gaW1nLnBhcmVudEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiByZWYucGFyZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZ2V0Q29tcHV0ZWRTdHlsZShpbWcucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50LnBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgcGFyZW50IGhhcyBub3QgYmVlbiByZW5kZXJlZCB0byB0aGUgZG9tIHlldCBhbmQgdGhlcmVmb3JlIGl0IGhhcyBubyBwb3NpdGlvbi4gU2tpcCB0aGUgd2FybmluZ3MgZm9yIHN1Y2ggY2FzZXMuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxheW91dCA9PT0gJ3Jlc3BvbnNpdmUnICYmIHBhcmVudC5kaXNwbGF5ID09PSAnZmxleCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBtYXkgbm90IHJlbmRlciBwcm9wZXJseSBhcyBhIGNoaWxkIG9mIGEgZmxleCBjb250YWluZXIuIENvbnNpZGVyIHdyYXBwaW5nIHRoZSBpbWFnZSB3aXRoIGEgZGl2IHRvIGNvbmZpZ3VyZSB0aGUgd2lkdGguYCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxheW91dCA9PT0gJ2ZpbGwnICYmIHBhcmVudC5wb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJyAmJiBwYXJlbnQucG9zaXRpb24gIT09ICdmaXhlZCcgJiYgcGFyZW50LnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgbWF5IG5vdCByZW5kZXIgcHJvcGVybHkgd2l0aCBhIHBhcmVudCB1c2luZyBwb3NpdGlvbjpcIiR7cGFyZW50LnBvc2l0aW9ufVwiLiBDb25zaWRlciBjaGFuZ2luZyB0aGUgcGFyZW50IHN0eWxlIHRvIHBvc2l0aW9uOlwicmVsYXRpdmVcIiB3aXRoIGEgd2lkdGggYW5kIGhlaWdodC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmNvbnN0IEltYWdlRWxlbWVudCA9IChfcGFyYW0pPT57XHJcbiAgICB2YXIgeyBpbWdBdHRyaWJ1dGVzICwgaGVpZ2h0SW50ICwgd2lkdGhJbnQgLCBxdWFsaXR5SW50ICwgbGF5b3V0ICwgY2xhc3NOYW1lICwgaW1nU3R5bGUgLCBibHVyU3R5bGUgLCBpc0xhenkgLCBwbGFjZWhvbGRlciAsIGxvYWRpbmcgLCBzcmNTdHJpbmcgLCBjb25maWcgLCB1bm9wdGltaXplZCAsIGxvYWRlciAsIG9uTG9hZGluZ0NvbXBsZXRlUmVmICwgc2V0Qmx1ckNvbXBsZXRlICwgc2V0SW50ZXJzZWN0aW9uICwgb25Mb2FkICwgb25FcnJvciAsIGlzVmlzaWJsZSAsIG5vc2NyaXB0U2l6ZXMgIH0gPSBfcGFyYW0sIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcGFyYW0sIFtcclxuICAgICAgICBcImltZ0F0dHJpYnV0ZXNcIixcclxuICAgICAgICBcImhlaWdodEludFwiLFxyXG4gICAgICAgIFwid2lkdGhJbnRcIixcclxuICAgICAgICBcInF1YWxpdHlJbnRcIixcclxuICAgICAgICBcImxheW91dFwiLFxyXG4gICAgICAgIFwiY2xhc3NOYW1lXCIsXHJcbiAgICAgICAgXCJpbWdTdHlsZVwiLFxyXG4gICAgICAgIFwiYmx1clN0eWxlXCIsXHJcbiAgICAgICAgXCJpc0xhenlcIixcclxuICAgICAgICBcInBsYWNlaG9sZGVyXCIsXHJcbiAgICAgICAgXCJsb2FkaW5nXCIsXHJcbiAgICAgICAgXCJzcmNTdHJpbmdcIixcclxuICAgICAgICBcImNvbmZpZ1wiLFxyXG4gICAgICAgIFwidW5vcHRpbWl6ZWRcIixcclxuICAgICAgICBcImxvYWRlclwiLFxyXG4gICAgICAgIFwib25Mb2FkaW5nQ29tcGxldGVSZWZcIixcclxuICAgICAgICBcInNldEJsdXJDb21wbGV0ZVwiLFxyXG4gICAgICAgIFwic2V0SW50ZXJzZWN0aW9uXCIsXHJcbiAgICAgICAgXCJvbkxvYWRcIixcclxuICAgICAgICBcIm9uRXJyb3JcIixcclxuICAgICAgICBcImlzVmlzaWJsZVwiLFxyXG4gICAgICAgIFwibm9zY3JpcHRTaXplc1wiXHJcbiAgICBdKTtcclxuICAgIGxvYWRpbmcgPSBpc0xhenkgPyAnbGF6eScgOiBsb2FkaW5nO1xyXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIE9iamVjdC5hc3NpZ24oe30sIHJlc3QsIGltZ0F0dHJpYnV0ZXMsIHtcclxuICAgICAgICBkZWNvZGluZzogXCJhc3luY1wiLFxyXG4gICAgICAgIFwiZGF0YS1uaW1nXCI6IGxheW91dCxcclxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcclxuICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIGltZ1N0eWxlLCBibHVyU3R5bGUpLFxyXG4gICAgICAgIHJlZjogKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKGltZyk9PntcclxuICAgICAgICAgICAgc2V0SW50ZXJzZWN0aW9uKGltZyk7XHJcbiAgICAgICAgICAgIGlmIChpbWcgPT0gbnVsbCA/IHZvaWQgMCA6IGltZy5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlTG9hZGluZyhpbWcsIHNyY1N0cmluZywgbGF5b3V0LCBwbGFjZWhvbGRlciwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbXHJcbiAgICAgICAgICAgIHNldEludGVyc2VjdGlvbixcclxuICAgICAgICAgICAgc3JjU3RyaW5nLFxyXG4gICAgICAgICAgICBsYXlvdXQsXHJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLFxyXG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcclxuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlLCBcclxuICAgICAgICBdKSxcclxuICAgICAgICBvbkxvYWQ6IChldmVudCk9PntcclxuICAgICAgICAgICAgY29uc3QgaW1nID0gZXZlbnQuY3VycmVudFRhcmdldDtcclxuICAgICAgICAgICAgaGFuZGxlTG9hZGluZyhpbWcsIHNyY1N0cmluZywgbGF5b3V0LCBwbGFjZWhvbGRlciwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSk7XHJcbiAgICAgICAgICAgIGlmIChvbkxvYWQpIHtcclxuICAgICAgICAgICAgICAgIG9uTG9hZChldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uRXJyb3I6IChldmVudCk9PntcclxuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyID09PSAnYmx1cicpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZWFsIGltYWdlIGZhaWxzIHRvIGxvYWQsIHRoaXMgd2lsbCBzdGlsbCByZW1vdmUgdGhlIHBsYWNlaG9sZGVyLlxyXG4gICAgICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBvbkVycm9yKGV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pKSwgKGlzTGF6eSB8fCBwbGFjZWhvbGRlciA9PT0gJ2JsdXInKSAmJiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJub3NjcmlwdFwiLCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwgT2JqZWN0LmFzc2lnbih7fSwgcmVzdCwgZ2VuZXJhdGVJbWdBdHRycyh7XHJcbiAgICAgICAgY29uZmlnLFxyXG4gICAgICAgIHNyYzogc3JjU3RyaW5nLFxyXG4gICAgICAgIHVub3B0aW1pemVkLFxyXG4gICAgICAgIGxheW91dCxcclxuICAgICAgICB3aWR0aDogd2lkdGhJbnQsXHJcbiAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCxcclxuICAgICAgICBzaXplczogbm9zY3JpcHRTaXplcyxcclxuICAgICAgICBsb2FkZXJcclxuICAgIH0pLCB7XHJcbiAgICAgICAgZGVjb2Rpbmc6IFwiYXN5bmNcIixcclxuICAgICAgICBcImRhdGEtbmltZ1wiOiBsYXlvdXQsXHJcbiAgICAgICAgc3R5bGU6IGltZ1N0eWxlLFxyXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgLSBUT0RPOiB1cGdyYWRlIHRvIGBAdHlwZXMvcmVhY3RAMTdgXHJcbiAgICAgICAgbG9hZGluZzogbG9hZGluZ1xyXG4gICAgfSkpKSk7XHJcbn07XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNyYyhzcmMpIHtcclxuICAgIHJldHVybiBzcmNbMF0gPT09ICcvJyA/IHNyYy5zbGljZSgxKSA6IHNyYztcclxufVxyXG5mdW5jdGlvbiBpbWdpeExvYWRlcih7IGNvbmZpZyAsIHNyYyAsIHdpZHRoICwgcXVhbGl0eSAgfSkge1xyXG4gICAgLy8gRGVtbzogaHR0cHM6Ly9zdGF0aWMuaW1naXgubmV0L2RhaXN5LnBuZz9hdXRvPWZvcm1hdCZmaXQ9bWF4Jnc9MzAwXHJcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke2NvbmZpZy5wYXRofSR7bm9ybWFsaXplU3JjKHNyYyl9YCk7XHJcbiAgICBjb25zdCBwYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xyXG4gICAgcGFyYW1zLnNldCgnYXV0bycsIHBhcmFtcy5nZXQoJ2F1dG8nKSB8fCAnZm9ybWF0Jyk7XHJcbiAgICBwYXJhbXMuc2V0KCdmaXQnLCBwYXJhbXMuZ2V0KCdmaXQnKSB8fCAnbWF4Jyk7XHJcbiAgICBwYXJhbXMuc2V0KCd3JywgcGFyYW1zLmdldCgndycpIHx8IHdpZHRoLnRvU3RyaW5nKCkpO1xyXG4gICAgaWYgKHF1YWxpdHkpIHtcclxuICAgICAgICBwYXJhbXMuc2V0KCdxJywgcXVhbGl0eS50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1cmwuaHJlZjtcclxufVxyXG5mdW5jdGlvbiBha2FtYWlMb2FkZXIoeyBjb25maWcgLCBzcmMgLCB3aWR0aCAgfSkge1xyXG4gICAgcmV0dXJuIGAke2NvbmZpZy5wYXRofSR7bm9ybWFsaXplU3JjKHNyYyl9P2ltd2lkdGg9JHt3aWR0aH1gO1xyXG59XHJcbmZ1bmN0aW9uIGNsb3VkaW5hcnlMb2FkZXIoeyBjb25maWcgLCBzcmMgLCB3aWR0aCAsIHF1YWxpdHkgIH0pIHtcclxuICAgIC8vIERlbW86IGh0dHBzOi8vcmVzLmNsb3VkaW5hcnkuY29tL2RlbW8vaW1hZ2UvdXBsb2FkL3dfMzAwLGNfbGltaXQscV9hdXRvL3R1cnRsZXMuanBnXHJcbiAgICBjb25zdCBwYXJhbXMgPSBbXHJcbiAgICAgICAgJ2ZfYXV0bycsXHJcbiAgICAgICAgJ2NfbGltaXQnLFxyXG4gICAgICAgICd3XycgKyB3aWR0aCxcclxuICAgICAgICAncV8nICsgKHF1YWxpdHkgfHwgJ2F1dG8nKVxyXG4gICAgXTtcclxuICAgIGNvbnN0IHBhcmFtc1N0cmluZyA9IHBhcmFtcy5qb2luKCcsJykgKyAnLyc7XHJcbiAgICByZXR1cm4gYCR7Y29uZmlnLnBhdGh9JHtwYXJhbXNTdHJpbmd9JHtub3JtYWxpemVTcmMoc3JjKX1gO1xyXG59XHJcbmZ1bmN0aW9uIGN1c3RvbUxvYWRlcih7IHNyYyAgfSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIG1pc3NpbmcgXCJsb2FkZXJcIiBwcm9wLmAgKyBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyYCk7XHJcbn1cclxuZnVuY3Rpb24gZGVmYXVsdExvYWRlcih7IGNvbmZpZyAsIHNyYyAsIHdpZHRoICwgcXVhbGl0eSAgfSkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBjb25zdCBtaXNzaW5nVmFsdWVzID0gW107XHJcbiAgICAgICAgLy8gdGhlc2Ugc2hvdWxkIGFsd2F5cyBiZSBwcm92aWRlZCBidXQgbWFrZSBzdXJlIHRoZXkgYXJlXHJcbiAgICAgICAgaWYgKCFzcmMpIG1pc3NpbmdWYWx1ZXMucHVzaCgnc3JjJyk7XHJcbiAgICAgICAgaWYgKCF3aWR0aCkgbWlzc2luZ1ZhbHVlcy5wdXNoKCd3aWR0aCcpO1xyXG4gICAgICAgIGlmIChtaXNzaW5nVmFsdWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXh0IEltYWdlIE9wdGltaXphdGlvbiByZXF1aXJlcyAke21pc3NpbmdWYWx1ZXMuam9pbignLCAnKX0gdG8gYmUgcHJvdmlkZWQuIE1ha2Ugc3VyZSB5b3UgcGFzcyB0aGVtIGFzIHByb3BzIHRvIHRoZSBcXGBuZXh0L2ltYWdlXFxgIGNvbXBvbmVudC4gUmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgc3JjLFxyXG4gICAgICAgICAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgICAgICAgICBxdWFsaXR5XHJcbiAgICAgICAgICAgIH0pfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3JjLnN0YXJ0c1dpdGgoJy8vJykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJHtzcmN9XCIgb24gXFxgbmV4dC9pbWFnZVxcYCwgcHJvdG9jb2wtcmVsYXRpdmUgVVJMICgvLykgbXVzdCBiZSBjaGFuZ2VkIHRvIGFuIGFic29sdXRlIFVSTCAoaHR0cDovLyBvciBodHRwczovLylgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzcmMuc3RhcnRzV2l0aCgnLycpICYmIChjb25maWcuZG9tYWlucyB8fCBleHBlcmltZW50YWxSZW1vdGVQYXR0ZXJucykpIHtcclxuICAgICAgICAgICAgbGV0IHBhcnNlZFNyYztcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHBhcnNlZFNyYyA9IG5ldyBVUkwoc3JjKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzcmMgXCIke3NyY31cIiBvbiBcXGBuZXh0L2ltYWdlXFxgLCBpZiB1c2luZyByZWxhdGl2ZSBpbWFnZSBpdCBtdXN0IHN0YXJ0IHdpdGggYSBsZWFkaW5nIHNsYXNoIFwiL1wiIG9yIGJlIGFuIGFic29sdXRlIFVSTCAoaHR0cDovLyBvciBodHRwczovLylgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0Jykge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIGR5bmFtaWMgcmVxdWlyZSBiZWNhdXNlIHRoaXMgc2hvdWxkIG9ubHkgZXJyb3IgaW4gZGV2ZWxvcG1lbnRcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGFzTWF0Y2ggIH0gPSByZXF1aXJlKCcuLi9zaGFyZWQvbGliL21hdGNoLXJlbW90ZS1wYXR0ZXJuJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc01hdGNoKGNvbmZpZy5kb21haW5zLCBleHBlcmltZW50YWxSZW1vdGVQYXR0ZXJucywgcGFyc2VkU3JjKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzcmMgcHJvcCAoJHtzcmN9KSBvbiBcXGBuZXh0L2ltYWdlXFxgLCBob3N0bmFtZSBcIiR7cGFyc2VkU3JjLmhvc3RuYW1lfVwiIGlzIG5vdCBjb25maWd1cmVkIHVuZGVyIGltYWdlcyBpbiB5b3VyIFxcYG5leHQuY29uZmlnLmpzXFxgXFxuYCArIGBTZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1ob3N0YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc3JjLmVuZHNXaXRoKCcuc3ZnJykgJiYgIWNvbmZpZy5kYW5nZXJvdXNseUFsbG93U1ZHKSB7XHJcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIG1ha2Ugc3ZnIHNlcnZlIGFzLWlzIHRvIGF2b2lkIHByb3h5aW5nXHJcbiAgICAgICAgLy8gdGhyb3VnaCB0aGUgYnVpbHQtaW4gSW1hZ2UgT3B0aW1pemF0aW9uIEFQSS5cclxuICAgICAgICByZXR1cm4gc3JjO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGAkeygwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2goY29uZmlnLnBhdGgpfT91cmw9JHtlbmNvZGVVUklDb21wb25lbnQoc3JjKX0mdz0ke3dpZHRofSZxPSR7cXVhbGl0eSB8fCA3NX1gO1xyXG59XHJcblxyXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xyXG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xyXG59XHJcblxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiSW1hZ2UiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfaGVhZCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfaW1hZ2VDb25maWciLCJfdXNlSW50ZXJzZWN0aW9uIiwiX2ltYWdlQ29uZmlnQ29udGV4dCIsIl91dGlscyIsIl9ub3JtYWxpemVUcmFpbGluZ1NsYXNoIiwiX3BhcmFtIiwic3JjIiwic2l6ZXMiLCJfdW5vcHRpbWl6ZWQiLCJ1bm9wdGltaXplZCIsIl9wcmlvcml0eSIsInByaW9yaXR5IiwibG9hZGluZyIsIl9sYXp5Um9vdCIsImxhenlSb290IiwibGF6eUJvdW5kYXJ5IiwiY2xhc3NOYW1lIiwicXVhbGl0eSIsIndpZHRoIiwiaGVpZ2h0Iiwic3R5bGUiLCJvYmplY3RGaXQiLCJvYmplY3RQb3NpdGlvbiIsIm9uTG9hZGluZ0NvbXBsZXRlIiwiX3BsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXIiLCJibHVyRGF0YVVSTCIsImFsbCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiY29uZmlnQ29udGV4dCIsInVzZUNvbnRleHQiLCJJbWFnZUNvbmZpZ0NvbnRleHQiLCJjb25maWciLCJ1c2VNZW1vIiwiYyIsImNvbmZpZ0VudiIsImltYWdlQ29uZmlnRGVmYXVsdCIsImFsbFNpemVzIiwiX3RvX2NvbnN1bWFibGVfYXJyYXkiLCJkZXZpY2VTaXplcyIsImltYWdlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJfZXh0ZW5kcyIsInJlc3QiLCJsYXlvdXQiLCJsb2FkZXIiLCJkZWZhdWx0SW1hZ2VMb2FkZXIiLCJjdXN0b21JbWFnZUxvYWRlciIsIl90bXAiLCJvYmoiLCJvcHRzIiwic3RhdGljU3JjIiwiaXNTdGF0aWNJbXBvcnQiLCJzdGF0aWNJbWFnZURhdGEiLCJpc1N0YXRpY1JlcXVpcmUiLCJFcnJvciIsImNvbmNhdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ3aWR0aEludCIsImdldEludCIsImhlaWdodEludCIsInF1YWxpdHlJbnQiLCJpc0xhenkiLCJzdGFydHNXaXRoIiwibG9hZGVkSW1hZ2VVUkxzIiwiaGFzIiwiZXhwZXJpbWVudGFsVW5vcHRpbWl6ZWQiLCJyZWYiLCJ1c2VTdGF0ZSIsImJsdXJDb21wbGV0ZSIsInNldEJsdXJDb21wbGV0ZSIsInJlZjEiLCJ1c2VJbnRlcnNlY3Rpb24iLCJyb290UmVmIiwicm9vdE1hcmdpbiIsImRpc2FibGVkIiwic2V0SW50ZXJzZWN0aW9uIiwiaXNJbnRlcnNlY3RlZCIsInJlc2V0SW50ZXJzZWN0ZWQiLCJpc1Zpc2libGUiLCJ3cmFwcGVyU3R5bGUiLCJib3hTaXppbmciLCJkaXNwbGF5Iiwib3ZlcmZsb3ciLCJiYWNrZ3JvdW5kIiwib3BhY2l0eSIsImJvcmRlciIsIm1hcmdpbiIsInBhZGRpbmciLCJzaXplclN0eWxlIiwiaGFzU2l6ZXIiLCJzaXplclN2Z1VybCIsImxheW91dFN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwiYm90dG9tIiwicmlnaHQiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwibWluSGVpZ2h0IiwibWF4SGVpZ2h0IiwicHJvY2VzcyIsIlZBTElEX0xBWU9VVF9WQUxVRVMiLCJpbmNsdWRlcyIsIm1hcCIsIlN0cmluZyIsImpvaW4iLCJpc05hTiIsIndhcm5PbmNlIiwiVkFMSURfTE9BRElOR19WQUxVRVMiLCJWQUxJRF9CTFVSX0VYVCIsInVybFN0ciIsInVybCIsIlVSTCIsImVyciIsInBhdGhuYW1lIiwic2VhcmNoIiwib3ZlcndyaXR0ZW5TdHlsZXMiLCJrZXlzIiwiZmlsdGVyIiwia2V5IiwibGVuZ3RoIiwicGVyZk9ic2VydmVyIiwid2luZG93IiwiUGVyZm9ybWFuY2VPYnNlcnZlciIsImVudHJ5TGlzdCIsIl9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24iLCJfZGlkSXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvckVycm9yIiwiX2l0ZXJhdG9yIiwiZ2V0RW50cmllcyIsIlN5bWJvbCIsIl9zdGVwIiwiZW50cnkiLCJpbWdTcmMiLCJlbGVtZW50IiwibGNwSW1hZ2UiLCJhbGxJbWdzIiwiZ2V0Iiwib2JzZXJ2ZSIsInR5cGUiLCJidWZmZXJlZCIsImNvbnNvbGUiLCJlcnJvciIsImltZ1N0eWxlIiwiYXNzaWduIiwiYmx1clN0eWxlIiwiYmFja2dyb3VuZFNpemUiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJiYWNrZ3JvdW5kSW1hZ2UiLCJxdW90aWVudCIsInBhZGRpbmdUb3AiLCJpbWdBdHRyaWJ1dGVzIiwiZW1wdHlEYXRhVVJMIiwic3JjU2V0IiwidW5kZWZpbmVkIiwiZ2VuZXJhdGVJbWdBdHRycyIsInNyY1N0cmluZyIsImZ1bGxVcmwiLCJlIiwibG9jYXRpb24iLCJocmVmIiwic2V0IiwiaW1hZ2VTcmNTZXRQcm9wTmFtZSIsImltYWdlU2l6ZXNQcm9wTmFtZSIsImVudiIsIl9fTkVYVF9SRUFDVF9ST09UIiwiX29iaiIsImxpbmtQcm9wcyIsIl9kZWZpbmVfcHJvcGVydHkiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJvbkxvYWRpbmdDb21wbGV0ZVJlZiIsInVzZVJlZiIsInByZXZpb3VzSW1hZ2VTcmMiLCJjdXJyZW50IiwiaW1nRWxlbWVudEFyZ3MiLCJub3NjcmlwdFNpemVzIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwiYWx0IiwiSW1hZ2VFbGVtZW50IiwicmVsIiwiYXMiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwic291cmNlIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiV2Vha01hcCIsImNhY2hlIiwibmV3T2JqIiwiaGFzUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVzYyIsImV4Y2x1ZGVkIiwic291cmNlS2V5cyIsImluZGV4T2YiLCJfX05FWFRfSU1BR0VfT1BUUyIsIl9leHBlcmltZW50YWxSZW1vdGVQYXR0ZXJucyIsImV4cGVyaW1lbnRhbFJlbW90ZVBhdHRlcm5zIiwiU2V0IiwiTWFwIiwiZ2xvYmFsIiwiX19ORVhUX0lNQUdFX0lNUE9SVEVEIiwibG9hZGVycyIsImRlZmF1bHRMb2FkZXIiLCJpbWdpeExvYWRlciIsImNsb3VkaW5hcnlMb2FkZXIiLCJha2FtYWlMb2FkZXIiLCJjdXN0b21Mb2FkZXIiLCJpc1N0YXRpY0ltYWdlRGF0YSIsImdldFdpZHRocyIsInBhcmFtIiwidmlld3BvcnRXaWR0aFJlIiwicGVyY2VudFNpemVzIiwibWF0Y2giLCJleGVjIiwicHVzaCIsInBhcnNlSW50IiwiTWF0aCIsInNtYWxsZXN0UmF0aW8iLCJtaW4iLCJ3aWR0aHMiLCJzIiwia2luZCIsInciLCJmaW5kIiwicCIsImxhc3QiLCJ4IiwibG9hZGVyUHJvcHMiLCJsb2FkZXJLZXkiLCJsb2FkIiwiVkFMSURfTE9BREVSUyIsImhhbmRsZUxvYWRpbmciLCJpbWciLCJkZWNvZGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhdGNoIiwidGhlbiIsInBhcmVudE5vZGUiLCJhZGQiLCJuYXR1cmFsV2lkdGgiLCJuYXR1cmFsSGVpZ2h0IiwicGFyZW50RWxlbWVudCIsInBhcmVudCIsImdldENvbXB1dGVkU3R5bGUiLCJvbkxvYWQiLCJvbkVycm9yIiwiZGVjb2RpbmciLCJ1c2VDYWxsYmFjayIsImNvbXBsZXRlIiwiZXZlbnQiLCJjdXJyZW50VGFyZ2V0Iiwibm9ybWFsaXplU3JjIiwic2xpY2UiLCJwYXRoIiwicGFyYW1zIiwic2VhcmNoUGFyYW1zIiwidG9TdHJpbmciLCJwYXJhbXNTdHJpbmciLCJtaXNzaW5nVmFsdWVzIiwiZG9tYWlucyIsInBhcnNlZFNyYyIsImhhc01hdGNoIiwiaG9zdG5hbWUiLCJlbmRzV2l0aCIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJlbmNvZGVVUklDb21wb25lbnQiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/image.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _sliced_to_array = (__webpack_require__(/*! @swc/helpers/lib/_sliced_to_array.js */ \"./node_modules/@swc/helpers/lib/_sliced_to_array.js\")[\"default\"]);\n\nvar _type_of = (__webpack_require__(/*! @swc/helpers/lib/_type_of.js */ \"./node_modules/@swc/helpers/lib/_type_of.js\")[\"default\"]);\n\nvar _s = $RefreshSig$();\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _router = __webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\");\n\nvar _addLocale = __webpack_require__(/*! ./add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\n\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\n\nvar _appRouterContext = __webpack_require__(/*! ../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\n\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\n\nvar _getDomainLocale = __webpack_require__(/*! ./get-domain-locale */ \"./node_modules/next/dist/client/get-domain-locale.js\");\n\nvar _addBasePath = __webpack_require__(/*! ./add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n} // @ts-ignore useTransition exist\n\n\nvar hasUseTransition = typeof _react.default.useTransition !== \"undefined\";\nvar prefetched = {};\n\nfunction prefetch(router, href, as, options) {\n  if ( false || !router) return;\n  if (!(0, _router).isLocalURL(href)) return; // Prefetch the JSON page if asked (only in the client)\n  // We need to handle a prefetch error here since we may be\n  // loading with priority which can reject but we don't\n  // want to force navigation since this is only a prefetch\n\n  router.prefetch(href, as, options).catch(function (err) {\n    if (true) {\n      // rethrow to show invalid URL errors\n      throw err;\n    }\n  });\n  var curLocale = options && typeof options.locale !== \"undefined\" ? options.locale : router && router.locale; // Join on an invalid URI character\n\n  prefetched[href + \"%\" + as + (curLocale ? \"%\" + curLocale : \"\")] = true;\n}\n\nfunction isModifiedEvent(event) {\n  var target = event.currentTarget.target;\n  return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || event.nativeEvent && event.nativeEvent.which === 2;\n}\n\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, startTransition) {\n  var nodeName = e.currentTarget.nodeName; // anchors inside an svg have a lowercase nodeName\n\n  var isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n\n  if (isAnchorNodeName && (isModifiedEvent(e) || !(0, _router).isLocalURL(href))) {\n    // ignore click for browser’s default behavior\n    return;\n  }\n\n  e.preventDefault();\n\n  var navigate = function () {\n    // replace state instead of push if prop is present\n    router[replace ? \"replace\" : \"push\"](href, as, {\n      shallow: shallow,\n      locale: locale,\n      scroll: scroll\n    });\n  };\n\n  if (startTransition) {\n    startTransition(navigate);\n  } else {\n    navigate();\n  }\n}\n\nvar Link = /*#__PURE__*/_s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n  _s();\n\n  if (true) {\n    var createPropError = function createPropError(args) {\n      return new Error(\"Failed prop type: The prop `\".concat(args.key, \"` expects a \").concat(args.expected, \" in `<Link>`, but got `\").concat(args.actual, \"` instead.\") + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0));\n    }; // TypeScript trick for type-guarding:\n\n\n    var requiredPropsGuard = {\n      href: true\n    };\n    var requiredProps = Object.keys(requiredPropsGuard);\n    requiredProps.forEach(function (key) {\n      if (key === \"href\") {\n        if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n          throw createPropError({\n            key: key,\n            expected: \"`string` or `object`\",\n            actual: props[key] === null ? \"null\" : _type_of(props[key])\n          });\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _ = key;\n      }\n    }); // TypeScript trick for type-guarding:\n\n    var optionalPropsGuard = {\n      as: true,\n      replace: true,\n      scroll: true,\n      shallow: true,\n      passHref: true,\n      prefetch: true,\n      locale: true,\n      onClick: true,\n      onMouseEnter: true,\n      legacyBehavior: true\n    };\n    var optionalProps = Object.keys(optionalPropsGuard);\n    optionalProps.forEach(function (key) {\n      var valType = _type_of(props[key]);\n\n      if (key === \"as\") {\n        if (props[key] && valType !== \"string\" && valType !== \"object\") {\n          throw createPropError({\n            key: key,\n            expected: \"`string` or `object`\",\n            actual: valType\n          });\n        }\n      } else if (key === \"locale\") {\n        if (props[key] && valType !== \"string\") {\n          throw createPropError({\n            key: key,\n            expected: \"`string`\",\n            actual: valType\n          });\n        }\n      } else if (key === \"onClick\" || key === \"onMouseEnter\") {\n        if (props[key] && valType !== \"function\") {\n          throw createPropError({\n            key: key,\n            expected: \"`function`\",\n            actual: valType\n          });\n        }\n      } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n        if (props[key] != null && valType !== \"boolean\") {\n          throw createPropError({\n            key: key,\n            expected: \"`boolean`\",\n            actual: valType\n          });\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _ = key;\n      }\n    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n\n    var hasWarned = _react.default.useRef(false);\n\n    if (props.prefetch && !hasWarned.current) {\n      hasWarned.current = true;\n      console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n    }\n  }\n\n  var children;\n\n  var hrefProp = props.href,\n      asProp = props.as,\n      childrenProp = props.children,\n      prefetchProp = props.prefetch,\n      passHref = props.passHref,\n      replace = props.replace,\n      shallow = props.shallow,\n      scroll = props.scroll,\n      locale = props.locale,\n      onClick = props.onClick,\n      onMouseEnter = props.onMouseEnter,\n      _legacyBehavior = props.legacyBehavior,\n      legacyBehavior = _legacyBehavior === void 0 ? Boolean(false) !== true : _legacyBehavior,\n      restProps = _objectWithoutPropertiesLoose(props, [\"href\", \"as\", \"children\", \"prefetch\", \"passHref\", \"replace\", \"shallow\", \"scroll\", \"locale\", \"onClick\", \"onMouseEnter\", \"legacyBehavior\"]);\n\n  children = childrenProp;\n\n  if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n    children = /*#__PURE__*/_react.default.createElement(\"a\", null, children);\n  }\n\n  var p = prefetchProp !== false;\n\n  var ref = _sliced_to_array(hasUseTransition ? // @ts-ignore useTransition exists\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  _react.default.useTransition() : [], 2),\n\n  /* isPending */\n  startTransition = ref[1];\n\n  var router = _react.default.useContext(_routerContext.RouterContext);\n\n  var appRouter = _react.default.useContext(_appRouterContext.AppRouterContext);\n\n  if (appRouter) {\n    router = appRouter;\n  }\n\n  var ref1 = _react.default.useMemo(function () {\n    var ref = _sliced_to_array((0, _router).resolveHref(router, hrefProp, true), 2),\n        resolvedHref = ref[0],\n        resolvedAs = ref[1];\n\n    return {\n      href: resolvedHref,\n      as: asProp ? (0, _router).resolveHref(router, asProp) : resolvedAs || resolvedHref\n    };\n  }, [router, hrefProp, asProp]),\n      href = ref1.href,\n      as = ref1.as;\n\n  var previousHref = _react.default.useRef(href);\n\n  var previousAs = _react.default.useRef(as); // This will return the first child, if multiple are provided it will throw an error\n\n\n  var child;\n\n  if (legacyBehavior) {\n    if (true) {\n      if (onClick) {\n        console.warn('\"onClick\" was passed to <Link> with `href` of `'.concat(hrefProp, '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link'));\n      }\n\n      if (onMouseEnter) {\n        console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `'.concat(hrefProp, '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link'));\n      }\n\n      try {\n        child = _react.default.Children.only(children);\n      } catch (err) {\n        if (!children) {\n          throw new Error(\"No children were passed to <Link> with `href` of `\".concat(hrefProp, \"` but one child is required https://nextjs.org/docs/messages/link-no-children\"));\n        }\n\n        throw new Error(\"Multiple children were passed to <Link> with `href` of `\".concat(hrefProp, \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\") + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0));\n      }\n    } else {}\n  }\n\n  var childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n\n  var ref2 = _sliced_to_array((0, _useIntersection).useIntersection({\n    rootMargin: \"200px\"\n  }), 3),\n      setIntersectionRef = ref2[0],\n      isVisible = ref2[1],\n      resetVisible = ref2[2];\n\n  var setRef = _react.default.useCallback(function (el) {\n    // Before the link getting observed, check if visible state need to be reset\n    if (previousAs.current !== as || previousHref.current !== href) {\n      resetVisible();\n      previousAs.current = as;\n      previousHref.current = href;\n    }\n\n    setIntersectionRef(el);\n\n    if (childRef) {\n      if (typeof childRef === \"function\") childRef(el);else if (typeof childRef === \"object\") {\n        childRef.current = el;\n      }\n    }\n  }, [as, childRef, href, resetVisible, setIntersectionRef]);\n\n  _react.default.useEffect(function () {\n    var shouldPrefetch = isVisible && p && (0, _router).isLocalURL(href);\n    var curLocale = typeof locale !== \"undefined\" ? locale : router && router.locale;\n    var isPrefetched = prefetched[href + \"%\" + as + (curLocale ? \"%\" + curLocale : \"\")];\n\n    if (shouldPrefetch && !isPrefetched) {\n      prefetch(router, href, as, {\n        locale: curLocale\n      });\n    }\n  }, [as, href, isVisible, locale, p, router]);\n\n  var childProps = {\n    ref: setRef,\n    onClick: function (e) {\n      if (true) {\n        if (!e) {\n          throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n        }\n      }\n\n      if (!legacyBehavior && typeof onClick === \"function\") {\n        onClick(e);\n      }\n\n      if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n        child.props.onClick(e);\n      }\n\n      if (!e.defaultPrevented) {\n        linkClicked(e, router, href, as, replace, shallow, scroll, locale, appRouter ? startTransition : undefined);\n      }\n    },\n    onMouseEnter: function (e) {\n      if (!legacyBehavior && typeof onMouseEnter === \"function\") {\n        onMouseEnter(e);\n      }\n\n      if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n        child.props.onMouseEnter(e);\n      }\n\n      if ((0, _router).isLocalURL(href)) {\n        prefetch(router, href, as, {\n          priority: true\n        });\n      }\n    }\n  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n  // defined, we specify the current 'href', so that repetition is not needed by the user\n\n  if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n    var curLocale = typeof locale !== \"undefined\" ? locale : router && router.locale; // we only render domain locales if we are currently on a domain locale\n    // so that locale links are still visitable in development/preview envs\n\n    var localeDomain = router && router.isLocaleDomain && (0, _getDomainLocale).getDomainLocale(as, curLocale, router.locales, router.domainLocales);\n    childProps.href = localeDomain || (0, _addBasePath).addBasePath((0, _addLocale).addLocale(as, curLocale, router && router.defaultLocale));\n  }\n\n  return legacyBehavior ? /*#__PURE__*/_react.default.cloneElement(child, childProps) : /*#__PURE__*/_react.default.createElement(\"a\", Object.assign({}, restProps, childProps), children);\n}, \"BtO78wD/8ZHkXeJW04HXE0IXA8Y=\")), \"BtO78wD/8ZHkXeJW04HXE0IXA8Y=\");\n\n_c1 = Link;\nvar _default = Link;\nexports[\"default\"] = _default;\n\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n  Object.defineProperty(exports.default, \"__esModule\", {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\n\n\nvar _c, _c1;\n\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOzs7Ozs7OztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3Q0gsRUFBQUE7QUFHQUUsa0JBQUFBLEdBQWtCLEtBQUssQ0FBdkJBOztBQUNBLElBQUlHLE1BQU0sR0FBR0Msc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsNENBQUQsQ0FBUixDQUFuQzs7QUFDQSxJQUFJQyxPQUFPLEdBQUdELG1CQUFPLENBQUMseUZBQUQsQ0FBckI7O0FBQ0EsSUFBSUUsVUFBVSxHQUFHRixtQkFBTyxDQUFDLG1FQUFELENBQXhCOztBQUNBLElBQUlHLGNBQWMsR0FBR0gsbUJBQU8sQ0FBQywyRkFBRCxDQUE1Qjs7QUFDQSxJQUFJSSxpQkFBaUIsR0FBR0osbUJBQU8sQ0FBQyxtR0FBRCxDQUEvQjs7QUFDQSxJQUFJSyxnQkFBZ0IsR0FBR0wsbUJBQU8sQ0FBQywrRUFBRCxDQUE5Qjs7QUFDQSxJQUFJTSxnQkFBZ0IsR0FBR04sbUJBQU8sQ0FBQyxpRkFBRCxDQUE5Qjs7QUFDQSxJQUFJTyxZQUFZLEdBQUdQLG1CQUFPLENBQUMseUVBQUQsQ0FBMUI7O0FBQ0EsU0FBU0Qsc0JBQVQsQ0FBZ0NTLEdBQWhDLEVBQXFDO0VBQ2pDLE9BQU9BLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFYRCxHQUF3QkEsR0FBeEJBLEdBQThCO0lBQ2pDWCxPQUFPLEVBQUVXO0VBRHdCLENBQXJDO0FBR0g7O0FBQ0QsU0FBU0UsNkJBQVQsQ0FBdUNDLE1BQXZDLEVBQStDQyxRQUEvQyxFQUF5RDtFQUNyRCxJQUFJRCxNQUFNLElBQUksSUFBZCxFQUFvQixPQUFPLEVBQVA7RUFDcEIsSUFBSUUsTUFBTSxHQUFHLEVBQWI7RUFDQSxJQUFJQyxVQUFVLEdBQUdyQixNQUFNLENBQUNzQixJQUFQdEIsQ0FBWWtCLE1BQVpsQixDQUFqQjtFQUNBLElBQUl1QixHQUFKLEVBQVNDLENB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QU8sQ0FBQ0UsT0FBekI2STtBQUNELEMsQ0FFRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzP2U0ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gICAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9yb3V0ZXIgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyXCIpO1xyXG52YXIgX2FkZExvY2FsZSA9IHJlcXVpcmUoXCIuL2FkZC1sb2NhbGVcIik7XHJcbnZhciBfcm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0XCIpO1xyXG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XHJcbnZhciBfdXNlSW50ZXJzZWN0aW9uID0gcmVxdWlyZShcIi4vdXNlLWludGVyc2VjdGlvblwiKTtcclxudmFyIF9nZXREb21haW5Mb2NhbGUgPSByZXF1aXJlKFwiLi9nZXQtZG9tYWluLWxvY2FsZVwiKTtcclxudmFyIF9hZGRCYXNlUGF0aCA9IHJlcXVpcmUoXCIuL2FkZC1iYXNlLXBhdGhcIik7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xyXG4gICAgICAgIGRlZmF1bHQ6IG9ialxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XHJcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcclxuICAgIHZhciB0YXJnZXQgPSB7fTtcclxuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcclxuICAgIHZhciBrZXksIGk7XHJcbiAgICBmb3IoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xyXG4gICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XHJcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuLy8gQHRzLWlnbm9yZSB1c2VUcmFuc2l0aW9uIGV4aXN0XHJcbmNvbnN0IGhhc1VzZVRyYW5zaXRpb24gPSB0eXBlb2YgX3JlYWN0LmRlZmF1bHQudXNlVHJhbnNpdGlvbiAhPT0gJ3VuZGVmaW5lZCc7XHJcbmNvbnN0IHByZWZldGNoZWQgPSB7fTtcclxuZnVuY3Rpb24gcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywgb3B0aW9ucykge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFyb3V0ZXIpIHJldHVybjtcclxuICAgIGlmICghKDAsIF9yb3V0ZXIpLmlzTG9jYWxVUkwoaHJlZikpIHJldHVybjtcclxuICAgIC8vIFByZWZldGNoIHRoZSBKU09OIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcclxuICAgIC8vIFdlIG5lZWQgdG8gaGFuZGxlIGEgcHJlZmV0Y2ggZXJyb3IgaGVyZSBzaW5jZSB3ZSBtYXkgYmVcclxuICAgIC8vIGxvYWRpbmcgd2l0aCBwcmlvcml0eSB3aGljaCBjYW4gcmVqZWN0IGJ1dCB3ZSBkb24ndFxyXG4gICAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXHJcbiAgICByb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXMsIG9wdGlvbnMpLmNhdGNoKChlcnIpPT57XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBjdXJMb2NhbGUgPSBvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmxvY2FsZSA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlO1xyXG4gICAgLy8gSm9pbiBvbiBhbiBpbnZhbGlkIFVSSSBjaGFyYWN0ZXJcclxuICAgIHByZWZldGNoZWRbaHJlZiArICclJyArIGFzICsgKGN1ckxvY2FsZSA/ICclJyArIGN1ckxvY2FsZSA6ICcnKV0gPSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xyXG4gICAgY29uc3QgeyB0YXJnZXQgIH0gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xyXG4gICAgcmV0dXJuIHRhcmdldCAmJiB0YXJnZXQgIT09ICdfc2VsZicgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5uYXRpdmVFdmVudCAmJiBldmVudC5uYXRpdmVFdmVudC53aGljaCA9PT0gMjtcclxufVxyXG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSwgc3RhcnRUcmFuc2l0aW9uKSB7XHJcbiAgICBjb25zdCB7IG5vZGVOYW1lICB9ID0gZS5jdXJyZW50VGFyZ2V0O1xyXG4gICAgLy8gYW5jaG9ycyBpbnNpZGUgYW4gc3ZnIGhhdmUgYSBsb3dlcmNhc2Ugbm9kZU5hbWVcclxuICAgIGNvbnN0IGlzQW5jaG9yTm9kZU5hbWUgPSBub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQSc7XHJcbiAgICBpZiAoaXNBbmNob3JOb2RlTmFtZSAmJiAoaXNNb2RpZmllZEV2ZW50KGUpIHx8ICEoMCwgX3JvdXRlcikuaXNMb2NhbFVSTChocmVmKSkpIHtcclxuICAgICAgICAvLyBpZ25vcmUgY2xpY2sgZm9yIGJyb3dzZXLigJlzIGRlZmF1bHQgYmVoYXZpb3JcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBjb25zdCBuYXZpZ2F0ZSA9ICgpPT57XHJcbiAgICAgICAgLy8gcmVwbGFjZSBzdGF0ZSBpbnN0ZWFkIG9mIHB1c2ggaWYgcHJvcCBpcyBwcmVzZW50XHJcbiAgICAgICAgcm91dGVyW3JlcGxhY2UgPyAncmVwbGFjZScgOiAncHVzaCddKGhyZWYsIGFzLCB7XHJcbiAgICAgICAgICAgIHNoYWxsb3csXHJcbiAgICAgICAgICAgIGxvY2FsZSxcclxuICAgICAgICAgICAgc2Nyb2xsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgaWYgKHN0YXJ0VHJhbnNpdGlvbikge1xyXG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbihuYXZpZ2F0ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5hdmlnYXRlKCk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgTGluayA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuZm9yd2FyZFJlZihmdW5jdGlvbiBMaW5rQ29tcG9uZW50KHByb3BzLCBmb3J3YXJkZWRSZWYpIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUHJvcEVycm9yKGFyZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgRmFpbGVkIHByb3AgdHlwZTogVGhlIHByb3AgXFxgJHthcmdzLmtleX1cXGAgZXhwZWN0cyBhICR7YXJncy5leHBlY3RlZH0gaW4gXFxgPExpbms+XFxgLCBidXQgZ290IFxcYCR7YXJncy5hY3R1YWx9XFxgIGluc3RlYWQuYCArICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFwiXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIiA6ICcnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XHJcbiAgICAgICAgY29uc3QgcmVxdWlyZWRQcm9wc0d1YXJkID0ge1xyXG4gICAgICAgICAgICBocmVmOiB0cnVlXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZXF1aXJlZFByb3BzID0gT2JqZWN0LmtleXMocmVxdWlyZWRQcm9wc0d1YXJkKTtcclxuICAgICAgICByZXF1aXJlZFByb3BzLmZvckVhY2goKGtleSk9PntcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wc1trZXldICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHByb3BzW2tleV0gPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcHJvcHNba2V5XVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcclxuICAgICAgICAgICAgICAgIGNvbnN0IF8gPSBrZXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxyXG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHNHdWFyZCA9IHtcclxuICAgICAgICAgICAgYXM6IHRydWUsXHJcbiAgICAgICAgICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICAgICAgICAgIHNjcm9sbDogdHJ1ZSxcclxuICAgICAgICAgICAgc2hhbGxvdzogdHJ1ZSxcclxuICAgICAgICAgICAgcGFzc0hyZWY6IHRydWUsXHJcbiAgICAgICAgICAgIHByZWZldGNoOiB0cnVlLFxyXG4gICAgICAgICAgICBsb2NhbGU6IHRydWUsXHJcbiAgICAgICAgICAgIG9uQ2xpY2s6IHRydWUsXHJcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcjogdHJ1ZSxcclxuICAgICAgICAgICAgbGVnYWN5QmVoYXZpb3I6IHRydWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSBPYmplY3Qua2V5cyhvcHRpb25hbFByb3BzR3VhcmQpO1xyXG4gICAgICAgIG9wdGlvbmFsUHJvcHMuZm9yRWFjaCgoa2V5KT0+e1xyXG4gICAgICAgICAgICBjb25zdCB2YWxUeXBlID0gdHlwZW9mIHByb3BzW2tleV07XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdhcycpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09ICdzdHJpbmcnICYmIHZhbFR5cGUgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnbG9jYWxlJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2AnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdvbkNsaWNrJyB8fCBrZXkgPT09ICdvbk1vdXNlRW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2BmdW5jdGlvbmAnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdyZXBsYWNlJyB8fCBrZXkgPT09ICdzY3JvbGwnIHx8IGtleSA9PT0gJ3NoYWxsb3cnIHx8IGtleSA9PT0gJ3Bhc3NIcmVmJyB8fCBrZXkgPT09ICdwcmVmZXRjaCcgfHwga2V5ID09PSAnbGVnYWN5QmVoYXZpb3InKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAhPSBudWxsICYmIHZhbFR5cGUgIT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgYm9vbGVhbmAnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBfID0ga2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcclxuICAgICAgICBjb25zdCBoYXNXYXJuZWQgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoZmFsc2UpO1xyXG4gICAgICAgIGlmIChwcm9wcy5wcmVmZXRjaCAmJiAhaGFzV2FybmVkLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgaGFzV2FybmVkLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05leHQuanMgYXV0by1wcmVmZXRjaGVzIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdmlld3BvcnQuIFRoZSBwcmVmZXRjaCBhdHRyaWJ1dGUgaXMgbm8gbG9uZ2VyIG5lZWRlZC4gTW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcHJlZmV0Y2gtdHJ1ZS1kZXByZWNhdGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IGNoaWxkcmVuO1xyXG4gICAgY29uc3QgeyBocmVmOiBocmVmUHJvcCAsIGFzOiBhc1Byb3AgLCBjaGlsZHJlbjogY2hpbGRyZW5Qcm9wICwgcHJlZmV0Y2g6IHByZWZldGNoUHJvcCAsIHBhc3NIcmVmICwgcmVwbGFjZSAsIHNoYWxsb3cgLCBzY3JvbGwgLCBsb2NhbGUgLCBvbkNsaWNrICwgb25Nb3VzZUVudGVyICwgbGVnYWN5QmVoYXZpb3IgPUJvb2xlYW4ocHJvY2Vzcy5lbnYuX19ORVhUX05FV19MSU5LX0JFSEFWSU9SKSAhPT0gdHJ1ZSAgfSA9IHByb3BzLCByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgW1xyXG4gICAgICAgIFwiaHJlZlwiLFxyXG4gICAgICAgIFwiYXNcIixcclxuICAgICAgICBcImNoaWxkcmVuXCIsXHJcbiAgICAgICAgXCJwcmVmZXRjaFwiLFxyXG4gICAgICAgIFwicGFzc0hyZWZcIixcclxuICAgICAgICBcInJlcGxhY2VcIixcclxuICAgICAgICBcInNoYWxsb3dcIixcclxuICAgICAgICBcInNjcm9sbFwiLFxyXG4gICAgICAgIFwibG9jYWxlXCIsXHJcbiAgICAgICAgXCJvbkNsaWNrXCIsXHJcbiAgICAgICAgXCJvbk1vdXNlRW50ZXJcIixcclxuICAgICAgICBcImxlZ2FjeUJlaGF2aW9yXCJcclxuICAgIF0pO1xyXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlblByb3A7XHJcbiAgICBpZiAobGVnYWN5QmVoYXZpb3IgJiYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkcmVuID09PSAnbnVtYmVyJykpIHtcclxuICAgICAgICBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwgbnVsbCwgY2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcCA9IHByZWZldGNoUHJvcCAhPT0gZmFsc2U7XHJcbiAgICBjb25zdCBbLCAvKiBpc1BlbmRpbmcgKi8gc3RhcnRUcmFuc2l0aW9uXSA9IGhhc1VzZVRyYW5zaXRpb24gPyAvLyBUaGVyZSBpcyBubyBkaWZmZXJlbmNlIGJldHdlZW4gcmVuZGVycyBpbiB0aGlzIGNhc2UsIG9ubHkgYmV0d2VlbiB1c2luZyBSZWFjdCAxOCB2cyAxNy5cclxuICAgIC8vIEB0cy1pZ25vcmUgdXNlVHJhbnNpdGlvbiBleGlzdHNcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xyXG4gICAgX3JlYWN0LmRlZmF1bHQudXNlVHJhbnNpdGlvbigpIDogW107XHJcbiAgICBsZXQgcm91dGVyID0gX3JlYWN0LmRlZmF1bHQudXNlQ29udGV4dChfcm91dGVyQ29udGV4dC5Sb3V0ZXJDb250ZXh0KTtcclxuICAgIGNvbnN0IGFwcFJvdXRlciA9IF9yZWFjdC5kZWZhdWx0LnVzZUNvbnRleHQoX2FwcFJvdXRlckNvbnRleHQuQXBwUm91dGVyQ29udGV4dCk7XHJcbiAgICBpZiAoYXBwUm91dGVyKSB7XHJcbiAgICAgICAgcm91dGVyID0gYXBwUm91dGVyO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBocmVmICwgYXMgIH0gPSBfcmVhY3QuZGVmYXVsdC51c2VNZW1vKCgpPT57XHJcbiAgICAgICAgY29uc3QgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSAoMCwgX3JvdXRlcikucmVzb2x2ZUhyZWYocm91dGVyLCBocmVmUHJvcCwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaHJlZjogcmVzb2x2ZWRIcmVmLFxyXG4gICAgICAgICAgICBhczogYXNQcm9wID8gKDAsIF9yb3V0ZXIpLnJlc29sdmVIcmVmKHJvdXRlciwgYXNQcm9wKSA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmXHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtcclxuICAgICAgICByb3V0ZXIsXHJcbiAgICAgICAgaHJlZlByb3AsXHJcbiAgICAgICAgYXNQcm9wXHJcbiAgICBdKTtcclxuICAgIGNvbnN0IHByZXZpb3VzSHJlZiA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihocmVmKTtcclxuICAgIGNvbnN0IHByZXZpb3VzQXMgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoYXMpO1xyXG4gICAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXHJcbiAgICBsZXQgY2hpbGQ7XHJcbiAgICBpZiAobGVnYWN5QmVoYXZpb3IpIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcclxuICAgICAgICAgICAgaWYgKG9uQ2xpY2spIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgXCJvbkNsaWNrXCIgd2FzIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBcImxlZ2FjeUJlaGF2aW9yXCIgd2FzIHNldC4gVGhlIGxlZ2FjeSBiZWhhdmlvciByZXF1aXJlcyBvbkNsaWNrIGJlIHNldCBvbiB0aGUgY2hpbGQgb2YgbmV4dC9saW5rYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9uTW91c2VFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBcIm9uTW91c2VFbnRlclwiIHdhcyBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgXCJsZWdhY3lCZWhhdmlvclwiIHdhcyBzZXQuIFRoZSBsZWdhY3kgYmVoYXZpb3IgcmVxdWlyZXMgb25Nb3VzZUVudGVyIGJlIHNldCBvbiB0aGUgY2hpbGQgb2YgbmV4dC9saW5rYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgb25lIGNoaWxkIGlzIHJlcXVpcmVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbm8tY2hpbGRyZW5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwbGUgY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgb25seSBvbmUgY2hpbGQgaXMgc3VwcG9ydGVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbXVsdGlwbGUtY2hpbGRyZW5gICsgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gXCIgXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIiA6ICcnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaGlsZCA9IF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGNoaWxkUmVmID0gbGVnYWN5QmVoYXZpb3IgPyBjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkLnJlZiA6IGZvcndhcmRlZFJlZjtcclxuICAgIGNvbnN0IFtzZXRJbnRlcnNlY3Rpb25SZWYsIGlzVmlzaWJsZSwgcmVzZXRWaXNpYmxlXSA9ICgwLCBfdXNlSW50ZXJzZWN0aW9uKS51c2VJbnRlcnNlY3Rpb24oe1xyXG4gICAgICAgIHJvb3RNYXJnaW46ICcyMDBweCdcclxuICAgIH0pO1xyXG4gICAgY29uc3Qgc2V0UmVmID0gX3JlYWN0LmRlZmF1bHQudXNlQ2FsbGJhY2soKGVsKT0+e1xyXG4gICAgICAgIC8vIEJlZm9yZSB0aGUgbGluayBnZXR0aW5nIG9ic2VydmVkLCBjaGVjayBpZiB2aXNpYmxlIHN0YXRlIG5lZWQgdG8gYmUgcmVzZXRcclxuICAgICAgICBpZiAocHJldmlvdXNBcy5jdXJyZW50ICE9PSBhcyB8fCBwcmV2aW91c0hyZWYuY3VycmVudCAhPT0gaHJlZikge1xyXG4gICAgICAgICAgICByZXNldFZpc2libGUoKTtcclxuICAgICAgICAgICAgcHJldmlvdXNBcy5jdXJyZW50ID0gYXM7XHJcbiAgICAgICAgICAgIHByZXZpb3VzSHJlZi5jdXJyZW50ID0gaHJlZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0SW50ZXJzZWN0aW9uUmVmKGVsKTtcclxuICAgICAgICBpZiAoY2hpbGRSZWYpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gJ2Z1bmN0aW9uJykgY2hpbGRSZWYoZWwpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZFJlZi5jdXJyZW50ID0gZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbXHJcbiAgICAgICAgYXMsXHJcbiAgICAgICAgY2hpbGRSZWYsXHJcbiAgICAgICAgaHJlZixcclxuICAgICAgICByZXNldFZpc2libGUsXHJcbiAgICAgICAgc2V0SW50ZXJzZWN0aW9uUmVmXHJcbiAgICBdKTtcclxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xyXG4gICAgICAgIGNvbnN0IHNob3VsZFByZWZldGNoID0gaXNWaXNpYmxlICYmIHAgJiYgKDAsIF9yb3V0ZXIpLmlzTG9jYWxVUkwoaHJlZik7XHJcbiAgICAgICAgY29uc3QgY3VyTG9jYWxlID0gdHlwZW9mIGxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhbGUgOiByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZTtcclxuICAgICAgICBjb25zdCBpc1ByZWZldGNoZWQgPSBwcmVmZXRjaGVkW2hyZWYgKyAnJScgKyBhcyArIChjdXJMb2NhbGUgPyAnJScgKyBjdXJMb2NhbGUgOiAnJyldO1xyXG4gICAgICAgIGlmIChzaG91bGRQcmVmZXRjaCAmJiAhaXNQcmVmZXRjaGVkKSB7XHJcbiAgICAgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZTogY3VyTG9jYWxlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtcclxuICAgICAgICBhcyxcclxuICAgICAgICBocmVmLFxyXG4gICAgICAgIGlzVmlzaWJsZSxcclxuICAgICAgICBsb2NhbGUsXHJcbiAgICAgICAgcCxcclxuICAgICAgICByb3V0ZXJcclxuICAgIF0pO1xyXG4gICAgY29uc3QgY2hpbGRQcm9wcyA9IHtcclxuICAgICAgICByZWY6IHNldFJlZixcclxuICAgICAgICBvbkNsaWNrOiAoZSk9PntcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9uZW50IHJlbmRlcmVkIGluc2lkZSBuZXh0L2xpbmsgaGFzIHRvIHBhc3MgY2xpY2sgZXZlbnQgdG8gXCJvbkNsaWNrXCIgcHJvcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWUuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgICAgICAgICAgbGlua0NsaWNrZWQoZSwgcm91dGVyLCBocmVmLCBhcywgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUsIGFwcFJvdXRlciA/IHN0YXJ0VHJhbnNpdGlvbiA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uTW91c2VFbnRlcjogKGUpPT57XHJcbiAgICAgICAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uTW91c2VFbnRlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCgwLCBfcm91dGVyKS5pc0xvY2FsVVJMKGhyZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIElmIGNoaWxkIGlzIGFuIDxhPiB0YWcgYW5kIGRvZXNuJ3QgaGF2ZSBhIGhyZWYgYXR0cmlidXRlLCBvciBpZiB0aGUgJ3Bhc3NIcmVmJyBwcm9wZXJ0eSBpc1xyXG4gICAgLy8gZGVmaW5lZCwgd2Ugc3BlY2lmeSB0aGUgY3VycmVudCAnaHJlZicsIHNvIHRoYXQgcmVwZXRpdGlvbiBpcyBub3QgbmVlZGVkIGJ5IHRoZSB1c2VyXHJcbiAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yIHx8IHBhc3NIcmVmIHx8IGNoaWxkLnR5cGUgPT09ICdhJyAmJiAhKCdocmVmJyBpbiBjaGlsZC5wcm9wcykpIHtcclxuICAgICAgICBjb25zdCBjdXJMb2NhbGUgPSB0eXBlb2YgbG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IGxvY2FsZSA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlO1xyXG4gICAgICAgIC8vIHdlIG9ubHkgcmVuZGVyIGRvbWFpbiBsb2NhbGVzIGlmIHdlIGFyZSBjdXJyZW50bHkgb24gYSBkb21haW4gbG9jYWxlXHJcbiAgICAgICAgLy8gc28gdGhhdCBsb2NhbGUgbGlua3MgYXJlIHN0aWxsIHZpc2l0YWJsZSBpbiBkZXZlbG9wbWVudC9wcmV2aWV3IGVudnNcclxuICAgICAgICBjb25zdCBsb2NhbGVEb21haW4gPSByb3V0ZXIgJiYgcm91dGVyLmlzTG9jYWxlRG9tYWluICYmICgwLCBfZ2V0RG9tYWluTG9jYWxlKS5nZXREb21haW5Mb2NhbGUoYXMsIGN1ckxvY2FsZSwgcm91dGVyLmxvY2FsZXMsIHJvdXRlci5kb21haW5Mb2NhbGVzKTtcclxuICAgICAgICBjaGlsZFByb3BzLmhyZWYgPSBsb2NhbGVEb21haW4gfHwgKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShhcywgY3VyTG9jYWxlLCByb3V0ZXIgJiYgcm91dGVyLmRlZmF1bHRMb2NhbGUpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsZWdhY3lCZWhhdmlvciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwgT2JqZWN0LmFzc2lnbih7fSwgcmVzdFByb3BzLCBjaGlsZFByb3BzKSwgY2hpbGRyZW4pO1xyXG59KTtcclxudmFyIF9kZWZhdWx0ID0gTGluaztcclxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XHJcblxyXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xyXG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xyXG59XHJcblxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9yb3V0ZXIiLCJfYWRkTG9jYWxlIiwiX3JvdXRlckNvbnRleHQiLCJfYXBwUm91dGVyQ29udGV4dCIsIl91c2VJbnRlcnNlY3Rpb24iLCJfZ2V0RG9tYWluTG9jYWxlIiwiX2FkZEJhc2VQYXRoIiwib2JqIiwiX19lc01vZHVsZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlIiwiZXhjbHVkZWQiLCJ0YXJnZXQiLCJzb3VyY2VLZXlzIiwia2V5cyIsImtleSIsImkiLCJsZW5ndGgiLCJpbmRleE9mIiwiaGFzVXNlVHJhbnNpdGlvbiIsInVzZVRyYW5zaXRpb24iLCJwcmVmZXRjaGVkIiwicHJlZmV0Y2giLCJyb3V0ZXIiLCJocmVmIiwiYXMiLCJvcHRpb25zIiwiaXNMb2NhbFVSTCIsImNhdGNoIiwiZXJyIiwicHJvY2VzcyIsImN1ckxvY2FsZSIsImxvY2FsZSIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwiY3VycmVudFRhcmdldCIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwicmVwbGFjZSIsInNoYWxsb3ciLCJzY3JvbGwiLCJzdGFydFRyYW5zaXRpb24iLCJub2RlTmFtZSIsImlzQW5jaG9yTm9kZU5hbWUiLCJ0b1VwcGVyQ2FzZSIsInByZXZlbnREZWZhdWx0IiwibmF2aWdhdGUiLCJMaW5rIiwiZm9yd2FyZFJlZiIsIl9jIiwiTGlua0NvbXBvbmVudCIsInByb3BzIiwiZm9yd2FyZGVkUmVmIiwiY3JlYXRlUHJvcEVycm9yIiwiYXJncyIsIkVycm9yIiwiZXhwZWN0ZWQiLCJjb25jYXQiLCJhY3R1YWwiLCJyZXF1aXJlZFByb3BzR3VhcmQiLCJyZXF1aXJlZFByb3BzIiwiZm9yRWFjaCIsIl90eXBlX29mIiwiXyIsIm9wdGlvbmFsUHJvcHNHdWFyZCIsInBhc3NIcmVmIiwib25DbGljayIsIm9uTW91c2VFbnRlciIsImxlZ2FjeUJlaGF2aW9yIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJoYXNXYXJuZWQiLCJ1c2VSZWYiLCJjdXJyZW50IiwiY29uc29sZSIsIndhcm4iLCJjaGlsZHJlbiIsIl9sZWdhY3lCZWhhdmlvciIsIkJvb2xlYW4iLCJlbnYiLCJfX05FWFRfTkVXX0xJTktfQkVIQVZJT1IiLCJyZXN0UHJvcHMiLCJjaGlsZHJlblByb3AiLCJjcmVhdGVFbGVtZW50IiwicCIsInByZWZldGNoUHJvcCIsInVzZUNvbnRleHQiLCJSb3V0ZXJDb250ZXh0IiwiYXBwUm91dGVyIiwiQXBwUm91dGVyQ29udGV4dCIsInVzZU1lbW8iLCJyZWYiLCJyZXNvbHZlSHJlZiIsImhyZWZQcm9wIiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZWRBcyIsImFzUHJvcCIsInByZXZpb3VzSHJlZiIsInByZXZpb3VzQXMiLCJjaGlsZCIsIkNoaWxkcmVuIiwib25seSIsImNoaWxkUmVmIiwicmVmMiIsInVzZUludGVyc2VjdGlvbiIsInJvb3RNYXJnaW4iLCJzZXRJbnRlcnNlY3Rpb25SZWYiLCJpc1Zpc2libGUiLCJyZXNldFZpc2libGUiLCJzZXRSZWYiLCJ1c2VDYWxsYmFjayIsImVsIiwidXNlRWZmZWN0Iiwic2hvdWxkUHJlZmV0Y2giLCJpc1ByZWZldGNoZWQiLCJjaGlsZFByb3BzIiwiZGVmYXVsdFByZXZlbnRlZCIsInVuZGVmaW5lZCIsInByaW9yaXR5IiwidHlwZSIsImxvY2FsZURvbWFpbiIsImlzTG9jYWxlRG9tYWluIiwiZ2V0RG9tYWluTG9jYWxlIiwibG9jYWxlcyIsImRvbWFpbkxvY2FsZXMiLCJhZGRCYXNlUGF0aCIsImFkZExvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJjbG9uZUVsZW1lbnQiLCJhc3NpZ24iLCJfZGVmYXVsdCIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _sliced_to_array = (__webpack_require__(/*! @swc/helpers/lib/_sliced_to_array.js */ \"./node_modules/@swc/helpers/lib/_sliced_to_array.js\")[\"default\"]);\n\nvar _s = $RefreshSig$();\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.useIntersection = useIntersection;\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\n\nvar hasIntersectionObserver = typeof IntersectionObserver === \"function\";\n\nfunction useIntersection(param) {\n  var rootRef = param.rootRef,\n      rootMargin = param.rootMargin,\n      disabled = param.disabled;\n\n  _s();\n\n  var isDisabled = disabled || !hasIntersectionObserver;\n  var unobserve = (0, _react).useRef();\n\n  var ref = _sliced_to_array((0, _react).useState(false), 2),\n      visible = ref[0],\n      setVisible = ref[1];\n\n  var ref1 = _sliced_to_array((0, _react).useState(null), 2),\n      element = ref1[0],\n      setElement = ref1[1];\n\n  (0, _react).useEffect(function () {\n    if (hasIntersectionObserver) {\n      if (unobserve.current) {\n        unobserve.current();\n        unobserve.current = undefined;\n      }\n\n      if (isDisabled || visible) return;\n\n      if (element && element.tagName) {\n        unobserve.current = observe(element, function (isVisible) {\n          return isVisible && setVisible(isVisible);\n        }, {\n          root: rootRef == null ? void 0 : rootRef.current,\n          rootMargin: rootMargin\n        });\n      }\n\n      return function () {\n        unobserve.current == null ? void 0 : unobserve.current();\n        unobserve.current = undefined;\n      };\n    } else {\n      if (!visible) {\n        var idleCallback = (0, _requestIdleCallback).requestIdleCallback(function () {\n          return setVisible(true);\n        });\n        return function () {\n          return (0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n        };\n      }\n    }\n  }, [element, isDisabled, rootMargin, rootRef, visible]);\n  var resetVisible = (0, _react).useCallback(function () {\n    setVisible(false);\n  }, []);\n  return [setElement, visible, resetVisible];\n}\n\n_s(useIntersection, \"Ftx7DdZ+Ab721MTRqq19v5g/6/E=\");\n\nfunction observe(element, callback, options) {\n  var ref = createObserver(options),\n      id = ref.id,\n      observer = ref.observer,\n      elements = ref.elements;\n  elements.set(element, callback);\n  observer.observe(element);\n  return function unobserve() {\n    elements.delete(element);\n    observer.unobserve(element); // Destroy observer when there's nothing left to watch:\n\n    if (elements.size === 0) {\n      observer.disconnect();\n      observers.delete(id);\n      var index = idList.findIndex(function (obj) {\n        return obj.root === id.root && obj.margin === id.margin;\n      });\n\n      if (index > -1) {\n        idList.splice(index, 1);\n      }\n    }\n  };\n}\n\nvar observers = new Map();\nvar idList = [];\n\nfunction createObserver(options) {\n  var id = {\n    root: options.root || null,\n    margin: options.rootMargin || \"\"\n  };\n  var existing = idList.find(function (obj) {\n    return obj.root === id.root && obj.margin === id.margin;\n  });\n  var instance;\n\n  if (existing) {\n    instance = observers.get(existing);\n\n    if (instance) {\n      return instance;\n    }\n  }\n\n  var elements = new Map();\n  var observer = new IntersectionObserver(function (entries) {\n    entries.forEach(function (entry) {\n      var callback = elements.get(entry.target);\n      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n\n      if (callback && isVisible) {\n        callback(isVisible);\n      }\n    });\n  }, options);\n  instance = {\n    id: id,\n    observer: observer,\n    elements: elements\n  };\n  idList.push(id);\n  observers.set(id, instance);\n  return instance;\n}\n\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n  Object.defineProperty(exports.default, \"__esModule\", {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOzs7Ozs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0NILEVBQUFBO0FBR0FFLHVCQUFBQSxHQUEwQkUsZUFBMUJGOztBQUNBLElBQUlHLE1BQU0sR0FBR0MsbUJBQU8sQ0FBQyw0Q0FBRCxDQUFwQjs7QUFDQSxJQUFJQyxvQkFBb0IsR0FBR0QsbUJBQU8sQ0FBQyx5RkFBRCxDQUFsQzs7QUFDQSxJQUFNRSx1QkFBdUIsR0FBRyxPQUFPQyxvQkFBUCxLQUFnQyxVQUFoRTs7QUFDQSxTQUFTTCxlQUFULENBQXlCTSxLQUF6QixFQUErRDtNQUFwQ0MsT0FBTyxHQUFURCxLQUFvQyxDQUFsQ0M7TUFBVUMsVUFBVSxHQUF0QkYsS0FBb0MsQ0FBeEJFO01BQWFDLFFBQVEsR0FBakNILEtBQW9DLENBQVhHOzs7O0VBQzlDLElBQU1DLFVBQVUsR0FBR0QsUUFBUSxJQUFJLENBQUNMLHVCQUFoQztFQUNBLElBQU1PLFNBQVMsR0FBRyxDQUFDLEdBQUdWLE1BQUosRUFBWVcsTUFBWixFQUFsQjs7RUFDQSxJQUE4QkMsR0FBMkIsb0JBQTNCLENBQUMsR0FBR1osTUFBSixFQUFZYSxRQUFaLENBQXFCLEtBQXJCLENBQTJCLElBQXpEO0VBQUEsSUFBT0MsT0FBTyxHQUFnQkYsR0FBMkIsR0FBekQ7RUFBQSxJQUFnQkcsVUFBVSxHQUFJSCxHQUEyQixHQUF6RDs7RUFDQSxJQUE4QkksSUFBMEIsb0JBQTFCLENBQUMsR0FBR2hCLE1BQUosRUFBWWEsUUFBWixDQUFxQixJQUFyQixDQUEwQixJQUF4RDtFQUFBLElBQU9JLE9BQU8sR0FBZ0JELElBQTBCLEdBQXhEO0VBQUEsSUFBZ0JFLFVBQVUsR0FBSUYsSUFBMEIsR0FBeEQ7O0VBQ0EsQ0FBQyxHQUFHaEIsTUFBSixFQUFZbUIsU0FBWixDQUFzQixZQUFJO0lBQ3RCLElBQUlo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QSxLQUFLLENBQUNHLGlCQUFOSCxHQUEwQixDQUFwRTs7TUFDQSxJQUFJeEIsUUFBUSxJQUFJUCxTQUFoQixFQUEyQjtRQUN2Qk8sUUFBUSxDQUFDUCxTQUFELENBQVJPO01BQ0g7SUFDSixDQU5Ec0I7RUFPSCxDQVJnQixFQVFkckIsT0FSYyxDQUFqQjtFQVNBbUIsUUFBUSxHQUFHO0lBQ1BqQixFQUFFLEVBQUZBLEVBRE87SUFFUEMsUUFBUSxFQUFSQSxRQUZPO0lBR1BDLFFBQVEsRUFBUkE7RUFITyxDQUFYZTtFQUtBUixNQUFNLENBQUNnQixJQUFQaEIsQ0FBWVQsRUFBWlM7RUFDQUYsU0FBUyxDQUFDSixHQUFWSSxDQUFjUCxFQUFkTyxFQUFrQlUsUUFBbEJWO0VBQ0EsT0FBT1UsUUFBUDtBQUNIOztBQUVELElBQUksQ0FBQyxPQUFPdEQsT0FBTyxDQUFDK0QsT0FBZixLQUEyQixVQUEzQixJQUEwQyxPQUFPL0QsT0FBTyxDQUFDK0QsT0FBZixLQUEyQixRQUEzQixJQUF1Qy9ELE9BQU8sQ0FBQytELE9BQVIvRCxLQUFvQixJQUF0RyxLQUFnSCxPQUFPQSxPQUFPLENBQUMrRCxPQUFSL0QsQ0FBZ0JnRSxVQUF2QixLQUFzQyxXQUExSixFQUF1SztFQUNyS2xFLE1BQU0sQ0FBQ0MsY0FBUEQsQ0FBc0JFLE9BQU8sQ0FBQytELE9BQTlCakUsRUFBdUMsWUFBdkNBLEVBQXFEO0lBQUVHLEtBQUssRUFBRTtFQUFULENBQXJESDtFQUNBQSxNQUFNLENBQUNtRSxNQUFQbkUsQ0FBY0UsT0FBTyxDQUFDK0QsT0FBdEJqRSxFQUErQkUsT0FBL0JGO0VBQ0FvRSxNQUFNLENBQUNsRSxPQUFQa0UsR0FBaUJsRSxPQUFPLENBQUMrRCxPQUF6Qkc7QUFDRCxDLENBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvdXNlLWludGVyc2VjdGlvbi5qcz9mZDk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICAgIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLnVzZUludGVyc2VjdGlvbiA9IHVzZUludGVyc2VjdGlvbjtcclxudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxudmFyIF9yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWlyZShcIi4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrXCIpO1xyXG5jb25zdCBoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJztcclxuZnVuY3Rpb24gdXNlSW50ZXJzZWN0aW9uKHsgcm9vdFJlZiAsIHJvb3RNYXJnaW4gLCBkaXNhYmxlZCAgfSkge1xyXG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IGRpc2FibGVkIHx8ICFoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcjtcclxuICAgIGNvbnN0IHVub2JzZXJ2ZSA9ICgwLCBfcmVhY3QpLnVzZVJlZigpO1xyXG4gICAgY29uc3QgW3Zpc2libGUsIHNldFZpc2libGVdID0gKDAsIF9yZWFjdCkudXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2VsZW1lbnQsIHNldEVsZW1lbnRdID0gKDAsIF9yZWFjdCkudXNlU3RhdGUobnVsbCk7XHJcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcclxuICAgICAgICBpZiAoaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgaWYgKHVub2JzZXJ2ZS5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB1bm9ic2VydmUuY3VycmVudCgpO1xyXG4gICAgICAgICAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgdmlzaWJsZSkgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnRhZ05hbWUpIHtcclxuICAgICAgICAgICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID0gb2JzZXJ2ZShlbGVtZW50LCAoaXNWaXNpYmxlKT0+aXNWaXNpYmxlICYmIHNldFZpc2libGUoaXNWaXNpYmxlKSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3Q6IHJvb3RSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3RSZWYuY3VycmVudCxcclxuICAgICAgICAgICAgICAgICAgICByb290TWFyZ2luXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKCk9PntcclxuICAgICAgICAgICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiB1bm9ic2VydmUuY3VycmVudCgpO1xyXG4gICAgICAgICAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCF2aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpZGxlQ2FsbGJhY2sgPSAoMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLnJlcXVlc3RJZGxlQ2FsbGJhY2soKCk9PnNldFZpc2libGUodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpPT4oMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLmNhbmNlbElkbGVDYWxsYmFjayhpZGxlQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW1xyXG4gICAgICAgIGVsZW1lbnQsXHJcbiAgICAgICAgaXNEaXNhYmxlZCxcclxuICAgICAgICByb290TWFyZ2luLFxyXG4gICAgICAgIHJvb3RSZWYsXHJcbiAgICAgICAgdmlzaWJsZVxyXG4gICAgXSk7XHJcbiAgICBjb25zdCByZXNldFZpc2libGUgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygoKT0+e1xyXG4gICAgICAgIHNldFZpc2libGUoZmFsc2UpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBzZXRFbGVtZW50LFxyXG4gICAgICAgIHZpc2libGUsXHJcbiAgICAgICAgcmVzZXRWaXNpYmxlXHJcbiAgICBdO1xyXG59XHJcbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgaWQgLCBvYnNlcnZlciAsIGVsZW1lbnRzICB9ID0gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucyk7XHJcbiAgICBlbGVtZW50cy5zZXQoZWxlbWVudCwgY2FsbGJhY2spO1xyXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcclxuICAgIHJldHVybiBmdW5jdGlvbiB1bm9ic2VydmUoKSB7XHJcbiAgICAgICAgZWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpO1xyXG4gICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcclxuICAgICAgICAvLyBEZXN0cm95IG9ic2VydmVyIHdoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gd2F0Y2g6XHJcbiAgICAgICAgaWYgKGVsZW1lbnRzLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICBvYnNlcnZlcnMuZGVsZXRlKGlkKTtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpZExpc3QuZmluZEluZGV4KChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW4pO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgaWRMaXN0LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IG9ic2VydmVycyA9IG5ldyBNYXAoKTtcclxuY29uc3QgaWRMaXN0ID0gW107XHJcbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGlkID0ge1xyXG4gICAgICAgIHJvb3Q6IG9wdGlvbnMucm9vdCB8fCBudWxsLFxyXG4gICAgICAgIG1hcmdpbjogb3B0aW9ucy5yb290TWFyZ2luIHx8ICcnXHJcbiAgICB9O1xyXG4gICAgY29uc3QgZXhpc3RpbmcgPSBpZExpc3QuZmluZCgob2JqKT0+b2JqLnJvb3QgPT09IGlkLnJvb3QgJiYgb2JqLm1hcmdpbiA9PT0gaWQubWFyZ2luKTtcclxuICAgIGxldCBpbnN0YW5jZTtcclxuICAgIGlmIChleGlzdGluZykge1xyXG4gICAgICAgIGluc3RhbmNlID0gb2JzZXJ2ZXJzLmdldChleGlzdGluZyk7XHJcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBlbGVtZW50cyA9IG5ldyBNYXAoKTtcclxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKT0+e1xyXG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpPT57XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gZWxlbWVudHMuZ2V0KGVudHJ5LnRhcmdldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMDtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGlzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaXNWaXNpYmxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgb3B0aW9ucyk7XHJcbiAgICBpbnN0YW5jZSA9IHtcclxuICAgICAgICBpZCxcclxuICAgICAgICBvYnNlcnZlcixcclxuICAgICAgICBlbGVtZW50c1xyXG4gICAgfTtcclxuICAgIGlkTGlzdC5wdXNoKGlkKTtcclxuICAgIG9ic2VydmVycy5zZXQoaWQsIGluc3RhbmNlKTtcclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxufVxyXG5cclxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcclxuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcclxufVxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWludGVyc2VjdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1c2VJbnRlcnNlY3Rpb24iLCJfcmVhY3QiLCJyZXF1aXJlIiwiX3JlcXVlc3RJZGxlQ2FsbGJhY2siLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwicGFyYW0iLCJyb290UmVmIiwicm9vdE1hcmdpbiIsImRpc2FibGVkIiwiaXNEaXNhYmxlZCIsInVub2JzZXJ2ZSIsInVzZVJlZiIsInJlZiIsInVzZVN0YXRlIiwidmlzaWJsZSIsInNldFZpc2libGUiLCJyZWYxIiwiZWxlbWVudCIsInNldEVsZW1lbnQiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwidW5kZWZpbmVkIiwidGFnTmFtZSIsIm9ic2VydmUiLCJpc1Zpc2libGUiLCJyb290IiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsInJlc2V0VmlzaWJsZSIsInVzZUNhbGxiYWNrIiwiY2FsbGJhY2siLCJvcHRpb25zIiwiY3JlYXRlT2JzZXJ2ZXIiLCJpZCIsIm9ic2VydmVyIiwiZWxlbWVudHMiLCJzZXQiLCJkZWxldGUiLCJzaXplIiwiZGlzY29ubmVjdCIsIm9ic2VydmVycyIsImluZGV4IiwiaWRMaXN0IiwiZmluZEluZGV4Iiwib2JqIiwibWFyZ2luIiwic3BsaWNlIiwiTWFwIiwiZXhpc3RpbmciLCJmaW5kIiwiaW5zdGFuY2UiLCJnZXQiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwidGFyZ2V0IiwiaXNJbnRlcnNlY3RpbmciLCJpbnRlcnNlY3Rpb25SYXRpbyIsInB1c2giLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/app-router-context.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/app-router-context.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AppRouterContext = void 0;\n\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar AppRouterContext = _react.default.createContext(null);\n\nexports.AppRouterContext = AppRouterContext;\n\nif (true) {\n  AppRouterContext.displayName = \"AppRouterContext\";\n} //# sourceMappingURL=app-router-context.js.map\n\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3Q0gsRUFBQUE7QUFHQUUsd0JBQUFBLEdBQTJCLEtBQUssQ0FBaENBOztBQUNBLElBQUlHLE1BQU0sR0FBR0Msc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsNENBQUQsQ0FBUixDQUFuQzs7QUFDQSxTQUFTRCxzQkFBVCxDQUFnQ0UsR0FBaEMsRUFBcUM7RUFDakMsT0FBT0EsR0FBRyxJQUFJQSxHQUFHLENBQUNDLFVBQVhELEdBQXdCQSxHQUF4QkEsR0FBOEI7SUFDakNFLE9BQU8sRUFBRUY7RUFEd0IsQ0FBckM7QUFHSDs7QUFDRCxJQUFNSixnQkFBZ0IsR0FBR0MsTUFBTSxDQUFDSyxPQUFQTCxDQUFlTSxhQUFmTixDQUE2QixJQUE3QkEsQ0FBekI7O0FBQ0FILHdCQUFBQSxHQUEyQkUsZ0JBQTNCRjs7QUFDQSxJQUFJVSxJQUFKLEVBQTJDO0VBQ3ZDUixnQkFBZ0IsQ0FBQ1MsV0FBakJULEdBQStCLGtCQUEvQkE7QUFDSCxDLENBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5qcz9kYmRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICAgIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLkFwcFJvdXRlckNvbnRleHQgPSB2b2lkIDA7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xyXG4gICAgICAgIGRlZmF1bHQ6IG9ialxyXG4gICAgfTtcclxufVxyXG5jb25zdCBBcHBSb3V0ZXJDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChudWxsKTtcclxuZXhwb3J0cy5BcHBSb3V0ZXJDb250ZXh0ID0gQXBwUm91dGVyQ29udGV4dDtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgQXBwUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiQXBwUm91dGVyQ29udGV4dFwiO1xyXG59XHJcblxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGVyLWNvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQXBwUm91dGVyQ29udGV4dCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJjcmVhdGVDb250ZXh0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/app-router-context.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.matchRemotePattern = matchRemotePattern;\nexports.hasMatch = hasMatch;\n\nvar _micromatch = __webpack_require__(/*! next/dist/compiled/micromatch */ \"./node_modules/next/dist/compiled/micromatch/index.js\");\n\nfunction matchRemotePattern(pattern, url) {\n  if (pattern.protocol !== undefined) {\n    var actualProto = url.protocol.slice(0, -1);\n\n    if (pattern.protocol !== actualProto) {\n      return false;\n    }\n  }\n\n  if (pattern.port !== undefined) {\n    if (pattern.port !== url.port) {\n      return false;\n    }\n  }\n\n  if (pattern.hostname === undefined) {\n    throw new Error(\"Pattern should define hostname but found\\n\".concat(JSON.stringify(pattern)));\n  } else {\n    if (!(0, _micromatch).makeRe(pattern.hostname).test(url.hostname)) {\n      return false;\n    }\n  }\n\n  var _pathname;\n\n  if (!(0, _micromatch).makeRe((_pathname = pattern.pathname) != null ? _pathname : \"**\").test(url.pathname)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction hasMatch(domains, remotePatterns, url) {\n  return domains.some(function (domain) {\n    return url.hostname === domain;\n  }) || remotePatterns.some(function (p) {\n    return matchRemotePattern(p, url);\n  });\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbWF0Y2gtcmVtb3RlLXBhdHRlcm4uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDSCxFQUFBQTtBQUdBRSwwQkFBQUEsR0FBNkJFLGtCQUE3QkY7QUFDQUEsZ0JBQUFBLEdBQW1CRyxRQUFuQkg7O0FBQ0EsSUFBSUksV0FBVyxHQUFHQyxtQkFBTyxDQUFDLDRGQUFELENBQXpCOztBQUNBLFNBQVNILGtCQUFULENBQTRCSSxPQUE1QixFQUFxQ0MsR0FBckMsRUFBMEM7RUFDdEMsSUFBSUQsT0FBTyxDQUFDRSxRQUFSRixLQUFxQkcsU0FBekIsRUFBb0M7SUFDaEMsSUFBTUMsV0FBVyxHQUFHSCxHQUFHLENBQUNDLFFBQUpELENBQWFJLEtBQWJKLENBQW1CLENBQW5CQSxFQUFzQixDQUFDLENBQXZCQSxDQUFwQjs7SUFDQSxJQUFJRCxPQUFPLENBQUNFLFFBQVJGLEtBQXFCSSxXQUF6QixFQUFzQztNQUNsQyxPQUFPLEtBQVA7SUFDSDtFQUNKOztFQUNELElBQUlKLE9BQU8sQ0FBQ00sSUFBUk4sS0FBaUJHLFNBQXJCLEVBQWdDO0lBQzVCLElBQUlILE9BQU8sQ0FBQ00sSUFBUk4sS0FBaUJDLEdBQUcsQ0FBQ0ssSUFBekIsRUFBK0I7TUFDM0IsT0FBTyxLQUFQO0lBQ0g7RUFDSjs7RUFDRCxJQUFJTixPQUFPLENBQUNPLFFBQVJQLEtBQXFCRyxTQUF6QixFQUFvQztJQUNoQyxNQUFNLElBQUlLLEtBQUosQ0FBVSw2Q0FBcUVDLE1BQXJFLENBQTZDQyxJQUFJLENBQUNDLFNBQUxELENBQWVWLE9BQWZVLENBQTdDLENBQVYsQ0FBTjtFQUNILENBRkQsTUFFTztJQUNILElBQUksQ0FBQyxDQUFDLEdBQUdaLFdBQUosRUFBaUJjLE1BQWpCLENBQXdCWixPQUFPLENBQUNPLFFBQWhDLEVBQTBDTSxJQUExQyxDQUErQ1osR0FBRyxDQUFDTSxRQUFuRCxDQUFMLEVBQW1FO01BQy9ELE9BQU8sS0FBUDtJQUNIO0VBQ0o7O0VBQ0QsSUFBSU8sU0FBSjs7RUFDQSxJQUFJLENBQUMsQ0FBQyxHQUFHaEIsV0FBSixFQUFpQmMsTUFBakIsQ0FBd0IsQ0FBQ0UsU0FBUyxHQUFHZCxPQUFPLENBQUNlLFFBQXJCLEtBQWtDLElBQWxDLEdBQXlDRCxTQUF6QyxHQUFxRCxJQUE3RSxFQUFtRkQsSUFBbkYsQ0FBd0ZaLEdBQUcsQ0FBQ2MsUUFBNUYsQ0FBTCxFQUE0RztJQUN4RyxPQUFPLEtBQVA7RUFDSDs7RUFDRCxPQUFPLElBQVA7QUFDSDs7QUFDRCxTQUFTbEIsUUFBVCxDQUFrQm1CLE9BQWxCLEVBQTJCQyxjQUEzQixFQUEyQ2hCLEdBQTNDLEVBQWdEO0VBQzVDLE9BQU9lLE9BQU8sQ0FBQ0UsSUFBUkYsQ0FBYSxVQUFDRyxNQUFELEVBQU87V0FBR2xCLEdBQUcsQ0FBQ00sUUFBSk4sS0FBaUJrQjtFQUFNLENBQTlDSCxLQUFtREMsY0FBYyxDQUFDQyxJQUFmRCxDQUFvQixVQUFDRyxDQUFELEVBQUU7V0FBR3hCLGtCQUFrQixDQUFDd0IsQ0FBRCxFQUFJbkIsR0FBSjtFQUFRLENBQW5EZ0IsQ0FBMUQ7QUFDSCxDLENBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL21hdGNoLXJlbW90ZS1wYXR0ZXJuLmpzPzBjOWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gICAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMubWF0Y2hSZW1vdGVQYXR0ZXJuID0gbWF0Y2hSZW1vdGVQYXR0ZXJuO1xyXG5leHBvcnRzLmhhc01hdGNoID0gaGFzTWF0Y2g7XHJcbnZhciBfbWljcm9tYXRjaCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvbWljcm9tYXRjaFwiKTtcclxuZnVuY3Rpb24gbWF0Y2hSZW1vdGVQYXR0ZXJuKHBhdHRlcm4sIHVybCkge1xyXG4gICAgaWYgKHBhdHRlcm4ucHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNvbnN0IGFjdHVhbFByb3RvID0gdXJsLnByb3RvY29sLnNsaWNlKDAsIC0xKTtcclxuICAgICAgICBpZiAocGF0dGVybi5wcm90b2NvbCAhPT0gYWN0dWFsUHJvdG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwYXR0ZXJuLnBvcnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmIChwYXR0ZXJuLnBvcnQgIT09IHVybC5wb3J0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocGF0dGVybi5ob3N0bmFtZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXR0ZXJuIHNob3VsZCBkZWZpbmUgaG9zdG5hbWUgYnV0IGZvdW5kXFxuJHtKU09OLnN0cmluZ2lmeShwYXR0ZXJuKX1gKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCEoMCwgX21pY3JvbWF0Y2gpLm1ha2VSZShwYXR0ZXJuLmhvc3RuYW1lKS50ZXN0KHVybC5ob3N0bmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBfcGF0aG5hbWU7XHJcbiAgICBpZiAoISgwLCBfbWljcm9tYXRjaCkubWFrZVJlKChfcGF0aG5hbWUgPSBwYXR0ZXJuLnBhdGhuYW1lKSAhPSBudWxsID8gX3BhdGhuYW1lIDogXCIqKlwiKS50ZXN0KHVybC5wYXRobmFtZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBoYXNNYXRjaChkb21haW5zLCByZW1vdGVQYXR0ZXJucywgdXJsKSB7XHJcbiAgICByZXR1cm4gZG9tYWlucy5zb21lKChkb21haW4pPT51cmwuaG9zdG5hbWUgPT09IGRvbWFpbikgfHwgcmVtb3RlUGF0dGVybnMuc29tZSgocCk9Pm1hdGNoUmVtb3RlUGF0dGVybihwLCB1cmwpKTtcclxufVxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0Y2gtcmVtb3RlLXBhdHRlcm4uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibWF0Y2hSZW1vdGVQYXR0ZXJuIiwiaGFzTWF0Y2giLCJfbWljcm9tYXRjaCIsInJlcXVpcmUiLCJwYXR0ZXJuIiwidXJsIiwicHJvdG9jb2wiLCJ1bmRlZmluZWQiLCJhY3R1YWxQcm90byIsInNsaWNlIiwicG9ydCIsImhvc3RuYW1lIiwiRXJyb3IiLCJjb25jYXQiLCJKU09OIiwic3RyaW5naWZ5IiwibWFrZVJlIiwidGVzdCIsIl9wYXRobmFtZSIsInBhdGhuYW1lIiwiZG9tYWlucyIsInJlbW90ZVBhdHRlcm5zIiwic29tZSIsImRvbWFpbiIsInAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function () {\n  var e = {\n    449: function (e, r) {\n      \"use strict\";\n\n      r.byteLength = byteLength;\n      r.toByteArray = toByteArray;\n      r.fromByteArray = fromByteArray;\n      var t = [];\n      var f = [];\n      var n = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n      var i = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n      for (var o = 0, u = i.length; o < u; ++o) {\n        t[o] = i[o];\n        f[i.charCodeAt(o)] = o;\n      }\n\n      f[\"-\".charCodeAt(0)] = 62;\n      f[\"_\".charCodeAt(0)] = 63;\n\n      function getLens(e) {\n        var r = e.length;\n\n        if (r % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n\n        var t = e.indexOf(\"=\");\n        if (t === -1) t = r;\n        var f = t === r ? 0 : 4 - t % 4;\n        return [t, f];\n      }\n\n      function byteLength(e) {\n        var r = getLens(e);\n        var t = r[0];\n        var f = r[1];\n        return (t + f) * 3 / 4 - f;\n      }\n\n      function _byteLength(e, r, t) {\n        return (r + t) * 3 / 4 - t;\n      }\n\n      function toByteArray(e) {\n        var r;\n        var t = getLens(e);\n        var i = t[0];\n        var o = t[1];\n        var u = new n(_byteLength(e, i, o));\n        var a = 0;\n        var s = o > 0 ? i - 4 : i;\n        var h;\n\n        for (h = 0; h < s; h += 4) {\n          r = f[e.charCodeAt(h)] << 18 | f[e.charCodeAt(h + 1)] << 12 | f[e.charCodeAt(h + 2)] << 6 | f[e.charCodeAt(h + 3)];\n          u[a++] = r >> 16 & 255;\n          u[a++] = r >> 8 & 255;\n          u[a++] = r & 255;\n        }\n\n        if (o === 2) {\n          r = f[e.charCodeAt(h)] << 2 | f[e.charCodeAt(h + 1)] >> 4;\n          u[a++] = r & 255;\n        }\n\n        if (o === 1) {\n          r = f[e.charCodeAt(h)] << 10 | f[e.charCodeAt(h + 1)] << 4 | f[e.charCodeAt(h + 2)] >> 2;\n          u[a++] = r >> 8 & 255;\n          u[a++] = r & 255;\n        }\n\n        return u;\n      }\n\n      function tripletToBase64(e) {\n        return t[e >> 18 & 63] + t[e >> 12 & 63] + t[e >> 6 & 63] + t[e & 63];\n      }\n\n      function encodeChunk(e, r, t) {\n        var f;\n        var n = [];\n\n        for (var i = r; i < t; i += 3) {\n          f = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255);\n          n.push(tripletToBase64(f));\n        }\n\n        return n.join(\"\");\n      }\n\n      function fromByteArray(e) {\n        var r;\n        var f = e.length;\n        var n = f % 3;\n        var i = [];\n        var o = 16383;\n\n        for (var u = 0, a = f - n; u < a; u += o) {\n          i.push(encodeChunk(e, u, u + o > a ? a : u + o));\n        }\n\n        if (n === 1) {\n          r = e[f - 1];\n          i.push(t[r >> 2] + t[r << 4 & 63] + \"==\");\n        } else if (n === 2) {\n          r = (e[f - 2] << 8) + e[f - 1];\n          i.push(t[r >> 10] + t[r >> 4 & 63] + t[r << 2 & 63] + \"=\");\n        }\n\n        return i.join(\"\");\n      }\n    },\n    877: function (e, r, t) {\n      \"use strict\";\n      /*!\r\n       * The buffer module from node.js, for the browser.\r\n       *\r\n       * @author   Feross Aboukhadijeh <https://feross.org>\r\n       * @license  MIT\r\n       */\n\n      var f = t(449);\n      var n = t(543);\n      var i = typeof Symbol === \"function\" && typeof Symbol.for === \"function\" ? Symbol.for(\"nodejs.util.inspect.custom\") : null;\n      r.Buffer = Buffer;\n      r.SlowBuffer = SlowBuffer;\n      r.INSPECT_MAX_BYTES = 50;\n      var o = 2147483647;\n      r.kMaxLength = o;\n      Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\n      if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(\"This browser lacks typed array (Uint8Array) support which is required by \" + \"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\n      }\n\n      function typedArraySupport() {\n        try {\n          var e = new Uint8Array(1);\n          var r = {\n            foo: function () {\n              return 42;\n            }\n          };\n          Object.setPrototypeOf(r, Uint8Array.prototype);\n          Object.setPrototypeOf(e, r);\n          return e.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n\n      Object.defineProperty(Buffer.prototype, \"parent\", {\n        enumerable: true,\n        get: function () {\n          if (!Buffer.isBuffer(this)) return undefined;\n          return this.buffer;\n        }\n      });\n      Object.defineProperty(Buffer.prototype, \"offset\", {\n        enumerable: true,\n        get: function () {\n          if (!Buffer.isBuffer(this)) return undefined;\n          return this.byteOffset;\n        }\n      });\n\n      function createBuffer(e) {\n        if (e > o) {\n          throw new RangeError('The value \"' + e + '\" is invalid for option \"size\"');\n        }\n\n        var r = new Uint8Array(e);\n        Object.setPrototypeOf(r, Buffer.prototype);\n        return r;\n      }\n\n      function Buffer(e, r, t) {\n        if (typeof e === \"number\") {\n          if (typeof r === \"string\") {\n            throw new TypeError('The \"string\" argument must be of type string. Received type number');\n          }\n\n          return allocUnsafe(e);\n        }\n\n        return from(e, r, t);\n      }\n\n      Buffer.poolSize = 8192;\n\n      function from(e, r, t) {\n        if (typeof e === \"string\") {\n          return fromString(e, r);\n        }\n\n        if (ArrayBuffer.isView(e)) {\n          return fromArrayLike(e);\n        }\n\n        if (e == null) {\n          throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \" + \"or Array-like Object. Received type \" + typeof e);\n        }\n\n        if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) {\n          return fromArrayBuffer(e, r, t);\n        }\n\n        if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(e, SharedArrayBuffer) || e && isInstance(e.buffer, SharedArrayBuffer))) {\n          return fromArrayBuffer(e, r, t);\n        }\n\n        if (typeof e === \"number\") {\n          throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n        }\n\n        var f = e.valueOf && e.valueOf();\n\n        if (f != null && f !== e) {\n          return Buffer.from(f, r, t);\n        }\n\n        var n = fromObject(e);\n        if (n) return n;\n\n        if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === \"function\") {\n          return Buffer.from(e[Symbol.toPrimitive](\"string\"), r, t);\n        }\n\n        throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \" + \"or Array-like Object. Received type \" + typeof e);\n      }\n\n      Buffer.from = function (e, r, t) {\n        return from(e, r, t);\n      };\n\n      Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\n      Object.setPrototypeOf(Buffer, Uint8Array);\n\n      function assertSize(e) {\n        if (typeof e !== \"number\") {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (e < 0) {\n          throw new RangeError('The value \"' + e + '\" is invalid for option \"size\"');\n        }\n      }\n\n      function alloc(e, r, t) {\n        assertSize(e);\n\n        if (e <= 0) {\n          return createBuffer(e);\n        }\n\n        if (r !== undefined) {\n          return typeof t === \"string\" ? createBuffer(e).fill(r, t) : createBuffer(e).fill(r);\n        }\n\n        return createBuffer(e);\n      }\n\n      Buffer.alloc = function (e, r, t) {\n        return alloc(e, r, t);\n      };\n\n      function allocUnsafe(e) {\n        assertSize(e);\n        return createBuffer(e < 0 ? 0 : checked(e) | 0);\n      }\n\n      Buffer.allocUnsafe = function (e) {\n        return allocUnsafe(e);\n      };\n\n      Buffer.allocUnsafeSlow = function (e) {\n        return allocUnsafe(e);\n      };\n\n      function fromString(e, r) {\n        if (typeof r !== \"string\" || r === \"\") {\n          r = \"utf8\";\n        }\n\n        if (!Buffer.isEncoding(r)) {\n          throw new TypeError(\"Unknown encoding: \" + r);\n        }\n\n        var t = byteLength(e, r) | 0;\n        var f = createBuffer(t);\n        var n = f.write(e, r);\n\n        if (n !== t) {\n          f = f.slice(0, n);\n        }\n\n        return f;\n      }\n\n      function fromArrayLike(e) {\n        var r = e.length < 0 ? 0 : checked(e.length) | 0;\n        var t = createBuffer(r);\n\n        for (var f = 0; f < r; f += 1) {\n          t[f] = e[f] & 255;\n        }\n\n        return t;\n      }\n\n      function fromArrayBuffer(e, r, t) {\n        if (r < 0 || e.byteLength < r) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n\n        if (e.byteLength < r + (t || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n\n        var f;\n\n        if (r === undefined && t === undefined) {\n          f = new Uint8Array(e);\n        } else if (t === undefined) {\n          f = new Uint8Array(e, r);\n        } else {\n          f = new Uint8Array(e, r, t);\n        }\n\n        Object.setPrototypeOf(f, Buffer.prototype);\n        return f;\n      }\n\n      function fromObject(e) {\n        if (Buffer.isBuffer(e)) {\n          var r = checked(e.length) | 0;\n          var t = createBuffer(r);\n\n          if (t.length === 0) {\n            return t;\n          }\n\n          e.copy(t, 0, 0, r);\n          return t;\n        }\n\n        if (e.length !== undefined) {\n          if (typeof e.length !== \"number\" || numberIsNaN(e.length)) {\n            return createBuffer(0);\n          }\n\n          return fromArrayLike(e);\n        }\n\n        if (e.type === \"Buffer\" && Array.isArray(e.data)) {\n          return fromArrayLike(e.data);\n        }\n      }\n\n      function checked(e) {\n        if (e >= o) {\n          throw new RangeError(\"Attempt to allocate Buffer larger than maximum \" + \"size: 0x\" + o.toString(16) + \" bytes\");\n        }\n\n        return e | 0;\n      }\n\n      function SlowBuffer(e) {\n        if (+e != e) {\n          e = 0;\n        }\n\n        return Buffer.alloc(+e);\n      }\n\n      Buffer.isBuffer = function isBuffer(e) {\n        return e != null && e._isBuffer === true && e !== Buffer.prototype;\n      };\n\n      Buffer.compare = function compare(e, r) {\n        if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);\n        if (isInstance(r, Uint8Array)) r = Buffer.from(r, r.offset, r.byteLength);\n\n        if (!Buffer.isBuffer(e) || !Buffer.isBuffer(r)) {\n          throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n        }\n\n        if (e === r) return 0;\n        var t = e.length;\n        var f = r.length;\n\n        for (var n = 0, i = Math.min(t, f); n < i; ++n) {\n          if (e[n] !== r[n]) {\n            t = e[n];\n            f = r[n];\n            break;\n          }\n        }\n\n        if (t < f) return -1;\n        if (f < t) return 1;\n        return 0;\n      };\n\n      Buffer.isEncoding = function isEncoding(e) {\n        switch (String(e).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return true;\n\n          default:\n            return false;\n        }\n      };\n\n      Buffer.concat = function concat(e, r) {\n        if (!Array.isArray(e)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n\n        if (e.length === 0) {\n          return Buffer.alloc(0);\n        }\n\n        var t;\n\n        if (r === undefined) {\n          r = 0;\n\n          for (t = 0; t < e.length; ++t) {\n            r += e[t].length;\n          }\n        }\n\n        var f = Buffer.allocUnsafe(r);\n        var n = 0;\n\n        for (t = 0; t < e.length; ++t) {\n          var i = e[t];\n\n          if (isInstance(i, Uint8Array)) {\n            i = Buffer.from(i);\n          }\n\n          if (!Buffer.isBuffer(i)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          }\n\n          i.copy(f, n);\n          n += i.length;\n        }\n\n        return f;\n      };\n\n      function byteLength(e, r) {\n        if (Buffer.isBuffer(e)) {\n          return e.length;\n        }\n\n        if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {\n          return e.byteLength;\n        }\n\n        if (typeof e !== \"string\") {\n          throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + \"Received type \" + typeof e);\n        }\n\n        var t = e.length;\n        var f = arguments.length > 2 && arguments[2] === true;\n        if (!f && t === 0) return 0;\n        var n = false;\n\n        for (;;) {\n          switch (r) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return t;\n\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8ToBytes(e).length;\n\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return t * 2;\n\n            case \"hex\":\n              return t >>> 1;\n\n            case \"base64\":\n              return base64ToBytes(e).length;\n\n            default:\n              if (n) {\n                return f ? -1 : utf8ToBytes(e).length;\n              }\n\n              r = (\"\" + r).toLowerCase();\n              n = true;\n          }\n        }\n      }\n\n      Buffer.byteLength = byteLength;\n\n      function slowToString(e, r, t) {\n        var f = false;\n\n        if (r === undefined || r < 0) {\n          r = 0;\n        }\n\n        if (r > this.length) {\n          return \"\";\n        }\n\n        if (t === undefined || t > this.length) {\n          t = this.length;\n        }\n\n        if (t <= 0) {\n          return \"\";\n        }\n\n        t >>>= 0;\n        r >>>= 0;\n\n        if (t <= r) {\n          return \"\";\n        }\n\n        if (!e) e = \"utf8\";\n\n        while (true) {\n          switch (e) {\n            case \"hex\":\n              return hexSlice(this, r, t);\n\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Slice(this, r, t);\n\n            case \"ascii\":\n              return asciiSlice(this, r, t);\n\n            case \"latin1\":\n            case \"binary\":\n              return latin1Slice(this, r, t);\n\n            case \"base64\":\n              return base64Slice(this, r, t);\n\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return utf16leSlice(this, r, t);\n\n            default:\n              if (f) throw new TypeError(\"Unknown encoding: \" + e);\n              e = (e + \"\").toLowerCase();\n              f = true;\n          }\n        }\n      }\n\n      Buffer.prototype._isBuffer = true;\n\n      function swap(e, r, t) {\n        var f = e[r];\n        e[r] = e[t];\n        e[t] = f;\n      }\n\n      Buffer.prototype.swap16 = function swap16() {\n        var e = this.length;\n\n        if (e % 2 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n        }\n\n        for (var r = 0; r < e; r += 2) {\n          swap(this, r, r + 1);\n        }\n\n        return this;\n      };\n\n      Buffer.prototype.swap32 = function swap32() {\n        var e = this.length;\n\n        if (e % 4 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n        }\n\n        for (var r = 0; r < e; r += 4) {\n          swap(this, r, r + 3);\n          swap(this, r + 1, r + 2);\n        }\n\n        return this;\n      };\n\n      Buffer.prototype.swap64 = function swap64() {\n        var e = this.length;\n\n        if (e % 8 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n        }\n\n        for (var r = 0; r < e; r += 8) {\n          swap(this, r, r + 7);\n          swap(this, r + 1, r + 6);\n          swap(this, r + 2, r + 5);\n          swap(this, r + 3, r + 4);\n        }\n\n        return this;\n      };\n\n      Buffer.prototype.toString = function toString() {\n        var e = this.length;\n        if (e === 0) return \"\";\n        if (arguments.length === 0) return utf8Slice(this, 0, e);\n        return slowToString.apply(this, arguments);\n      };\n\n      Buffer.prototype.toLocaleString = Buffer.prototype.toString;\n\n      Buffer.prototype.equals = function equals(e) {\n        if (!Buffer.isBuffer(e)) throw new TypeError(\"Argument must be a Buffer\");\n        if (this === e) return true;\n        return Buffer.compare(this, e) === 0;\n      };\n\n      Buffer.prototype.inspect = function inspect() {\n        var e = \"\";\n        var t = r.INSPECT_MAX_BYTES;\n        e = this.toString(\"hex\", 0, t).replace(/(.{2})/g, \"$1 \").trim();\n        if (this.length > t) e += \" ... \";\n        return \"<Buffer \" + e + \">\";\n      };\n\n      if (i) {\n        Buffer.prototype[i] = Buffer.prototype.inspect;\n      }\n\n      Buffer.prototype.compare = function compare(e, r, t, f, n) {\n        if (isInstance(e, Uint8Array)) {\n          e = Buffer.from(e, e.offset, e.byteLength);\n        }\n\n        if (!Buffer.isBuffer(e)) {\n          throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. ' + \"Received type \" + typeof e);\n        }\n\n        if (r === undefined) {\n          r = 0;\n        }\n\n        if (t === undefined) {\n          t = e ? e.length : 0;\n        }\n\n        if (f === undefined) {\n          f = 0;\n        }\n\n        if (n === undefined) {\n          n = this.length;\n        }\n\n        if (r < 0 || t > e.length || f < 0 || n > this.length) {\n          throw new RangeError(\"out of range index\");\n        }\n\n        if (f >= n && r >= t) {\n          return 0;\n        }\n\n        if (f >= n) {\n          return -1;\n        }\n\n        if (r >= t) {\n          return 1;\n        }\n\n        r >>>= 0;\n        t >>>= 0;\n        f >>>= 0;\n        n >>>= 0;\n        if (this === e) return 0;\n        var i = n - f;\n        var o = t - r;\n        var u = Math.min(i, o);\n        var a = this.slice(f, n);\n        var s = e.slice(r, t);\n\n        for (var h = 0; h < u; ++h) {\n          if (a[h] !== s[h]) {\n            i = a[h];\n            o = s[h];\n            break;\n          }\n        }\n\n        if (i < o) return -1;\n        if (o < i) return 1;\n        return 0;\n      };\n\n      function bidirectionalIndexOf(e, r, t, f, n) {\n        if (e.length === 0) return -1;\n\n        if (typeof t === \"string\") {\n          f = t;\n          t = 0;\n        } else if (t > 2147483647) {\n          t = 2147483647;\n        } else if (t < -2147483648) {\n          t = -2147483648;\n        }\n\n        t = +t;\n\n        if (numberIsNaN(t)) {\n          t = n ? 0 : e.length - 1;\n        }\n\n        if (t < 0) t = e.length + t;\n\n        if (t >= e.length) {\n          if (n) return -1;else t = e.length - 1;\n        } else if (t < 0) {\n          if (n) t = 0;else return -1;\n        }\n\n        if (typeof r === \"string\") {\n          r = Buffer.from(r, f);\n        }\n\n        if (Buffer.isBuffer(r)) {\n          if (r.length === 0) {\n            return -1;\n          }\n\n          return arrayIndexOf(e, r, t, f, n);\n        } else if (typeof r === \"number\") {\n          r = r & 255;\n\n          if (typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (n) {\n              return Uint8Array.prototype.indexOf.call(e, r, t);\n            } else {\n              return Uint8Array.prototype.lastIndexOf.call(e, r, t);\n            }\n          }\n\n          return arrayIndexOf(e, [r], t, f, n);\n        }\n\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n\n      function arrayIndexOf(e, r, t, f, n) {\n        var i = 1;\n        var o = e.length;\n        var u = r.length;\n\n        if (f !== undefined) {\n          f = String(f).toLowerCase();\n\n          if (f === \"ucs2\" || f === \"ucs-2\" || f === \"utf16le\" || f === \"utf-16le\") {\n            if (e.length < 2 || r.length < 2) {\n              return -1;\n            }\n\n            i = 2;\n            o /= 2;\n            u /= 2;\n            t /= 2;\n          }\n        }\n\n        function read(e, r) {\n          if (i === 1) {\n            return e[r];\n          } else {\n            return e.readUInt16BE(r * i);\n          }\n        }\n\n        var a;\n\n        if (n) {\n          var s = -1;\n\n          for (a = t; a < o; a++) {\n            if (read(e, a) === read(r, s === -1 ? 0 : a - s)) {\n              if (s === -1) s = a;\n              if (a - s + 1 === u) return s * i;\n            } else {\n              if (s !== -1) a -= a - s;\n              s = -1;\n            }\n          }\n        } else {\n          if (t + u > o) t = o - u;\n\n          for (a = t; a >= 0; a--) {\n            var h = true;\n\n            for (var c = 0; c < u; c++) {\n              if (read(e, a + c) !== read(r, c)) {\n                h = false;\n                break;\n              }\n            }\n\n            if (h) return a;\n          }\n        }\n\n        return -1;\n      }\n\n      Buffer.prototype.includes = function includes(e, r, t) {\n        return this.indexOf(e, r, t) !== -1;\n      };\n\n      Buffer.prototype.indexOf = function indexOf(e, r, t) {\n        return bidirectionalIndexOf(this, e, r, t, true);\n      };\n\n      Buffer.prototype.lastIndexOf = function lastIndexOf(e, r, t) {\n        return bidirectionalIndexOf(this, e, r, t, false);\n      };\n\n      function hexWrite(e, r, t, f) {\n        t = Number(t) || 0;\n        var n = e.length - t;\n\n        if (!f) {\n          f = n;\n        } else {\n          f = Number(f);\n\n          if (f > n) {\n            f = n;\n          }\n        }\n\n        var i = r.length;\n\n        if (f > i / 2) {\n          f = i / 2;\n        }\n\n        for (var o = 0; o < f; ++o) {\n          var u = parseInt(r.substr(o * 2, 2), 16);\n          if (numberIsNaN(u)) return o;\n          e[t + o] = u;\n        }\n\n        return o;\n      }\n\n      function utf8Write(e, r, t, f) {\n        return blitBuffer(utf8ToBytes(r, e.length - t), e, t, f);\n      }\n\n      function asciiWrite(e, r, t, f) {\n        return blitBuffer(asciiToBytes(r), e, t, f);\n      }\n\n      function latin1Write(e, r, t, f) {\n        return asciiWrite(e, r, t, f);\n      }\n\n      function base64Write(e, r, t, f) {\n        return blitBuffer(base64ToBytes(r), e, t, f);\n      }\n\n      function ucs2Write(e, r, t, f) {\n        return blitBuffer(utf16leToBytes(r, e.length - t), e, t, f);\n      }\n\n      Buffer.prototype.write = function write(e, r, t, f) {\n        if (r === undefined) {\n          f = \"utf8\";\n          t = this.length;\n          r = 0;\n        } else if (t === undefined && typeof r === \"string\") {\n          f = r;\n          t = this.length;\n          r = 0;\n        } else if (isFinite(r)) {\n          r = r >>> 0;\n\n          if (isFinite(t)) {\n            t = t >>> 0;\n            if (f === undefined) f = \"utf8\";\n          } else {\n            f = t;\n            t = undefined;\n          }\n        } else {\n          throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n        }\n\n        var n = this.length - r;\n        if (t === undefined || t > n) t = n;\n\n        if (e.length > 0 && (t < 0 || r < 0) || r > this.length) {\n          throw new RangeError(\"Attempt to write outside buffer bounds\");\n        }\n\n        if (!f) f = \"utf8\";\n        var i = false;\n\n        for (;;) {\n          switch (f) {\n            case \"hex\":\n              return hexWrite(this, e, r, t);\n\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Write(this, e, r, t);\n\n            case \"ascii\":\n              return asciiWrite(this, e, r, t);\n\n            case \"latin1\":\n            case \"binary\":\n              return latin1Write(this, e, r, t);\n\n            case \"base64\":\n              return base64Write(this, e, r, t);\n\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return ucs2Write(this, e, r, t);\n\n            default:\n              if (i) throw new TypeError(\"Unknown encoding: \" + f);\n              f = (\"\" + f).toLowerCase();\n              i = true;\n          }\n        }\n      };\n\n      Buffer.prototype.toJSON = function toJSON() {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n\n      function base64Slice(e, r, t) {\n        if (r === 0 && t === e.length) {\n          return f.fromByteArray(e);\n        } else {\n          return f.fromByteArray(e.slice(r, t));\n        }\n      }\n\n      function utf8Slice(e, r, t) {\n        t = Math.min(e.length, t);\n        var f = [];\n        var n = r;\n\n        while (n < t) {\n          var i = e[n];\n          var o = null;\n          var u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;\n\n          if (n + u <= t) {\n            var a, s, h, c;\n\n            switch (u) {\n              case 1:\n                if (i < 128) {\n                  o = i;\n                }\n\n                break;\n\n              case 2:\n                a = e[n + 1];\n\n                if ((a & 192) === 128) {\n                  c = (i & 31) << 6 | a & 63;\n\n                  if (c > 127) {\n                    o = c;\n                  }\n                }\n\n                break;\n\n              case 3:\n                a = e[n + 1];\n                s = e[n + 2];\n\n                if ((a & 192) === 128 && (s & 192) === 128) {\n                  c = (i & 15) << 12 | (a & 63) << 6 | s & 63;\n\n                  if (c > 2047 && (c < 55296 || c > 57343)) {\n                    o = c;\n                  }\n                }\n\n                break;\n\n              case 4:\n                a = e[n + 1];\n                s = e[n + 2];\n                h = e[n + 3];\n\n                if ((a & 192) === 128 && (s & 192) === 128 && (h & 192) === 128) {\n                  c = (i & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | h & 63;\n\n                  if (c > 65535 && c < 1114112) {\n                    o = c;\n                  }\n                }\n\n            }\n          }\n\n          if (o === null) {\n            o = 65533;\n            u = 1;\n          } else if (o > 65535) {\n            o -= 65536;\n            f.push(o >>> 10 & 1023 | 55296);\n            o = 56320 | o & 1023;\n          }\n\n          f.push(o);\n          n += u;\n        }\n\n        return decodeCodePointsArray(f);\n      }\n\n      var u = 4096;\n\n      function decodeCodePointsArray(e) {\n        var r = e.length;\n\n        if (r <= u) {\n          return String.fromCharCode.apply(String, e);\n        }\n\n        var t = \"\";\n        var f = 0;\n\n        while (f < r) {\n          t += String.fromCharCode.apply(String, e.slice(f, f += u));\n        }\n\n        return t;\n      }\n\n      function asciiSlice(e, r, t) {\n        var f = \"\";\n        t = Math.min(e.length, t);\n\n        for (var n = r; n < t; ++n) {\n          f += String.fromCharCode(e[n] & 127);\n        }\n\n        return f;\n      }\n\n      function latin1Slice(e, r, t) {\n        var f = \"\";\n        t = Math.min(e.length, t);\n\n        for (var n = r; n < t; ++n) {\n          f += String.fromCharCode(e[n]);\n        }\n\n        return f;\n      }\n\n      function hexSlice(e, r, t) {\n        var f = e.length;\n        if (!r || r < 0) r = 0;\n        if (!t || t < 0 || t > f) t = f;\n        var n = \"\";\n\n        for (var i = r; i < t; ++i) {\n          n += s[e[i]];\n        }\n\n        return n;\n      }\n\n      function utf16leSlice(e, r, t) {\n        var f = e.slice(r, t);\n        var n = \"\";\n\n        for (var i = 0; i < f.length; i += 2) {\n          n += String.fromCharCode(f[i] + f[i + 1] * 256);\n        }\n\n        return n;\n      }\n\n      Buffer.prototype.slice = function slice(e, r) {\n        var t = this.length;\n        e = ~~e;\n        r = r === undefined ? t : ~~r;\n\n        if (e < 0) {\n          e += t;\n          if (e < 0) e = 0;\n        } else if (e > t) {\n          e = t;\n        }\n\n        if (r < 0) {\n          r += t;\n          if (r < 0) r = 0;\n        } else if (r > t) {\n          r = t;\n        }\n\n        if (r < e) r = e;\n        var f = this.subarray(e, r);\n        Object.setPrototypeOf(f, Buffer.prototype);\n        return f;\n      };\n\n      function checkOffset(e, r, t) {\n        if (e % 1 !== 0 || e < 0) throw new RangeError(\"offset is not uint\");\n        if (e + r > t) throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n\n      Buffer.prototype.readUIntLE = function readUIntLE(e, r, t) {\n        e = e >>> 0;\n        r = r >>> 0;\n        if (!t) checkOffset(e, r, this.length);\n        var f = this[e];\n        var n = 1;\n        var i = 0;\n\n        while (++i < r && (n *= 256)) {\n          f += this[e + i] * n;\n        }\n\n        return f;\n      };\n\n      Buffer.prototype.readUIntBE = function readUIntBE(e, r, t) {\n        e = e >>> 0;\n        r = r >>> 0;\n\n        if (!t) {\n          checkOffset(e, r, this.length);\n        }\n\n        var f = this[e + --r];\n        var n = 1;\n\n        while (r > 0 && (n *= 256)) {\n          f += this[e + --r] * n;\n        }\n\n        return f;\n      };\n\n      Buffer.prototype.readUInt8 = function readUInt8(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 1, this.length);\n        return this[e];\n      };\n\n      Buffer.prototype.readUInt16LE = function readUInt16LE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 2, this.length);\n        return this[e] | this[e + 1] << 8;\n      };\n\n      Buffer.prototype.readUInt16BE = function readUInt16BE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 2, this.length);\n        return this[e] << 8 | this[e + 1];\n      };\n\n      Buffer.prototype.readUInt32LE = function readUInt32LE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 4, this.length);\n        return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;\n      };\n\n      Buffer.prototype.readUInt32BE = function readUInt32BE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 4, this.length);\n        return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);\n      };\n\n      Buffer.prototype.readIntLE = function readIntLE(e, r, t) {\n        e = e >>> 0;\n        r = r >>> 0;\n        if (!t) checkOffset(e, r, this.length);\n        var f = this[e];\n        var n = 1;\n        var i = 0;\n\n        while (++i < r && (n *= 256)) {\n          f += this[e + i] * n;\n        }\n\n        n *= 128;\n        if (f >= n) f -= Math.pow(2, 8 * r);\n        return f;\n      };\n\n      Buffer.prototype.readIntBE = function readIntBE(e, r, t) {\n        e = e >>> 0;\n        r = r >>> 0;\n        if (!t) checkOffset(e, r, this.length);\n        var f = r;\n        var n = 1;\n        var i = this[e + --f];\n\n        while (f > 0 && (n *= 256)) {\n          i += this[e + --f] * n;\n        }\n\n        n *= 128;\n        if (i >= n) i -= Math.pow(2, 8 * r);\n        return i;\n      };\n\n      Buffer.prototype.readInt8 = function readInt8(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 1, this.length);\n        if (!(this[e] & 128)) return this[e];\n        return (255 - this[e] + 1) * -1;\n      };\n\n      Buffer.prototype.readInt16LE = function readInt16LE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 2, this.length);\n        var t = this[e] | this[e + 1] << 8;\n        return t & 32768 ? t | 4294901760 : t;\n      };\n\n      Buffer.prototype.readInt16BE = function readInt16BE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 2, this.length);\n        var t = this[e + 1] | this[e] << 8;\n        return t & 32768 ? t | 4294901760 : t;\n      };\n\n      Buffer.prototype.readInt32LE = function readInt32LE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 4, this.length);\n        return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;\n      };\n\n      Buffer.prototype.readInt32BE = function readInt32BE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 4, this.length);\n        return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];\n      };\n\n      Buffer.prototype.readFloatLE = function readFloatLE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 4, this.length);\n        return n.read(this, e, true, 23, 4);\n      };\n\n      Buffer.prototype.readFloatBE = function readFloatBE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 4, this.length);\n        return n.read(this, e, false, 23, 4);\n      };\n\n      Buffer.prototype.readDoubleLE = function readDoubleLE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 8, this.length);\n        return n.read(this, e, true, 52, 8);\n      };\n\n      Buffer.prototype.readDoubleBE = function readDoubleBE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 8, this.length);\n        return n.read(this, e, false, 52, 8);\n      };\n\n      function checkInt(e, r, t, f, n, i) {\n        if (!Buffer.isBuffer(e)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (r > n || r < i) throw new RangeError('\"value\" argument is out of bounds');\n        if (t + f > e.length) throw new RangeError(\"Index out of range\");\n      }\n\n      Buffer.prototype.writeUIntLE = function writeUIntLE(e, r, t, f) {\n        e = +e;\n        r = r >>> 0;\n        t = t >>> 0;\n\n        if (!f) {\n          var n = Math.pow(2, 8 * t) - 1;\n          checkInt(this, e, r, t, n, 0);\n        }\n\n        var i = 1;\n        var o = 0;\n        this[r] = e & 255;\n\n        while (++o < t && (i *= 256)) {\n          this[r + o] = e / i & 255;\n        }\n\n        return r + t;\n      };\n\n      Buffer.prototype.writeUIntBE = function writeUIntBE(e, r, t, f) {\n        e = +e;\n        r = r >>> 0;\n        t = t >>> 0;\n\n        if (!f) {\n          var n = Math.pow(2, 8 * t) - 1;\n          checkInt(this, e, r, t, n, 0);\n        }\n\n        var i = t - 1;\n        var o = 1;\n        this[r + i] = e & 255;\n\n        while (--i >= 0 && (o *= 256)) {\n          this[r + i] = e / o & 255;\n        }\n\n        return r + t;\n      };\n\n      Buffer.prototype.writeUInt8 = function writeUInt8(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 1, 255, 0);\n        this[r] = e & 255;\n        return r + 1;\n      };\n\n      Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 2, 65535, 0);\n        this[r] = e & 255;\n        this[r + 1] = e >>> 8;\n        return r + 2;\n      };\n\n      Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 2, 65535, 0);\n        this[r] = e >>> 8;\n        this[r + 1] = e & 255;\n        return r + 2;\n      };\n\n      Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 4, 4294967295, 0);\n        this[r + 3] = e >>> 24;\n        this[r + 2] = e >>> 16;\n        this[r + 1] = e >>> 8;\n        this[r] = e & 255;\n        return r + 4;\n      };\n\n      Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 4, 4294967295, 0);\n        this[r] = e >>> 24;\n        this[r + 1] = e >>> 16;\n        this[r + 2] = e >>> 8;\n        this[r + 3] = e & 255;\n        return r + 4;\n      };\n\n      Buffer.prototype.writeIntLE = function writeIntLE(e, r, t, f) {\n        e = +e;\n        r = r >>> 0;\n\n        if (!f) {\n          var n = Math.pow(2, 8 * t - 1);\n          checkInt(this, e, r, t, n - 1, -n);\n        }\n\n        var i = 0;\n        var o = 1;\n        var u = 0;\n        this[r] = e & 255;\n\n        while (++i < t && (o *= 256)) {\n          if (e < 0 && u === 0 && this[r + i - 1] !== 0) {\n            u = 1;\n          }\n\n          this[r + i] = (e / o >> 0) - u & 255;\n        }\n\n        return r + t;\n      };\n\n      Buffer.prototype.writeIntBE = function writeIntBE(e, r, t, f) {\n        e = +e;\n        r = r >>> 0;\n\n        if (!f) {\n          var n = Math.pow(2, 8 * t - 1);\n          checkInt(this, e, r, t, n - 1, -n);\n        }\n\n        var i = t - 1;\n        var o = 1;\n        var u = 0;\n        this[r + i] = e & 255;\n\n        while (--i >= 0 && (o *= 256)) {\n          if (e < 0 && u === 0 && this[r + i + 1] !== 0) {\n            u = 1;\n          }\n\n          this[r + i] = (e / o >> 0) - u & 255;\n        }\n\n        return r + t;\n      };\n\n      Buffer.prototype.writeInt8 = function writeInt8(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 1, 127, -128);\n        if (e < 0) e = 255 + e + 1;\n        this[r] = e & 255;\n        return r + 1;\n      };\n\n      Buffer.prototype.writeInt16LE = function writeInt16LE(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 2, 32767, -32768);\n        this[r] = e & 255;\n        this[r + 1] = e >>> 8;\n        return r + 2;\n      };\n\n      Buffer.prototype.writeInt16BE = function writeInt16BE(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 2, 32767, -32768);\n        this[r] = e >>> 8;\n        this[r + 1] = e & 255;\n        return r + 2;\n      };\n\n      Buffer.prototype.writeInt32LE = function writeInt32LE(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);\n        this[r] = e & 255;\n        this[r + 1] = e >>> 8;\n        this[r + 2] = e >>> 16;\n        this[r + 3] = e >>> 24;\n        return r + 4;\n      };\n\n      Buffer.prototype.writeInt32BE = function writeInt32BE(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);\n        if (e < 0) e = 4294967295 + e + 1;\n        this[r] = e >>> 24;\n        this[r + 1] = e >>> 16;\n        this[r + 2] = e >>> 8;\n        this[r + 3] = e & 255;\n        return r + 4;\n      };\n\n      function checkIEEE754(e, r, t, f, n, i) {\n        if (t + f > e.length) throw new RangeError(\"Index out of range\");\n        if (t < 0) throw new RangeError(\"Index out of range\");\n      }\n\n      function writeFloat(e, r, t, f, i) {\n        r = +r;\n        t = t >>> 0;\n\n        if (!i) {\n          checkIEEE754(e, r, t, 4, 34028234663852886e22, -34028234663852886e22);\n        }\n\n        n.write(e, r, t, f, 23, 4);\n        return t + 4;\n      }\n\n      Buffer.prototype.writeFloatLE = function writeFloatLE(e, r, t) {\n        return writeFloat(this, e, r, true, t);\n      };\n\n      Buffer.prototype.writeFloatBE = function writeFloatBE(e, r, t) {\n        return writeFloat(this, e, r, false, t);\n      };\n\n      function writeDouble(e, r, t, f, i) {\n        r = +r;\n        t = t >>> 0;\n\n        if (!i) {\n          checkIEEE754(e, r, t, 8, 17976931348623157e292, -17976931348623157e292);\n        }\n\n        n.write(e, r, t, f, 52, 8);\n        return t + 8;\n      }\n\n      Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, r, t) {\n        return writeDouble(this, e, r, true, t);\n      };\n\n      Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, r, t) {\n        return writeDouble(this, e, r, false, t);\n      };\n\n      Buffer.prototype.copy = function copy(e, r, t, f) {\n        if (!Buffer.isBuffer(e)) throw new TypeError(\"argument should be a Buffer\");\n        if (!t) t = 0;\n        if (!f && f !== 0) f = this.length;\n        if (r >= e.length) r = e.length;\n        if (!r) r = 0;\n        if (f > 0 && f < t) f = t;\n        if (f === t) return 0;\n        if (e.length === 0 || this.length === 0) return 0;\n\n        if (r < 0) {\n          throw new RangeError(\"targetStart out of bounds\");\n        }\n\n        if (t < 0 || t >= this.length) throw new RangeError(\"Index out of range\");\n        if (f < 0) throw new RangeError(\"sourceEnd out of bounds\");\n        if (f > this.length) f = this.length;\n\n        if (e.length - r < f - t) {\n          f = e.length - r + t;\n        }\n\n        var n = f - t;\n\n        if (this === e && typeof Uint8Array.prototype.copyWithin === \"function\") {\n          this.copyWithin(r, t, f);\n        } else if (this === e && t < r && r < f) {\n          for (var i = n - 1; i >= 0; --i) {\n            e[i + r] = this[i + t];\n          }\n        } else {\n          Uint8Array.prototype.set.call(e, this.subarray(t, f), r);\n        }\n\n        return n;\n      };\n\n      Buffer.prototype.fill = function fill(e, r, t, f) {\n        if (typeof e === \"string\") {\n          if (typeof r === \"string\") {\n            f = r;\n            r = 0;\n            t = this.length;\n          } else if (typeof t === \"string\") {\n            f = t;\n            t = this.length;\n          }\n\n          if (f !== undefined && typeof f !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n          }\n\n          if (typeof f === \"string\" && !Buffer.isEncoding(f)) {\n            throw new TypeError(\"Unknown encoding: \" + f);\n          }\n\n          if (e.length === 1) {\n            var n = e.charCodeAt(0);\n\n            if (f === \"utf8\" && n < 128 || f === \"latin1\") {\n              e = n;\n            }\n          }\n        } else if (typeof e === \"number\") {\n          e = e & 255;\n        } else if (typeof e === \"boolean\") {\n          e = Number(e);\n        }\n\n        if (r < 0 || this.length < r || this.length < t) {\n          throw new RangeError(\"Out of range index\");\n        }\n\n        if (t <= r) {\n          return this;\n        }\n\n        r = r >>> 0;\n        t = t === undefined ? this.length : t >>> 0;\n        if (!e) e = 0;\n        var i;\n\n        if (typeof e === \"number\") {\n          for (i = r; i < t; ++i) {\n            this[i] = e;\n          }\n        } else {\n          var o = Buffer.isBuffer(e) ? e : Buffer.from(e, f);\n          var u = o.length;\n\n          if (u === 0) {\n            throw new TypeError('The value \"' + e + '\" is invalid for argument \"value\"');\n          }\n\n          for (i = 0; i < t - r; ++i) {\n            this[i + r] = o[i % u];\n          }\n        }\n\n        return this;\n      };\n\n      var a = /[^+/0-9A-Za-z-_]/g;\n\n      function base64clean(e) {\n        e = e.split(\"=\")[0];\n        e = e.trim().replace(a, \"\");\n        if (e.length < 2) return \"\";\n\n        while (e.length % 4 !== 0) {\n          e = e + \"=\";\n        }\n\n        return e;\n      }\n\n      function utf8ToBytes(e, r) {\n        r = r || Infinity;\n        var t;\n        var f = e.length;\n        var n = null;\n        var i = [];\n\n        for (var o = 0; o < f; ++o) {\n          t = e.charCodeAt(o);\n\n          if (t > 55295 && t < 57344) {\n            if (!n) {\n              if (t > 56319) {\n                if ((r -= 3) > -1) i.push(239, 191, 189);\n                continue;\n              } else if (o + 1 === f) {\n                if ((r -= 3) > -1) i.push(239, 191, 189);\n                continue;\n              }\n\n              n = t;\n              continue;\n            }\n\n            if (t < 56320) {\n              if ((r -= 3) > -1) i.push(239, 191, 189);\n              n = t;\n              continue;\n            }\n\n            t = (n - 55296 << 10 | t - 56320) + 65536;\n          } else if (n) {\n            if ((r -= 3) > -1) i.push(239, 191, 189);\n          }\n\n          n = null;\n\n          if (t < 128) {\n            if ((r -= 1) < 0) break;\n            i.push(t);\n          } else if (t < 2048) {\n            if ((r -= 2) < 0) break;\n            i.push(t >> 6 | 192, t & 63 | 128);\n          } else if (t < 65536) {\n            if ((r -= 3) < 0) break;\n            i.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);\n          } else if (t < 1114112) {\n            if ((r -= 4) < 0) break;\n            i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);\n          } else {\n            throw new Error(\"Invalid code point\");\n          }\n        }\n\n        return i;\n      }\n\n      function asciiToBytes(e) {\n        var r = [];\n\n        for (var t = 0; t < e.length; ++t) {\n          r.push(e.charCodeAt(t) & 255);\n        }\n\n        return r;\n      }\n\n      function utf16leToBytes(e, r) {\n        var t, f, n;\n        var i = [];\n\n        for (var o = 0; o < e.length; ++o) {\n          if ((r -= 2) < 0) break;\n          t = e.charCodeAt(o);\n          f = t >> 8;\n          n = t % 256;\n          i.push(n);\n          i.push(f);\n        }\n\n        return i;\n      }\n\n      function base64ToBytes(e) {\n        return f.toByteArray(base64clean(e));\n      }\n\n      function blitBuffer(e, r, t, f) {\n        for (var n = 0; n < f; ++n) {\n          if (n + t >= r.length || n >= e.length) break;\n          r[n + t] = e[n];\n        }\n\n        return n;\n      }\n\n      function isInstance(e, r) {\n        return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;\n      }\n\n      function numberIsNaN(e) {\n        return e !== e;\n      }\n\n      var s = function () {\n        var e = \"0123456789abcdef\";\n        var r = new Array(256);\n\n        for (var t = 0; t < 16; ++t) {\n          var f = t * 16;\n\n          for (var n = 0; n < 16; ++n) {\n            r[f + n] = e[t] + e[n];\n          }\n        }\n\n        return r;\n      }();\n    },\n    543: function (e, r) {\n      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n      r.read = function (e, r, t, f, n) {\n        var i, o;\n        var u = n * 8 - f - 1;\n        var a = (1 << u) - 1;\n        var s = a >> 1;\n        var h = -7;\n        var c = t ? n - 1 : 0;\n        var l = t ? -1 : 1;\n        var p = e[r + c];\n        c += l;\n        i = p & (1 << -h) - 1;\n        p >>= -h;\n        h += u;\n\n        for (; h > 0; i = i * 256 + e[r + c], c += l, h -= 8) {}\n\n        o = i & (1 << -h) - 1;\n        i >>= -h;\n        h += f;\n\n        for (; h > 0; o = o * 256 + e[r + c], c += l, h -= 8) {}\n\n        if (i === 0) {\n          i = 1 - s;\n        } else if (i === a) {\n          return o ? NaN : (p ? -1 : 1) * Infinity;\n        } else {\n          o = o + Math.pow(2, f);\n          i = i - s;\n        }\n\n        return (p ? -1 : 1) * o * Math.pow(2, i - f);\n      };\n\n      r.write = function (e, r, t, f, n, i) {\n        var o, u, a;\n        var s = i * 8 - n - 1;\n        var h = (1 << s) - 1;\n        var c = h >> 1;\n        var l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var p = f ? 0 : i - 1;\n        var y = f ? 1 : -1;\n        var g = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;\n        r = Math.abs(r);\n\n        if (isNaN(r) || r === Infinity) {\n          u = isNaN(r) ? 1 : 0;\n          o = h;\n        } else {\n          o = Math.floor(Math.log(r) / Math.LN2);\n\n          if (r * (a = Math.pow(2, -o)) < 1) {\n            o--;\n            a *= 2;\n          }\n\n          if (o + c >= 1) {\n            r += l / a;\n          } else {\n            r += l * Math.pow(2, 1 - c);\n          }\n\n          if (r * a >= 2) {\n            o++;\n            a /= 2;\n          }\n\n          if (o + c >= h) {\n            u = 0;\n            o = h;\n          } else if (o + c >= 1) {\n            u = (r * a - 1) * Math.pow(2, n);\n            o = o + c;\n          } else {\n            u = r * Math.pow(2, c - 1) * Math.pow(2, n);\n            o = 0;\n          }\n        }\n\n        for (; n >= 8; e[t + p] = u & 255, p += y, u /= 256, n -= 8) {}\n\n        o = o << n | u;\n        s += n;\n\n        for (; s > 0; e[t + p] = o & 255, p += y, o /= 256, s -= 8) {}\n\n        e[t + p - y] |= g * 128;\n      };\n    }\n  };\n  var r = {};\n\n  function __nccwpck_require__(t) {\n    var f = r[t];\n\n    if (f !== undefined) {\n      return f.exports;\n    }\n\n    var n = r[t] = {\n      exports: {}\n    };\n    var i = true;\n\n    try {\n      e[t](n, n.exports, __nccwpck_require__);\n      i = false;\n    } finally {\n      if (i) delete r[t];\n    }\n\n    return n.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var t = __nccwpck_require__(877);\n\n  module.exports = t;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2J1ZmZlci9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsQ0FBQyxZQUFVO0VBQUMsSUFBSUEsQ0FBQyxHQUFDO0lBQUMsS0FBSSxVQUFTQSxDQUFULEVBQVdDLENBQVgsRUFBYTtNQUFDOztNQUFhQSxDQUFDLENBQUNDLFVBQUYsR0FBYUEsVUFBYjtNQUF3QkQsQ0FBQyxDQUFDRSxXQUFGLEdBQWNBLFdBQWQ7TUFBMEJGLENBQUMsQ0FBQ0csYUFBRixHQUFnQkEsYUFBaEI7TUFBOEIsSUFBSUMsQ0FBQyxHQUFDLEVBQU47TUFBUyxJQUFJQyxDQUFDLEdBQUMsRUFBTjtNQUFTLElBQUlDLENBQUMsR0FBQyxPQUFPQyxVQUFQLEtBQW9CLFdBQXBCLEdBQWdDQSxVQUFoQyxHQUEyQ0MsS0FBakQ7TUFBdUQsSUFBSUMsQ0FBQyxHQUFDLGtFQUFOOztNQUF5RSxLQUFJLElBQUlDLENBQUMsR0FBQyxDQUFOLEVBQVFDLENBQUMsR0FBQ0YsQ0FBQyxDQUFDRyxNQUFoQixFQUF1QkYsQ0FBQyxHQUFDQyxDQUF6QixFQUEyQixFQUFFRCxDQUE3QixFQUErQjtRQUFDTixDQUFDLENBQUNNLENBQUQsQ0FBRCxHQUFLRCxDQUFDLENBQUNDLENBQUQsQ0FBTjtRQUFVTCxDQUFDLENBQUNJLENBQUMsQ0FBQ0ksVUFBRixDQUFhSCxDQUFiLENBQUQsQ0FBRCxHQUFtQkEsQ0FBbkI7TUFBcUI7O01BQUFMLENBQUMsQ0FBQyxJQUFJUSxVQUFKLENBQWUsQ0FBZixDQUFELENBQUQsR0FBcUIsRUFBckI7TUFBd0JSLENBQUMsQ0FBQyxJQUFJUSxVQUFKLENBQWUsQ0FBZixDQUFELENBQUQsR0FBcUIsRUFBckI7O01BQXdCLFNBQVNDLE9BQVQsQ0FBaUJmLENBQWpCLEVBQW1CO1FBQUMsSUFBSUMsQ0FBQyxHQUFDRCxDQUFDLENBQUNhLE1BQVI7O1FBQWUsSUFBR1osQ0FBQyxHQUFDLENBQUYsR0FBSSxDQUFQLEVBQVM7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ZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2J1ZmZlci9pbmRleC5qcz8zNzc2Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXs0NDk6ZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtyLnRvQnl0ZUFycmF5PXRvQnl0ZUFycmF5O3IuZnJvbUJ5dGVBcnJheT1mcm9tQnl0ZUFycmF5O3ZhciB0PVtdO3ZhciBmPVtdO3ZhciBuPXR5cGVvZiBVaW50OEFycmF5IT09XCJ1bmRlZmluZWRcIj9VaW50OEFycmF5OkFycmF5O3ZhciBpPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO2Zvcih2YXIgbz0wLHU9aS5sZW5ndGg7bzx1Oysrbyl7dFtvXT1pW29dO2ZbaS5jaGFyQ29kZUF0KG8pXT1vfWZbXCItXCIuY2hhckNvZGVBdCgwKV09NjI7ZltcIl9cIi5jaGFyQ29kZUF0KDApXT02MztmdW5jdGlvbiBnZXRMZW5zKGUpe3ZhciByPWUubGVuZ3RoO2lmKHIlND4wKXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpfXZhciB0PWUuaW5kZXhPZihcIj1cIik7aWYodD09PS0xKXQ9cjt2YXIgZj10PT09cj8wOjQtdCU0O3JldHVyblt0LGZdfWZ1bmN0aW9uIGJ5dGVMZW5ndGgoZSl7dmFyIHI9Z2V0TGVucyhlKTt2YXIgdD1yWzBdO3ZhciBmPXJbMV07cmV0dXJuKHQrZikqMy80LWZ9ZnVuY3Rpb24gX2J5dGVMZW5ndGgoZSxyLHQpe3JldHVybihyK3QpKjMvNC10fWZ1bmN0aW9uIHRvQnl0ZUFycmF5KGUpe3ZhciByO3ZhciB0PWdldExlbnMoZSk7dmFyIGk9dFswXTt2YXIgbz10WzFdO3ZhciB1PW5ldyBuKF9ieXRlTGVuZ3RoKGUsaSxvKSk7dmFyIGE9MDt2YXIgcz1vPjA/aS00Omk7dmFyIGg7Zm9yKGg9MDtoPHM7aCs9NCl7cj1mW2UuY2hhckNvZGVBdChoKV08PDE4fGZbZS5jaGFyQ29kZUF0KGgrMSldPDwxMnxmW2UuY2hhckNvZGVBdChoKzIpXTw8NnxmW2UuY2hhckNvZGVBdChoKzMpXTt1W2ErK109cj4+MTYmMjU1O3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9aWYobz09PTIpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwyfGZbZS5jaGFyQ29kZUF0KGgrMSldPj40O3VbYSsrXT1yJjI1NX1pZihvPT09MSl7cj1mW2UuY2hhckNvZGVBdChoKV08PDEwfGZbZS5jaGFyQ29kZUF0KGgrMSldPDw0fGZbZS5jaGFyQ29kZUF0KGgrMildPj4yO3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9cmV0dXJuIHV9ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KGUpe3JldHVybiB0W2U+PjE4JjYzXSt0W2U+PjEyJjYzXSt0W2U+PjYmNjNdK3RbZSY2M119ZnVuY3Rpb24gZW5jb2RlQ2h1bmsoZSxyLHQpe3ZhciBmO3ZhciBuPVtdO2Zvcih2YXIgaT1yO2k8dDtpKz0zKXtmPShlW2ldPDwxNiYxNjcxMTY4MCkrKGVbaSsxXTw8OCY2NTI4MCkrKGVbaSsyXSYyNTUpO24ucHVzaCh0cmlwbGV0VG9CYXNlNjQoZikpfXJldHVybiBuLmpvaW4oXCJcIil9ZnVuY3Rpb24gZnJvbUJ5dGVBcnJheShlKXt2YXIgcjt2YXIgZj1lLmxlbmd0aDt2YXIgbj1mJTM7dmFyIGk9W107dmFyIG89MTYzODM7Zm9yKHZhciB1PTAsYT1mLW47dTxhO3UrPW8pe2kucHVzaChlbmNvZGVDaHVuayhlLHUsdStvPmE/YTp1K28pKX1pZihuPT09MSl7cj1lW2YtMV07aS5wdXNoKHRbcj4+Ml0rdFtyPDw0JjYzXStcIj09XCIpfWVsc2UgaWYobj09PTIpe3I9KGVbZi0yXTw8OCkrZVtmLTFdO2kucHVzaCh0W3I+PjEwXSt0W3I+PjQmNjNdK3Rbcjw8MiY2M10rXCI9XCIpfXJldHVybiBpLmpvaW4oXCJcIil9fSw4Nzc6ZnVuY3Rpb24oZSxyLHQpe1widXNlIHN0cmljdFwiO1xyXG4vKiFcclxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXHJcbiAqXHJcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XHJcbiAqIEBsaWNlbnNlICBNSVRcclxuICovdmFyIGY9dCg0NDkpO3ZhciBuPXQoNTQzKTt2YXIgaT10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLmZvcj09PVwiZnVuY3Rpb25cIj9TeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIik6bnVsbDtyLkJ1ZmZlcj1CdWZmZXI7ci5TbG93QnVmZmVyPVNsb3dCdWZmZXI7ci5JTlNQRUNUX01BWF9CWVRFUz01MDt2YXIgbz0yMTQ3NDgzNjQ3O3Iua01heExlbmd0aD1vO0J1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUPXR5cGVkQXJyYXlTdXBwb3J0KCk7aWYoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUJiZ0eXBlb2YgY29uc29sZSE9PVwidW5kZWZpbmVkXCImJnR5cGVvZiBjb25zb2xlLmVycm9yPT09XCJmdW5jdGlvblwiKXtjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5IFwiK1wiYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC5cIil9ZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQoKXt0cnl7dmFyIGU9bmV3IFVpbnQ4QXJyYXkoMSk7dmFyIHI9e2ZvbzpmdW5jdGlvbigpe3JldHVybiA0Mn19O09iamVjdC5zZXRQcm90b3R5cGVPZihyLFVpbnQ4QXJyYXkucHJvdG90eXBlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoZSxyKTtyZXR1cm4gZS5mb28oKT09PTQyfWNhdGNoKGUpe3JldHVybiBmYWxzZX19T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsXCJwYXJlbnRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe2lmKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpcmV0dXJuIHVuZGVmaW5lZDtyZXR1cm4gdGhpcy5idWZmZXJ9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsXCJvZmZzZXRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe2lmKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpcmV0dXJuIHVuZGVmaW5lZDtyZXR1cm4gdGhpcy5ieXRlT2Zmc2V0fX0pO2Z1bmN0aW9uIGNyZWF0ZUJ1ZmZlcihlKXtpZihlPm8pe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpfXZhciByPW5ldyBVaW50OEFycmF5KGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihyLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiByfWZ1bmN0aW9uIEJ1ZmZlcihlLHIsdCl7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtpZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyl9cmV0dXJuIGFsbG9jVW5zYWZlKGUpfXJldHVybiBmcm9tKGUscix0KX1CdWZmZXIucG9vbFNpemU9ODE5MjtmdW5jdGlvbiBmcm9tKGUscix0KXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBmcm9tU3RyaW5nKGUscil9aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpKXtyZXR1cm4gZnJvbUFycmF5TGlrZShlKX1pZihlPT1udWxsKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgXCIrXCJvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9aWYoaXNJbnN0YW5jZShlLEFycmF5QnVmZmVyKXx8ZSYmaXNJbnN0YW5jZShlLmJ1ZmZlcixBcnJheUJ1ZmZlcikpe3JldHVybiBmcm9tQXJyYXlCdWZmZXIoZSxyLHQpfWlmKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCImJihpc0luc3RhbmNlKGUsU2hhcmVkQXJyYXlCdWZmZXIpfHxlJiZpc0luc3RhbmNlKGUuYnVmZmVyLFNoYXJlZEFycmF5QnVmZmVyKSkpe3JldHVybiBmcm9tQXJyYXlCdWZmZXIoZSxyLHQpfWlmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKX12YXIgZj1lLnZhbHVlT2YmJmUudmFsdWVPZigpO2lmKGYhPW51bGwmJmYhPT1lKXtyZXR1cm4gQnVmZmVyLmZyb20oZixyLHQpfXZhciBuPWZyb21PYmplY3QoZSk7aWYobilyZXR1cm4gbjtpZih0eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIiYmU3ltYm9sLnRvUHJpbWl0aXZlIT1udWxsJiZ0eXBlb2YgZVtTeW1ib2wudG9QcmltaXRpdmVdPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gQnVmZmVyLmZyb20oZVtTeW1ib2wudG9QcmltaXRpdmVdKFwic3RyaW5nXCIpLHIsdCl9dGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIFwiK1wib3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfUJ1ZmZlci5mcm9tPWZ1bmN0aW9uKGUscix0KXtyZXR1cm4gZnJvbShlLHIsdCl9O09iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLFVpbnQ4QXJyYXkucHJvdG90eXBlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLFVpbnQ4QXJyYXkpO2Z1bmN0aW9uIGFzc2VydFNpemUoZSl7aWYodHlwZW9mIGUhPT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJyl9ZWxzZSBpZihlPDApe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpfX1mdW5jdGlvbiBhbGxvYyhlLHIsdCl7YXNzZXJ0U2l6ZShlKTtpZihlPD0wKXtyZXR1cm4gY3JlYXRlQnVmZmVyKGUpfWlmKHIhPT11bmRlZmluZWQpe3JldHVybiB0eXBlb2YgdD09PVwic3RyaW5nXCI/Y3JlYXRlQnVmZmVyKGUpLmZpbGwocix0KTpjcmVhdGVCdWZmZXIoZSkuZmlsbChyKX1yZXR1cm4gY3JlYXRlQnVmZmVyKGUpfUJ1ZmZlci5hbGxvYz1mdW5jdGlvbihlLHIsdCl7cmV0dXJuIGFsbG9jKGUscix0KX07ZnVuY3Rpb24gYWxsb2NVbnNhZmUoZSl7YXNzZXJ0U2l6ZShlKTtyZXR1cm4gY3JlYXRlQnVmZmVyKGU8MD8wOmNoZWNrZWQoZSl8MCl9QnVmZmVyLmFsbG9jVW5zYWZlPWZ1bmN0aW9uKGUpe3JldHVybiBhbGxvY1Vuc2FmZShlKX07QnVmZmVyLmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbihlKXtyZXR1cm4gYWxsb2NVbnNhZmUoZSl9O2Z1bmN0aW9uIGZyb21TdHJpbmcoZSxyKXtpZih0eXBlb2YgciE9PVwic3RyaW5nXCJ8fHI9PT1cIlwiKXtyPVwidXRmOFwifWlmKCFCdWZmZXIuaXNFbmNvZGluZyhyKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3IpfXZhciB0PWJ5dGVMZW5ndGgoZSxyKXwwO3ZhciBmPWNyZWF0ZUJ1ZmZlcih0KTt2YXIgbj1mLndyaXRlKGUscik7aWYobiE9PXQpe2Y9Zi5zbGljZSgwLG4pfXJldHVybiBmfWZ1bmN0aW9uIGZyb21BcnJheUxpa2UoZSl7dmFyIHI9ZS5sZW5ndGg8MD8wOmNoZWNrZWQoZS5sZW5ndGgpfDA7dmFyIHQ9Y3JlYXRlQnVmZmVyKHIpO2Zvcih2YXIgZj0wO2Y8cjtmKz0xKXt0W2ZdPWVbZl0mMjU1fXJldHVybiB0fWZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl7aWYocjwwfHxlLmJ5dGVMZW5ndGg8cil7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyl9aWYoZS5ieXRlTGVuZ3RoPHIrKHR8fDApKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKX12YXIgZjtpZihyPT09dW5kZWZpbmVkJiZ0PT09dW5kZWZpbmVkKXtmPW5ldyBVaW50OEFycmF5KGUpfWVsc2UgaWYodD09PXVuZGVmaW5lZCl7Zj1uZXcgVWludDhBcnJheShlLHIpfWVsc2V7Zj1uZXcgVWludDhBcnJheShlLHIsdCl9T2JqZWN0LnNldFByb3RvdHlwZU9mKGYsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIGZ9ZnVuY3Rpb24gZnJvbU9iamVjdChlKXtpZihCdWZmZXIuaXNCdWZmZXIoZSkpe3ZhciByPWNoZWNrZWQoZS5sZW5ndGgpfDA7dmFyIHQ9Y3JlYXRlQnVmZmVyKHIpO2lmKHQubGVuZ3RoPT09MCl7cmV0dXJuIHR9ZS5jb3B5KHQsMCwwLHIpO3JldHVybiB0fWlmKGUubGVuZ3RoIT09dW5kZWZpbmVkKXtpZih0eXBlb2YgZS5sZW5ndGghPT1cIm51bWJlclwifHxudW1iZXJJc05hTihlLmxlbmd0aCkpe3JldHVybiBjcmVhdGVCdWZmZXIoMCl9cmV0dXJuIGZyb21BcnJheUxpa2UoZSl9aWYoZS50eXBlPT09XCJCdWZmZXJcIiYmQXJyYXkuaXNBcnJheShlLmRhdGEpKXtyZXR1cm4gZnJvbUFycmF5TGlrZShlLmRhdGEpfX1mdW5jdGlvbiBjaGVja2VkKGUpe2lmKGU+PW8pe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBcIitcInNpemU6IDB4XCIrby50b1N0cmluZygxNikrXCIgYnl0ZXNcIil9cmV0dXJuIGV8MH1mdW5jdGlvbiBTbG93QnVmZmVyKGUpe2lmKCtlIT1lKXtlPTB9cmV0dXJuIEJ1ZmZlci5hbGxvYygrZSl9QnVmZmVyLmlzQnVmZmVyPWZ1bmN0aW9uIGlzQnVmZmVyKGUpe3JldHVybiBlIT1udWxsJiZlLl9pc0J1ZmZlcj09PXRydWUmJmUhPT1CdWZmZXIucHJvdG90eXBlfTtCdWZmZXIuY29tcGFyZT1mdW5jdGlvbiBjb21wYXJlKGUscil7aWYoaXNJbnN0YW5jZShlLFVpbnQ4QXJyYXkpKWU9QnVmZmVyLmZyb20oZSxlLm9mZnNldCxlLmJ5dGVMZW5ndGgpO2lmKGlzSW5zdGFuY2UocixVaW50OEFycmF5KSlyPUJ1ZmZlci5mcm9tKHIsci5vZmZzZXQsci5ieXRlTGVuZ3RoKTtpZighQnVmZmVyLmlzQnVmZmVyKGUpfHwhQnVmZmVyLmlzQnVmZmVyKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5Jyl9aWYoZT09PXIpcmV0dXJuIDA7dmFyIHQ9ZS5sZW5ndGg7dmFyIGY9ci5sZW5ndGg7Zm9yKHZhciBuPTAsaT1NYXRoLm1pbih0LGYpO248aTsrK24pe2lmKGVbbl0hPT1yW25dKXt0PWVbbl07Zj1yW25dO2JyZWFrfX1pZih0PGYpcmV0dXJuLTE7aWYoZjx0KXJldHVybiAxO3JldHVybiAwfTtCdWZmZXIuaXNFbmNvZGluZz1mdW5jdGlvbiBpc0VuY29kaW5nKGUpe3N3aXRjaChTdHJpbmcoZSkudG9Mb3dlckNhc2UoKSl7Y2FzZVwiaGV4XCI6Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpjYXNlXCJiYXNlNjRcIjpjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdHJ1ZTtkZWZhdWx0OnJldHVybiBmYWxzZX19O0J1ZmZlci5jb25jYXQ9ZnVuY3Rpb24gY29uY2F0KGUscil7aWYoIUFycmF5LmlzQXJyYXkoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpfWlmKGUubGVuZ3RoPT09MCl7cmV0dXJuIEJ1ZmZlci5hbGxvYygwKX12YXIgdDtpZihyPT09dW5kZWZpbmVkKXtyPTA7Zm9yKHQ9MDt0PGUubGVuZ3RoOysrdCl7cis9ZVt0XS5sZW5ndGh9fXZhciBmPUJ1ZmZlci5hbGxvY1Vuc2FmZShyKTt2YXIgbj0wO2Zvcih0PTA7dDxlLmxlbmd0aDsrK3Qpe3ZhciBpPWVbdF07aWYoaXNJbnN0YW5jZShpLFVpbnQ4QXJyYXkpKXtpPUJ1ZmZlci5mcm9tKGkpfWlmKCFCdWZmZXIuaXNCdWZmZXIoaSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpfWkuY29weShmLG4pO24rPWkubGVuZ3RofXJldHVybiBmfTtmdW5jdGlvbiBieXRlTGVuZ3RoKGUscil7aWYoQnVmZmVyLmlzQnVmZmVyKGUpKXtyZXR1cm4gZS5sZW5ndGh9aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpfHxpc0luc3RhbmNlKGUsQXJyYXlCdWZmZXIpKXtyZXR1cm4gZS5ieXRlTGVuZ3RofWlmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcrXCJSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX12YXIgdD1lLmxlbmd0aDt2YXIgZj1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXT09PXRydWU7aWYoIWYmJnQ9PT0wKXJldHVybiAwO3ZhciBuPWZhbHNlO2Zvcig7Oyl7c3dpdGNoKHIpe2Nhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIHQ7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhUb0J5dGVzKGUpLmxlbmd0aDtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdCoyO2Nhc2VcImhleFwiOnJldHVybiB0Pj4+MTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0VG9CeXRlcyhlKS5sZW5ndGg7ZGVmYXVsdDppZihuKXtyZXR1cm4gZj8tMTp1dGY4VG9CeXRlcyhlKS5sZW5ndGh9cj0oXCJcIityKS50b0xvd2VyQ2FzZSgpO249dHJ1ZX19fUJ1ZmZlci5ieXRlTGVuZ3RoPWJ5dGVMZW5ndGg7ZnVuY3Rpb24gc2xvd1RvU3RyaW5nKGUscix0KXt2YXIgZj1mYWxzZTtpZihyPT09dW5kZWZpbmVkfHxyPDApe3I9MH1pZihyPnRoaXMubGVuZ3RoKXtyZXR1cm5cIlwifWlmKHQ9PT11bmRlZmluZWR8fHQ+dGhpcy5sZW5ndGgpe3Q9dGhpcy5sZW5ndGh9aWYodDw9MCl7cmV0dXJuXCJcIn10Pj4+PTA7cj4+Pj0wO2lmKHQ8PXIpe3JldHVyblwiXCJ9aWYoIWUpZT1cInV0ZjhcIjt3aGlsZSh0cnVlKXtzd2l0Y2goZSl7Y2FzZVwiaGV4XCI6cmV0dXJuIGhleFNsaWNlKHRoaXMscix0KTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFNsaWNlKHRoaXMscix0KTtjYXNlXCJhc2NpaVwiOnJldHVybiBhc2NpaVNsaWNlKHRoaXMscix0KTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gbGF0aW4xU2xpY2UodGhpcyxyLHQpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRTbGljZSh0aGlzLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLHIsdCk7ZGVmYXVsdDppZihmKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitlKTtlPShlK1wiXCIpLnRvTG93ZXJDYXNlKCk7Zj10cnVlfX19QnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXI9dHJ1ZTtmdW5jdGlvbiBzd2FwKGUscix0KXt2YXIgZj1lW3JdO2Vbcl09ZVt0XTtlW3RdPWZ9QnVmZmVyLnByb3RvdHlwZS5zd2FwMTY9ZnVuY3Rpb24gc3dhcDE2KCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSUyIT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9Mil7c3dhcCh0aGlzLHIscisxKX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS5zd2FwMzI9ZnVuY3Rpb24gc3dhcDMyKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU0IT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9NCl7c3dhcCh0aGlzLHIsciszKTtzd2FwKHRoaXMscisxLHIrMil9cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUuc3dhcDY0PWZ1bmN0aW9uIHN3YXA2NCgpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlOCE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHNcIil9Zm9yKHZhciByPTA7cjxlO3IrPTgpe3N3YXAodGhpcyxyLHIrNyk7c3dhcCh0aGlzLHIrMSxyKzYpO3N3YXAodGhpcyxyKzIscis1KTtzd2FwKHRoaXMsciszLHIrNCl9cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24gdG9TdHJpbmcoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlPT09MClyZXR1cm5cIlwiO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0wKXJldHVybiB1dGY4U2xpY2UodGhpcywwLGUpO3JldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtCdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nPUJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc7QnVmZmVyLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24gZXF1YWxzKGUpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7aWYodGhpcz09PWUpcmV0dXJuIHRydWU7cmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsZSk9PT0wfTtCdWZmZXIucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24gaW5zcGVjdCgpe3ZhciBlPVwiXCI7dmFyIHQ9ci5JTlNQRUNUX01BWF9CWVRFUztlPXRoaXMudG9TdHJpbmcoXCJoZXhcIiwwLHQpLnJlcGxhY2UoLyguezJ9KS9nLFwiJDEgXCIpLnRyaW0oKTtpZih0aGlzLmxlbmd0aD50KWUrPVwiIC4uLiBcIjtyZXR1cm5cIjxCdWZmZXIgXCIrZStcIj5cIn07aWYoaSl7QnVmZmVyLnByb3RvdHlwZVtpXT1CdWZmZXIucHJvdG90eXBlLmluc3BlY3R9QnVmZmVyLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uIGNvbXBhcmUoZSxyLHQsZixuKXtpZihpc0luc3RhbmNlKGUsVWludDhBcnJheSkpe2U9QnVmZmVyLmZyb20oZSxlLm9mZnNldCxlLmJ5dGVMZW5ndGgpfWlmKCFCdWZmZXIuaXNCdWZmZXIoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcrXCJSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1pZihyPT09dW5kZWZpbmVkKXtyPTB9aWYodD09PXVuZGVmaW5lZCl7dD1lP2UubGVuZ3RoOjB9aWYoZj09PXVuZGVmaW5lZCl7Zj0wfWlmKG49PT11bmRlZmluZWQpe249dGhpcy5sZW5ndGh9aWYocjwwfHx0PmUubGVuZ3RofHxmPDB8fG4+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJhbmdlIGluZGV4XCIpfWlmKGY+PW4mJnI+PXQpe3JldHVybiAwfWlmKGY+PW4pe3JldHVybi0xfWlmKHI+PXQpe3JldHVybiAxfXI+Pj49MDt0Pj4+PTA7Zj4+Pj0wO24+Pj49MDtpZih0aGlzPT09ZSlyZXR1cm4gMDt2YXIgaT1uLWY7dmFyIG89dC1yO3ZhciB1PU1hdGgubWluKGksbyk7dmFyIGE9dGhpcy5zbGljZShmLG4pO3ZhciBzPWUuc2xpY2Uocix0KTtmb3IodmFyIGg9MDtoPHU7KytoKXtpZihhW2hdIT09c1toXSl7aT1hW2hdO289c1toXTticmVha319aWYoaTxvKXJldHVybi0xO2lmKG88aSlyZXR1cm4gMTtyZXR1cm4gMH07ZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YoZSxyLHQsZixuKXtpZihlLmxlbmd0aD09PTApcmV0dXJuLTE7aWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtmPXQ7dD0wfWVsc2UgaWYodD4yMTQ3NDgzNjQ3KXt0PTIxNDc0ODM2NDd9ZWxzZSBpZih0PC0yMTQ3NDgzNjQ4KXt0PS0yMTQ3NDgzNjQ4fXQ9K3Q7aWYobnVtYmVySXNOYU4odCkpe3Q9bj8wOmUubGVuZ3RoLTF9aWYodDwwKXQ9ZS5sZW5ndGgrdDtpZih0Pj1lLmxlbmd0aCl7aWYobilyZXR1cm4tMTtlbHNlIHQ9ZS5sZW5ndGgtMX1lbHNlIGlmKHQ8MCl7aWYobil0PTA7ZWxzZSByZXR1cm4tMX1pZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe3I9QnVmZmVyLmZyb20ocixmKX1pZihCdWZmZXIuaXNCdWZmZXIocikpe2lmKHIubGVuZ3RoPT09MCl7cmV0dXJuLTF9cmV0dXJuIGFycmF5SW5kZXhPZihlLHIsdCxmLG4pfWVsc2UgaWYodHlwZW9mIHI9PT1cIm51bWJlclwiKXtyPXImMjU1O2lmKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mPT09XCJmdW5jdGlvblwiKXtpZihuKXtyZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGUscix0KX1lbHNle3JldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGUscix0KX19cmV0dXJuIGFycmF5SW5kZXhPZihlLFtyXSx0LGYsbil9dGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlclwiKX1mdW5jdGlvbiBhcnJheUluZGV4T2YoZSxyLHQsZixuKXt2YXIgaT0xO3ZhciBvPWUubGVuZ3RoO3ZhciB1PXIubGVuZ3RoO2lmKGYhPT11bmRlZmluZWQpe2Y9U3RyaW5nKGYpLnRvTG93ZXJDYXNlKCk7aWYoZj09PVwidWNzMlwifHxmPT09XCJ1Y3MtMlwifHxmPT09XCJ1dGYxNmxlXCJ8fGY9PT1cInV0Zi0xNmxlXCIpe2lmKGUubGVuZ3RoPDJ8fHIubGVuZ3RoPDIpe3JldHVybi0xfWk9MjtvLz0yO3UvPTI7dC89Mn19ZnVuY3Rpb24gcmVhZChlLHIpe2lmKGk9PT0xKXtyZXR1cm4gZVtyXX1lbHNle3JldHVybiBlLnJlYWRVSW50MTZCRShyKmkpfX12YXIgYTtpZihuKXt2YXIgcz0tMTtmb3IoYT10O2E8bzthKyspe2lmKHJlYWQoZSxhKT09PXJlYWQocixzPT09LTE/MDphLXMpKXtpZihzPT09LTEpcz1hO2lmKGEtcysxPT09dSlyZXR1cm4gcyppfWVsc2V7aWYocyE9PS0xKWEtPWEtcztzPS0xfX19ZWxzZXtpZih0K3U+byl0PW8tdTtmb3IoYT10O2E+PTA7YS0tKXt2YXIgaD10cnVlO2Zvcih2YXIgYz0wO2M8dTtjKyspe2lmKHJlYWQoZSxhK2MpIT09cmVhZChyLGMpKXtoPWZhbHNlO2JyZWFrfX1pZihoKXJldHVybiBhfX1yZXR1cm4tMX1CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzPWZ1bmN0aW9uIGluY2x1ZGVzKGUscix0KXtyZXR1cm4gdGhpcy5pbmRleE9mKGUscix0KSE9PS0xfTtCdWZmZXIucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24gaW5kZXhPZihlLHIsdCl7cmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsZSxyLHQsdHJ1ZSl9O0J1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2Y9ZnVuY3Rpb24gbGFzdEluZGV4T2YoZSxyLHQpe3JldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLGUscix0LGZhbHNlKX07ZnVuY3Rpb24gaGV4V3JpdGUoZSxyLHQsZil7dD1OdW1iZXIodCl8fDA7dmFyIG49ZS5sZW5ndGgtdDtpZighZil7Zj1ufWVsc2V7Zj1OdW1iZXIoZik7aWYoZj5uKXtmPW59fXZhciBpPXIubGVuZ3RoO2lmKGY+aS8yKXtmPWkvMn1mb3IodmFyIG89MDtvPGY7KytvKXt2YXIgdT1wYXJzZUludChyLnN1YnN0cihvKjIsMiksMTYpO2lmKG51bWJlcklzTmFOKHUpKXJldHVybiBvO2VbdCtvXT11fXJldHVybiBvfWZ1bmN0aW9uIHV0ZjhXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhyLGUubGVuZ3RoLXQpLGUsdCxmKX1mdW5jdGlvbiBhc2NpaVdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhyKSxlLHQsZil9ZnVuY3Rpb24gbGF0aW4xV3JpdGUoZSxyLHQsZil7cmV0dXJuIGFzY2lpV3JpdGUoZSxyLHQsZil9ZnVuY3Rpb24gYmFzZTY0V3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhyKSxlLHQsZil9ZnVuY3Rpb24gdWNzMldyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHIsZS5sZW5ndGgtdCksZSx0LGYpfUJ1ZmZlci5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24gd3JpdGUoZSxyLHQsZil7aWYocj09PXVuZGVmaW5lZCl7Zj1cInV0ZjhcIjt0PXRoaXMubGVuZ3RoO3I9MH1lbHNlIGlmKHQ9PT11bmRlZmluZWQmJnR5cGVvZiByPT09XCJzdHJpbmdcIil7Zj1yO3Q9dGhpcy5sZW5ndGg7cj0wfWVsc2UgaWYoaXNGaW5pdGUocikpe3I9cj4+PjA7aWYoaXNGaW5pdGUodCkpe3Q9dD4+PjA7aWYoZj09PXVuZGVmaW5lZClmPVwidXRmOFwifWVsc2V7Zj10O3Q9dW5kZWZpbmVkfX1lbHNle3Rocm93IG5ldyBFcnJvcihcIkJ1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCIpfXZhciBuPXRoaXMubGVuZ3RoLXI7aWYodD09PXVuZGVmaW5lZHx8dD5uKXQ9bjtpZihlLmxlbmd0aD4wJiYodDwwfHxyPDApfHxyPnRoaXMubGVuZ3RoKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzXCIpfWlmKCFmKWY9XCJ1dGY4XCI7dmFyIGk9ZmFsc2U7Zm9yKDs7KXtzd2l0Y2goZil7Y2FzZVwiaGV4XCI6cmV0dXJuIGhleFdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gYXNjaWlXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gbGF0aW4xV3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB1Y3MyV3JpdGUodGhpcyxlLHIsdCk7ZGVmYXVsdDppZihpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitmKTtmPShcIlwiK2YpLnRvTG93ZXJDYXNlKCk7aT10cnVlfX19O0J1ZmZlci5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uIHRvSlNPTigpe3JldHVybnt0eXBlOlwiQnVmZmVyXCIsZGF0YTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnJ8fHRoaXMsMCl9fTtmdW5jdGlvbiBiYXNlNjRTbGljZShlLHIsdCl7aWYocj09PTAmJnQ9PT1lLmxlbmd0aCl7cmV0dXJuIGYuZnJvbUJ5dGVBcnJheShlKX1lbHNle3JldHVybiBmLmZyb21CeXRlQXJyYXkoZS5zbGljZShyLHQpKX19ZnVuY3Rpb24gdXRmOFNsaWNlKGUscix0KXt0PU1hdGgubWluKGUubGVuZ3RoLHQpO3ZhciBmPVtdO3ZhciBuPXI7d2hpbGUobjx0KXt2YXIgaT1lW25dO3ZhciBvPW51bGw7dmFyIHU9aT4yMzk/NDppPjIyMz8zOmk+MTkxPzI6MTtpZihuK3U8PXQpe3ZhciBhLHMsaCxjO3N3aXRjaCh1KXtjYXNlIDE6aWYoaTwxMjgpe289aX1icmVhaztjYXNlIDI6YT1lW24rMV07aWYoKGEmMTkyKT09PTEyOCl7Yz0oaSYzMSk8PDZ8YSY2MztpZihjPjEyNyl7bz1jfX1icmVhaztjYXNlIDM6YT1lW24rMV07cz1lW24rMl07aWYoKGEmMTkyKT09PTEyOCYmKHMmMTkyKT09PTEyOCl7Yz0oaSYxNSk8PDEyfChhJjYzKTw8NnxzJjYzO2lmKGM+MjA0NyYmKGM8NTUyOTZ8fGM+NTczNDMpKXtvPWN9fWJyZWFrO2Nhc2UgNDphPWVbbisxXTtzPWVbbisyXTtoPWVbbiszXTtpZigoYSYxOTIpPT09MTI4JiYocyYxOTIpPT09MTI4JiYoaCYxOTIpPT09MTI4KXtjPShpJjE1KTw8MTh8KGEmNjMpPDwxMnwocyY2Myk8PDZ8aCY2MztpZihjPjY1NTM1JiZjPDExMTQxMTIpe289Y319fX1pZihvPT09bnVsbCl7bz02NTUzMzt1PTF9ZWxzZSBpZihvPjY1NTM1KXtvLT02NTUzNjtmLnB1c2gobz4+PjEwJjEwMjN8NTUyOTYpO289NTYzMjB8byYxMDIzfWYucHVzaChvKTtuKz11fXJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoZil9dmFyIHU9NDA5NjtmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoZSl7dmFyIHI9ZS5sZW5ndGg7aWYocjw9dSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGUpfXZhciB0PVwiXCI7dmFyIGY9MDt3aGlsZShmPHIpe3QrPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGUuc2xpY2UoZixmKz11KSl9cmV0dXJuIHR9ZnVuY3Rpb24gYXNjaWlTbGljZShlLHIsdCl7dmFyIGY9XCJcIjt0PU1hdGgubWluKGUubGVuZ3RoLHQpO2Zvcih2YXIgbj1yO248dDsrK24pe2YrPVN0cmluZy5mcm9tQ2hhckNvZGUoZVtuXSYxMjcpfXJldHVybiBmfWZ1bmN0aW9uIGxhdGluMVNsaWNlKGUscix0KXt2YXIgZj1cIlwiO3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7Zm9yKHZhciBuPXI7bjx0Oysrbil7Zis9U3RyaW5nLmZyb21DaGFyQ29kZShlW25dKX1yZXR1cm4gZn1mdW5jdGlvbiBoZXhTbGljZShlLHIsdCl7dmFyIGY9ZS5sZW5ndGg7aWYoIXJ8fHI8MClyPTA7aWYoIXR8fHQ8MHx8dD5mKXQ9Zjt2YXIgbj1cIlwiO2Zvcih2YXIgaT1yO2k8dDsrK2kpe24rPXNbZVtpXV19cmV0dXJuIG59ZnVuY3Rpb24gdXRmMTZsZVNsaWNlKGUscix0KXt2YXIgZj1lLnNsaWNlKHIsdCk7dmFyIG49XCJcIjtmb3IodmFyIGk9MDtpPGYubGVuZ3RoO2krPTIpe24rPVN0cmluZy5mcm9tQ2hhckNvZGUoZltpXStmW2krMV0qMjU2KX1yZXR1cm4gbn1CdWZmZXIucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uIHNsaWNlKGUscil7dmFyIHQ9dGhpcy5sZW5ndGg7ZT1+fmU7cj1yPT09dW5kZWZpbmVkP3Q6fn5yO2lmKGU8MCl7ZSs9dDtpZihlPDApZT0wfWVsc2UgaWYoZT50KXtlPXR9aWYocjwwKXtyKz10O2lmKHI8MClyPTB9ZWxzZSBpZihyPnQpe3I9dH1pZihyPGUpcj1lO3ZhciBmPXRoaXMuc3ViYXJyYXkoZSxyKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoZixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gZn07ZnVuY3Rpb24gY2hlY2tPZmZzZXQoZSxyLHQpe2lmKGUlMSE9PTB8fGU8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm9mZnNldCBpcyBub3QgdWludFwiKTtpZihlK3I+dCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFPWZ1bmN0aW9uIHJlYWRVSW50TEUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCljaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpO3ZhciBmPXRoaXNbZV07dmFyIG49MTt2YXIgaT0wO3doaWxlKCsraTxyJiYobio9MjU2KSl7Zis9dGhpc1tlK2ldKm59cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRT1mdW5jdGlvbiByZWFkVUludEJFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpe2NoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCl9dmFyIGY9dGhpc1tlKy0tcl07dmFyIG49MTt3aGlsZShyPjAmJihuKj0yNTYpKXtmKz10aGlzW2UrLS1yXSpufXJldHVybiBmfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OD1mdW5jdGlvbiByZWFkVUludDgoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMSx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV19O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFPWZ1bmN0aW9uIHJlYWRVSW50MTZMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXXx0aGlzW2UrMV08PDh9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFPWZ1bmN0aW9uIHJlYWRVSW50MTZCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXTw8OHx0aGlzW2UrMV19O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFPWZ1bmN0aW9uIHJlYWRVSW50MzJMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4odGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNikrdGhpc1tlKzNdKjE2Nzc3MjE2fTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRT1mdW5jdGlvbiByZWFkVUludDMyQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV0qMTY3NzcyMTYrKHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXSl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludExFPWZ1bmN0aW9uIHJlYWRJbnRMRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9dGhpc1tlXTt2YXIgbj0xO3ZhciBpPTA7d2hpbGUoKytpPHImJihuKj0yNTYpKXtmKz10aGlzW2UraV0qbn1uKj0xMjg7aWYoZj49bilmLT1NYXRoLnBvdygyLDgqcik7cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludEJFPWZ1bmN0aW9uIHJlYWRJbnRCRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9cjt2YXIgbj0xO3ZhciBpPXRoaXNbZSstLWZdO3doaWxlKGY+MCYmKG4qPTI1Nikpe2krPXRoaXNbZSstLWZdKm59bio9MTI4O2lmKGk+PW4paS09TWF0aC5wb3coMiw4KnIpO3JldHVybiBpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4PWZ1bmN0aW9uIHJlYWRJbnQ4KGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDEsdGhpcy5sZW5ndGgpO2lmKCEodGhpc1tlXSYxMjgpKXJldHVybiB0aGlzW2VdO3JldHVybigyNTUtdGhpc1tlXSsxKSotMX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbiByZWFkSW50MTZMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTt2YXIgdD10aGlzW2VdfHRoaXNbZSsxXTw8ODtyZXR1cm4gdCYzMjc2OD90fDQyOTQ5MDE3NjA6dH07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRT1mdW5jdGlvbiByZWFkSW50MTZCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTt2YXIgdD10aGlzW2UrMV18dGhpc1tlXTw8ODtyZXR1cm4gdCYzMjc2OD90fDQyOTQ5MDE3NjA6dH07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRT1mdW5jdGlvbiByZWFkSW50MzJMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNnx0aGlzW2UrM108PDI0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uIHJlYWRJbnQzMkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdPDwyNHx0aGlzW2UrMV08PDE2fHRoaXNbZSsyXTw8OHx0aGlzW2UrM119O0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEU9ZnVuY3Rpb24gcmVhZEZsb2F0TEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsdHJ1ZSwyMyw0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbiByZWFkRmxvYXRCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSxmYWxzZSwyMyw0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEU9ZnVuY3Rpb24gcmVhZERvdWJsZUxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDgsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLHRydWUsNTIsOCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFPWZ1bmN0aW9uIHJlYWREb3VibGVCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw4LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSxmYWxzZSw1Miw4KX07ZnVuY3Rpb24gY2hlY2tJbnQoZSxyLHQsZixuLGkpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7aWYocj5ufHxyPGkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7aWYodCtmPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEU9ZnVuY3Rpb24gd3JpdGVVSW50TEUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO3Q9dD4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0KS0xO2NoZWNrSW50KHRoaXMsZSxyLHQsbiwwKX12YXIgaT0xO3ZhciBvPTA7dGhpc1tyXT1lJjI1NTt3aGlsZSgrK288dCYmKGkqPTI1Nikpe3RoaXNbcitvXT1lL2kmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24gd3JpdGVVSW50QkUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO3Q9dD4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0KS0xO2NoZWNrSW50KHRoaXMsZSxyLHQsbiwwKX12YXIgaT10LTE7dmFyIG89MTt0aGlzW3IraV09ZSYyNTU7d2hpbGUoLS1pPj0wJiYobyo9MjU2KSl7dGhpc1tyK2ldPWUvbyYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4PWZ1bmN0aW9uIHdyaXRlVUludDgoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwxLDI1NSwwKTt0aGlzW3JdPWUmMjU1O3JldHVybiByKzF9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRT1mdW5jdGlvbiB3cml0ZVVJbnQxNkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiw2NTUzNSwwKTt0aGlzW3JdPWUmMjU1O3RoaXNbcisxXT1lPj4+ODtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24gd3JpdGVVSW50MTZCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsNjU1MzUsMCk7dGhpc1tyXT1lPj4+ODt0aGlzW3IrMV09ZSYyNTU7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlVUludDMyTEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDQyOTQ5NjcyOTUsMCk7dGhpc1tyKzNdPWU+Pj4yNDt0aGlzW3IrMl09ZT4+PjE2O3RoaXNbcisxXT1lPj4+ODt0aGlzW3JdPWUmMjU1O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRT1mdW5jdGlvbiB3cml0ZVVJbnQzMkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCw0Mjk0OTY3Mjk1LDApO3RoaXNbcl09ZT4+PjI0O3RoaXNbcisxXT1lPj4+MTY7dGhpc1tyKzJdPWU+Pj44O3RoaXNbciszXT1lJjI1NTtyZXR1cm4gcis0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24gd3JpdGVJbnRMRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0LTEpO2NoZWNrSW50KHRoaXMsZSxyLHQsbi0xLC1uKX12YXIgaT0wO3ZhciBvPTE7dmFyIHU9MDt0aGlzW3JdPWUmMjU1O3doaWxlKCsraTx0JiYobyo9MjU2KSl7aWYoZTwwJiZ1PT09MCYmdGhpc1tyK2ktMV0hPT0wKXt1PTF9dGhpc1tyK2ldPShlL28+PjApLXUmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRT1mdW5jdGlvbiB3cml0ZUludEJFKGUscix0LGYpe2U9K2U7cj1yPj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQtMSk7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLTEsLW4pfXZhciBpPXQtMTt2YXIgbz0xO3ZhciB1PTA7dGhpc1tyK2ldPWUmMjU1O3doaWxlKC0taT49MCYmKG8qPTI1Nikpe2lmKGU8MCYmdT09PTAmJnRoaXNbcitpKzFdIT09MCl7dT0xfXRoaXNbcitpXT0oZS9vPj4wKS11JjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbiB3cml0ZUludDgoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwxLDEyNywtMTI4KTtpZihlPDApZT0yNTUrZSsxO3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrMX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEU9ZnVuY3Rpb24gd3JpdGVJbnQxNkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiwzMjc2NywtMzI3NjgpO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFPWZ1bmN0aW9uIHdyaXRlSW50MTZCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsMzI3NjcsLTMyNzY4KTt0aGlzW3JdPWU+Pj44O3RoaXNbcisxXT1lJjI1NTtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbiB3cml0ZUludDMyTEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3RoaXNbcisyXT1lPj4+MTY7dGhpc1tyKzNdPWU+Pj4yNDtyZXR1cm4gcis0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRT1mdW5jdGlvbiB3cml0ZUludDMyQkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpO2lmKGU8MCllPTQyOTQ5NjcyOTUrZSsxO3RoaXNbcl09ZT4+PjI0O3RoaXNbcisxXT1lPj4+MTY7dGhpc1tyKzJdPWU+Pj44O3RoaXNbciszXT1lJjI1NTtyZXR1cm4gcis0fTtmdW5jdGlvbiBjaGVja0lFRUU3NTQoZSxyLHQsZixuLGkpe2lmKHQrZj5lLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZih0PDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gd3JpdGVGbG9hdChlLHIsdCxmLGkpe3I9K3I7dD10Pj4+MDtpZighaSl7Y2hlY2tJRUVFNzU0KGUscix0LDQsMzQwMjgyMzQ2NjM4NTI4ODZlMjIsLTM0MDI4MjM0NjYzODUyODg2ZTIyKX1uLndyaXRlKGUscix0LGYsMjMsNCk7cmV0dXJuIHQrNH1CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRT1mdW5jdGlvbiB3cml0ZUZsb2F0TEUoZSxyLHQpe3JldHVybiB3cml0ZUZsb2F0KHRoaXMsZSxyLHRydWUsdCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFPWZ1bmN0aW9uIHdyaXRlRmxvYXRCRShlLHIsdCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyxlLHIsZmFsc2UsdCl9O2Z1bmN0aW9uIHdyaXRlRG91YmxlKGUscix0LGYsaSl7cj0rcjt0PXQ+Pj4wO2lmKCFpKXtjaGVja0lFRUU3NTQoZSxyLHQsOCwxNzk3NjkzMTM0ODYyMzE1N2UyOTIsLTE3OTc2OTMxMzQ4NjIzMTU3ZTI5Mil9bi53cml0ZShlLHIsdCxmLDUyLDgpO3JldHVybiB0Kzh9QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFPWZ1bmN0aW9uIHdyaXRlRG91YmxlTEUoZSxyLHQpe3JldHVybiB3cml0ZURvdWJsZSh0aGlzLGUscix0cnVlLHQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkU9ZnVuY3Rpb24gd3JpdGVEb3VibGVCRShlLHIsdCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsZSxyLGZhbHNlLHQpfTtCdWZmZXIucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24gY29weShlLHIsdCxmKXtpZighQnVmZmVyLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXJcIik7aWYoIXQpdD0wO2lmKCFmJiZmIT09MClmPXRoaXMubGVuZ3RoO2lmKHI+PWUubGVuZ3RoKXI9ZS5sZW5ndGg7aWYoIXIpcj0wO2lmKGY+MCYmZjx0KWY9dDtpZihmPT09dClyZXR1cm4gMDtpZihlLmxlbmd0aD09PTB8fHRoaXMubGVuZ3RoPT09MClyZXR1cm4gMDtpZihyPDApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1wiKX1pZih0PDB8fHQ+PXRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKGY8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXCIpO2lmKGY+dGhpcy5sZW5ndGgpZj10aGlzLmxlbmd0aDtpZihlLmxlbmd0aC1yPGYtdCl7Zj1lLmxlbmd0aC1yK3R9dmFyIG49Zi10O2lmKHRoaXM9PT1lJiZ0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbj09PVwiZnVuY3Rpb25cIil7dGhpcy5jb3B5V2l0aGluKHIsdCxmKX1lbHNlIGlmKHRoaXM9PT1lJiZ0PHImJnI8Zil7Zm9yKHZhciBpPW4tMTtpPj0wOy0taSl7ZVtpK3JdPXRoaXNbaSt0XX19ZWxzZXtVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChlLHRoaXMuc3ViYXJyYXkodCxmKSxyKX1yZXR1cm4gbn07QnVmZmVyLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uIGZpbGwoZSxyLHQsZil7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtpZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe2Y9cjtyPTA7dD10aGlzLmxlbmd0aH1lbHNlIGlmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7Zj10O3Q9dGhpcy5sZW5ndGh9aWYoZiE9PXVuZGVmaW5lZCYmdHlwZW9mIGYhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZ1wiKX1pZih0eXBlb2YgZj09PVwic3RyaW5nXCImJiFCdWZmZXIuaXNFbmNvZGluZyhmKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2YpfWlmKGUubGVuZ3RoPT09MSl7dmFyIG49ZS5jaGFyQ29kZUF0KDApO2lmKGY9PT1cInV0ZjhcIiYmbjwxMjh8fGY9PT1cImxhdGluMVwiKXtlPW59fX1lbHNlIGlmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7ZT1lJjI1NX1lbHNlIGlmKHR5cGVvZiBlPT09XCJib29sZWFuXCIpe2U9TnVtYmVyKGUpfWlmKHI8MHx8dGhpcy5sZW5ndGg8cnx8dGhpcy5sZW5ndGg8dCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJPdXQgb2YgcmFuZ2UgaW5kZXhcIil9aWYodDw9cil7cmV0dXJuIHRoaXN9cj1yPj4+MDt0PXQ9PT11bmRlZmluZWQ/dGhpcy5sZW5ndGg6dD4+PjA7aWYoIWUpZT0wO3ZhciBpO2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7Zm9yKGk9cjtpPHQ7KytpKXt0aGlzW2ldPWV9fWVsc2V7dmFyIG89QnVmZmVyLmlzQnVmZmVyKGUpP2U6QnVmZmVyLmZyb20oZSxmKTt2YXIgdT1vLmxlbmd0aDtpZih1PT09MCl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJytlKydcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKX1mb3IoaT0wO2k8dC1yOysraSl7dGhpc1tpK3JdPW9baSV1XX19cmV0dXJuIHRoaXN9O3ZhciBhPS9bXisvMC05QS1aYS16LV9dL2c7ZnVuY3Rpb24gYmFzZTY0Y2xlYW4oZSl7ZT1lLnNwbGl0KFwiPVwiKVswXTtlPWUudHJpbSgpLnJlcGxhY2UoYSxcIlwiKTtpZihlLmxlbmd0aDwyKXJldHVyblwiXCI7d2hpbGUoZS5sZW5ndGglNCE9PTApe2U9ZStcIj1cIn1yZXR1cm4gZX1mdW5jdGlvbiB1dGY4VG9CeXRlcyhlLHIpe3I9cnx8SW5maW5pdHk7dmFyIHQ7dmFyIGY9ZS5sZW5ndGg7dmFyIG49bnVsbDt2YXIgaT1bXTtmb3IodmFyIG89MDtvPGY7KytvKXt0PWUuY2hhckNvZGVBdChvKTtpZih0PjU1Mjk1JiZ0PDU3MzQ0KXtpZighbil7aWYodD41NjMxOSl7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9ZWxzZSBpZihvKzE9PT1mKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1uPXQ7Y29udGludWV9aWYodDw1NjMyMCl7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSk7bj10O2NvbnRpbnVlfXQ9KG4tNTUyOTY8PDEwfHQtNTYzMjApKzY1NTM2fWVsc2UgaWYobil7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSl9bj1udWxsO2lmKHQ8MTI4KXtpZigoci09MSk8MClicmVhaztpLnB1c2godCl9ZWxzZSBpZih0PDIwNDgpe2lmKChyLT0yKTwwKWJyZWFrO2kucHVzaCh0Pj42fDE5Mix0JjYzfDEyOCl9ZWxzZSBpZih0PDY1NTM2KXtpZigoci09Myk8MClicmVhaztpLnB1c2godD4+MTJ8MjI0LHQ+PjYmNjN8MTI4LHQmNjN8MTI4KX1lbHNlIGlmKHQ8MTExNDExMil7aWYoKHItPTQpPDApYnJlYWs7aS5wdXNoKHQ+PjE4fDI0MCx0Pj4xMiY2M3wxMjgsdD4+NiY2M3wxMjgsdCY2M3wxMjgpfWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50XCIpfX1yZXR1cm4gaX1mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoZSl7dmFyIHI9W107Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDsrK3Qpe3IucHVzaChlLmNoYXJDb2RlQXQodCkmMjU1KX1yZXR1cm4gcn1mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyhlLHIpe3ZhciB0LGYsbjt2YXIgaT1bXTtmb3IodmFyIG89MDtvPGUubGVuZ3RoOysrbyl7aWYoKHItPTIpPDApYnJlYWs7dD1lLmNoYXJDb2RlQXQobyk7Zj10Pj44O249dCUyNTY7aS5wdXNoKG4pO2kucHVzaChmKX1yZXR1cm4gaX1mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKGUpe3JldHVybiBmLnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKGUpKX1mdW5jdGlvbiBibGl0QnVmZmVyKGUscix0LGYpe2Zvcih2YXIgbj0wO248ZjsrK24pe2lmKG4rdD49ci5sZW5ndGh8fG4+PWUubGVuZ3RoKWJyZWFrO3Jbbit0XT1lW25dfXJldHVybiBufWZ1bmN0aW9uIGlzSW5zdGFuY2UoZSxyKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHJ8fGUhPW51bGwmJmUuY29uc3RydWN0b3IhPW51bGwmJmUuY29uc3RydWN0b3IubmFtZSE9bnVsbCYmZS5jb25zdHJ1Y3Rvci5uYW1lPT09ci5uYW1lfWZ1bmN0aW9uIG51bWJlcklzTmFOKGUpe3JldHVybiBlIT09ZX12YXIgcz1mdW5jdGlvbigpe3ZhciBlPVwiMDEyMzQ1Njc4OWFiY2RlZlwiO3ZhciByPW5ldyBBcnJheSgyNTYpO2Zvcih2YXIgdD0wO3Q8MTY7Kyt0KXt2YXIgZj10KjE2O2Zvcih2YXIgbj0wO248MTY7KytuKXtyW2Yrbl09ZVt0XStlW25dfX1yZXR1cm4gcn0oKX0sNTQzOmZ1bmN0aW9uKGUscil7XHJcbi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXHJcbnIucmVhZD1mdW5jdGlvbihlLHIsdCxmLG4pe3ZhciBpLG87dmFyIHU9bio4LWYtMTt2YXIgYT0oMTw8dSktMTt2YXIgcz1hPj4xO3ZhciBoPS03O3ZhciBjPXQ/bi0xOjA7dmFyIGw9dD8tMToxO3ZhciBwPWVbcitjXTtjKz1sO2k9cCYoMTw8LWgpLTE7cD4+PS1oO2grPXU7Zm9yKDtoPjA7aT1pKjI1NitlW3IrY10sYys9bCxoLT04KXt9bz1pJigxPDwtaCktMTtpPj49LWg7aCs9Zjtmb3IoO2g+MDtvPW8qMjU2K2VbcitjXSxjKz1sLGgtPTgpe31pZihpPT09MCl7aT0xLXN9ZWxzZSBpZihpPT09YSl7cmV0dXJuIG8/TmFOOihwPy0xOjEpKkluZmluaXR5fWVsc2V7bz1vK01hdGgucG93KDIsZik7aT1pLXN9cmV0dXJuKHA/LTE6MSkqbypNYXRoLnBvdygyLGktZil9O3Iud3JpdGU9ZnVuY3Rpb24oZSxyLHQsZixuLGkpe3ZhciBvLHUsYTt2YXIgcz1pKjgtbi0xO3ZhciBoPSgxPDxzKS0xO3ZhciBjPWg+PjE7dmFyIGw9bj09PTIzP01hdGgucG93KDIsLTI0KS1NYXRoLnBvdygyLC03Nyk6MDt2YXIgcD1mPzA6aS0xO3ZhciB5PWY/MTotMTt2YXIgZz1yPDB8fHI9PT0wJiYxL3I8MD8xOjA7cj1NYXRoLmFicyhyKTtpZihpc05hTihyKXx8cj09PUluZmluaXR5KXt1PWlzTmFOKHIpPzE6MDtvPWh9ZWxzZXtvPU1hdGguZmxvb3IoTWF0aC5sb2cocikvTWF0aC5MTjIpO2lmKHIqKGE9TWF0aC5wb3coMiwtbykpPDEpe28tLTthKj0yfWlmKG8rYz49MSl7cis9bC9hfWVsc2V7cis9bCpNYXRoLnBvdygyLDEtYyl9aWYociphPj0yKXtvKys7YS89Mn1pZihvK2M+PWgpe3U9MDtvPWh9ZWxzZSBpZihvK2M+PTEpe3U9KHIqYS0xKSpNYXRoLnBvdygyLG4pO289bytjfWVsc2V7dT1yKk1hdGgucG93KDIsYy0xKSpNYXRoLnBvdygyLG4pO289MH19Zm9yKDtuPj04O2VbdCtwXT11JjI1NSxwKz15LHUvPTI1NixuLT04KXt9bz1vPDxufHU7cys9bjtmb3IoO3M+MDtlW3QrcF09byYyNTUscCs9eSxvLz0yNTYscy09OCl7fWVbdCtwLXldfD1nKjEyOH19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBmPXJbdF07aWYoZiE9PXVuZGVmaW5lZCl7cmV0dXJuIGYuZXhwb3J0c312YXIgbj1yW3RdPXtleHBvcnRzOnt9fTt2YXIgaT10cnVlO3RyeXtlW3RdKG4sbi5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2k9ZmFsc2V9ZmluYWxseXtpZihpKWRlbGV0ZSByW3RdfXJldHVybiBuLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oODc3KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOlsiZSIsInIiLCJieXRlTGVuZ3RoIiwidG9CeXRlQXJyYXkiLCJmcm9tQnl0ZUFycmF5IiwidCIsImYiLCJuIiwiVWludDhBcnJheSIsIkFycmF5IiwiaSIsIm8iLCJ1IiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsImdldExlbnMiLCJFcnJvciIsImluZGV4T2YiLCJfYnl0ZUxlbmd0aCIsImEiLCJzIiwiaCIsInRyaXBsZXRUb0Jhc2U2NCIsImVuY29kZUNodW5rIiwicHVzaCIsImpvaW4iLCJTeW1ib2wiLCJmb3IiLCJCdWZmZXIiLCJTbG93QnVmZmVyIiwiSU5TUEVDVF9NQVhfQllURVMiLCJrTWF4TGVuZ3RoIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsInR5cGVkQXJyYXlTdXBwb3J0IiwiY29uc29sZSIsImVycm9yIiwiZm9vIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJpc0J1ZmZlciIsInVuZGVmaW5lZCIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJjcmVhdGVCdWZmZXIiLCJSYW5nZUVycm9yIiwiVHlwZUVycm9yIiwiYWxsb2NVbnNhZmUiLCJmcm9tIiwicG9vbFNpemUiLCJmcm9tU3RyaW5nIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJmcm9tQXJyYXlMaWtlIiwiaXNJbnN0YW5jZSIsImZyb21BcnJheUJ1ZmZlciIsIlNoYXJlZEFycmF5QnVmZmVyIiwidmFsdWVPZiIsImZyb21PYmplY3QiLCJ0b1ByaW1pdGl2ZSIsImFzc2VydFNpemUiLCJhbGxvYyIsImZpbGwiLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93IiwiaXNFbmNvZGluZyIsIndyaXRlIiwic2xpY2UiLCJjb3B5IiwibnVtYmVySXNOYU4iLCJ0eXBlIiwiaXNBcnJheSIsImRhdGEiLCJ0b1N0cmluZyIsIl9pc0J1ZmZlciIsImNvbXBhcmUiLCJvZmZzZXQiLCJNYXRoIiwibWluIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJjb25jYXQiLCJhcmd1bWVudHMiLCJ1dGY4VG9CeXRlcyIsImJhc2U2NFRvQnl0ZXMiLCJzbG93VG9TdHJpbmciLCJoZXhTbGljZSIsInV0ZjhTbGljZSIsImFzY2lpU2xpY2UiLCJsYXRpbjFTbGljZSIsImJhc2U2NFNsaWNlIiwidXRmMTZsZVNsaWNlIiwic3dhcCIsInN3YXAxNiIsInN3YXAzMiIsInN3YXA2NCIsImFwcGx5IiwidG9Mb2NhbGVTdHJpbmciLCJlcXVhbHMiLCJpbnNwZWN0IiwicmVwbGFjZSIsInRyaW0iLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsImFycmF5SW5kZXhPZiIsImNhbGwiLCJsYXN0SW5kZXhPZiIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJjIiwiaW5jbHVkZXMiLCJoZXhXcml0ZSIsIk51bWJlciIsInBhcnNlSW50Iiwic3Vic3RyIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJpc0Zpbml0ZSIsInRvSlNPTiIsIl9hcnIiLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJmcm9tQ2hhckNvZGUiLCJzdWJhcnJheSIsImNoZWNrT2Zmc2V0IiwicmVhZFVJbnRMRSIsInJlYWRVSW50QkUiLCJyZWFkVUludDgiLCJyZWFkVUludDE2TEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJyZWFkSW50TEUiLCJwb3ciLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsInJlYWREb3VibGVMRSIsInJlYWREb3VibGVCRSIsImNoZWNrSW50Iiwid3JpdGVVSW50TEUiLCJ3cml0ZVVJbnRCRSIsIndyaXRlVUludDgiLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVJbnQzMkJFIiwid3JpdGVJbnRMRSIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsImNvcHlXaXRoaW4iLCJzZXQiLCJiYXNlNjRjbGVhbiIsInNwbGl0IiwiSW5maW5pdHkiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJsIiwicCIsIk5hTiIsInkiLCJnIiwiYWJzIiwiaXNOYU4iLCJmbG9vciIsImxvZyIsIkxOMiIsIl9fbmNjd3Bja19yZXF1aXJlX18iLCJleHBvcnRzIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/micromatch/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/micromatch/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n(() => {\n  \"use strict\";\n\n  var e = {\n    526: (e, t, r) => {\n      const n = r(119);\n      const u = r(769);\n      const s = r(722);\n      const o = r(407);\n\n      const braces = (e, t = {}) => {\n        let r = [];\n\n        if (Array.isArray(e)) {\n          for (let n of e) {\n            let e = braces.create(n, t);\n\n            if (Array.isArray(e)) {\n              r.push(...e);\n            } else {\n              r.push(e);\n            }\n          }\n        } else {\n          r = [].concat(braces.create(e, t));\n        }\n\n        if (t && t.expand === true && t.nodupes === true) {\n          r = [...new Set(r)];\n        }\n\n        return r;\n      };\n\n      braces.parse = (e, t = {}) => o(e, t);\n\n      braces.stringify = (e, t = {}) => {\n        if (typeof e === \"string\") {\n          return n(braces.parse(e, t), t);\n        }\n\n        return n(e, t);\n      };\n\n      braces.compile = (e, t = {}) => {\n        if (typeof e === \"string\") {\n          e = braces.parse(e, t);\n        }\n\n        return u(e, t);\n      };\n\n      braces.expand = (e, t = {}) => {\n        if (typeof e === \"string\") {\n          e = braces.parse(e, t);\n        }\n\n        let r = s(e, t);\n\n        if (t.noempty === true) {\n          r = r.filter(Boolean);\n        }\n\n        if (t.nodupes === true) {\n          r = [...new Set(r)];\n        }\n\n        return r;\n      };\n\n      braces.create = (e, t = {}) => {\n        if (e === \"\" || e.length < 3) {\n          return [e];\n        }\n\n        return t.expand !== true ? braces.compile(e, t) : braces.expand(e, t);\n      };\n\n      e.exports = braces;\n    },\n    769: (e, t, r) => {\n      const n = r(789);\n      const u = r(15);\n\n      const compile = (e, t = {}) => {\n        let walk = (e, r = {}) => {\n          let s = u.isInvalidBrace(r);\n          let o = e.invalid === true && t.escapeInvalid === true;\n          let i = s === true || o === true;\n          let a = t.escapeInvalid === true ? \"\\\\\" : \"\";\n          let l = \"\";\n\n          if (e.isOpen === true) {\n            return a + e.value;\n          }\n\n          if (e.isClose === true) {\n            return a + e.value;\n          }\n\n          if (e.type === \"open\") {\n            return i ? a + e.value : \"(\";\n          }\n\n          if (e.type === \"close\") {\n            return i ? a + e.value : \")\";\n          }\n\n          if (e.type === \"comma\") {\n            return e.prev.type === \"comma\" ? \"\" : i ? e.value : \"|\";\n          }\n\n          if (e.value) {\n            return e.value;\n          }\n\n          if (e.nodes && e.ranges > 0) {\n            let r = u.reduce(e.nodes);\n            let s = n(...r, { ...t,\n              wrap: false,\n              toRegex: true\n            });\n\n            if (s.length !== 0) {\n              return r.length > 1 && s.length > 1 ? `(${s})` : s;\n            }\n          }\n\n          if (e.nodes) {\n            for (let t of e.nodes) {\n              l += walk(t, e);\n            }\n          }\n\n          return l;\n        };\n\n        return walk(e);\n      };\n\n      e.exports = compile;\n    },\n    262: e => {\n      e.exports = {\n        MAX_LENGTH: 1024 * 64,\n        CHAR_0: \"0\",\n        CHAR_9: \"9\",\n        CHAR_UPPERCASE_A: \"A\",\n        CHAR_LOWERCASE_A: \"a\",\n        CHAR_UPPERCASE_Z: \"Z\",\n        CHAR_LOWERCASE_Z: \"z\",\n        CHAR_LEFT_PARENTHESES: \"(\",\n        CHAR_RIGHT_PARENTHESES: \")\",\n        CHAR_ASTERISK: \"*\",\n        CHAR_AMPERSAND: \"&\",\n        CHAR_AT: \"@\",\n        CHAR_BACKSLASH: \"\\\\\",\n        CHAR_BACKTICK: \"`\",\n        CHAR_CARRIAGE_RETURN: \"\\r\",\n        CHAR_CIRCUMFLEX_ACCENT: \"^\",\n        CHAR_COLON: \":\",\n        CHAR_COMMA: \",\",\n        CHAR_DOLLAR: \"$\",\n        CHAR_DOT: \".\",\n        CHAR_DOUBLE_QUOTE: '\"',\n        CHAR_EQUAL: \"=\",\n        CHAR_EXCLAMATION_MARK: \"!\",\n        CHAR_FORM_FEED: \"\\f\",\n        CHAR_FORWARD_SLASH: \"/\",\n        CHAR_HASH: \"#\",\n        CHAR_HYPHEN_MINUS: \"-\",\n        CHAR_LEFT_ANGLE_BRACKET: \"<\",\n        CHAR_LEFT_CURLY_BRACE: \"{\",\n        CHAR_LEFT_SQUARE_BRACKET: \"[\",\n        CHAR_LINE_FEED: \"\\n\",\n        CHAR_NO_BREAK_SPACE: \" \",\n        CHAR_PERCENT: \"%\",\n        CHAR_PLUS: \"+\",\n        CHAR_QUESTION_MARK: \"?\",\n        CHAR_RIGHT_ANGLE_BRACKET: \">\",\n        CHAR_RIGHT_CURLY_BRACE: \"}\",\n        CHAR_RIGHT_SQUARE_BRACKET: \"]\",\n        CHAR_SEMICOLON: \";\",\n        CHAR_SINGLE_QUOTE: \"'\",\n        CHAR_SPACE: \" \",\n        CHAR_TAB: \"\\t\",\n        CHAR_UNDERSCORE: \"_\",\n        CHAR_VERTICAL_LINE: \"|\",\n        CHAR_ZERO_WIDTH_NOBREAK_SPACE: \"\\ufeff\"\n      };\n    },\n    722: (e, t, r) => {\n      const n = r(789);\n      const u = r(119);\n      const s = r(15);\n\n      const append = (e = \"\", t = \"\", r = false) => {\n        let n = [];\n        e = [].concat(e);\n        t = [].concat(t);\n        if (!t.length) return e;\n\n        if (!e.length) {\n          return r ? s.flatten(t).map(e => `{${e}}`) : t;\n        }\n\n        for (let u of e) {\n          if (Array.isArray(u)) {\n            for (let e of u) {\n              n.push(append(e, t, r));\n            }\n          } else {\n            for (let e of t) {\n              if (r === true && typeof e === \"string\") e = `{${e}}`;\n              n.push(Array.isArray(e) ? append(u, e, r) : u + e);\n            }\n          }\n        }\n\n        return s.flatten(n);\n      };\n\n      const expand = (e, t = {}) => {\n        let r = t.rangeLimit === void 0 ? 1e3 : t.rangeLimit;\n\n        let walk = (e, o = {}) => {\n          e.queue = [];\n          let i = o;\n          let a = o.queue;\n\n          while (i.type !== \"brace\" && i.type !== \"root\" && i.parent) {\n            i = i.parent;\n            a = i.queue;\n          }\n\n          if (e.invalid || e.dollar) {\n            a.push(append(a.pop(), u(e, t)));\n            return;\n          }\n\n          if (e.type === \"brace\" && e.invalid !== true && e.nodes.length === 2) {\n            a.push(append(a.pop(), [\"{}\"]));\n            return;\n          }\n\n          if (e.nodes && e.ranges > 0) {\n            let o = s.reduce(e.nodes);\n\n            if (s.exceedsLimit(...o, t.step, r)) {\n              throw new RangeError(\"expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.\");\n            }\n\n            let i = n(...o, t);\n\n            if (i.length === 0) {\n              i = u(e, t);\n            }\n\n            a.push(append(a.pop(), i));\n            e.nodes = [];\n            return;\n          }\n\n          let l = s.encloseBrace(e);\n          let c = e.queue;\n          let p = e;\n\n          while (p.type !== \"brace\" && p.type !== \"root\" && p.parent) {\n            p = p.parent;\n            c = p.queue;\n          }\n\n          for (let t = 0; t < e.nodes.length; t++) {\n            let r = e.nodes[t];\n\n            if (r.type === \"comma\" && e.type === \"brace\") {\n              if (t === 1) c.push(\"\");\n              c.push(\"\");\n              continue;\n            }\n\n            if (r.type === \"close\") {\n              a.push(append(a.pop(), c, l));\n              continue;\n            }\n\n            if (r.value && r.type !== \"open\") {\n              c.push(append(c.pop(), r.value));\n              continue;\n            }\n\n            if (r.nodes) {\n              walk(r, e);\n            }\n          }\n\n          return c;\n        };\n\n        return s.flatten(walk(e));\n      };\n\n      e.exports = expand;\n    },\n    407: (e, t, r) => {\n      const n = r(119);\n      const {\n        MAX_LENGTH: u,\n        CHAR_BACKSLASH: s,\n        CHAR_BACKTICK: o,\n        CHAR_COMMA: i,\n        CHAR_DOT: a,\n        CHAR_LEFT_PARENTHESES: l,\n        CHAR_RIGHT_PARENTHESES: c,\n        CHAR_LEFT_CURLY_BRACE: p,\n        CHAR_RIGHT_CURLY_BRACE: f,\n        CHAR_LEFT_SQUARE_BRACKET: A,\n        CHAR_RIGHT_SQUARE_BRACKET: R,\n        CHAR_DOUBLE_QUOTE: _,\n        CHAR_SINGLE_QUOTE: h,\n        CHAR_NO_BREAK_SPACE: g,\n        CHAR_ZERO_WIDTH_NOBREAK_SPACE: E\n      } = r(262);\n\n      const parse = (e, t = {}) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(\"Expected a string\");\n        }\n\n        let r = t || {};\n        let C = typeof r.maxLength === \"number\" ? Math.min(u, r.maxLength) : u;\n\n        if (e.length > C) {\n          throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${C})`);\n        }\n\n        let y = {\n          type: \"root\",\n          input: e,\n          nodes: []\n        };\n        let d = [y];\n        let x = y;\n        let b = y;\n        let S = 0;\n        let H = e.length;\n        let v = 0;\n        let $ = 0;\n        let m;\n        let T = {};\n\n        const advance = () => e[v++];\n\n        const push = e => {\n          if (e.type === \"text\" && b.type === \"dot\") {\n            b.type = \"text\";\n          }\n\n          if (b && b.type === \"text\" && e.type === \"text\") {\n            b.value += e.value;\n            return;\n          }\n\n          x.nodes.push(e);\n          e.parent = x;\n          e.prev = b;\n          b = e;\n          return e;\n        };\n\n        push({\n          type: \"bos\"\n        });\n\n        while (v < H) {\n          x = d[d.length - 1];\n          m = advance();\n\n          if (m === E || m === g) {\n            continue;\n          }\n\n          if (m === s) {\n            push({\n              type: \"text\",\n              value: (t.keepEscaping ? m : \"\") + advance()\n            });\n            continue;\n          }\n\n          if (m === R) {\n            push({\n              type: \"text\",\n              value: \"\\\\\" + m\n            });\n            continue;\n          }\n\n          if (m === A) {\n            S++;\n            let e = true;\n            let t;\n\n            while (v < H && (t = advance())) {\n              m += t;\n\n              if (t === A) {\n                S++;\n                continue;\n              }\n\n              if (t === s) {\n                m += advance();\n                continue;\n              }\n\n              if (t === R) {\n                S--;\n\n                if (S === 0) {\n                  break;\n                }\n              }\n            }\n\n            push({\n              type: \"text\",\n              value: m\n            });\n            continue;\n          }\n\n          if (m === l) {\n            x = push({\n              type: \"paren\",\n              nodes: []\n            });\n            d.push(x);\n            push({\n              type: \"text\",\n              value: m\n            });\n            continue;\n          }\n\n          if (m === c) {\n            if (x.type !== \"paren\") {\n              push({\n                type: \"text\",\n                value: m\n              });\n              continue;\n            }\n\n            x = d.pop();\n            push({\n              type: \"text\",\n              value: m\n            });\n            x = d[d.length - 1];\n            continue;\n          }\n\n          if (m === _ || m === h || m === o) {\n            let e = m;\n            let r;\n\n            if (t.keepQuotes !== true) {\n              m = \"\";\n            }\n\n            while (v < H && (r = advance())) {\n              if (r === s) {\n                m += r + advance();\n                continue;\n              }\n\n              if (r === e) {\n                if (t.keepQuotes === true) m += r;\n                break;\n              }\n\n              m += r;\n            }\n\n            push({\n              type: \"text\",\n              value: m\n            });\n            continue;\n          }\n\n          if (m === p) {\n            $++;\n            let e = b.value && b.value.slice(-1) === \"$\" || x.dollar === true;\n            let t = {\n              type: \"brace\",\n              open: true,\n              close: false,\n              dollar: e,\n              depth: $,\n              commas: 0,\n              ranges: 0,\n              nodes: []\n            };\n            x = push(t);\n            d.push(x);\n            push({\n              type: \"open\",\n              value: m\n            });\n            continue;\n          }\n\n          if (m === f) {\n            if (x.type !== \"brace\") {\n              push({\n                type: \"text\",\n                value: m\n              });\n              continue;\n            }\n\n            let e = \"close\";\n            x = d.pop();\n            x.close = true;\n            push({\n              type: e,\n              value: m\n            });\n            $--;\n            x = d[d.length - 1];\n            continue;\n          }\n\n          if (m === i && $ > 0) {\n            if (x.ranges > 0) {\n              x.ranges = 0;\n              let e = x.nodes.shift();\n              x.nodes = [e, {\n                type: \"text\",\n                value: n(x)\n              }];\n            }\n\n            push({\n              type: \"comma\",\n              value: m\n            });\n            x.commas++;\n            continue;\n          }\n\n          if (m === a && $ > 0 && x.commas === 0) {\n            let e = x.nodes;\n\n            if ($ === 0 || e.length === 0) {\n              push({\n                type: \"text\",\n                value: m\n              });\n              continue;\n            }\n\n            if (b.type === \"dot\") {\n              x.range = [];\n              b.value += m;\n              b.type = \"range\";\n\n              if (x.nodes.length !== 3 && x.nodes.length !== 5) {\n                x.invalid = true;\n                x.ranges = 0;\n                b.type = \"text\";\n                continue;\n              }\n\n              x.ranges++;\n              x.args = [];\n              continue;\n            }\n\n            if (b.type === \"range\") {\n              e.pop();\n              let t = e[e.length - 1];\n              t.value += b.value + m;\n              b = t;\n              x.ranges--;\n              continue;\n            }\n\n            push({\n              type: \"dot\",\n              value: m\n            });\n            continue;\n          }\n\n          push({\n            type: \"text\",\n            value: m\n          });\n        }\n\n        do {\n          x = d.pop();\n\n          if (x.type !== \"root\") {\n            x.nodes.forEach(e => {\n              if (!e.nodes) {\n                if (e.type === \"open\") e.isOpen = true;\n                if (e.type === \"close\") e.isClose = true;\n                if (!e.nodes) e.type = \"text\";\n                e.invalid = true;\n              }\n            });\n            let e = d[d.length - 1];\n            let t = e.nodes.indexOf(x);\n            e.nodes.splice(t, 1, ...x.nodes);\n          }\n        } while (d.length > 0);\n\n        push({\n          type: \"eos\"\n        });\n        return y;\n      };\n\n      e.exports = parse;\n    },\n    119: (e, t, r) => {\n      const n = r(15);\n\n      e.exports = (e, t = {}) => {\n        let stringify = (e, r = {}) => {\n          let u = t.escapeInvalid && n.isInvalidBrace(r);\n          let s = e.invalid === true && t.escapeInvalid === true;\n          let o = \"\";\n\n          if (e.value) {\n            if ((u || s) && n.isOpenOrClose(e)) {\n              return \"\\\\\" + e.value;\n            }\n\n            return e.value;\n          }\n\n          if (e.value) {\n            return e.value;\n          }\n\n          if (e.nodes) {\n            for (let t of e.nodes) {\n              o += stringify(t);\n            }\n          }\n\n          return o;\n        };\n\n        return stringify(e);\n      };\n    },\n    15: (e, t) => {\n      t.isInteger = e => {\n        if (typeof e === \"number\") {\n          return Number.isInteger(e);\n        }\n\n        if (typeof e === \"string\" && e.trim() !== \"\") {\n          return Number.isInteger(Number(e));\n        }\n\n        return false;\n      };\n\n      t.find = (e, t) => e.nodes.find(e => e.type === t);\n\n      t.exceedsLimit = (e, r, n = 1, u) => {\n        if (u === false) return false;\n        if (!t.isInteger(e) || !t.isInteger(r)) return false;\n        return (Number(r) - Number(e)) / Number(n) >= u;\n      };\n\n      t.escapeNode = (e, t = 0, r) => {\n        let n = e.nodes[t];\n        if (!n) return;\n\n        if (r && n.type === r || n.type === \"open\" || n.type === \"close\") {\n          if (n.escaped !== true) {\n            n.value = \"\\\\\" + n.value;\n            n.escaped = true;\n          }\n        }\n      };\n\n      t.encloseBrace = e => {\n        if (e.type !== \"brace\") return false;\n\n        if (e.commas >> 0 + e.ranges >> 0 === 0) {\n          e.invalid = true;\n          return true;\n        }\n\n        return false;\n      };\n\n      t.isInvalidBrace = e => {\n        if (e.type !== \"brace\") return false;\n        if (e.invalid === true || e.dollar) return true;\n\n        if (e.commas >> 0 + e.ranges >> 0 === 0) {\n          e.invalid = true;\n          return true;\n        }\n\n        if (e.open !== true || e.close !== true) {\n          e.invalid = true;\n          return true;\n        }\n\n        return false;\n      };\n\n      t.isOpenOrClose = e => {\n        if (e.type === \"open\" || e.type === \"close\") {\n          return true;\n        }\n\n        return e.open === true || e.close === true;\n      };\n\n      t.reduce = e => e.reduce((e, t) => {\n        if (t.type === \"text\") e.push(t.value);\n        if (t.type === \"range\") t.type = \"text\";\n        return e;\n      }, []);\n\n      t.flatten = (...e) => {\n        const t = [];\n\n        const flat = e => {\n          for (let r = 0; r < e.length; r++) {\n            let n = e[r];\n            Array.isArray(n) ? flat(n, t) : n !== void 0 && t.push(n);\n          }\n\n          return t;\n        };\n\n        flat(e);\n        return t;\n      };\n    },\n    789: (e, t, r) => {\n      /*!\r\n       * fill-range <https://github.com/jonschlinkert/fill-range>\r\n       *\r\n       * Copyright (c) 2014-present, Jon Schlinkert.\r\n       * Licensed under the MIT License.\r\n       */\n      const n = r(837);\n      const u = r(368);\n\n      const isObject = e => e !== null && typeof e === \"object\" && !Array.isArray(e);\n\n      const transform = e => t => e === true ? Number(t) : String(t);\n\n      const isValidValue = e => typeof e === \"number\" || typeof e === \"string\" && e !== \"\";\n\n      const isNumber = e => Number.isInteger(+e);\n\n      const zeros = e => {\n        let t = `${e}`;\n        let r = -1;\n        if (t[0] === \"-\") t = t.slice(1);\n        if (t === \"0\") return false;\n\n        while (t[++r] === \"0\");\n\n        return r > 0;\n      };\n\n      const stringify = (e, t, r) => {\n        if (typeof e === \"string\" || typeof t === \"string\") {\n          return true;\n        }\n\n        return r.stringify === true;\n      };\n\n      const pad = (e, t, r) => {\n        if (t > 0) {\n          let r = e[0] === \"-\" ? \"-\" : \"\";\n          if (r) e = e.slice(1);\n          e = r + e.padStart(r ? t - 1 : t, \"0\");\n        }\n\n        if (r === false) {\n          return String(e);\n        }\n\n        return e;\n      };\n\n      const toMaxLen = (e, t) => {\n        let r = e[0] === \"-\" ? \"-\" : \"\";\n\n        if (r) {\n          e = e.slice(1);\n          t--;\n        }\n\n        while (e.length < t) e = \"0\" + e;\n\n        return r ? \"-\" + e : e;\n      };\n\n      const toSequence = (e, t) => {\n        e.negatives.sort((e, t) => e < t ? -1 : e > t ? 1 : 0);\n        e.positives.sort((e, t) => e < t ? -1 : e > t ? 1 : 0);\n        let r = t.capture ? \"\" : \"?:\";\n        let n = \"\";\n        let u = \"\";\n        let s;\n\n        if (e.positives.length) {\n          n = e.positives.join(\"|\");\n        }\n\n        if (e.negatives.length) {\n          u = `-(${r}${e.negatives.join(\"|\")})`;\n        }\n\n        if (n && u) {\n          s = `${n}|${u}`;\n        } else {\n          s = n || u;\n        }\n\n        if (t.wrap) {\n          return `(${r}${s})`;\n        }\n\n        return s;\n      };\n\n      const toRange = (e, t, r, n) => {\n        if (r) {\n          return u(e, t, {\n            wrap: false,\n            ...n\n          });\n        }\n\n        let s = String.fromCharCode(e);\n        if (e === t) return s;\n        let o = String.fromCharCode(t);\n        return `[${s}-${o}]`;\n      };\n\n      const toRegex = (e, t, r) => {\n        if (Array.isArray(e)) {\n          let t = r.wrap === true;\n          let n = r.capture ? \"\" : \"?:\";\n          return t ? `(${n}${e.join(\"|\")})` : e.join(\"|\");\n        }\n\n        return u(e, t, r);\n      };\n\n      const rangeError = (...e) => new RangeError(\"Invalid range arguments: \" + n.inspect(...e));\n\n      const invalidRange = (e, t, r) => {\n        if (r.strictRanges === true) throw rangeError([e, t]);\n        return [];\n      };\n\n      const invalidStep = (e, t) => {\n        if (t.strictRanges === true) {\n          throw new TypeError(`Expected step \"${e}\" to be a number`);\n        }\n\n        return [];\n      };\n\n      const fillNumbers = (e, t, r = 1, n = {}) => {\n        let u = Number(e);\n        let s = Number(t);\n\n        if (!Number.isInteger(u) || !Number.isInteger(s)) {\n          if (n.strictRanges === true) throw rangeError([e, t]);\n          return [];\n        }\n\n        if (u === 0) u = 0;\n        if (s === 0) s = 0;\n        let o = u > s;\n        let i = String(e);\n        let a = String(t);\n        let l = String(r);\n        r = Math.max(Math.abs(r), 1);\n        let c = zeros(i) || zeros(a) || zeros(l);\n        let p = c ? Math.max(i.length, a.length, l.length) : 0;\n        let f = c === false && stringify(e, t, n) === false;\n        let A = n.transform || transform(f);\n\n        if (n.toRegex && r === 1) {\n          return toRange(toMaxLen(e, p), toMaxLen(t, p), true, n);\n        }\n\n        let R = {\n          negatives: [],\n          positives: []\n        };\n\n        let push = e => R[e < 0 ? \"negatives\" : \"positives\"].push(Math.abs(e));\n\n        let _ = [];\n        let h = 0;\n\n        while (o ? u >= s : u <= s) {\n          if (n.toRegex === true && r > 1) {\n            push(u);\n          } else {\n            _.push(pad(A(u, h), p, f));\n          }\n\n          u = o ? u - r : u + r;\n          h++;\n        }\n\n        if (n.toRegex === true) {\n          return r > 1 ? toSequence(R, n) : toRegex(_, null, {\n            wrap: false,\n            ...n\n          });\n        }\n\n        return _;\n      };\n\n      const fillLetters = (e, t, r = 1, n = {}) => {\n        if (!isNumber(e) && e.length > 1 || !isNumber(t) && t.length > 1) {\n          return invalidRange(e, t, n);\n        }\n\n        let u = n.transform || (e => String.fromCharCode(e));\n\n        let s = `${e}`.charCodeAt(0);\n        let o = `${t}`.charCodeAt(0);\n        let i = s > o;\n        let a = Math.min(s, o);\n        let l = Math.max(s, o);\n\n        if (n.toRegex && r === 1) {\n          return toRange(a, l, false, n);\n        }\n\n        let c = [];\n        let p = 0;\n\n        while (i ? s >= o : s <= o) {\n          c.push(u(s, p));\n          s = i ? s - r : s + r;\n          p++;\n        }\n\n        if (n.toRegex === true) {\n          return toRegex(c, null, {\n            wrap: false,\n            options: n\n          });\n        }\n\n        return c;\n      };\n\n      const fill = (e, t, r, n = {}) => {\n        if (t == null && isValidValue(e)) {\n          return [e];\n        }\n\n        if (!isValidValue(e) || !isValidValue(t)) {\n          return invalidRange(e, t, n);\n        }\n\n        if (typeof r === \"function\") {\n          return fill(e, t, 1, {\n            transform: r\n          });\n        }\n\n        if (isObject(r)) {\n          return fill(e, t, 0, r);\n        }\n\n        let u = { ...n\n        };\n        if (u.capture === true) u.wrap = true;\n        r = r || u.step || 1;\n\n        if (!isNumber(r)) {\n          if (r != null && !isObject(r)) return invalidStep(r, u);\n          return fill(e, t, 1, r);\n        }\n\n        if (isNumber(e) && isNumber(t)) {\n          return fillNumbers(e, t, r, u);\n        }\n\n        return fillLetters(e, t, Math.max(Math.abs(r), 1), u);\n      };\n\n      e.exports = fill;\n    },\n    773: e => {\n      /*!\r\n       * is-number <https://github.com/jonschlinkert/is-number>\r\n       *\r\n       * Copyright (c) 2014-present, Jon Schlinkert.\r\n       * Released under the MIT License.\r\n       */\n      e.exports = function (e) {\n        if (typeof e === \"number\") {\n          return e - e === 0;\n        }\n\n        if (typeof e === \"string\" && e.trim() !== \"\") {\n          return Number.isFinite ? Number.isFinite(+e) : isFinite(+e);\n        }\n\n        return false;\n      };\n    },\n    888: (e, t, r) => {\n      const n = r(837);\n      const u = r(526);\n      const s = r(601);\n      const o = r(243);\n\n      const isEmptyString = e => e === \"\" || e === \"./\";\n\n      const micromatch = (e, t, r) => {\n        t = [].concat(t);\n        e = [].concat(e);\n        let n = new Set();\n        let u = new Set();\n        let o = new Set();\n        let i = 0;\n\n        let onResult = e => {\n          o.add(e.output);\n\n          if (r && r.onResult) {\n            r.onResult(e);\n          }\n        };\n\n        for (let o = 0; o < t.length; o++) {\n          let a = s(String(t[o]), { ...r,\n            onResult: onResult\n          }, true);\n          let l = a.state.negated || a.state.negatedExtglob;\n          if (l) i++;\n\n          for (let t of e) {\n            let e = a(t, true);\n            let r = l ? !e.isMatch : e.isMatch;\n            if (!r) continue;\n\n            if (l) {\n              n.add(e.output);\n            } else {\n              n.delete(e.output);\n              u.add(e.output);\n            }\n          }\n        }\n\n        let a = i === t.length ? [...o] : [...u];\n        let l = a.filter(e => !n.has(e));\n\n        if (r && l.length === 0) {\n          if (r.failglob === true) {\n            throw new Error(`No matches found for \"${t.join(\", \")}\"`);\n          }\n\n          if (r.nonull === true || r.nullglob === true) {\n            return r.unescape ? t.map(e => e.replace(/\\\\/g, \"\")) : t;\n          }\n        }\n\n        return l;\n      };\n\n      micromatch.match = micromatch;\n\n      micromatch.matcher = (e, t) => s(e, t);\n\n      micromatch.isMatch = (e, t, r) => s(t, r)(e);\n\n      micromatch.any = micromatch.isMatch;\n\n      micromatch.not = (e, t, r = {}) => {\n        t = [].concat(t).map(String);\n        let n = new Set();\n        let u = [];\n\n        let onResult = e => {\n          if (r.onResult) r.onResult(e);\n          u.push(e.output);\n        };\n\n        let s = micromatch(e, t, { ...r,\n          onResult: onResult\n        });\n\n        for (let e of u) {\n          if (!s.includes(e)) {\n            n.add(e);\n          }\n        }\n\n        return [...n];\n      };\n\n      micromatch.contains = (e, t, r) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(`Expected a string: \"${n.inspect(e)}\"`);\n        }\n\n        if (Array.isArray(t)) {\n          return t.some(t => micromatch.contains(e, t, r));\n        }\n\n        if (typeof t === \"string\") {\n          if (isEmptyString(e) || isEmptyString(t)) {\n            return false;\n          }\n\n          if (e.includes(t) || e.startsWith(\"./\") && e.slice(2).includes(t)) {\n            return true;\n          }\n        }\n\n        return micromatch.isMatch(e, t, { ...r,\n          contains: true\n        });\n      };\n\n      micromatch.matchKeys = (e, t, r) => {\n        if (!o.isObject(e)) {\n          throw new TypeError(\"Expected the first argument to be an object\");\n        }\n\n        let n = micromatch(Object.keys(e), t, r);\n        let u = {};\n\n        for (let t of n) u[t] = e[t];\n\n        return u;\n      };\n\n      micromatch.some = (e, t, r) => {\n        let n = [].concat(e);\n\n        for (let e of [].concat(t)) {\n          let t = s(String(e), r);\n\n          if (n.some(e => t(e))) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      micromatch.every = (e, t, r) => {\n        let n = [].concat(e);\n\n        for (let e of [].concat(t)) {\n          let t = s(String(e), r);\n\n          if (!n.every(e => t(e))) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n\n      micromatch.all = (e, t, r) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(`Expected a string: \"${n.inspect(e)}\"`);\n        }\n\n        return [].concat(t).every(t => s(t, r)(e));\n      };\n\n      micromatch.capture = (e, t, r) => {\n        let n = o.isWindows(r);\n        let u = s.makeRe(String(e), { ...r,\n          capture: true\n        });\n        let i = u.exec(n ? o.toPosixSlashes(t) : t);\n\n        if (i) {\n          return i.slice(1).map(e => e === void 0 ? \"\" : e);\n        }\n      };\n\n      micromatch.makeRe = (...e) => s.makeRe(...e);\n\n      micromatch.scan = (...e) => s.scan(...e);\n\n      micromatch.parse = (e, t) => {\n        let r = [];\n\n        for (let n of [].concat(e || [])) {\n          for (let e of u(String(n), t)) {\n            r.push(s.parse(e, t));\n          }\n        }\n\n        return r;\n      };\n\n      micromatch.braces = (e, t) => {\n        if (typeof e !== \"string\") throw new TypeError(\"Expected a string\");\n\n        if (t && t.nobrace === true || !/\\{.*\\}/.test(e)) {\n          return [e];\n        }\n\n        return u(e, t);\n      };\n\n      micromatch.braceExpand = (e, t) => {\n        if (typeof e !== \"string\") throw new TypeError(\"Expected a string\");\n        return micromatch.braces(e, { ...t,\n          expand: true\n        });\n      };\n\n      e.exports = micromatch;\n    },\n    601: (e, t, r) => {\n      e.exports = r(509);\n    },\n    871: (e, t, r) => {\n      const n = r(17);\n      const u = \"\\\\\\\\/\";\n      const s = `[^${u}]`;\n      const o = \"\\\\.\";\n      const i = \"\\\\+\";\n      const a = \"\\\\?\";\n      const l = \"\\\\/\";\n      const c = \"(?=.)\";\n      const p = \"[^/]\";\n      const f = `(?:${l}|$)`;\n      const A = `(?:^|${l})`;\n      const R = `${o}{1,2}${f}`;\n      const _ = `(?!${o})`;\n      const h = `(?!${A}${R})`;\n      const g = `(?!${o}{0,1}${f})`;\n      const E = `(?!${R})`;\n      const C = `[^.${l}]`;\n      const y = `${p}*?`;\n      const d = {\n        DOT_LITERAL: o,\n        PLUS_LITERAL: i,\n        QMARK_LITERAL: a,\n        SLASH_LITERAL: l,\n        ONE_CHAR: c,\n        QMARK: p,\n        END_ANCHOR: f,\n        DOTS_SLASH: R,\n        NO_DOT: _,\n        NO_DOTS: h,\n        NO_DOT_SLASH: g,\n        NO_DOTS_SLASH: E,\n        QMARK_NO_DOT: C,\n        STAR: y,\n        START_ANCHOR: A\n      };\n      const x = { ...d,\n        SLASH_LITERAL: `[${u}]`,\n        QMARK: s,\n        STAR: `${s}*?`,\n        DOTS_SLASH: `${o}{1,2}(?:[${u}]|$)`,\n        NO_DOT: `(?!${o})`,\n        NO_DOTS: `(?!(?:^|[${u}])${o}{1,2}(?:[${u}]|$))`,\n        NO_DOT_SLASH: `(?!${o}{0,1}(?:[${u}]|$))`,\n        NO_DOTS_SLASH: `(?!${o}{1,2}(?:[${u}]|$))`,\n        QMARK_NO_DOT: `[^.${u}]`,\n        START_ANCHOR: `(?:^|[${u}])`,\n        END_ANCHOR: `(?:[${u}]|$)`\n      };\n      const b = {\n        alnum: \"a-zA-Z0-9\",\n        alpha: \"a-zA-Z\",\n        ascii: \"\\\\x00-\\\\x7F\",\n        blank: \" \\\\t\",\n        cntrl: \"\\\\x00-\\\\x1F\\\\x7F\",\n        digit: \"0-9\",\n        graph: \"\\\\x21-\\\\x7E\",\n        lower: \"a-z\",\n        print: \"\\\\x20-\\\\x7E \",\n        punct: \"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",\n        space: \" \\\\t\\\\r\\\\n\\\\v\\\\f\",\n        upper: \"A-Z\",\n        word: \"A-Za-z0-9_\",\n        xdigit: \"A-Fa-f0-9\"\n      };\n      e.exports = {\n        MAX_LENGTH: 1024 * 64,\n        POSIX_REGEX_SOURCE: b,\n        REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n        REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n        REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n        REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n        REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n        REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n        REPLACEMENTS: {\n          \"***\": \"*\",\n          \"**/**\": \"**\",\n          \"**/**/**\": \"**\"\n        },\n        CHAR_0: 48,\n        CHAR_9: 57,\n        CHAR_UPPERCASE_A: 65,\n        CHAR_LOWERCASE_A: 97,\n        CHAR_UPPERCASE_Z: 90,\n        CHAR_LOWERCASE_Z: 122,\n        CHAR_LEFT_PARENTHESES: 40,\n        CHAR_RIGHT_PARENTHESES: 41,\n        CHAR_ASTERISK: 42,\n        CHAR_AMPERSAND: 38,\n        CHAR_AT: 64,\n        CHAR_BACKWARD_SLASH: 92,\n        CHAR_CARRIAGE_RETURN: 13,\n        CHAR_CIRCUMFLEX_ACCENT: 94,\n        CHAR_COLON: 58,\n        CHAR_COMMA: 44,\n        CHAR_DOT: 46,\n        CHAR_DOUBLE_QUOTE: 34,\n        CHAR_EQUAL: 61,\n        CHAR_EXCLAMATION_MARK: 33,\n        CHAR_FORM_FEED: 12,\n        CHAR_FORWARD_SLASH: 47,\n        CHAR_GRAVE_ACCENT: 96,\n        CHAR_HASH: 35,\n        CHAR_HYPHEN_MINUS: 45,\n        CHAR_LEFT_ANGLE_BRACKET: 60,\n        CHAR_LEFT_CURLY_BRACE: 123,\n        CHAR_LEFT_SQUARE_BRACKET: 91,\n        CHAR_LINE_FEED: 10,\n        CHAR_NO_BREAK_SPACE: 160,\n        CHAR_PERCENT: 37,\n        CHAR_PLUS: 43,\n        CHAR_QUESTION_MARK: 63,\n        CHAR_RIGHT_ANGLE_BRACKET: 62,\n        CHAR_RIGHT_CURLY_BRACE: 125,\n        CHAR_RIGHT_SQUARE_BRACKET: 93,\n        CHAR_SEMICOLON: 59,\n        CHAR_SINGLE_QUOTE: 39,\n        CHAR_SPACE: 32,\n        CHAR_TAB: 9,\n        CHAR_UNDERSCORE: 95,\n        CHAR_VERTICAL_LINE: 124,\n        CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n        SEP: n.sep,\n\n        extglobChars(e) {\n          return {\n            \"!\": {\n              type: \"negate\",\n              open: \"(?:(?!(?:\",\n              close: `))${e.STAR})`\n            },\n            \"?\": {\n              type: \"qmark\",\n              open: \"(?:\",\n              close: \")?\"\n            },\n            \"+\": {\n              type: \"plus\",\n              open: \"(?:\",\n              close: \")+\"\n            },\n            \"*\": {\n              type: \"star\",\n              open: \"(?:\",\n              close: \")*\"\n            },\n            \"@\": {\n              type: \"at\",\n              open: \"(?:\",\n              close: \")\"\n            }\n          };\n        },\n\n        globChars(e) {\n          return e === true ? x : d;\n        }\n\n      };\n    },\n    821: (e, t, r) => {\n      const n = r(871);\n      const u = r(243);\n      const {\n        MAX_LENGTH: s,\n        POSIX_REGEX_SOURCE: o,\n        REGEX_NON_SPECIAL_CHARS: i,\n        REGEX_SPECIAL_CHARS_BACKREF: a,\n        REPLACEMENTS: l\n      } = n;\n\n      const expandRange = (e, t) => {\n        if (typeof t.expandRange === \"function\") {\n          return t.expandRange(...e, t);\n        }\n\n        e.sort();\n        const r = `[${e.join(\"-\")}]`;\n\n        try {\n          new RegExp(r);\n        } catch (t) {\n          return e.map(e => u.escapeRegex(e)).join(\"..\");\n        }\n\n        return r;\n      };\n\n      const syntaxError = (e, t) => `Missing ${e}: \"${t}\" - use \"\\\\\\\\${t}\" to match literal characters`;\n\n      const parse = (e, t) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(\"Expected a string\");\n        }\n\n        e = l[e] || e;\n        const r = { ...t\n        };\n        const c = typeof r.maxLength === \"number\" ? Math.min(s, r.maxLength) : s;\n        let p = e.length;\n\n        if (p > c) {\n          throw new SyntaxError(`Input length: ${p}, exceeds maximum allowed length: ${c}`);\n        }\n\n        const f = {\n          type: \"bos\",\n          value: \"\",\n          output: r.prepend || \"\"\n        };\n        const A = [f];\n        const R = r.capture ? \"\" : \"?:\";\n\n        const _ = u.isWindows(t);\n\n        const h = n.globChars(_);\n        const g = n.extglobChars(h);\n        const {\n          DOT_LITERAL: E,\n          PLUS_LITERAL: C,\n          SLASH_LITERAL: y,\n          ONE_CHAR: d,\n          DOTS_SLASH: x,\n          NO_DOT: b,\n          NO_DOT_SLASH: S,\n          NO_DOTS_SLASH: H,\n          QMARK: v,\n          QMARK_NO_DOT: $,\n          STAR: m,\n          START_ANCHOR: T\n        } = h;\n\n        const globstar = e => `(${R}(?:(?!${T}${e.dot ? x : E}).)*?)`;\n\n        const L = r.dot ? \"\" : b;\n        const O = r.dot ? v : $;\n        let w = r.bash === true ? globstar(r) : m;\n\n        if (r.capture) {\n          w = `(${w})`;\n        }\n\n        if (typeof r.noext === \"boolean\") {\n          r.noextglob = r.noext;\n        }\n\n        const N = {\n          input: e,\n          index: -1,\n          start: 0,\n          dot: r.dot === true,\n          consumed: \"\",\n          output: \"\",\n          prefix: \"\",\n          backtrack: false,\n          negated: false,\n          brackets: 0,\n          braces: 0,\n          parens: 0,\n          quotes: 0,\n          globstar: false,\n          tokens: A\n        };\n        e = u.removePrefix(e, N);\n        p = e.length;\n        const k = [];\n        const I = [];\n        const M = [];\n        let P = f;\n        let B;\n\n        const eos = () => N.index === p - 1;\n\n        const G = N.peek = (t = 1) => e[N.index + t];\n\n        const D = N.advance = () => e[++N.index];\n\n        const remaining = () => e.slice(N.index + 1);\n\n        const consume = (e = \"\", t = 0) => {\n          N.consumed += e;\n          N.index += t;\n        };\n\n        const append = e => {\n          N.output += e.output != null ? e.output : e.value;\n          consume(e.value);\n        };\n\n        const negate = () => {\n          let e = 1;\n\n          while (G() === \"!\" && (G(2) !== \"(\" || G(3) === \"?\")) {\n            D();\n            N.start++;\n            e++;\n          }\n\n          if (e % 2 === 0) {\n            return false;\n          }\n\n          N.negated = true;\n          N.start++;\n          return true;\n        };\n\n        const increment = e => {\n          N[e]++;\n          M.push(e);\n        };\n\n        const decrement = e => {\n          N[e]--;\n          M.pop();\n        };\n\n        const push = e => {\n          if (P.type === \"globstar\") {\n            const t = N.braces > 0 && (e.type === \"comma\" || e.type === \"brace\");\n            const r = e.extglob === true || k.length && (e.type === \"pipe\" || e.type === \"paren\");\n\n            if (e.type !== \"slash\" && e.type !== \"paren\" && !t && !r) {\n              N.output = N.output.slice(0, -P.output.length);\n              P.type = \"star\";\n              P.value = \"*\";\n              P.output = w;\n              N.output += P.output;\n            }\n          }\n\n          if (k.length && e.type !== \"paren\" && !g[e.value]) {\n            k[k.length - 1].inner += e.value;\n          }\n\n          if (e.value || e.output) append(e);\n\n          if (P && P.type === \"text\" && e.type === \"text\") {\n            P.value += e.value;\n            P.output = (P.output || \"\") + e.value;\n            return;\n          }\n\n          e.prev = P;\n          A.push(e);\n          P = e;\n        };\n\n        const extglobOpen = (e, t) => {\n          const n = { ...g[t],\n            conditions: 1,\n            inner: \"\"\n          };\n          n.prev = P;\n          n.parens = N.parens;\n          n.output = N.output;\n          const u = (r.capture ? \"(\" : \"\") + n.open;\n          increment(\"parens\");\n          push({\n            type: e,\n            value: t,\n            output: N.output ? \"\" : d\n          });\n          push({\n            type: \"paren\",\n            extglob: true,\n            value: D(),\n            output: u\n          });\n          k.push(n);\n        };\n\n        const extglobClose = e => {\n          let t = e.close + (r.capture ? \")\" : \"\");\n\n          if (e.type === \"negate\") {\n            let n = w;\n\n            if (e.inner && e.inner.length > 1 && e.inner.includes(\"/\")) {\n              n = globstar(r);\n            }\n\n            if (n !== w || eos() || /^\\)+$/.test(remaining())) {\n              t = e.close = `)$))${n}`;\n            }\n\n            if (e.prev.type === \"bos\") {\n              N.negatedExtglob = true;\n            }\n          }\n\n          push({\n            type: \"paren\",\n            extglob: true,\n            value: B,\n            output: t\n          });\n          decrement(\"parens\");\n        };\n\n        if (r.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(e)) {\n          let n = false;\n          let s = e.replace(a, (e, t, r, u, s, o) => {\n            if (u === \"\\\\\") {\n              n = true;\n              return e;\n            }\n\n            if (u === \"?\") {\n              if (t) {\n                return t + u + (s ? v.repeat(s.length) : \"\");\n              }\n\n              if (o === 0) {\n                return O + (s ? v.repeat(s.length) : \"\");\n              }\n\n              return v.repeat(r.length);\n            }\n\n            if (u === \".\") {\n              return E.repeat(r.length);\n            }\n\n            if (u === \"*\") {\n              if (t) {\n                return t + u + (s ? w : \"\");\n              }\n\n              return w;\n            }\n\n            return t ? e : `\\\\${e}`;\n          });\n\n          if (n === true) {\n            if (r.unescape === true) {\n              s = s.replace(/\\\\/g, \"\");\n            } else {\n              s = s.replace(/\\\\+/g, e => e.length % 2 === 0 ? \"\\\\\\\\\" : e ? \"\\\\\" : \"\");\n            }\n          }\n\n          if (s === e && r.contains === true) {\n            N.output = e;\n            return N;\n          }\n\n          N.output = u.wrapOutput(s, N, t);\n          return N;\n        }\n\n        while (!eos()) {\n          B = D();\n\n          if (B === \"\\0\") {\n            continue;\n          }\n\n          if (B === \"\\\\\") {\n            const e = G();\n\n            if (e === \"/\" && r.bash !== true) {\n              continue;\n            }\n\n            if (e === \".\" || e === \";\") {\n              continue;\n            }\n\n            if (!e) {\n              B += \"\\\\\";\n              push({\n                type: \"text\",\n                value: B\n              });\n              continue;\n            }\n\n            const t = /^\\\\+/.exec(remaining());\n            let n = 0;\n\n            if (t && t[0].length > 2) {\n              n = t[0].length;\n              N.index += n;\n\n              if (n % 2 !== 0) {\n                B += \"\\\\\";\n              }\n            }\n\n            if (r.unescape === true) {\n              B = D() || \"\";\n            } else {\n              B += D() || \"\";\n            }\n\n            if (N.brackets === 0) {\n              push({\n                type: \"text\",\n                value: B\n              });\n              continue;\n            }\n          }\n\n          if (N.brackets > 0 && (B !== \"]\" || P.value === \"[\" || P.value === \"[^\")) {\n            if (r.posix !== false && B === \":\") {\n              const e = P.value.slice(1);\n\n              if (e.includes(\"[\")) {\n                P.posix = true;\n\n                if (e.includes(\":\")) {\n                  const e = P.value.lastIndexOf(\"[\");\n                  const t = P.value.slice(0, e);\n                  const r = P.value.slice(e + 2);\n                  const n = o[r];\n\n                  if (n) {\n                    P.value = t + n;\n                    N.backtrack = true;\n                    D();\n\n                    if (!f.output && A.indexOf(P) === 1) {\n                      f.output = d;\n                    }\n\n                    continue;\n                  }\n                }\n              }\n            }\n\n            if (B === \"[\" && G() !== \":\" || B === \"-\" && G() === \"]\") {\n              B = `\\\\${B}`;\n            }\n\n            if (B === \"]\" && (P.value === \"[\" || P.value === \"[^\")) {\n              B = `\\\\${B}`;\n            }\n\n            if (r.posix === true && B === \"!\" && P.value === \"[\") {\n              B = \"^\";\n            }\n\n            P.value += B;\n            append({\n              value: B\n            });\n            continue;\n          }\n\n          if (N.quotes === 1 && B !== '\"') {\n            B = u.escapeRegex(B);\n            P.value += B;\n            append({\n              value: B\n            });\n            continue;\n          }\n\n          if (B === '\"') {\n            N.quotes = N.quotes === 1 ? 0 : 1;\n\n            if (r.keepQuotes === true) {\n              push({\n                type: \"text\",\n                value: B\n              });\n            }\n\n            continue;\n          }\n\n          if (B === \"(\") {\n            increment(\"parens\");\n            push({\n              type: \"paren\",\n              value: B\n            });\n            continue;\n          }\n\n          if (B === \")\") {\n            if (N.parens === 0 && r.strictBrackets === true) {\n              throw new SyntaxError(syntaxError(\"opening\", \"(\"));\n            }\n\n            const e = k[k.length - 1];\n\n            if (e && N.parens === e.parens + 1) {\n              extglobClose(k.pop());\n              continue;\n            }\n\n            push({\n              type: \"paren\",\n              value: B,\n              output: N.parens ? \")\" : \"\\\\)\"\n            });\n            decrement(\"parens\");\n            continue;\n          }\n\n          if (B === \"[\") {\n            if (r.nobracket === true || !remaining().includes(\"]\")) {\n              if (r.nobracket !== true && r.strictBrackets === true) {\n                throw new SyntaxError(syntaxError(\"closing\", \"]\"));\n              }\n\n              B = `\\\\${B}`;\n            } else {\n              increment(\"brackets\");\n            }\n\n            push({\n              type: \"bracket\",\n              value: B\n            });\n            continue;\n          }\n\n          if (B === \"]\") {\n            if (r.nobracket === true || P && P.type === \"bracket\" && P.value.length === 1) {\n              push({\n                type: \"text\",\n                value: B,\n                output: `\\\\${B}`\n              });\n              continue;\n            }\n\n            if (N.brackets === 0) {\n              if (r.strictBrackets === true) {\n                throw new SyntaxError(syntaxError(\"opening\", \"[\"));\n              }\n\n              push({\n                type: \"text\",\n                value: B,\n                output: `\\\\${B}`\n              });\n              continue;\n            }\n\n            decrement(\"brackets\");\n            const e = P.value.slice(1);\n\n            if (P.posix !== true && e[0] === \"^\" && !e.includes(\"/\")) {\n              B = `/${B}`;\n            }\n\n            P.value += B;\n            append({\n              value: B\n            });\n\n            if (r.literalBrackets === false || u.hasRegexChars(e)) {\n              continue;\n            }\n\n            const t = u.escapeRegex(P.value);\n            N.output = N.output.slice(0, -P.value.length);\n\n            if (r.literalBrackets === true) {\n              N.output += t;\n              P.value = t;\n              continue;\n            }\n\n            P.value = `(${R}${t}|${P.value})`;\n            N.output += P.value;\n            continue;\n          }\n\n          if (B === \"{\" && r.nobrace !== true) {\n            increment(\"braces\");\n            const e = {\n              type: \"brace\",\n              value: B,\n              output: \"(\",\n              outputIndex: N.output.length,\n              tokensIndex: N.tokens.length\n            };\n            I.push(e);\n            push(e);\n            continue;\n          }\n\n          if (B === \"}\") {\n            const e = I[I.length - 1];\n\n            if (r.nobrace === true || !e) {\n              push({\n                type: \"text\",\n                value: B,\n                output: B\n              });\n              continue;\n            }\n\n            let t = \")\";\n\n            if (e.dots === true) {\n              const e = A.slice();\n              const n = [];\n\n              for (let t = e.length - 1; t >= 0; t--) {\n                A.pop();\n\n                if (e[t].type === \"brace\") {\n                  break;\n                }\n\n                if (e[t].type !== \"dots\") {\n                  n.unshift(e[t].value);\n                }\n              }\n\n              t = expandRange(n, r);\n              N.backtrack = true;\n            }\n\n            if (e.comma !== true && e.dots !== true) {\n              const r = N.output.slice(0, e.outputIndex);\n              const n = N.tokens.slice(e.tokensIndex);\n              e.value = e.output = \"\\\\{\";\n              B = t = \"\\\\}\";\n              N.output = r;\n\n              for (const e of n) {\n                N.output += e.output || e.value;\n              }\n            }\n\n            push({\n              type: \"brace\",\n              value: B,\n              output: t\n            });\n            decrement(\"braces\");\n            I.pop();\n            continue;\n          }\n\n          if (B === \"|\") {\n            if (k.length > 0) {\n              k[k.length - 1].conditions++;\n            }\n\n            push({\n              type: \"text\",\n              value: B\n            });\n            continue;\n          }\n\n          if (B === \",\") {\n            let e = B;\n            const t = I[I.length - 1];\n\n            if (t && M[M.length - 1] === \"braces\") {\n              t.comma = true;\n              e = \"|\";\n            }\n\n            push({\n              type: \"comma\",\n              value: B,\n              output: e\n            });\n            continue;\n          }\n\n          if (B === \"/\") {\n            if (P.type === \"dot\" && N.index === N.start + 1) {\n              N.start = N.index + 1;\n              N.consumed = \"\";\n              N.output = \"\";\n              A.pop();\n              P = f;\n              continue;\n            }\n\n            push({\n              type: \"slash\",\n              value: B,\n              output: y\n            });\n            continue;\n          }\n\n          if (B === \".\") {\n            if (N.braces > 0 && P.type === \"dot\") {\n              if (P.value === \".\") P.output = E;\n              const e = I[I.length - 1];\n              P.type = \"dots\";\n              P.output += B;\n              P.value += B;\n              e.dots = true;\n              continue;\n            }\n\n            if (N.braces + N.parens === 0 && P.type !== \"bos\" && P.type !== \"slash\") {\n              push({\n                type: \"text\",\n                value: B,\n                output: E\n              });\n              continue;\n            }\n\n            push({\n              type: \"dot\",\n              value: B,\n              output: E\n            });\n            continue;\n          }\n\n          if (B === \"?\") {\n            const e = P && P.value === \"(\";\n\n            if (!e && r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n              extglobOpen(\"qmark\", B);\n              continue;\n            }\n\n            if (P && P.type === \"paren\") {\n              const e = G();\n              let t = B;\n\n              if (e === \"<\" && !u.supportsLookbehinds()) {\n                throw new Error(\"Node.js v10 or higher is required for regex lookbehinds\");\n              }\n\n              if (P.value === \"(\" && !/[!=<:]/.test(e) || e === \"<\" && !/<([!=]|\\w+>)/.test(remaining())) {\n                t = `\\\\${B}`;\n              }\n\n              push({\n                type: \"text\",\n                value: B,\n                output: t\n              });\n              continue;\n            }\n\n            if (r.dot !== true && (P.type === \"slash\" || P.type === \"bos\")) {\n              push({\n                type: \"qmark\",\n                value: B,\n                output: $\n              });\n              continue;\n            }\n\n            push({\n              type: \"qmark\",\n              value: B,\n              output: v\n            });\n            continue;\n          }\n\n          if (B === \"!\") {\n            if (r.noextglob !== true && G() === \"(\") {\n              if (G(2) !== \"?\" || !/[!=<:]/.test(G(3))) {\n                extglobOpen(\"negate\", B);\n                continue;\n              }\n            }\n\n            if (r.nonegate !== true && N.index === 0) {\n              negate();\n              continue;\n            }\n          }\n\n          if (B === \"+\") {\n            if (r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n              extglobOpen(\"plus\", B);\n              continue;\n            }\n\n            if (P && P.value === \"(\" || r.regex === false) {\n              push({\n                type: \"plus\",\n                value: B,\n                output: C\n              });\n              continue;\n            }\n\n            if (P && (P.type === \"bracket\" || P.type === \"paren\" || P.type === \"brace\") || N.parens > 0) {\n              push({\n                type: \"plus\",\n                value: B\n              });\n              continue;\n            }\n\n            push({\n              type: \"plus\",\n              value: C\n            });\n            continue;\n          }\n\n          if (B === \"@\") {\n            if (r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n              push({\n                type: \"at\",\n                extglob: true,\n                value: B,\n                output: \"\"\n              });\n              continue;\n            }\n\n            push({\n              type: \"text\",\n              value: B\n            });\n            continue;\n          }\n\n          if (B !== \"*\") {\n            if (B === \"$\" || B === \"^\") {\n              B = `\\\\${B}`;\n            }\n\n            const e = i.exec(remaining());\n\n            if (e) {\n              B += e[0];\n              N.index += e[0].length;\n            }\n\n            push({\n              type: \"text\",\n              value: B\n            });\n            continue;\n          }\n\n          if (P && (P.type === \"globstar\" || P.star === true)) {\n            P.type = \"star\";\n            P.star = true;\n            P.value += B;\n            P.output = w;\n            N.backtrack = true;\n            N.globstar = true;\n            consume(B);\n            continue;\n          }\n\n          let t = remaining();\n\n          if (r.noextglob !== true && /^\\([^?]/.test(t)) {\n            extglobOpen(\"star\", B);\n            continue;\n          }\n\n          if (P.type === \"star\") {\n            if (r.noglobstar === true) {\n              consume(B);\n              continue;\n            }\n\n            const n = P.prev;\n            const u = n.prev;\n            const s = n.type === \"slash\" || n.type === \"bos\";\n            const o = u && (u.type === \"star\" || u.type === \"globstar\");\n\n            if (r.bash === true && (!s || t[0] && t[0] !== \"/\")) {\n              push({\n                type: \"star\",\n                value: B,\n                output: \"\"\n              });\n              continue;\n            }\n\n            const i = N.braces > 0 && (n.type === \"comma\" || n.type === \"brace\");\n            const a = k.length && (n.type === \"pipe\" || n.type === \"paren\");\n\n            if (!s && n.type !== \"paren\" && !i && !a) {\n              push({\n                type: \"star\",\n                value: B,\n                output: \"\"\n              });\n              continue;\n            }\n\n            while (t.slice(0, 3) === \"/**\") {\n              const r = e[N.index + 4];\n\n              if (r && r !== \"/\") {\n                break;\n              }\n\n              t = t.slice(3);\n              consume(\"/**\", 3);\n            }\n\n            if (n.type === \"bos\" && eos()) {\n              P.type = \"globstar\";\n              P.value += B;\n              P.output = globstar(r);\n              N.output = P.output;\n              N.globstar = true;\n              consume(B);\n              continue;\n            }\n\n            if (n.type === \"slash\" && n.prev.type !== \"bos\" && !o && eos()) {\n              N.output = N.output.slice(0, -(n.output + P.output).length);\n              n.output = `(?:${n.output}`;\n              P.type = \"globstar\";\n              P.output = globstar(r) + (r.strictSlashes ? \")\" : \"|$)\");\n              P.value += B;\n              N.globstar = true;\n              N.output += n.output + P.output;\n              consume(B);\n              continue;\n            }\n\n            if (n.type === \"slash\" && n.prev.type !== \"bos\" && t[0] === \"/\") {\n              const e = t[1] !== void 0 ? \"|$\" : \"\";\n              N.output = N.output.slice(0, -(n.output + P.output).length);\n              n.output = `(?:${n.output}`;\n              P.type = \"globstar\";\n              P.output = `${globstar(r)}${y}|${y}${e})`;\n              P.value += B;\n              N.output += n.output + P.output;\n              N.globstar = true;\n              consume(B + D());\n              push({\n                type: \"slash\",\n                value: \"/\",\n                output: \"\"\n              });\n              continue;\n            }\n\n            if (n.type === \"bos\" && t[0] === \"/\") {\n              P.type = \"globstar\";\n              P.value += B;\n              P.output = `(?:^|${y}|${globstar(r)}${y})`;\n              N.output = P.output;\n              N.globstar = true;\n              consume(B + D());\n              push({\n                type: \"slash\",\n                value: \"/\",\n                output: \"\"\n              });\n              continue;\n            }\n\n            N.output = N.output.slice(0, -P.output.length);\n            P.type = \"globstar\";\n            P.output = globstar(r);\n            P.value += B;\n            N.output += P.output;\n            N.globstar = true;\n            consume(B);\n            continue;\n          }\n\n          const n = {\n            type: \"star\",\n            value: B,\n            output: w\n          };\n\n          if (r.bash === true) {\n            n.output = \".*?\";\n\n            if (P.type === \"bos\" || P.type === \"slash\") {\n              n.output = L + n.output;\n            }\n\n            push(n);\n            continue;\n          }\n\n          if (P && (P.type === \"bracket\" || P.type === \"paren\") && r.regex === true) {\n            n.output = B;\n            push(n);\n            continue;\n          }\n\n          if (N.index === N.start || P.type === \"slash\" || P.type === \"dot\") {\n            if (P.type === \"dot\") {\n              N.output += S;\n              P.output += S;\n            } else if (r.dot === true) {\n              N.output += H;\n              P.output += H;\n            } else {\n              N.output += L;\n              P.output += L;\n            }\n\n            if (G() !== \"*\") {\n              N.output += d;\n              P.output += d;\n            }\n          }\n\n          push(n);\n        }\n\n        while (N.brackets > 0) {\n          if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \"]\"));\n          N.output = u.escapeLast(N.output, \"[\");\n          decrement(\"brackets\");\n        }\n\n        while (N.parens > 0) {\n          if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \")\"));\n          N.output = u.escapeLast(N.output, \"(\");\n          decrement(\"parens\");\n        }\n\n        while (N.braces > 0) {\n          if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \"}\"));\n          N.output = u.escapeLast(N.output, \"{\");\n          decrement(\"braces\");\n        }\n\n        if (r.strictSlashes !== true && (P.type === \"star\" || P.type === \"bracket\")) {\n          push({\n            type: \"maybe_slash\",\n            value: \"\",\n            output: `${y}?`\n          });\n        }\n\n        if (N.backtrack === true) {\n          N.output = \"\";\n\n          for (const e of N.tokens) {\n            N.output += e.output != null ? e.output : e.value;\n\n            if (e.suffix) {\n              N.output += e.suffix;\n            }\n          }\n        }\n\n        return N;\n      };\n\n      parse.fastpaths = (e, t) => {\n        const r = { ...t\n        };\n        const o = typeof r.maxLength === \"number\" ? Math.min(s, r.maxLength) : s;\n        const i = e.length;\n\n        if (i > o) {\n          throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${o}`);\n        }\n\n        e = l[e] || e;\n        const a = u.isWindows(t);\n        const {\n          DOT_LITERAL: c,\n          SLASH_LITERAL: p,\n          ONE_CHAR: f,\n          DOTS_SLASH: A,\n          NO_DOT: R,\n          NO_DOTS: _,\n          NO_DOTS_SLASH: h,\n          STAR: g,\n          START_ANCHOR: E\n        } = n.globChars(a);\n        const C = r.dot ? _ : R;\n        const y = r.dot ? h : R;\n        const d = r.capture ? \"\" : \"?:\";\n        const x = {\n          negated: false,\n          prefix: \"\"\n        };\n        let b = r.bash === true ? \".*?\" : g;\n\n        if (r.capture) {\n          b = `(${b})`;\n        }\n\n        const globstar = e => {\n          if (e.noglobstar === true) return b;\n          return `(${d}(?:(?!${E}${e.dot ? A : c}).)*?)`;\n        };\n\n        const create = e => {\n          switch (e) {\n            case \"*\":\n              return `${C}${f}${b}`;\n\n            case \".*\":\n              return `${c}${f}${b}`;\n\n            case \"*.*\":\n              return `${C}${b}${c}${f}${b}`;\n\n            case \"*/*\":\n              return `${C}${b}${p}${f}${y}${b}`;\n\n            case \"**\":\n              return C + globstar(r);\n\n            case \"**/*\":\n              return `(?:${C}${globstar(r)}${p})?${y}${f}${b}`;\n\n            case \"**/*.*\":\n              return `(?:${C}${globstar(r)}${p})?${y}${b}${c}${f}${b}`;\n\n            case \"**/.*\":\n              return `(?:${C}${globstar(r)}${p})?${c}${f}${b}`;\n\n            default:\n              {\n                const t = /^(.*?)\\.(\\w+)$/.exec(e);\n                if (!t) return;\n                const r = create(t[1]);\n                if (!r) return;\n                return r + c + t[2];\n              }\n          }\n        };\n\n        const S = u.removePrefix(e, x);\n        let H = create(S);\n\n        if (H && r.strictSlashes !== true) {\n          H += `${p}?`;\n        }\n\n        return H;\n      };\n\n      e.exports = parse;\n    },\n    509: (e, t, r) => {\n      const n = r(17);\n      const u = r(216);\n      const s = r(821);\n      const o = r(243);\n      const i = r(871);\n\n      const isObject = e => e && typeof e === \"object\" && !Array.isArray(e);\n\n      const picomatch = (e, t, r = false) => {\n        if (Array.isArray(e)) {\n          const n = e.map(e => picomatch(e, t, r));\n\n          const arrayMatcher = e => {\n            for (const t of n) {\n              const r = t(e);\n              if (r) return r;\n            }\n\n            return false;\n          };\n\n          return arrayMatcher;\n        }\n\n        const n = isObject(e) && e.tokens && e.input;\n\n        if (e === \"\" || typeof e !== \"string\" && !n) {\n          throw new TypeError(\"Expected pattern to be a non-empty string\");\n        }\n\n        const u = t || {};\n        const s = o.isWindows(t);\n        const i = n ? picomatch.compileRe(e, t) : picomatch.makeRe(e, t, false, true);\n        const a = i.state;\n        delete i.state;\n\n        let isIgnored = () => false;\n\n        if (u.ignore) {\n          const e = { ...t,\n            ignore: null,\n            onMatch: null,\n            onResult: null\n          };\n          isIgnored = picomatch(u.ignore, e, r);\n        }\n\n        const matcher = (r, n = false) => {\n          const {\n            isMatch: o,\n            match: l,\n            output: c\n          } = picomatch.test(r, i, t, {\n            glob: e,\n            posix: s\n          });\n          const p = {\n            glob: e,\n            state: a,\n            regex: i,\n            posix: s,\n            input: r,\n            output: c,\n            match: l,\n            isMatch: o\n          };\n\n          if (typeof u.onResult === \"function\") {\n            u.onResult(p);\n          }\n\n          if (o === false) {\n            p.isMatch = false;\n            return n ? p : false;\n          }\n\n          if (isIgnored(r)) {\n            if (typeof u.onIgnore === \"function\") {\n              u.onIgnore(p);\n            }\n\n            p.isMatch = false;\n            return n ? p : false;\n          }\n\n          if (typeof u.onMatch === \"function\") {\n            u.onMatch(p);\n          }\n\n          return n ? p : true;\n        };\n\n        if (r) {\n          matcher.state = a;\n        }\n\n        return matcher;\n      };\n\n      picomatch.test = (e, t, r, {\n        glob: n,\n        posix: u\n      } = {}) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(\"Expected input to be a string\");\n        }\n\n        if (e === \"\") {\n          return {\n            isMatch: false,\n            output: \"\"\n          };\n        }\n\n        const s = r || {};\n        const i = s.format || (u ? o.toPosixSlashes : null);\n        let a = e === n;\n        let l = a && i ? i(e) : e;\n\n        if (a === false) {\n          l = i ? i(e) : e;\n          a = l === n;\n        }\n\n        if (a === false || s.capture === true) {\n          if (s.matchBase === true || s.basename === true) {\n            a = picomatch.matchBase(e, t, r, u);\n          } else {\n            a = t.exec(l);\n          }\n        }\n\n        return {\n          isMatch: Boolean(a),\n          match: a,\n          output: l\n        };\n      };\n\n      picomatch.matchBase = (e, t, r, u = o.isWindows(r)) => {\n        const s = t instanceof RegExp ? t : picomatch.makeRe(t, r);\n        return s.test(n.basename(e));\n      };\n\n      picomatch.isMatch = (e, t, r) => picomatch(t, r)(e);\n\n      picomatch.parse = (e, t) => {\n        if (Array.isArray(e)) return e.map(e => picomatch.parse(e, t));\n        return s(e, { ...t,\n          fastpaths: false\n        });\n      };\n\n      picomatch.scan = (e, t) => u(e, t);\n\n      picomatch.compileRe = (e, t, r = false, n = false) => {\n        if (r === true) {\n          return e.output;\n        }\n\n        const u = t || {};\n        const s = u.contains ? \"\" : \"^\";\n        const o = u.contains ? \"\" : \"$\";\n        let i = `${s}(?:${e.output})${o}`;\n\n        if (e && e.negated === true) {\n          i = `^(?!${i}).*$`;\n        }\n\n        const a = picomatch.toRegex(i, t);\n\n        if (n === true) {\n          a.state = e;\n        }\n\n        return a;\n      };\n\n      picomatch.makeRe = (e, t, r = false, n = false) => {\n        if (!e || typeof e !== \"string\") {\n          throw new TypeError(\"Expected a non-empty string\");\n        }\n\n        const u = t || {};\n        let o = {\n          negated: false,\n          fastpaths: true\n        };\n        let i = \"\";\n        let a;\n\n        if (e.startsWith(\"./\")) {\n          e = e.slice(2);\n          i = o.prefix = \"./\";\n        }\n\n        if (u.fastpaths !== false && (e[0] === \".\" || e[0] === \"*\")) {\n          a = s.fastpaths(e, t);\n        }\n\n        if (a === undefined) {\n          o = s(e, t);\n          o.prefix = i + (o.prefix || \"\");\n        } else {\n          o.output = a;\n        }\n\n        return picomatch.compileRe(o, t, r, n);\n      };\n\n      picomatch.toRegex = (e, t) => {\n        try {\n          const r = t || {};\n          return new RegExp(e, r.flags || (r.nocase ? \"i\" : \"\"));\n        } catch (e) {\n          if (t && t.debug === true) throw e;\n          return /$^/;\n        }\n      };\n\n      picomatch.constants = i;\n      e.exports = picomatch;\n    },\n    216: (e, t, r) => {\n      const n = r(243);\n      const {\n        CHAR_ASTERISK: u,\n        CHAR_AT: s,\n        CHAR_BACKWARD_SLASH: o,\n        CHAR_COMMA: i,\n        CHAR_DOT: a,\n        CHAR_EXCLAMATION_MARK: l,\n        CHAR_FORWARD_SLASH: c,\n        CHAR_LEFT_CURLY_BRACE: p,\n        CHAR_LEFT_PARENTHESES: f,\n        CHAR_LEFT_SQUARE_BRACKET: A,\n        CHAR_PLUS: R,\n        CHAR_QUESTION_MARK: _,\n        CHAR_RIGHT_CURLY_BRACE: h,\n        CHAR_RIGHT_PARENTHESES: g,\n        CHAR_RIGHT_SQUARE_BRACKET: E\n      } = r(871);\n\n      const isPathSeparator = e => e === c || e === o;\n\n      const depth = e => {\n        if (e.isPrefix !== true) {\n          e.depth = e.isGlobstar ? Infinity : 1;\n        }\n      };\n\n      const scan = (e, t) => {\n        const r = t || {};\n        const C = e.length - 1;\n        const y = r.parts === true || r.scanToEnd === true;\n        const d = [];\n        const x = [];\n        const b = [];\n        let S = e;\n        let H = -1;\n        let v = 0;\n        let $ = 0;\n        let m = false;\n        let T = false;\n        let L = false;\n        let O = false;\n        let w = false;\n        let N = false;\n        let k = false;\n        let I = false;\n        let M = false;\n        let P = 0;\n        let B;\n        let G;\n        let D = {\n          value: \"\",\n          depth: 0,\n          isGlob: false\n        };\n\n        const eos = () => H >= C;\n\n        const peek = () => S.charCodeAt(H + 1);\n\n        const advance = () => {\n          B = G;\n          return S.charCodeAt(++H);\n        };\n\n        while (H < C) {\n          G = advance();\n          let e;\n\n          if (G === o) {\n            k = D.backslashes = true;\n            G = advance();\n\n            if (G === p) {\n              N = true;\n            }\n\n            continue;\n          }\n\n          if (N === true || G === p) {\n            P++;\n\n            while (eos() !== true && (G = advance())) {\n              if (G === o) {\n                k = D.backslashes = true;\n                advance();\n                continue;\n              }\n\n              if (G === p) {\n                P++;\n                continue;\n              }\n\n              if (N !== true && G === a && (G = advance()) === a) {\n                m = D.isBrace = true;\n                L = D.isGlob = true;\n                M = true;\n\n                if (y === true) {\n                  continue;\n                }\n\n                break;\n              }\n\n              if (N !== true && G === i) {\n                m = D.isBrace = true;\n                L = D.isGlob = true;\n                M = true;\n\n                if (y === true) {\n                  continue;\n                }\n\n                break;\n              }\n\n              if (G === h) {\n                P--;\n\n                if (P === 0) {\n                  N = false;\n                  m = D.isBrace = true;\n                  M = true;\n                  break;\n                }\n              }\n            }\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n\n          if (G === c) {\n            d.push(H);\n            x.push(D);\n            D = {\n              value: \"\",\n              depth: 0,\n              isGlob: false\n            };\n            if (M === true) continue;\n\n            if (B === a && H === v + 1) {\n              v += 2;\n              continue;\n            }\n\n            $ = H + 1;\n            continue;\n          }\n\n          if (r.noext !== true) {\n            const e = G === R || G === s || G === u || G === _ || G === l;\n\n            if (e === true && peek() === f) {\n              L = D.isGlob = true;\n              O = D.isExtglob = true;\n              M = true;\n\n              if (y === true) {\n                while (eos() !== true && (G = advance())) {\n                  if (G === o) {\n                    k = D.backslashes = true;\n                    G = advance();\n                    continue;\n                  }\n\n                  if (G === g) {\n                    L = D.isGlob = true;\n                    M = true;\n                    break;\n                  }\n                }\n\n                continue;\n              }\n\n              break;\n            }\n          }\n\n          if (G === u) {\n            if (B === u) w = D.isGlobstar = true;\n            L = D.isGlob = true;\n            M = true;\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n\n          if (G === _) {\n            L = D.isGlob = true;\n            M = true;\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n\n          if (G === A) {\n            while (eos() !== true && (e = advance())) {\n              if (e === o) {\n                k = D.backslashes = true;\n                advance();\n                continue;\n              }\n\n              if (e === E) {\n                T = D.isBracket = true;\n                L = D.isGlob = true;\n                M = true;\n                break;\n              }\n            }\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n\n          if (r.nonegate !== true && G === l && H === v) {\n            I = D.negated = true;\n            v++;\n            continue;\n          }\n\n          if (r.noparen !== true && G === f) {\n            L = D.isGlob = true;\n\n            if (y === true) {\n              while (eos() !== true && (G = advance())) {\n                if (G === f) {\n                  k = D.backslashes = true;\n                  G = advance();\n                  continue;\n                }\n\n                if (G === g) {\n                  M = true;\n                  break;\n                }\n              }\n\n              continue;\n            }\n\n            break;\n          }\n\n          if (L === true) {\n            M = true;\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n        }\n\n        if (r.noext === true) {\n          O = false;\n          L = false;\n        }\n\n        let U = S;\n        let K = \"\";\n        let F = \"\";\n\n        if (v > 0) {\n          K = S.slice(0, v);\n          S = S.slice(v);\n          $ -= v;\n        }\n\n        if (U && L === true && $ > 0) {\n          U = S.slice(0, $);\n          F = S.slice($);\n        } else if (L === true) {\n          U = \"\";\n          F = S;\n        } else {\n          U = S;\n        }\n\n        if (U && U !== \"\" && U !== \"/\" && U !== S) {\n          if (isPathSeparator(U.charCodeAt(U.length - 1))) {\n            U = U.slice(0, -1);\n          }\n        }\n\n        if (r.unescape === true) {\n          if (F) F = n.removeBackslashes(F);\n\n          if (U && k === true) {\n            U = n.removeBackslashes(U);\n          }\n        }\n\n        const Q = {\n          prefix: K,\n          input: e,\n          start: v,\n          base: U,\n          glob: F,\n          isBrace: m,\n          isBracket: T,\n          isGlob: L,\n          isExtglob: O,\n          isGlobstar: w,\n          negated: I\n        };\n\n        if (r.tokens === true) {\n          Q.maxDepth = 0;\n\n          if (!isPathSeparator(G)) {\n            x.push(D);\n          }\n\n          Q.tokens = x;\n        }\n\n        if (r.parts === true || r.tokens === true) {\n          let t;\n\n          for (let n = 0; n < d.length; n++) {\n            const u = t ? t + 1 : v;\n            const s = d[n];\n            const o = e.slice(u, s);\n\n            if (r.tokens) {\n              if (n === 0 && v !== 0) {\n                x[n].isPrefix = true;\n                x[n].value = K;\n              } else {\n                x[n].value = o;\n              }\n\n              depth(x[n]);\n              Q.maxDepth += x[n].depth;\n            }\n\n            if (n !== 0 || o !== \"\") {\n              b.push(o);\n            }\n\n            t = s;\n          }\n\n          if (t && t + 1 < e.length) {\n            const n = e.slice(t + 1);\n            b.push(n);\n\n            if (r.tokens) {\n              x[x.length - 1].value = n;\n              depth(x[x.length - 1]);\n              Q.maxDepth += x[x.length - 1].depth;\n            }\n          }\n\n          Q.slashes = d;\n          Q.parts = b;\n        }\n\n        return Q;\n      };\n\n      e.exports = scan;\n    },\n    243: (e, t, r) => {\n      const n = r(17);\n      const u = process.platform === \"win32\";\n      const {\n        REGEX_BACKSLASH: s,\n        REGEX_REMOVE_BACKSLASH: o,\n        REGEX_SPECIAL_CHARS: i,\n        REGEX_SPECIAL_CHARS_GLOBAL: a\n      } = r(871);\n\n      t.isObject = e => e !== null && typeof e === \"object\" && !Array.isArray(e);\n\n      t.hasRegexChars = e => i.test(e);\n\n      t.isRegexChar = e => e.length === 1 && t.hasRegexChars(e);\n\n      t.escapeRegex = e => e.replace(a, \"\\\\$1\");\n\n      t.toPosixSlashes = e => e.replace(s, \"/\");\n\n      t.removeBackslashes = e => e.replace(o, e => e === \"\\\\\" ? \"\" : e);\n\n      t.supportsLookbehinds = () => {\n        const e = process.version.slice(1).split(\".\").map(Number);\n\n        if (e.length === 3 && e[0] >= 9 || e[0] === 8 && e[1] >= 10) {\n          return true;\n        }\n\n        return false;\n      };\n\n      t.isWindows = e => {\n        if (e && typeof e.windows === \"boolean\") {\n          return e.windows;\n        }\n\n        return u === true || n.sep === \"\\\\\";\n      };\n\n      t.escapeLast = (e, r, n) => {\n        const u = e.lastIndexOf(r, n);\n        if (u === -1) return e;\n        if (e[u - 1] === \"\\\\\") return t.escapeLast(e, r, u - 1);\n        return `${e.slice(0, u)}\\\\${e.slice(u)}`;\n      };\n\n      t.removePrefix = (e, t = {}) => {\n        let r = e;\n\n        if (r.startsWith(\"./\")) {\n          r = r.slice(2);\n          t.prefix = \"./\";\n        }\n\n        return r;\n      };\n\n      t.wrapOutput = (e, t = {}, r = {}) => {\n        const n = r.contains ? \"\" : \"^\";\n        const u = r.contains ? \"\" : \"$\";\n        let s = `${n}(?:${e})${u}`;\n\n        if (t.negated === true) {\n          s = `(?:^(?!${s}).*$)`;\n        }\n\n        return s;\n      };\n    },\n    368: (e, t, r) => {\n      /*!\r\n       * to-regex-range <https://github.com/micromatch/to-regex-range>\r\n       *\r\n       * Copyright (c) 2015-present, Jon Schlinkert.\r\n       * Released under the MIT License.\r\n       */\n      const n = r(773);\n\n      const toRegexRange = (e, t, r) => {\n        if (n(e) === false) {\n          throw new TypeError(\"toRegexRange: expected the first argument to be a number\");\n        }\n\n        if (t === void 0 || e === t) {\n          return String(e);\n        }\n\n        if (n(t) === false) {\n          throw new TypeError(\"toRegexRange: expected the second argument to be a number.\");\n        }\n\n        let u = {\n          relaxZeros: true,\n          ...r\n        };\n\n        if (typeof u.strictZeros === \"boolean\") {\n          u.relaxZeros = u.strictZeros === false;\n        }\n\n        let s = String(u.relaxZeros);\n        let o = String(u.shorthand);\n        let i = String(u.capture);\n        let a = String(u.wrap);\n        let l = e + \":\" + t + \"=\" + s + o + i + a;\n\n        if (toRegexRange.cache.hasOwnProperty(l)) {\n          return toRegexRange.cache[l].result;\n        }\n\n        let c = Math.min(e, t);\n        let p = Math.max(e, t);\n\n        if (Math.abs(c - p) === 1) {\n          let r = e + \"|\" + t;\n\n          if (u.capture) {\n            return `(${r})`;\n          }\n\n          if (u.wrap === false) {\n            return r;\n          }\n\n          return `(?:${r})`;\n        }\n\n        let f = hasPadding(e) || hasPadding(t);\n        let A = {\n          min: e,\n          max: t,\n          a: c,\n          b: p\n        };\n        let R = [];\n        let _ = [];\n\n        if (f) {\n          A.isPadded = f;\n          A.maxLen = String(A.max).length;\n        }\n\n        if (c < 0) {\n          let e = p < 0 ? Math.abs(p) : 1;\n          _ = splitToPatterns(e, Math.abs(c), A, u);\n          c = A.a = 0;\n        }\n\n        if (p >= 0) {\n          R = splitToPatterns(c, p, A, u);\n        }\n\n        A.negatives = _;\n        A.positives = R;\n        A.result = collatePatterns(_, R, u);\n\n        if (u.capture === true) {\n          A.result = `(${A.result})`;\n        } else if (u.wrap !== false && R.length + _.length > 1) {\n          A.result = `(?:${A.result})`;\n        }\n\n        toRegexRange.cache[l] = A;\n        return A.result;\n      };\n\n      function collatePatterns(e, t, r) {\n        let n = filterPatterns(e, t, \"-\", false, r) || [];\n        let u = filterPatterns(t, e, \"\", false, r) || [];\n        let s = filterPatterns(e, t, \"-?\", true, r) || [];\n        let o = n.concat(s).concat(u);\n        return o.join(\"|\");\n      }\n\n      function splitToRanges(e, t) {\n        let r = 1;\n        let n = 1;\n        let u = countNines(e, r);\n        let s = new Set([t]);\n\n        while (e <= u && u <= t) {\n          s.add(u);\n          r += 1;\n          u = countNines(e, r);\n        }\n\n        u = countZeros(t + 1, n) - 1;\n\n        while (e < u && u <= t) {\n          s.add(u);\n          n += 1;\n          u = countZeros(t + 1, n) - 1;\n        }\n\n        s = [...s];\n        s.sort(compare);\n        return s;\n      }\n\n      function rangeToPattern(e, t, r) {\n        if (e === t) {\n          return {\n            pattern: e,\n            count: [],\n            digits: 0\n          };\n        }\n\n        let n = zip(e, t);\n        let u = n.length;\n        let s = \"\";\n        let o = 0;\n\n        for (let e = 0; e < u; e++) {\n          let [t, u] = n[e];\n\n          if (t === u) {\n            s += t;\n          } else if (t !== \"0\" || u !== \"9\") {\n            s += toCharacterClass(t, u, r);\n          } else {\n            o++;\n          }\n        }\n\n        if (o) {\n          s += r.shorthand === true ? \"\\\\d\" : \"[0-9]\";\n        }\n\n        return {\n          pattern: s,\n          count: [o],\n          digits: u\n        };\n      }\n\n      function splitToPatterns(e, t, r, n) {\n        let u = splitToRanges(e, t);\n        let s = [];\n        let o = e;\n        let i;\n\n        for (let e = 0; e < u.length; e++) {\n          let t = u[e];\n          let a = rangeToPattern(String(o), String(t), n);\n          let l = \"\";\n\n          if (!r.isPadded && i && i.pattern === a.pattern) {\n            if (i.count.length > 1) {\n              i.count.pop();\n            }\n\n            i.count.push(a.count[0]);\n            i.string = i.pattern + toQuantifier(i.count);\n            o = t + 1;\n            continue;\n          }\n\n          if (r.isPadded) {\n            l = padZeros(t, r, n);\n          }\n\n          a.string = l + a.pattern + toQuantifier(a.count);\n          s.push(a);\n          o = t + 1;\n          i = a;\n        }\n\n        return s;\n      }\n\n      function filterPatterns(e, t, r, n, u) {\n        let s = [];\n\n        for (let u of e) {\n          let {\n            string: e\n          } = u;\n\n          if (!n && !contains(t, \"string\", e)) {\n            s.push(r + e);\n          }\n\n          if (n && contains(t, \"string\", e)) {\n            s.push(r + e);\n          }\n        }\n\n        return s;\n      }\n\n      function zip(e, t) {\n        let r = [];\n\n        for (let n = 0; n < e.length; n++) r.push([e[n], t[n]]);\n\n        return r;\n      }\n\n      function compare(e, t) {\n        return e > t ? 1 : t > e ? -1 : 0;\n      }\n\n      function contains(e, t, r) {\n        return e.some(e => e[t] === r);\n      }\n\n      function countNines(e, t) {\n        return Number(String(e).slice(0, -t) + \"9\".repeat(t));\n      }\n\n      function countZeros(e, t) {\n        return e - e % Math.pow(10, t);\n      }\n\n      function toQuantifier(e) {\n        let [t = 0, r = \"\"] = e;\n\n        if (r || t > 1) {\n          return `{${t + (r ? \",\" + r : \"\")}}`;\n        }\n\n        return \"\";\n      }\n\n      function toCharacterClass(e, t, r) {\n        return `[${e}${t - e === 1 ? \"\" : \"-\"}${t}]`;\n      }\n\n      function hasPadding(e) {\n        return /^-?(0+)\\d/.test(e);\n      }\n\n      function padZeros(e, t, r) {\n        if (!t.isPadded) {\n          return e;\n        }\n\n        let n = Math.abs(t.maxLen - String(e).length);\n        let u = r.relaxZeros !== false;\n\n        switch (n) {\n          case 0:\n            return \"\";\n\n          case 1:\n            return u ? \"0?\" : \"0\";\n\n          case 2:\n            return u ? \"0{0,2}\" : \"00\";\n\n          default:\n            {\n              return u ? `0{0,${n}}` : `0{${n}}`;\n            }\n        }\n      }\n\n      toRegexRange.cache = {};\n\n      toRegexRange.clearCache = () => toRegexRange.cache = {};\n\n      e.exports = toRegexRange;\n    },\n    17: e => {\n      e.exports = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\n    },\n    837: e => {\n      e.exports = __webpack_require__(/*! util */ \"./node_modules/next/dist/compiled/util/util.js\");\n    }\n  };\n  var t = {};\n\n  function __nccwpck_require__(r) {\n    var n = t[r];\n\n    if (n !== undefined) {\n      return n.exports;\n    }\n\n    var u = t[r] = {\n      exports: {}\n    };\n    var s = true;\n\n    try {\n      e[r](u, u.exports, __nccwpck_require__);\n      s = false;\n    } finally {\n      if (s) delete t[r];\n    }\n\n    return u.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var r = __nccwpck_require__(888);\n\n  module.exports = r;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2gvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQSxDQUFDLE1BQUk7RUFBQzs7RUFBYSxJQUFJQSxDQUFDLEdBQUM7SUFBQyxLQUFJLENBQUNBLENBQUQsRUFBR0MsQ0FBSCxFQUFLQyxDQUFMLEtBQVM7TUFBQyxNQUFNQyxDQUFDLEdBQUNELENBQUMsQ0FBQyxHQUFELENBQVQ7TUFBZSxNQUFNRSxDQUFDLEdBQUNGLENBQUMsQ0FBQyxHQUFELENBQVQ7TUFBZSxNQUFNRyxDQUFDLEdBQUNILENBQUMsQ0FBQyxHQUFELENBQVQ7TUFBZSxNQUFNSSxDQUFDLEdBQUNKLENBQUMsQ0FBQyxHQUFELENBQVQ7O01BQWUsTUFBTUssTUFBTSxHQUFDLENBQUNQLENBQUQsRUFBR0MsQ0FBQyxHQUFDLEVBQUwsS0FBVTtRQUFDLElBQUlDLENBQUMsR0FBQyxFQUFOOztRQUFTLElBQUdNLEtBQUssQ0FBQ0MsT0FBTixDQUFjVCxDQUFkLENBQUgsRUFBb0I7VUFBQyxLQUFJLElBQUlHLENBQVIsSUFBYUgsQ0FBYixFQUFlO1lBQUMsSUFBSUEsQ0FBQyxHQUFDTyxNQUFNLENBQUNHLE1BQVAsQ0FBY1AsQ0FBZCxFQUFnQkYsQ0FBaEIsQ0FBTjs7WUFBeUIsSUFBR08sS0FBSyxDQUFDQyxPQUFOLENBQWNULENBQWQsQ0FBSCxFQUFvQjtjQUFDRSxDQUFDLENBQUNTLElBQUYsQ0FBTyxHQUFHWCxDQUFWO1lBQWEsQ0FBbEMsTUFBc0M7Y0FBQ0UsQ0FBQyxDQUFDUyxJQUFGLENBQU9YLENBQVA7WUFBVTtVQUFDO1FBQUMsQ0FBakgsTUFBcUg7VUFBQ0UsQ0FBQyxHQUFDLEdBQUdVLE1BQUgsQ0FBVUwsTUFBTSxDQUFDRyxNQUFQLENBQWNWLENBQWQsRUFBZ0JDLENBQWhCLENBQVYsQ0FBRjtRQUFnQzs7UUFBQSxJQUFHQSxDQUFDLElBQUVBLENBQUMsQ0FBQ1ksTUFBRixLQUFXLElBQWQsSUFBb0Ja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OztJQUFXLElBQUc7TUFBQ0wsQ0FBQyxDQUFDRSxDQUFELENBQUQsQ0FBS0UsQ0FBTCxFQUFPQSxDQUFDLENBQUNtQixPQUFULEVBQWlCa1gsbUJBQWpCO01BQXNDcFksQ0FBQyxHQUFDLEtBQUY7SUFBUSxDQUFsRCxTQUF5RDtNQUFDLElBQUdBLENBQUgsRUFBSyxPQUFPSixDQUFDLENBQUNDLENBQUQsQ0FBUjtJQUFZOztJQUFBLE9BQU9FLENBQUMsQ0FBQ21CLE9BQVQ7RUFBaUI7O0VBQUEsSUFBRyxPQUFPa1gsbUJBQVAsS0FBNkIsV0FBaEMsRUFBNENBLG1CQUFtQixDQUFDQyxFQUFwQixHQUF1QkMsU0FBUyxHQUFDLEdBQWpDOztFQUFxQyxJQUFJelksQ0FBQyxHQUFDdVksbUJBQW1CLENBQUMsR0FBRCxDQUF6Qjs7RUFBK0JHLE1BQU0sQ0FBQ3JYLE9BQVAsR0FBZXJCLENBQWY7QUFBaUIsQ0FyQnh2SCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2gvaW5kZXguanM/M2NlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17NTI2OihlLHQscik9Pntjb25zdCBuPXIoMTE5KTtjb25zdCB1PXIoNzY5KTtjb25zdCBzPXIoNzIyKTtjb25zdCBvPXIoNDA3KTtjb25zdCBicmFjZXM9KGUsdD17fSk9PntsZXQgcj1bXTtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IobGV0IG4gb2YgZSl7bGV0IGU9YnJhY2VzLmNyZWF0ZShuLHQpO2lmKEFycmF5LmlzQXJyYXkoZSkpe3IucHVzaCguLi5lKX1lbHNle3IucHVzaChlKX19fWVsc2V7cj1bXS5jb25jYXQoYnJhY2VzLmNyZWF0ZShlLHQpKX1pZih0JiZ0LmV4cGFuZD09PXRydWUmJnQubm9kdXBlcz09PXRydWUpe3I9Wy4uLm5ldyBTZXQocildfXJldHVybiByfTticmFjZXMucGFyc2U9KGUsdD17fSk9Pm8oZSx0KTticmFjZXMuc3RyaW5naWZ5PShlLHQ9e30pPT57aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gbihicmFjZXMucGFyc2UoZSx0KSx0KX1yZXR1cm4gbihlLHQpfTticmFjZXMuY29tcGlsZT0oZSx0PXt9KT0+e2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7ZT1icmFjZXMucGFyc2UoZSx0KX1yZXR1cm4gdShlLHQpfTticmFjZXMuZXhwYW5kPShlLHQ9e30pPT57aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtlPWJyYWNlcy5wYXJzZShlLHQpfWxldCByPXMoZSx0KTtpZih0Lm5vZW1wdHk9PT10cnVlKXtyPXIuZmlsdGVyKEJvb2xlYW4pfWlmKHQubm9kdXBlcz09PXRydWUpe3I9Wy4uLm5ldyBTZXQocildfXJldHVybiByfTticmFjZXMuY3JlYXRlPShlLHQ9e30pPT57aWYoZT09PVwiXCJ8fGUubGVuZ3RoPDMpe3JldHVybltlXX1yZXR1cm4gdC5leHBhbmQhPT10cnVlP2JyYWNlcy5jb21waWxlKGUsdCk6YnJhY2VzLmV4cGFuZChlLHQpfTtlLmV4cG9ydHM9YnJhY2VzfSw3Njk6KGUsdCxyKT0+e2NvbnN0IG49cig3ODkpO2NvbnN0IHU9cigxNSk7Y29uc3QgY29tcGlsZT0oZSx0PXt9KT0+e2xldCB3YWxrPShlLHI9e30pPT57bGV0IHM9dS5pc0ludmFsaWRCcmFjZShyKTtsZXQgbz1lLmludmFsaWQ9PT10cnVlJiZ0LmVzY2FwZUludmFsaWQ9PT10cnVlO2xldCBpPXM9PT10cnVlfHxvPT09dHJ1ZTtsZXQgYT10LmVzY2FwZUludmFsaWQ9PT10cnVlP1wiXFxcXFwiOlwiXCI7bGV0IGw9XCJcIjtpZihlLmlzT3Blbj09PXRydWUpe3JldHVybiBhK2UudmFsdWV9aWYoZS5pc0Nsb3NlPT09dHJ1ZSl7cmV0dXJuIGErZS52YWx1ZX1pZihlLnR5cGU9PT1cIm9wZW5cIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKFwifWlmKGUudHlwZT09PVwiY2xvc2VcIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKVwifWlmKGUudHlwZT09PVwiY29tbWFcIil7cmV0dXJuIGUucHJldi50eXBlPT09XCJjb21tYVwiP1wiXCI6aT9lLnZhbHVlOlwifFwifWlmKGUudmFsdWUpe3JldHVybiBlLnZhbHVlfWlmKGUubm9kZXMmJmUucmFuZ2VzPjApe2xldCByPXUucmVkdWNlKGUubm9kZXMpO2xldCBzPW4oLi4ucix7Li4udCx3cmFwOmZhbHNlLHRvUmVnZXg6dHJ1ZX0pO2lmKHMubGVuZ3RoIT09MCl7cmV0dXJuIHIubGVuZ3RoPjEmJnMubGVuZ3RoPjE/YCgke3N9KWA6c319aWYoZS5ub2Rlcyl7Zm9yKGxldCB0IG9mIGUubm9kZXMpe2wrPXdhbGsodCxlKX19cmV0dXJuIGx9O3JldHVybiB3YWxrKGUpfTtlLmV4cG9ydHM9Y29tcGlsZX0sMjYyOmU9PntlLmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxDSEFSXzA6XCIwXCIsQ0hBUl85OlwiOVwiLENIQVJfVVBQRVJDQVNFX0E6XCJBXCIsQ0hBUl9MT1dFUkNBU0VfQTpcImFcIixDSEFSX1VQUEVSQ0FTRV9aOlwiWlwiLENIQVJfTE9XRVJDQVNFX1o6XCJ6XCIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOlwiKFwiLENIQVJfUklHSFRfUEFSRU5USEVTRVM6XCIpXCIsQ0hBUl9BU1RFUklTSzpcIipcIixDSEFSX0FNUEVSU0FORDpcIiZcIixDSEFSX0FUOlwiQFwiLENIQVJfQkFDS1NMQVNIOlwiXFxcXFwiLENIQVJfQkFDS1RJQ0s6XCJgXCIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46XCJcXHJcIixDSEFSX0NJUkNVTUZMRVhfQUNDRU5UOlwiXlwiLENIQVJfQ09MT046XCI6XCIsQ0hBUl9DT01NQTpcIixcIixDSEFSX0RPTExBUjpcIiRcIixDSEFSX0RPVDpcIi5cIixDSEFSX0RPVUJMRV9RVU9URTonXCInLENIQVJfRVFVQUw6XCI9XCIsQ0hBUl9FWENMQU1BVElPTl9NQVJLOlwiIVwiLENIQVJfRk9STV9GRUVEOlwiXFxmXCIsQ0hBUl9GT1JXQVJEX1NMQVNIOlwiL1wiLENIQVJfSEFTSDpcIiNcIixDSEFSX0hZUEhFTl9NSU5VUzpcIi1cIixDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDpcIjxcIixDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6XCJ7XCIsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOlwiW1wiLENIQVJfTElORV9GRUVEOlwiXFxuXCIsQ0hBUl9OT19CUkVBS19TUEFDRTpcIsKgXCIsQ0hBUl9QRVJDRU5UOlwiJVwiLENIQVJfUExVUzpcIitcIixDSEFSX1FVRVNUSU9OX01BUks6XCI/XCIsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOlwiPlwiLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6XCJ9XCIsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpcIl1cIixDSEFSX1NFTUlDT0xPTjpcIjtcIixDSEFSX1NJTkdMRV9RVU9URTpcIidcIixDSEFSX1NQQUNFOlwiIFwiLENIQVJfVEFCOlwiXFx0XCIsQ0hBUl9VTkRFUlNDT1JFOlwiX1wiLENIQVJfVkVSVElDQUxfTElORTpcInxcIixDSEFSX1pFUk9fV0lEVEhfTk9CUkVBS19TUEFDRTpcIlxcdWZlZmZcIn19LDcyMjooZSx0LHIpPT57Y29uc3Qgbj1yKDc4OSk7Y29uc3QgdT1yKDExOSk7Y29uc3Qgcz1yKDE1KTtjb25zdCBhcHBlbmQ9KGU9XCJcIix0PVwiXCIscj1mYWxzZSk9PntsZXQgbj1bXTtlPVtdLmNvbmNhdChlKTt0PVtdLmNvbmNhdCh0KTtpZighdC5sZW5ndGgpcmV0dXJuIGU7aWYoIWUubGVuZ3RoKXtyZXR1cm4gcj9zLmZsYXR0ZW4odCkubWFwKChlPT5geyR7ZX19YCkpOnR9Zm9yKGxldCB1IG9mIGUpe2lmKEFycmF5LmlzQXJyYXkodSkpe2ZvcihsZXQgZSBvZiB1KXtuLnB1c2goYXBwZW5kKGUsdCxyKSl9fWVsc2V7Zm9yKGxldCBlIG9mIHQpe2lmKHI9PT10cnVlJiZ0eXBlb2YgZT09PVwic3RyaW5nXCIpZT1geyR7ZX19YDtuLnB1c2goQXJyYXkuaXNBcnJheShlKT9hcHBlbmQodSxlLHIpOnUrZSl9fX1yZXR1cm4gcy5mbGF0dGVuKG4pfTtjb25zdCBleHBhbmQ9KGUsdD17fSk9PntsZXQgcj10LnJhbmdlTGltaXQ9PT12b2lkIDA/MWUzOnQucmFuZ2VMaW1pdDtsZXQgd2Fsaz0oZSxvPXt9KT0+e2UucXVldWU9W107bGV0IGk9bztsZXQgYT1vLnF1ZXVlO3doaWxlKGkudHlwZSE9PVwiYnJhY2VcIiYmaS50eXBlIT09XCJyb290XCImJmkucGFyZW50KXtpPWkucGFyZW50O2E9aS5xdWV1ZX1pZihlLmludmFsaWR8fGUuZG9sbGFyKXthLnB1c2goYXBwZW5kKGEucG9wKCksdShlLHQpKSk7cmV0dXJufWlmKGUudHlwZT09PVwiYnJhY2VcIiYmZS5pbnZhbGlkIT09dHJ1ZSYmZS5ub2Rlcy5sZW5ndGg9PT0yKXthLnB1c2goYXBwZW5kKGEucG9wKCksW1wie31cIl0pKTtyZXR1cm59aWYoZS5ub2RlcyYmZS5yYW5nZXM+MCl7bGV0IG89cy5yZWR1Y2UoZS5ub2Rlcyk7aWYocy5leGNlZWRzTGltaXQoLi4ubyx0LnN0ZXAscikpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiZXhwYW5kZWQgYXJyYXkgbGVuZ3RoIGV4Y2VlZHMgcmFuZ2UgbGltaXQuIFVzZSBvcHRpb25zLnJhbmdlTGltaXQgdG8gaW5jcmVhc2Ugb3IgZGlzYWJsZSB0aGUgbGltaXQuXCIpfWxldCBpPW4oLi4ubyx0KTtpZihpLmxlbmd0aD09PTApe2k9dShlLHQpfWEucHVzaChhcHBlbmQoYS5wb3AoKSxpKSk7ZS5ub2Rlcz1bXTtyZXR1cm59bGV0IGw9cy5lbmNsb3NlQnJhY2UoZSk7bGV0IGM9ZS5xdWV1ZTtsZXQgcD1lO3doaWxlKHAudHlwZSE9PVwiYnJhY2VcIiYmcC50eXBlIT09XCJyb290XCImJnAucGFyZW50KXtwPXAucGFyZW50O2M9cC5xdWV1ZX1mb3IobGV0IHQ9MDt0PGUubm9kZXMubGVuZ3RoO3QrKyl7bGV0IHI9ZS5ub2Rlc1t0XTtpZihyLnR5cGU9PT1cImNvbW1hXCImJmUudHlwZT09PVwiYnJhY2VcIil7aWYodD09PTEpYy5wdXNoKFwiXCIpO2MucHVzaChcIlwiKTtjb250aW51ZX1pZihyLnR5cGU9PT1cImNsb3NlXCIpe2EucHVzaChhcHBlbmQoYS5wb3AoKSxjLGwpKTtjb250aW51ZX1pZihyLnZhbHVlJiZyLnR5cGUhPT1cIm9wZW5cIil7Yy5wdXNoKGFwcGVuZChjLnBvcCgpLHIudmFsdWUpKTtjb250aW51ZX1pZihyLm5vZGVzKXt3YWxrKHIsZSl9fXJldHVybiBjfTtyZXR1cm4gcy5mbGF0dGVuKHdhbGsoZSkpfTtlLmV4cG9ydHM9ZXhwYW5kfSw0MDc6KGUsdCxyKT0+e2NvbnN0IG49cigxMTkpO2NvbnN0e01BWF9MRU5HVEg6dSxDSEFSX0JBQ0tTTEFTSDpzLENIQVJfQkFDS1RJQ0s6byxDSEFSX0NPTU1BOmksQ0hBUl9ET1Q6YSxDSEFSX0xFRlRfUEFSRU5USEVTRVM6bCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmMsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOnAsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6UixDSEFSX0RPVUJMRV9RVU9URTpfLENIQVJfU0lOR0xFX1FVT1RFOmgsQ0hBUl9OT19CUkVBS19TUEFDRTpnLENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOkV9PXIoMjYyKTtjb25zdCBwYXJzZT0oZSx0PXt9KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpfWxldCByPXR8fHt9O2xldCBDPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4odSxyLm1heExlbmd0aCk6dTtpZihlLmxlbmd0aD5DKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aCAoJHtlLmxlbmd0aH0pLCBleGNlZWRzIG1heCBjaGFyYWN0ZXJzICgke0N9KWApfWxldCB5PXt0eXBlOlwicm9vdFwiLGlucHV0OmUsbm9kZXM6W119O2xldCBkPVt5XTtsZXQgeD15O2xldCBiPXk7bGV0IFM9MDtsZXQgSD1lLmxlbmd0aDtsZXQgdj0wO2xldCAkPTA7bGV0IG07bGV0IFQ9e307Y29uc3QgYWR2YW5jZT0oKT0+ZVt2KytdO2NvbnN0IHB1c2g9ZT0+e2lmKGUudHlwZT09PVwidGV4dFwiJiZiLnR5cGU9PT1cImRvdFwiKXtiLnR5cGU9XCJ0ZXh0XCJ9aWYoYiYmYi50eXBlPT09XCJ0ZXh0XCImJmUudHlwZT09PVwidGV4dFwiKXtiLnZhbHVlKz1lLnZhbHVlO3JldHVybn14Lm5vZGVzLnB1c2goZSk7ZS5wYXJlbnQ9eDtlLnByZXY9YjtiPWU7cmV0dXJuIGV9O3B1c2goe3R5cGU6XCJib3NcIn0pO3doaWxlKHY8SCl7eD1kW2QubGVuZ3RoLTFdO209YWR2YW5jZSgpO2lmKG09PT1FfHxtPT09Zyl7Y29udGludWV9aWYobT09PXMpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6KHQua2VlcEVzY2FwaW5nP206XCJcIikrYWR2YW5jZSgpfSk7Y29udGludWV9aWYobT09PVIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6XCJcXFxcXCIrbX0pO2NvbnRpbnVlfWlmKG09PT1BKXtTKys7bGV0IGU9dHJ1ZTtsZXQgdDt3aGlsZSh2PEgmJih0PWFkdmFuY2UoKSkpe20rPXQ7aWYodD09PUEpe1MrKztjb250aW51ZX1pZih0PT09cyl7bSs9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKHQ9PT1SKXtTLS07aWYoUz09PTApe2JyZWFrfX19cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWwpe3g9cHVzaCh7dHlwZTpcInBhcmVuXCIsbm9kZXM6W119KTtkLnB1c2goeCk7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWMpe2lmKHgudHlwZSE9PVwicGFyZW5cIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9eD1kLnBvcCgpO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09X3x8bT09PWh8fG09PT1vKXtsZXQgZT1tO2xldCByO2lmKHQua2VlcFF1b3RlcyE9PXRydWUpe209XCJcIn13aGlsZSh2PEgmJihyPWFkdmFuY2UoKSkpe2lmKHI9PT1zKXttKz1yK2FkdmFuY2UoKTtjb250aW51ZX1pZihyPT09ZSl7aWYodC5rZWVwUXVvdGVzPT09dHJ1ZSltKz1yO2JyZWFrfW0rPXJ9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PXApeyQrKztsZXQgZT1iLnZhbHVlJiZiLnZhbHVlLnNsaWNlKC0xKT09PVwiJFwifHx4LmRvbGxhcj09PXRydWU7bGV0IHQ9e3R5cGU6XCJicmFjZVwiLG9wZW46dHJ1ZSxjbG9zZTpmYWxzZSxkb2xsYXI6ZSxkZXB0aDokLGNvbW1hczowLHJhbmdlczowLG5vZGVzOltdfTt4PXB1c2godCk7ZC5wdXNoKHgpO3B1c2goe3R5cGU6XCJvcGVuXCIsdmFsdWU6bX0pO2NvbnRpbnVlfWlmKG09PT1mKXtpZih4LnR5cGUhPT1cImJyYWNlXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO2NvbnRpbnVlfWxldCBlPVwiY2xvc2VcIjt4PWQucG9wKCk7eC5jbG9zZT10cnVlO3B1c2goe3R5cGU6ZSx2YWx1ZTptfSk7JC0tO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09aSYmJD4wKXtpZih4LnJhbmdlcz4wKXt4LnJhbmdlcz0wO2xldCBlPXgubm9kZXMuc2hpZnQoKTt4Lm5vZGVzPVtlLHt0eXBlOlwidGV4dFwiLHZhbHVlOm4oeCl9XX1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTptfSk7eC5jb21tYXMrKztjb250aW51ZX1pZihtPT09YSYmJD4wJiZ4LmNvbW1hcz09PTApe2xldCBlPXgubm9kZXM7aWYoJD09PTB8fGUubGVuZ3RoPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYoYi50eXBlPT09XCJkb3RcIil7eC5yYW5nZT1bXTtiLnZhbHVlKz1tO2IudHlwZT1cInJhbmdlXCI7aWYoeC5ub2Rlcy5sZW5ndGghPT0zJiZ4Lm5vZGVzLmxlbmd0aCE9PTUpe3guaW52YWxpZD10cnVlO3gucmFuZ2VzPTA7Yi50eXBlPVwidGV4dFwiO2NvbnRpbnVlfXgucmFuZ2VzKys7eC5hcmdzPVtdO2NvbnRpbnVlfWlmKGIudHlwZT09PVwicmFuZ2VcIil7ZS5wb3AoKTtsZXQgdD1lW2UubGVuZ3RoLTFdO3QudmFsdWUrPWIudmFsdWUrbTtiPXQ7eC5yYW5nZXMtLTtjb250aW51ZX1wdXNoKHt0eXBlOlwiZG90XCIsdmFsdWU6bX0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pfWRve3g9ZC5wb3AoKTtpZih4LnR5cGUhPT1cInJvb3RcIil7eC5ub2Rlcy5mb3JFYWNoKChlPT57aWYoIWUubm9kZXMpe2lmKGUudHlwZT09PVwib3BlblwiKWUuaXNPcGVuPXRydWU7aWYoZS50eXBlPT09XCJjbG9zZVwiKWUuaXNDbG9zZT10cnVlO2lmKCFlLm5vZGVzKWUudHlwZT1cInRleHRcIjtlLmludmFsaWQ9dHJ1ZX19KSk7bGV0IGU9ZFtkLmxlbmd0aC0xXTtsZXQgdD1lLm5vZGVzLmluZGV4T2YoeCk7ZS5ub2Rlcy5zcGxpY2UodCwxLC4uLngubm9kZXMpfX13aGlsZShkLmxlbmd0aD4wKTtwdXNoKHt0eXBlOlwiZW9zXCJ9KTtyZXR1cm4geX07ZS5leHBvcnRzPXBhcnNlfSwxMTk6KGUsdCxyKT0+e2NvbnN0IG49cigxNSk7ZS5leHBvcnRzPShlLHQ9e30pPT57bGV0IHN0cmluZ2lmeT0oZSxyPXt9KT0+e2xldCB1PXQuZXNjYXBlSW52YWxpZCYmbi5pc0ludmFsaWRCcmFjZShyKTtsZXQgcz1lLmludmFsaWQ9PT10cnVlJiZ0LmVzY2FwZUludmFsaWQ9PT10cnVlO2xldCBvPVwiXCI7aWYoZS52YWx1ZSl7aWYoKHV8fHMpJiZuLmlzT3Blbk9yQ2xvc2UoZSkpe3JldHVyblwiXFxcXFwiK2UudmFsdWV9cmV0dXJuIGUudmFsdWV9aWYoZS52YWx1ZSl7cmV0dXJuIGUudmFsdWV9aWYoZS5ub2Rlcyl7Zm9yKGxldCB0IG9mIGUubm9kZXMpe28rPXN0cmluZ2lmeSh0KX19cmV0dXJuIG99O3JldHVybiBzdHJpbmdpZnkoZSl9fSwxNTooZSx0KT0+e3QuaXNJbnRlZ2VyPWU9PntpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGUpfWlmKHR5cGVvZiBlPT09XCJzdHJpbmdcIiYmZS50cmltKCkhPT1cIlwiKXtyZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihOdW1iZXIoZSkpfXJldHVybiBmYWxzZX07dC5maW5kPShlLHQpPT5lLm5vZGVzLmZpbmQoKGU9PmUudHlwZT09PXQpKTt0LmV4Y2VlZHNMaW1pdD0oZSxyLG49MSx1KT0+e2lmKHU9PT1mYWxzZSlyZXR1cm4gZmFsc2U7aWYoIXQuaXNJbnRlZ2VyKGUpfHwhdC5pc0ludGVnZXIocikpcmV0dXJuIGZhbHNlO3JldHVybihOdW1iZXIociktTnVtYmVyKGUpKS9OdW1iZXIobik+PXV9O3QuZXNjYXBlTm9kZT0oZSx0PTAscik9PntsZXQgbj1lLm5vZGVzW3RdO2lmKCFuKXJldHVybjtpZihyJiZuLnR5cGU9PT1yfHxuLnR5cGU9PT1cIm9wZW5cInx8bi50eXBlPT09XCJjbG9zZVwiKXtpZihuLmVzY2FwZWQhPT10cnVlKXtuLnZhbHVlPVwiXFxcXFwiK24udmFsdWU7bi5lc2NhcGVkPXRydWV9fX07dC5lbmNsb3NlQnJhY2U9ZT0+e2lmKGUudHlwZSE9PVwiYnJhY2VcIilyZXR1cm4gZmFsc2U7aWYoZS5jb21tYXM+PjArZS5yYW5nZXM+PjA9PT0wKXtlLmludmFsaWQ9dHJ1ZTtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9O3QuaXNJbnZhbGlkQnJhY2U9ZT0+e2lmKGUudHlwZSE9PVwiYnJhY2VcIilyZXR1cm4gZmFsc2U7aWYoZS5pbnZhbGlkPT09dHJ1ZXx8ZS5kb2xsYXIpcmV0dXJuIHRydWU7aWYoZS5jb21tYXM+PjArZS5yYW5nZXM+PjA9PT0wKXtlLmludmFsaWQ9dHJ1ZTtyZXR1cm4gdHJ1ZX1pZihlLm9wZW4hPT10cnVlfHxlLmNsb3NlIT09dHJ1ZSl7ZS5pbnZhbGlkPXRydWU7cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlfTt0LmlzT3Blbk9yQ2xvc2U9ZT0+e2lmKGUudHlwZT09PVwib3BlblwifHxlLnR5cGU9PT1cImNsb3NlXCIpe3JldHVybiB0cnVlfXJldHVybiBlLm9wZW49PT10cnVlfHxlLmNsb3NlPT09dHJ1ZX07dC5yZWR1Y2U9ZT0+ZS5yZWR1Y2UoKChlLHQpPT57aWYodC50eXBlPT09XCJ0ZXh0XCIpZS5wdXNoKHQudmFsdWUpO2lmKHQudHlwZT09PVwicmFuZ2VcIil0LnR5cGU9XCJ0ZXh0XCI7cmV0dXJuIGV9KSxbXSk7dC5mbGF0dGVuPSguLi5lKT0+e2NvbnN0IHQ9W107Y29uc3QgZmxhdD1lPT57Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2xldCBuPWVbcl07QXJyYXkuaXNBcnJheShuKT9mbGF0KG4sdCk6biE9PXZvaWQgMCYmdC5wdXNoKG4pfXJldHVybiB0fTtmbGF0KGUpO3JldHVybiB0fX0sNzg5OihlLHQscik9PntcclxuLyohXHJcbiAqIGZpbGwtcmFuZ2UgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2ZpbGwtcmFuZ2U+XHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBKb24gU2NobGlua2VydC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3Qgbj1yKDgzNyk7Y29uc3QgdT1yKDM2OCk7Y29uc3QgaXNPYmplY3Q9ZT0+ZSE9PW51bGwmJnR5cGVvZiBlPT09XCJvYmplY3RcIiYmIUFycmF5LmlzQXJyYXkoZSk7Y29uc3QgdHJhbnNmb3JtPWU9PnQ9PmU9PT10cnVlP051bWJlcih0KTpTdHJpbmcodCk7Y29uc3QgaXNWYWxpZFZhbHVlPWU9PnR5cGVvZiBlPT09XCJudW1iZXJcInx8dHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlIT09XCJcIjtjb25zdCBpc051bWJlcj1lPT5OdW1iZXIuaXNJbnRlZ2VyKCtlKTtjb25zdCB6ZXJvcz1lPT57bGV0IHQ9YCR7ZX1gO2xldCByPS0xO2lmKHRbMF09PT1cIi1cIil0PXQuc2xpY2UoMSk7aWYodD09PVwiMFwiKXJldHVybiBmYWxzZTt3aGlsZSh0Wysrcl09PT1cIjBcIik7cmV0dXJuIHI+MH07Y29uc3Qgc3RyaW5naWZ5PShlLHQscik9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCJ8fHR5cGVvZiB0PT09XCJzdHJpbmdcIil7cmV0dXJuIHRydWV9cmV0dXJuIHIuc3RyaW5naWZ5PT09dHJ1ZX07Y29uc3QgcGFkPShlLHQscik9PntpZih0PjApe2xldCByPWVbMF09PT1cIi1cIj9cIi1cIjpcIlwiO2lmKHIpZT1lLnNsaWNlKDEpO2U9citlLnBhZFN0YXJ0KHI/dC0xOnQsXCIwXCIpfWlmKHI9PT1mYWxzZSl7cmV0dXJuIFN0cmluZyhlKX1yZXR1cm4gZX07Y29uc3QgdG9NYXhMZW49KGUsdCk9PntsZXQgcj1lWzBdPT09XCItXCI/XCItXCI6XCJcIjtpZihyKXtlPWUuc2xpY2UoMSk7dC0tfXdoaWxlKGUubGVuZ3RoPHQpZT1cIjBcIitlO3JldHVybiByP1wiLVwiK2U6ZX07Y29uc3QgdG9TZXF1ZW5jZT0oZSx0KT0+e2UubmVnYXRpdmVzLnNvcnQoKChlLHQpPT5lPHQ/LTE6ZT50PzE6MCkpO2UucG9zaXRpdmVzLnNvcnQoKChlLHQpPT5lPHQ/LTE6ZT50PzE6MCkpO2xldCByPXQuY2FwdHVyZT9cIlwiOlwiPzpcIjtsZXQgbj1cIlwiO2xldCB1PVwiXCI7bGV0IHM7aWYoZS5wb3NpdGl2ZXMubGVuZ3RoKXtuPWUucG9zaXRpdmVzLmpvaW4oXCJ8XCIpfWlmKGUubmVnYXRpdmVzLmxlbmd0aCl7dT1gLSgke3J9JHtlLm5lZ2F0aXZlcy5qb2luKFwifFwiKX0pYH1pZihuJiZ1KXtzPWAke259fCR7dX1gfWVsc2V7cz1ufHx1fWlmKHQud3JhcCl7cmV0dXJuYCgke3J9JHtzfSlgfXJldHVybiBzfTtjb25zdCB0b1JhbmdlPShlLHQscixuKT0+e2lmKHIpe3JldHVybiB1KGUsdCx7d3JhcDpmYWxzZSwuLi5ufSl9bGV0IHM9U3RyaW5nLmZyb21DaGFyQ29kZShlKTtpZihlPT09dClyZXR1cm4gcztsZXQgbz1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpO3JldHVybmBbJHtzfS0ke299XWB9O2NvbnN0IHRvUmVnZXg9KGUsdCxyKT0+e2lmKEFycmF5LmlzQXJyYXkoZSkpe2xldCB0PXIud3JhcD09PXRydWU7bGV0IG49ci5jYXB0dXJlP1wiXCI6XCI/OlwiO3JldHVybiB0P2AoJHtufSR7ZS5qb2luKFwifFwiKX0pYDplLmpvaW4oXCJ8XCIpfXJldHVybiB1KGUsdCxyKX07Y29uc3QgcmFuZ2VFcnJvcj0oLi4uZSk9Pm5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByYW5nZSBhcmd1bWVudHM6IFwiK24uaW5zcGVjdCguLi5lKSk7Y29uc3QgaW52YWxpZFJhbmdlPShlLHQscik9PntpZihyLnN0cmljdFJhbmdlcz09PXRydWUpdGhyb3cgcmFuZ2VFcnJvcihbZSx0XSk7cmV0dXJuW119O2NvbnN0IGludmFsaWRTdGVwPShlLHQpPT57aWYodC5zdHJpY3RSYW5nZXM9PT10cnVlKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBzdGVwIFwiJHtlfVwiIHRvIGJlIGEgbnVtYmVyYCl9cmV0dXJuW119O2NvbnN0IGZpbGxOdW1iZXJzPShlLHQscj0xLG49e30pPT57bGV0IHU9TnVtYmVyKGUpO2xldCBzPU51bWJlcih0KTtpZighTnVtYmVyLmlzSW50ZWdlcih1KXx8IU51bWJlci5pc0ludGVnZXIocykpe2lmKG4uc3RyaWN0UmFuZ2VzPT09dHJ1ZSl0aHJvdyByYW5nZUVycm9yKFtlLHRdKTtyZXR1cm5bXX1pZih1PT09MCl1PTA7aWYocz09PTApcz0wO2xldCBvPXU+cztsZXQgaT1TdHJpbmcoZSk7bGV0IGE9U3RyaW5nKHQpO2xldCBsPVN0cmluZyhyKTtyPU1hdGgubWF4KE1hdGguYWJzKHIpLDEpO2xldCBjPXplcm9zKGkpfHx6ZXJvcyhhKXx8emVyb3MobCk7bGV0IHA9Yz9NYXRoLm1heChpLmxlbmd0aCxhLmxlbmd0aCxsLmxlbmd0aCk6MDtsZXQgZj1jPT09ZmFsc2UmJnN0cmluZ2lmeShlLHQsbik9PT1mYWxzZTtsZXQgQT1uLnRyYW5zZm9ybXx8dHJhbnNmb3JtKGYpO2lmKG4udG9SZWdleCYmcj09PTEpe3JldHVybiB0b1JhbmdlKHRvTWF4TGVuKGUscCksdG9NYXhMZW4odCxwKSx0cnVlLG4pfWxldCBSPXtuZWdhdGl2ZXM6W10scG9zaXRpdmVzOltdfTtsZXQgcHVzaD1lPT5SW2U8MD9cIm5lZ2F0aXZlc1wiOlwicG9zaXRpdmVzXCJdLnB1c2goTWF0aC5hYnMoZSkpO2xldCBfPVtdO2xldCBoPTA7d2hpbGUobz91Pj1zOnU8PXMpe2lmKG4udG9SZWdleD09PXRydWUmJnI+MSl7cHVzaCh1KX1lbHNle18ucHVzaChwYWQoQSh1LGgpLHAsZikpfXU9bz91LXI6dStyO2grK31pZihuLnRvUmVnZXg9PT10cnVlKXtyZXR1cm4gcj4xP3RvU2VxdWVuY2UoUixuKTp0b1JlZ2V4KF8sbnVsbCx7d3JhcDpmYWxzZSwuLi5ufSl9cmV0dXJuIF99O2NvbnN0IGZpbGxMZXR0ZXJzPShlLHQscj0xLG49e30pPT57aWYoIWlzTnVtYmVyKGUpJiZlLmxlbmd0aD4xfHwhaXNOdW1iZXIodCkmJnQubGVuZ3RoPjEpe3JldHVybiBpbnZhbGlkUmFuZ2UoZSx0LG4pfWxldCB1PW4udHJhbnNmb3JtfHwoZT0+U3RyaW5nLmZyb21DaGFyQ29kZShlKSk7bGV0IHM9YCR7ZX1gLmNoYXJDb2RlQXQoMCk7bGV0IG89YCR7dH1gLmNoYXJDb2RlQXQoMCk7bGV0IGk9cz5vO2xldCBhPU1hdGgubWluKHMsbyk7bGV0IGw9TWF0aC5tYXgocyxvKTtpZihuLnRvUmVnZXgmJnI9PT0xKXtyZXR1cm4gdG9SYW5nZShhLGwsZmFsc2Usbil9bGV0IGM9W107bGV0IHA9MDt3aGlsZShpP3M+PW86czw9byl7Yy5wdXNoKHUocyxwKSk7cz1pP3MtcjpzK3I7cCsrfWlmKG4udG9SZWdleD09PXRydWUpe3JldHVybiB0b1JlZ2V4KGMsbnVsbCx7d3JhcDpmYWxzZSxvcHRpb25zOm59KX1yZXR1cm4gY307Y29uc3QgZmlsbD0oZSx0LHIsbj17fSk9PntpZih0PT1udWxsJiZpc1ZhbGlkVmFsdWUoZSkpe3JldHVybltlXX1pZighaXNWYWxpZFZhbHVlKGUpfHwhaXNWYWxpZFZhbHVlKHQpKXtyZXR1cm4gaW52YWxpZFJhbmdlKGUsdCxuKX1pZih0eXBlb2Ygcj09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZpbGwoZSx0LDEse3RyYW5zZm9ybTpyfSl9aWYoaXNPYmplY3Qocikpe3JldHVybiBmaWxsKGUsdCwwLHIpfWxldCB1PXsuLi5ufTtpZih1LmNhcHR1cmU9PT10cnVlKXUud3JhcD10cnVlO3I9cnx8dS5zdGVwfHwxO2lmKCFpc051bWJlcihyKSl7aWYociE9bnVsbCYmIWlzT2JqZWN0KHIpKXJldHVybiBpbnZhbGlkU3RlcChyLHUpO3JldHVybiBmaWxsKGUsdCwxLHIpfWlmKGlzTnVtYmVyKGUpJiZpc051bWJlcih0KSl7cmV0dXJuIGZpbGxOdW1iZXJzKGUsdCxyLHUpfXJldHVybiBmaWxsTGV0dGVycyhlLHQsTWF0aC5tYXgoTWF0aC5hYnMociksMSksdSl9O2UuZXhwb3J0cz1maWxsfSw3NzM6ZT0+e1xyXG4vKiFcclxuICogaXMtbnVtYmVyIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1udW1iZXI+XHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBKb24gU2NobGlua2VydC5cclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuZS5leHBvcnRzPWZ1bmN0aW9uKGUpe2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7cmV0dXJuIGUtZT09PTB9aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlLnRyaW0oKSE9PVwiXCIpe3JldHVybiBOdW1iZXIuaXNGaW5pdGU/TnVtYmVyLmlzRmluaXRlKCtlKTppc0Zpbml0ZSgrZSl9cmV0dXJuIGZhbHNlfX0sODg4OihlLHQscik9Pntjb25zdCBuPXIoODM3KTtjb25zdCB1PXIoNTI2KTtjb25zdCBzPXIoNjAxKTtjb25zdCBvPXIoMjQzKTtjb25zdCBpc0VtcHR5U3RyaW5nPWU9PmU9PT1cIlwifHxlPT09XCIuL1wiO2NvbnN0IG1pY3JvbWF0Y2g9KGUsdCxyKT0+e3Q9W10uY29uY2F0KHQpO2U9W10uY29uY2F0KGUpO2xldCBuPW5ldyBTZXQ7bGV0IHU9bmV3IFNldDtsZXQgbz1uZXcgU2V0O2xldCBpPTA7bGV0IG9uUmVzdWx0PWU9PntvLmFkZChlLm91dHB1dCk7aWYociYmci5vblJlc3VsdCl7ci5vblJlc3VsdChlKX19O2ZvcihsZXQgbz0wO288dC5sZW5ndGg7bysrKXtsZXQgYT1zKFN0cmluZyh0W29dKSx7Li4ucixvblJlc3VsdDpvblJlc3VsdH0sdHJ1ZSk7bGV0IGw9YS5zdGF0ZS5uZWdhdGVkfHxhLnN0YXRlLm5lZ2F0ZWRFeHRnbG9iO2lmKGwpaSsrO2ZvcihsZXQgdCBvZiBlKXtsZXQgZT1hKHQsdHJ1ZSk7bGV0IHI9bD8hZS5pc01hdGNoOmUuaXNNYXRjaDtpZighciljb250aW51ZTtpZihsKXtuLmFkZChlLm91dHB1dCl9ZWxzZXtuLmRlbGV0ZShlLm91dHB1dCk7dS5hZGQoZS5vdXRwdXQpfX19bGV0IGE9aT09PXQubGVuZ3RoP1suLi5vXTpbLi4udV07bGV0IGw9YS5maWx0ZXIoKGU9PiFuLmhhcyhlKSkpO2lmKHImJmwubGVuZ3RoPT09MCl7aWYoci5mYWlsZ2xvYj09PXRydWUpe3Rocm93IG5ldyBFcnJvcihgTm8gbWF0Y2hlcyBmb3VuZCBmb3IgXCIke3Quam9pbihcIiwgXCIpfVwiYCl9aWYoci5ub251bGw9PT10cnVlfHxyLm51bGxnbG9iPT09dHJ1ZSl7cmV0dXJuIHIudW5lc2NhcGU/dC5tYXAoKGU9PmUucmVwbGFjZSgvXFxcXC9nLFwiXCIpKSk6dH19cmV0dXJuIGx9O21pY3JvbWF0Y2gubWF0Y2g9bWljcm9tYXRjaDttaWNyb21hdGNoLm1hdGNoZXI9KGUsdCk9PnMoZSx0KTttaWNyb21hdGNoLmlzTWF0Y2g9KGUsdCxyKT0+cyh0LHIpKGUpO21pY3JvbWF0Y2guYW55PW1pY3JvbWF0Y2guaXNNYXRjaDttaWNyb21hdGNoLm5vdD0oZSx0LHI9e30pPT57dD1bXS5jb25jYXQodCkubWFwKFN0cmluZyk7bGV0IG49bmV3IFNldDtsZXQgdT1bXTtsZXQgb25SZXN1bHQ9ZT0+e2lmKHIub25SZXN1bHQpci5vblJlc3VsdChlKTt1LnB1c2goZS5vdXRwdXQpfTtsZXQgcz1taWNyb21hdGNoKGUsdCx7Li4ucixvblJlc3VsdDpvblJlc3VsdH0pO2ZvcihsZXQgZSBvZiB1KXtpZighcy5pbmNsdWRlcyhlKSl7bi5hZGQoZSl9fXJldHVyblsuLi5uXX07bWljcm9tYXRjaC5jb250YWlucz0oZSx0LHIpPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBhIHN0cmluZzogXCIke24uaW5zcGVjdChlKX1cImApfWlmKEFycmF5LmlzQXJyYXkodCkpe3JldHVybiB0LnNvbWUoKHQ9Pm1pY3JvbWF0Y2guY29udGFpbnMoZSx0LHIpKSl9aWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtpZihpc0VtcHR5U3RyaW5nKGUpfHxpc0VtcHR5U3RyaW5nKHQpKXtyZXR1cm4gZmFsc2V9aWYoZS5pbmNsdWRlcyh0KXx8ZS5zdGFydHNXaXRoKFwiLi9cIikmJmUuc2xpY2UoMikuaW5jbHVkZXModCkpe3JldHVybiB0cnVlfX1yZXR1cm4gbWljcm9tYXRjaC5pc01hdGNoKGUsdCx7Li4ucixjb250YWluczp0cnVlfSl9O21pY3JvbWF0Y2gubWF0Y2hLZXlzPShlLHQscik9PntpZighby5pc09iamVjdChlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3RcIil9bGV0IG49bWljcm9tYXRjaChPYmplY3Qua2V5cyhlKSx0LHIpO2xldCB1PXt9O2ZvcihsZXQgdCBvZiBuKXVbdF09ZVt0XTtyZXR1cm4gdX07bWljcm9tYXRjaC5zb21lPShlLHQscik9PntsZXQgbj1bXS5jb25jYXQoZSk7Zm9yKGxldCBlIG9mW10uY29uY2F0KHQpKXtsZXQgdD1zKFN0cmluZyhlKSxyKTtpZihuLnNvbWUoKGU9PnQoZSkpKSl7cmV0dXJuIHRydWV9fXJldHVybiBmYWxzZX07bWljcm9tYXRjaC5ldmVyeT0oZSx0LHIpPT57bGV0IG49W10uY29uY2F0KGUpO2ZvcihsZXQgZSBvZltdLmNvbmNhdCh0KSl7bGV0IHQ9cyhTdHJpbmcoZSkscik7aWYoIW4uZXZlcnkoKGU9PnQoZSkpKSl7cmV0dXJuIGZhbHNlfX1yZXR1cm4gdHJ1ZX07bWljcm9tYXRjaC5hbGw9KGUsdCxyKT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmc6IFwiJHtuLmluc3BlY3QoZSl9XCJgKX1yZXR1cm5bXS5jb25jYXQodCkuZXZlcnkoKHQ9PnModCxyKShlKSkpfTttaWNyb21hdGNoLmNhcHR1cmU9KGUsdCxyKT0+e2xldCBuPW8uaXNXaW5kb3dzKHIpO2xldCB1PXMubWFrZVJlKFN0cmluZyhlKSx7Li4ucixjYXB0dXJlOnRydWV9KTtsZXQgaT11LmV4ZWMobj9vLnRvUG9zaXhTbGFzaGVzKHQpOnQpO2lmKGkpe3JldHVybiBpLnNsaWNlKDEpLm1hcCgoZT0+ZT09PXZvaWQgMD9cIlwiOmUpKX19O21pY3JvbWF0Y2gubWFrZVJlPSguLi5lKT0+cy5tYWtlUmUoLi4uZSk7bWljcm9tYXRjaC5zY2FuPSguLi5lKT0+cy5zY2FuKC4uLmUpO21pY3JvbWF0Y2gucGFyc2U9KGUsdCk9PntsZXQgcj1bXTtmb3IobGV0IG4gb2ZbXS5jb25jYXQoZXx8W10pKXtmb3IobGV0IGUgb2YgdShTdHJpbmcobiksdCkpe3IucHVzaChzLnBhcnNlKGUsdCkpfX1yZXR1cm4gcn07bWljcm9tYXRjaC5icmFjZXM9KGUsdCk9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpO2lmKHQmJnQubm9icmFjZT09PXRydWV8fCEvXFx7LipcXH0vLnRlc3QoZSkpe3JldHVybltlXX1yZXR1cm4gdShlLHQpfTttaWNyb21hdGNoLmJyYWNlRXhwYW5kPShlLHQpPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKTtyZXR1cm4gbWljcm9tYXRjaC5icmFjZXMoZSx7Li4udCxleHBhbmQ6dHJ1ZX0pfTtlLmV4cG9ydHM9bWljcm9tYXRjaH0sNjAxOihlLHQscik9PntlLmV4cG9ydHM9cig1MDkpfSw4NzE6KGUsdCxyKT0+e2NvbnN0IG49cigxNyk7Y29uc3QgdT1cIlxcXFxcXFxcL1wiO2NvbnN0IHM9YFteJHt1fV1gO2NvbnN0IG89XCJcXFxcLlwiO2NvbnN0IGk9XCJcXFxcK1wiO2NvbnN0IGE9XCJcXFxcP1wiO2NvbnN0IGw9XCJcXFxcL1wiO2NvbnN0IGM9XCIoPz0uKVwiO2NvbnN0IHA9XCJbXi9dXCI7Y29uc3QgZj1gKD86JHtsfXwkKWA7Y29uc3QgQT1gKD86Xnwke2x9KWA7Y29uc3QgUj1gJHtvfXsxLDJ9JHtmfWA7Y29uc3QgXz1gKD8hJHtvfSlgO2NvbnN0IGg9YCg/ISR7QX0ke1J9KWA7Y29uc3QgZz1gKD8hJHtvfXswLDF9JHtmfSlgO2NvbnN0IEU9YCg/ISR7Un0pYDtjb25zdCBDPWBbXi4ke2x9XWA7Y29uc3QgeT1gJHtwfSo/YDtjb25zdCBkPXtET1RfTElURVJBTDpvLFBMVVNfTElURVJBTDppLFFNQVJLX0xJVEVSQUw6YSxTTEFTSF9MSVRFUkFMOmwsT05FX0NIQVI6YyxRTUFSSzpwLEVORF9BTkNIT1I6ZixET1RTX1NMQVNIOlIsTk9fRE9UOl8sTk9fRE9UUzpoLE5PX0RPVF9TTEFTSDpnLE5PX0RPVFNfU0xBU0g6RSxRTUFSS19OT19ET1Q6QyxTVEFSOnksU1RBUlRfQU5DSE9SOkF9O2NvbnN0IHg9ey4uLmQsU0xBU0hfTElURVJBTDpgWyR7dX1dYCxRTUFSSzpzLFNUQVI6YCR7c30qP2AsRE9UU19TTEFTSDpgJHtvfXsxLDJ9KD86WyR7dX1dfCQpYCxOT19ET1Q6YCg/ISR7b30pYCxOT19ET1RTOmAoPyEoPzpefFske3V9XSkke299ezEsMn0oPzpbJHt1fV18JCkpYCxOT19ET1RfU0xBU0g6YCg/ISR7b317MCwxfSg/Olske3V9XXwkKSlgLE5PX0RPVFNfU0xBU0g6YCg/ISR7b317MSwyfSg/Olske3V9XXwkKSlgLFFNQVJLX05PX0RPVDpgW14uJHt1fV1gLFNUQVJUX0FOQ0hPUjpgKD86XnxbJHt1fV0pYCxFTkRfQU5DSE9SOmAoPzpbJHt1fV18JClgfTtjb25zdCBiPXthbG51bTpcImEtekEtWjAtOVwiLGFscGhhOlwiYS16QS1aXCIsYXNjaWk6XCJcXFxceDAwLVxcXFx4N0ZcIixibGFuazpcIiBcXFxcdFwiLGNudHJsOlwiXFxcXHgwMC1cXFxceDFGXFxcXHg3RlwiLGRpZ2l0OlwiMC05XCIsZ3JhcGg6XCJcXFxceDIxLVxcXFx4N0VcIixsb3dlcjpcImEtelwiLHByaW50OlwiXFxcXHgyMC1cXFxceDdFIFwiLHB1bmN0OlwiXFxcXC0hXFxcIiMkJSYnKClcXFxcKissLi86Ozw9Pj9AW1xcXFxdXl9ge3x9flwiLHNwYWNlOlwiIFxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGZcIix1cHBlcjpcIkEtWlwiLHdvcmQ6XCJBLVphLXowLTlfXCIseGRpZ2l0OlwiQS1GYS1mMC05XCJ9O2UuZXhwb3J0cz17TUFYX0xFTkdUSDoxMDI0KjY0LFBPU0lYX1JFR0VYX1NPVVJDRTpiLFJFR0VYX0JBQ0tTTEFTSDovXFxcXCg/IVsqKz9eJHt9KHwpW1xcXV0pL2csUkVHRVhfTk9OX1NQRUNJQUxfQ0hBUlM6L15bXkAhW1xcXS4sJCorP157fSgpfFxcXFwvXSsvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6L1stKis/Ll4ke30ofClbXFxdXS8sUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOi8oXFxcXD8pKChcXFcpKFxcMyopKS9nLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOi8oWy0qKz8uXiR7fSh8KVtcXF1dKS9nLFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6Lyg/OlxcWy4qP1teXFxcXF1cXF18XFxcXCg/PS4pKS9nLFJFUExBQ0VNRU5UUzp7XCIqKipcIjpcIipcIixcIioqLyoqXCI6XCIqKlwiLFwiKiovKiovKipcIjpcIioqXCJ9LENIQVJfMDo0OCxDSEFSXzk6NTcsQ0hBUl9VUFBFUkNBU0VfQTo2NSxDSEFSX0xPV0VSQ0FTRV9BOjk3LENIQVJfVVBQRVJDQVNFX1o6OTAsQ0hBUl9MT1dFUkNBU0VfWjoxMjIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOjQwLENIQVJfUklHSFRfUEFSRU5USEVTRVM6NDEsQ0hBUl9BU1RFUklTSzo0MixDSEFSX0FNUEVSU0FORDozOCxDSEFSX0FUOjY0LENIQVJfQkFDS1dBUkRfU0xBU0g6OTIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46MTMsQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVDo5NCxDSEFSX0NPTE9OOjU4LENIQVJfQ09NTUE6NDQsQ0hBUl9ET1Q6NDYsQ0hBUl9ET1VCTEVfUVVPVEU6MzQsQ0hBUl9FUVVBTDo2MSxDSEFSX0VYQ0xBTUFUSU9OX01BUks6MzMsQ0hBUl9GT1JNX0ZFRUQ6MTIsQ0hBUl9GT1JXQVJEX1NMQVNIOjQ3LENIQVJfR1JBVkVfQUNDRU5UOjk2LENIQVJfSEFTSDozNSxDSEFSX0hZUEhFTl9NSU5VUzo0NSxDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDo2MCxDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6MTIzLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDo5MSxDSEFSX0xJTkVfRkVFRDoxMCxDSEFSX05PX0JSRUFLX1NQQUNFOjE2MCxDSEFSX1BFUkNFTlQ6MzcsQ0hBUl9QTFVTOjQzLENIQVJfUVVFU1RJT05fTUFSSzo2MyxDSEFSX1JJR0hUX0FOR0xFX0JSQUNLRVQ6NjIsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRToxMjUsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDo5MyxDSEFSX1NFTUlDT0xPTjo1OSxDSEFSX1NJTkdMRV9RVU9URTozOSxDSEFSX1NQQUNFOjMyLENIQVJfVEFCOjksQ0hBUl9VTkRFUlNDT1JFOjk1LENIQVJfVkVSVElDQUxfTElORToxMjQsQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0U6NjUyNzksU0VQOm4uc2VwLGV4dGdsb2JDaGFycyhlKXtyZXR1cm57XCIhXCI6e3R5cGU6XCJuZWdhdGVcIixvcGVuOlwiKD86KD8hKD86XCIsY2xvc2U6YCkpJHtlLlNUQVJ9KWB9LFwiP1wiOnt0eXBlOlwicW1hcmtcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpP1wifSxcIitcIjp7dHlwZTpcInBsdXNcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpK1wifSxcIipcIjp7dHlwZTpcInN0YXJcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpKlwifSxcIkBcIjp7dHlwZTpcImF0XCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKVwifX19LGdsb2JDaGFycyhlKXtyZXR1cm4gZT09PXRydWU/eDpkfX19LDgyMTooZSx0LHIpPT57Y29uc3Qgbj1yKDg3MSk7Y29uc3QgdT1yKDI0Myk7Y29uc3R7TUFYX0xFTkdUSDpzLFBPU0lYX1JFR0VYX1NPVVJDRTpvLFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOmksUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOmEsUkVQTEFDRU1FTlRTOmx9PW47Y29uc3QgZXhwYW5kUmFuZ2U9KGUsdCk9PntpZih0eXBlb2YgdC5leHBhbmRSYW5nZT09PVwiZnVuY3Rpb25cIil7cmV0dXJuIHQuZXhwYW5kUmFuZ2UoLi4uZSx0KX1lLnNvcnQoKTtjb25zdCByPWBbJHtlLmpvaW4oXCItXCIpfV1gO3RyeXtuZXcgUmVnRXhwKHIpfWNhdGNoKHQpe3JldHVybiBlLm1hcCgoZT0+dS5lc2NhcGVSZWdleChlKSkpLmpvaW4oXCIuLlwiKX1yZXR1cm4gcn07Y29uc3Qgc3ludGF4RXJyb3I9KGUsdCk9PmBNaXNzaW5nICR7ZX06IFwiJHt0fVwiIC0gdXNlIFwiXFxcXFxcXFwke3R9XCIgdG8gbWF0Y2ggbGl0ZXJhbCBjaGFyYWN0ZXJzYDtjb25zdCBwYXJzZT0oZSx0KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpfWU9bFtlXXx8ZTtjb25zdCByPXsuLi50fTtjb25zdCBjPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4ocyxyLm1heExlbmd0aCk6cztsZXQgcD1lLmxlbmd0aDtpZihwPmMpe3Rocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke3B9LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7Y31gKX1jb25zdCBmPXt0eXBlOlwiYm9zXCIsdmFsdWU6XCJcIixvdXRwdXQ6ci5wcmVwZW5kfHxcIlwifTtjb25zdCBBPVtmXTtjb25zdCBSPXIuY2FwdHVyZT9cIlwiOlwiPzpcIjtjb25zdCBfPXUuaXNXaW5kb3dzKHQpO2NvbnN0IGg9bi5nbG9iQ2hhcnMoXyk7Y29uc3QgZz1uLmV4dGdsb2JDaGFycyhoKTtjb25zdHtET1RfTElURVJBTDpFLFBMVVNfTElURVJBTDpDLFNMQVNIX0xJVEVSQUw6eSxPTkVfQ0hBUjpkLERPVFNfU0xBU0g6eCxOT19ET1Q6YixOT19ET1RfU0xBU0g6UyxOT19ET1RTX1NMQVNIOkgsUU1BUks6dixRTUFSS19OT19ET1Q6JCxTVEFSOm0sU1RBUlRfQU5DSE9SOlR9PWg7Y29uc3QgZ2xvYnN0YXI9ZT0+YCgke1J9KD86KD8hJHtUfSR7ZS5kb3Q/eDpFfSkuKSo/KWA7Y29uc3QgTD1yLmRvdD9cIlwiOmI7Y29uc3QgTz1yLmRvdD92OiQ7bGV0IHc9ci5iYXNoPT09dHJ1ZT9nbG9ic3RhcihyKTptO2lmKHIuY2FwdHVyZSl7dz1gKCR7d30pYH1pZih0eXBlb2Ygci5ub2V4dD09PVwiYm9vbGVhblwiKXtyLm5vZXh0Z2xvYj1yLm5vZXh0fWNvbnN0IE49e2lucHV0OmUsaW5kZXg6LTEsc3RhcnQ6MCxkb3Q6ci5kb3Q9PT10cnVlLGNvbnN1bWVkOlwiXCIsb3V0cHV0OlwiXCIscHJlZml4OlwiXCIsYmFja3RyYWNrOmZhbHNlLG5lZ2F0ZWQ6ZmFsc2UsYnJhY2tldHM6MCxicmFjZXM6MCxwYXJlbnM6MCxxdW90ZXM6MCxnbG9ic3RhcjpmYWxzZSx0b2tlbnM6QX07ZT11LnJlbW92ZVByZWZpeChlLE4pO3A9ZS5sZW5ndGg7Y29uc3Qgaz1bXTtjb25zdCBJPVtdO2NvbnN0IE09W107bGV0IFA9ZjtsZXQgQjtjb25zdCBlb3M9KCk9Pk4uaW5kZXg9PT1wLTE7Y29uc3QgRz1OLnBlZWs9KHQ9MSk9PmVbTi5pbmRleCt0XTtjb25zdCBEPU4uYWR2YW5jZT0oKT0+ZVsrK04uaW5kZXhdO2NvbnN0IHJlbWFpbmluZz0oKT0+ZS5zbGljZShOLmluZGV4KzEpO2NvbnN0IGNvbnN1bWU9KGU9XCJcIix0PTApPT57Ti5jb25zdW1lZCs9ZTtOLmluZGV4Kz10fTtjb25zdCBhcHBlbmQ9ZT0+e04ub3V0cHV0Kz1lLm91dHB1dCE9bnVsbD9lLm91dHB1dDplLnZhbHVlO2NvbnN1bWUoZS52YWx1ZSl9O2NvbnN0IG5lZ2F0ZT0oKT0+e2xldCBlPTE7d2hpbGUoRygpPT09XCIhXCImJihHKDIpIT09XCIoXCJ8fEcoMyk9PT1cIj9cIikpe0QoKTtOLnN0YXJ0Kys7ZSsrfWlmKGUlMj09PTApe3JldHVybiBmYWxzZX1OLm5lZ2F0ZWQ9dHJ1ZTtOLnN0YXJ0Kys7cmV0dXJuIHRydWV9O2NvbnN0IGluY3JlbWVudD1lPT57TltlXSsrO00ucHVzaChlKX07Y29uc3QgZGVjcmVtZW50PWU9PntOW2VdLS07TS5wb3AoKX07Y29uc3QgcHVzaD1lPT57aWYoUC50eXBlPT09XCJnbG9ic3RhclwiKXtjb25zdCB0PU4uYnJhY2VzPjAmJihlLnR5cGU9PT1cImNvbW1hXCJ8fGUudHlwZT09PVwiYnJhY2VcIik7Y29uc3Qgcj1lLmV4dGdsb2I9PT10cnVlfHxrLmxlbmd0aCYmKGUudHlwZT09PVwicGlwZVwifHxlLnR5cGU9PT1cInBhcmVuXCIpO2lmKGUudHlwZSE9PVwic2xhc2hcIiYmZS50eXBlIT09XCJwYXJlblwiJiYhdCYmIXIpe04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLVAub3V0cHV0Lmxlbmd0aCk7UC50eXBlPVwic3RhclwiO1AudmFsdWU9XCIqXCI7UC5vdXRwdXQ9dztOLm91dHB1dCs9UC5vdXRwdXR9fWlmKGsubGVuZ3RoJiZlLnR5cGUhPT1cInBhcmVuXCImJiFnW2UudmFsdWVdKXtrW2subGVuZ3RoLTFdLmlubmVyKz1lLnZhbHVlfWlmKGUudmFsdWV8fGUub3V0cHV0KWFwcGVuZChlKTtpZihQJiZQLnR5cGU9PT1cInRleHRcIiYmZS50eXBlPT09XCJ0ZXh0XCIpe1AudmFsdWUrPWUudmFsdWU7UC5vdXRwdXQ9KFAub3V0cHV0fHxcIlwiKStlLnZhbHVlO3JldHVybn1lLnByZXY9UDtBLnB1c2goZSk7UD1lfTtjb25zdCBleHRnbG9iT3Blbj0oZSx0KT0+e2NvbnN0IG49ey4uLmdbdF0sY29uZGl0aW9uczoxLGlubmVyOlwiXCJ9O24ucHJldj1QO24ucGFyZW5zPU4ucGFyZW5zO24ub3V0cHV0PU4ub3V0cHV0O2NvbnN0IHU9KHIuY2FwdHVyZT9cIihcIjpcIlwiKStuLm9wZW47aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6ZSx2YWx1ZTp0LG91dHB1dDpOLm91dHB1dD9cIlwiOmR9KTtwdXNoKHt0eXBlOlwicGFyZW5cIixleHRnbG9iOnRydWUsdmFsdWU6RCgpLG91dHB1dDp1fSk7ay5wdXNoKG4pfTtjb25zdCBleHRnbG9iQ2xvc2U9ZT0+e2xldCB0PWUuY2xvc2UrKHIuY2FwdHVyZT9cIilcIjpcIlwiKTtpZihlLnR5cGU9PT1cIm5lZ2F0ZVwiKXtsZXQgbj13O2lmKGUuaW5uZXImJmUuaW5uZXIubGVuZ3RoPjEmJmUuaW5uZXIuaW5jbHVkZXMoXCIvXCIpKXtuPWdsb2JzdGFyKHIpfWlmKG4hPT13fHxlb3MoKXx8L15cXCkrJC8udGVzdChyZW1haW5pbmcoKSkpe3Q9ZS5jbG9zZT1gKSQpKSR7bn1gfWlmKGUucHJldi50eXBlPT09XCJib3NcIil7Ti5uZWdhdGVkRXh0Z2xvYj10cnVlfX1wdXNoKHt0eXBlOlwicGFyZW5cIixleHRnbG9iOnRydWUsdmFsdWU6QixvdXRwdXQ6dH0pO2RlY3JlbWVudChcInBhcmVuc1wiKX07aWYoci5mYXN0cGF0aHMhPT1mYWxzZSYmIS8oXlsqIV18Wy8oKVtcXF17fVwiXSkvLnRlc3QoZSkpe2xldCBuPWZhbHNlO2xldCBzPWUucmVwbGFjZShhLCgoZSx0LHIsdSxzLG8pPT57aWYodT09PVwiXFxcXFwiKXtuPXRydWU7cmV0dXJuIGV9aWYodT09PVwiP1wiKXtpZih0KXtyZXR1cm4gdCt1KyhzP3YucmVwZWF0KHMubGVuZ3RoKTpcIlwiKX1pZihvPT09MCl7cmV0dXJuIE8rKHM/di5yZXBlYXQocy5sZW5ndGgpOlwiXCIpfXJldHVybiB2LnJlcGVhdChyLmxlbmd0aCl9aWYodT09PVwiLlwiKXtyZXR1cm4gRS5yZXBlYXQoci5sZW5ndGgpfWlmKHU9PT1cIipcIil7aWYodCl7cmV0dXJuIHQrdSsocz93OlwiXCIpfXJldHVybiB3fXJldHVybiB0P2U6YFxcXFwke2V9YH0pKTtpZihuPT09dHJ1ZSl7aWYoci51bmVzY2FwZT09PXRydWUpe3M9cy5yZXBsYWNlKC9cXFxcL2csXCJcIil9ZWxzZXtzPXMucmVwbGFjZSgvXFxcXCsvZywoZT0+ZS5sZW5ndGglMj09PTA/XCJcXFxcXFxcXFwiOmU/XCJcXFxcXCI6XCJcIikpfX1pZihzPT09ZSYmci5jb250YWlucz09PXRydWUpe04ub3V0cHV0PWU7cmV0dXJuIE59Ti5vdXRwdXQ9dS53cmFwT3V0cHV0KHMsTix0KTtyZXR1cm4gTn13aGlsZSghZW9zKCkpe0I9RCgpO2lmKEI9PT1cIlxcMFwiKXtjb250aW51ZX1pZihCPT09XCJcXFxcXCIpe2NvbnN0IGU9RygpO2lmKGU9PT1cIi9cIiYmci5iYXNoIT09dHJ1ZSl7Y29udGludWV9aWYoZT09PVwiLlwifHxlPT09XCI7XCIpe2NvbnRpbnVlfWlmKCFlKXtCKz1cIlxcXFxcIjtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX1jb25zdCB0PS9eXFxcXCsvLmV4ZWMocmVtYWluaW5nKCkpO2xldCBuPTA7aWYodCYmdFswXS5sZW5ndGg+Mil7bj10WzBdLmxlbmd0aDtOLmluZGV4Kz1uO2lmKG4lMiE9PTApe0IrPVwiXFxcXFwifX1pZihyLnVuZXNjYXBlPT09dHJ1ZSl7Qj1EKCl8fFwiXCJ9ZWxzZXtCKz1EKCl8fFwiXCJ9aWYoTi5icmFja2V0cz09PTApe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfX1pZihOLmJyYWNrZXRzPjAmJihCIT09XCJdXCJ8fFAudmFsdWU9PT1cIltcInx8UC52YWx1ZT09PVwiW15cIikpe2lmKHIucG9zaXghPT1mYWxzZSYmQj09PVwiOlwiKXtjb25zdCBlPVAudmFsdWUuc2xpY2UoMSk7aWYoZS5pbmNsdWRlcyhcIltcIikpe1AucG9zaXg9dHJ1ZTtpZihlLmluY2x1ZGVzKFwiOlwiKSl7Y29uc3QgZT1QLnZhbHVlLmxhc3RJbmRleE9mKFwiW1wiKTtjb25zdCB0PVAudmFsdWUuc2xpY2UoMCxlKTtjb25zdCByPVAudmFsdWUuc2xpY2UoZSsyKTtjb25zdCBuPW9bcl07aWYobil7UC52YWx1ZT10K247Ti5iYWNrdHJhY2s9dHJ1ZTtEKCk7aWYoIWYub3V0cHV0JiZBLmluZGV4T2YoUCk9PT0xKXtmLm91dHB1dD1kfWNvbnRpbnVlfX19fWlmKEI9PT1cIltcIiYmRygpIT09XCI6XCJ8fEI9PT1cIi1cIiYmRygpPT09XCJdXCIpe0I9YFxcXFwke0J9YH1pZihCPT09XCJdXCImJihQLnZhbHVlPT09XCJbXCJ8fFAudmFsdWU9PT1cIlteXCIpKXtCPWBcXFxcJHtCfWB9aWYoci5wb3NpeD09PXRydWUmJkI9PT1cIiFcIiYmUC52YWx1ZT09PVwiW1wiKXtCPVwiXlwifVAudmFsdWUrPUI7YXBwZW5kKHt2YWx1ZTpCfSk7Y29udGludWV9aWYoTi5xdW90ZXM9PT0xJiZCIT09J1wiJyl7Qj11LmVzY2FwZVJlZ2V4KEIpO1AudmFsdWUrPUI7YXBwZW5kKHt2YWx1ZTpCfSk7Y29udGludWV9aWYoQj09PSdcIicpe04ucXVvdGVzPU4ucXVvdGVzPT09MT8wOjE7aWYoci5rZWVwUXVvdGVzPT09dHJ1ZSl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCfSl9Y29udGludWV9aWYoQj09PVwiKFwiKXtpbmNyZW1lbnQoXCJwYXJlbnNcIik7cHVzaCh7dHlwZTpcInBhcmVuXCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT1cIilcIil7aWYoTi5wYXJlbnM9PT0wJiZyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl7dGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwib3BlbmluZ1wiLFwiKFwiKSl9Y29uc3QgZT1rW2subGVuZ3RoLTFdO2lmKGUmJk4ucGFyZW5zPT09ZS5wYXJlbnMrMSl7ZXh0Z2xvYkNsb3NlKGsucG9wKCkpO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJwYXJlblwiLHZhbHVlOkIsb3V0cHV0Ok4ucGFyZW5zP1wiKVwiOlwiXFxcXClcIn0pO2RlY3JlbWVudChcInBhcmVuc1wiKTtjb250aW51ZX1pZihCPT09XCJbXCIpe2lmKHIubm9icmFja2V0PT09dHJ1ZXx8IXJlbWFpbmluZygpLmluY2x1ZGVzKFwiXVwiKSl7aWYoci5ub2JyYWNrZXQhPT10cnVlJiZyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl7dGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiXVwiKSl9Qj1gXFxcXCR7Qn1gfWVsc2V7aW5jcmVtZW50KFwiYnJhY2tldHNcIil9cHVzaCh7dHlwZTpcImJyYWNrZXRcIix2YWx1ZTpCfSk7Y29udGludWV9aWYoQj09PVwiXVwiKXtpZihyLm5vYnJhY2tldD09PXRydWV8fFAmJlAudHlwZT09PVwiYnJhY2tldFwiJiZQLnZhbHVlLmxlbmd0aD09PTEpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6QixvdXRwdXQ6YFxcXFwke0J9YH0pO2NvbnRpbnVlfWlmKE4uYnJhY2tldHM9PT0wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl7dGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwib3BlbmluZ1wiLFwiW1wiKSl9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDpgXFxcXCR7Qn1gfSk7Y29udGludWV9ZGVjcmVtZW50KFwiYnJhY2tldHNcIik7Y29uc3QgZT1QLnZhbHVlLnNsaWNlKDEpO2lmKFAucG9zaXghPT10cnVlJiZlWzBdPT09XCJeXCImJiFlLmluY2x1ZGVzKFwiL1wiKSl7Qj1gLyR7Qn1gfVAudmFsdWUrPUI7YXBwZW5kKHt2YWx1ZTpCfSk7aWYoci5saXRlcmFsQnJhY2tldHM9PT1mYWxzZXx8dS5oYXNSZWdleENoYXJzKGUpKXtjb250aW51ZX1jb25zdCB0PXUuZXNjYXBlUmVnZXgoUC52YWx1ZSk7Ti5vdXRwdXQ9Ti5vdXRwdXQuc2xpY2UoMCwtUC52YWx1ZS5sZW5ndGgpO2lmKHIubGl0ZXJhbEJyYWNrZXRzPT09dHJ1ZSl7Ti5vdXRwdXQrPXQ7UC52YWx1ZT10O2NvbnRpbnVlfVAudmFsdWU9YCgke1J9JHt0fXwke1AudmFsdWV9KWA7Ti5vdXRwdXQrPVAudmFsdWU7Y29udGludWV9aWYoQj09PVwie1wiJiZyLm5vYnJhY2UhPT10cnVlKXtpbmNyZW1lbnQoXCJicmFjZXNcIik7Y29uc3QgZT17dHlwZTpcImJyYWNlXCIsdmFsdWU6QixvdXRwdXQ6XCIoXCIsb3V0cHV0SW5kZXg6Ti5vdXRwdXQubGVuZ3RoLHRva2Vuc0luZGV4Ok4udG9rZW5zLmxlbmd0aH07SS5wdXNoKGUpO3B1c2goZSk7Y29udGludWV9aWYoQj09PVwifVwiKXtjb25zdCBlPUlbSS5sZW5ndGgtMV07aWYoci5ub2JyYWNlPT09dHJ1ZXx8IWUpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6QixvdXRwdXQ6Qn0pO2NvbnRpbnVlfWxldCB0PVwiKVwiO2lmKGUuZG90cz09PXRydWUpe2NvbnN0IGU9QS5zbGljZSgpO2NvbnN0IG49W107Zm9yKGxldCB0PWUubGVuZ3RoLTE7dD49MDt0LS0pe0EucG9wKCk7aWYoZVt0XS50eXBlPT09XCJicmFjZVwiKXticmVha31pZihlW3RdLnR5cGUhPT1cImRvdHNcIil7bi51bnNoaWZ0KGVbdF0udmFsdWUpfX10PWV4cGFuZFJhbmdlKG4scik7Ti5iYWNrdHJhY2s9dHJ1ZX1pZihlLmNvbW1hIT09dHJ1ZSYmZS5kb3RzIT09dHJ1ZSl7Y29uc3Qgcj1OLm91dHB1dC5zbGljZSgwLGUub3V0cHV0SW5kZXgpO2NvbnN0IG49Ti50b2tlbnMuc2xpY2UoZS50b2tlbnNJbmRleCk7ZS52YWx1ZT1lLm91dHB1dD1cIlxcXFx7XCI7Qj10PVwiXFxcXH1cIjtOLm91dHB1dD1yO2Zvcihjb25zdCBlIG9mIG4pe04ub3V0cHV0Kz1lLm91dHB1dHx8ZS52YWx1ZX19cHVzaCh7dHlwZTpcImJyYWNlXCIsdmFsdWU6QixvdXRwdXQ6dH0pO2RlY3JlbWVudChcImJyYWNlc1wiKTtJLnBvcCgpO2NvbnRpbnVlfWlmKEI9PT1cInxcIil7aWYoay5sZW5ndGg+MCl7a1trLmxlbmd0aC0xXS5jb25kaXRpb25zKyt9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCfSk7Y29udGludWV9aWYoQj09PVwiLFwiKXtsZXQgZT1CO2NvbnN0IHQ9SVtJLmxlbmd0aC0xXTtpZih0JiZNW00ubGVuZ3RoLTFdPT09XCJicmFjZXNcIil7dC5jb21tYT10cnVlO2U9XCJ8XCJ9cHVzaCh7dHlwZTpcImNvbW1hXCIsdmFsdWU6QixvdXRwdXQ6ZX0pO2NvbnRpbnVlfWlmKEI9PT1cIi9cIil7aWYoUC50eXBlPT09XCJkb3RcIiYmTi5pbmRleD09PU4uc3RhcnQrMSl7Ti5zdGFydD1OLmluZGV4KzE7Ti5jb25zdW1lZD1cIlwiO04ub3V0cHV0PVwiXCI7QS5wb3AoKTtQPWY7Y29udGludWV9cHVzaCh7dHlwZTpcInNsYXNoXCIsdmFsdWU6QixvdXRwdXQ6eX0pO2NvbnRpbnVlfWlmKEI9PT1cIi5cIil7aWYoTi5icmFjZXM+MCYmUC50eXBlPT09XCJkb3RcIil7aWYoUC52YWx1ZT09PVwiLlwiKVAub3V0cHV0PUU7Y29uc3QgZT1JW0kubGVuZ3RoLTFdO1AudHlwZT1cImRvdHNcIjtQLm91dHB1dCs9QjtQLnZhbHVlKz1CO2UuZG90cz10cnVlO2NvbnRpbnVlfWlmKE4uYnJhY2VzK04ucGFyZW5zPT09MCYmUC50eXBlIT09XCJib3NcIiYmUC50eXBlIT09XCJzbGFzaFwiKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OkV9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwiZG90XCIsdmFsdWU6QixvdXRwdXQ6RX0pO2NvbnRpbnVlfWlmKEI9PT1cIj9cIil7Y29uc3QgZT1QJiZQLnZhbHVlPT09XCIoXCI7aWYoIWUmJnIubm9leHRnbG9iIT09dHJ1ZSYmRygpPT09XCIoXCImJkcoMikhPT1cIj9cIil7ZXh0Z2xvYk9wZW4oXCJxbWFya1wiLEIpO2NvbnRpbnVlfWlmKFAmJlAudHlwZT09PVwicGFyZW5cIil7Y29uc3QgZT1HKCk7bGV0IHQ9QjtpZihlPT09XCI8XCImJiF1LnN1cHBvcnRzTG9va2JlaGluZHMoKSl7dGhyb3cgbmV3IEVycm9yKFwiTm9kZS5qcyB2MTAgb3IgaGlnaGVyIGlzIHJlcXVpcmVkIGZvciByZWdleCBsb29rYmVoaW5kc1wiKX1pZihQLnZhbHVlPT09XCIoXCImJiEvWyE9PDpdLy50ZXN0KGUpfHxlPT09XCI8XCImJiEvPChbIT1dfFxcdys+KS8udGVzdChyZW1haW5pbmcoKSkpe3Q9YFxcXFwke0J9YH1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OnR9KTtjb250aW51ZX1pZihyLmRvdCE9PXRydWUmJihQLnR5cGU9PT1cInNsYXNoXCJ8fFAudHlwZT09PVwiYm9zXCIpKXtwdXNoKHt0eXBlOlwicW1hcmtcIix2YWx1ZTpCLG91dHB1dDokfSk7Y29udGludWV9cHVzaCh7dHlwZTpcInFtYXJrXCIsdmFsdWU6QixvdXRwdXQ6dn0pO2NvbnRpbnVlfWlmKEI9PT1cIiFcIil7aWYoci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIil7aWYoRygyKSE9PVwiP1wifHwhL1shPTw6XS8udGVzdChHKDMpKSl7ZXh0Z2xvYk9wZW4oXCJuZWdhdGVcIixCKTtjb250aW51ZX19aWYoci5ub25lZ2F0ZSE9PXRydWUmJk4uaW5kZXg9PT0wKXtuZWdhdGUoKTtjb250aW51ZX19aWYoQj09PVwiK1wiKXtpZihyLm5vZXh0Z2xvYiE9PXRydWUmJkcoKT09PVwiKFwiJiZHKDIpIT09XCI/XCIpe2V4dGdsb2JPcGVuKFwicGx1c1wiLEIpO2NvbnRpbnVlfWlmKFAmJlAudmFsdWU9PT1cIihcInx8ci5yZWdleD09PWZhbHNlKXtwdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOkIsb3V0cHV0OkN9KTtjb250aW51ZX1pZihQJiYoUC50eXBlPT09XCJicmFja2V0XCJ8fFAudHlwZT09PVwicGFyZW5cInx8UC50eXBlPT09XCJicmFjZVwiKXx8Ti5wYXJlbnM+MCl7cHVzaCh7dHlwZTpcInBsdXNcIix2YWx1ZTpCfSk7Y29udGludWV9cHVzaCh7dHlwZTpcInBsdXNcIix2YWx1ZTpDfSk7Y29udGludWV9aWYoQj09PVwiQFwiKXtpZihyLm5vZXh0Z2xvYiE9PXRydWUmJkcoKT09PVwiKFwiJiZHKDIpIT09XCI/XCIpe3B1c2goe3R5cGU6XCJhdFwiLGV4dGdsb2I6dHJ1ZSx2YWx1ZTpCLG91dHB1dDpcIlwifSk7Y29udGludWV9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCfSk7Y29udGludWV9aWYoQiE9PVwiKlwiKXtpZihCPT09XCIkXCJ8fEI9PT1cIl5cIil7Qj1gXFxcXCR7Qn1gfWNvbnN0IGU9aS5leGVjKHJlbWFpbmluZygpKTtpZihlKXtCKz1lWzBdO04uaW5kZXgrPWVbMF0ubGVuZ3RofXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKFAmJihQLnR5cGU9PT1cImdsb2JzdGFyXCJ8fFAuc3Rhcj09PXRydWUpKXtQLnR5cGU9XCJzdGFyXCI7UC5zdGFyPXRydWU7UC52YWx1ZSs9QjtQLm91dHB1dD13O04uYmFja3RyYWNrPXRydWU7Ti5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoQik7Y29udGludWV9bGV0IHQ9cmVtYWluaW5nKCk7aWYoci5ub2V4dGdsb2IhPT10cnVlJiYvXlxcKFteP10vLnRlc3QodCkpe2V4dGdsb2JPcGVuKFwic3RhclwiLEIpO2NvbnRpbnVlfWlmKFAudHlwZT09PVwic3RhclwiKXtpZihyLm5vZ2xvYnN0YXI9PT10cnVlKXtjb25zdW1lKEIpO2NvbnRpbnVlfWNvbnN0IG49UC5wcmV2O2NvbnN0IHU9bi5wcmV2O2NvbnN0IHM9bi50eXBlPT09XCJzbGFzaFwifHxuLnR5cGU9PT1cImJvc1wiO2NvbnN0IG89dSYmKHUudHlwZT09PVwic3RhclwifHx1LnR5cGU9PT1cImdsb2JzdGFyXCIpO2lmKHIuYmFzaD09PXRydWUmJighc3x8dFswXSYmdFswXSE9PVwiL1wiKSl7cHVzaCh7dHlwZTpcInN0YXJcIix2YWx1ZTpCLG91dHB1dDpcIlwifSk7Y29udGludWV9Y29uc3QgaT1OLmJyYWNlcz4wJiYobi50eXBlPT09XCJjb21tYVwifHxuLnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IGE9ay5sZW5ndGgmJihuLnR5cGU9PT1cInBpcGVcInx8bi50eXBlPT09XCJwYXJlblwiKTtpZighcyYmbi50eXBlIT09XCJwYXJlblwiJiYhaSYmIWEpe3B1c2goe3R5cGU6XCJzdGFyXCIsdmFsdWU6QixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfXdoaWxlKHQuc2xpY2UoMCwzKT09PVwiLyoqXCIpe2NvbnN0IHI9ZVtOLmluZGV4KzRdO2lmKHImJnIhPT1cIi9cIil7YnJlYWt9dD10LnNsaWNlKDMpO2NvbnN1bWUoXCIvKipcIiwzKX1pZihuLnR5cGU9PT1cImJvc1wiJiZlb3MoKSl7UC50eXBlPVwiZ2xvYnN0YXJcIjtQLnZhbHVlKz1CO1Aub3V0cHV0PWdsb2JzdGFyKHIpO04ub3V0cHV0PVAub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIpO2NvbnRpbnVlfWlmKG4udHlwZT09PVwic2xhc2hcIiYmbi5wcmV2LnR5cGUhPT1cImJvc1wiJiYhbyYmZW9zKCkpe04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLShuLm91dHB1dCtQLm91dHB1dCkubGVuZ3RoKTtuLm91dHB1dD1gKD86JHtuLm91dHB1dH1gO1AudHlwZT1cImdsb2JzdGFyXCI7UC5vdXRwdXQ9Z2xvYnN0YXIocikrKHIuc3RyaWN0U2xhc2hlcz9cIilcIjpcInwkKVwiKTtQLnZhbHVlKz1CO04uZ2xvYnN0YXI9dHJ1ZTtOLm91dHB1dCs9bi5vdXRwdXQrUC5vdXRwdXQ7Y29uc3VtZShCKTtjb250aW51ZX1pZihuLnR5cGU9PT1cInNsYXNoXCImJm4ucHJldi50eXBlIT09XCJib3NcIiYmdFswXT09PVwiL1wiKXtjb25zdCBlPXRbMV0hPT12b2lkIDA/XCJ8JFwiOlwiXCI7Ti5vdXRwdXQ9Ti5vdXRwdXQuc2xpY2UoMCwtKG4ub3V0cHV0K1Aub3V0cHV0KS5sZW5ndGgpO24ub3V0cHV0PWAoPzoke24ub3V0cHV0fWA7UC50eXBlPVwiZ2xvYnN0YXJcIjtQLm91dHB1dD1gJHtnbG9ic3RhcihyKX0ke3l9fCR7eX0ke2V9KWA7UC52YWx1ZSs9QjtOLm91dHB1dCs9bi5vdXRwdXQrUC5vdXRwdXQ7Ti5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoQitEKCkpO3B1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOlwiL1wiLG91dHB1dDpcIlwifSk7Y29udGludWV9aWYobi50eXBlPT09XCJib3NcIiYmdFswXT09PVwiL1wiKXtQLnR5cGU9XCJnbG9ic3RhclwiO1AudmFsdWUrPUI7UC5vdXRwdXQ9YCg/Ol58JHt5fXwke2dsb2JzdGFyKHIpfSR7eX0pYDtOLm91dHB1dD1QLm91dHB1dDtOLmdsb2JzdGFyPXRydWU7Y29uc3VtZShCK0QoKSk7cHVzaCh7dHlwZTpcInNsYXNoXCIsdmFsdWU6XCIvXCIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1OLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC1QLm91dHB1dC5sZW5ndGgpO1AudHlwZT1cImdsb2JzdGFyXCI7UC5vdXRwdXQ9Z2xvYnN0YXIocik7UC52YWx1ZSs9QjtOLm91dHB1dCs9UC5vdXRwdXQ7Ti5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoQik7Y29udGludWV9Y29uc3Qgbj17dHlwZTpcInN0YXJcIix2YWx1ZTpCLG91dHB1dDp3fTtpZihyLmJhc2g9PT10cnVlKXtuLm91dHB1dD1cIi4qP1wiO2lmKFAudHlwZT09PVwiYm9zXCJ8fFAudHlwZT09PVwic2xhc2hcIil7bi5vdXRwdXQ9TCtuLm91dHB1dH1wdXNoKG4pO2NvbnRpbnVlfWlmKFAmJihQLnR5cGU9PT1cImJyYWNrZXRcInx8UC50eXBlPT09XCJwYXJlblwiKSYmci5yZWdleD09PXRydWUpe24ub3V0cHV0PUI7cHVzaChuKTtjb250aW51ZX1pZihOLmluZGV4PT09Ti5zdGFydHx8UC50eXBlPT09XCJzbGFzaFwifHxQLnR5cGU9PT1cImRvdFwiKXtpZihQLnR5cGU9PT1cImRvdFwiKXtOLm91dHB1dCs9UztQLm91dHB1dCs9U31lbHNlIGlmKHIuZG90PT09dHJ1ZSl7Ti5vdXRwdXQrPUg7UC5vdXRwdXQrPUh9ZWxzZXtOLm91dHB1dCs9TDtQLm91dHB1dCs9TH1pZihHKCkhPT1cIipcIil7Ti5vdXRwdXQrPWQ7UC5vdXRwdXQrPWR9fXB1c2gobil9d2hpbGUoTi5icmFja2V0cz4wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJdXCIpKTtOLm91dHB1dD11LmVzY2FwZUxhc3QoTi5vdXRwdXQsXCJbXCIpO2RlY3JlbWVudChcImJyYWNrZXRzXCIpfXdoaWxlKE4ucGFyZW5zPjApe2lmKHIuc3RyaWN0QnJhY2tldHM9PT10cnVlKXRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIilcIikpO04ub3V0cHV0PXUuZXNjYXBlTGFzdChOLm91dHB1dCxcIihcIik7ZGVjcmVtZW50KFwicGFyZW5zXCIpfXdoaWxlKE4uYnJhY2VzPjApe2lmKHIuc3RyaWN0QnJhY2tldHM9PT10cnVlKXRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIn1cIikpO04ub3V0cHV0PXUuZXNjYXBlTGFzdChOLm91dHB1dCxcIntcIik7ZGVjcmVtZW50KFwiYnJhY2VzXCIpfWlmKHIuc3RyaWN0U2xhc2hlcyE9PXRydWUmJihQLnR5cGU9PT1cInN0YXJcInx8UC50eXBlPT09XCJicmFja2V0XCIpKXtwdXNoKHt0eXBlOlwibWF5YmVfc2xhc2hcIix2YWx1ZTpcIlwiLG91dHB1dDpgJHt5fT9gfSl9aWYoTi5iYWNrdHJhY2s9PT10cnVlKXtOLm91dHB1dD1cIlwiO2Zvcihjb25zdCBlIG9mIE4udG9rZW5zKXtOLm91dHB1dCs9ZS5vdXRwdXQhPW51bGw/ZS5vdXRwdXQ6ZS52YWx1ZTtpZihlLnN1ZmZpeCl7Ti5vdXRwdXQrPWUuc3VmZml4fX19cmV0dXJuIE59O3BhcnNlLmZhc3RwYXRocz0oZSx0KT0+e2NvbnN0IHI9ey4uLnR9O2NvbnN0IG89dHlwZW9mIHIubWF4TGVuZ3RoPT09XCJudW1iZXJcIj9NYXRoLm1pbihzLHIubWF4TGVuZ3RoKTpzO2NvbnN0IGk9ZS5sZW5ndGg7aWYoaT5vKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtpfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke299YCl9ZT1sW2VdfHxlO2NvbnN0IGE9dS5pc1dpbmRvd3ModCk7Y29uc3R7RE9UX0xJVEVSQUw6YyxTTEFTSF9MSVRFUkFMOnAsT05FX0NIQVI6ZixET1RTX1NMQVNIOkEsTk9fRE9UOlIsTk9fRE9UUzpfLE5PX0RPVFNfU0xBU0g6aCxTVEFSOmcsU1RBUlRfQU5DSE9SOkV9PW4uZ2xvYkNoYXJzKGEpO2NvbnN0IEM9ci5kb3Q/XzpSO2NvbnN0IHk9ci5kb3Q/aDpSO2NvbnN0IGQ9ci5jYXB0dXJlP1wiXCI6XCI/OlwiO2NvbnN0IHg9e25lZ2F0ZWQ6ZmFsc2UscHJlZml4OlwiXCJ9O2xldCBiPXIuYmFzaD09PXRydWU/XCIuKj9cIjpnO2lmKHIuY2FwdHVyZSl7Yj1gKCR7Yn0pYH1jb25zdCBnbG9ic3Rhcj1lPT57aWYoZS5ub2dsb2JzdGFyPT09dHJ1ZSlyZXR1cm4gYjtyZXR1cm5gKCR7ZH0oPzooPyEke0V9JHtlLmRvdD9BOmN9KS4pKj8pYH07Y29uc3QgY3JlYXRlPWU9Pntzd2l0Y2goZSl7Y2FzZVwiKlwiOnJldHVybmAke0N9JHtmfSR7Yn1gO2Nhc2VcIi4qXCI6cmV0dXJuYCR7Y30ke2Z9JHtifWA7Y2FzZVwiKi4qXCI6cmV0dXJuYCR7Q30ke2J9JHtjfSR7Zn0ke2J9YDtjYXNlXCIqLypcIjpyZXR1cm5gJHtDfSR7Yn0ke3B9JHtmfSR7eX0ke2J9YDtjYXNlXCIqKlwiOnJldHVybiBDK2dsb2JzdGFyKHIpO2Nhc2VcIioqLypcIjpyZXR1cm5gKD86JHtDfSR7Z2xvYnN0YXIocil9JHtwfSk/JHt5fSR7Zn0ke2J9YDtjYXNlXCIqKi8qLipcIjpyZXR1cm5gKD86JHtDfSR7Z2xvYnN0YXIocil9JHtwfSk/JHt5fSR7Yn0ke2N9JHtmfSR7Yn1gO2Nhc2VcIioqLy4qXCI6cmV0dXJuYCg/OiR7Q30ke2dsb2JzdGFyKHIpfSR7cH0pPyR7Y30ke2Z9JHtifWA7ZGVmYXVsdDp7Y29uc3QgdD0vXiguKj8pXFwuKFxcdyspJC8uZXhlYyhlKTtpZighdClyZXR1cm47Y29uc3Qgcj1jcmVhdGUodFsxXSk7aWYoIXIpcmV0dXJuO3JldHVybiByK2MrdFsyXX19fTtjb25zdCBTPXUucmVtb3ZlUHJlZml4KGUseCk7bGV0IEg9Y3JlYXRlKFMpO2lmKEgmJnIuc3RyaWN0U2xhc2hlcyE9PXRydWUpe0grPWAke3B9P2B9cmV0dXJuIEh9O2UuZXhwb3J0cz1wYXJzZX0sNTA5OihlLHQscik9Pntjb25zdCBuPXIoMTcpO2NvbnN0IHU9cigyMTYpO2NvbnN0IHM9cig4MjEpO2NvbnN0IG89cigyNDMpO2NvbnN0IGk9cig4NzEpO2NvbnN0IGlzT2JqZWN0PWU9PmUmJnR5cGVvZiBlPT09XCJvYmplY3RcIiYmIUFycmF5LmlzQXJyYXkoZSk7Y29uc3QgcGljb21hdGNoPShlLHQscj1mYWxzZSk9PntpZihBcnJheS5pc0FycmF5KGUpKXtjb25zdCBuPWUubWFwKChlPT5waWNvbWF0Y2goZSx0LHIpKSk7Y29uc3QgYXJyYXlNYXRjaGVyPWU9Pntmb3IoY29uc3QgdCBvZiBuKXtjb25zdCByPXQoZSk7aWYocilyZXR1cm4gcn1yZXR1cm4gZmFsc2V9O3JldHVybiBhcnJheU1hdGNoZXJ9Y29uc3Qgbj1pc09iamVjdChlKSYmZS50b2tlbnMmJmUuaW5wdXQ7aWYoZT09PVwiXCJ8fHR5cGVvZiBlIT09XCJzdHJpbmdcIiYmIW4pe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1jb25zdCB1PXR8fHt9O2NvbnN0IHM9by5pc1dpbmRvd3ModCk7Y29uc3QgaT1uP3BpY29tYXRjaC5jb21waWxlUmUoZSx0KTpwaWNvbWF0Y2gubWFrZVJlKGUsdCxmYWxzZSx0cnVlKTtjb25zdCBhPWkuc3RhdGU7ZGVsZXRlIGkuc3RhdGU7bGV0IGlzSWdub3JlZD0oKT0+ZmFsc2U7aWYodS5pZ25vcmUpe2NvbnN0IGU9ey4uLnQsaWdub3JlOm51bGwsb25NYXRjaDpudWxsLG9uUmVzdWx0Om51bGx9O2lzSWdub3JlZD1waWNvbWF0Y2godS5pZ25vcmUsZSxyKX1jb25zdCBtYXRjaGVyPShyLG49ZmFsc2UpPT57Y29uc3R7aXNNYXRjaDpvLG1hdGNoOmwsb3V0cHV0OmN9PXBpY29tYXRjaC50ZXN0KHIsaSx0LHtnbG9iOmUscG9zaXg6c30pO2NvbnN0IHA9e2dsb2I6ZSxzdGF0ZTphLHJlZ2V4OmkscG9zaXg6cyxpbnB1dDpyLG91dHB1dDpjLG1hdGNoOmwsaXNNYXRjaDpvfTtpZih0eXBlb2YgdS5vblJlc3VsdD09PVwiZnVuY3Rpb25cIil7dS5vblJlc3VsdChwKX1pZihvPT09ZmFsc2Upe3AuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9wOmZhbHNlfWlmKGlzSWdub3JlZChyKSl7aWYodHlwZW9mIHUub25JZ25vcmU9PT1cImZ1bmN0aW9uXCIpe3Uub25JZ25vcmUocCl9cC5pc01hdGNoPWZhbHNlO3JldHVybiBuP3A6ZmFsc2V9aWYodHlwZW9mIHUub25NYXRjaD09PVwiZnVuY3Rpb25cIil7dS5vbk1hdGNoKHApfXJldHVybiBuP3A6dHJ1ZX07aWYocil7bWF0Y2hlci5zdGF0ZT1hfXJldHVybiBtYXRjaGVyfTtwaWNvbWF0Y2gudGVzdD0oZSx0LHIse2dsb2I6bixwb3NpeDp1fT17fSk9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbnB1dCB0byBiZSBhIHN0cmluZ1wiKX1pZihlPT09XCJcIil7cmV0dXJue2lzTWF0Y2g6ZmFsc2Usb3V0cHV0OlwiXCJ9fWNvbnN0IHM9cnx8e307Y29uc3QgaT1zLmZvcm1hdHx8KHU/by50b1Bvc2l4U2xhc2hlczpudWxsKTtsZXQgYT1lPT09bjtsZXQgbD1hJiZpP2koZSk6ZTtpZihhPT09ZmFsc2Upe2w9aT9pKGUpOmU7YT1sPT09bn1pZihhPT09ZmFsc2V8fHMuY2FwdHVyZT09PXRydWUpe2lmKHMubWF0Y2hCYXNlPT09dHJ1ZXx8cy5iYXNlbmFtZT09PXRydWUpe2E9cGljb21hdGNoLm1hdGNoQmFzZShlLHQscix1KX1lbHNle2E9dC5leGVjKGwpfX1yZXR1cm57aXNNYXRjaDpCb29sZWFuKGEpLG1hdGNoOmEsb3V0cHV0Omx9fTtwaWNvbWF0Y2gubWF0Y2hCYXNlPShlLHQscix1PW8uaXNXaW5kb3dzKHIpKT0+e2NvbnN0IHM9dCBpbnN0YW5jZW9mIFJlZ0V4cD90OnBpY29tYXRjaC5tYWtlUmUodCxyKTtyZXR1cm4gcy50ZXN0KG4uYmFzZW5hbWUoZSkpfTtwaWNvbWF0Y2guaXNNYXRjaD0oZSx0LHIpPT5waWNvbWF0Y2godCxyKShlKTtwaWNvbWF0Y2gucGFyc2U9KGUsdCk9PntpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlLm1hcCgoZT0+cGljb21hdGNoLnBhcnNlKGUsdCkpKTtyZXR1cm4gcyhlLHsuLi50LGZhc3RwYXRoczpmYWxzZX0pfTtwaWNvbWF0Y2guc2Nhbj0oZSx0KT0+dShlLHQpO3BpY29tYXRjaC5jb21waWxlUmU9KGUsdCxyPWZhbHNlLG49ZmFsc2UpPT57aWYocj09PXRydWUpe3JldHVybiBlLm91dHB1dH1jb25zdCB1PXR8fHt9O2NvbnN0IHM9dS5jb250YWlucz9cIlwiOlwiXlwiO2NvbnN0IG89dS5jb250YWlucz9cIlwiOlwiJFwiO2xldCBpPWAke3N9KD86JHtlLm91dHB1dH0pJHtvfWA7aWYoZSYmZS5uZWdhdGVkPT09dHJ1ZSl7aT1gXig/ISR7aX0pLiokYH1jb25zdCBhPXBpY29tYXRjaC50b1JlZ2V4KGksdCk7aWYobj09PXRydWUpe2Euc3RhdGU9ZX1yZXR1cm4gYX07cGljb21hdGNoLm1ha2VSZT0oZSx0LHI9ZmFsc2Usbj1mYWxzZSk9PntpZighZXx8dHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBub24tZW1wdHkgc3RyaW5nXCIpfWNvbnN0IHU9dHx8e307bGV0IG89e25lZ2F0ZWQ6ZmFsc2UsZmFzdHBhdGhzOnRydWV9O2xldCBpPVwiXCI7bGV0IGE7aWYoZS5zdGFydHNXaXRoKFwiLi9cIikpe2U9ZS5zbGljZSgyKTtpPW8ucHJlZml4PVwiLi9cIn1pZih1LmZhc3RwYXRocyE9PWZhbHNlJiYoZVswXT09PVwiLlwifHxlWzBdPT09XCIqXCIpKXthPXMuZmFzdHBhdGhzKGUsdCl9aWYoYT09PXVuZGVmaW5lZCl7bz1zKGUsdCk7by5wcmVmaXg9aSsoby5wcmVmaXh8fFwiXCIpfWVsc2V7by5vdXRwdXQ9YX1yZXR1cm4gcGljb21hdGNoLmNvbXBpbGVSZShvLHQscixuKX07cGljb21hdGNoLnRvUmVnZXg9KGUsdCk9Pnt0cnl7Y29uc3Qgcj10fHx7fTtyZXR1cm4gbmV3IFJlZ0V4cChlLHIuZmxhZ3N8fChyLm5vY2FzZT9cImlcIjpcIlwiKSl9Y2F0Y2goZSl7aWYodCYmdC5kZWJ1Zz09PXRydWUpdGhyb3cgZTtyZXR1cm4vJF4vfX07cGljb21hdGNoLmNvbnN0YW50cz1pO2UuZXhwb3J0cz1waWNvbWF0Y2h9LDIxNjooZSx0LHIpPT57Y29uc3Qgbj1yKDI0Myk7Y29uc3R7Q0hBUl9BU1RFUklTSzp1LENIQVJfQVQ6cyxDSEFSX0JBQ0tXQVJEX1NMQVNIOm8sQ0hBUl9DT01NQTppLENIQVJfRE9UOmEsQ0hBUl9FWENMQU1BVElPTl9NQVJLOmwsQ0hBUl9GT1JXQVJEX1NMQVNIOmMsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOnAsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOmYsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOkEsQ0hBUl9QTFVTOlIsQ0hBUl9RVUVTVElPTl9NQVJLOl8sQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTpoLENIQVJfUklHSFRfUEFSRU5USEVTRVM6ZyxDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUOkV9PXIoODcxKTtjb25zdCBpc1BhdGhTZXBhcmF0b3I9ZT0+ZT09PWN8fGU9PT1vO2NvbnN0IGRlcHRoPWU9PntpZihlLmlzUHJlZml4IT09dHJ1ZSl7ZS5kZXB0aD1lLmlzR2xvYnN0YXI/SW5maW5pdHk6MX19O2NvbnN0IHNjYW49KGUsdCk9Pntjb25zdCByPXR8fHt9O2NvbnN0IEM9ZS5sZW5ndGgtMTtjb25zdCB5PXIucGFydHM9PT10cnVlfHxyLnNjYW5Ub0VuZD09PXRydWU7Y29uc3QgZD1bXTtjb25zdCB4PVtdO2NvbnN0IGI9W107bGV0IFM9ZTtsZXQgSD0tMTtsZXQgdj0wO2xldCAkPTA7bGV0IG09ZmFsc2U7bGV0IFQ9ZmFsc2U7bGV0IEw9ZmFsc2U7bGV0IE89ZmFsc2U7bGV0IHc9ZmFsc2U7bGV0IE49ZmFsc2U7bGV0IGs9ZmFsc2U7bGV0IEk9ZmFsc2U7bGV0IE09ZmFsc2U7bGV0IFA9MDtsZXQgQjtsZXQgRztsZXQgRD17dmFsdWU6XCJcIixkZXB0aDowLGlzR2xvYjpmYWxzZX07Y29uc3QgZW9zPSgpPT5IPj1DO2NvbnN0IHBlZWs9KCk9PlMuY2hhckNvZGVBdChIKzEpO2NvbnN0IGFkdmFuY2U9KCk9PntCPUc7cmV0dXJuIFMuY2hhckNvZGVBdCgrK0gpfTt3aGlsZShIPEMpe0c9YWR2YW5jZSgpO2xldCBlO2lmKEc9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTtHPWFkdmFuY2UoKTtpZihHPT09cCl7Tj10cnVlfWNvbnRpbnVlfWlmKE49PT10cnVlfHxHPT09cCl7UCsrO3doaWxlKGVvcygpIT09dHJ1ZSYmKEc9YWR2YW5jZSgpKSl7aWYoRz09PW8pe2s9RC5iYWNrc2xhc2hlcz10cnVlO2FkdmFuY2UoKTtjb250aW51ZX1pZihHPT09cCl7UCsrO2NvbnRpbnVlfWlmKE4hPT10cnVlJiZHPT09YSYmKEc9YWR2YW5jZSgpKT09PWEpe209RC5pc0JyYWNlPXRydWU7TD1ELmlzR2xvYj10cnVlO009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoTiE9PXRydWUmJkc9PT1pKXttPUQuaXNCcmFjZT10cnVlO0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1oKXtQLS07aWYoUD09PTApe049ZmFsc2U7bT1ELmlzQnJhY2U9dHJ1ZTtNPXRydWU7YnJlYWt9fX1pZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoRz09PWMpe2QucHVzaChIKTt4LnB1c2goRCk7RD17dmFsdWU6XCJcIixkZXB0aDowLGlzR2xvYjpmYWxzZX07aWYoTT09PXRydWUpY29udGludWU7aWYoQj09PWEmJkg9PT12KzEpe3YrPTI7Y29udGludWV9JD1IKzE7Y29udGludWV9aWYoci5ub2V4dCE9PXRydWUpe2NvbnN0IGU9Rz09PVJ8fEc9PT1zfHxHPT09dXx8Rz09PV98fEc9PT1sO2lmKGU9PT10cnVlJiZwZWVrKCk9PT1mKXtMPUQuaXNHbG9iPXRydWU7Tz1ELmlzRXh0Z2xvYj10cnVlO009dHJ1ZTtpZih5PT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoRz1hZHZhbmNlKCkpKXtpZihHPT09byl7az1ELmJhY2tzbGFzaGVzPXRydWU7Rz1hZHZhbmNlKCk7Y29udGludWV9aWYoRz09PWcpe0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7YnJlYWt9fWNvbnRpbnVlfWJyZWFrfX1pZihHPT09dSl7aWYoQj09PXUpdz1ELmlzR2xvYnN0YXI9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2lmKHk9PT10cnVlKXtjb250aW51ZX1icmVha31pZihHPT09Xyl7TD1ELmlzR2xvYj10cnVlO009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoRz09PUEpe3doaWxlKGVvcygpIT09dHJ1ZSYmKGU9YWR2YW5jZSgpKSl7aWYoZT09PW8pe2s9RC5iYWNrc2xhc2hlcz10cnVlO2FkdmFuY2UoKTtjb250aW51ZX1pZihlPT09RSl7VD1ELmlzQnJhY2tldD10cnVlO0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7YnJlYWt9fWlmKHk9PT10cnVlKXtjb250aW51ZX1icmVha31pZihyLm5vbmVnYXRlIT09dHJ1ZSYmRz09PWwmJkg9PT12KXtJPUQubmVnYXRlZD10cnVlO3YrKztjb250aW51ZX1pZihyLm5vcGFyZW4hPT10cnVlJiZHPT09Zil7TD1ELmlzR2xvYj10cnVlO2lmKHk9PT10cnVlKXt3aGlsZShlb3MoKSE9PXRydWUmJihHPWFkdmFuY2UoKSkpe2lmKEc9PT1mKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTtHPWFkdmFuY2UoKTtjb250aW51ZX1pZihHPT09Zyl7TT10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha31pZihMPT09dHJ1ZSl7TT10cnVlO2lmKHk9PT10cnVlKXtjb250aW51ZX1icmVha319aWYoci5ub2V4dD09PXRydWUpe089ZmFsc2U7TD1mYWxzZX1sZXQgVT1TO2xldCBLPVwiXCI7bGV0IEY9XCJcIjtpZih2PjApe0s9Uy5zbGljZSgwLHYpO1M9Uy5zbGljZSh2KTskLT12fWlmKFUmJkw9PT10cnVlJiYkPjApe1U9Uy5zbGljZSgwLCQpO0Y9Uy5zbGljZSgkKX1lbHNlIGlmKEw9PT10cnVlKXtVPVwiXCI7Rj1TfWVsc2V7VT1TfWlmKFUmJlUhPT1cIlwiJiZVIT09XCIvXCImJlUhPT1TKXtpZihpc1BhdGhTZXBhcmF0b3IoVS5jaGFyQ29kZUF0KFUubGVuZ3RoLTEpKSl7VT1VLnNsaWNlKDAsLTEpfX1pZihyLnVuZXNjYXBlPT09dHJ1ZSl7aWYoRilGPW4ucmVtb3ZlQmFja3NsYXNoZXMoRik7aWYoVSYmaz09PXRydWUpe1U9bi5yZW1vdmVCYWNrc2xhc2hlcyhVKX19Y29uc3QgUT17cHJlZml4OkssaW5wdXQ6ZSxzdGFydDp2LGJhc2U6VSxnbG9iOkYsaXNCcmFjZTptLGlzQnJhY2tldDpULGlzR2xvYjpMLGlzRXh0Z2xvYjpPLGlzR2xvYnN0YXI6dyxuZWdhdGVkOkl9O2lmKHIudG9rZW5zPT09dHJ1ZSl7US5tYXhEZXB0aD0wO2lmKCFpc1BhdGhTZXBhcmF0b3IoRykpe3gucHVzaChEKX1RLnRva2Vucz14fWlmKHIucGFydHM9PT10cnVlfHxyLnRva2Vucz09PXRydWUpe2xldCB0O2ZvcihsZXQgbj0wO248ZC5sZW5ndGg7bisrKXtjb25zdCB1PXQ/dCsxOnY7Y29uc3Qgcz1kW25dO2NvbnN0IG89ZS5zbGljZSh1LHMpO2lmKHIudG9rZW5zKXtpZihuPT09MCYmdiE9PTApe3hbbl0uaXNQcmVmaXg9dHJ1ZTt4W25dLnZhbHVlPUt9ZWxzZXt4W25dLnZhbHVlPW99ZGVwdGgoeFtuXSk7US5tYXhEZXB0aCs9eFtuXS5kZXB0aH1pZihuIT09MHx8byE9PVwiXCIpe2IucHVzaChvKX10PXN9aWYodCYmdCsxPGUubGVuZ3RoKXtjb25zdCBuPWUuc2xpY2UodCsxKTtiLnB1c2gobik7aWYoci50b2tlbnMpe3hbeC5sZW5ndGgtMV0udmFsdWU9bjtkZXB0aCh4W3gubGVuZ3RoLTFdKTtRLm1heERlcHRoKz14W3gubGVuZ3RoLTFdLmRlcHRofX1RLnNsYXNoZXM9ZDtRLnBhcnRzPWJ9cmV0dXJuIFF9O2UuZXhwb3J0cz1zY2FufSwyNDM6KGUsdCxyKT0+e2NvbnN0IG49cigxNyk7Y29uc3QgdT1wcm9jZXNzLnBsYXRmb3JtPT09XCJ3aW4zMlwiO2NvbnN0e1JFR0VYX0JBQ0tTTEFTSDpzLFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6byxSRUdFWF9TUEVDSUFMX0NIQVJTOmksUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUw6YX09cig4NzEpO3QuaXNPYmplY3Q9ZT0+ZSE9PW51bGwmJnR5cGVvZiBlPT09XCJvYmplY3RcIiYmIUFycmF5LmlzQXJyYXkoZSk7dC5oYXNSZWdleENoYXJzPWU9PmkudGVzdChlKTt0LmlzUmVnZXhDaGFyPWU9PmUubGVuZ3RoPT09MSYmdC5oYXNSZWdleENoYXJzKGUpO3QuZXNjYXBlUmVnZXg9ZT0+ZS5yZXBsYWNlKGEsXCJcXFxcJDFcIik7dC50b1Bvc2l4U2xhc2hlcz1lPT5lLnJlcGxhY2UocyxcIi9cIik7dC5yZW1vdmVCYWNrc2xhc2hlcz1lPT5lLnJlcGxhY2UobywoZT0+ZT09PVwiXFxcXFwiP1wiXCI6ZSkpO3Quc3VwcG9ydHNMb29rYmVoaW5kcz0oKT0+e2NvbnN0IGU9cHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDEpLnNwbGl0KFwiLlwiKS5tYXAoTnVtYmVyKTtpZihlLmxlbmd0aD09PTMmJmVbMF0+PTl8fGVbMF09PT04JiZlWzFdPj0xMCl7cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlfTt0LmlzV2luZG93cz1lPT57aWYoZSYmdHlwZW9mIGUud2luZG93cz09PVwiYm9vbGVhblwiKXtyZXR1cm4gZS53aW5kb3dzfXJldHVybiB1PT09dHJ1ZXx8bi5zZXA9PT1cIlxcXFxcIn07dC5lc2NhcGVMYXN0PShlLHIsbik9Pntjb25zdCB1PWUubGFzdEluZGV4T2YocixuKTtpZih1PT09LTEpcmV0dXJuIGU7aWYoZVt1LTFdPT09XCJcXFxcXCIpcmV0dXJuIHQuZXNjYXBlTGFzdChlLHIsdS0xKTtyZXR1cm5gJHtlLnNsaWNlKDAsdSl9XFxcXCR7ZS5zbGljZSh1KX1gfTt0LnJlbW92ZVByZWZpeD0oZSx0PXt9KT0+e2xldCByPWU7aWYoci5zdGFydHNXaXRoKFwiLi9cIikpe3I9ci5zbGljZSgyKTt0LnByZWZpeD1cIi4vXCJ9cmV0dXJuIHJ9O3Qud3JhcE91dHB1dD0oZSx0PXt9LHI9e30pPT57Y29uc3Qgbj1yLmNvbnRhaW5zP1wiXCI6XCJeXCI7Y29uc3QgdT1yLmNvbnRhaW5zP1wiXCI6XCIkXCI7bGV0IHM9YCR7bn0oPzoke2V9KSR7dX1gO2lmKHQubmVnYXRlZD09PXRydWUpe3M9YCg/Ol4oPyEke3N9KS4qJClgfXJldHVybiBzfX0sMzY4OihlLHQscik9PntcclxuLyohXHJcbiAqIHRvLXJlZ2V4LXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vbWljcm9tYXRjaC90by1yZWdleC1yYW5nZT5cclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEpvbiBTY2hsaW5rZXJ0LlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBuPXIoNzczKTtjb25zdCB0b1JlZ2V4UmFuZ2U9KGUsdCxyKT0+e2lmKG4oZSk9PT1mYWxzZSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcInRvUmVnZXhSYW5nZTogZXhwZWN0ZWQgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGEgbnVtYmVyXCIpfWlmKHQ9PT12b2lkIDB8fGU9PT10KXtyZXR1cm4gU3RyaW5nKGUpfWlmKG4odCk9PT1mYWxzZSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcInRvUmVnZXhSYW5nZTogZXhwZWN0ZWQgdGhlIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIG51bWJlci5cIil9bGV0IHU9e3JlbGF4WmVyb3M6dHJ1ZSwuLi5yfTtpZih0eXBlb2YgdS5zdHJpY3RaZXJvcz09PVwiYm9vbGVhblwiKXt1LnJlbGF4WmVyb3M9dS5zdHJpY3RaZXJvcz09PWZhbHNlfWxldCBzPVN0cmluZyh1LnJlbGF4WmVyb3MpO2xldCBvPVN0cmluZyh1LnNob3J0aGFuZCk7bGV0IGk9U3RyaW5nKHUuY2FwdHVyZSk7bGV0IGE9U3RyaW5nKHUud3JhcCk7bGV0IGw9ZStcIjpcIit0K1wiPVwiK3MrbytpK2E7aWYodG9SZWdleFJhbmdlLmNhY2hlLmhhc093blByb3BlcnR5KGwpKXtyZXR1cm4gdG9SZWdleFJhbmdlLmNhY2hlW2xdLnJlc3VsdH1sZXQgYz1NYXRoLm1pbihlLHQpO2xldCBwPU1hdGgubWF4KGUsdCk7aWYoTWF0aC5hYnMoYy1wKT09PTEpe2xldCByPWUrXCJ8XCIrdDtpZih1LmNhcHR1cmUpe3JldHVybmAoJHtyfSlgfWlmKHUud3JhcD09PWZhbHNlKXtyZXR1cm4gcn1yZXR1cm5gKD86JHtyfSlgfWxldCBmPWhhc1BhZGRpbmcoZSl8fGhhc1BhZGRpbmcodCk7bGV0IEE9e21pbjplLG1heDp0LGE6YyxiOnB9O2xldCBSPVtdO2xldCBfPVtdO2lmKGYpe0EuaXNQYWRkZWQ9ZjtBLm1heExlbj1TdHJpbmcoQS5tYXgpLmxlbmd0aH1pZihjPDApe2xldCBlPXA8MD9NYXRoLmFicyhwKToxO189c3BsaXRUb1BhdHRlcm5zKGUsTWF0aC5hYnMoYyksQSx1KTtjPUEuYT0wfWlmKHA+PTApe1I9c3BsaXRUb1BhdHRlcm5zKGMscCxBLHUpfUEubmVnYXRpdmVzPV87QS5wb3NpdGl2ZXM9UjtBLnJlc3VsdD1jb2xsYXRlUGF0dGVybnMoXyxSLHUpO2lmKHUuY2FwdHVyZT09PXRydWUpe0EucmVzdWx0PWAoJHtBLnJlc3VsdH0pYH1lbHNlIGlmKHUud3JhcCE9PWZhbHNlJiZSLmxlbmd0aCtfLmxlbmd0aD4xKXtBLnJlc3VsdD1gKD86JHtBLnJlc3VsdH0pYH10b1JlZ2V4UmFuZ2UuY2FjaGVbbF09QTtyZXR1cm4gQS5yZXN1bHR9O2Z1bmN0aW9uIGNvbGxhdGVQYXR0ZXJucyhlLHQscil7bGV0IG49ZmlsdGVyUGF0dGVybnMoZSx0LFwiLVwiLGZhbHNlLHIpfHxbXTtsZXQgdT1maWx0ZXJQYXR0ZXJucyh0LGUsXCJcIixmYWxzZSxyKXx8W107bGV0IHM9ZmlsdGVyUGF0dGVybnMoZSx0LFwiLT9cIix0cnVlLHIpfHxbXTtsZXQgbz1uLmNvbmNhdChzKS5jb25jYXQodSk7cmV0dXJuIG8uam9pbihcInxcIil9ZnVuY3Rpb24gc3BsaXRUb1JhbmdlcyhlLHQpe2xldCByPTE7bGV0IG49MTtsZXQgdT1jb3VudE5pbmVzKGUscik7bGV0IHM9bmV3IFNldChbdF0pO3doaWxlKGU8PXUmJnU8PXQpe3MuYWRkKHUpO3IrPTE7dT1jb3VudE5pbmVzKGUscil9dT1jb3VudFplcm9zKHQrMSxuKS0xO3doaWxlKGU8dSYmdTw9dCl7cy5hZGQodSk7bis9MTt1PWNvdW50WmVyb3ModCsxLG4pLTF9cz1bLi4uc107cy5zb3J0KGNvbXBhcmUpO3JldHVybiBzfWZ1bmN0aW9uIHJhbmdlVG9QYXR0ZXJuKGUsdCxyKXtpZihlPT09dCl7cmV0dXJue3BhdHRlcm46ZSxjb3VudDpbXSxkaWdpdHM6MH19bGV0IG49emlwKGUsdCk7bGV0IHU9bi5sZW5ndGg7bGV0IHM9XCJcIjtsZXQgbz0wO2ZvcihsZXQgZT0wO2U8dTtlKyspe2xldFt0LHVdPW5bZV07aWYodD09PXUpe3MrPXR9ZWxzZSBpZih0IT09XCIwXCJ8fHUhPT1cIjlcIil7cys9dG9DaGFyYWN0ZXJDbGFzcyh0LHUscil9ZWxzZXtvKyt9fWlmKG8pe3MrPXIuc2hvcnRoYW5kPT09dHJ1ZT9cIlxcXFxkXCI6XCJbMC05XVwifXJldHVybntwYXR0ZXJuOnMsY291bnQ6W29dLGRpZ2l0czp1fX1mdW5jdGlvbiBzcGxpdFRvUGF0dGVybnMoZSx0LHIsbil7bGV0IHU9c3BsaXRUb1JhbmdlcyhlLHQpO2xldCBzPVtdO2xldCBvPWU7bGV0IGk7Zm9yKGxldCBlPTA7ZTx1Lmxlbmd0aDtlKyspe2xldCB0PXVbZV07bGV0IGE9cmFuZ2VUb1BhdHRlcm4oU3RyaW5nKG8pLFN0cmluZyh0KSxuKTtsZXQgbD1cIlwiO2lmKCFyLmlzUGFkZGVkJiZpJiZpLnBhdHRlcm49PT1hLnBhdHRlcm4pe2lmKGkuY291bnQubGVuZ3RoPjEpe2kuY291bnQucG9wKCl9aS5jb3VudC5wdXNoKGEuY291bnRbMF0pO2kuc3RyaW5nPWkucGF0dGVybit0b1F1YW50aWZpZXIoaS5jb3VudCk7bz10KzE7Y29udGludWV9aWYoci5pc1BhZGRlZCl7bD1wYWRaZXJvcyh0LHIsbil9YS5zdHJpbmc9bCthLnBhdHRlcm4rdG9RdWFudGlmaWVyKGEuY291bnQpO3MucHVzaChhKTtvPXQrMTtpPWF9cmV0dXJuIHN9ZnVuY3Rpb24gZmlsdGVyUGF0dGVybnMoZSx0LHIsbix1KXtsZXQgcz1bXTtmb3IobGV0IHUgb2YgZSl7bGV0e3N0cmluZzplfT11O2lmKCFuJiYhY29udGFpbnModCxcInN0cmluZ1wiLGUpKXtzLnB1c2gocitlKX1pZihuJiZjb250YWlucyh0LFwic3RyaW5nXCIsZSkpe3MucHVzaChyK2UpfX1yZXR1cm4gc31mdW5jdGlvbiB6aXAoZSx0KXtsZXQgcj1bXTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKylyLnB1c2goW2Vbbl0sdFtuXV0pO3JldHVybiByfWZ1bmN0aW9uIGNvbXBhcmUoZSx0KXtyZXR1cm4gZT50PzE6dD5lPy0xOjB9ZnVuY3Rpb24gY29udGFpbnMoZSx0LHIpe3JldHVybiBlLnNvbWUoKGU9PmVbdF09PT1yKSl9ZnVuY3Rpb24gY291bnROaW5lcyhlLHQpe3JldHVybiBOdW1iZXIoU3RyaW5nKGUpLnNsaWNlKDAsLXQpK1wiOVwiLnJlcGVhdCh0KSl9ZnVuY3Rpb24gY291bnRaZXJvcyhlLHQpe3JldHVybiBlLWUlTWF0aC5wb3coMTAsdCl9ZnVuY3Rpb24gdG9RdWFudGlmaWVyKGUpe2xldFt0PTAscj1cIlwiXT1lO2lmKHJ8fHQ+MSl7cmV0dXJuYHske3QrKHI/XCIsXCIrcjpcIlwiKX19YH1yZXR1cm5cIlwifWZ1bmN0aW9uIHRvQ2hhcmFjdGVyQ2xhc3MoZSx0LHIpe3JldHVybmBbJHtlfSR7dC1lPT09MT9cIlwiOlwiLVwifSR7dH1dYH1mdW5jdGlvbiBoYXNQYWRkaW5nKGUpe3JldHVybi9eLT8oMCspXFxkLy50ZXN0KGUpfWZ1bmN0aW9uIHBhZFplcm9zKGUsdCxyKXtpZighdC5pc1BhZGRlZCl7cmV0dXJuIGV9bGV0IG49TWF0aC5hYnModC5tYXhMZW4tU3RyaW5nKGUpLmxlbmd0aCk7bGV0IHU9ci5yZWxheFplcm9zIT09ZmFsc2U7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm5cIlwiO2Nhc2UgMTpyZXR1cm4gdT9cIjA/XCI6XCIwXCI7Y2FzZSAyOnJldHVybiB1P1wiMHswLDJ9XCI6XCIwMFwiO2RlZmF1bHQ6e3JldHVybiB1P2AwezAsJHtufX1gOmAweyR7bn19YH19fXRvUmVnZXhSYW5nZS5jYWNoZT17fTt0b1JlZ2V4UmFuZ2UuY2xlYXJDYWNoZT0oKT0+dG9SZWdleFJhbmdlLmNhY2hlPXt9O2UuZXhwb3J0cz10b1JlZ2V4UmFuZ2V9LDE3OmU9PntlLmV4cG9ydHM9cmVxdWlyZShcInBhdGhcIil9LDgzNzplPT57ZS5leHBvcnRzPXJlcXVpcmUoXCJ1dGlsXCIpfX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIHU9dFtyXT17ZXhwb3J0czp7fX07dmFyIHM9dHJ1ZTt0cnl7ZVtyXSh1LHUuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtzPWZhbHNlfWZpbmFsbHl7aWYocylkZWxldGUgdFtyXX1yZXR1cm4gdS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj1fX25jY3dwY2tfcmVxdWlyZV9fKDg4OCk7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbImUiLCJ0IiwiciIsIm4iLCJ1IiwicyIsIm8iLCJicmFjZXMiLCJBcnJheSIsImlzQXJyYXkiLCJjcmVhdGUiLCJwdXNoIiwiY29uY2F0IiwiZXhwYW5kIiwibm9kdXBlcyIsIlNldCIsInBhcnNlIiwic3RyaW5naWZ5IiwiY29tcGlsZSIsIm5vZW1wdHkiLCJmaWx0ZXIiLCJCb29sZWFuIiwibGVuZ3RoIiwiZXhwb3J0cyIsIndhbGsiLCJpc0ludmFsaWRCcmFjZSIsImludmFsaWQiLCJlc2NhcGVJbnZhbGlkIiwiaSIsImEiLCJsIiwiaXNPcGVuIiwidmFsdWUiLCJpc0Nsb3NlIiwidHlwZSIsInByZXYiLCJub2RlcyIsInJhbmdlcyIsInJlZHVjZSIsIndyYXAiLCJ0b1JlZ2V4IiwiTUFYX0xFTkdUSCIsIkNIQVJfMCIsIkNIQVJfOSIsIkNIQVJfVVBQRVJDQVNFX0EiLCJDSEFSX0xPV0VSQ0FTRV9BIiwiQ0hBUl9VUFBFUkNBU0VfWiIsIkNIQVJfTE9XRVJDQVNFX1oiLCJDSEFSX0xFRlRfUEFSRU5USEVTRVMiLCJDSEFSX1JJR0hUX1BBUkVOVEhFU0VTIiwiQ0hBUl9BU1RFUklTSyIsIkNIQVJfQU1QRVJTQU5EIiwiQ0hBUl9BVCIsIkNIQVJfQkFDS1NMQVNIIiwiQ0hBUl9CQUNLVElDSyIsIkNIQVJfQ0FSUklBR0VfUkVUVVJOIiwiQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVCIsIkNIQVJfQ09MT04iLCJDSEFSX0NPTU1BIiwiQ0hBUl9ET0xMQVIiLCJDSEFSX0RPVCIsIkNIQVJfRE9VQkxFX1FVT1RFIiwiQ0hBUl9FUVVBTCIsIkNIQVJfRVhDTEFNQVRJT05fTUFSSyIsIkNIQVJfRk9STV9GRUVEIiwiQ0hBUl9GT1JXQVJEX1NMQVNIIiwiQ0hBUl9IQVNIIiwiQ0hBUl9IWVBIRU5fTUlOVVMiLCJDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVCIsIkNIQVJfTEVGVF9DVVJMWV9CUkFDRSIsIkNIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCIsIkNIQVJfTElORV9GRUVEIiwiQ0hBUl9OT19CUkVBS19TUEFDRSIsIkNIQVJfUEVSQ0VOVCIsIkNIQVJfUExVUyIsIkNIQVJfUVVFU1RJT05fTUFSSyIsIkNIQVJfUklHSFRfQU5HTEVfQlJBQ0tFVCIsIkNIQVJfUklHSFRfQ1VSTFlfQlJBQ0UiLCJDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUIiwiQ0hBUl9TRU1JQ09MT04iLCJDSEFSX1NJTkdMRV9RVU9URSIsIkNIQVJfU1BBQ0UiLCJDSEFSX1RBQiIsIkNIQVJfVU5ERVJTQ09SRSIsIkNIQVJfVkVSVElDQUxfTElORSIsIkNIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFIiwiYXBwZW5kIiwiZmxhdHRlbiIsIm1hcCIsInJhbmdlTGltaXQiLCJxdWV1ZSIsInBhcmVudCIsImRvbGxhciIsInBvcCIsImV4Y2VlZHNMaW1pdCIsInN0ZXAiLCJSYW5nZUVycm9yIiwiZW5jbG9zZUJyYWNlIiwiYyIsInAiLCJmIiwiQSIsIlIiLCJfIiwiaCIsImciLCJFIiwiVHlwZUVycm9yIiwiQyIsIm1heExlbmd0aCIsIk1hdGgiLCJtaW4iLCJTeW50YXhFcnJvciIsInkiLCJpbnB1dCIsImQiLCJ4IiwiYiIsIlMiLCJIIiwidiIsIiQiLCJtIiwiVCIsImFkdmFuY2UiLCJrZWVwRXNjYXBpbmciLCJrZWVwUXVvdGVzIiwic2xpY2UiLCJvcGVuIiwiY2xvc2UiLCJkZXB0aCIsImNvbW1hcyIsInNoaWZ0IiwicmFuZ2UiLCJhcmdzIiwiZm9yRWFjaCIsImluZGV4T2YiLCJzcGxpY2UiLCJpc09wZW5PckNsb3NlIiwiaXNJbnRlZ2VyIiwiTnVtYmVyIiwidHJpbSIsImZpbmQiLCJlc2NhcGVOb2RlIiwiZXNjYXBlZCIsImZsYXQiLCJpc09iamVjdCIsInRyYW5zZm9ybSIsIlN0cmluZyIsImlzVmFsaWRWYWx1ZSIsImlzTnVtYmVyIiwiemVyb3MiLCJwYWQiLCJwYWRTdGFydCIsInRvTWF4TGVuIiwidG9TZXF1ZW5jZSIsIm5lZ2F0aXZlcyIsInNvcnQiLCJwb3NpdGl2ZXMiLCJjYXB0dXJlIiwiam9pbiIsInRvUmFuZ2UiLCJmcm9tQ2hhckNvZGUiLCJyYW5nZUVycm9yIiwiaW5zcGVjdCIsImludmFsaWRSYW5nZSIsInN0cmljdFJhbmdlcyIsImludmFsaWRTdGVwIiwiZmlsbE51bWJlcnMiLCJtYXgiLCJhYnMiLCJmaWxsTGV0dGVycyIsImNoYXJDb2RlQXQiLCJvcHRpb25zIiwiZmlsbCIsImlzRmluaXRlIiwiaXNFbXB0eVN0cmluZyIsIm1pY3JvbWF0Y2giLCJvblJlc3VsdCIsImFkZCIsIm91dHB1dCIsInN0YXRlIiwibmVnYXRlZCIsIm5lZ2F0ZWRFeHRnbG9iIiwiaXNNYXRjaCIsImRlbGV0ZSIsImhhcyIsImZhaWxnbG9iIiwiRXJyb3IiLCJub251bGwiLCJudWxsZ2xvYiIsInVuZXNjYXBlIiwicmVwbGFjZSIsIm1hdGNoIiwibWF0Y2hlciIsImFueSIsIm5vdCIsImluY2x1ZGVzIiwiY29udGFpbnMiLCJzb21lIiwic3RhcnRzV2l0aCIsIm1hdGNoS2V5cyIsIk9iamVjdCIsImtleXMiLCJldmVyeSIsImFsbCIsImlzV2luZG93cyIsIm1ha2VSZSIsImV4ZWMiLCJ0b1Bvc2l4U2xhc2hlcyIsInNjYW4iLCJub2JyYWNlIiwidGVzdCIsImJyYWNlRXhwYW5kIiwiRE9UX0xJVEVSQUwiLCJQTFVTX0xJVEVSQUwiLCJRTUFSS19MSVRFUkFMIiwiU0xBU0hfTElURVJBTCIsIk9ORV9DSEFSIiwiUU1BUksiLCJFTkRfQU5DSE9SIiwiRE9UU19TTEFTSCIsIk5PX0RPVCIsIk5PX0RPVFMiLCJOT19ET1RfU0xBU0giLCJOT19ET1RTX1NMQVNIIiwiUU1BUktfTk9fRE9UIiwiU1RBUiIsIlNUQVJUX0FOQ0hPUiIsImFsbnVtIiwiYWxwaGEiLCJhc2NpaSIsImJsYW5rIiwiY250cmwiLCJkaWdpdCIsImdyYXBoIiwibG93ZXIiLCJwcmludCIsInB1bmN0Iiwic3BhY2UiLCJ1cHBlciIsIndvcmQiLCJ4ZGlnaXQiLCJQT1NJWF9SRUdFWF9TT1VSQ0UiLCJSRUdFWF9CQUNLU0xBU0giLCJSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUyIsIlJFR0VYX1NQRUNJQUxfQ0hBUlMiLCJSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUYiLCJSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTCIsIlJFR0VYX1JFTU9WRV9CQUNLU0xBU0giLCJSRVBMQUNFTUVOVFMiLCJDSEFSX0JBQ0tXQVJEX1NMQVNIIiwiQ0hBUl9HUkFWRV9BQ0NFTlQiLCJTRVAiLCJzZXAiLCJleHRnbG9iQ2hhcnMiLCJnbG9iQ2hhcnMiLCJleHBhbmRSYW5nZSIsIlJlZ0V4cCIsImVzY2FwZVJlZ2V4Iiwic3ludGF4RXJyb3IiLCJwcmVwZW5kIiwiZ2xvYnN0YXIiLCJkb3QiLCJMIiwiTyIsInciLCJiYXNoIiwibm9leHQiLCJub2V4dGdsb2IiLCJOIiwiaW5kZXgiLCJzdGFydCIsImNvbnN1bWVkIiwicHJlZml4IiwiYmFja3RyYWNrIiwiYnJhY2tldHMiLCJwYXJlbnMiLCJxdW90ZXMiLCJ0b2tlbnMiLCJyZW1vdmVQcmVmaXgiLCJrIiwiSSIsIk0iLCJQIiwiQiIsImVvcyIsIkciLCJwZWVrIiwiRCIsInJlbWFpbmluZyIsImNvbnN1bWUiLCJuZWdhdGUiLCJpbmNyZW1lbnQiLCJkZWNyZW1lbnQiLCJleHRnbG9iIiwiaW5uZXIiLCJleHRnbG9iT3BlbiIsImNvbmRpdGlvbnMiLCJleHRnbG9iQ2xvc2UiLCJmYXN0cGF0aHMiLCJyZXBlYXQiLCJ3cmFwT3V0cHV0IiwicG9zaXgiLCJsYXN0SW5kZXhPZiIsInN0cmljdEJyYWNrZXRzIiwibm9icmFja2V0IiwibGl0ZXJhbEJyYWNrZXRzIiwiaGFzUmVnZXhDaGFycyIsIm91dHB1dEluZGV4IiwidG9rZW5zSW5kZXgiLCJkb3RzIiwidW5zaGlmdCIsImNvbW1hIiwic3VwcG9ydHNMb29rYmVoaW5kcyIsIm5vbmVnYXRlIiwicmVnZXgiLCJzdGFyIiwibm9nbG9ic3RhciIsInN0cmljdFNsYXNoZXMiLCJlc2NhcGVMYXN0Iiwic3VmZml4IiwicGljb21hdGNoIiwiYXJyYXlNYXRjaGVyIiwiY29tcGlsZVJlIiwiaXNJZ25vcmVkIiwiaWdub3JlIiwib25NYXRjaCIsImdsb2IiLCJvbklnbm9yZSIsImZvcm1hdCIsIm1hdGNoQmFzZSIsImJhc2VuYW1lIiwidW5kZWZpbmVkIiwiZmxhZ3MiLCJub2Nhc2UiLCJkZWJ1ZyIsImNvbnN0YW50cyIsImlzUGF0aFNlcGFyYXRvciIsImlzUHJlZml4IiwiaXNHbG9ic3RhciIsIkluZmluaXR5IiwicGFydHMiLCJzY2FuVG9FbmQiLCJpc0dsb2IiLCJiYWNrc2xhc2hlcyIsImlzQnJhY2UiLCJpc0V4dGdsb2IiLCJpc0JyYWNrZXQiLCJub3BhcmVuIiwiVSIsIksiLCJGIiwicmVtb3ZlQmFja3NsYXNoZXMiLCJRIiwiYmFzZSIsIm1heERlcHRoIiwic2xhc2hlcyIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsImlzUmVnZXhDaGFyIiwidmVyc2lvbiIsInNwbGl0Iiwid2luZG93cyIsInRvUmVnZXhSYW5nZSIsInJlbGF4WmVyb3MiLCJzdHJpY3RaZXJvcyIsInNob3J0aGFuZCIsImNhY2hlIiwiaGFzT3duUHJvcGVydHkiLCJyZXN1bHQiLCJoYXNQYWRkaW5nIiwiaXNQYWRkZWQiLCJtYXhMZW4iLCJzcGxpdFRvUGF0dGVybnMiLCJjb2xsYXRlUGF0dGVybnMiLCJmaWx0ZXJQYXR0ZXJucyIsInNwbGl0VG9SYW5nZXMiLCJjb3VudE5pbmVzIiwiY291bnRaZXJvcyIsImNvbXBhcmUiLCJyYW5nZVRvUGF0dGVybiIsInBhdHRlcm4iLCJjb3VudCIsImRpZ2l0cyIsInppcCIsInRvQ2hhcmFjdGVyQ2xhc3MiLCJzdHJpbmciLCJ0b1F1YW50aWZpZXIiLCJwYWRaZXJvcyIsInBvdyIsImNsZWFyQ2FjaGUiLCJyZXF1aXJlIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsImFiIiwiX19kaXJuYW1lIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/micromatch/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-browserify/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-browserify/index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function () {\n  \"use strict\";\n\n  var e = {\n    113: function (e) {\n      function assertPath(e) {\n        if (typeof e !== \"string\") {\n          throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(e));\n        }\n      }\n\n      function normalizeStringPosix(e, r) {\n        var t = \"\";\n        var i = 0;\n        var n = -1;\n        var a = 0;\n        var f;\n\n        for (var l = 0; l <= e.length; ++l) {\n          if (l < e.length) f = e.charCodeAt(l);else if (f === 47) break;else f = 47;\n\n          if (f === 47) {\n            if (n === l - 1 || a === 1) {} else if (n !== l - 1 && a === 2) {\n              if (t.length < 2 || i !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {\n                if (t.length > 2) {\n                  var s = t.lastIndexOf(\"/\");\n\n                  if (s !== t.length - 1) {\n                    if (s === -1) {\n                      t = \"\";\n                      i = 0;\n                    } else {\n                      t = t.slice(0, s);\n                      i = t.length - 1 - t.lastIndexOf(\"/\");\n                    }\n\n                    n = l;\n                    a = 0;\n                    continue;\n                  }\n                } else if (t.length === 2 || t.length === 1) {\n                  t = \"\";\n                  i = 0;\n                  n = l;\n                  a = 0;\n                  continue;\n                }\n              }\n\n              if (r) {\n                if (t.length > 0) t += \"/..\";else t = \"..\";\n                i = 2;\n              }\n            } else {\n              if (t.length > 0) t += \"/\" + e.slice(n + 1, l);else t = e.slice(n + 1, l);\n              i = l - n - 1;\n            }\n\n            n = l;\n            a = 0;\n          } else if (f === 46 && a !== -1) {\n            ++a;\n          } else {\n            a = -1;\n          }\n        }\n\n        return t;\n      }\n\n      function _format(e, r) {\n        var t = r.dir || r.root;\n        var i = r.base || (r.name || \"\") + (r.ext || \"\");\n\n        if (!t) {\n          return i;\n        }\n\n        if (t === r.root) {\n          return t + i;\n        }\n\n        return t + e + i;\n      }\n\n      var r = {\n        resolve: function resolve() {\n          var e = \"\";\n          var r = false;\n          var t;\n\n          for (var i = arguments.length - 1; i >= -1 && !r; i--) {\n            var n;\n            if (i >= 0) n = arguments[i];else {\n              if (t === undefined) t = \"\";\n              n = t;\n            }\n            assertPath(n);\n\n            if (n.length === 0) {\n              continue;\n            }\n\n            e = n + \"/\" + e;\n            r = n.charCodeAt(0) === 47;\n          }\n\n          e = normalizeStringPosix(e, !r);\n\n          if (r) {\n            if (e.length > 0) return \"/\" + e;else return \"/\";\n          } else if (e.length > 0) {\n            return e;\n          } else {\n            return \".\";\n          }\n        },\n        normalize: function normalize(e) {\n          assertPath(e);\n          if (e.length === 0) return \".\";\n          var r = e.charCodeAt(0) === 47;\n          var t = e.charCodeAt(e.length - 1) === 47;\n          e = normalizeStringPosix(e, !r);\n          if (e.length === 0 && !r) e = \".\";\n          if (e.length > 0 && t) e += \"/\";\n          if (r) return \"/\" + e;\n          return e;\n        },\n        isAbsolute: function isAbsolute(e) {\n          assertPath(e);\n          return e.length > 0 && e.charCodeAt(0) === 47;\n        },\n        join: function join() {\n          if (arguments.length === 0) return \".\";\n          var e;\n\n          for (var t = 0; t < arguments.length; ++t) {\n            var i = arguments[t];\n            assertPath(i);\n\n            if (i.length > 0) {\n              if (e === undefined) e = i;else e += \"/\" + i;\n            }\n          }\n\n          if (e === undefined) return \".\";\n          return r.normalize(e);\n        },\n        relative: function relative(e, t) {\n          assertPath(e);\n          assertPath(t);\n          if (e === t) return \"\";\n          e = r.resolve(e);\n          t = r.resolve(t);\n          if (e === t) return \"\";\n          var i = 1;\n\n          for (; i < e.length; ++i) {\n            if (e.charCodeAt(i) !== 47) break;\n          }\n\n          var n = e.length;\n          var a = n - i;\n          var f = 1;\n\n          for (; f < t.length; ++f) {\n            if (t.charCodeAt(f) !== 47) break;\n          }\n\n          var l = t.length;\n          var s = l - f;\n          var o = a < s ? a : s;\n          var u = -1;\n          var h = 0;\n\n          for (; h <= o; ++h) {\n            if (h === o) {\n              if (s > o) {\n                if (t.charCodeAt(f + h) === 47) {\n                  return t.slice(f + h + 1);\n                } else if (h === 0) {\n                  return t.slice(f + h);\n                }\n              } else if (a > o) {\n                if (e.charCodeAt(i + h) === 47) {\n                  u = h;\n                } else if (h === 0) {\n                  u = 0;\n                }\n              }\n\n              break;\n            }\n\n            var c = e.charCodeAt(i + h);\n            var v = t.charCodeAt(f + h);\n            if (c !== v) break;else if (c === 47) u = h;\n          }\n\n          var g = \"\";\n\n          for (h = i + u + 1; h <= n; ++h) {\n            if (h === n || e.charCodeAt(h) === 47) {\n              if (g.length === 0) g += \"..\";else g += \"/..\";\n            }\n          }\n\n          if (g.length > 0) return g + t.slice(f + u);else {\n            f += u;\n            if (t.charCodeAt(f) === 47) ++f;\n            return t.slice(f);\n          }\n        },\n        _makeLong: function _makeLong(e) {\n          return e;\n        },\n        dirname: function dirname(e) {\n          assertPath(e);\n          if (e.length === 0) return \".\";\n          var r = e.charCodeAt(0);\n          var t = r === 47;\n          var i = -1;\n          var n = true;\n\n          for (var a = e.length - 1; a >= 1; --a) {\n            r = e.charCodeAt(a);\n\n            if (r === 47) {\n              if (!n) {\n                i = a;\n                break;\n              }\n            } else {\n              n = false;\n            }\n          }\n\n          if (i === -1) return t ? \"/\" : \".\";\n          if (t && i === 1) return \"//\";\n          return e.slice(0, i);\n        },\n        basename: function basename(e, r) {\n          if (r !== undefined && typeof r !== \"string\") throw new TypeError('\"ext\" argument must be a string');\n          assertPath(e);\n          var t = 0;\n          var i = -1;\n          var n = true;\n          var a;\n\n          if (r !== undefined && r.length > 0 && r.length <= e.length) {\n            if (r.length === e.length && r === e) return \"\";\n            var f = r.length - 1;\n            var l = -1;\n\n            for (a = e.length - 1; a >= 0; --a) {\n              var s = e.charCodeAt(a);\n\n              if (s === 47) {\n                if (!n) {\n                  t = a + 1;\n                  break;\n                }\n              } else {\n                if (l === -1) {\n                  n = false;\n                  l = a + 1;\n                }\n\n                if (f >= 0) {\n                  if (s === r.charCodeAt(f)) {\n                    if (--f === -1) {\n                      i = a;\n                    }\n                  } else {\n                    f = -1;\n                    i = l;\n                  }\n                }\n              }\n            }\n\n            if (t === i) i = l;else if (i === -1) i = e.length;\n            return e.slice(t, i);\n          } else {\n            for (a = e.length - 1; a >= 0; --a) {\n              if (e.charCodeAt(a) === 47) {\n                if (!n) {\n                  t = a + 1;\n                  break;\n                }\n              } else if (i === -1) {\n                n = false;\n                i = a + 1;\n              }\n            }\n\n            if (i === -1) return \"\";\n            return e.slice(t, i);\n          }\n        },\n        extname: function extname(e) {\n          assertPath(e);\n          var r = -1;\n          var t = 0;\n          var i = -1;\n          var n = true;\n          var a = 0;\n\n          for (var f = e.length - 1; f >= 0; --f) {\n            var l = e.charCodeAt(f);\n\n            if (l === 47) {\n              if (!n) {\n                t = f + 1;\n                break;\n              }\n\n              continue;\n            }\n\n            if (i === -1) {\n              n = false;\n              i = f + 1;\n            }\n\n            if (l === 46) {\n              if (r === -1) r = f;else if (a !== 1) a = 1;\n            } else if (r !== -1) {\n              a = -1;\n            }\n          }\n\n          if (r === -1 || i === -1 || a === 0 || a === 1 && r === i - 1 && r === t + 1) {\n            return \"\";\n          }\n\n          return e.slice(r, i);\n        },\n        format: function format(e) {\n          if (e === null || typeof e !== \"object\") {\n            throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof e);\n          }\n\n          return _format(\"/\", e);\n        },\n        parse: function parse(e) {\n          assertPath(e);\n          var r = {\n            root: \"\",\n            dir: \"\",\n            base: \"\",\n            ext: \"\",\n            name: \"\"\n          };\n          if (e.length === 0) return r;\n          var t = e.charCodeAt(0);\n          var i = t === 47;\n          var n;\n\n          if (i) {\n            r.root = \"/\";\n            n = 1;\n          } else {\n            n = 0;\n          }\n\n          var a = -1;\n          var f = 0;\n          var l = -1;\n          var s = true;\n          var o = e.length - 1;\n          var u = 0;\n\n          for (; o >= n; --o) {\n            t = e.charCodeAt(o);\n\n            if (t === 47) {\n              if (!s) {\n                f = o + 1;\n                break;\n              }\n\n              continue;\n            }\n\n            if (l === -1) {\n              s = false;\n              l = o + 1;\n            }\n\n            if (t === 46) {\n              if (a === -1) a = o;else if (u !== 1) u = 1;\n            } else if (a !== -1) {\n              u = -1;\n            }\n          }\n\n          if (a === -1 || l === -1 || u === 0 || u === 1 && a === l - 1 && a === f + 1) {\n            if (l !== -1) {\n              if (f === 0 && i) r.base = r.name = e.slice(1, l);else r.base = r.name = e.slice(f, l);\n            }\n          } else {\n            if (f === 0 && i) {\n              r.name = e.slice(1, a);\n              r.base = e.slice(1, l);\n            } else {\n              r.name = e.slice(f, a);\n              r.base = e.slice(f, l);\n            }\n\n            r.ext = e.slice(a, l);\n          }\n\n          if (f > 0) r.dir = e.slice(0, f - 1);else if (i) r.dir = \"/\";\n          return r;\n        },\n        sep: \"/\",\n        delimiter: \":\",\n        win32: null,\n        posix: null\n      };\n      r.posix = r;\n      e.exports = r;\n    }\n  };\n  var r = {};\n\n  function __nccwpck_require__(t) {\n    var i = r[t];\n\n    if (i !== undefined) {\n      return i.exports;\n    }\n\n    var n = r[t] = {\n      exports: {}\n    };\n    var a = true;\n\n    try {\n      e[t](n, n.exports, __nccwpck_require__);\n      a = false;\n    } finally {\n      if (a) delete r[t];\n    }\n\n    return n.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var t = __nccwpck_require__(113);\n\n  module.exports = t;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsQ0FBQyxZQUFVO0VBQUM7O0VBQWEsSUFBSUEsQ0FBQyxHQUFDO0lBQUMsS0FBSSxVQUFTQSxDQUFULEVBQVc7TUFBQyxTQUFTQyxVQUFULENBQW9CRCxDQUFwQixFQUFzQjtRQUFDLElBQUcsT0FBT0EsQ0FBUCxLQUFXLFFBQWQsRUFBdUI7VUFBQyxNQUFNLElBQUlFLFNBQUosQ0FBYyxxQ0FBbUNDLElBQUksQ0FBQ0MsU0FBTCxDQUFlSixDQUFmLENBQWpELENBQU47UUFBMEU7TUFBQzs7TUFBQSxTQUFTSyxvQkFBVCxDQUE4QkwsQ0FBOUIsRUFBZ0NNLENBQWhDLEVBQWtDO1FBQUMsSUFBSUMsQ0FBQyxHQUFDLEVBQU47UUFBUyxJQUFJQyxDQUFDLEdBQUMsQ0FBTjtRQUFRLElBQUlDLENBQUMsR0FBQyxDQUFDLENBQVA7UUFBUyxJQUFJQyxDQUFDLEdBQUMsQ0FBTjtRQUFRLElBQUlDLENBQUo7O1FBQU0sS0FBSSxJQUFJQyxDQUFDLEdBQUMsQ0FBVixFQUFZQSxDQUFDLElBQUVaLENBQUMsQ0FBQ2EsTUFBakIsRUFBd0IsRUFBRUQsQ0FBMUIsRUFBNEI7VUFBQyxJQUFHQSxDQUFDLEdBQUNaLENBQUMsQ0FBQ2EsTUFBUCxFQUFjRixDQUFDLEdBQUNYLENBQUMsQ0FBQ2MsVUFBRixDQUFhRixDQUFiLENBQUYsQ0FBZCxLQUFxQyxJQUFHRCxDQUFDLEtBQUcsRUFBUCxFQUFVLE1BQVYsS0FBcUJBLENBQUMsR0FBQyxFQUFGOztVQUFLLElBQUdBLENBQUMsS0FBRyxFQUFQLEVBQVU7WUFBQyxJQUFHRixDQUFDLEtBQUdHLENBQUMsR0FBQyxDQUFOLElBQVNGLENBQUMsS0FBRyxDQUFoQixFQUFrQixDQUFFLENBQXBCLE1BQXlCLElBQUdELENBQUMsS0FBR0csQ0FBQyxHQUFDLENBQU4sSUFBU0YsQ0FBQyxLQUFHLENB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QUssRUFBQyxJQUFoNUg7UUFBcTVIQyxLQUFLLEVBQUM7TUFBMzVILENBQU47TUFBdTZIeEMsQ0FBQyxDQUFDd0MsS0FBRixHQUFReEMsQ0FBUjtNQUFVTixDQUFDLENBQUMrQyxPQUFGLEdBQVV6QyxDQUFWO0lBQVk7RUFBbjRKLENBQU47RUFBMjRKLElBQUlBLENBQUMsR0FBQyxFQUFOOztFQUFTLFNBQVMwQyxtQkFBVCxDQUE2QnpDLENBQTdCLEVBQStCO0lBQUMsSUFBSUMsQ0FBQyxHQUFDRixDQUFDLENBQUNDLENBQUQsQ0FBUDs7SUFBVyxJQUFHQyxDQUFDLEtBQUdrQixTQUFQLEVBQWlCO01BQUMsT0FBT2xCLENBQUMsQ0FBQ3VDLE9BQVQ7SUFBaUI7O0lBQUEsSUFBSXRDLENBQUMsR0FBQ0gsQ0FBQyxDQUFDQyxDQUFELENBQUQsR0FBSztNQUFDd0MsT0FBTyxFQUFDO0lBQVQsQ0FBWDtJQUF3QixJQUFJckMsQ0FBQyxHQUFDLElBQU47O0lBQVcsSUFBRztNQUFDVixDQUFDLENBQUNPLENBQUQsQ0FBRCxDQUFLRSxDQUFMLEVBQU9BLENBQUMsQ0FBQ3NDLE9BQVQsRUFBaUJDLG1CQUFqQjtNQUFzQ3RDLENBQUMsR0FBQyxLQUFGO0lBQVEsQ0FBbEQsU0FBeUQ7TUFBQyxJQUFHQSxDQUFILEVBQUssT0FBT0osQ0FBQyxDQUFDQyxDQUFELENBQVI7SUFBWTs7SUFBQSxPQUFPRSxDQUFDLENBQUNzQyxPQUFUO0VBQWlCOztFQUFBLElBQUcsT0FBT0MsbUJBQVAsS0FBNkIsV0FBaEMsRUFBNENBLG1CQUFtQixDQUFDQyxFQUFwQixHQUF1QkMsU0FBUyxHQUFDLEdBQWpDOztFQUFxQyxJQUFJM0MsQ0FBQyxHQUFDeUMsbUJBQW1CLENBQUMsR0FBRCxDQUF6Qjs7RUFBK0JHLE1BQU0sQ0FBQ0osT0FBUCxHQUFleEMsQ0FBZjtBQUFpQixDQUEzdksiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanM/M2NkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT17MTEzOmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGFzc2VydFBhdGgoZSl7aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShlKSl9fWZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KGUscil7dmFyIHQ9XCJcIjt2YXIgaT0wO3ZhciBuPS0xO3ZhciBhPTA7dmFyIGY7Zm9yKHZhciBsPTA7bDw9ZS5sZW5ndGg7KytsKXtpZihsPGUubGVuZ3RoKWY9ZS5jaGFyQ29kZUF0KGwpO2Vsc2UgaWYoZj09PTQ3KWJyZWFrO2Vsc2UgZj00NztpZihmPT09NDcpe2lmKG49PT1sLTF8fGE9PT0xKXt9ZWxzZSBpZihuIT09bC0xJiZhPT09Mil7aWYodC5sZW5ndGg8Mnx8aSE9PTJ8fHQuY2hhckNvZGVBdCh0Lmxlbmd0aC0xKSE9PTQ2fHx0LmNoYXJDb2RlQXQodC5sZW5ndGgtMikhPT00Nil7aWYodC5sZW5ndGg+Mil7dmFyIHM9dC5sYXN0SW5kZXhPZihcIi9cIik7aWYocyE9PXQubGVuZ3RoLTEpe2lmKHM9PT0tMSl7dD1cIlwiO2k9MH1lbHNle3Q9dC5zbGljZSgwLHMpO2k9dC5sZW5ndGgtMS10Lmxhc3RJbmRleE9mKFwiL1wiKX1uPWw7YT0wO2NvbnRpbnVlfX1lbHNlIGlmKHQubGVuZ3RoPT09Mnx8dC5sZW5ndGg9PT0xKXt0PVwiXCI7aT0wO249bDthPTA7Y29udGludWV9fWlmKHIpe2lmKHQubGVuZ3RoPjApdCs9XCIvLi5cIjtlbHNlIHQ9XCIuLlwiO2k9Mn19ZWxzZXtpZih0Lmxlbmd0aD4wKXQrPVwiL1wiK2Uuc2xpY2UobisxLGwpO2Vsc2UgdD1lLnNsaWNlKG4rMSxsKTtpPWwtbi0xfW49bDthPTB9ZWxzZSBpZihmPT09NDYmJmEhPT0tMSl7KythfWVsc2V7YT0tMX19cmV0dXJuIHR9ZnVuY3Rpb24gX2Zvcm1hdChlLHIpe3ZhciB0PXIuZGlyfHxyLnJvb3Q7dmFyIGk9ci5iYXNlfHwoci5uYW1lfHxcIlwiKSsoci5leHR8fFwiXCIpO2lmKCF0KXtyZXR1cm4gaX1pZih0PT09ci5yb290KXtyZXR1cm4gdCtpfXJldHVybiB0K2UraX12YXIgcj17cmVzb2x2ZTpmdW5jdGlvbiByZXNvbHZlKCl7dmFyIGU9XCJcIjt2YXIgcj1mYWxzZTt2YXIgdDtmb3IodmFyIGk9YXJndW1lbnRzLmxlbmd0aC0xO2k+PS0xJiYhcjtpLS0pe3ZhciBuO2lmKGk+PTApbj1hcmd1bWVudHNbaV07ZWxzZXtpZih0PT09dW5kZWZpbmVkKXQ9XCJcIjtuPXR9YXNzZXJ0UGF0aChuKTtpZihuLmxlbmd0aD09PTApe2NvbnRpbnVlfWU9bitcIi9cIitlO3I9bi5jaGFyQ29kZUF0KDApPT09NDd9ZT1ub3JtYWxpemVTdHJpbmdQb3NpeChlLCFyKTtpZihyKXtpZihlLmxlbmd0aD4wKXJldHVyblwiL1wiK2U7ZWxzZSByZXR1cm5cIi9cIn1lbHNlIGlmKGUubGVuZ3RoPjApe3JldHVybiBlfWVsc2V7cmV0dXJuXCIuXCJ9fSxub3JtYWxpemU6ZnVuY3Rpb24gbm9ybWFsaXplKGUpe2Fzc2VydFBhdGgoZSk7aWYoZS5sZW5ndGg9PT0wKXJldHVyblwiLlwiO3ZhciByPWUuY2hhckNvZGVBdCgwKT09PTQ3O3ZhciB0PWUuY2hhckNvZGVBdChlLmxlbmd0aC0xKT09PTQ3O2U9bm9ybWFsaXplU3RyaW5nUG9zaXgoZSwhcik7aWYoZS5sZW5ndGg9PT0wJiYhcillPVwiLlwiO2lmKGUubGVuZ3RoPjAmJnQpZSs9XCIvXCI7aWYocilyZXR1cm5cIi9cIitlO3JldHVybiBlfSxpc0Fic29sdXRlOmZ1bmN0aW9uIGlzQWJzb2x1dGUoZSl7YXNzZXJ0UGF0aChlKTtyZXR1cm4gZS5sZW5ndGg+MCYmZS5jaGFyQ29kZUF0KDApPT09NDd9LGpvaW46ZnVuY3Rpb24gam9pbigpe2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0wKXJldHVyblwiLlwiO3ZhciBlO2Zvcih2YXIgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDsrK3Qpe3ZhciBpPWFyZ3VtZW50c1t0XTthc3NlcnRQYXRoKGkpO2lmKGkubGVuZ3RoPjApe2lmKGU9PT11bmRlZmluZWQpZT1pO2Vsc2UgZSs9XCIvXCIraX19aWYoZT09PXVuZGVmaW5lZClyZXR1cm5cIi5cIjtyZXR1cm4gci5ub3JtYWxpemUoZSl9LHJlbGF0aXZlOmZ1bmN0aW9uIHJlbGF0aXZlKGUsdCl7YXNzZXJ0UGF0aChlKTthc3NlcnRQYXRoKHQpO2lmKGU9PT10KXJldHVyblwiXCI7ZT1yLnJlc29sdmUoZSk7dD1yLnJlc29sdmUodCk7aWYoZT09PXQpcmV0dXJuXCJcIjt2YXIgaT0xO2Zvcig7aTxlLmxlbmd0aDsrK2kpe2lmKGUuY2hhckNvZGVBdChpKSE9PTQ3KWJyZWFrfXZhciBuPWUubGVuZ3RoO3ZhciBhPW4taTt2YXIgZj0xO2Zvcig7Zjx0Lmxlbmd0aDsrK2Ype2lmKHQuY2hhckNvZGVBdChmKSE9PTQ3KWJyZWFrfXZhciBsPXQubGVuZ3RoO3ZhciBzPWwtZjt2YXIgbz1hPHM/YTpzO3ZhciB1PS0xO3ZhciBoPTA7Zm9yKDtoPD1vOysraCl7aWYoaD09PW8pe2lmKHM+byl7aWYodC5jaGFyQ29kZUF0KGYraCk9PT00Nyl7cmV0dXJuIHQuc2xpY2UoZitoKzEpfWVsc2UgaWYoaD09PTApe3JldHVybiB0LnNsaWNlKGYraCl9fWVsc2UgaWYoYT5vKXtpZihlLmNoYXJDb2RlQXQoaStoKT09PTQ3KXt1PWh9ZWxzZSBpZihoPT09MCl7dT0wfX1icmVha312YXIgYz1lLmNoYXJDb2RlQXQoaStoKTt2YXIgdj10LmNoYXJDb2RlQXQoZitoKTtpZihjIT09dilicmVhaztlbHNlIGlmKGM9PT00Nyl1PWh9dmFyIGc9XCJcIjtmb3IoaD1pK3UrMTtoPD1uOysraCl7aWYoaD09PW58fGUuY2hhckNvZGVBdChoKT09PTQ3KXtpZihnLmxlbmd0aD09PTApZys9XCIuLlwiO2Vsc2UgZys9XCIvLi5cIn19aWYoZy5sZW5ndGg+MClyZXR1cm4gZyt0LnNsaWNlKGYrdSk7ZWxzZXtmKz11O2lmKHQuY2hhckNvZGVBdChmKT09PTQ3KSsrZjtyZXR1cm4gdC5zbGljZShmKX19LF9tYWtlTG9uZzpmdW5jdGlvbiBfbWFrZUxvbmcoZSl7cmV0dXJuIGV9LGRpcm5hbWU6ZnVuY3Rpb24gZGlybmFtZShlKXthc3NlcnRQYXRoKGUpO2lmKGUubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgcj1lLmNoYXJDb2RlQXQoMCk7dmFyIHQ9cj09PTQ3O3ZhciBpPS0xO3ZhciBuPXRydWU7Zm9yKHZhciBhPWUubGVuZ3RoLTE7YT49MTstLWEpe3I9ZS5jaGFyQ29kZUF0KGEpO2lmKHI9PT00Nyl7aWYoIW4pe2k9YTticmVha319ZWxzZXtuPWZhbHNlfX1pZihpPT09LTEpcmV0dXJuIHQ/XCIvXCI6XCIuXCI7aWYodCYmaT09PTEpcmV0dXJuXCIvL1wiO3JldHVybiBlLnNsaWNlKDAsaSl9LGJhc2VuYW1lOmZ1bmN0aW9uIGJhc2VuYW1lKGUscil7aWYociE9PXVuZGVmaW5lZCYmdHlwZW9mIHIhPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXh0XCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO2Fzc2VydFBhdGgoZSk7dmFyIHQ9MDt2YXIgaT0tMTt2YXIgbj10cnVlO3ZhciBhO2lmKHIhPT11bmRlZmluZWQmJnIubGVuZ3RoPjAmJnIubGVuZ3RoPD1lLmxlbmd0aCl7aWYoci5sZW5ndGg9PT1lLmxlbmd0aCYmcj09PWUpcmV0dXJuXCJcIjt2YXIgZj1yLmxlbmd0aC0xO3ZhciBsPS0xO2ZvcihhPWUubGVuZ3RoLTE7YT49MDstLWEpe3ZhciBzPWUuY2hhckNvZGVBdChhKTtpZihzPT09NDcpe2lmKCFuKXt0PWErMTticmVha319ZWxzZXtpZihsPT09LTEpe249ZmFsc2U7bD1hKzF9aWYoZj49MCl7aWYocz09PXIuY2hhckNvZGVBdChmKSl7aWYoLS1mPT09LTEpe2k9YX19ZWxzZXtmPS0xO2k9bH19fX1pZih0PT09aSlpPWw7ZWxzZSBpZihpPT09LTEpaT1lLmxlbmd0aDtyZXR1cm4gZS5zbGljZSh0LGkpfWVsc2V7Zm9yKGE9ZS5sZW5ndGgtMTthPj0wOy0tYSl7aWYoZS5jaGFyQ29kZUF0KGEpPT09NDcpe2lmKCFuKXt0PWErMTticmVha319ZWxzZSBpZihpPT09LTEpe249ZmFsc2U7aT1hKzF9fWlmKGk9PT0tMSlyZXR1cm5cIlwiO3JldHVybiBlLnNsaWNlKHQsaSl9fSxleHRuYW1lOmZ1bmN0aW9uIGV4dG5hbWUoZSl7YXNzZXJ0UGF0aChlKTt2YXIgcj0tMTt2YXIgdD0wO3ZhciBpPS0xO3ZhciBuPXRydWU7dmFyIGE9MDtmb3IodmFyIGY9ZS5sZW5ndGgtMTtmPj0wOy0tZil7dmFyIGw9ZS5jaGFyQ29kZUF0KGYpO2lmKGw9PT00Nyl7aWYoIW4pe3Q9ZisxO2JyZWFrfWNvbnRpbnVlfWlmKGk9PT0tMSl7bj1mYWxzZTtpPWYrMX1pZihsPT09NDYpe2lmKHI9PT0tMSlyPWY7ZWxzZSBpZihhIT09MSlhPTF9ZWxzZSBpZihyIT09LTEpe2E9LTF9fWlmKHI9PT0tMXx8aT09PS0xfHxhPT09MHx8YT09PTEmJnI9PT1pLTEmJnI9PT10KzEpe3JldHVyblwiXCJ9cmV0dXJuIGUuc2xpY2UocixpKX0sZm9ybWF0OmZ1bmN0aW9uIGZvcm1hdChlKXtpZihlPT09bnVsbHx8dHlwZW9mIGUhPT1cIm9iamVjdFwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJwYXRoT2JqZWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnK3R5cGVvZiBlKX1yZXR1cm4gX2Zvcm1hdChcIi9cIixlKX0scGFyc2U6ZnVuY3Rpb24gcGFyc2UoZSl7YXNzZXJ0UGF0aChlKTt2YXIgcj17cm9vdDpcIlwiLGRpcjpcIlwiLGJhc2U6XCJcIixleHQ6XCJcIixuYW1lOlwiXCJ9O2lmKGUubGVuZ3RoPT09MClyZXR1cm4gcjt2YXIgdD1lLmNoYXJDb2RlQXQoMCk7dmFyIGk9dD09PTQ3O3ZhciBuO2lmKGkpe3Iucm9vdD1cIi9cIjtuPTF9ZWxzZXtuPTB9dmFyIGE9LTE7dmFyIGY9MDt2YXIgbD0tMTt2YXIgcz10cnVlO3ZhciBvPWUubGVuZ3RoLTE7dmFyIHU9MDtmb3IoO28+PW47LS1vKXt0PWUuY2hhckNvZGVBdChvKTtpZih0PT09NDcpe2lmKCFzKXtmPW8rMTticmVha31jb250aW51ZX1pZihsPT09LTEpe3M9ZmFsc2U7bD1vKzF9aWYodD09PTQ2KXtpZihhPT09LTEpYT1vO2Vsc2UgaWYodSE9PTEpdT0xfWVsc2UgaWYoYSE9PS0xKXt1PS0xfX1pZihhPT09LTF8fGw9PT0tMXx8dT09PTB8fHU9PT0xJiZhPT09bC0xJiZhPT09ZisxKXtpZihsIT09LTEpe2lmKGY9PT0wJiZpKXIuYmFzZT1yLm5hbWU9ZS5zbGljZSgxLGwpO2Vsc2Ugci5iYXNlPXIubmFtZT1lLnNsaWNlKGYsbCl9fWVsc2V7aWYoZj09PTAmJmkpe3IubmFtZT1lLnNsaWNlKDEsYSk7ci5iYXNlPWUuc2xpY2UoMSxsKX1lbHNle3IubmFtZT1lLnNsaWNlKGYsYSk7ci5iYXNlPWUuc2xpY2UoZixsKX1yLmV4dD1lLnNsaWNlKGEsbCl9aWYoZj4wKXIuZGlyPWUuc2xpY2UoMCxmLTEpO2Vsc2UgaWYoaSlyLmRpcj1cIi9cIjtyZXR1cm4gcn0sc2VwOlwiL1wiLGRlbGltaXRlcjpcIjpcIix3aW4zMjpudWxsLHBvc2l4Om51bGx9O3IucG9zaXg9cjtlLmV4cG9ydHM9cn19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIGk9clt0XTtpZihpIT09dW5kZWZpbmVkKXtyZXR1cm4gaS5leHBvcnRzfXZhciBuPXJbdF09e2V4cG9ydHM6e319O3ZhciBhPXRydWU7dHJ5e2VbdF0obixuLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7YT1mYWxzZX1maW5hbGx5e2lmKGEpZGVsZXRlIHJbdF19cmV0dXJuIG4uZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXygxMTMpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6WyJlIiwiYXNzZXJ0UGF0aCIsIlR5cGVFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJub3JtYWxpemVTdHJpbmdQb3NpeCIsInIiLCJ0IiwiaSIsIm4iLCJhIiwiZiIsImwiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwicyIsImxhc3RJbmRleE9mIiwic2xpY2UiLCJfZm9ybWF0IiwiZGlyIiwicm9vdCIsImJhc2UiLCJuYW1lIiwiZXh0IiwicmVzb2x2ZSIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsIm5vcm1hbGl6ZSIsImlzQWJzb2x1dGUiLCJqb2luIiwicmVsYXRpdmUiLCJvIiwidSIsImgiLCJjIiwidiIsImciLCJfbWFrZUxvbmciLCJkaXJuYW1lIiwiYmFzZW5hbWUiLCJleHRuYW1lIiwiZm9ybWF0IiwicGFyc2UiLCJzZXAiLCJkZWxpbWl0ZXIiLCJ3aW4zMiIsInBvc2l4IiwiZXhwb3J0cyIsIl9fbmNjd3Bja19yZXF1aXJlX18iLCJhYiIsIl9fZGlybmFtZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/path-browserify/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function () {\n  var e = {\n    308: function (e) {\n      var t = e.exports = {};\n      var r;\n      var n;\n\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n\n      (function () {\n        try {\n          if (typeof setTimeout === \"function\") {\n            r = setTimeout;\n          } else {\n            r = defaultSetTimout;\n          }\n        } catch (e) {\n          r = defaultSetTimout;\n        }\n\n        try {\n          if (typeof clearTimeout === \"function\") {\n            n = clearTimeout;\n          } else {\n            n = defaultClearTimeout;\n          }\n        } catch (e) {\n          n = defaultClearTimeout;\n        }\n      })();\n\n      function runTimeout(e) {\n        if (r === setTimeout) {\n          return setTimeout(e, 0);\n        }\n\n        if ((r === defaultSetTimout || !r) && setTimeout) {\n          r = setTimeout;\n          return setTimeout(e, 0);\n        }\n\n        try {\n          return r(e, 0);\n        } catch (t) {\n          try {\n            return r.call(null, e, 0);\n          } catch (t) {\n            return r.call(this, e, 0);\n          }\n        }\n      }\n\n      function runClearTimeout(e) {\n        if (n === clearTimeout) {\n          return clearTimeout(e);\n        }\n\n        if ((n === defaultClearTimeout || !n) && clearTimeout) {\n          n = clearTimeout;\n          return clearTimeout(e);\n        }\n\n        try {\n          return n(e);\n        } catch (t) {\n          try {\n            return n.call(null, e);\n          } catch (t) {\n            return n.call(this, e);\n          }\n        }\n      }\n\n      var i = [];\n      var o = false;\n      var u;\n      var a = -1;\n\n      function cleanUpNextTick() {\n        if (!o || !u) {\n          return;\n        }\n\n        o = false;\n\n        if (u.length) {\n          i = u.concat(i);\n        } else {\n          a = -1;\n        }\n\n        if (i.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (o) {\n          return;\n        }\n\n        var e = runTimeout(cleanUpNextTick);\n        o = true;\n        var t = i.length;\n\n        while (t) {\n          u = i;\n          i = [];\n\n          while (++a < t) {\n            if (u) {\n              u[a].run();\n            }\n          }\n\n          a = -1;\n          t = i.length;\n        }\n\n        u = null;\n        o = false;\n        runClearTimeout(e);\n      }\n\n      t.nextTick = function (e) {\n        var t = new Array(arguments.length - 1);\n\n        if (arguments.length > 1) {\n          for (var r = 1; r < arguments.length; r++) {\n            t[r - 1] = arguments[r];\n          }\n        }\n\n        i.push(new Item(e, t));\n\n        if (i.length === 1 && !o) {\n          runTimeout(drainQueue);\n        }\n      };\n\n      function Item(e, t) {\n        this.fun = e;\n        this.array = t;\n      }\n\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n\n      t.title = \"browser\";\n      t.browser = true;\n      t.env = {};\n      t.argv = [];\n      t.version = \"\";\n      t.versions = {};\n\n      function noop() {}\n\n      t.on = noop;\n      t.addListener = noop;\n      t.once = noop;\n      t.off = noop;\n      t.removeListener = noop;\n      t.removeAllListeners = noop;\n      t.emit = noop;\n      t.prependListener = noop;\n      t.prependOnceListener = noop;\n\n      t.listeners = function (e) {\n        return [];\n      };\n\n      t.binding = function (e) {\n        throw new Error(\"process.binding is not supported\");\n      };\n\n      t.cwd = function () {\n        return \"/\";\n      };\n\n      t.chdir = function (e) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n\n      t.umask = function () {\n        return 0;\n      };\n    }\n  };\n  var t = {};\n\n  function __nccwpck_require__(r) {\n    var n = t[r];\n\n    if (n !== undefined) {\n      return n.exports;\n    }\n\n    var i = t[r] = {\n      exports: {}\n    };\n    var o = true;\n\n    try {\n      e[r](i, i.exports, __nccwpck_require__);\n      o = false;\n    } finally {\n      if (o) delete t[r];\n    }\n\n    return i.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var r = __nccwpck_require__(308);\n\n  module.exports = r;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsQ0FBQyxZQUFVO0VBQUMsSUFBSUEsQ0FBQyxHQUFDO0lBQUMsS0FBSSxVQUFTQSxDQUFULEVBQVc7TUFBQyxJQUFJQyxDQUFDLEdBQUNELENBQUMsQ0FBQ0UsT0FBRixHQUFVLEVBQWhCO01BQW1CLElBQUlDLENBQUo7TUFBTSxJQUFJQyxDQUFKOztNQUFNLFNBQVNDLGdCQUFULEdBQTJCO1FBQUMsTUFBTSxJQUFJQyxLQUFKLENBQVUsaUNBQVYsQ0FBTjtNQUFtRDs7TUFBQSxTQUFTQyxtQkFBVCxHQUE4QjtRQUFDLE1BQU0sSUFBSUQsS0FBSixDQUFVLG1DQUFWLENBQU47TUFBcUQ7O01BQUEsQ0FBQyxZQUFVO1FBQUMsSUFBRztVQUFDLElBQUcsT0FBT0UsVUFBUCxLQUFvQixVQUF2QixFQUFrQztZQUFDTCxDQUFDLEdBQUNLLFVBQUY7VUFBYSxDQUFoRCxNQUFvRDtZQUFDTCxDQUFDLEdBQUNFLGdCQUFGO1VBQW1CO1FBQUMsQ0FBN0UsQ0FBNkUsT0FBTUwsQ0FBTixFQUFRO1VBQUNHLENBQUMsR0FBQ0UsZ0JBQUY7UUFBbUI7O1FBQUEsSUFBRztVQUFDLElBQUcsT0FBT0ksWUFBUCxLQUFzQixVQUF6QixFQUFvQztZQUFDTCxDQUFDLEdBQUNLLFlBQUY7VUFBZSxDQUFwRCxNQUF3RDtZQUFDTCxDQUFDLEdBQUNHLG1CQUFGO1VBQXNCO1FBQUMsQ0FBcEYsQ0FBb0YsT0FBTVAsQ0FBTixFQUFRO1VBQUNJLENBQUMsR0FBQ0csbUJBQUY7UUFBc0I7TUFBQyxDQUF6Tzs7TUFBNk8sU0FBU0csVUFBVCxDQUFvQlYsQ0FBcEIsRUFBc0I7UUFBQyxJQUFHRyxDQUFDLEtBQUdLLFVBQVAsRUFBa0I7VUFBQyxPQUFPQSxVQUFVLENBQUNSLENBQUQsRUFBRyxDQUFILENBQWpCO1FBQXVCOztRQUFBLElBQUcsQ0FBQ0csQ0FBQyxLQUFH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SUFBaUI7O0lBQUEsSUFBSVcsQ0FBQyxHQUFDWixDQUFDLENBQUNFLENBQUQsQ0FBRCxHQUFLO01BQUNELE9BQU8sRUFBQztJQUFULENBQVg7SUFBd0IsSUFBSVksQ0FBQyxHQUFDLElBQU47O0lBQVcsSUFBRztNQUFDZCxDQUFDLENBQUNHLENBQUQsQ0FBRCxDQUFLVSxDQUFMLEVBQU9BLENBQUMsQ0FBQ1gsT0FBVCxFQUFpQmtELG1CQUFqQjtNQUFzQ3RDLENBQUMsR0FBQyxLQUFGO0lBQVEsQ0FBbEQsU0FBeUQ7TUFBQyxJQUFHQSxDQUFILEVBQUssT0FBT2IsQ0FBQyxDQUFDRSxDQUFELENBQVI7SUFBWTs7SUFBQSxPQUFPVSxDQUFDLENBQUNYLE9BQVQ7RUFBaUI7O0VBQUEsSUFBRyxPQUFPa0QsbUJBQVAsS0FBNkIsV0FBaEMsRUFBNENBLG1CQUFtQixDQUFDRSxFQUFwQixHQUF1QkMsU0FBUyxHQUFDLEdBQWpDOztFQUFxQyxJQUFJcEQsQ0FBQyxHQUFDaUQsbUJBQW1CLENBQUMsR0FBRCxDQUF6Qjs7RUFBK0JJLE1BQU0sQ0FBQ3RELE9BQVAsR0FBZUMsQ0FBZjtBQUFpQixDQUF0NEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanM/MWIxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17MzA4OmZ1bmN0aW9uKGUpe3ZhciB0PWUuZXhwb3J0cz17fTt2YXIgcjt2YXIgbjtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfShmdW5jdGlvbigpe3RyeXtpZih0eXBlb2Ygc2V0VGltZW91dD09PVwiZnVuY3Rpb25cIil7cj1zZXRUaW1lb3V0fWVsc2V7cj1kZWZhdWx0U2V0VGltb3V0fX1jYXRjaChlKXtyPWRlZmF1bHRTZXRUaW1vdXR9dHJ5e2lmKHR5cGVvZiBjbGVhclRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe249Y2xlYXJUaW1lb3V0fWVsc2V7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX1jYXRjaChlKXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fSkoKTtmdW5jdGlvbiBydW5UaW1lb3V0KGUpe2lmKHI9PT1zZXRUaW1lb3V0KXtyZXR1cm4gc2V0VGltZW91dChlLDApfWlmKChyPT09ZGVmYXVsdFNldFRpbW91dHx8IXIpJiZzZXRUaW1lb3V0KXtyPXNldFRpbWVvdXQ7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX10cnl7cmV0dXJuIHIoZSwwKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUsMCl9Y2F0Y2godCl7cmV0dXJuIHIuY2FsbCh0aGlzLGUsMCl9fX1mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQoZSl7aWYobj09PWNsZWFyVGltZW91dCl7cmV0dXJuIGNsZWFyVGltZW91dChlKX1pZigobj09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCFuKSYmY2xlYXJUaW1lb3V0KXtuPWNsZWFyVGltZW91dDtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfXRyeXtyZXR1cm4gbihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlKX19fXZhciBpPVtdO3ZhciBvPWZhbHNlO3ZhciB1O3ZhciBhPS0xO2Z1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpe2lmKCFvfHwhdSl7cmV0dXJufW89ZmFsc2U7aWYodS5sZW5ndGgpe2k9dS5jb25jYXQoaSl9ZWxzZXthPS0xfWlmKGkubGVuZ3RoKXtkcmFpblF1ZXVlKCl9fWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZihvKXtyZXR1cm59dmFyIGU9cnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO289dHJ1ZTt2YXIgdD1pLmxlbmd0aDt3aGlsZSh0KXt1PWk7aT1bXTt3aGlsZSgrK2E8dCl7aWYodSl7dVthXS5ydW4oKX19YT0tMTt0PWkubGVuZ3RofXU9bnVsbDtvPWZhbHNlO3J1bkNsZWFyVGltZW91dChlKX10Lm5leHRUaWNrPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dFtyLTFdPWFyZ3VtZW50c1tyXX19aS5wdXNoKG5ldyBJdGVtKGUsdCkpO2lmKGkubGVuZ3RoPT09MSYmIW8pe3J1blRpbWVvdXQoZHJhaW5RdWV1ZSl9fTtmdW5jdGlvbiBJdGVtKGUsdCl7dGhpcy5mdW49ZTt0aGlzLmFycmF5PXR9SXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX07dC50aXRsZT1cImJyb3dzZXJcIjt0LmJyb3dzZXI9dHJ1ZTt0LmVudj17fTt0LmFyZ3Y9W107dC52ZXJzaW9uPVwiXCI7dC52ZXJzaW9ucz17fTtmdW5jdGlvbiBub29wKCl7fXQub249bm9vcDt0LmFkZExpc3RlbmVyPW5vb3A7dC5vbmNlPW5vb3A7dC5vZmY9bm9vcDt0LnJlbW92ZUxpc3RlbmVyPW5vb3A7dC5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDt0LmVtaXQ9bm9vcDt0LnByZXBlbmRMaXN0ZW5lcj1ub29wO3QucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wO3QubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybltdfTt0LmJpbmRpbmc9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3QuY2hkaXI9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGk9dFtyXT17ZXhwb3J0czp7fX07dmFyIG89dHJ1ZTt0cnl7ZVtyXShpLGkuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtvPWZhbHNlfWZpbmFsbHl7aWYobylkZWxldGUgdFtyXX1yZXR1cm4gaS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj1fX25jY3dwY2tfcmVxdWlyZV9fKDMwOCk7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbImUiLCJ0IiwiZXhwb3J0cyIsInIiLCJuIiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiY2FsbCIsInJ1bkNsZWFyVGltZW91dCIsImkiLCJvIiwidSIsImEiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwicnVuIiwibmV4dFRpY2siLCJBcnJheSIsImFyZ3VtZW50cyIsInB1c2giLCJJdGVtIiwiZnVuIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwidW5kZWZpbmVkIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/util/util.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/compiled/util/util.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n(function () {\n  var r = {\n    997: function (r) {\n      r.exports = function (r, t, n) {\n        if (r.filter) return r.filter(t, n);\n        if (void 0 === r || null === r) throw new TypeError();\n        if (\"function\" != typeof t) throw new TypeError();\n        var o = [];\n\n        for (var i = 0; i < r.length; i++) {\n          if (!e.call(r, i)) continue;\n          var a = r[i];\n          if (t.call(n, a, i, r)) o.push(a);\n        }\n\n        return o;\n      };\n\n      var e = Object.prototype.hasOwnProperty;\n    },\n    171: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(627);\n      var o = t(302);\n      var i = o(n(\"String.prototype.indexOf\"));\n\n      r.exports = function callBoundIntrinsic(r, e) {\n        var t = n(r, !!e);\n\n        if (typeof t === \"function\" && i(r, \".prototype.\") > -1) {\n          return o(t);\n        }\n\n        return t;\n      };\n    },\n    302: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(194);\n      var o = t(627);\n      var i = o(\"%Function.prototype.apply%\");\n      var a = o(\"%Function.prototype.call%\");\n      var f = o(\"%Reflect.apply%\", true) || n.call(a, i);\n      var u = o(\"%Object.getOwnPropertyDescriptor%\", true);\n      var s = o(\"%Object.defineProperty%\", true);\n      var c = o(\"%Math.max%\");\n\n      if (s) {\n        try {\n          s({}, \"a\", {\n            value: 1\n          });\n        } catch (r) {\n          s = null;\n        }\n      }\n\n      r.exports = function callBind(r) {\n        var e = f(n, a, arguments);\n\n        if (u && s) {\n          var t = u(e, \"length\");\n\n          if (t.configurable) {\n            s(e, \"length\", {\n              value: 1 + c(0, r.length - (arguments.length - 1))\n            });\n          }\n        }\n\n        return e;\n      };\n\n      var y = function applyBind() {\n        return f(n, i, arguments);\n      };\n\n      if (s) {\n        s(r.exports, \"apply\", {\n          value: y\n        });\n      } else {\n        r.exports.apply = y;\n      }\n    },\n    981: function (r) {\n      var e = Object.prototype.hasOwnProperty;\n      var t = Object.prototype.toString;\n\n      r.exports = function forEach(r, n, o) {\n        if (t.call(n) !== \"[object Function]\") {\n          throw new TypeError(\"iterator must be a function\");\n        }\n\n        var i = r.length;\n\n        if (i === +i) {\n          for (var a = 0; a < i; a++) {\n            n.call(o, r[a], a, r);\n          }\n        } else {\n          for (var f in r) {\n            if (e.call(r, f)) {\n              n.call(o, r[f], f, r);\n            }\n          }\n        }\n      };\n    },\n    861: function (r) {\n      \"use strict\";\n\n      var e = \"Function.prototype.bind called on incompatible \";\n      var t = Array.prototype.slice;\n      var n = Object.prototype.toString;\n      var o = \"[object Function]\";\n\n      r.exports = function bind(r) {\n        var i = this;\n\n        if (typeof i !== \"function\" || n.call(i) !== o) {\n          throw new TypeError(e + i);\n        }\n\n        var a = t.call(arguments, 1);\n        var f;\n\n        var binder = function () {\n          if (this instanceof f) {\n            var e = i.apply(this, a.concat(t.call(arguments)));\n\n            if (Object(e) === e) {\n              return e;\n            }\n\n            return this;\n          } else {\n            return i.apply(r, a.concat(t.call(arguments)));\n          }\n        };\n\n        var u = Math.max(0, i.length - a.length);\n        var s = [];\n\n        for (var c = 0; c < u; c++) {\n          s.push(\"$\" + c);\n        }\n\n        f = Function(\"binder\", \"return function (\" + s.join(\",\") + \"){ return binder.apply(this,arguments); }\")(binder);\n\n        if (i.prototype) {\n          var y = function Empty() {};\n\n          y.prototype = i.prototype;\n          f.prototype = new y();\n          y.prototype = null;\n        }\n\n        return f;\n      };\n    },\n    194: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(861);\n      r.exports = Function.prototype.bind || n;\n    },\n    627: function (r, e, t) {\n      \"use strict\";\n\n      var n;\n      var o = SyntaxError;\n      var i = Function;\n      var a = TypeError;\n\n      var getEvalledConstructor = function (r) {\n        try {\n          return i('\"use strict\"; return (' + r + \").constructor;\")();\n        } catch (r) {}\n      };\n\n      var f = Object.getOwnPropertyDescriptor;\n\n      if (f) {\n        try {\n          f({}, \"\");\n        } catch (r) {\n          f = null;\n        }\n      }\n\n      var throwTypeError = function () {\n        throw new a();\n      };\n\n      var u = f ? function () {\n        try {\n          arguments.callee;\n          return throwTypeError;\n        } catch (r) {\n          try {\n            return f(arguments, \"callee\").get;\n          } catch (r) {\n            return throwTypeError;\n          }\n        }\n      }() : throwTypeError;\n      var s = t(567)();\n\n      var c = Object.getPrototypeOf || function (r) {\n        return r.__proto__;\n      };\n\n      var y = {};\n      var p = typeof Uint8Array === \"undefined\" ? n : c(Uint8Array);\n      var l = {\n        \"%AggregateError%\": typeof AggregateError === \"undefined\" ? n : AggregateError,\n        \"%Array%\": Array,\n        \"%ArrayBuffer%\": typeof ArrayBuffer === \"undefined\" ? n : ArrayBuffer,\n        \"%ArrayIteratorPrototype%\": s ? c([][Symbol.iterator]()) : n,\n        \"%AsyncFromSyncIteratorPrototype%\": n,\n        \"%AsyncFunction%\": y,\n        \"%AsyncGenerator%\": y,\n        \"%AsyncGeneratorFunction%\": y,\n        \"%AsyncIteratorPrototype%\": y,\n        \"%Atomics%\": typeof Atomics === \"undefined\" ? n : Atomics,\n        \"%BigInt%\": typeof BigInt === \"undefined\" ? n : BigInt,\n        \"%Boolean%\": Boolean,\n        \"%DataView%\": typeof DataView === \"undefined\" ? n : DataView,\n        \"%Date%\": Date,\n        \"%decodeURI%\": decodeURI,\n        \"%decodeURIComponent%\": decodeURIComponent,\n        \"%encodeURI%\": encodeURI,\n        \"%encodeURIComponent%\": encodeURIComponent,\n        \"%Error%\": Error,\n        \"%eval%\": eval,\n        \"%EvalError%\": EvalError,\n        \"%Float32Array%\": typeof Float32Array === \"undefined\" ? n : Float32Array,\n        \"%Float64Array%\": typeof Float64Array === \"undefined\" ? n : Float64Array,\n        \"%FinalizationRegistry%\": typeof FinalizationRegistry === \"undefined\" ? n : FinalizationRegistry,\n        \"%Function%\": i,\n        \"%GeneratorFunction%\": y,\n        \"%Int8Array%\": typeof Int8Array === \"undefined\" ? n : Int8Array,\n        \"%Int16Array%\": typeof Int16Array === \"undefined\" ? n : Int16Array,\n        \"%Int32Array%\": typeof Int32Array === \"undefined\" ? n : Int32Array,\n        \"%isFinite%\": isFinite,\n        \"%isNaN%\": isNaN,\n        \"%IteratorPrototype%\": s ? c(c([][Symbol.iterator]())) : n,\n        \"%JSON%\": typeof JSON === \"object\" ? JSON : n,\n        \"%Map%\": typeof Map === \"undefined\" ? n : Map,\n        \"%MapIteratorPrototype%\": typeof Map === \"undefined\" || !s ? n : c(new Map()[Symbol.iterator]()),\n        \"%Math%\": Math,\n        \"%Number%\": Number,\n        \"%Object%\": Object,\n        \"%parseFloat%\": parseFloat,\n        \"%parseInt%\": parseInt,\n        \"%Promise%\": typeof Promise === \"undefined\" ? n : Promise,\n        \"%Proxy%\": typeof Proxy === \"undefined\" ? n : Proxy,\n        \"%RangeError%\": RangeError,\n        \"%ReferenceError%\": ReferenceError,\n        \"%Reflect%\": typeof Reflect === \"undefined\" ? n : Reflect,\n        \"%RegExp%\": RegExp,\n        \"%Set%\": typeof Set === \"undefined\" ? n : Set,\n        \"%SetIteratorPrototype%\": typeof Set === \"undefined\" || !s ? n : c(new Set()[Symbol.iterator]()),\n        \"%SharedArrayBuffer%\": typeof SharedArrayBuffer === \"undefined\" ? n : SharedArrayBuffer,\n        \"%String%\": String,\n        \"%StringIteratorPrototype%\": s ? c(\"\"[Symbol.iterator]()) : n,\n        \"%Symbol%\": s ? Symbol : n,\n        \"%SyntaxError%\": o,\n        \"%ThrowTypeError%\": u,\n        \"%TypedArray%\": p,\n        \"%TypeError%\": a,\n        \"%Uint8Array%\": typeof Uint8Array === \"undefined\" ? n : Uint8Array,\n        \"%Uint8ClampedArray%\": typeof Uint8ClampedArray === \"undefined\" ? n : Uint8ClampedArray,\n        \"%Uint16Array%\": typeof Uint16Array === \"undefined\" ? n : Uint16Array,\n        \"%Uint32Array%\": typeof Uint32Array === \"undefined\" ? n : Uint32Array,\n        \"%URIError%\": URIError,\n        \"%WeakMap%\": typeof WeakMap === \"undefined\" ? n : WeakMap,\n        \"%WeakRef%\": typeof WeakRef === \"undefined\" ? n : WeakRef,\n        \"%WeakSet%\": typeof WeakSet === \"undefined\" ? n : WeakSet\n      };\n\n      var g = function doEval(r) {\n        var e;\n\n        if (r === \"%AsyncFunction%\") {\n          e = getEvalledConstructor(\"async function () {}\");\n        } else if (r === \"%GeneratorFunction%\") {\n          e = getEvalledConstructor(\"function* () {}\");\n        } else if (r === \"%AsyncGeneratorFunction%\") {\n          e = getEvalledConstructor(\"async function* () {}\");\n        } else if (r === \"%AsyncGenerator%\") {\n          var t = doEval(\"%AsyncGeneratorFunction%\");\n\n          if (t) {\n            e = t.prototype;\n          }\n        } else if (r === \"%AsyncIteratorPrototype%\") {\n          var n = doEval(\"%AsyncGenerator%\");\n\n          if (n) {\n            e = c(n.prototype);\n          }\n        }\n\n        l[r] = e;\n        return e;\n      };\n\n      var d = {\n        \"%ArrayBufferPrototype%\": [\"ArrayBuffer\", \"prototype\"],\n        \"%ArrayPrototype%\": [\"Array\", \"prototype\"],\n        \"%ArrayProto_entries%\": [\"Array\", \"prototype\", \"entries\"],\n        \"%ArrayProto_forEach%\": [\"Array\", \"prototype\", \"forEach\"],\n        \"%ArrayProto_keys%\": [\"Array\", \"prototype\", \"keys\"],\n        \"%ArrayProto_values%\": [\"Array\", \"prototype\", \"values\"],\n        \"%AsyncFunctionPrototype%\": [\"AsyncFunction\", \"prototype\"],\n        \"%AsyncGenerator%\": [\"AsyncGeneratorFunction\", \"prototype\"],\n        \"%AsyncGeneratorPrototype%\": [\"AsyncGeneratorFunction\", \"prototype\", \"prototype\"],\n        \"%BooleanPrototype%\": [\"Boolean\", \"prototype\"],\n        \"%DataViewPrototype%\": [\"DataView\", \"prototype\"],\n        \"%DatePrototype%\": [\"Date\", \"prototype\"],\n        \"%ErrorPrototype%\": [\"Error\", \"prototype\"],\n        \"%EvalErrorPrototype%\": [\"EvalError\", \"prototype\"],\n        \"%Float32ArrayPrototype%\": [\"Float32Array\", \"prototype\"],\n        \"%Float64ArrayPrototype%\": [\"Float64Array\", \"prototype\"],\n        \"%FunctionPrototype%\": [\"Function\", \"prototype\"],\n        \"%Generator%\": [\"GeneratorFunction\", \"prototype\"],\n        \"%GeneratorPrototype%\": [\"GeneratorFunction\", \"prototype\", \"prototype\"],\n        \"%Int8ArrayPrototype%\": [\"Int8Array\", \"prototype\"],\n        \"%Int16ArrayPrototype%\": [\"Int16Array\", \"prototype\"],\n        \"%Int32ArrayPrototype%\": [\"Int32Array\", \"prototype\"],\n        \"%JSONParse%\": [\"JSON\", \"parse\"],\n        \"%JSONStringify%\": [\"JSON\", \"stringify\"],\n        \"%MapPrototype%\": [\"Map\", \"prototype\"],\n        \"%NumberPrototype%\": [\"Number\", \"prototype\"],\n        \"%ObjectPrototype%\": [\"Object\", \"prototype\"],\n        \"%ObjProto_toString%\": [\"Object\", \"prototype\", \"toString\"],\n        \"%ObjProto_valueOf%\": [\"Object\", \"prototype\", \"valueOf\"],\n        \"%PromisePrototype%\": [\"Promise\", \"prototype\"],\n        \"%PromiseProto_then%\": [\"Promise\", \"prototype\", \"then\"],\n        \"%Promise_all%\": [\"Promise\", \"all\"],\n        \"%Promise_reject%\": [\"Promise\", \"reject\"],\n        \"%Promise_resolve%\": [\"Promise\", \"resolve\"],\n        \"%RangeErrorPrototype%\": [\"RangeError\", \"prototype\"],\n        \"%ReferenceErrorPrototype%\": [\"ReferenceError\", \"prototype\"],\n        \"%RegExpPrototype%\": [\"RegExp\", \"prototype\"],\n        \"%SetPrototype%\": [\"Set\", \"prototype\"],\n        \"%SharedArrayBufferPrototype%\": [\"SharedArrayBuffer\", \"prototype\"],\n        \"%StringPrototype%\": [\"String\", \"prototype\"],\n        \"%SymbolPrototype%\": [\"Symbol\", \"prototype\"],\n        \"%SyntaxErrorPrototype%\": [\"SyntaxError\", \"prototype\"],\n        \"%TypedArrayPrototype%\": [\"TypedArray\", \"prototype\"],\n        \"%TypeErrorPrototype%\": [\"TypeError\", \"prototype\"],\n        \"%Uint8ArrayPrototype%\": [\"Uint8Array\", \"prototype\"],\n        \"%Uint8ClampedArrayPrototype%\": [\"Uint8ClampedArray\", \"prototype\"],\n        \"%Uint16ArrayPrototype%\": [\"Uint16Array\", \"prototype\"],\n        \"%Uint32ArrayPrototype%\": [\"Uint32Array\", \"prototype\"],\n        \"%URIErrorPrototype%\": [\"URIError\", \"prototype\"],\n        \"%WeakMapPrototype%\": [\"WeakMap\", \"prototype\"],\n        \"%WeakSetPrototype%\": [\"WeakSet\", \"prototype\"]\n      };\n      var v = t(194);\n      var b = t(646);\n      var A = v.call(Function.call, Array.prototype.concat);\n      var m = v.call(Function.apply, Array.prototype.splice);\n      var S = v.call(Function.call, String.prototype.replace);\n      var h = v.call(Function.call, String.prototype.slice);\n      var O = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\n      var w = /\\\\(\\\\)?/g;\n\n      var j = function stringToPath(r) {\n        var e = h(r, 0, 1);\n        var t = h(r, -1);\n\n        if (e === \"%\" && t !== \"%\") {\n          throw new o(\"invalid intrinsic syntax, expected closing `%`\");\n        } else if (t === \"%\" && e !== \"%\") {\n          throw new o(\"invalid intrinsic syntax, expected opening `%`\");\n        }\n\n        var n = [];\n        S(r, O, function (r, e, t, o) {\n          n[n.length] = t ? S(o, w, \"$1\") : e || r;\n        });\n        return n;\n      };\n\n      var P = function getBaseIntrinsic(r, e) {\n        var t = r;\n        var n;\n\n        if (b(d, t)) {\n          n = d[t];\n          t = \"%\" + n[0] + \"%\";\n        }\n\n        if (b(l, t)) {\n          var i = l[t];\n\n          if (i === y) {\n            i = g(t);\n          }\n\n          if (typeof i === \"undefined\" && !e) {\n            throw new a(\"intrinsic \" + r + \" exists, but is not available. Please file an issue!\");\n          }\n\n          return {\n            alias: n,\n            name: t,\n            value: i\n          };\n        }\n\n        throw new o(\"intrinsic \" + r + \" does not exist!\");\n      };\n\n      r.exports = function GetIntrinsic(r, e) {\n        if (typeof r !== \"string\" || r.length === 0) {\n          throw new a(\"intrinsic name must be a non-empty string\");\n        }\n\n        if (arguments.length > 1 && typeof e !== \"boolean\") {\n          throw new a('\"allowMissing\" argument must be a boolean');\n        }\n\n        var t = j(r);\n        var i = t.length > 0 ? t[0] : \"\";\n        var u = P(\"%\" + i + \"%\", e);\n        var s = u.name;\n        var c = u.value;\n        var y = false;\n        var p = u.alias;\n\n        if (p) {\n          i = p[0];\n          m(t, A([0, 1], p));\n        }\n\n        for (var g = 1, d = true; g < t.length; g += 1) {\n          var v = t[g];\n          var S = h(v, 0, 1);\n          var O = h(v, -1);\n\n          if ((S === '\"' || S === \"'\" || S === \"`\" || O === '\"' || O === \"'\" || O === \"`\") && S !== O) {\n            throw new o(\"property names with quotes must have matching quotes\");\n          }\n\n          if (v === \"constructor\" || !d) {\n            y = true;\n          }\n\n          i += \".\" + v;\n          s = \"%\" + i + \"%\";\n\n          if (b(l, s)) {\n            c = l[s];\n          } else if (c != null) {\n            if (!(v in c)) {\n              if (!e) {\n                throw new a(\"base intrinsic for \" + r + \" exists, but the property is not available.\");\n              }\n\n              return void n;\n            }\n\n            if (f && g + 1 >= t.length) {\n              var w = f(c, v);\n              d = !!w;\n\n              if (d && \"get\" in w && !(\"originalValue\" in w.get)) {\n                c = w.get;\n              } else {\n                c = c[v];\n              }\n            } else {\n              d = b(c, v);\n              c = c[v];\n            }\n\n            if (d && !y) {\n              l[s] = c;\n            }\n          }\n        }\n\n        return c;\n      };\n    },\n    567: function (r, e, t) {\n      \"use strict\";\n\n      var n = typeof Symbol !== \"undefined\" && Symbol;\n      var o = t(186);\n\n      r.exports = function hasNativeSymbols() {\n        if (typeof n !== \"function\") {\n          return false;\n        }\n\n        if (typeof Symbol !== \"function\") {\n          return false;\n        }\n\n        if (typeof n(\"foo\") !== \"symbol\") {\n          return false;\n        }\n\n        if (typeof Symbol(\"bar\") !== \"symbol\") {\n          return false;\n        }\n\n        return o();\n      };\n    },\n    186: function (r) {\n      \"use strict\";\n\n      r.exports = function hasSymbols() {\n        if (typeof Symbol !== \"function\" || typeof Object.getOwnPropertySymbols !== \"function\") {\n          return false;\n        }\n\n        if (typeof Symbol.iterator === \"symbol\") {\n          return true;\n        }\n\n        var r = {};\n        var e = Symbol(\"test\");\n        var t = Object(e);\n\n        if (typeof e === \"string\") {\n          return false;\n        }\n\n        if (Object.prototype.toString.call(e) !== \"[object Symbol]\") {\n          return false;\n        }\n\n        if (Object.prototype.toString.call(t) !== \"[object Symbol]\") {\n          return false;\n        }\n\n        var n = 42;\n        r[e] = n;\n\n        for (e in r) {\n          return false;\n        }\n\n        if (typeof Object.keys === \"function\" && Object.keys(r).length !== 0) {\n          return false;\n        }\n\n        if (typeof Object.getOwnPropertyNames === \"function\" && Object.getOwnPropertyNames(r).length !== 0) {\n          return false;\n        }\n\n        var o = Object.getOwnPropertySymbols(r);\n\n        if (o.length !== 1 || o[0] !== e) {\n          return false;\n        }\n\n        if (!Object.prototype.propertyIsEnumerable.call(r, e)) {\n          return false;\n        }\n\n        if (typeof Object.getOwnPropertyDescriptor === \"function\") {\n          var i = Object.getOwnPropertyDescriptor(r, e);\n\n          if (i.value !== n || i.enumerable !== true) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n    },\n    646: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(194);\n      r.exports = n.call(Function.call, Object.prototype.hasOwnProperty);\n    },\n    140: function (r) {\n      if (typeof Object.create === \"function\") {\n        r.exports = function inherits(r, e) {\n          if (e) {\n            r.super_ = e;\n            r.prototype = Object.create(e.prototype, {\n              constructor: {\n                value: r,\n                enumerable: false,\n                writable: true,\n                configurable: true\n              }\n            });\n          }\n        };\n      } else {\n        r.exports = function inherits(r, e) {\n          if (e) {\n            r.super_ = e;\n\n            var TempCtor = function () {};\n\n            TempCtor.prototype = e.prototype;\n            r.prototype = new TempCtor();\n            r.prototype.constructor = r;\n          }\n        };\n      }\n    },\n    749: function (r) {\n      \"use strict\";\n\n      var e = typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\";\n      var t = Object.prototype.toString;\n\n      var n = function isArguments(r) {\n        if (e && r && typeof r === \"object\" && Symbol.toStringTag in r) {\n          return false;\n        }\n\n        return t.call(r) === \"[object Arguments]\";\n      };\n\n      var o = function isArguments(r) {\n        if (n(r)) {\n          return true;\n        }\n\n        return r !== null && typeof r === \"object\" && typeof r.length === \"number\" && r.length >= 0 && t.call(r) !== \"[object Array]\" && t.call(r.callee) === \"[object Function]\";\n      };\n\n      var i = function () {\n        return n(arguments);\n      }();\n\n      n.isLegacyArguments = o;\n      r.exports = i ? n : o;\n    },\n    611: function (r) {\n      \"use strict\";\n\n      var e = Object.prototype.toString;\n      var t = Function.prototype.toString;\n      var n = /^\\s*(?:function)?\\*/;\n      var o = typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\";\n      var i = Object.getPrototypeOf;\n\n      var getGeneratorFunc = function () {\n        if (!o) {\n          return false;\n        }\n\n        try {\n          return Function(\"return function*() {}\")();\n        } catch (r) {}\n      };\n\n      var a = getGeneratorFunc();\n      var f = a ? i(a) : {};\n\n      r.exports = function isGeneratorFunction(r) {\n        if (typeof r !== \"function\") {\n          return false;\n        }\n\n        if (n.test(t.call(r))) {\n          return true;\n        }\n\n        if (!o) {\n          var a = e.call(r);\n          return a === \"[object GeneratorFunction]\";\n        }\n\n        return i(r) === f;\n      };\n    },\n    387: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(981);\n      var o = t(382);\n      var i = t(171);\n      var a = i(\"Object.prototype.toString\");\n      var f = t(567)();\n      var u = f && typeof Symbol.toStringTag === \"symbol\";\n      var s = o();\n\n      var c = i(\"Array.prototype.indexOf\", true) || function indexOf(r, e) {\n        for (var t = 0; t < r.length; t += 1) {\n          if (r[t] === e) {\n            return t;\n          }\n        }\n\n        return -1;\n      };\n\n      var y = i(\"String.prototype.slice\");\n      var p = {};\n      var l = t(30);\n      var g = Object.getPrototypeOf;\n\n      if (u && l && g) {\n        n(s, function (r) {\n          var e = new __webpack_require__.g[r]();\n\n          if (!(Symbol.toStringTag in e)) {\n            throw new EvalError(\"this engine has support for Symbol.toStringTag, but \" + r + \" does not have the property! Please report this.\");\n          }\n\n          var t = g(e);\n          var n = l(t, Symbol.toStringTag);\n\n          if (!n) {\n            var o = g(t);\n            n = l(o, Symbol.toStringTag);\n          }\n\n          p[r] = n.get;\n        });\n      }\n\n      var d = function tryAllTypedArrays(r) {\n        var e = false;\n        n(p, function (t, n) {\n          if (!e) {\n            try {\n              e = t.call(r) === n;\n            } catch (r) {}\n          }\n        });\n        return e;\n      };\n\n      r.exports = function isTypedArray(r) {\n        if (!r || typeof r !== \"object\") {\n          return false;\n        }\n\n        if (!u) {\n          var e = y(a(r), 8, -1);\n          return c(s, e) > -1;\n        }\n\n        if (!l) {\n          return false;\n        }\n\n        return d(r);\n      };\n    },\n    913: function (r) {\n      r.exports = function isBuffer(r) {\n        return r instanceof Buffer;\n      };\n    },\n    989: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(749);\n      var o = t(611);\n      var i = t(728);\n      var a = t(387);\n\n      function uncurryThis(r) {\n        return r.call.bind(r);\n      }\n\n      var f = typeof BigInt !== \"undefined\";\n      var u = typeof Symbol !== \"undefined\";\n      var s = uncurryThis(Object.prototype.toString);\n      var c = uncurryThis(Number.prototype.valueOf);\n      var y = uncurryThis(String.prototype.valueOf);\n      var p = uncurryThis(Boolean.prototype.valueOf);\n\n      if (f) {\n        var l = uncurryThis(BigInt.prototype.valueOf);\n      }\n\n      if (u) {\n        var g = uncurryThis(Symbol.prototype.valueOf);\n      }\n\n      function checkBoxedPrimitive(r, e) {\n        if (typeof r !== \"object\") {\n          return false;\n        }\n\n        try {\n          e(r);\n          return true;\n        } catch (r) {\n          return false;\n        }\n      }\n\n      e.isArgumentsObject = n;\n      e.isGeneratorFunction = o;\n      e.isTypedArray = a;\n\n      function isPromise(r) {\n        return typeof Promise !== \"undefined\" && r instanceof Promise || r !== null && typeof r === \"object\" && typeof r.then === \"function\" && typeof r.catch === \"function\";\n      }\n\n      e.isPromise = isPromise;\n\n      function isArrayBufferView(r) {\n        if (typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView) {\n          return ArrayBuffer.isView(r);\n        }\n\n        return a(r) || isDataView(r);\n      }\n\n      e.isArrayBufferView = isArrayBufferView;\n\n      function isUint8Array(r) {\n        return i(r) === \"Uint8Array\";\n      }\n\n      e.isUint8Array = isUint8Array;\n\n      function isUint8ClampedArray(r) {\n        return i(r) === \"Uint8ClampedArray\";\n      }\n\n      e.isUint8ClampedArray = isUint8ClampedArray;\n\n      function isUint16Array(r) {\n        return i(r) === \"Uint16Array\";\n      }\n\n      e.isUint16Array = isUint16Array;\n\n      function isUint32Array(r) {\n        return i(r) === \"Uint32Array\";\n      }\n\n      e.isUint32Array = isUint32Array;\n\n      function isInt8Array(r) {\n        return i(r) === \"Int8Array\";\n      }\n\n      e.isInt8Array = isInt8Array;\n\n      function isInt16Array(r) {\n        return i(r) === \"Int16Array\";\n      }\n\n      e.isInt16Array = isInt16Array;\n\n      function isInt32Array(r) {\n        return i(r) === \"Int32Array\";\n      }\n\n      e.isInt32Array = isInt32Array;\n\n      function isFloat32Array(r) {\n        return i(r) === \"Float32Array\";\n      }\n\n      e.isFloat32Array = isFloat32Array;\n\n      function isFloat64Array(r) {\n        return i(r) === \"Float64Array\";\n      }\n\n      e.isFloat64Array = isFloat64Array;\n\n      function isBigInt64Array(r) {\n        return i(r) === \"BigInt64Array\";\n      }\n\n      e.isBigInt64Array = isBigInt64Array;\n\n      function isBigUint64Array(r) {\n        return i(r) === \"BigUint64Array\";\n      }\n\n      e.isBigUint64Array = isBigUint64Array;\n\n      function isMapToString(r) {\n        return s(r) === \"[object Map]\";\n      }\n\n      isMapToString.working = typeof Map !== \"undefined\" && isMapToString(new Map());\n\n      function isMap(r) {\n        if (typeof Map === \"undefined\") {\n          return false;\n        }\n\n        return isMapToString.working ? isMapToString(r) : r instanceof Map;\n      }\n\n      e.isMap = isMap;\n\n      function isSetToString(r) {\n        return s(r) === \"[object Set]\";\n      }\n\n      isSetToString.working = typeof Set !== \"undefined\" && isSetToString(new Set());\n\n      function isSet(r) {\n        if (typeof Set === \"undefined\") {\n          return false;\n        }\n\n        return isSetToString.working ? isSetToString(r) : r instanceof Set;\n      }\n\n      e.isSet = isSet;\n\n      function isWeakMapToString(r) {\n        return s(r) === \"[object WeakMap]\";\n      }\n\n      isWeakMapToString.working = typeof WeakMap !== \"undefined\" && isWeakMapToString(new WeakMap());\n\n      function isWeakMap(r) {\n        if (typeof WeakMap === \"undefined\") {\n          return false;\n        }\n\n        return isWeakMapToString.working ? isWeakMapToString(r) : r instanceof WeakMap;\n      }\n\n      e.isWeakMap = isWeakMap;\n\n      function isWeakSetToString(r) {\n        return s(r) === \"[object WeakSet]\";\n      }\n\n      isWeakSetToString.working = typeof WeakSet !== \"undefined\" && isWeakSetToString(new WeakSet());\n\n      function isWeakSet(r) {\n        return isWeakSetToString(r);\n      }\n\n      e.isWeakSet = isWeakSet;\n\n      function isArrayBufferToString(r) {\n        return s(r) === \"[object ArrayBuffer]\";\n      }\n\n      isArrayBufferToString.working = typeof ArrayBuffer !== \"undefined\" && isArrayBufferToString(new ArrayBuffer());\n\n      function isArrayBuffer(r) {\n        if (typeof ArrayBuffer === \"undefined\") {\n          return false;\n        }\n\n        return isArrayBufferToString.working ? isArrayBufferToString(r) : r instanceof ArrayBuffer;\n      }\n\n      e.isArrayBuffer = isArrayBuffer;\n\n      function isDataViewToString(r) {\n        return s(r) === \"[object DataView]\";\n      }\n\n      isDataViewToString.working = typeof ArrayBuffer !== \"undefined\" && typeof DataView !== \"undefined\" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));\n\n      function isDataView(r) {\n        if (typeof DataView === \"undefined\") {\n          return false;\n        }\n\n        return isDataViewToString.working ? isDataViewToString(r) : r instanceof DataView;\n      }\n\n      e.isDataView = isDataView;\n      var d = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : undefined;\n\n      function isSharedArrayBufferToString(r) {\n        return s(r) === \"[object SharedArrayBuffer]\";\n      }\n\n      function isSharedArrayBuffer(r) {\n        if (typeof d === \"undefined\") {\n          return false;\n        }\n\n        if (typeof isSharedArrayBufferToString.working === \"undefined\") {\n          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new d());\n        }\n\n        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(r) : r instanceof d;\n      }\n\n      e.isSharedArrayBuffer = isSharedArrayBuffer;\n\n      function isAsyncFunction(r) {\n        return s(r) === \"[object AsyncFunction]\";\n      }\n\n      e.isAsyncFunction = isAsyncFunction;\n\n      function isMapIterator(r) {\n        return s(r) === \"[object Map Iterator]\";\n      }\n\n      e.isMapIterator = isMapIterator;\n\n      function isSetIterator(r) {\n        return s(r) === \"[object Set Iterator]\";\n      }\n\n      e.isSetIterator = isSetIterator;\n\n      function isGeneratorObject(r) {\n        return s(r) === \"[object Generator]\";\n      }\n\n      e.isGeneratorObject = isGeneratorObject;\n\n      function isWebAssemblyCompiledModule(r) {\n        return s(r) === \"[object WebAssembly.Module]\";\n      }\n\n      e.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\n      function isNumberObject(r) {\n        return checkBoxedPrimitive(r, c);\n      }\n\n      e.isNumberObject = isNumberObject;\n\n      function isStringObject(r) {\n        return checkBoxedPrimitive(r, y);\n      }\n\n      e.isStringObject = isStringObject;\n\n      function isBooleanObject(r) {\n        return checkBoxedPrimitive(r, p);\n      }\n\n      e.isBooleanObject = isBooleanObject;\n\n      function isBigIntObject(r) {\n        return f && checkBoxedPrimitive(r, l);\n      }\n\n      e.isBigIntObject = isBigIntObject;\n\n      function isSymbolObject(r) {\n        return u && checkBoxedPrimitive(r, g);\n      }\n\n      e.isSymbolObject = isSymbolObject;\n\n      function isBoxedPrimitive(r) {\n        return isNumberObject(r) || isStringObject(r) || isBooleanObject(r) || isBigIntObject(r) || isSymbolObject(r);\n      }\n\n      e.isBoxedPrimitive = isBoxedPrimitive;\n\n      function isAnyArrayBuffer(r) {\n        return typeof Uint8Array !== \"undefined\" && (isArrayBuffer(r) || isSharedArrayBuffer(r));\n      }\n\n      e.isAnyArrayBuffer = isAnyArrayBuffer;\n      [\"isProxy\", \"isExternal\", \"isModuleNamespaceObject\"].forEach(function (r) {\n        Object.defineProperty(e, r, {\n          enumerable: false,\n          value: function () {\n            throw new Error(r + \" is not supported in userland\");\n          }\n        });\n      });\n    },\n    467: function (r, e, t) {\n      var n = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(r) {\n        var e = Object.keys(r);\n        var t = {};\n\n        for (var n = 0; n < e.length; n++) {\n          t[e[n]] = Object.getOwnPropertyDescriptor(r, e[n]);\n        }\n\n        return t;\n      };\n\n      var o = /%[sdj%]/g;\n\n      e.format = function (r) {\n        if (!isString(r)) {\n          var e = [];\n\n          for (var t = 0; t < arguments.length; t++) {\n            e.push(inspect(arguments[t]));\n          }\n\n          return e.join(\" \");\n        }\n\n        var t = 1;\n        var n = arguments;\n        var i = n.length;\n        var a = String(r).replace(o, function (r) {\n          if (r === \"%%\") return \"%\";\n          if (t >= i) return r;\n\n          switch (r) {\n            case \"%s\":\n              return String(n[t++]);\n\n            case \"%d\":\n              return Number(n[t++]);\n\n            case \"%j\":\n              try {\n                return JSON.stringify(n[t++]);\n              } catch (r) {\n                return \"[Circular]\";\n              }\n\n            default:\n              return r;\n          }\n        });\n\n        for (var f = n[t]; t < i; f = n[++t]) {\n          if (isNull(f) || !isObject(f)) {\n            a += \" \" + f;\n          } else {\n            a += \" \" + inspect(f);\n          }\n        }\n\n        return a;\n      };\n\n      e.deprecate = function (r, t) {\n        if (typeof process !== \"undefined\" && process.noDeprecation === true) {\n          return r;\n        }\n\n        if (typeof process === \"undefined\") {\n          return function () {\n            return e.deprecate(r, t).apply(this, arguments);\n          };\n        }\n\n        var n = false;\n\n        function deprecated() {\n          if (!n) {\n            if (process.throwDeprecation) {\n              throw new Error(t);\n            } else if (process.traceDeprecation) {\n              console.trace(t);\n            } else {\n              console.error(t);\n            }\n\n            n = true;\n          }\n\n          return r.apply(this, arguments);\n        }\n\n        return deprecated;\n      };\n\n      var i = {};\n      var a = /^$/;\n\n      if (process.env.NODE_DEBUG) {\n        var f = process.env.NODE_DEBUG;\n        f = f.replace(/[|\\\\{}()[\\]^$+?.]/g, \"\\\\$&\").replace(/\\*/g, \".*\").replace(/,/g, \"$|^\").toUpperCase();\n        a = new RegExp(\"^\" + f + \"$\", \"i\");\n      }\n\n      e.debuglog = function (r) {\n        r = r.toUpperCase();\n\n        if (!i[r]) {\n          if (a.test(r)) {\n            var t = process.pid;\n\n            i[r] = function () {\n              var n = e.format.apply(e, arguments);\n              console.error(\"%s %d: %s\", r, t, n);\n            };\n          } else {\n            i[r] = function () {};\n          }\n        }\n\n        return i[r];\n      };\n\n      function inspect(r, t) {\n        var n = {\n          seen: [],\n          stylize: stylizeNoColor\n        };\n        if (arguments.length >= 3) n.depth = arguments[2];\n        if (arguments.length >= 4) n.colors = arguments[3];\n\n        if (isBoolean(t)) {\n          n.showHidden = t;\n        } else if (t) {\n          e._extend(n, t);\n        }\n\n        if (isUndefined(n.showHidden)) n.showHidden = false;\n        if (isUndefined(n.depth)) n.depth = 2;\n        if (isUndefined(n.colors)) n.colors = false;\n        if (isUndefined(n.customInspect)) n.customInspect = true;\n        if (n.colors) n.stylize = stylizeWithColor;\n        return formatValue(n, r, n.depth);\n      }\n\n      e.inspect = inspect;\n      inspect.colors = {\n        bold: [1, 22],\n        italic: [3, 23],\n        underline: [4, 24],\n        inverse: [7, 27],\n        white: [37, 39],\n        grey: [90, 39],\n        black: [30, 39],\n        blue: [34, 39],\n        cyan: [36, 39],\n        green: [32, 39],\n        magenta: [35, 39],\n        red: [31, 39],\n        yellow: [33, 39]\n      };\n      inspect.styles = {\n        special: \"cyan\",\n        number: \"yellow\",\n        boolean: \"yellow\",\n        undefined: \"grey\",\n        null: \"bold\",\n        string: \"green\",\n        date: \"magenta\",\n        regexp: \"red\"\n      };\n\n      function stylizeWithColor(r, e) {\n        var t = inspect.styles[e];\n\n        if (t) {\n          return \"\u001b[\" + inspect.colors[t][0] + \"m\" + r + \"\u001b[\" + inspect.colors[t][1] + \"m\";\n        } else {\n          return r;\n        }\n      }\n\n      function stylizeNoColor(r, e) {\n        return r;\n      }\n\n      function arrayToHash(r) {\n        var e = {};\n        r.forEach(function (r, t) {\n          e[r] = true;\n        });\n        return e;\n      }\n\n      function formatValue(r, t, n) {\n        if (r.customInspect && t && isFunction(t.inspect) && t.inspect !== e.inspect && !(t.constructor && t.constructor.prototype === t)) {\n          var o = t.inspect(n, r);\n\n          if (!isString(o)) {\n            o = formatValue(r, o, n);\n          }\n\n          return o;\n        }\n\n        var i = formatPrimitive(r, t);\n\n        if (i) {\n          return i;\n        }\n\n        var a = Object.keys(t);\n        var f = arrayToHash(a);\n\n        if (r.showHidden) {\n          a = Object.getOwnPropertyNames(t);\n        }\n\n        if (isError(t) && (a.indexOf(\"message\") >= 0 || a.indexOf(\"description\") >= 0)) {\n          return formatError(t);\n        }\n\n        if (a.length === 0) {\n          if (isFunction(t)) {\n            var u = t.name ? \": \" + t.name : \"\";\n            return r.stylize(\"[Function\" + u + \"]\", \"special\");\n          }\n\n          if (isRegExp(t)) {\n            return r.stylize(RegExp.prototype.toString.call(t), \"regexp\");\n          }\n\n          if (isDate(t)) {\n            return r.stylize(Date.prototype.toString.call(t), \"date\");\n          }\n\n          if (isError(t)) {\n            return formatError(t);\n          }\n        }\n\n        var s = \"\",\n            c = false,\n            y = [\"{\", \"}\"];\n\n        if (isArray(t)) {\n          c = true;\n          y = [\"[\", \"]\"];\n        }\n\n        if (isFunction(t)) {\n          var p = t.name ? \": \" + t.name : \"\";\n          s = \" [Function\" + p + \"]\";\n        }\n\n        if (isRegExp(t)) {\n          s = \" \" + RegExp.prototype.toString.call(t);\n        }\n\n        if (isDate(t)) {\n          s = \" \" + Date.prototype.toUTCString.call(t);\n        }\n\n        if (isError(t)) {\n          s = \" \" + formatError(t);\n        }\n\n        if (a.length === 0 && (!c || t.length == 0)) {\n          return y[0] + s + y[1];\n        }\n\n        if (n < 0) {\n          if (isRegExp(t)) {\n            return r.stylize(RegExp.prototype.toString.call(t), \"regexp\");\n          } else {\n            return r.stylize(\"[Object]\", \"special\");\n          }\n        }\n\n        r.seen.push(t);\n        var l;\n\n        if (c) {\n          l = formatArray(r, t, n, f, a);\n        } else {\n          l = a.map(function (e) {\n            return formatProperty(r, t, n, f, e, c);\n          });\n        }\n\n        r.seen.pop();\n        return reduceToSingleString(l, s, y);\n      }\n\n      function formatPrimitive(r, e) {\n        if (isUndefined(e)) return r.stylize(\"undefined\", \"undefined\");\n\n        if (isString(e)) {\n          var t = \"'\" + JSON.stringify(e).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n          return r.stylize(t, \"string\");\n        }\n\n        if (isNumber(e)) return r.stylize(\"\" + e, \"number\");\n        if (isBoolean(e)) return r.stylize(\"\" + e, \"boolean\");\n        if (isNull(e)) return r.stylize(\"null\", \"null\");\n      }\n\n      function formatError(r) {\n        return \"[\" + Error.prototype.toString.call(r) + \"]\";\n      }\n\n      function formatArray(r, e, t, n, o) {\n        var i = [];\n\n        for (var a = 0, f = e.length; a < f; ++a) {\n          if (hasOwnProperty(e, String(a))) {\n            i.push(formatProperty(r, e, t, n, String(a), true));\n          } else {\n            i.push(\"\");\n          }\n        }\n\n        o.forEach(function (o) {\n          if (!o.match(/^\\d+$/)) {\n            i.push(formatProperty(r, e, t, n, o, true));\n          }\n        });\n        return i;\n      }\n\n      function formatProperty(r, e, t, n, o, i) {\n        var a, f, u;\n        u = Object.getOwnPropertyDescriptor(e, o) || {\n          value: e[o]\n        };\n\n        if (u.get) {\n          if (u.set) {\n            f = r.stylize(\"[Getter/Setter]\", \"special\");\n          } else {\n            f = r.stylize(\"[Getter]\", \"special\");\n          }\n        } else {\n          if (u.set) {\n            f = r.stylize(\"[Setter]\", \"special\");\n          }\n        }\n\n        if (!hasOwnProperty(n, o)) {\n          a = \"[\" + o + \"]\";\n        }\n\n        if (!f) {\n          if (r.seen.indexOf(u.value) < 0) {\n            if (isNull(t)) {\n              f = formatValue(r, u.value, null);\n            } else {\n              f = formatValue(r, u.value, t - 1);\n            }\n\n            if (f.indexOf(\"\\n\") > -1) {\n              if (i) {\n                f = f.split(\"\\n\").map(function (r) {\n                  return \"  \" + r;\n                }).join(\"\\n\").substr(2);\n              } else {\n                f = \"\\n\" + f.split(\"\\n\").map(function (r) {\n                  return \"   \" + r;\n                }).join(\"\\n\");\n              }\n            }\n          } else {\n            f = r.stylize(\"[Circular]\", \"special\");\n          }\n        }\n\n        if (isUndefined(a)) {\n          if (i && o.match(/^\\d+$/)) {\n            return f;\n          }\n\n          a = JSON.stringify(\"\" + o);\n\n          if (a.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n            a = a.substr(1, a.length - 2);\n            a = r.stylize(a, \"name\");\n          } else {\n            a = a.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n            a = r.stylize(a, \"string\");\n          }\n        }\n\n        return a + \": \" + f;\n      }\n\n      function reduceToSingleString(r, e, t) {\n        var n = 0;\n        var o = r.reduce(function (r, e) {\n          n++;\n          if (e.indexOf(\"\\n\") >= 0) n++;\n          return r + e.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n        }, 0);\n\n        if (o > 60) {\n          return t[0] + (e === \"\" ? \"\" : e + \"\\n \") + \" \" + r.join(\",\\n  \") + \" \" + t[1];\n        }\n\n        return t[0] + e + \" \" + r.join(\", \") + \" \" + t[1];\n      }\n\n      e.types = t(989);\n\n      function isArray(r) {\n        return Array.isArray(r);\n      }\n\n      e.isArray = isArray;\n\n      function isBoolean(r) {\n        return typeof r === \"boolean\";\n      }\n\n      e.isBoolean = isBoolean;\n\n      function isNull(r) {\n        return r === null;\n      }\n\n      e.isNull = isNull;\n\n      function isNullOrUndefined(r) {\n        return r == null;\n      }\n\n      e.isNullOrUndefined = isNullOrUndefined;\n\n      function isNumber(r) {\n        return typeof r === \"number\";\n      }\n\n      e.isNumber = isNumber;\n\n      function isString(r) {\n        return typeof r === \"string\";\n      }\n\n      e.isString = isString;\n\n      function isSymbol(r) {\n        return typeof r === \"symbol\";\n      }\n\n      e.isSymbol = isSymbol;\n\n      function isUndefined(r) {\n        return r === void 0;\n      }\n\n      e.isUndefined = isUndefined;\n\n      function isRegExp(r) {\n        return isObject(r) && objectToString(r) === \"[object RegExp]\";\n      }\n\n      e.isRegExp = isRegExp;\n      e.types.isRegExp = isRegExp;\n\n      function isObject(r) {\n        return typeof r === \"object\" && r !== null;\n      }\n\n      e.isObject = isObject;\n\n      function isDate(r) {\n        return isObject(r) && objectToString(r) === \"[object Date]\";\n      }\n\n      e.isDate = isDate;\n      e.types.isDate = isDate;\n\n      function isError(r) {\n        return isObject(r) && (objectToString(r) === \"[object Error]\" || r instanceof Error);\n      }\n\n      e.isError = isError;\n      e.types.isNativeError = isError;\n\n      function isFunction(r) {\n        return typeof r === \"function\";\n      }\n\n      e.isFunction = isFunction;\n\n      function isPrimitive(r) {\n        return r === null || typeof r === \"boolean\" || typeof r === \"number\" || typeof r === \"string\" || typeof r === \"symbol\" || typeof r === \"undefined\";\n      }\n\n      e.isPrimitive = isPrimitive;\n      e.isBuffer = t(913);\n\n      function objectToString(r) {\n        return Object.prototype.toString.call(r);\n      }\n\n      function pad(r) {\n        return r < 10 ? \"0\" + r.toString(10) : r.toString(10);\n      }\n\n      var u = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n      function timestamp() {\n        var r = new Date();\n        var e = [pad(r.getHours()), pad(r.getMinutes()), pad(r.getSeconds())].join(\":\");\n        return [r.getDate(), u[r.getMonth()], e].join(\" \");\n      }\n\n      e.log = function () {\n        console.log(\"%s - %s\", timestamp(), e.format.apply(e, arguments));\n      };\n\n      e.inherits = t(140);\n\n      e._extend = function (r, e) {\n        if (!e || !isObject(e)) return r;\n        var t = Object.keys(e);\n        var n = t.length;\n\n        while (n--) {\n          r[t[n]] = e[t[n]];\n        }\n\n        return r;\n      };\n\n      function hasOwnProperty(r, e) {\n        return Object.prototype.hasOwnProperty.call(r, e);\n      }\n\n      var s = typeof Symbol !== \"undefined\" ? Symbol(\"util.promisify.custom\") : undefined;\n\n      e.promisify = function promisify(r) {\n        if (typeof r !== \"function\") throw new TypeError('The \"original\" argument must be of type Function');\n\n        if (s && r[s]) {\n          var e = r[s];\n\n          if (typeof e !== \"function\") {\n            throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n          }\n\n          Object.defineProperty(e, s, {\n            value: e,\n            enumerable: false,\n            writable: false,\n            configurable: true\n          });\n          return e;\n        }\n\n        function e() {\n          var e, t;\n          var n = new Promise(function (r, n) {\n            e = r;\n            t = n;\n          });\n          var o = [];\n\n          for (var i = 0; i < arguments.length; i++) {\n            o.push(arguments[i]);\n          }\n\n          o.push(function (r, n) {\n            if (r) {\n              t(r);\n            } else {\n              e(n);\n            }\n          });\n\n          try {\n            r.apply(this, o);\n          } catch (r) {\n            t(r);\n          }\n\n          return n;\n        }\n\n        Object.setPrototypeOf(e, Object.getPrototypeOf(r));\n        if (s) Object.defineProperty(e, s, {\n          value: e,\n          enumerable: false,\n          writable: false,\n          configurable: true\n        });\n        return Object.defineProperties(e, n(r));\n      };\n\n      e.promisify.custom = s;\n\n      function callbackifyOnRejected(r, e) {\n        if (!r) {\n          var t = new Error(\"Promise was rejected with a falsy value\");\n          t.reason = r;\n          r = t;\n        }\n\n        return e(r);\n      }\n\n      function callbackify(r) {\n        if (typeof r !== \"function\") {\n          throw new TypeError('The \"original\" argument must be of type Function');\n        }\n\n        function callbackified() {\n          var e = [];\n\n          for (var t = 0; t < arguments.length; t++) {\n            e.push(arguments[t]);\n          }\n\n          var n = e.pop();\n\n          if (typeof n !== \"function\") {\n            throw new TypeError(\"The last argument must be of type Function\");\n          }\n\n          var o = this;\n\n          var cb = function () {\n            return n.apply(o, arguments);\n          };\n\n          r.apply(this, e).then(function (r) {\n            process.nextTick(cb.bind(null, null, r));\n          }, function (r) {\n            process.nextTick(callbackifyOnRejected.bind(null, r, cb));\n          });\n        }\n\n        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(r));\n        Object.defineProperties(callbackified, n(r));\n        return callbackified;\n      }\n\n      e.callbackify = callbackify;\n    },\n    728: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(981);\n      var o = t(382);\n      var i = t(171);\n      var a = i(\"Object.prototype.toString\");\n      var f = t(567)();\n      var u = f && typeof Symbol.toStringTag === \"symbol\";\n      var s = o();\n      var c = i(\"String.prototype.slice\");\n      var y = {};\n      var p = t(30);\n      var l = Object.getPrototypeOf;\n\n      if (u && p && l) {\n        n(s, function (r) {\n          if (typeof __webpack_require__.g[r] === \"function\") {\n            var e = new __webpack_require__.g[r]();\n\n            if (!(Symbol.toStringTag in e)) {\n              throw new EvalError(\"this engine has support for Symbol.toStringTag, but \" + r + \" does not have the property! Please report this.\");\n            }\n\n            var t = l(e);\n            var n = p(t, Symbol.toStringTag);\n\n            if (!n) {\n              var o = l(t);\n              n = p(o, Symbol.toStringTag);\n            }\n\n            y[r] = n.get;\n          }\n        });\n      }\n\n      var g = function tryAllTypedArrays(r) {\n        var e = false;\n        n(y, function (t, n) {\n          if (!e) {\n            try {\n              var o = t.call(r);\n\n              if (o === n) {\n                e = o;\n              }\n            } catch (r) {}\n          }\n        });\n        return e;\n      };\n\n      var d = t(387);\n\n      r.exports = function whichTypedArray(r) {\n        if (!d(r)) {\n          return false;\n        }\n\n        if (!u) {\n          return c(a(r), 8, -1);\n        }\n\n        return g(r);\n      };\n    },\n    382: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(997);\n\n      r.exports = function availableTypedArrays() {\n        return n([\"BigInt64Array\", \"BigUint64Array\", \"Float32Array\", \"Float64Array\", \"Int16Array\", \"Int32Array\", \"Int8Array\", \"Uint16Array\", \"Uint32Array\", \"Uint8Array\", \"Uint8ClampedArray\"], function (r) {\n          return typeof __webpack_require__.g[r] === \"function\";\n        });\n      };\n    },\n    30: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(627);\n      var o = n(\"%Object.getOwnPropertyDescriptor%\", true);\n\n      if (o) {\n        try {\n          o([], \"length\");\n        } catch (r) {\n          o = null;\n        }\n      }\n\n      r.exports = o;\n    }\n  };\n  var e = {};\n\n  function __nccwpck_require__(t) {\n    var n = e[t];\n\n    if (n !== undefined) {\n      return n.exports;\n    }\n\n    var o = e[t] = {\n      exports: {}\n    };\n    var i = true;\n\n    try {\n      r[t](o, o.exports, __nccwpck_require__);\n      i = false;\n    } finally {\n      if (i) delete e[t];\n    }\n\n    return o.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var t = __nccwpck_require__(467);\n\n  module.exports = t;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3V0aWwvdXRpbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxDQUFDLFlBQVU7RUFBQyxJQUFJQSxDQUFDLEdBQUM7SUFBQyxLQUFJLFVBQVNBLENBQVQsRUFBVztNQUFDQSxDQUFDLENBQUNDLE9BQUYsR0FBVSxVQUFTRCxDQUFULEVBQVdFLENBQVgsRUFBYUMsQ0FBYixFQUFlO1FBQUMsSUFBR0gsQ0FBQyxDQUFDSSxNQUFMLEVBQVksT0FBT0osQ0FBQyxDQUFDSSxNQUFGLENBQVNGLENBQVQsRUFBV0MsQ0FBWCxDQUFQO1FBQXFCLElBQUcsS0FBSyxDQUFMLEtBQVNILENBQVQsSUFBWSxTQUFPQSxDQUF0QixFQUF3QixNQUFNLElBQUlLLFNBQUosRUFBTjtRQUFvQixJQUFHLGNBQVksT0FBT0gsQ0FBdEIsRUFBd0IsTUFBTSxJQUFJRyxTQUFKLEVBQU47UUFBb0IsSUFBSUMsQ0FBQyxHQUFDLEVBQU47O1FBQVMsS0FBSSxJQUFJQyxDQUFDLEdBQUMsQ0FBVixFQUFZQSxDQUFDLEdBQUNQLENBQUMsQ0FBQ1EsTUFBaEIsRUFBdUJELENBQUMsRUFBeEIsRUFBMkI7VUFBQyxJQUFHLENBQUNFLENBQUMsQ0FBQ0MsSUFBRixDQUFPVixDQUFQLEVBQVNPLENBQVQsQ0FBSixFQUFnQjtVQUFTLElBQUlJLENBQUMsR0FBQ1gsQ0FBQyxDQUFDTyxDQUFELENBQVA7VUFBVyxJQUFHTCxDQUFDLENBQUNRLElBQUYsQ0FBT1AsQ0FBUCxFQUFTUSxDQUFULEVBQVdKLENBQVgsRUFBYVAsQ0FBYixDQUFILEVBQW1CTSxDQUFDLENBQUNNLElBQUYsQ0FBT0QsQ0FBUDtRQUFVOztRQUFBLE9BQU9MLENBQVA7TUFBUyxDQUFsUTs7TUFBbVEsSUFBSUcsQ0FBQyxHQUFDSSxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLGNBQXZCO0lBQXNDLENBQTFUO0lBQTJULEtBQUksVUFBU2YsQ0FBVCxFQUFXUyxDQUFYLEVBQWFQLENB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aXN0L2NvbXBpbGVkL3V0aWwvdXRpbC5qcz9hYzE0Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciByPXs5OTc6ZnVuY3Rpb24ocil7ci5leHBvcnRzPWZ1bmN0aW9uKHIsdCxuKXtpZihyLmZpbHRlcilyZXR1cm4gci5maWx0ZXIodCxuKTtpZih2b2lkIDA9PT1yfHxudWxsPT09cil0aHJvdyBuZXcgVHlwZUVycm9yO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgbz1bXTtmb3IodmFyIGk9MDtpPHIubGVuZ3RoO2krKyl7aWYoIWUuY2FsbChyLGkpKWNvbnRpbnVlO3ZhciBhPXJbaV07aWYodC5jYWxsKG4sYSxpLHIpKW8ucHVzaChhKX1yZXR1cm4gb307dmFyIGU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eX0sMTcxOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KDYyNyk7dmFyIG89dCgzMDIpO3ZhciBpPW8obihcIlN0cmluZy5wcm90b3R5cGUuaW5kZXhPZlwiKSk7ci5leHBvcnRzPWZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhyLGUpe3ZhciB0PW4ociwhIWUpO2lmKHR5cGVvZiB0PT09XCJmdW5jdGlvblwiJiZpKHIsXCIucHJvdG90eXBlLlwiKT4tMSl7cmV0dXJuIG8odCl9cmV0dXJuIHR9fSwzMDI6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoMTk0KTt2YXIgbz10KDYyNyk7dmFyIGk9byhcIiVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklXCIpO3ZhciBhPW8oXCIlRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlXCIpO3ZhciBmPW8oXCIlUmVmbGVjdC5hcHBseSVcIix0cnVlKXx8bi5jYWxsKGEsaSk7dmFyIHU9byhcIiVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJVwiLHRydWUpO3ZhciBzPW8oXCIlT2JqZWN0LmRlZmluZVByb3BlcnR5JVwiLHRydWUpO3ZhciBjPW8oXCIlTWF0aC5tYXglXCIpO2lmKHMpe3RyeXtzKHt9LFwiYVwiLHt2YWx1ZToxfSl9Y2F0Y2gocil7cz1udWxsfX1yLmV4cG9ydHM9ZnVuY3Rpb24gY2FsbEJpbmQocil7dmFyIGU9ZihuLGEsYXJndW1lbnRzKTtpZih1JiZzKXt2YXIgdD11KGUsXCJsZW5ndGhcIik7aWYodC5jb25maWd1cmFibGUpe3MoZSxcImxlbmd0aFwiLHt2YWx1ZToxK2MoMCxyLmxlbmd0aC0oYXJndW1lbnRzLmxlbmd0aC0xKSl9KX19cmV0dXJuIGV9O3ZhciB5PWZ1bmN0aW9uIGFwcGx5QmluZCgpe3JldHVybiBmKG4saSxhcmd1bWVudHMpfTtpZihzKXtzKHIuZXhwb3J0cyxcImFwcGx5XCIse3ZhbHVlOnl9KX1lbHNle3IuZXhwb3J0cy5hcHBseT15fX0sOTgxOmZ1bmN0aW9uKHIpe3ZhciBlPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztyLmV4cG9ydHM9ZnVuY3Rpb24gZm9yRWFjaChyLG4sbyl7aWYodC5jYWxsKG4pIT09XCJbb2JqZWN0IEZ1bmN0aW9uXVwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpfXZhciBpPXIubGVuZ3RoO2lmKGk9PT0raSl7Zm9yKHZhciBhPTA7YTxpO2ErKyl7bi5jYWxsKG8sclthXSxhLHIpfX1lbHNle2Zvcih2YXIgZiBpbiByKXtpZihlLmNhbGwocixmKSl7bi5jYWxsKG8scltmXSxmLHIpfX19fX0sODYxOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3ZhciBlPVwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSBcIjt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2U7dmFyIG49T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgbz1cIltvYmplY3QgRnVuY3Rpb25dXCI7ci5leHBvcnRzPWZ1bmN0aW9uIGJpbmQocil7dmFyIGk9dGhpcztpZih0eXBlb2YgaSE9PVwiZnVuY3Rpb25cInx8bi5jYWxsKGkpIT09byl7dGhyb3cgbmV3IFR5cGVFcnJvcihlK2kpfXZhciBhPXQuY2FsbChhcmd1bWVudHMsMSk7dmFyIGY7dmFyIGJpbmRlcj1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiBmKXt2YXIgZT1pLmFwcGx5KHRoaXMsYS5jb25jYXQodC5jYWxsKGFyZ3VtZW50cykpKTtpZihPYmplY3QoZSk9PT1lKXtyZXR1cm4gZX1yZXR1cm4gdGhpc31lbHNle3JldHVybiBpLmFwcGx5KHIsYS5jb25jYXQodC5jYWxsKGFyZ3VtZW50cykpKX19O3ZhciB1PU1hdGgubWF4KDAsaS5sZW5ndGgtYS5sZW5ndGgpO3ZhciBzPVtdO2Zvcih2YXIgYz0wO2M8dTtjKyspe3MucHVzaChcIiRcIitjKX1mPUZ1bmN0aW9uKFwiYmluZGVyXCIsXCJyZXR1cm4gZnVuY3Rpb24gKFwiK3Muam9pbihcIixcIikrXCIpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfVwiKShiaW5kZXIpO2lmKGkucHJvdG90eXBlKXt2YXIgeT1mdW5jdGlvbiBFbXB0eSgpe307eS5wcm90b3R5cGU9aS5wcm90b3R5cGU7Zi5wcm90b3R5cGU9bmV3IHk7eS5wcm90b3R5cGU9bnVsbH1yZXR1cm4gZn19LDE5NDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCg4NjEpO3IuZXhwb3J0cz1GdW5jdGlvbi5wcm90b3R5cGUuYmluZHx8bn0sNjI3OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbjt2YXIgbz1TeW50YXhFcnJvcjt2YXIgaT1GdW5jdGlvbjt2YXIgYT1UeXBlRXJyb3I7dmFyIGdldEV2YWxsZWRDb25zdHJ1Y3Rvcj1mdW5jdGlvbihyKXt0cnl7cmV0dXJuIGkoJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcrcitcIikuY29uc3RydWN0b3I7XCIpKCl9Y2F0Y2gocil7fX07dmFyIGY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtpZihmKXt0cnl7Zih7fSxcIlwiKX1jYXRjaChyKXtmPW51bGx9fXZhciB0aHJvd1R5cGVFcnJvcj1mdW5jdGlvbigpe3Rocm93IG5ldyBhfTt2YXIgdT1mP2Z1bmN0aW9uKCl7dHJ5e2FyZ3VtZW50cy5jYWxsZWU7cmV0dXJuIHRocm93VHlwZUVycm9yfWNhdGNoKHIpe3RyeXtyZXR1cm4gZihhcmd1bWVudHMsXCJjYWxsZWVcIikuZ2V0fWNhdGNoKHIpe3JldHVybiB0aHJvd1R5cGVFcnJvcn19fSgpOnRocm93VHlwZUVycm9yO3ZhciBzPXQoNTY3KSgpO3ZhciBjPU9iamVjdC5nZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24ocil7cmV0dXJuIHIuX19wcm90b19ffTt2YXIgeT17fTt2YXIgcD10eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bjpjKFVpbnQ4QXJyYXkpO3ZhciBsPXtcIiVBZ2dyZWdhdGVFcnJvciVcIjp0eXBlb2YgQWdncmVnYXRlRXJyb3I9PT1cInVuZGVmaW5lZFwiP246QWdncmVnYXRlRXJyb3IsXCIlQXJyYXklXCI6QXJyYXksXCIlQXJyYXlCdWZmZXIlXCI6dHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9uOkFycmF5QnVmZmVyLFwiJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlXCI6cz9jKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk6bixcIiVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlXCI6bixcIiVBc3luY0Z1bmN0aW9uJVwiOnksXCIlQXN5bmNHZW5lcmF0b3IlXCI6eSxcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiOnksXCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIjp5LFwiJUF0b21pY3MlXCI6dHlwZW9mIEF0b21pY3M9PT1cInVuZGVmaW5lZFwiP246QXRvbWljcyxcIiVCaWdJbnQlXCI6dHlwZW9mIEJpZ0ludD09PVwidW5kZWZpbmVkXCI/bjpCaWdJbnQsXCIlQm9vbGVhbiVcIjpCb29sZWFuLFwiJURhdGFWaWV3JVwiOnR5cGVvZiBEYXRhVmlldz09PVwidW5kZWZpbmVkXCI/bjpEYXRhVmlldyxcIiVEYXRlJVwiOkRhdGUsXCIlZGVjb2RlVVJJJVwiOmRlY29kZVVSSSxcIiVkZWNvZGVVUklDb21wb25lbnQlXCI6ZGVjb2RlVVJJQ29tcG9uZW50LFwiJWVuY29kZVVSSSVcIjplbmNvZGVVUkksXCIlZW5jb2RlVVJJQ29tcG9uZW50JVwiOmVuY29kZVVSSUNvbXBvbmVudCxcIiVFcnJvciVcIjpFcnJvcixcIiVldmFsJVwiOmV2YWwsXCIlRXZhbEVycm9yJVwiOkV2YWxFcnJvcixcIiVGbG9hdDMyQXJyYXklXCI6dHlwZW9mIEZsb2F0MzJBcnJheT09PVwidW5kZWZpbmVkXCI/bjpGbG9hdDMyQXJyYXksXCIlRmxvYXQ2NEFycmF5JVwiOnR5cGVvZiBGbG9hdDY0QXJyYXk9PT1cInVuZGVmaW5lZFwiP246RmxvYXQ2NEFycmF5LFwiJUZpbmFsaXphdGlvblJlZ2lzdHJ5JVwiOnR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeT09PVwidW5kZWZpbmVkXCI/bjpGaW5hbGl6YXRpb25SZWdpc3RyeSxcIiVGdW5jdGlvbiVcIjppLFwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiOnksXCIlSW50OEFycmF5JVwiOnR5cGVvZiBJbnQ4QXJyYXk9PT1cInVuZGVmaW5lZFwiP246SW50OEFycmF5LFwiJUludDE2QXJyYXklXCI6dHlwZW9mIEludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP246SW50MTZBcnJheSxcIiVJbnQzMkFycmF5JVwiOnR5cGVvZiBJbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9uOkludDMyQXJyYXksXCIlaXNGaW5pdGUlXCI6aXNGaW5pdGUsXCIlaXNOYU4lXCI6aXNOYU4sXCIlSXRlcmF0b3JQcm90b3R5cGUlXCI6cz9jKGMoW11bU3ltYm9sLml0ZXJhdG9yXSgpKSk6bixcIiVKU09OJVwiOnR5cGVvZiBKU09OPT09XCJvYmplY3RcIj9KU09OOm4sXCIlTWFwJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwiP246TWFwLFwiJU1hcEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwifHwhcz9uOmMoKG5ldyBNYXApW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlTWF0aCVcIjpNYXRoLFwiJU51bWJlciVcIjpOdW1iZXIsXCIlT2JqZWN0JVwiOk9iamVjdCxcIiVwYXJzZUZsb2F0JVwiOnBhcnNlRmxvYXQsXCIlcGFyc2VJbnQlXCI6cGFyc2VJbnQsXCIlUHJvbWlzZSVcIjp0eXBlb2YgUHJvbWlzZT09PVwidW5kZWZpbmVkXCI/bjpQcm9taXNlLFwiJVByb3h5JVwiOnR5cGVvZiBQcm94eT09PVwidW5kZWZpbmVkXCI/bjpQcm94eSxcIiVSYW5nZUVycm9yJVwiOlJhbmdlRXJyb3IsXCIlUmVmZXJlbmNlRXJyb3IlXCI6UmVmZXJlbmNlRXJyb3IsXCIlUmVmbGVjdCVcIjp0eXBlb2YgUmVmbGVjdD09PVwidW5kZWZpbmVkXCI/bjpSZWZsZWN0LFwiJVJlZ0V4cCVcIjpSZWdFeHAsXCIlU2V0JVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiP246U2V0LFwiJVNldEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwifHwhcz9uOmMoKG5ldyBTZXQpW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlU2hhcmVkQXJyYXlCdWZmZXIlXCI6dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9uOlNoYXJlZEFycmF5QnVmZmVyLFwiJVN0cmluZyVcIjpTdHJpbmcsXCIlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlXCI6cz9jKFwiXCJbU3ltYm9sLml0ZXJhdG9yXSgpKTpuLFwiJVN5bWJvbCVcIjpzP1N5bWJvbDpuLFwiJVN5bnRheEVycm9yJVwiOm8sXCIlVGhyb3dUeXBlRXJyb3IlXCI6dSxcIiVUeXBlZEFycmF5JVwiOnAsXCIlVHlwZUVycm9yJVwiOmEsXCIlVWludDhBcnJheSVcIjp0eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bjpVaW50OEFycmF5LFwiJVVpbnQ4Q2xhbXBlZEFycmF5JVwiOnR5cGVvZiBVaW50OENsYW1wZWRBcnJheT09PVwidW5kZWZpbmVkXCI/bjpVaW50OENsYW1wZWRBcnJheSxcIiVVaW50MTZBcnJheSVcIjp0eXBlb2YgVWludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP246VWludDE2QXJyYXksXCIlVWludDMyQXJyYXklXCI6dHlwZW9mIFVpbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9uOlVpbnQzMkFycmF5LFwiJVVSSUVycm9yJVwiOlVSSUVycm9yLFwiJVdlYWtNYXAlXCI6dHlwZW9mIFdlYWtNYXA9PT1cInVuZGVmaW5lZFwiP246V2Vha01hcCxcIiVXZWFrUmVmJVwiOnR5cGVvZiBXZWFrUmVmPT09XCJ1bmRlZmluZWRcIj9uOldlYWtSZWYsXCIlV2Vha1NldCVcIjp0eXBlb2YgV2Vha1NldD09PVwidW5kZWZpbmVkXCI/bjpXZWFrU2V0fTt2YXIgZz1mdW5jdGlvbiBkb0V2YWwocil7dmFyIGU7aWYocj09PVwiJUFzeW5jRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24gKCkge31cIil9ZWxzZSBpZihyPT09XCIlR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yJVwiKXt2YXIgdD1kb0V2YWwoXCIlQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiVcIik7aWYodCl7ZT10LnByb3RvdHlwZX19ZWxzZSBpZihyPT09XCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIil7dmFyIG49ZG9FdmFsKFwiJUFzeW5jR2VuZXJhdG9yJVwiKTtpZihuKXtlPWMobi5wcm90b3R5cGUpfX1sW3JdPWU7cmV0dXJuIGV9O3ZhciBkPXtcIiVBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjpbXCJBcnJheUJ1ZmZlclwiLFwicHJvdG90eXBlXCJdLFwiJUFycmF5UHJvdG90eXBlJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlQXJyYXlQcm90b19lbnRyaWVzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImVudHJpZXNcIl0sXCIlQXJyYXlQcm90b19mb3JFYWNoJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImZvckVhY2hcIl0sXCIlQXJyYXlQcm90b19rZXlzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImtleXNcIl0sXCIlQXJyYXlQcm90b192YWx1ZXMlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwidmFsdWVzXCJdLFwiJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiQXN5bmNGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUFzeW5jR2VuZXJhdG9yJVwiOltcIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVBc3luY0dlbmVyYXRvclByb3RvdHlwZSVcIjpbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIixcInByb3RvdHlwZVwiXSxcIiVCb29sZWFuUHJvdG90eXBlJVwiOltcIkJvb2xlYW5cIixcInByb3RvdHlwZVwiXSxcIiVEYXRhVmlld1Byb3RvdHlwZSVcIjpbXCJEYXRhVmlld1wiLFwicHJvdG90eXBlXCJdLFwiJURhdGVQcm90b3R5cGUlXCI6W1wiRGF0ZVwiLFwicHJvdG90eXBlXCJdLFwiJUVycm9yUHJvdG90eXBlJVwiOltcIkVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlRXZhbEVycm9yUHJvdG90eXBlJVwiOltcIkV2YWxFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJUZsb2F0MzJBcnJheVByb3RvdHlwZSVcIjpbXCJGbG9hdDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVGbG9hdDY0QXJyYXlQcm90b3R5cGUlXCI6W1wiRmxvYXQ2NEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3IlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3JQcm90b3R5cGUlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiLFwicHJvdG90eXBlXCJdLFwiJUludDhBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIkludDE2QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQzMkFycmF5UHJvdG90eXBlJVwiOltcIkludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVKU09OUGFyc2UlXCI6W1wiSlNPTlwiLFwicGFyc2VcIl0sXCIlSlNPTlN0cmluZ2lmeSVcIjpbXCJKU09OXCIsXCJzdHJpbmdpZnlcIl0sXCIlTWFwUHJvdG90eXBlJVwiOltcIk1hcFwiLFwicHJvdG90eXBlXCJdLFwiJU51bWJlclByb3RvdHlwZSVcIjpbXCJOdW1iZXJcIixcInByb3RvdHlwZVwiXSxcIiVPYmplY3RQcm90b3R5cGUlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIl0sXCIlT2JqUHJvdG9fdG9TdHJpbmclXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInRvU3RyaW5nXCJdLFwiJU9ialByb3RvX3ZhbHVlT2YlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInZhbHVlT2ZcIl0sXCIlUHJvbWlzZVByb3RvdHlwZSVcIjpbXCJQcm9taXNlXCIsXCJwcm90b3R5cGVcIl0sXCIlUHJvbWlzZVByb3RvX3RoZW4lXCI6W1wiUHJvbWlzZVwiLFwicHJvdG90eXBlXCIsXCJ0aGVuXCJdLFwiJVByb21pc2VfYWxsJVwiOltcIlByb21pc2VcIixcImFsbFwiXSxcIiVQcm9taXNlX3JlamVjdCVcIjpbXCJQcm9taXNlXCIsXCJyZWplY3RcIl0sXCIlUHJvbWlzZV9yZXNvbHZlJVwiOltcIlByb21pc2VcIixcInJlc29sdmVcIl0sXCIlUmFuZ2VFcnJvclByb3RvdHlwZSVcIjpbXCJSYW5nZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlXCI6W1wiUmVmZXJlbmNlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVSZWdFeHBQcm90b3R5cGUlXCI6W1wiUmVnRXhwXCIsXCJwcm90b3R5cGVcIl0sXCIlU2V0UHJvdG90eXBlJVwiOltcIlNldFwiLFwicHJvdG90eXBlXCJdLFwiJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJVwiOltcIlNoYXJlZEFycmF5QnVmZmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlU3RyaW5nUHJvdG90eXBlJVwiOltcIlN0cmluZ1wiLFwicHJvdG90eXBlXCJdLFwiJVN5bWJvbFByb3RvdHlwZSVcIjpbXCJTeW1ib2xcIixcInByb3RvdHlwZVwiXSxcIiVTeW50YXhFcnJvclByb3RvdHlwZSVcIjpbXCJTeW50YXhFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVkQXJyYXlQcm90b3R5cGUlXCI6W1wiVHlwZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVFcnJvclByb3RvdHlwZSVcIjpbXCJUeXBlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OEFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50OENsYW1wZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQxNkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVUklFcnJvclByb3RvdHlwZSVcIjpbXCJVUklFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtNYXBQcm90b3R5cGUlXCI6W1wiV2Vha01hcFwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtTZXRQcm90b3R5cGUlXCI6W1wiV2Vha1NldFwiLFwicHJvdG90eXBlXCJdfTt2YXIgdj10KDE5NCk7dmFyIGI9dCg2NDYpO3ZhciBBPXYuY2FsbChGdW5jdGlvbi5jYWxsLEFycmF5LnByb3RvdHlwZS5jb25jYXQpO3ZhciBtPXYuY2FsbChGdW5jdGlvbi5hcHBseSxBcnJheS5wcm90b3R5cGUuc3BsaWNlKTt2YXIgUz12LmNhbGwoRnVuY3Rpb24uY2FsbCxTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO3ZhciBoPXYuY2FsbChGdW5jdGlvbi5jYWxsLFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO3ZhciBPPS9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO3ZhciB3PS9cXFxcKFxcXFwpPy9nO3ZhciBqPWZ1bmN0aW9uIHN0cmluZ1RvUGF0aChyKXt2YXIgZT1oKHIsMCwxKTt2YXIgdD1oKHIsLTEpO2lmKGU9PT1cIiVcIiYmdCE9PVwiJVwiKXt0aHJvdyBuZXcgbyhcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWBcIil9ZWxzZSBpZih0PT09XCIlXCImJmUhPT1cIiVcIil7dGhyb3cgbmV3IG8oXCJpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgXCIpfXZhciBuPVtdO1MocixPLChmdW5jdGlvbihyLGUsdCxvKXtuW24ubGVuZ3RoXT10P1Mobyx3LFwiJDFcIik6ZXx8cn0pKTtyZXR1cm4gbn07dmFyIFA9ZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhyLGUpe3ZhciB0PXI7dmFyIG47aWYoYihkLHQpKXtuPWRbdF07dD1cIiVcIituWzBdK1wiJVwifWlmKGIobCx0KSl7dmFyIGk9bFt0XTtpZihpPT09eSl7aT1nKHQpfWlmKHR5cGVvZiBpPT09XCJ1bmRlZmluZWRcIiYmIWUpe3Rocm93IG5ldyBhKFwiaW50cmluc2ljIFwiK3IrXCIgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhXCIpfXJldHVybnthbGlhczpuLG5hbWU6dCx2YWx1ZTppfX10aHJvdyBuZXcgbyhcImludHJpbnNpYyBcIityK1wiIGRvZXMgbm90IGV4aXN0IVwiKX07ci5leHBvcnRzPWZ1bmN0aW9uIEdldEludHJpbnNpYyhyLGUpe2lmKHR5cGVvZiByIT09XCJzdHJpbmdcInx8ci5sZW5ndGg9PT0wKXt0aHJvdyBuZXcgYShcImludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWlmKGFyZ3VtZW50cy5sZW5ndGg+MSYmdHlwZW9mIGUhPT1cImJvb2xlYW5cIil7dGhyb3cgbmV3IGEoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKX12YXIgdD1qKHIpO3ZhciBpPXQubGVuZ3RoPjA/dFswXTpcIlwiO3ZhciB1PVAoXCIlXCIraStcIiVcIixlKTt2YXIgcz11Lm5hbWU7dmFyIGM9dS52YWx1ZTt2YXIgeT1mYWxzZTt2YXIgcD11LmFsaWFzO2lmKHApe2k9cFswXTttKHQsQShbMCwxXSxwKSl9Zm9yKHZhciBnPTEsZD10cnVlO2c8dC5sZW5ndGg7Zys9MSl7dmFyIHY9dFtnXTt2YXIgUz1oKHYsMCwxKTt2YXIgTz1oKHYsLTEpO2lmKChTPT09J1wiJ3x8Uz09PVwiJ1wifHxTPT09XCJgXCJ8fChPPT09J1wiJ3x8Tz09PVwiJ1wifHxPPT09XCJgXCIpKSYmUyE9PU8pe3Rocm93IG5ldyBvKFwicHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3Rlc1wiKX1pZih2PT09XCJjb25zdHJ1Y3RvclwifHwhZCl7eT10cnVlfWkrPVwiLlwiK3Y7cz1cIiVcIitpK1wiJVwiO2lmKGIobCxzKSl7Yz1sW3NdfWVsc2UgaWYoYyE9bnVsbCl7aWYoISh2IGluIGMpKXtpZighZSl7dGhyb3cgbmV3IGEoXCJiYXNlIGludHJpbnNpYyBmb3IgXCIrcitcIiBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS5cIil9cmV0dXJuIHZvaWQgbn1pZihmJiZnKzE+PXQubGVuZ3RoKXt2YXIgdz1mKGMsdik7ZD0hIXc7aWYoZCYmXCJnZXRcImluIHcmJiEoXCJvcmlnaW5hbFZhbHVlXCJpbiB3LmdldCkpe2M9dy5nZXR9ZWxzZXtjPWNbdl19fWVsc2V7ZD1iKGMsdik7Yz1jW3ZdfWlmKGQmJiF5KXtsW3NdPWN9fX1yZXR1cm4gY319LDU2NzpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dHlwZW9mIFN5bWJvbCE9PVwidW5kZWZpbmVkXCImJlN5bWJvbDt2YXIgbz10KDE4Nik7ci5leHBvcnRzPWZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKXtpZih0eXBlb2YgbiE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBTeW1ib2whPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgbihcImZvb1wiKSE9PVwic3ltYm9sXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sKFwiYmFyXCIpIT09XCJzeW1ib2xcIil7cmV0dXJuIGZhbHNlfXJldHVybiBvKCl9fSwxODY6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7ci5leHBvcnRzPWZ1bmN0aW9uIGhhc1N5bWJvbHMoKXtpZih0eXBlb2YgU3ltYm9sIT09XCJmdW5jdGlvblwifHx0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3I9PT1cInN5bWJvbFwiKXtyZXR1cm4gdHJ1ZX12YXIgcj17fTt2YXIgZT1TeW1ib2woXCJ0ZXN0XCIpO3ZhciB0PU9iamVjdChlKTtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBmYWxzZX1pZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkhPT1cIltvYmplY3QgU3ltYm9sXVwiKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpIT09XCJbb2JqZWN0IFN5bWJvbF1cIil7cmV0dXJuIGZhbHNlfXZhciBuPTQyO3JbZV09bjtmb3IoZSBpbiByKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIE9iamVjdC5rZXlzPT09XCJmdW5jdGlvblwiJiZPYmplY3Qua2V5cyhyKS5sZW5ndGghPT0wKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzPT09XCJmdW5jdGlvblwiJiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhyKS5sZW5ndGghPT0wKXtyZXR1cm4gZmFsc2V9dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhyKTtpZihvLmxlbmd0aCE9PTF8fG9bMF0hPT1lKXtyZXR1cm4gZmFsc2V9aWYoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChyLGUpKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I9PT1cImZ1bmN0aW9uXCIpe3ZhciBpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocixlKTtpZihpLnZhbHVlIT09bnx8aS5lbnVtZXJhYmxlIT09dHJ1ZSl7cmV0dXJuIGZhbHNlfX1yZXR1cm4gdHJ1ZX19LDY0NjpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCgxOTQpO3IuZXhwb3J0cz1uLmNhbGwoRnVuY3Rpb24uY2FsbCxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KX0sMTQwOmZ1bmN0aW9uKHIpe2lmKHR5cGVvZiBPYmplY3QuY3JlYXRlPT09XCJmdW5jdGlvblwiKXtyLmV4cG9ydHM9ZnVuY3Rpb24gaW5oZXJpdHMocixlKXtpZihlKXtyLnN1cGVyXz1lO3IucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpyLGVudW1lcmFibGU6ZmFsc2Usd3JpdGFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZX19KX19fWVsc2V7ci5leHBvcnRzPWZ1bmN0aW9uIGluaGVyaXRzKHIsZSl7aWYoZSl7ci5zdXBlcl89ZTt2YXIgVGVtcEN0b3I9ZnVuY3Rpb24oKXt9O1RlbXBDdG9yLnByb3RvdHlwZT1lLnByb3RvdHlwZTtyLnByb3RvdHlwZT1uZXcgVGVtcEN0b3I7ci5wcm90b3R5cGUuY29uc3RydWN0b3I9cn19fX0sNzQ5OmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3ZhciBlPXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PT1cInN5bWJvbFwiO3ZhciB0PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7dmFyIG49ZnVuY3Rpb24gaXNBcmd1bWVudHMocil7aWYoZSYmciYmdHlwZW9mIHI9PT1cIm9iamVjdFwiJiZTeW1ib2wudG9TdHJpbmdUYWcgaW4gcil7cmV0dXJuIGZhbHNlfXJldHVybiB0LmNhbGwocik9PT1cIltvYmplY3QgQXJndW1lbnRzXVwifTt2YXIgbz1mdW5jdGlvbiBpc0FyZ3VtZW50cyhyKXtpZihuKHIpKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gciE9PW51bGwmJnR5cGVvZiByPT09XCJvYmplY3RcIiYmdHlwZW9mIHIubGVuZ3RoPT09XCJudW1iZXJcIiYmci5sZW5ndGg+PTAmJnQuY2FsbChyKSE9PVwiW29iamVjdCBBcnJheV1cIiYmdC5jYWxsKHIuY2FsbGVlKT09PVwiW29iamVjdCBGdW5jdGlvbl1cIn07dmFyIGk9ZnVuY3Rpb24oKXtyZXR1cm4gbihhcmd1bWVudHMpfSgpO24uaXNMZWdhY3lBcmd1bWVudHM9bztyLmV4cG9ydHM9aT9uOm99LDYxMTpmdW5jdGlvbihyKXtcInVzZSBzdHJpY3RcIjt2YXIgZT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO3ZhciB0PUZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZzt2YXIgbj0vXlxccyooPzpmdW5jdGlvbik/XFwqLzt2YXIgbz10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT09XCJzeW1ib2xcIjt2YXIgaT1PYmplY3QuZ2V0UHJvdG90eXBlT2Y7dmFyIGdldEdlbmVyYXRvckZ1bmM9ZnVuY3Rpb24oKXtpZighbyl7cmV0dXJuIGZhbHNlfXRyeXtyZXR1cm4gRnVuY3Rpb24oXCJyZXR1cm4gZnVuY3Rpb24qKCkge31cIikoKX1jYXRjaChyKXt9fTt2YXIgYT1nZXRHZW5lcmF0b3JGdW5jKCk7dmFyIGY9YT9pKGEpOnt9O3IuZXhwb3J0cz1mdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKHIpe2lmKHR5cGVvZiByIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYobi50ZXN0KHQuY2FsbChyKSkpe3JldHVybiB0cnVlfWlmKCFvKXt2YXIgYT1lLmNhbGwocik7cmV0dXJuIGE9PT1cIltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dXCJ9cmV0dXJuIGkocik9PT1mfX0sMzg3OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KDk4MSk7dmFyIG89dCgzODIpO3ZhciBpPXQoMTcxKTt2YXIgYT1pKFwiT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1wiKTt2YXIgZj10KDU2NykoKTt2YXIgdT1mJiZ0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT09XCJzeW1ib2xcIjt2YXIgcz1vKCk7dmFyIGM9aShcIkFycmF5LnByb3RvdHlwZS5pbmRleE9mXCIsdHJ1ZSl8fGZ1bmN0aW9uIGluZGV4T2YocixlKXtmb3IodmFyIHQ9MDt0PHIubGVuZ3RoO3QrPTEpe2lmKHJbdF09PT1lKXtyZXR1cm4gdH19cmV0dXJuLTF9O3ZhciB5PWkoXCJTdHJpbmcucHJvdG90eXBlLnNsaWNlXCIpO3ZhciBwPXt9O3ZhciBsPXQoMzApO3ZhciBnPU9iamVjdC5nZXRQcm90b3R5cGVPZjtpZih1JiZsJiZnKXtuKHMsKGZ1bmN0aW9uKHIpe3ZhciBlPW5ldyBnbG9iYWxbcl07aWYoIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gZSkpe3Rocm93IG5ldyBFdmFsRXJyb3IoXCJ0aGlzIGVuZ2luZSBoYXMgc3VwcG9ydCBmb3IgU3ltYm9sLnRvU3RyaW5nVGFnLCBidXQgXCIrcitcIiBkb2VzIG5vdCBoYXZlIHRoZSBwcm9wZXJ0eSEgUGxlYXNlIHJlcG9ydCB0aGlzLlwiKX12YXIgdD1nKGUpO3ZhciBuPWwodCxTeW1ib2wudG9TdHJpbmdUYWcpO2lmKCFuKXt2YXIgbz1nKHQpO249bChvLFN5bWJvbC50b1N0cmluZ1RhZyl9cFtyXT1uLmdldH0pKX12YXIgZD1mdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyhyKXt2YXIgZT1mYWxzZTtuKHAsKGZ1bmN0aW9uKHQsbil7aWYoIWUpe3RyeXtlPXQuY2FsbChyKT09PW59Y2F0Y2gocil7fX19KSk7cmV0dXJuIGV9O3IuZXhwb3J0cz1mdW5jdGlvbiBpc1R5cGVkQXJyYXkocil7aWYoIXJ8fHR5cGVvZiByIT09XCJvYmplY3RcIil7cmV0dXJuIGZhbHNlfWlmKCF1KXt2YXIgZT15KGEociksOCwtMSk7cmV0dXJuIGMocyxlKT4tMX1pZighbCl7cmV0dXJuIGZhbHNlfXJldHVybiBkKHIpfX0sOTEzOmZ1bmN0aW9uKHIpe3IuZXhwb3J0cz1mdW5jdGlvbiBpc0J1ZmZlcihyKXtyZXR1cm4gciBpbnN0YW5jZW9mIEJ1ZmZlcn19LDk4OTpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCg3NDkpO3ZhciBvPXQoNjExKTt2YXIgaT10KDcyOCk7dmFyIGE9dCgzODcpO2Z1bmN0aW9uIHVuY3VycnlUaGlzKHIpe3JldHVybiByLmNhbGwuYmluZChyKX12YXIgZj10eXBlb2YgQmlnSW50IT09XCJ1bmRlZmluZWRcIjt2YXIgdT10eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIjt2YXIgcz11bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTt2YXIgYz11bmN1cnJ5VGhpcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YpO3ZhciB5PXVuY3VycnlUaGlzKFN0cmluZy5wcm90b3R5cGUudmFsdWVPZik7dmFyIHA9dW5jdXJyeVRoaXMoQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZik7aWYoZil7dmFyIGw9dW5jdXJyeVRoaXMoQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mKX1pZih1KXt2YXIgZz11bmN1cnJ5VGhpcyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpfWZ1bmN0aW9uIGNoZWNrQm94ZWRQcmltaXRpdmUocixlKXtpZih0eXBlb2YgciE9PVwib2JqZWN0XCIpe3JldHVybiBmYWxzZX10cnl7ZShyKTtyZXR1cm4gdHJ1ZX1jYXRjaChyKXtyZXR1cm4gZmFsc2V9fWUuaXNBcmd1bWVudHNPYmplY3Q9bjtlLmlzR2VuZXJhdG9yRnVuY3Rpb249bztlLmlzVHlwZWRBcnJheT1hO2Z1bmN0aW9uIGlzUHJvbWlzZShyKXtyZXR1cm4gdHlwZW9mIFByb21pc2UhPT1cInVuZGVmaW5lZFwiJiZyIGluc3RhbmNlb2YgUHJvbWlzZXx8ciE9PW51bGwmJnR5cGVvZiByPT09XCJvYmplY3RcIiYmdHlwZW9mIHIudGhlbj09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIHIuY2F0Y2g9PT1cImZ1bmN0aW9uXCJ9ZS5pc1Byb21pc2U9aXNQcm9taXNlO2Z1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHIpe2lmKHR5cGVvZiBBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCImJkFycmF5QnVmZmVyLmlzVmlldyl7cmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhyKX1yZXR1cm4gYShyKXx8aXNEYXRhVmlldyhyKX1lLmlzQXJyYXlCdWZmZXJWaWV3PWlzQXJyYXlCdWZmZXJWaWV3O2Z1bmN0aW9uIGlzVWludDhBcnJheShyKXtyZXR1cm4gaShyKT09PVwiVWludDhBcnJheVwifWUuaXNVaW50OEFycmF5PWlzVWludDhBcnJheTtmdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJVaW50OENsYW1wZWRBcnJheVwifWUuaXNVaW50OENsYW1wZWRBcnJheT1pc1VpbnQ4Q2xhbXBlZEFycmF5O2Z1bmN0aW9uIGlzVWludDE2QXJyYXkocil7cmV0dXJuIGkocik9PT1cIlVpbnQxNkFycmF5XCJ9ZS5pc1VpbnQxNkFycmF5PWlzVWludDE2QXJyYXk7ZnVuY3Rpb24gaXNVaW50MzJBcnJheShyKXtyZXR1cm4gaShyKT09PVwiVWludDMyQXJyYXlcIn1lLmlzVWludDMyQXJyYXk9aXNVaW50MzJBcnJheTtmdW5jdGlvbiBpc0ludDhBcnJheShyKXtyZXR1cm4gaShyKT09PVwiSW50OEFycmF5XCJ9ZS5pc0ludDhBcnJheT1pc0ludDhBcnJheTtmdW5jdGlvbiBpc0ludDE2QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkludDE2QXJyYXlcIn1lLmlzSW50MTZBcnJheT1pc0ludDE2QXJyYXk7ZnVuY3Rpb24gaXNJbnQzMkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJJbnQzMkFycmF5XCJ9ZS5pc0ludDMyQXJyYXk9aXNJbnQzMkFycmF5O2Z1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJGbG9hdDMyQXJyYXlcIn1lLmlzRmxvYXQzMkFycmF5PWlzRmxvYXQzMkFycmF5O2Z1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJGbG9hdDY0QXJyYXlcIn1lLmlzRmxvYXQ2NEFycmF5PWlzRmxvYXQ2NEFycmF5O2Z1bmN0aW9uIGlzQmlnSW50NjRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiQmlnSW50NjRBcnJheVwifWUuaXNCaWdJbnQ2NEFycmF5PWlzQmlnSW50NjRBcnJheTtmdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJCaWdVaW50NjRBcnJheVwifWUuaXNCaWdVaW50NjRBcnJheT1pc0JpZ1VpbnQ2NEFycmF5O2Z1bmN0aW9uIGlzTWFwVG9TdHJpbmcocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgTWFwXVwifWlzTWFwVG9TdHJpbmcud29ya2luZz10eXBlb2YgTWFwIT09XCJ1bmRlZmluZWRcIiYmaXNNYXBUb1N0cmluZyhuZXcgTWFwKTtmdW5jdGlvbiBpc01hcChyKXtpZih0eXBlb2YgTWFwPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc01hcFRvU3RyaW5nLndvcmtpbmc/aXNNYXBUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgTWFwfWUuaXNNYXA9aXNNYXA7ZnVuY3Rpb24gaXNTZXRUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBTZXRdXCJ9aXNTZXRUb1N0cmluZy53b3JraW5nPXR5cGVvZiBTZXQhPT1cInVuZGVmaW5lZFwiJiZpc1NldFRvU3RyaW5nKG5ldyBTZXQpO2Z1bmN0aW9uIGlzU2V0KHIpe2lmKHR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGlzU2V0VG9TdHJpbmcud29ya2luZz9pc1NldFRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBTZXR9ZS5pc1NldD1pc1NldDtmdW5jdGlvbiBpc1dlYWtNYXBUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBXZWFrTWFwXVwifWlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIFdlYWtNYXAhPT1cInVuZGVmaW5lZFwiJiZpc1dlYWtNYXBUb1N0cmluZyhuZXcgV2Vha01hcCk7ZnVuY3Rpb24gaXNXZWFrTWFwKHIpe2lmKHR5cGVvZiBXZWFrTWFwPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc1dlYWtNYXBUb1N0cmluZy53b3JraW5nP2lzV2Vha01hcFRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBXZWFrTWFwfWUuaXNXZWFrTWFwPWlzV2Vha01hcDtmdW5jdGlvbiBpc1dlYWtTZXRUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBXZWFrU2V0XVwifWlzV2Vha1NldFRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIFdlYWtTZXQhPT1cInVuZGVmaW5lZFwiJiZpc1dlYWtTZXRUb1N0cmluZyhuZXcgV2Vha1NldCk7ZnVuY3Rpb24gaXNXZWFrU2V0KHIpe3JldHVybiBpc1dlYWtTZXRUb1N0cmluZyhyKX1lLmlzV2Vha1NldD1pc1dlYWtTZXQ7ZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IEFycmF5QnVmZmVyXVwifWlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nPXR5cGVvZiBBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCImJmlzQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgQXJyYXlCdWZmZXIpO2Z1bmN0aW9uIGlzQXJyYXlCdWZmZXIocil7aWYodHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz9pc0FycmF5QnVmZmVyVG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfWUuaXNBcnJheUJ1ZmZlcj1pc0FycmF5QnVmZmVyO2Z1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBEYXRhVmlld11cIn1pc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZz10eXBlb2YgQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiZ0eXBlb2YgRGF0YVZpZXchPT1cInVuZGVmaW5lZFwiJiZpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwwLDEpKTtmdW5jdGlvbiBpc0RhdGFWaWV3KHIpe2lmKHR5cGVvZiBEYXRhVmlldz09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmc/aXNEYXRhVmlld1RvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBEYXRhVmlld31lLmlzRGF0YVZpZXc9aXNEYXRhVmlldzt2YXIgZD10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiP1NoYXJlZEFycmF5QnVmZmVyOnVuZGVmaW5lZDtmdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdXCJ9ZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlcihyKXtpZih0eXBlb2YgZD09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc9PT1cInVuZGVmaW5lZFwiKXtpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz1pc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcobmV3IGQpfXJldHVybiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz9pc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIGR9ZS5pc1NoYXJlZEFycmF5QnVmZmVyPWlzU2hhcmVkQXJyYXlCdWZmZXI7ZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dXCJ9ZS5pc0FzeW5jRnVuY3Rpb249aXNBc3luY0Z1bmN0aW9uO2Z1bmN0aW9uIGlzTWFwSXRlcmF0b3Iocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgTWFwIEl0ZXJhdG9yXVwifWUuaXNNYXBJdGVyYXRvcj1pc01hcEl0ZXJhdG9yO2Z1bmN0aW9uIGlzU2V0SXRlcmF0b3Iocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgU2V0IEl0ZXJhdG9yXVwifWUuaXNTZXRJdGVyYXRvcj1pc1NldEl0ZXJhdG9yO2Z1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IEdlbmVyYXRvcl1cIn1lLmlzR2VuZXJhdG9yT2JqZWN0PWlzR2VuZXJhdG9yT2JqZWN0O2Z1bmN0aW9uIGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZShyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBXZWJBc3NlbWJseS5Nb2R1bGVdXCJ9ZS5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU9aXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlO2Z1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHIpe3JldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHIsYyl9ZS5pc051bWJlck9iamVjdD1pc051bWJlck9iamVjdDtmdW5jdGlvbiBpc1N0cmluZ09iamVjdChyKXtyZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZShyLHkpfWUuaXNTdHJpbmdPYmplY3Q9aXNTdHJpbmdPYmplY3Q7ZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHIpe3JldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHIscCl9ZS5pc0Jvb2xlYW5PYmplY3Q9aXNCb29sZWFuT2JqZWN0O2Z1bmN0aW9uIGlzQmlnSW50T2JqZWN0KHIpe3JldHVybiBmJiZjaGVja0JveGVkUHJpbWl0aXZlKHIsbCl9ZS5pc0JpZ0ludE9iamVjdD1pc0JpZ0ludE9iamVjdDtmdW5jdGlvbiBpc1N5bWJvbE9iamVjdChyKXtyZXR1cm4gdSYmY2hlY2tCb3hlZFByaW1pdGl2ZShyLGcpfWUuaXNTeW1ib2xPYmplY3Q9aXNTeW1ib2xPYmplY3Q7ZnVuY3Rpb24gaXNCb3hlZFByaW1pdGl2ZShyKXtyZXR1cm4gaXNOdW1iZXJPYmplY3Qocil8fGlzU3RyaW5nT2JqZWN0KHIpfHxpc0Jvb2xlYW5PYmplY3Qocil8fGlzQmlnSW50T2JqZWN0KHIpfHxpc1N5bWJvbE9iamVjdChyKX1lLmlzQm94ZWRQcmltaXRpdmU9aXNCb3hlZFByaW1pdGl2ZTtmdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHIpe3JldHVybiB0eXBlb2YgVWludDhBcnJheSE9PVwidW5kZWZpbmVkXCImJihpc0FycmF5QnVmZmVyKHIpfHxpc1NoYXJlZEFycmF5QnVmZmVyKHIpKX1lLmlzQW55QXJyYXlCdWZmZXI9aXNBbnlBcnJheUJ1ZmZlcjtbXCJpc1Byb3h5XCIsXCJpc0V4dGVybmFsXCIsXCJpc01vZHVsZU5hbWVzcGFjZU9iamVjdFwiXS5mb3JFYWNoKChmdW5jdGlvbihyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOmZhbHNlLHZhbHVlOmZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKHIrXCIgaXMgbm90IHN1cHBvcnRlZCBpbiB1c2VybGFuZFwiKX19KX0pKX0sNDY3OmZ1bmN0aW9uKHIsZSx0KXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yc3x8ZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhyKXt2YXIgZT1PYmplY3Qua2V5cyhyKTt2YXIgdD17fTtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dFtlW25dXT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZVtuXSl9cmV0dXJuIHR9O3ZhciBvPS8lW3NkaiVdL2c7ZS5mb3JtYXQ9ZnVuY3Rpb24ocil7aWYoIWlzU3RyaW5nKHIpKXt2YXIgZT1bXTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXtlLnB1c2goaW5zcGVjdChhcmd1bWVudHNbdF0pKX1yZXR1cm4gZS5qb2luKFwiIFwiKX12YXIgdD0xO3ZhciBuPWFyZ3VtZW50czt2YXIgaT1uLmxlbmd0aDt2YXIgYT1TdHJpbmcocikucmVwbGFjZShvLChmdW5jdGlvbihyKXtpZihyPT09XCIlJVwiKXJldHVyblwiJVwiO2lmKHQ+PWkpcmV0dXJuIHI7c3dpdGNoKHIpe2Nhc2VcIiVzXCI6cmV0dXJuIFN0cmluZyhuW3QrK10pO2Nhc2VcIiVkXCI6cmV0dXJuIE51bWJlcihuW3QrK10pO2Nhc2VcIiVqXCI6dHJ5e3JldHVybiBKU09OLnN0cmluZ2lmeShuW3QrK10pfWNhdGNoKHIpe3JldHVyblwiW0NpcmN1bGFyXVwifWRlZmF1bHQ6cmV0dXJuIHJ9fSkpO2Zvcih2YXIgZj1uW3RdO3Q8aTtmPW5bKyt0XSl7aWYoaXNOdWxsKGYpfHwhaXNPYmplY3QoZikpe2ErPVwiIFwiK2Z9ZWxzZXthKz1cIiBcIitpbnNwZWN0KGYpfX1yZXR1cm4gYX07ZS5kZXByZWNhdGU9ZnVuY3Rpb24ocix0KXtpZih0eXBlb2YgcHJvY2VzcyE9PVwidW5kZWZpbmVkXCImJnByb2Nlc3Mubm9EZXByZWNhdGlvbj09PXRydWUpe3JldHVybiByfWlmKHR5cGVvZiBwcm9jZXNzPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUuZGVwcmVjYXRlKHIsdCkuYXBwbHkodGhpcyxhcmd1bWVudHMpfX12YXIgbj1mYWxzZTtmdW5jdGlvbiBkZXByZWNhdGVkKCl7aWYoIW4pe2lmKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbil7dGhyb3cgbmV3IEVycm9yKHQpfWVsc2UgaWYocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKXtjb25zb2xlLnRyYWNlKHQpfWVsc2V7Y29uc29sZS5lcnJvcih0KX1uPXRydWV9cmV0dXJuIHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBkZXByZWNhdGVkfTt2YXIgaT17fTt2YXIgYT0vXiQvO2lmKHByb2Nlc3MuZW52Lk5PREVfREVCVUcpe3ZhciBmPXByb2Nlc3MuZW52Lk5PREVfREVCVUc7Zj1mLnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csXCJcXFxcJCZcIikucmVwbGFjZSgvXFwqL2csXCIuKlwiKS5yZXBsYWNlKC8sL2csXCIkfF5cIikudG9VcHBlckNhc2UoKTthPW5ldyBSZWdFeHAoXCJeXCIrZitcIiRcIixcImlcIil9ZS5kZWJ1Z2xvZz1mdW5jdGlvbihyKXtyPXIudG9VcHBlckNhc2UoKTtpZighaVtyXSl7aWYoYS50ZXN0KHIpKXt2YXIgdD1wcm9jZXNzLnBpZDtpW3JdPWZ1bmN0aW9uKCl7dmFyIG49ZS5mb3JtYXQuYXBwbHkoZSxhcmd1bWVudHMpO2NvbnNvbGUuZXJyb3IoXCIlcyAlZDogJXNcIixyLHQsbil9fWVsc2V7aVtyXT1mdW5jdGlvbigpe319fXJldHVybiBpW3JdfTtmdW5jdGlvbiBpbnNwZWN0KHIsdCl7dmFyIG49e3NlZW46W10sc3R5bGl6ZTpzdHlsaXplTm9Db2xvcn07aWYoYXJndW1lbnRzLmxlbmd0aD49MyluLmRlcHRoPWFyZ3VtZW50c1syXTtpZihhcmd1bWVudHMubGVuZ3RoPj00KW4uY29sb3JzPWFyZ3VtZW50c1szXTtpZihpc0Jvb2xlYW4odCkpe24uc2hvd0hpZGRlbj10fWVsc2UgaWYodCl7ZS5fZXh0ZW5kKG4sdCl9aWYoaXNVbmRlZmluZWQobi5zaG93SGlkZGVuKSluLnNob3dIaWRkZW49ZmFsc2U7aWYoaXNVbmRlZmluZWQobi5kZXB0aCkpbi5kZXB0aD0yO2lmKGlzVW5kZWZpbmVkKG4uY29sb3JzKSluLmNvbG9ycz1mYWxzZTtpZihpc1VuZGVmaW5lZChuLmN1c3RvbUluc3BlY3QpKW4uY3VzdG9tSW5zcGVjdD10cnVlO2lmKG4uY29sb3JzKW4uc3R5bGl6ZT1zdHlsaXplV2l0aENvbG9yO3JldHVybiBmb3JtYXRWYWx1ZShuLHIsbi5kZXB0aCl9ZS5pbnNwZWN0PWluc3BlY3Q7aW5zcGVjdC5jb2xvcnM9e2JvbGQ6WzEsMjJdLGl0YWxpYzpbMywyM10sdW5kZXJsaW5lOls0LDI0XSxpbnZlcnNlOls3LDI3XSx3aGl0ZTpbMzcsMzldLGdyZXk6WzkwLDM5XSxibGFjazpbMzAsMzldLGJsdWU6WzM0LDM5XSxjeWFuOlszNiwzOV0sZ3JlZW46WzMyLDM5XSxtYWdlbnRhOlszNSwzOV0scmVkOlszMSwzOV0seWVsbG93OlszMywzOV19O2luc3BlY3Quc3R5bGVzPXtzcGVjaWFsOlwiY3lhblwiLG51bWJlcjpcInllbGxvd1wiLGJvb2xlYW46XCJ5ZWxsb3dcIix1bmRlZmluZWQ6XCJncmV5XCIsbnVsbDpcImJvbGRcIixzdHJpbmc6XCJncmVlblwiLGRhdGU6XCJtYWdlbnRhXCIscmVnZXhwOlwicmVkXCJ9O2Z1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3IocixlKXt2YXIgdD1pbnNwZWN0LnN0eWxlc1tlXTtpZih0KXtyZXR1cm5cIlx1MDAxYltcIitpbnNwZWN0LmNvbG9yc1t0XVswXStcIm1cIityK1wiXHUwMDFiW1wiK2luc3BlY3QuY29sb3JzW3RdWzFdK1wibVwifWVsc2V7cmV0dXJuIHJ9fWZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHIsZSl7cmV0dXJuIHJ9ZnVuY3Rpb24gYXJyYXlUb0hhc2gocil7dmFyIGU9e307ci5mb3JFYWNoKChmdW5jdGlvbihyLHQpe2Vbcl09dHJ1ZX0pKTtyZXR1cm4gZX1mdW5jdGlvbiBmb3JtYXRWYWx1ZShyLHQsbil7aWYoci5jdXN0b21JbnNwZWN0JiZ0JiZpc0Z1bmN0aW9uKHQuaW5zcGVjdCkmJnQuaW5zcGVjdCE9PWUuaW5zcGVjdCYmISh0LmNvbnN0cnVjdG9yJiZ0LmNvbnN0cnVjdG9yLnByb3RvdHlwZT09PXQpKXt2YXIgbz10Lmluc3BlY3QobixyKTtpZighaXNTdHJpbmcobykpe289Zm9ybWF0VmFsdWUocixvLG4pfXJldHVybiBvfXZhciBpPWZvcm1hdFByaW1pdGl2ZShyLHQpO2lmKGkpe3JldHVybiBpfXZhciBhPU9iamVjdC5rZXlzKHQpO3ZhciBmPWFycmF5VG9IYXNoKGEpO2lmKHIuc2hvd0hpZGRlbil7YT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0KX1pZihpc0Vycm9yKHQpJiYoYS5pbmRleE9mKFwibWVzc2FnZVwiKT49MHx8YS5pbmRleE9mKFwiZGVzY3JpcHRpb25cIik+PTApKXtyZXR1cm4gZm9ybWF0RXJyb3IodCl9aWYoYS5sZW5ndGg9PT0wKXtpZihpc0Z1bmN0aW9uKHQpKXt2YXIgdT10Lm5hbWU/XCI6IFwiK3QubmFtZTpcIlwiO3JldHVybiByLnN0eWxpemUoXCJbRnVuY3Rpb25cIit1K1wiXVwiLFwic3BlY2lhbFwiKX1pZihpc1JlZ0V4cCh0KSl7cmV0dXJuIHIuc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCksXCJyZWdleHBcIil9aWYoaXNEYXRlKHQpKXtyZXR1cm4gci5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCksXCJkYXRlXCIpfWlmKGlzRXJyb3IodCkpe3JldHVybiBmb3JtYXRFcnJvcih0KX19dmFyIHM9XCJcIixjPWZhbHNlLHk9W1wie1wiLFwifVwiXTtpZihpc0FycmF5KHQpKXtjPXRydWU7eT1bXCJbXCIsXCJdXCJdfWlmKGlzRnVuY3Rpb24odCkpe3ZhciBwPXQubmFtZT9cIjogXCIrdC5uYW1lOlwiXCI7cz1cIiBbRnVuY3Rpb25cIitwK1wiXVwifWlmKGlzUmVnRXhwKHQpKXtzPVwiIFwiK1JlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX1pZihpc0RhdGUodCkpe3M9XCIgXCIrRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh0KX1pZihpc0Vycm9yKHQpKXtzPVwiIFwiK2Zvcm1hdEVycm9yKHQpfWlmKGEubGVuZ3RoPT09MCYmKCFjfHx0Lmxlbmd0aD09MCkpe3JldHVybiB5WzBdK3MreVsxXX1pZihuPDApe2lmKGlzUmVnRXhwKHQpKXtyZXR1cm4gci5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSxcInJlZ2V4cFwiKX1lbHNle3JldHVybiByLnN0eWxpemUoXCJbT2JqZWN0XVwiLFwic3BlY2lhbFwiKX19ci5zZWVuLnB1c2godCk7dmFyIGw7aWYoYyl7bD1mb3JtYXRBcnJheShyLHQsbixmLGEpfWVsc2V7bD1hLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGZvcm1hdFByb3BlcnR5KHIsdCxuLGYsZSxjKX0pKX1yLnNlZW4ucG9wKCk7cmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKGwscyx5KX1mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUocixlKXtpZihpc1VuZGVmaW5lZChlKSlyZXR1cm4gci5zdHlsaXplKFwidW5kZWZpbmVkXCIsXCJ1bmRlZmluZWRcIik7aWYoaXNTdHJpbmcoZSkpe3ZhciB0PVwiJ1wiK0pTT04uc3RyaW5naWZ5KGUpLnJlcGxhY2UoL15cInxcIiQvZyxcIlwiKS5yZXBsYWNlKC8nL2csXCJcXFxcJ1wiKS5yZXBsYWNlKC9cXFxcXCIvZywnXCInKStcIidcIjtyZXR1cm4gci5zdHlsaXplKHQsXCJzdHJpbmdcIil9aWYoaXNOdW1iZXIoZSkpcmV0dXJuIHIuc3R5bGl6ZShcIlwiK2UsXCJudW1iZXJcIik7aWYoaXNCb29sZWFuKGUpKXJldHVybiByLnN0eWxpemUoXCJcIitlLFwiYm9vbGVhblwiKTtpZihpc051bGwoZSkpcmV0dXJuIHIuc3R5bGl6ZShcIm51bGxcIixcIm51bGxcIil9ZnVuY3Rpb24gZm9ybWF0RXJyb3Iocil7cmV0dXJuXCJbXCIrRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocikrXCJdXCJ9ZnVuY3Rpb24gZm9ybWF0QXJyYXkocixlLHQsbixvKXt2YXIgaT1bXTtmb3IodmFyIGE9MCxmPWUubGVuZ3RoO2E8ZjsrK2Epe2lmKGhhc093blByb3BlcnR5KGUsU3RyaW5nKGEpKSl7aS5wdXNoKGZvcm1hdFByb3BlcnR5KHIsZSx0LG4sU3RyaW5nKGEpLHRydWUpKX1lbHNle2kucHVzaChcIlwiKX19by5mb3JFYWNoKChmdW5jdGlvbihvKXtpZighby5tYXRjaCgvXlxcZCskLykpe2kucHVzaChmb3JtYXRQcm9wZXJ0eShyLGUsdCxuLG8sdHJ1ZSkpfX0pKTtyZXR1cm4gaX1mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShyLGUsdCxuLG8saSl7dmFyIGEsZix1O3U9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG8pfHx7dmFsdWU6ZVtvXX07aWYodS5nZXQpe2lmKHUuc2V0KXtmPXIuc3R5bGl6ZShcIltHZXR0ZXIvU2V0dGVyXVwiLFwic3BlY2lhbFwiKX1lbHNle2Y9ci5zdHlsaXplKFwiW0dldHRlcl1cIixcInNwZWNpYWxcIil9fWVsc2V7aWYodS5zZXQpe2Y9ci5zdHlsaXplKFwiW1NldHRlcl1cIixcInNwZWNpYWxcIil9fWlmKCFoYXNPd25Qcm9wZXJ0eShuLG8pKXthPVwiW1wiK28rXCJdXCJ9aWYoIWYpe2lmKHIuc2Vlbi5pbmRleE9mKHUudmFsdWUpPDApe2lmKGlzTnVsbCh0KSl7Zj1mb3JtYXRWYWx1ZShyLHUudmFsdWUsbnVsbCl9ZWxzZXtmPWZvcm1hdFZhbHVlKHIsdS52YWx1ZSx0LTEpfWlmKGYuaW5kZXhPZihcIlxcblwiKT4tMSl7aWYoaSl7Zj1mLnNwbGl0KFwiXFxuXCIpLm1hcCgoZnVuY3Rpb24ocil7cmV0dXJuXCIgIFwiK3J9KSkuam9pbihcIlxcblwiKS5zdWJzdHIoMil9ZWxzZXtmPVwiXFxuXCIrZi5zcGxpdChcIlxcblwiKS5tYXAoKGZ1bmN0aW9uKHIpe3JldHVyblwiICAgXCIrcn0pKS5qb2luKFwiXFxuXCIpfX19ZWxzZXtmPXIuc3R5bGl6ZShcIltDaXJjdWxhcl1cIixcInNwZWNpYWxcIil9fWlmKGlzVW5kZWZpbmVkKGEpKXtpZihpJiZvLm1hdGNoKC9eXFxkKyQvKSl7cmV0dXJuIGZ9YT1KU09OLnN0cmluZ2lmeShcIlwiK28pO2lmKGEubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKXthPWEuc3Vic3RyKDEsYS5sZW5ndGgtMik7YT1yLnN0eWxpemUoYSxcIm5hbWVcIil9ZWxzZXthPWEucmVwbGFjZSgvJy9nLFwiXFxcXCdcIikucmVwbGFjZSgvXFxcXFwiL2csJ1wiJykucmVwbGFjZSgvKF5cInxcIiQpL2csXCInXCIpO2E9ci5zdHlsaXplKGEsXCJzdHJpbmdcIil9fXJldHVybiBhK1wiOiBcIitmfWZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKHIsZSx0KXt2YXIgbj0wO3ZhciBvPXIucmVkdWNlKChmdW5jdGlvbihyLGUpe24rKztpZihlLmluZGV4T2YoXCJcXG5cIik+PTApbisrO3JldHVybiByK2UucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csXCJcIikubGVuZ3RoKzF9KSwwKTtpZihvPjYwKXtyZXR1cm4gdFswXSsoZT09PVwiXCI/XCJcIjplK1wiXFxuIFwiKStcIiBcIityLmpvaW4oXCIsXFxuICBcIikrXCIgXCIrdFsxXX1yZXR1cm4gdFswXStlK1wiIFwiK3Iuam9pbihcIiwgXCIpK1wiIFwiK3RbMV19ZS50eXBlcz10KDk4OSk7ZnVuY3Rpb24gaXNBcnJheShyKXtyZXR1cm4gQXJyYXkuaXNBcnJheShyKX1lLmlzQXJyYXk9aXNBcnJheTtmdW5jdGlvbiBpc0Jvb2xlYW4ocil7cmV0dXJuIHR5cGVvZiByPT09XCJib29sZWFuXCJ9ZS5pc0Jvb2xlYW49aXNCb29sZWFuO2Z1bmN0aW9uIGlzTnVsbChyKXtyZXR1cm4gcj09PW51bGx9ZS5pc051bGw9aXNOdWxsO2Z1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHIpe3JldHVybiByPT1udWxsfWUuaXNOdWxsT3JVbmRlZmluZWQ9aXNOdWxsT3JVbmRlZmluZWQ7ZnVuY3Rpb24gaXNOdW1iZXIocil7cmV0dXJuIHR5cGVvZiByPT09XCJudW1iZXJcIn1lLmlzTnVtYmVyPWlzTnVtYmVyO2Z1bmN0aW9uIGlzU3RyaW5nKHIpe3JldHVybiB0eXBlb2Ygcj09PVwic3RyaW5nXCJ9ZS5pc1N0cmluZz1pc1N0cmluZztmdW5jdGlvbiBpc1N5bWJvbChyKXtyZXR1cm4gdHlwZW9mIHI9PT1cInN5bWJvbFwifWUuaXNTeW1ib2w9aXNTeW1ib2w7ZnVuY3Rpb24gaXNVbmRlZmluZWQocil7cmV0dXJuIHI9PT12b2lkIDB9ZS5pc1VuZGVmaW5lZD1pc1VuZGVmaW5lZDtmdW5jdGlvbiBpc1JlZ0V4cChyKXtyZXR1cm4gaXNPYmplY3QocikmJm9iamVjdFRvU3RyaW5nKHIpPT09XCJbb2JqZWN0IFJlZ0V4cF1cIn1lLmlzUmVnRXhwPWlzUmVnRXhwO2UudHlwZXMuaXNSZWdFeHA9aXNSZWdFeHA7ZnVuY3Rpb24gaXNPYmplY3Qocil7cmV0dXJuIHR5cGVvZiByPT09XCJvYmplY3RcIiYmciE9PW51bGx9ZS5pc09iamVjdD1pc09iamVjdDtmdW5jdGlvbiBpc0RhdGUocil7cmV0dXJuIGlzT2JqZWN0KHIpJiZvYmplY3RUb1N0cmluZyhyKT09PVwiW29iamVjdCBEYXRlXVwifWUuaXNEYXRlPWlzRGF0ZTtlLnR5cGVzLmlzRGF0ZT1pc0RhdGU7ZnVuY3Rpb24gaXNFcnJvcihyKXtyZXR1cm4gaXNPYmplY3QocikmJihvYmplY3RUb1N0cmluZyhyKT09PVwiW29iamVjdCBFcnJvcl1cInx8ciBpbnN0YW5jZW9mIEVycm9yKX1lLmlzRXJyb3I9aXNFcnJvcjtlLnR5cGVzLmlzTmF0aXZlRXJyb3I9aXNFcnJvcjtmdW5jdGlvbiBpc0Z1bmN0aW9uKHIpe3JldHVybiB0eXBlb2Ygcj09PVwiZnVuY3Rpb25cIn1lLmlzRnVuY3Rpb249aXNGdW5jdGlvbjtmdW5jdGlvbiBpc1ByaW1pdGl2ZShyKXtyZXR1cm4gcj09PW51bGx8fHR5cGVvZiByPT09XCJib29sZWFuXCJ8fHR5cGVvZiByPT09XCJudW1iZXJcInx8dHlwZW9mIHI9PT1cInN0cmluZ1wifHx0eXBlb2Ygcj09PVwic3ltYm9sXCJ8fHR5cGVvZiByPT09XCJ1bmRlZmluZWRcIn1lLmlzUHJpbWl0aXZlPWlzUHJpbWl0aXZlO2UuaXNCdWZmZXI9dCg5MTMpO2Z1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHIpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocil9ZnVuY3Rpb24gcGFkKHIpe3JldHVybiByPDEwP1wiMFwiK3IudG9TdHJpbmcoMTApOnIudG9TdHJpbmcoMTApfXZhciB1PVtcIkphblwiLFwiRmViXCIsXCJNYXJcIixcIkFwclwiLFwiTWF5XCIsXCJKdW5cIixcIkp1bFwiLFwiQXVnXCIsXCJTZXBcIixcIk9jdFwiLFwiTm92XCIsXCJEZWNcIl07ZnVuY3Rpb24gdGltZXN0YW1wKCl7dmFyIHI9bmV3IERhdGU7dmFyIGU9W3BhZChyLmdldEhvdXJzKCkpLHBhZChyLmdldE1pbnV0ZXMoKSkscGFkKHIuZ2V0U2Vjb25kcygpKV0uam9pbihcIjpcIik7cmV0dXJuW3IuZ2V0RGF0ZSgpLHVbci5nZXRNb250aCgpXSxlXS5qb2luKFwiIFwiKX1lLmxvZz1mdW5jdGlvbigpe2NvbnNvbGUubG9nKFwiJXMgLSAlc1wiLHRpbWVzdGFtcCgpLGUuZm9ybWF0LmFwcGx5KGUsYXJndW1lbnRzKSl9O2UuaW5oZXJpdHM9dCgxNDApO2UuX2V4dGVuZD1mdW5jdGlvbihyLGUpe2lmKCFlfHwhaXNPYmplY3QoZSkpcmV0dXJuIHI7dmFyIHQ9T2JqZWN0LmtleXMoZSk7dmFyIG49dC5sZW5ndGg7d2hpbGUobi0tKXtyW3Rbbl1dPWVbdFtuXV19cmV0dXJuIHJ9O2Z1bmN0aW9uIGhhc093blByb3BlcnR5KHIsZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLGUpfXZhciBzPXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiP1N5bWJvbChcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiKTp1bmRlZmluZWQ7ZS5wcm9taXNpZnk9ZnVuY3Rpb24gcHJvbWlzaWZ5KHIpe2lmKHR5cGVvZiByIT09XCJmdW5jdGlvblwiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7aWYocyYmcltzXSl7dmFyIGU9cltzXTtpZih0eXBlb2YgZSE9PVwiZnVuY3Rpb25cIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscyx7dmFsdWU6ZSxlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOmZhbHNlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7cmV0dXJuIGV9ZnVuY3Rpb24gZSgpe3ZhciBlLHQ7dmFyIG49bmV3IFByb21pc2UoKGZ1bmN0aW9uKHIsbil7ZT1yO3Q9bn0pKTt2YXIgbz1bXTtmb3IodmFyIGk9MDtpPGFyZ3VtZW50cy5sZW5ndGg7aSsrKXtvLnB1c2goYXJndW1lbnRzW2ldKX1vLnB1c2goKGZ1bmN0aW9uKHIsbil7aWYocil7dChyKX1lbHNle2Uobil9fSkpO3RyeXtyLmFwcGx5KHRoaXMsbyl9Y2F0Y2gocil7dChyKX1yZXR1cm4gbn1PYmplY3Quc2V0UHJvdG90eXBlT2YoZSxPYmplY3QuZ2V0UHJvdG90eXBlT2YocikpO2lmKHMpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscyx7dmFsdWU6ZSxlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOmZhbHNlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsbihyKSl9O2UucHJvbWlzaWZ5LmN1c3RvbT1zO2Z1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyLGUpe2lmKCFyKXt2YXIgdD1uZXcgRXJyb3IoXCJQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWVcIik7dC5yZWFzb249cjtyPXR9cmV0dXJuIGUocil9ZnVuY3Rpb24gY2FsbGJhY2tpZnkocil7aWYodHlwZW9mIHIhPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyl9ZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpe3ZhciBlPVtdO2Zvcih2YXIgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe2UucHVzaChhcmd1bWVudHNbdF0pfXZhciBuPWUucG9wKCk7aWYodHlwZW9mIG4hPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb25cIil9dmFyIG89dGhpczt2YXIgY2I9ZnVuY3Rpb24oKXtyZXR1cm4gbi5hcHBseShvLGFyZ3VtZW50cyl9O3IuYXBwbHkodGhpcyxlKS50aGVuKChmdW5jdGlvbihyKXtwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCxudWxsLHIpKX0pLChmdW5jdGlvbihyKXtwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZC5iaW5kKG51bGwscixjYikpfSkpfU9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLE9iamVjdC5nZXRQcm90b3R5cGVPZihyKSk7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxuKHIpKTtyZXR1cm4gY2FsbGJhY2tpZmllZH1lLmNhbGxiYWNraWZ5PWNhbGxiYWNraWZ5fSw3Mjg6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoOTgxKTt2YXIgbz10KDM4Mik7dmFyIGk9dCgxNzEpO3ZhciBhPWkoXCJPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXCIpO3ZhciBmPXQoNTY3KSgpO3ZhciB1PWYmJnR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PT1cInN5bWJvbFwiO3ZhciBzPW8oKTt2YXIgYz1pKFwiU3RyaW5nLnByb3RvdHlwZS5zbGljZVwiKTt2YXIgeT17fTt2YXIgcD10KDMwKTt2YXIgbD1PYmplY3QuZ2V0UHJvdG90eXBlT2Y7aWYodSYmcCYmbCl7bihzLChmdW5jdGlvbihyKXtpZih0eXBlb2YgZ2xvYmFsW3JdPT09XCJmdW5jdGlvblwiKXt2YXIgZT1uZXcgZ2xvYmFsW3JdO2lmKCEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGUpKXt0aHJvdyBuZXcgRXZhbEVycm9yKFwidGhpcyBlbmdpbmUgaGFzIHN1cHBvcnQgZm9yIFN5bWJvbC50b1N0cmluZ1RhZywgYnV0IFwiK3IrXCIgZG9lcyBub3QgaGF2ZSB0aGUgcHJvcGVydHkhIFBsZWFzZSByZXBvcnQgdGhpcy5cIil9dmFyIHQ9bChlKTt2YXIgbj1wKHQsU3ltYm9sLnRvU3RyaW5nVGFnKTtpZighbil7dmFyIG89bCh0KTtuPXAobyxTeW1ib2wudG9TdHJpbmdUYWcpfXlbcl09bi5nZXR9fSkpfXZhciBnPWZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHIpe3ZhciBlPWZhbHNlO24oeSwoZnVuY3Rpb24odCxuKXtpZighZSl7dHJ5e3ZhciBvPXQuY2FsbChyKTtpZihvPT09bil7ZT1vfX1jYXRjaChyKXt9fX0pKTtyZXR1cm4gZX07dmFyIGQ9dCgzODcpO3IuZXhwb3J0cz1mdW5jdGlvbiB3aGljaFR5cGVkQXJyYXkocil7aWYoIWQocikpe3JldHVybiBmYWxzZX1pZighdSl7cmV0dXJuIGMoYShyKSw4LC0xKX1yZXR1cm4gZyhyKX19LDM4MjpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCg5OTcpO3IuZXhwb3J0cz1mdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5cygpe3JldHVybiBuKFtcIkJpZ0ludDY0QXJyYXlcIixcIkJpZ1VpbnQ2NEFycmF5XCIsXCJGbG9hdDMyQXJyYXlcIixcIkZsb2F0NjRBcnJheVwiLFwiSW50MTZBcnJheVwiLFwiSW50MzJBcnJheVwiLFwiSW50OEFycmF5XCIsXCJVaW50MTZBcnJheVwiLFwiVWludDMyQXJyYXlcIixcIlVpbnQ4QXJyYXlcIixcIlVpbnQ4Q2xhbXBlZEFycmF5XCJdLChmdW5jdGlvbihyKXtyZXR1cm4gdHlwZW9mIGdsb2JhbFtyXT09PVwiZnVuY3Rpb25cIn0pKX19LDMwOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KDYyNyk7dmFyIG89bihcIiVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJVwiLHRydWUpO2lmKG8pe3RyeXtvKFtdLFwibGVuZ3RoXCIpfWNhdGNoKHIpe289bnVsbH19ci5leHBvcnRzPW99fTt2YXIgZT17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPWVbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgbz1lW3RdPXtleHBvcnRzOnt9fTt2YXIgaT10cnVlO3RyeXtyW3RdKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2k9ZmFsc2V9ZmluYWxseXtpZihpKWRlbGV0ZSBlW3RdfXJldHVybiBvLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNDY3KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOlsiciIsImV4cG9ydHMiLCJ0IiwibiIsImZpbHRlciIsIlR5cGVFcnJvciIsIm8iLCJpIiwibGVuZ3RoIiwiZSIsImNhbGwiLCJhIiwicHVzaCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbEJvdW5kSW50cmluc2ljIiwiZiIsInUiLCJzIiwiYyIsInZhbHVlIiwiY2FsbEJpbmQiLCJhcmd1bWVudHMiLCJjb25maWd1cmFibGUiLCJ5IiwiYXBwbHlCaW5kIiwiYXBwbHkiLCJ0b1N0cmluZyIsImZvckVhY2giLCJBcnJheSIsInNsaWNlIiwiYmluZCIsImJpbmRlciIsImNvbmNhdCIsIk1hdGgiLCJtYXgiLCJGdW5jdGlvbiIsImpvaW4iLCJFbXB0eSIsIlN5bnRheEVycm9yIiwiZ2V0RXZhbGxlZENvbnN0cnVjdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidGhyb3dUeXBlRXJyb3IiLCJjYWxsZWUiLCJnZXQiLCJnZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsInAiLCJVaW50OEFycmF5IiwibCIsIkFnZ3JlZ2F0ZUVycm9yIiwiQXJyYXlCdWZmZXIiLCJTeW1ib2wiLCJpdGVyYXRvciIsIkF0b21pY3MiLCJCaWdJbnQiLCJCb29sZWFuIiwiRGF0YVZpZXciLCJEYXRlIiwiZGVjb2RlVVJJIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZW5jb2RlVVJJIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiRXJyb3IiLCJldmFsIiwiRXZhbEVycm9yIiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsImlzRmluaXRlIiwiaXNOYU4iLCJKU09OIiwiTWFwIiwiTnVtYmVyIiwicGFyc2VGbG9hdCIsInBhcnNlSW50IiwiUHJvbWlzZSIsIlByb3h5IiwiUmFuZ2VFcnJvciIsIlJlZmVyZW5jZUVycm9yIiwiUmVmbGVjdCIsIlJlZ0V4cCIsIlNldCIsIlNoYXJlZEFycmF5QnVmZmVyIiwiU3RyaW5nIiwiVWludDhDbGFtcGVkQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiVVJJRXJyb3IiLCJXZWFrTWFwIiwiV2Vha1JlZiIsIldlYWtTZXQiLCJnIiwiZG9FdmFsIiwiZCIsInYiLCJiIiwiQSIsIm0iLCJzcGxpY2UiLCJTIiwicmVwbGFjZSIsImgiLCJPIiwidyIsImoiLCJzdHJpbmdUb1BhdGgiLCJQIiwiZ2V0QmFzZUludHJpbnNpYyIsImFsaWFzIiwibmFtZSIsIkdldEludHJpbnNpYyIsImhhc05hdGl2ZVN5bWJvbHMiLCJoYXNTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwia2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImVudW1lcmFibGUiLCJjcmVhdGUiLCJpbmhlcml0cyIsInN1cGVyXyIsImNvbnN0cnVjdG9yIiwid3JpdGFibGUiLCJUZW1wQ3RvciIsInRvU3RyaW5nVGFnIiwiaXNBcmd1bWVudHMiLCJpc0xlZ2FjeUFyZ3VtZW50cyIsImdldEdlbmVyYXRvckZ1bmMiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwidGVzdCIsImluZGV4T2YiLCJnbG9iYWwiLCJ0cnlBbGxUeXBlZEFycmF5cyIsImlzVHlwZWRBcnJheSIsImlzQnVmZmVyIiwiQnVmZmVyIiwidW5jdXJyeVRoaXMiLCJ2YWx1ZU9mIiwiY2hlY2tCb3hlZFByaW1pdGl2ZSIsImlzQXJndW1lbnRzT2JqZWN0IiwiaXNQcm9taXNlIiwidGhlbiIsImNhdGNoIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJpc1ZpZXciLCJpc0RhdGFWaWV3IiwiaXNVaW50OEFycmF5IiwiaXNVaW50OENsYW1wZWRBcnJheSIsImlzVWludDE2QXJyYXkiLCJpc1VpbnQzMkFycmF5IiwiaXNJbnQ4QXJyYXkiLCJpc0ludDE2QXJyYXkiLCJpc0ludDMyQXJyYXkiLCJpc0Zsb2F0MzJBcnJheSIsImlzRmxvYXQ2NEFycmF5IiwiaXNCaWdJbnQ2NEFycmF5IiwiaXNCaWdVaW50NjRBcnJheSIsImlzTWFwVG9TdHJpbmciLCJ3b3JraW5nIiwiaXNNYXAiLCJpc1NldFRvU3RyaW5nIiwiaXNTZXQiLCJpc1dlYWtNYXBUb1N0cmluZyIsImlzV2Vha01hcCIsImlzV2Vha1NldFRvU3RyaW5nIiwiaXNXZWFrU2V0IiwiaXNBcnJheUJ1ZmZlclRvU3RyaW5nIiwiaXNBcnJheUJ1ZmZlciIsImlzRGF0YVZpZXdUb1N0cmluZyIsInVuZGVmaW5lZCIsImlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyIsImlzU2hhcmVkQXJyYXlCdWZmZXIiLCJpc0FzeW5jRnVuY3Rpb24iLCJpc01hcEl0ZXJhdG9yIiwiaXNTZXRJdGVyYXRvciIsImlzR2VuZXJhdG9yT2JqZWN0IiwiaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlIiwiaXNOdW1iZXJPYmplY3QiLCJpc1N0cmluZ09iamVjdCIsImlzQm9vbGVhbk9iamVjdCIsImlzQmlnSW50T2JqZWN0IiwiaXNTeW1ib2xPYmplY3QiLCJpc0JveGVkUHJpbWl0aXZlIiwiaXNBbnlBcnJheUJ1ZmZlciIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImZvcm1hdCIsImlzU3RyaW5nIiwiaW5zcGVjdCIsInN0cmluZ2lmeSIsImlzTnVsbCIsImlzT2JqZWN0IiwiZGVwcmVjYXRlIiwicHJvY2VzcyIsIm5vRGVwcmVjYXRpb24iLCJkZXByZWNhdGVkIiwidGhyb3dEZXByZWNhdGlvbiIsInRyYWNlRGVwcmVjYXRpb24iLCJjb25zb2xlIiwidHJhY2UiLCJlcnJvciIsImVudiIsIk5PREVfREVCVUciLCJ0b1VwcGVyQ2FzZSIsImRlYnVnbG9nIiwicGlkIiwic2VlbiIsInN0eWxpemUiLCJzdHlsaXplTm9Db2xvciIsImRlcHRoIiwiY29sb3JzIiwiaXNCb29sZWFuIiwic2hvd0hpZGRlbiIsIl9leHRlbmQiLCJpc1VuZGVmaW5lZCIsImN1c3RvbUluc3BlY3QiLCJzdHlsaXplV2l0aENvbG9yIiwiZm9ybWF0VmFsdWUiLCJib2xkIiwiaXRhbGljIiwidW5kZXJsaW5lIiwiaW52ZXJzZSIsIndoaXRlIiwiZ3JleSIsImJsYWNrIiwiYmx1ZSIsImN5YW4iLCJncmVlbiIsIm1hZ2VudGEiLCJyZWQiLCJ5ZWxsb3ciLCJzdHlsZXMiLCJzcGVjaWFsIiwibnVtYmVyIiwiYm9vbGVhbiIsIm51bGwiLCJzdHJpbmciLCJkYXRlIiwicmVnZXhwIiwiYXJyYXlUb0hhc2giLCJpc0Z1bmN0aW9uIiwiZm9ybWF0UHJpbWl0aXZlIiwiaXNFcnJvciIsImZvcm1hdEVycm9yIiwiaXNSZWdFeHAiLCJpc0RhdGUiLCJpc0FycmF5IiwidG9VVENTdHJpbmciLCJmb3JtYXRBcnJheSIsIm1hcCIsImZvcm1hdFByb3BlcnR5IiwicG9wIiwicmVkdWNlVG9TaW5nbGVTdHJpbmciLCJpc051bWJlciIsIm1hdGNoIiwic2V0Iiwic3BsaXQiLCJzdWJzdHIiLCJyZWR1Y2UiLCJ0eXBlcyIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNTeW1ib2wiLCJvYmplY3RUb1N0cmluZyIsImlzTmF0aXZlRXJyb3IiLCJpc1ByaW1pdGl2ZSIsInBhZCIsInRpbWVzdGFtcCIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJsb2ciLCJwcm9taXNpZnkiLCJzZXRQcm90b3R5cGVPZiIsImRlZmluZVByb3BlcnRpZXMiLCJjdXN0b20iLCJjYWxsYmFja2lmeU9uUmVqZWN0ZWQiLCJyZWFzb24iLCJjYWxsYmFja2lmeSIsImNhbGxiYWNraWZpZWQiLCJjYiIsIm5leHRUaWNrIiwid2hpY2hUeXBlZEFycmF5IiwiYXZhaWxhYmxlVHlwZWRBcnJheXMiLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/util/util.js\n"));

/***/ }),

/***/ "./node_modules/next/image.js":
/*!************************************!*\
  !*** ./node_modules/next/image.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/image */ \"./node_modules/next/dist/client/image.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQUEsMkdBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvaW1hZ2UuanM/MDUzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGllbnQvaW1hZ2UnKVxyXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/image.js\n"));

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/link */ \"./node_modules/next/dist/client/link.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBQSx5R0FBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzPzc1YjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxyXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/link.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/** @license React v17.0.2\r\n * react-jsx-dev-runtime.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n\n\nif (true) {\n  (function () {\n    'use strict';\n\n    var React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n    var _assign = __webpack_require__(/*! object-assign */ \"./node_modules/next/dist/build/polyfills/object-assign.js\"); // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n\n    var REACT_ELEMENT_TYPE = 0xeac7;\n    var REACT_PORTAL_TYPE = 0xeaca;\n    exports.Fragment = 0xeacb;\n    var REACT_STRICT_MODE_TYPE = 0xeacc;\n    var REACT_PROFILER_TYPE = 0xead2;\n    var REACT_PROVIDER_TYPE = 0xeacd;\n    var REACT_CONTEXT_TYPE = 0xeace;\n    var REACT_FORWARD_REF_TYPE = 0xead0;\n    var REACT_SUSPENSE_TYPE = 0xead1;\n    var REACT_SUSPENSE_LIST_TYPE = 0xead8;\n    var REACT_MEMO_TYPE = 0xead3;\n    var REACT_LAZY_TYPE = 0xead4;\n    var REACT_BLOCK_TYPE = 0xead9;\n    var REACT_SERVER_BLOCK_TYPE = 0xeada;\n    var REACT_FUNDAMENTAL_TYPE = 0xead5;\n    var REACT_SCOPE_TYPE = 0xead7;\n    var REACT_OPAQUE_ID_TYPE = 0xeae0;\n    var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\n    var REACT_OFFSCREEN_TYPE = 0xeae2;\n    var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\n\n    if (typeof Symbol === 'function' && Symbol.for) {\n      var symbolFor = Symbol.for;\n      REACT_ELEMENT_TYPE = symbolFor('react.element');\n      REACT_PORTAL_TYPE = symbolFor('react.portal');\n      exports.Fragment = symbolFor('react.fragment');\n      REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\n      REACT_PROFILER_TYPE = symbolFor('react.profiler');\n      REACT_PROVIDER_TYPE = symbolFor('react.provider');\n      REACT_CONTEXT_TYPE = symbolFor('react.context');\n      REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n      REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\n      REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\n      REACT_MEMO_TYPE = symbolFor('react.memo');\n      REACT_LAZY_TYPE = symbolFor('react.lazy');\n      REACT_BLOCK_TYPE = symbolFor('react.block');\n      REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');\n      REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');\n      REACT_SCOPE_TYPE = symbolFor('react.scope');\n      REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');\n      REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\n      REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\n      REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\n    }\n\n    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable !== 'object') {\n        return null;\n      }\n\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n\n      return null;\n    }\n\n    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n    function error(format) {\n      {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        printWarning('error', format, args);\n      }\n    }\n\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        }\n\n        var argsWithFormat = args.map(function (item) {\n          return '' + item;\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    } // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.\n\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n      if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {\n        return true;\n      }\n\n      if (typeof type === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var functionName = innerType.displayName || innerType.name || '';\n      return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n    }\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    }\n\n    function getComponentName(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      switch (type) {\n        case exports.Fragment:\n          return 'Fragment';\n\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n\n        case REACT_PROFILER_TYPE:\n          return 'Profiler';\n\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n\n        case REACT_SUSPENSE_TYPE:\n          return 'Suspense';\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return 'SuspenseList';\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n\n          case REACT_MEMO_TYPE:\n            return getComponentName(type.type);\n\n          case REACT_BLOCK_TYPE:\n            return getComponentName(type._render);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                return getComponentName(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n        }\n      }\n\n      return null;\n    } // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n\n\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n\n    function disabledLog() {}\n\n    disabledLog.__reactDisabledLog = true;\n\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        disabledDepth++;\n      }\n    }\n\n    function reenableLogs() {\n      {\n        disabledDepth--;\n\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: _assign({}, props, {\n              value: prevLog\n            }),\n            info: _assign({}, props, {\n              value: prevInfo\n            }),\n            warn: _assign({}, props, {\n              value: prevWarn\n            }),\n            error: _assign({}, props, {\n              value: prevError\n            }),\n            group: _assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: _assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: _assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n\n    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n        return '\\n' + prefix + name;\n      }\n    }\n\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n\n      {\n        var frame = componentFrameCache.get(fn);\n\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher.current = null;\n        disableLogs();\n      }\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\n\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame('Suspense');\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n          case REACT_BLOCK_TYPE:\n            return describeFunctionComponentFrame(type._render);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n\n      return '';\n    }\n\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n              setCurrentlyValidatingElement(null);\n            }\n\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n\n    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown;\n    var specialPropRefWarningShown;\n    var didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n\n    function warnIfStringRefCannotBeAutoConverted(config, self) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n          var componentName = getComponentName(ReactCurrentOwner.current.type);\n\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n\n    function defineKeyPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingKey = function () {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingKey.isReactWarning = true;\n        Object.defineProperty(props, 'key', {\n          get: warnAboutAccessingKey,\n          configurable: true\n        });\n      }\n    }\n\n    function defineRefPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingRef = function () {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingRef.isReactWarning = true;\n        Object.defineProperty(props, 'ref', {\n          get: warnAboutAccessingRef,\n          configurable: true\n        });\n      }\n    }\n    /**\r\n     * Factory method to create a new React element. This no longer adheres to\r\n     * the class pattern, so do not use new to call it. Also, instanceof check\r\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\r\n     * if something is a React Element.\r\n     *\r\n     * @param {*} type\r\n     * @param {*} props\r\n     * @param {*} key\r\n     * @param {string|object} ref\r\n     * @param {*} owner\r\n     * @param {*} self A *temporary* helper to detect places where `this` is\r\n     * different from the `owner` when React.createElement is called, so that we\r\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\r\n     * functions, and as long as `this` and owner are the same, there will be no\r\n     * change in behavior.\r\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\r\n     * indicating filename, line number, and/or other information.\r\n     * @internal\r\n     */\n\n\n    var ReactElement = function (type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\r\n     * https://github.com/reactjs/rfcs/pull/107\r\n     * @param {*} type\r\n     * @param {object} props\r\n     * @param {string} key\r\n     */\n\n\n    function jsxDEV(type, config, maybeKey, source, self) {\n      {\n        var propName; // Reserved names are extracted\n\n        var props = {};\n        var key = null;\n        var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n        // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n        // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n        // but as an intermediary step, we will use jsxDEV for everything except\n        // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n        // key is explicitly declared to be undefined or not.\n\n        if (maybeKey !== undefined) {\n          key = '' + maybeKey;\n        }\n\n        if (hasValidKey(config)) {\n          key = '' + config.key;\n        }\n\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          warnIfStringRefCannotBeAutoConverted(config, self);\n        } // Remaining properties are added to a new props object\n\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        } // Resolve default props\n\n\n        if (type && type.defaultProps) {\n          var defaultProps = type.defaultProps;\n\n          for (propName in defaultProps) {\n            if (props[propName] === undefined) {\n              props[propName] = defaultProps[propName];\n            }\n          }\n        }\n\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n\n        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n      }\n    }\n\n    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n    /**\r\n     * Verifies the object is a ReactElement.\r\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\r\n     * @param {?object} object\r\n     * @return {boolean} True if `object` is a ReactElement.\r\n     * @final\r\n     */\n\n    function isValidElement(object) {\n      {\n        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n      }\n    }\n\n    function getDeclarationErrorAddendum() {\n      {\n        if (ReactCurrentOwner$1.current) {\n          var name = getComponentName(ReactCurrentOwner$1.current.type);\n\n          if (name) {\n            return '\\n\\nCheck the render method of `' + name + '`.';\n          }\n        }\n\n        return '';\n      }\n    }\n\n    function getSourceInfoErrorAddendum(source) {\n      {\n        if (source !== undefined) {\n          var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n          var lineNumber = source.lineNumber;\n          return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n        }\n\n        return '';\n      }\n    }\n    /**\r\n     * Warn if there's no key explicitly set on dynamic arrays of children or\r\n     * object keys are not valid. This allows us to keep track of children between\r\n     * updates.\r\n     */\n\n\n    var ownerHasKeyUseWarning = {};\n\n    function getCurrentComponentErrorInfo(parentType) {\n      {\n        var info = getDeclarationErrorAddendum();\n\n        if (!info) {\n          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n          if (parentName) {\n            info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n          }\n        }\n\n        return info;\n      }\n    }\n    /**\r\n     * Warn if the element doesn't have an explicit key assigned to it.\r\n     * This element is in an array. The array could grow and shrink or be\r\n     * reordered. All children that haven't already been validated are required to\r\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\r\n     * will only be shown once.\r\n     *\r\n     * @internal\r\n     * @param {ReactElement} element Element that requires a key.\r\n     * @param {*} parentType element's parent's type.\r\n     */\n\n\n    function validateExplicitKey(element, parentType) {\n      {\n        if (!element._store || element._store.validated || element.key != null) {\n          return;\n        }\n\n        element._store.validated = true;\n        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n          return;\n        }\n\n        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n        // property, it may be the creator of the child that's responsible for\n        // assigning it a key.\n\n        var childOwner = '';\n\n        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n          // Give the component that originally created this child.\n          childOwner = \" It was passed a child from \" + getComponentName(element._owner.type) + \".\";\n        }\n\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\r\n     * Ensure that every element either is passed in a static location, in an\r\n     * array with an explicit keys property defined, or in an object literal\r\n     * with valid key property.\r\n     *\r\n     * @internal\r\n     * @param {ReactNode} node Statically passed child of any type.\r\n     * @param {*} parentType node's parent's type.\r\n     */\n\n\n    function validateChildKeys(node, parentType) {\n      {\n        if (typeof node !== 'object') {\n          return;\n        }\n\n        if (Array.isArray(node)) {\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n\n            if (isValidElement(child)) {\n              validateExplicitKey(child, parentType);\n            }\n          }\n        } else if (isValidElement(node)) {\n          // This element was passed in a valid location.\n          if (node._store) {\n            node._store.validated = true;\n          }\n        } else if (node) {\n          var iteratorFn = getIteratorFn(node);\n\n          if (typeof iteratorFn === 'function') {\n            // Entry iterators used to provide implicit keys,\n            // but now we print a separate warning for them later.\n            if (iteratorFn !== node.entries) {\n              var iterator = iteratorFn.call(node);\n              var step;\n\n              while (!(step = iterator.next()).done) {\n                if (isValidElement(step.value)) {\n                  validateExplicitKey(step.value, parentType);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\r\n     * Given an element, validate that its props follow the propTypes definition,\r\n     * provided by the type.\r\n     *\r\n     * @param {ReactElement} element\r\n     */\n\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n\n        var propTypes;\n\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentName(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentName(type);\n\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\r\n     * Given a fragment, validate that it can only be provided with fragment props\r\n     * @param {ReactElement} fragment\r\n     */\n\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n\n    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n      {\n        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n        // succeed and there will likely be errors in render.\n\n        if (!validType) {\n          var info = '';\n\n          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n            info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n          }\n\n          var sourceInfo = getSourceInfoErrorAddendum(source);\n\n          if (sourceInfo) {\n            info += sourceInfo;\n          } else {\n            info += getDeclarationErrorAddendum();\n          }\n\n          var typeString;\n\n          if (type === null) {\n            typeString = 'null';\n          } else if (Array.isArray(type)) {\n            typeString = 'array';\n          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n            typeString = \"<\" + (getComponentName(type.type) || 'Unknown') + \" />\";\n            info = ' Did you accidentally export a JSX literal instead of a component?';\n          } else {\n            typeString = typeof type;\n          }\n\n          error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n\n        var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n        // TODO: Drop this when these are no longer allowed as the type argument.\n\n        if (element == null) {\n          return element;\n        } // Skip key warning if the type isn't valid since our key validation logic\n        // doesn't expect a non-string/function type and can throw confusing errors.\n        // We don't want exception behavior to differ between dev and prod.\n        // (Rendering will throw with a helpful message and as soon as the type is\n        // fixed, the key warnings will appear.)\n\n\n        if (validType) {\n          var children = props.children;\n\n          if (children !== undefined) {\n            if (isStaticChildren) {\n              if (Array.isArray(children)) {\n                for (var i = 0; i < children.length; i++) {\n                  validateChildKeys(children[i], type);\n                }\n\n                if (Object.freeze) {\n                  Object.freeze(children);\n                }\n              } else {\n                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n              }\n            } else {\n              validateChildKeys(children, type);\n            }\n          }\n        }\n\n        if (type === exports.Fragment) {\n          validateFragmentProps(element);\n        } else {\n          validatePropTypes(element);\n        }\n\n        return element;\n      }\n    } // These two functions exist to still get child warnings in dev\n\n\n    var jsxDEV$1 = jsxWithValidation;\n    exports.jsxDEV = jsxDEV$1;\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRWE7O0FBRWIsSUFBSUEsSUFBSixFQUEyQztFQUN6QyxDQUFDLFlBQVc7SUFDZDs7SUFFQSxJQUFJRyxLQUFLLEdBQUdDLG1CQUFPLENBQUMsNENBQUQsQ0FBbkI7O0lBQ0EsSUFBSUMsT0FBTyxHQUFHRCxtQkFBTyxDQUFDLGdGQUFELENBQXJCLENBSmMsQ0FNZDtJQUNBO0lBQ0E7SUFDQTtJQUNBOzs7SUFDQSxJQUFJRSxrQkFBa0IsR0FBRyxNQUF6QjtJQUNBLElBQUlDLGlCQUFpQixHQUFHLE1BQXhCO0lBQ0FDLGdCQUFBLEdBQW1CLE1BQW5CO0lBQ0EsSUFBSUUsc0JBQXNCLEdBQUcsTUFBN0I7SUFDQSxJQUFJQyxtQkFBbUIsR0FBRyxNQUExQjtJQUNBLElBQUlDLG1CQUFtQixHQUFHLE1BQTFCO0lBQ0EsSUFBSUMsa0JBQWtCLEdBQUcsTUFBekI7SUFDQSxJQUFJQyxzQkFBc0IsR0FBRyxNQUE3QjtJQUNBLElBQUlDLG1CQUFtQixHQUFHLE1BQTFCO0lBQ0EsSUFBSUMsd0JBQXdCLEdBQUcsTUFBL0I7SUFDQSxJQUFJQyxlQUFlLEdBQUcsTUFBdEI7SUFDQSxJQUFJQyxlQUFlLEdBQUcsTUFBdEI7SUFDQSxJQUFJQyxnQkFBZ0IsR0FBRyxNQUF2QjtJQUNBLElBQUlDLHVCQUF1QixHQUFHLE1BQTlCO0lBQ0EsSUFBSUMsc0JBQXNCLEdBQUcsTUFBN0I7SUFDQSxJQUFJQyxnQkFBZ0IsR0FBRyxNQUF2QjtJQUNBLElBQUlDLG9CQUFvQixHQUFHLE1BQTNCO0lBQ0EsSUFBSUMsNkJBQTZCLEdBQUcsTUFBcEM7SUFDQSxJQUFJQyxvQkFBb0IsR0FBRyxNQUEzQjtJQUNBLElBQUlDLHdCQUF3QixHQUFHLE1BQS9COztJQUVBLElBQUksT0FBT0Ms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Q0FBRCxDQUFULEVBQWNoSyxJQUFkLENBQWpCO2dCQUNEOztnQkFFRCxJQUFJNkMsTUFBTSxDQUFDeUYsTUFBWCxFQUFtQjtrQkFDakJ6RixNQUFNLENBQUN5RixNQUFQLENBQWMrQyxRQUFkO2dCQUNEO2NBQ0YsQ0FSRCxNQVFPO2dCQUNMOU0sS0FBSyxDQUFDLDJEQUEyRCxnRUFBM0QsR0FBOEgsa0NBQS9ILENBQUw7Y0FDRDtZQUNGLENBWkQsTUFZTztjQUNMc0wsaUJBQWlCLENBQUN3QixRQUFELEVBQVdyTCxJQUFYLENBQWpCO1lBQ0Q7VUFDRjtRQUNGOztRQUVELElBQUlBLElBQUksS0FBS3ZELE9BQU8sQ0FBQ0MsUUFBckIsRUFBK0I7VUFDN0JtTyxxQkFBcUIsQ0FBQ2pGLE9BQUQsQ0FBckI7UUFDRCxDQUZELE1BRU87VUFDTDJFLGlCQUFpQixDQUFDM0UsT0FBRCxDQUFqQjtRQUNEOztRQUVELE9BQU9BLE9BQVA7TUFDRDtJQUNGLENBaHFDYSxDQWdxQ1o7OztJQUVGLElBQUkwRixRQUFRLEdBQUlOLGlCQUFoQjtJQUVBdk8sY0FBQSxHQUFpQjZPLFFBQWpCO0VBQ0csQ0FycUNEO0FBc3FDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz8xN2UxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXHJcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgKGZ1bmN0aW9uKCkge1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcclxuXHJcbi8vIEFUVEVOVElPTlxyXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXHJcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcclxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcclxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxyXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xyXG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XHJcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XHJcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gMHhlYWNjO1xyXG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IDB4ZWFkMjtcclxudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XHJcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XHJcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xyXG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IDB4ZWFkMTtcclxudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcclxudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcclxudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcclxudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XHJcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcclxudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XHJcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xyXG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XHJcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcclxudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xyXG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xyXG5cclxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xyXG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xyXG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xyXG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcclxuICBleHBvcnRzLkZyYWdtZW50ID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xyXG4gIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XHJcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcclxuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xyXG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xyXG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XHJcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcclxuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcclxuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcclxuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcclxuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xyXG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcclxuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xyXG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XHJcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xyXG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XHJcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xyXG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xyXG59XHJcblxyXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XHJcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcclxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XHJcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcclxuXHJcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcclxuXHJcbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xyXG4gIHtcclxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XHJcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xyXG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xyXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxyXG4gIHtcclxuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcclxuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xyXG5cclxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcclxuICAgICAgZm9ybWF0ICs9ICclcyc7XHJcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xyXG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XHJcblxyXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XHJcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXHJcblxyXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxyXG5cclxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XHJcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxyXG5cclxuXHJcbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSApIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XHJcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSB8fCB0eXBlWzBdID09PSBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XHJcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcclxuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XHJcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcclxuICBpZiAodHlwZSA9PSBudWxsKSB7XHJcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAge1xyXG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIHR5cGU7XHJcbiAgfVxyXG5cclxuICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcclxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XHJcblxyXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcclxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xyXG5cclxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcclxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XHJcblxyXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxyXG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xyXG5cclxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcclxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XHJcblxyXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XHJcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xyXG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcclxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XHJcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XHJcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcclxuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XHJcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xyXG5cclxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XHJcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcclxuXHJcbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcclxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xyXG5cclxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xyXG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xyXG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xyXG5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxyXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxyXG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXHJcbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxyXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XHJcbnZhciBwcmV2TG9nO1xyXG52YXIgcHJldkluZm87XHJcbnZhciBwcmV2V2FybjtcclxudmFyIHByZXZFcnJvcjtcclxudmFyIHByZXZHcm91cDtcclxudmFyIHByZXZHcm91cENvbGxhcHNlZDtcclxudmFyIHByZXZHcm91cEVuZDtcclxuXHJcbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cclxuXHJcbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XHJcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xyXG4gIHtcclxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XHJcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xyXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XHJcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xyXG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcclxuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcclxuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcclxuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcclxuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxyXG5cclxuICAgICAgdmFyIHByb3BzID0ge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcclxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xyXG4gICAgICAgIGluZm86IHByb3BzLFxyXG4gICAgICAgIGxvZzogcHJvcHMsXHJcbiAgICAgICAgd2FybjogcHJvcHMsXHJcbiAgICAgICAgZXJyb3I6IHByb3BzLFxyXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcclxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXHJcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXHJcbiAgICAgIH0pO1xyXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xyXG4gICAgfVxyXG5cclxuICAgIGRpc2FibGVkRGVwdGgrKztcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xyXG4gIHtcclxuICAgIGRpc2FibGVkRGVwdGgtLTtcclxuXHJcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xyXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cclxuICAgICAgdmFyIHByb3BzID0ge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XHJcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcclxuICAgICAgICB9KSxcclxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcclxuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pO1xyXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xyXG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XHJcbnZhciBwcmVmaXg7XHJcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xyXG4gIHtcclxuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcclxuICAgICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XHJcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XHJcbiAgICAgIH1cclxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXHJcblxyXG5cclxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XHJcbiAgfVxyXG59XHJcbnZhciByZWVudHJ5ID0gZmFsc2U7XHJcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xyXG5cclxue1xyXG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XHJcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XHJcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXHJcbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG5cclxuICB7XHJcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XHJcblxyXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIGZyYW1lO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIGNvbnRyb2w7XHJcbiAgcmVlbnRyeSA9IHRydWU7XHJcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXHJcblxyXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xyXG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XHJcblxyXG4gIHtcclxuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXHJcbiAgICAvLyBmb3Igd2FybmluZ3MuXHJcblxyXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcclxuICAgIGRpc2FibGVMb2dzKCk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXHJcbiAgICBpZiAoY29uc3RydWN0KSB7XHJcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxyXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aHJvdyBFcnJvcigpO1xyXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXHJcblxyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXHJcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXHJcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XHJcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxyXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcclxuICAgICAgICB9IGNhdGNoICh4KSB7XHJcbiAgICAgICAgICBjb250cm9sID0geDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIEZha2UuY2FsbCgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICAgIGNvbnRyb2wgPSB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcclxuICAgICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAgIGNvbnRyb2wgPSB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmbigpO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xyXG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cclxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xyXG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxyXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cclxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcclxuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xyXG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XHJcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XHJcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXHJcbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxyXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXHJcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcclxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxyXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxyXG4gICAgICAgIGMtLTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XHJcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXHJcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXHJcbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcclxuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXHJcbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXHJcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xyXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxyXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cclxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgIHMtLTtcclxuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cclxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cclxuXHJcbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcclxuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxyXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xyXG5cclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZmluYWxseSB7XHJcbiAgICByZWVudHJ5ID0gZmFsc2U7XHJcblxyXG4gICAge1xyXG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XHJcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xyXG4gICAgfVxyXG5cclxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcclxuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cclxuXHJcblxyXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XHJcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XHJcblxyXG4gIHtcclxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcclxufVxyXG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xyXG4gIHtcclxuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XHJcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XHJcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcclxuXHJcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICB7XHJcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XHJcbiAgfVxyXG5cclxuICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcclxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xyXG5cclxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxyXG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XHJcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcclxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcclxuXHJcbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxyXG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXHJcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XHJcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xyXG5cclxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xyXG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xyXG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xyXG5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXHJcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuICcnO1xyXG59XHJcblxyXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XHJcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcclxuXHJcbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcclxuICB7XHJcbiAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcclxuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcclxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcclxuICB7XHJcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXHJcbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xyXG5cclxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcclxuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcclxuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cclxuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXHJcbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXHJcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xyXG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICBlcnJvciQxID0gZXg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcclxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xyXG5cclxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XHJcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcclxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXHJcbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XHJcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcclxuXHJcbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XHJcblxyXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcclxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xyXG4gIGtleTogdHJ1ZSxcclxuICByZWY6IHRydWUsXHJcbiAgX19zZWxmOiB0cnVlLFxyXG4gIF9fc291cmNlOiB0cnVlXHJcbn07XHJcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcclxudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xyXG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcclxuXHJcbntcclxuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xyXG4gIHtcclxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XHJcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcclxuXHJcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcclxuICB7XHJcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xyXG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XHJcblxyXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xyXG4gIHtcclxuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XHJcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xyXG5cclxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XHJcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcclxuXHJcbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xyXG4gIHtcclxuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcclxuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XHJcblxyXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xyXG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xyXG4gIHtcclxuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcclxuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XHJcblxyXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xyXG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXHJcbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXHJcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xyXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHR5cGVcclxuICogQHBhcmFtIHsqfSBwcm9wc1xyXG4gKiBAcGFyYW0geyp9IGtleVxyXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxyXG4gKiBAcGFyYW0geyp9IG93bmVyXHJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xyXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXHJcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XHJcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cclxuICogY2hhbmdlIGluIGJlaGF2aW9yLlxyXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcclxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5cclxuXHJcbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XHJcbiAgdmFyIGVsZW1lbnQgPSB7XHJcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcclxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXHJcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XHJcbiAgICB0eXBlOiB0eXBlLFxyXG4gICAga2V5OiBrZXksXHJcbiAgICByZWY6IHJlZixcclxuICAgIHByb3BzOiBwcm9wcyxcclxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXHJcbiAgICBfb3duZXI6IG93bmVyXHJcbiAgfTtcclxuXHJcbiAge1xyXG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxyXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cclxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cclxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxyXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcclxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcclxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXHJcbiAgICAvLyBpZ25vcmVzIGl0LlxyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcclxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICB2YWx1ZTogZmFsc2VcclxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcclxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgdmFsdWU6IHNlbGZcclxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxyXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xyXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICB2YWx1ZTogc291cmNlXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xyXG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xyXG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcbi8qKlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XHJcbiAqIEBwYXJhbSB7Kn0gdHlwZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcclxuICB7XHJcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcclxuXHJcbiAgICB2YXIgcHJvcHMgPSB7fTtcclxuICAgIHZhciBrZXkgPSBudWxsO1xyXG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxyXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XHJcbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxyXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XHJcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxyXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cclxuXHJcbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XHJcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xyXG4gICAgICByZWYgPSBjb25maWcucmVmO1xyXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcclxuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxyXG5cclxuXHJcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xyXG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XHJcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcclxuICAgICAgfVxyXG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcclxuXHJcblxyXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcclxuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xyXG5cclxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcclxuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGtleSB8fCByZWYpIHtcclxuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xyXG5cclxuICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZWYpIHtcclxuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xyXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcclxuXHJcbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xyXG4gIHtcclxuICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xyXG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xyXG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XHJcblxyXG57XHJcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcclxufVxyXG4vKipcclxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cclxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxyXG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxyXG4gKiBAZmluYWxcclxuICovXHJcblxyXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcclxuICB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xyXG4gIHtcclxuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcclxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcclxuXHJcbiAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XHJcbiAge1xyXG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XHJcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XHJcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxyXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cclxuICogdXBkYXRlcy5cclxuICovXHJcblxyXG5cclxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xyXG5cclxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XHJcbiAge1xyXG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcclxuXHJcbiAgICBpZiAoIWluZm8pIHtcclxuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XHJcblxyXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xyXG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpbmZvO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxyXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcclxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXHJcbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xyXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cclxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcclxuICB7XHJcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xyXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xyXG5cclxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXHJcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXHJcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXHJcblxyXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcclxuXHJcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XHJcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxyXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcclxuXHJcbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcclxuXHJcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxyXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcclxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cclxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XHJcbiAge1xyXG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcclxuXHJcbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xyXG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XHJcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXHJcbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xyXG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xyXG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXHJcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXHJcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xyXG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xyXG4gICAgICAgICAgdmFyIHN0ZXA7XHJcblxyXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxyXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cclxuICpcclxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xyXG4gIHtcclxuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xyXG5cclxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcm9wVHlwZXM7XHJcblxyXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxyXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXHJcbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XHJcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwcm9wVHlwZXMpIHtcclxuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcclxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xyXG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XHJcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcclxuXHJcbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XHJcblxyXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xyXG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4vKipcclxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXHJcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcclxuICB7XHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcblxyXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcclxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcclxuXHJcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xyXG5cclxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xyXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcclxuXHJcbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xyXG5cclxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xyXG4gIHtcclxuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXHJcbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxyXG5cclxuICAgIGlmICghdmFsaWRUeXBlKSB7XHJcbiAgICAgIHZhciBpbmZvID0gJyc7XHJcblxyXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcclxuXHJcbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB0eXBlU3RyaW5nO1xyXG5cclxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcclxuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xyXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcclxuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcclxuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XHJcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcclxuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXHJcbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXHJcblxyXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcclxuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cclxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cclxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXHJcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXHJcblxyXG5cclxuICAgIGlmICh2YWxpZFR5cGUpIHtcclxuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XHJcblxyXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcclxuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xyXG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxuICB9XHJcbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XHJcblxyXG52YXIganN4REVWJDEgPSAganN4V2l0aFZhbGlkYXRpb24gO1xyXG5cclxuZXhwb3J0cy5qc3hERVYgPSBqc3hERVYkMTtcclxuICB9KSgpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJSZWFjdCIsInJlcXVpcmUiLCJfYXNzaWduIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJleHBvcnRzIiwiRnJhZ21lbnQiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX0JMT0NLX1RZUEUiLCJSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSIsIlJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUiLCJSRUFDVF9TQ09QRV9UWVBFIiwiUkVBQ1RfT1BBUVVFX0lEX1RZUEUiLCJSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIiwiU3ltYm9sIiwiZm9yIiwic3ltYm9sRm9yIiwiTUFZQkVfSVRFUkFUT1JfU1lNQk9MIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwibWF5YmVJdGVyYXRvciIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJlcnJvciIsImZvcm1hdCIsIl9sZW4yIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleTIiLCJwcmludFdhcm5pbmciLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJzdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiZW5hYmxlU2NvcGVBUEkiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZnVuY3Rpb25OYW1lIiwiZGlzcGxheU5hbWUiLCJuYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lIiwidGFnIiwiY29udGV4dCIsInByb3ZpZGVyIiwiX2NvbnRleHQiLCJyZW5kZXIiLCJfcmVuZGVyIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJ1bmRlZmluZWQiLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwiY29udHJvbCIsInByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsImN1cnJlbnQiLCJGYWtlIiwiZGVmaW5lUHJvcGVydHkiLCJzZXQiLCJSZWZsZWN0Iiwic2FtcGxlIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiX2ZyYW1lIiwicmVwbGFjZSIsInN5bnRoZXRpY0ZyYW1lIiwiZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lIiwic2hvdWxkQ29uc3RydWN0IiwiQ29tcG9uZW50IiwiaXNSZWFjdENvbXBvbmVudCIsImRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFViIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50IiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsImhhc093blByb3BlcnR5IiwidHlwZVNwZWNOYW1lIiwiZXJyb3IkMSIsImVyciIsImV4IiwibWVzc2FnZSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYiLCJtYXliZUtleSIsInByb3BOYW1lIiwiZGVmYXVsdFByb3BzIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpc0FycmF5IiwiaSIsImNoaWxkIiwiaXRlcmF0b3JGbiIsImVudHJpZXMiLCJzdGVwIiwibmV4dCIsImRvbmUiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsIl9uYW1lIiwiZ2V0RGVmYXVsdFByb3BzIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJmcmFnbWVudCIsImtleXMiLCJqc3hXaXRoVmFsaWRhdGlvbiIsImlzU3RhdGljQ2hpbGRyZW4iLCJ2YWxpZFR5cGUiLCJzb3VyY2VJbmZvIiwidHlwZVN0cmluZyIsImNoaWxkcmVuIiwianN4REVWJDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/** @license React v17.0.2\r\n * react-jsx-runtime.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n\n\nif (true) {\n  (function () {\n    'use strict';\n\n    var React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n    var _assign = __webpack_require__(/*! object-assign */ \"./node_modules/next/dist/build/polyfills/object-assign.js\"); // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n\n    var REACT_ELEMENT_TYPE = 0xeac7;\n    var REACT_PORTAL_TYPE = 0xeaca;\n    exports.Fragment = 0xeacb;\n    var REACT_STRICT_MODE_TYPE = 0xeacc;\n    var REACT_PROFILER_TYPE = 0xead2;\n    var REACT_PROVIDER_TYPE = 0xeacd;\n    var REACT_CONTEXT_TYPE = 0xeace;\n    var REACT_FORWARD_REF_TYPE = 0xead0;\n    var REACT_SUSPENSE_TYPE = 0xead1;\n    var REACT_SUSPENSE_LIST_TYPE = 0xead8;\n    var REACT_MEMO_TYPE = 0xead3;\n    var REACT_LAZY_TYPE = 0xead4;\n    var REACT_BLOCK_TYPE = 0xead9;\n    var REACT_SERVER_BLOCK_TYPE = 0xeada;\n    var REACT_FUNDAMENTAL_TYPE = 0xead5;\n    var REACT_SCOPE_TYPE = 0xead7;\n    var REACT_OPAQUE_ID_TYPE = 0xeae0;\n    var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\n    var REACT_OFFSCREEN_TYPE = 0xeae2;\n    var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\n\n    if (typeof Symbol === 'function' && Symbol.for) {\n      var symbolFor = Symbol.for;\n      REACT_ELEMENT_TYPE = symbolFor('react.element');\n      REACT_PORTAL_TYPE = symbolFor('react.portal');\n      exports.Fragment = symbolFor('react.fragment');\n      REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\n      REACT_PROFILER_TYPE = symbolFor('react.profiler');\n      REACT_PROVIDER_TYPE = symbolFor('react.provider');\n      REACT_CONTEXT_TYPE = symbolFor('react.context');\n      REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n      REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\n      REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\n      REACT_MEMO_TYPE = symbolFor('react.memo');\n      REACT_LAZY_TYPE = symbolFor('react.lazy');\n      REACT_BLOCK_TYPE = symbolFor('react.block');\n      REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');\n      REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');\n      REACT_SCOPE_TYPE = symbolFor('react.scope');\n      REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');\n      REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\n      REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\n      REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\n    }\n\n    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable !== 'object') {\n        return null;\n      }\n\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n\n      return null;\n    }\n\n    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n    function error(format) {\n      {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        printWarning('error', format, args);\n      }\n    }\n\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        }\n\n        var argsWithFormat = args.map(function (item) {\n          return '' + item;\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    } // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.\n\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n      if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {\n        return true;\n      }\n\n      if (typeof type === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var functionName = innerType.displayName || innerType.name || '';\n      return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n    }\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    }\n\n    function getComponentName(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      switch (type) {\n        case exports.Fragment:\n          return 'Fragment';\n\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n\n        case REACT_PROFILER_TYPE:\n          return 'Profiler';\n\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n\n        case REACT_SUSPENSE_TYPE:\n          return 'Suspense';\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return 'SuspenseList';\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n\n          case REACT_MEMO_TYPE:\n            return getComponentName(type.type);\n\n          case REACT_BLOCK_TYPE:\n            return getComponentName(type._render);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                return getComponentName(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n        }\n      }\n\n      return null;\n    } // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n\n\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n\n    function disabledLog() {}\n\n    disabledLog.__reactDisabledLog = true;\n\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        disabledDepth++;\n      }\n    }\n\n    function reenableLogs() {\n      {\n        disabledDepth--;\n\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: _assign({}, props, {\n              value: prevLog\n            }),\n            info: _assign({}, props, {\n              value: prevInfo\n            }),\n            warn: _assign({}, props, {\n              value: prevWarn\n            }),\n            error: _assign({}, props, {\n              value: prevError\n            }),\n            group: _assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: _assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: _assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n\n    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n        return '\\n' + prefix + name;\n      }\n    }\n\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n\n      {\n        var frame = componentFrameCache.get(fn);\n\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher.current = null;\n        disableLogs();\n      }\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\n\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame('Suspense');\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n          case REACT_BLOCK_TYPE:\n            return describeFunctionComponentFrame(type._render);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n\n      return '';\n    }\n\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n              setCurrentlyValidatingElement(null);\n            }\n\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n\n    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown;\n    var specialPropRefWarningShown;\n    var didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n\n    function warnIfStringRefCannotBeAutoConverted(config, self) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n          var componentName = getComponentName(ReactCurrentOwner.current.type);\n\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n\n    function defineKeyPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingKey = function () {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingKey.isReactWarning = true;\n        Object.defineProperty(props, 'key', {\n          get: warnAboutAccessingKey,\n          configurable: true\n        });\n      }\n    }\n\n    function defineRefPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingRef = function () {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingRef.isReactWarning = true;\n        Object.defineProperty(props, 'ref', {\n          get: warnAboutAccessingRef,\n          configurable: true\n        });\n      }\n    }\n    /**\r\n     * Factory method to create a new React element. This no longer adheres to\r\n     * the class pattern, so do not use new to call it. Also, instanceof check\r\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\r\n     * if something is a React Element.\r\n     *\r\n     * @param {*} type\r\n     * @param {*} props\r\n     * @param {*} key\r\n     * @param {string|object} ref\r\n     * @param {*} owner\r\n     * @param {*} self A *temporary* helper to detect places where `this` is\r\n     * different from the `owner` when React.createElement is called, so that we\r\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\r\n     * functions, and as long as `this` and owner are the same, there will be no\r\n     * change in behavior.\r\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\r\n     * indicating filename, line number, and/or other information.\r\n     * @internal\r\n     */\n\n\n    var ReactElement = function (type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\r\n     * https://github.com/reactjs/rfcs/pull/107\r\n     * @param {*} type\r\n     * @param {object} props\r\n     * @param {string} key\r\n     */\n\n\n    function jsxDEV(type, config, maybeKey, source, self) {\n      {\n        var propName; // Reserved names are extracted\n\n        var props = {};\n        var key = null;\n        var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n        // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n        // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n        // but as an intermediary step, we will use jsxDEV for everything except\n        // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n        // key is explicitly declared to be undefined or not.\n\n        if (maybeKey !== undefined) {\n          key = '' + maybeKey;\n        }\n\n        if (hasValidKey(config)) {\n          key = '' + config.key;\n        }\n\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          warnIfStringRefCannotBeAutoConverted(config, self);\n        } // Remaining properties are added to a new props object\n\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        } // Resolve default props\n\n\n        if (type && type.defaultProps) {\n          var defaultProps = type.defaultProps;\n\n          for (propName in defaultProps) {\n            if (props[propName] === undefined) {\n              props[propName] = defaultProps[propName];\n            }\n          }\n        }\n\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n\n        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n      }\n    }\n\n    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n    /**\r\n     * Verifies the object is a ReactElement.\r\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\r\n     * @param {?object} object\r\n     * @return {boolean} True if `object` is a ReactElement.\r\n     * @final\r\n     */\n\n    function isValidElement(object) {\n      {\n        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n      }\n    }\n\n    function getDeclarationErrorAddendum() {\n      {\n        if (ReactCurrentOwner$1.current) {\n          var name = getComponentName(ReactCurrentOwner$1.current.type);\n\n          if (name) {\n            return '\\n\\nCheck the render method of `' + name + '`.';\n          }\n        }\n\n        return '';\n      }\n    }\n\n    function getSourceInfoErrorAddendum(source) {\n      {\n        if (source !== undefined) {\n          var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n          var lineNumber = source.lineNumber;\n          return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n        }\n\n        return '';\n      }\n    }\n    /**\r\n     * Warn if there's no key explicitly set on dynamic arrays of children or\r\n     * object keys are not valid. This allows us to keep track of children between\r\n     * updates.\r\n     */\n\n\n    var ownerHasKeyUseWarning = {};\n\n    function getCurrentComponentErrorInfo(parentType) {\n      {\n        var info = getDeclarationErrorAddendum();\n\n        if (!info) {\n          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n          if (parentName) {\n            info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n          }\n        }\n\n        return info;\n      }\n    }\n    /**\r\n     * Warn if the element doesn't have an explicit key assigned to it.\r\n     * This element is in an array. The array could grow and shrink or be\r\n     * reordered. All children that haven't already been validated are required to\r\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\r\n     * will only be shown once.\r\n     *\r\n     * @internal\r\n     * @param {ReactElement} element Element that requires a key.\r\n     * @param {*} parentType element's parent's type.\r\n     */\n\n\n    function validateExplicitKey(element, parentType) {\n      {\n        if (!element._store || element._store.validated || element.key != null) {\n          return;\n        }\n\n        element._store.validated = true;\n        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n          return;\n        }\n\n        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n        // property, it may be the creator of the child that's responsible for\n        // assigning it a key.\n\n        var childOwner = '';\n\n        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n          // Give the component that originally created this child.\n          childOwner = \" It was passed a child from \" + getComponentName(element._owner.type) + \".\";\n        }\n\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\r\n     * Ensure that every element either is passed in a static location, in an\r\n     * array with an explicit keys property defined, or in an object literal\r\n     * with valid key property.\r\n     *\r\n     * @internal\r\n     * @param {ReactNode} node Statically passed child of any type.\r\n     * @param {*} parentType node's parent's type.\r\n     */\n\n\n    function validateChildKeys(node, parentType) {\n      {\n        if (typeof node !== 'object') {\n          return;\n        }\n\n        if (Array.isArray(node)) {\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n\n            if (isValidElement(child)) {\n              validateExplicitKey(child, parentType);\n            }\n          }\n        } else if (isValidElement(node)) {\n          // This element was passed in a valid location.\n          if (node._store) {\n            node._store.validated = true;\n          }\n        } else if (node) {\n          var iteratorFn = getIteratorFn(node);\n\n          if (typeof iteratorFn === 'function') {\n            // Entry iterators used to provide implicit keys,\n            // but now we print a separate warning for them later.\n            if (iteratorFn !== node.entries) {\n              var iterator = iteratorFn.call(node);\n              var step;\n\n              while (!(step = iterator.next()).done) {\n                if (isValidElement(step.value)) {\n                  validateExplicitKey(step.value, parentType);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\r\n     * Given an element, validate that its props follow the propTypes definition,\r\n     * provided by the type.\r\n     *\r\n     * @param {ReactElement} element\r\n     */\n\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n\n        var propTypes;\n\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentName(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentName(type);\n\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\r\n     * Given a fragment, validate that it can only be provided with fragment props\r\n     * @param {ReactElement} fragment\r\n     */\n\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n\n    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n      {\n        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n        // succeed and there will likely be errors in render.\n\n        if (!validType) {\n          var info = '';\n\n          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n            info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n          }\n\n          var sourceInfo = getSourceInfoErrorAddendum(source);\n\n          if (sourceInfo) {\n            info += sourceInfo;\n          } else {\n            info += getDeclarationErrorAddendum();\n          }\n\n          var typeString;\n\n          if (type === null) {\n            typeString = 'null';\n          } else if (Array.isArray(type)) {\n            typeString = 'array';\n          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n            typeString = \"<\" + (getComponentName(type.type) || 'Unknown') + \" />\";\n            info = ' Did you accidentally export a JSX literal instead of a component?';\n          } else {\n            typeString = typeof type;\n          }\n\n          error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n\n        var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n        // TODO: Drop this when these are no longer allowed as the type argument.\n\n        if (element == null) {\n          return element;\n        } // Skip key warning if the type isn't valid since our key validation logic\n        // doesn't expect a non-string/function type and can throw confusing errors.\n        // We don't want exception behavior to differ between dev and prod.\n        // (Rendering will throw with a helpful message and as soon as the type is\n        // fixed, the key warnings will appear.)\n\n\n        if (validType) {\n          var children = props.children;\n\n          if (children !== undefined) {\n            if (isStaticChildren) {\n              if (Array.isArray(children)) {\n                for (var i = 0; i < children.length; i++) {\n                  validateChildKeys(children[i], type);\n                }\n\n                if (Object.freeze) {\n                  Object.freeze(children);\n                }\n              } else {\n                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n              }\n            } else {\n              validateChildKeys(children, type);\n            }\n          }\n        }\n\n        if (type === exports.Fragment) {\n          validateFragmentProps(element);\n        } else {\n          validatePropTypes(element);\n        }\n\n        return element;\n      }\n    } // These two functions exist to still get child warnings in dev\n    // even with the prod transform. This means that jsxDEV is purely\n    // opt-in behavior for better messages but that we won't stop\n    // giving you warnings if you use production apis.\n\n\n    function jsxWithValidationStatic(type, props, key) {\n      {\n        return jsxWithValidation(type, props, key, true);\n      }\n    }\n\n    function jsxWithValidationDynamic(type, props, key) {\n      {\n        return jsxWithValidation(type, props, key, false);\n      }\n    }\n\n    var jsx = jsxWithValidationDynamic; // we may want to special case jsxs internally to take advantage of static children.\n    // for now we can ship identical prod functions\n\n    var jsxs = jsxWithValidationStatic;\n    exports.jsx = jsx;\n    exports.jsxs = jsxs;\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFYTs7QUFFYixJQUFJQSxJQUFKLEVBQTJDO0VBQ3pDLENBQUMsWUFBVztJQUNkOztJQUVBLElBQUlHLEtBQUssR0FBR0MsbUJBQU8sQ0FBQyw0Q0FBRCxDQUFuQjs7SUFDQSxJQUFJQyxPQUFPLEdBQUdELG1CQUFPLENBQUMsZ0ZBQUQsQ0FBckIsQ0FKYyxDQU1kO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7OztJQUNBLElBQUlFLGtCQUFrQixHQUFHLE1BQXpCO0lBQ0EsSUFBSUMsaUJBQWlCLEdBQUcsTUFBeEI7SUFDQUMsZ0JBQUEsR0FBbUIsTUFBbkI7SUFDQSxJQUFJRSxzQkFBc0IsR0FBRyxNQUE3QjtJQUNBLElBQUlDLG1CQUFtQixHQUFHLE1BQTFCO0lBQ0EsSUFBSUMsbUJBQW1CLEdBQUcsTUFBMUI7SUFDQSxJQUFJQyxrQkFBa0IsR0FBRyxNQUF6QjtJQUNBLElBQUlDLHNCQUFzQixHQUFHLE1BQTdCO0lBQ0EsSUFBSUMsbUJBQW1CLEdBQUcsTUFBMUI7SUFDQSxJQUFJQyx3QkFBd0IsR0FBRyxNQUEvQjtJQUNBLElBQUlDLGVBQWUsR0FBRyxNQUF0QjtJQUNBLElBQUlDLGVBQWUsR0FBRyxNQUF0QjtJQUNBLElBQUlDLGdCQUFnQixHQUFHLE1BQXZCO0lBQ0EsSUFBSUMsdUJBQXVCLEdBQUcsTUFBOUI7SUFDQSxJQUFJQyxzQkFBc0IsR0FBRyxNQUE3QjtJQUNBLElBQUlDLGdCQUFnQixHQUFHLE1BQXZCO0lBQ0EsSUFBSUMsb0JBQW9CLEdBQUcsTUFBM0I7SUFDQSxJQUFJQyw2QkFBNkIsR0FBRyxNQUFwQztJQUNBLElBQUlDLG9CQUFvQixHQUFHLE1BQTNCO0lBQ0EsSUFBSUMsd0JBQXdCLEdBQUcsTUFBL0I7O0lBRUEsSUFBSSxPQUFPQyxNQUFQ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Q0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcz8yZmMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXHJcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAoZnVuY3Rpb24oKSB7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxuLy8gQVRURU5USU9OXHJcbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcclxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xyXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxyXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXHJcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XHJcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcclxuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcclxudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAweGVhY2M7XHJcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gMHhlYWQyO1xyXG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcclxudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcclxudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XHJcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gMHhlYWQxO1xyXG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xyXG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xyXG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xyXG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcclxudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xyXG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcclxudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XHJcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcclxudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xyXG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XHJcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XHJcblxyXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XHJcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XHJcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XHJcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xyXG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XHJcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcclxuICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xyXG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XHJcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XHJcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcclxuICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xyXG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xyXG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xyXG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xyXG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XHJcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xyXG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XHJcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcclxuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XHJcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcclxuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XHJcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XHJcbn1cclxuXHJcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcclxudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xyXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcclxuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xyXG5cclxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xyXG5cclxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XHJcbiAge1xyXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcclxuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcclxuICAgIH1cclxuXHJcbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XHJcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXHJcbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXHJcbiAge1xyXG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xyXG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XHJcblxyXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xyXG4gICAgICBmb3JtYXQgKz0gJyVzJztcclxuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XHJcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcclxuXHJcbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcclxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcclxuXHJcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXHJcblxyXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxyXG5cclxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXHJcblxyXG5cclxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcclxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFIHx8IHR5cGVbMF0gPT09IFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcclxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xyXG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcclxuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xyXG4gIGlmICh0eXBlID09IG51bGwpIHtcclxuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICB7XHJcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xyXG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gdHlwZTtcclxuICB9XHJcblxyXG4gIHN3aXRjaCAodHlwZSkge1xyXG4gICAgY2FzZSBleHBvcnRzLkZyYWdtZW50OlxyXG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcclxuXHJcbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxyXG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XHJcblxyXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxyXG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcclxuXHJcbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XHJcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XHJcblxyXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxyXG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcclxuXHJcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcclxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XHJcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxyXG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcclxuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcclxuXHJcbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcclxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xyXG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcclxuXHJcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcclxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcclxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xyXG5cclxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxyXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcclxuICAgICAgICB7XHJcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XHJcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XHJcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XHJcblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XHJcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXHJcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XHJcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cclxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXHJcbnZhciBkaXNhYmxlZERlcHRoID0gMDtcclxudmFyIHByZXZMb2c7XHJcbnZhciBwcmV2SW5mbztcclxudmFyIHByZXZXYXJuO1xyXG52YXIgcHJldkVycm9yO1xyXG52YXIgcHJldkdyb3VwO1xyXG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xyXG52YXIgcHJldkdyb3VwRW5kO1xyXG5cclxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxyXG5cclxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcclxuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XHJcbiAge1xyXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcclxuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXHJcbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcclxuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XHJcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xyXG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xyXG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xyXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xyXG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XHJcblxyXG4gICAgICB2YXIgcHJvcHMgPSB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XHJcbiAgICAgICAgaW5mbzogcHJvcHMsXHJcbiAgICAgICAgbG9nOiBwcm9wcyxcclxuICAgICAgICB3YXJuOiBwcm9wcyxcclxuICAgICAgICBlcnJvcjogcHJvcHMsXHJcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxyXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcclxuICAgICAgICBncm91cEVuZDogcHJvcHNcclxuICAgICAgfSk7XHJcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXHJcbiAgICB9XHJcblxyXG4gICAgZGlzYWJsZWREZXB0aCsrO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XHJcbiAge1xyXG4gICAgZGlzYWJsZWREZXB0aC0tO1xyXG5cclxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XHJcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xyXG4gICAgICB2YXIgcHJvcHMgPSB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcclxuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XHJcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XHJcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cclxuICAgICAgICB9KSxcclxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XHJcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XHJcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XHJcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XHJcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXHJcbiAgICAgICAgfSlcclxuICAgICAgfSk7XHJcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XHJcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcclxudmFyIHByZWZpeDtcclxuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XHJcbiAge1xyXG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aHJvdyBFcnJvcigpO1xyXG4gICAgICB9IGNhdGNoICh4KSB7XHJcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcclxuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcclxuICAgICAgfVxyXG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cclxuXHJcblxyXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcclxuICB9XHJcbn1cclxudmFyIHJlZW50cnkgPSBmYWxzZTtcclxudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XHJcblxyXG57XHJcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcclxuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcclxuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cclxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcblxyXG4gIHtcclxuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcclxuXHJcbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gZnJhbWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgY29udHJvbDtcclxuICByZWVudHJ5ID0gdHJ1ZTtcclxuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cclxuXHJcbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XHJcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcclxuXHJcbiAge1xyXG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cclxuICAgIC8vIGZvciB3YXJuaW5ncy5cclxuXHJcbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgZGlzYWJsZUxvZ3MoKTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cclxuICAgIGlmIChjb25zdHJ1Y3QpIHtcclxuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXHJcbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRocm93IEVycm9yKCk7XHJcbiAgICAgIH07IC8vICRGbG93Rml4TWVcclxuXHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcclxuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cclxuICAgICAgICAgIHRocm93IEVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcclxuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXHJcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xyXG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICAgIGNvbnRyb2wgPSB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgRmFrZS5jYWxsKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAgICAgY29udHJvbCA9IHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aHJvdyBFcnJvcigpO1xyXG4gICAgICB9IGNhdGNoICh4KSB7XHJcbiAgICAgICAgY29udHJvbCA9IHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZuKCk7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoc2FtcGxlKSB7XHJcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxyXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXHJcbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxyXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xyXG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XHJcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcclxuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcclxuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cclxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXHJcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcclxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxyXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXHJcbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXHJcbiAgICAgICAgYy0tO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcclxuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcclxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cclxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xyXG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cclxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcclxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXHJcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXHJcbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxyXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgcy0tO1xyXG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxyXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxyXG5cclxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXHJcbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XHJcblxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIHJlZW50cnkgPSBmYWxzZTtcclxuXHJcbiAgICB7XHJcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcclxuICAgICAgcmVlbmFibGVMb2dzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xyXG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxyXG5cclxuXHJcbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcclxuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcclxuXHJcbiAge1xyXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xyXG59XHJcbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XHJcbiAge1xyXG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcclxuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcclxuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xyXG5cclxuICBpZiAodHlwZSA9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHtcclxuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcclxuICB9XHJcblxyXG4gIHN3aXRjaCAodHlwZSkge1xyXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxyXG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XHJcblxyXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XHJcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcclxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxyXG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xyXG5cclxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XHJcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cclxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcclxuXHJcbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcclxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcclxuICAgICAgICB7XHJcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XHJcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XHJcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XHJcblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cclxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xyXG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gJyc7XHJcbn1cclxuXHJcbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcclxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xyXG5cclxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xyXG4gIHtcclxuICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xyXG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xyXG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xyXG4gIHtcclxuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cclxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XHJcblxyXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xyXG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xyXG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xyXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cclxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcclxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cclxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XHJcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgIGVycm9yJDEgPSBleDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xyXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XHJcblxyXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcclxuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxyXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cclxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcclxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcclxuXHJcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xyXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XHJcbiAga2V5OiB0cnVlLFxyXG4gIHJlZjogdHJ1ZSxcclxuICBfX3NlbGY6IHRydWUsXHJcbiAgX19zb3VyY2U6IHRydWVcclxufTtcclxudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xyXG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XHJcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xyXG5cclxue1xyXG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XHJcbiAge1xyXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcclxuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xyXG5cclxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xyXG4gIHtcclxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XHJcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcclxuXHJcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XHJcbiAge1xyXG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcclxuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XHJcblxyXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcclxuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xyXG5cclxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XHJcbiAge1xyXG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xyXG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XHJcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XHJcbiAge1xyXG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xyXG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XHJcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cclxuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcclxuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXHJcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdHlwZVxyXG4gKiBAcGFyYW0geyp9IHByb3BzXHJcbiAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXHJcbiAqIEBwYXJhbSB7Kn0gb3duZXJcclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXHJcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcclxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcclxuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xyXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXHJcbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxyXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcblxyXG5cclxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcclxuICB2YXIgZWxlbWVudCA9IHtcclxuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxyXG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcclxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcclxuICAgIHR5cGU6IHR5cGUsXHJcbiAgICBrZXk6IGtleSxcclxuICAgIHJlZjogcmVmLFxyXG4gICAgcHJvcHM6IHByb3BzLFxyXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cclxuICAgIF9vd25lcjogb3duZXJcclxuICB9O1xyXG5cclxuICB7XHJcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXHJcbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxyXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxyXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXHJcbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxyXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxyXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcclxuICAgIC8vIGlnbm9yZXMgaXQuXHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xyXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xyXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICB2YWx1ZTogc2VsZlxyXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXHJcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgIHZhbHVlOiBzb3VyY2VcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XHJcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XHJcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZWxlbWVudDtcclxufTtcclxuLyoqXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcclxuICogQHBhcmFtIHsqfSB0eXBlXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xyXG4gIHtcclxuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxyXG5cclxuICAgIHZhciBwcm9wcyA9IHt9O1xyXG4gICAgdmFyIGtleSA9IG51bGw7XHJcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXHJcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cclxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXHJcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcclxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXHJcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxyXG5cclxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcclxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XHJcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XHJcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xyXG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XHJcblxyXG5cclxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XHJcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcclxuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xyXG4gICAgICB9XHJcbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xyXG5cclxuXHJcbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xyXG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XHJcblxyXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xyXG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoa2V5IHx8IHJlZikge1xyXG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XHJcblxyXG4gICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlZikge1xyXG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XHJcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xyXG5cclxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XHJcbiAge1xyXG4gICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XHJcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XHJcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcclxuXHJcbntcclxuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxyXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XHJcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXHJcbiAqIEBmaW5hbFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xyXG4gIHtcclxuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XHJcbiAge1xyXG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xyXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xyXG5cclxuICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcclxuICB7XHJcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcclxuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcclxuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXHJcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxyXG4gKiB1cGRhdGVzLlxyXG4gKi9cclxuXHJcblxyXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XHJcblxyXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcclxuICB7XHJcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xyXG5cclxuICAgIGlmICghaW5mbykge1xyXG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcclxuXHJcbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XHJcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGluZm87XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXHJcbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxyXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cclxuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXHJcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxyXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXHJcbiAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xyXG4gIHtcclxuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XHJcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XHJcblxyXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcclxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cclxuXHJcbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xyXG5cclxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcclxuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXHJcbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcclxuICAgIH1cclxuXHJcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xyXG5cclxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xyXG5cclxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXHJcbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxyXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxyXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXHJcbiAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcclxuICB7XHJcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xyXG5cclxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XHJcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcclxuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cclxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XHJcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChub2RlKSB7XHJcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcclxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cclxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XHJcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XHJcbiAgICAgICAgICB2YXIgc3RlcDtcclxuXHJcbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXHJcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XHJcbiAge1xyXG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XHJcblxyXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByb3BUeXBlcztcclxuXHJcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXHJcbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cclxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcclxuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByb3BUeXBlcykge1xyXG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxyXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XHJcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcclxuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcclxuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxyXG5cclxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcclxuXHJcbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XHJcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcclxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XHJcbiAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xyXG4gIHtcclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuXHJcbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xyXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xyXG5cclxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XHJcblxyXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XHJcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xyXG5cclxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XHJcblxyXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XHJcbiAge1xyXG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cclxuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXHJcblxyXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcclxuICAgICAgdmFyIGluZm8gPSAnJztcclxuXHJcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xyXG5cclxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcclxuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHR5cGVTdHJpbmc7XHJcblxyXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XHJcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xyXG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcclxuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xyXG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cclxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cclxuXHJcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xyXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxyXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxyXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcclxuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcclxuXHJcblxyXG4gICAgaWYgKHZhbGlkVHlwZSkge1xyXG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcclxuXHJcbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xyXG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50KSB7XHJcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG4gIH1cclxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcclxuLy8gZXZlbiB3aXRoIHRoZSBwcm9kIHRyYW5zZm9ybS4gVGhpcyBtZWFucyB0aGF0IGpzeERFViBpcyBwdXJlbHlcclxuLy8gb3B0LWluIGJlaGF2aW9yIGZvciBiZXR0ZXIgbWVzc2FnZXMgYnV0IHRoYXQgd2Ugd29uJ3Qgc3RvcFxyXG4vLyBnaXZpbmcgeW91IHdhcm5pbmdzIGlmIHlvdSB1c2UgcHJvZHVjdGlvbiBhcGlzLlxyXG5cclxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25TdGF0aWModHlwZSwgcHJvcHMsIGtleSkge1xyXG4gIHtcclxuICAgIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCB0cnVlKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25EeW5hbWljKHR5cGUsIHByb3BzLCBrZXkpIHtcclxuICB7XHJcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgZmFsc2UpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGpzeCA9ICBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWMgOyAvLyB3ZSBtYXkgd2FudCB0byBzcGVjaWFsIGNhc2UganN4cyBpbnRlcm5hbGx5IHRvIHRha2UgYWR2YW50YWdlIG9mIHN0YXRpYyBjaGlsZHJlbi5cclxuLy8gZm9yIG5vdyB3ZSBjYW4gc2hpcCBpZGVudGljYWwgcHJvZCBmdW5jdGlvbnNcclxuXHJcbnZhciBqc3hzID0gIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljIDtcclxuXHJcbmV4cG9ydHMuanN4ID0ganN4O1xyXG5leHBvcnRzLmpzeHMgPSBqc3hzO1xyXG4gIH0pKCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIlJlYWN0IiwicmVxdWlyZSIsIl9hc3NpZ24iLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsImV4cG9ydHMiLCJGcmFnbWVudCIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfQkxPQ0tfVFlQRSIsIlJFQUNUX1NFUlZFUl9CTE9DS19UWVBFIiwiUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSIsIlJFQUNUX1NDT1BFX1RZUEUiLCJSRUFDVF9PUEFRVUVfSURfVFlQRSIsIlJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJzeW1ib2xGb3IiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiUmVhY3RTaGFyZWRJbnRlcm5hbHMiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsImVycm9yIiwiZm9ybWF0IiwiX2xlbjIiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5MiIsInByaW50V2FybmluZyIsImxldmVsIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSIsInN0YWNrIiwiZ2V0U3RhY2tBZGRlbmR1bSIsImNvbmNhdCIsImFyZ3NXaXRoRm9ybWF0IiwibWFwIiwiaXRlbSIsInVuc2hpZnQiLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImFwcGx5IiwiY2FsbCIsImNvbnNvbGUiLCJlbmFibGVTY29wZUFQSSIsImlzVmFsaWRFbGVtZW50VHlwZSIsInR5cGUiLCIkJHR5cGVvZiIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJmdW5jdGlvbk5hbWUiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsImdldENvbXBvbmVudE5hbWUiLCJ0YWciLCJjb250ZXh0IiwicHJvdmlkZXIiLCJfY29udGV4dCIsInJlbmRlciIsIl9yZW5kZXIiLCJsYXp5Q29tcG9uZW50IiwicGF5bG9hZCIsIl9wYXlsb2FkIiwiaW5pdCIsIl9pbml0IiwieCIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwicHJldkluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImRpc2FibGVkTG9nIiwiX19yZWFjdERpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJsb2ciLCJpbmZvIiwid2FybiIsImdyb3VwIiwiZ3JvdXBDb2xsYXBzZWQiLCJncm91cEVuZCIsInByb3BzIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsInZhbHVlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsInByZWZpeCIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwic291cmNlIiwib3duZXJGbiIsInVuZGVmaW5lZCIsIkVycm9yIiwibWF0Y2giLCJ0cmltIiwicmVlbnRyeSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJQb3NzaWJseVdlYWtNYXAiLCJXZWFrTWFwIiwiTWFwIiwiZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSIsImZuIiwiY29uc3RydWN0IiwiZnJhbWUiLCJnZXQiLCJjb250cm9sIiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJzYW1wbGUiLCJzYW1wbGVMaW5lcyIsInNwbGl0IiwiY29udHJvbExpbmVzIiwicyIsImMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJlbGVtZW50Iiwib3duZXIiLCJfb3duZXIiLCJfc291cmNlIiwic2V0RXh0cmFTdGFja0ZyYW1lIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImNvbXBvbmVudE5hbWUiLCJoYXMiLCJiaW5kIiwiaGFzT3duUHJvcGVydHkiLCJ0eXBlU3BlY05hbWUiLCJlcnJvciQxIiwiZXJyIiwiZXgiLCJtZXNzYWdlIiwiUmVhY3RDdXJyZW50T3duZXIiLCJSRVNFUlZFRF9QUk9QUyIsImtleSIsInJlZiIsIl9fc2VsZiIsIl9fc291cmNlIiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biIsImRpZFdhcm5BYm91dFN0cmluZ1JlZnMiLCJoYXNWYWxpZFJlZiIsImNvbmZpZyIsImdldHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlzUmVhY3RXYXJuaW5nIiwiaGFzVmFsaWRLZXkiLCJ3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQiLCJzZWxmIiwic3RhdGVOb2RlIiwiZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdLZXkiLCJkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ1JlZiIsIlJlYWN0RWxlbWVudCIsIl9zdG9yZSIsImZyZWV6ZSIsImpzeERFViIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSZWFjdEN1cnJlbnRPd25lciQxIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMSIsInByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duIiwiaXNWYWxpZEVsZW1lbnQiLCJvYmplY3QiLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnRUeXBlIiwicGFyZW50TmFtZSIsInZhbGlkYXRlRXhwbGljaXRLZXkiLCJ2YWxpZGF0ZWQiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lciIsInZhbGlkYXRlQ2hpbGRLZXlzIiwibm9kZSIsImlzQXJyYXkiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyIsImpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyIsImpzeCIsImpzeHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUlBLEtBQUosRUFBMkMsRUFBM0MsTUFFTztFQUNMRyx1SkFBQTtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/NTc3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XHJcbn0gZWxzZSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcclxufVxyXG4iXSwibmFtZXMiOlsicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-runtime.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSUEsS0FBSixFQUEyQyxFQUEzQyxNQUVPO0VBQ0xHLCtJQUFBO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzPzM0ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XHJcbn0gZWxzZSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-runtime.js\n"));

/***/ }),

/***/ "./node_modules/recoil/es/index.js":
/*!*****************************************!*\
  !*** ./node_modules/recoil/es/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultValue\": function() { return /* binding */ Recoil_index_1; },\n/* harmony export */   \"RecoilLoadable\": function() { return /* binding */ Recoil_index_3; },\n/* harmony export */   \"RecoilRoot\": function() { return /* binding */ Recoil_index_4; },\n/* harmony export */   \"atom\": function() { return /* binding */ Recoil_index_7; },\n/* harmony export */   \"atomFamily\": function() { return /* binding */ Recoil_index_9; },\n/* harmony export */   \"constSelector\": function() { return /* binding */ Recoil_index_11; },\n/* harmony export */   \"errorSelector\": function() { return /* binding */ Recoil_index_12; },\n/* harmony export */   \"isRecoilValue\": function() { return /* binding */ Recoil_index_2; },\n/* harmony export */   \"noWait\": function() { return /* binding */ Recoil_index_14; },\n/* harmony export */   \"readOnlySelector\": function() { return /* binding */ Recoil_index_13; },\n/* harmony export */   \"retentionZone\": function() { return /* binding */ Recoil_index_37; },\n/* harmony export */   \"selector\": function() { return /* binding */ Recoil_index_8; },\n/* harmony export */   \"selectorFamily\": function() { return /* binding */ Recoil_index_10; },\n/* harmony export */   \"snapshot_UNSTABLE\": function() { return /* binding */ Recoil_index_35; },\n/* harmony export */   \"useGetRecoilValueInfo_UNSTABLE\": function() { return /* binding */ Recoil_index_25; },\n/* harmony export */   \"useGotoRecoilSnapshot\": function() { return /* binding */ Recoil_index_32; },\n/* harmony export */   \"useRecoilBridgeAcrossReactRoots_UNSTABLE\": function() { return /* binding */ Recoil_index_6; },\n/* harmony export */   \"useRecoilCallback\": function() { return /* binding */ Recoil_index_30; },\n/* harmony export */   \"useRecoilRefresher_UNSTABLE\": function() { return /* binding */ Recoil_index_26; },\n/* harmony export */   \"useRecoilSnapshot\": function() { return /* binding */ Recoil_index_33; },\n/* harmony export */   \"useRecoilState\": function() { return /* binding */ Recoil_index_21; },\n/* harmony export */   \"useRecoilStateLoadable\": function() { return /* binding */ Recoil_index_22; },\n/* harmony export */   \"useRecoilState_TRANSITION_SUPPORT_UNSTABLE\": function() { return /* binding */ Recoil_index_29; },\n/* harmony export */   \"useRecoilStoreID\": function() { return /* binding */ Recoil_index_5; },\n/* harmony export */   \"useRecoilTransactionObserver_UNSTABLE\": function() { return /* binding */ Recoil_index_34; },\n/* harmony export */   \"useRecoilTransaction_UNSTABLE\": function() { return /* binding */ Recoil_index_31; },\n/* harmony export */   \"useRecoilValue\": function() { return /* binding */ Recoil_index_19; },\n/* harmony export */   \"useRecoilValueLoadable\": function() { return /* binding */ Recoil_index_20; },\n/* harmony export */   \"useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE\": function() { return /* binding */ Recoil_index_27; },\n/* harmony export */   \"useRecoilValue_TRANSITION_SUPPORT_UNSTABLE\": function() { return /* binding */ Recoil_index_28; },\n/* harmony export */   \"useResetRecoilState\": function() { return /* binding */ Recoil_index_24; },\n/* harmony export */   \"useRetain\": function() { return /* binding */ Recoil_index_36; },\n/* harmony export */   \"useSetRecoilState\": function() { return /* binding */ Recoil_index_23; },\n/* harmony export */   \"waitForAll\": function() { return /* binding */ Recoil_index_17; },\n/* harmony export */   \"waitForAllSettled\": function() { return /* binding */ Recoil_index_18; },\n/* harmony export */   \"waitForAny\": function() { return /* binding */ Recoil_index_16; },\n/* harmony export */   \"waitForNone\": function() { return /* binding */ Recoil_index_15; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n\n\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction err(message) {\n  const error = new Error(message); // In V8, Error objects keep the closure scope chain alive until the\n  // err.stack property is accessed.\n\n  if (error.stack === undefined) {\n    // IE sets the stack only if error is thrown\n    try {\n      throw error;\n    } catch (_) {} // eslint-disable-line fb-www/no-unused-catch-bindings, no-empty\n\n  }\n\n  return error;\n}\n\nvar err_1 = err; // @oss-only\n\nvar Recoil_err = err_1;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n// Split declaration and implementation to allow this function to pretend to\n// check for actual instance of Promise instead of something with a `then`\n// method.\n// eslint-disable-next-line no-redeclare\n\nfunction isPromise(p) {\n  return !!p && typeof p.then === 'function';\n}\n\nvar Recoil_isPromise = isPromise;\n\nfunction nullthrows(x, message) {\n  if (x != null) {\n    return x;\n  }\n\n  throw Recoil_err(message !== null && message !== void 0 ? message : 'Got unexpected null or undefined');\n}\n\nvar Recoil_nullthrows = nullthrows;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass BaseLoadable {\n  getValue() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  toPromise() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  valueMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  valueOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected value, but in \"${this.state}\" state`);\n  }\n\n  promiseMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  promiseOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected promise, but in \"${this.state}\" state`);\n  }\n\n  errorMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  errorOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected error, but in \"${this.state}\" state`);\n  }\n\n  is(other) {\n    // $FlowFixMe[prop-missing]\n    return other.state === this.state && other.contents === this.contents;\n  }\n\n  map(_map) {\n    throw Recoil_err('BaseLoadable');\n  }\n\n}\n\nclass ValueLoadable extends BaseLoadable {\n  constructor(value) {\n    super();\n\n    _defineProperty(this, \"state\", 'hasValue');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = value;\n  }\n\n  getValue() {\n    return this.contents;\n  }\n\n  toPromise() {\n    return Promise.resolve(this.contents);\n  }\n\n  valueMaybe() {\n    return this.contents;\n  }\n\n  valueOrThrow() {\n    return this.contents;\n  }\n\n  promiseMaybe() {\n    return undefined;\n  }\n\n  errorMaybe() {\n    return undefined;\n  }\n\n  map(map) {\n    try {\n      const next = map(this.contents);\n      return Recoil_isPromise(next) ? loadableWithPromise(next) : isLoadable(next) ? next : loadableWithValue(next);\n    } catch (e) {\n      return Recoil_isPromise(e) ? // If we \"suspended\", then try again.\n      // errors and subsequent retries will be handled in 'loading' case\n      // $FlowFixMe[prop-missing]\n      loadableWithPromise(e.next(() => this.map(map))) : loadableWithError(e);\n    }\n  }\n\n}\n\nclass ErrorLoadable extends BaseLoadable {\n  constructor(error) {\n    super();\n\n    _defineProperty(this, \"state\", 'hasError');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = error;\n  }\n\n  getValue() {\n    throw this.contents;\n  }\n\n  toPromise() {\n    return Promise.reject(this.contents);\n  }\n\n  valueMaybe() {\n    return undefined;\n  }\n\n  promiseMaybe() {\n    return undefined;\n  }\n\n  errorMaybe() {\n    return this.contents;\n  }\n\n  errorOrThrow() {\n    return this.contents;\n  }\n\n  map(_map) {\n    // $FlowIssue[incompatible-return]\n    return this;\n  }\n\n}\n\nclass LoadingLoadable extends BaseLoadable {\n  constructor(promise) {\n    super();\n\n    _defineProperty(this, \"state\", 'loading');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = promise;\n  }\n\n  getValue() {\n    throw this.contents;\n  }\n\n  toPromise() {\n    return this.contents;\n  }\n\n  valueMaybe() {\n    return undefined;\n  }\n\n  promiseMaybe() {\n    return this.contents;\n  }\n\n  promiseOrThrow() {\n    return this.contents;\n  }\n\n  errorMaybe() {\n    return undefined;\n  }\n\n  map(map) {\n    return loadableWithPromise(this.contents.then(value => {\n      const next = map(value);\n\n      if (isLoadable(next)) {\n        const nextLoadable = next;\n\n        switch (nextLoadable.state) {\n          case 'hasValue':\n            return nextLoadable.contents;\n\n          case 'hasError':\n            throw nextLoadable.contents;\n\n          case 'loading':\n            return nextLoadable.contents;\n        }\n      } // $FlowIssue[incompatible-return]\n\n\n      return next;\n    }).catch(e => {\n      if (Recoil_isPromise(e)) {\n        // we were \"suspended,\" try again\n        return e.then(() => this.map(map).contents);\n      }\n\n      throw e;\n    }));\n  }\n\n}\n\nfunction loadableWithValue(value) {\n  return Object.freeze(new ValueLoadable(value));\n}\n\nfunction loadableWithError(error) {\n  return Object.freeze(new ErrorLoadable(error));\n}\n\nfunction loadableWithPromise(promise) {\n  return Object.freeze(new LoadingLoadable(promise));\n}\n\nfunction loadableLoading() {\n  return Object.freeze(new LoadingLoadable(new Promise(() => {})));\n}\n\nfunction loadableAllArray(inputs) {\n  return inputs.every(i => i.state === 'hasValue') ? loadableWithValue(inputs.map(i => i.contents)) : inputs.some(i => i.state === 'hasError') ? loadableWithError(Recoil_nullthrows(inputs.find(i => i.state === 'hasError'), 'Invalid loadable passed to loadableAll').contents) : loadableWithPromise(Promise.all(inputs.map(i => i.contents)));\n}\n\nfunction loadableAll(inputs) {\n  const unwrapedInputs = Array.isArray(inputs) ? inputs : Object.getOwnPropertyNames(inputs).map(key => inputs[key]);\n  const normalizedInputs = unwrapedInputs.map(x => isLoadable(x) ? x : Recoil_isPromise(x) ? loadableWithPromise(x) : loadableWithValue(x));\n  const output = loadableAllArray(normalizedInputs);\n  return Array.isArray(inputs) ? // $FlowIssue[incompatible-return]\n  output : // Object.getOwnPropertyNames() has consistent key ordering with ES6\n  // $FlowIssue[incompatible-call]\n  output.map(outputs => Object.getOwnPropertyNames(inputs).reduce((out, key, idx) => ({ ...out,\n    [key]: outputs[idx]\n  }), {}));\n}\n\nfunction isLoadable(x) {\n  return x instanceof BaseLoadable;\n}\n\nconst LoadableStaticInterface = {\n  of: value => Recoil_isPromise(value) ? loadableWithPromise(value) : isLoadable(value) ? value : loadableWithValue(value),\n  error: error => loadableWithError(error),\n  // $FlowIssue[incompatible-return]\n  loading: () => loadableLoading(),\n  // $FlowIssue[unclear-type]\n  all: loadableAll,\n  isLoadable\n};\nvar Recoil_Loadable = {\n  loadableWithValue,\n  loadableWithError,\n  loadableWithPromise,\n  loadableLoading,\n  loadableAll,\n  isLoadable,\n  RecoilLoadable: LoadableStaticInterface\n};\nvar Recoil_Loadable_1 = Recoil_Loadable.loadableWithValue;\nvar Recoil_Loadable_2 = Recoil_Loadable.loadableWithError;\nvar Recoil_Loadable_3 = Recoil_Loadable.loadableWithPromise;\nvar Recoil_Loadable_4 = Recoil_Loadable.loadableLoading;\nvar Recoil_Loadable_5 = Recoil_Loadable.loadableAll;\nvar Recoil_Loadable_6 = Recoil_Loadable.isLoadable;\nvar Recoil_Loadable_7 = Recoil_Loadable.RecoilLoadable;\nvar Recoil_Loadable$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  loadableWithValue: Recoil_Loadable_1,\n  loadableWithError: Recoil_Loadable_2,\n  loadableWithPromise: Recoil_Loadable_3,\n  loadableLoading: Recoil_Loadable_4,\n  loadableAll: Recoil_Loadable_5,\n  isLoadable: Recoil_Loadable_6,\n  RecoilLoadable: Recoil_Loadable_7\n});\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nconst gks = new Map().set('recoil_hamt_2020', true).set('recoil_sync_external_store', true).set('recoil_suppress_rerender_in_callback', true).set('recoil_memory_managament_2020', true);\n\nfunction Recoil_gkx_OSS(gk) {\n  var _gks$get;\n\n  return (_gks$get = gks.get(gk)) !== null && _gks$get !== void 0 ? _gks$get : false;\n}\n\nRecoil_gkx_OSS.setPass = gk => {\n  gks.set(gk, true);\n};\n\nRecoil_gkx_OSS.setFail = gk => {\n  gks.set(gk, false);\n};\n\nRecoil_gkx_OSS.clear = () => {\n  gks.clear();\n};\n\nvar Recoil_gkx = Recoil_gkx_OSS; // @oss-only\n\nvar _createMutableSource, _useMutableSource, _useSyncExternalStore;\n\nconst createMutableSource = // flowlint-next-line unclear-type:off\n(_createMutableSource = (react__WEBPACK_IMPORTED_MODULE_0___default().createMutableSource)) !== null && _createMutableSource !== void 0 ? _createMutableSource : (react__WEBPACK_IMPORTED_MODULE_0___default().unstable_createMutableSource);\nconst useMutableSource = // flowlint-next-line unclear-type:off\n(_useMutableSource = (react__WEBPACK_IMPORTED_MODULE_0___default().useMutableSource)) !== null && _useMutableSource !== void 0 ? _useMutableSource : (react__WEBPACK_IMPORTED_MODULE_0___default().unstable_useMutableSource); // https://github.com/reactwg/react-18/discussions/86\n\nconst useSyncExternalStore = // flowlint-next-line unclear-type:off\n(_useSyncExternalStore = (react__WEBPACK_IMPORTED_MODULE_0___default().useSyncExternalStore)) !== null && _useSyncExternalStore !== void 0 ? _useSyncExternalStore : // flowlint-next-line unclear-type:off\n(react__WEBPACK_IMPORTED_MODULE_0___default().unstable_useSyncExternalStore);\n/**\r\n * mode: The React API and approach to use for syncing state with React\r\n * early: Re-renders from Recoil updates occur:\r\n *    1) earlier\r\n *    2) in sync with React updates in the same batch\r\n *    3) before transaction observers instead of after.\r\n * concurrent: Is the current mode compatible with Concurrent Mode and useTransition()\r\n */\n\nfunction reactMode() {\n  // NOTE: This mode is currently broken with some Suspense cases\n  // see Recoil_selector-test.js\n  if (Recoil_gkx('recoil_transition_support')) {\n    return {\n      mode: 'TRANSITION_SUPPORT',\n      early: true,\n      concurrent: true\n    };\n  }\n\n  if (Recoil_gkx('recoil_sync_external_store') && useSyncExternalStore != null) {\n    return {\n      mode: 'SYNC_EXTERNAL_STORE',\n      early: true,\n      concurrent: false\n    };\n  }\n\n  if (Recoil_gkx('recoil_mutable_source') && useMutableSource != null && typeof window !== 'undefined' && !window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE) {\n    return Recoil_gkx('recoil_suppress_rerender_in_callback') ? {\n      mode: 'MUTABLE_SOURCE',\n      early: true,\n      concurrent: true\n    } : {\n      mode: 'MUTABLE_SOURCE',\n      early: false,\n      concurrent: false\n    };\n  }\n\n  return Recoil_gkx('recoil_suppress_rerender_in_callback') ? {\n    mode: 'LEGACY',\n    early: true,\n    concurrent: false\n  } : {\n    mode: 'LEGACY',\n    early: false,\n    concurrent: false\n  };\n} // TODO Need to figure out if there is a standard/open-source equivalent to see if hot module replacement is happening:\n\n\nfunction isFastRefreshEnabled() {\n  // @fb-only: const {isAcceptingUpdate} = require('__debug');\n  // @fb-only: return typeof isAcceptingUpdate === 'function' && isAcceptingUpdate();\n  return false; // @oss-only\n}\n\nvar Recoil_ReactMode = {\n  createMutableSource,\n  useMutableSource,\n  useSyncExternalStore,\n  reactMode,\n  isFastRefreshEnabled\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n// eslint-disable-next-line no-unused-vars\n\nclass AbstractRecoilValue {\n  constructor(newKey) {\n    _defineProperty(this, \"key\", void 0);\n\n    this.key = newKey;\n  }\n\n  toJSON() {\n    return {\n      key: this.key\n    };\n  }\n\n}\n\nclass RecoilState extends AbstractRecoilValue {}\n\nclass RecoilValueReadOnly extends AbstractRecoilValue {}\n\nfunction isRecoilValue(x) {\n  return x instanceof RecoilState || x instanceof RecoilValueReadOnly;\n}\n\nvar Recoil_RecoilValue = {\n  AbstractRecoilValue,\n  RecoilState,\n  RecoilValueReadOnly,\n  isRecoilValue\n};\nvar Recoil_RecoilValue_1 = Recoil_RecoilValue.AbstractRecoilValue;\nvar Recoil_RecoilValue_2 = Recoil_RecoilValue.RecoilState;\nvar Recoil_RecoilValue_3 = Recoil_RecoilValue.RecoilValueReadOnly;\nvar Recoil_RecoilValue_4 = Recoil_RecoilValue.isRecoilValue;\nvar Recoil_RecoilValue$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AbstractRecoilValue: Recoil_RecoilValue_1,\n  RecoilState: Recoil_RecoilValue_2,\n  RecoilValueReadOnly: Recoil_RecoilValue_3,\n  isRecoilValue: Recoil_RecoilValue_4\n});\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction sprintf(format, ...args) {\n  let index = 0;\n  return format.replace(/%s/g, () => String(args[index++]));\n}\n\nvar sprintf_1 = sprintf;\n\nfunction expectationViolation(format, ...args) {\n  if (true) {\n    const message = sprintf_1.call(null, format, ...args);\n    const error = new Error(message);\n    error.name = 'Expectation Violation';\n    console.error(error);\n  }\n}\n\nvar expectationViolation_1 = expectationViolation; // @oss-only\n\nvar Recoil_expectationViolation = expectationViolation_1;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Creates a new iterable whose output is generated by passing the input\r\n * iterable's values through the mapper function.\r\n */\n\nfunction mapIterable(iterable, callback) {\n  // Use generator to create iterable/iterator\n  return function* () {\n    let index = 0;\n\n    for (const value of iterable) {\n      yield callback(value, index++);\n    }\n  }();\n}\n\nvar Recoil_mapIterable = mapIterable;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction recoverableViolation(message, _projectName, {\n  error\n} = {}) {\n  if (true) {\n    console.error(message, error);\n  }\n\n  return null;\n}\n\nvar recoverableViolation_1 = recoverableViolation; // @oss-only\n\nvar Recoil_recoverableViolation = recoverableViolation_1;\nconst {\n  isFastRefreshEnabled: isFastRefreshEnabled$1\n} = Recoil_ReactMode;\n\nclass DefaultValue {}\n\nconst DEFAULT_VALUE = new DefaultValue(); // flowlint-next-line unclear-type:off\n\nconst nodes = new Map(); // flowlint-next-line unclear-type:off\n\nconst recoilValues = new Map();\n/* eslint-disable no-redeclare */\n\nfunction recoilValuesForKeys(keys) {\n  return Recoil_mapIterable(keys, key => Recoil_nullthrows(recoilValues.get(key)));\n}\n\nfunction registerNode(node) {\n  if (nodes.has(node.key)) {\n    const message = `Duplicate atom key \"${node.key}\". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;\n\n    if (true) {\n      // TODO Figure this out for open-source\n      if (!isFastRefreshEnabled$1()) {\n        Recoil_expectationViolation(message, 'recoil');\n      }\n    } else {}\n  }\n\n  nodes.set(node.key, node);\n  const recoilValue = node.set == null ? new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key) : new Recoil_RecoilValue$1.RecoilState(node.key);\n  recoilValues.set(node.key, recoilValue);\n  return recoilValue;\n}\n/* eslint-enable no-redeclare */\n\n\nclass NodeMissingError extends Error {} // flowlint-next-line unclear-type:off\n\n\nfunction getNode(key) {\n  const node = nodes.get(key);\n\n  if (node == null) {\n    throw new NodeMissingError(`Missing definition for RecoilValue: \"${key}\"\"`);\n  }\n\n  return node;\n} // flowlint-next-line unclear-type:off\n\n\nfunction getNodeMaybe(key) {\n  return nodes.get(key);\n}\n\nconst configDeletionHandlers = new Map();\n\nfunction deleteNodeConfigIfPossible(key) {\n  var _node$shouldDeleteCon;\n\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const node = nodes.get(key);\n\n  if (node !== null && node !== void 0 && (_node$shouldDeleteCon = node.shouldDeleteConfigOnRelease) !== null && _node$shouldDeleteCon !== void 0 && _node$shouldDeleteCon.call(node)) {\n    var _getConfigDeletionHan;\n\n    nodes.delete(key);\n    (_getConfigDeletionHan = getConfigDeletionHandler(key)) === null || _getConfigDeletionHan === void 0 ? void 0 : _getConfigDeletionHan();\n    configDeletionHandlers.delete(key);\n  }\n}\n\nfunction setConfigDeletionHandler(key, fn) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  if (fn === undefined) {\n    configDeletionHandlers.delete(key);\n  } else {\n    configDeletionHandlers.set(key, fn);\n  }\n}\n\nfunction getConfigDeletionHandler(key) {\n  return configDeletionHandlers.get(key);\n}\n\nvar Recoil_Node = {\n  nodes,\n  recoilValues,\n  registerNode,\n  getNode,\n  getNodeMaybe,\n  deleteNodeConfigIfPossible,\n  setConfigDeletionHandler,\n  getConfigDeletionHandler,\n  recoilValuesForKeys,\n  NodeMissingError,\n  DefaultValue,\n  DEFAULT_VALUE\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction enqueueExecution(s, f) {\n  f();\n}\n\nvar Recoil_Queue = {\n  enqueueExecution\n};\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar hamt_1 = createCommonjsModule(function (module) {\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n  /**\r\n      @fileOverview Hash Array Mapped Trie.\r\n  \r\n      Code based on: https://github.com/exclipy/pdata\r\n  */\n\n\n  var hamt = {}; // export\n\n  /* Configuration\r\n   ******************************************************************************/\n\n  var SIZE = 5;\n  var BUCKET_SIZE = Math.pow(2, SIZE);\n  var MASK = BUCKET_SIZE - 1;\n  var MAX_INDEX_NODE = BUCKET_SIZE / 2;\n  var MIN_ARRAY_NODE = BUCKET_SIZE / 4;\n  /*\r\n   ******************************************************************************/\n\n  var nothing = {};\n\n  var constant = function constant(x) {\n    return function () {\n      return x;\n    };\n  };\n  /**\r\n      Get 32 bit hash of string.\r\n  \r\n      Based on:\r\n      http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\r\n  */\n\n\n  var hash = hamt.hash = function (str) {\n    var type = typeof str === 'undefined' ? 'undefined' : _typeof(str);\n    if (type === 'number') return str;\n    if (type !== 'string') str += '';\n    var hash = 0;\n\n    for (var i = 0, len = str.length; i < len; ++i) {\n      var c = str.charCodeAt(i);\n      hash = (hash << 5) - hash + c | 0;\n    }\n\n    return hash;\n  };\n  /* Bit Ops\r\n   ******************************************************************************/\n\n  /**\r\n      Hamming weight.\r\n  \r\n      Taken from: http://jsperf.com/hamming-weight\r\n  */\n\n\n  var popcount = function popcount(x) {\n    x -= x >> 1 & 0x55555555;\n    x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n    x = x + (x >> 4) & 0x0f0f0f0f;\n    x += x >> 8;\n    x += x >> 16;\n    return x & 0x7f;\n  };\n\n  var hashFragment = function hashFragment(shift, h) {\n    return h >>> shift & MASK;\n  };\n\n  var toBitmap = function toBitmap(x) {\n    return 1 << x;\n  };\n\n  var fromBitmap = function fromBitmap(bitmap, bit) {\n    return popcount(bitmap & bit - 1);\n  };\n  /* Array Ops\r\n   ******************************************************************************/\n\n  /**\r\n      Set a value in an array.\r\n  \r\n      @param mutate Should the input array be mutated?\r\n      @param at Index to change.\r\n      @param v New value\r\n      @param arr Array.\r\n  */\n\n\n  var arrayUpdate = function arrayUpdate(mutate, at, v, arr) {\n    var out = arr;\n\n    if (!mutate) {\n      var len = arr.length;\n      out = new Array(len);\n\n      for (var i = 0; i < len; ++i) {\n        out[i] = arr[i];\n      }\n    }\n\n    out[at] = v;\n    return out;\n  };\n  /**\r\n      Remove a value from an array.\r\n  \r\n      @param mutate Should the input array be mutated?\r\n      @param at Index to remove.\r\n      @param arr Array.\r\n  */\n\n\n  var arraySpliceOut = function arraySpliceOut(mutate, at, arr) {\n    var newLen = arr.length - 1;\n    var i = 0;\n    var g = 0;\n    var out = arr;\n\n    if (mutate) {\n      i = g = at;\n    } else {\n      out = new Array(newLen);\n\n      while (i < at) {\n        out[g++] = arr[i++];\n      }\n    }\n\n    ++i;\n\n    while (i <= newLen) {\n      out[g++] = arr[i++];\n    }\n\n    if (mutate) {\n      out.length = newLen;\n    }\n\n    return out;\n  };\n  /**\r\n      Insert a value into an array.\r\n  \r\n      @param mutate Should the input array be mutated?\r\n      @param at Index to insert at.\r\n      @param v Value to insert,\r\n      @param arr Array.\r\n  */\n\n\n  var arraySpliceIn = function arraySpliceIn(mutate, at, v, arr) {\n    var len = arr.length;\n\n    if (mutate) {\n      var _i = len;\n\n      while (_i >= at) {\n        arr[_i--] = arr[_i];\n      }\n\n      arr[at] = v;\n      return arr;\n    }\n\n    var i = 0,\n        g = 0;\n    var out = new Array(len + 1);\n\n    while (i < at) {\n      out[g++] = arr[i++];\n    }\n\n    out[at] = v;\n\n    while (i < len) {\n      out[++g] = arr[i++];\n    }\n\n    return out;\n  };\n  /* Node Structures\r\n   ******************************************************************************/\n\n\n  var LEAF = 1;\n  var COLLISION = 2;\n  var INDEX = 3;\n  var ARRAY = 4;\n  /**\r\n      Empty node.\r\n  */\n\n  var empty = {\n    __hamt_isEmpty: true\n  };\n\n  var isEmptyNode = function isEmptyNode(x) {\n    return x === empty || x && x.__hamt_isEmpty;\n  };\n  /**\r\n      Leaf holding a value.\r\n  \r\n      @member edit Edit of the node.\r\n      @member hash Hash of key.\r\n      @member key Key.\r\n      @member value Value stored.\r\n  */\n\n\n  var Leaf = function Leaf(edit, hash, key, value) {\n    return {\n      type: LEAF,\n      edit: edit,\n      hash: hash,\n      key: key,\n      value: value,\n      _modify: Leaf__modify\n    };\n  };\n  /**\r\n      Leaf holding multiple values with the same hash but different keys.\r\n  \r\n      @member edit Edit of the node.\r\n      @member hash Hash of key.\r\n      @member children Array of collision children node.\r\n  */\n\n\n  var Collision = function Collision(edit, hash, children) {\n    return {\n      type: COLLISION,\n      edit: edit,\n      hash: hash,\n      children: children,\n      _modify: Collision__modify\n    };\n  };\n  /**\r\n      Internal node with a sparse set of children.\r\n  \r\n      Uses a bitmap and array to pack children.\r\n  \r\n    @member edit Edit of the node.\r\n      @member mask Bitmap that encode the positions of children in the array.\r\n      @member children Array of child nodes.\r\n  */\n\n\n  var IndexedNode = function IndexedNode(edit, mask, children) {\n    return {\n      type: INDEX,\n      edit: edit,\n      mask: mask,\n      children: children,\n      _modify: IndexedNode__modify\n    };\n  };\n  /**\r\n      Internal node with many children.\r\n  \r\n      @member edit Edit of the node.\r\n      @member size Number of children.\r\n      @member children Array of child nodes.\r\n  */\n\n\n  var ArrayNode = function ArrayNode(edit, size, children) {\n    return {\n      type: ARRAY,\n      edit: edit,\n      size: size,\n      children: children,\n      _modify: ArrayNode__modify\n    };\n  };\n  /**\r\n      Is `node` a leaf node?\r\n  */\n\n\n  var isLeaf = function isLeaf(node) {\n    return node === empty || node.type === LEAF || node.type === COLLISION;\n  };\n  /* Internal node operations.\r\n   ******************************************************************************/\n\n  /**\r\n      Expand an indexed node into an array node.\r\n  \r\n    @param edit Current edit.\r\n      @param frag Index of added child.\r\n      @param child Added child.\r\n      @param mask Index node mask before child added.\r\n      @param subNodes Index node children before child added.\r\n  */\n\n\n  var expand = function expand(edit, frag, child, bitmap, subNodes) {\n    var arr = [];\n    var bit = bitmap;\n    var count = 0;\n\n    for (var i = 0; bit; ++i) {\n      if (bit & 1) arr[i] = subNodes[count++];\n      bit >>>= 1;\n    }\n\n    arr[frag] = child;\n    return ArrayNode(edit, count + 1, arr);\n  };\n  /**\r\n      Collapse an array node into a indexed node.\r\n  \r\n    @param edit Current edit.\r\n      @param count Number of elements in new array.\r\n      @param removed Index of removed element.\r\n      @param elements Array node children before remove.\r\n  */\n\n\n  var pack = function pack(edit, count, removed, elements) {\n    var children = new Array(count - 1);\n    var g = 0;\n    var bitmap = 0;\n\n    for (var i = 0, len = elements.length; i < len; ++i) {\n      if (i !== removed) {\n        var elem = elements[i];\n\n        if (elem && !isEmptyNode(elem)) {\n          children[g++] = elem;\n          bitmap |= 1 << i;\n        }\n      }\n    }\n\n    return IndexedNode(edit, bitmap, children);\n  };\n  /**\r\n      Merge two leaf nodes.\r\n  \r\n      @param shift Current shift.\r\n      @param h1 Node 1 hash.\r\n      @param n1 Node 1.\r\n      @param h2 Node 2 hash.\r\n      @param n2 Node 2.\r\n  */\n\n\n  var mergeLeaves = function mergeLeaves(edit, shift, h1, n1, h2, n2) {\n    if (h1 === h2) return Collision(edit, h1, [n2, n1]);\n    var subH1 = hashFragment(shift, h1);\n    var subH2 = hashFragment(shift, h2);\n    return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [mergeLeaves(edit, shift + SIZE, h1, n1, h2, n2)] : subH1 < subH2 ? [n1, n2] : [n2, n1]);\n  };\n  /**\r\n      Update an entry in a collision list.\r\n  \r\n      @param mutate Should mutation be used?\r\n      @param edit Current edit.\r\n      @param keyEq Key compare function.\r\n      @param hash Hash of collision.\r\n      @param list Collision list.\r\n      @param f Update function.\r\n      @param k Key to update.\r\n      @param size Size ref.\r\n  */\n\n\n  var updateCollisionList = function updateCollisionList(mutate, edit, keyEq, h, list, f, k, size) {\n    var len = list.length;\n\n    for (var i = 0; i < len; ++i) {\n      var child = list[i];\n\n      if (keyEq(k, child.key)) {\n        var value = child.value;\n\n        var _newValue = f(value);\n\n        if (_newValue === value) return list;\n\n        if (_newValue === nothing) {\n          --size.value;\n          return arraySpliceOut(mutate, i, list);\n        }\n\n        return arrayUpdate(mutate, i, Leaf(edit, h, k, _newValue), list);\n      }\n    }\n\n    var newValue = f();\n    if (newValue === nothing) return list;\n    ++size.value;\n    return arrayUpdate(mutate, len, Leaf(edit, h, k, newValue), list);\n  };\n\n  var canEditNode = function canEditNode(edit, node) {\n    return edit === node.edit;\n  };\n  /* Editing\r\n   ******************************************************************************/\n\n\n  var Leaf__modify = function Leaf__modify(edit, keyEq, shift, f, h, k, size) {\n    if (keyEq(k, this.key)) {\n      var _v = f(this.value);\n\n      if (_v === this.value) return this;else if (_v === nothing) {\n        --size.value;\n        return empty;\n      }\n\n      if (canEditNode(edit, this)) {\n        this.value = _v;\n        return this;\n      }\n\n      return Leaf(edit, h, k, _v);\n    }\n\n    var v = f();\n    if (v === nothing) return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n  };\n\n  var Collision__modify = function Collision__modify(edit, keyEq, shift, f, h, k, size) {\n    if (h === this.hash) {\n      var canEdit = canEditNode(edit, this);\n      var list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f, k, size);\n      if (list === this.children) return this;\n      return list.length > 1 ? Collision(edit, this.hash, list) : list[0]; // collapse single element collision list\n    }\n\n    var v = f();\n    if (v === nothing) return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n  };\n\n  var IndexedNode__modify = function IndexedNode__modify(edit, keyEq, shift, f, h, k, size) {\n    var mask = this.mask;\n    var children = this.children;\n    var frag = hashFragment(shift, h);\n    var bit = toBitmap(frag);\n    var indx = fromBitmap(mask, bit);\n    var exists = mask & bit;\n    var current = exists ? children[indx] : empty;\n\n    var child = current._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n\n    if (current === child) return this;\n    var canEdit = canEditNode(edit, this);\n    var bitmap = mask;\n    var newChildren = void 0;\n\n    if (exists && isEmptyNode(child)) {\n      // remove\n      bitmap &= ~bit;\n      if (!bitmap) return empty;\n      if (children.length <= 2 && isLeaf(children[indx ^ 1])) return children[indx ^ 1]; // collapse\n\n      newChildren = arraySpliceOut(canEdit, indx, children);\n    } else if (!exists && !isEmptyNode(child)) {\n      // add\n      if (children.length >= MAX_INDEX_NODE) return expand(edit, frag, child, mask, children);\n      bitmap |= bit;\n      newChildren = arraySpliceIn(canEdit, indx, child, children);\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, indx, child, children);\n    }\n\n    if (canEdit) {\n      this.mask = bitmap;\n      this.children = newChildren;\n      return this;\n    }\n\n    return IndexedNode(edit, bitmap, newChildren);\n  };\n\n  var ArrayNode__modify = function ArrayNode__modify(edit, keyEq, shift, f, h, k, size) {\n    var count = this.size;\n    var children = this.children;\n    var frag = hashFragment(shift, h);\n    var child = children[frag];\n\n    var newChild = (child || empty)._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n\n    if (child === newChild) return this;\n    var canEdit = canEditNode(edit, this);\n    var newChildren = void 0;\n\n    if (isEmptyNode(child) && !isEmptyNode(newChild)) {\n      // add\n      ++count;\n      newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {\n      // remove\n      --count;\n      if (count <= MIN_ARRAY_NODE) return pack(edit, count, frag, children);\n      newChildren = arrayUpdate(canEdit, frag, empty, children);\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    }\n\n    if (canEdit) {\n      this.size = count;\n      this.children = newChildren;\n      return this;\n    }\n\n    return ArrayNode(edit, count, newChildren);\n  };\n\n  empty._modify = function (edit, keyEq, shift, f, h, k, size) {\n    var v = f();\n    if (v === nothing) return empty;\n    ++size.value;\n    return Leaf(edit, h, k, v);\n  };\n  /*\r\n   ******************************************************************************/\n\n\n  function Map(editable, edit, config, root, size) {\n    this._editable = editable;\n    this._edit = edit;\n    this._config = config;\n    this._root = root;\n    this._size = size;\n  }\n\n  Map.prototype.setTree = function (newRoot, newSize) {\n    if (this._editable) {\n      this._root = newRoot;\n      this._size = newSize;\n      return this;\n    }\n\n    return newRoot === this._root ? this : new Map(this._editable, this._edit, this._config, newRoot, newSize);\n  };\n  /* Queries\r\n   ******************************************************************************/\n\n  /**\r\n      Lookup the value for `key` in `map` using a custom `hash`.\r\n  \r\n      Returns the value or `alt` if none.\r\n  */\n\n\n  var tryGetHash = hamt.tryGetHash = function (alt, hash, key, map) {\n    var node = map._root;\n    var shift = 0;\n    var keyEq = map._config.keyEq;\n\n    while (true) {\n      switch (node.type) {\n        case LEAF:\n          {\n            return keyEq(key, node.key) ? node.value : alt;\n          }\n\n        case COLLISION:\n          {\n            if (hash === node.hash) {\n              var children = node.children;\n\n              for (var i = 0, len = children.length; i < len; ++i) {\n                var child = children[i];\n                if (keyEq(key, child.key)) return child.value;\n              }\n            }\n\n            return alt;\n          }\n\n        case INDEX:\n          {\n            var frag = hashFragment(shift, hash);\n            var bit = toBitmap(frag);\n\n            if (node.mask & bit) {\n              node = node.children[fromBitmap(node.mask, bit)];\n              shift += SIZE;\n              break;\n            }\n\n            return alt;\n          }\n\n        case ARRAY:\n          {\n            node = node.children[hashFragment(shift, hash)];\n\n            if (node) {\n              shift += SIZE;\n              break;\n            }\n\n            return alt;\n          }\n\n        default:\n          return alt;\n      }\n    }\n  };\n\n  Map.prototype.tryGetHash = function (alt, hash, key) {\n    return tryGetHash(alt, hash, key, this);\n  };\n  /**\r\n      Lookup the value for `key` in `map` using internal hash function.\r\n  \r\n      @see `tryGetHash`\r\n  */\n\n\n  var tryGet = hamt.tryGet = function (alt, key, map) {\n    return tryGetHash(alt, map._config.hash(key), key, map);\n  };\n\n  Map.prototype.tryGet = function (alt, key) {\n    return tryGet(alt, key, this);\n  };\n  /**\r\n      Lookup the value for `key` in `map` using a custom `hash`.\r\n  \r\n      Returns the value or `undefined` if none.\r\n  */\n\n\n  var getHash = hamt.getHash = function (hash, key, map) {\n    return tryGetHash(undefined, hash, key, map);\n  };\n\n  Map.prototype.getHash = function (hash, key) {\n    return getHash(hash, key, this);\n  };\n  /**\r\n      Lookup the value for `key` in `map` using internal hash function.\r\n  \r\n      @see `get`\r\n  */\n\n\n  var get = hamt.get = function (key, map) {\n    return tryGetHash(undefined, map._config.hash(key), key, map);\n  };\n\n  Map.prototype.get = function (key, alt) {\n    return tryGet(alt, key, this);\n  };\n  /**\r\n      Does an entry exist for `key` in `map`? Uses custom `hash`.\r\n  */\n\n\n  var hasHash = hamt.has = function (hash, key, map) {\n    return tryGetHash(nothing, hash, key, map) !== nothing;\n  };\n\n  Map.prototype.hasHash = function (hash, key) {\n    return hasHash(hash, key, this);\n  };\n  /**\r\n      Does an entry exist for `key` in `map`? Uses internal hash function.\r\n  */\n\n\n  var has = hamt.has = function (key, map) {\n    return hasHash(map._config.hash(key), key, map);\n  };\n\n  Map.prototype.has = function (key) {\n    return has(key, this);\n  };\n\n  var defKeyCompare = function defKeyCompare(x, y) {\n    return x === y;\n  };\n  /**\r\n      Create an empty map.\r\n  \r\n      @param config Configuration.\r\n  */\n\n\n  hamt.make = function (config) {\n    return new Map(0, 0, {\n      keyEq: config && config.keyEq || defKeyCompare,\n      hash: config && config.hash || hash\n    }, empty, 0);\n  };\n  /**\r\n      Empty map.\r\n  */\n\n\n  hamt.empty = hamt.make();\n  /**\r\n      Does `map` contain any elements?\r\n  */\n\n  var isEmpty = hamt.isEmpty = function (map) {\n    return map && !!isEmptyNode(map._root);\n  };\n\n  Map.prototype.isEmpty = function () {\n    return isEmpty(this);\n  };\n  /* Updates\r\n   ******************************************************************************/\n\n  /**\r\n      Alter the value stored for `key` in `map` using function `f` using\r\n      custom hash.\r\n  \r\n      `f` is invoked with the current value for `k` if it exists,\r\n      or no arguments if no such value exists. `modify` will always either\r\n      update or insert a value into the map.\r\n  \r\n      Returns a map with the modified value. Does not alter `map`.\r\n  */\n\n\n  var modifyHash = hamt.modifyHash = function (f, hash, key, map) {\n    var size = {\n      value: map._size\n    };\n\n    var newRoot = map._root._modify(map._editable ? map._edit : NaN, map._config.keyEq, 0, f, hash, key, size);\n\n    return map.setTree(newRoot, size.value);\n  };\n\n  Map.prototype.modifyHash = function (hash, key, f) {\n    return modifyHash(f, hash, key, this);\n  };\n  /**\r\n      Alter the value stored for `key` in `map` using function `f` using\r\n      internal hash function.\r\n  \r\n      @see `modifyHash`\r\n  */\n\n\n  var modify = hamt.modify = function (f, key, map) {\n    return modifyHash(f, map._config.hash(key), key, map);\n  };\n\n  Map.prototype.modify = function (key, f) {\n    return modify(f, key, this);\n  };\n  /**\r\n      Store `value` for `key` in `map` using custom `hash`.\r\n  \r\n      Returns a map with the modified value. Does not alter `map`.\r\n  */\n\n\n  var setHash = hamt.setHash = function (hash, key, value, map) {\n    return modifyHash(constant(value), hash, key, map);\n  };\n\n  Map.prototype.setHash = function (hash, key, value) {\n    return setHash(hash, key, value, this);\n  };\n  /**\r\n      Store `value` for `key` in `map` using internal hash function.\r\n  \r\n      @see `setHash`\r\n  */\n\n\n  var set = hamt.set = function (key, value, map) {\n    return setHash(map._config.hash(key), key, value, map);\n  };\n\n  Map.prototype.set = function (key, value) {\n    return set(key, value, this);\n  };\n  /**\r\n      Remove the entry for `key` in `map`.\r\n  \r\n      Returns a map with the value removed. Does not alter `map`.\r\n  */\n\n\n  var del = constant(nothing);\n\n  var removeHash = hamt.removeHash = function (hash, key, map) {\n    return modifyHash(del, hash, key, map);\n  };\n\n  Map.prototype.removeHash = Map.prototype.deleteHash = function (hash, key) {\n    return removeHash(hash, key, this);\n  };\n  /**\r\n      Remove the entry for `key` in `map` using internal hash function.\r\n  \r\n      @see `removeHash`\r\n  */\n\n\n  var remove = hamt.remove = function (key, map) {\n    return removeHash(map._config.hash(key), key, map);\n  };\n\n  Map.prototype.remove = Map.prototype.delete = function (key) {\n    return remove(key, this);\n  };\n  /* Mutation\r\n   ******************************************************************************/\n\n  /**\r\n      Mark `map` as mutable.\r\n   */\n\n\n  var beginMutation = hamt.beginMutation = function (map) {\n    return new Map(map._editable + 1, map._edit + 1, map._config, map._root, map._size);\n  };\n\n  Map.prototype.beginMutation = function () {\n    return beginMutation(this);\n  };\n  /**\r\n      Mark `map` as immutable.\r\n   */\n\n\n  var endMutation = hamt.endMutation = function (map) {\n    map._editable = map._editable && map._editable - 1;\n    return map;\n  };\n\n  Map.prototype.endMutation = function () {\n    return endMutation(this);\n  };\n  /**\r\n      Mutate `map` within the context of `f`.\r\n      @param f\r\n      @param map HAMT\r\n  */\n\n\n  var mutate = hamt.mutate = function (f, map) {\n    var transient = beginMutation(map);\n    f(transient);\n    return endMutation(transient);\n  };\n\n  Map.prototype.mutate = function (f) {\n    return mutate(f, this);\n  };\n  /* Traversal\r\n   ******************************************************************************/\n\n  /**\r\n      Apply a continuation.\r\n  */\n\n\n  var appk = function appk(k) {\n    return k && lazyVisitChildren(k[0], k[1], k[2], k[3], k[4]);\n  };\n  /**\r\n      Recursively visit all values stored in an array of nodes lazily.\r\n  */\n\n\n  var lazyVisitChildren = function lazyVisitChildren(len, children, i, f, k) {\n    while (i < len) {\n      var child = children[i++];\n      if (child && !isEmptyNode(child)) return lazyVisit(child, f, [len, children, i, f, k]);\n    }\n\n    return appk(k);\n  };\n  /**\r\n      Recursively visit all values stored in `node` lazily.\r\n  */\n\n\n  var lazyVisit = function lazyVisit(node, f, k) {\n    switch (node.type) {\n      case LEAF:\n        return {\n          value: f(node),\n          rest: k\n        };\n\n      case COLLISION:\n      case ARRAY:\n      case INDEX:\n        var children = node.children;\n        return lazyVisitChildren(children.length, children, 0, f, k);\n\n      default:\n        return appk(k);\n    }\n  };\n\n  var DONE = {\n    done: true\n  };\n  /**\r\n      Javascript iterator over a map.\r\n  */\n\n  function MapIterator(v) {\n    this.v = v;\n  }\n\n  MapIterator.prototype.next = function () {\n    if (!this.v) return DONE;\n    var v0 = this.v;\n    this.v = appk(v0.rest);\n    return v0;\n  };\n\n  MapIterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n  /**\r\n      Lazily visit each value in map with function `f`.\r\n  */\n\n\n  var visit = function visit(map, f) {\n    return new MapIterator(lazyVisit(map._root, f));\n  };\n  /**\r\n      Get a Javascsript iterator of `map`.\r\n  \r\n      Iterates over `[key, value]` arrays.\r\n  */\n\n\n  var buildPairs = function buildPairs(x) {\n    return [x.key, x.value];\n  };\n\n  var entries = hamt.entries = function (map) {\n    return visit(map, buildPairs);\n  };\n\n  Map.prototype.entries = Map.prototype[Symbol.iterator] = function () {\n    return entries(this);\n  };\n  /**\r\n      Get array of all keys in `map`.\r\n  \r\n      Order is not guaranteed.\r\n  */\n\n\n  var buildKeys = function buildKeys(x) {\n    return x.key;\n  };\n\n  var keys = hamt.keys = function (map) {\n    return visit(map, buildKeys);\n  };\n\n  Map.prototype.keys = function () {\n    return keys(this);\n  };\n  /**\r\n      Get array of all values in `map`.\r\n  \r\n      Order is not guaranteed, duplicates are preserved.\r\n  */\n\n\n  var buildValues = function buildValues(x) {\n    return x.value;\n  };\n\n  var values = hamt.values = Map.prototype.values = function (map) {\n    return visit(map, buildValues);\n  };\n\n  Map.prototype.values = function () {\n    return values(this);\n  };\n  /* Fold\r\n   ******************************************************************************/\n\n  /**\r\n      Visit every entry in the map, aggregating data.\r\n  \r\n      Order of nodes is not guaranteed.\r\n  \r\n      @param f Function mapping accumulated value, value, and key to new value.\r\n      @param z Starting value.\r\n      @param m HAMT\r\n  */\n\n\n  var fold = hamt.fold = function (f, z, m) {\n    var root = m._root;\n    if (root.type === LEAF) return f(z, root.value, root.key);\n    var toVisit = [root.children];\n    var children = void 0;\n\n    while (children = toVisit.pop()) {\n      for (var i = 0, len = children.length; i < len;) {\n        var child = children[i++];\n\n        if (child && child.type) {\n          if (child.type === LEAF) z = f(z, child.value, child.key);else toVisit.push(child.children);\n        }\n      }\n    }\n\n    return z;\n  };\n\n  Map.prototype.fold = function (f, z) {\n    return fold(f, z, this);\n  };\n  /**\r\n      Visit every entry in the map, aggregating data.\r\n  \r\n      Order of nodes is not guaranteed.\r\n  \r\n      @param f Function invoked with value and key\r\n      @param map HAMT\r\n  */\n\n\n  var forEach = hamt.forEach = function (f, map) {\n    return fold(function (_, value, key) {\n      return f(value, key, map);\n    }, null, map);\n  };\n\n  Map.prototype.forEach = function (f) {\n    return forEach(f, this);\n  };\n  /* Aggregate\r\n   ******************************************************************************/\n\n  /**\r\n      Get the number of entries in `map`.\r\n  */\n\n\n  var count = hamt.count = function (map) {\n    return map._size;\n  };\n\n  Map.prototype.count = function () {\n    return count(this);\n  };\n\n  Object.defineProperty(Map.prototype, 'size', {\n    get: Map.prototype.count\n  });\n  /* Export\r\n   ******************************************************************************/\n\n  if (module.exports) {\n    module.exports = hamt;\n  } else {\n    undefined.hamt = hamt;\n  }\n});\n\nclass BuiltInMap {\n  constructor(existing) {\n    _defineProperty(this, \"_map\", void 0);\n\n    this._map = new Map(existing === null || existing === void 0 ? void 0 : existing.entries());\n  }\n\n  keys() {\n    return this._map.keys();\n  }\n\n  entries() {\n    return this._map.entries();\n  }\n\n  get(k) {\n    return this._map.get(k);\n  }\n\n  has(k) {\n    return this._map.has(k);\n  }\n\n  set(k, v) {\n    this._map.set(k, v);\n\n    return this;\n  }\n\n  delete(k) {\n    this._map.delete(k);\n\n    return this;\n  }\n\n  clone() {\n    return persistentMap(this);\n  }\n\n  toMap() {\n    return new Map(this._map);\n  }\n\n}\n\nclass HashArrayMappedTrieMap {\n  // Because hamt.empty is not a function there is no way to introduce type\n  // parameters on it, so empty is typed as HAMTPlusMap<string, mixed>.\n  // $FlowIssue\n  constructor(existing) {\n    _defineProperty(this, \"_hamt\", hamt_1.empty.beginMutation());\n\n    if (existing instanceof HashArrayMappedTrieMap) {\n      const h = existing._hamt.endMutation();\n\n      existing._hamt = h.beginMutation();\n      this._hamt = h.beginMutation();\n    } else if (existing) {\n      for (const [k, v] of existing.entries()) {\n        this._hamt.set(k, v);\n      }\n    }\n  }\n\n  keys() {\n    return this._hamt.keys();\n  }\n\n  entries() {\n    return this._hamt.entries();\n  }\n\n  get(k) {\n    return this._hamt.get(k);\n  }\n\n  has(k) {\n    return this._hamt.has(k);\n  }\n\n  set(k, v) {\n    this._hamt.set(k, v);\n\n    return this;\n  }\n\n  delete(k) {\n    this._hamt.delete(k);\n\n    return this;\n  }\n\n  clone() {\n    return persistentMap(this);\n  }\n\n  toMap() {\n    return new Map(this._hamt);\n  }\n\n}\n\nfunction persistentMap(existing) {\n  if (Recoil_gkx('recoil_hamt_2020')) {\n    return new HashArrayMappedTrieMap(existing);\n  } else {\n    return new BuiltInMap(existing);\n  }\n}\n\nvar Recoil_PersistentMap = {\n  persistentMap\n};\nvar Recoil_PersistentMap_1 = Recoil_PersistentMap.persistentMap;\nvar Recoil_PersistentMap$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  persistentMap: Recoil_PersistentMap_1\n});\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Returns a set containing all of the values from the first set that are not\r\n * present in any of the subsequent sets.\r\n *\r\n * Note: this is written procedurally (i.e., without filterSet) for performant\r\n * use in tight loops.\r\n */\n\nfunction differenceSets(set, ...setsWithValuesToRemove) {\n  const ret = new Set();\n\n  FIRST: for (const value of set) {\n    for (const otherSet of setsWithValuesToRemove) {\n      if (otherSet.has(value)) {\n        continue FIRST;\n      }\n    }\n\n    ret.add(value);\n  }\n\n  return ret;\n}\n\nvar Recoil_differenceSets = differenceSets;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Returns a new Map object with the same keys as the original, but with the\r\n * values replaced with the output of the given callback function.\r\n */\n\nfunction mapMap(map, callback) {\n  const result = new Map();\n  map.forEach((value, key) => {\n    result.set(key, callback(value, key));\n  });\n  return result;\n}\n\nvar Recoil_mapMap = mapMap;\n\nfunction makeGraph() {\n  return {\n    nodeDeps: new Map(),\n    nodeToNodeSubscriptions: new Map()\n  };\n}\n\nfunction cloneGraph(graph) {\n  return {\n    nodeDeps: Recoil_mapMap(graph.nodeDeps, s => new Set(s)),\n    nodeToNodeSubscriptions: Recoil_mapMap(graph.nodeToNodeSubscriptions, s => new Set(s))\n  };\n} // Note that this overwrites the deps of existing nodes, rather than unioning\n// the new deps with the old deps.\n\n\nfunction mergeDepsIntoGraph(key, newDeps, graph, // If olderGraph is given then we will not overwrite changes made to the given\n// graph compared with olderGraph:\nolderGraph) {\n  const {\n    nodeDeps,\n    nodeToNodeSubscriptions\n  } = graph;\n  const oldDeps = nodeDeps.get(key);\n\n  if (oldDeps && olderGraph && oldDeps !== olderGraph.nodeDeps.get(key)) {\n    return;\n  } // Update nodeDeps:\n\n\n  nodeDeps.set(key, newDeps); // Add new deps to nodeToNodeSubscriptions:\n\n  const addedDeps = oldDeps == null ? newDeps : Recoil_differenceSets(newDeps, oldDeps);\n\n  for (const dep of addedDeps) {\n    if (!nodeToNodeSubscriptions.has(dep)) {\n      nodeToNodeSubscriptions.set(dep, new Set());\n    }\n\n    const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));\n    existing.add(key);\n  } // Remove removed deps from nodeToNodeSubscriptions:\n\n\n  if (oldDeps) {\n    const removedDeps = Recoil_differenceSets(oldDeps, newDeps);\n\n    for (const dep of removedDeps) {\n      if (!nodeToNodeSubscriptions.has(dep)) {\n        return;\n      }\n\n      const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));\n      existing.delete(key);\n\n      if (existing.size === 0) {\n        nodeToNodeSubscriptions.delete(dep);\n      }\n    }\n  }\n}\n\nfunction saveDepsToStore(key, deps, store, version) {\n  var _storeState$nextTree, _storeState$previousT, _storeState$previousT2, _storeState$previousT3;\n\n  const storeState = store.getState();\n\n  if (!(version === storeState.currentTree.version || version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {\n    Recoil_recoverableViolation('Tried to save dependencies to a discarded tree');\n  } // Merge the dependencies discovered into the store's dependency map\n  // for the version that was read:\n\n\n  const graph = store.getGraph(version);\n  mergeDepsIntoGraph(key, deps, graph); // If this version is not the latest version, also write these dependencies\n  // into later versions if they don't already have their own:\n\n  if (version === ((_storeState$previousT2 = storeState.previousTree) === null || _storeState$previousT2 === void 0 ? void 0 : _storeState$previousT2.version)) {\n    const currentGraph = store.getGraph(storeState.currentTree.version);\n    mergeDepsIntoGraph(key, deps, currentGraph, graph);\n  }\n\n  if (version === ((_storeState$previousT3 = storeState.previousTree) === null || _storeState$previousT3 === void 0 ? void 0 : _storeState$previousT3.version) || version === storeState.currentTree.version) {\n    var _storeState$nextTree2;\n\n    const nextVersion = (_storeState$nextTree2 = storeState.nextTree) === null || _storeState$nextTree2 === void 0 ? void 0 : _storeState$nextTree2.version;\n\n    if (nextVersion !== undefined) {\n      const nextGraph = store.getGraph(nextVersion);\n      mergeDepsIntoGraph(key, deps, nextGraph, graph);\n    }\n  }\n}\n\nvar Recoil_Graph = {\n  cloneGraph,\n  graph: makeGraph,\n  saveDepsToStore\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nlet nextTreeStateVersion = 0;\n\nconst getNextTreeStateVersion = () => nextTreeStateVersion++;\n\nlet nextStoreID = 0;\n\nconst getNextStoreID = () => nextStoreID++;\n\nlet nextComponentID = 0;\n\nconst getNextComponentID = () => nextComponentID++;\n\nvar Recoil_Keys = {\n  getNextTreeStateVersion,\n  getNextStoreID,\n  getNextComponentID\n};\nconst {\n  persistentMap: persistentMap$1\n} = Recoil_PersistentMap$1;\nconst {\n  graph\n} = Recoil_Graph;\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$1\n} = Recoil_Keys;\n\nfunction makeEmptyTreeState() {\n  const version = getNextTreeStateVersion$1();\n  return {\n    version,\n    stateID: version,\n    transactionMetadata: {},\n    dirtyAtoms: new Set(),\n    atomValues: persistentMap$1(),\n    nonvalidatedAtoms: persistentMap$1()\n  };\n}\n\nfunction makeEmptyStoreState() {\n  const currentTree = makeEmptyTreeState();\n  return {\n    currentTree,\n    nextTree: null,\n    previousTree: null,\n    commitDepth: 0,\n    knownAtoms: new Set(),\n    knownSelectors: new Set(),\n    transactionSubscriptions: new Map(),\n    nodeTransactionSubscriptions: new Map(),\n    nodeToComponentSubscriptions: new Map(),\n    queuedComponentCallbacks_DEPRECATED: [],\n    suspendedComponentResolvers: new Set(),\n    graphsByVersion: new Map().set(currentTree.version, graph()),\n    retention: {\n      referenceCounts: new Map(),\n      nodesRetainedByZone: new Map(),\n      retainablesToCheckForRelease: new Set()\n    },\n    nodeCleanupFunctions: new Map()\n  };\n}\n\nvar Recoil_State = {\n  makeEmptyTreeState,\n  makeEmptyStoreState,\n  getNextTreeStateVersion: getNextTreeStateVersion$1\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nclass RetentionZone {}\n\nfunction retentionZone() {\n  return new RetentionZone();\n}\n\nvar Recoil_RetentionZone = {\n  RetentionZone,\n  retentionZone\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * Utilities for working with built-in Maps and Sets without mutating them.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction setByAddingToSet(set, v) {\n  const next = new Set(set);\n  next.add(v);\n  return next;\n}\n\nfunction setByDeletingFromSet(set, v) {\n  const next = new Set(set);\n  next.delete(v);\n  return next;\n}\n\nfunction mapBySettingInMap(map, k, v) {\n  const next = new Map(map);\n  next.set(k, v);\n  return next;\n}\n\nfunction mapByUpdatingInMap(map, k, updater) {\n  const next = new Map(map);\n  next.set(k, updater(next.get(k)));\n  return next;\n}\n\nfunction mapByDeletingFromMap(map, k) {\n  const next = new Map(map);\n  next.delete(k);\n  return next;\n}\n\nfunction mapByDeletingMultipleFromMap(map, ks) {\n  const next = new Map(map);\n  ks.forEach(k => next.delete(k));\n  return next;\n}\n\nvar Recoil_CopyOnWrite = {\n  setByAddingToSet,\n  setByDeletingFromSet,\n  mapBySettingInMap,\n  mapByUpdatingInMap,\n  mapByDeletingFromMap,\n  mapByDeletingMultipleFromMap\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Creates a new iterable whose output is generated by passing the input\r\n * iterable's values through the filter function.\r\n */\n\nfunction* filterIterable(iterable, predicate) {\n  // Use generator to create iterable/iterator\n  let index = 0;\n\n  for (const value of iterable) {\n    if (predicate(value, index++)) {\n      yield value;\n    }\n  }\n}\n\nvar Recoil_filterIterable = filterIterable;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Return a proxy object based on the provided base and factories objects.\r\n * The proxy will include all properties of the base object as-is.\r\n * The factories object contains callbacks to obtain the values of the properies\r\n * for its keys.\r\n *\r\n * This is useful for providing users an object where some properties may be\r\n * lazily computed only on first access.\r\n */\n// $FlowIssue[unclear-type]\n\nfunction lazyProxy(base, factories) {\n  const proxy = new Proxy(base, {\n    // Compute and cache lazy property if not already done.\n    get: (target, prop) => {\n      if (!(prop in target) && prop in factories) {\n        target[prop] = factories[prop]();\n      }\n\n      return target[prop];\n    },\n    // This method allows user to iterate keys as normal\n    ownKeys: target => {\n      return Object.keys(target);\n    }\n  }); // $FlowIssue[incompatible-return]\n\n  return proxy;\n}\n\nvar Recoil_lazyProxy = lazyProxy;\nconst {\n  getNode: getNode$1,\n  getNodeMaybe: getNodeMaybe$1,\n  recoilValuesForKeys: recoilValuesForKeys$1\n} = Recoil_Node;\nconst {\n  RetentionZone: RetentionZone$1\n} = Recoil_RetentionZone;\nconst {\n  setByAddingToSet: setByAddingToSet$1\n} = Recoil_CopyOnWrite; // flowlint-next-line unclear-type:off\n\nconst emptySet = Object.freeze(new Set());\n\nclass ReadOnlyRecoilValueError extends Error {}\n\nfunction initializeRetentionForNode(store, nodeKey, retainedBy) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return () => undefined;\n  }\n\n  const {\n    nodesRetainedByZone\n  } = store.getState().retention;\n\n  function addToZone(zone) {\n    let set = nodesRetainedByZone.get(zone);\n\n    if (!set) {\n      nodesRetainedByZone.set(zone, set = new Set());\n    }\n\n    set.add(nodeKey);\n  }\n\n  if (retainedBy instanceof RetentionZone$1) {\n    addToZone(retainedBy);\n  } else if (Array.isArray(retainedBy)) {\n    for (const zone of retainedBy) {\n      addToZone(zone);\n    }\n  }\n\n  return () => {\n    if (!Recoil_gkx('recoil_memory_managament_2020')) {\n      return;\n    }\n\n    const {\n      retention\n    } = store.getState();\n\n    function deleteFromZone(zone) {\n      const set = retention.nodesRetainedByZone.get(zone);\n      set === null || set === void 0 ? void 0 : set.delete(nodeKey);\n\n      if (set && set.size === 0) {\n        retention.nodesRetainedByZone.delete(zone);\n      }\n    }\n\n    if (retainedBy instanceof RetentionZone$1) {\n      deleteFromZone(retainedBy);\n    } else if (Array.isArray(retainedBy)) {\n      for (const zone of retainedBy) {\n        deleteFromZone(zone);\n      }\n    }\n  };\n}\n\nfunction initializeNodeIfNewToStore(store, treeState, key, trigger) {\n  const storeState = store.getState();\n\n  if (storeState.nodeCleanupFunctions.has(key)) {\n    return;\n  }\n\n  const node = getNode$1(key);\n  const retentionCleanup = initializeRetentionForNode(store, key, node.retainedBy);\n  const nodeCleanup = node.init(store, treeState, trigger);\n  storeState.nodeCleanupFunctions.set(key, () => {\n    nodeCleanup();\n    retentionCleanup();\n  });\n}\n\nfunction initializeNode(store, key, trigger) {\n  initializeNodeIfNewToStore(store, store.getState().currentTree, key, trigger);\n}\n\nfunction cleanUpNode(store, key) {\n  var _state$nodeCleanupFun;\n\n  const state = store.getState();\n  (_state$nodeCleanupFun = state.nodeCleanupFunctions.get(key)) === null || _state$nodeCleanupFun === void 0 ? void 0 : _state$nodeCleanupFun();\n  state.nodeCleanupFunctions.delete(key);\n} // Get the current value loadable of a node and update the state.\n// Update dependencies and subscriptions for selectors.\n// Update saved value validation for atoms.\n\n\nfunction getNodeLoadable(store, state, key) {\n  initializeNodeIfNewToStore(store, state, key, 'get');\n  return getNode$1(key).get(store, state);\n} // Peek at the current value loadable for a node without any evaluation or state change\n\n\nfunction peekNodeLoadable(store, state, key) {\n  return getNode$1(key).peek(store, state);\n} // Write value directly to state bypassing the Node interface as the node\n// definitions may not have been loaded yet when processing the initial snapshot.\n\n\nfunction setUnvalidatedAtomValue_DEPRECATED(state, key, newValue) {\n  var _node$invalidate;\n\n  const node = getNodeMaybe$1(key);\n  node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);\n  return { ...state,\n    atomValues: state.atomValues.clone().delete(key),\n    nonvalidatedAtoms: state.nonvalidatedAtoms.clone().set(key, newValue),\n    dirtyAtoms: setByAddingToSet$1(state.dirtyAtoms, key)\n  };\n} // Return the discovered dependencies and values to be written by setting\n// a node value. (Multiple values may be written due to selectors getting to\n// set upstreams; deps may be discovered because of reads in updater functions.)\n\n\nfunction setNodeValue(store, state, key, newValue) {\n  const node = getNode$1(key);\n\n  if (node.set == null) {\n    throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${key}`);\n  }\n\n  const set = node.set; // so flow doesn't lose the above refinement.\n\n  initializeNodeIfNewToStore(store, state, key, 'set');\n  return set(store, state, newValue);\n}\n\nfunction peekNodeInfo(store, state, key) {\n  const storeState = store.getState();\n  const graph = store.getGraph(state.version);\n  const type = getNode$1(key).nodeType;\n  return Recoil_lazyProxy({\n    type\n  }, {\n    loadable: () => peekNodeLoadable(store, state, key),\n    isActive: () => storeState.knownAtoms.has(key) || storeState.knownSelectors.has(key),\n    isSet: () => type === 'selector' ? false : state.atomValues.has(key),\n    isModified: () => state.dirtyAtoms.has(key),\n    // Report current dependencies.  If the node hasn't been evaluated, then\n    // dependencies may be missing based on the current state.\n    deps: () => {\n      var _graph$nodeDeps$get;\n\n      return recoilValuesForKeys$1((_graph$nodeDeps$get = graph.nodeDeps.get(key)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : []);\n    },\n    // Reports all \"current\" subscribers.  Evaluating other nodes or\n    // previous in-progress async evaluations may introduce new subscribers.\n    subscribers: () => {\n      var _storeState$nodeToCom, _storeState$nodeToCom2;\n\n      return {\n        nodes: recoilValuesForKeys$1(Recoil_filterIterable(getDownstreamNodes(store, state, new Set([key])), nodeKey => nodeKey !== key)),\n        components: Recoil_mapIterable((_storeState$nodeToCom = (_storeState$nodeToCom2 = storeState.nodeToComponentSubscriptions.get(key)) === null || _storeState$nodeToCom2 === void 0 ? void 0 : _storeState$nodeToCom2.values()) !== null && _storeState$nodeToCom !== void 0 ? _storeState$nodeToCom : [], ([name]) => ({\n          name\n        }))\n      };\n    }\n  });\n} // Find all of the recursively dependent nodes\n\n\nfunction getDownstreamNodes(store, state, keys) {\n  const visitedNodes = new Set();\n  const visitingNodes = Array.from(keys);\n  const graph = store.getGraph(state.version);\n\n  for (let key = visitingNodes.pop(); key; key = visitingNodes.pop()) {\n    var _graph$nodeToNodeSubs;\n\n    visitedNodes.add(key);\n    const subscribedNodes = (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(key)) !== null && _graph$nodeToNodeSubs !== void 0 ? _graph$nodeToNodeSubs : emptySet;\n\n    for (const downstreamNode of subscribedNodes) {\n      if (!visitedNodes.has(downstreamNode)) {\n        visitingNodes.push(downstreamNode);\n      }\n    }\n  }\n\n  return visitedNodes;\n}\n\nvar Recoil_FunctionalCore = {\n  getNodeLoadable,\n  peekNodeLoadable,\n  setNodeValue,\n  initializeNode,\n  cleanUpNode,\n  setUnvalidatedAtomValue_DEPRECATED,\n  peekNodeInfo,\n  getDownstreamNodes\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nlet _invalidateMemoizedSnapshot = null;\n\nfunction setInvalidateMemoizedSnapshot(invalidate) {\n  _invalidateMemoizedSnapshot = invalidate;\n}\n\nfunction invalidateMemoizedSnapshot() {\n  var _invalidateMemoizedSn;\n\n  (_invalidateMemoizedSn = _invalidateMemoizedSnapshot) === null || _invalidateMemoizedSn === void 0 ? void 0 : _invalidateMemoizedSn();\n}\n\nvar Recoil_SnapshotCache = {\n  setInvalidateMemoizedSnapshot,\n  invalidateMemoizedSnapshot\n};\nconst {\n  getDownstreamNodes: getDownstreamNodes$1,\n  getNodeLoadable: getNodeLoadable$1,\n  setNodeValue: setNodeValue$1\n} = Recoil_FunctionalCore;\nconst {\n  getNextComponentID: getNextComponentID$1\n} = Recoil_Keys;\nconst {\n  getNode: getNode$2,\n  getNodeMaybe: getNodeMaybe$2\n} = Recoil_Node;\nconst {\n  DefaultValue: DefaultValue$1\n} = Recoil_Node;\nconst {\n  reactMode: reactMode$1\n} = Recoil_ReactMode;\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$1,\n  RecoilState: RecoilState$1,\n  RecoilValueReadOnly: RecoilValueReadOnly$1,\n  isRecoilValue: isRecoilValue$1\n} = Recoil_RecoilValue$1;\nconst {\n  invalidateMemoizedSnapshot: invalidateMemoizedSnapshot$1\n} = Recoil_SnapshotCache;\n\nfunction getRecoilValueAsLoadable(store, {\n  key\n}, treeState = store.getState().currentTree) {\n  var _storeState$nextTree, _storeState$previousT; // Reading from an older tree can cause bugs because the dependencies that we\n  // discover during the read are lost.\n\n\n  const storeState = store.getState();\n\n  if (!(treeState.version === storeState.currentTree.version || treeState.version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || treeState.version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {\n    Recoil_recoverableViolation('Tried to read from a discarded tree');\n  }\n\n  const loadable = getNodeLoadable$1(store, treeState, key);\n\n  if (loadable.state === 'loading') {\n    loadable.contents.catch(() => {\n      /**\r\n       * HACK: intercept thrown error here to prevent an uncaught promise exception. Ideally this would happen closer to selector\r\n       * execution (perhaps introducing a new ERROR class to be resolved by async selectors that are in an error state)\r\n       */\n      return;\n    });\n  }\n\n  return loadable;\n}\n\nfunction applyAtomValueWrites(atomValues, writes) {\n  const result = atomValues.clone();\n  writes.forEach((v, k) => {\n    if (v.state === 'hasValue' && v.contents instanceof DefaultValue$1) {\n      result.delete(k);\n    } else {\n      result.set(k, v);\n    }\n  });\n  return result;\n}\n\nfunction valueFromValueOrUpdater(store, state, {\n  key\n}, valueOrUpdater) {\n  if (typeof valueOrUpdater === 'function') {\n    // Updater form: pass in the current value. Throw if the current value\n    // is unavailable (namely when updating an async selector that's\n    // pending or errored):\n    const current = getNodeLoadable$1(store, state, key);\n\n    if (current.state === 'loading') {\n      const msg = `Tried to set atom or selector \"${key}\" using an updater function while the current state is pending, this is not currently supported.`;\n      Recoil_recoverableViolation(msg);\n      throw Recoil_err(msg);\n    } else if (current.state === 'hasError') {\n      throw current.contents;\n    } // T itself may be a function, so our refinement is not sufficient:\n\n\n    return valueOrUpdater(current.contents); // flowlint-line unclear-type:off\n  } else {\n    return valueOrUpdater;\n  }\n}\n\nfunction applyAction(store, state, action) {\n  if (action.type === 'set') {\n    const {\n      recoilValue,\n      valueOrUpdater\n    } = action;\n    const newValue = valueFromValueOrUpdater(store, state, recoilValue, valueOrUpdater);\n    const writes = setNodeValue$1(store, state, recoilValue.key, newValue);\n\n    for (const [key, loadable] of writes.entries()) {\n      writeLoadableToTreeState(state, key, loadable);\n    }\n  } else if (action.type === 'setLoadable') {\n    const {\n      recoilValue: {\n        key\n      },\n      loadable\n    } = action;\n    writeLoadableToTreeState(state, key, loadable);\n  } else if (action.type === 'markModified') {\n    const {\n      recoilValue: {\n        key\n      }\n    } = action;\n    state.dirtyAtoms.add(key);\n  } else if (action.type === 'setUnvalidated') {\n    var _node$invalidate; // Write value directly to state bypassing the Node interface as the node\n    // definitions may not have been loaded yet when processing the initial snapshot.\n\n\n    const {\n      recoilValue: {\n        key\n      },\n      unvalidatedValue\n    } = action;\n    const node = getNodeMaybe$2(key);\n    node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);\n    state.atomValues.delete(key);\n    state.nonvalidatedAtoms.set(key, unvalidatedValue);\n    state.dirtyAtoms.add(key);\n  } else {\n    Recoil_recoverableViolation(`Unknown action ${action.type}`);\n  }\n}\n\nfunction writeLoadableToTreeState(state, key, loadable) {\n  if (loadable.state === 'hasValue' && loadable.contents instanceof DefaultValue$1) {\n    state.atomValues.delete(key);\n  } else {\n    state.atomValues.set(key, loadable);\n  }\n\n  state.dirtyAtoms.add(key);\n  state.nonvalidatedAtoms.delete(key);\n}\n\nfunction applyActionsToStore(store, actions) {\n  store.replaceState(state => {\n    const newState = copyTreeState(state);\n\n    for (const action of actions) {\n      applyAction(store, newState, action);\n    }\n\n    invalidateDownstreams(store, newState);\n    invalidateMemoizedSnapshot$1();\n    return newState;\n  });\n}\n\nfunction queueOrPerformStateUpdate(store, action) {\n  if (batchStack.length) {\n    const actionsByStore = batchStack[batchStack.length - 1];\n    let actions = actionsByStore.get(store);\n\n    if (!actions) {\n      actionsByStore.set(store, actions = []);\n    }\n\n    actions.push(action);\n  } else {\n    applyActionsToStore(store, [action]);\n  }\n}\n\nconst batchStack = [];\n\nfunction batchStart() {\n  const actionsByStore = new Map();\n  batchStack.push(actionsByStore);\n  return () => {\n    for (const [store, actions] of actionsByStore) {\n      applyActionsToStore(store, actions);\n    }\n\n    const popped = batchStack.pop();\n\n    if (popped !== actionsByStore) {\n      Recoil_recoverableViolation('Incorrect order of batch popping');\n    }\n  };\n}\n\nfunction copyTreeState(state) {\n  return { ...state,\n    atomValues: state.atomValues.clone(),\n    nonvalidatedAtoms: state.nonvalidatedAtoms.clone(),\n    dirtyAtoms: new Set(state.dirtyAtoms)\n  };\n}\n\nfunction invalidateDownstreams(store, state) {\n  // Inform any nodes that were changed or downstream of changes so that they\n  // can clear out any caches as needed due to the update:\n  const downstreams = getDownstreamNodes$1(store, state, state.dirtyAtoms);\n\n  for (const key of downstreams) {\n    var _getNodeMaybe, _getNodeMaybe$invalid;\n\n    (_getNodeMaybe = getNodeMaybe$2(key)) === null || _getNodeMaybe === void 0 ? void 0 : (_getNodeMaybe$invalid = _getNodeMaybe.invalidate) === null || _getNodeMaybe$invalid === void 0 ? void 0 : _getNodeMaybe$invalid.call(_getNodeMaybe, state);\n  }\n}\n\nfunction setRecoilValue(store, recoilValue, valueOrUpdater) {\n  queueOrPerformStateUpdate(store, {\n    type: 'set',\n    recoilValue,\n    valueOrUpdater\n  });\n}\n\nfunction setRecoilValueLoadable(store, recoilValue, loadable) {\n  if (loadable instanceof DefaultValue$1) {\n    return setRecoilValue(store, recoilValue, loadable);\n  }\n\n  queueOrPerformStateUpdate(store, {\n    type: 'setLoadable',\n    recoilValue,\n    loadable: loadable\n  });\n}\n\nfunction markRecoilValueModified(store, recoilValue) {\n  queueOrPerformStateUpdate(store, {\n    type: 'markModified',\n    recoilValue\n  });\n}\n\nfunction setUnvalidatedRecoilValue(store, recoilValue, unvalidatedValue) {\n  queueOrPerformStateUpdate(store, {\n    type: 'setUnvalidated',\n    recoilValue,\n    unvalidatedValue\n  });\n}\n\nfunction subscribeToRecoilValue(store, {\n  key\n}, callback, componentDebugName = null) {\n  const subID = getNextComponentID$1();\n  const storeState = store.getState();\n\n  if (!storeState.nodeToComponentSubscriptions.has(key)) {\n    storeState.nodeToComponentSubscriptions.set(key, new Map());\n  }\n\n  Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID, [componentDebugName !== null && componentDebugName !== void 0 ? componentDebugName : '<not captured>', callback]); // Handle the case that, during the same tick that we are subscribing, an atom\n  // has been updated by some effect handler. Otherwise we will miss the update.\n\n  const mode = reactMode$1();\n\n  if (mode.early && (mode.mode === 'LEGACY' || mode.mode === 'MUTABLE_SOURCE')) {\n    const nextTree = store.getState().nextTree;\n\n    if (nextTree && nextTree.dirtyAtoms.has(key)) {\n      callback(nextTree);\n    }\n  }\n\n  return {\n    release: () => {\n      const releaseStoreState = store.getState();\n      const subs = releaseStoreState.nodeToComponentSubscriptions.get(key);\n\n      if (subs === undefined || !subs.has(subID)) {\n        Recoil_recoverableViolation(`Subscription missing at release time for atom ${key}. This is a bug in Recoil.`);\n        return;\n      }\n\n      subs.delete(subID);\n\n      if (subs.size === 0) {\n        releaseStoreState.nodeToComponentSubscriptions.delete(key);\n      }\n    }\n  };\n}\n\nfunction refreshRecoilValue(store, recoilValue) {\n  var _node$clearCache;\n\n  const {\n    currentTree\n  } = store.getState();\n  const node = getNode$2(recoilValue.key);\n  (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, currentTree);\n}\n\nvar Recoil_RecoilValueInterface = {\n  RecoilValueReadOnly: RecoilValueReadOnly$1,\n  AbstractRecoilValue: AbstractRecoilValue$1,\n  RecoilState: RecoilState$1,\n  getRecoilValueAsLoadable,\n  setRecoilValue,\n  setRecoilValueLoadable,\n  markRecoilValueModified,\n  setUnvalidatedRecoilValue,\n  subscribeToRecoilValue,\n  isRecoilValue: isRecoilValue$1,\n  applyAtomValueWrites,\n  // TODO Remove export when deprecating initialStoreState_DEPRECATED in RecoilRoot\n  batchStart,\n  writeLoadableToTreeState,\n  invalidateDownstreams,\n  copyTreeState,\n  refreshRecoilValue\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * The someSet() method tests whether some elements in the given Set pass the\r\n * test implemented by the provided function.\r\n */\n\nfunction someSet(set, callback, context) {\n  const iterator = set.entries();\n  let current = iterator.next();\n\n  while (!current.done) {\n    const entry = current.value;\n\n    if (callback.call(context, entry[1], entry[0], set)) {\n      return true;\n    }\n\n    current = iterator.next();\n  }\n\n  return false;\n}\n\nvar Recoil_someSet = someSet;\nconst {\n  cleanUpNode: cleanUpNode$1\n} = Recoil_FunctionalCore;\nconst {\n  deleteNodeConfigIfPossible: deleteNodeConfigIfPossible$1,\n  getNode: getNode$3\n} = Recoil_Node;\nconst {\n  RetentionZone: RetentionZone$2\n} = Recoil_RetentionZone; // Components that aren't mounted after suspending for this long will be assumed\n// to be discarded and their resources released.\n\nconst SUSPENSE_TIMEOUT_MS = 120000;\nconst emptySet$1 = new Set();\n\nfunction releaseRetainablesNowOnCurrentTree(store, retainables) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree;\n\n  if (storeState.nextTree) {\n    Recoil_recoverableViolation('releaseNodesNowOnCurrentTree should only be called at the end of a batch');\n    return; // leak memory rather than erase something that's about to be used.\n  }\n\n  const nodes = new Set();\n\n  for (const r of retainables) {\n    if (r instanceof RetentionZone$2) {\n      for (const n of nodesRetainedByZone(storeState, r)) {\n        nodes.add(n);\n      }\n    } else {\n      nodes.add(r);\n    }\n  }\n\n  const releasableNodes = findReleasableNodes(store, nodes);\n\n  for (const node of releasableNodes) {\n    releaseNode(store, treeState, node);\n  }\n}\n\nfunction findReleasableNodes(store, searchFromNodes) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree;\n  const graph = store.getGraph(treeState.version);\n  const releasableNodes = new Set(); // mutated to collect answer\n\n  const nonReleasableNodes = new Set();\n  findReleasableNodesInner(searchFromNodes);\n  return releasableNodes;\n\n  function findReleasableNodesInner(searchFromNodes) {\n    const releasableNodesFoundThisIteration = new Set();\n    const downstreams = getDownstreamNodesInTopologicalOrder(store, treeState, searchFromNodes, releasableNodes, // don't descend into these\n    nonReleasableNodes // don't descend into these\n    ); // Find which of the downstream nodes are releasable and which are not:\n\n    for (const node of downstreams) {\n      var _storeState$retention; // Not releasable if configured to be retained forever:\n\n\n      if (getNode$3(node).retainedBy === 'recoilRoot') {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if retained directly by a component:\n\n\n      if (((_storeState$retention = storeState.retention.referenceCounts.get(node)) !== null && _storeState$retention !== void 0 ? _storeState$retention : 0) > 0) {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if retained by a zone:\n\n\n      if (zonesThatCouldRetainNode(node).some(z => storeState.retention.referenceCounts.get(z))) {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if it has a non-releasable child (which will already be in\n      // nonReleasableNodes because we are going in topological order):\n\n\n      const nodeChildren = graph.nodeToNodeSubscriptions.get(node);\n\n      if (nodeChildren && Recoil_someSet(nodeChildren, child => nonReleasableNodes.has(child))) {\n        nonReleasableNodes.add(node);\n        continue;\n      }\n\n      releasableNodes.add(node);\n      releasableNodesFoundThisIteration.add(node);\n    } // If we found any releasable nodes, we need to walk UP from those nodes to\n    // find whether their parents can now be released as well:\n\n\n    const parents = new Set();\n\n    for (const node of releasableNodesFoundThisIteration) {\n      for (const parent of (_graph$nodeDeps$get = graph.nodeDeps.get(node)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : emptySet$1) {\n        var _graph$nodeDeps$get;\n\n        if (!releasableNodes.has(parent)) {\n          parents.add(parent);\n        }\n      }\n    }\n\n    if (parents.size) {\n      findReleasableNodesInner(parents);\n    }\n  }\n} // Children before parents\n\n\nfunction getDownstreamNodesInTopologicalOrder(store, treeState, nodes, // Mutable set is destroyed in place\ndoNotDescendInto1, doNotDescendInto2) {\n  const graph = store.getGraph(treeState.version);\n  const answer = [];\n  const visited = new Set();\n\n  while (nodes.size > 0) {\n    visit(Recoil_nullthrows(nodes.values().next().value));\n  }\n\n  return answer;\n\n  function visit(node) {\n    if (doNotDescendInto1.has(node) || doNotDescendInto2.has(node)) {\n      nodes.delete(node);\n      return;\n    }\n\n    if (visited.has(node)) {\n      return;\n    }\n\n    const children = graph.nodeToNodeSubscriptions.get(node);\n\n    if (children) {\n      for (const child of children) {\n        visit(child);\n      }\n    }\n\n    visited.add(node);\n    nodes.delete(node);\n    answer.push(node);\n  }\n}\n\nfunction releaseNode(store, treeState, node) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  } // Atom effects, in-closure caches, etc.:\n\n\n  cleanUpNode$1(store, node); // Delete from store state:\n\n  const storeState = store.getState();\n  storeState.knownAtoms.delete(node);\n  storeState.knownSelectors.delete(node);\n  storeState.nodeTransactionSubscriptions.delete(node);\n  storeState.retention.referenceCounts.delete(node);\n  const zones = zonesThatCouldRetainNode(node);\n\n  for (const zone of zones) {\n    var _storeState$retention2;\n\n    (_storeState$retention2 = storeState.retention.nodesRetainedByZone.get(zone)) === null || _storeState$retention2 === void 0 ? void 0 : _storeState$retention2.delete(node);\n  } // Note that we DO NOT delete from nodeToComponentSubscriptions because this\n  // already happens when the last component that was retaining the node unmounts,\n  // and this could happen either before or after that.\n  // Delete from TreeState and dep graph:\n\n\n  treeState.atomValues.delete(node);\n  treeState.dirtyAtoms.delete(node);\n  treeState.nonvalidatedAtoms.delete(node);\n  const graph = storeState.graphsByVersion.get(treeState.version);\n\n  if (graph) {\n    const deps = graph.nodeDeps.get(node);\n\n    if (deps !== undefined) {\n      graph.nodeDeps.delete(node);\n\n      for (const dep of deps) {\n        var _graph$nodeToNodeSubs;\n\n        (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(dep)) === null || _graph$nodeToNodeSubs === void 0 ? void 0 : _graph$nodeToNodeSubs.delete(node);\n      }\n    } // No need to delete sub's deps as there should be no subs at this point.\n    // But an invariant would require deleting nodes in topological order.\n\n\n    graph.nodeToNodeSubscriptions.delete(node);\n  } // Node config (for family members only as their configs can be recreated, and\n  // only if they are not retained within any other Stores):\n\n\n  deleteNodeConfigIfPossible$1(node);\n}\n\nfunction nodesRetainedByZone(storeState, zone) {\n  var _storeState$retention3;\n\n  return (_storeState$retention3 = storeState.retention.nodesRetainedByZone.get(zone)) !== null && _storeState$retention3 !== void 0 ? _storeState$retention3 : emptySet$1;\n}\n\nfunction zonesThatCouldRetainNode(node) {\n  const retainedBy = getNode$3(node).retainedBy;\n\n  if (retainedBy === undefined || retainedBy === 'components' || retainedBy === 'recoilRoot') {\n    return [];\n  } else if (retainedBy instanceof RetentionZone$2) {\n    return [retainedBy];\n  } else {\n    return retainedBy; // it's an array of zones\n  }\n}\n\nfunction scheduleOrPerformPossibleReleaseOfRetainable(store, retainable) {\n  const state = store.getState();\n\n  if (state.nextTree) {\n    state.retention.retainablesToCheckForRelease.add(retainable);\n  } else {\n    releaseRetainablesNowOnCurrentTree(store, new Set([retainable]));\n  }\n}\n\nfunction updateRetainCount(store, retainable, delta) {\n  var _map$get;\n\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const map = store.getState().retention.referenceCounts;\n  const newCount = ((_map$get = map.get(retainable)) !== null && _map$get !== void 0 ? _map$get : 0) + delta;\n\n  if (newCount === 0) {\n    updateRetainCountToZero(store, retainable);\n  } else {\n    map.set(retainable, newCount);\n  }\n}\n\nfunction updateRetainCountToZero(store, retainable) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const map = store.getState().retention.referenceCounts;\n  map.delete(retainable);\n  scheduleOrPerformPossibleReleaseOfRetainable(store, retainable);\n}\n\nfunction releaseScheduledRetainablesNow(store) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const state = store.getState();\n  releaseRetainablesNowOnCurrentTree(store, state.retention.retainablesToCheckForRelease);\n  state.retention.retainablesToCheckForRelease.clear();\n}\n\nfunction retainedByOptionWithDefault(r) {\n  // The default will change from 'recoilRoot' to 'components' in the future.\n  return r === undefined ? 'recoilRoot' : r;\n}\n\nvar Recoil_Retention = {\n  SUSPENSE_TIMEOUT_MS,\n  updateRetainCount,\n  updateRetainCountToZero,\n  releaseScheduledRetainablesNow,\n  retainedByOptionWithDefault\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * This is to export esstiential functions from react-dom\r\n * for our web build\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nconst {\n  unstable_batchedUpdates\n} = (react_dom__WEBPACK_IMPORTED_MODULE_1___default());\nvar ReactBatchedUpdates = {\n  unstable_batchedUpdates\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * This is to export esstiential functions from react-dom\r\n * for our web build\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n// @fb-only: const {unstable_batchedUpdates} = require('ReactDOMComet');\n// prettier-ignore\n\nconst {\n  unstable_batchedUpdates: unstable_batchedUpdates$1\n} = ReactBatchedUpdates; // @oss-only\n\nvar Recoil_ReactBatchedUpdates = {\n  unstable_batchedUpdates: unstable_batchedUpdates$1\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nconst {\n  batchStart: batchStart$1\n} = Recoil_RecoilValueInterface;\nconst {\n  unstable_batchedUpdates: unstable_batchedUpdates$2\n} = Recoil_ReactBatchedUpdates;\nlet batcher = unstable_batchedUpdates$2; // flowlint-next-line unclear-type:off\n\n/**\r\n * Sets the provided batcher function as the batcher function used by Recoil.\r\n *\r\n * Set the batcher to a custom batcher for your renderer,\r\n * if you use a renderer other than React DOM or React Native.\r\n */\n\nconst setBatcher = newBatcher => {\n  batcher = newBatcher;\n};\n/**\r\n * Returns the current batcher function.\r\n */\n\n\nconst getBatcher = () => batcher;\n/**\r\n * Calls the current batcher function and passes the\r\n * provided callback function.\r\n */\n\n\nconst batchUpdates = callback => {\n  batcher(() => {\n    let batchEnd = () => undefined;\n\n    try {\n      batchEnd = batchStart$1();\n      callback();\n    } finally {\n      batchEnd();\n    }\n  });\n};\n\nvar Recoil_Batching = {\n  getBatcher,\n  setBatcher,\n  batchUpdates\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Combines multiple Iterables into a single Iterable.\r\n * Traverses the input Iterables in the order provided and maintains the order\r\n * of their elements.\r\n *\r\n * Example:\r\n * ```\r\n * const r = Array.from(concatIterables(['a', 'b'], ['c'], ['d', 'e', 'f']));\r\n * r == ['a', 'b', 'c', 'd', 'e', 'f'];\r\n * ```\r\n */\n\nfunction* concatIterables(iters) {\n  for (const iter of iters) {\n    for (const val of iter) {\n      yield val;\n    }\n  }\n}\n\nvar Recoil_concatIterables = concatIterables;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/* eslint-disable fb-www/typeof-undefined */\n\nconst isSSR = // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709\ntypeof Window === 'undefined' || typeof window === 'undefined';\n/* eslint-enable fb-www/typeof-undefined */\n\nconst isWindow = value => !isSSR && ( // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709\nvalue === window || value instanceof Window);\n\nconst isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative'; // eslint-disable-line fb-www/typeof-undefined\n\nvar Recoil_Environment = {\n  isSSR,\n  isReactNative,\n  isWindow\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Caches a function's results based on the key returned by the passed\r\n * hashFunction.\r\n */\n\nfunction memoizeWithArgsHash(fn, hashFunction) {\n  let cache;\n\n  const memoizedFn = (...args) => {\n    if (!cache) {\n      cache = {};\n    }\n\n    const key = hashFunction(...args);\n\n    if (!Object.hasOwnProperty.call(cache, key)) {\n      cache[key] = fn(...args);\n    }\n\n    return cache[key];\n  };\n\n  return memoizedFn;\n}\n/**\r\n * Caches a function's results based on a comparison of the arguments.\r\n * Only caches the last return of the function.\r\n * Defaults to reference equality\r\n */\n\n\nfunction memoizeOneWithArgsHash(fn, hashFunction) {\n  let lastKey;\n  let lastResult; // breaking cache when arguments change\n\n  const memoizedFn = (...args) => {\n    const key = hashFunction(...args);\n\n    if (lastKey === key) {\n      return lastResult;\n    }\n\n    lastKey = key;\n    lastResult = fn(...args);\n    return lastResult;\n  };\n\n  return memoizedFn;\n}\n/**\r\n * Caches a function's results based on a comparison of the arguments.\r\n * Only caches the last return of the function.\r\n * Defaults to reference equality\r\n */\n\n\nfunction memoizeOneWithArgsHashAndInvalidation(fn, hashFunction) {\n  let lastKey;\n  let lastResult; // breaking cache when arguments change\n\n  const memoizedFn = (...args) => {\n    const key = hashFunction(...args);\n\n    if (lastKey === key) {\n      return lastResult;\n    }\n\n    lastKey = key;\n    lastResult = fn(...args);\n    return lastResult;\n  };\n\n  const invalidate = () => {\n    lastKey = null;\n  };\n\n  return [memoizedFn, invalidate];\n}\n\nvar Recoil_Memoize = {\n  memoizeWithArgsHash,\n  memoizeOneWithArgsHash,\n  memoizeOneWithArgsHashAndInvalidation\n};\nconst {\n  batchUpdates: batchUpdates$1\n} = Recoil_Batching;\nconst {\n  initializeNode: initializeNode$1,\n  peekNodeInfo: peekNodeInfo$1\n} = Recoil_FunctionalCore;\nconst {\n  graph: graph$1\n} = Recoil_Graph;\nconst {\n  getNextStoreID: getNextStoreID$1\n} = Recoil_Keys;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$1,\n  recoilValues: recoilValues$1,\n  recoilValuesForKeys: recoilValuesForKeys$2\n} = Recoil_Node;\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$2,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$1,\n  setRecoilValue: setRecoilValue$1,\n  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$1\n} = Recoil_RecoilValueInterface;\nconst {\n  updateRetainCount: updateRetainCount$1\n} = Recoil_Retention;\nconst {\n  setInvalidateMemoizedSnapshot: setInvalidateMemoizedSnapshot$1\n} = Recoil_SnapshotCache;\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$2,\n  makeEmptyStoreState: makeEmptyStoreState$1\n} = Recoil_State;\nconst {\n  isSSR: isSSR$1\n} = Recoil_Environment;\nconst {\n  memoizeOneWithArgsHashAndInvalidation: memoizeOneWithArgsHashAndInvalidation$1\n} = Recoil_Memoize; // Opaque at this surface because it's part of the public API from here.\n\nconst retainWarning = `\nRecoil Snapshots only last for the duration of the callback they are provided to. To keep a Snapshot longer, do this:\n\n  const release = snapshot.retain();\n  try {\n    await doSomethingWithSnapshot(snapshot);\n  } finally {\n    release();\n  }\n\nThis is currently a DEV-only warning but will become a thrown exception in the next release of Recoil.\n`; // A \"Snapshot\" is \"read-only\" and captures a specific set of values of atoms.\n// However, the data-flow-graph and selector values may evolve as selector\n// evaluation functions are executed and async selectors resolve.\n\nclass Snapshot {\n  // eslint-disable-next-line fb-www/no-uninitialized-properties\n  constructor(storeState, parentStoreID) {\n    _defineProperty(this, \"_store\", void 0);\n\n    _defineProperty(this, \"_refCount\", 1);\n\n    _defineProperty(this, \"getLoadable\", recoilValue => {\n      this.checkRefCount_INTERNAL();\n      return getRecoilValueAsLoadable$1(this._store, recoilValue);\n    });\n\n    _defineProperty(this, \"getPromise\", recoilValue => {\n      this.checkRefCount_INTERNAL();\n      return this.getLoadable(recoilValue).toPromise();\n    });\n\n    _defineProperty(this, \"getNodes_UNSTABLE\", opt => {\n      this.checkRefCount_INTERNAL(); // TODO Deal with modified selectors\n\n      if ((opt === null || opt === void 0 ? void 0 : opt.isModified) === true) {\n        if ((opt === null || opt === void 0 ? void 0 : opt.isInitialized) === false) {\n          return [];\n        }\n\n        const state = this._store.getState().currentTree;\n\n        return recoilValuesForKeys$2(state.dirtyAtoms);\n      }\n\n      const knownAtoms = this._store.getState().knownAtoms;\n\n      const knownSelectors = this._store.getState().knownSelectors;\n\n      return (opt === null || opt === void 0 ? void 0 : opt.isInitialized) == null ? recoilValues$1.values() : opt.isInitialized === true ? recoilValuesForKeys$2(Recoil_concatIterables([knownAtoms, knownSelectors])) : Recoil_filterIterable(recoilValues$1.values(), ({\n        key\n      }) => !knownAtoms.has(key) && !knownSelectors.has(key));\n    });\n\n    _defineProperty(this, \"getInfo_UNSTABLE\", ({\n      key\n    }) => {\n      this.checkRefCount_INTERNAL();\n      return peekNodeInfo$1(this._store, this._store.getState().currentTree, key);\n    });\n\n    _defineProperty(this, \"map\", mapper => {\n      this.checkRefCount_INTERNAL();\n      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);\n      mapper(mutableSnapshot); // if removing batchUpdates from `set` add it here\n\n      return mutableSnapshot;\n    });\n\n    _defineProperty(this, \"asyncMap\", async mapper => {\n      this.checkRefCount_INTERNAL();\n      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);\n      mutableSnapshot.retain(); // Retain new snapshot during async mapper\n\n      await mapper(mutableSnapshot); // Continue to retain the new snapshot for the user, but auto-release it\n      // after the next tick, the same as a new synchronous snapshot.\n\n      mutableSnapshot.autoRelease_INTERNAL();\n      return mutableSnapshot;\n    });\n\n    this._store = {\n      storeID: getNextStoreID$1(),\n      parentStoreID,\n      getState: () => storeState,\n      replaceState: replacer => {\n        // no batching, so nextTree is never active\n        storeState.currentTree = replacer(storeState.currentTree);\n      },\n      getGraph: version => {\n        const graphs = storeState.graphsByVersion;\n\n        if (graphs.has(version)) {\n          return Recoil_nullthrows(graphs.get(version));\n        }\n\n        const newGraph = graph$1();\n        graphs.set(version, newGraph);\n        return newGraph;\n      },\n      subscribeToTransactions: () => ({\n        release: () => {}\n      }),\n      addTransactionMetadata: () => {\n        throw Recoil_err('Cannot subscribe to Snapshots');\n      }\n    }; // Initialize any nodes that are live in the parent store (primarily so that\n    // this snapshot gets counted towards the node's live stores count).\n    // TODO Optimize this when cloning snapshots for callbacks\n\n    for (const nodeKey of this._store.getState().knownAtoms) {\n      initializeNode$1(this._store, nodeKey, 'get');\n      updateRetainCount$1(this._store, nodeKey, 1);\n    }\n\n    this.autoRelease_INTERNAL();\n  }\n\n  retain() {\n    if (this._refCount <= 0) {\n      if (true) {\n        throw Recoil_err('Snapshot has already been released.');\n      } else {}\n    }\n\n    this._refCount++;\n    let released = false;\n    return () => {\n      if (!released) {\n        released = true;\n\n        this._release();\n      }\n    };\n  }\n  /**\r\n   * Release the snapshot on the next tick.  This means the snapshot is retained\r\n   * during the execution of the current function using it.\r\n   */\n\n\n  autoRelease_INTERNAL() {\n    if (!isSSR$1) {\n      // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936\n      window.setTimeout(() => this._release(), 10);\n    }\n  }\n\n  _release() {\n    this._refCount--;\n\n    if (this._refCount === 0) {\n      this._store.getState().nodeCleanupFunctions.forEach(cleanup => cleanup());\n\n      this._store.getState().nodeCleanupFunctions.clear();\n\n      if (!Recoil_gkx('recoil_memory_managament_2020')) {\n        return;\n      } // Temporarily nerfing this to allow us to find broken call sites without\n      // actually breaking anybody yet.\n      // for (const k of this._store.getState().knownAtoms) {\n      //   updateRetainCountToZero(this._store, k);\n      // }\n\n    } else if (this._refCount < 0) {\n      if (true) {\n        Recoil_recoverableViolation('Snapshot released an extra time.');\n      }\n    }\n  }\n\n  isRetained() {\n    return this._refCount > 0;\n  }\n\n  checkRefCount_INTERNAL() {\n    if (Recoil_gkx('recoil_memory_managament_2020') && this._refCount <= 0) {\n      if (true) {\n        Recoil_recoverableViolation(retainWarning);\n      } // What we will ship later:\n      // throw err(retainWarning);\n\n    }\n  }\n\n  getStore_INTERNAL() {\n    this.checkRefCount_INTERNAL();\n    return this._store;\n  }\n\n  getID() {\n    this.checkRefCount_INTERNAL();\n    return this._store.getState().currentTree.stateID;\n  }\n\n  getStoreID() {\n    this.checkRefCount_INTERNAL();\n    return this._store.storeID;\n  } // We want to allow the methods to be destructured and used as accessors\n\n  /* eslint-disable fb-www/extra-arrow-initializer */\n\n  /* eslint-enable fb-www/extra-arrow-initializer */\n\n\n}\n\nfunction cloneStoreState(store, treeState, bumpVersion = false) {\n  const storeState = store.getState();\n  const version = bumpVersion ? getNextTreeStateVersion$2() : treeState.version;\n  return {\n    // Always clone the TreeState to isolate stores from accidental mutations.\n    // For example, reading a selector from a cloned snapshot shouldn't cache\n    // in the original treestate which may cause the original to skip\n    // initialization of upstream atoms.\n    currentTree: {\n      // TODO snapshots shouldn't really have versions because a new version number\n      // is always assigned when the snapshot is gone to.\n      version: bumpVersion ? version : treeState.version,\n      stateID: bumpVersion ? version : treeState.stateID,\n      transactionMetadata: { ...treeState.transactionMetadata\n      },\n      dirtyAtoms: new Set(treeState.dirtyAtoms),\n      atomValues: treeState.atomValues.clone(),\n      nonvalidatedAtoms: treeState.nonvalidatedAtoms.clone()\n    },\n    commitDepth: 0,\n    nextTree: null,\n    previousTree: null,\n    knownAtoms: new Set(storeState.knownAtoms),\n    // FIXME here's a copy\n    knownSelectors: new Set(storeState.knownSelectors),\n    // FIXME here's a copy\n    transactionSubscriptions: new Map(),\n    nodeTransactionSubscriptions: new Map(),\n    nodeToComponentSubscriptions: new Map(),\n    queuedComponentCallbacks_DEPRECATED: [],\n    suspendedComponentResolvers: new Set(),\n    graphsByVersion: new Map().set(version, store.getGraph(treeState.version)),\n    retention: {\n      referenceCounts: new Map(),\n      nodesRetainedByZone: new Map(),\n      retainablesToCheckForRelease: new Set()\n    },\n    // FIXME here's a copy\n    // Create blank cleanup handlers for atoms so snapshots don't re-run\n    // atom effects.\n    nodeCleanupFunctions: new Map(Recoil_mapIterable(storeState.nodeCleanupFunctions.entries(), ([key]) => [key, () => {}]))\n  };\n} // Factory to build a fresh snapshot\n\n\nfunction freshSnapshot(initializeState) {\n  const snapshot = new Snapshot(makeEmptyStoreState$1());\n  return initializeState != null ? snapshot.map(initializeState) : snapshot;\n} // Factory to clone a snapshot state\n\n\nconst [memoizedCloneSnapshot, invalidateMemoizedSnapshot$2] = memoizeOneWithArgsHashAndInvalidation$1((store, version) => {\n  var _storeState$nextTree;\n\n  const storeState = store.getState();\n  const treeState = version === 'latest' ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : Recoil_nullthrows(storeState.previousTree);\n  return new Snapshot(cloneStoreState(store, treeState), store.storeID);\n}, (store, version) => {\n  var _store$getState$nextT, _store$getState$previ;\n\n  return String(version) + String(store.storeID) + String((_store$getState$nextT = store.getState().nextTree) === null || _store$getState$nextT === void 0 ? void 0 : _store$getState$nextT.version) + String(store.getState().currentTree.version) + String((_store$getState$previ = store.getState().previousTree) === null || _store$getState$previ === void 0 ? void 0 : _store$getState$previ.version);\n}); // Avoid circular dependencies\n\nsetInvalidateMemoizedSnapshot$1(invalidateMemoizedSnapshot$2);\n\nfunction cloneSnapshot(store, version = 'latest') {\n  const snapshot = memoizedCloneSnapshot(store, version);\n\n  if (!snapshot.isRetained()) {\n    invalidateMemoizedSnapshot$2();\n    return memoizedCloneSnapshot(store, version);\n  }\n\n  return snapshot;\n}\n\nclass MutableSnapshot extends Snapshot {\n  constructor(snapshot, batch) {\n    super(cloneStoreState(snapshot.getStore_INTERNAL(), snapshot.getStore_INTERNAL().getState().currentTree, true), snapshot.getStoreID());\n\n    _defineProperty(this, \"_batch\", void 0);\n\n    _defineProperty(this, \"set\", (recoilState, newValueOrUpdater) => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // This batchUpdates ensures this `set` is applied immediately and you can\n      // read the written value after calling `set`. I would like to remove this\n      // behavior and only batch in `Snapshot.map`, but this would be a breaking\n      // change potentially.\n\n      this._batch(() => {\n        updateRetainCount$1(store, recoilState.key, 1);\n        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, newValueOrUpdater);\n      });\n    });\n\n    _defineProperty(this, \"reset\", recoilState => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.\n\n      this._batch(() => {\n        updateRetainCount$1(store, recoilState.key, 1);\n        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, DEFAULT_VALUE$1);\n      });\n    });\n\n    _defineProperty(this, \"setUnvalidatedAtomValues_DEPRECATED\", values => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.\n\n      batchUpdates$1(() => {\n        for (const [k, v] of values.entries()) {\n          updateRetainCount$1(store, k, 1);\n          setUnvalidatedRecoilValue$1(store, new AbstractRecoilValue$2(k), v);\n        }\n      });\n    });\n\n    this._batch = batch;\n  }\n\n}\n\nvar Recoil_Snapshot = {\n  Snapshot,\n  MutableSnapshot,\n  freshSnapshot,\n  cloneSnapshot\n};\nvar Recoil_Snapshot_1 = Recoil_Snapshot.Snapshot;\nvar Recoil_Snapshot_2 = Recoil_Snapshot.MutableSnapshot;\nvar Recoil_Snapshot_3 = Recoil_Snapshot.freshSnapshot;\nvar Recoil_Snapshot_4 = Recoil_Snapshot.cloneSnapshot;\nvar Recoil_Snapshot$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Snapshot: Recoil_Snapshot_1,\n  MutableSnapshot: Recoil_Snapshot_2,\n  freshSnapshot: Recoil_Snapshot_3,\n  cloneSnapshot: Recoil_Snapshot_4\n});\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction unionSets(...sets) {\n  const result = new Set();\n\n  for (const set of sets) {\n    for (const value of set) {\n      result.add(value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_unionSets = unionSets;\nconst {\n  useRef\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n/**\r\n * The same as `useRef()` except that if a function is specified then it will\r\n * call that function to get the value to initialize the reference with.\r\n * This is similar to how `useState()` behaves when given a function.  It allows\r\n * the user to avoid generating the initial value for subsequent renders.\r\n * The tradeoff is that to set the reference to a function itself you need to\r\n * nest it: useRefInitOnce(() => () => {...});\r\n */\n\nfunction useRefInitOnce(initialValue) {\n  // $FlowExpectedError[incompatible-call]\n  const ref = useRef(initialValue);\n\n  if (ref.current === initialValue && typeof initialValue === 'function') {\n    // $FlowExpectedError[incompatible-use]\n    ref.current = initialValue();\n  }\n\n  return ref;\n}\n\nvar Recoil_useRefInitOnce = useRefInitOnce; // @fb-only: const RecoilusagelogEvent = require('RecoilusagelogEvent');\n// @fb-only: const RecoilUsageLogFalcoEvent = require('RecoilUsageLogFalcoEvent');\n// @fb-only: const URI = require('URI');\n\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$3,\n  makeEmptyStoreState: makeEmptyStoreState$2\n} = Recoil_State;\nconst {\n  cleanUpNode: cleanUpNode$2,\n  getDownstreamNodes: getDownstreamNodes$2,\n  initializeNode: initializeNode$2,\n  setNodeValue: setNodeValue$2,\n  setUnvalidatedAtomValue_DEPRECATED: setUnvalidatedAtomValue_DEPRECATED$1\n} = Recoil_FunctionalCore;\nconst {\n  graph: graph$2\n} = Recoil_Graph;\nconst {\n  cloneGraph: cloneGraph$1\n} = Recoil_Graph;\nconst {\n  getNextStoreID: getNextStoreID$2\n} = Recoil_Keys;\nconst {\n  createMutableSource: createMutableSource$1,\n  reactMode: reactMode$2\n} = Recoil_ReactMode;\nconst {\n  applyAtomValueWrites: applyAtomValueWrites$1\n} = Recoil_RecoilValueInterface;\nconst {\n  releaseScheduledRetainablesNow: releaseScheduledRetainablesNow$1\n} = Recoil_Retention;\nconst {\n  freshSnapshot: freshSnapshot$1\n} = Recoil_Snapshot$1;\nconst {\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef: useRef$1,\n  useState\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction notInAContext() {\n  throw Recoil_err('This component must be used inside a <RecoilRoot> component.');\n}\n\nconst defaultStore = Object.freeze({\n  storeID: getNextStoreID$2(),\n  getState: notInAContext,\n  replaceState: notInAContext,\n  getGraph: notInAContext,\n  subscribeToTransactions: notInAContext,\n  addTransactionMetadata: notInAContext\n});\nlet stateReplacerIsBeingExecuted = false;\n\nfunction startNextTreeIfNeeded(store) {\n  if (stateReplacerIsBeingExecuted) {\n    throw Recoil_err('An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.');\n  }\n\n  const storeState = store.getState();\n\n  if (storeState.nextTree === null) {\n    if (Recoil_gkx('recoil_memory_managament_2020') && Recoil_gkx('recoil_release_on_cascading_update_killswitch_2021')) {\n      // If this is a cascading update (that is, rendering due to one state change\n      // invokes a second state change), we won't have cleaned up retainables yet\n      // because this normally happens after notifying components. Do it before\n      // proceeding with the cascading update so that it remains predictable:\n      if (storeState.commitDepth > 0) {\n        releaseScheduledRetainablesNow$1(store);\n      }\n    }\n\n    const version = storeState.currentTree.version;\n    const nextVersion = getNextTreeStateVersion$3();\n    storeState.nextTree = { ...storeState.currentTree,\n      version: nextVersion,\n      stateID: nextVersion,\n      dirtyAtoms: new Set(),\n      transactionMetadata: {}\n    };\n    storeState.graphsByVersion.set(nextVersion, cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))));\n  }\n}\n\nconst AppContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext({\n  current: defaultStore\n});\n\nconst useStoreRef = () => useContext(AppContext); // $FlowExpectedError[incompatible-call]\n\n\nconst MutableSourceContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\n\nfunction useRecoilMutableSource() {\n  const mutableSource = useContext(MutableSourceContext);\n\n  if (mutableSource == null) {\n    Recoil_expectationViolation('Attempted to use a Recoil hook outside of a <RecoilRoot>. ' + '<RecoilRoot> must be an ancestor of any component that uses ' + 'Recoil hooks.');\n  }\n\n  return mutableSource;\n}\n\nfunction notifyComponents(store, storeState, treeState) {\n  const dependentNodes = getDownstreamNodes$2(store, treeState, treeState.dirtyAtoms);\n\n  for (const key of dependentNodes) {\n    const comps = storeState.nodeToComponentSubscriptions.get(key);\n\n    if (comps) {\n      for (const [_subID, [_debugName, callback]] of comps) {\n        callback(treeState);\n      }\n    }\n  }\n}\n\nfunction sendEndOfBatchNotifications(store) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree; // Inform transaction subscribers of the transaction:\n\n  const dirtyAtoms = treeState.dirtyAtoms;\n\n  if (dirtyAtoms.size) {\n    // Execute Node-specific subscribers before global subscribers\n    for (const [key, subscriptions] of storeState.nodeTransactionSubscriptions) {\n      if (dirtyAtoms.has(key)) {\n        for (const [_, subscription] of subscriptions) {\n          subscription(store);\n        }\n      }\n    }\n\n    for (const [_, subscription] of storeState.transactionSubscriptions) {\n      subscription(store);\n    }\n\n    if (!reactMode$2().early || storeState.suspendedComponentResolvers.size > 0) {\n      // Notifying components is needed to wake from suspense, even when using\n      // early rendering.\n      notifyComponents(store, storeState, treeState); // Wake all suspended components so the right one(s) can try to re-render.\n      // We need to wake up components not just when some asynchronous selector\n      // resolved, but also when changing synchronous values because this may cause\n      // a selector to change from asynchronous to synchronous, in which case there\n      // would be no follow-up asynchronous resolution to wake us up.\n      // TODO OPTIMIZATION Only wake up related downstream components\n\n      storeState.suspendedComponentResolvers.forEach(cb => cb());\n      storeState.suspendedComponentResolvers.clear();\n    }\n  } // Special behavior ONLY invoked by useInterface.\n  // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.\n\n\n  storeState.queuedComponentCallbacks_DEPRECATED.forEach(cb => cb(treeState));\n  storeState.queuedComponentCallbacks_DEPRECATED.splice(0, storeState.queuedComponentCallbacks_DEPRECATED.length);\n}\n\nfunction endBatch(store) {\n  const storeState = store.getState();\n  storeState.commitDepth++;\n\n  try {\n    const {\n      nextTree\n    } = storeState; // Ignore commits that are not because of Recoil transactions -- namely,\n    // because something above RecoilRoot re-rendered:\n\n    if (nextTree == null) {\n      return;\n    } // nextTree is now committed -- note that copying and reset occurs when\n    // a transaction begins, in startNextTreeIfNeeded:\n\n\n    storeState.previousTree = storeState.currentTree;\n    storeState.currentTree = nextTree;\n    storeState.nextTree = null;\n    sendEndOfBatchNotifications(store);\n\n    if (storeState.previousTree != null) {\n      storeState.graphsByVersion.delete(storeState.previousTree.version);\n    } else {\n      Recoil_recoverableViolation('Ended batch with no previous state, which is unexpected', 'recoil');\n    }\n\n    storeState.previousTree = null;\n\n    if (Recoil_gkx('recoil_memory_managament_2020')) {\n      // Only release retainables if there were no writes during the end of the\n      // batch.  This avoids releasing something we might be about to use.\n      if (nextTree == null) {\n        releaseScheduledRetainablesNow$1(store);\n      }\n    }\n  } finally {\n    storeState.commitDepth--;\n  }\n}\n/*\r\n * The purpose of the Batcher is to observe when React batches end so that\r\n * Recoil state changes can be batched. Whenever Recoil state changes, we call\r\n * setState on the batcher. Then we wait for that change to be committed, which\r\n * signifies the end of the batch. That's when we respond to the Recoil change.\r\n */\n\n\nfunction Batcher({\n  setNotifyBatcherOfChange\n}) {\n  const storeRef = useStoreRef();\n  const [, setState] = useState([]);\n  setNotifyBatcherOfChange(() => setState({}));\n  useEffect(() => {\n    setNotifyBatcherOfChange(() => setState({})); // If an asynchronous selector resolves after the Batcher is unmounted,\n    // notifyBatcherOfChange will still be called. An error gets thrown whenever\n    // setState is called after a component is already unmounted, so this sets\n    // notifyBatcherOfChange to be a no-op.\n\n    return () => {\n      setNotifyBatcherOfChange(() => {});\n    };\n  }, [setNotifyBatcherOfChange]);\n  useEffect(() => {\n    // enqueueExecution runs this function immediately; it is only used to\n    // manipulate the order of useEffects during tests, since React seems to\n    // call useEffect in an unpredictable order sometimes.\n    Recoil_Queue.enqueueExecution('Batcher', () => {\n      endBatch(storeRef.current);\n    });\n  });\n  return null;\n}\n\nif (true) {\n  if (typeof window !== 'undefined' && !window.$recoilDebugStates) {\n    window.$recoilDebugStates = [];\n  }\n} // When removing this deprecated function, remove stateBySettingRecoilValue\n// which will no longer be needed.\n\n\nfunction initialStoreState_DEPRECATED(store, initializeState) {\n  const initial = makeEmptyStoreState$2();\n  initializeState({\n    set: (atom, value) => {\n      const state = initial.currentTree;\n      const writes = setNodeValue$2(store, state, atom.key, value);\n      const writtenNodes = new Set(writes.keys());\n      const nonvalidatedAtoms = state.nonvalidatedAtoms.clone();\n\n      for (const n of writtenNodes) {\n        nonvalidatedAtoms.delete(n);\n      }\n\n      initial.currentTree = { ...state,\n        dirtyAtoms: Recoil_unionSets(state.dirtyAtoms, writtenNodes),\n        atomValues: applyAtomValueWrites$1(state.atomValues, writes),\n        // NB: PLEASE un-export applyAtomValueWrites when deleting this code\n        nonvalidatedAtoms\n      };\n    },\n    setUnvalidatedAtomValues: atomValues => {\n      // FIXME replace this with a mutative loop\n      atomValues.forEach((v, k) => {\n        initial.currentTree = setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree, k, v);\n      });\n    }\n  });\n  return initial;\n} // Initialize state snapshot for <RecoilRoot> for the initializeState prop.\n// Atom effect initialization takes precedence over this prop.\n// Any atom effects will be run before initialization, but then cleaned up,\n// they are then re-run when used as part of rendering.  These semantics are\n// compatible with React StrictMode where effects may be re-run multiple times\n// but state initialization only happens once the first time.\n\n\nfunction initialStoreState(initializeState) {\n  // Initialize a snapshot and get its store\n  const snapshot = freshSnapshot$1(initializeState);\n  const storeState = snapshot.getStore_INTERNAL().getState(); // Counteract the snapshot auto-release\n\n  snapshot.retain(); // Cleanup any effects run during initialization and clear the handlers so\n  // they will re-initialize if used during rendering.  This allows atom effect\n  // initialization to take precedence over initializeState and be compatible\n  // with StrictMode semantics.\n\n  storeState.nodeCleanupFunctions.forEach(cleanup => cleanup());\n  storeState.nodeCleanupFunctions.clear();\n  return storeState;\n}\n\nlet nextID = 0;\n\nfunction RecoilRoot_INTERNAL({\n  initializeState_DEPRECATED,\n  initializeState,\n  store_INTERNAL: storeProp,\n  // For use with React \"context bridging\"\n  children\n}) {\n  // prettier-ignore\n  // @fb-only: useEffect(() => {\n  // @fb-only: if (gkx('recoil_usage_logging')) {\n  // @fb-only: try {\n  // @fb-only: RecoilUsageLogFalcoEvent.log(() => ({\n  // @fb-only: type: RecoilusagelogEvent.RECOIL_ROOT_MOUNTED,\n  // @fb-only: path: URI.getRequestURI().getPath(),\n  // @fb-only: }));\n  // @fb-only: } catch {\n  // @fb-only: recoverableViolation(\n  // @fb-only: 'Error when logging Recoil Usage event',\n  // @fb-only: 'recoil',\n  // @fb-only: );\n  // @fb-only: }\n  // @fb-only: }\n  // @fb-only: }, []);\n  let storeStateRef; // eslint-disable-line prefer-const\n\n  const getGraph = version => {\n    const graphs = storeStateRef.current.graphsByVersion;\n\n    if (graphs.has(version)) {\n      return Recoil_nullthrows(graphs.get(version));\n    }\n\n    const newGraph = graph$2();\n    graphs.set(version, newGraph);\n    return newGraph;\n  };\n\n  const subscribeToTransactions = (callback, key) => {\n    if (key == null) {\n      // Global transaction subscriptions\n      const {\n        transactionSubscriptions\n      } = storeRef.current.getState();\n      const id = nextID++;\n      transactionSubscriptions.set(id, callback);\n      return {\n        release: () => {\n          transactionSubscriptions.delete(id);\n        }\n      };\n    } else {\n      // Node-specific transaction subscriptions:\n      const {\n        nodeTransactionSubscriptions\n      } = storeRef.current.getState();\n\n      if (!nodeTransactionSubscriptions.has(key)) {\n        nodeTransactionSubscriptions.set(key, new Map());\n      }\n\n      const id = nextID++;\n      Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id, callback);\n      return {\n        release: () => {\n          const subs = nodeTransactionSubscriptions.get(key);\n\n          if (subs) {\n            subs.delete(id);\n\n            if (subs.size === 0) {\n              nodeTransactionSubscriptions.delete(key);\n            }\n          }\n        }\n      };\n    }\n  };\n\n  const addTransactionMetadata = metadata => {\n    startNextTreeIfNeeded(storeRef.current);\n\n    for (const k of Object.keys(metadata)) {\n      Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k] = metadata[k];\n    }\n  };\n\n  const replaceState = replacer => {\n    startNextTreeIfNeeded(storeRef.current); // Use replacer to get the next state:\n\n    const nextTree = Recoil_nullthrows(storeStateRef.current.nextTree);\n    let replaced;\n\n    try {\n      stateReplacerIsBeingExecuted = true;\n      replaced = replacer(nextTree);\n    } finally {\n      stateReplacerIsBeingExecuted = false;\n    }\n\n    if (replaced === nextTree) {\n      return;\n    }\n\n    if (true) {\n      if (typeof window !== 'undefined') {\n        window.$recoilDebugStates.push(replaced); // TODO this shouldn't happen here because it's not batched\n      }\n    } // Save changes to nextTree and schedule a React update:\n\n\n    storeStateRef.current.nextTree = replaced;\n\n    if (reactMode$2().early) {\n      notifyComponents(storeRef.current, storeStateRef.current, replaced);\n    }\n\n    Recoil_nullthrows(notifyBatcherOfChange.current)();\n  };\n\n  const notifyBatcherOfChange = useRef$1(null);\n  const setNotifyBatcherOfChange = useCallback(x => {\n    notifyBatcherOfChange.current = x;\n  }, [notifyBatcherOfChange]);\n  const storeRef = Recoil_useRefInitOnce(() => storeProp !== null && storeProp !== void 0 ? storeProp : {\n    storeID: getNextStoreID$2(),\n    getState: () => storeStateRef.current,\n    replaceState,\n    getGraph,\n    subscribeToTransactions,\n    addTransactionMetadata\n  });\n\n  if (storeProp != null) {\n    storeRef.current = storeProp;\n  }\n\n  storeStateRef = Recoil_useRefInitOnce(() => initializeState_DEPRECATED != null ? initialStoreState_DEPRECATED(storeRef.current, initializeState_DEPRECATED) : initializeState != null ? initialStoreState(initializeState) : makeEmptyStoreState$2());\n  const mutableSource = useMemo(() => createMutableSource$1 === null || createMutableSource$1 === void 0 ? void 0 : createMutableSource$1(storeStateRef, () => storeStateRef.current.currentTree.version), [storeStateRef]); // Cleanup when the <RecoilRoot> is unmounted\n\n  useEffect(() => {\n    // React is free to call effect cleanup handlers and effects at will, the\n    // deps array is only an optimization.  For example, React strict mode\n    // will execute each effect twice for testing.  Therefore, we need symmetry\n    // to re-initialize all known atoms after they were cleaned up.\n    const store = storeRef.current;\n\n    for (const atomKey of new Set(store.getState().knownAtoms)) {\n      initializeNode$2(store, atomKey, 'get');\n    }\n\n    return () => {\n      for (const atomKey of store.getState().knownAtoms) {\n        cleanUpNode$2(store, atomKey);\n      }\n    };\n  }, [storeRef]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AppContext.Provider, {\n    value: storeRef\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MutableSourceContext.Provider, {\n    value: mutableSource\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Batcher, {\n    setNotifyBatcherOfChange: setNotifyBatcherOfChange\n  }), children));\n}\n\nfunction RecoilRoot(props) {\n  const {\n    override,\n    ...propsExceptOverride\n  } = props;\n  const ancestorStoreRef = useStoreRef();\n\n  if (override === false && ancestorStoreRef.current !== defaultStore) {\n    // If ancestorStoreRef.current !== defaultStore, it means that this\n    // RecoilRoot is not nested within another.\n    return props.children;\n  }\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RecoilRoot_INTERNAL, propsExceptOverride);\n}\n\nfunction useRecoilStoreID() {\n  return useStoreRef().current.storeID;\n}\n\nvar Recoil_RecoilRoot = {\n  RecoilRoot,\n  useStoreRef,\n  useRecoilMutableSource,\n  useRecoilStoreID,\n  notifyComponents_FOR_TESTING: notifyComponents,\n  sendEndOfBatchNotifications_FOR_TESTING: sendEndOfBatchNotifications\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction shallowArrayEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar Recoil_shallowArrayEqual = shallowArrayEqual;\nconst {\n  useEffect: useEffect$1,\n  useRef: useRef$2\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction usePrevious(value) {\n  const ref = useRef$2();\n  useEffect$1(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\nvar Recoil_usePrevious = usePrevious;\nconst {\n  useStoreRef: useStoreRef$1\n} = Recoil_RecoilRoot;\nconst {\n  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$1\n} = Recoil_Retention;\nconst {\n  updateRetainCount: updateRetainCount$2\n} = Recoil_Retention;\nconst {\n  RetentionZone: RetentionZone$3\n} = Recoil_RetentionZone;\nconst {\n  useEffect: useEffect$2,\n  useRef: useRef$3\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\nconst {\n  isSSR: isSSR$2\n} = Recoil_Environment; // I don't see a way to avoid the any type here because we want to accept readable\n// and writable values with any type parameter, but normally with writable ones\n// RecoilState<SomeT> is not a subtype of RecoilState<mixed>.\n// flowlint-line unclear-type:off\n\nfunction useRetain(toRetain) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  } // eslint-disable-next-line fb-www/react-hooks\n\n\n  return useRetain_ACTUAL(toRetain);\n}\n\nfunction useRetain_ACTUAL(toRetain) {\n  const array = Array.isArray(toRetain) ? toRetain : [toRetain];\n  const retainables = array.map(a => a instanceof RetentionZone$3 ? a : a.key);\n  const storeRef = useStoreRef$1();\n  useEffect$2(() => {\n    if (!Recoil_gkx('recoil_memory_managament_2020')) {\n      return;\n    }\n\n    const store = storeRef.current;\n\n    if (timeoutID.current && !isSSR$2) {\n      // Already performed a temporary retain on render, simply cancel the release\n      // of that temporary retain.\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n    } else {\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, 1);\n      }\n    }\n\n    return () => {\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }; // eslint-disable-next-line fb-www/react-hooks-deps\n  }, [storeRef, ...retainables]); // We want to retain if the component suspends. This is terrible but the Suspense\n  // API affords us no better option. If we suspend and never commit after some\n  // seconds, then release. The 'actual' retain/release in the effect above\n  // cancels this.\n\n  const timeoutID = useRef$3();\n  const previousRetainables = Recoil_usePrevious(retainables);\n\n  if (!isSSR$2 && (previousRetainables === undefined || !Recoil_shallowArrayEqual(previousRetainables, retainables))) {\n    const store = storeRef.current;\n\n    for (const r of retainables) {\n      updateRetainCount$2(store, r, 1);\n    }\n\n    if (previousRetainables) {\n      for (const r of previousRetainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }\n\n    if (timeoutID.current) {\n      window.clearTimeout(timeoutID.current);\n    }\n\n    timeoutID.current = window.setTimeout(() => {\n      timeoutID.current = null;\n\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }, SUSPENSE_TIMEOUT_MS$1);\n  }\n}\n\nvar Recoil_useRetain = useRetain;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * THIS CODE HAS BEEN COMMENTED OUT INTENTIONALLY\r\n *\r\n * This technique of getting the component name is imperfect, since it both only\r\n * works in a non-minified code base, and more importantly introduces performance\r\n * problems since it relies in throwing errors which is an expensive operation.\r\n *\r\n * At some point we may want to reevaluate this technique hence why we have commented\r\n * this code out, rather than delete it all together.\r\n */\n// const {useRef} = require('react');\n// const gkx = require('recoil-shared/util/Recoil_gkx');\n// const stackTraceParser = require('recoil-shared/util/Recoil_stackTraceParser');\n\nfunction useComponentName() {\n  // const nameRef = useRef();\n  // if (__DEV__) {\n  //   if (gkx('recoil_infer_component_names')) {\n  //     if (nameRef.current === undefined) {\n  //       // There is no blessed way to determine the calling React component from\n  //       // within a hook. This hack uses the fact that hooks must start with 'use'\n  //       // and that hooks are either called by React Components or other hooks. It\n  //       // follows therefore, that to find the calling component, you simply need\n  //       // to look down the stack and find the first function which doesn't start\n  //       // with 'use'. We are only enabling this in dev for now, since once the\n  //       // codebase is minified, the naming assumptions no longer hold true.\n  //       // eslint-disable-next-line fb-www/no-new-error\n  //       const frames = stackTraceParser(new Error().stack);\n  //       for (const {methodName} of frames) {\n  //         // I observed cases where the frame was of the form 'Object.useXXX'\n  //         // hence why I'm searching for hooks following a word boundary\n  //         if (!methodName.match(/\\buse[^\\b]+$/)) {\n  //           return (nameRef.current = methodName);\n  //         }\n  //       }\n  //       nameRef.current = null;\n  //     }\n  //     return nameRef.current ?? '<unable to determine component name>';\n  //   }\n  // }\n  // @fb-only: return \"<component name only available when both in dev mode and when passing GK 'recoil_infer_component_names'>\";\n  return '<component name not available>'; // @oss-only\n}\n\nvar Recoil_useComponentName = useComponentName;\nconst {\n  batchUpdates: batchUpdates$2\n} = Recoil_Batching;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$2\n} = Recoil_Node;\nconst {\n  reactMode: reactMode$3,\n  useMutableSource: useMutableSource$1,\n  useSyncExternalStore: useSyncExternalStore$1\n} = Recoil_ReactMode;\nconst {\n  useRecoilMutableSource: useRecoilMutableSource$1,\n  useStoreRef: useStoreRef$2\n} = Recoil_RecoilRoot;\nconst {\n  isRecoilValue: isRecoilValue$2\n} = Recoil_RecoilValue$1;\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$3,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$2,\n  setRecoilValue: setRecoilValue$2,\n  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$2,\n  subscribeToRecoilValue: subscribeToRecoilValue$1\n} = Recoil_RecoilValueInterface;\nconst {\n  useCallback: useCallback$1,\n  useEffect: useEffect$3,\n  useMemo: useMemo$1,\n  useRef: useRef$4,\n  useState: useState$1\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\nconst {\n  setByAddingToSet: setByAddingToSet$2\n} = Recoil_CopyOnWrite;\n\nfunction handleLoadable(loadable, recoilValue, storeRef) {\n  // We can't just throw the promise we are waiting on to Suspense.  If the\n  // upstream dependencies change it may produce a state in which the component\n  // can render, but it would still be suspended on a Promise that may never resolve.\n  if (loadable.state === 'hasValue') {\n    return loadable.contents;\n  } else if (loadable.state === 'loading') {\n    const promise = new Promise(resolve => {\n      storeRef.current.getState().suspendedComponentResolvers.add(resolve);\n    }); // $FlowExpectedError Flow(prop-missing) for integrating with tools that inspect thrown promises @fb-only\n    // @fb-only: promise.displayName = `Recoil State: ${recoilValue.key}`;\n\n    throw promise;\n  } else if (loadable.state === 'hasError') {\n    throw loadable.contents;\n  } else {\n    throw Recoil_err(`Invalid value of loadable atom \"${recoilValue.key}\"`);\n  }\n}\n\nfunction validateRecoilValue(recoilValue, hookName) {\n  if (!isRecoilValue$2(recoilValue)) {\n    throw Recoil_err(`Invalid argument to ${hookName}: expected an atom or selector but got ${String(recoilValue)}`);\n  }\n}\n/**\r\n * Various things are broken with useRecoilInterface, particularly concurrent\r\n * mode, React strict mode, and memory management. They will not be fixed.\r\n * */\n\n\nfunction useRecoilInterface_DEPRECATED() {\n  const componentName = Recoil_useComponentName();\n  const storeRef = useStoreRef$2();\n  const [, forceUpdate] = useState$1([]);\n  const recoilValuesUsed = useRef$4(new Set());\n  recoilValuesUsed.current = new Set(); // Track the RecoilValues used just during this render\n\n  const previousSubscriptions = useRef$4(new Set());\n  const subscriptions = useRef$4(new Map());\n  const unsubscribeFrom = useCallback$1(key => {\n    const sub = subscriptions.current.get(key);\n\n    if (sub) {\n      sub.release();\n      subscriptions.current.delete(key);\n    }\n  }, [subscriptions]);\n  const updateState = useCallback$1((_state, key) => {\n    if (subscriptions.current.has(key)) {\n      forceUpdate([]);\n    }\n  }, []); // Effect to add/remove subscriptions as nodes are used\n\n  useEffect$3(() => {\n    const store = storeRef.current;\n    Recoil_differenceSets(recoilValuesUsed.current, previousSubscriptions.current).forEach(key => {\n      if (subscriptions.current.has(key)) {\n        Recoil_expectationViolation(`Double subscription to RecoilValue \"${key}\"`);\n        return;\n      }\n\n      const sub = subscribeToRecoilValue$1(store, new AbstractRecoilValue$3(key), state => updateState(state, key), componentName);\n      subscriptions.current.set(key, sub);\n      /**\r\n       * Since we're subscribing in an effect we need to update to the latest\r\n       * value of the atom since it may have changed since we rendered. We can\r\n       * go ahead and do that now, unless we're in the middle of a batch --\r\n       * in which case we should do it at the end of the batch, due to the\r\n       * following edge case: Suppose an atom is updated in another useEffect\r\n       * of this same component. Then the following sequence of events occur:\r\n       * 1. Atom is updated and subs fired (but we may not be subscribed\r\n       *    yet depending on order of effects, so we miss this) Updated value\r\n       *    is now in nextTree, but not currentTree.\r\n       * 2. This effect happens. We subscribe and update.\r\n       * 3. From the update we re-render and read currentTree, with old value.\r\n       * 4. Batcher's effect sets currentTree to nextTree.\r\n       * In this sequence we miss the update. To avoid that, add the update\r\n       * to queuedComponentCallback if a batch is in progress.\r\n       */\n      // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.\n\n      const state = store.getState();\n\n      if (state.nextTree) {\n        store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {\n          updateState(store.getState(), key);\n        });\n      } else {\n        updateState(store.getState(), key);\n      }\n    });\n    Recoil_differenceSets(previousSubscriptions.current, recoilValuesUsed.current).forEach(key => {\n      unsubscribeFrom(key);\n    });\n    previousSubscriptions.current = recoilValuesUsed.current;\n  }); // Effect to unsubscribe from all when unmounting\n\n  useEffect$3(() => {\n    const currentSubscriptions = subscriptions.current; // Restore subscriptions that were cleared due to StrictMode running this effect twice\n\n    Recoil_differenceSets(recoilValuesUsed.current, new Set(currentSubscriptions.keys())).forEach(key => {\n      const sub = subscribeToRecoilValue$1(storeRef.current, new AbstractRecoilValue$3(key), state => updateState(state, key), componentName);\n      currentSubscriptions.set(key, sub);\n    });\n    return () => currentSubscriptions.forEach((_, key) => unsubscribeFrom(key));\n  }, [componentName, storeRef, unsubscribeFrom, updateState]);\n  return useMemo$1(() => {\n    // eslint-disable-next-line no-shadow\n    function useSetRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useSetRecoilState');\n      }\n\n      return newValueOrUpdater => {\n        setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);\n      };\n    } // eslint-disable-next-line no-shadow\n\n\n    function useResetRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useResetRecoilState');\n      }\n\n      return () => setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilValueLoadable(recoilValue) {\n      var _storeState$nextTree;\n\n      if (true) {\n        validateRecoilValue(recoilValue, 'useRecoilValueLoadable');\n      }\n\n      if (!recoilValuesUsed.current.has(recoilValue.key)) {\n        recoilValuesUsed.current = setByAddingToSet$2(recoilValuesUsed.current, recoilValue.key);\n      } // TODO Restore optimization to memoize lookup\n\n\n      const storeState = storeRef.current.getState();\n      return getRecoilValueAsLoadable$2(storeRef.current, recoilValue, reactMode$3().early ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : storeState.currentTree);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilValue(recoilValue) {\n      if (true) {\n        validateRecoilValue(recoilValue, 'useRecoilValue');\n      }\n\n      const loadable = useRecoilValueLoadable(recoilValue);\n      return handleLoadable(loadable, recoilValue, storeRef);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useRecoilState');\n      }\n\n      return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilStateLoadable(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useRecoilStateLoadable');\n      }\n\n      return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];\n    }\n\n    return {\n      getRecoilValue: useRecoilValue,\n      getRecoilValueLoadable: useRecoilValueLoadable,\n      getRecoilState: useRecoilState,\n      getRecoilStateLoadable: useRecoilStateLoadable,\n      getSetRecoilState: useSetRecoilState,\n      getResetRecoilState: useResetRecoilState\n    };\n  }, [recoilValuesUsed, storeRef]);\n}\n\nconst recoilComponentGetRecoilValueCount_FOR_TESTING = {\n  current: 0\n};\n\nfunction useRecoilValueLoadable_SYNC_EXTERNAL_STORE(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const componentName = Recoil_useComponentName();\n  const getSnapshot = useCallback$1(() => {\n    var _storeState$nextTree2;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree2 = storeState.nextTree) !== null && _storeState$nextTree2 !== void 0 ? _storeState$nextTree2 : storeState.currentTree : storeState.currentTree;\n    const loadable = getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n    return {\n      loadable,\n      key: recoilValue.key\n    };\n  }, [storeRef, recoilValue]); // Memoize the state to avoid unnecessary rerenders\n\n  const memoizePreviousSnapshot = useCallback$1(getState => {\n    let prevState;\n    return () => {\n      var _prevState, _prevState2;\n\n      const nextState = getState();\n\n      if ((_prevState = prevState) !== null && _prevState !== void 0 && _prevState.loadable.is(nextState.loadable) && ((_prevState2 = prevState) === null || _prevState2 === void 0 ? void 0 : _prevState2.key) === nextState.key) {\n        return prevState;\n      }\n\n      prevState = nextState;\n      return nextState;\n    };\n  }, []);\n  const getMemoizedSnapshot = useMemo$1(() => memoizePreviousSnapshot(getSnapshot), [getSnapshot, memoizePreviousSnapshot]);\n  const subscribe = useCallback$1(notify => {\n    const store = storeRef.current;\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, notify, componentName);\n    return subscription.release;\n  }, [storeRef, recoilValue, componentName]);\n  return useSyncExternalStore$1(subscribe, getMemoizedSnapshot, // getSnapshot()\n  getMemoizedSnapshot // getServerSnapshot() for SSR support\n  ).loadable;\n}\n\nfunction useRecoilValueLoadable_MUTABLE_SOURCE(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree3;\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree3 = storeState.nextTree) !== null && _storeState$nextTree3 !== void 0 ? _storeState$nextTree3 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const getLoadableWithTesting = useCallback$1(() => {\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    return getLoadable();\n  }, [getLoadable]);\n  const componentName = Recoil_useComponentName();\n  const subscribe = useCallback$1((_storeState, notify) => {\n    const store = storeRef.current;\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, () => {\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return notify();\n      } // Only re-render if the value has changed.\n      // This will evaluate the atom/selector now as well as when the\n      // component renders, but that may help with prefetching.\n\n\n      const newLoadable = getLoadable();\n\n      if (!prevLoadableRef.current.is(newLoadable)) {\n        notify();\n      } // If the component is suspended then the effect setting prevLoadableRef\n      // will not run.  So, set the previous value here when its subscription\n      // is fired to wake it up.  We can't just rely on this, though, because\n      // this only executes when an atom/selector is dirty and the atom/selector\n      // passed to the hook can dynamically change.\n\n\n      prevLoadableRef.current = newLoadable;\n    }, componentName);\n    return subscription.release;\n  }, [storeRef, recoilValue, componentName, getLoadable]);\n  const source = useRecoilMutableSource$1();\n\n  if (source == null) {\n    throw Recoil_err('Recoil hooks must be used in components contained within a <RecoilRoot> component.');\n  }\n\n  const loadable = useMutableSource$1(source, getLoadableWithTesting, subscribe);\n  const prevLoadableRef = useRef$4(loadable);\n  useEffect$3(() => {\n    prevLoadableRef.current = loadable;\n  });\n  return loadable;\n}\n\nfunction useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const componentName = Recoil_useComponentName(); // Accessors to get the current state\n\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree4;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree4 = storeState.nextTree) !== null && _storeState$nextTree4 !== void 0 ? _storeState$nextTree4 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const getState = useCallback$1(() => ({\n    loadable: getLoadable(),\n    key: recoilValue.key\n  }), [getLoadable, recoilValue.key]); // Memoize state snapshots\n\n  const updateState = useCallback$1(prevState => {\n    const nextState = getState();\n    return prevState.loadable.is(nextState.loadable) && prevState.key === nextState.key ? prevState : nextState;\n  }, [getState]); // Subscribe to Recoil state changes\n\n  useEffect$3(() => {\n    const subscription = subscribeToRecoilValue$1(storeRef.current, recoilValue, _state => {\n      setState(updateState);\n    }, componentName); // Update state in case we are using a different key\n\n    setState(updateState);\n    return subscription.release;\n  }, [componentName, recoilValue, storeRef, updateState]); // Get the current state\n\n  const [state, setState] = useState$1(getState); // If we changed keys, then return the state for the new key.\n  // This is important in case the old key would cause the component to suspend.\n  // We don't have to set the new state here since the subscribing effect above\n  // will do that.\n\n  return state.key !== recoilValue.key ? getState().loadable : state.loadable;\n}\n\nfunction useRecoilValueLoadable_LEGACY(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const [, forceUpdate] = useState$1([]);\n  const componentName = Recoil_useComponentName();\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree5;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree5 = storeState.nextTree) !== null && _storeState$nextTree5 !== void 0 ? _storeState$nextTree5 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const loadable = getLoadable();\n  const prevLoadableRef = useRef$4(loadable);\n  useEffect$3(() => {\n    prevLoadableRef.current = loadable;\n  });\n  useEffect$3(() => {\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, _state => {\n      var _prevLoadableRef$curr;\n\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return forceUpdate([]);\n      }\n\n      const newLoadable = getLoadable();\n\n      if (!((_prevLoadableRef$curr = prevLoadableRef.current) !== null && _prevLoadableRef$curr !== void 0 && _prevLoadableRef$curr.is(newLoadable))) {\n        forceUpdate(newLoadable);\n      }\n\n      prevLoadableRef.current = newLoadable;\n    }, componentName);\n    /**\r\n     * Since we're subscribing in an effect we need to update to the latest\r\n     * value of the atom since it may have changed since we rendered. We can\r\n     * go ahead and do that now, unless we're in the middle of a batch --\r\n     * in which case we should do it at the end of the batch, due to the\r\n     * following edge case: Suppose an atom is updated in another useEffect\r\n     * of this same component. Then the following sequence of events occur:\r\n     * 1. Atom is updated and subs fired (but we may not be subscribed\r\n     *    yet depending on order of effects, so we miss this) Updated value\r\n     *    is now in nextTree, but not currentTree.\r\n     * 2. This effect happens. We subscribe and update.\r\n     * 3. From the update we re-render and read currentTree, with old value.\r\n     * 4. Batcher's effect sets currentTree to nextTree.\r\n     * In this sequence we miss the update. To avoid that, add the update\r\n     * to queuedComponentCallback if a batch is in progress.\r\n     */\n\n    if (storeState.nextTree) {\n      store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {\n        prevLoadableRef.current = null;\n        forceUpdate([]);\n      });\n    } else {\n      var _prevLoadableRef$curr2;\n\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return forceUpdate([]);\n      }\n\n      const newLoadable = getLoadable();\n\n      if (!((_prevLoadableRef$curr2 = prevLoadableRef.current) !== null && _prevLoadableRef$curr2 !== void 0 && _prevLoadableRef$curr2.is(newLoadable))) {\n        forceUpdate(newLoadable);\n      }\n\n      prevLoadableRef.current = newLoadable;\n    }\n\n    return subscription.release;\n  }, [componentName, getLoadable, recoilValue, storeRef]);\n  return loadable;\n}\n/**\r\n  Like useRecoilValue(), but either returns the value if available or\r\n  just undefined if not available for any reason, such as pending or error.\r\n*/\n\n\nfunction useRecoilValueLoadable(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValueLoadable');\n  }\n\n  if (Recoil_gkx('recoil_memory_managament_2020')) {\n    // eslint-disable-next-line fb-www/react-hooks\n    Recoil_useRetain(recoilValue);\n  }\n\n  return {\n    TRANSITION_SUPPORT: useRecoilValueLoadable_TRANSITION_SUPPORT,\n    SYNC_EXTERNAL_STORE: useRecoilValueLoadable_SYNC_EXTERNAL_STORE,\n    MUTABLE_SOURCE: useRecoilValueLoadable_MUTABLE_SOURCE,\n    LEGACY: useRecoilValueLoadable_LEGACY\n  }[reactMode$3().mode](recoilValue);\n}\n/**\r\n  Returns the value represented by the RecoilValue.\r\n  If the value is pending, it will throw a Promise to suspend the component,\r\n  if the value is an error it will throw it for the nearest React error boundary.\r\n  This will also subscribe the component for any updates in the value.\r\n  */\n\n\nfunction useRecoilValue(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValue');\n  }\n\n  const storeRef = useStoreRef$2();\n  const loadable = useRecoilValueLoadable(recoilValue);\n  return handleLoadable(loadable, recoilValue, storeRef);\n}\n/**\r\n  Returns a function that allows the value of a RecoilState to be updated, but does\r\n  not subscribe the component to changes to that RecoilState.\r\n*/\n\n\nfunction useSetRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useSetRecoilState');\n  }\n\n  const storeRef = useStoreRef$2();\n  return useCallback$1(newValueOrUpdater => {\n    setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);\n  }, [storeRef, recoilState]);\n}\n/**\r\n  Returns a function that will reset the value of a RecoilState to its default\r\n*/\n\n\nfunction useResetRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useResetRecoilState');\n  }\n\n  const storeRef = useStoreRef$2();\n  return useCallback$1(() => {\n    setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n  }, [storeRef, recoilState]);\n}\n/**\r\n  Equivalent to useState(). Allows the value of the RecoilState to be read and written.\r\n  Subsequent updates to the RecoilState will cause the component to re-render. If the\r\n  RecoilState is pending, this will suspend the component and initiate the\r\n  retrieval of the value. If evaluating the RecoilState resulted in an error, this will\r\n  throw the error so that the nearest React error boundary can catch it.\r\n*/\n\n\nfunction useRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilState');\n  }\n\n  return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];\n}\n/**\r\n  Like useRecoilState(), but does not cause Suspense or React error handling. Returns\r\n  an object that indicates whether the RecoilState is available, pending, or\r\n  unavailable due to an error.\r\n*/\n\n\nfunction useRecoilStateLoadable(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilStateLoadable');\n  }\n\n  return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];\n}\n\nfunction useSetUnvalidatedAtomValues() {\n  const storeRef = useStoreRef$2();\n  return (values, transactionMetadata = {}) => {\n    batchUpdates$2(() => {\n      storeRef.current.addTransactionMetadata(transactionMetadata);\n      values.forEach((value, key) => setUnvalidatedRecoilValue$2(storeRef.current, new AbstractRecoilValue$3(key), value));\n    });\n  };\n}\n/**\r\n * Experimental variants of hooks with support for useTransition()\r\n */\n\n\nfunction useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE');\n\n    if (!reactMode$3().early) {\n      Recoil_recoverableViolation('Attepmt to use a hook with UNSTABLE_TRANSITION_SUPPORT in a rendering mode incompatible with concurrent rendering.  Try enabling the recoil_sync_external_store or recoil_transition_support GKs.');\n    }\n  }\n\n  if (Recoil_gkx('recoil_memory_managament_2020')) {\n    // eslint-disable-next-line fb-www/react-hooks\n    Recoil_useRetain(recoilValue);\n  }\n\n  return useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue);\n}\n\nfunction useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValue_TRANSITION_SUPPORT_UNSTABLE');\n  }\n\n  const storeRef = useStoreRef$2();\n  const loadable = useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue);\n  return handleLoadable(loadable, recoilValue, storeRef);\n}\n\nfunction useRecoilState_TRANSITION_SUPPORT_UNSTABLE(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilState_TRANSITION_SUPPORT_UNSTABLE');\n  }\n\n  return [useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilState), useSetRecoilState(recoilState)];\n}\n\nvar Recoil_Hooks = {\n  recoilComponentGetRecoilValueCount_FOR_TESTING,\n  useRecoilInterface: useRecoilInterface_DEPRECATED,\n  useRecoilState,\n  useRecoilStateLoadable,\n  useRecoilValue,\n  useRecoilValueLoadable,\n  useResetRecoilState,\n  useSetRecoilState,\n  useSetUnvalidatedAtomValues,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE\n};\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Returns a map containing all of the keys + values from the original map where\r\n * the given callback returned true.\r\n */\n\nfunction filterMap(map, callback) {\n  const result = new Map();\n\n  for (const [key, value] of map) {\n    if (callback(value, key)) {\n      result.set(key, value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_filterMap = filterMap;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\n/**\r\n * Returns a set containing all of the values from the original set where\r\n * the given callback returned true.\r\n */\n\nfunction filterSet(set, callback) {\n  const result = new Set();\n\n  for (const value of set) {\n    if (callback(value)) {\n      result.add(value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_filterSet = filterSet;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction mergeMaps(...maps) {\n  const result = new Map();\n\n  for (let i = 0; i < maps.length; i++) {\n    const iterator = maps[i].keys();\n    let nextKey;\n\n    while (!(nextKey = iterator.next()).done) {\n      // $FlowIssue[incompatible-call] - map/iterator knows nothing about flow types\n      result.set(nextKey.value, maps[i].get(nextKey.value));\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_mergeMaps = mergeMaps;\nconst {\n  batchUpdates: batchUpdates$3\n} = Recoil_Batching;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$3,\n  getNode: getNode$4,\n  nodes: nodes$1\n} = Recoil_Node;\nconst {\n  useStoreRef: useStoreRef$3\n} = Recoil_RecoilRoot;\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$4,\n  setRecoilValueLoadable: setRecoilValueLoadable$1\n} = Recoil_RecoilValueInterface;\nconst {\n  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$2\n} = Recoil_Retention;\nconst {\n  cloneSnapshot: cloneSnapshot$1\n} = Recoil_Snapshot$1;\nconst {\n  useCallback: useCallback$2,\n  useEffect: useEffect$4,\n  useRef: useRef$5,\n  useState: useState$2\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\nconst {\n  isSSR: isSSR$3\n} = Recoil_Environment;\n\nfunction useTransactionSubscription(callback) {\n  const storeRef = useStoreRef$3();\n  useEffect$4(() => {\n    const sub = storeRef.current.subscribeToTransactions(callback);\n    return sub.release;\n  }, [callback, storeRef]);\n}\n\nfunction externallyVisibleAtomValuesInState(state) {\n  const atomValues = state.atomValues.toMap();\n  const persistedAtomContentsValues = Recoil_mapMap(Recoil_filterMap(atomValues, (v, k) => {\n    const node = getNode$4(k);\n    const persistence = node.persistence_UNSTABLE;\n    return persistence != null && persistence.type !== 'none' && v.state === 'hasValue';\n  }), v => v.contents); // Merge in nonvalidated atoms; we may not have defs for them but they will\n  // all have persistence on or they wouldn't be there in the first place.\n\n  return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(), persistedAtomContentsValues);\n}\n/**\r\n  Calls the given callback after any atoms have been modified and the consequent\r\n  component re-renders have been committed. This is intended for persisting\r\n  the values of the atoms to storage. The stored values can then be restored\r\n  using the useSetUnvalidatedAtomValues hook.\r\n\r\n  The callback receives the following info:\r\n\r\n  atomValues: The current value of every atom that is both persistable (persistence\r\n              type not set to 'none') and whose value is available (not in an\r\n              error or loading state).\r\n\r\n  previousAtomValues: The value of every persistable and available atom before\r\n               the transaction began.\r\n\r\n  atomInfo: A map containing the persistence settings for each atom. Every key\r\n            that exists in atomValues will also exist in atomInfo.\r\n\r\n  modifiedAtoms: The set of atoms that were written to during the transaction.\r\n\r\n  transactionMetadata: Arbitrary information that was added via the\r\n          useSetUnvalidatedAtomValues hook. Useful for ignoring the useSetUnvalidatedAtomValues\r\n          transaction, to avoid loops.\r\n*/\n\n\nfunction useTransactionObservation_DEPRECATED(callback) {\n  useTransactionSubscription(useCallback$2(store => {\n    let previousTree = store.getState().previousTree;\n    const currentTree = store.getState().currentTree;\n\n    if (!previousTree) {\n      Recoil_recoverableViolation('Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil');\n      previousTree = store.getState().currentTree; // attempt to trundle on\n    }\n\n    const atomValues = externallyVisibleAtomValuesInState(currentTree);\n    const previousAtomValues = externallyVisibleAtomValuesInState(previousTree);\n    const atomInfo = Recoil_mapMap(nodes$1, node => {\n      var _node$persistence_UNS, _node$persistence_UNS2, _node$persistence_UNS3, _node$persistence_UNS4;\n\n      return {\n        persistence_UNSTABLE: {\n          type: (_node$persistence_UNS = (_node$persistence_UNS2 = node.persistence_UNSTABLE) === null || _node$persistence_UNS2 === void 0 ? void 0 : _node$persistence_UNS2.type) !== null && _node$persistence_UNS !== void 0 ? _node$persistence_UNS : 'none',\n          backButton: (_node$persistence_UNS3 = (_node$persistence_UNS4 = node.persistence_UNSTABLE) === null || _node$persistence_UNS4 === void 0 ? void 0 : _node$persistence_UNS4.backButton) !== null && _node$persistence_UNS3 !== void 0 ? _node$persistence_UNS3 : false\n        }\n      };\n    }); // Filter on existance in atomValues so that externally-visible rules\n    // are also applied to modified atoms (specifically exclude selectors):\n\n    const modifiedAtoms = Recoil_filterSet(currentTree.dirtyAtoms, k => atomValues.has(k) || previousAtomValues.has(k));\n    callback({\n      atomValues,\n      previousAtomValues,\n      atomInfo,\n      modifiedAtoms,\n      transactionMetadata: { ...currentTree.transactionMetadata\n      }\n    });\n  }, [callback]));\n}\n\nfunction useRecoilTransactionObserver(callback) {\n  useTransactionSubscription(useCallback$2(store => {\n    const snapshot = cloneSnapshot$1(store, 'latest');\n    const previousSnapshot = cloneSnapshot$1(store, 'previous');\n    callback({\n      snapshot,\n      previousSnapshot\n    });\n  }, [callback]));\n} // Return a snapshot of the current state and subscribe to all state changes\n\n\nfunction useRecoilSnapshot() {\n  const storeRef = useStoreRef$3();\n  const [snapshot, setSnapshot] = useState$2(() => cloneSnapshot$1(storeRef.current));\n  const previousSnapshot = Recoil_usePrevious(snapshot);\n  const timeoutID = useRef$5();\n  const releaseRef = useRef$5();\n  useTransactionSubscription(useCallback$2(store => setSnapshot(cloneSnapshot$1(store)), [])); // Retain snapshot for duration component is mounted\n\n  useEffect$4(() => {\n    const release = snapshot.retain(); // Release the retain from the rendering call\n\n    if (timeoutID.current && !isSSR$3) {\n      var _releaseRef$current;\n\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n      (_releaseRef$current = releaseRef.current) === null || _releaseRef$current === void 0 ? void 0 : _releaseRef$current.call(releaseRef);\n      releaseRef.current = null;\n    }\n\n    return () => {\n      // Defer the release.  If \"Fast Refresh\"\" is used then the component may\n      // re-render with the same state.  The previous cleanup will then run and\n      // then the new effect will run. We don't want the snapshot to be released\n      // by that cleanup before the new effect has a chance to retain it again.\n      // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936\n      window.setTimeout(release, 10);\n    };\n  }, [snapshot]); // Retain snapshot until above effect is run.\n  // Release after a threshold in case component is suspended.\n\n  if (previousSnapshot !== snapshot && !isSSR$3) {\n    // Release the previous snapshot\n    if (timeoutID.current) {\n      var _releaseRef$current2;\n\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n      (_releaseRef$current2 = releaseRef.current) === null || _releaseRef$current2 === void 0 ? void 0 : _releaseRef$current2.call(releaseRef);\n      releaseRef.current = null;\n    }\n\n    releaseRef.current = snapshot.retain();\n    timeoutID.current = window.setTimeout(() => {\n      var _releaseRef$current3;\n\n      timeoutID.current = null;\n      (_releaseRef$current3 = releaseRef.current) === null || _releaseRef$current3 === void 0 ? void 0 : _releaseRef$current3.call(releaseRef);\n      releaseRef.current = null;\n    }, SUSPENSE_TIMEOUT_MS$2);\n  }\n\n  return snapshot;\n}\n\nfunction gotoSnapshot(store, snapshot) {\n  var _storeState$nextTree;\n\n  const storeState = store.getState();\n  const prev = (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree;\n  const next = snapshot.getStore_INTERNAL().getState().currentTree;\n  batchUpdates$3(() => {\n    const keysToUpdate = new Set();\n\n    for (const keys of [prev.atomValues.keys(), next.atomValues.keys()]) {\n      for (const key of keys) {\n        var _prev$atomValues$get, _next$atomValues$get;\n\n        if (((_prev$atomValues$get = prev.atomValues.get(key)) === null || _prev$atomValues$get === void 0 ? void 0 : _prev$atomValues$get.contents) !== ((_next$atomValues$get = next.atomValues.get(key)) === null || _next$atomValues$get === void 0 ? void 0 : _next$atomValues$get.contents) && getNode$4(key).shouldRestoreFromSnapshots) {\n          keysToUpdate.add(key);\n        }\n      }\n    }\n\n    keysToUpdate.forEach(key => {\n      setRecoilValueLoadable$1(store, new AbstractRecoilValue$4(key), next.atomValues.has(key) ? Recoil_nullthrows(next.atomValues.get(key)) : DEFAULT_VALUE$3);\n    });\n    store.replaceState(state => ({ ...state,\n      stateID: snapshot.getID()\n    }));\n  });\n}\n\nfunction useGotoRecoilSnapshot() {\n  const storeRef = useStoreRef$3();\n  return useCallback$2(snapshot => gotoSnapshot(storeRef.current, snapshot), [storeRef]);\n}\n\nvar Recoil_SnapshotHooks = {\n  useRecoilSnapshot,\n  gotoSnapshot,\n  useGotoRecoilSnapshot,\n  useRecoilTransactionObserver,\n  useTransactionObservation_DEPRECATED,\n  useTransactionSubscription_DEPRECATED: useTransactionSubscription\n};\nconst {\n  peekNodeInfo: peekNodeInfo$2\n} = Recoil_FunctionalCore;\nconst {\n  useStoreRef: useStoreRef$4\n} = Recoil_RecoilRoot;\n\nfunction useGetRecoilValueInfo() {\n  const storeRef = useStoreRef$4();\n  return ({\n    key\n  }) => peekNodeInfo$2(storeRef.current, storeRef.current.getState().currentTree, key);\n}\n\nvar Recoil_useGetRecoilValueInfo = useGetRecoilValueInfo;\nconst {\n  reactMode: reactMode$4\n} = Recoil_ReactMode;\nconst {\n  RecoilRoot: RecoilRoot$1,\n  useStoreRef: useStoreRef$5\n} = Recoil_RecoilRoot;\nconst {\n  useMemo: useMemo$2\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction useRecoilBridgeAcrossReactRoots() {\n  // The test fails when using useMutableSource(), but only if act() is used\n  // for the nested root.  So, this may only be a testing environment issue.\n  if (reactMode$4().mode === 'MUTABLE_SOURCE') {\n    // eslint-disable-next-line fb-www/no-console\n    console.warn('Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.');\n  }\n\n  const store = useStoreRef$5().current;\n  return useMemo$2(() => {\n    // eslint-disable-next-line no-shadow\n    function RecoilBridge({\n      children\n    }) {\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RecoilRoot$1, {\n        store_INTERNAL: store\n      }, children);\n    }\n\n    return RecoilBridge;\n  }, [store]);\n}\n\nvar Recoil_useRecoilBridgeAcrossReactRoots = useRecoilBridgeAcrossReactRoots;\nconst {\n  loadableWithValue: loadableWithValue$1\n} = Recoil_Loadable$1;\nconst {\n  initializeNode: initializeNode$3\n} = Recoil_FunctionalCore;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$4,\n  getNode: getNode$5\n} = Recoil_Node;\nconst {\n  copyTreeState: copyTreeState$1,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$3,\n  invalidateDownstreams: invalidateDownstreams$1,\n  writeLoadableToTreeState: writeLoadableToTreeState$1\n} = Recoil_RecoilValueInterface;\n\nfunction isAtom(recoilValue) {\n  return getNode$5(recoilValue.key).nodeType === 'atom';\n}\n\nclass TransactionInterfaceImpl {\n  constructor(store, treeState) {\n    _defineProperty(this, \"_store\", void 0);\n\n    _defineProperty(this, \"_treeState\", void 0);\n\n    _defineProperty(this, \"_changes\", void 0);\n\n    _defineProperty(this, \"get\", recoilValue => {\n      if (this._changes.has(recoilValue.key)) {\n        // $FlowIssue[incompatible-return]\n        return this._changes.get(recoilValue.key);\n      }\n\n      if (!isAtom(recoilValue)) {\n        throw Recoil_err('Reading selectors within atomicUpdate is not supported');\n      }\n\n      const loadable = getRecoilValueAsLoadable$3(this._store, recoilValue, this._treeState);\n\n      if (loadable.state === 'hasValue') {\n        return loadable.contents;\n      } else if (loadable.state === 'hasError') {\n        throw loadable.contents;\n      } else {\n        throw Recoil_err(`Expected Recoil atom ${recoilValue.key} to have a value, but it is in a loading state.`);\n      }\n    });\n\n    _defineProperty(this, \"set\", (recoilState, valueOrUpdater) => {\n      if (!isAtom(recoilState)) {\n        throw Recoil_err('Setting selectors within atomicUpdate is not supported');\n      }\n\n      if (typeof valueOrUpdater === 'function') {\n        const current = this.get(recoilState);\n\n        this._changes.set(recoilState.key, valueOrUpdater(current)); // flowlint-line unclear-type:off\n\n      } else {\n        // Initialize atom and run effects if not initialized yet\n        initializeNode$3(this._store, recoilState.key, 'set');\n\n        this._changes.set(recoilState.key, valueOrUpdater);\n      }\n    });\n\n    _defineProperty(this, \"reset\", recoilState => {\n      this.set(recoilState, DEFAULT_VALUE$4);\n    });\n\n    this._store = store;\n    this._treeState = treeState;\n    this._changes = new Map();\n  } // Allow destructing\n  // eslint-disable-next-line fb-www/extra-arrow-initializer\n\n\n  newTreeState_INTERNAL() {\n    if (this._changes.size === 0) {\n      return this._treeState;\n    }\n\n    const newState = copyTreeState$1(this._treeState);\n\n    for (const [k, v] of this._changes) {\n      writeLoadableToTreeState$1(newState, k, loadableWithValue$1(v));\n    }\n\n    invalidateDownstreams$1(this._store, newState);\n    return newState;\n  }\n\n}\n\nfunction atomicUpdater(store) {\n  return fn => {\n    store.replaceState(treeState => {\n      const changeset = new TransactionInterfaceImpl(store, treeState);\n      fn(changeset);\n      return changeset.newTreeState_INTERNAL();\n    });\n  };\n}\n\nvar Recoil_AtomicUpdates = {\n  atomicUpdater\n};\nvar Recoil_AtomicUpdates_1 = Recoil_AtomicUpdates.atomicUpdater;\nvar Recoil_AtomicUpdates$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  atomicUpdater: Recoil_AtomicUpdates_1\n});\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nvar invariant_1 = invariant; // @oss-only\n\nvar Recoil_invariant = invariant_1;\nconst {\n  atomicUpdater: atomicUpdater$1\n} = Recoil_AtomicUpdates$1;\nconst {\n  batchUpdates: batchUpdates$4\n} = Recoil_Batching;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$5\n} = Recoil_Node;\nconst {\n  useStoreRef: useStoreRef$6\n} = Recoil_RecoilRoot;\nconst {\n  refreshRecoilValue: refreshRecoilValue$1,\n  setRecoilValue: setRecoilValue$3\n} = Recoil_RecoilValueInterface;\nconst {\n  cloneSnapshot: cloneSnapshot$2\n} = Recoil_Snapshot$1;\nconst {\n  gotoSnapshot: gotoSnapshot$1\n} = Recoil_SnapshotHooks;\nconst {\n  useCallback: useCallback$3\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nclass Sentinel {}\n\nconst SENTINEL = new Sentinel();\n\nfunction recoilCallback(store, fn, args, extraInterface) {\n  let ret = SENTINEL;\n  let releaseSnapshot;\n  batchUpdates$4(() => {\n    const errMsg = 'useRecoilCallback() expects a function that returns a function: ' + 'it accepts a function of the type (RecoilInterface) => (Args) => ReturnType ' + 'and returns a callback function (Args) => ReturnType, where RecoilInterface is ' + 'an object {snapshot, set, ...} and Args and ReturnType are the argument and return ' + 'types of the callback you want to create.  Please see the docs ' + 'at recoiljs.org for details.';\n\n    if (typeof fn !== 'function') {\n      throw Recoil_err(errMsg);\n    } // Clone the snapshot lazily to avoid overhead if the callback does not use it.\n    // Note that this means the snapshot may represent later state from when\n    // the callback was called if it first accesses the snapshot asynchronously.\n\n\n    const callbackInterface = Recoil_lazyProxy({ ...(extraInterface !== null && extraInterface !== void 0 ? extraInterface : {}),\n      // flowlint-line unclear-type:off\n      set: (node, newValue) => setRecoilValue$3(store, node, newValue),\n      reset: node => setRecoilValue$3(store, node, DEFAULT_VALUE$5),\n      refresh: node => refreshRecoilValue$1(store, node),\n      gotoSnapshot: snapshot => gotoSnapshot$1(store, snapshot),\n      transact_UNSTABLE: transaction => atomicUpdater$1(store)(transaction)\n    }, {\n      snapshot: () => {\n        const snapshot = cloneSnapshot$2(store);\n        releaseSnapshot = snapshot.retain();\n        return snapshot;\n      }\n    });\n    const callback = fn(callbackInterface);\n\n    if (typeof callback !== 'function') {\n      throw Recoil_err(errMsg);\n    }\n\n    ret = callback(...args);\n  });\n  !!(ret instanceof Sentinel) ?  true ? Recoil_invariant(false, 'batchUpdates should return immediately') : 0 : void 0;\n\n  if (Recoil_isPromise(ret)) {\n    ret.finally(() => {\n      var _releaseSnapshot;\n\n      (_releaseSnapshot = releaseSnapshot) === null || _releaseSnapshot === void 0 ? void 0 : _releaseSnapshot();\n    });\n  } else {\n    var _releaseSnapshot2;\n\n    (_releaseSnapshot2 = releaseSnapshot) === null || _releaseSnapshot2 === void 0 ? void 0 : _releaseSnapshot2();\n  } // $FlowFixMe[incompatible-cast]\n\n\n  return ret;\n}\n\nfunction useRecoilCallback(fn, deps) {\n  const storeRef = useStoreRef$6();\n  return useCallback$3( // $FlowIssue[incompatible-call]\n  (...args) => {\n    return recoilCallback(storeRef.current, fn, args);\n  }, deps != null ? [...deps, storeRef] : undefined // eslint-disable-line fb-www/react-hooks-deps\n  );\n}\n\nvar Recoil_useRecoilCallback = {\n  recoilCallback,\n  useRecoilCallback\n};\nconst {\n  useStoreRef: useStoreRef$7\n} = Recoil_RecoilRoot;\nconst {\n  refreshRecoilValue: refreshRecoilValue$2\n} = Recoil_RecoilValueInterface;\nconst {\n  useCallback: useCallback$4\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction useRecoilRefresher(recoilValue) {\n  const storeRef = useStoreRef$7();\n  return useCallback$4(() => {\n    const store = storeRef.current;\n    refreshRecoilValue$2(store, recoilValue);\n  }, [recoilValue, storeRef]);\n}\n\nvar Recoil_useRecoilRefresher = useRecoilRefresher;\nconst {\n  atomicUpdater: atomicUpdater$2\n} = Recoil_AtomicUpdates$1;\nconst {\n  useStoreRef: useStoreRef$8\n} = Recoil_RecoilRoot;\nconst {\n  useMemo: useMemo$3\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction useRecoilTransaction(fn, deps) {\n  const storeRef = useStoreRef$8();\n  return useMemo$3(() => (...args) => {\n    const atomicUpdate = atomicUpdater$2(storeRef.current);\n    atomicUpdate(transactionInterface => {\n      fn(transactionInterface)(...args);\n    });\n  }, deps != null ? [...deps, storeRef] : undefined // eslint-disable-line fb-www/react-hooks-deps\n  );\n}\n\nvar Recoil_useRecoilTransaction = useRecoilTransaction;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nclass WrappedValue {\n  constructor(value) {\n    _defineProperty(this, \"value\", void 0);\n\n    this.value = value;\n  }\n\n}\n\nvar Recoil_Wrapper = {\n  WrappedValue\n};\nvar Recoil_Wrapper_1 = Recoil_Wrapper.WrappedValue;\nvar Recoil_Wrapper$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  WrappedValue: Recoil_Wrapper_1\n});\nconst {\n  isFastRefreshEnabled: isFastRefreshEnabled$2\n} = Recoil_ReactMode;\n\nclass ChangedPathError extends Error {}\n\nclass TreeCache {\n  // $FlowIssue[unclear-type]\n  constructor(options) {\n    var _options$onHit, _options$onSet, _options$mapNodeValue;\n\n    _defineProperty(this, \"_name\", void 0);\n\n    _defineProperty(this, \"_numLeafs\", void 0);\n\n    _defineProperty(this, \"_root\", void 0);\n\n    _defineProperty(this, \"_onHit\", void 0);\n\n    _defineProperty(this, \"_onSet\", void 0);\n\n    _defineProperty(this, \"_mapNodeValue\", void 0);\n\n    this._name = options === null || options === void 0 ? void 0 : options.name;\n    this._numLeafs = 0;\n    this._root = null;\n    this._onHit = (_options$onHit = options === null || options === void 0 ? void 0 : options.onHit) !== null && _options$onHit !== void 0 ? _options$onHit : () => {};\n    this._onSet = (_options$onSet = options === null || options === void 0 ? void 0 : options.onSet) !== null && _options$onSet !== void 0 ? _options$onSet : () => {};\n    this._mapNodeValue = (_options$mapNodeValue = options === null || options === void 0 ? void 0 : options.mapNodeValue) !== null && _options$mapNodeValue !== void 0 ? _options$mapNodeValue : val => val;\n  }\n\n  size() {\n    return this._numLeafs;\n  } // $FlowIssue[unclear-type]\n\n\n  root() {\n    return this._root;\n  }\n\n  get(getNodeValue, handlers) {\n    var _this$getLeafNode;\n\n    return (_this$getLeafNode = this.getLeafNode(getNodeValue, handlers)) === null || _this$getLeafNode === void 0 ? void 0 : _this$getLeafNode.value;\n  }\n\n  getLeafNode(getNodeValue, handlers) {\n    if (this._root == null) {\n      return undefined;\n    } // Iterate down the tree based on the current node values until we hit a leaf\n    // $FlowIssue[unclear-type]\n\n\n    let node = this._root;\n\n    while (node) {\n      handlers === null || handlers === void 0 ? void 0 : handlers.onNodeVisit(node);\n\n      if (node.type === 'leaf') {\n        this._onHit(node);\n\n        return node;\n      }\n\n      const nodeValue = this._mapNodeValue(getNodeValue(node.nodeKey));\n\n      node = node.branches.get(nodeValue);\n    }\n\n    return undefined;\n  }\n\n  set(route, value, handlers) {\n    const addLeaf = () => {\n      var _node2, _node3, _this$_root2, _handlers$onNodeVisit2; // First, setup the branch nodes for the route:\n      // Iterate down the tree to find or add branch nodes following the route\n\n\n      let node;\n      let branchKey;\n\n      for (const [nodeKey, nodeValue] of route) {\n        var _node, _handlers$onNodeVisit, _this$_root; // If the previous root was a leaf, while we not have a get(), it means\n        // the selector has inconsistent values or implementation changed.\n\n\n        const root = this._root;\n\n        if ((root === null || root === void 0 ? void 0 : root.type) === 'leaf') {\n          throw this.invalidCacheError();\n        } // node now refers to the next node down in the tree\n\n\n        const parent = node; // $FlowFixMe[prop-missing]\n        // $FlowFixMe[incompatible-type]\n\n        node = parent ? parent.branches.get(branchKey) : root; // $FlowFixMe[prop-missing]\n        // $FlowFixMe[incompatible-type]\n\n        node = (_node = node) !== null && _node !== void 0 ? _node : {\n          type: 'branch',\n          nodeKey,\n          parent,\n          branches: new Map(),\n          branchKey\n        }; // If we found an existing node, confirm it has a consistent value\n\n        if (node.type !== 'branch' || node.nodeKey !== nodeKey) {\n          throw this.invalidCacheError();\n        } // Add the branch node to the tree\n\n\n        parent === null || parent === void 0 ? void 0 : parent.branches.set(branchKey, node);\n        handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit = handlers.onNodeVisit) === null || _handlers$onNodeVisit === void 0 ? void 0 : _handlers$onNodeVisit.call(handlers, node); // Prepare for next iteration and install root if it is new.\n\n        branchKey = this._mapNodeValue(nodeValue);\n        this._root = (_this$_root = this._root) !== null && _this$_root !== void 0 ? _this$_root : node;\n      } // Second, setup the leaf node:\n      // If there is an existing leaf for this route confirm it is consistent\n\n\n      const oldLeaf = node ? (_node2 = node) === null || _node2 === void 0 ? void 0 : _node2.branches.get(branchKey) : this._root;\n\n      if (oldLeaf != null && (oldLeaf.type !== 'leaf' || oldLeaf.branchKey !== branchKey)) {\n        throw this.invalidCacheError();\n      } // Create a new or replacement leaf.\n\n\n      const leafNode = {\n        type: 'leaf',\n        value,\n        parent: node,\n        branchKey\n      }; // Install the leaf and call handlers\n\n      (_node3 = node) === null || _node3 === void 0 ? void 0 : _node3.branches.set(branchKey, leafNode);\n      this._root = (_this$_root2 = this._root) !== null && _this$_root2 !== void 0 ? _this$_root2 : leafNode;\n      this._numLeafs++;\n\n      this._onSet(leafNode);\n\n      handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit2 = handlers.onNodeVisit) === null || _handlers$onNodeVisit2 === void 0 ? void 0 : _handlers$onNodeVisit2.call(handlers, leafNode);\n    };\n\n    try {\n      addLeaf();\n    } catch (error) {\n      // If the cache was stale or observed inconsistent values, such as with\n      // Fast Refresh, then clear it and rebuild with the new values.\n      if (error instanceof ChangedPathError) {\n        this.clear();\n        addLeaf();\n      } else {\n        throw error;\n      }\n    }\n  } // Returns true if leaf was actually deleted from the tree\n\n\n  delete(leaf) {\n    const root = this.root();\n\n    if (!root) {\n      return false;\n    }\n\n    if (leaf === root) {\n      this._root = null;\n      this._numLeafs = 0;\n      return true;\n    } // Iterate up from the leaf deleteing it from it's parent's branches.\n\n\n    let node = leaf.parent;\n    let branchKey = leaf.branchKey;\n\n    while (node) {\n      var _node4;\n\n      node.branches.delete(branchKey); // Stop iterating if we hit the root.\n\n      if (node === root) {\n        if (node.branches.size === 0) {\n          this._root = null;\n          this._numLeafs = 0;\n        } else {\n          this._numLeafs--;\n        }\n\n        return true;\n      } // Stop iterating if there are other branches since we don't need to\n      // remove any more nodes.\n\n\n      if (node.branches.size > 0) {\n        break;\n      } // Iterate up to our parent\n\n\n      branchKey = (_node4 = node) === null || _node4 === void 0 ? void 0 : _node4.branchKey;\n      node = node.parent;\n    } // Confirm that the leaf we are deleting is actually attached to our tree\n\n\n    for (; node !== root; node = node.parent) {\n      if (node == null) {\n        return false;\n      }\n    }\n\n    this._numLeafs--;\n    return true;\n  }\n\n  clear() {\n    this._numLeafs = 0;\n    this._root = null;\n  }\n\n  invalidCacheError() {\n    const CHANGED_PATH_ERROR_MESSAGE = isFastRefreshEnabled$2() ? 'Possible Fast Refresh module reload detected.  ' + 'This may also be caused by an selector returning inconsistent values. ' + 'Resetting cache.' : 'Invalid cache values.  This happens when selectors do not return ' + 'consistent values for the same input dependency values.  That may also ' + 'be caused when using Fast Refresh to change a selector implementation.  ' + 'Resetting cache.';\n    Recoil_recoverableViolation(CHANGED_PATH_ERROR_MESSAGE + (this._name != null ? ` - ${this._name}` : ''));\n    throw new ChangedPathError();\n  }\n\n}\n\nvar Recoil_TreeCache = {\n  TreeCache\n};\nvar Recoil_TreeCache_1 = Recoil_TreeCache.TreeCache;\nvar Recoil_TreeCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  TreeCache: Recoil_TreeCache_1\n});\n\nclass LRUCache {\n  constructor(options) {\n    var _options$mapKey;\n\n    _defineProperty(this, \"_maxSize\", void 0);\n\n    _defineProperty(this, \"_size\", void 0);\n\n    _defineProperty(this, \"_head\", void 0);\n\n    _defineProperty(this, \"_tail\", void 0);\n\n    _defineProperty(this, \"_map\", void 0);\n\n    _defineProperty(this, \"_keyMapper\", void 0);\n\n    this._maxSize = options.maxSize;\n    this._size = 0;\n    this._head = null;\n    this._tail = null;\n    this._map = new Map();\n    this._keyMapper = (_options$mapKey = options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : v => v;\n  }\n\n  head() {\n    return this._head;\n  }\n\n  tail() {\n    return this._tail;\n  }\n\n  size() {\n    return this._size;\n  }\n\n  maxSize() {\n    return this._maxSize;\n  }\n\n  has(key) {\n    return this._map.has(this._keyMapper(key));\n  }\n\n  get(key) {\n    const mappedKey = this._keyMapper(key);\n\n    const node = this._map.get(mappedKey);\n\n    if (!node) {\n      return undefined;\n    }\n\n    this.set(key, node.value);\n    return node.value;\n  }\n\n  set(key, val) {\n    const mappedKey = this._keyMapper(key);\n\n    const existingNode = this._map.get(mappedKey);\n\n    if (existingNode) {\n      this.delete(key);\n    }\n\n    const head = this.head();\n    const node = {\n      key,\n      right: head,\n      left: null,\n      value: val\n    };\n\n    if (head) {\n      head.left = node;\n    } else {\n      this._tail = node;\n    }\n\n    this._map.set(mappedKey, node);\n\n    this._head = node;\n    this._size++;\n\n    this._maybeDeleteLRU();\n  }\n\n  _maybeDeleteLRU() {\n    if (this.size() > this.maxSize()) {\n      this.deleteLru();\n    }\n  }\n\n  deleteLru() {\n    const tail = this.tail();\n\n    if (tail) {\n      this.delete(tail.key);\n    }\n  }\n\n  delete(key) {\n    const mappedKey = this._keyMapper(key);\n\n    if (!this._size || !this._map.has(mappedKey)) {\n      return;\n    }\n\n    const node = Recoil_nullthrows(this._map.get(mappedKey));\n    const right = node.right;\n    const left = node.left;\n\n    if (right) {\n      right.left = node.left;\n    }\n\n    if (left) {\n      left.right = node.right;\n    }\n\n    if (node === this.head()) {\n      this._head = right;\n    }\n\n    if (node === this.tail()) {\n      this._tail = left;\n    }\n\n    this._map.delete(mappedKey);\n\n    this._size--;\n  }\n\n  clear() {\n    this._size = 0;\n    this._head = null;\n    this._tail = null;\n    this._map = new Map();\n  }\n\n}\n\nvar Recoil_LRUCache = {\n  LRUCache\n};\nvar Recoil_LRUCache_1 = Recoil_LRUCache.LRUCache;\nvar Recoil_LRUCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  LRUCache: Recoil_LRUCache_1\n});\nconst {\n  LRUCache: LRUCache$1\n} = Recoil_LRUCache$1;\nconst {\n  TreeCache: TreeCache$1\n} = Recoil_TreeCache$1;\n\nfunction treeCacheLRU({\n  name,\n  maxSize,\n  mapNodeValue = v => v\n}) {\n  const lruCache = new LRUCache$1({\n    maxSize\n  });\n  const cache = new TreeCache$1({\n    name,\n    mapNodeValue,\n    onHit: node => {\n      lruCache.set(node, true);\n    },\n    onSet: node => {\n      const lruNode = lruCache.tail();\n      lruCache.set(node, true);\n\n      if (lruNode && cache.size() > maxSize) {\n        cache.delete(lruNode.key);\n      }\n    }\n  });\n  return cache;\n}\n\nvar Recoil_treeCacheLRU = treeCacheLRU;\nconst TIME_WARNING_THRESHOLD_MS = 15;\n\nfunction stringify(x, opt, key) {\n  // A optimization to avoid the more expensive JSON.stringify() for simple strings\n  // This may lose protection for u2028 and u2029, though.\n  if (typeof x === 'string' && !x.includes('\"') && !x.includes('\\\\')) {\n    return `\"${x}\"`;\n  } // Handle primitive types\n\n\n  switch (typeof x) {\n    case 'undefined':\n      return '';\n    // JSON.stringify(undefined) returns undefined, but we always want to return a string\n\n    case 'boolean':\n      return x ? 'true' : 'false';\n\n    case 'number':\n    case 'symbol':\n      // case 'bigint': // BigInt is not supported in www\n      return String(x);\n\n    case 'string':\n      // Add surrounding quotes and escape internal quotes\n      return JSON.stringify(x);\n\n    case 'function':\n      if ((opt === null || opt === void 0 ? void 0 : opt.allowFunctions) !== true) {\n        throw Recoil_err('Attempt to serialize function in a Recoil cache key');\n      }\n\n      return `__FUNCTION(${x.name})__`;\n  }\n\n  if (x === null) {\n    return 'null';\n  } // Fallback case for unknown types\n\n\n  if (typeof x !== 'object') {\n    var _JSON$stringify;\n\n    return (_JSON$stringify = JSON.stringify(x)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : '';\n  } // Deal with all promises as equivalent for now.\n\n\n  if (Recoil_isPromise(x)) {\n    return '__PROMISE__';\n  } // Arrays handle recursive stringification\n\n\n  if (Array.isArray(x)) {\n    return `[${x.map((v, i) => stringify(v, opt, i.toString()))}]`;\n  } // If an object defines a toJSON() method, then use that to override the\n  // serialization.  This matches the behavior of JSON.stringify().\n  // Pass the key for compatibility.\n  // Immutable.js collections define this method to allow us to serialize them.\n\n\n  if (typeof x.toJSON === 'function') {\n    // flowlint-next-line unclear-type: off\n    return stringify(x.toJSON(key), opt, key);\n  } // For built-in Maps, sort the keys in a stable order instead of the\n  // default insertion order.  Support non-string keys.\n\n\n  if (x instanceof Map) {\n    const obj = {};\n\n    for (const [k, v] of x) {\n      // Stringify will escape any nested quotes\n      obj[typeof k === 'string' ? k : stringify(k, opt)] = v;\n    }\n\n    return stringify(obj, opt, key);\n  } // For built-in Sets, sort the keys in a stable order instead of the\n  // default insertion order.\n\n\n  if (x instanceof Set) {\n    return stringify(Array.from(x).sort((a, b) => stringify(a, opt).localeCompare(stringify(b, opt))), opt, key);\n  } // Anything else that is iterable serialize as an Array.\n\n\n  if (Symbol !== undefined && x[Symbol.iterator] != null && typeof x[Symbol.iterator] === 'function') {\n    // flowlint-next-line unclear-type: off\n    return stringify(Array.from(x), opt, key);\n  } // For all other Objects, sort the keys in a stable order.\n\n\n  return `{${Object.keys(x).filter(k => x[k] !== undefined).sort() // stringify the key to add quotes and escape any nested slashes or quotes.\n  .map(k => `${stringify(k, opt)}:${stringify(x[k], opt, k)}`).join(',')}}`;\n} // Utility similar to JSON.stringify() except:\n// * Serialize built-in Sets as an Array\n// * Serialize built-in Maps as an Object.  Supports non-string keys.\n// * Serialize other iterables as arrays\n// * Sort the keys of Objects and Maps to have a stable order based on string conversion.\n//    This overrides their default insertion order.\n// * Still uses toJSON() of any object to override serialization\n// * Support Symbols (though don't guarantee uniqueness)\n// * We could support BigInt, but Flow doesn't seem to like it.\n// See Recoil_stableStringify-test.js for examples\n\n\nfunction stableStringify(x, opt = {\n  allowFunctions: false\n}) {\n  if (true) {\n    if (typeof window !== 'undefined') {\n      const startTime = window.performance ? window.performance.now() : 0;\n      const str = stringify(x, opt);\n      const endTime = window.performance ? window.performance.now() : 0;\n\n      if (endTime - startTime > TIME_WARNING_THRESHOLD_MS) {\n        /* eslint-disable fb-www/no-console */\n        console.groupCollapsed(`Recoil: Spent ${endTime - startTime}ms computing a cache key`);\n        console.warn(x, str);\n        console.groupEnd();\n        /* eslint-enable fb-www/no-console */\n      }\n\n      return str;\n    }\n  }\n\n  return stringify(x, opt);\n}\n\nvar Recoil_stableStringify = stableStringify;\nconst {\n  TreeCache: TreeCache$2\n} = Recoil_TreeCache$1;\nconst defaultPolicy = {\n  equality: 'reference',\n  eviction: 'keep-all',\n  maxSize: Infinity\n};\n\nfunction treeCacheFromPolicy({\n  equality = defaultPolicy.equality,\n  eviction = defaultPolicy.eviction,\n  maxSize = defaultPolicy.maxSize\n} = defaultPolicy, name) {\n  const valueMapper = getValueMapper(equality);\n  return getTreeCache(eviction, maxSize, valueMapper, name);\n}\n\nfunction getValueMapper(equality) {\n  switch (equality) {\n    case 'reference':\n      return val => val;\n\n    case 'value':\n      return val => Recoil_stableStringify(val);\n  }\n\n  throw Recoil_err(`Unrecognized equality policy ${equality}`);\n}\n\nfunction getTreeCache(eviction, maxSize, mapNodeValue, name) {\n  switch (eviction) {\n    case 'keep-all':\n      return new TreeCache$2({\n        name,\n        mapNodeValue\n      });\n\n    case 'lru':\n      return Recoil_treeCacheLRU({\n        name,\n        maxSize: Recoil_nullthrows(maxSize),\n        mapNodeValue\n      });\n\n    case 'most-recent':\n      return Recoil_treeCacheLRU({\n        name,\n        maxSize: 1,\n        mapNodeValue\n      });\n  }\n\n  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);\n}\n\nvar Recoil_treeCacheFromPolicy = treeCacheFromPolicy;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction isNode(object) {\n  var _ownerDocument, _doc$defaultView;\n\n  if (typeof window === 'undefined') {\n    return false;\n  }\n\n  const doc = object != null ? (_ownerDocument = object.ownerDocument) !== null && _ownerDocument !== void 0 ? _ownerDocument : object : document;\n  const defaultView = (_doc$defaultView = doc.defaultView) !== null && _doc$defaultView !== void 0 ? _doc$defaultView : window;\n  return !!(object != null && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));\n}\n\nvar Recoil_isNode = isNode;\nconst {\n  isReactNative: isReactNative$1,\n  isWindow: isWindow$1\n} = Recoil_Environment;\n\nfunction shouldNotBeFrozen(value) {\n  // Primitives and functions:\n  if (value === null || typeof value !== 'object') {\n    return true;\n  } // React elements:\n\n\n  switch (typeof value.$$typeof) {\n    case 'symbol':\n      return true;\n\n    case 'number':\n      return true;\n  } // Immutable structures:\n\n\n  if (value['@@__IMMUTABLE_ITERABLE__@@'] != null || value['@@__IMMUTABLE_KEYED__@@'] != null || value['@@__IMMUTABLE_INDEXED__@@'] != null || value['@@__IMMUTABLE_ORDERED__@@'] != null || value['@@__IMMUTABLE_RECORD__@@'] != null) {\n    return true;\n  } // DOM nodes:\n\n\n  if (Recoil_isNode(value)) {\n    return true;\n  }\n\n  if (Recoil_isPromise(value)) {\n    return true;\n  }\n\n  if (value instanceof Error) {\n    return true;\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return true;\n  } // Some environments, just as Jest, don't work with the instanceof check\n\n\n  if (!isReactNative$1 && isWindow$1(value)) {\n    return true;\n  }\n\n  return false;\n} // Recursively freeze a value to enforce it is read-only.\n// This may also have minimal performance improvements for enumerating\n// objects (based on browser implementations, of course)\n\n\nfunction deepFreezeValue(value) {\n  if (typeof value !== 'object' || shouldNotBeFrozen(value)) {\n    return;\n  }\n\n  Object.freeze(value); // Make all properties read-only\n\n  for (const key in value) {\n    // $FlowIssue[method-unbinding] added when improving typing for this parameters\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      const prop = value[key]; // Prevent infinite recurssion for circular references.\n\n      if (typeof prop === 'object' && prop != null && !Object.isFrozen(prop)) {\n        deepFreezeValue(prop);\n      }\n    }\n  }\n\n  Object.seal(value); // This also makes existing properties non-configurable.\n}\n\nvar Recoil_deepFreezeValue = deepFreezeValue;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * This is a stub for some integration into FB internal stuff\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction startPerfBlock(_id) {\n  return () => null;\n}\n\nvar Recoil_PerformanceTimings = {\n  startPerfBlock\n};\nconst {\n  isLoadable: isLoadable$1,\n  loadableWithError: loadableWithError$1,\n  loadableWithPromise: loadableWithPromise$1,\n  loadableWithValue: loadableWithValue$2\n} = Recoil_Loadable$1;\nconst {\n  WrappedValue: WrappedValue$1\n} = Recoil_Wrapper$1;\nconst {\n  getNodeLoadable: getNodeLoadable$2,\n  peekNodeLoadable: peekNodeLoadable$1,\n  setNodeValue: setNodeValue$3\n} = Recoil_FunctionalCore;\nconst {\n  saveDepsToStore: saveDepsToStore$1\n} = Recoil_Graph;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$6,\n  getConfigDeletionHandler: getConfigDeletionHandler$1,\n  getNode: getNode$6,\n  registerNode: registerNode$1\n} = Recoil_Node;\nconst {\n  isRecoilValue: isRecoilValue$3\n} = Recoil_RecoilValue$1;\nconst {\n  markRecoilValueModified: markRecoilValueModified$1\n} = Recoil_RecoilValueInterface;\nconst {\n  retainedByOptionWithDefault: retainedByOptionWithDefault$1\n} = Recoil_Retention;\nconst {\n  recoilCallback: recoilCallback$1\n} = Recoil_useRecoilCallback;\nconst {\n  startPerfBlock: startPerfBlock$1\n} = Recoil_PerformanceTimings;\n\nclass Canceled {}\n\nconst CANCELED = new Canceled();\n/**\r\n * An ExecutionID is an arbitrary ID that lets us distinguish executions from\r\n * each other. This is necessary as we need a way of solving this problem:\r\n * \"given 3 async executions, only update state for the 'latest' execution when\r\n * it finishes running regardless of when the other 2 finish\". ExecutionIDs\r\n * provide a convenient way of identifying executions so that we can track and\r\n * manage them over time.\r\n */\n\nconst dependencyStack = []; // for detecting circular dependencies.\n\nconst waitingStores = new Map();\n\nconst getNewExecutionID = (() => {\n  let executionID = 0;\n  return () => executionID++;\n})();\n/* eslint-disable no-redeclare */\n\n\nfunction selector(options) {\n  let recoilValue = null;\n  const {\n    key,\n    get,\n    cachePolicy_UNSTABLE: cachePolicy\n  } = options;\n  const set = options.set != null ? options.set : undefined; // flow\n\n  if (true) {\n    if (typeof key !== 'string') {\n      throw Recoil_err('A key option with a unique string value must be provided when creating a selector.');\n    }\n\n    if (typeof get !== 'function') {\n      throw Recoil_err('Selectors must specify a get callback option to get the selector value.');\n    }\n  } // This is every discovered dependency across all executions\n\n\n  const discoveredDependencyNodeKeys = new Set();\n  const cache = Recoil_treeCacheFromPolicy(cachePolicy !== null && cachePolicy !== void 0 ? cachePolicy : {\n    equality: 'reference',\n    eviction: 'keep-all'\n  }, key);\n  const retainedBy = retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE);\n  const executionInfoMap = new Map();\n  let liveStoresCount = 0;\n\n  function selectorIsLive() {\n    return !Recoil_gkx('recoil_memory_managament_2020') || liveStoresCount > 0;\n  }\n\n  function selectorInit(store) {\n    store.getState().knownSelectors.add(key);\n    liveStoresCount++;\n    return () => {\n      liveStoresCount--;\n    };\n  }\n\n  function selectorShouldDeleteConfigOnRelease() {\n    return getConfigDeletionHandler$1(key) !== undefined && !selectorIsLive();\n  }\n\n  function resolveAsync(store, state, executionID, loadable, depValues) {\n    setCache(state, loadable, depValues);\n    notifyStoresOfResolvedAsync(store, executionID);\n  }\n\n  function notifyStoresOfResolvedAsync(store, executionID) {\n    if (isLatestExecution(store, executionID)) {\n      clearExecutionInfo(store);\n    }\n\n    notifyWaitingStores(executionID, true);\n  }\n  /**\r\n   * Notify stores to pull the selector again if a new async dep was discovered.\r\n   * 1) Async selector adds a new dep but doesn't resolve yet.\r\n   *    Note that deps for an async selector are based on the state when the\r\n   *    evaluation started, in order to provide a consistent picture of state.\r\n   * 2) But, new value of dep based on the current state might cause the selector\r\n   *    to resolve or resolve differently.\r\n   * 3) Therefore, this notification will pull the selector based on the current\r\n   *    state for the components\r\n   */\n\n\n  function notifyStoresOfNewAsyncDep(store, executionID) {\n    if (isLatestExecution(store, executionID)) {\n      const executionInfo = Recoil_nullthrows(getExecutionInfo(store));\n      executionInfo.stateVersions.clear();\n      notifyWaitingStores(executionID, false);\n    }\n  }\n\n  function notifyWaitingStores(executionID, clearWaitlist) {\n    const stores = waitingStores.get(executionID);\n\n    if (stores != null) {\n      for (const waitingStore of stores) {\n        markRecoilValueModified$1(waitingStore, Recoil_nullthrows(recoilValue));\n      }\n\n      if (clearWaitlist) {\n        waitingStores.delete(executionID);\n      }\n    }\n  }\n\n  function markStoreWaitingForResolvedAsync(store, executionID) {\n    let stores = waitingStores.get(executionID);\n\n    if (stores == null) {\n      waitingStores.set(executionID, stores = new Set());\n    }\n\n    stores.add(store);\n  }\n  /**\r\n   * This function attaches a then() and a catch() to a promise that was\r\n   * returned from a selector's get() (either explicitly or implicitly by\r\n   * running a function that uses the \"async\" keyword). If a selector's get()\r\n   * returns a promise, we have two possibilities:\r\n   *\r\n   * 1. The promise will resolve, in which case it will have completely finished\r\n   *    executing without any remaining pending dependencies. No more retries\r\n   *    are needed and we can proceed with updating the cache and notifying\r\n   *    subscribers (if it is the latest execution, otherwise only the cache\r\n   *    will be updated and subscriptions will not be fired). This is the case\r\n   *    handled by the attached then() handler.\r\n   *\r\n   * 2. The promise will throw because it either has an error or it came across\r\n   *    an async dependency that has not yet resolved, in which case we will\r\n   *    call wrapDepdencyPromise(), whose responsibility is to handle dependency\r\n   *    promises. This case is handled by the attached catch() handler.\r\n   *\r\n   * Both branches will eventually resolve to the final result of the selector\r\n   * (or an error if a real error occurred).\r\n   *\r\n   * The execution will run to completion even if it is stale, and its value\r\n   * will be cached. But stale executions will not update global state or update\r\n   * executionInfo as that is the responsibility of the 'latest' execution.\r\n   *\r\n   * Note this function should not be passed a promise that was thrown--AKA a\r\n   * dependency promise. Dependency promises should be passed to\r\n   * wrapPendingDependencyPromise()).\r\n   */\n\n\n  function wrapResultPromise(store, promise, state, depValues, executionID, loadingDepsState) {\n    return promise.then(value => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      const loadable = loadableWithValue$2(value);\n      resolveAsync(store, state, executionID, loadable, depValues);\n      return value;\n    }).catch(errorOrPromise => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      if (Recoil_isPromise(errorOrPromise)) {\n        return wrapPendingDependencyPromise(store, errorOrPromise, state, depValues, executionID, loadingDepsState);\n      }\n\n      const loadable = loadableWithError$1(errorOrPromise);\n      resolveAsync(store, state, executionID, loadable, depValues);\n      throw errorOrPromise;\n    });\n  }\n  /**\r\n   * This function attaches a then() and a catch() to a promise that was\r\n   * thrown from a selector's get(). If a selector's get() throws a promise,\r\n   * we have two possibilities:\r\n   *\r\n   * 1. The promise will resolve, meaning one of our selector's dependencies is\r\n   *    now available and we should \"retry\" our get() by running it again. This\r\n   *    is the case handled by the attached then() handler.\r\n   *\r\n   * 2. The promise will throw because something went wrong with the dependency\r\n   *    promise (in other words a real error occurred). This case is handled by\r\n   *    the attached catch() handler. If the dependency promise throws, it is\r\n   *    _always_ a real error and not another dependency promise (any dependency\r\n   *    promises would have been handled upstream).\r\n   *\r\n   * The then() branch will eventually resolve to the final result of the\r\n   * selector (or an error if a real error occurs), and the catch() will always\r\n   * resolve to an error because the dependency promise is a promise that was\r\n   * wrapped upstream, meaning it will only resolve to its real value or to a\r\n   * real error.\r\n   *\r\n   * The execution will run to completion even if it is stale, and its value\r\n   * will be cached. But stale executions will not update global state or update\r\n   * executionInfo as that is the responsibility of the 'latest' execution.\r\n   *\r\n   * Note this function should not be passed a promise that was returned from\r\n   * get(). The intention is that this function is only passed promises that\r\n   * were thrown due to a pending dependency. Promises returned by get() should\r\n   * be passed to wrapResultPromise() instead.\r\n   */\n\n\n  function wrapPendingDependencyPromise(store, promise, state, existingDeps, executionID, loadingDepsState) {\n    return promise.then(resolvedDep => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      } // Check if we are handling a pending Recoil dependency or if the user\n      // threw their own Promise to \"suspend\" a selector evaluation.  We need\n      // to check that the loadingDepPromise actually matches the promise that\n      // we caught in case the selector happened to catch the promise we threw\n      // for a pending Recoil dependency from `getRecoilValue()` and threw\n      // their own promise instead.\n\n\n      if (loadingDepsState.loadingDepKey != null && loadingDepsState.loadingDepPromise === promise) {\n        /**\r\n         * Note for async atoms, this means we are changing the atom's value\r\n         * in the store for the given version. This should be alright because\r\n         * the version of state is now stale and a new version will have\r\n         * already been triggered by the atom being resolved (see this logic\r\n         * in Recoil_atom.js)\r\n         */\n        state.atomValues.set(loadingDepsState.loadingDepKey, loadableWithValue$2(resolvedDep));\n      } else {\n        /**\r\n         * If resolvedDepKey is not defined, the promise was a user-thrown\r\n         * promise. User-thrown promises are an advanced feature and they\r\n         * should be avoided in almost all cases. Using `loadable.map()` inside\r\n         * of selectors for loading loadables and then throwing that mapped\r\n         * loadable's promise is an example of a user-thrown promise.\r\n         *\r\n         * When we hit a user-thrown promise, we have to bail out of an optimization\r\n         * where we bypass calculating selector cache keys for selectors that\r\n         * have been previously seen for a given state (these selectors are saved in\r\n         * state.atomValues) to avoid stale state as we have no way of knowing\r\n         * what state changes happened (if any) in result to the promise resolving.\r\n         *\r\n         * Ideally we would only bail out selectors that are in the chain of\r\n         * dependencies for this selector, but there's currently no way to get\r\n         * a full list of a selector's downstream nodes because the state that\r\n         * is executing may be a discarded tree (so store.getGraph(state.version)\r\n         * will be empty), and the full dep tree may not be in the selector\r\n         * caches in the case where the selector's cache was cleared. To solve\r\n         * for this we would have to keep track of all running selector\r\n         * executions and their downstream deps. Because this only covers edge\r\n         * cases, that complexity might not be justifyable.\r\n         */\n        store.getState().knownSelectors.forEach(nodeKey => {\n          state.atomValues.delete(nodeKey);\n        });\n      }\n      /**\r\n       * Optimization: Now that the dependency has resolved, let's try hitting\r\n       * the cache in case the dep resolved to a value we have previously seen.\r\n       *\r\n       * TODO:\r\n       * Note this optimization is not perfect because it only prevents re-executions\r\n       * _after_ the point where an async dependency is found. Any code leading\r\n       * up to the async dependency may have run unnecessarily. The ideal case\r\n       * would be to wait for the async dependency to resolve first, check the\r\n       * cache, and prevent _any_ execution of the selector if the resulting\r\n       * value of the dependency leads to a path that is found in the cache.\r\n       * The ideal case is more difficult to implement as it would require that\r\n       * we capture and wait for the the async dependency right after checking\r\n       * the cache. The current approach takes advantage of the fact that running\r\n       * the selector already has a code path that lets us exit early when\r\n       * an async dep resolves.\r\n       */\n\n\n      const cachedLoadable = getLoadableFromCacheAndUpdateDeps(store, state);\n\n      if (cachedLoadable && cachedLoadable.state !== 'loading') {\n        /**\r\n         * This has to notify stores of a resolved async, even if there is no\r\n         * current pending execution for the following case:\r\n         * 1) A component renders with this pending loadable.\r\n         * 2) The upstream dependency resolves.\r\n         * 3) While processing some other selector it reads this one, such as\r\n         *    while traversing its dependencies.  At this point it gets the\r\n         *    new resolved value synchronously and clears the current\r\n         *    execution ID.  The component wasn't getting the value itself,\r\n         *    though, so it still has the pending loadable.\r\n         * 4) When this code executes the current execution id was cleared\r\n         *    and it wouldn't notify the component of the new value.\r\n         *\r\n         * I think this is only an issue with \"early\" rendering since the\r\n         * components got their value using the in-progress execution.\r\n         * We don't have a unit test for this case yet.  I'm not sure it is\r\n         * necessary with recoil_transition_support mode.\r\n         */\n        if (isLatestExecution(store, executionID) || getExecutionInfo(store) == null) {\n          notifyStoresOfResolvedAsync(store, executionID);\n        }\n\n        if (cachedLoadable.state === 'hasValue') {\n          return cachedLoadable.contents;\n        } else {\n          throw cachedLoadable.contents;\n        }\n      }\n      /**\r\n       * If this execution is stale, let's check to see if there is some in\r\n       * progress execution with a matching state. If we find a match, then\r\n       * we can take the value from that in-progress execution. Note this may\r\n       * sound like an edge case, but may be very common in cases where a\r\n       * loading dependency resolves from loading to having a value (thus\r\n       * possibly triggering a re-render), and React re-renders before the\r\n       * chained .then() functions run, thus starting a new execution as the\r\n       * dep has changed value. Without this check we will run the selector\r\n       * twice (once in the new execution and once again in this .then(), so\r\n       * this check is necessary to keep unnecessary re-executions to a\r\n       * minimum).\r\n       *\r\n       * Also note this code does not check across all executions that may be\r\n       * running. It only optimizes for the _latest_ execution per store as\r\n       * we currently do not maintain a list of all currently running executions.\r\n       * This means in some cases we may run selectors more than strictly\r\n       * necessary when there are multiple executions running for the same\r\n       * selector. This may be a valid tradeoff as checking for dep changes\r\n       * across all in-progress executions may take longer than just\r\n       * re-running the selector. This will be app-dependent, and maybe in the\r\n       * future we can make the behavior configurable. An ideal fix may be\r\n       * to extend the tree cache to support caching loading states.\r\n       */\n\n\n      if (!isLatestExecution(store, executionID)) {\n        const executionInfo = getInProgressExecutionInfo(store, state);\n\n        if (executionInfo != null) {\n          /**\r\n           * Returning promise here without wrapping as the wrapper logic was\r\n           * already done upstream when this promise was generated.\r\n           */\n          return executionInfo.loadingLoadable.contents;\n        }\n      } // Retry the selector evaluation now that the dependency has resolved\n\n\n      const [loadable, depValues] = evaluateSelectorGetter(store, state, executionID);\n\n      if (loadable.state !== 'loading') {\n        resolveAsync(store, state, executionID, loadable, depValues);\n      }\n\n      if (loadable.state === 'hasError') {\n        throw loadable.contents;\n      }\n\n      return loadable.contents;\n    }).catch(error => {\n      // The selector was released since the request began; ignore the response.\n      if (error instanceof Canceled) {\n        throw CANCELED;\n      }\n\n      if (!selectorIsLive()) {\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      const loadable = loadableWithError$1(error);\n      resolveAsync(store, state, executionID, loadable, existingDeps);\n      throw error;\n    });\n  }\n\n  function updateDeps(store, state, deps, executionID) {\n    var _store$getState, _store$getState$curre, _store$getState2, _store$getState2$next;\n\n    if (isLatestExecution(store, executionID) || state.version === ((_store$getState = store.getState()) === null || _store$getState === void 0 ? void 0 : (_store$getState$curre = _store$getState.currentTree) === null || _store$getState$curre === void 0 ? void 0 : _store$getState$curre.version) || state.version === ((_store$getState2 = store.getState()) === null || _store$getState2 === void 0 ? void 0 : (_store$getState2$next = _store$getState2.nextTree) === null || _store$getState2$next === void 0 ? void 0 : _store$getState2$next.version)) {\n      var _store$getState$nextT, _store$getState3, _store$getState3$next;\n\n      saveDepsToStore$1(key, deps, store, (_store$getState$nextT = (_store$getState3 = store.getState()) === null || _store$getState3 === void 0 ? void 0 : (_store$getState3$next = _store$getState3.nextTree) === null || _store$getState3$next === void 0 ? void 0 : _store$getState3$next.version) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree.version);\n    }\n\n    for (const nodeKey of deps) {\n      discoveredDependencyNodeKeys.add(nodeKey);\n    }\n  }\n\n  function evaluateSelectorGetter(store, state, executionID) {\n    const endPerfBlock = startPerfBlock$1(key); // TODO T63965866: use execution ID here\n\n    let duringSynchronousExecution = true;\n    let duringAsynchronousExecution = true;\n\n    const finishEvaluation = () => {\n      endPerfBlock();\n      duringAsynchronousExecution = false;\n    };\n\n    let result;\n    let resultIsError = false;\n    let loadable;\n    const loadingDepsState = {\n      loadingDepKey: null,\n      loadingDepPromise: null\n    };\n    /**\r\n     * Starting a fresh set of deps that we'll be using to update state. We're\r\n     * starting a new set versus adding it in existing state deps because\r\n     * the version of state that we update deps for may be a more recent version\r\n     * than the version the selector was called with. This is because the latest\r\n     * execution will update the deps of the current/latest version of state\r\n     * (This is safe to do because the fact that the selector is the latest\r\n     * execution means the deps we discover below are our best guess at the\r\n     * deps for the current/latest state in the store)\r\n     */\n\n    const depValues = new Map();\n\n    function getRecoilValue({\n      key: depKey\n    }) {\n      const depLoadable = getNodeLoadable$2(store, state, depKey);\n      depValues.set(depKey, depLoadable); // We need to update asynchronous dependencies as we go so the selector\n      // knows if it has to restart evaluation if one of them is updated before\n      // the asynchronous selector completely resolves.\n\n      if (!duringSynchronousExecution) {\n        updateDeps(store, state, new Set(depValues.keys()), executionID);\n        notifyStoresOfNewAsyncDep(store, executionID);\n      }\n\n      switch (depLoadable.state) {\n        case 'hasValue':\n          return depLoadable.contents;\n\n        case 'hasError':\n          throw depLoadable.contents;\n\n        case 'loading':\n          loadingDepsState.loadingDepKey = depKey;\n          loadingDepsState.loadingDepPromise = depLoadable.contents;\n          throw depLoadable.contents;\n      }\n\n      throw Recoil_err('Invalid Loadable state');\n    }\n\n    const getCallback = fn => {\n      return (...args) => {\n        if (duringAsynchronousExecution) {\n          throw Recoil_err('Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.');\n        }\n\n        !(recoilValue != null) ?  true ? Recoil_invariant(false, 'Recoil Value can never be null') : 0 : void 0;\n        return recoilCallback$1(store, fn, args, {\n          node: recoilValue\n        } // flowlint-line unclear-type:off\n        );\n      };\n    };\n\n    try {\n      result = get({\n        get: getRecoilValue,\n        getCallback\n      });\n      result = isRecoilValue$3(result) ? getRecoilValue(result) : result;\n\n      if (isLoadable$1(result)) {\n        if (result.state === 'hasError') {\n          resultIsError = true;\n        }\n\n        result = result.contents;\n      }\n\n      if (Recoil_isPromise(result)) {\n        result = wrapResultPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);\n      } else {\n        finishEvaluation();\n      }\n\n      result = result instanceof WrappedValue$1 ? result.value : result;\n    } catch (errorOrDepPromise) {\n      result = errorOrDepPromise;\n\n      if (Recoil_isPromise(result)) {\n        result = wrapPendingDependencyPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);\n      } else {\n        resultIsError = true;\n        finishEvaluation();\n      }\n    }\n\n    if (resultIsError) {\n      loadable = loadableWithError$1(result);\n    } else if (Recoil_isPromise(result)) {\n      loadable = loadableWithPromise$1(result);\n    } else {\n      loadable = loadableWithValue$2(result);\n    }\n\n    duringSynchronousExecution = false;\n    updateExecutionInfoDepValues(store, executionID, depValues);\n    updateDeps(store, state, new Set(depValues.keys()), executionID);\n    return [loadable, depValues];\n  }\n\n  function getLoadableFromCacheAndUpdateDeps(store, state) {\n    // First, look up in the state cache\n    // If it's here, then the deps in the store should already be valid.\n    let cachedLoadable = state.atomValues.get(key);\n\n    if (cachedLoadable != null) {\n      return cachedLoadable;\n    } // Second, look up in the selector cache and update the deps in the store\n\n\n    const depsAfterCacheLookup = new Set();\n\n    try {\n      cachedLoadable = cache.get(nodeKey => {\n        !(typeof nodeKey === 'string') ?  true ? Recoil_invariant(false, 'Cache nodeKey is type string') : 0 : void 0;\n        return getNodeLoadable$2(store, state, nodeKey).contents;\n      }, {\n        onNodeVisit: node => {\n          if (node.type === 'branch' && node.nodeKey !== key) {\n            depsAfterCacheLookup.add(node.nodeKey);\n          }\n        }\n      });\n    } catch (error) {\n      throw Recoil_err(`Problem with cache lookup for selector \"${key}\": ${error.message}`);\n    }\n\n    if (cachedLoadable) {\n      var _getExecutionInfo; // Cache the results in the state to allow for cheaper lookup than\n      // iterating the tree cache of dependencies.\n\n\n      state.atomValues.set(key, cachedLoadable);\n      /**\r\n       * Ensure store contains correct dependencies if we hit the cache so that\r\n       * the store deps and cache are in sync for a given state. This is important\r\n       * because store deps are normally updated when new executions are created,\r\n       * but cache hits don't trigger new executions but they still _may_ signify\r\n       * a change in deps in the store if the store deps for this state are empty\r\n       * or stale.\r\n       */\n\n      updateDeps(store, state, depsAfterCacheLookup, (_getExecutionInfo = getExecutionInfo(store)) === null || _getExecutionInfo === void 0 ? void 0 : _getExecutionInfo.executionID);\n    }\n\n    return cachedLoadable;\n  }\n  /**\r\n   * Given a tree state, this function returns a Loadable of the current state.\r\n   *\r\n   * The selector's get() function will only be re-evaluated if _both_ of the\r\n   * following statements are true:\r\n   *\r\n   * 1. The current dep values from the given state produced a cache key that\r\n   *    was not found in the cache.\r\n   * 2. There is no currently running async execution OR there is an\r\n   *    async execution that is running, but after comparing the dep values in\r\n   *    the given state with the dep values that the execution has discovered so\r\n   *    far we find that at least one dep value has changed, in which case we\r\n   *    start a new execution (the previously running execution will continue to\r\n   *    run to completion, but only the new execution will be deemed the\r\n   *    'latest' execution, meaning it will be the only execution that will\r\n   *    update global state when it is finished. Any non-latest executions will\r\n   *    run to completion and update the selector cache but not global state).\r\n   */\n\n\n  function getSelectorLoadableAndUpdateDeps(store, state) {\n    // First, see if our current state is cached\n    const cachedVal = getLoadableFromCacheAndUpdateDeps(store, state);\n\n    if (cachedVal != null) {\n      clearExecutionInfo(store);\n      return cachedVal;\n    } // Second, check if there is already an ongoing execution based on the current state\n\n\n    const inProgressExecutionInfo = getInProgressExecutionInfo(store, state);\n\n    if (inProgressExecutionInfo != null) {\n      var _inProgressExecutionI;\n\n      if (((_inProgressExecutionI = inProgressExecutionInfo.loadingLoadable) === null || _inProgressExecutionI === void 0 ? void 0 : _inProgressExecutionI.state) === 'loading') {\n        markStoreWaitingForResolvedAsync(store, inProgressExecutionInfo.executionID);\n      } // FIXME: check after the fact to see if we made the right choice by waiting\n\n\n      return inProgressExecutionInfo.loadingLoadable;\n    } // Third, start a new evaluation of the selector\n\n\n    const newExecutionID = getNewExecutionID();\n    const [loadable, newDepValues] = evaluateSelectorGetter(store, state, newExecutionID);\n    /**\r\n     * Conditionally updates the cache with a given loadable.\r\n     *\r\n     * We only cache loadables that are not loading because our cache keys are\r\n     * based on dep values, which are in an unfinished state for loadables that\r\n     * have a 'loading' state (new deps may be discovered while the selector\r\n     * runs its async code). We never want to cache partial dependencies b/c it\r\n     * could lead to errors, such as prematurely returning the result based on a\r\n     * partial list of deps-- we need the full list of deps to ensure that we\r\n     * are returning the correct result from cache.\r\n     */\n\n    if (loadable.state === 'loading') {\n      setExecutionInfo(store, newExecutionID, loadable, newDepValues, state);\n      markStoreWaitingForResolvedAsync(store, newExecutionID);\n    } else {\n      clearExecutionInfo(store);\n      setCache(state, loadable, newDepValues);\n    }\n\n    return loadable;\n  }\n  /**\r\n   * Searches execution info across all stores to see if there is an in-progress\r\n   * execution whose dependency values match the values of the requesting store.\r\n   */\n\n\n  function getInProgressExecutionInfo(store, state) {\n    // Sort the pending executions so that our current store is checked first.\n    const pendingExecutions = Recoil_concatIterables([executionInfoMap.has(store) ? [Recoil_nullthrows(executionInfoMap.get(store))] : [], Recoil_mapIterable(Recoil_filterIterable(executionInfoMap, ([s]) => s !== store), ([, execInfo]) => execInfo)]);\n\n    function anyDepChanged(execDepValues) {\n      for (const [depKey, execLoadable] of execDepValues) {\n        if (!getNodeLoadable$2(store, state, depKey).is(execLoadable)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    for (const execInfo of pendingExecutions) {\n      if ( // If this execution was already checked to be valid with this version\n      // of state, then let's use it!\n      execInfo.stateVersions.get(state.version) || // If the deps for the execution match our current state, then it's valid\n      !anyDepChanged(execInfo.depValuesDiscoveredSoFarDuringAsyncWork)) {\n        execInfo.stateVersions.set(state.version, true);\n        return execInfo;\n      } else {\n        execInfo.stateVersions.set(state.version, false);\n      }\n    }\n\n    return undefined;\n  }\n\n  function getExecutionInfo(store) {\n    return executionInfoMap.get(store);\n  }\n  /**\r\n   * This function will update the selector's execution info when the selector\r\n   * has either finished running an execution or has started a new execution. If\r\n   * the given loadable is in a 'loading' state, the intention is that a new\r\n   * execution has started. Otherwise, the intention is that an execution has\r\n   * just finished.\r\n   */\n\n\n  function setExecutionInfo(store, newExecutionID, loadable, depValues, state) {\n    executionInfoMap.set(store, {\n      depValuesDiscoveredSoFarDuringAsyncWork: depValues,\n      executionID: newExecutionID,\n      loadingLoadable: loadable,\n      stateVersions: new Map([[state.version, true]])\n    });\n  }\n\n  function updateExecutionInfoDepValues(store, executionID, depValues) {\n    // We only need to bother updating the deps for the latest execution because\n    // that's all getInProgressExecutionInfo() will be looking for.\n    if (isLatestExecution(store, executionID)) {\n      const executionInfo = getExecutionInfo(store);\n\n      if (executionInfo != null) {\n        executionInfo.depValuesDiscoveredSoFarDuringAsyncWork = depValues;\n      }\n    }\n  }\n\n  function clearExecutionInfo(store) {\n    executionInfoMap.delete(store);\n  }\n\n  function isLatestExecution(store, executionID) {\n    var _getExecutionInfo2;\n\n    return executionID === ((_getExecutionInfo2 = getExecutionInfo(store)) === null || _getExecutionInfo2 === void 0 ? void 0 : _getExecutionInfo2.executionID);\n  }\n  /**\r\n   * FIXME: dep keys should take into account the state of the loadable to\r\n   * prevent the edge case where a loadable with an error and a loadable with\r\n   * an error as a value are treated as the same thing incorrectly. For example\r\n   * these two should be treated differently:\r\n   *\r\n   * selector({key: '', get: () => new Error('hi')});\r\n   * selector({key: '', get () => {throw new Error('hi')}});\r\n   *\r\n   * With current implementation they are treated the same\r\n   */\n\n\n  function depValuesToDepRoute(depValues) {\n    return Array.from(depValues.entries()).map(([depKey, valLoadable]) => [depKey, valLoadable.contents]);\n  }\n\n  function setCache(state, loadable, depValues) {\n    if (true) {\n      if (loadable.state !== 'loading' && Boolean(options.dangerouslyAllowMutability) === false) {\n        Recoil_deepFreezeValue(loadable.contents);\n      }\n    }\n\n    state.atomValues.set(key, loadable);\n\n    try {\n      cache.set(depValuesToDepRoute(depValues), loadable);\n    } catch (error) {\n      throw Recoil_err(`Problem with setting cache for selector \"${key}\": ${error.message}`);\n    }\n  }\n\n  function detectCircularDependencies(fn) {\n    if (dependencyStack.includes(key)) {\n      const message = `Recoil selector has circular dependencies: ${dependencyStack.slice(dependencyStack.indexOf(key)).join(' \\u2192 ')}`;\n      return loadableWithError$1(Recoil_err(message));\n    }\n\n    dependencyStack.push(key);\n\n    try {\n      return fn();\n    } finally {\n      dependencyStack.pop();\n    }\n  }\n\n  function selectorPeek(store, state) {\n    const cachedLoadable = state.atomValues.get(key);\n\n    if (cachedLoadable != null) {\n      return cachedLoadable;\n    }\n\n    return cache.get(nodeKey => {\n      var _peekNodeLoadable;\n\n      !(typeof nodeKey === 'string') ?  true ? Recoil_invariant(false, 'Cache nodeKey is type string') : 0 : void 0;\n      return (_peekNodeLoadable = peekNodeLoadable$1(store, state, nodeKey)) === null || _peekNodeLoadable === void 0 ? void 0 : _peekNodeLoadable.contents;\n    });\n  }\n\n  function selectorGet(store, state) {\n    return detectCircularDependencies(() => getSelectorLoadableAndUpdateDeps(store, state));\n  }\n\n  function invalidateSelector(state) {\n    state.atomValues.delete(key);\n  }\n\n  function clearSelectorCache(store, treeState) {\n    !(recoilValue != null) ?  true ? Recoil_invariant(false, 'Recoil Value can never be null') : 0 : void 0;\n\n    for (const nodeKey of discoveredDependencyNodeKeys) {\n      var _node$clearCache;\n\n      const node = getNode$6(nodeKey);\n      (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, treeState);\n    }\n\n    discoveredDependencyNodeKeys.clear();\n    invalidateSelector(treeState);\n    cache.clear();\n    markRecoilValueModified$1(store, recoilValue);\n  }\n\n  if (set != null) {\n    /**\r\n     * ES5 strict mode prohibits defining non-top-level function declarations,\r\n     * so don't use function declaration syntax here\r\n     */\n    const selectorSet = (store, state, newValue) => {\n      let syncSelectorSetFinished = false;\n      const writes = new Map();\n\n      function getRecoilValue({\n        key: depKey\n      }) {\n        if (syncSelectorSetFinished) {\n          throw Recoil_err('Recoil: Async selector sets are not currently supported.');\n        }\n\n        const loadable = getNodeLoadable$2(store, state, depKey);\n\n        if (loadable.state === 'hasValue') {\n          return loadable.contents;\n        } else if (loadable.state === 'loading') {\n          const msg = `Getting value of asynchronous atom or selector \"${depKey}\" in a pending state while setting selector \"${key}\" is not yet supported.`;\n          Recoil_recoverableViolation(msg);\n          throw Recoil_err(msg);\n        } else {\n          throw loadable.contents;\n        }\n      }\n\n      function setRecoilState(recoilState, valueOrUpdater) {\n        if (syncSelectorSetFinished) {\n          const msg = 'Recoil: Async selector sets are not currently supported.';\n          Recoil_recoverableViolation(msg);\n          throw Recoil_err(msg);\n        }\n\n        const setValue = typeof valueOrUpdater === 'function' ? // cast to any because we can't restrict type S from being a function itself without losing support for opaque types\n        // flowlint-next-line unclear-type:off\n        valueOrUpdater(getRecoilValue(recoilState)) : valueOrUpdater;\n        const upstreamWrites = setNodeValue$3(store, state, recoilState.key, setValue);\n        upstreamWrites.forEach((v, k) => writes.set(k, v));\n      }\n\n      function resetRecoilState(recoilState) {\n        setRecoilState(recoilState, DEFAULT_VALUE$6);\n      }\n\n      const ret = set({\n        set: setRecoilState,\n        get: getRecoilValue,\n        reset: resetRecoilState\n      }, newValue); // set should be a void method, but if the user makes it `async`, then it\n      // will return a Promise, which we don't currently support.\n\n      if (ret !== undefined) {\n        throw Recoil_isPromise(ret) ? Recoil_err('Recoil: Async selector sets are not currently supported.') : Recoil_err('Recoil: selector set should be a void function.');\n      }\n\n      syncSelectorSetFinished = true;\n      return writes;\n    };\n\n    return recoilValue = registerNode$1({\n      key,\n      nodeType: 'selector',\n      peek: selectorPeek,\n      get: selectorGet,\n      set: selectorSet,\n      init: selectorInit,\n      invalidate: invalidateSelector,\n      clearCache: clearSelectorCache,\n      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,\n      dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n      shouldRestoreFromSnapshots: false,\n      retainedBy\n    });\n  } else {\n    return recoilValue = registerNode$1({\n      key,\n      nodeType: 'selector',\n      peek: selectorPeek,\n      get: selectorGet,\n      init: selectorInit,\n      invalidate: invalidateSelector,\n      clearCache: clearSelectorCache,\n      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,\n      dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n      shouldRestoreFromSnapshots: false,\n      retainedBy\n    });\n  }\n}\n/* eslint-enable no-redeclare */\n// $FlowIssue[incompatible-use]\n\n\nselector.value = value => new WrappedValue$1(value);\n\nvar Recoil_selector = selector; // @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';\n// @fb-only: const {scopedAtom} = require('Recoil_ScopedAtom');\n\nconst {\n  isLoadable: isLoadable$2,\n  loadableWithError: loadableWithError$2,\n  loadableWithPromise: loadableWithPromise$2,\n  loadableWithValue: loadableWithValue$3\n} = Recoil_Loadable$1;\nconst {\n  WrappedValue: WrappedValue$2\n} = Recoil_Wrapper$1;\nconst {\n  peekNodeInfo: peekNodeInfo$3\n} = Recoil_FunctionalCore;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$7,\n  DefaultValue: DefaultValue$2,\n  getConfigDeletionHandler: getConfigDeletionHandler$2,\n  registerNode: registerNode$2,\n  setConfigDeletionHandler: setConfigDeletionHandler$1\n} = Recoil_Node;\nconst {\n  isRecoilValue: isRecoilValue$4\n} = Recoil_RecoilValue$1;\nconst {\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$4,\n  markRecoilValueModified: markRecoilValueModified$2,\n  setRecoilValue: setRecoilValue$4,\n  setRecoilValueLoadable: setRecoilValueLoadable$2\n} = Recoil_RecoilValueInterface;\nconst {\n  retainedByOptionWithDefault: retainedByOptionWithDefault$2\n} = Recoil_Retention;\n\nconst unwrap = x => x instanceof WrappedValue$2 ? x.value : x;\n\nfunction baseAtom(options) {\n  const {\n    key,\n    persistence_UNSTABLE: persistence\n  } = options;\n  const retainedBy = retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE);\n  let liveStoresCount = 0;\n\n  function unwrapPromise(promise) {\n    return loadableWithPromise$2(promise.then(value => {\n      defaultLoadable = loadableWithValue$3(value);\n      return value;\n    }).catch(error => {\n      defaultLoadable = loadableWithError$2(error);\n      throw error;\n    }));\n  }\n\n  let defaultLoadable = Recoil_isPromise(options.default) ? unwrapPromise(options.default) : isLoadable$2(options.default) ? options.default.state === 'loading' ? unwrapPromise(options.default.contents) : options.default : loadableWithValue$3(unwrap(options.default));\n  maybeFreezeValueOrPromise(defaultLoadable.contents);\n  let cachedAnswerForUnvalidatedValue = undefined; // Cleanup handlers for this atom\n  // Rely on stable reference equality of the store to use it as a key per <RecoilRoot>\n\n  const cleanupEffectsByStore = new Map();\n\n  function maybeFreezeValueOrPromise(valueOrPromise) {\n    if (true) {\n      if (options.dangerouslyAllowMutability !== true) {\n        if (Recoil_isPromise(valueOrPromise)) {\n          return valueOrPromise.then(value => {\n            Recoil_deepFreezeValue(value);\n            return value;\n          });\n        } else {\n          Recoil_deepFreezeValue(valueOrPromise);\n          return valueOrPromise;\n        }\n      }\n    }\n\n    return valueOrPromise;\n  }\n\n  function wrapPendingPromise(store, promise) {\n    const wrappedPromise = promise.then(value => {\n      var _store$getState$nextT, _state$atomValues$get;\n\n      const state = (_store$getState$nextT = store.getState().nextTree) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree;\n\n      if (((_state$atomValues$get = state.atomValues.get(key)) === null || _state$atomValues$get === void 0 ? void 0 : _state$atomValues$get.contents) === wrappedPromise) {\n        setRecoilValue$4(store, node, value);\n      }\n\n      return value;\n    }).catch(error => {\n      var _store$getState$nextT2, _state$atomValues$get2;\n\n      const state = (_store$getState$nextT2 = store.getState().nextTree) !== null && _store$getState$nextT2 !== void 0 ? _store$getState$nextT2 : store.getState().currentTree;\n\n      if (((_state$atomValues$get2 = state.atomValues.get(key)) === null || _state$atomValues$get2 === void 0 ? void 0 : _state$atomValues$get2.contents) === wrappedPromise) {\n        setRecoilValueLoadable$2(store, node, loadableWithError$2(error));\n      }\n\n      throw error;\n    });\n    return wrappedPromise;\n  }\n\n  function initAtom(store, initState, trigger) {\n    var _options$effects;\n\n    liveStoresCount++;\n\n    const cleanupAtom = () => {\n      var _cleanupEffectsByStor;\n\n      liveStoresCount--;\n      (_cleanupEffectsByStor = cleanupEffectsByStore.get(store)) === null || _cleanupEffectsByStor === void 0 ? void 0 : _cleanupEffectsByStor.forEach(cleanup => cleanup());\n      cleanupEffectsByStore.delete(store);\n    };\n\n    store.getState().knownAtoms.add(key); // Setup async defaults to notify subscribers when they resolve\n\n    if (defaultLoadable.state === 'loading') {\n      const notifyDefaultSubscribers = () => {\n        var _store$getState$nextT3;\n\n        const state = (_store$getState$nextT3 = store.getState().nextTree) !== null && _store$getState$nextT3 !== void 0 ? _store$getState$nextT3 : store.getState().currentTree;\n\n        if (!state.atomValues.has(key)) {\n          markRecoilValueModified$2(store, node);\n        }\n      };\n\n      defaultLoadable.contents.finally(notifyDefaultSubscribers);\n    } ///////////////////\n    // Run Atom Effects\n    ///////////////////\n\n\n    const effects = (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE;\n\n    if (effects != null) {\n      // This state is scoped by Store, since this is in the initAtom() closure\n      let initValue = DEFAULT_VALUE$7;\n      let isDuringInit = true;\n      let isInitError = false;\n      let pendingSetSelf = null;\n\n      function getLoadable(recoilValue) {\n        // Normally we can just get the current value of another atom.\n        // But for our own value we need to check if there is a pending\n        // initialized value or get the fallback default value.\n        if (isDuringInit && recoilValue.key === key) {\n          // Cast T to S\n          const retValue = initValue; // flowlint-line unclear-type:off\n\n          return retValue instanceof DefaultValue$2 ? peekAtom(store, initState) // flowlint-line unclear-type:off\n          : Recoil_isPromise(retValue) ? loadableWithPromise$2(retValue.then(v => v instanceof DefaultValue$2 ? // Cast T to S\n          defaultLoadable.toPromise() // flowlint-line unclear-type:off\n          : v)) : loadableWithValue$3(retValue);\n        }\n\n        return getRecoilValueAsLoadable$4(store, recoilValue);\n      }\n\n      function getPromise(recoilValue) {\n        return getLoadable(recoilValue).toPromise();\n      }\n\n      function getInfo_UNSTABLE(recoilValue) {\n        var _store$getState$nextT4;\n\n        const info = peekNodeInfo$3(store, (_store$getState$nextT4 = store.getState().nextTree) !== null && _store$getState$nextT4 !== void 0 ? _store$getState$nextT4 : store.getState().currentTree, recoilValue.key);\n        return isDuringInit && recoilValue.key === key && !(initValue instanceof DefaultValue$2) ? { ...info,\n          isSet: true,\n          loadable: getLoadable(recoilValue)\n        } : info;\n      }\n\n      const setSelf = effect => valueOrUpdater => {\n        if (isDuringInit) {\n          const currentLoadable = getLoadable(node);\n          const currentValue = currentLoadable.state === 'hasValue' ? currentLoadable.contents : DEFAULT_VALUE$7;\n          initValue = typeof valueOrUpdater === 'function' ? // cast to any because we can't restrict T from being a function without losing support for opaque types\n          valueOrUpdater(currentValue) // flowlint-line unclear-type:off\n          : valueOrUpdater;\n\n          if (Recoil_isPromise(initValue)) {\n            initValue = initValue.then(value => {\n              // Avoid calling onSet() when setSelf() initializes with a Promise\n              pendingSetSelf = {\n                effect,\n                value\n              };\n              return value;\n            });\n          }\n        } else {\n          if (Recoil_isPromise(valueOrUpdater)) {\n            throw Recoil_err('Setting atoms to async values is not implemented.');\n          }\n\n          if (typeof valueOrUpdater !== 'function') {\n            pendingSetSelf = {\n              effect,\n              value: unwrap(valueOrUpdater)\n            };\n          }\n\n          setRecoilValue$4(store, node, typeof valueOrUpdater === 'function' ? currentValue => {\n            const newValue = unwrap( // cast to any because we can't restrict T from being a function without losing support for opaque types\n            valueOrUpdater(currentValue) // flowlint-line unclear-type:off\n            );\n            pendingSetSelf = {\n              effect,\n              value: newValue\n            };\n            return newValue;\n          } : unwrap(valueOrUpdater));\n        }\n      };\n\n      const resetSelf = effect => () => setSelf(effect)(DEFAULT_VALUE$7);\n\n      const onSet = effect => handler => {\n        var _cleanupEffectsByStor2;\n\n        const {\n          release\n        } = store.subscribeToTransactions(currentStore => {\n          var _currentTree$atomValu; // eslint-disable-next-line prefer-const\n\n\n          let {\n            currentTree,\n            previousTree\n          } = currentStore.getState();\n\n          if (!previousTree) {\n            Recoil_recoverableViolation('Transaction subscribers notified without a next tree being present -- this is a bug in Recoil');\n            previousTree = currentTree; // attempt to trundle on\n          }\n\n          const newLoadable = (_currentTree$atomValu = currentTree.atomValues.get(key)) !== null && _currentTree$atomValu !== void 0 ? _currentTree$atomValu : defaultLoadable;\n\n          if (newLoadable.state === 'hasValue') {\n            var _previousTree$atomVal, _pendingSetSelf, _pendingSetSelf2, _pendingSetSelf3;\n\n            const newValue = newLoadable.contents;\n            const oldLoadable = (_previousTree$atomVal = previousTree.atomValues.get(key)) !== null && _previousTree$atomVal !== void 0 ? _previousTree$atomVal : defaultLoadable;\n            const oldValue = oldLoadable.state === 'hasValue' ? oldLoadable.contents : DEFAULT_VALUE$7; // TODO This isn't actually valid, use as a placeholder for now.\n            // Ignore atom value changes that were set via setSelf() in the same effect.\n            // We will still properly call the handler if there was a subsequent\n            // set from something other than an atom effect which was batched\n            // with the `setSelf()` call.  However, we may incorrectly ignore\n            // the handler if the subsequent batched call happens to set the\n            // atom to the exact same value as the `setSelf()`.   But, in that\n            // case, it was kind of a noop, so the semantics are debatable..\n\n            if (((_pendingSetSelf = pendingSetSelf) === null || _pendingSetSelf === void 0 ? void 0 : _pendingSetSelf.effect) !== effect || ((_pendingSetSelf2 = pendingSetSelf) === null || _pendingSetSelf2 === void 0 ? void 0 : _pendingSetSelf2.value) !== newValue) {\n              handler(newValue, oldValue, !currentTree.atomValues.has(key));\n            } else if (((_pendingSetSelf3 = pendingSetSelf) === null || _pendingSetSelf3 === void 0 ? void 0 : _pendingSetSelf3.effect) === effect) {\n              pendingSetSelf = null;\n            }\n          }\n        }, key);\n        cleanupEffectsByStore.set(store, [...((_cleanupEffectsByStor2 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor2 !== void 0 ? _cleanupEffectsByStor2 : []), release]);\n      };\n\n      for (const effect of effects) {\n        try {\n          const cleanup = effect({\n            node,\n            storeID: store.storeID,\n            parentStoreID_UNSTABLE: store.parentStoreID,\n            trigger,\n            setSelf: setSelf(effect),\n            resetSelf: resetSelf(effect),\n            onSet: onSet(effect),\n            getPromise,\n            getLoadable,\n            getInfo_UNSTABLE\n          });\n\n          if (cleanup != null) {\n            var _cleanupEffectsByStor3;\n\n            cleanupEffectsByStore.set(store, [...((_cleanupEffectsByStor3 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor3 !== void 0 ? _cleanupEffectsByStor3 : []), cleanup]);\n          }\n        } catch (error) {\n          initValue = error;\n          isInitError = true;\n        }\n      }\n\n      isDuringInit = false; // Mutate initial state in place since we know there are no other subscribers\n      // since we are the ones initializing on first use.\n\n      if (!(initValue instanceof DefaultValue$2)) {\n        var _store$getState$nextT5;\n\n        const initLoadable = isInitError ? loadableWithError$2(initValue) : Recoil_isPromise(initValue) ? loadableWithPromise$2(wrapPendingPromise(store, initValue)) : loadableWithValue$3(unwrap(initValue));\n        maybeFreezeValueOrPromise(initLoadable.contents);\n        initState.atomValues.set(key, initLoadable); // If there is a pending transaction, then also mutate the next state tree.\n        // This could happen if the atom was first initialized in an action that\n        // also updated some other atom's state.\n\n        (_store$getState$nextT5 = store.getState().nextTree) === null || _store$getState$nextT5 === void 0 ? void 0 : _store$getState$nextT5.atomValues.set(key, initLoadable);\n      }\n    }\n\n    return cleanupAtom;\n  }\n\n  function peekAtom(_store, state) {\n    var _ref, _state$atomValues$get3;\n\n    return (_ref = (_state$atomValues$get3 = state.atomValues.get(key)) !== null && _state$atomValues$get3 !== void 0 ? _state$atomValues$get3 : cachedAnswerForUnvalidatedValue) !== null && _ref !== void 0 ? _ref : defaultLoadable;\n  }\n\n  function getAtom(_store, state) {\n    if (state.atomValues.has(key)) {\n      // Atom value is stored in state:\n      return Recoil_nullthrows(state.atomValues.get(key));\n    } else if (state.nonvalidatedAtoms.has(key)) {\n      // Atom value is stored but needs validation before use.\n      // We might have already validated it and have a cached validated value:\n      if (cachedAnswerForUnvalidatedValue != null) {\n        return cachedAnswerForUnvalidatedValue;\n      }\n\n      if (persistence == null) {\n        Recoil_expectationViolation(`Tried to restore a persisted value for atom ${key} but it has no persistence settings.`);\n        return defaultLoadable;\n      }\n\n      const nonvalidatedValue = state.nonvalidatedAtoms.get(key);\n      const validatorResult = persistence.validator(nonvalidatedValue, DEFAULT_VALUE$7);\n      const validatedValueLoadable = validatorResult instanceof DefaultValue$2 ? defaultLoadable : loadableWithValue$3(validatorResult);\n      cachedAnswerForUnvalidatedValue = validatedValueLoadable;\n      return cachedAnswerForUnvalidatedValue;\n    } else {\n      return defaultLoadable;\n    }\n  }\n\n  function invalidateAtom() {\n    cachedAnswerForUnvalidatedValue = undefined;\n  }\n\n  function setAtom(_store, state, newValue) {\n    // Bail out if we're being set to the existing value, or if we're being\n    // reset but have no stored value (validated or unvalidated) to reset from:\n    if (state.atomValues.has(key)) {\n      const existing = Recoil_nullthrows(state.atomValues.get(key));\n\n      if (existing.state === 'hasValue' && newValue === existing.contents) {\n        return new Map();\n      }\n    } else if (!state.nonvalidatedAtoms.has(key) && newValue instanceof DefaultValue$2) {\n      return new Map();\n    }\n\n    maybeFreezeValueOrPromise(newValue);\n    cachedAnswerForUnvalidatedValue = undefined; // can be released now if it was previously in use\n\n    return new Map().set(key, loadableWithValue$3(newValue));\n  }\n\n  function shouldDeleteConfigOnReleaseAtom() {\n    return getConfigDeletionHandler$2(key) !== undefined && liveStoresCount <= 0;\n  }\n\n  const node = registerNode$2({\n    key,\n    nodeType: 'atom',\n    peek: peekAtom,\n    get: getAtom,\n    set: setAtom,\n    init: initAtom,\n    invalidate: invalidateAtom,\n    shouldDeleteConfigOnRelease: shouldDeleteConfigOnReleaseAtom,\n    dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n    persistence_UNSTABLE: options.persistence_UNSTABLE ? {\n      type: options.persistence_UNSTABLE.type,\n      backButton: options.persistence_UNSTABLE.backButton\n    } : undefined,\n    shouldRestoreFromSnapshots: true,\n    retainedBy\n  });\n  return node;\n} // prettier-ignore\n\n\nfunction atom(options) {\n  if (true) {\n    if (typeof options.key !== 'string') {\n      throw Recoil_err('A key option with a unique string value must be provided when creating an atom.');\n    }\n  }\n\n  const { // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n    ...restOptions\n  } = options;\n  const optionsDefault = 'default' in options ? // $FlowIssue[prop-missing] No way to refine in Flow that property is not defined\n  // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined\n  options.default : new Promise(() => {});\n\n  if (isRecoilValue$4(optionsDefault) // Continue to use atomWithFallback for promise defaults for scoped atoms\n  // for now, since scoped atoms don't support async defaults\n  // @fb-only: || (isPromise(optionsDefault) && scopeRules_APPEND_ONLY_READ_THE_DOCS)\n  // @fb-only: || (isLoadable(optionsDefault) && scopeRules_APPEND_ONLY_READ_THE_DOCS)\n  ) {\n    return atomWithFallback({ ...restOptions,\n      default: optionsDefault // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n\n    }); // @fb-only: } else if (scopeRules_APPEND_ONLY_READ_THE_DOCS\n    // @fb-only: && !isPromise(optionsDefault)\n    // @fb-only: && !isLoadable(optionsDefault)\n    // @fb-only: ) {\n    // @fb-only: return scopedAtom<T>({\n    // @fb-only: ...restOptions,\n    // @fb-only: default: unwrap<T>(optionsDefault),\n    // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n    // @fb-only: });\n  } else {\n    return baseAtom({ ...restOptions,\n      default: optionsDefault\n    });\n  }\n}\n\nfunction atomWithFallback(options) {\n  const base = atom({ ...options,\n    default: DEFAULT_VALUE$7,\n    persistence_UNSTABLE: options.persistence_UNSTABLE === undefined ? undefined : { ...options.persistence_UNSTABLE,\n      validator: storedValue => storedValue instanceof DefaultValue$2 ? storedValue : Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue, DEFAULT_VALUE$7)\n    },\n    // TODO Hack for now.\n    effects: options.effects,\n    // flowlint-line unclear-type: off\n    effects_UNSTABLE: options.effects_UNSTABLE // flowlint-line unclear-type: off\n\n  });\n  const sel = Recoil_selector({\n    key: `${options.key}__withFallback`,\n    get: ({\n      get\n    }) => {\n      const baseValue = get(base);\n      return baseValue instanceof DefaultValue$2 ? options.default : baseValue;\n    },\n    set: ({\n      set\n    }, newValue) => set(base, newValue),\n    // This selector does not need to cache as it is a wrapper selector\n    // and the selector within the wrapper selector will have a cache\n    // option by default\n    cachePolicy_UNSTABLE: {\n      eviction: 'most-recent'\n    },\n    dangerouslyAllowMutability: options.dangerouslyAllowMutability\n  });\n  setConfigDeletionHandler$1(sel.key, getConfigDeletionHandler$2(options.key));\n  return sel;\n}\n\natom.value = value => new WrappedValue$2(value);\n\nvar Recoil_atom = atom;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nclass MapCache {\n  constructor(options) {\n    var _options$mapKey;\n\n    _defineProperty(this, \"_map\", void 0);\n\n    _defineProperty(this, \"_keyMapper\", void 0);\n\n    this._map = new Map();\n    this._keyMapper = (_options$mapKey = options === null || options === void 0 ? void 0 : options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : v => v;\n  }\n\n  size() {\n    return this._map.size;\n  }\n\n  has(key) {\n    return this._map.has(this._keyMapper(key));\n  }\n\n  get(key) {\n    return this._map.get(this._keyMapper(key));\n  }\n\n  set(key, val) {\n    this._map.set(this._keyMapper(key), val);\n  }\n\n  delete(key) {\n    this._map.delete(this._keyMapper(key));\n  }\n\n  clear() {\n    this._map.clear();\n  }\n\n}\n\nvar Recoil_MapCache = {\n  MapCache\n};\nvar Recoil_MapCache_1 = Recoil_MapCache.MapCache;\nvar Recoil_MapCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MapCache: Recoil_MapCache_1\n});\nconst {\n  LRUCache: LRUCache$2\n} = Recoil_LRUCache$1;\nconst {\n  MapCache: MapCache$1\n} = Recoil_MapCache$1;\nconst defaultPolicy$1 = {\n  equality: 'reference',\n  eviction: 'none',\n  maxSize: Infinity\n};\n\nfunction cacheFromPolicy({\n  equality = defaultPolicy$1.equality,\n  eviction = defaultPolicy$1.eviction,\n  maxSize = defaultPolicy$1.maxSize\n} = defaultPolicy$1) {\n  const valueMapper = getValueMapper$1(equality);\n  const cache = getCache(eviction, maxSize, valueMapper);\n  return cache;\n}\n\nfunction getValueMapper$1(equality) {\n  switch (equality) {\n    case 'reference':\n      return val => val;\n\n    case 'value':\n      return val => Recoil_stableStringify(val);\n  }\n\n  throw Recoil_err(`Unrecognized equality policy ${equality}`);\n}\n\nfunction getCache(eviction, maxSize, mapKey) {\n  switch (eviction) {\n    case 'keep-all':\n      return new MapCache$1({\n        mapKey\n      });\n\n    case 'lru':\n      return new LRUCache$2({\n        mapKey,\n        maxSize: Recoil_nullthrows(maxSize)\n      });\n\n    case 'most-recent':\n      return new LRUCache$2({\n        mapKey,\n        maxSize: 1\n      });\n  }\n\n  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);\n}\n\nvar Recoil_cacheFromPolicy = cacheFromPolicy; // @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';\n\nconst {\n  setConfigDeletionHandler: setConfigDeletionHandler$2\n} = Recoil_Node; // Process scopeRules to handle any entries which are functions taking parameters\n// prettier-ignore\n// @fb-only: function mapScopeRules<P>(\n// @fb-only: scopeRules?: ParameterizedScopeRules<P>,\n// @fb-only: param: P,\n// @fb-only: ): ScopeRules | void {\n// @fb-only: return scopeRules?.map(rule =>\n// @fb-only: Array.isArray(rule)\n// @fb-only: ? rule.map(entry => (typeof entry === 'function' ? entry(param) : entry))\n// @fb-only: : rule,\n// @fb-only: );\n// @fb-only: }\n\n/*\r\nA function which returns an atom based on the input parameter.\r\n\r\nEach unique parameter returns a unique atom. E.g.,\r\n\r\n  const f = atomFamily(...);\r\n  f({a: 1}) => an atom\r\n  f({a: 2}) => a different atom\r\n\r\nThis allows components to persist local, private state using atoms.  Each\r\ninstance of the component may have a different key, which it uses as the\r\nparameter for a family of atoms; in this way, each component will have\r\nits own atom not shared by other instances.  These state keys may be composed\r\ninto children's state keys as well.\r\n*/\n\nfunction atomFamily(options) {\n  var _options$cachePolicyF, _options$cachePolicyF2;\n\n  const atomCache = Recoil_cacheFromPolicy({\n    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : 'value',\n    eviction: 'keep-all'\n  }); // Simple atomFamily implementation to cache individual atoms based\n  // on the parameter value equality.\n\n  return params => {\n    var _stableStringify, _options$effects;\n\n    const cachedAtom = atomCache.get(params);\n\n    if (cachedAtom != null) {\n      return cachedAtom;\n    }\n\n    const {\n      cachePolicyForParams_UNSTABLE,\n      ...atomOptions\n    } = options;\n    const optionsDefault = 'default' in options ? // $FlowIssue[prop-missing] No way to refine in Flow that property is not defined\n    // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined\n    options.default : new Promise(() => {});\n    const newAtom = Recoil_atom({ ...atomOptions,\n      key: `${options.key}__${(_stableStringify = Recoil_stableStringify(params)) !== null && _stableStringify !== void 0 ? _stableStringify : 'void'}`,\n      default: typeof optionsDefault === 'function' ? // The default was parameterized\n      // Flow doesn't know that T isn't a function, so we need to case to any\n      // $FlowIssue[incompatible-use]\n      optionsDefault(params) : // Default may be a static value, promise, or RecoilValue\n      optionsDefault,\n      retainedBy_UNSTABLE: typeof options.retainedBy_UNSTABLE === 'function' ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE,\n      effects: typeof options.effects === 'function' ? options.effects(params) : typeof options.effects_UNSTABLE === 'function' ? options.effects_UNSTABLE(params) : (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE // prettier-ignore\n      // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS: mapScopeRules(\n      // @fb-only: options.scopeRules_APPEND_ONLY_READ_THE_DOCS,\n      // @fb-only: params,\n      // @fb-only: ),\n\n    });\n    atomCache.set(params, newAtom);\n    setConfigDeletionHandler$2(newAtom.key, () => {\n      atomCache.delete(params);\n    });\n    return newAtom;\n  };\n}\n\nvar Recoil_atomFamily = atomFamily;\nconst {\n  setConfigDeletionHandler: setConfigDeletionHandler$3\n} = Recoil_Node; // Keep in mind the parameter needs to be serializable as a cahche key\n// using Recoil_stableStringify\n// Add a unique index to each selector in case the cache implementation allows\n// duplicate keys based on equivalent stringified parameters\n\nlet nextIndex = 0;\n/* eslint-disable no-redeclare */\n// Return a function that returns members of a family of selectors of the same type\n// E.g.,\n//\n// const s = selectorFamily(...);\n// s({a: 1}) => a selector\n// s({a: 2}) => a different selector\n//\n// By default, the selectors are distinguished by distinct values of the\n// parameter based on value equality, not reference equality.  This allows using\n// object literals or other equivalent objects at callsites to not create\n// duplicate cache entries.  This behavior may be overridden with the\n// cacheImplementationForParams option.\n\nfunction selectorFamily(options) {\n  var _options$cachePolicyF, _options$cachePolicyF2;\n\n  const selectorCache = Recoil_cacheFromPolicy({\n    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : 'value',\n    eviction: 'keep-all'\n  });\n  return params => {\n    var _stableStringify; // Throw an error with selector key so that it is clear which\n    // selector is causing an error\n\n\n    let cachedSelector;\n\n    try {\n      cachedSelector = selectorCache.get(params);\n    } catch (error) {\n      throw Recoil_err(`Problem with cache lookup for selector ${options.key}: ${error.message}`);\n    }\n\n    if (cachedSelector != null) {\n      return cachedSelector;\n    }\n\n    const myKey = `${options.key}__selectorFamily/${(_stableStringify = Recoil_stableStringify(params, {\n      // It is possible to use functions in parameters if the user uses\n      // a cache with reference equality thanks to the incrementing index.\n      allowFunctions: true\n    })) !== null && _stableStringify !== void 0 ? _stableStringify : 'void'}/${nextIndex++}`; // Append index in case values serialize to the same key string\n\n    const myGet = callbacks => options.get(params)(callbacks);\n\n    const myCachePolicy = options.cachePolicy_UNSTABLE;\n    const retainedBy = typeof options.retainedBy_UNSTABLE === 'function' ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE;\n    let newSelector;\n\n    if (options.set != null) {\n      const set = options.set;\n\n      const mySet = (callbacks, newValue) => set(params)(callbacks, newValue);\n\n      newSelector = Recoil_selector({\n        key: myKey,\n        get: myGet,\n        set: mySet,\n        cachePolicy_UNSTABLE: myCachePolicy,\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n        retainedBy_UNSTABLE: retainedBy\n      });\n    } else {\n      newSelector = Recoil_selector({\n        key: myKey,\n        get: myGet,\n        cachePolicy_UNSTABLE: myCachePolicy,\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n        retainedBy_UNSTABLE: retainedBy\n      });\n    }\n\n    selectorCache.set(params, newSelector);\n    setConfigDeletionHandler$3(newSelector.key, () => {\n      selectorCache.delete(params);\n    });\n    return newSelector;\n  };\n}\n/* eslint-enable no-redeclare */\n\n\nvar Recoil_selectorFamily = selectorFamily; // flowlint-next-line unclear-type:off\n\nconst constantSelector = Recoil_selectorFamily({\n  key: '__constant',\n  get: constant => () => constant,\n  cachePolicyForParams_UNSTABLE: {\n    equality: 'reference'\n  }\n}); // Function that returns a selector which always produces the\n// same constant value.  It may be called multiple times with the\n// same value, based on reference equality, and will provide the\n// same selector.\n\nfunction constSelector(constant) {\n  return constantSelector(constant);\n}\n\nvar Recoil_constSelector = constSelector; // flowlint-next-line unclear-type:off\n\nconst throwingSelector = Recoil_selectorFamily({\n  key: '__error',\n  get: message => () => {\n    throw Recoil_err(message);\n  },\n  // TODO Why?\n  cachePolicyForParams_UNSTABLE: {\n    equality: 'reference'\n  }\n}); // Function that returns a selector which always throws an error\n// with the provided message.\n\nfunction errorSelector(message) {\n  return throwingSelector(message);\n}\n\nvar Recoil_errorSelector = errorSelector;\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * Wraps another recoil value and prevents writing to it.\r\n *\r\n * \r\n * @format\r\n * @oncall recoil\r\n */\n\nfunction readOnlySelector(atom) {\n  // flowlint-next-line unclear-type: off\n  return atom;\n}\n\nvar Recoil_readOnlySelector = readOnlySelector;\nconst {\n  loadableWithError: loadableWithError$3,\n  loadableWithPromise: loadableWithPromise$3,\n  loadableWithValue: loadableWithValue$4\n} = Recoil_Loadable$1; /////////////////\n//  TRUTH TABLE\n/////////////////\n// Dependencies        waitForNone         waitForAny        waitForAll       waitForAllSettled\n//  [loading, loading]  [Promise, Promise]  Promise           Promise         Promise\n//  [value, loading]    [value, Promise]    [value, Promise]  Promise         Promise\n//  [value, value]      [value, value]      [value, value]    [value, value]  [value, value]\n//\n//  [error, loading]    [Error, Promise]    [Error, Promise]  Error           Promise\n//  [error, error]      [Error, Error]      [Error, Error]    Error           [error, error]\n//  [value, error]      [value, Error]      [value, Error]    Error           [value, error]\n// Issue parallel requests for all dependencies and return the current\n// status if they have results, have some error, or are still pending.\n\nfunction concurrentRequests(getRecoilValue, deps) {\n  const results = Array(deps.length).fill(undefined);\n  const exceptions = Array(deps.length).fill(undefined);\n\n  for (const [i, dep] of deps.entries()) {\n    try {\n      results[i] = getRecoilValue(dep);\n    } catch (e) {\n      // exceptions can either be Promises of pending results or real errors\n      exceptions[i] = e;\n    }\n  }\n\n  return [results, exceptions];\n}\n\nfunction isError(exp) {\n  return exp != null && !Recoil_isPromise(exp);\n}\n\nfunction unwrapDependencies(dependencies) {\n  return Array.isArray(dependencies) ? dependencies : Object.getOwnPropertyNames(dependencies).map(key => dependencies[key]);\n}\n\nfunction wrapResults(dependencies,\n/* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\r\n * LTI update could not be added via codemod */\nresults) {\n  return Array.isArray(dependencies) ? results : // Object.getOwnPropertyNames() has consistent key ordering with ES6\n  Object.getOwnPropertyNames(dependencies).reduce((out, key, idx) => ({ ...out,\n    [key]: results[idx]\n  }), {});\n}\n\nfunction wrapLoadables(dependencies, results, exceptions) {\n  const output = exceptions.map((exception, idx) => exception == null ? loadableWithValue$4(results[idx]) : Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));\n  return wrapResults(dependencies, output);\n}\n\nfunction combineAsyncResultsWithSyncResults(syncResults, asyncResults) {\n  return asyncResults.map((result, idx) =>\n  /**\r\n   * it's important we use === undefined as opposed to == null, because the\r\n   * resolved value of the async promise could be `null`, in which case we\r\n   * don't want to use syncResults[idx], which would be undefined. If async\r\n   * promise resolves to `undefined`, that's ok because `syncResults[idx]`\r\n   * will also be `undefined`. That's a little hacky, but it works.\r\n   */\n  result === undefined ? syncResults[idx] : result);\n} // Selector that requests all dependencies in parallel and immediately returns\n// current results without waiting.\n\n\nconst waitForNone = Recoil_selectorFamily({\n  key: '__waitForNone',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // Always return the current status of the results; never block.\n\n    return wrapLoadables(dependencies, results, exceptions);\n  },\n  dangerouslyAllowMutability: true\n}); // Selector that requests all dependencies in parallel and waits for at least\n// one to be available before returning results.  It will only error if all\n// dependencies have errors.\n\nconst waitForAny = Recoil_selectorFamily({\n  key: '__waitForAny',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If any results are available, value or error, return the current status\n\n    if (exceptions.some(exp => !Recoil_isPromise(exp))) {\n      return wrapLoadables(dependencies, results, exceptions);\n    } // Otherwise, return a promise that will resolve when the next result is\n    // available, whichever one happens to be next.  But, if all pending\n    // dependencies end up with errors, then reject the promise.\n\n\n    return new Promise(resolve => {\n      for (const [i, exp] of exceptions.entries()) {\n        if (Recoil_isPromise(exp)) {\n          exp.then(result => {\n            results[i] = result;\n            exceptions[i] = undefined;\n            resolve(wrapLoadables(dependencies, results, exceptions));\n          }).catch(error => {\n            exceptions[i] = error;\n            resolve(wrapLoadables(dependencies, results, exceptions));\n          });\n        }\n      }\n    });\n  },\n  dangerouslyAllowMutability: true\n}); // Selector that requests all dependencies in parallel and waits for all to be\n// available before returning a value.  It will error if any dependencies error.\n\nconst waitForAll = Recoil_selectorFamily({\n  key: '__waitForAll',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results\n\n    if (exceptions.every(exp => exp == null)) {\n      return wrapResults(dependencies, results);\n    } // If we have any errors, throw the first error\n\n\n    const error = exceptions.find(isError);\n\n    if (error != null) {\n      throw error;\n    } // Otherwise, return a promise that will resolve when all results are available\n\n\n    return Promise.all(exceptions).then(exceptionResults => wrapResults(dependencies, combineAsyncResultsWithSyncResults(results, exceptionResults)));\n  },\n  dangerouslyAllowMutability: true\n});\nconst waitForAllSettled = Recoil_selectorFamily({\n  key: '__waitForAllSettled',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results\n\n    if (exceptions.every(exp => !Recoil_isPromise(exp))) {\n      return wrapLoadables(dependencies, results, exceptions);\n    } // Wait for all results to settle\n\n\n    return Promise.all(exceptions.map((exp, i) => Recoil_isPromise(exp) ? exp.then(result => {\n      results[i] = result;\n      exceptions[i] = undefined;\n    }).catch(error => {\n      results[i] = undefined;\n      exceptions[i] = error;\n    }) : null)) // Then wrap them as loadables\n    .then(() => wrapLoadables(dependencies, results, exceptions));\n  },\n  dangerouslyAllowMutability: true\n});\nconst noWait = Recoil_selectorFamily({\n  key: '__noWait',\n  get: dependency => ({\n    get\n  }) => {\n    try {\n      return Recoil_selector.value(loadableWithValue$4(get(dependency)));\n    } catch (exception) {\n      return Recoil_selector.value(Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));\n    }\n  },\n  dangerouslyAllowMutability: true\n});\nvar Recoil_WaitFor = {\n  waitForNone,\n  waitForAny,\n  waitForAll,\n  waitForAllSettled,\n  noWait\n};\nconst {\n  RecoilLoadable\n} = Recoil_Loadable$1;\nconst {\n  DefaultValue: DefaultValue$3\n} = Recoil_Node;\nconst {\n  RecoilRoot: RecoilRoot$2,\n  useRecoilStoreID: useRecoilStoreID$1\n} = Recoil_RecoilRoot;\nconst {\n  isRecoilValue: isRecoilValue$5\n} = Recoil_RecoilValue$1;\nconst {\n  retentionZone: retentionZone$1\n} = Recoil_RetentionZone;\nconst {\n  freshSnapshot: freshSnapshot$2\n} = Recoil_Snapshot$1;\nconst {\n  useRecoilState: useRecoilState$1,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilStateLoadable: useRecoilStateLoadable$1,\n  useRecoilValue: useRecoilValue$1,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilValueLoadable: useRecoilValueLoadable$1,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,\n  useResetRecoilState: useResetRecoilState$1,\n  useSetRecoilState: useSetRecoilState$1\n} = Recoil_Hooks;\nconst {\n  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,\n  useRecoilSnapshot: useRecoilSnapshot$1,\n  useRecoilTransactionObserver: useRecoilTransactionObserver$1\n} = Recoil_SnapshotHooks;\nconst {\n  useRecoilCallback: useRecoilCallback$1\n} = Recoil_useRecoilCallback;\nconst {\n  noWait: noWait$1,\n  waitForAll: waitForAll$1,\n  waitForAllSettled: waitForAllSettled$1,\n  waitForAny: waitForAny$1,\n  waitForNone: waitForNone$1\n} = Recoil_WaitFor;\nvar Recoil_index = {\n  // Types\n  DefaultValue: DefaultValue$3,\n  isRecoilValue: isRecoilValue$5,\n  RecoilLoadable,\n  // Recoil Root\n  RecoilRoot: RecoilRoot$2,\n  useRecoilStoreID: useRecoilStoreID$1,\n  useRecoilBridgeAcrossReactRoots_UNSTABLE: Recoil_useRecoilBridgeAcrossReactRoots,\n  // Atoms/Selectors\n  atom: Recoil_atom,\n  selector: Recoil_selector,\n  // Convenience Atoms/Selectors\n  atomFamily: Recoil_atomFamily,\n  selectorFamily: Recoil_selectorFamily,\n  constSelector: Recoil_constSelector,\n  errorSelector: Recoil_errorSelector,\n  readOnlySelector: Recoil_readOnlySelector,\n  // Concurrency Helpers for Atoms/Selectors\n  noWait: noWait$1,\n  waitForNone: waitForNone$1,\n  waitForAny: waitForAny$1,\n  waitForAll: waitForAll$1,\n  waitForAllSettled: waitForAllSettled$1,\n  // Hooks for Atoms/Selectors\n  useRecoilValue: useRecoilValue$1,\n  useRecoilValueLoadable: useRecoilValueLoadable$1,\n  useRecoilState: useRecoilState$1,\n  useRecoilStateLoadable: useRecoilStateLoadable$1,\n  useSetRecoilState: useSetRecoilState$1,\n  useResetRecoilState: useResetRecoilState$1,\n  useGetRecoilValueInfo_UNSTABLE: Recoil_useGetRecoilValueInfo,\n  useRecoilRefresher_UNSTABLE: Recoil_useRecoilRefresher,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,\n  // Hooks for complex operations\n  useRecoilCallback: useRecoilCallback$1,\n  useRecoilTransaction_UNSTABLE: Recoil_useRecoilTransaction,\n  // Snapshots\n  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,\n  useRecoilSnapshot: useRecoilSnapshot$1,\n  useRecoilTransactionObserver_UNSTABLE: useRecoilTransactionObserver$1,\n  snapshot_UNSTABLE: freshSnapshot$2,\n  // Memory Management\n  useRetain: Recoil_useRetain,\n  retentionZone: retentionZone$1\n};\nvar Recoil_index_1 = Recoil_index.DefaultValue;\nvar Recoil_index_2 = Recoil_index.isRecoilValue;\nvar Recoil_index_3 = Recoil_index.RecoilLoadable;\nvar Recoil_index_4 = Recoil_index.RecoilRoot;\nvar Recoil_index_5 = Recoil_index.useRecoilStoreID;\nvar Recoil_index_6 = Recoil_index.useRecoilBridgeAcrossReactRoots_UNSTABLE;\nvar Recoil_index_7 = Recoil_index.atom;\nvar Recoil_index_8 = Recoil_index.selector;\nvar Recoil_index_9 = Recoil_index.atomFamily;\nvar Recoil_index_10 = Recoil_index.selectorFamily;\nvar Recoil_index_11 = Recoil_index.constSelector;\nvar Recoil_index_12 = Recoil_index.errorSelector;\nvar Recoil_index_13 = Recoil_index.readOnlySelector;\nvar Recoil_index_14 = Recoil_index.noWait;\nvar Recoil_index_15 = Recoil_index.waitForNone;\nvar Recoil_index_16 = Recoil_index.waitForAny;\nvar Recoil_index_17 = Recoil_index.waitForAll;\nvar Recoil_index_18 = Recoil_index.waitForAllSettled;\nvar Recoil_index_19 = Recoil_index.useRecoilValue;\nvar Recoil_index_20 = Recoil_index.useRecoilValueLoadable;\nvar Recoil_index_21 = Recoil_index.useRecoilState;\nvar Recoil_index_22 = Recoil_index.useRecoilStateLoadable;\nvar Recoil_index_23 = Recoil_index.useSetRecoilState;\nvar Recoil_index_24 = Recoil_index.useResetRecoilState;\nvar Recoil_index_25 = Recoil_index.useGetRecoilValueInfo_UNSTABLE;\nvar Recoil_index_26 = Recoil_index.useRecoilRefresher_UNSTABLE;\nvar Recoil_index_27 = Recoil_index.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_28 = Recoil_index.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_29 = Recoil_index.useRecoilState_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_30 = Recoil_index.useRecoilCallback;\nvar Recoil_index_31 = Recoil_index.useRecoilTransaction_UNSTABLE;\nvar Recoil_index_32 = Recoil_index.useGotoRecoilSnapshot;\nvar Recoil_index_33 = Recoil_index.useRecoilSnapshot;\nvar Recoil_index_34 = Recoil_index.useRecoilTransactionObserver_UNSTABLE;\nvar Recoil_index_35 = Recoil_index.snapshot_UNSTABLE;\nvar Recoil_index_36 = Recoil_index.useRetain;\nvar Recoil_index_37 = Recoil_index.retentionZone;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Recoil_index);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM3aEIsMENBQW5DO0FBQ0EsSUFBSWlrQixlQUFlLEdBQUdwQyxZQUFZLENBQUM3YSxpQkFBbkM7QUFDQSxJQUFJa2QsZUFBZSxHQUFHckMsWUFBWSxDQUFDSSw2QkFBbkM7QUFDQSxJQUFJa0MsZUFBZSxHQUFHdEMsWUFBWSxDQUFDeGUscUJBQW5DO0FBQ0EsSUFBSStnQixlQUFlLEdBQUd2QyxZQUFZLENBQUNwZixpQkFBbkM7QUFDQSxJQUFJNGhCLGVBQWUsR0FBR3hDLFlBQVksQ0FBQ0sscUNBQW5DO0FBQ0EsSUFBSW9DLGVBQWUsR0FBR3pDLFlBQVksQ0FBQ00saUJBQW5DO0FBQ0EsSUFBSW9DLGVBQWUsR0FBRzFDLFlBQVksQ0FBQ2xuQixTQUFuQztBQUNBLElBQUk2cEIsZUFBZSxHQUFHM0MsWUFBWSxDQUFDcitCLGFBQW5DO0FBRUEsK0RBQWVxK0IsWUFBZiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVjb2lsL2VzL2luZGV4LmpzPzNhNjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHJlYWN0RG9tIGZyb20gJ3JlYWN0LWRvbSc7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gZXJyKG1lc3NhZ2UpIHtcclxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTsgLy8gSW4gVjgsIEVycm9yIG9iamVjdHMga2VlcCB0aGUgY2xvc3VyZSBzY29wZSBjaGFpbiBhbGl2ZSB1bnRpbCB0aGVcclxuICAvLyBlcnIuc3RhY2sgcHJvcGVydHkgaXMgYWNjZXNzZWQuXHJcblxyXG4gIGlmIChlcnJvci5zdGFjayA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAvLyBJRSBzZXRzIHRoZSBzdGFjayBvbmx5IGlmIGVycm9yIGlzIHRocm93blxyXG4gICAgdHJ5IHtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9IGNhdGNoIChfKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZiLXd3dy9uby11bnVzZWQtY2F0Y2gtYmluZGluZ3MsIG5vLWVtcHR5XHJcblxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVycm9yO1xyXG59XHJcblxyXG52YXIgZXJyXzEgPSBlcnI7XHJcblxyXG4vLyBAb3NzLW9ubHlcclxuXHJcblxyXG52YXIgUmVjb2lsX2VyciA9IGVycl8xO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuXHJcbi8vIFNwbGl0IGRlY2xhcmF0aW9uIGFuZCBpbXBsZW1lbnRhdGlvbiB0byBhbGxvdyB0aGlzIGZ1bmN0aW9uIHRvIHByZXRlbmQgdG9cclxuLy8gY2hlY2sgZm9yIGFjdHVhbCBpbnN0YW5jZSBvZiBQcm9taXNlIGluc3RlYWQgb2Ygc29tZXRoaW5nIHdpdGggYSBgdGhlbmBcclxuLy8gbWV0aG9kLlxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXHJcbmZ1bmN0aW9uIGlzUHJvbWlzZShwKSB7XHJcbiAgcmV0dXJuICEhcCAmJiB0eXBlb2YgcC50aGVuID09PSAnZnVuY3Rpb24nO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX2lzUHJvbWlzZSA9IGlzUHJvbWlzZTtcclxuXHJcbmZ1bmN0aW9uIG51bGx0aHJvd3MoeCwgbWVzc2FnZSkge1xyXG4gIGlmICh4ICE9IG51bGwpIHtcclxuICAgIHJldHVybiB4O1xyXG4gIH1cclxuXHJcbiAgdGhyb3cgUmVjb2lsX2VycihtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAnR290IHVuZXhwZWN0ZWQgbnVsbCBvciB1bmRlZmluZWQnKTtcclxufVxyXG5cclxudmFyIFJlY29pbF9udWxsdGhyb3dzID0gbnVsbHRocm93cztcclxuXHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcclxuICBpZiAoa2V5IGluIG9iaikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIG9ialtrZXldID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG5jbGFzcyBCYXNlTG9hZGFibGUge1xyXG4gIGdldFZhbHVlKCkge1xyXG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XHJcbiAgfVxyXG5cclxuICB0b1Byb21pc2UoKSB7XHJcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcclxuICB9XHJcblxyXG4gIHZhbHVlTWF5YmUoKSB7XHJcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcclxuICB9XHJcblxyXG4gIHZhbHVlT3JUaHJvdygpIHtcclxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxyXG4gICAgdGhyb3cgUmVjb2lsX2VycihgTG9hZGFibGUgZXhwZWN0ZWQgdmFsdWUsIGJ1dCBpbiBcIiR7dGhpcy5zdGF0ZX1cIiBzdGF0ZWApO1xyXG4gIH1cclxuXHJcbiAgcHJvbWlzZU1heWJlKCkge1xyXG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XHJcbiAgfVxyXG5cclxuICBwcm9taXNlT3JUaHJvdygpIHtcclxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxyXG4gICAgdGhyb3cgUmVjb2lsX2VycihgTG9hZGFibGUgZXhwZWN0ZWQgcHJvbWlzZSwgYnV0IGluIFwiJHt0aGlzLnN0YXRlfVwiIHN0YXRlYCk7XHJcbiAgfVxyXG5cclxuICBlcnJvck1heWJlKCkge1xyXG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XHJcbiAgfVxyXG5cclxuICBlcnJvck9yVGhyb3coKSB7XHJcbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cclxuICAgIHRocm93IFJlY29pbF9lcnIoYExvYWRhYmxlIGV4cGVjdGVkIGVycm9yLCBidXQgaW4gXCIke3RoaXMuc3RhdGV9XCIgc3RhdGVgKTtcclxuICB9XHJcblxyXG4gIGlzKG90aGVyKSB7XHJcbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cclxuICAgIHJldHVybiBvdGhlci5zdGF0ZSA9PT0gdGhpcy5zdGF0ZSAmJiBvdGhlci5jb250ZW50cyA9PT0gdGhpcy5jb250ZW50cztcclxuICB9XHJcblxyXG4gIG1hcChfbWFwKSB7XHJcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcclxuICB9XHJcblxyXG59XHJcblxyXG5jbGFzcyBWYWx1ZUxvYWRhYmxlIGV4dGVuZHMgQmFzZUxvYWRhYmxlIHtcclxuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCAnaGFzVmFsdWUnKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZW50c1wiLCB2b2lkIDApO1xyXG5cclxuICAgIHRoaXMuY29udGVudHMgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIGdldFZhbHVlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XHJcbiAgfVxyXG5cclxuICB0b1Byb21pc2UoKSB7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29udGVudHMpO1xyXG4gIH1cclxuXHJcbiAgdmFsdWVNYXliZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzO1xyXG4gIH1cclxuXHJcbiAgdmFsdWVPclRocm93KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XHJcbiAgfVxyXG5cclxuICBwcm9taXNlTWF5YmUoKSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgZXJyb3JNYXliZSgpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBtYXAobWFwKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBuZXh0ID0gbWFwKHRoaXMuY29udGVudHMpO1xyXG4gICAgICByZXR1cm4gUmVjb2lsX2lzUHJvbWlzZShuZXh0KSA/IGxvYWRhYmxlV2l0aFByb21pc2UobmV4dCkgOiBpc0xvYWRhYmxlKG5leHQpID8gbmV4dCA6IGxvYWRhYmxlV2l0aFZhbHVlKG5leHQpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICByZXR1cm4gUmVjb2lsX2lzUHJvbWlzZShlKSA/IC8vIElmIHdlIFwic3VzcGVuZGVkXCIsIHRoZW4gdHJ5IGFnYWluLlxyXG4gICAgICAvLyBlcnJvcnMgYW5kIHN1YnNlcXVlbnQgcmV0cmllcyB3aWxsIGJlIGhhbmRsZWQgaW4gJ2xvYWRpbmcnIGNhc2VcclxuICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXHJcbiAgICAgIGxvYWRhYmxlV2l0aFByb21pc2UoZS5uZXh0KCgpID0+IHRoaXMubWFwKG1hcCkpKSA6IGxvYWRhYmxlV2l0aEVycm9yKGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIEVycm9yTG9hZGFibGUgZXh0ZW5kcyBCYXNlTG9hZGFibGUge1xyXG4gIGNvbnN0cnVjdG9yKGVycm9yKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsICdoYXNFcnJvcicpO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRlbnRzXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy5jb250ZW50cyA9IGVycm9yO1xyXG4gIH1cclxuXHJcbiAgZ2V0VmFsdWUoKSB7XHJcbiAgICB0aHJvdyB0aGlzLmNvbnRlbnRzO1xyXG4gIH1cclxuXHJcbiAgdG9Qcm9taXNlKCkge1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuY29udGVudHMpO1xyXG4gIH1cclxuXHJcbiAgdmFsdWVNYXliZSgpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBwcm9taXNlTWF5YmUoKSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgZXJyb3JNYXliZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzO1xyXG4gIH1cclxuXHJcbiAgZXJyb3JPclRocm93KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XHJcbiAgfVxyXG5cclxuICBtYXAoX21hcCkge1xyXG4gICAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuY2xhc3MgTG9hZGluZ0xvYWRhYmxlIGV4dGVuZHMgQmFzZUxvYWRhYmxlIHtcclxuICBjb25zdHJ1Y3Rvcihwcm9taXNlKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsICdsb2FkaW5nJyk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGVudHNcIiwgdm9pZCAwKTtcclxuXHJcbiAgICB0aGlzLmNvbnRlbnRzID0gcHJvbWlzZTtcclxuICB9XHJcblxyXG4gIGdldFZhbHVlKCkge1xyXG4gICAgdGhyb3cgdGhpcy5jb250ZW50cztcclxuICB9XHJcblxyXG4gIHRvUHJvbWlzZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzO1xyXG4gIH1cclxuXHJcbiAgdmFsdWVNYXliZSgpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBwcm9taXNlTWF5YmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcclxuICB9XHJcblxyXG4gIHByb21pc2VPclRocm93KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XHJcbiAgfVxyXG5cclxuICBlcnJvck1heWJlKCkge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIG1hcChtYXApIHtcclxuICAgIHJldHVybiBsb2FkYWJsZVdpdGhQcm9taXNlKHRoaXMuY29udGVudHMudGhlbih2YWx1ZSA9PiB7XHJcbiAgICAgIGNvbnN0IG5leHQgPSBtYXAodmFsdWUpO1xyXG5cclxuICAgICAgaWYgKGlzTG9hZGFibGUobmV4dCkpIHtcclxuICAgICAgICBjb25zdCBuZXh0TG9hZGFibGUgPSBuZXh0O1xyXG5cclxuICAgICAgICBzd2l0Y2ggKG5leHRMb2FkYWJsZS5zdGF0ZSkge1xyXG4gICAgICAgICAgY2FzZSAnaGFzVmFsdWUnOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV4dExvYWRhYmxlLmNvbnRlbnRzO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ2hhc0Vycm9yJzpcclxuICAgICAgICAgICAgdGhyb3cgbmV4dExvYWRhYmxlLmNvbnRlbnRzO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ2xvYWRpbmcnOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV4dExvYWRhYmxlLmNvbnRlbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgfSAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1yZXR1cm5dXHJcblxyXG5cclxuICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UoZSkpIHtcclxuICAgICAgICAvLyB3ZSB3ZXJlIFwic3VzcGVuZGVkLFwiIHRyeSBhZ2FpblxyXG4gICAgICAgIHJldHVybiBlLnRoZW4oKCkgPT4gdGhpcy5tYXAobWFwKS5jb250ZW50cyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IGU7XHJcbiAgICB9KSk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gbG9hZGFibGVXaXRoVmFsdWUodmFsdWUpIHtcclxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuZXcgVmFsdWVMb2FkYWJsZSh2YWx1ZSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsb2FkYWJsZVdpdGhFcnJvcihlcnJvcikge1xyXG4gIHJldHVybiBPYmplY3QuZnJlZXplKG5ldyBFcnJvckxvYWRhYmxlKGVycm9yKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvYWRhYmxlV2l0aFByb21pc2UocHJvbWlzZSkge1xyXG4gIHJldHVybiBPYmplY3QuZnJlZXplKG5ldyBMb2FkaW5nTG9hZGFibGUocHJvbWlzZSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsb2FkYWJsZUxvYWRpbmcoKSB7XHJcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobmV3IExvYWRpbmdMb2FkYWJsZShuZXcgUHJvbWlzZSgoKSA9PiB7fSkpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbG9hZGFibGVBbGxBcnJheShpbnB1dHMpIHtcclxuICByZXR1cm4gaW5wdXRzLmV2ZXJ5KGkgPT4gaS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJykgPyBsb2FkYWJsZVdpdGhWYWx1ZShpbnB1dHMubWFwKGkgPT4gaS5jb250ZW50cykpIDogaW5wdXRzLnNvbWUoaSA9PiBpLnN0YXRlID09PSAnaGFzRXJyb3InKSA/IGxvYWRhYmxlV2l0aEVycm9yKFJlY29pbF9udWxsdGhyb3dzKGlucHV0cy5maW5kKGkgPT4gaS5zdGF0ZSA9PT0gJ2hhc0Vycm9yJyksICdJbnZhbGlkIGxvYWRhYmxlIHBhc3NlZCB0byBsb2FkYWJsZUFsbCcpLmNvbnRlbnRzKSA6IGxvYWRhYmxlV2l0aFByb21pc2UoUHJvbWlzZS5hbGwoaW5wdXRzLm1hcChpID0+IGkuY29udGVudHMpKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvYWRhYmxlQWxsKGlucHV0cykge1xyXG4gIGNvbnN0IHVud3JhcGVkSW5wdXRzID0gQXJyYXkuaXNBcnJheShpbnB1dHMpID8gaW5wdXRzIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5wdXRzKS5tYXAoa2V5ID0+IGlucHV0c1trZXldKTtcclxuICBjb25zdCBub3JtYWxpemVkSW5wdXRzID0gdW53cmFwZWRJbnB1dHMubWFwKHggPT4gaXNMb2FkYWJsZSh4KSA/IHggOiBSZWNvaWxfaXNQcm9taXNlKHgpID8gbG9hZGFibGVXaXRoUHJvbWlzZSh4KSA6IGxvYWRhYmxlV2l0aFZhbHVlKHgpKTtcclxuICBjb25zdCBvdXRwdXQgPSBsb2FkYWJsZUFsbEFycmF5KG5vcm1hbGl6ZWRJbnB1dHMpO1xyXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0cykgPyAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1yZXR1cm5dXHJcbiAgb3V0cHV0IDogLy8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoKSBoYXMgY29uc2lzdGVudCBrZXkgb3JkZXJpbmcgd2l0aCBFUzZcclxuICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1jYWxsXVxyXG4gIG91dHB1dC5tYXAob3V0cHV0cyA9PiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbnB1dHMpLnJlZHVjZSgob3V0LCBrZXksIGlkeCkgPT4gKHsgLi4ub3V0LFxyXG4gICAgW2tleV06IG91dHB1dHNbaWR4XVxyXG4gIH0pLCB7fSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0xvYWRhYmxlKHgpIHtcclxuICByZXR1cm4geCBpbnN0YW5jZW9mIEJhc2VMb2FkYWJsZTtcclxufVxyXG5cclxuY29uc3QgTG9hZGFibGVTdGF0aWNJbnRlcmZhY2UgPSB7XHJcbiAgb2Y6IHZhbHVlID0+IFJlY29pbF9pc1Byb21pc2UodmFsdWUpID8gbG9hZGFibGVXaXRoUHJvbWlzZSh2YWx1ZSkgOiBpc0xvYWRhYmxlKHZhbHVlKSA/IHZhbHVlIDogbG9hZGFibGVXaXRoVmFsdWUodmFsdWUpLFxyXG4gIGVycm9yOiBlcnJvciA9PiBsb2FkYWJsZVdpdGhFcnJvcihlcnJvciksXHJcbiAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxyXG4gIGxvYWRpbmc6ICgpID0+IGxvYWRhYmxlTG9hZGluZygpLFxyXG4gIC8vICRGbG93SXNzdWVbdW5jbGVhci10eXBlXVxyXG4gIGFsbDogbG9hZGFibGVBbGwsXHJcbiAgaXNMb2FkYWJsZVxyXG59O1xyXG52YXIgUmVjb2lsX0xvYWRhYmxlID0ge1xyXG4gIGxvYWRhYmxlV2l0aFZhbHVlLFxyXG4gIGxvYWRhYmxlV2l0aEVycm9yLFxyXG4gIGxvYWRhYmxlV2l0aFByb21pc2UsXHJcbiAgbG9hZGFibGVMb2FkaW5nLFxyXG4gIGxvYWRhYmxlQWxsLFxyXG4gIGlzTG9hZGFibGUsXHJcbiAgUmVjb2lsTG9hZGFibGU6IExvYWRhYmxlU3RhdGljSW50ZXJmYWNlXHJcbn07XHJcblxyXG52YXIgUmVjb2lsX0xvYWRhYmxlXzEgPSBSZWNvaWxfTG9hZGFibGUubG9hZGFibGVXaXRoVmFsdWU7XHJcbnZhciBSZWNvaWxfTG9hZGFibGVfMiA9IFJlY29pbF9Mb2FkYWJsZS5sb2FkYWJsZVdpdGhFcnJvcjtcclxudmFyIFJlY29pbF9Mb2FkYWJsZV8zID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlV2l0aFByb21pc2U7XHJcbnZhciBSZWNvaWxfTG9hZGFibGVfNCA9IFJlY29pbF9Mb2FkYWJsZS5sb2FkYWJsZUxvYWRpbmc7XHJcbnZhciBSZWNvaWxfTG9hZGFibGVfNSA9IFJlY29pbF9Mb2FkYWJsZS5sb2FkYWJsZUFsbDtcclxudmFyIFJlY29pbF9Mb2FkYWJsZV82ID0gUmVjb2lsX0xvYWRhYmxlLmlzTG9hZGFibGU7XHJcbnZhciBSZWNvaWxfTG9hZGFibGVfNyA9IFJlY29pbF9Mb2FkYWJsZS5SZWNvaWxMb2FkYWJsZTtcclxuXHJcbnZhciBSZWNvaWxfTG9hZGFibGUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgbG9hZGFibGVXaXRoVmFsdWU6IFJlY29pbF9Mb2FkYWJsZV8xLFxyXG4gIGxvYWRhYmxlV2l0aEVycm9yOiBSZWNvaWxfTG9hZGFibGVfMixcclxuICBsb2FkYWJsZVdpdGhQcm9taXNlOiBSZWNvaWxfTG9hZGFibGVfMyxcclxuICBsb2FkYWJsZUxvYWRpbmc6IFJlY29pbF9Mb2FkYWJsZV80LFxyXG4gIGxvYWRhYmxlQWxsOiBSZWNvaWxfTG9hZGFibGVfNSxcclxuICBpc0xvYWRhYmxlOiBSZWNvaWxfTG9hZGFibGVfNixcclxuICBSZWNvaWxMb2FkYWJsZTogUmVjb2lsX0xvYWRhYmxlXzdcclxufSk7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG5cclxuY29uc3QgZ2tzID0gbmV3IE1hcCgpLnNldCgncmVjb2lsX2hhbXRfMjAyMCcsIHRydWUpLnNldCgncmVjb2lsX3N5bmNfZXh0ZXJuYWxfc3RvcmUnLCB0cnVlKS5zZXQoJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycsIHRydWUpLnNldCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnLCB0cnVlKTtcclxuXHJcbmZ1bmN0aW9uIFJlY29pbF9na3hfT1NTKGdrKSB7XHJcbiAgdmFyIF9na3MkZ2V0O1xyXG5cclxuICByZXR1cm4gKF9na3MkZ2V0ID0gZ2tzLmdldChnaykpICE9PSBudWxsICYmIF9na3MkZ2V0ICE9PSB2b2lkIDAgPyBfZ2tzJGdldCA6IGZhbHNlO1xyXG59XHJcblxyXG5SZWNvaWxfZ2t4X09TUy5zZXRQYXNzID0gZ2sgPT4ge1xyXG4gIGdrcy5zZXQoZ2ssIHRydWUpO1xyXG59O1xyXG5cclxuUmVjb2lsX2dreF9PU1Muc2V0RmFpbCA9IGdrID0+IHtcclxuICBna3Muc2V0KGdrLCBmYWxzZSk7XHJcbn07XHJcblxyXG5SZWNvaWxfZ2t4X09TUy5jbGVhciA9ICgpID0+IHtcclxuICBna3MuY2xlYXIoKTtcclxufTtcclxuXHJcbnZhciBSZWNvaWxfZ2t4ID0gUmVjb2lsX2dreF9PU1M7IC8vIEBvc3Mtb25seVxyXG5cclxudmFyIF9jcmVhdGVNdXRhYmxlU291cmNlLCBfdXNlTXV0YWJsZVNvdXJjZSwgX3VzZVN5bmNFeHRlcm5hbFN0b3JlO1xyXG5cclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IGNyZWF0ZU11dGFibGVTb3VyY2UgPSAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxyXG4oX2NyZWF0ZU11dGFibGVTb3VyY2UgPSByZWFjdC5jcmVhdGVNdXRhYmxlU291cmNlKSAhPT0gbnVsbCAmJiBfY3JlYXRlTXV0YWJsZVNvdXJjZSAhPT0gdm9pZCAwID8gX2NyZWF0ZU11dGFibGVTb3VyY2UgOiByZWFjdC51bnN0YWJsZV9jcmVhdGVNdXRhYmxlU291cmNlO1xyXG5jb25zdCB1c2VNdXRhYmxlU291cmNlID0gLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcclxuKF91c2VNdXRhYmxlU291cmNlID0gcmVhY3QudXNlTXV0YWJsZVNvdXJjZSkgIT09IG51bGwgJiYgX3VzZU11dGFibGVTb3VyY2UgIT09IHZvaWQgMCA/IF91c2VNdXRhYmxlU291cmNlIDogcmVhY3QudW5zdGFibGVfdXNlTXV0YWJsZVNvdXJjZTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0d2cvcmVhY3QtMTgvZGlzY3Vzc2lvbnMvODZcclxuXHJcbmNvbnN0IHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcclxuKF91c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IHJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlKSAhPT0gbnVsbCAmJiBfdXNlU3luY0V4dGVybmFsU3RvcmUgIT09IHZvaWQgMCA/IF91c2VTeW5jRXh0ZXJuYWxTdG9yZSA6IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXHJcbnJlYWN0LnVuc3RhYmxlX3VzZVN5bmNFeHRlcm5hbFN0b3JlO1xyXG5cclxuLyoqXHJcbiAqIG1vZGU6IFRoZSBSZWFjdCBBUEkgYW5kIGFwcHJvYWNoIHRvIHVzZSBmb3Igc3luY2luZyBzdGF0ZSB3aXRoIFJlYWN0XHJcbiAqIGVhcmx5OiBSZS1yZW5kZXJzIGZyb20gUmVjb2lsIHVwZGF0ZXMgb2NjdXI6XHJcbiAqICAgIDEpIGVhcmxpZXJcclxuICogICAgMikgaW4gc3luYyB3aXRoIFJlYWN0IHVwZGF0ZXMgaW4gdGhlIHNhbWUgYmF0Y2hcclxuICogICAgMykgYmVmb3JlIHRyYW5zYWN0aW9uIG9ic2VydmVycyBpbnN0ZWFkIG9mIGFmdGVyLlxyXG4gKiBjb25jdXJyZW50OiBJcyB0aGUgY3VycmVudCBtb2RlIGNvbXBhdGlibGUgd2l0aCBDb25jdXJyZW50IE1vZGUgYW5kIHVzZVRyYW5zaXRpb24oKVxyXG4gKi9cclxuZnVuY3Rpb24gcmVhY3RNb2RlKCkge1xyXG4gIC8vIE5PVEU6IFRoaXMgbW9kZSBpcyBjdXJyZW50bHkgYnJva2VuIHdpdGggc29tZSBTdXNwZW5zZSBjYXNlc1xyXG4gIC8vIHNlZSBSZWNvaWxfc2VsZWN0b3ItdGVzdC5qc1xyXG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfdHJhbnNpdGlvbl9zdXBwb3J0JykpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG1vZGU6ICdUUkFOU0lUSU9OX1NVUFBPUlQnLFxyXG4gICAgICBlYXJseTogdHJ1ZSxcclxuICAgICAgY29uY3VycmVudDogdHJ1ZVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfc3luY19leHRlcm5hbF9zdG9yZScpICYmIHVzZVN5bmNFeHRlcm5hbFN0b3JlICE9IG51bGwpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG1vZGU6ICdTWU5DX0VYVEVSTkFMX1NUT1JFJyxcclxuICAgICAgZWFybHk6IHRydWUsXHJcbiAgICAgIGNvbmN1cnJlbnQ6IGZhbHNlXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tdXRhYmxlX3NvdXJjZScpICYmIHVzZU11dGFibGVTb3VyY2UgIT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LiRkaXNhYmxlUmVjb2lsVmFsdWVNdXRhYmxlU291cmNlX1RFTVBfSEFDS19ET19OT1RfVVNFKSB7XHJcbiAgICByZXR1cm4gUmVjb2lsX2dreCgncmVjb2lsX3N1cHByZXNzX3JlcmVuZGVyX2luX2NhbGxiYWNrJykgPyB7XHJcbiAgICAgIG1vZGU6ICdNVVRBQkxFX1NPVVJDRScsXHJcbiAgICAgIGVhcmx5OiB0cnVlLFxyXG4gICAgICBjb25jdXJyZW50OiB0cnVlXHJcbiAgICB9IDoge1xyXG4gICAgICBtb2RlOiAnTVVUQUJMRV9TT1VSQ0UnLFxyXG4gICAgICBlYXJseTogZmFsc2UsXHJcbiAgICAgIGNvbmN1cnJlbnQ6IGZhbHNlXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFJlY29pbF9na3goJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycpID8ge1xyXG4gICAgbW9kZTogJ0xFR0FDWScsXHJcbiAgICBlYXJseTogdHJ1ZSxcclxuICAgIGNvbmN1cnJlbnQ6IGZhbHNlXHJcbiAgfSA6IHtcclxuICAgIG1vZGU6ICdMRUdBQ1knLFxyXG4gICAgZWFybHk6IGZhbHNlLFxyXG4gICAgY29uY3VycmVudDogZmFsc2VcclxuICB9O1xyXG59IC8vIFRPRE8gTmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoZXJlIGlzIGEgc3RhbmRhcmQvb3Blbi1zb3VyY2UgZXF1aXZhbGVudCB0byBzZWUgaWYgaG90IG1vZHVsZSByZXBsYWNlbWVudCBpcyBoYXBwZW5pbmc6XHJcblxyXG5cclxuZnVuY3Rpb24gaXNGYXN0UmVmcmVzaEVuYWJsZWQoKSB7XHJcbiAgLy8gQGZiLW9ubHk6IGNvbnN0IHtpc0FjY2VwdGluZ1VwZGF0ZX0gPSByZXF1aXJlKCdfX2RlYnVnJyk7XHJcbiAgLy8gQGZiLW9ubHk6IHJldHVybiB0eXBlb2YgaXNBY2NlcHRpbmdVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaXNBY2NlcHRpbmdVcGRhdGUoKTtcclxuICByZXR1cm4gZmFsc2U7IC8vIEBvc3Mtb25seVxyXG59XHJcblxyXG52YXIgUmVjb2lsX1JlYWN0TW9kZSA9IHtcclxuICBjcmVhdGVNdXRhYmxlU291cmNlLFxyXG4gIHVzZU11dGFibGVTb3VyY2UsXHJcbiAgdXNlU3luY0V4dGVybmFsU3RvcmUsXHJcbiAgcmVhY3RNb2RlLFxyXG4gIGlzRmFzdFJlZnJlc2hFbmFibGVkXHJcbn07XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXHJcbmNsYXNzIEFic3RyYWN0UmVjb2lsVmFsdWUge1xyXG4gIGNvbnN0cnVjdG9yKG5ld0tleSkge1xyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5XCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy5rZXkgPSBuZXdLZXk7XHJcbiAgfVxyXG5cclxuICB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBrZXk6IHRoaXMua2V5XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIFJlY29pbFN0YXRlIGV4dGVuZHMgQWJzdHJhY3RSZWNvaWxWYWx1ZSB7fVxyXG5cclxuY2xhc3MgUmVjb2lsVmFsdWVSZWFkT25seSBleHRlbmRzIEFic3RyYWN0UmVjb2lsVmFsdWUge31cclxuXHJcbmZ1bmN0aW9uIGlzUmVjb2lsVmFsdWUoeCkge1xyXG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVjb2lsU3RhdGUgfHwgeCBpbnN0YW5jZW9mIFJlY29pbFZhbHVlUmVhZE9ubHk7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfUmVjb2lsVmFsdWUgPSB7XHJcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZSxcclxuICBSZWNvaWxTdGF0ZSxcclxuICBSZWNvaWxWYWx1ZVJlYWRPbmx5LFxyXG4gIGlzUmVjb2lsVmFsdWVcclxufTtcclxuXHJcbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVfMSA9IFJlY29pbF9SZWNvaWxWYWx1ZS5BYnN0cmFjdFJlY29pbFZhbHVlO1xyXG52YXIgUmVjb2lsX1JlY29pbFZhbHVlXzIgPSBSZWNvaWxfUmVjb2lsVmFsdWUuUmVjb2lsU3RhdGU7XHJcbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVfMyA9IFJlY29pbF9SZWNvaWxWYWx1ZS5SZWNvaWxWYWx1ZVJlYWRPbmx5O1xyXG52YXIgUmVjb2lsX1JlY29pbFZhbHVlXzQgPSBSZWNvaWxfUmVjb2lsVmFsdWUuaXNSZWNvaWxWYWx1ZTtcclxuXHJcbnZhciBSZWNvaWxfUmVjb2lsVmFsdWUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZTogUmVjb2lsX1JlY29pbFZhbHVlXzEsXHJcbiAgUmVjb2lsU3RhdGU6IFJlY29pbF9SZWNvaWxWYWx1ZV8yLFxyXG4gIFJlY29pbFZhbHVlUmVhZE9ubHk6IFJlY29pbF9SZWNvaWxWYWx1ZV8zLFxyXG4gIGlzUmVjb2lsVmFsdWU6IFJlY29pbF9SZWNvaWxWYWx1ZV80XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHNwcmludGYoZm9ybWF0LCAuLi5hcmdzKSB7XHJcbiAgbGV0IGluZGV4ID0gMDtcclxuICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoLyVzL2csICgpID0+IFN0cmluZyhhcmdzW2luZGV4KytdKSk7XHJcbn1cclxuXHJcbnZhciBzcHJpbnRmXzEgPSBzcHJpbnRmO1xyXG5cclxuZnVuY3Rpb24gZXhwZWN0YXRpb25WaW9sYXRpb24oZm9ybWF0LCAuLi5hcmdzKSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgY29uc3QgbWVzc2FnZSA9IHNwcmludGZfMS5jYWxsKG51bGwsIGZvcm1hdCwgLi4uYXJncyk7XHJcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIGVycm9yLm5hbWUgPSAnRXhwZWN0YXRpb24gVmlvbGF0aW9uJztcclxuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGV4cGVjdGF0aW9uVmlvbGF0aW9uXzEgPSBleHBlY3RhdGlvblZpb2xhdGlvbjtcclxuXHJcbi8vIEBvc3Mtb25seVxyXG5cclxuXHJcbnZhciBSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24gPSBleHBlY3RhdGlvblZpb2xhdGlvbl8xO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaXRlcmFibGUgd2hvc2Ugb3V0cHV0IGlzIGdlbmVyYXRlZCBieSBwYXNzaW5nIHRoZSBpbnB1dFxyXG4gKiBpdGVyYWJsZSdzIHZhbHVlcyB0aHJvdWdoIHRoZSBtYXBwZXIgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWFwSXRlcmFibGUoaXRlcmFibGUsIGNhbGxiYWNrKSB7XHJcbiAgLy8gVXNlIGdlbmVyYXRvciB0byBjcmVhdGUgaXRlcmFibGUvaXRlcmF0b3JcclxuICByZXR1cm4gZnVuY3Rpb24qICgpIHtcclxuICAgIGxldCBpbmRleCA9IDA7XHJcblxyXG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xyXG4gICAgICB5aWVsZCBjYWxsYmFjayh2YWx1ZSwgaW5kZXgrKyk7XHJcbiAgICB9XHJcbiAgfSgpO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX21hcEl0ZXJhYmxlID0gbWFwSXRlcmFibGU7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcmVjb3ZlcmFibGVWaW9sYXRpb24obWVzc2FnZSwgX3Byb2plY3ROYW1lLCB7XHJcbiAgZXJyb3JcclxufSA9IHt9KSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBlcnJvcik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxudmFyIHJlY292ZXJhYmxlVmlvbGF0aW9uXzEgPSByZWNvdmVyYWJsZVZpb2xhdGlvbjtcclxuXHJcbi8vIEBvc3Mtb25seVxyXG5cclxuXHJcbnZhciBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24gPSByZWNvdmVyYWJsZVZpb2xhdGlvbl8xO1xyXG5cclxuY29uc3Qge1xyXG4gIGlzRmFzdFJlZnJlc2hFbmFibGVkOiBpc0Zhc3RSZWZyZXNoRW5hYmxlZCQxXHJcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgRGVmYXVsdFZhbHVlIHt9XHJcblxyXG5jb25zdCBERUZBVUxUX1ZBTFVFID0gbmV3IERlZmF1bHRWYWx1ZSgpO1xyXG4vLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxyXG5jb25zdCBub2RlcyA9IG5ldyBNYXAoKTsgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcclxuXHJcbmNvbnN0IHJlY29pbFZhbHVlcyA9IG5ldyBNYXAoKTtcclxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVkZWNsYXJlICovXHJcblxyXG5mdW5jdGlvbiByZWNvaWxWYWx1ZXNGb3JLZXlzKGtleXMpIHtcclxuICByZXR1cm4gUmVjb2lsX21hcEl0ZXJhYmxlKGtleXMsIGtleSA9PiBSZWNvaWxfbnVsbHRocm93cyhyZWNvaWxWYWx1ZXMuZ2V0KGtleSkpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVnaXN0ZXJOb2RlKG5vZGUpIHtcclxuICBpZiAobm9kZXMuaGFzKG5vZGUua2V5KSkge1xyXG4gICAgY29uc3QgbWVzc2FnZSA9IGBEdXBsaWNhdGUgYXRvbSBrZXkgXCIke25vZGUua2V5fVwiLiBUaGlzIGlzIGEgRkFUQUwgRVJST1IgaW5cclxuICAgICAgcHJvZHVjdGlvbi4gQnV0IGl0IGlzIHNhZmUgdG8gaWdub3JlIHRoaXMgd2FybmluZyBpZiBpdCBvY2N1cnJlZCBiZWNhdXNlIG9mXHJcbiAgICAgIGhvdCBtb2R1bGUgcmVwbGFjZW1lbnQuYDtcclxuXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgIC8vIFRPRE8gRmlndXJlIHRoaXMgb3V0IGZvciBvcGVuLXNvdXJjZVxyXG4gICAgICBpZiAoIWlzRmFzdFJlZnJlc2hFbmFibGVkJDEoKSkge1xyXG4gICAgICAgIFJlY29pbF9leHBlY3RhdGlvblZpb2xhdGlvbihtZXNzYWdlLCAncmVjb2lsJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEBmYi1vbmx5OiByZWNvdmVyYWJsZVZpb2xhdGlvbihtZXNzYWdlLCAncmVjb2lsJyk7XHJcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTsgLy8gQG9zcy1vbmx5XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBub2Rlcy5zZXQobm9kZS5rZXksIG5vZGUpO1xyXG4gIGNvbnN0IHJlY29pbFZhbHVlID0gbm9kZS5zZXQgPT0gbnVsbCA/IG5ldyBSZWNvaWxfUmVjb2lsVmFsdWUkMS5SZWNvaWxWYWx1ZVJlYWRPbmx5KG5vZGUua2V5KSA6IG5ldyBSZWNvaWxfUmVjb2lsVmFsdWUkMS5SZWNvaWxTdGF0ZShub2RlLmtleSk7XHJcbiAgcmVjb2lsVmFsdWVzLnNldChub2RlLmtleSwgcmVjb2lsVmFsdWUpO1xyXG4gIHJldHVybiByZWNvaWxWYWx1ZTtcclxufVxyXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXJlZGVjbGFyZSAqL1xyXG5cclxuXHJcbmNsYXNzIE5vZGVNaXNzaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7fSAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldE5vZGUoa2V5KSB7XHJcbiAgY29uc3Qgbm9kZSA9IG5vZGVzLmdldChrZXkpO1xyXG5cclxuICBpZiAobm9kZSA9PSBudWxsKSB7XHJcbiAgICB0aHJvdyBuZXcgTm9kZU1pc3NpbmdFcnJvcihgTWlzc2luZyBkZWZpbml0aW9uIGZvciBSZWNvaWxWYWx1ZTogXCIke2tleX1cIlwiYCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbm9kZTtcclxufSAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldE5vZGVNYXliZShrZXkpIHtcclxuICByZXR1cm4gbm9kZXMuZ2V0KGtleSk7XHJcbn1cclxuXHJcbmNvbnN0IGNvbmZpZ0RlbGV0aW9uSGFuZGxlcnMgPSBuZXcgTWFwKCk7XHJcblxyXG5mdW5jdGlvbiBkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZShrZXkpIHtcclxuICB2YXIgX25vZGUkc2hvdWxkRGVsZXRlQ29uO1xyXG5cclxuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGNvbnN0IG5vZGUgPSBub2Rlcy5nZXQoa2V5KTtcclxuXHJcbiAgaWYgKG5vZGUgIT09IG51bGwgJiYgbm9kZSAhPT0gdm9pZCAwICYmIChfbm9kZSRzaG91bGREZWxldGVDb24gPSBub2RlLnNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZSkgIT09IG51bGwgJiYgX25vZGUkc2hvdWxkRGVsZXRlQ29uICE9PSB2b2lkIDAgJiYgX25vZGUkc2hvdWxkRGVsZXRlQ29uLmNhbGwobm9kZSkpIHtcclxuICAgIHZhciBfZ2V0Q29uZmlnRGVsZXRpb25IYW47XHJcblxyXG4gICAgbm9kZXMuZGVsZXRlKGtleSk7XHJcbiAgICAoX2dldENvbmZpZ0RlbGV0aW9uSGFuID0gZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyKGtleSkpID09PSBudWxsIHx8IF9nZXRDb25maWdEZWxldGlvbkhhbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldENvbmZpZ0RlbGV0aW9uSGFuKCk7XHJcbiAgICBjb25maWdEZWxldGlvbkhhbmRsZXJzLmRlbGV0ZShrZXkpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyKGtleSwgZm4pIHtcclxuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlmIChmbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBjb25maWdEZWxldGlvbkhhbmRsZXJzLmRlbGV0ZShrZXkpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25maWdEZWxldGlvbkhhbmRsZXJzLnNldChrZXksIGZuKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlcihrZXkpIHtcclxuICByZXR1cm4gY29uZmlnRGVsZXRpb25IYW5kbGVycy5nZXQoa2V5KTtcclxufVxyXG5cclxudmFyIFJlY29pbF9Ob2RlID0ge1xyXG4gIG5vZGVzLFxyXG4gIHJlY29pbFZhbHVlcyxcclxuICByZWdpc3Rlck5vZGUsXHJcbiAgZ2V0Tm9kZSxcclxuICBnZXROb2RlTWF5YmUsXHJcbiAgZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGUsXHJcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyLFxyXG4gIGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlcixcclxuICByZWNvaWxWYWx1ZXNGb3JLZXlzLFxyXG4gIE5vZGVNaXNzaW5nRXJyb3IsXHJcbiAgRGVmYXVsdFZhbHVlLFxyXG4gIERFRkFVTFRfVkFMVUVcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcblxyXG5mdW5jdGlvbiBlbnF1ZXVlRXhlY3V0aW9uKHMsIGYpIHtcclxuICBmKCk7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfUXVldWUgPSB7XHJcbiAgZW5xdWV1ZUV4ZWN1dGlvblxyXG59O1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xyXG5cdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcclxufVxyXG5cclxudmFyIGhhbXRfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcclxuXHJcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XHJcbn0gOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XHJcbn07XHJcbi8qKlxyXG4gICAgQGZpbGVPdmVydmlldyBIYXNoIEFycmF5IE1hcHBlZCBUcmllLlxyXG5cclxuICAgIENvZGUgYmFzZWQgb246IGh0dHBzOi8vZ2l0aHViLmNvbS9leGNsaXB5L3BkYXRhXHJcbiovXHJcblxyXG5cclxudmFyIGhhbXQgPSB7fTsgLy8gZXhwb3J0XHJcblxyXG4vKiBDb25maWd1cmF0aW9uXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG52YXIgU0laRSA9IDU7XHJcbnZhciBCVUNLRVRfU0laRSA9IE1hdGgucG93KDIsIFNJWkUpO1xyXG52YXIgTUFTSyA9IEJVQ0tFVF9TSVpFIC0gMTtcclxudmFyIE1BWF9JTkRFWF9OT0RFID0gQlVDS0VUX1NJWkUgLyAyO1xyXG52YXIgTUlOX0FSUkFZX05PREUgPSBCVUNLRVRfU0laRSAvIDQ7XHJcbi8qXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG52YXIgbm90aGluZyA9IHt9O1xyXG5cclxudmFyIGNvbnN0YW50ID0gZnVuY3Rpb24gY29uc3RhbnQoeCkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4geDtcclxuICB9O1xyXG59O1xyXG4vKipcclxuICAgIEdldCAzMiBiaXQgaGFzaCBvZiBzdHJpbmcuXHJcblxyXG4gICAgQmFzZWQgb246XHJcbiAgICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc2MTY0NjEvZ2VuZXJhdGUtYS1oYXNoLWZyb20tc3RyaW5nLWluLWphdmFzY3JpcHQtanF1ZXJ5XHJcbiovXHJcblxyXG5cclxudmFyIGhhc2ggPSBoYW10Lmhhc2ggPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihzdHIpO1xyXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJykgcmV0dXJuIHN0cjtcclxuICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHN0ciArPSAnJztcclxuICB2YXIgaGFzaCA9IDA7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgYyB8IDA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaGFzaDtcclxufTtcclxuLyogQml0IE9wc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLyoqXHJcbiAgICBIYW1taW5nIHdlaWdodC5cclxuXHJcbiAgICBUYWtlbiBmcm9tOiBodHRwOi8vanNwZXJmLmNvbS9oYW1taW5nLXdlaWdodFxyXG4qL1xyXG5cclxuXHJcbnZhciBwb3Bjb3VudCA9IGZ1bmN0aW9uIHBvcGNvdW50KHgpIHtcclxuICB4IC09IHggPj4gMSAmIDB4NTU1NTU1NTU7XHJcbiAgeCA9ICh4ICYgMHgzMzMzMzMzMykgKyAoeCA+PiAyICYgMHgzMzMzMzMzMyk7XHJcbiAgeCA9IHggKyAoeCA+PiA0KSAmIDB4MGYwZjBmMGY7XHJcbiAgeCArPSB4ID4+IDg7XHJcbiAgeCArPSB4ID4+IDE2O1xyXG4gIHJldHVybiB4ICYgMHg3ZjtcclxufTtcclxuXHJcbnZhciBoYXNoRnJhZ21lbnQgPSBmdW5jdGlvbiBoYXNoRnJhZ21lbnQoc2hpZnQsIGgpIHtcclxuICByZXR1cm4gaCA+Pj4gc2hpZnQgJiBNQVNLO1xyXG59O1xyXG5cclxudmFyIHRvQml0bWFwID0gZnVuY3Rpb24gdG9CaXRtYXAoeCkge1xyXG4gIHJldHVybiAxIDw8IHg7XHJcbn07XHJcblxyXG52YXIgZnJvbUJpdG1hcCA9IGZ1bmN0aW9uIGZyb21CaXRtYXAoYml0bWFwLCBiaXQpIHtcclxuICByZXR1cm4gcG9wY291bnQoYml0bWFwICYgYml0IC0gMSk7XHJcbn07XHJcbi8qIEFycmF5IE9wc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLyoqXHJcbiAgICBTZXQgYSB2YWx1ZSBpbiBhbiBhcnJheS5cclxuXHJcbiAgICBAcGFyYW0gbXV0YXRlIFNob3VsZCB0aGUgaW5wdXQgYXJyYXkgYmUgbXV0YXRlZD9cclxuICAgIEBwYXJhbSBhdCBJbmRleCB0byBjaGFuZ2UuXHJcbiAgICBAcGFyYW0gdiBOZXcgdmFsdWVcclxuICAgIEBwYXJhbSBhcnIgQXJyYXkuXHJcbiovXHJcblxyXG5cclxudmFyIGFycmF5VXBkYXRlID0gZnVuY3Rpb24gYXJyYXlVcGRhdGUobXV0YXRlLCBhdCwgdiwgYXJyKSB7XHJcbiAgdmFyIG91dCA9IGFycjtcclxuXHJcbiAgaWYgKCFtdXRhdGUpIHtcclxuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gICAgb3V0ID0gbmV3IEFycmF5KGxlbik7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBvdXRbaV0gPSBhcnJbaV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvdXRbYXRdID0gdjtcclxuICByZXR1cm4gb3V0O1xyXG59O1xyXG4vKipcclxuICAgIFJlbW92ZSBhIHZhbHVlIGZyb20gYW4gYXJyYXkuXHJcblxyXG4gICAgQHBhcmFtIG11dGF0ZSBTaG91bGQgdGhlIGlucHV0IGFycmF5IGJlIG11dGF0ZWQ/XHJcbiAgICBAcGFyYW0gYXQgSW5kZXggdG8gcmVtb3ZlLlxyXG4gICAgQHBhcmFtIGFyciBBcnJheS5cclxuKi9cclxuXHJcblxyXG52YXIgYXJyYXlTcGxpY2VPdXQgPSBmdW5jdGlvbiBhcnJheVNwbGljZU91dChtdXRhdGUsIGF0LCBhcnIpIHtcclxuICB2YXIgbmV3TGVuID0gYXJyLmxlbmd0aCAtIDE7XHJcbiAgdmFyIGkgPSAwO1xyXG4gIHZhciBnID0gMDtcclxuICB2YXIgb3V0ID0gYXJyO1xyXG5cclxuICBpZiAobXV0YXRlKSB7XHJcbiAgICBpID0gZyA9IGF0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvdXQgPSBuZXcgQXJyYXkobmV3TGVuKTtcclxuXHJcbiAgICB3aGlsZSAoaSA8IGF0KSB7XHJcbiAgICAgIG91dFtnKytdID0gYXJyW2krK107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICArK2k7XHJcblxyXG4gIHdoaWxlIChpIDw9IG5ld0xlbikge1xyXG4gICAgb3V0W2crK10gPSBhcnJbaSsrXTtcclxuICB9XHJcblxyXG4gIGlmIChtdXRhdGUpIHtcclxuICAgIG91dC5sZW5ndGggPSBuZXdMZW47XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb3V0O1xyXG59O1xyXG4vKipcclxuICAgIEluc2VydCBhIHZhbHVlIGludG8gYW4gYXJyYXkuXHJcblxyXG4gICAgQHBhcmFtIG11dGF0ZSBTaG91bGQgdGhlIGlucHV0IGFycmF5IGJlIG11dGF0ZWQ/XHJcbiAgICBAcGFyYW0gYXQgSW5kZXggdG8gaW5zZXJ0IGF0LlxyXG4gICAgQHBhcmFtIHYgVmFsdWUgdG8gaW5zZXJ0LFxyXG4gICAgQHBhcmFtIGFyciBBcnJheS5cclxuKi9cclxuXHJcblxyXG52YXIgYXJyYXlTcGxpY2VJbiA9IGZ1bmN0aW9uIGFycmF5U3BsaWNlSW4obXV0YXRlLCBhdCwgdiwgYXJyKSB7XHJcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XHJcblxyXG4gIGlmIChtdXRhdGUpIHtcclxuICAgIHZhciBfaSA9IGxlbjtcclxuXHJcbiAgICB3aGlsZSAoX2kgPj0gYXQpIHtcclxuICAgICAgYXJyW19pLS1dID0gYXJyW19pXTtcclxuICAgIH1cclxuXHJcbiAgICBhcnJbYXRdID0gdjtcclxuICAgIHJldHVybiBhcnI7XHJcbiAgfVxyXG5cclxuICB2YXIgaSA9IDAsXHJcbiAgICAgIGcgPSAwO1xyXG4gIHZhciBvdXQgPSBuZXcgQXJyYXkobGVuICsgMSk7XHJcblxyXG4gIHdoaWxlIChpIDwgYXQpIHtcclxuICAgIG91dFtnKytdID0gYXJyW2krK107XHJcbiAgfVxyXG5cclxuICBvdXRbYXRdID0gdjtcclxuXHJcbiAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgIG91dFsrK2ddID0gYXJyW2krK107XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb3V0O1xyXG59O1xyXG4vKiBOb2RlIFN0cnVjdHVyZXNcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG52YXIgTEVBRiA9IDE7XHJcbnZhciBDT0xMSVNJT04gPSAyO1xyXG52YXIgSU5ERVggPSAzO1xyXG52YXIgQVJSQVkgPSA0O1xyXG4vKipcclxuICAgIEVtcHR5IG5vZGUuXHJcbiovXHJcblxyXG52YXIgZW1wdHkgPSB7XHJcbiAgX19oYW10X2lzRW1wdHk6IHRydWVcclxufTtcclxuXHJcbnZhciBpc0VtcHR5Tm9kZSA9IGZ1bmN0aW9uIGlzRW1wdHlOb2RlKHgpIHtcclxuICByZXR1cm4geCA9PT0gZW1wdHkgfHwgeCAmJiB4Ll9faGFtdF9pc0VtcHR5O1xyXG59O1xyXG4vKipcclxuICAgIExlYWYgaG9sZGluZyBhIHZhbHVlLlxyXG5cclxuICAgIEBtZW1iZXIgZWRpdCBFZGl0IG9mIHRoZSBub2RlLlxyXG4gICAgQG1lbWJlciBoYXNoIEhhc2ggb2Yga2V5LlxyXG4gICAgQG1lbWJlciBrZXkgS2V5LlxyXG4gICAgQG1lbWJlciB2YWx1ZSBWYWx1ZSBzdG9yZWQuXHJcbiovXHJcblxyXG5cclxudmFyIExlYWYgPSBmdW5jdGlvbiBMZWFmKGVkaXQsIGhhc2gsIGtleSwgdmFsdWUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogTEVBRixcclxuICAgIGVkaXQ6IGVkaXQsXHJcbiAgICBoYXNoOiBoYXNoLFxyXG4gICAga2V5OiBrZXksXHJcbiAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICBfbW9kaWZ5OiBMZWFmX19tb2RpZnlcclxuICB9O1xyXG59O1xyXG4vKipcclxuICAgIExlYWYgaG9sZGluZyBtdWx0aXBsZSB2YWx1ZXMgd2l0aCB0aGUgc2FtZSBoYXNoIGJ1dCBkaWZmZXJlbnQga2V5cy5cclxuXHJcbiAgICBAbWVtYmVyIGVkaXQgRWRpdCBvZiB0aGUgbm9kZS5cclxuICAgIEBtZW1iZXIgaGFzaCBIYXNoIG9mIGtleS5cclxuICAgIEBtZW1iZXIgY2hpbGRyZW4gQXJyYXkgb2YgY29sbGlzaW9uIGNoaWxkcmVuIG5vZGUuXHJcbiovXHJcblxyXG5cclxudmFyIENvbGxpc2lvbiA9IGZ1bmN0aW9uIENvbGxpc2lvbihlZGl0LCBoYXNoLCBjaGlsZHJlbikge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiBDT0xMSVNJT04sXHJcbiAgICBlZGl0OiBlZGl0LFxyXG4gICAgaGFzaDogaGFzaCxcclxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcclxuICAgIF9tb2RpZnk6IENvbGxpc2lvbl9fbW9kaWZ5XHJcbiAgfTtcclxufTtcclxuLyoqXHJcbiAgICBJbnRlcm5hbCBub2RlIHdpdGggYSBzcGFyc2Ugc2V0IG9mIGNoaWxkcmVuLlxyXG5cclxuICAgIFVzZXMgYSBiaXRtYXAgYW5kIGFycmF5IHRvIHBhY2sgY2hpbGRyZW4uXHJcblxyXG4gIEBtZW1iZXIgZWRpdCBFZGl0IG9mIHRoZSBub2RlLlxyXG4gICAgQG1lbWJlciBtYXNrIEJpdG1hcCB0aGF0IGVuY29kZSB0aGUgcG9zaXRpb25zIG9mIGNoaWxkcmVuIGluIHRoZSBhcnJheS5cclxuICAgIEBtZW1iZXIgY2hpbGRyZW4gQXJyYXkgb2YgY2hpbGQgbm9kZXMuXHJcbiovXHJcblxyXG5cclxudmFyIEluZGV4ZWROb2RlID0gZnVuY3Rpb24gSW5kZXhlZE5vZGUoZWRpdCwgbWFzaywgY2hpbGRyZW4pIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogSU5ERVgsXHJcbiAgICBlZGl0OiBlZGl0LFxyXG4gICAgbWFzazogbWFzayxcclxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcclxuICAgIF9tb2RpZnk6IEluZGV4ZWROb2RlX19tb2RpZnlcclxuICB9O1xyXG59O1xyXG4vKipcclxuICAgIEludGVybmFsIG5vZGUgd2l0aCBtYW55IGNoaWxkcmVuLlxyXG5cclxuICAgIEBtZW1iZXIgZWRpdCBFZGl0IG9mIHRoZSBub2RlLlxyXG4gICAgQG1lbWJlciBzaXplIE51bWJlciBvZiBjaGlsZHJlbi5cclxuICAgIEBtZW1iZXIgY2hpbGRyZW4gQXJyYXkgb2YgY2hpbGQgbm9kZXMuXHJcbiovXHJcblxyXG5cclxudmFyIEFycmF5Tm9kZSA9IGZ1bmN0aW9uIEFycmF5Tm9kZShlZGl0LCBzaXplLCBjaGlsZHJlbikge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiBBUlJBWSxcclxuICAgIGVkaXQ6IGVkaXQsXHJcbiAgICBzaXplOiBzaXplLFxyXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxyXG4gICAgX21vZGlmeTogQXJyYXlOb2RlX19tb2RpZnlcclxuICB9O1xyXG59O1xyXG4vKipcclxuICAgIElzIGBub2RlYCBhIGxlYWYgbm9kZT9cclxuKi9cclxuXHJcblxyXG52YXIgaXNMZWFmID0gZnVuY3Rpb24gaXNMZWFmKG5vZGUpIHtcclxuICByZXR1cm4gbm9kZSA9PT0gZW1wdHkgfHwgbm9kZS50eXBlID09PSBMRUFGIHx8IG5vZGUudHlwZSA9PT0gQ09MTElTSU9OO1xyXG59O1xyXG4vKiBJbnRlcm5hbCBub2RlIG9wZXJhdGlvbnMuXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vKipcclxuICAgIEV4cGFuZCBhbiBpbmRleGVkIG5vZGUgaW50byBhbiBhcnJheSBub2RlLlxyXG5cclxuICBAcGFyYW0gZWRpdCBDdXJyZW50IGVkaXQuXHJcbiAgICBAcGFyYW0gZnJhZyBJbmRleCBvZiBhZGRlZCBjaGlsZC5cclxuICAgIEBwYXJhbSBjaGlsZCBBZGRlZCBjaGlsZC5cclxuICAgIEBwYXJhbSBtYXNrIEluZGV4IG5vZGUgbWFzayBiZWZvcmUgY2hpbGQgYWRkZWQuXHJcbiAgICBAcGFyYW0gc3ViTm9kZXMgSW5kZXggbm9kZSBjaGlsZHJlbiBiZWZvcmUgY2hpbGQgYWRkZWQuXHJcbiovXHJcblxyXG5cclxudmFyIGV4cGFuZCA9IGZ1bmN0aW9uIGV4cGFuZChlZGl0LCBmcmFnLCBjaGlsZCwgYml0bWFwLCBzdWJOb2Rlcykge1xyXG4gIHZhciBhcnIgPSBbXTtcclxuICB2YXIgYml0ID0gYml0bWFwO1xyXG4gIHZhciBjb3VudCA9IDA7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBiaXQ7ICsraSkge1xyXG4gICAgaWYgKGJpdCAmIDEpIGFycltpXSA9IHN1Yk5vZGVzW2NvdW50KytdO1xyXG4gICAgYml0ID4+Pj0gMTtcclxuICB9XHJcblxyXG4gIGFycltmcmFnXSA9IGNoaWxkO1xyXG4gIHJldHVybiBBcnJheU5vZGUoZWRpdCwgY291bnQgKyAxLCBhcnIpO1xyXG59O1xyXG4vKipcclxuICAgIENvbGxhcHNlIGFuIGFycmF5IG5vZGUgaW50byBhIGluZGV4ZWQgbm9kZS5cclxuXHJcbiAgQHBhcmFtIGVkaXQgQ3VycmVudCBlZGl0LlxyXG4gICAgQHBhcmFtIGNvdW50IE51bWJlciBvZiBlbGVtZW50cyBpbiBuZXcgYXJyYXkuXHJcbiAgICBAcGFyYW0gcmVtb3ZlZCBJbmRleCBvZiByZW1vdmVkIGVsZW1lbnQuXHJcbiAgICBAcGFyYW0gZWxlbWVudHMgQXJyYXkgbm9kZSBjaGlsZHJlbiBiZWZvcmUgcmVtb3ZlLlxyXG4qL1xyXG5cclxuXHJcbnZhciBwYWNrID0gZnVuY3Rpb24gcGFjayhlZGl0LCBjb3VudCwgcmVtb3ZlZCwgZWxlbWVudHMpIHtcclxuICB2YXIgY2hpbGRyZW4gPSBuZXcgQXJyYXkoY291bnQgLSAxKTtcclxuICB2YXIgZyA9IDA7XHJcbiAgdmFyIGJpdG1hcCA9IDA7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgaWYgKGkgIT09IHJlbW92ZWQpIHtcclxuICAgICAgdmFyIGVsZW0gPSBlbGVtZW50c1tpXTtcclxuXHJcbiAgICAgIGlmIChlbGVtICYmICFpc0VtcHR5Tm9kZShlbGVtKSkge1xyXG4gICAgICAgIGNoaWxkcmVuW2crK10gPSBlbGVtO1xyXG4gICAgICAgIGJpdG1hcCB8PSAxIDw8IGk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBJbmRleGVkTm9kZShlZGl0LCBiaXRtYXAsIGNoaWxkcmVuKTtcclxufTtcclxuLyoqXHJcbiAgICBNZXJnZSB0d28gbGVhZiBub2Rlcy5cclxuXHJcbiAgICBAcGFyYW0gc2hpZnQgQ3VycmVudCBzaGlmdC5cclxuICAgIEBwYXJhbSBoMSBOb2RlIDEgaGFzaC5cclxuICAgIEBwYXJhbSBuMSBOb2RlIDEuXHJcbiAgICBAcGFyYW0gaDIgTm9kZSAyIGhhc2guXHJcbiAgICBAcGFyYW0gbjIgTm9kZSAyLlxyXG4qL1xyXG5cclxuXHJcbnZhciBtZXJnZUxlYXZlcyA9IGZ1bmN0aW9uIG1lcmdlTGVhdmVzKGVkaXQsIHNoaWZ0LCBoMSwgbjEsIGgyLCBuMikge1xyXG4gIGlmIChoMSA9PT0gaDIpIHJldHVybiBDb2xsaXNpb24oZWRpdCwgaDEsIFtuMiwgbjFdKTtcclxuICB2YXIgc3ViSDEgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGgxKTtcclxuICB2YXIgc3ViSDIgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGgyKTtcclxuICByZXR1cm4gSW5kZXhlZE5vZGUoZWRpdCwgdG9CaXRtYXAoc3ViSDEpIHwgdG9CaXRtYXAoc3ViSDIpLCBzdWJIMSA9PT0gc3ViSDIgPyBbbWVyZ2VMZWF2ZXMoZWRpdCwgc2hpZnQgKyBTSVpFLCBoMSwgbjEsIGgyLCBuMildIDogc3ViSDEgPCBzdWJIMiA/IFtuMSwgbjJdIDogW24yLCBuMV0pO1xyXG59O1xyXG4vKipcclxuICAgIFVwZGF0ZSBhbiBlbnRyeSBpbiBhIGNvbGxpc2lvbiBsaXN0LlxyXG5cclxuICAgIEBwYXJhbSBtdXRhdGUgU2hvdWxkIG11dGF0aW9uIGJlIHVzZWQ/XHJcbiAgICBAcGFyYW0gZWRpdCBDdXJyZW50IGVkaXQuXHJcbiAgICBAcGFyYW0ga2V5RXEgS2V5IGNvbXBhcmUgZnVuY3Rpb24uXHJcbiAgICBAcGFyYW0gaGFzaCBIYXNoIG9mIGNvbGxpc2lvbi5cclxuICAgIEBwYXJhbSBsaXN0IENvbGxpc2lvbiBsaXN0LlxyXG4gICAgQHBhcmFtIGYgVXBkYXRlIGZ1bmN0aW9uLlxyXG4gICAgQHBhcmFtIGsgS2V5IHRvIHVwZGF0ZS5cclxuICAgIEBwYXJhbSBzaXplIFNpemUgcmVmLlxyXG4qL1xyXG5cclxuXHJcbnZhciB1cGRhdGVDb2xsaXNpb25MaXN0ID0gZnVuY3Rpb24gdXBkYXRlQ29sbGlzaW9uTGlzdChtdXRhdGUsIGVkaXQsIGtleUVxLCBoLCBsaXN0LCBmLCBrLCBzaXplKSB7XHJcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICB2YXIgY2hpbGQgPSBsaXN0W2ldO1xyXG5cclxuICAgIGlmIChrZXlFcShrLCBjaGlsZC5rZXkpKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IGNoaWxkLnZhbHVlO1xyXG5cclxuICAgICAgdmFyIF9uZXdWYWx1ZSA9IGYodmFsdWUpO1xyXG5cclxuICAgICAgaWYgKF9uZXdWYWx1ZSA9PT0gdmFsdWUpIHJldHVybiBsaXN0O1xyXG5cclxuICAgICAgaWYgKF9uZXdWYWx1ZSA9PT0gbm90aGluZykge1xyXG4gICAgICAgIC0tc2l6ZS52YWx1ZTtcclxuICAgICAgICByZXR1cm4gYXJyYXlTcGxpY2VPdXQobXV0YXRlLCBpLCBsaXN0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGFycmF5VXBkYXRlKG11dGF0ZSwgaSwgTGVhZihlZGl0LCBoLCBrLCBfbmV3VmFsdWUpLCBsaXN0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBuZXdWYWx1ZSA9IGYoKTtcclxuICBpZiAobmV3VmFsdWUgPT09IG5vdGhpbmcpIHJldHVybiBsaXN0O1xyXG4gICsrc2l6ZS52YWx1ZTtcclxuICByZXR1cm4gYXJyYXlVcGRhdGUobXV0YXRlLCBsZW4sIExlYWYoZWRpdCwgaCwgaywgbmV3VmFsdWUpLCBsaXN0KTtcclxufTtcclxuXHJcbnZhciBjYW5FZGl0Tm9kZSA9IGZ1bmN0aW9uIGNhbkVkaXROb2RlKGVkaXQsIG5vZGUpIHtcclxuICByZXR1cm4gZWRpdCA9PT0gbm9kZS5lZGl0O1xyXG59O1xyXG4vKiBFZGl0aW5nXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxudmFyIExlYWZfX21vZGlmeSA9IGZ1bmN0aW9uIExlYWZfX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQsIGYsIGgsIGssIHNpemUpIHtcclxuICBpZiAoa2V5RXEoaywgdGhpcy5rZXkpKSB7XHJcbiAgICB2YXIgX3YgPSBmKHRoaXMudmFsdWUpO1xyXG5cclxuICAgIGlmIChfdiA9PT0gdGhpcy52YWx1ZSkgcmV0dXJuIHRoaXM7ZWxzZSBpZiAoX3YgPT09IG5vdGhpbmcpIHtcclxuICAgICAgLS1zaXplLnZhbHVlO1xyXG4gICAgICByZXR1cm4gZW1wdHk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNhbkVkaXROb2RlKGVkaXQsIHRoaXMpKSB7XHJcbiAgICAgIHRoaXMudmFsdWUgPSBfdjtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIExlYWYoZWRpdCwgaCwgaywgX3YpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHYgPSBmKCk7XHJcbiAgaWYgKHYgPT09IG5vdGhpbmcpIHJldHVybiB0aGlzO1xyXG4gICsrc2l6ZS52YWx1ZTtcclxuICByZXR1cm4gbWVyZ2VMZWF2ZXMoZWRpdCwgc2hpZnQsIHRoaXMuaGFzaCwgdGhpcywgaCwgTGVhZihlZGl0LCBoLCBrLCB2KSk7XHJcbn07XHJcblxyXG52YXIgQ29sbGlzaW9uX19tb2RpZnkgPSBmdW5jdGlvbiBDb2xsaXNpb25fX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQsIGYsIGgsIGssIHNpemUpIHtcclxuICBpZiAoaCA9PT0gdGhpcy5oYXNoKSB7XHJcbiAgICB2YXIgY2FuRWRpdCA9IGNhbkVkaXROb2RlKGVkaXQsIHRoaXMpO1xyXG4gICAgdmFyIGxpc3QgPSB1cGRhdGVDb2xsaXNpb25MaXN0KGNhbkVkaXQsIGVkaXQsIGtleUVxLCB0aGlzLmhhc2gsIHRoaXMuY2hpbGRyZW4sIGYsIGssIHNpemUpO1xyXG4gICAgaWYgKGxpc3QgPT09IHRoaXMuY2hpbGRyZW4pIHJldHVybiB0aGlzO1xyXG4gICAgcmV0dXJuIGxpc3QubGVuZ3RoID4gMSA/IENvbGxpc2lvbihlZGl0LCB0aGlzLmhhc2gsIGxpc3QpIDogbGlzdFswXTsgLy8gY29sbGFwc2Ugc2luZ2xlIGVsZW1lbnQgY29sbGlzaW9uIGxpc3RcclxuICB9XHJcblxyXG4gIHZhciB2ID0gZigpO1xyXG4gIGlmICh2ID09PSBub3RoaW5nKSByZXR1cm4gdGhpcztcclxuICArK3NpemUudmFsdWU7XHJcbiAgcmV0dXJuIG1lcmdlTGVhdmVzKGVkaXQsIHNoaWZ0LCB0aGlzLmhhc2gsIHRoaXMsIGgsIExlYWYoZWRpdCwgaCwgaywgdikpO1xyXG59O1xyXG5cclxudmFyIEluZGV4ZWROb2RlX19tb2RpZnkgPSBmdW5jdGlvbiBJbmRleGVkTm9kZV9fbW9kaWZ5KGVkaXQsIGtleUVxLCBzaGlmdCwgZiwgaCwgaywgc2l6ZSkge1xyXG4gIHZhciBtYXNrID0gdGhpcy5tYXNrO1xyXG4gIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcbiAgdmFyIGZyYWcgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGgpO1xyXG4gIHZhciBiaXQgPSB0b0JpdG1hcChmcmFnKTtcclxuICB2YXIgaW5keCA9IGZyb21CaXRtYXAobWFzaywgYml0KTtcclxuICB2YXIgZXhpc3RzID0gbWFzayAmIGJpdDtcclxuICB2YXIgY3VycmVudCA9IGV4aXN0cyA/IGNoaWxkcmVuW2luZHhdIDogZW1wdHk7XHJcblxyXG4gIHZhciBjaGlsZCA9IGN1cnJlbnQuX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQgKyBTSVpFLCBmLCBoLCBrLCBzaXplKTtcclxuXHJcbiAgaWYgKGN1cnJlbnQgPT09IGNoaWxkKSByZXR1cm4gdGhpcztcclxuICB2YXIgY2FuRWRpdCA9IGNhbkVkaXROb2RlKGVkaXQsIHRoaXMpO1xyXG4gIHZhciBiaXRtYXAgPSBtYXNrO1xyXG4gIHZhciBuZXdDaGlsZHJlbiA9IHZvaWQgMDtcclxuXHJcbiAgaWYgKGV4aXN0cyAmJiBpc0VtcHR5Tm9kZShjaGlsZCkpIHtcclxuICAgIC8vIHJlbW92ZVxyXG4gICAgYml0bWFwICY9IH5iaXQ7XHJcbiAgICBpZiAoIWJpdG1hcCkgcmV0dXJuIGVtcHR5O1xyXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA8PSAyICYmIGlzTGVhZihjaGlsZHJlbltpbmR4IF4gMV0pKSByZXR1cm4gY2hpbGRyZW5baW5keCBeIDFdOyAvLyBjb2xsYXBzZVxyXG5cclxuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlTcGxpY2VPdXQoY2FuRWRpdCwgaW5keCwgY2hpbGRyZW4pO1xyXG4gIH0gZWxzZSBpZiAoIWV4aXN0cyAmJiAhaXNFbXB0eU5vZGUoY2hpbGQpKSB7XHJcbiAgICAvLyBhZGRcclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPj0gTUFYX0lOREVYX05PREUpIHJldHVybiBleHBhbmQoZWRpdCwgZnJhZywgY2hpbGQsIG1hc2ssIGNoaWxkcmVuKTtcclxuICAgIGJpdG1hcCB8PSBiaXQ7XHJcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5U3BsaWNlSW4oY2FuRWRpdCwgaW5keCwgY2hpbGQsIGNoaWxkcmVuKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gbW9kaWZ5XHJcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5VXBkYXRlKGNhbkVkaXQsIGluZHgsIGNoaWxkLCBjaGlsZHJlbik7XHJcbiAgfVxyXG5cclxuICBpZiAoY2FuRWRpdCkge1xyXG4gICAgdGhpcy5tYXNrID0gYml0bWFwO1xyXG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gSW5kZXhlZE5vZGUoZWRpdCwgYml0bWFwLCBuZXdDaGlsZHJlbik7XHJcbn07XHJcblxyXG52YXIgQXJyYXlOb2RlX19tb2RpZnkgPSBmdW5jdGlvbiBBcnJheU5vZGVfX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQsIGYsIGgsIGssIHNpemUpIHtcclxuICB2YXIgY291bnQgPSB0aGlzLnNpemU7XHJcbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuICB2YXIgZnJhZyA9IGhhc2hGcmFnbWVudChzaGlmdCwgaCk7XHJcbiAgdmFyIGNoaWxkID0gY2hpbGRyZW5bZnJhZ107XHJcblxyXG4gIHZhciBuZXdDaGlsZCA9IChjaGlsZCB8fCBlbXB0eSkuX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQgKyBTSVpFLCBmLCBoLCBrLCBzaXplKTtcclxuXHJcbiAgaWYgKGNoaWxkID09PSBuZXdDaGlsZCkgcmV0dXJuIHRoaXM7XHJcbiAgdmFyIGNhbkVkaXQgPSBjYW5FZGl0Tm9kZShlZGl0LCB0aGlzKTtcclxuICB2YXIgbmV3Q2hpbGRyZW4gPSB2b2lkIDA7XHJcblxyXG4gIGlmIChpc0VtcHR5Tm9kZShjaGlsZCkgJiYgIWlzRW1wdHlOb2RlKG5ld0NoaWxkKSkge1xyXG4gICAgLy8gYWRkXHJcbiAgICArK2NvdW50O1xyXG4gICAgbmV3Q2hpbGRyZW4gPSBhcnJheVVwZGF0ZShjYW5FZGl0LCBmcmFnLCBuZXdDaGlsZCwgY2hpbGRyZW4pO1xyXG4gIH0gZWxzZSBpZiAoIWlzRW1wdHlOb2RlKGNoaWxkKSAmJiBpc0VtcHR5Tm9kZShuZXdDaGlsZCkpIHtcclxuICAgIC8vIHJlbW92ZVxyXG4gICAgLS1jb3VudDtcclxuICAgIGlmIChjb3VudCA8PSBNSU5fQVJSQVlfTk9ERSkgcmV0dXJuIHBhY2soZWRpdCwgY291bnQsIGZyYWcsIGNoaWxkcmVuKTtcclxuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlVcGRhdGUoY2FuRWRpdCwgZnJhZywgZW1wdHksIGNoaWxkcmVuKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gbW9kaWZ5XHJcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5VXBkYXRlKGNhbkVkaXQsIGZyYWcsIG5ld0NoaWxkLCBjaGlsZHJlbik7XHJcbiAgfVxyXG5cclxuICBpZiAoY2FuRWRpdCkge1xyXG4gICAgdGhpcy5zaXplID0gY291bnQ7XHJcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHJldHVybiBBcnJheU5vZGUoZWRpdCwgY291bnQsIG5ld0NoaWxkcmVuKTtcclxufTtcclxuXHJcbmVtcHR5Ll9tb2RpZnkgPSBmdW5jdGlvbiAoZWRpdCwga2V5RXEsIHNoaWZ0LCBmLCBoLCBrLCBzaXplKSB7XHJcbiAgdmFyIHYgPSBmKCk7XHJcbiAgaWYgKHYgPT09IG5vdGhpbmcpIHJldHVybiBlbXB0eTtcclxuICArK3NpemUudmFsdWU7XHJcbiAgcmV0dXJuIExlYWYoZWRpdCwgaCwgaywgdik7XHJcbn07XHJcbi8qXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxuZnVuY3Rpb24gTWFwKGVkaXRhYmxlLCBlZGl0LCBjb25maWcsIHJvb3QsIHNpemUpIHtcclxuICB0aGlzLl9lZGl0YWJsZSA9IGVkaXRhYmxlO1xyXG4gIHRoaXMuX2VkaXQgPSBlZGl0O1xyXG4gIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcclxuICB0aGlzLl9yb290ID0gcm9vdDtcclxuICB0aGlzLl9zaXplID0gc2l6ZTtcclxufVxyXG5cclxuTWFwLnByb3RvdHlwZS5zZXRUcmVlID0gZnVuY3Rpb24gKG5ld1Jvb3QsIG5ld1NpemUpIHtcclxuICBpZiAodGhpcy5fZWRpdGFibGUpIHtcclxuICAgIHRoaXMuX3Jvb3QgPSBuZXdSb290O1xyXG4gICAgdGhpcy5fc2l6ZSA9IG5ld1NpemU7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHJldHVybiBuZXdSb290ID09PSB0aGlzLl9yb290ID8gdGhpcyA6IG5ldyBNYXAodGhpcy5fZWRpdGFibGUsIHRoaXMuX2VkaXQsIHRoaXMuX2NvbmZpZywgbmV3Um9vdCwgbmV3U2l6ZSk7XHJcbn07XHJcbi8qIFF1ZXJpZXNcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8qKlxyXG4gICAgTG9va3VwIHRoZSB2YWx1ZSBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgYSBjdXN0b20gYGhhc2hgLlxyXG5cclxuICAgIFJldHVybnMgdGhlIHZhbHVlIG9yIGBhbHRgIGlmIG5vbmUuXHJcbiovXHJcblxyXG5cclxudmFyIHRyeUdldEhhc2ggPSBoYW10LnRyeUdldEhhc2ggPSBmdW5jdGlvbiAoYWx0LCBoYXNoLCBrZXksIG1hcCkge1xyXG4gIHZhciBub2RlID0gbWFwLl9yb290O1xyXG4gIHZhciBzaGlmdCA9IDA7XHJcbiAgdmFyIGtleUVxID0gbWFwLl9jb25maWcua2V5RXE7XHJcblxyXG4gIHdoaWxlICh0cnVlKSB7XHJcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICBjYXNlIExFQUY6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcmV0dXJuIGtleUVxKGtleSwgbm9kZS5rZXkpID8gbm9kZS52YWx1ZSA6IGFsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICBjYXNlIENPTExJU0lPTjpcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZiAoaGFzaCA9PT0gbm9kZS5oYXNoKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICBpZiAoa2V5RXEoa2V5LCBjaGlsZC5rZXkpKSByZXR1cm4gY2hpbGQudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gYWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIGNhc2UgSU5ERVg6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdmFyIGZyYWcgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGhhc2gpO1xyXG4gICAgICAgICAgdmFyIGJpdCA9IHRvQml0bWFwKGZyYWcpO1xyXG5cclxuICAgICAgICAgIGlmIChub2RlLm1hc2sgJiBiaXQpIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bZnJvbUJpdG1hcChub2RlLm1hc2ssIGJpdCldO1xyXG4gICAgICAgICAgICBzaGlmdCArPSBTSVpFO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gYWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIGNhc2UgQVJSQVk6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5baGFzaEZyYWdtZW50KHNoaWZ0LCBoYXNoKV07XHJcblxyXG4gICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgc2hpZnQgKz0gU0laRTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGFsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBhbHQ7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS50cnlHZXRIYXNoID0gZnVuY3Rpb24gKGFsdCwgaGFzaCwga2V5KSB7XHJcbiAgcmV0dXJuIHRyeUdldEhhc2goYWx0LCBoYXNoLCBrZXksIHRoaXMpO1xyXG59O1xyXG4vKipcclxuICAgIExvb2t1cCB0aGUgdmFsdWUgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGludGVybmFsIGhhc2ggZnVuY3Rpb24uXHJcblxyXG4gICAgQHNlZSBgdHJ5R2V0SGFzaGBcclxuKi9cclxuXHJcblxyXG52YXIgdHJ5R2V0ID0gaGFtdC50cnlHZXQgPSBmdW5jdGlvbiAoYWx0LCBrZXksIG1hcCkge1xyXG4gIHJldHVybiB0cnlHZXRIYXNoKGFsdCwgbWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIG1hcCk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLnRyeUdldCA9IGZ1bmN0aW9uIChhbHQsIGtleSkge1xyXG4gIHJldHVybiB0cnlHZXQoYWx0LCBrZXksIHRoaXMpO1xyXG59O1xyXG4vKipcclxuICAgIExvb2t1cCB0aGUgdmFsdWUgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGEgY3VzdG9tIGBoYXNoYC5cclxuXHJcbiAgICBSZXR1cm5zIHRoZSB2YWx1ZSBvciBgdW5kZWZpbmVkYCBpZiBub25lLlxyXG4qL1xyXG5cclxuXHJcbnZhciBnZXRIYXNoID0gaGFtdC5nZXRIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgbWFwKSB7XHJcbiAgcmV0dXJuIHRyeUdldEhhc2godW5kZWZpbmVkLCBoYXNoLCBrZXksIG1hcCk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLmdldEhhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5KSB7XHJcbiAgcmV0dXJuIGdldEhhc2goaGFzaCwga2V5LCB0aGlzKTtcclxufTtcclxuLyoqXHJcbiAgICBMb29rdXAgdGhlIHZhbHVlIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxyXG5cclxuICAgIEBzZWUgYGdldGBcclxuKi9cclxuXHJcblxyXG52YXIgZ2V0ID0gaGFtdC5nZXQgPSBmdW5jdGlvbiAoa2V5LCBtYXApIHtcclxuICByZXR1cm4gdHJ5R2V0SGFzaCh1bmRlZmluZWQsIG1hcC5fY29uZmlnLmhhc2goa2V5KSwga2V5LCBtYXApO1xyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5LCBhbHQpIHtcclxuICByZXR1cm4gdHJ5R2V0KGFsdCwga2V5LCB0aGlzKTtcclxufTtcclxuLyoqXHJcbiAgICBEb2VzIGFuIGVudHJ5IGV4aXN0IGZvciBga2V5YCBpbiBgbWFwYD8gVXNlcyBjdXN0b20gYGhhc2hgLlxyXG4qL1xyXG5cclxuXHJcbnZhciBoYXNIYXNoID0gaGFtdC5oYXMgPSBmdW5jdGlvbiAoaGFzaCwga2V5LCBtYXApIHtcclxuICByZXR1cm4gdHJ5R2V0SGFzaChub3RoaW5nLCBoYXNoLCBrZXksIG1hcCkgIT09IG5vdGhpbmc7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLmhhc0hhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5KSB7XHJcbiAgcmV0dXJuIGhhc0hhc2goaGFzaCwga2V5LCB0aGlzKTtcclxufTtcclxuLyoqXHJcbiAgICBEb2VzIGFuIGVudHJ5IGV4aXN0IGZvciBga2V5YCBpbiBgbWFwYD8gVXNlcyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxyXG4qL1xyXG5cclxuXHJcbnZhciBoYXMgPSBoYW10LmhhcyA9IGZ1bmN0aW9uIChrZXksIG1hcCkge1xyXG4gIHJldHVybiBoYXNIYXNoKG1hcC5fY29uZmlnLmhhc2goa2V5KSwga2V5LCBtYXApO1xyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgcmV0dXJuIGhhcyhrZXksIHRoaXMpO1xyXG59O1xyXG5cclxudmFyIGRlZktleUNvbXBhcmUgPSBmdW5jdGlvbiBkZWZLZXlDb21wYXJlKHgsIHkpIHtcclxuICByZXR1cm4geCA9PT0geTtcclxufTtcclxuLyoqXHJcbiAgICBDcmVhdGUgYW4gZW1wdHkgbWFwLlxyXG5cclxuICAgIEBwYXJhbSBjb25maWcgQ29uZmlndXJhdGlvbi5cclxuKi9cclxuXHJcblxyXG5oYW10Lm1ha2UgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgcmV0dXJuIG5ldyBNYXAoMCwgMCwge1xyXG4gICAga2V5RXE6IGNvbmZpZyAmJiBjb25maWcua2V5RXEgfHwgZGVmS2V5Q29tcGFyZSxcclxuICAgIGhhc2g6IGNvbmZpZyAmJiBjb25maWcuaGFzaCB8fCBoYXNoXHJcbiAgfSwgZW1wdHksIDApO1xyXG59O1xyXG4vKipcclxuICAgIEVtcHR5IG1hcC5cclxuKi9cclxuXHJcblxyXG5oYW10LmVtcHR5ID0gaGFtdC5tYWtlKCk7XHJcbi8qKlxyXG4gICAgRG9lcyBgbWFwYCBjb250YWluIGFueSBlbGVtZW50cz9cclxuKi9cclxuXHJcbnZhciBpc0VtcHR5ID0gaGFtdC5pc0VtcHR5ID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gIHJldHVybiBtYXAgJiYgISFpc0VtcHR5Tm9kZShtYXAuX3Jvb3QpO1xyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBpc0VtcHR5KHRoaXMpO1xyXG59O1xyXG4vKiBVcGRhdGVzXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vKipcclxuICAgIEFsdGVyIHRoZSB2YWx1ZSBzdG9yZWQgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGZ1bmN0aW9uIGBmYCB1c2luZ1xyXG4gICAgY3VzdG9tIGhhc2guXHJcblxyXG4gICAgYGZgIGlzIGludm9rZWQgd2l0aCB0aGUgY3VycmVudCB2YWx1ZSBmb3IgYGtgIGlmIGl0IGV4aXN0cyxcclxuICAgIG9yIG5vIGFyZ3VtZW50cyBpZiBubyBzdWNoIHZhbHVlIGV4aXN0cy4gYG1vZGlmeWAgd2lsbCBhbHdheXMgZWl0aGVyXHJcbiAgICB1cGRhdGUgb3IgaW5zZXJ0IGEgdmFsdWUgaW50byB0aGUgbWFwLlxyXG5cclxuICAgIFJldHVybnMgYSBtYXAgd2l0aCB0aGUgbW9kaWZpZWQgdmFsdWUuIERvZXMgbm90IGFsdGVyIGBtYXBgLlxyXG4qL1xyXG5cclxuXHJcbnZhciBtb2RpZnlIYXNoID0gaGFtdC5tb2RpZnlIYXNoID0gZnVuY3Rpb24gKGYsIGhhc2gsIGtleSwgbWFwKSB7XHJcbiAgdmFyIHNpemUgPSB7XHJcbiAgICB2YWx1ZTogbWFwLl9zaXplXHJcbiAgfTtcclxuXHJcbiAgdmFyIG5ld1Jvb3QgPSBtYXAuX3Jvb3QuX21vZGlmeShtYXAuX2VkaXRhYmxlID8gbWFwLl9lZGl0IDogTmFOLCBtYXAuX2NvbmZpZy5rZXlFcSwgMCwgZiwgaGFzaCwga2V5LCBzaXplKTtcclxuXHJcbiAgcmV0dXJuIG1hcC5zZXRUcmVlKG5ld1Jvb3QsIHNpemUudmFsdWUpO1xyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS5tb2RpZnlIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgZikge1xyXG4gIHJldHVybiBtb2RpZnlIYXNoKGYsIGhhc2gsIGtleSwgdGhpcyk7XHJcbn07XHJcbi8qKlxyXG4gICAgQWx0ZXIgdGhlIHZhbHVlIHN0b3JlZCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgZnVuY3Rpb24gYGZgIHVzaW5nXHJcbiAgICBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxyXG5cclxuICAgIEBzZWUgYG1vZGlmeUhhc2hgXHJcbiovXHJcblxyXG5cclxudmFyIG1vZGlmeSA9IGhhbXQubW9kaWZ5ID0gZnVuY3Rpb24gKGYsIGtleSwgbWFwKSB7XHJcbiAgcmV0dXJuIG1vZGlmeUhhc2goZiwgbWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIG1hcCk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLm1vZGlmeSA9IGZ1bmN0aW9uIChrZXksIGYpIHtcclxuICByZXR1cm4gbW9kaWZ5KGYsIGtleSwgdGhpcyk7XHJcbn07XHJcbi8qKlxyXG4gICAgU3RvcmUgYHZhbHVlYCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgY3VzdG9tIGBoYXNoYC5cclxuXHJcbiAgICBSZXR1cm5zIGEgbWFwIHdpdGggdGhlIG1vZGlmaWVkIHZhbHVlLiBEb2VzIG5vdCBhbHRlciBgbWFwYC5cclxuKi9cclxuXHJcblxyXG52YXIgc2V0SGFzaCA9IGhhbXQuc2V0SGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXksIHZhbHVlLCBtYXApIHtcclxuICByZXR1cm4gbW9kaWZ5SGFzaChjb25zdGFudCh2YWx1ZSksIGhhc2gsIGtleSwgbWFwKTtcclxufTtcclxuXHJcbk1hcC5wcm90b3R5cGUuc2V0SGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXksIHZhbHVlKSB7XHJcbiAgcmV0dXJuIHNldEhhc2goaGFzaCwga2V5LCB2YWx1ZSwgdGhpcyk7XHJcbn07XHJcbi8qKlxyXG4gICAgU3RvcmUgYHZhbHVlYCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgaW50ZXJuYWwgaGFzaCBmdW5jdGlvbi5cclxuXHJcbiAgICBAc2VlIGBzZXRIYXNoYFxyXG4qL1xyXG5cclxuXHJcbnZhciBzZXQgPSBoYW10LnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBtYXApIHtcclxuICByZXR1cm4gc2V0SGFzaChtYXAuX2NvbmZpZy5oYXNoKGtleSksIGtleSwgdmFsdWUsIG1hcCk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgcmV0dXJuIHNldChrZXksIHZhbHVlLCB0aGlzKTtcclxufTtcclxuLyoqXHJcbiAgICBSZW1vdmUgdGhlIGVudHJ5IGZvciBga2V5YCBpbiBgbWFwYC5cclxuXHJcbiAgICBSZXR1cm5zIGEgbWFwIHdpdGggdGhlIHZhbHVlIHJlbW92ZWQuIERvZXMgbm90IGFsdGVyIGBtYXBgLlxyXG4qL1xyXG5cclxuXHJcbnZhciBkZWwgPSBjb25zdGFudChub3RoaW5nKTtcclxuXHJcbnZhciByZW1vdmVIYXNoID0gaGFtdC5yZW1vdmVIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgbWFwKSB7XHJcbiAgcmV0dXJuIG1vZGlmeUhhc2goZGVsLCBoYXNoLCBrZXksIG1hcCk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLnJlbW92ZUhhc2ggPSBNYXAucHJvdG90eXBlLmRlbGV0ZUhhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5KSB7XHJcbiAgcmV0dXJuIHJlbW92ZUhhc2goaGFzaCwga2V5LCB0aGlzKTtcclxufTtcclxuLyoqXHJcbiAgICBSZW1vdmUgdGhlIGVudHJ5IGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxyXG5cclxuICAgIEBzZWUgYHJlbW92ZUhhc2hgXHJcbiovXHJcblxyXG5cclxudmFyIHJlbW92ZSA9IGhhbXQucmVtb3ZlID0gZnVuY3Rpb24gKGtleSwgbWFwKSB7XHJcbiAgcmV0dXJuIHJlbW92ZUhhc2gobWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIG1hcCk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLnJlbW92ZSA9IE1hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gIHJldHVybiByZW1vdmUoa2V5LCB0aGlzKTtcclxufTtcclxuLyogTXV0YXRpb25cclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8qKlxyXG4gICAgTWFyayBgbWFwYCBhcyBtdXRhYmxlLlxyXG4gKi9cclxuXHJcblxyXG52YXIgYmVnaW5NdXRhdGlvbiA9IGhhbXQuYmVnaW5NdXRhdGlvbiA9IGZ1bmN0aW9uIChtYXApIHtcclxuICByZXR1cm4gbmV3IE1hcChtYXAuX2VkaXRhYmxlICsgMSwgbWFwLl9lZGl0ICsgMSwgbWFwLl9jb25maWcsIG1hcC5fcm9vdCwgbWFwLl9zaXplKTtcclxufTtcclxuXHJcbk1hcC5wcm90b3R5cGUuYmVnaW5NdXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gYmVnaW5NdXRhdGlvbih0aGlzKTtcclxufTtcclxuLyoqXHJcbiAgICBNYXJrIGBtYXBgIGFzIGltbXV0YWJsZS5cclxuICovXHJcblxyXG5cclxudmFyIGVuZE11dGF0aW9uID0gaGFtdC5lbmRNdXRhdGlvbiA9IGZ1bmN0aW9uIChtYXApIHtcclxuICBtYXAuX2VkaXRhYmxlID0gbWFwLl9lZGl0YWJsZSAmJiBtYXAuX2VkaXRhYmxlIC0gMTtcclxuICByZXR1cm4gbWFwO1xyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS5lbmRNdXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gZW5kTXV0YXRpb24odGhpcyk7XHJcbn07XHJcbi8qKlxyXG4gICAgTXV0YXRlIGBtYXBgIHdpdGhpbiB0aGUgY29udGV4dCBvZiBgZmAuXHJcbiAgICBAcGFyYW0gZlxyXG4gICAgQHBhcmFtIG1hcCBIQU1UXHJcbiovXHJcblxyXG5cclxudmFyIG11dGF0ZSA9IGhhbXQubXV0YXRlID0gZnVuY3Rpb24gKGYsIG1hcCkge1xyXG4gIHZhciB0cmFuc2llbnQgPSBiZWdpbk11dGF0aW9uKG1hcCk7XHJcbiAgZih0cmFuc2llbnQpO1xyXG4gIHJldHVybiBlbmRNdXRhdGlvbih0cmFuc2llbnQpO1xyXG59O1xyXG5cclxuTWFwLnByb3RvdHlwZS5tdXRhdGUgPSBmdW5jdGlvbiAoZikge1xyXG4gIHJldHVybiBtdXRhdGUoZiwgdGhpcyk7XHJcbn07XHJcbi8qIFRyYXZlcnNhbFxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLyoqXHJcbiAgICBBcHBseSBhIGNvbnRpbnVhdGlvbi5cclxuKi9cclxuXHJcblxyXG52YXIgYXBwayA9IGZ1bmN0aW9uIGFwcGsoaykge1xyXG4gIHJldHVybiBrICYmIGxhenlWaXNpdENoaWxkcmVuKGtbMF0sIGtbMV0sIGtbMl0sIGtbM10sIGtbNF0pO1xyXG59O1xyXG4vKipcclxuICAgIFJlY3Vyc2l2ZWx5IHZpc2l0IGFsbCB2YWx1ZXMgc3RvcmVkIGluIGFuIGFycmF5IG9mIG5vZGVzIGxhemlseS5cclxuKi9cclxuXHJcblxyXG52YXIgbGF6eVZpc2l0Q2hpbGRyZW4gPSBmdW5jdGlvbiBsYXp5VmlzaXRDaGlsZHJlbihsZW4sIGNoaWxkcmVuLCBpLCBmLCBrKSB7XHJcbiAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2krK107XHJcbiAgICBpZiAoY2hpbGQgJiYgIWlzRW1wdHlOb2RlKGNoaWxkKSkgcmV0dXJuIGxhenlWaXNpdChjaGlsZCwgZiwgW2xlbiwgY2hpbGRyZW4sIGksIGYsIGtdKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBhcHBrKGspO1xyXG59O1xyXG4vKipcclxuICAgIFJlY3Vyc2l2ZWx5IHZpc2l0IGFsbCB2YWx1ZXMgc3RvcmVkIGluIGBub2RlYCBsYXppbHkuXHJcbiovXHJcblxyXG5cclxudmFyIGxhenlWaXNpdCA9IGZ1bmN0aW9uIGxhenlWaXNpdChub2RlLCBmLCBrKSB7XHJcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgIGNhc2UgTEVBRjpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB2YWx1ZTogZihub2RlKSxcclxuICAgICAgICByZXN0OiBrXHJcbiAgICAgIH07XHJcblxyXG4gICAgY2FzZSBDT0xMSVNJT046XHJcbiAgICBjYXNlIEFSUkFZOlxyXG4gICAgY2FzZSBJTkRFWDpcclxuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcclxuICAgICAgcmV0dXJuIGxhenlWaXNpdENoaWxkcmVuKGNoaWxkcmVuLmxlbmd0aCwgY2hpbGRyZW4sIDAsIGYsIGspO1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBhcHBrKGspO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBET05FID0ge1xyXG4gIGRvbmU6IHRydWVcclxufTtcclxuLyoqXHJcbiAgICBKYXZhc2NyaXB0IGl0ZXJhdG9yIG92ZXIgYSBtYXAuXHJcbiovXHJcblxyXG5mdW5jdGlvbiBNYXBJdGVyYXRvcih2KSB7XHJcbiAgdGhpcy52ID0gdjtcclxufVxyXG5cclxuTWFwSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKCF0aGlzLnYpIHJldHVybiBET05FO1xyXG4gIHZhciB2MCA9IHRoaXMudjtcclxuICB0aGlzLnYgPSBhcHBrKHYwLnJlc3QpO1xyXG4gIHJldHVybiB2MDtcclxufTtcclxuXHJcbk1hcEl0ZXJhdG9yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG4vKipcclxuICAgIExhemlseSB2aXNpdCBlYWNoIHZhbHVlIGluIG1hcCB3aXRoIGZ1bmN0aW9uIGBmYC5cclxuKi9cclxuXHJcblxyXG52YXIgdmlzaXQgPSBmdW5jdGlvbiB2aXNpdChtYXAsIGYpIHtcclxuICByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKGxhenlWaXNpdChtYXAuX3Jvb3QsIGYpKTtcclxufTtcclxuLyoqXHJcbiAgICBHZXQgYSBKYXZhc2NzcmlwdCBpdGVyYXRvciBvZiBgbWFwYC5cclxuXHJcbiAgICBJdGVyYXRlcyBvdmVyIGBba2V5LCB2YWx1ZV1gIGFycmF5cy5cclxuKi9cclxuXHJcblxyXG52YXIgYnVpbGRQYWlycyA9IGZ1bmN0aW9uIGJ1aWxkUGFpcnMoeCkge1xyXG4gIHJldHVybiBbeC5rZXksIHgudmFsdWVdO1xyXG59O1xyXG5cclxudmFyIGVudHJpZXMgPSBoYW10LmVudHJpZXMgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgcmV0dXJuIHZpc2l0KG1hcCwgYnVpbGRQYWlycyk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLmVudHJpZXMgPSBNYXAucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGVudHJpZXModGhpcyk7XHJcbn07XHJcbi8qKlxyXG4gICAgR2V0IGFycmF5IG9mIGFsbCBrZXlzIGluIGBtYXBgLlxyXG5cclxuICAgIE9yZGVyIGlzIG5vdCBndWFyYW50ZWVkLlxyXG4qL1xyXG5cclxuXHJcbnZhciBidWlsZEtleXMgPSBmdW5jdGlvbiBidWlsZEtleXMoeCkge1xyXG4gIHJldHVybiB4LmtleTtcclxufTtcclxuXHJcbnZhciBrZXlzID0gaGFtdC5rZXlzID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gIHJldHVybiB2aXNpdChtYXAsIGJ1aWxkS2V5cyk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGtleXModGhpcyk7XHJcbn07XHJcbi8qKlxyXG4gICAgR2V0IGFycmF5IG9mIGFsbCB2YWx1ZXMgaW4gYG1hcGAuXHJcblxyXG4gICAgT3JkZXIgaXMgbm90IGd1YXJhbnRlZWQsIGR1cGxpY2F0ZXMgYXJlIHByZXNlcnZlZC5cclxuKi9cclxuXHJcblxyXG52YXIgYnVpbGRWYWx1ZXMgPSBmdW5jdGlvbiBidWlsZFZhbHVlcyh4KSB7XHJcbiAgcmV0dXJuIHgudmFsdWU7XHJcbn07XHJcblxyXG52YXIgdmFsdWVzID0gaGFtdC52YWx1ZXMgPSBNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uIChtYXApIHtcclxuICByZXR1cm4gdmlzaXQobWFwLCBidWlsZFZhbHVlcyk7XHJcbn07XHJcblxyXG5NYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdmFsdWVzKHRoaXMpO1xyXG59O1xyXG4vKiBGb2xkXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vKipcclxuICAgIFZpc2l0IGV2ZXJ5IGVudHJ5IGluIHRoZSBtYXAsIGFnZ3JlZ2F0aW5nIGRhdGEuXHJcblxyXG4gICAgT3JkZXIgb2Ygbm9kZXMgaXMgbm90IGd1YXJhbnRlZWQuXHJcblxyXG4gICAgQHBhcmFtIGYgRnVuY3Rpb24gbWFwcGluZyBhY2N1bXVsYXRlZCB2YWx1ZSwgdmFsdWUsIGFuZCBrZXkgdG8gbmV3IHZhbHVlLlxyXG4gICAgQHBhcmFtIHogU3RhcnRpbmcgdmFsdWUuXHJcbiAgICBAcGFyYW0gbSBIQU1UXHJcbiovXHJcblxyXG5cclxudmFyIGZvbGQgPSBoYW10LmZvbGQgPSBmdW5jdGlvbiAoZiwgeiwgbSkge1xyXG4gIHZhciByb290ID0gbS5fcm9vdDtcclxuICBpZiAocm9vdC50eXBlID09PSBMRUFGKSByZXR1cm4gZih6LCByb290LnZhbHVlLCByb290LmtleSk7XHJcbiAgdmFyIHRvVmlzaXQgPSBbcm9vdC5jaGlsZHJlbl07XHJcbiAgdmFyIGNoaWxkcmVuID0gdm9pZCAwO1xyXG5cclxuICB3aGlsZSAoY2hpbGRyZW4gPSB0b1Zpc2l0LnBvcCgpKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOykge1xyXG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpKytdO1xyXG5cclxuICAgICAgaWYgKGNoaWxkICYmIGNoaWxkLnR5cGUpIHtcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gTEVBRikgeiA9IGYoeiwgY2hpbGQudmFsdWUsIGNoaWxkLmtleSk7ZWxzZSB0b1Zpc2l0LnB1c2goY2hpbGQuY2hpbGRyZW4pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gejtcclxufTtcclxuXHJcbk1hcC5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uIChmLCB6KSB7XHJcbiAgcmV0dXJuIGZvbGQoZiwgeiwgdGhpcyk7XHJcbn07XHJcbi8qKlxyXG4gICAgVmlzaXQgZXZlcnkgZW50cnkgaW4gdGhlIG1hcCwgYWdncmVnYXRpbmcgZGF0YS5cclxuXHJcbiAgICBPcmRlciBvZiBub2RlcyBpcyBub3QgZ3VhcmFudGVlZC5cclxuXHJcbiAgICBAcGFyYW0gZiBGdW5jdGlvbiBpbnZva2VkIHdpdGggdmFsdWUgYW5kIGtleVxyXG4gICAgQHBhcmFtIG1hcCBIQU1UXHJcbiovXHJcblxyXG5cclxudmFyIGZvckVhY2ggPSBoYW10LmZvckVhY2ggPSBmdW5jdGlvbiAoZiwgbWFwKSB7XHJcbiAgcmV0dXJuIGZvbGQoZnVuY3Rpb24gKF8sIHZhbHVlLCBrZXkpIHtcclxuICAgIHJldHVybiBmKHZhbHVlLCBrZXksIG1hcCk7XHJcbiAgfSwgbnVsbCwgbWFwKTtcclxufTtcclxuXHJcbk1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmKSB7XHJcbiAgcmV0dXJuIGZvckVhY2goZiwgdGhpcyk7XHJcbn07XHJcbi8qIEFnZ3JlZ2F0ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLyoqXHJcbiAgICBHZXQgdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIGBtYXBgLlxyXG4qL1xyXG5cclxuXHJcbnZhciBjb3VudCA9IGhhbXQuY291bnQgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgcmV0dXJuIG1hcC5fc2l6ZTtcclxufTtcclxuXHJcbk1hcC5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGNvdW50KHRoaXMpO1xyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcC5wcm90b3R5cGUsICdzaXplJywge1xyXG4gIGdldDogTWFwLnByb3RvdHlwZS5jb3VudFxyXG59KTtcclxuLyogRXhwb3J0XHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5pZiAoIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBoYW10O1xyXG59IGVsc2Uge1xyXG4gIHVuZGVmaW5lZC5oYW10ID0gaGFtdDtcclxufVxyXG59KTtcclxuXHJcbmNsYXNzIEJ1aWx0SW5NYXAge1xyXG4gIGNvbnN0cnVjdG9yKGV4aXN0aW5nKSB7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWFwXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcChleGlzdGluZyA9PT0gbnVsbCB8fCBleGlzdGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhpc3RpbmcuZW50cmllcygpKTtcclxuICB9XHJcblxyXG4gIGtleXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcclxuICB9XHJcblxyXG4gIGVudHJpZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLmVudHJpZXMoKTtcclxuICB9XHJcblxyXG4gIGdldChrKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldChrKTtcclxuICB9XHJcblxyXG4gIGhhcyhrKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyhrKTtcclxuICB9XHJcblxyXG4gIHNldChrLCB2KSB7XHJcbiAgICB0aGlzLl9tYXAuc2V0KGssIHYpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgZGVsZXRlKGspIHtcclxuICAgIHRoaXMuX21hcC5kZWxldGUoayk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBjbG9uZSgpIHtcclxuICAgIHJldHVybiBwZXJzaXN0ZW50TWFwKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgdG9NYXAoKSB7XHJcbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzLl9tYXApO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIEhhc2hBcnJheU1hcHBlZFRyaWVNYXAge1xyXG4gIC8vIEJlY2F1c2UgaGFtdC5lbXB0eSBpcyBub3QgYSBmdW5jdGlvbiB0aGVyZSBpcyBubyB3YXkgdG8gaW50cm9kdWNlIHR5cGVcclxuICAvLyBwYXJhbWV0ZXJzIG9uIGl0LCBzbyBlbXB0eSBpcyB0eXBlZCBhcyBIQU1UUGx1c01hcDxzdHJpbmcsIG1peGVkPi5cclxuICAvLyAkRmxvd0lzc3VlXHJcbiAgY29uc3RydWN0b3IoZXhpc3RpbmcpIHtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9oYW10XCIsIGhhbXRfMS5lbXB0eS5iZWdpbk11dGF0aW9uKCkpO1xyXG5cclxuICAgIGlmIChleGlzdGluZyBpbnN0YW5jZW9mIEhhc2hBcnJheU1hcHBlZFRyaWVNYXApIHtcclxuICAgICAgY29uc3QgaCA9IGV4aXN0aW5nLl9oYW10LmVuZE11dGF0aW9uKCk7XHJcblxyXG4gICAgICBleGlzdGluZy5faGFtdCA9IGguYmVnaW5NdXRhdGlvbigpO1xyXG4gICAgICB0aGlzLl9oYW10ID0gaC5iZWdpbk11dGF0aW9uKCk7XHJcbiAgICB9IGVsc2UgaWYgKGV4aXN0aW5nKSB7XHJcbiAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIGV4aXN0aW5nLmVudHJpZXMoKSkge1xyXG4gICAgICAgIHRoaXMuX2hhbXQuc2V0KGssIHYpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBrZXlzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2hhbXQua2V5cygpO1xyXG4gIH1cclxuXHJcbiAgZW50cmllcygpIHtcclxuICAgIHJldHVybiB0aGlzLl9oYW10LmVudHJpZXMoKTtcclxuICB9XHJcblxyXG4gIGdldChrKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faGFtdC5nZXQoayk7XHJcbiAgfVxyXG5cclxuICBoYXMoaykge1xyXG4gICAgcmV0dXJuIHRoaXMuX2hhbXQuaGFzKGspO1xyXG4gIH1cclxuXHJcbiAgc2V0KGssIHYpIHtcclxuICAgIHRoaXMuX2hhbXQuc2V0KGssIHYpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgZGVsZXRlKGspIHtcclxuICAgIHRoaXMuX2hhbXQuZGVsZXRlKGspO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgY2xvbmUoKSB7XHJcbiAgICByZXR1cm4gcGVyc2lzdGVudE1hcCh0aGlzKTtcclxuICB9XHJcblxyXG4gIHRvTWFwKCkge1xyXG4gICAgcmV0dXJuIG5ldyBNYXAodGhpcy5faGFtdCk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gcGVyc2lzdGVudE1hcChleGlzdGluZykge1xyXG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfaGFtdF8yMDIwJykpIHtcclxuICAgIHJldHVybiBuZXcgSGFzaEFycmF5TWFwcGVkVHJpZU1hcChleGlzdGluZyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBuZXcgQnVpbHRJbk1hcChleGlzdGluZyk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgUmVjb2lsX1BlcnNpc3RlbnRNYXAgPSB7XHJcbiAgcGVyc2lzdGVudE1hcFxyXG59O1xyXG5cclxudmFyIFJlY29pbF9QZXJzaXN0ZW50TWFwXzEgPSBSZWNvaWxfUGVyc2lzdGVudE1hcC5wZXJzaXN0ZW50TWFwO1xyXG5cclxudmFyIFJlY29pbF9QZXJzaXN0ZW50TWFwJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIHBlcnNpc3RlbnRNYXA6IFJlY29pbF9QZXJzaXN0ZW50TWFwXzFcclxufSk7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBhIHNldCBjb250YWluaW5nIGFsbCBvZiB0aGUgdmFsdWVzIGZyb20gdGhlIGZpcnN0IHNldCB0aGF0IGFyZSBub3RcclxuICogcHJlc2VudCBpbiBhbnkgb2YgdGhlIHN1YnNlcXVlbnQgc2V0cy5cclxuICpcclxuICogTm90ZTogdGhpcyBpcyB3cml0dGVuIHByb2NlZHVyYWxseSAoaS5lLiwgd2l0aG91dCBmaWx0ZXJTZXQpIGZvciBwZXJmb3JtYW50XHJcbiAqIHVzZSBpbiB0aWdodCBsb29wcy5cclxuICovXHJcblxyXG5mdW5jdGlvbiBkaWZmZXJlbmNlU2V0cyhzZXQsIC4uLnNldHNXaXRoVmFsdWVzVG9SZW1vdmUpIHtcclxuICBjb25zdCByZXQgPSBuZXcgU2V0KCk7XHJcblxyXG4gIEZJUlNUOiBmb3IgKGNvbnN0IHZhbHVlIG9mIHNldCkge1xyXG4gICAgZm9yIChjb25zdCBvdGhlclNldCBvZiBzZXRzV2l0aFZhbHVlc1RvUmVtb3ZlKSB7XHJcbiAgICAgIGlmIChvdGhlclNldC5oYXModmFsdWUpKSB7XHJcbiAgICAgICAgY29udGludWUgRklSU1Q7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXQuYWRkKHZhbHVlKTtcclxuICB9XHJcblxyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfZGlmZmVyZW5jZVNldHMgPSBkaWZmZXJlbmNlU2V0cztcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbmV3IE1hcCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIHRoZSBvcmlnaW5hbCwgYnV0IHdpdGggdGhlXHJcbiAqIHZhbHVlcyByZXBsYWNlZCB3aXRoIHRoZSBvdXRwdXQgb2YgdGhlIGdpdmVuIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1hcE1hcChtYXAsIGNhbGxiYWNrKSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xyXG4gIG1hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICByZXN1bHQuc2V0KGtleSwgY2FsbGJhY2sodmFsdWUsIGtleSkpO1xyXG4gIH0pO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfbWFwTWFwID0gbWFwTWFwO1xyXG5cclxuZnVuY3Rpb24gbWFrZUdyYXBoKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBub2RlRGVwczogbmV3IE1hcCgpLFxyXG4gICAgbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsb25lR3JhcGgoZ3JhcGgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgbm9kZURlcHM6IFJlY29pbF9tYXBNYXAoZ3JhcGgubm9kZURlcHMsIHMgPT4gbmV3IFNldChzKSksXHJcbiAgICBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uczogUmVjb2lsX21hcE1hcChncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucywgcyA9PiBuZXcgU2V0KHMpKVxyXG4gIH07XHJcbn0gLy8gTm90ZSB0aGF0IHRoaXMgb3ZlcndyaXRlcyB0aGUgZGVwcyBvZiBleGlzdGluZyBub2RlcywgcmF0aGVyIHRoYW4gdW5pb25pbmdcclxuLy8gdGhlIG5ldyBkZXBzIHdpdGggdGhlIG9sZCBkZXBzLlxyXG5cclxuXHJcbmZ1bmN0aW9uIG1lcmdlRGVwc0ludG9HcmFwaChrZXksIG5ld0RlcHMsIGdyYXBoLCAvLyBJZiBvbGRlckdyYXBoIGlzIGdpdmVuIHRoZW4gd2Ugd2lsbCBub3Qgb3ZlcndyaXRlIGNoYW5nZXMgbWFkZSB0byB0aGUgZ2l2ZW5cclxuLy8gZ3JhcGggY29tcGFyZWQgd2l0aCBvbGRlckdyYXBoOlxyXG5vbGRlckdyYXBoKSB7XHJcbiAgY29uc3Qge1xyXG4gICAgbm9kZURlcHMsXHJcbiAgICBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uc1xyXG4gIH0gPSBncmFwaDtcclxuICBjb25zdCBvbGREZXBzID0gbm9kZURlcHMuZ2V0KGtleSk7XHJcblxyXG4gIGlmIChvbGREZXBzICYmIG9sZGVyR3JhcGggJiYgb2xkRGVwcyAhPT0gb2xkZXJHcmFwaC5ub2RlRGVwcy5nZXQoa2V5KSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH0gLy8gVXBkYXRlIG5vZGVEZXBzOlxyXG5cclxuXHJcbiAgbm9kZURlcHMuc2V0KGtleSwgbmV3RGVwcyk7IC8vIEFkZCBuZXcgZGVwcyB0byBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uczpcclxuXHJcbiAgY29uc3QgYWRkZWREZXBzID0gb2xkRGVwcyA9PSBudWxsID8gbmV3RGVwcyA6IFJlY29pbF9kaWZmZXJlbmNlU2V0cyhuZXdEZXBzLCBvbGREZXBzKTtcclxuXHJcbiAgZm9yIChjb25zdCBkZXAgb2YgYWRkZWREZXBzKSB7XHJcbiAgICBpZiAoIW5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmhhcyhkZXApKSB7XHJcbiAgICAgIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zLnNldChkZXAsIG5ldyBTZXQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZXhpc3RpbmcgPSBSZWNvaWxfbnVsbHRocm93cyhub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQoZGVwKSk7XHJcbiAgICBleGlzdGluZy5hZGQoa2V5KTtcclxuICB9IC8vIFJlbW92ZSByZW1vdmVkIGRlcHMgZnJvbSBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uczpcclxuXHJcblxyXG4gIGlmIChvbGREZXBzKSB7XHJcbiAgICBjb25zdCByZW1vdmVkRGVwcyA9IFJlY29pbF9kaWZmZXJlbmNlU2V0cyhvbGREZXBzLCBuZXdEZXBzKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiByZW1vdmVkRGVwcykge1xyXG4gICAgICBpZiAoIW5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmhhcyhkZXApKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBleGlzdGluZyA9IFJlY29pbF9udWxsdGhyb3dzKG5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChkZXApKTtcclxuICAgICAgZXhpc3RpbmcuZGVsZXRlKGtleSk7XHJcblxyXG4gICAgICBpZiAoZXhpc3Rpbmcuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmRlbGV0ZShkZXApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzYXZlRGVwc1RvU3RvcmUoa2V5LCBkZXBzLCBzdG9yZSwgdmVyc2lvbikge1xyXG4gIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZSwgX3N0b3JlU3RhdGUkcHJldmlvdXNULCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QyLCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QzO1xyXG5cclxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgaWYgKCEodmVyc2lvbiA9PT0gc3RvcmVTdGF0ZS5jdXJyZW50VHJlZS52ZXJzaW9uIHx8IHZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkbmV4dFRyZWUudmVyc2lvbikgfHwgdmVyc2lvbiA9PT0gKChfc3RvcmVTdGF0ZSRwcmV2aW91c1QgPSBzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkcHJldmlvdXNUID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRwcmV2aW91c1QudmVyc2lvbikpKSB7XHJcbiAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ1RyaWVkIHRvIHNhdmUgZGVwZW5kZW5jaWVzIHRvIGEgZGlzY2FyZGVkIHRyZWUnKTtcclxuICB9IC8vIE1lcmdlIHRoZSBkZXBlbmRlbmNpZXMgZGlzY292ZXJlZCBpbnRvIHRoZSBzdG9yZSdzIGRlcGVuZGVuY3kgbWFwXHJcbiAgLy8gZm9yIHRoZSB2ZXJzaW9uIHRoYXQgd2FzIHJlYWQ6XHJcblxyXG5cclxuICBjb25zdCBncmFwaCA9IHN0b3JlLmdldEdyYXBoKHZlcnNpb24pO1xyXG4gIG1lcmdlRGVwc0ludG9HcmFwaChrZXksIGRlcHMsIGdyYXBoKTsgLy8gSWYgdGhpcyB2ZXJzaW9uIGlzIG5vdCB0aGUgbGF0ZXN0IHZlcnNpb24sIGFsc28gd3JpdGUgdGhlc2UgZGVwZW5kZW5jaWVzXHJcbiAgLy8gaW50byBsYXRlciB2ZXJzaW9ucyBpZiB0aGV5IGRvbid0IGFscmVhZHkgaGF2ZSB0aGVpciBvd246XHJcblxyXG4gIGlmICh2ZXJzaW9uID09PSAoKF9zdG9yZVN0YXRlJHByZXZpb3VzVDIgPSBzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkcHJldmlvdXNUMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNUMi52ZXJzaW9uKSkge1xyXG4gICAgY29uc3QgY3VycmVudEdyYXBoID0gc3RvcmUuZ2V0R3JhcGgoc3RvcmVTdGF0ZS5jdXJyZW50VHJlZS52ZXJzaW9uKTtcclxuICAgIG1lcmdlRGVwc0ludG9HcmFwaChrZXksIGRlcHMsIGN1cnJlbnRHcmFwaCwgZ3JhcGgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUMyA9IHN0b3JlU3RhdGUucHJldmlvdXNUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRwcmV2aW91c1QzLnZlcnNpb24pIHx8IHZlcnNpb24gPT09IHN0b3JlU3RhdGUuY3VycmVudFRyZWUudmVyc2lvbikge1xyXG4gICAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlMjtcclxuXHJcbiAgICBjb25zdCBuZXh0VmVyc2lvbiA9IChfc3RvcmVTdGF0ZSRuZXh0VHJlZTIgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRuZXh0VHJlZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJG5leHRUcmVlMi52ZXJzaW9uO1xyXG5cclxuICAgIGlmIChuZXh0VmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnN0IG5leHRHcmFwaCA9IHN0b3JlLmdldEdyYXBoKG5leHRWZXJzaW9uKTtcclxuICAgICAgbWVyZ2VEZXBzSW50b0dyYXBoKGtleSwgZGVwcywgbmV4dEdyYXBoLCBncmFwaCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgUmVjb2lsX0dyYXBoID0ge1xyXG4gIGNsb25lR3JhcGgsXHJcbiAgZ3JhcGg6IG1ha2VHcmFwaCxcclxuICBzYXZlRGVwc1RvU3RvcmVcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcblxyXG5sZXQgbmV4dFRyZWVTdGF0ZVZlcnNpb24gPSAwO1xyXG5cclxuY29uc3QgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24gPSAoKSA9PiBuZXh0VHJlZVN0YXRlVmVyc2lvbisrO1xyXG5cclxubGV0IG5leHRTdG9yZUlEID0gMDtcclxuXHJcbmNvbnN0IGdldE5leHRTdG9yZUlEID0gKCkgPT4gbmV4dFN0b3JlSUQrKztcclxuXHJcbmxldCBuZXh0Q29tcG9uZW50SUQgPSAwO1xyXG5cclxuY29uc3QgZ2V0TmV4dENvbXBvbmVudElEID0gKCkgPT4gbmV4dENvbXBvbmVudElEKys7XHJcblxyXG52YXIgUmVjb2lsX0tleXMgPSB7XHJcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24sXHJcbiAgZ2V0TmV4dFN0b3JlSUQsXHJcbiAgZ2V0TmV4dENvbXBvbmVudElEXHJcbn07XHJcblxyXG5jb25zdCB7XHJcbiAgcGVyc2lzdGVudE1hcDogcGVyc2lzdGVudE1hcCQxXHJcbn0gPSBSZWNvaWxfUGVyc2lzdGVudE1hcCQxO1xyXG5cclxuY29uc3Qge1xyXG4gIGdyYXBoXHJcbn0gPSBSZWNvaWxfR3JhcGg7XHJcblxyXG5jb25zdCB7XHJcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb246IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDFcclxufSA9IFJlY29pbF9LZXlzO1xyXG5cclxuZnVuY3Rpb24gbWFrZUVtcHR5VHJlZVN0YXRlKCkge1xyXG4gIGNvbnN0IHZlcnNpb24gPSBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQxKCk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHZlcnNpb24sXHJcbiAgICBzdGF0ZUlEOiB2ZXJzaW9uLFxyXG4gICAgdHJhbnNhY3Rpb25NZXRhZGF0YToge30sXHJcbiAgICBkaXJ0eUF0b21zOiBuZXcgU2V0KCksXHJcbiAgICBhdG9tVmFsdWVzOiBwZXJzaXN0ZW50TWFwJDEoKSxcclxuICAgIG5vbnZhbGlkYXRlZEF0b21zOiBwZXJzaXN0ZW50TWFwJDEoKVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1ha2VFbXB0eVN0b3JlU3RhdGUoKSB7XHJcbiAgY29uc3QgY3VycmVudFRyZWUgPSBtYWtlRW1wdHlUcmVlU3RhdGUoKTtcclxuICByZXR1cm4ge1xyXG4gICAgY3VycmVudFRyZWUsXHJcbiAgICBuZXh0VHJlZTogbnVsbCxcclxuICAgIHByZXZpb3VzVHJlZTogbnVsbCxcclxuICAgIGNvbW1pdERlcHRoOiAwLFxyXG4gICAga25vd25BdG9tczogbmV3IFNldCgpLFxyXG4gICAga25vd25TZWxlY3RvcnM6IG5ldyBTZXQoKSxcclxuICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxyXG4gICAgbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxyXG4gICAgbm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxyXG4gICAgcXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQ6IFtdLFxyXG4gICAgc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzOiBuZXcgU2V0KCksXHJcbiAgICBncmFwaHNCeVZlcnNpb246IG5ldyBNYXAoKS5zZXQoY3VycmVudFRyZWUudmVyc2lvbiwgZ3JhcGgoKSksXHJcbiAgICByZXRlbnRpb246IHtcclxuICAgICAgcmVmZXJlbmNlQ291bnRzOiBuZXcgTWFwKCksXHJcbiAgICAgIG5vZGVzUmV0YWluZWRCeVpvbmU6IG5ldyBNYXAoKSxcclxuICAgICAgcmV0YWluYWJsZXNUb0NoZWNrRm9yUmVsZWFzZTogbmV3IFNldCgpXHJcbiAgICB9LFxyXG4gICAgbm9kZUNsZWFudXBGdW5jdGlvbnM6IG5ldyBNYXAoKVxyXG4gIH07XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfU3RhdGUgPSB7XHJcbiAgbWFrZUVtcHR5VHJlZVN0YXRlLFxyXG4gIG1ha2VFbXB0eVN0b3JlU3RhdGUsXHJcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb246IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDFcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcblxyXG5jbGFzcyBSZXRlbnRpb25ab25lIHt9XHJcblxyXG5mdW5jdGlvbiByZXRlbnRpb25ab25lKCkge1xyXG4gIHJldHVybiBuZXcgUmV0ZW50aW9uWm9uZSgpO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX1JldGVudGlvblpvbmUgPSB7XHJcbiAgUmV0ZW50aW9uWm9uZSxcclxuICByZXRlbnRpb25ab25lXHJcbn07XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFV0aWxpdGllcyBmb3Igd29ya2luZyB3aXRoIGJ1aWx0LWluIE1hcHMgYW5kIFNldHMgd2l0aG91dCBtdXRhdGluZyB0aGVtLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHNldEJ5QWRkaW5nVG9TZXQoc2V0LCB2KSB7XHJcbiAgY29uc3QgbmV4dCA9IG5ldyBTZXQoc2V0KTtcclxuICBuZXh0LmFkZCh2KTtcclxuICByZXR1cm4gbmV4dDtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0QnlEZWxldGluZ0Zyb21TZXQoc2V0LCB2KSB7XHJcbiAgY29uc3QgbmV4dCA9IG5ldyBTZXQoc2V0KTtcclxuICBuZXh0LmRlbGV0ZSh2KTtcclxuICByZXR1cm4gbmV4dDtcclxufVxyXG5cclxuZnVuY3Rpb24gbWFwQnlTZXR0aW5nSW5NYXAobWFwLCBrLCB2KSB7XHJcbiAgY29uc3QgbmV4dCA9IG5ldyBNYXAobWFwKTtcclxuICBuZXh0LnNldChrLCB2KTtcclxuICByZXR1cm4gbmV4dDtcclxufVxyXG5cclxuZnVuY3Rpb24gbWFwQnlVcGRhdGluZ0luTWFwKG1hcCwgaywgdXBkYXRlcikge1xyXG4gIGNvbnN0IG5leHQgPSBuZXcgTWFwKG1hcCk7XHJcbiAgbmV4dC5zZXQoaywgdXBkYXRlcihuZXh0LmdldChrKSkpO1xyXG4gIHJldHVybiBuZXh0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXBCeURlbGV0aW5nRnJvbU1hcChtYXAsIGspIHtcclxuICBjb25zdCBuZXh0ID0gbmV3IE1hcChtYXApO1xyXG4gIG5leHQuZGVsZXRlKGspO1xyXG4gIHJldHVybiBuZXh0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXBCeURlbGV0aW5nTXVsdGlwbGVGcm9tTWFwKG1hcCwga3MpIHtcclxuICBjb25zdCBuZXh0ID0gbmV3IE1hcChtYXApO1xyXG4gIGtzLmZvckVhY2goayA9PiBuZXh0LmRlbGV0ZShrKSk7XHJcbiAgcmV0dXJuIG5leHQ7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfQ29weU9uV3JpdGUgPSB7XHJcbiAgc2V0QnlBZGRpbmdUb1NldCxcclxuICBzZXRCeURlbGV0aW5nRnJvbVNldCxcclxuICBtYXBCeVNldHRpbmdJbk1hcCxcclxuICBtYXBCeVVwZGF0aW5nSW5NYXAsXHJcbiAgbWFwQnlEZWxldGluZ0Zyb21NYXAsXHJcbiAgbWFwQnlEZWxldGluZ011bHRpcGxlRnJvbU1hcFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaXRlcmFibGUgd2hvc2Ugb3V0cHV0IGlzIGdlbmVyYXRlZCBieSBwYXNzaW5nIHRoZSBpbnB1dFxyXG4gKiBpdGVyYWJsZSdzIHZhbHVlcyB0aHJvdWdoIHRoZSBmaWx0ZXIgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24qIGZpbHRlckl0ZXJhYmxlKGl0ZXJhYmxlLCBwcmVkaWNhdGUpIHtcclxuICAvLyBVc2UgZ2VuZXJhdG9yIHRvIGNyZWF0ZSBpdGVyYWJsZS9pdGVyYXRvclxyXG4gIGxldCBpbmRleCA9IDA7XHJcblxyXG4gIGZvciAoY29uc3QgdmFsdWUgb2YgaXRlcmFibGUpIHtcclxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4KyspKSB7XHJcbiAgICAgIHlpZWxkIHZhbHVlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIFJlY29pbF9maWx0ZXJJdGVyYWJsZSA9IGZpbHRlckl0ZXJhYmxlO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybiBhIHByb3h5IG9iamVjdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYmFzZSBhbmQgZmFjdG9yaWVzIG9iamVjdHMuXHJcbiAqIFRoZSBwcm94eSB3aWxsIGluY2x1ZGUgYWxsIHByb3BlcnRpZXMgb2YgdGhlIGJhc2Ugb2JqZWN0IGFzLWlzLlxyXG4gKiBUaGUgZmFjdG9yaWVzIG9iamVjdCBjb250YWlucyBjYWxsYmFja3MgdG8gb2J0YWluIHRoZSB2YWx1ZXMgb2YgdGhlIHByb3Blcmllc1xyXG4gKiBmb3IgaXRzIGtleXMuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBwcm92aWRpbmcgdXNlcnMgYW4gb2JqZWN0IHdoZXJlIHNvbWUgcHJvcGVydGllcyBtYXkgYmVcclxuICogbGF6aWx5IGNvbXB1dGVkIG9ubHkgb24gZmlyc3QgYWNjZXNzLlxyXG4gKi9cclxuLy8gJEZsb3dJc3N1ZVt1bmNsZWFyLXR5cGVdXHJcblxyXG5mdW5jdGlvbiBsYXp5UHJveHkoYmFzZSwgZmFjdG9yaWVzKSB7XHJcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoYmFzZSwge1xyXG4gICAgLy8gQ29tcHV0ZSBhbmQgY2FjaGUgbGF6eSBwcm9wZXJ0eSBpZiBub3QgYWxyZWFkeSBkb25lLlxyXG4gICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XHJcbiAgICAgIGlmICghKHByb3AgaW4gdGFyZ2V0KSAmJiBwcm9wIGluIGZhY3Rvcmllcykge1xyXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IGZhY3Rvcmllc1twcm9wXSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xyXG4gICAgfSxcclxuICAgIC8vIFRoaXMgbWV0aG9kIGFsbG93cyB1c2VyIHRvIGl0ZXJhdGUga2V5cyBhcyBub3JtYWxcclxuICAgIG93bktleXM6IHRhcmdldCA9PiB7XHJcblxyXG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KTtcclxuICAgIH1cclxuICB9KTsgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxyXG5cclxuICByZXR1cm4gcHJveHk7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfbGF6eVByb3h5ID0gbGF6eVByb3h5O1xyXG5cclxuY29uc3Qge1xyXG4gIGdldE5vZGU6IGdldE5vZGUkMSxcclxuICBnZXROb2RlTWF5YmU6IGdldE5vZGVNYXliZSQxLFxyXG4gIHJlY29pbFZhbHVlc0ZvcktleXM6IHJlY29pbFZhbHVlc0ZvcktleXMkMVxyXG59ID0gUmVjb2lsX05vZGU7XHJcblxyXG5jb25zdCB7XHJcbiAgUmV0ZW50aW9uWm9uZTogUmV0ZW50aW9uWm9uZSQxXHJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uWm9uZTtcclxuXHJcbmNvbnN0IHtcclxuICBzZXRCeUFkZGluZ1RvU2V0OiBzZXRCeUFkZGluZ1RvU2V0JDFcclxufSA9IFJlY29pbF9Db3B5T25Xcml0ZTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxyXG5cclxuXHJcbmNvbnN0IGVtcHR5U2V0ID0gT2JqZWN0LmZyZWV6ZShuZXcgU2V0KCkpO1xyXG5cclxuY2xhc3MgUmVhZE9ubHlSZWNvaWxWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige31cclxuXHJcbmZ1bmN0aW9uIGluaXRpYWxpemVSZXRlbnRpb25Gb3JOb2RlKHN0b3JlLCBub2RlS2V5LCByZXRhaW5lZEJ5KSB7XHJcbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XHJcbiAgICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qge1xyXG4gICAgbm9kZXNSZXRhaW5lZEJ5Wm9uZVxyXG4gIH0gPSBzdG9yZS5nZXRTdGF0ZSgpLnJldGVudGlvbjtcclxuXHJcbiAgZnVuY3Rpb24gYWRkVG9ab25lKHpvbmUpIHtcclxuICAgIGxldCBzZXQgPSBub2Rlc1JldGFpbmVkQnlab25lLmdldCh6b25lKTtcclxuXHJcbiAgICBpZiAoIXNldCkge1xyXG4gICAgICBub2Rlc1JldGFpbmVkQnlab25lLnNldCh6b25lLCBzZXQgPSBuZXcgU2V0KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldC5hZGQobm9kZUtleSk7XHJcbiAgfVxyXG5cclxuICBpZiAocmV0YWluZWRCeSBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMSkge1xyXG4gICAgYWRkVG9ab25lKHJldGFpbmVkQnkpO1xyXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRhaW5lZEJ5KSkge1xyXG4gICAgZm9yIChjb25zdCB6b25lIG9mIHJldGFpbmVkQnkpIHtcclxuICAgICAgYWRkVG9ab25lKHpvbmUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuICgpID0+IHtcclxuICAgIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICByZXRlbnRpb25cclxuICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGRlbGV0ZUZyb21ab25lKHpvbmUpIHtcclxuICAgICAgY29uc3Qgc2V0ID0gcmV0ZW50aW9uLm5vZGVzUmV0YWluZWRCeVpvbmUuZ2V0KHpvbmUpO1xyXG4gICAgICBzZXQgPT09IG51bGwgfHwgc2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXQuZGVsZXRlKG5vZGVLZXkpO1xyXG5cclxuICAgICAgaWYgKHNldCAmJiBzZXQuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgIHJldGVudGlvbi5ub2Rlc1JldGFpbmVkQnlab25lLmRlbGV0ZSh6b25lKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZXRhaW5lZEJ5IGluc3RhbmNlb2YgUmV0ZW50aW9uWm9uZSQxKSB7XHJcbiAgICAgIGRlbGV0ZUZyb21ab25lKHJldGFpbmVkQnkpO1xyXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldGFpbmVkQnkpKSB7XHJcbiAgICAgIGZvciAoY29uc3Qgem9uZSBvZiByZXRhaW5lZEJ5KSB7XHJcbiAgICAgICAgZGVsZXRlRnJvbVpvbmUoem9uZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0aWFsaXplTm9kZUlmTmV3VG9TdG9yZShzdG9yZSwgdHJlZVN0YXRlLCBrZXksIHRyaWdnZXIpIHtcclxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgaWYgKHN0b3JlU3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuaGFzKGtleSkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGNvbnN0IG5vZGUgPSBnZXROb2RlJDEoa2V5KTtcclxuICBjb25zdCByZXRlbnRpb25DbGVhbnVwID0gaW5pdGlhbGl6ZVJldGVudGlvbkZvck5vZGUoc3RvcmUsIGtleSwgbm9kZS5yZXRhaW5lZEJ5KTtcclxuICBjb25zdCBub2RlQ2xlYW51cCA9IG5vZGUuaW5pdChzdG9yZSwgdHJlZVN0YXRlLCB0cmlnZ2VyKTtcclxuICBzdG9yZVN0YXRlLm5vZGVDbGVhbnVwRnVuY3Rpb25zLnNldChrZXksICgpID0+IHtcclxuICAgIG5vZGVDbGVhbnVwKCk7XHJcbiAgICByZXRlbnRpb25DbGVhbnVwKCk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRpYWxpemVOb2RlKHN0b3JlLCBrZXksIHRyaWdnZXIpIHtcclxuICBpbml0aWFsaXplTm9kZUlmTmV3VG9TdG9yZShzdG9yZSwgc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSwga2V5LCB0cmlnZ2VyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2xlYW5VcE5vZGUoc3RvcmUsIGtleSkge1xyXG4gIHZhciBfc3RhdGUkbm9kZUNsZWFudXBGdW47XHJcblxyXG4gIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICAoX3N0YXRlJG5vZGVDbGVhbnVwRnVuID0gc3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9zdGF0ZSRub2RlQ2xlYW51cEZ1biA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlJG5vZGVDbGVhbnVwRnVuKCk7XHJcbiAgc3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuZGVsZXRlKGtleSk7XHJcbn0gLy8gR2V0IHRoZSBjdXJyZW50IHZhbHVlIGxvYWRhYmxlIG9mIGEgbm9kZSBhbmQgdXBkYXRlIHRoZSBzdGF0ZS5cclxuLy8gVXBkYXRlIGRlcGVuZGVuY2llcyBhbmQgc3Vic2NyaXB0aW9ucyBmb3Igc2VsZWN0b3JzLlxyXG4vLyBVcGRhdGUgc2F2ZWQgdmFsdWUgdmFsaWRhdGlvbiBmb3IgYXRvbXMuXHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0Tm9kZUxvYWRhYmxlKHN0b3JlLCBzdGF0ZSwga2V5KSB7XHJcbiAgaW5pdGlhbGl6ZU5vZGVJZk5ld1RvU3RvcmUoc3RvcmUsIHN0YXRlLCBrZXksICdnZXQnKTtcclxuICByZXR1cm4gZ2V0Tm9kZSQxKGtleSkuZ2V0KHN0b3JlLCBzdGF0ZSk7XHJcbn0gLy8gUGVlayBhdCB0aGUgY3VycmVudCB2YWx1ZSBsb2FkYWJsZSBmb3IgYSBub2RlIHdpdGhvdXQgYW55IGV2YWx1YXRpb24gb3Igc3RhdGUgY2hhbmdlXHJcblxyXG5cclxuZnVuY3Rpb24gcGVla05vZGVMb2FkYWJsZShzdG9yZSwgc3RhdGUsIGtleSkge1xyXG4gIHJldHVybiBnZXROb2RlJDEoa2V5KS5wZWVrKHN0b3JlLCBzdGF0ZSk7XHJcbn0gLy8gV3JpdGUgdmFsdWUgZGlyZWN0bHkgdG8gc3RhdGUgYnlwYXNzaW5nIHRoZSBOb2RlIGludGVyZmFjZSBhcyB0aGUgbm9kZVxyXG4vLyBkZWZpbml0aW9ucyBtYXkgbm90IGhhdmUgYmVlbiBsb2FkZWQgeWV0IHdoZW4gcHJvY2Vzc2luZyB0aGUgaW5pdGlhbCBzbmFwc2hvdC5cclxuXHJcblxyXG5mdW5jdGlvbiBzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVEKHN0YXRlLCBrZXksIG5ld1ZhbHVlKSB7XHJcbiAgdmFyIF9ub2RlJGludmFsaWRhdGU7XHJcblxyXG4gIGNvbnN0IG5vZGUgPSBnZXROb2RlTWF5YmUkMShrZXkpO1xyXG4gIG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ub2RlJGludmFsaWRhdGUgPSBub2RlLmludmFsaWRhdGUpID09PSBudWxsIHx8IF9ub2RlJGludmFsaWRhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGludmFsaWRhdGUuY2FsbChub2RlLCBzdGF0ZSk7XHJcbiAgcmV0dXJuIHsgLi4uc3RhdGUsXHJcbiAgICBhdG9tVmFsdWVzOiBzdGF0ZS5hdG9tVmFsdWVzLmNsb25lKCkuZGVsZXRlKGtleSksXHJcbiAgICBub252YWxpZGF0ZWRBdG9tczogc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuY2xvbmUoKS5zZXQoa2V5LCBuZXdWYWx1ZSksXHJcbiAgICBkaXJ0eUF0b21zOiBzZXRCeUFkZGluZ1RvU2V0JDEoc3RhdGUuZGlydHlBdG9tcywga2V5KVxyXG4gIH07XHJcbn0gLy8gUmV0dXJuIHRoZSBkaXNjb3ZlcmVkIGRlcGVuZGVuY2llcyBhbmQgdmFsdWVzIHRvIGJlIHdyaXR0ZW4gYnkgc2V0dGluZ1xyXG4vLyBhIG5vZGUgdmFsdWUuIChNdWx0aXBsZSB2YWx1ZXMgbWF5IGJlIHdyaXR0ZW4gZHVlIHRvIHNlbGVjdG9ycyBnZXR0aW5nIHRvXHJcbi8vIHNldCB1cHN0cmVhbXM7IGRlcHMgbWF5IGJlIGRpc2NvdmVyZWQgYmVjYXVzZSBvZiByZWFkcyBpbiB1cGRhdGVyIGZ1bmN0aW9ucy4pXHJcblxyXG5cclxuZnVuY3Rpb24gc2V0Tm9kZVZhbHVlKHN0b3JlLCBzdGF0ZSwga2V5LCBuZXdWYWx1ZSkge1xyXG4gIGNvbnN0IG5vZGUgPSBnZXROb2RlJDEoa2V5KTtcclxuXHJcbiAgaWYgKG5vZGUuc2V0ID09IG51bGwpIHtcclxuICAgIHRocm93IG5ldyBSZWFkT25seVJlY29pbFZhbHVlRXJyb3IoYEF0dGVtcHQgdG8gc2V0IHJlYWQtb25seSBSZWNvaWxWYWx1ZTogJHtrZXl9YCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzZXQgPSBub2RlLnNldDsgLy8gc28gZmxvdyBkb2Vzbid0IGxvc2UgdGhlIGFib3ZlIHJlZmluZW1lbnQuXHJcblxyXG4gIGluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlKHN0b3JlLCBzdGF0ZSwga2V5LCAnc2V0Jyk7XHJcbiAgcmV0dXJuIHNldChzdG9yZSwgc3RhdGUsIG5ld1ZhbHVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGVla05vZGVJbmZvKHN0b3JlLCBzdGF0ZSwga2V5KSB7XHJcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaChzdGF0ZS52ZXJzaW9uKTtcclxuICBjb25zdCB0eXBlID0gZ2V0Tm9kZSQxKGtleSkubm9kZVR5cGU7XHJcbiAgcmV0dXJuIFJlY29pbF9sYXp5UHJveHkoe1xyXG4gICAgdHlwZVxyXG4gIH0sIHtcclxuICAgIGxvYWRhYmxlOiAoKSA9PiBwZWVrTm9kZUxvYWRhYmxlKHN0b3JlLCBzdGF0ZSwga2V5KSxcclxuICAgIGlzQWN0aXZlOiAoKSA9PiBzdG9yZVN0YXRlLmtub3duQXRvbXMuaGFzKGtleSkgfHwgc3RvcmVTdGF0ZS5rbm93blNlbGVjdG9ycy5oYXMoa2V5KSxcclxuICAgIGlzU2V0OiAoKSA9PiB0eXBlID09PSAnc2VsZWN0b3InID8gZmFsc2UgOiBzdGF0ZS5hdG9tVmFsdWVzLmhhcyhrZXkpLFxyXG4gICAgaXNNb2RpZmllZDogKCkgPT4gc3RhdGUuZGlydHlBdG9tcy5oYXMoa2V5KSxcclxuICAgIC8vIFJlcG9ydCBjdXJyZW50IGRlcGVuZGVuY2llcy4gIElmIHRoZSBub2RlIGhhc24ndCBiZWVuIGV2YWx1YXRlZCwgdGhlblxyXG4gICAgLy8gZGVwZW5kZW5jaWVzIG1heSBiZSBtaXNzaW5nIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlLlxyXG4gICAgZGVwczogKCkgPT4ge1xyXG4gICAgICB2YXIgX2dyYXBoJG5vZGVEZXBzJGdldDtcclxuXHJcbiAgICAgIHJldHVybiByZWNvaWxWYWx1ZXNGb3JLZXlzJDEoKF9ncmFwaCRub2RlRGVwcyRnZXQgPSBncmFwaC5ub2RlRGVwcy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX2dyYXBoJG5vZGVEZXBzJGdldCAhPT0gdm9pZCAwID8gX2dyYXBoJG5vZGVEZXBzJGdldCA6IFtdKTtcclxuICAgIH0sXHJcbiAgICAvLyBSZXBvcnRzIGFsbCBcImN1cnJlbnRcIiBzdWJzY3JpYmVycy4gIEV2YWx1YXRpbmcgb3RoZXIgbm9kZXMgb3JcclxuICAgIC8vIHByZXZpb3VzIGluLXByb2dyZXNzIGFzeW5jIGV2YWx1YXRpb25zIG1heSBpbnRyb2R1Y2UgbmV3IHN1YnNjcmliZXJzLlxyXG4gICAgc3Vic2NyaWJlcnM6ICgpID0+IHtcclxuICAgICAgdmFyIF9zdG9yZVN0YXRlJG5vZGVUb0NvbSwgX3N0b3JlU3RhdGUkbm9kZVRvQ29tMjtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9kZXM6IHJlY29pbFZhbHVlc0ZvcktleXMkMShSZWNvaWxfZmlsdGVySXRlcmFibGUoZ2V0RG93bnN0cmVhbU5vZGVzKHN0b3JlLCBzdGF0ZSwgbmV3IFNldChba2V5XSkpLCBub2RlS2V5ID0+IG5vZGVLZXkgIT09IGtleSkpLFxyXG4gICAgICAgIGNvbXBvbmVudHM6IFJlY29pbF9tYXBJdGVyYWJsZSgoX3N0b3JlU3RhdGUkbm9kZVRvQ29tID0gKF9zdG9yZVN0YXRlJG5vZGVUb0NvbTIgPSBzdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJG5vZGVUb0NvbTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJG5vZGVUb0NvbTIudmFsdWVzKCkpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5vZGVUb0NvbSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbm9kZVRvQ29tIDogW10sIChbbmFtZV0pID0+ICh7XHJcbiAgICAgICAgICBuYW1lXHJcbiAgICAgICAgfSkpXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0gLy8gRmluZCBhbGwgb2YgdGhlIHJlY3Vyc2l2ZWx5IGRlcGVuZGVudCBub2Rlc1xyXG5cclxuXHJcbmZ1bmN0aW9uIGdldERvd25zdHJlYW1Ob2RlcyhzdG9yZSwgc3RhdGUsIGtleXMpIHtcclxuICBjb25zdCB2aXNpdGVkTm9kZXMgPSBuZXcgU2V0KCk7XHJcbiAgY29uc3QgdmlzaXRpbmdOb2RlcyA9IEFycmF5LmZyb20oa2V5cyk7XHJcbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaChzdGF0ZS52ZXJzaW9uKTtcclxuXHJcbiAgZm9yIChsZXQga2V5ID0gdmlzaXRpbmdOb2Rlcy5wb3AoKTsga2V5OyBrZXkgPSB2aXNpdGluZ05vZGVzLnBvcCgpKSB7XHJcbiAgICB2YXIgX2dyYXBoJG5vZGVUb05vZGVTdWJzO1xyXG5cclxuICAgIHZpc2l0ZWROb2Rlcy5hZGQoa2V5KTtcclxuICAgIGNvbnN0IHN1YnNjcmliZWROb2RlcyA9IChfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgPSBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX2dyYXBoJG5vZGVUb05vZGVTdWJzICE9PSB2b2lkIDAgPyBfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgOiBlbXB0eVNldDtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGRvd25zdHJlYW1Ob2RlIG9mIHN1YnNjcmliZWROb2Rlcykge1xyXG4gICAgICBpZiAoIXZpc2l0ZWROb2Rlcy5oYXMoZG93bnN0cmVhbU5vZGUpKSB7XHJcbiAgICAgICAgdmlzaXRpbmdOb2Rlcy5wdXNoKGRvd25zdHJlYW1Ob2RlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHZpc2l0ZWROb2RlcztcclxufVxyXG5cclxudmFyIFJlY29pbF9GdW5jdGlvbmFsQ29yZSA9IHtcclxuICBnZXROb2RlTG9hZGFibGUsXHJcbiAgcGVla05vZGVMb2FkYWJsZSxcclxuICBzZXROb2RlVmFsdWUsXHJcbiAgaW5pdGlhbGl6ZU5vZGUsXHJcbiAgY2xlYW5VcE5vZGUsXHJcbiAgc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCxcclxuICBwZWVrTm9kZUluZm8sXHJcbiAgZ2V0RG93bnN0cmVhbU5vZGVzXHJcbn07XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG5cclxubGV0IF9pbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCA9IG51bGw7XHJcblxyXG5mdW5jdGlvbiBzZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdChpbnZhbGlkYXRlKSB7XHJcbiAgX2ludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90ID0gaW52YWxpZGF0ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QoKSB7XHJcbiAgdmFyIF9pbnZhbGlkYXRlTWVtb2l6ZWRTbjtcclxuXHJcbiAgKF9pbnZhbGlkYXRlTWVtb2l6ZWRTbiA9IF9pbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCkgPT09IG51bGwgfHwgX2ludmFsaWRhdGVNZW1vaXplZFNuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW52YWxpZGF0ZU1lbW9pemVkU24oKTtcclxufVxyXG5cclxudmFyIFJlY29pbF9TbmFwc2hvdENhY2hlID0ge1xyXG4gIHNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90LFxyXG4gIGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90XHJcbn07XHJcblxyXG5jb25zdCB7XHJcbiAgZ2V0RG93bnN0cmVhbU5vZGVzOiBnZXREb3duc3RyZWFtTm9kZXMkMSxcclxuICBnZXROb2RlTG9hZGFibGU6IGdldE5vZGVMb2FkYWJsZSQxLFxyXG4gIHNldE5vZGVWYWx1ZTogc2V0Tm9kZVZhbHVlJDFcclxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcclxuXHJcbmNvbnN0IHtcclxuICBnZXROZXh0Q29tcG9uZW50SUQ6IGdldE5leHRDb21wb25lbnRJRCQxXHJcbn0gPSBSZWNvaWxfS2V5cztcclxuXHJcbmNvbnN0IHtcclxuICBnZXROb2RlOiBnZXROb2RlJDIsXHJcbiAgZ2V0Tm9kZU1heWJlOiBnZXROb2RlTWF5YmUkMlxyXG59ID0gUmVjb2lsX05vZGU7XHJcblxyXG5jb25zdCB7XHJcbiAgRGVmYXVsdFZhbHVlOiBEZWZhdWx0VmFsdWUkMVxyXG59ID0gUmVjb2lsX05vZGU7XHJcblxyXG5jb25zdCB7XHJcbiAgcmVhY3RNb2RlOiByZWFjdE1vZGUkMVxyXG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcclxuXHJcbmNvbnN0IHtcclxuICBBYnN0cmFjdFJlY29pbFZhbHVlOiBBYnN0cmFjdFJlY29pbFZhbHVlJDEsXHJcbiAgUmVjb2lsU3RhdGU6IFJlY29pbFN0YXRlJDEsXHJcbiAgUmVjb2lsVmFsdWVSZWFkT25seTogUmVjb2lsVmFsdWVSZWFkT25seSQxLFxyXG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkMVxyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlJDE7XHJcblxyXG5jb25zdCB7XHJcbiAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3Q6IGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDFcclxufSA9IFJlY29pbF9TbmFwc2hvdENhY2hlO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlKHN0b3JlLCB7XHJcbiAga2V5XHJcbn0sIHRyZWVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUpIHtcclxuICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWUsIF9zdG9yZVN0YXRlJHByZXZpb3VzVDtcclxuXHJcbiAgLy8gUmVhZGluZyBmcm9tIGFuIG9sZGVyIHRyZWUgY2FuIGNhdXNlIGJ1Z3MgYmVjYXVzZSB0aGUgZGVwZW5kZW5jaWVzIHRoYXQgd2VcclxuICAvLyBkaXNjb3ZlciBkdXJpbmcgdGhlIHJlYWQgYXJlIGxvc3QuXHJcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gIGlmICghKHRyZWVTdGF0ZS52ZXJzaW9uID09PSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlLnZlcnNpb24gfHwgdHJlZVN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkbmV4dFRyZWUudmVyc2lvbikgfHwgdHJlZVN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUID0gc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJHByZXZpb3VzVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNULnZlcnNpb24pKSkge1xyXG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdUcmllZCB0byByZWFkIGZyb20gYSBkaXNjYXJkZWQgdHJlZScpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgbG9hZGFibGUgPSBnZXROb2RlTG9hZGFibGUkMShzdG9yZSwgdHJlZVN0YXRlLCBrZXkpO1xyXG5cclxuICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xyXG4gICAgbG9hZGFibGUuY29udGVudHMuY2F0Y2goKCkgPT4ge1xyXG4gICAgICAvKipcclxuICAgICAgICogSEFDSzogaW50ZXJjZXB0IHRocm93biBlcnJvciBoZXJlIHRvIHByZXZlbnQgYW4gdW5jYXVnaHQgcHJvbWlzZSBleGNlcHRpb24uIElkZWFsbHkgdGhpcyB3b3VsZCBoYXBwZW4gY2xvc2VyIHRvIHNlbGVjdG9yXHJcbiAgICAgICAqIGV4ZWN1dGlvbiAocGVyaGFwcyBpbnRyb2R1Y2luZyBhIG5ldyBFUlJPUiBjbGFzcyB0byBiZSByZXNvbHZlZCBieSBhc3luYyBzZWxlY3RvcnMgdGhhdCBhcmUgaW4gYW4gZXJyb3Igc3RhdGUpXHJcbiAgICAgICAqL1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBsb2FkYWJsZTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlBdG9tVmFsdWVXcml0ZXMoYXRvbVZhbHVlcywgd3JpdGVzKSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXRvbVZhbHVlcy5jbG9uZSgpO1xyXG4gIHdyaXRlcy5mb3JFYWNoKCh2LCBrKSA9PiB7XHJcbiAgICBpZiAodi5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJyAmJiB2LmNvbnRlbnRzIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDEpIHtcclxuICAgICAgcmVzdWx0LmRlbGV0ZShrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlc3VsdC5zZXQoaywgdik7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gdmFsdWVGcm9tVmFsdWVPclVwZGF0ZXIoc3RvcmUsIHN0YXRlLCB7XHJcbiAga2V5XHJcbn0sIHZhbHVlT3JVcGRhdGVyKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZU9yVXBkYXRlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgLy8gVXBkYXRlciBmb3JtOiBwYXNzIGluIHRoZSBjdXJyZW50IHZhbHVlLiBUaHJvdyBpZiB0aGUgY3VycmVudCB2YWx1ZVxyXG4gICAgLy8gaXMgdW5hdmFpbGFibGUgKG5hbWVseSB3aGVuIHVwZGF0aW5nIGFuIGFzeW5jIHNlbGVjdG9yIHRoYXQnc1xyXG4gICAgLy8gcGVuZGluZyBvciBlcnJvcmVkKTpcclxuICAgIGNvbnN0IGN1cnJlbnQgPSBnZXROb2RlTG9hZGFibGUkMShzdG9yZSwgc3RhdGUsIGtleSk7XHJcblxyXG4gICAgaWYgKGN1cnJlbnQuc3RhdGUgPT09ICdsb2FkaW5nJykge1xyXG4gICAgICBjb25zdCBtc2cgPSBgVHJpZWQgdG8gc2V0IGF0b20gb3Igc2VsZWN0b3IgXCIke2tleX1cIiB1c2luZyBhbiB1cGRhdGVyIGZ1bmN0aW9uIHdoaWxlIHRoZSBjdXJyZW50IHN0YXRlIGlzIHBlbmRpbmcsIHRoaXMgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuYDtcclxuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKG1zZyk7XHJcbiAgICAgIHRocm93IFJlY29pbF9lcnIobXNnKTtcclxuICAgIH0gZWxzZSBpZiAoY3VycmVudC5zdGF0ZSA9PT0gJ2hhc0Vycm9yJykge1xyXG4gICAgICB0aHJvdyBjdXJyZW50LmNvbnRlbnRzO1xyXG4gICAgfSAvLyBUIGl0c2VsZiBtYXkgYmUgYSBmdW5jdGlvbiwgc28gb3VyIHJlZmluZW1lbnQgaXMgbm90IHN1ZmZpY2llbnQ6XHJcblxyXG5cclxuICAgIHJldHVybiB2YWx1ZU9yVXBkYXRlcihjdXJyZW50LmNvbnRlbnRzKTsgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB2YWx1ZU9yVXBkYXRlcjtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5QWN0aW9uKHN0b3JlLCBzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgaWYgKGFjdGlvbi50eXBlID09PSAnc2V0Jykge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICByZWNvaWxWYWx1ZSxcclxuICAgICAgdmFsdWVPclVwZGF0ZXJcclxuICAgIH0gPSBhY3Rpb247XHJcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlRnJvbVZhbHVlT3JVcGRhdGVyKHN0b3JlLCBzdGF0ZSwgcmVjb2lsVmFsdWUsIHZhbHVlT3JVcGRhdGVyKTtcclxuICAgIGNvbnN0IHdyaXRlcyA9IHNldE5vZGVWYWx1ZSQxKHN0b3JlLCBzdGF0ZSwgcmVjb2lsVmFsdWUua2V5LCBuZXdWYWx1ZSk7XHJcblxyXG4gICAgZm9yIChjb25zdCBba2V5LCBsb2FkYWJsZV0gb2Ygd3JpdGVzLmVudHJpZXMoKSkge1xyXG4gICAgICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUoc3RhdGUsIGtleSwgbG9hZGFibGUpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09ICdzZXRMb2FkYWJsZScpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgcmVjb2lsVmFsdWU6IHtcclxuICAgICAgICBrZXlcclxuICAgICAgfSxcclxuICAgICAgbG9hZGFibGVcclxuICAgIH0gPSBhY3Rpb247XHJcbiAgICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUoc3RhdGUsIGtleSwgbG9hZGFibGUpO1xyXG4gIH0gZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09ICdtYXJrTW9kaWZpZWQnKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHJlY29pbFZhbHVlOiB7XHJcbiAgICAgICAga2V5XHJcbiAgICAgIH1cclxuICAgIH0gPSBhY3Rpb247XHJcbiAgICBzdGF0ZS5kaXJ0eUF0b21zLmFkZChrZXkpO1xyXG4gIH0gZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09ICdzZXRVbnZhbGlkYXRlZCcpIHtcclxuICAgIHZhciBfbm9kZSRpbnZhbGlkYXRlO1xyXG5cclxuICAgIC8vIFdyaXRlIHZhbHVlIGRpcmVjdGx5IHRvIHN0YXRlIGJ5cGFzc2luZyB0aGUgTm9kZSBpbnRlcmZhY2UgYXMgdGhlIG5vZGVcclxuICAgIC8vIGRlZmluaXRpb25zIG1heSBub3QgaGF2ZSBiZWVuIGxvYWRlZCB5ZXQgd2hlbiBwcm9jZXNzaW5nIHRoZSBpbml0aWFsIHNuYXBzaG90LlxyXG4gICAgY29uc3Qge1xyXG4gICAgICByZWNvaWxWYWx1ZToge1xyXG4gICAgICAgIGtleVxyXG4gICAgICB9LFxyXG4gICAgICB1bnZhbGlkYXRlZFZhbHVlXHJcbiAgICB9ID0gYWN0aW9uO1xyXG4gICAgY29uc3Qgbm9kZSA9IGdldE5vZGVNYXliZSQyKGtleSk7XHJcbiAgICBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbm9kZSRpbnZhbGlkYXRlID0gbm9kZS5pbnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfbm9kZSRpbnZhbGlkYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRpbnZhbGlkYXRlLmNhbGwobm9kZSwgc3RhdGUpO1xyXG4gICAgc3RhdGUuYXRvbVZhbHVlcy5kZWxldGUoa2V5KTtcclxuICAgIHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLnNldChrZXksIHVudmFsaWRhdGVkVmFsdWUpO1xyXG4gICAgc3RhdGUuZGlydHlBdG9tcy5hZGQoa2V5KTtcclxuICB9IGVsc2Uge1xyXG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKGBVbmtub3duIGFjdGlvbiAke2FjdGlvbi50eXBlfWApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlKHN0YXRlLCBrZXksIGxvYWRhYmxlKSB7XHJcbiAgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnICYmIGxvYWRhYmxlLmNvbnRlbnRzIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDEpIHtcclxuICAgIHN0YXRlLmF0b21WYWx1ZXMuZGVsZXRlKGtleSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHN0YXRlLmF0b21WYWx1ZXMuc2V0KGtleSwgbG9hZGFibGUpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGUuZGlydHlBdG9tcy5hZGQoa2V5KTtcclxuICBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5kZWxldGUoa2V5KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlBY3Rpb25zVG9TdG9yZShzdG9yZSwgYWN0aW9ucykge1xyXG4gIHN0b3JlLnJlcGxhY2VTdGF0ZShzdGF0ZSA9PiB7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IGNvcHlUcmVlU3RhdGUoc3RhdGUpO1xyXG5cclxuICAgIGZvciAoY29uc3QgYWN0aW9uIG9mIGFjdGlvbnMpIHtcclxuICAgICAgYXBwbHlBY3Rpb24oc3RvcmUsIG5ld1N0YXRlLCBhY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGludmFsaWRhdGVEb3duc3RyZWFtcyhzdG9yZSwgbmV3U3RhdGUpO1xyXG4gICAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMSgpO1xyXG4gICAgcmV0dXJuIG5ld1N0YXRlO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdWV1ZU9yUGVyZm9ybVN0YXRlVXBkYXRlKHN0b3JlLCBhY3Rpb24pIHtcclxuICBpZiAoYmF0Y2hTdGFjay5sZW5ndGgpIHtcclxuICAgIGNvbnN0IGFjdGlvbnNCeVN0b3JlID0gYmF0Y2hTdGFja1tiYXRjaFN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgbGV0IGFjdGlvbnMgPSBhY3Rpb25zQnlTdG9yZS5nZXQoc3RvcmUpO1xyXG5cclxuICAgIGlmICghYWN0aW9ucykge1xyXG4gICAgICBhY3Rpb25zQnlTdG9yZS5zZXQoc3RvcmUsIGFjdGlvbnMgPSBbXSk7XHJcbiAgICB9XHJcblxyXG4gICAgYWN0aW9ucy5wdXNoKGFjdGlvbik7XHJcbiAgfSBlbHNlIHtcclxuICAgIGFwcGx5QWN0aW9uc1RvU3RvcmUoc3RvcmUsIFthY3Rpb25dKTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGJhdGNoU3RhY2sgPSBbXTtcclxuXHJcbmZ1bmN0aW9uIGJhdGNoU3RhcnQoKSB7XHJcbiAgY29uc3QgYWN0aW9uc0J5U3RvcmUgPSBuZXcgTWFwKCk7XHJcbiAgYmF0Y2hTdGFjay5wdXNoKGFjdGlvbnNCeVN0b3JlKTtcclxuICByZXR1cm4gKCkgPT4ge1xyXG4gICAgZm9yIChjb25zdCBbc3RvcmUsIGFjdGlvbnNdIG9mIGFjdGlvbnNCeVN0b3JlKSB7XHJcbiAgICAgIGFwcGx5QWN0aW9uc1RvU3RvcmUoc3RvcmUsIGFjdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBvcHBlZCA9IGJhdGNoU3RhY2sucG9wKCk7XHJcblxyXG4gICAgaWYgKHBvcHBlZCAhPT0gYWN0aW9uc0J5U3RvcmUpIHtcclxuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdJbmNvcnJlY3Qgb3JkZXIgb2YgYmF0Y2ggcG9wcGluZycpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvcHlUcmVlU3RhdGUoc3RhdGUpIHtcclxuICByZXR1cm4geyAuLi5zdGF0ZSxcclxuICAgIGF0b21WYWx1ZXM6IHN0YXRlLmF0b21WYWx1ZXMuY2xvbmUoKSxcclxuICAgIG5vbnZhbGlkYXRlZEF0b21zOiBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5jbG9uZSgpLFxyXG4gICAgZGlydHlBdG9tczogbmV3IFNldChzdGF0ZS5kaXJ0eUF0b21zKVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludmFsaWRhdGVEb3duc3RyZWFtcyhzdG9yZSwgc3RhdGUpIHtcclxuICAvLyBJbmZvcm0gYW55IG5vZGVzIHRoYXQgd2VyZSBjaGFuZ2VkIG9yIGRvd25zdHJlYW0gb2YgY2hhbmdlcyBzbyB0aGF0IHRoZXlcclxuICAvLyBjYW4gY2xlYXIgb3V0IGFueSBjYWNoZXMgYXMgbmVlZGVkIGR1ZSB0byB0aGUgdXBkYXRlOlxyXG4gIGNvbnN0IGRvd25zdHJlYW1zID0gZ2V0RG93bnN0cmVhbU5vZGVzJDEoc3RvcmUsIHN0YXRlLCBzdGF0ZS5kaXJ0eUF0b21zKTtcclxuXHJcbiAgZm9yIChjb25zdCBrZXkgb2YgZG93bnN0cmVhbXMpIHtcclxuICAgIHZhciBfZ2V0Tm9kZU1heWJlLCBfZ2V0Tm9kZU1heWJlJGludmFsaWQ7XHJcblxyXG4gICAgKF9nZXROb2RlTWF5YmUgPSBnZXROb2RlTWF5YmUkMihrZXkpKSA9PT0gbnVsbCB8fCBfZ2V0Tm9kZU1heWJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2dldE5vZGVNYXliZSRpbnZhbGlkID0gX2dldE5vZGVNYXliZS5pbnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfZ2V0Tm9kZU1heWJlJGludmFsaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXROb2RlTWF5YmUkaW52YWxpZC5jYWxsKF9nZXROb2RlTWF5YmUsIHN0YXRlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFJlY29pbFZhbHVlKHN0b3JlLCByZWNvaWxWYWx1ZSwgdmFsdWVPclVwZGF0ZXIpIHtcclxuICBxdWV1ZU9yUGVyZm9ybVN0YXRlVXBkYXRlKHN0b3JlLCB7XHJcbiAgICB0eXBlOiAnc2V0JyxcclxuICAgIHJlY29pbFZhbHVlLFxyXG4gICAgdmFsdWVPclVwZGF0ZXJcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0UmVjb2lsVmFsdWVMb2FkYWJsZShzdG9yZSwgcmVjb2lsVmFsdWUsIGxvYWRhYmxlKSB7XHJcbiAgaWYgKGxvYWRhYmxlIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDEpIHtcclxuICAgIHJldHVybiBzZXRSZWNvaWxWYWx1ZShzdG9yZSwgcmVjb2lsVmFsdWUsIGxvYWRhYmxlKTtcclxuICB9XHJcblxyXG4gIHF1ZXVlT3JQZXJmb3JtU3RhdGVVcGRhdGUoc3RvcmUsIHtcclxuICAgIHR5cGU6ICdzZXRMb2FkYWJsZScsXHJcbiAgICByZWNvaWxWYWx1ZSxcclxuICAgIGxvYWRhYmxlOiBsb2FkYWJsZVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZChzdG9yZSwgcmVjb2lsVmFsdWUpIHtcclxuICBxdWV1ZU9yUGVyZm9ybVN0YXRlVXBkYXRlKHN0b3JlLCB7XHJcbiAgICB0eXBlOiAnbWFya01vZGlmaWVkJyxcclxuICAgIHJlY29pbFZhbHVlXHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUoc3RvcmUsIHJlY29pbFZhbHVlLCB1bnZhbGlkYXRlZFZhbHVlKSB7XHJcbiAgcXVldWVPclBlcmZvcm1TdGF0ZVVwZGF0ZShzdG9yZSwge1xyXG4gICAgdHlwZTogJ3NldFVudmFsaWRhdGVkJyxcclxuICAgIHJlY29pbFZhbHVlLFxyXG4gICAgdW52YWxpZGF0ZWRWYWx1ZVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdWJzY3JpYmVUb1JlY29pbFZhbHVlKHN0b3JlLCB7XHJcbiAga2V5XHJcbn0sIGNhbGxiYWNrLCBjb21wb25lbnREZWJ1Z05hbWUgPSBudWxsKSB7XHJcbiAgY29uc3Qgc3ViSUQgPSBnZXROZXh0Q29tcG9uZW50SUQkMSgpO1xyXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICBpZiAoIXN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5oYXMoa2V5KSkge1xyXG4gICAgc3RvcmVTdGF0ZS5ub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zLnNldChrZXksIG5ldyBNYXAoKSk7XHJcbiAgfVxyXG5cclxuICBSZWNvaWxfbnVsbHRocm93cyhzdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZ2V0KGtleSkpLnNldChzdWJJRCwgW2NvbXBvbmVudERlYnVnTmFtZSAhPT0gbnVsbCAmJiBjb21wb25lbnREZWJ1Z05hbWUgIT09IHZvaWQgMCA/IGNvbXBvbmVudERlYnVnTmFtZSA6ICc8bm90IGNhcHR1cmVkPicsIGNhbGxiYWNrXSk7IC8vIEhhbmRsZSB0aGUgY2FzZSB0aGF0LCBkdXJpbmcgdGhlIHNhbWUgdGljayB0aGF0IHdlIGFyZSBzdWJzY3JpYmluZywgYW4gYXRvbVxyXG4gIC8vIGhhcyBiZWVuIHVwZGF0ZWQgYnkgc29tZSBlZmZlY3QgaGFuZGxlci4gT3RoZXJ3aXNlIHdlIHdpbGwgbWlzcyB0aGUgdXBkYXRlLlxyXG5cclxuICBjb25zdCBtb2RlID0gcmVhY3RNb2RlJDEoKTtcclxuXHJcbiAgaWYgKG1vZGUuZWFybHkgJiYgKG1vZGUubW9kZSA9PT0gJ0xFR0FDWScgfHwgbW9kZS5tb2RlID09PSAnTVVUQUJMRV9TT1VSQ0UnKSkge1xyXG4gICAgY29uc3QgbmV4dFRyZWUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlO1xyXG5cclxuICAgIGlmIChuZXh0VHJlZSAmJiBuZXh0VHJlZS5kaXJ0eUF0b21zLmhhcyhrZXkpKSB7XHJcbiAgICAgIGNhbGxiYWNrKG5leHRUcmVlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICByZWxlYXNlOiAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlbGVhc2VTdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgICAgY29uc3Qgc3VicyA9IHJlbGVhc2VTdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZ2V0KGtleSk7XHJcblxyXG4gICAgICBpZiAoc3VicyA9PT0gdW5kZWZpbmVkIHx8ICFzdWJzLmhhcyhzdWJJRCkpIHtcclxuICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oYFN1YnNjcmlwdGlvbiBtaXNzaW5nIGF0IHJlbGVhc2UgdGltZSBmb3IgYXRvbSAke2tleX0uIFRoaXMgaXMgYSBidWcgaW4gUmVjb2lsLmApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3Vicy5kZWxldGUoc3ViSUQpO1xyXG5cclxuICAgICAgaWYgKHN1YnMuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgIHJlbGVhc2VTdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZGVsZXRlKGtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWZyZXNoUmVjb2lsVmFsdWUoc3RvcmUsIHJlY29pbFZhbHVlKSB7XHJcbiAgdmFyIF9ub2RlJGNsZWFyQ2FjaGU7XHJcblxyXG4gIGNvbnN0IHtcclxuICAgIGN1cnJlbnRUcmVlXHJcbiAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcbiAgY29uc3Qgbm9kZSA9IGdldE5vZGUkMihyZWNvaWxWYWx1ZS5rZXkpO1xyXG4gIChfbm9kZSRjbGVhckNhY2hlID0gbm9kZS5jbGVhckNhY2hlKSA9PT0gbnVsbCB8fCBfbm9kZSRjbGVhckNhY2hlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRjbGVhckNhY2hlLmNhbGwobm9kZSwgc3RvcmUsIGN1cnJlbnRUcmVlKTtcclxufVxyXG5cclxudmFyIFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZSA9IHtcclxuICBSZWNvaWxWYWx1ZVJlYWRPbmx5OiBSZWNvaWxWYWx1ZVJlYWRPbmx5JDEsXHJcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZTogQWJzdHJhY3RSZWNvaWxWYWx1ZSQxLFxyXG4gIFJlY29pbFN0YXRlOiBSZWNvaWxTdGF0ZSQxLFxyXG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSxcclxuICBzZXRSZWNvaWxWYWx1ZSxcclxuICBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlLFxyXG4gIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkLFxyXG4gIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUsXHJcbiAgc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSxcclxuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDEsXHJcbiAgYXBwbHlBdG9tVmFsdWVXcml0ZXMsXHJcbiAgLy8gVE9ETyBSZW1vdmUgZXhwb3J0IHdoZW4gZGVwcmVjYXRpbmcgaW5pdGlhbFN0b3JlU3RhdGVfREVQUkVDQVRFRCBpbiBSZWNvaWxSb290XHJcbiAgYmF0Y2hTdGFydCxcclxuICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUsXHJcbiAgaW52YWxpZGF0ZURvd25zdHJlYW1zLFxyXG4gIGNvcHlUcmVlU3RhdGUsXHJcbiAgcmVmcmVzaFJlY29pbFZhbHVlXHJcbn07XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG4vKipcclxuICogVGhlIHNvbWVTZXQoKSBtZXRob2QgdGVzdHMgd2hldGhlciBzb21lIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBTZXQgcGFzcyB0aGVcclxuICogdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gc29tZVNldChzZXQsIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgY29uc3QgaXRlcmF0b3IgPSBzZXQuZW50cmllcygpO1xyXG4gIGxldCBjdXJyZW50ID0gaXRlcmF0b3IubmV4dCgpO1xyXG5cclxuICB3aGlsZSAoIWN1cnJlbnQuZG9uZSkge1xyXG4gICAgY29uc3QgZW50cnkgPSBjdXJyZW50LnZhbHVlO1xyXG5cclxuICAgIGlmIChjYWxsYmFjay5jYWxsKGNvbnRleHQsIGVudHJ5WzFdLCBlbnRyeVswXSwgc2V0KSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBjdXJyZW50ID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX3NvbWVTZXQgPSBzb21lU2V0O1xyXG5cclxuY29uc3Qge1xyXG4gIGNsZWFuVXBOb2RlOiBjbGVhblVwTm9kZSQxXHJcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XHJcblxyXG5jb25zdCB7XHJcbiAgZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGU6IGRlbGV0ZU5vZGVDb25maWdJZlBvc3NpYmxlJDEsXHJcbiAgZ2V0Tm9kZTogZ2V0Tm9kZSQzXHJcbn0gPSBSZWNvaWxfTm9kZTtcclxuXHJcbmNvbnN0IHtcclxuICBSZXRlbnRpb25ab25lOiBSZXRlbnRpb25ab25lJDJcclxufSA9IFJlY29pbF9SZXRlbnRpb25ab25lO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIC8vIENvbXBvbmVudHMgdGhhdCBhcmVuJ3QgbW91bnRlZCBhZnRlciBzdXNwZW5kaW5nIGZvciB0aGlzIGxvbmcgd2lsbCBiZSBhc3N1bWVkXHJcbi8vIHRvIGJlIGRpc2NhcmRlZCBhbmQgdGhlaXIgcmVzb3VyY2VzIHJlbGVhc2VkLlxyXG5cclxuXHJcbmNvbnN0IFNVU1BFTlNFX1RJTUVPVVRfTVMgPSAxMjAwMDA7XHJcbmNvbnN0IGVtcHR5U2V0JDEgPSBuZXcgU2V0KCk7XHJcblxyXG5mdW5jdGlvbiByZWxlYXNlUmV0YWluYWJsZXNOb3dPbkN1cnJlbnRUcmVlKHN0b3JlLCByZXRhaW5hYmxlcykge1xyXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG4gIGNvbnN0IHRyZWVTdGF0ZSA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XHJcblxyXG4gIGlmIChzdG9yZVN0YXRlLm5leHRUcmVlKSB7XHJcbiAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ3JlbGVhc2VOb2Rlc05vd09uQ3VycmVudFRyZWUgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGF0IHRoZSBlbmQgb2YgYSBiYXRjaCcpO1xyXG4gICAgcmV0dXJuOyAvLyBsZWFrIG1lbW9yeSByYXRoZXIgdGhhbiBlcmFzZSBzb21ldGhpbmcgdGhhdCdzIGFib3V0IHRvIGJlIHVzZWQuXHJcbiAgfVxyXG5cclxuICBjb25zdCBub2RlcyA9IG5ldyBTZXQoKTtcclxuXHJcbiAgZm9yIChjb25zdCByIG9mIHJldGFpbmFibGVzKSB7XHJcbiAgICBpZiAociBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMikge1xyXG4gICAgICBmb3IgKGNvbnN0IG4gb2Ygbm9kZXNSZXRhaW5lZEJ5Wm9uZShzdG9yZVN0YXRlLCByKSkge1xyXG4gICAgICAgIG5vZGVzLmFkZChuKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbm9kZXMuYWRkKHIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgcmVsZWFzYWJsZU5vZGVzID0gZmluZFJlbGVhc2FibGVOb2RlcyhzdG9yZSwgbm9kZXMpO1xyXG5cclxuICBmb3IgKGNvbnN0IG5vZGUgb2YgcmVsZWFzYWJsZU5vZGVzKSB7XHJcbiAgICByZWxlYXNlTm9kZShzdG9yZSwgdHJlZVN0YXRlLCBub2RlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbmRSZWxlYXNhYmxlTm9kZXMoc3RvcmUsIHNlYXJjaEZyb21Ob2Rlcykge1xyXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG4gIGNvbnN0IHRyZWVTdGF0ZSA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XHJcbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaCh0cmVlU3RhdGUudmVyc2lvbik7XHJcbiAgY29uc3QgcmVsZWFzYWJsZU5vZGVzID0gbmV3IFNldCgpOyAvLyBtdXRhdGVkIHRvIGNvbGxlY3QgYW5zd2VyXHJcblxyXG4gIGNvbnN0IG5vblJlbGVhc2FibGVOb2RlcyA9IG5ldyBTZXQoKTtcclxuICBmaW5kUmVsZWFzYWJsZU5vZGVzSW5uZXIoc2VhcmNoRnJvbU5vZGVzKTtcclxuICByZXR1cm4gcmVsZWFzYWJsZU5vZGVzO1xyXG5cclxuICBmdW5jdGlvbiBmaW5kUmVsZWFzYWJsZU5vZGVzSW5uZXIoc2VhcmNoRnJvbU5vZGVzKSB7XHJcbiAgICBjb25zdCByZWxlYXNhYmxlTm9kZXNGb3VuZFRoaXNJdGVyYXRpb24gPSBuZXcgU2V0KCk7XHJcbiAgICBjb25zdCBkb3duc3RyZWFtcyA9IGdldERvd25zdHJlYW1Ob2Rlc0luVG9wb2xvZ2ljYWxPcmRlcihzdG9yZSwgdHJlZVN0YXRlLCBzZWFyY2hGcm9tTm9kZXMsIHJlbGVhc2FibGVOb2RlcywgLy8gZG9uJ3QgZGVzY2VuZCBpbnRvIHRoZXNlXHJcbiAgICBub25SZWxlYXNhYmxlTm9kZXMgLy8gZG9uJ3QgZGVzY2VuZCBpbnRvIHRoZXNlXHJcbiAgICApOyAvLyBGaW5kIHdoaWNoIG9mIHRoZSBkb3duc3RyZWFtIG5vZGVzIGFyZSByZWxlYXNhYmxlIGFuZCB3aGljaCBhcmUgbm90OlxyXG5cclxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBkb3duc3RyZWFtcykge1xyXG4gICAgICB2YXIgX3N0b3JlU3RhdGUkcmV0ZW50aW9uO1xyXG5cclxuICAgICAgLy8gTm90IHJlbGVhc2FibGUgaWYgY29uZmlndXJlZCB0byBiZSByZXRhaW5lZCBmb3JldmVyOlxyXG4gICAgICBpZiAoZ2V0Tm9kZSQzKG5vZGUpLnJldGFpbmVkQnkgPT09ICdyZWNvaWxSb290Jykge1xyXG4gICAgICAgIG5vblJlbGVhc2FibGVOb2Rlcy5hZGQobm9kZSk7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH0gLy8gTm90IHJlbGVhc2FibGUgaWYgcmV0YWluZWQgZGlyZWN0bHkgYnkgYSBjb21wb25lbnQ6XHJcblxyXG5cclxuICAgICAgaWYgKCgoX3N0b3JlU3RhdGUkcmV0ZW50aW9uID0gc3RvcmVTdGF0ZS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzLmdldChub2RlKSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkcmV0ZW50aW9uICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRyZXRlbnRpb24gOiAwKSA+IDApIHtcclxuICAgICAgICBub25SZWxlYXNhYmxlTm9kZXMuYWRkKG5vZGUpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9IC8vIE5vdCByZWxlYXNhYmxlIGlmIHJldGFpbmVkIGJ5IGEgem9uZTpcclxuXHJcblxyXG4gICAgICBpZiAoem9uZXNUaGF0Q291bGRSZXRhaW5Ob2RlKG5vZGUpLnNvbWUoeiA9PiBzdG9yZVN0YXRlLnJldGVudGlvbi5yZWZlcmVuY2VDb3VudHMuZ2V0KHopKSkge1xyXG4gICAgICAgIG5vblJlbGVhc2FibGVOb2Rlcy5hZGQobm9kZSk7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH0gLy8gTm90IHJlbGVhc2FibGUgaWYgaXQgaGFzIGEgbm9uLXJlbGVhc2FibGUgY2hpbGQgKHdoaWNoIHdpbGwgYWxyZWFkeSBiZSBpblxyXG4gICAgICAvLyBub25SZWxlYXNhYmxlTm9kZXMgYmVjYXVzZSB3ZSBhcmUgZ29pbmcgaW4gdG9wb2xvZ2ljYWwgb3JkZXIpOlxyXG5cclxuXHJcbiAgICAgIGNvbnN0IG5vZGVDaGlsZHJlbiA9IGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChub2RlKTtcclxuXHJcbiAgICAgIGlmIChub2RlQ2hpbGRyZW4gJiYgUmVjb2lsX3NvbWVTZXQobm9kZUNoaWxkcmVuLCBjaGlsZCA9PiBub25SZWxlYXNhYmxlTm9kZXMuaGFzKGNoaWxkKSkpIHtcclxuICAgICAgICBub25SZWxlYXNhYmxlTm9kZXMuYWRkKG5vZGUpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZWxlYXNhYmxlTm9kZXMuYWRkKG5vZGUpO1xyXG4gICAgICByZWxlYXNhYmxlTm9kZXNGb3VuZFRoaXNJdGVyYXRpb24uYWRkKG5vZGUpO1xyXG4gICAgfSAvLyBJZiB3ZSBmb3VuZCBhbnkgcmVsZWFzYWJsZSBub2Rlcywgd2UgbmVlZCB0byB3YWxrIFVQIGZyb20gdGhvc2Ugbm9kZXMgdG9cclxuICAgIC8vIGZpbmQgd2hldGhlciB0aGVpciBwYXJlbnRzIGNhbiBub3cgYmUgcmVsZWFzZWQgYXMgd2VsbDpcclxuXHJcblxyXG4gICAgY29uc3QgcGFyZW50cyA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgcmVsZWFzYWJsZU5vZGVzRm91bmRUaGlzSXRlcmF0aW9uKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGFyZW50IG9mIChfZ3JhcGgkbm9kZURlcHMkZ2V0ID0gZ3JhcGgubm9kZURlcHMuZ2V0KG5vZGUpKSAhPT0gbnVsbCAmJiBfZ3JhcGgkbm9kZURlcHMkZ2V0ICE9PSB2b2lkIDAgPyBfZ3JhcGgkbm9kZURlcHMkZ2V0IDogZW1wdHlTZXQkMSkge1xyXG4gICAgICAgIHZhciBfZ3JhcGgkbm9kZURlcHMkZ2V0O1xyXG5cclxuICAgICAgICBpZiAoIXJlbGVhc2FibGVOb2Rlcy5oYXMocGFyZW50KSkge1xyXG4gICAgICAgICAgcGFyZW50cy5hZGQocGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocGFyZW50cy5zaXplKSB7XHJcbiAgICAgIGZpbmRSZWxlYXNhYmxlTm9kZXNJbm5lcihwYXJlbnRzKTtcclxuICAgIH1cclxuICB9XHJcbn0gLy8gQ2hpbGRyZW4gYmVmb3JlIHBhcmVudHNcclxuXHJcblxyXG5mdW5jdGlvbiBnZXREb3duc3RyZWFtTm9kZXNJblRvcG9sb2dpY2FsT3JkZXIoc3RvcmUsIHRyZWVTdGF0ZSwgbm9kZXMsIC8vIE11dGFibGUgc2V0IGlzIGRlc3Ryb3llZCBpbiBwbGFjZVxyXG5kb05vdERlc2NlbmRJbnRvMSwgZG9Ob3REZXNjZW5kSW50bzIpIHtcclxuICBjb25zdCBncmFwaCA9IHN0b3JlLmdldEdyYXBoKHRyZWVTdGF0ZS52ZXJzaW9uKTtcclxuICBjb25zdCBhbnN3ZXIgPSBbXTtcclxuICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xyXG5cclxuICB3aGlsZSAobm9kZXMuc2l6ZSA+IDApIHtcclxuICAgIHZpc2l0KFJlY29pbF9udWxsdGhyb3dzKG5vZGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZSkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFuc3dlcjtcclxuXHJcbiAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xyXG4gICAgaWYgKGRvTm90RGVzY2VuZEludG8xLmhhcyhub2RlKSB8fCBkb05vdERlc2NlbmRJbnRvMi5oYXMobm9kZSkpIHtcclxuICAgICAgbm9kZXMuZGVsZXRlKG5vZGUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHZpc2l0ZWQuaGFzKG5vZGUpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChub2RlKTtcclxuXHJcbiAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xyXG4gICAgICAgIHZpc2l0KGNoaWxkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xyXG4gICAgbm9kZXMuZGVsZXRlKG5vZGUpO1xyXG4gICAgYW5zd2VyLnB1c2gobm9kZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZWxlYXNlTm9kZShzdG9yZSwgdHJlZVN0YXRlLCBub2RlKSB7XHJcbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfSAvLyBBdG9tIGVmZmVjdHMsIGluLWNsb3N1cmUgY2FjaGVzLCBldGMuOlxyXG5cclxuXHJcbiAgY2xlYW5VcE5vZGUkMShzdG9yZSwgbm9kZSk7IC8vIERlbGV0ZSBmcm9tIHN0b3JlIHN0YXRlOlxyXG5cclxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICBzdG9yZVN0YXRlLmtub3duQXRvbXMuZGVsZXRlKG5vZGUpO1xyXG4gIHN0b3JlU3RhdGUua25vd25TZWxlY3RvcnMuZGVsZXRlKG5vZGUpO1xyXG4gIHN0b3JlU3RhdGUubm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5kZWxldGUobm9kZSk7XHJcbiAgc3RvcmVTdGF0ZS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzLmRlbGV0ZShub2RlKTtcclxuICBjb25zdCB6b25lcyA9IHpvbmVzVGhhdENvdWxkUmV0YWluTm9kZShub2RlKTtcclxuXHJcbiAgZm9yIChjb25zdCB6b25lIG9mIHpvbmVzKSB7XHJcbiAgICB2YXIgX3N0b3JlU3RhdGUkcmV0ZW50aW9uMjtcclxuXHJcbiAgICAoX3N0b3JlU3RhdGUkcmV0ZW50aW9uMiA9IHN0b3JlU3RhdGUucmV0ZW50aW9uLm5vZGVzUmV0YWluZWRCeVpvbmUuZ2V0KHpvbmUpKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRyZXRlbnRpb24yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRyZXRlbnRpb24yLmRlbGV0ZShub2RlKTtcclxuICB9IC8vIE5vdGUgdGhhdCB3ZSBETyBOT1QgZGVsZXRlIGZyb20gbm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucyBiZWNhdXNlIHRoaXNcclxuICAvLyBhbHJlYWR5IGhhcHBlbnMgd2hlbiB0aGUgbGFzdCBjb21wb25lbnQgdGhhdCB3YXMgcmV0YWluaW5nIHRoZSBub2RlIHVubW91bnRzLFxyXG4gIC8vIGFuZCB0aGlzIGNvdWxkIGhhcHBlbiBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoYXQuXHJcbiAgLy8gRGVsZXRlIGZyb20gVHJlZVN0YXRlIGFuZCBkZXAgZ3JhcGg6XHJcblxyXG5cclxuICB0cmVlU3RhdGUuYXRvbVZhbHVlcy5kZWxldGUobm9kZSk7XHJcbiAgdHJlZVN0YXRlLmRpcnR5QXRvbXMuZGVsZXRlKG5vZGUpO1xyXG4gIHRyZWVTdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5kZWxldGUobm9kZSk7XHJcbiAgY29uc3QgZ3JhcGggPSBzdG9yZVN0YXRlLmdyYXBoc0J5VmVyc2lvbi5nZXQodHJlZVN0YXRlLnZlcnNpb24pO1xyXG5cclxuICBpZiAoZ3JhcGgpIHtcclxuICAgIGNvbnN0IGRlcHMgPSBncmFwaC5ub2RlRGVwcy5nZXQobm9kZSk7XHJcblxyXG4gICAgaWYgKGRlcHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBncmFwaC5ub2RlRGVwcy5kZWxldGUobm9kZSk7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XHJcbiAgICAgICAgdmFyIF9ncmFwaCRub2RlVG9Ob2RlU3VicztcclxuXHJcbiAgICAgICAgKF9ncmFwaCRub2RlVG9Ob2RlU3VicyA9IGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChkZXApKSA9PT0gbnVsbCB8fCBfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ncmFwaCRub2RlVG9Ob2RlU3Vicy5kZWxldGUobm9kZSk7XHJcbiAgICAgIH1cclxuICAgIH0gLy8gTm8gbmVlZCB0byBkZWxldGUgc3ViJ3MgZGVwcyBhcyB0aGVyZSBzaG91bGQgYmUgbm8gc3VicyBhdCB0aGlzIHBvaW50LlxyXG4gICAgLy8gQnV0IGFuIGludmFyaWFudCB3b3VsZCByZXF1aXJlIGRlbGV0aW5nIG5vZGVzIGluIHRvcG9sb2dpY2FsIG9yZGVyLlxyXG5cclxuXHJcbiAgICBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5kZWxldGUobm9kZSk7XHJcbiAgfSAvLyBOb2RlIGNvbmZpZyAoZm9yIGZhbWlseSBtZW1iZXJzIG9ubHkgYXMgdGhlaXIgY29uZmlncyBjYW4gYmUgcmVjcmVhdGVkLCBhbmRcclxuICAvLyBvbmx5IGlmIHRoZXkgYXJlIG5vdCByZXRhaW5lZCB3aXRoaW4gYW55IG90aGVyIFN0b3Jlcyk6XHJcblxyXG5cclxuICBkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZSQxKG5vZGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBub2Rlc1JldGFpbmVkQnlab25lKHN0b3JlU3RhdGUsIHpvbmUpIHtcclxuICB2YXIgX3N0b3JlU3RhdGUkcmV0ZW50aW9uMztcclxuXHJcbiAgcmV0dXJuIChfc3RvcmVTdGF0ZSRyZXRlbnRpb24zID0gc3RvcmVTdGF0ZS5yZXRlbnRpb24ubm9kZXNSZXRhaW5lZEJ5Wm9uZS5nZXQoem9uZSkpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJHJldGVudGlvbjMgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJHJldGVudGlvbjMgOiBlbXB0eVNldCQxO1xyXG59XHJcblxyXG5mdW5jdGlvbiB6b25lc1RoYXRDb3VsZFJldGFpbk5vZGUobm9kZSkge1xyXG4gIGNvbnN0IHJldGFpbmVkQnkgPSBnZXROb2RlJDMobm9kZSkucmV0YWluZWRCeTtcclxuXHJcbiAgaWYgKHJldGFpbmVkQnkgPT09IHVuZGVmaW5lZCB8fCByZXRhaW5lZEJ5ID09PSAnY29tcG9uZW50cycgfHwgcmV0YWluZWRCeSA9PT0gJ3JlY29pbFJvb3QnKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfSBlbHNlIGlmIChyZXRhaW5lZEJ5IGluc3RhbmNlb2YgUmV0ZW50aW9uWm9uZSQyKSB7XHJcbiAgICByZXR1cm4gW3JldGFpbmVkQnldO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gcmV0YWluZWRCeTsgLy8gaXQncyBhbiBhcnJheSBvZiB6b25lc1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2NoZWR1bGVPclBlcmZvcm1Qb3NzaWJsZVJlbGVhc2VPZlJldGFpbmFibGUoc3RvcmUsIHJldGFpbmFibGUpIHtcclxuICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gIGlmIChzdGF0ZS5uZXh0VHJlZSkge1xyXG4gICAgc3RhdGUucmV0ZW50aW9uLnJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2UuYWRkKHJldGFpbmFibGUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZWxlYXNlUmV0YWluYWJsZXNOb3dPbkN1cnJlbnRUcmVlKHN0b3JlLCBuZXcgU2V0KFtyZXRhaW5hYmxlXSkpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlUmV0YWluQ291bnQoc3RvcmUsIHJldGFpbmFibGUsIGRlbHRhKSB7XHJcbiAgdmFyIF9tYXAkZ2V0O1xyXG5cclxuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGNvbnN0IG1hcCA9IHN0b3JlLmdldFN0YXRlKCkucmV0ZW50aW9uLnJlZmVyZW5jZUNvdW50cztcclxuICBjb25zdCBuZXdDb3VudCA9ICgoX21hcCRnZXQgPSBtYXAuZ2V0KHJldGFpbmFibGUpKSAhPT0gbnVsbCAmJiBfbWFwJGdldCAhPT0gdm9pZCAwID8gX21hcCRnZXQgOiAwKSArIGRlbHRhO1xyXG5cclxuICBpZiAobmV3Q291bnQgPT09IDApIHtcclxuICAgIHVwZGF0ZVJldGFpbkNvdW50VG9aZXJvKHN0b3JlLCByZXRhaW5hYmxlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgbWFwLnNldChyZXRhaW5hYmxlLCBuZXdDb3VudCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVSZXRhaW5Db3VudFRvWmVybyhzdG9yZSwgcmV0YWluYWJsZSkge1xyXG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgbWFwID0gc3RvcmUuZ2V0U3RhdGUoKS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzO1xyXG4gIG1hcC5kZWxldGUocmV0YWluYWJsZSk7XHJcbiAgc2NoZWR1bGVPclBlcmZvcm1Qb3NzaWJsZVJlbGVhc2VPZlJldGFpbmFibGUoc3RvcmUsIHJldGFpbmFibGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3coc3RvcmUpIHtcclxuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICByZWxlYXNlUmV0YWluYWJsZXNOb3dPbkN1cnJlbnRUcmVlKHN0b3JlLCBzdGF0ZS5yZXRlbnRpb24ucmV0YWluYWJsZXNUb0NoZWNrRm9yUmVsZWFzZSk7XHJcbiAgc3RhdGUucmV0ZW50aW9uLnJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2UuY2xlYXIoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0KHIpIHtcclxuICAvLyBUaGUgZGVmYXVsdCB3aWxsIGNoYW5nZSBmcm9tICdyZWNvaWxSb290JyB0byAnY29tcG9uZW50cycgaW4gdGhlIGZ1dHVyZS5cclxuICByZXR1cm4gciA9PT0gdW5kZWZpbmVkID8gJ3JlY29pbFJvb3QnIDogcjtcclxufVxyXG5cclxudmFyIFJlY29pbF9SZXRlbnRpb24gPSB7XHJcbiAgU1VTUEVOU0VfVElNRU9VVF9NUyxcclxuICB1cGRhdGVSZXRhaW5Db3VudCxcclxuICB1cGRhdGVSZXRhaW5Db3VudFRvWmVybyxcclxuICByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3csXHJcbiAgcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0XHJcbn07XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdG8gZXhwb3J0IGVzc3RpZW50aWFsIGZ1bmN0aW9ucyBmcm9tIHJlYWN0LWRvbVxyXG4gKiBmb3Igb3VyIHdlYiBidWlsZFxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuY29uc3Qge1xyXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzXHJcbn0gPSByZWFjdERvbTtcclxuXHJcbnZhciBSZWFjdEJhdGNoZWRVcGRhdGVzID0ge1xyXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzXHJcbn07XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdG8gZXhwb3J0IGVzc3RpZW50aWFsIGZ1bmN0aW9ucyBmcm9tIHJlYWN0LWRvbVxyXG4gKiBmb3Igb3VyIHdlYiBidWlsZFxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuLy8gQGZiLW9ubHk6IGNvbnN0IHt1bnN0YWJsZV9iYXRjaGVkVXBkYXRlc30gPSByZXF1aXJlKCdSZWFjdERPTUNvbWV0Jyk7XHJcbi8vIHByZXR0aWVyLWlnbm9yZVxyXG5jb25zdCB7XHJcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDFcclxufSA9IFJlYWN0QmF0Y2hlZFVwZGF0ZXM7IC8vIEBvc3Mtb25seVxyXG5cclxuXHJcbnZhciBSZWNvaWxfUmVhY3RCYXRjaGVkVXBkYXRlcyA9IHtcclxuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMkMVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuY29uc3Qge1xyXG4gIGJhdGNoU3RhcnQ6IGJhdGNoU3RhcnQkMVxyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xyXG5cclxuY29uc3Qge1xyXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQyXHJcbn0gPSBSZWNvaWxfUmVhY3RCYXRjaGVkVXBkYXRlcztcclxuXHJcbmxldCBiYXRjaGVyID0gdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMkMjsgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBwcm92aWRlZCBiYXRjaGVyIGZ1bmN0aW9uIGFzIHRoZSBiYXRjaGVyIGZ1bmN0aW9uIHVzZWQgYnkgUmVjb2lsLlxyXG4gKlxyXG4gKiBTZXQgdGhlIGJhdGNoZXIgdG8gYSBjdXN0b20gYmF0Y2hlciBmb3IgeW91ciByZW5kZXJlcixcclxuICogaWYgeW91IHVzZSBhIHJlbmRlcmVyIG90aGVyIHRoYW4gUmVhY3QgRE9NIG9yIFJlYWN0IE5hdGl2ZS5cclxuICovXHJcbmNvbnN0IHNldEJhdGNoZXIgPSBuZXdCYXRjaGVyID0+IHtcclxuICBiYXRjaGVyID0gbmV3QmF0Y2hlcjtcclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgYmF0Y2hlciBmdW5jdGlvbi5cclxuICovXHJcblxyXG5cclxuY29uc3QgZ2V0QmF0Y2hlciA9ICgpID0+IGJhdGNoZXI7XHJcbi8qKlxyXG4gKiBDYWxscyB0aGUgY3VycmVudCBiYXRjaGVyIGZ1bmN0aW9uIGFuZCBwYXNzZXMgdGhlXHJcbiAqIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcblxyXG5jb25zdCBiYXRjaFVwZGF0ZXMgPSBjYWxsYmFjayA9PiB7XHJcbiAgYmF0Y2hlcigoKSA9PiB7XHJcbiAgICBsZXQgYmF0Y2hFbmQgPSAoKSA9PiB1bmRlZmluZWQ7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgYmF0Y2hFbmQgPSBiYXRjaFN0YXJ0JDEoKTtcclxuICAgICAgY2FsbGJhY2soKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIGJhdGNoRW5kKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn07XHJcblxyXG52YXIgUmVjb2lsX0JhdGNoaW5nID0ge1xyXG4gIGdldEJhdGNoZXIsXHJcbiAgc2V0QmF0Y2hlcixcclxuICBiYXRjaFVwZGF0ZXNcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcbi8qKlxyXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBJdGVyYWJsZXMgaW50byBhIHNpbmdsZSBJdGVyYWJsZS5cclxuICogVHJhdmVyc2VzIHRoZSBpbnB1dCBJdGVyYWJsZXMgaW4gdGhlIG9yZGVyIHByb3ZpZGVkIGFuZCBtYWludGFpbnMgdGhlIG9yZGVyXHJcbiAqIG9mIHRoZWlyIGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKiBgYGBcclxuICogY29uc3QgciA9IEFycmF5LmZyb20oY29uY2F0SXRlcmFibGVzKFsnYScsICdiJ10sIFsnYyddLCBbJ2QnLCAnZScsICdmJ10pKTtcclxuICogciA9PSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJ107XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uKiBjb25jYXRJdGVyYWJsZXMoaXRlcnMpIHtcclxuICBmb3IgKGNvbnN0IGl0ZXIgb2YgaXRlcnMpIHtcclxuICAgIGZvciAoY29uc3QgdmFsIG9mIGl0ZXIpIHtcclxuICAgICAgeWllbGQgdmFsO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIFJlY29pbF9jb25jYXRJdGVyYWJsZXMgPSBjb25jYXRJdGVyYWJsZXM7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvdHlwZW9mLXVuZGVmaW5lZCAqL1xyXG5cclxuY29uc3QgaXNTU1IgPSAvLyAkRmxvd0ZpeE1lKHNpdGU9cmVjb2lsKSBXaW5kb3cgZG9lcyBub3QgaGF2ZSBhIEZsb3dUeXBlIGRlZmluaXRpb24gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzY3MDlcclxudHlwZW9mIFdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XHJcbi8qIGVzbGludC1lbmFibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cclxuXHJcbmNvbnN0IGlzV2luZG93ID0gdmFsdWUgPT4gIWlzU1NSICYmICggLy8gJEZsb3dGaXhNZShzaXRlPXJlY29pbCkgV2luZG93IGRvZXMgbm90IGhhdmUgYSBGbG93VHlwZSBkZWZpbml0aW9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy82NzA5XHJcbnZhbHVlID09PSB3aW5kb3cgfHwgdmFsdWUgaW5zdGFuY2VvZiBXaW5kb3cpO1xyXG5cclxuY29uc3QgaXNSZWFjdE5hdGl2ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkXHJcblxyXG52YXIgUmVjb2lsX0Vudmlyb25tZW50ID0ge1xyXG4gIGlzU1NSLFxyXG4gIGlzUmVhY3ROYXRpdmUsXHJcbiAgaXNXaW5kb3dcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcbi8qKlxyXG4gKiBDYWNoZXMgYSBmdW5jdGlvbidzIHJlc3VsdHMgYmFzZWQgb24gdGhlIGtleSByZXR1cm5lZCBieSB0aGUgcGFzc2VkXHJcbiAqIGhhc2hGdW5jdGlvbi5cclxuICovXHJcblxyXG5mdW5jdGlvbiBtZW1vaXplV2l0aEFyZ3NIYXNoKGZuLCBoYXNoRnVuY3Rpb24pIHtcclxuICBsZXQgY2FjaGU7XHJcblxyXG4gIGNvbnN0IG1lbW9pemVkRm4gPSAoLi4uYXJncykgPT4ge1xyXG4gICAgaWYgKCFjYWNoZSkge1xyXG4gICAgICBjYWNoZSA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGtleSA9IGhhc2hGdW5jdGlvbiguLi5hcmdzKTtcclxuXHJcbiAgICBpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBrZXkpKSB7XHJcbiAgICAgIGNhY2hlW2tleV0gPSBmbiguLi5hcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2FjaGVba2V5XTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gbWVtb2l6ZWRGbjtcclxufVxyXG4vKipcclxuICogQ2FjaGVzIGEgZnVuY3Rpb24ncyByZXN1bHRzIGJhc2VkIG9uIGEgY29tcGFyaXNvbiBvZiB0aGUgYXJndW1lbnRzLlxyXG4gKiBPbmx5IGNhY2hlcyB0aGUgbGFzdCByZXR1cm4gb2YgdGhlIGZ1bmN0aW9uLlxyXG4gKiBEZWZhdWx0cyB0byByZWZlcmVuY2UgZXF1YWxpdHlcclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaChmbiwgaGFzaEZ1bmN0aW9uKSB7XHJcbiAgbGV0IGxhc3RLZXk7XHJcbiAgbGV0IGxhc3RSZXN1bHQ7IC8vIGJyZWFraW5nIGNhY2hlIHdoZW4gYXJndW1lbnRzIGNoYW5nZVxyXG5cclxuICBjb25zdCBtZW1vaXplZEZuID0gKC4uLmFyZ3MpID0+IHtcclxuICAgIGNvbnN0IGtleSA9IGhhc2hGdW5jdGlvbiguLi5hcmdzKTtcclxuXHJcbiAgICBpZiAobGFzdEtleSA9PT0ga2V5KSB7XHJcbiAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGxhc3RLZXkgPSBrZXk7XHJcbiAgICBsYXN0UmVzdWx0ID0gZm4oLi4uYXJncyk7XHJcbiAgICByZXR1cm4gbGFzdFJlc3VsdDtcclxuICB9O1xyXG5cclxuICByZXR1cm4gbWVtb2l6ZWRGbjtcclxufVxyXG4vKipcclxuICogQ2FjaGVzIGEgZnVuY3Rpb24ncyByZXN1bHRzIGJhc2VkIG9uIGEgY29tcGFyaXNvbiBvZiB0aGUgYXJndW1lbnRzLlxyXG4gKiBPbmx5IGNhY2hlcyB0aGUgbGFzdCByZXR1cm4gb2YgdGhlIGZ1bmN0aW9uLlxyXG4gKiBEZWZhdWx0cyB0byByZWZlcmVuY2UgZXF1YWxpdHlcclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaEFuZEludmFsaWRhdGlvbihmbiwgaGFzaEZ1bmN0aW9uKSB7XHJcbiAgbGV0IGxhc3RLZXk7XHJcbiAgbGV0IGxhc3RSZXN1bHQ7IC8vIGJyZWFraW5nIGNhY2hlIHdoZW4gYXJndW1lbnRzIGNoYW5nZVxyXG5cclxuICBjb25zdCBtZW1vaXplZEZuID0gKC4uLmFyZ3MpID0+IHtcclxuICAgIGNvbnN0IGtleSA9IGhhc2hGdW5jdGlvbiguLi5hcmdzKTtcclxuXHJcbiAgICBpZiAobGFzdEtleSA9PT0ga2V5KSB7XHJcbiAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGxhc3RLZXkgPSBrZXk7XHJcbiAgICBsYXN0UmVzdWx0ID0gZm4oLi4uYXJncyk7XHJcbiAgICByZXR1cm4gbGFzdFJlc3VsdDtcclxuICB9O1xyXG5cclxuICBjb25zdCBpbnZhbGlkYXRlID0gKCkgPT4ge1xyXG4gICAgbGFzdEtleSA9IG51bGw7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFttZW1vaXplZEZuLCBpbnZhbGlkYXRlXTtcclxufVxyXG5cclxudmFyIFJlY29pbF9NZW1vaXplID0ge1xyXG4gIG1lbW9pemVXaXRoQXJnc0hhc2gsXHJcbiAgbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaCxcclxuICBtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uXHJcbn07XHJcblxyXG5jb25zdCB7XHJcbiAgYmF0Y2hVcGRhdGVzOiBiYXRjaFVwZGF0ZXMkMVxyXG59ID0gUmVjb2lsX0JhdGNoaW5nO1xyXG5cclxuY29uc3Qge1xyXG4gIGluaXRpYWxpemVOb2RlOiBpbml0aWFsaXplTm9kZSQxLFxyXG4gIHBlZWtOb2RlSW5mbzogcGVla05vZGVJbmZvJDFcclxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcclxuXHJcbmNvbnN0IHtcclxuICBncmFwaDogZ3JhcGgkMVxyXG59ID0gUmVjb2lsX0dyYXBoO1xyXG5cclxuY29uc3Qge1xyXG4gIGdldE5leHRTdG9yZUlEOiBnZXROZXh0U3RvcmVJRCQxXHJcbn0gPSBSZWNvaWxfS2V5cztcclxuXHJcbmNvbnN0IHtcclxuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDEsXHJcbiAgcmVjb2lsVmFsdWVzOiByZWNvaWxWYWx1ZXMkMSxcclxuICByZWNvaWxWYWx1ZXNGb3JLZXlzOiByZWNvaWxWYWx1ZXNGb3JLZXlzJDJcclxufSA9IFJlY29pbF9Ob2RlO1xyXG5cclxuY29uc3Qge1xyXG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkMixcclxuICBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGU6IGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQxLFxyXG4gIHNldFJlY29pbFZhbHVlOiBzZXRSZWNvaWxWYWx1ZSQxLFxyXG4gIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWU6IHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMVxyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xyXG5cclxuY29uc3Qge1xyXG4gIHVwZGF0ZVJldGFpbkNvdW50OiB1cGRhdGVSZXRhaW5Db3VudCQxXHJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xyXG5cclxuY29uc3Qge1xyXG4gIHNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90OiBzZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQxXHJcbn0gPSBSZWNvaWxfU25hcHNob3RDYWNoZTtcclxuXHJcbmNvbnN0IHtcclxuICBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbjogZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMixcclxuICBtYWtlRW1wdHlTdG9yZVN0YXRlOiBtYWtlRW1wdHlTdG9yZVN0YXRlJDFcclxufSA9IFJlY29pbF9TdGF0ZTtcclxuXHJcblxyXG5cclxuY29uc3Qge1xyXG4gIGlzU1NSOiBpc1NTUiQxXHJcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IHtcclxuICBtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uOiBtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uJDFcclxufSA9IFJlY29pbF9NZW1vaXplO1xyXG5cclxuXHJcblxyXG4gLy8gT3BhcXVlIGF0IHRoaXMgc3VyZmFjZSBiZWNhdXNlIGl0J3MgcGFydCBvZiB0aGUgcHVibGljIEFQSSBmcm9tIGhlcmUuXHJcblxyXG5cclxuY29uc3QgcmV0YWluV2FybmluZyA9IGBcclxuUmVjb2lsIFNuYXBzaG90cyBvbmx5IGxhc3QgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgY2FsbGJhY2sgdGhleSBhcmUgcHJvdmlkZWQgdG8uIFRvIGtlZXAgYSBTbmFwc2hvdCBsb25nZXIsIGRvIHRoaXM6XHJcblxyXG4gIGNvbnN0IHJlbGVhc2UgPSBzbmFwc2hvdC5yZXRhaW4oKTtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgZG9Tb21ldGhpbmdXaXRoU25hcHNob3Qoc25hcHNob3QpO1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICByZWxlYXNlKCk7XHJcbiAgfVxyXG5cclxuVGhpcyBpcyBjdXJyZW50bHkgYSBERVYtb25seSB3YXJuaW5nIGJ1dCB3aWxsIGJlY29tZSBhIHRocm93biBleGNlcHRpb24gaW4gdGhlIG5leHQgcmVsZWFzZSBvZiBSZWNvaWwuXHJcbmA7IC8vIEEgXCJTbmFwc2hvdFwiIGlzIFwicmVhZC1vbmx5XCIgYW5kIGNhcHR1cmVzIGEgc3BlY2lmaWMgc2V0IG9mIHZhbHVlcyBvZiBhdG9tcy5cclxuLy8gSG93ZXZlciwgdGhlIGRhdGEtZmxvdy1ncmFwaCBhbmQgc2VsZWN0b3IgdmFsdWVzIG1heSBldm9sdmUgYXMgc2VsZWN0b3JcclxuLy8gZXZhbHVhdGlvbiBmdW5jdGlvbnMgYXJlIGV4ZWN1dGVkIGFuZCBhc3luYyBzZWxlY3RvcnMgcmVzb2x2ZS5cclxuXHJcbmNsYXNzIFNuYXBzaG90IHtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L25vLXVuaW5pdGlhbGl6ZWQtcHJvcGVydGllc1xyXG4gIGNvbnN0cnVjdG9yKHN0b3JlU3RhdGUsIHBhcmVudFN0b3JlSUQpIHtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdG9yZVwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yZWZDb3VudFwiLCAxKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRMb2FkYWJsZVwiLCByZWNvaWxWYWx1ZSA9PiB7XHJcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xyXG4gICAgICByZXR1cm4gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDEodGhpcy5fc3RvcmUsIHJlY29pbFZhbHVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFByb21pc2VcIiwgcmVjb2lsVmFsdWUgPT4ge1xyXG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9hZGFibGUocmVjb2lsVmFsdWUpLnRvUHJvbWlzZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0Tm9kZXNfVU5TVEFCTEVcIiwgb3B0ID0+IHtcclxuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7IC8vIFRPRE8gRGVhbCB3aXRoIG1vZGlmaWVkIHNlbGVjdG9yc1xyXG5cclxuICAgICAgaWYgKChvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuaXNNb2RpZmllZCkgPT09IHRydWUpIHtcclxuICAgICAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5pc0luaXRpYWxpemVkKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlY29pbFZhbHVlc0ZvcktleXMkMihzdGF0ZS5kaXJ0eUF0b21zKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qga25vd25BdG9tcyA9IHRoaXMuX3N0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcztcclxuXHJcbiAgICAgIGNvbnN0IGtub3duU2VsZWN0b3JzID0gdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5rbm93blNlbGVjdG9ycztcclxuXHJcbiAgICAgIHJldHVybiAob3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LmlzSW5pdGlhbGl6ZWQpID09IG51bGwgPyByZWNvaWxWYWx1ZXMkMS52YWx1ZXMoKSA6IG9wdC5pc0luaXRpYWxpemVkID09PSB0cnVlID8gcmVjb2lsVmFsdWVzRm9yS2V5cyQyKFJlY29pbF9jb25jYXRJdGVyYWJsZXMoW2tub3duQXRvbXMsIGtub3duU2VsZWN0b3JzXSkpIDogUmVjb2lsX2ZpbHRlckl0ZXJhYmxlKHJlY29pbFZhbHVlcyQxLnZhbHVlcygpLCAoe1xyXG4gICAgICAgIGtleVxyXG4gICAgICB9KSA9PiAha25vd25BdG9tcy5oYXMoa2V5KSAmJiAha25vd25TZWxlY3RvcnMuaGFzKGtleSkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0SW5mb19VTlNUQUJMRVwiLCAoe1xyXG4gICAgICBrZXlcclxuICAgIH0pID0+IHtcclxuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XHJcbiAgICAgIHJldHVybiBwZWVrTm9kZUluZm8kMSh0aGlzLl9zdG9yZSwgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSwga2V5KTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1hcFwiLCBtYXBwZXIgPT4ge1xyXG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcclxuICAgICAgY29uc3QgbXV0YWJsZVNuYXBzaG90ID0gbmV3IE11dGFibGVTbmFwc2hvdCh0aGlzLCBiYXRjaFVwZGF0ZXMkMSk7XHJcbiAgICAgIG1hcHBlcihtdXRhYmxlU25hcHNob3QpOyAvLyBpZiByZW1vdmluZyBiYXRjaFVwZGF0ZXMgZnJvbSBgc2V0YCBhZGQgaXQgaGVyZVxyXG5cclxuICAgICAgcmV0dXJuIG11dGFibGVTbmFwc2hvdDtcclxuICAgIH0pO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFzeW5jTWFwXCIsIGFzeW5jIG1hcHBlciA9PiB7XHJcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xyXG4gICAgICBjb25zdCBtdXRhYmxlU25hcHNob3QgPSBuZXcgTXV0YWJsZVNuYXBzaG90KHRoaXMsIGJhdGNoVXBkYXRlcyQxKTtcclxuICAgICAgbXV0YWJsZVNuYXBzaG90LnJldGFpbigpOyAvLyBSZXRhaW4gbmV3IHNuYXBzaG90IGR1cmluZyBhc3luYyBtYXBwZXJcclxuXHJcbiAgICAgIGF3YWl0IG1hcHBlcihtdXRhYmxlU25hcHNob3QpOyAvLyBDb250aW51ZSB0byByZXRhaW4gdGhlIG5ldyBzbmFwc2hvdCBmb3IgdGhlIHVzZXIsIGJ1dCBhdXRvLXJlbGVhc2UgaXRcclxuICAgICAgLy8gYWZ0ZXIgdGhlIG5leHQgdGljaywgdGhlIHNhbWUgYXMgYSBuZXcgc3luY2hyb25vdXMgc25hcHNob3QuXHJcblxyXG4gICAgICBtdXRhYmxlU25hcHNob3QuYXV0b1JlbGVhc2VfSU5URVJOQUwoKTtcclxuICAgICAgcmV0dXJuIG11dGFibGVTbmFwc2hvdDtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX3N0b3JlID0ge1xyXG4gICAgICBzdG9yZUlEOiBnZXROZXh0U3RvcmVJRCQxKCksXHJcbiAgICAgIHBhcmVudFN0b3JlSUQsXHJcbiAgICAgIGdldFN0YXRlOiAoKSA9PiBzdG9yZVN0YXRlLFxyXG4gICAgICByZXBsYWNlU3RhdGU6IHJlcGxhY2VyID0+IHtcclxuICAgICAgICAvLyBubyBiYXRjaGluZywgc28gbmV4dFRyZWUgaXMgbmV2ZXIgYWN0aXZlXHJcbiAgICAgICAgc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA9IHJlcGxhY2VyKHN0b3JlU3RhdGUuY3VycmVudFRyZWUpO1xyXG4gICAgICB9LFxyXG4gICAgICBnZXRHcmFwaDogdmVyc2lvbiA9PiB7XHJcbiAgICAgICAgY29uc3QgZ3JhcGhzID0gc3RvcmVTdGF0ZS5ncmFwaHNCeVZlcnNpb247XHJcblxyXG4gICAgICAgIGlmIChncmFwaHMuaGFzKHZlcnNpb24pKSB7XHJcbiAgICAgICAgICByZXR1cm4gUmVjb2lsX251bGx0aHJvd3MoZ3JhcGhzLmdldCh2ZXJzaW9uKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBuZXdHcmFwaCA9IGdyYXBoJDEoKTtcclxuICAgICAgICBncmFwaHMuc2V0KHZlcnNpb24sIG5ld0dyYXBoKTtcclxuICAgICAgICByZXR1cm4gbmV3R3JhcGg7XHJcbiAgICAgIH0sXHJcbiAgICAgIHN1YnNjcmliZVRvVHJhbnNhY3Rpb25zOiAoKSA9PiAoe1xyXG4gICAgICAgIHJlbGVhc2U6ICgpID0+IHt9XHJcbiAgICAgIH0pLFxyXG4gICAgICBhZGRUcmFuc2FjdGlvbk1ldGFkYXRhOiAoKSA9PiB7XHJcbiAgICAgICAgdGhyb3cgUmVjb2lsX2VycignQ2Fubm90IHN1YnNjcmliZSB0byBTbmFwc2hvdHMnKTtcclxuICAgICAgfVxyXG4gICAgfTsgLy8gSW5pdGlhbGl6ZSBhbnkgbm9kZXMgdGhhdCBhcmUgbGl2ZSBpbiB0aGUgcGFyZW50IHN0b3JlIChwcmltYXJpbHkgc28gdGhhdFxyXG4gICAgLy8gdGhpcyBzbmFwc2hvdCBnZXRzIGNvdW50ZWQgdG93YXJkcyB0aGUgbm9kZSdzIGxpdmUgc3RvcmVzIGNvdW50KS5cclxuICAgIC8vIFRPRE8gT3B0aW1pemUgdGhpcyB3aGVuIGNsb25pbmcgc25hcHNob3RzIGZvciBjYWxsYmFja3NcclxuXHJcbiAgICBmb3IgKGNvbnN0IG5vZGVLZXkgb2YgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5rbm93bkF0b21zKSB7XHJcbiAgICAgIGluaXRpYWxpemVOb2RlJDEodGhpcy5fc3RvcmUsIG5vZGVLZXksICdnZXQnKTtcclxuICAgICAgdXBkYXRlUmV0YWluQ291bnQkMSh0aGlzLl9zdG9yZSwgbm9kZUtleSwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hdXRvUmVsZWFzZV9JTlRFUk5BTCgpO1xyXG4gIH1cclxuXHJcbiAgcmV0YWluKCkge1xyXG4gICAgaWYgKHRoaXMuX3JlZkNvdW50IDw9IDApIHtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIHRocm93IFJlY29pbF9lcnIoJ1NuYXBzaG90IGhhcyBhbHJlYWR5IGJlZW4gcmVsZWFzZWQuJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdBdHRlbXB0IHRvIHJldGFpbigpIFNuYXBzaG90IHRoYXQgd2FzIGFscmVhZHkgcmVsZWFzZWQuJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9yZWZDb3VudCsrO1xyXG4gICAgbGV0IHJlbGVhc2VkID0gZmFsc2U7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBpZiAoIXJlbGVhc2VkKSB7XHJcbiAgICAgICAgcmVsZWFzZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLl9yZWxlYXNlKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlbGVhc2UgdGhlIHNuYXBzaG90IG9uIHRoZSBuZXh0IHRpY2suICBUaGlzIG1lYW5zIHRoZSBzbmFwc2hvdCBpcyByZXRhaW5lZFxyXG4gICAqIGR1cmluZyB0aGUgZXhlY3V0aW9uIG9mIHRoZSBjdXJyZW50IGZ1bmN0aW9uIHVzaW5nIGl0LlxyXG4gICAqL1xyXG5cclxuXHJcbiAgYXV0b1JlbGVhc2VfSU5URVJOQUwoKSB7XHJcbiAgICBpZiAoIWlzU1NSJDEpIHtcclxuICAgICAgLy8gVXNlIHRpbWVvdXQgb2YgMTAgdG8gd29ya2Fyb3VuZCBGaXJlZm94IGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tleHBlcmltZW50YWwvUmVjb2lsL2lzc3Vlcy8xOTM2XHJcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuX3JlbGVhc2UoKSwgMTApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3JlbGVhc2UoKSB7XHJcbiAgICB0aGlzLl9yZWZDb3VudC0tO1xyXG5cclxuICAgIGlmICh0aGlzLl9yZWZDb3VudCA9PT0gMCkge1xyXG4gICAgICB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLm5vZGVDbGVhbnVwRnVuY3Rpb25zLmZvckVhY2goY2xlYW51cCA9PiBjbGVhbnVwKCkpO1xyXG5cclxuICAgICAgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5jbGVhcigpO1xyXG5cclxuICAgICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9IC8vIFRlbXBvcmFyaWx5IG5lcmZpbmcgdGhpcyB0byBhbGxvdyB1cyB0byBmaW5kIGJyb2tlbiBjYWxsIHNpdGVzIHdpdGhvdXRcclxuICAgICAgLy8gYWN0dWFsbHkgYnJlYWtpbmcgYW55Ym9keSB5ZXQuXHJcbiAgICAgIC8vIGZvciAoY29uc3QgayBvZiB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMpIHtcclxuICAgICAgLy8gICB1cGRhdGVSZXRhaW5Db3VudFRvWmVybyh0aGlzLl9zdG9yZSwgayk7XHJcbiAgICAgIC8vIH1cclxuXHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3JlZkNvdW50IDwgMCkge1xyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdTbmFwc2hvdCByZWxlYXNlZCBhbiBleHRyYSB0aW1lLicpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpc1JldGFpbmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3JlZkNvdW50ID4gMDtcclxuICB9XHJcblxyXG4gIGNoZWNrUmVmQ291bnRfSU5URVJOQUwoKSB7XHJcbiAgICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSAmJiB0aGlzLl9yZWZDb3VudCA8PSAwKSB7XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24ocmV0YWluV2FybmluZyk7XHJcbiAgICAgIH0gLy8gV2hhdCB3ZSB3aWxsIHNoaXAgbGF0ZXI6XHJcbiAgICAgIC8vIHRocm93IGVycihyZXRhaW5XYXJuaW5nKTtcclxuXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRTdG9yZV9JTlRFUk5BTCgpIHtcclxuICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlO1xyXG4gIH1cclxuXHJcbiAgZ2V0SUQoKSB7XHJcbiAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcclxuICAgIHJldHVybiB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLnN0YXRlSUQ7XHJcbiAgfVxyXG5cclxuICBnZXRTdG9yZUlEKCkge1xyXG4gICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RvcmUuc3RvcmVJRDtcclxuICB9IC8vIFdlIHdhbnQgdG8gYWxsb3cgdGhlIG1ldGhvZHMgdG8gYmUgZGVzdHJ1Y3R1cmVkIGFuZCB1c2VkIGFzIGFjY2Vzc29yc1xyXG5cclxuICAvKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvZXh0cmEtYXJyb3ctaW5pdGlhbGl6ZXIgKi9cclxuXHJcbiAgLyogZXNsaW50LWVuYWJsZSBmYi13d3cvZXh0cmEtYXJyb3ctaW5pdGlhbGl6ZXIgKi9cclxuXHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBjbG9uZVN0b3JlU3RhdGUoc3RvcmUsIHRyZWVTdGF0ZSwgYnVtcFZlcnNpb24gPSBmYWxzZSkge1xyXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG4gIGNvbnN0IHZlcnNpb24gPSBidW1wVmVyc2lvbiA/IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDIoKSA6IHRyZWVTdGF0ZS52ZXJzaW9uO1xyXG4gIHJldHVybiB7XHJcbiAgICAvLyBBbHdheXMgY2xvbmUgdGhlIFRyZWVTdGF0ZSB0byBpc29sYXRlIHN0b3JlcyBmcm9tIGFjY2lkZW50YWwgbXV0YXRpb25zLlxyXG4gICAgLy8gRm9yIGV4YW1wbGUsIHJlYWRpbmcgYSBzZWxlY3RvciBmcm9tIGEgY2xvbmVkIHNuYXBzaG90IHNob3VsZG4ndCBjYWNoZVxyXG4gICAgLy8gaW4gdGhlIG9yaWdpbmFsIHRyZWVzdGF0ZSB3aGljaCBtYXkgY2F1c2UgdGhlIG9yaWdpbmFsIHRvIHNraXBcclxuICAgIC8vIGluaXRpYWxpemF0aW9uIG9mIHVwc3RyZWFtIGF0b21zLlxyXG4gICAgY3VycmVudFRyZWU6IHtcclxuICAgICAgLy8gVE9ETyBzbmFwc2hvdHMgc2hvdWxkbid0IHJlYWxseSBoYXZlIHZlcnNpb25zIGJlY2F1c2UgYSBuZXcgdmVyc2lvbiBudW1iZXJcclxuICAgICAgLy8gaXMgYWx3YXlzIGFzc2lnbmVkIHdoZW4gdGhlIHNuYXBzaG90IGlzIGdvbmUgdG8uXHJcbiAgICAgIHZlcnNpb246IGJ1bXBWZXJzaW9uID8gdmVyc2lvbiA6IHRyZWVTdGF0ZS52ZXJzaW9uLFxyXG4gICAgICBzdGF0ZUlEOiBidW1wVmVyc2lvbiA/IHZlcnNpb24gOiB0cmVlU3RhdGUuc3RhdGVJRCxcclxuICAgICAgdHJhbnNhY3Rpb25NZXRhZGF0YTogeyAuLi50cmVlU3RhdGUudHJhbnNhY3Rpb25NZXRhZGF0YVxyXG4gICAgICB9LFxyXG4gICAgICBkaXJ0eUF0b21zOiBuZXcgU2V0KHRyZWVTdGF0ZS5kaXJ0eUF0b21zKSxcclxuICAgICAgYXRvbVZhbHVlczogdHJlZVN0YXRlLmF0b21WYWx1ZXMuY2xvbmUoKSxcclxuICAgICAgbm9udmFsaWRhdGVkQXRvbXM6IHRyZWVTdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5jbG9uZSgpXHJcbiAgICB9LFxyXG4gICAgY29tbWl0RGVwdGg6IDAsXHJcbiAgICBuZXh0VHJlZTogbnVsbCxcclxuICAgIHByZXZpb3VzVHJlZTogbnVsbCxcclxuICAgIGtub3duQXRvbXM6IG5ldyBTZXQoc3RvcmVTdGF0ZS5rbm93bkF0b21zKSxcclxuICAgIC8vIEZJWE1FIGhlcmUncyBhIGNvcHlcclxuICAgIGtub3duU2VsZWN0b3JzOiBuZXcgU2V0KHN0b3JlU3RhdGUua25vd25TZWxlY3RvcnMpLFxyXG4gICAgLy8gRklYTUUgaGVyZSdzIGEgY29weVxyXG4gICAgdHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXHJcbiAgICBub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXHJcbiAgICBub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXHJcbiAgICBxdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRDogW10sXHJcbiAgICBzdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnM6IG5ldyBTZXQoKSxcclxuICAgIGdyYXBoc0J5VmVyc2lvbjogbmV3IE1hcCgpLnNldCh2ZXJzaW9uLCBzdG9yZS5nZXRHcmFwaCh0cmVlU3RhdGUudmVyc2lvbikpLFxyXG4gICAgcmV0ZW50aW9uOiB7XHJcbiAgICAgIHJlZmVyZW5jZUNvdW50czogbmV3IE1hcCgpLFxyXG4gICAgICBub2Rlc1JldGFpbmVkQnlab25lOiBuZXcgTWFwKCksXHJcbiAgICAgIHJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2U6IG5ldyBTZXQoKVxyXG4gICAgfSxcclxuICAgIC8vIEZJWE1FIGhlcmUncyBhIGNvcHlcclxuICAgIC8vIENyZWF0ZSBibGFuayBjbGVhbnVwIGhhbmRsZXJzIGZvciBhdG9tcyBzbyBzbmFwc2hvdHMgZG9uJ3QgcmUtcnVuXHJcbiAgICAvLyBhdG9tIGVmZmVjdHMuXHJcbiAgICBub2RlQ2xlYW51cEZ1bmN0aW9uczogbmV3IE1hcChSZWNvaWxfbWFwSXRlcmFibGUoc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5lbnRyaWVzKCksIChba2V5XSkgPT4gW2tleSwgKCkgPT4ge31dKSlcclxuICB9O1xyXG59IC8vIEZhY3RvcnkgdG8gYnVpbGQgYSBmcmVzaCBzbmFwc2hvdFxyXG5cclxuXHJcbmZ1bmN0aW9uIGZyZXNoU25hcHNob3QoaW5pdGlhbGl6ZVN0YXRlKSB7XHJcbiAgY29uc3Qgc25hcHNob3QgPSBuZXcgU25hcHNob3QobWFrZUVtcHR5U3RvcmVTdGF0ZSQxKCkpO1xyXG4gIHJldHVybiBpbml0aWFsaXplU3RhdGUgIT0gbnVsbCA/IHNuYXBzaG90Lm1hcChpbml0aWFsaXplU3RhdGUpIDogc25hcHNob3Q7XHJcbn0gLy8gRmFjdG9yeSB0byBjbG9uZSBhIHNuYXBzaG90IHN0YXRlXHJcblxyXG5cclxuY29uc3QgW21lbW9pemVkQ2xvbmVTbmFwc2hvdCwgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMl0gPSBtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uJDEoKHN0b3JlLCB2ZXJzaW9uKSA9PiB7XHJcbiAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlO1xyXG5cclxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICBjb25zdCB0cmVlU3RhdGUgPSB2ZXJzaW9uID09PSAnbGF0ZXN0JyA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBSZWNvaWxfbnVsbHRocm93cyhzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSk7XHJcbiAgcmV0dXJuIG5ldyBTbmFwc2hvdChjbG9uZVN0b3JlU3RhdGUoc3RvcmUsIHRyZWVTdGF0ZSksIHN0b3JlLnN0b3JlSUQpO1xyXG59LCAoc3RvcmUsIHZlcnNpb24pID0+IHtcclxuICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRULCBfc3RvcmUkZ2V0U3RhdGUkcHJldmk7XHJcblxyXG4gIHJldHVybiBTdHJpbmcodmVyc2lvbikgKyBTdHJpbmcoc3RvcmUuc3RvcmVJRCkgKyBTdHJpbmcoKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA9IHN0b3JlLmdldFN0YXRlKCkubmV4dFRyZWUpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlJGdldFN0YXRlJG5leHRULnZlcnNpb24pICsgU3RyaW5nKHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUudmVyc2lvbikgKyBTdHJpbmcoKF9zdG9yZSRnZXRTdGF0ZSRwcmV2aSA9IHN0b3JlLmdldFN0YXRlKCkucHJldmlvdXNUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUkcHJldmkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZSRnZXRTdGF0ZSRwcmV2aS52ZXJzaW9uKTtcclxufSk7IC8vIEF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xyXG5cclxuc2V0SW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMShpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQyKTtcclxuXHJcbmZ1bmN0aW9uIGNsb25lU25hcHNob3Qoc3RvcmUsIHZlcnNpb24gPSAnbGF0ZXN0Jykge1xyXG4gIGNvbnN0IHNuYXBzaG90ID0gbWVtb2l6ZWRDbG9uZVNuYXBzaG90KHN0b3JlLCB2ZXJzaW9uKTtcclxuXHJcbiAgaWYgKCFzbmFwc2hvdC5pc1JldGFpbmVkKCkpIHtcclxuICAgIGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDIoKTtcclxuICAgIHJldHVybiBtZW1vaXplZENsb25lU25hcHNob3Qoc3RvcmUsIHZlcnNpb24pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNuYXBzaG90O1xyXG59XHJcblxyXG5jbGFzcyBNdXRhYmxlU25hcHNob3QgZXh0ZW5kcyBTbmFwc2hvdCB7XHJcbiAgY29uc3RydWN0b3Ioc25hcHNob3QsIGJhdGNoKSB7XHJcbiAgICBzdXBlcihjbG9uZVN0b3JlU3RhdGUoc25hcHNob3QuZ2V0U3RvcmVfSU5URVJOQUwoKSwgc25hcHNob3QuZ2V0U3RvcmVfSU5URVJOQUwoKS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLCB0cnVlKSwgc25hcHNob3QuZ2V0U3RvcmVJRCgpKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYmF0Y2hcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRcIiwgKHJlY29pbFN0YXRlLCBuZXdWYWx1ZU9yVXBkYXRlcikgPT4ge1xyXG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcclxuICAgICAgY29uc3Qgc3RvcmUgPSB0aGlzLmdldFN0b3JlX0lOVEVSTkFMKCk7IC8vIFRoaXMgYmF0Y2hVcGRhdGVzIGVuc3VyZXMgdGhpcyBgc2V0YCBpcyBhcHBsaWVkIGltbWVkaWF0ZWx5IGFuZCB5b3UgY2FuXHJcbiAgICAgIC8vIHJlYWQgdGhlIHdyaXR0ZW4gdmFsdWUgYWZ0ZXIgY2FsbGluZyBgc2V0YC4gSSB3b3VsZCBsaWtlIHRvIHJlbW92ZSB0aGlzXHJcbiAgICAgIC8vIGJlaGF2aW9yIGFuZCBvbmx5IGJhdGNoIGluIGBTbmFwc2hvdC5tYXBgLCBidXQgdGhpcyB3b3VsZCBiZSBhIGJyZWFraW5nXHJcbiAgICAgIC8vIGNoYW5nZSBwb3RlbnRpYWxseS5cclxuXHJcbiAgICAgIHRoaXMuX2JhdGNoKCgpID0+IHtcclxuICAgICAgICB1cGRhdGVSZXRhaW5Db3VudCQxKHN0b3JlLCByZWNvaWxTdGF0ZS5rZXksIDEpO1xyXG4gICAgICAgIHNldFJlY29pbFZhbHVlJDEodGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpLCByZWNvaWxTdGF0ZSwgbmV3VmFsdWVPclVwZGF0ZXIpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc2V0XCIsIHJlY29pbFN0YXRlID0+IHtcclxuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpOyAvLyBTZWUgbm90ZSBhdCBgc2V0YCBhYm91dCBiYXRjaGVkIHVwZGF0ZXMuXHJcblxyXG4gICAgICB0aGlzLl9iYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMShzdG9yZSwgcmVjb2lsU3RhdGUua2V5LCAxKTtcclxuICAgICAgICBzZXRSZWNvaWxWYWx1ZSQxKHRoaXMuZ2V0U3RvcmVfSU5URVJOQUwoKSwgcmVjb2lsU3RhdGUsIERFRkFVTFRfVkFMVUUkMSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzX0RFUFJFQ0FURURcIiwgdmFsdWVzID0+IHtcclxuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpOyAvLyBTZWUgbm90ZSBhdCBgc2V0YCBhYm91dCBiYXRjaGVkIHVwZGF0ZXMuXHJcblxyXG4gICAgICBiYXRjaFVwZGF0ZXMkMSgoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdmFsdWVzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMShzdG9yZSwgaywgMSk7XHJcbiAgICAgICAgICBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlJDEoc3RvcmUsIG5ldyBBYnN0cmFjdFJlY29pbFZhbHVlJDIoayksIHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9iYXRjaCA9IGJhdGNoO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbnZhciBSZWNvaWxfU25hcHNob3QgPSB7XHJcbiAgU25hcHNob3QsXHJcbiAgTXV0YWJsZVNuYXBzaG90LFxyXG4gIGZyZXNoU25hcHNob3QsXHJcbiAgY2xvbmVTbmFwc2hvdFxyXG59O1xyXG5cclxudmFyIFJlY29pbF9TbmFwc2hvdF8xID0gUmVjb2lsX1NuYXBzaG90LlNuYXBzaG90O1xyXG52YXIgUmVjb2lsX1NuYXBzaG90XzIgPSBSZWNvaWxfU25hcHNob3QuTXV0YWJsZVNuYXBzaG90O1xyXG52YXIgUmVjb2lsX1NuYXBzaG90XzMgPSBSZWNvaWxfU25hcHNob3QuZnJlc2hTbmFwc2hvdDtcclxudmFyIFJlY29pbF9TbmFwc2hvdF80ID0gUmVjb2lsX1NuYXBzaG90LmNsb25lU25hcHNob3Q7XHJcblxyXG52YXIgUmVjb2lsX1NuYXBzaG90JDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIFNuYXBzaG90OiBSZWNvaWxfU25hcHNob3RfMSxcclxuICBNdXRhYmxlU25hcHNob3Q6IFJlY29pbF9TbmFwc2hvdF8yLFxyXG4gIGZyZXNoU25hcHNob3Q6IFJlY29pbF9TbmFwc2hvdF8zLFxyXG4gIGNsb25lU25hcHNob3Q6IFJlY29pbF9TbmFwc2hvdF80XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHVuaW9uU2V0cyguLi5zZXRzKSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xyXG5cclxuICBmb3IgKGNvbnN0IHNldCBvZiBzZXRzKSB7XHJcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHNldCkge1xyXG4gICAgICByZXN1bHQuYWRkKHZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfdW5pb25TZXRzID0gdW5pb25TZXRzO1xyXG5cclxuY29uc3Qge1xyXG4gIHVzZVJlZlxyXG59ID0gcmVhY3Q7XHJcbi8qKlxyXG4gKiBUaGUgc2FtZSBhcyBgdXNlUmVmKClgIGV4Y2VwdCB0aGF0IGlmIGEgZnVuY3Rpb24gaXMgc3BlY2lmaWVkIHRoZW4gaXQgd2lsbFxyXG4gKiBjYWxsIHRoYXQgZnVuY3Rpb24gdG8gZ2V0IHRoZSB2YWx1ZSB0byBpbml0aWFsaXplIHRoZSByZWZlcmVuY2Ugd2l0aC5cclxuICogVGhpcyBpcyBzaW1pbGFyIHRvIGhvdyBgdXNlU3RhdGUoKWAgYmVoYXZlcyB3aGVuIGdpdmVuIGEgZnVuY3Rpb24uICBJdCBhbGxvd3NcclxuICogdGhlIHVzZXIgdG8gYXZvaWQgZ2VuZXJhdGluZyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3Igc3Vic2VxdWVudCByZW5kZXJzLlxyXG4gKiBUaGUgdHJhZGVvZmYgaXMgdGhhdCB0byBzZXQgdGhlIHJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIGl0c2VsZiB5b3UgbmVlZCB0b1xyXG4gKiBuZXN0IGl0OiB1c2VSZWZJbml0T25jZSgoKSA9PiAoKSA9PiB7Li4ufSk7XHJcbiAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIHVzZVJlZkluaXRPbmNlKGluaXRpYWxWYWx1ZSkge1xyXG4gIC8vICRGbG93RXhwZWN0ZWRFcnJvcltpbmNvbXBhdGlibGUtY2FsbF1cclxuICBjb25zdCByZWYgPSB1c2VSZWYoaW5pdGlhbFZhbHVlKTtcclxuXHJcbiAgaWYgKHJlZi5jdXJyZW50ID09PSBpbml0aWFsVmFsdWUgJiYgdHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yW2luY29tcGF0aWJsZS11c2VdXHJcbiAgICByZWYuY3VycmVudCA9IGluaXRpYWxWYWx1ZSgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlZjtcclxufVxyXG5cclxudmFyIFJlY29pbF91c2VSZWZJbml0T25jZSA9IHVzZVJlZkluaXRPbmNlO1xyXG5cclxuLy8gQGZiLW9ubHk6IGNvbnN0IFJlY29pbHVzYWdlbG9nRXZlbnQgPSByZXF1aXJlKCdSZWNvaWx1c2FnZWxvZ0V2ZW50Jyk7XHJcbi8vIEBmYi1vbmx5OiBjb25zdCBSZWNvaWxVc2FnZUxvZ0ZhbGNvRXZlbnQgPSByZXF1aXJlKCdSZWNvaWxVc2FnZUxvZ0ZhbGNvRXZlbnQnKTtcclxuLy8gQGZiLW9ubHk6IGNvbnN0IFVSSSA9IHJlcXVpcmUoJ1VSSScpO1xyXG5cclxuXHJcbmNvbnN0IHtcclxuICBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbjogZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMyxcclxuICBtYWtlRW1wdHlTdG9yZVN0YXRlOiBtYWtlRW1wdHlTdG9yZVN0YXRlJDJcclxufSA9IFJlY29pbF9TdGF0ZTtcclxuXHJcbmNvbnN0IHtcclxuICBjbGVhblVwTm9kZTogY2xlYW5VcE5vZGUkMixcclxuICBnZXREb3duc3RyZWFtTm9kZXM6IGdldERvd25zdHJlYW1Ob2RlcyQyLFxyXG4gIGluaXRpYWxpemVOb2RlOiBpbml0aWFsaXplTm9kZSQyLFxyXG4gIHNldE5vZGVWYWx1ZTogc2V0Tm9kZVZhbHVlJDIsXHJcbiAgc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRDogc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCQxXHJcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XHJcblxyXG5jb25zdCB7XHJcbiAgZ3JhcGg6IGdyYXBoJDJcclxufSA9IFJlY29pbF9HcmFwaDtcclxuXHJcbmNvbnN0IHtcclxuICBjbG9uZUdyYXBoOiBjbG9uZUdyYXBoJDFcclxufSA9IFJlY29pbF9HcmFwaDtcclxuXHJcbmNvbnN0IHtcclxuICBnZXROZXh0U3RvcmVJRDogZ2V0TmV4dFN0b3JlSUQkMlxyXG59ID0gUmVjb2lsX0tleXM7XHJcblxyXG5jb25zdCB7XHJcbiAgY3JlYXRlTXV0YWJsZVNvdXJjZTogY3JlYXRlTXV0YWJsZVNvdXJjZSQxLFxyXG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDJcclxufSA9IFJlY29pbF9SZWFjdE1vZGU7XHJcblxyXG5jb25zdCB7XHJcbiAgYXBwbHlBdG9tVmFsdWVXcml0ZXM6IGFwcGx5QXRvbVZhbHVlV3JpdGVzJDFcclxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcclxuXHJcbmNvbnN0IHtcclxuICByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3c6IHJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdyQxXHJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xyXG5cclxuY29uc3Qge1xyXG4gIGZyZXNoU25hcHNob3Q6IGZyZXNoU25hcHNob3QkMVxyXG59ID0gUmVjb2lsX1NuYXBzaG90JDE7XHJcblxyXG5cclxuXHJcbmNvbnN0IHtcclxuICB1c2VDYWxsYmFjayxcclxuICB1c2VDb250ZXh0LFxyXG4gIHVzZUVmZmVjdCxcclxuICB1c2VNZW1vLFxyXG4gIHVzZVJlZjogdXNlUmVmJDEsXHJcbiAgdXNlU3RhdGVcclxufSA9IHJlYWN0O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBub3RJbkFDb250ZXh0KCkge1xyXG4gIHRocm93IFJlY29pbF9lcnIoJ1RoaXMgY29tcG9uZW50IG11c3QgYmUgdXNlZCBpbnNpZGUgYSA8UmVjb2lsUm9vdD4gY29tcG9uZW50LicpO1xyXG59XHJcblxyXG5jb25zdCBkZWZhdWx0U3RvcmUgPSBPYmplY3QuZnJlZXplKHtcclxuICBzdG9yZUlEOiBnZXROZXh0U3RvcmVJRCQyKCksXHJcbiAgZ2V0U3RhdGU6IG5vdEluQUNvbnRleHQsXHJcbiAgcmVwbGFjZVN0YXRlOiBub3RJbkFDb250ZXh0LFxyXG4gIGdldEdyYXBoOiBub3RJbkFDb250ZXh0LFxyXG4gIHN1YnNjcmliZVRvVHJhbnNhY3Rpb25zOiBub3RJbkFDb250ZXh0LFxyXG4gIGFkZFRyYW5zYWN0aW9uTWV0YWRhdGE6IG5vdEluQUNvbnRleHRcclxufSk7XHJcbmxldCBzdGF0ZVJlcGxhY2VySXNCZWluZ0V4ZWN1dGVkID0gZmFsc2U7XHJcblxyXG5mdW5jdGlvbiBzdGFydE5leHRUcmVlSWZOZWVkZWQoc3RvcmUpIHtcclxuICBpZiAoc3RhdGVSZXBsYWNlcklzQmVpbmdFeGVjdXRlZCkge1xyXG4gICAgdGhyb3cgUmVjb2lsX2VycignQW4gYXRvbSB1cGRhdGUgd2FzIHRyaWdnZXJlZCB3aXRoaW4gdGhlIGV4ZWN1dGlvbiBvZiBhIHN0YXRlIHVwZGF0ZXIgZnVuY3Rpb24uIFN0YXRlIHVwZGF0ZXIgZnVuY3Rpb25zIHByb3ZpZGVkIHRvIFJlY29pbCBtdXN0IGJlIHB1cmUgZnVuY3Rpb25zLicpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gIGlmIChzdG9yZVN0YXRlLm5leHRUcmVlID09PSBudWxsKSB7XHJcbiAgICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSAmJiBSZWNvaWxfZ2t4KCdyZWNvaWxfcmVsZWFzZV9vbl9jYXNjYWRpbmdfdXBkYXRlX2tpbGxzd2l0Y2hfMjAyMScpKSB7XHJcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjYXNjYWRpbmcgdXBkYXRlICh0aGF0IGlzLCByZW5kZXJpbmcgZHVlIHRvIG9uZSBzdGF0ZSBjaGFuZ2VcclxuICAgICAgLy8gaW52b2tlcyBhIHNlY29uZCBzdGF0ZSBjaGFuZ2UpLCB3ZSB3b24ndCBoYXZlIGNsZWFuZWQgdXAgcmV0YWluYWJsZXMgeWV0XHJcbiAgICAgIC8vIGJlY2F1c2UgdGhpcyBub3JtYWxseSBoYXBwZW5zIGFmdGVyIG5vdGlmeWluZyBjb21wb25lbnRzLiBEbyBpdCBiZWZvcmVcclxuICAgICAgLy8gcHJvY2VlZGluZyB3aXRoIHRoZSBjYXNjYWRpbmcgdXBkYXRlIHNvIHRoYXQgaXQgcmVtYWlucyBwcmVkaWN0YWJsZTpcclxuICAgICAgaWYgKHN0b3JlU3RhdGUuY29tbWl0RGVwdGggPiAwKSB7XHJcbiAgICAgICAgcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93JDEoc3RvcmUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdmVyc2lvbiA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWUudmVyc2lvbjtcclxuICAgIGNvbnN0IG5leHRWZXJzaW9uID0gZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMygpO1xyXG4gICAgc3RvcmVTdGF0ZS5uZXh0VHJlZSA9IHsgLi4uc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSxcclxuICAgICAgdmVyc2lvbjogbmV4dFZlcnNpb24sXHJcbiAgICAgIHN0YXRlSUQ6IG5leHRWZXJzaW9uLFxyXG4gICAgICBkaXJ0eUF0b21zOiBuZXcgU2V0KCksXHJcbiAgICAgIHRyYW5zYWN0aW9uTWV0YWRhdGE6IHt9XHJcbiAgICB9O1xyXG4gICAgc3RvcmVTdGF0ZS5ncmFwaHNCeVZlcnNpb24uc2V0KG5leHRWZXJzaW9uLCBjbG9uZUdyYXBoJDEoUmVjb2lsX251bGx0aHJvd3Moc3RvcmVTdGF0ZS5ncmFwaHNCeVZlcnNpb24uZ2V0KHZlcnNpb24pKSkpO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgQXBwQ29udGV4dCA9IHJlYWN0LmNyZWF0ZUNvbnRleHQoe1xyXG4gIGN1cnJlbnQ6IGRlZmF1bHRTdG9yZVxyXG59KTtcclxuXHJcbmNvbnN0IHVzZVN0b3JlUmVmID0gKCkgPT4gdXNlQ29udGV4dChBcHBDb250ZXh0KTsgLy8gJEZsb3dFeHBlY3RlZEVycm9yW2luY29tcGF0aWJsZS1jYWxsXVxyXG5cclxuXHJcbmNvbnN0IE11dGFibGVTb3VyY2VDb250ZXh0ID0gcmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbE11dGFibGVTb3VyY2UoKSB7XHJcbiAgY29uc3QgbXV0YWJsZVNvdXJjZSA9IHVzZUNvbnRleHQoTXV0YWJsZVNvdXJjZUNvbnRleHQpO1xyXG5cclxuICBpZiAobXV0YWJsZVNvdXJjZSA9PSBudWxsKSB7XHJcbiAgICBSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24oJ0F0dGVtcHRlZCB0byB1c2UgYSBSZWNvaWwgaG9vayBvdXRzaWRlIG9mIGEgPFJlY29pbFJvb3Q+LiAnICsgJzxSZWNvaWxSb290PiBtdXN0IGJlIGFuIGFuY2VzdG9yIG9mIGFueSBjb21wb25lbnQgdGhhdCB1c2VzICcgKyAnUmVjb2lsIGhvb2tzLicpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG11dGFibGVTb3VyY2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vdGlmeUNvbXBvbmVudHMoc3RvcmUsIHN0b3JlU3RhdGUsIHRyZWVTdGF0ZSkge1xyXG4gIGNvbnN0IGRlcGVuZGVudE5vZGVzID0gZ2V0RG93bnN0cmVhbU5vZGVzJDIoc3RvcmUsIHRyZWVTdGF0ZSwgdHJlZVN0YXRlLmRpcnR5QXRvbXMpO1xyXG5cclxuICBmb3IgKGNvbnN0IGtleSBvZiBkZXBlbmRlbnROb2Rlcykge1xyXG4gICAgY29uc3QgY29tcHMgPSBzdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZ2V0KGtleSk7XHJcblxyXG4gICAgaWYgKGNvbXBzKSB7XHJcbiAgICAgIGZvciAoY29uc3QgW19zdWJJRCwgW19kZWJ1Z05hbWUsIGNhbGxiYWNrXV0gb2YgY29tcHMpIHtcclxuICAgICAgICBjYWxsYmFjayh0cmVlU3RhdGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnMoc3RvcmUpIHtcclxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICBjb25zdCB0cmVlU3RhdGUgPSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlOyAvLyBJbmZvcm0gdHJhbnNhY3Rpb24gc3Vic2NyaWJlcnMgb2YgdGhlIHRyYW5zYWN0aW9uOlxyXG5cclxuICBjb25zdCBkaXJ0eUF0b21zID0gdHJlZVN0YXRlLmRpcnR5QXRvbXM7XHJcblxyXG4gIGlmIChkaXJ0eUF0b21zLnNpemUpIHtcclxuICAgIC8vIEV4ZWN1dGUgTm9kZS1zcGVjaWZpYyBzdWJzY3JpYmVycyBiZWZvcmUgZ2xvYmFsIHN1YnNjcmliZXJzXHJcbiAgICBmb3IgKGNvbnN0IFtrZXksIHN1YnNjcmlwdGlvbnNdIG9mIHN0b3JlU3RhdGUubm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucykge1xyXG4gICAgICBpZiAoZGlydHlBdG9tcy5oYXMoa2V5KSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgW18sIHN1YnNjcmlwdGlvbl0gb2Ygc3Vic2NyaXB0aW9ucykge1xyXG4gICAgICAgICAgc3Vic2NyaXB0aW9uKHN0b3JlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGNvbnN0IFtfLCBzdWJzY3JpcHRpb25dIG9mIHN0b3JlU3RhdGUudHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zKSB7XHJcbiAgICAgIHN1YnNjcmlwdGlvbihzdG9yZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFyZWFjdE1vZGUkMigpLmVhcmx5IHx8IHN0b3JlU3RhdGUuc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzLnNpemUgPiAwKSB7XHJcbiAgICAgIC8vIE5vdGlmeWluZyBjb21wb25lbnRzIGlzIG5lZWRlZCB0byB3YWtlIGZyb20gc3VzcGVuc2UsIGV2ZW4gd2hlbiB1c2luZ1xyXG4gICAgICAvLyBlYXJseSByZW5kZXJpbmcuXHJcbiAgICAgIG5vdGlmeUNvbXBvbmVudHMoc3RvcmUsIHN0b3JlU3RhdGUsIHRyZWVTdGF0ZSk7IC8vIFdha2UgYWxsIHN1c3BlbmRlZCBjb21wb25lbnRzIHNvIHRoZSByaWdodCBvbmUocykgY2FuIHRyeSB0byByZS1yZW5kZXIuXHJcbiAgICAgIC8vIFdlIG5lZWQgdG8gd2FrZSB1cCBjb21wb25lbnRzIG5vdCBqdXN0IHdoZW4gc29tZSBhc3luY2hyb25vdXMgc2VsZWN0b3JcclxuICAgICAgLy8gcmVzb2x2ZWQsIGJ1dCBhbHNvIHdoZW4gY2hhbmdpbmcgc3luY2hyb25vdXMgdmFsdWVzIGJlY2F1c2UgdGhpcyBtYXkgY2F1c2VcclxuICAgICAgLy8gYSBzZWxlY3RvciB0byBjaGFuZ2UgZnJvbSBhc3luY2hyb25vdXMgdG8gc3luY2hyb25vdXMsIGluIHdoaWNoIGNhc2UgdGhlcmVcclxuICAgICAgLy8gd291bGQgYmUgbm8gZm9sbG93LXVwIGFzeW5jaHJvbm91cyByZXNvbHV0aW9uIHRvIHdha2UgdXMgdXAuXHJcbiAgICAgIC8vIFRPRE8gT1BUSU1JWkFUSU9OIE9ubHkgd2FrZSB1cCByZWxhdGVkIGRvd25zdHJlYW0gY29tcG9uZW50c1xyXG5cclxuICAgICAgc3RvcmVTdGF0ZS5zdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMuZm9yRWFjaChjYiA9PiBjYigpKTtcclxuICAgICAgc3RvcmVTdGF0ZS5zdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMuY2xlYXIoKTtcclxuICAgIH1cclxuICB9IC8vIFNwZWNpYWwgYmVoYXZpb3IgT05MWSBpbnZva2VkIGJ5IHVzZUludGVyZmFjZS5cclxuICAvLyBGSVhNRSBkZWxldGUgcXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQgd2hlbiBkZWxldGluZyB1c2VJbnRlcmZhY2UuXHJcblxyXG5cclxuICBzdG9yZVN0YXRlLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELmZvckVhY2goY2IgPT4gY2IodHJlZVN0YXRlKSk7XHJcbiAgc3RvcmVTdGF0ZS5xdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRC5zcGxpY2UoMCwgc3RvcmVTdGF0ZS5xdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRC5sZW5ndGgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbmRCYXRjaChzdG9yZSkge1xyXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG4gIHN0b3JlU3RhdGUuY29tbWl0RGVwdGgrKztcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgbmV4dFRyZWVcclxuICAgIH0gPSBzdG9yZVN0YXRlOyAvLyBJZ25vcmUgY29tbWl0cyB0aGF0IGFyZSBub3QgYmVjYXVzZSBvZiBSZWNvaWwgdHJhbnNhY3Rpb25zIC0tIG5hbWVseSxcclxuICAgIC8vIGJlY2F1c2Ugc29tZXRoaW5nIGFib3ZlIFJlY29pbFJvb3QgcmUtcmVuZGVyZWQ6XHJcblxyXG4gICAgaWYgKG5leHRUcmVlID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSAvLyBuZXh0VHJlZSBpcyBub3cgY29tbWl0dGVkIC0tIG5vdGUgdGhhdCBjb3B5aW5nIGFuZCByZXNldCBvY2N1cnMgd2hlblxyXG4gICAgLy8gYSB0cmFuc2FjdGlvbiBiZWdpbnMsIGluIHN0YXJ0TmV4dFRyZWVJZk5lZWRlZDpcclxuXHJcblxyXG4gICAgc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUgPSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xyXG4gICAgc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA9IG5leHRUcmVlO1xyXG4gICAgc3RvcmVTdGF0ZS5uZXh0VHJlZSA9IG51bGw7XHJcbiAgICBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnMoc3RvcmUpO1xyXG5cclxuICAgIGlmIChzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSAhPSBudWxsKSB7XHJcbiAgICAgIHN0b3JlU3RhdGUuZ3JhcGhzQnlWZXJzaW9uLmRlbGV0ZShzdG9yZVN0YXRlLnByZXZpb3VzVHJlZS52ZXJzaW9uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignRW5kZWQgYmF0Y2ggd2l0aCBubyBwcmV2aW91cyBzdGF0ZSwgd2hpY2ggaXMgdW5leHBlY3RlZCcsICdyZWNvaWwnKTtcclxuICAgIH1cclxuXHJcbiAgICBzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSA9IG51bGw7XHJcblxyXG4gICAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcclxuICAgICAgLy8gT25seSByZWxlYXNlIHJldGFpbmFibGVzIGlmIHRoZXJlIHdlcmUgbm8gd3JpdGVzIGR1cmluZyB0aGUgZW5kIG9mIHRoZVxyXG4gICAgICAvLyBiYXRjaC4gIFRoaXMgYXZvaWRzIHJlbGVhc2luZyBzb21ldGhpbmcgd2UgbWlnaHQgYmUgYWJvdXQgdG8gdXNlLlxyXG4gICAgICBpZiAobmV4dFRyZWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdyQxKHN0b3JlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZmluYWxseSB7XHJcbiAgICBzdG9yZVN0YXRlLmNvbW1pdERlcHRoLS07XHJcbiAgfVxyXG59XHJcbi8qXHJcbiAqIFRoZSBwdXJwb3NlIG9mIHRoZSBCYXRjaGVyIGlzIHRvIG9ic2VydmUgd2hlbiBSZWFjdCBiYXRjaGVzIGVuZCBzbyB0aGF0XHJcbiAqIFJlY29pbCBzdGF0ZSBjaGFuZ2VzIGNhbiBiZSBiYXRjaGVkLiBXaGVuZXZlciBSZWNvaWwgc3RhdGUgY2hhbmdlcywgd2UgY2FsbFxyXG4gKiBzZXRTdGF0ZSBvbiB0aGUgYmF0Y2hlci4gVGhlbiB3ZSB3YWl0IGZvciB0aGF0IGNoYW5nZSB0byBiZSBjb21taXR0ZWQsIHdoaWNoXHJcbiAqIHNpZ25pZmllcyB0aGUgZW5kIG9mIHRoZSBiYXRjaC4gVGhhdCdzIHdoZW4gd2UgcmVzcG9uZCB0byB0aGUgUmVjb2lsIGNoYW5nZS5cclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gQmF0Y2hlcih7XHJcbiAgc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlXHJcbn0pIHtcclxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmKCk7XHJcbiAgY29uc3QgWywgc2V0U3RhdGVdID0gdXNlU3RhdGUoW10pO1xyXG4gIHNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZSgoKSA9PiBzZXRTdGF0ZSh7fSkpO1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2UoKCkgPT4gc2V0U3RhdGUoe30pKTsgLy8gSWYgYW4gYXN5bmNocm9ub3VzIHNlbGVjdG9yIHJlc29sdmVzIGFmdGVyIHRoZSBCYXRjaGVyIGlzIHVubW91bnRlZCxcclxuICAgIC8vIG5vdGlmeUJhdGNoZXJPZkNoYW5nZSB3aWxsIHN0aWxsIGJlIGNhbGxlZC4gQW4gZXJyb3IgZ2V0cyB0aHJvd24gd2hlbmV2ZXJcclxuICAgIC8vIHNldFN0YXRlIGlzIGNhbGxlZCBhZnRlciBhIGNvbXBvbmVudCBpcyBhbHJlYWR5IHVubW91bnRlZCwgc28gdGhpcyBzZXRzXHJcbiAgICAvLyBub3RpZnlCYXRjaGVyT2ZDaGFuZ2UgdG8gYmUgYSBuby1vcC5cclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2UoKCkgPT4ge30pO1xyXG4gICAgfTtcclxuICB9LCBbc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlXSk7XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIC8vIGVucXVldWVFeGVjdXRpb24gcnVucyB0aGlzIGZ1bmN0aW9uIGltbWVkaWF0ZWx5OyBpdCBpcyBvbmx5IHVzZWQgdG9cclxuICAgIC8vIG1hbmlwdWxhdGUgdGhlIG9yZGVyIG9mIHVzZUVmZmVjdHMgZHVyaW5nIHRlc3RzLCBzaW5jZSBSZWFjdCBzZWVtcyB0b1xyXG4gICAgLy8gY2FsbCB1c2VFZmZlY3QgaW4gYW4gdW5wcmVkaWN0YWJsZSBvcmRlciBzb21ldGltZXMuXHJcbiAgICBSZWNvaWxfUXVldWUuZW5xdWV1ZUV4ZWN1dGlvbignQmF0Y2hlcicsICgpID0+IHtcclxuICAgICAgZW5kQmF0Y2goc3RvcmVSZWYuY3VycmVudCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LiRyZWNvaWxEZWJ1Z1N0YXRlcykge1xyXG4gICAgd2luZG93LiRyZWNvaWxEZWJ1Z1N0YXRlcyA9IFtdO1xyXG4gIH1cclxufSAvLyBXaGVuIHJlbW92aW5nIHRoaXMgZGVwcmVjYXRlZCBmdW5jdGlvbiwgcmVtb3ZlIHN0YXRlQnlTZXR0aW5nUmVjb2lsVmFsdWVcclxuLy8gd2hpY2ggd2lsbCBubyBsb25nZXIgYmUgbmVlZGVkLlxyXG5cclxuXHJcbmZ1bmN0aW9uIGluaXRpYWxTdG9yZVN0YXRlX0RFUFJFQ0FURUQoc3RvcmUsIGluaXRpYWxpemVTdGF0ZSkge1xyXG4gIGNvbnN0IGluaXRpYWwgPSBtYWtlRW1wdHlTdG9yZVN0YXRlJDIoKTtcclxuICBpbml0aWFsaXplU3RhdGUoe1xyXG4gICAgc2V0OiAoYXRvbSwgdmFsdWUpID0+IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSBpbml0aWFsLmN1cnJlbnRUcmVlO1xyXG4gICAgICBjb25zdCB3cml0ZXMgPSBzZXROb2RlVmFsdWUkMihzdG9yZSwgc3RhdGUsIGF0b20ua2V5LCB2YWx1ZSk7XHJcbiAgICAgIGNvbnN0IHdyaXR0ZW5Ob2RlcyA9IG5ldyBTZXQod3JpdGVzLmtleXMoKSk7XHJcbiAgICAgIGNvbnN0IG5vbnZhbGlkYXRlZEF0b21zID0gc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuY2xvbmUoKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgbiBvZiB3cml0dGVuTm9kZXMpIHtcclxuICAgICAgICBub252YWxpZGF0ZWRBdG9tcy5kZWxldGUobik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGluaXRpYWwuY3VycmVudFRyZWUgPSB7IC4uLnN0YXRlLFxyXG4gICAgICAgIGRpcnR5QXRvbXM6IFJlY29pbF91bmlvblNldHMoc3RhdGUuZGlydHlBdG9tcywgd3JpdHRlbk5vZGVzKSxcclxuICAgICAgICBhdG9tVmFsdWVzOiBhcHBseUF0b21WYWx1ZVdyaXRlcyQxKHN0YXRlLmF0b21WYWx1ZXMsIHdyaXRlcyksXHJcbiAgICAgICAgLy8gTkI6IFBMRUFTRSB1bi1leHBvcnQgYXBwbHlBdG9tVmFsdWVXcml0ZXMgd2hlbiBkZWxldGluZyB0aGlzIGNvZGVcclxuICAgICAgICBub252YWxpZGF0ZWRBdG9tc1xyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgIHNldFVudmFsaWRhdGVkQXRvbVZhbHVlczogYXRvbVZhbHVlcyA9PiB7XHJcbiAgICAgIC8vIEZJWE1FIHJlcGxhY2UgdGhpcyB3aXRoIGEgbXV0YXRpdmUgbG9vcFxyXG4gICAgICBhdG9tVmFsdWVzLmZvckVhY2goKHYsIGspID0+IHtcclxuICAgICAgICBpbml0aWFsLmN1cnJlbnRUcmVlID0gc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCQxKGluaXRpYWwuY3VycmVudFRyZWUsIGssIHYpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gaW5pdGlhbDtcclxufSAvLyBJbml0aWFsaXplIHN0YXRlIHNuYXBzaG90IGZvciA8UmVjb2lsUm9vdD4gZm9yIHRoZSBpbml0aWFsaXplU3RhdGUgcHJvcC5cclxuLy8gQXRvbSBlZmZlY3QgaW5pdGlhbGl6YXRpb24gdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgcHJvcC5cclxuLy8gQW55IGF0b20gZWZmZWN0cyB3aWxsIGJlIHJ1biBiZWZvcmUgaW5pdGlhbGl6YXRpb24sIGJ1dCB0aGVuIGNsZWFuZWQgdXAsXHJcbi8vIHRoZXkgYXJlIHRoZW4gcmUtcnVuIHdoZW4gdXNlZCBhcyBwYXJ0IG9mIHJlbmRlcmluZy4gIFRoZXNlIHNlbWFudGljcyBhcmVcclxuLy8gY29tcGF0aWJsZSB3aXRoIFJlYWN0IFN0cmljdE1vZGUgd2hlcmUgZWZmZWN0cyBtYXkgYmUgcmUtcnVuIG11bHRpcGxlIHRpbWVzXHJcbi8vIGJ1dCBzdGF0ZSBpbml0aWFsaXphdGlvbiBvbmx5IGhhcHBlbnMgb25jZSB0aGUgZmlyc3QgdGltZS5cclxuXHJcblxyXG5mdW5jdGlvbiBpbml0aWFsU3RvcmVTdGF0ZShpbml0aWFsaXplU3RhdGUpIHtcclxuICAvLyBJbml0aWFsaXplIGEgc25hcHNob3QgYW5kIGdldCBpdHMgc3RvcmVcclxuICBjb25zdCBzbmFwc2hvdCA9IGZyZXNoU25hcHNob3QkMShpbml0aWFsaXplU3RhdGUpO1xyXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzbmFwc2hvdC5nZXRTdG9yZV9JTlRFUk5BTCgpLmdldFN0YXRlKCk7IC8vIENvdW50ZXJhY3QgdGhlIHNuYXBzaG90IGF1dG8tcmVsZWFzZVxyXG5cclxuICBzbmFwc2hvdC5yZXRhaW4oKTsgLy8gQ2xlYW51cCBhbnkgZWZmZWN0cyBydW4gZHVyaW5nIGluaXRpYWxpemF0aW9uIGFuZCBjbGVhciB0aGUgaGFuZGxlcnMgc29cclxuICAvLyB0aGV5IHdpbGwgcmUtaW5pdGlhbGl6ZSBpZiB1c2VkIGR1cmluZyByZW5kZXJpbmcuICBUaGlzIGFsbG93cyBhdG9tIGVmZmVjdFxyXG4gIC8vIGluaXRpYWxpemF0aW9uIHRvIHRha2UgcHJlY2VkZW5jZSBvdmVyIGluaXRpYWxpemVTdGF0ZSBhbmQgYmUgY29tcGF0aWJsZVxyXG4gIC8vIHdpdGggU3RyaWN0TW9kZSBzZW1hbnRpY3MuXHJcblxyXG4gIHN0b3JlU3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuZm9yRWFjaChjbGVhbnVwID0+IGNsZWFudXAoKSk7XHJcbiAgc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5jbGVhcigpO1xyXG4gIHJldHVybiBzdG9yZVN0YXRlO1xyXG59XHJcblxyXG5sZXQgbmV4dElEID0gMDtcclxuXHJcbmZ1bmN0aW9uIFJlY29pbFJvb3RfSU5URVJOQUwoe1xyXG4gIGluaXRpYWxpemVTdGF0ZV9ERVBSRUNBVEVELFxyXG4gIGluaXRpYWxpemVTdGF0ZSxcclxuICBzdG9yZV9JTlRFUk5BTDogc3RvcmVQcm9wLFxyXG4gIC8vIEZvciB1c2Ugd2l0aCBSZWFjdCBcImNvbnRleHQgYnJpZGdpbmdcIlxyXG4gIGNoaWxkcmVuXHJcbn0pIHtcclxuICAvLyBwcmV0dGllci1pZ25vcmVcclxuICAvLyBAZmItb25seTogdXNlRWZmZWN0KCgpID0+IHtcclxuICAvLyBAZmItb25seTogaWYgKGdreCgncmVjb2lsX3VzYWdlX2xvZ2dpbmcnKSkge1xyXG4gIC8vIEBmYi1vbmx5OiB0cnkge1xyXG4gIC8vIEBmYi1vbmx5OiBSZWNvaWxVc2FnZUxvZ0ZhbGNvRXZlbnQubG9nKCgpID0+ICh7XHJcbiAgLy8gQGZiLW9ubHk6IHR5cGU6IFJlY29pbHVzYWdlbG9nRXZlbnQuUkVDT0lMX1JPT1RfTU9VTlRFRCxcclxuICAvLyBAZmItb25seTogcGF0aDogVVJJLmdldFJlcXVlc3RVUkkoKS5nZXRQYXRoKCksXHJcbiAgLy8gQGZiLW9ubHk6IH0pKTtcclxuICAvLyBAZmItb25seTogfSBjYXRjaCB7XHJcbiAgLy8gQGZiLW9ubHk6IHJlY292ZXJhYmxlVmlvbGF0aW9uKFxyXG4gIC8vIEBmYi1vbmx5OiAnRXJyb3Igd2hlbiBsb2dnaW5nIFJlY29pbCBVc2FnZSBldmVudCcsXHJcbiAgLy8gQGZiLW9ubHk6ICdyZWNvaWwnLFxyXG4gIC8vIEBmYi1vbmx5OiApO1xyXG4gIC8vIEBmYi1vbmx5OiB9XHJcbiAgLy8gQGZiLW9ubHk6IH1cclxuICAvLyBAZmItb25seTogfSwgW10pO1xyXG4gIGxldCBzdG9yZVN0YXRlUmVmOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1jb25zdFxyXG5cclxuICBjb25zdCBnZXRHcmFwaCA9IHZlcnNpb24gPT4ge1xyXG4gICAgY29uc3QgZ3JhcGhzID0gc3RvcmVTdGF0ZVJlZi5jdXJyZW50LmdyYXBoc0J5VmVyc2lvbjtcclxuXHJcbiAgICBpZiAoZ3JhcGhzLmhhcyh2ZXJzaW9uKSkge1xyXG4gICAgICByZXR1cm4gUmVjb2lsX251bGx0aHJvd3MoZ3JhcGhzLmdldCh2ZXJzaW9uKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbmV3R3JhcGggPSBncmFwaCQyKCk7XHJcbiAgICBncmFwaHMuc2V0KHZlcnNpb24sIG5ld0dyYXBoKTtcclxuICAgIHJldHVybiBuZXdHcmFwaDtcclxuICB9O1xyXG5cclxuICBjb25zdCBzdWJzY3JpYmVUb1RyYW5zYWN0aW9ucyA9IChjYWxsYmFjaywga2V5KSA9PiB7XHJcbiAgICBpZiAoa2V5ID09IG51bGwpIHtcclxuICAgICAgLy8gR2xvYmFsIHRyYW5zYWN0aW9uIHN1YnNjcmlwdGlvbnNcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uc1xyXG4gICAgICB9ID0gc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpO1xyXG4gICAgICBjb25zdCBpZCA9IG5leHRJRCsrO1xyXG4gICAgICB0cmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuc2V0KGlkLCBjYWxsYmFjayk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVsZWFzZTogKCkgPT4ge1xyXG4gICAgICAgICAgdHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gTm9kZS1zcGVjaWZpYyB0cmFuc2FjdGlvbiBzdWJzY3JpcHRpb25zOlxyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uc1xyXG4gICAgICB9ID0gc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgaWYgKCFub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5zZXQoa2V5LCBuZXcgTWFwKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBpZCA9IG5leHRJRCsrO1xyXG4gICAgICBSZWNvaWxfbnVsbHRocm93cyhub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLmdldChrZXkpKS5zZXQoaWQsIGNhbGxiYWNrKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICByZWxlYXNlOiAoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBzdWJzID0gbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5nZXQoa2V5KTtcclxuXHJcbiAgICAgICAgICBpZiAoc3Vicykge1xyXG4gICAgICAgICAgICBzdWJzLmRlbGV0ZShpZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3Vicy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBhZGRUcmFuc2FjdGlvbk1ldGFkYXRhID0gbWV0YWRhdGEgPT4ge1xyXG4gICAgc3RhcnROZXh0VHJlZUlmTmVlZGVkKHN0b3JlUmVmLmN1cnJlbnQpO1xyXG5cclxuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhtZXRhZGF0YSkpIHtcclxuICAgICAgUmVjb2lsX251bGx0aHJvd3Moc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpLm5leHRUcmVlKS50cmFuc2FjdGlvbk1ldGFkYXRhW2tdID0gbWV0YWRhdGFba107XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgcmVwbGFjZVN0YXRlID0gcmVwbGFjZXIgPT4ge1xyXG4gICAgc3RhcnROZXh0VHJlZUlmTmVlZGVkKHN0b3JlUmVmLmN1cnJlbnQpOyAvLyBVc2UgcmVwbGFjZXIgdG8gZ2V0IHRoZSBuZXh0IHN0YXRlOlxyXG5cclxuICAgIGNvbnN0IG5leHRUcmVlID0gUmVjb2lsX251bGx0aHJvd3Moc3RvcmVTdGF0ZVJlZi5jdXJyZW50Lm5leHRUcmVlKTtcclxuICAgIGxldCByZXBsYWNlZDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBzdGF0ZVJlcGxhY2VySXNCZWluZ0V4ZWN1dGVkID0gdHJ1ZTtcclxuICAgICAgcmVwbGFjZWQgPSByZXBsYWNlcihuZXh0VHJlZSk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzdGF0ZVJlcGxhY2VySXNCZWluZ0V4ZWN1dGVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlcGxhY2VkID09PSBuZXh0VHJlZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB3aW5kb3cuJHJlY29pbERlYnVnU3RhdGVzLnB1c2gocmVwbGFjZWQpOyAvLyBUT0RPIHRoaXMgc2hvdWxkbid0IGhhcHBlbiBoZXJlIGJlY2F1c2UgaXQncyBub3QgYmF0Y2hlZFxyXG4gICAgICB9XHJcbiAgICB9IC8vIFNhdmUgY2hhbmdlcyB0byBuZXh0VHJlZSBhbmQgc2NoZWR1bGUgYSBSZWFjdCB1cGRhdGU6XHJcblxyXG5cclxuICAgIHN0b3JlU3RhdGVSZWYuY3VycmVudC5uZXh0VHJlZSA9IHJlcGxhY2VkO1xyXG5cclxuICAgIGlmIChyZWFjdE1vZGUkMigpLmVhcmx5KSB7XHJcbiAgICAgIG5vdGlmeUNvbXBvbmVudHMoc3RvcmVSZWYuY3VycmVudCwgc3RvcmVTdGF0ZVJlZi5jdXJyZW50LCByZXBsYWNlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgUmVjb2lsX251bGx0aHJvd3Mobm90aWZ5QmF0Y2hlck9mQ2hhbmdlLmN1cnJlbnQpKCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgbm90aWZ5QmF0Y2hlck9mQ2hhbmdlID0gdXNlUmVmJDEobnVsbCk7XHJcbiAgY29uc3Qgc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlID0gdXNlQ2FsbGJhY2soeCA9PiB7XHJcbiAgICBub3RpZnlCYXRjaGVyT2ZDaGFuZ2UuY3VycmVudCA9IHg7XHJcbiAgfSwgW25vdGlmeUJhdGNoZXJPZkNoYW5nZV0pO1xyXG4gIGNvbnN0IHN0b3JlUmVmID0gUmVjb2lsX3VzZVJlZkluaXRPbmNlKCgpID0+IHN0b3JlUHJvcCAhPT0gbnVsbCAmJiBzdG9yZVByb3AgIT09IHZvaWQgMCA/IHN0b3JlUHJvcCA6IHtcclxuICAgIHN0b3JlSUQ6IGdldE5leHRTdG9yZUlEJDIoKSxcclxuICAgIGdldFN0YXRlOiAoKSA9PiBzdG9yZVN0YXRlUmVmLmN1cnJlbnQsXHJcbiAgICByZXBsYWNlU3RhdGUsXHJcbiAgICBnZXRHcmFwaCxcclxuICAgIHN1YnNjcmliZVRvVHJhbnNhY3Rpb25zLFxyXG4gICAgYWRkVHJhbnNhY3Rpb25NZXRhZGF0YVxyXG4gIH0pO1xyXG5cclxuICBpZiAoc3RvcmVQcm9wICE9IG51bGwpIHtcclxuICAgIHN0b3JlUmVmLmN1cnJlbnQgPSBzdG9yZVByb3A7XHJcbiAgfVxyXG5cclxuICBzdG9yZVN0YXRlUmVmID0gUmVjb2lsX3VzZVJlZkluaXRPbmNlKCgpID0+IGluaXRpYWxpemVTdGF0ZV9ERVBSRUNBVEVEICE9IG51bGwgPyBpbml0aWFsU3RvcmVTdGF0ZV9ERVBSRUNBVEVEKHN0b3JlUmVmLmN1cnJlbnQsIGluaXRpYWxpemVTdGF0ZV9ERVBSRUNBVEVEKSA6IGluaXRpYWxpemVTdGF0ZSAhPSBudWxsID8gaW5pdGlhbFN0b3JlU3RhdGUoaW5pdGlhbGl6ZVN0YXRlKSA6IG1ha2VFbXB0eVN0b3JlU3RhdGUkMigpKTtcclxuICBjb25zdCBtdXRhYmxlU291cmNlID0gdXNlTWVtbygoKSA9PiBjcmVhdGVNdXRhYmxlU291cmNlJDEgPT09IG51bGwgfHwgY3JlYXRlTXV0YWJsZVNvdXJjZSQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjcmVhdGVNdXRhYmxlU291cmNlJDEoc3RvcmVTdGF0ZVJlZiwgKCkgPT4gc3RvcmVTdGF0ZVJlZi5jdXJyZW50LmN1cnJlbnRUcmVlLnZlcnNpb24pLCBbc3RvcmVTdGF0ZVJlZl0pOyAvLyBDbGVhbnVwIHdoZW4gdGhlIDxSZWNvaWxSb290PiBpcyB1bm1vdW50ZWRcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIC8vIFJlYWN0IGlzIGZyZWUgdG8gY2FsbCBlZmZlY3QgY2xlYW51cCBoYW5kbGVycyBhbmQgZWZmZWN0cyBhdCB3aWxsLCB0aGVcclxuICAgIC8vIGRlcHMgYXJyYXkgaXMgb25seSBhbiBvcHRpbWl6YXRpb24uICBGb3IgZXhhbXBsZSwgUmVhY3Qgc3RyaWN0IG1vZGVcclxuICAgIC8vIHdpbGwgZXhlY3V0ZSBlYWNoIGVmZmVjdCB0d2ljZSBmb3IgdGVzdGluZy4gIFRoZXJlZm9yZSwgd2UgbmVlZCBzeW1tZXRyeVxyXG4gICAgLy8gdG8gcmUtaW5pdGlhbGl6ZSBhbGwga25vd24gYXRvbXMgYWZ0ZXIgdGhleSB3ZXJlIGNsZWFuZWQgdXAuXHJcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XHJcblxyXG4gICAgZm9yIChjb25zdCBhdG9tS2V5IG9mIG5ldyBTZXQoc3RvcmUuZ2V0U3RhdGUoKS5rbm93bkF0b21zKSkge1xyXG4gICAgICBpbml0aWFsaXplTm9kZSQyKHN0b3JlLCBhdG9tS2V5LCAnZ2V0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgZm9yIChjb25zdCBhdG9tS2V5IG9mIHN0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcykge1xyXG4gICAgICAgIGNsZWFuVXBOb2RlJDIoc3RvcmUsIGF0b21LZXkpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFtzdG9yZVJlZl0pO1xyXG4gIHJldHVybiAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChBcHBDb250ZXh0LlByb3ZpZGVyLCB7XHJcbiAgICB2YWx1ZTogc3RvcmVSZWZcclxuICB9LCAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChNdXRhYmxlU291cmNlQ29udGV4dC5Qcm92aWRlciwge1xyXG4gICAgdmFsdWU6IG11dGFibGVTb3VyY2VcclxuICB9LCAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChCYXRjaGVyLCB7XHJcbiAgICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2U6IHNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZVxyXG4gIH0pLCBjaGlsZHJlbikpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBSZWNvaWxSb290KHByb3BzKSB7XHJcbiAgY29uc3Qge1xyXG4gICAgb3ZlcnJpZGUsXHJcbiAgICAuLi5wcm9wc0V4Y2VwdE92ZXJyaWRlXHJcbiAgfSA9IHByb3BzO1xyXG4gIGNvbnN0IGFuY2VzdG9yU3RvcmVSZWYgPSB1c2VTdG9yZVJlZigpO1xyXG5cclxuICBpZiAob3ZlcnJpZGUgPT09IGZhbHNlICYmIGFuY2VzdG9yU3RvcmVSZWYuY3VycmVudCAhPT0gZGVmYXVsdFN0b3JlKSB7XHJcbiAgICAvLyBJZiBhbmNlc3RvclN0b3JlUmVmLmN1cnJlbnQgIT09IGRlZmF1bHRTdG9yZSwgaXQgbWVhbnMgdGhhdCB0aGlzXHJcbiAgICAvLyBSZWNvaWxSb290IGlzIG5vdCBuZXN0ZWQgd2l0aGluIGFub3RoZXIuXHJcbiAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XHJcbiAgfVxyXG5cclxuICByZXR1cm4gLyojX19QVVJFX18qL3JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVjb2lsUm9vdF9JTlRFUk5BTCwgcHJvcHNFeGNlcHRPdmVycmlkZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbFN0b3JlSUQoKSB7XHJcbiAgcmV0dXJuIHVzZVN0b3JlUmVmKCkuY3VycmVudC5zdG9yZUlEO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX1JlY29pbFJvb3QgPSB7XHJcbiAgUmVjb2lsUm9vdCxcclxuICB1c2VTdG9yZVJlZixcclxuICB1c2VSZWNvaWxNdXRhYmxlU291cmNlLFxyXG4gIHVzZVJlY29pbFN0b3JlSUQsXHJcbiAgbm90aWZ5Q29tcG9uZW50c19GT1JfVEVTVElORzogbm90aWZ5Q29tcG9uZW50cyxcclxuICBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnNfRk9SX1RFU1RJTkc6IHNlbmRFbmRPZkJhdGNoTm90aWZpY2F0aW9uc1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHNoYWxsb3dBcnJheUVxdWFsKGEsIGIpIHtcclxuICBpZiAoYSA9PT0gYikge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmb3IgKGxldCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxudmFyIFJlY29pbF9zaGFsbG93QXJyYXlFcXVhbCA9IHNoYWxsb3dBcnJheUVxdWFsO1xyXG5cclxuY29uc3Qge1xyXG4gIHVzZUVmZmVjdDogdXNlRWZmZWN0JDEsXHJcbiAgdXNlUmVmOiB1c2VSZWYkMlxyXG59ID0gcmVhY3Q7XHJcblxyXG5mdW5jdGlvbiB1c2VQcmV2aW91cyh2YWx1ZSkge1xyXG4gIGNvbnN0IHJlZiA9IHVzZVJlZiQyKCk7XHJcbiAgdXNlRWZmZWN0JDEoKCkgPT4ge1xyXG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcclxuICB9KTtcclxuICByZXR1cm4gcmVmLmN1cnJlbnQ7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfdXNlUHJldmlvdXMgPSB1c2VQcmV2aW91cztcclxuXHJcbmNvbnN0IHtcclxuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkMVxyXG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XHJcblxyXG5jb25zdCB7XHJcbiAgU1VTUEVOU0VfVElNRU9VVF9NUzogU1VTUEVOU0VfVElNRU9VVF9NUyQxXHJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xyXG5cclxuY29uc3Qge1xyXG4gIHVwZGF0ZVJldGFpbkNvdW50OiB1cGRhdGVSZXRhaW5Db3VudCQyXHJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xyXG5cclxuY29uc3Qge1xyXG4gIFJldGVudGlvblpvbmU6IFJldGVudGlvblpvbmUkM1xyXG59ID0gUmVjb2lsX1JldGVudGlvblpvbmU7XHJcblxyXG5jb25zdCB7XHJcbiAgdXNlRWZmZWN0OiB1c2VFZmZlY3QkMixcclxuICB1c2VSZWY6IHVzZVJlZiQzXHJcbn0gPSByZWFjdDtcclxuXHJcbmNvbnN0IHtcclxuICBpc1NTUjogaXNTU1IkMlxyXG59ID0gUmVjb2lsX0Vudmlyb25tZW50O1xyXG5cclxuXHJcblxyXG5cclxuXHJcbiAvLyBJIGRvbid0IHNlZSBhIHdheSB0byBhdm9pZCB0aGUgYW55IHR5cGUgaGVyZSBiZWNhdXNlIHdlIHdhbnQgdG8gYWNjZXB0IHJlYWRhYmxlXHJcbi8vIGFuZCB3cml0YWJsZSB2YWx1ZXMgd2l0aCBhbnkgdHlwZSBwYXJhbWV0ZXIsIGJ1dCBub3JtYWxseSB3aXRoIHdyaXRhYmxlIG9uZXNcclxuLy8gUmVjb2lsU3RhdGU8U29tZVQ+IGlzIG5vdCBhIHN1YnR5cGUgb2YgUmVjb2lsU3RhdGU8bWl4ZWQ+LlxyXG5cclxuXHJcbi8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxyXG5mdW5jdGlvbiB1c2VSZXRhaW4odG9SZXRhaW4pIHtcclxuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcclxuICAgIHJldHVybjtcclxuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvcmVhY3QtaG9va3NcclxuXHJcblxyXG4gIHJldHVybiB1c2VSZXRhaW5fQUNUVUFMKHRvUmV0YWluKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXNlUmV0YWluX0FDVFVBTCh0b1JldGFpbikge1xyXG4gIGNvbnN0IGFycmF5ID0gQXJyYXkuaXNBcnJheSh0b1JldGFpbikgPyB0b1JldGFpbiA6IFt0b1JldGFpbl07XHJcbiAgY29uc3QgcmV0YWluYWJsZXMgPSBhcnJheS5tYXAoYSA9PiBhIGluc3RhbmNlb2YgUmV0ZW50aW9uWm9uZSQzID8gYSA6IGEua2V5KTtcclxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDEoKTtcclxuICB1c2VFZmZlY3QkMigoKSA9PiB7XHJcbiAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcclxuXHJcbiAgICBpZiAodGltZW91dElELmN1cnJlbnQgJiYgIWlzU1NSJDIpIHtcclxuICAgICAgLy8gQWxyZWFkeSBwZXJmb3JtZWQgYSB0ZW1wb3JhcnkgcmV0YWluIG9uIHJlbmRlciwgc2ltcGx5IGNhbmNlbCB0aGUgcmVsZWFzZVxyXG4gICAgICAvLyBvZiB0aGF0IHRlbXBvcmFyeSByZXRhaW4uXHJcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElELmN1cnJlbnQpO1xyXG4gICAgICB0aW1lb3V0SUQuY3VycmVudCA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcclxuICAgICAgICB1cGRhdGVSZXRhaW5Db3VudCQyKHN0b3JlLCByLCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGZvciAoY29uc3QgciBvZiByZXRhaW5hYmxlcykge1xyXG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIC0xKTtcclxuICAgICAgfVxyXG4gICAgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9yZWFjdC1ob29rcy1kZXBzXHJcbiAgfSwgW3N0b3JlUmVmLCAuLi5yZXRhaW5hYmxlc10pOyAvLyBXZSB3YW50IHRvIHJldGFpbiBpZiB0aGUgY29tcG9uZW50IHN1c3BlbmRzLiBUaGlzIGlzIHRlcnJpYmxlIGJ1dCB0aGUgU3VzcGVuc2VcclxuICAvLyBBUEkgYWZmb3JkcyB1cyBubyBiZXR0ZXIgb3B0aW9uLiBJZiB3ZSBzdXNwZW5kIGFuZCBuZXZlciBjb21taXQgYWZ0ZXIgc29tZVxyXG4gIC8vIHNlY29uZHMsIHRoZW4gcmVsZWFzZS4gVGhlICdhY3R1YWwnIHJldGFpbi9yZWxlYXNlIGluIHRoZSBlZmZlY3QgYWJvdmVcclxuICAvLyBjYW5jZWxzIHRoaXMuXHJcblxyXG4gIGNvbnN0IHRpbWVvdXRJRCA9IHVzZVJlZiQzKCk7XHJcbiAgY29uc3QgcHJldmlvdXNSZXRhaW5hYmxlcyA9IFJlY29pbF91c2VQcmV2aW91cyhyZXRhaW5hYmxlcyk7XHJcblxyXG4gIGlmICghaXNTU1IkMiAmJiAocHJldmlvdXNSZXRhaW5hYmxlcyA9PT0gdW5kZWZpbmVkIHx8ICFSZWNvaWxfc2hhbGxvd0FycmF5RXF1YWwocHJldmlvdXNSZXRhaW5hYmxlcywgcmV0YWluYWJsZXMpKSkge1xyXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xyXG5cclxuICAgIGZvciAoY29uc3QgciBvZiByZXRhaW5hYmxlcykge1xyXG4gICAgICB1cGRhdGVSZXRhaW5Db3VudCQyKHN0b3JlLCByLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocHJldmlvdXNSZXRhaW5hYmxlcykge1xyXG4gICAgICBmb3IgKGNvbnN0IHIgb2YgcHJldmlvdXNSZXRhaW5hYmxlcykge1xyXG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIC0xKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aW1lb3V0SUQuY3VycmVudCkge1xyXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcclxuICAgIH1cclxuXHJcbiAgICB0aW1lb3V0SUQuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGltZW91dElELmN1cnJlbnQgPSBudWxsO1xyXG5cclxuICAgICAgZm9yIChjb25zdCByIG9mIHJldGFpbmFibGVzKSB7XHJcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMihzdG9yZSwgciwgLTEpO1xyXG4gICAgICB9XHJcbiAgICB9LCBTVVNQRU5TRV9USU1FT1VUX01TJDEpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIFJlY29pbF91c2VSZXRhaW4gPSB1c2VSZXRhaW47XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG4vKipcclxuICogVEhJUyBDT0RFIEhBUyBCRUVOIENPTU1FTlRFRCBPVVQgSU5URU5USU9OQUxMWVxyXG4gKlxyXG4gKiBUaGlzIHRlY2huaXF1ZSBvZiBnZXR0aW5nIHRoZSBjb21wb25lbnQgbmFtZSBpcyBpbXBlcmZlY3QsIHNpbmNlIGl0IGJvdGggb25seVxyXG4gKiB3b3JrcyBpbiBhIG5vbi1taW5pZmllZCBjb2RlIGJhc2UsIGFuZCBtb3JlIGltcG9ydGFudGx5IGludHJvZHVjZXMgcGVyZm9ybWFuY2VcclxuICogcHJvYmxlbXMgc2luY2UgaXQgcmVsaWVzIGluIHRocm93aW5nIGVycm9ycyB3aGljaCBpcyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBBdCBzb21lIHBvaW50IHdlIG1heSB3YW50IHRvIHJlZXZhbHVhdGUgdGhpcyB0ZWNobmlxdWUgaGVuY2Ugd2h5IHdlIGhhdmUgY29tbWVudGVkXHJcbiAqIHRoaXMgY29kZSBvdXQsIHJhdGhlciB0aGFuIGRlbGV0ZSBpdCBhbGwgdG9nZXRoZXIuXHJcbiAqL1xyXG4vLyBjb25zdCB7dXNlUmVmfSA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcbi8vIGNvbnN0IGdreCA9IHJlcXVpcmUoJ3JlY29pbC1zaGFyZWQvdXRpbC9SZWNvaWxfZ2t4Jyk7XHJcbi8vIGNvbnN0IHN0YWNrVHJhY2VQYXJzZXIgPSByZXF1aXJlKCdyZWNvaWwtc2hhcmVkL3V0aWwvUmVjb2lsX3N0YWNrVHJhY2VQYXJzZXInKTtcclxuXHJcbmZ1bmN0aW9uIHVzZUNvbXBvbmVudE5hbWUoKSB7XHJcbiAgLy8gY29uc3QgbmFtZVJlZiA9IHVzZVJlZigpO1xyXG4gIC8vIGlmIChfX0RFVl9fKSB7XHJcbiAgLy8gICBpZiAoZ2t4KCdyZWNvaWxfaW5mZXJfY29tcG9uZW50X25hbWVzJykpIHtcclxuICAvLyAgICAgaWYgKG5hbWVSZWYuY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgLy8gICAgICAgLy8gVGhlcmUgaXMgbm8gYmxlc3NlZCB3YXkgdG8gZGV0ZXJtaW5lIHRoZSBjYWxsaW5nIFJlYWN0IGNvbXBvbmVudCBmcm9tXHJcbiAgLy8gICAgICAgLy8gd2l0aGluIGEgaG9vay4gVGhpcyBoYWNrIHVzZXMgdGhlIGZhY3QgdGhhdCBob29rcyBtdXN0IHN0YXJ0IHdpdGggJ3VzZSdcclxuICAvLyAgICAgICAvLyBhbmQgdGhhdCBob29rcyBhcmUgZWl0aGVyIGNhbGxlZCBieSBSZWFjdCBDb21wb25lbnRzIG9yIG90aGVyIGhvb2tzLiBJdFxyXG4gIC8vICAgICAgIC8vIGZvbGxvd3MgdGhlcmVmb3JlLCB0aGF0IHRvIGZpbmQgdGhlIGNhbGxpbmcgY29tcG9uZW50LCB5b3Ugc2ltcGx5IG5lZWRcclxuICAvLyAgICAgICAvLyB0byBsb29rIGRvd24gdGhlIHN0YWNrIGFuZCBmaW5kIHRoZSBmaXJzdCBmdW5jdGlvbiB3aGljaCBkb2Vzbid0IHN0YXJ0XHJcbiAgLy8gICAgICAgLy8gd2l0aCAndXNlJy4gV2UgYXJlIG9ubHkgZW5hYmxpbmcgdGhpcyBpbiBkZXYgZm9yIG5vdywgc2luY2Ugb25jZSB0aGVcclxuICAvLyAgICAgICAvLyBjb2RlYmFzZSBpcyBtaW5pZmllZCwgdGhlIG5hbWluZyBhc3N1bXB0aW9ucyBubyBsb25nZXIgaG9sZCB0cnVlLlxyXG4gIC8vICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvbm8tbmV3LWVycm9yXHJcbiAgLy8gICAgICAgY29uc3QgZnJhbWVzID0gc3RhY2tUcmFjZVBhcnNlcihuZXcgRXJyb3IoKS5zdGFjayk7XHJcbiAgLy8gICAgICAgZm9yIChjb25zdCB7bWV0aG9kTmFtZX0gb2YgZnJhbWVzKSB7XHJcbiAgLy8gICAgICAgICAvLyBJIG9ic2VydmVkIGNhc2VzIHdoZXJlIHRoZSBmcmFtZSB3YXMgb2YgdGhlIGZvcm0gJ09iamVjdC51c2VYWFgnXHJcbiAgLy8gICAgICAgICAvLyBoZW5jZSB3aHkgSSdtIHNlYXJjaGluZyBmb3IgaG9va3MgZm9sbG93aW5nIGEgd29yZCBib3VuZGFyeVxyXG4gIC8vICAgICAgICAgaWYgKCFtZXRob2ROYW1lLm1hdGNoKC9cXGJ1c2VbXlxcYl0rJC8pKSB7XHJcbiAgLy8gICAgICAgICAgIHJldHVybiAobmFtZVJlZi5jdXJyZW50ID0gbWV0aG9kTmFtZSk7XHJcbiAgLy8gICAgICAgICB9XHJcbiAgLy8gICAgICAgfVxyXG4gIC8vICAgICAgIG5hbWVSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgLy8gICAgIH1cclxuICAvLyAgICAgcmV0dXJuIG5hbWVSZWYuY3VycmVudCA/PyAnPHVuYWJsZSB0byBkZXRlcm1pbmUgY29tcG9uZW50IG5hbWU+JztcclxuICAvLyAgIH1cclxuICAvLyB9XHJcbiAgLy8gQGZiLW9ubHk6IHJldHVybiBcIjxjb21wb25lbnQgbmFtZSBvbmx5IGF2YWlsYWJsZSB3aGVuIGJvdGggaW4gZGV2IG1vZGUgYW5kIHdoZW4gcGFzc2luZyBHSyAncmVjb2lsX2luZmVyX2NvbXBvbmVudF9uYW1lcyc+XCI7XHJcbiAgcmV0dXJuICc8Y29tcG9uZW50IG5hbWUgbm90IGF2YWlsYWJsZT4nOyAvLyBAb3NzLW9ubHlcclxufVxyXG5cclxudmFyIFJlY29pbF91c2VDb21wb25lbnROYW1lID0gdXNlQ29tcG9uZW50TmFtZTtcclxuXHJcbmNvbnN0IHtcclxuICBiYXRjaFVwZGF0ZXM6IGJhdGNoVXBkYXRlcyQyXHJcbn0gPSBSZWNvaWxfQmF0Y2hpbmc7XHJcblxyXG5jb25zdCB7XHJcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQyXHJcbn0gPSBSZWNvaWxfTm9kZTtcclxuXHJcbmNvbnN0IHtcclxuICByZWFjdE1vZGU6IHJlYWN0TW9kZSQzLFxyXG4gIHVzZU11dGFibGVTb3VyY2U6IHVzZU11dGFibGVTb3VyY2UkMSxcclxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdXNlU3luY0V4dGVybmFsU3RvcmUkMVxyXG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcclxuXHJcbmNvbnN0IHtcclxuICB1c2VSZWNvaWxNdXRhYmxlU291cmNlOiB1c2VSZWNvaWxNdXRhYmxlU291cmNlJDEsXHJcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDJcclxufSA9IFJlY29pbF9SZWNvaWxSb290O1xyXG5cclxuY29uc3Qge1xyXG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkMlxyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlJDE7XHJcblxyXG5jb25zdCB7XHJcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZTogQWJzdHJhY3RSZWNvaWxWYWx1ZSQzLFxyXG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZTogZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIsXHJcbiAgc2V0UmVjb2lsVmFsdWU6IHNldFJlY29pbFZhbHVlJDIsXHJcbiAgc2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZTogc2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZSQyLFxyXG4gIHN1YnNjcmliZVRvUmVjb2lsVmFsdWU6IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMVxyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xyXG5cclxuXHJcblxyXG5jb25zdCB7XHJcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrJDEsXHJcbiAgdXNlRWZmZWN0OiB1c2VFZmZlY3QkMyxcclxuICB1c2VNZW1vOiB1c2VNZW1vJDEsXHJcbiAgdXNlUmVmOiB1c2VSZWYkNCxcclxuICB1c2VTdGF0ZTogdXNlU3RhdGUkMVxyXG59ID0gcmVhY3Q7XHJcblxyXG5jb25zdCB7XHJcbiAgc2V0QnlBZGRpbmdUb1NldDogc2V0QnlBZGRpbmdUb1NldCQyXHJcbn0gPSBSZWNvaWxfQ29weU9uV3JpdGU7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBoYW5kbGVMb2FkYWJsZShsb2FkYWJsZSwgcmVjb2lsVmFsdWUsIHN0b3JlUmVmKSB7XHJcbiAgLy8gV2UgY2FuJ3QganVzdCB0aHJvdyB0aGUgcHJvbWlzZSB3ZSBhcmUgd2FpdGluZyBvbiB0byBTdXNwZW5zZS4gIElmIHRoZVxyXG4gIC8vIHVwc3RyZWFtIGRlcGVuZGVuY2llcyBjaGFuZ2UgaXQgbWF5IHByb2R1Y2UgYSBzdGF0ZSBpbiB3aGljaCB0aGUgY29tcG9uZW50XHJcbiAgLy8gY2FuIHJlbmRlciwgYnV0IGl0IHdvdWxkIHN0aWxsIGJlIHN1c3BlbmRlZCBvbiBhIFByb21pc2UgdGhhdCBtYXkgbmV2ZXIgcmVzb2x2ZS5cclxuICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScpIHtcclxuICAgIHJldHVybiBsb2FkYWJsZS5jb250ZW50cztcclxuICB9IGVsc2UgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnbG9hZGluZycpIHtcclxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpLnN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVycy5hZGQocmVzb2x2ZSk7XHJcbiAgICB9KTsgLy8gJEZsb3dFeHBlY3RlZEVycm9yIEZsb3cocHJvcC1taXNzaW5nKSBmb3IgaW50ZWdyYXRpbmcgd2l0aCB0b29scyB0aGF0IGluc3BlY3QgdGhyb3duIHByb21pc2VzIEBmYi1vbmx5XHJcbiAgICAvLyBAZmItb25seTogcHJvbWlzZS5kaXNwbGF5TmFtZSA9IGBSZWNvaWwgU3RhdGU6ICR7cmVjb2lsVmFsdWUua2V5fWA7XHJcblxyXG4gICAgdGhyb3cgcHJvbWlzZTtcclxuICB9IGVsc2UgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzRXJyb3InKSB7XHJcbiAgICB0aHJvdyBsb2FkYWJsZS5jb250ZW50cztcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgUmVjb2lsX2VycihgSW52YWxpZCB2YWx1ZSBvZiBsb2FkYWJsZSBhdG9tIFwiJHtyZWNvaWxWYWx1ZS5rZXl9XCJgKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsIGhvb2tOYW1lKSB7XHJcbiAgaWYgKCFpc1JlY29pbFZhbHVlJDIocmVjb2lsVmFsdWUpKSB7XHJcbiAgICB0aHJvdyBSZWNvaWxfZXJyKGBJbnZhbGlkIGFyZ3VtZW50IHRvICR7aG9va05hbWV9OiBleHBlY3RlZCBhbiBhdG9tIG9yIHNlbGVjdG9yIGJ1dCBnb3QgJHtTdHJpbmcocmVjb2lsVmFsdWUpfWApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZhcmlvdXMgdGhpbmdzIGFyZSBicm9rZW4gd2l0aCB1c2VSZWNvaWxJbnRlcmZhY2UsIHBhcnRpY3VsYXJseSBjb25jdXJyZW50XHJcbiAqIG1vZGUsIFJlYWN0IHN0cmljdCBtb2RlLCBhbmQgbWVtb3J5IG1hbmFnZW1lbnQuIFRoZXkgd2lsbCBub3QgYmUgZml4ZWQuXHJcbiAqICovXHJcbmZ1bmN0aW9uIHVzZVJlY29pbEludGVyZmFjZV9ERVBSRUNBVEVEKCkge1xyXG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBSZWNvaWxfdXNlQ29tcG9uZW50TmFtZSgpO1xyXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xyXG4gIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVN0YXRlJDEoW10pO1xyXG4gIGNvbnN0IHJlY29pbFZhbHVlc1VzZWQgPSB1c2VSZWYkNChuZXcgU2V0KCkpO1xyXG4gIHJlY29pbFZhbHVlc1VzZWQuY3VycmVudCA9IG5ldyBTZXQoKTsgLy8gVHJhY2sgdGhlIFJlY29pbFZhbHVlcyB1c2VkIGp1c3QgZHVyaW5nIHRoaXMgcmVuZGVyXHJcblxyXG4gIGNvbnN0IHByZXZpb3VzU3Vic2NyaXB0aW9ucyA9IHVzZVJlZiQ0KG5ldyBTZXQoKSk7XHJcbiAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHVzZVJlZiQ0KG5ldyBNYXAoKSk7XHJcbiAgY29uc3QgdW5zdWJzY3JpYmVGcm9tID0gdXNlQ2FsbGJhY2skMShrZXkgPT4ge1xyXG4gICAgY29uc3Qgc3ViID0gc3Vic2NyaXB0aW9ucy5jdXJyZW50LmdldChrZXkpO1xyXG5cclxuICAgIGlmIChzdWIpIHtcclxuICAgICAgc3ViLnJlbGVhc2UoKTtcclxuICAgICAgc3Vic2NyaXB0aW9ucy5jdXJyZW50LmRlbGV0ZShrZXkpO1xyXG4gICAgfVxyXG4gIH0sIFtzdWJzY3JpcHRpb25zXSk7XHJcbiAgY29uc3QgdXBkYXRlU3RhdGUgPSB1c2VDYWxsYmFjayQxKChfc3RhdGUsIGtleSkgPT4ge1xyXG4gICAgaWYgKHN1YnNjcmlwdGlvbnMuY3VycmVudC5oYXMoa2V5KSkge1xyXG4gICAgICBmb3JjZVVwZGF0ZShbXSk7XHJcbiAgICB9XHJcbiAgfSwgW10pOyAvLyBFZmZlY3QgdG8gYWRkL3JlbW92ZSBzdWJzY3JpcHRpb25zIGFzIG5vZGVzIGFyZSB1c2VkXHJcblxyXG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcclxuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcclxuICAgIFJlY29pbF9kaWZmZXJlbmNlU2V0cyhyZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQsIHByZXZpb3VzU3Vic2NyaXB0aW9ucy5jdXJyZW50KS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIGlmIChzdWJzY3JpcHRpb25zLmN1cnJlbnQuaGFzKGtleSkpIHtcclxuICAgICAgICBSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24oYERvdWJsZSBzdWJzY3JpcHRpb24gdG8gUmVjb2lsVmFsdWUgXCIke2tleX1cImApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgc3ViID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlLCBuZXcgQWJzdHJhY3RSZWNvaWxWYWx1ZSQzKGtleSksIHN0YXRlID0+IHVwZGF0ZVN0YXRlKHN0YXRlLCBrZXkpLCBjb21wb25lbnROYW1lKTtcclxuICAgICAgc3Vic2NyaXB0aW9ucy5jdXJyZW50LnNldChrZXksIHN1Yik7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBTaW5jZSB3ZSdyZSBzdWJzY3JpYmluZyBpbiBhbiBlZmZlY3Qgd2UgbmVlZCB0byB1cGRhdGUgdG8gdGhlIGxhdGVzdFxyXG4gICAgICAgKiB2YWx1ZSBvZiB0aGUgYXRvbSBzaW5jZSBpdCBtYXkgaGF2ZSBjaGFuZ2VkIHNpbmNlIHdlIHJlbmRlcmVkLiBXZSBjYW5cclxuICAgICAgICogZ28gYWhlYWQgYW5kIGRvIHRoYXQgbm93LCB1bmxlc3Mgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIGJhdGNoIC0tXHJcbiAgICAgICAqIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGRvIGl0IGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLCBkdWUgdG8gdGhlXHJcbiAgICAgICAqIGZvbGxvd2luZyBlZGdlIGNhc2U6IFN1cHBvc2UgYW4gYXRvbSBpcyB1cGRhdGVkIGluIGFub3RoZXIgdXNlRWZmZWN0XHJcbiAgICAgICAqIG9mIHRoaXMgc2FtZSBjb21wb25lbnQuIFRoZW4gdGhlIGZvbGxvd2luZyBzZXF1ZW5jZSBvZiBldmVudHMgb2NjdXI6XHJcbiAgICAgICAqIDEuIEF0b20gaXMgdXBkYXRlZCBhbmQgc3VicyBmaXJlZCAoYnV0IHdlIG1heSBub3QgYmUgc3Vic2NyaWJlZFxyXG4gICAgICAgKiAgICB5ZXQgZGVwZW5kaW5nIG9uIG9yZGVyIG9mIGVmZmVjdHMsIHNvIHdlIG1pc3MgdGhpcykgVXBkYXRlZCB2YWx1ZVxyXG4gICAgICAgKiAgICBpcyBub3cgaW4gbmV4dFRyZWUsIGJ1dCBub3QgY3VycmVudFRyZWUuXHJcbiAgICAgICAqIDIuIFRoaXMgZWZmZWN0IGhhcHBlbnMuIFdlIHN1YnNjcmliZSBhbmQgdXBkYXRlLlxyXG4gICAgICAgKiAzLiBGcm9tIHRoZSB1cGRhdGUgd2UgcmUtcmVuZGVyIGFuZCByZWFkIGN1cnJlbnRUcmVlLCB3aXRoIG9sZCB2YWx1ZS5cclxuICAgICAgICogNC4gQmF0Y2hlcidzIGVmZmVjdCBzZXRzIGN1cnJlbnRUcmVlIHRvIG5leHRUcmVlLlxyXG4gICAgICAgKiBJbiB0aGlzIHNlcXVlbmNlIHdlIG1pc3MgdGhlIHVwZGF0ZS4gVG8gYXZvaWQgdGhhdCwgYWRkIHRoZSB1cGRhdGVcclxuICAgICAgICogdG8gcXVldWVkQ29tcG9uZW50Q2FsbGJhY2sgaWYgYSBiYXRjaCBpcyBpbiBwcm9ncmVzcy5cclxuICAgICAgICovXHJcbiAgICAgIC8vIEZJWE1FIGRlbGV0ZSBxdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRCB3aGVuIGRlbGV0aW5nIHVzZUludGVyZmFjZS5cclxuXHJcbiAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIGlmIChzdGF0ZS5uZXh0VHJlZSkge1xyXG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkucXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQucHVzaCgoKSA9PiB7XHJcbiAgICAgICAgICB1cGRhdGVTdGF0ZShzdG9yZS5nZXRTdGF0ZSgpLCBrZXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVwZGF0ZVN0YXRlKHN0b3JlLmdldFN0YXRlKCksIGtleSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgUmVjb2lsX2RpZmZlcmVuY2VTZXRzKHByZXZpb3VzU3Vic2NyaXB0aW9ucy5jdXJyZW50LCByZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgdW5zdWJzY3JpYmVGcm9tKGtleSk7XHJcbiAgICB9KTtcclxuICAgIHByZXZpb3VzU3Vic2NyaXB0aW9ucy5jdXJyZW50ID0gcmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50O1xyXG4gIH0pOyAvLyBFZmZlY3QgdG8gdW5zdWJzY3JpYmUgZnJvbSBhbGwgd2hlbiB1bm1vdW50aW5nXHJcblxyXG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcclxuICAgIGNvbnN0IGN1cnJlbnRTdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucy5jdXJyZW50OyAvLyBSZXN0b3JlIHN1YnNjcmlwdGlvbnMgdGhhdCB3ZXJlIGNsZWFyZWQgZHVlIHRvIFN0cmljdE1vZGUgcnVubmluZyB0aGlzIGVmZmVjdCB0d2ljZVxyXG5cclxuICAgIFJlY29pbF9kaWZmZXJlbmNlU2V0cyhyZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQsIG5ldyBTZXQoY3VycmVudFN1YnNjcmlwdGlvbnMua2V5cygpKSkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICBjb25zdCBzdWIgPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmVSZWYuY3VycmVudCwgbmV3IEFic3RyYWN0UmVjb2lsVmFsdWUkMyhrZXkpLCBzdGF0ZSA9PiB1cGRhdGVTdGF0ZShzdGF0ZSwga2V5KSwgY29tcG9uZW50TmFtZSk7XHJcbiAgICAgIGN1cnJlbnRTdWJzY3JpcHRpb25zLnNldChrZXksIHN1Yik7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiAoKSA9PiBjdXJyZW50U3Vic2NyaXB0aW9ucy5mb3JFYWNoKChfLCBrZXkpID0+IHVuc3Vic2NyaWJlRnJvbShrZXkpKTtcclxuICB9LCBbY29tcG9uZW50TmFtZSwgc3RvcmVSZWYsIHVuc3Vic2NyaWJlRnJvbSwgdXBkYXRlU3RhdGVdKTtcclxuICByZXR1cm4gdXNlTWVtbyQxKCgpID0+IHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcclxuICAgIGZ1bmN0aW9uIHVzZVNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlKSB7XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlU2V0UmVjb2lsU3RhdGUnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5ld1ZhbHVlT3JVcGRhdGVyID0+IHtcclxuICAgICAgICBzZXRSZWNvaWxWYWx1ZSQyKHN0b3JlUmVmLmN1cnJlbnQsIHJlY29pbFN0YXRlLCBuZXdWYWx1ZU9yVXBkYXRlcik7XHJcbiAgICAgIH07XHJcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlUmVzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlc2V0UmVjb2lsU3RhdGUnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuICgpID0+IHNldFJlY29pbFZhbHVlJDIoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsU3RhdGUsIERFRkFVTFRfVkFMVUUkMik7XHJcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZShyZWNvaWxWYWx1ZSkge1xyXG4gICAgICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWU7XHJcblxyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSwgJ3VzZVJlY29pbFZhbHVlTG9hZGFibGUnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFyZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQuaGFzKHJlY29pbFZhbHVlLmtleSkpIHtcclxuICAgICAgICByZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQgPSBzZXRCeUFkZGluZ1RvU2V0JDIocmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50LCByZWNvaWxWYWx1ZS5rZXkpO1xyXG4gICAgICB9IC8vIFRPRE8gUmVzdG9yZSBvcHRpbWl6YXRpb24gdG8gbWVtb2l6ZSBsb29rdXBcclxuXHJcblxyXG4gICAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpO1xyXG4gICAgICByZXR1cm4gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsVmFsdWUsIHJlYWN0TW9kZSQzKCkuZWFybHkgPyAoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSk7XHJcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUpIHtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBsb2FkYWJsZSA9IHVzZVJlY29pbFZhbHVlTG9hZGFibGUocmVjb2lsVmFsdWUpO1xyXG4gICAgICByZXR1cm4gaGFuZGxlTG9hZGFibGUobG9hZGFibGUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZik7XHJcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlUmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZWNvaWxTdGF0ZScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gW3VzZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcclxuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlKHJlY29pbFN0YXRlKSB7XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlUmVjb2lsU3RhdGVMb2FkYWJsZScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gW3VzZVJlY29pbFZhbHVlTG9hZGFibGUocmVjb2lsU3RhdGUpLCB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSldO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGdldFJlY29pbFZhbHVlOiB1c2VSZWNvaWxWYWx1ZSxcclxuICAgICAgZ2V0UmVjb2lsVmFsdWVMb2FkYWJsZTogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZSxcclxuICAgICAgZ2V0UmVjb2lsU3RhdGU6IHVzZVJlY29pbFN0YXRlLFxyXG4gICAgICBnZXRSZWNvaWxTdGF0ZUxvYWRhYmxlOiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlLFxyXG4gICAgICBnZXRTZXRSZWNvaWxTdGF0ZTogdXNlU2V0UmVjb2lsU3RhdGUsXHJcbiAgICAgIGdldFJlc2V0UmVjb2lsU3RhdGU6IHVzZVJlc2V0UmVjb2lsU3RhdGVcclxuICAgIH07XHJcbiAgfSwgW3JlY29pbFZhbHVlc1VzZWQsIHN0b3JlUmVmXSk7XHJcbn1cclxuXHJcbmNvbnN0IHJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkcgPSB7XHJcbiAgY3VycmVudDogMFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9TWU5DX0VYVEVSTkFMX1NUT1JFKHJlY29pbFZhbHVlKSB7XHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XHJcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7XHJcbiAgY29uc3QgZ2V0U25hcHNob3QgPSB1c2VDYWxsYmFjayQxKCgpID0+IHtcclxuICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTI7XHJcblxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICByZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HLmN1cnJlbnQrKztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XHJcbiAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgIGNvbnN0IHRyZWVTdGF0ZSA9IHJlYWN0TW9kZSQzKCkuZWFybHkgPyAoX3N0b3JlU3RhdGUkbmV4dFRyZWUyID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWUyICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZTIgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcclxuICAgIGNvbnN0IGxvYWRhYmxlID0gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIoc3RvcmUsIHJlY29pbFZhbHVlLCB0cmVlU3RhdGUpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbG9hZGFibGUsXHJcbiAgICAgIGtleTogcmVjb2lsVmFsdWUua2V5XHJcbiAgICB9O1xyXG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsVmFsdWVdKTsgLy8gTWVtb2l6ZSB0aGUgc3RhdGUgdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmVyZW5kZXJzXHJcblxyXG4gIGNvbnN0IG1lbW9pemVQcmV2aW91c1NuYXBzaG90ID0gdXNlQ2FsbGJhY2skMShnZXRTdGF0ZSA9PiB7XHJcbiAgICBsZXQgcHJldlN0YXRlO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgdmFyIF9wcmV2U3RhdGUsIF9wcmV2U3RhdGUyO1xyXG5cclxuICAgICAgY29uc3QgbmV4dFN0YXRlID0gZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIGlmICgoX3ByZXZTdGF0ZSA9IHByZXZTdGF0ZSkgIT09IG51bGwgJiYgX3ByZXZTdGF0ZSAhPT0gdm9pZCAwICYmIF9wcmV2U3RhdGUubG9hZGFibGUuaXMobmV4dFN0YXRlLmxvYWRhYmxlKSAmJiAoKF9wcmV2U3RhdGUyID0gcHJldlN0YXRlKSA9PT0gbnVsbCB8fCBfcHJldlN0YXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ByZXZTdGF0ZTIua2V5KSA9PT0gbmV4dFN0YXRlLmtleSkge1xyXG4gICAgICAgIHJldHVybiBwcmV2U3RhdGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByZXZTdGF0ZSA9IG5leHRTdGF0ZTtcclxuICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcclxuICAgIH07XHJcbiAgfSwgW10pO1xyXG4gIGNvbnN0IGdldE1lbW9pemVkU25hcHNob3QgPSB1c2VNZW1vJDEoKCkgPT4gbWVtb2l6ZVByZXZpb3VzU25hcHNob3QoZ2V0U25hcHNob3QpLCBbZ2V0U25hcHNob3QsIG1lbW9pemVQcmV2aW91c1NuYXBzaG90XSk7XHJcbiAgY29uc3Qgc3Vic2NyaWJlID0gdXNlQ2FsbGJhY2skMShub3RpZnkgPT4ge1xyXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xyXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlLCByZWNvaWxWYWx1ZSwgbm90aWZ5LCBjb21wb25lbnROYW1lKTtcclxuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucmVsZWFzZTtcclxuICB9LCBbc3RvcmVSZWYsIHJlY29pbFZhbHVlLCBjb21wb25lbnROYW1lXSk7XHJcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDEoc3Vic2NyaWJlLCBnZXRNZW1vaXplZFNuYXBzaG90LCAvLyBnZXRTbmFwc2hvdCgpXHJcbiAgZ2V0TWVtb2l6ZWRTbmFwc2hvdCAvLyBnZXRTZXJ2ZXJTbmFwc2hvdCgpIGZvciBTU1Igc3VwcG9ydFxyXG4gICkubG9hZGFibGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfTVVUQUJMRV9TT1VSQ0UocmVjb2lsVmFsdWUpIHtcclxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcclxuICBjb25zdCBnZXRMb2FkYWJsZSA9IHVzZUNhbGxiYWNrJDEoKCkgPT4ge1xyXG4gICAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlMztcclxuXHJcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XHJcbiAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgIGNvbnN0IHRyZWVTdGF0ZSA9IHJlYWN0TW9kZSQzKCkuZWFybHkgPyAoX3N0b3JlU3RhdGUkbmV4dFRyZWUzID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWUzICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZTMgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcclxuICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMihzdG9yZSwgcmVjb2lsVmFsdWUsIHRyZWVTdGF0ZSk7XHJcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZV0pO1xyXG4gIGNvbnN0IGdldExvYWRhYmxlV2l0aFRlc3RpbmcgPSB1c2VDYWxsYmFjayQxKCgpID0+IHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgcmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORy5jdXJyZW50Kys7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGdldExvYWRhYmxlKCk7XHJcbiAgfSwgW2dldExvYWRhYmxlXSk7XHJcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7XHJcbiAgY29uc3Qgc3Vic2NyaWJlID0gdXNlQ2FsbGJhY2skMSgoX3N0b3JlU3RhdGUsIG5vdGlmeSkgPT4ge1xyXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xyXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlLCByZWNvaWxWYWx1ZSwgKCkgPT4ge1xyXG4gICAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vdGlmeSgpO1xyXG4gICAgICB9IC8vIE9ubHkgcmUtcmVuZGVyIGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZC5cclxuICAgICAgLy8gVGhpcyB3aWxsIGV2YWx1YXRlIHRoZSBhdG9tL3NlbGVjdG9yIG5vdyBhcyB3ZWxsIGFzIHdoZW4gdGhlXHJcbiAgICAgIC8vIGNvbXBvbmVudCByZW5kZXJzLCBidXQgdGhhdCBtYXkgaGVscCB3aXRoIHByZWZldGNoaW5nLlxyXG5cclxuXHJcbiAgICAgIGNvbnN0IG5ld0xvYWRhYmxlID0gZ2V0TG9hZGFibGUoKTtcclxuXHJcbiAgICAgIGlmICghcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQuaXMobmV3TG9hZGFibGUpKSB7XHJcbiAgICAgICAgbm90aWZ5KCk7XHJcbiAgICAgIH0gLy8gSWYgdGhlIGNvbXBvbmVudCBpcyBzdXNwZW5kZWQgdGhlbiB0aGUgZWZmZWN0IHNldHRpbmcgcHJldkxvYWRhYmxlUmVmXHJcbiAgICAgIC8vIHdpbGwgbm90IHJ1bi4gIFNvLCBzZXQgdGhlIHByZXZpb3VzIHZhbHVlIGhlcmUgd2hlbiBpdHMgc3Vic2NyaXB0aW9uXHJcbiAgICAgIC8vIGlzIGZpcmVkIHRvIHdha2UgaXQgdXAuICBXZSBjYW4ndCBqdXN0IHJlbHkgb24gdGhpcywgdGhvdWdoLCBiZWNhdXNlXHJcbiAgICAgIC8vIHRoaXMgb25seSBleGVjdXRlcyB3aGVuIGFuIGF0b20vc2VsZWN0b3IgaXMgZGlydHkgYW5kIHRoZSBhdG9tL3NlbGVjdG9yXHJcbiAgICAgIC8vIHBhc3NlZCB0byB0aGUgaG9vayBjYW4gZHluYW1pY2FsbHkgY2hhbmdlLlxyXG5cclxuXHJcbiAgICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbmV3TG9hZGFibGU7XHJcbiAgICB9LCBjb21wb25lbnROYW1lKTtcclxuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucmVsZWFzZTtcclxuICB9LCBbc3RvcmVSZWYsIHJlY29pbFZhbHVlLCBjb21wb25lbnROYW1lLCBnZXRMb2FkYWJsZV0pO1xyXG4gIGNvbnN0IHNvdXJjZSA9IHVzZVJlY29pbE11dGFibGVTb3VyY2UkMSgpO1xyXG5cclxuICBpZiAoc291cmNlID09IG51bGwpIHtcclxuICAgIHRocm93IFJlY29pbF9lcnIoJ1JlY29pbCBob29rcyBtdXN0IGJlIHVzZWQgaW4gY29tcG9uZW50cyBjb250YWluZWQgd2l0aGluIGEgPFJlY29pbFJvb3Q+IGNvbXBvbmVudC4nKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGxvYWRhYmxlID0gdXNlTXV0YWJsZVNvdXJjZSQxKHNvdXJjZSwgZ2V0TG9hZGFibGVXaXRoVGVzdGluZywgc3Vic2NyaWJlKTtcclxuICBjb25zdCBwcmV2TG9hZGFibGVSZWYgPSB1c2VSZWYkNChsb2FkYWJsZSk7XHJcbiAgdXNlRWZmZWN0JDMoKCkgPT4ge1xyXG4gICAgcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQgPSBsb2FkYWJsZTtcclxuICB9KTtcclxuICByZXR1cm4gbG9hZGFibGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUKHJlY29pbFZhbHVlKSB7XHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XHJcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7IC8vIEFjY2Vzc29ycyB0byBnZXQgdGhlIGN1cnJlbnQgc3RhdGVcclxuXHJcbiAgY29uc3QgZ2V0TG9hZGFibGUgPSB1c2VDYWxsYmFjayQxKCgpID0+IHtcclxuICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTQ7XHJcblxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICByZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HLmN1cnJlbnQrKztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XHJcbiAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgIGNvbnN0IHRyZWVTdGF0ZSA9IHJlYWN0TW9kZSQzKCkuZWFybHkgPyAoX3N0b3JlU3RhdGUkbmV4dFRyZWU0ID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWU0ICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZTQgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcclxuICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMihzdG9yZSwgcmVjb2lsVmFsdWUsIHRyZWVTdGF0ZSk7XHJcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZV0pO1xyXG4gIGNvbnN0IGdldFN0YXRlID0gdXNlQ2FsbGJhY2skMSgoKSA9PiAoe1xyXG4gICAgbG9hZGFibGU6IGdldExvYWRhYmxlKCksXHJcbiAgICBrZXk6IHJlY29pbFZhbHVlLmtleVxyXG4gIH0pLCBbZ2V0TG9hZGFibGUsIHJlY29pbFZhbHVlLmtleV0pOyAvLyBNZW1vaXplIHN0YXRlIHNuYXBzaG90c1xyXG5cclxuICBjb25zdCB1cGRhdGVTdGF0ZSA9IHVzZUNhbGxiYWNrJDEocHJldlN0YXRlID0+IHtcclxuICAgIGNvbnN0IG5leHRTdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICByZXR1cm4gcHJldlN0YXRlLmxvYWRhYmxlLmlzKG5leHRTdGF0ZS5sb2FkYWJsZSkgJiYgcHJldlN0YXRlLmtleSA9PT0gbmV4dFN0YXRlLmtleSA/IHByZXZTdGF0ZSA6IG5leHRTdGF0ZTtcclxuICB9LCBbZ2V0U3RhdGVdKTsgLy8gU3Vic2NyaWJlIHRvIFJlY29pbCBzdGF0ZSBjaGFuZ2VzXHJcblxyXG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcclxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMShzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxWYWx1ZSwgX3N0YXRlID0+IHtcclxuICAgICAgc2V0U3RhdGUodXBkYXRlU3RhdGUpO1xyXG4gICAgfSwgY29tcG9uZW50TmFtZSk7IC8vIFVwZGF0ZSBzdGF0ZSBpbiBjYXNlIHdlIGFyZSB1c2luZyBhIGRpZmZlcmVudCBrZXlcclxuXHJcbiAgICBzZXRTdGF0ZSh1cGRhdGVTdGF0ZSk7XHJcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uLnJlbGVhc2U7XHJcbiAgfSwgW2NvbXBvbmVudE5hbWUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZiwgdXBkYXRlU3RhdGVdKTsgLy8gR2V0IHRoZSBjdXJyZW50IHN0YXRlXHJcblxyXG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUkMShnZXRTdGF0ZSk7IC8vIElmIHdlIGNoYW5nZWQga2V5cywgdGhlbiByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgbmV3IGtleS5cclxuICAvLyBUaGlzIGlzIGltcG9ydGFudCBpbiBjYXNlIHRoZSBvbGQga2V5IHdvdWxkIGNhdXNlIHRoZSBjb21wb25lbnQgdG8gc3VzcGVuZC5cclxuICAvLyBXZSBkb24ndCBoYXZlIHRvIHNldCB0aGUgbmV3IHN0YXRlIGhlcmUgc2luY2UgdGhlIHN1YnNjcmliaW5nIGVmZmVjdCBhYm92ZVxyXG4gIC8vIHdpbGwgZG8gdGhhdC5cclxuXHJcbiAgcmV0dXJuIHN0YXRlLmtleSAhPT0gcmVjb2lsVmFsdWUua2V5ID8gZ2V0U3RhdGUoKS5sb2FkYWJsZSA6IHN0YXRlLmxvYWRhYmxlO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX0xFR0FDWShyZWNvaWxWYWx1ZSkge1xyXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xyXG4gIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVN0YXRlJDEoW10pO1xyXG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBSZWNvaWxfdXNlQ29tcG9uZW50TmFtZSgpO1xyXG4gIGNvbnN0IGdldExvYWRhYmxlID0gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XHJcbiAgICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWU1O1xyXG5cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgcmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORy5jdXJyZW50Kys7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xyXG4gICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICBjb25zdCB0cmVlU3RhdGUgPSByZWFjdE1vZGUkMygpLmVhcmx5ID8gKF9zdG9yZVN0YXRlJG5leHRUcmVlNSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlNSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWU1IDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XHJcbiAgICByZXR1cm4gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIoc3RvcmUsIHJlY29pbFZhbHVlLCB0cmVlU3RhdGUpO1xyXG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsVmFsdWVdKTtcclxuICBjb25zdCBsb2FkYWJsZSA9IGdldExvYWRhYmxlKCk7XHJcbiAgY29uc3QgcHJldkxvYWRhYmxlUmVmID0gdXNlUmVmJDQobG9hZGFibGUpO1xyXG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcclxuICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbG9hZGFibGU7XHJcbiAgfSk7XHJcbiAgdXNlRWZmZWN0JDMoKCkgPT4ge1xyXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xyXG4gICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmUsIHJlY29pbFZhbHVlLCBfc3RhdGUgPT4ge1xyXG4gICAgICB2YXIgX3ByZXZMb2FkYWJsZVJlZiRjdXJyO1xyXG5cclxuICAgICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snKSkge1xyXG4gICAgICAgIHJldHVybiBmb3JjZVVwZGF0ZShbXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG5ld0xvYWRhYmxlID0gZ2V0TG9hZGFibGUoKTtcclxuXHJcbiAgICAgIGlmICghKChfcHJldkxvYWRhYmxlUmVmJGN1cnIgPSBwcmV2TG9hZGFibGVSZWYuY3VycmVudCkgIT09IG51bGwgJiYgX3ByZXZMb2FkYWJsZVJlZiRjdXJyICE9PSB2b2lkIDAgJiYgX3ByZXZMb2FkYWJsZVJlZiRjdXJyLmlzKG5ld0xvYWRhYmxlKSkpIHtcclxuICAgICAgICBmb3JjZVVwZGF0ZShuZXdMb2FkYWJsZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbmV3TG9hZGFibGU7XHJcbiAgICB9LCBjb21wb25lbnROYW1lKTtcclxuICAgIC8qKlxyXG4gICAgICogU2luY2Ugd2UncmUgc3Vic2NyaWJpbmcgaW4gYW4gZWZmZWN0IHdlIG5lZWQgdG8gdXBkYXRlIHRvIHRoZSBsYXRlc3RcclxuICAgICAqIHZhbHVlIG9mIHRoZSBhdG9tIHNpbmNlIGl0IG1heSBoYXZlIGNoYW5nZWQgc2luY2Ugd2UgcmVuZGVyZWQuIFdlIGNhblxyXG4gICAgICogZ28gYWhlYWQgYW5kIGRvIHRoYXQgbm93LCB1bmxlc3Mgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIGJhdGNoIC0tXHJcbiAgICAgKiBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBkbyBpdCBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaCwgZHVlIHRvIHRoZVxyXG4gICAgICogZm9sbG93aW5nIGVkZ2UgY2FzZTogU3VwcG9zZSBhbiBhdG9tIGlzIHVwZGF0ZWQgaW4gYW5vdGhlciB1c2VFZmZlY3RcclxuICAgICAqIG9mIHRoaXMgc2FtZSBjb21wb25lbnQuIFRoZW4gdGhlIGZvbGxvd2luZyBzZXF1ZW5jZSBvZiBldmVudHMgb2NjdXI6XHJcbiAgICAgKiAxLiBBdG9tIGlzIHVwZGF0ZWQgYW5kIHN1YnMgZmlyZWQgKGJ1dCB3ZSBtYXkgbm90IGJlIHN1YnNjcmliZWRcclxuICAgICAqICAgIHlldCBkZXBlbmRpbmcgb24gb3JkZXIgb2YgZWZmZWN0cywgc28gd2UgbWlzcyB0aGlzKSBVcGRhdGVkIHZhbHVlXHJcbiAgICAgKiAgICBpcyBub3cgaW4gbmV4dFRyZWUsIGJ1dCBub3QgY3VycmVudFRyZWUuXHJcbiAgICAgKiAyLiBUaGlzIGVmZmVjdCBoYXBwZW5zLiBXZSBzdWJzY3JpYmUgYW5kIHVwZGF0ZS5cclxuICAgICAqIDMuIEZyb20gdGhlIHVwZGF0ZSB3ZSByZS1yZW5kZXIgYW5kIHJlYWQgY3VycmVudFRyZWUsIHdpdGggb2xkIHZhbHVlLlxyXG4gICAgICogNC4gQmF0Y2hlcidzIGVmZmVjdCBzZXRzIGN1cnJlbnRUcmVlIHRvIG5leHRUcmVlLlxyXG4gICAgICogSW4gdGhpcyBzZXF1ZW5jZSB3ZSBtaXNzIHRoZSB1cGRhdGUuIFRvIGF2b2lkIHRoYXQsIGFkZCB0aGUgdXBkYXRlXHJcbiAgICAgKiB0byBxdWV1ZWRDb21wb25lbnRDYWxsYmFjayBpZiBhIGJhdGNoIGlzIGluIHByb2dyZXNzLlxyXG4gICAgICovXHJcblxyXG4gICAgaWYgKHN0b3JlU3RhdGUubmV4dFRyZWUpIHtcclxuICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5xdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRC5wdXNoKCgpID0+IHtcclxuICAgICAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgZm9yY2VVcGRhdGUoW10pO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBfcHJldkxvYWRhYmxlUmVmJGN1cnIyO1xyXG5cclxuICAgICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snKSkge1xyXG4gICAgICAgIHJldHVybiBmb3JjZVVwZGF0ZShbXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG5ld0xvYWRhYmxlID0gZ2V0TG9hZGFibGUoKTtcclxuXHJcbiAgICAgIGlmICghKChfcHJldkxvYWRhYmxlUmVmJGN1cnIyID0gcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQpICE9PSBudWxsICYmIF9wcmV2TG9hZGFibGVSZWYkY3VycjIgIT09IHZvaWQgMCAmJiBfcHJldkxvYWRhYmxlUmVmJGN1cnIyLmlzKG5ld0xvYWRhYmxlKSkpIHtcclxuICAgICAgICBmb3JjZVVwZGF0ZShuZXdMb2FkYWJsZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbmV3TG9hZGFibGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbi5yZWxlYXNlO1xyXG4gIH0sIFtjb21wb25lbnROYW1lLCBnZXRMb2FkYWJsZSwgcmVjb2lsVmFsdWUsIHN0b3JlUmVmXSk7XHJcbiAgcmV0dXJuIGxvYWRhYmxlO1xyXG59XHJcbi8qKlxyXG4gIExpa2UgdXNlUmVjb2lsVmFsdWUoKSwgYnV0IGVpdGhlciByZXR1cm5zIHRoZSB2YWx1ZSBpZiBhdmFpbGFibGUgb3JcclxuICBqdXN0IHVuZGVmaW5lZCBpZiBub3QgYXZhaWxhYmxlIGZvciBhbnkgcmVhc29uLCBzdWNoIGFzIHBlbmRpbmcgb3IgZXJyb3IuXHJcbiovXHJcblxyXG5cclxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZShyZWNvaWxWYWx1ZSkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9yZWFjdC1ob29rc1xyXG4gICAgUmVjb2lsX3VzZVJldGFpbihyZWNvaWxWYWx1ZSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgVFJBTlNJVElPTl9TVVBQT1JUOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVCxcclxuICAgIFNZTkNfRVhURVJOQUxfU1RPUkU6IHVzZVJlY29pbFZhbHVlTG9hZGFibGVfU1lOQ19FWFRFUk5BTF9TVE9SRSxcclxuICAgIE1VVEFCTEVfU09VUkNFOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX01VVEFCTEVfU09VUkNFLFxyXG4gICAgTEVHQUNZOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX0xFR0FDWVxyXG4gIH1bcmVhY3RNb2RlJDMoKS5tb2RlXShyZWNvaWxWYWx1ZSk7XHJcbn1cclxuLyoqXHJcbiAgUmV0dXJucyB0aGUgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIFJlY29pbFZhbHVlLlxyXG4gIElmIHRoZSB2YWx1ZSBpcyBwZW5kaW5nLCBpdCB3aWxsIHRocm93IGEgUHJvbWlzZSB0byBzdXNwZW5kIHRoZSBjb21wb25lbnQsXHJcbiAgaWYgdGhlIHZhbHVlIGlzIGFuIGVycm9yIGl0IHdpbGwgdGhyb3cgaXQgZm9yIHRoZSBuZWFyZXN0IFJlYWN0IGVycm9yIGJvdW5kYXJ5LlxyXG4gIFRoaXMgd2lsbCBhbHNvIHN1YnNjcmliZSB0aGUgY29tcG9uZW50IGZvciBhbnkgdXBkYXRlcyBpbiB0aGUgdmFsdWUuXHJcbiAgKi9cclxuXHJcblxyXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZScpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XHJcbiAgY29uc3QgbG9hZGFibGUgPSB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFZhbHVlKTtcclxuICByZXR1cm4gaGFuZGxlTG9hZGFibGUobG9hZGFibGUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZik7XHJcbn1cclxuLyoqXHJcbiAgUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHRoZSB2YWx1ZSBvZiBhIFJlY29pbFN0YXRlIHRvIGJlIHVwZGF0ZWQsIGJ1dCBkb2VzXHJcbiAgbm90IHN1YnNjcmliZSB0aGUgY29tcG9uZW50IHRvIGNoYW5nZXMgdG8gdGhhdCBSZWNvaWxTdGF0ZS5cclxuKi9cclxuXHJcblxyXG5mdW5jdGlvbiB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VTZXRSZWNvaWxTdGF0ZScpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XHJcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDEobmV3VmFsdWVPclVwZGF0ZXIgPT4ge1xyXG4gICAgc2V0UmVjb2lsVmFsdWUkMihzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxTdGF0ZSwgbmV3VmFsdWVPclVwZGF0ZXIpO1xyXG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsU3RhdGVdKTtcclxufVxyXG4vKipcclxuICBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlc2V0IHRoZSB2YWx1ZSBvZiBhIFJlY29pbFN0YXRlIHRvIGl0cyBkZWZhdWx0XHJcbiovXHJcblxyXG5cclxuZnVuY3Rpb24gdXNlUmVzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZXNldFJlY29pbFN0YXRlJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcclxuICByZXR1cm4gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XHJcbiAgICBzZXRSZWNvaWxWYWx1ZSQyKHN0b3JlUmVmLmN1cnJlbnQsIHJlY29pbFN0YXRlLCBERUZBVUxUX1ZBTFVFJDIpO1xyXG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsU3RhdGVdKTtcclxufVxyXG4vKipcclxuICBFcXVpdmFsZW50IHRvIHVzZVN0YXRlKCkuIEFsbG93cyB0aGUgdmFsdWUgb2YgdGhlIFJlY29pbFN0YXRlIHRvIGJlIHJlYWQgYW5kIHdyaXR0ZW4uXHJcbiAgU3Vic2VxdWVudCB1cGRhdGVzIHRvIHRoZSBSZWNvaWxTdGF0ZSB3aWxsIGNhdXNlIHRoZSBjb21wb25lbnQgdG8gcmUtcmVuZGVyLiBJZiB0aGVcclxuICBSZWNvaWxTdGF0ZSBpcyBwZW5kaW5nLCB0aGlzIHdpbGwgc3VzcGVuZCB0aGUgY29tcG9uZW50IGFuZCBpbml0aWF0ZSB0aGVcclxuICByZXRyaWV2YWwgb2YgdGhlIHZhbHVlLiBJZiBldmFsdWF0aW5nIHRoZSBSZWNvaWxTdGF0ZSByZXN1bHRlZCBpbiBhbiBlcnJvciwgdGhpcyB3aWxsXHJcbiAgdGhyb3cgdGhlIGVycm9yIHNvIHRoYXQgdGhlIG5lYXJlc3QgUmVhY3QgZXJyb3IgYm91bmRhcnkgY2FuIGNhdGNoIGl0LlxyXG4qL1xyXG5cclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbFN0YXRlKHJlY29pbFN0YXRlKSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlY29pbFN0YXRlJyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gW3VzZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcclxufVxyXG4vKipcclxuICBMaWtlIHVzZVJlY29pbFN0YXRlKCksIGJ1dCBkb2VzIG5vdCBjYXVzZSBTdXNwZW5zZSBvciBSZWFjdCBlcnJvciBoYW5kbGluZy4gUmV0dXJuc1xyXG4gIGFuIG9iamVjdCB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBSZWNvaWxTdGF0ZSBpcyBhdmFpbGFibGUsIHBlbmRpbmcsIG9yXHJcbiAgdW5hdmFpbGFibGUgZHVlIHRvIGFuIGVycm9yLlxyXG4qL1xyXG5cclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbFN0YXRlTG9hZGFibGUocmVjb2lsU3RhdGUpIHtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlUmVjb2lsU3RhdGVMb2FkYWJsZScpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFt1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzKCkge1xyXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xyXG4gIHJldHVybiAodmFsdWVzLCB0cmFuc2FjdGlvbk1ldGFkYXRhID0ge30pID0+IHtcclxuICAgIGJhdGNoVXBkYXRlcyQyKCgpID0+IHtcclxuICAgICAgc3RvcmVSZWYuY3VycmVudC5hZGRUcmFuc2FjdGlvbk1ldGFkYXRhKHRyYW5zYWN0aW9uTWV0YWRhdGEpO1xyXG4gICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gc2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZSQyKHN0b3JlUmVmLmN1cnJlbnQsIG5ldyBBYnN0cmFjdFJlY29pbFZhbHVlJDMoa2V5KSwgdmFsdWUpKTtcclxuICAgIH0pO1xyXG4gIH07XHJcbn1cclxuLyoqXHJcbiAqIEV4cGVyaW1lbnRhbCB2YXJpYW50cyBvZiBob29rcyB3aXRoIHN1cHBvcnQgZm9yIHVzZVRyYW5zaXRpb24oKVxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRShyZWNvaWxWYWx1ZSkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRScpO1xyXG5cclxuICAgIGlmICghcmVhY3RNb2RlJDMoKS5lYXJseSkge1xyXG4gICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ0F0dGVwbXQgdG8gdXNlIGEgaG9vayB3aXRoIFVOU1RBQkxFX1RSQU5TSVRJT05fU1VQUE9SVCBpbiBhIHJlbmRlcmluZyBtb2RlIGluY29tcGF0aWJsZSB3aXRoIGNvbmN1cnJlbnQgcmVuZGVyaW5nLiAgVHJ5IGVuYWJsaW5nIHRoZSByZWNvaWxfc3luY19leHRlcm5hbF9zdG9yZSBvciByZWNvaWxfdHJhbnNpdGlvbl9zdXBwb3J0IEdLcy4nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L3JlYWN0LWhvb2tzXHJcbiAgICBSZWNvaWxfdXNlUmV0YWluKHJlY29pbFZhbHVlKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVChyZWNvaWxWYWx1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRShyZWNvaWxWYWx1ZSkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUnKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xyXG4gIGNvbnN0IGxvYWRhYmxlID0gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsVmFsdWUpO1xyXG4gIHJldHVybiBoYW5kbGVMb2FkYWJsZShsb2FkYWJsZSwgcmVjb2lsVmFsdWUsIHN0b3JlUmVmKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFKHJlY29pbFN0YXRlKSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRScpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFt1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsU3RhdGUpLCB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSldO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX0hvb2tzID0ge1xyXG4gIHJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkcsXHJcbiAgdXNlUmVjb2lsSW50ZXJmYWNlOiB1c2VSZWNvaWxJbnRlcmZhY2VfREVQUkVDQVRFRCxcclxuICB1c2VSZWNvaWxTdGF0ZSxcclxuICB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlLFxyXG4gIHVzZVJlY29pbFZhbHVlLFxyXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGUsXHJcbiAgdXNlUmVzZXRSZWNvaWxTdGF0ZSxcclxuICB1c2VTZXRSZWNvaWxTdGF0ZSxcclxuICB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMsXHJcbiAgdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUsXHJcbiAgdXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFLFxyXG4gIHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYSBtYXAgY29udGFpbmluZyBhbGwgb2YgdGhlIGtleXMgKyB2YWx1ZXMgZnJvbSB0aGUgb3JpZ2luYWwgbWFwIHdoZXJlXHJcbiAqIHRoZSBnaXZlbiBjYWxsYmFjayByZXR1cm5lZCB0cnVlLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGZpbHRlck1hcChtYXAsIGNhbGxiYWNrKSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xyXG5cclxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXApIHtcclxuICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5KSkge1xyXG4gICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxudmFyIFJlY29pbF9maWx0ZXJNYXAgPSBmaWx0ZXJNYXA7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBhIHNldCBjb250YWluaW5nIGFsbCBvZiB0aGUgdmFsdWVzIGZyb20gdGhlIG9yaWdpbmFsIHNldCB3aGVyZVxyXG4gKiB0aGUgZ2l2ZW4gY2FsbGJhY2sgcmV0dXJuZWQgdHJ1ZS5cclxuICovXHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJTZXQoc2V0LCBjYWxsYmFjaykge1xyXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcclxuXHJcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBzZXQpIHtcclxuICAgIGlmIChjYWxsYmFjayh2YWx1ZSkpIHtcclxuICAgICAgcmVzdWx0LmFkZCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG52YXIgUmVjb2lsX2ZpbHRlclNldCA9IGZpbHRlclNldDtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcblxyXG5mdW5jdGlvbiBtZXJnZU1hcHMoLi4ubWFwcykge1xyXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBpdGVyYXRvciA9IG1hcHNbaV0ua2V5cygpO1xyXG4gICAgbGV0IG5leHRLZXk7XHJcblxyXG4gICAgd2hpbGUgKCEobmV4dEtleSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xyXG4gICAgICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1jYWxsXSAtIG1hcC9pdGVyYXRvciBrbm93cyBub3RoaW5nIGFib3V0IGZsb3cgdHlwZXNcclxuICAgICAgcmVzdWx0LnNldChuZXh0S2V5LnZhbHVlLCBtYXBzW2ldLmdldChuZXh0S2V5LnZhbHVlKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG52YXIgUmVjb2lsX21lcmdlTWFwcyA9IG1lcmdlTWFwcztcclxuXHJcbmNvbnN0IHtcclxuICBiYXRjaFVwZGF0ZXM6IGJhdGNoVXBkYXRlcyQzXHJcbn0gPSBSZWNvaWxfQmF0Y2hpbmc7XHJcblxyXG5jb25zdCB7XHJcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQzLFxyXG4gIGdldE5vZGU6IGdldE5vZGUkNCxcclxuICBub2Rlczogbm9kZXMkMVxyXG59ID0gUmVjb2lsX05vZGU7XHJcblxyXG5jb25zdCB7XHJcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDNcclxufSA9IFJlY29pbF9SZWNvaWxSb290O1xyXG5cclxuY29uc3Qge1xyXG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkNCxcclxuICBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlOiBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlJDFcclxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcclxuXHJcbmNvbnN0IHtcclxuICBTVVNQRU5TRV9USU1FT1VUX01TOiBTVVNQRU5TRV9USU1FT1VUX01TJDJcclxufSA9IFJlY29pbF9SZXRlbnRpb247XHJcblxyXG5jb25zdCB7XHJcbiAgY2xvbmVTbmFwc2hvdDogY2xvbmVTbmFwc2hvdCQxXHJcbn0gPSBSZWNvaWxfU25hcHNob3QkMTtcclxuXHJcbmNvbnN0IHtcclxuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2skMixcclxuICB1c2VFZmZlY3Q6IHVzZUVmZmVjdCQ0LFxyXG4gIHVzZVJlZjogdXNlUmVmJDUsXHJcbiAgdXNlU3RhdGU6IHVzZVN0YXRlJDJcclxufSA9IHJlYWN0O1xyXG5cclxuY29uc3Qge1xyXG4gIGlzU1NSOiBpc1NTUiQzXHJcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIHVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uKGNhbGxiYWNrKSB7XHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQzKCk7XHJcbiAgdXNlRWZmZWN0JDQoKCkgPT4ge1xyXG4gICAgY29uc3Qgc3ViID0gc3RvcmVSZWYuY3VycmVudC5zdWJzY3JpYmVUb1RyYW5zYWN0aW9ucyhjYWxsYmFjayk7XHJcbiAgICByZXR1cm4gc3ViLnJlbGVhc2U7XHJcbiAgfSwgW2NhbGxiYWNrLCBzdG9yZVJlZl0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBleHRlcm5hbGx5VmlzaWJsZUF0b21WYWx1ZXNJblN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgYXRvbVZhbHVlcyA9IHN0YXRlLmF0b21WYWx1ZXMudG9NYXAoKTtcclxuICBjb25zdCBwZXJzaXN0ZWRBdG9tQ29udGVudHNWYWx1ZXMgPSBSZWNvaWxfbWFwTWFwKFJlY29pbF9maWx0ZXJNYXAoYXRvbVZhbHVlcywgKHYsIGspID0+IHtcclxuICAgIGNvbnN0IG5vZGUgPSBnZXROb2RlJDQoayk7XHJcbiAgICBjb25zdCBwZXJzaXN0ZW5jZSA9IG5vZGUucGVyc2lzdGVuY2VfVU5TVEFCTEU7XHJcbiAgICByZXR1cm4gcGVyc2lzdGVuY2UgIT0gbnVsbCAmJiBwZXJzaXN0ZW5jZS50eXBlICE9PSAnbm9uZScgJiYgdi5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJztcclxuICB9KSwgdiA9PiB2LmNvbnRlbnRzKTsgLy8gTWVyZ2UgaW4gbm9udmFsaWRhdGVkIGF0b21zOyB3ZSBtYXkgbm90IGhhdmUgZGVmcyBmb3IgdGhlbSBidXQgdGhleSB3aWxsXHJcbiAgLy8gYWxsIGhhdmUgcGVyc2lzdGVuY2Ugb24gb3IgdGhleSB3b3VsZG4ndCBiZSB0aGVyZSBpbiB0aGUgZmlyc3QgcGxhY2UuXHJcblxyXG4gIHJldHVybiBSZWNvaWxfbWVyZ2VNYXBzKHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLnRvTWFwKCksIHBlcnNpc3RlZEF0b21Db250ZW50c1ZhbHVlcyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gIENhbGxzIHRoZSBnaXZlbiBjYWxsYmFjayBhZnRlciBhbnkgYXRvbXMgaGF2ZSBiZWVuIG1vZGlmaWVkIGFuZCB0aGUgY29uc2VxdWVudFxyXG4gIGNvbXBvbmVudCByZS1yZW5kZXJzIGhhdmUgYmVlbiBjb21taXR0ZWQuIFRoaXMgaXMgaW50ZW5kZWQgZm9yIHBlcnNpc3RpbmdcclxuICB0aGUgdmFsdWVzIG9mIHRoZSBhdG9tcyB0byBzdG9yYWdlLiBUaGUgc3RvcmVkIHZhbHVlcyBjYW4gdGhlbiBiZSByZXN0b3JlZFxyXG4gIHVzaW5nIHRoZSB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMgaG9vay5cclxuXHJcbiAgVGhlIGNhbGxiYWNrIHJlY2VpdmVzIHRoZSBmb2xsb3dpbmcgaW5mbzpcclxuXHJcbiAgYXRvbVZhbHVlczogVGhlIGN1cnJlbnQgdmFsdWUgb2YgZXZlcnkgYXRvbSB0aGF0IGlzIGJvdGggcGVyc2lzdGFibGUgKHBlcnNpc3RlbmNlXHJcbiAgICAgICAgICAgICAgdHlwZSBub3Qgc2V0IHRvICdub25lJykgYW5kIHdob3NlIHZhbHVlIGlzIGF2YWlsYWJsZSAobm90IGluIGFuXHJcbiAgICAgICAgICAgICAgZXJyb3Igb3IgbG9hZGluZyBzdGF0ZSkuXHJcblxyXG4gIHByZXZpb3VzQXRvbVZhbHVlczogVGhlIHZhbHVlIG9mIGV2ZXJ5IHBlcnNpc3RhYmxlIGFuZCBhdmFpbGFibGUgYXRvbSBiZWZvcmVcclxuICAgICAgICAgICAgICAgdGhlIHRyYW5zYWN0aW9uIGJlZ2FuLlxyXG5cclxuICBhdG9tSW5mbzogQSBtYXAgY29udGFpbmluZyB0aGUgcGVyc2lzdGVuY2Ugc2V0dGluZ3MgZm9yIGVhY2ggYXRvbS4gRXZlcnkga2V5XHJcbiAgICAgICAgICAgIHRoYXQgZXhpc3RzIGluIGF0b21WYWx1ZXMgd2lsbCBhbHNvIGV4aXN0IGluIGF0b21JbmZvLlxyXG5cclxuICBtb2RpZmllZEF0b21zOiBUaGUgc2V0IG9mIGF0b21zIHRoYXQgd2VyZSB3cml0dGVuIHRvIGR1cmluZyB0aGUgdHJhbnNhY3Rpb24uXHJcblxyXG4gIHRyYW5zYWN0aW9uTWV0YWRhdGE6IEFyYml0cmFyeSBpbmZvcm1hdGlvbiB0aGF0IHdhcyBhZGRlZCB2aWEgdGhlXHJcbiAgICAgICAgICB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMgaG9vay4gVXNlZnVsIGZvciBpZ25vcmluZyB0aGUgdXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzXHJcbiAgICAgICAgICB0cmFuc2FjdGlvbiwgdG8gYXZvaWQgbG9vcHMuXHJcbiovXHJcbmZ1bmN0aW9uIHVzZVRyYW5zYWN0aW9uT2JzZXJ2YXRpb25fREVQUkVDQVRFRChjYWxsYmFjaykge1xyXG4gIHVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uKHVzZUNhbGxiYWNrJDIoc3RvcmUgPT4ge1xyXG4gICAgbGV0IHByZXZpb3VzVHJlZSA9IHN0b3JlLmdldFN0YXRlKCkucHJldmlvdXNUcmVlO1xyXG4gICAgY29uc3QgY3VycmVudFRyZWUgPSBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xyXG5cclxuICAgIGlmICghcHJldmlvdXNUcmVlKSB7XHJcbiAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignVHJhbnNhY3Rpb24gc3Vic2NyaWJlcnMgbm90aWZpZWQgd2l0aG91dCBhIHByZXZpb3VzIHRyZWUgYmVpbmcgcHJlc2VudCAtLSB0aGlzIGlzIGEgYnVnIGluIFJlY29pbCcpO1xyXG4gICAgICBwcmV2aW91c1RyZWUgPSBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlOyAvLyBhdHRlbXB0IHRvIHRydW5kbGUgb25cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhdG9tVmFsdWVzID0gZXh0ZXJuYWxseVZpc2libGVBdG9tVmFsdWVzSW5TdGF0ZShjdXJyZW50VHJlZSk7XHJcbiAgICBjb25zdCBwcmV2aW91c0F0b21WYWx1ZXMgPSBleHRlcm5hbGx5VmlzaWJsZUF0b21WYWx1ZXNJblN0YXRlKHByZXZpb3VzVHJlZSk7XHJcbiAgICBjb25zdCBhdG9tSW5mbyA9IFJlY29pbF9tYXBNYXAobm9kZXMkMSwgbm9kZSA9PiB7XHJcbiAgICAgIHZhciBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMsIF9ub2RlJHBlcnNpc3RlbmNlX1VOUzIsIF9ub2RlJHBlcnNpc3RlbmNlX1VOUzMsIF9ub2RlJHBlcnNpc3RlbmNlX1VOUzQ7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHBlcnNpc3RlbmNlX1VOU1RBQkxFOiB7XHJcbiAgICAgICAgICB0eXBlOiAoX25vZGUkcGVyc2lzdGVuY2VfVU5TID0gKF9ub2RlJHBlcnNpc3RlbmNlX1VOUzIgPSBub2RlLnBlcnNpc3RlbmNlX1VOU1RBQkxFKSA9PT0gbnVsbCB8fCBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMyLnR5cGUpICE9PSBudWxsICYmIF9ub2RlJHBlcnNpc3RlbmNlX1VOUyAhPT0gdm9pZCAwID8gX25vZGUkcGVyc2lzdGVuY2VfVU5TIDogJ25vbmUnLFxyXG4gICAgICAgICAgYmFja0J1dHRvbjogKF9ub2RlJHBlcnNpc3RlbmNlX1VOUzMgPSAoX25vZGUkcGVyc2lzdGVuY2VfVU5TNCA9IG5vZGUucGVyc2lzdGVuY2VfVU5TVEFCTEUpID09PSBudWxsIHx8IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzQuYmFja0J1dHRvbikgIT09IG51bGwgJiYgX25vZGUkcGVyc2lzdGVuY2VfVU5TMyAhPT0gdm9pZCAwID8gX25vZGUkcGVyc2lzdGVuY2VfVU5TMyA6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSk7IC8vIEZpbHRlciBvbiBleGlzdGFuY2UgaW4gYXRvbVZhbHVlcyBzbyB0aGF0IGV4dGVybmFsbHktdmlzaWJsZSBydWxlc1xyXG4gICAgLy8gYXJlIGFsc28gYXBwbGllZCB0byBtb2RpZmllZCBhdG9tcyAoc3BlY2lmaWNhbGx5IGV4Y2x1ZGUgc2VsZWN0b3JzKTpcclxuXHJcbiAgICBjb25zdCBtb2RpZmllZEF0b21zID0gUmVjb2lsX2ZpbHRlclNldChjdXJyZW50VHJlZS5kaXJ0eUF0b21zLCBrID0+IGF0b21WYWx1ZXMuaGFzKGspIHx8IHByZXZpb3VzQXRvbVZhbHVlcy5oYXMoaykpO1xyXG4gICAgY2FsbGJhY2soe1xyXG4gICAgICBhdG9tVmFsdWVzLFxyXG4gICAgICBwcmV2aW91c0F0b21WYWx1ZXMsXHJcbiAgICAgIGF0b21JbmZvLFxyXG4gICAgICBtb2RpZmllZEF0b21zLFxyXG4gICAgICB0cmFuc2FjdGlvbk1ldGFkYXRhOiB7IC4uLmN1cnJlbnRUcmVlLnRyYW5zYWN0aW9uTWV0YWRhdGFcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSwgW2NhbGxiYWNrXSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XHJcbiAgdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb24odXNlQ2FsbGJhY2skMihzdG9yZSA9PiB7XHJcbiAgICBjb25zdCBzbmFwc2hvdCA9IGNsb25lU25hcHNob3QkMShzdG9yZSwgJ2xhdGVzdCcpO1xyXG4gICAgY29uc3QgcHJldmlvdXNTbmFwc2hvdCA9IGNsb25lU25hcHNob3QkMShzdG9yZSwgJ3ByZXZpb3VzJyk7XHJcbiAgICBjYWxsYmFjayh7XHJcbiAgICAgIHNuYXBzaG90LFxyXG4gICAgICBwcmV2aW91c1NuYXBzaG90XHJcbiAgICB9KTtcclxuICB9LCBbY2FsbGJhY2tdKSk7XHJcbn0gLy8gUmV0dXJuIGEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHN1YnNjcmliZSB0byBhbGwgc3RhdGUgY2hhbmdlc1xyXG5cclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbFNuYXBzaG90KCkge1xyXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMygpO1xyXG4gIGNvbnN0IFtzbmFwc2hvdCwgc2V0U25hcHNob3RdID0gdXNlU3RhdGUkMigoKSA9PiBjbG9uZVNuYXBzaG90JDEoc3RvcmVSZWYuY3VycmVudCkpO1xyXG4gIGNvbnN0IHByZXZpb3VzU25hcHNob3QgPSBSZWNvaWxfdXNlUHJldmlvdXMoc25hcHNob3QpO1xyXG4gIGNvbnN0IHRpbWVvdXRJRCA9IHVzZVJlZiQ1KCk7XHJcbiAgY29uc3QgcmVsZWFzZVJlZiA9IHVzZVJlZiQ1KCk7XHJcbiAgdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb24odXNlQ2FsbGJhY2skMihzdG9yZSA9PiBzZXRTbmFwc2hvdChjbG9uZVNuYXBzaG90JDEoc3RvcmUpKSwgW10pKTsgLy8gUmV0YWluIHNuYXBzaG90IGZvciBkdXJhdGlvbiBjb21wb25lbnQgaXMgbW91bnRlZFxyXG5cclxuICB1c2VFZmZlY3QkNCgoKSA9PiB7XHJcbiAgICBjb25zdCByZWxlYXNlID0gc25hcHNob3QucmV0YWluKCk7IC8vIFJlbGVhc2UgdGhlIHJldGFpbiBmcm9tIHRoZSByZW5kZXJpbmcgY2FsbFxyXG5cclxuICAgIGlmICh0aW1lb3V0SUQuY3VycmVudCAmJiAhaXNTU1IkMykge1xyXG4gICAgICB2YXIgX3JlbGVhc2VSZWYkY3VycmVudDtcclxuXHJcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElELmN1cnJlbnQpO1xyXG4gICAgICB0aW1lb3V0SUQuY3VycmVudCA9IG51bGw7XHJcbiAgICAgIChfcmVsZWFzZVJlZiRjdXJyZW50ID0gcmVsZWFzZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfcmVsZWFzZVJlZiRjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsZWFzZVJlZiRjdXJyZW50LmNhbGwocmVsZWFzZVJlZik7XHJcbiAgICAgIHJlbGVhc2VSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgLy8gRGVmZXIgdGhlIHJlbGVhc2UuICBJZiBcIkZhc3QgUmVmcmVzaFwiXCIgaXMgdXNlZCB0aGVuIHRoZSBjb21wb25lbnQgbWF5XHJcbiAgICAgIC8vIHJlLXJlbmRlciB3aXRoIHRoZSBzYW1lIHN0YXRlLiAgVGhlIHByZXZpb3VzIGNsZWFudXAgd2lsbCB0aGVuIHJ1biBhbmRcclxuICAgICAgLy8gdGhlbiB0aGUgbmV3IGVmZmVjdCB3aWxsIHJ1bi4gV2UgZG9uJ3Qgd2FudCB0aGUgc25hcHNob3QgdG8gYmUgcmVsZWFzZWRcclxuICAgICAgLy8gYnkgdGhhdCBjbGVhbnVwIGJlZm9yZSB0aGUgbmV3IGVmZmVjdCBoYXMgYSBjaGFuY2UgdG8gcmV0YWluIGl0IGFnYWluLlxyXG4gICAgICAvLyBVc2UgdGltZW91dCBvZiAxMCB0byB3b3JrYXJvdW5kIEZpcmVmb3ggaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2V4cGVyaW1lbnRhbC9SZWNvaWwvaXNzdWVzLzE5MzZcclxuICAgICAgd2luZG93LnNldFRpbWVvdXQocmVsZWFzZSwgMTApO1xyXG4gICAgfTtcclxuICB9LCBbc25hcHNob3RdKTsgLy8gUmV0YWluIHNuYXBzaG90IHVudGlsIGFib3ZlIGVmZmVjdCBpcyBydW4uXHJcbiAgLy8gUmVsZWFzZSBhZnRlciBhIHRocmVzaG9sZCBpbiBjYXNlIGNvbXBvbmVudCBpcyBzdXNwZW5kZWQuXHJcblxyXG4gIGlmIChwcmV2aW91c1NuYXBzaG90ICE9PSBzbmFwc2hvdCAmJiAhaXNTU1IkMykge1xyXG4gICAgLy8gUmVsZWFzZSB0aGUgcHJldmlvdXMgc25hcHNob3RcclxuICAgIGlmICh0aW1lb3V0SUQuY3VycmVudCkge1xyXG4gICAgICB2YXIgX3JlbGVhc2VSZWYkY3VycmVudDI7XHJcblxyXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcclxuICAgICAgdGltZW91dElELmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAoX3JlbGVhc2VSZWYkY3VycmVudDIgPSByZWxlYXNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9yZWxlYXNlUmVmJGN1cnJlbnQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsZWFzZVJlZiRjdXJyZW50Mi5jYWxsKHJlbGVhc2VSZWYpO1xyXG4gICAgICByZWxlYXNlUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbGVhc2VSZWYuY3VycmVudCA9IHNuYXBzaG90LnJldGFpbigpO1xyXG4gICAgdGltZW91dElELmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHZhciBfcmVsZWFzZVJlZiRjdXJyZW50MztcclxuXHJcbiAgICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgKF9yZWxlYXNlUmVmJGN1cnJlbnQzID0gcmVsZWFzZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfcmVsZWFzZVJlZiRjdXJyZW50MyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbGVhc2VSZWYkY3VycmVudDMuY2FsbChyZWxlYXNlUmVmKTtcclxuICAgICAgcmVsZWFzZVJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgIH0sIFNVU1BFTlNFX1RJTUVPVVRfTVMkMik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc25hcHNob3Q7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdvdG9TbmFwc2hvdChzdG9yZSwgc25hcHNob3QpIHtcclxuICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWU7XHJcblxyXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG4gIGNvbnN0IHByZXYgPSAoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xyXG4gIGNvbnN0IG5leHQgPSBzbmFwc2hvdC5nZXRTdG9yZV9JTlRFUk5BTCgpLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XHJcbiAgYmF0Y2hVcGRhdGVzJDMoKCkgPT4ge1xyXG4gICAgY29uc3Qga2V5c1RvVXBkYXRlID0gbmV3IFNldCgpO1xyXG5cclxuICAgIGZvciAoY29uc3Qga2V5cyBvZiBbcHJldi5hdG9tVmFsdWVzLmtleXMoKSwgbmV4dC5hdG9tVmFsdWVzLmtleXMoKV0pIHtcclxuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xyXG4gICAgICAgIHZhciBfcHJldiRhdG9tVmFsdWVzJGdldCwgX25leHQkYXRvbVZhbHVlcyRnZXQ7XHJcblxyXG4gICAgICAgIGlmICgoKF9wcmV2JGF0b21WYWx1ZXMkZ2V0ID0gcHJldi5hdG9tVmFsdWVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfcHJldiRhdG9tVmFsdWVzJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ByZXYkYXRvbVZhbHVlcyRnZXQuY29udGVudHMpICE9PSAoKF9uZXh0JGF0b21WYWx1ZXMkZ2V0ID0gbmV4dC5hdG9tVmFsdWVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfbmV4dCRhdG9tVmFsdWVzJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25leHQkYXRvbVZhbHVlcyRnZXQuY29udGVudHMpICYmIGdldE5vZGUkNChrZXkpLnNob3VsZFJlc3RvcmVGcm9tU25hcHNob3RzKSB7XHJcbiAgICAgICAgICBrZXlzVG9VcGRhdGUuYWRkKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAga2V5c1RvVXBkYXRlLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQxKHN0b3JlLCBuZXcgQWJzdHJhY3RSZWNvaWxWYWx1ZSQ0KGtleSksIG5leHQuYXRvbVZhbHVlcy5oYXMoa2V5KSA/IFJlY29pbF9udWxsdGhyb3dzKG5leHQuYXRvbVZhbHVlcy5nZXQoa2V5KSkgOiBERUZBVUxUX1ZBTFVFJDMpO1xyXG4gICAgfSk7XHJcbiAgICBzdG9yZS5yZXBsYWNlU3RhdGUoc3RhdGUgPT4gKHsgLi4uc3RhdGUsXHJcbiAgICAgIHN0YXRlSUQ6IHNuYXBzaG90LmdldElEKClcclxuICAgIH0pKTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXNlR290b1JlY29pbFNuYXBzaG90KCkge1xyXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMygpO1xyXG4gIHJldHVybiB1c2VDYWxsYmFjayQyKHNuYXBzaG90ID0+IGdvdG9TbmFwc2hvdChzdG9yZVJlZi5jdXJyZW50LCBzbmFwc2hvdCksIFtzdG9yZVJlZl0pO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX1NuYXBzaG90SG9va3MgPSB7XHJcbiAgdXNlUmVjb2lsU25hcHNob3QsXHJcbiAgZ290b1NuYXBzaG90LFxyXG4gIHVzZUdvdG9SZWNvaWxTbmFwc2hvdCxcclxuICB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyLFxyXG4gIHVzZVRyYW5zYWN0aW9uT2JzZXJ2YXRpb25fREVQUkVDQVRFRCxcclxuICB1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvbl9ERVBSRUNBVEVEOiB1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvblxyXG59O1xyXG5cclxuY29uc3Qge1xyXG4gIHBlZWtOb2RlSW5mbzogcGVla05vZGVJbmZvJDJcclxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcclxuXHJcbmNvbnN0IHtcclxuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkNFxyXG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XHJcblxyXG5mdW5jdGlvbiB1c2VHZXRSZWNvaWxWYWx1ZUluZm8oKSB7XHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQ0KCk7XHJcbiAgcmV0dXJuICh7XHJcbiAgICBrZXlcclxuICB9KSA9PiBwZWVrTm9kZUluZm8kMihzdG9yZVJlZi5jdXJyZW50LCBzdG9yZVJlZi5jdXJyZW50LmdldFN0YXRlKCkuY3VycmVudFRyZWUsIGtleSk7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfdXNlR2V0UmVjb2lsVmFsdWVJbmZvID0gdXNlR2V0UmVjb2lsVmFsdWVJbmZvO1xyXG5cclxuY29uc3Qge1xyXG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDRcclxufSA9IFJlY29pbF9SZWFjdE1vZGU7XHJcblxyXG5jb25zdCB7XHJcbiAgUmVjb2lsUm9vdDogUmVjb2lsUm9vdCQxLFxyXG4gIHVzZVN0b3JlUmVmOiB1c2VTdG9yZVJlZiQ1XHJcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcclxuXHJcblxyXG5cclxuY29uc3Qge1xyXG4gIHVzZU1lbW86IHVzZU1lbW8kMlxyXG59ID0gcmVhY3Q7XHJcblxyXG5mdW5jdGlvbiB1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzKCkge1xyXG4gIC8vIFRoZSB0ZXN0IGZhaWxzIHdoZW4gdXNpbmcgdXNlTXV0YWJsZVNvdXJjZSgpLCBidXQgb25seSBpZiBhY3QoKSBpcyB1c2VkXHJcbiAgLy8gZm9yIHRoZSBuZXN0ZWQgcm9vdC4gIFNvLCB0aGlzIG1heSBvbmx5IGJlIGEgdGVzdGluZyBlbnZpcm9ubWVudCBpc3N1ZS5cclxuICBpZiAocmVhY3RNb2RlJDQoKS5tb2RlID09PSAnTVVUQUJMRV9TT1VSQ0UnKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L25vLWNvbnNvbGVcclxuICAgIGNvbnNvbGUud2FybignV2FybmluZzogVGhlcmUgYXJlIGtub3duIGlzc3VlcyB1c2luZyB1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzKCkgaW4gcmVjb2lsX211dGFibGVfc291cmNlIHJlbmRlcmluZyBtb2RlLiAgUGxlYXNlIGNvbnNpZGVyIHVwZ3JhZGluZyB0byByZWNvaWxfc3luY19leHRlcm5hbF9zdG9yZSBtb2RlLicpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZVJlZiQ1KCkuY3VycmVudDtcclxuICByZXR1cm4gdXNlTWVtbyQyKCgpID0+IHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcclxuICAgIGZ1bmN0aW9uIFJlY29pbEJyaWRnZSh7XHJcbiAgICAgIGNoaWxkcmVuXHJcbiAgICB9KSB7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChSZWNvaWxSb290JDEsIHtcclxuICAgICAgICBzdG9yZV9JTlRFUk5BTDogc3RvcmVcclxuICAgICAgfSwgY2hpbGRyZW4pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBSZWNvaWxCcmlkZ2U7XHJcbiAgfSwgW3N0b3JlXSk7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cyA9IHVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHM7XHJcblxyXG5jb25zdCB7XHJcbiAgbG9hZGFibGVXaXRoVmFsdWU6IGxvYWRhYmxlV2l0aFZhbHVlJDFcclxufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xyXG5cclxuY29uc3Qge1xyXG4gIGluaXRpYWxpemVOb2RlOiBpbml0aWFsaXplTm9kZSQzXHJcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XHJcblxyXG5jb25zdCB7XHJcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQ0LFxyXG4gIGdldE5vZGU6IGdldE5vZGUkNVxyXG59ID0gUmVjb2lsX05vZGU7XHJcblxyXG5jb25zdCB7XHJcbiAgY29weVRyZWVTdGF0ZTogY29weVRyZWVTdGF0ZSQxLFxyXG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZTogZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDMsXHJcbiAgaW52YWxpZGF0ZURvd25zdHJlYW1zOiBpbnZhbGlkYXRlRG93bnN0cmVhbXMkMSxcclxuICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGU6IHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZSQxXHJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGlzQXRvbShyZWNvaWxWYWx1ZSkge1xyXG4gIHJldHVybiBnZXROb2RlJDUocmVjb2lsVmFsdWUua2V5KS5ub2RlVHlwZSA9PT0gJ2F0b20nO1xyXG59XHJcblxyXG5jbGFzcyBUcmFuc2FjdGlvbkludGVyZmFjZUltcGwge1xyXG4gIGNvbnN0cnVjdG9yKHN0b3JlLCB0cmVlU3RhdGUpIHtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdG9yZVwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90cmVlU3RhdGVcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2hhbmdlc1wiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFwiLCByZWNvaWxWYWx1ZSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLl9jaGFuZ2VzLmhhcyhyZWNvaWxWYWx1ZS5rZXkpKSB7XHJcbiAgICAgICAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VzLmdldChyZWNvaWxWYWx1ZS5rZXkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWlzQXRvbShyZWNvaWxWYWx1ZSkpIHtcclxuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdSZWFkaW5nIHNlbGVjdG9ycyB3aXRoaW4gYXRvbWljVXBkYXRlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbG9hZGFibGUgPSBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMyh0aGlzLl9zdG9yZSwgcmVjb2lsVmFsdWUsIHRoaXMuX3RyZWVTdGF0ZSk7XHJcblxyXG4gICAgICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScpIHtcclxuICAgICAgICByZXR1cm4gbG9hZGFibGUuY29udGVudHM7XHJcbiAgICAgIH0gZWxzZSBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNFcnJvcicpIHtcclxuICAgICAgICB0aHJvdyBsb2FkYWJsZS5jb250ZW50cztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKGBFeHBlY3RlZCBSZWNvaWwgYXRvbSAke3JlY29pbFZhbHVlLmtleX0gdG8gaGF2ZSBhIHZhbHVlLCBidXQgaXQgaXMgaW4gYSBsb2FkaW5nIHN0YXRlLmApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRcIiwgKHJlY29pbFN0YXRlLCB2YWx1ZU9yVXBkYXRlcikgPT4ge1xyXG4gICAgICBpZiAoIWlzQXRvbShyZWNvaWxTdGF0ZSkpIHtcclxuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdTZXR0aW5nIHNlbGVjdG9ycyB3aXRoaW4gYXRvbWljVXBkYXRlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZU9yVXBkYXRlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmdldChyZWNvaWxTdGF0ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2NoYW5nZXMuc2V0KHJlY29pbFN0YXRlLmtleSwgdmFsdWVPclVwZGF0ZXIoY3VycmVudCkpOyAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhdG9tIGFuZCBydW4gZWZmZWN0cyBpZiBub3QgaW5pdGlhbGl6ZWQgeWV0XHJcbiAgICAgICAgaW5pdGlhbGl6ZU5vZGUkMyh0aGlzLl9zdG9yZSwgcmVjb2lsU3RhdGUua2V5LCAnc2V0Jyk7XHJcblxyXG4gICAgICAgIHRoaXMuX2NoYW5nZXMuc2V0KHJlY29pbFN0YXRlLmtleSwgdmFsdWVPclVwZGF0ZXIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNldFwiLCByZWNvaWxTdGF0ZSA9PiB7XHJcbiAgICAgIHRoaXMuc2V0KHJlY29pbFN0YXRlLCBERUZBVUxUX1ZBTFVFJDQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fc3RvcmUgPSBzdG9yZTtcclxuICAgIHRoaXMuX3RyZWVTdGF0ZSA9IHRyZWVTdGF0ZTtcclxuICAgIHRoaXMuX2NoYW5nZXMgPSBuZXcgTWFwKCk7XHJcbiAgfSAvLyBBbGxvdyBkZXN0cnVjdGluZ1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvZXh0cmEtYXJyb3ctaW5pdGlhbGl6ZXJcclxuXHJcblxyXG4gIG5ld1RyZWVTdGF0ZV9JTlRFUk5BTCgpIHtcclxuICAgIGlmICh0aGlzLl9jaGFuZ2VzLnNpemUgPT09IDApIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3RyZWVTdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IGNvcHlUcmVlU3RhdGUkMSh0aGlzLl90cmVlU3RhdGUpO1xyXG5cclxuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHRoaXMuX2NoYW5nZXMpIHtcclxuICAgICAgd3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlJDEobmV3U3RhdGUsIGssIGxvYWRhYmxlV2l0aFZhbHVlJDEodikpO1xyXG4gICAgfVxyXG5cclxuICAgIGludmFsaWRhdGVEb3duc3RyZWFtcyQxKHRoaXMuX3N0b3JlLCBuZXdTdGF0ZSk7XHJcbiAgICByZXR1cm4gbmV3U3RhdGU7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gYXRvbWljVXBkYXRlcihzdG9yZSkge1xyXG4gIHJldHVybiBmbiA9PiB7XHJcbiAgICBzdG9yZS5yZXBsYWNlU3RhdGUodHJlZVN0YXRlID0+IHtcclxuICAgICAgY29uc3QgY2hhbmdlc2V0ID0gbmV3IFRyYW5zYWN0aW9uSW50ZXJmYWNlSW1wbChzdG9yZSwgdHJlZVN0YXRlKTtcclxuICAgICAgZm4oY2hhbmdlc2V0KTtcclxuICAgICAgcmV0dXJuIGNoYW5nZXNldC5uZXdUcmVlU3RhdGVfSU5URVJOQUwoKTtcclxuICAgIH0pO1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfQXRvbWljVXBkYXRlcyA9IHtcclxuICBhdG9taWNVcGRhdGVyXHJcbn07XHJcblxyXG52YXIgUmVjb2lsX0F0b21pY1VwZGF0ZXNfMSA9IFJlY29pbF9BdG9taWNVcGRhdGVzLmF0b21pY1VwZGF0ZXI7XHJcblxyXG52YXIgUmVjb2lsX0F0b21pY1VwZGF0ZXMkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgYXRvbWljVXBkYXRlcjogUmVjb2lsX0F0b21pY1VwZGF0ZXNfMVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcblxyXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcbiAgaWYgKCFjb25kaXRpb24pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBpbnZhcmlhbnRfMSA9IGludmFyaWFudDtcclxuXHJcbi8vIEBvc3Mtb25seVxyXG5cclxuXHJcbnZhciBSZWNvaWxfaW52YXJpYW50ID0gaW52YXJpYW50XzE7XHJcblxyXG5jb25zdCB7XHJcbiAgYXRvbWljVXBkYXRlcjogYXRvbWljVXBkYXRlciQxXHJcbn0gPSBSZWNvaWxfQXRvbWljVXBkYXRlcyQxO1xyXG5cclxuY29uc3Qge1xyXG4gIGJhdGNoVXBkYXRlczogYmF0Y2hVcGRhdGVzJDRcclxufSA9IFJlY29pbF9CYXRjaGluZztcclxuXHJcbmNvbnN0IHtcclxuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDVcclxufSA9IFJlY29pbF9Ob2RlO1xyXG5cclxuY29uc3Qge1xyXG4gIHVzZVN0b3JlUmVmOiB1c2VTdG9yZVJlZiQ2XHJcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcclxuXHJcbmNvbnN0IHtcclxuICByZWZyZXNoUmVjb2lsVmFsdWU6IHJlZnJlc2hSZWNvaWxWYWx1ZSQxLFxyXG4gIHNldFJlY29pbFZhbHVlOiBzZXRSZWNvaWxWYWx1ZSQzXHJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XHJcblxyXG5jb25zdCB7XHJcbiAgY2xvbmVTbmFwc2hvdDogY2xvbmVTbmFwc2hvdCQyXHJcbn0gPSBSZWNvaWxfU25hcHNob3QkMTtcclxuXHJcbmNvbnN0IHtcclxuICBnb3RvU25hcHNob3Q6IGdvdG9TbmFwc2hvdCQxXHJcbn0gPSBSZWNvaWxfU25hcHNob3RIb29rcztcclxuXHJcbmNvbnN0IHtcclxuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2skM1xyXG59ID0gcmVhY3Q7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIFNlbnRpbmVsIHt9XHJcblxyXG5jb25zdCBTRU5USU5FTCA9IG5ldyBTZW50aW5lbCgpO1xyXG5cclxuZnVuY3Rpb24gcmVjb2lsQ2FsbGJhY2soc3RvcmUsIGZuLCBhcmdzLCBleHRyYUludGVyZmFjZSkge1xyXG4gIGxldCByZXQgPSBTRU5USU5FTDtcclxuICBsZXQgcmVsZWFzZVNuYXBzaG90O1xyXG4gIGJhdGNoVXBkYXRlcyQ0KCgpID0+IHtcclxuICAgIGNvbnN0IGVyck1zZyA9ICd1c2VSZWNvaWxDYWxsYmFjaygpIGV4cGVjdHMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbjogJyArICdpdCBhY2NlcHRzIGEgZnVuY3Rpb24gb2YgdGhlIHR5cGUgKFJlY29pbEludGVyZmFjZSkgPT4gKEFyZ3MpID0+IFJldHVyblR5cGUgJyArICdhbmQgcmV0dXJucyBhIGNhbGxiYWNrIGZ1bmN0aW9uIChBcmdzKSA9PiBSZXR1cm5UeXBlLCB3aGVyZSBSZWNvaWxJbnRlcmZhY2UgaXMgJyArICdhbiBvYmplY3Qge3NuYXBzaG90LCBzZXQsIC4uLn0gYW5kIEFyZ3MgYW5kIFJldHVyblR5cGUgYXJlIHRoZSBhcmd1bWVudCBhbmQgcmV0dXJuICcgKyAndHlwZXMgb2YgdGhlIGNhbGxiYWNrIHlvdSB3YW50IHRvIGNyZWF0ZS4gIFBsZWFzZSBzZWUgdGhlIGRvY3MgJyArICdhdCByZWNvaWxqcy5vcmcgZm9yIGRldGFpbHMuJztcclxuXHJcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IFJlY29pbF9lcnIoZXJyTXNnKTtcclxuICAgIH0gLy8gQ2xvbmUgdGhlIHNuYXBzaG90IGxhemlseSB0byBhdm9pZCBvdmVyaGVhZCBpZiB0aGUgY2FsbGJhY2sgZG9lcyBub3QgdXNlIGl0LlxyXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgbWVhbnMgdGhlIHNuYXBzaG90IG1heSByZXByZXNlbnQgbGF0ZXIgc3RhdGUgZnJvbSB3aGVuXHJcbiAgICAvLyB0aGUgY2FsbGJhY2sgd2FzIGNhbGxlZCBpZiBpdCBmaXJzdCBhY2Nlc3NlcyB0aGUgc25hcHNob3QgYXN5bmNocm9ub3VzbHkuXHJcblxyXG5cclxuICAgIGNvbnN0IGNhbGxiYWNrSW50ZXJmYWNlID0gUmVjb2lsX2xhenlQcm94eSh7IC4uLihleHRyYUludGVyZmFjZSAhPT0gbnVsbCAmJiBleHRyYUludGVyZmFjZSAhPT0gdm9pZCAwID8gZXh0cmFJbnRlcmZhY2UgOiB7fSksXHJcbiAgICAgIC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxyXG4gICAgICBzZXQ6IChub2RlLCBuZXdWYWx1ZSkgPT4gc2V0UmVjb2lsVmFsdWUkMyhzdG9yZSwgbm9kZSwgbmV3VmFsdWUpLFxyXG4gICAgICByZXNldDogbm9kZSA9PiBzZXRSZWNvaWxWYWx1ZSQzKHN0b3JlLCBub2RlLCBERUZBVUxUX1ZBTFVFJDUpLFxyXG4gICAgICByZWZyZXNoOiBub2RlID0+IHJlZnJlc2hSZWNvaWxWYWx1ZSQxKHN0b3JlLCBub2RlKSxcclxuICAgICAgZ290b1NuYXBzaG90OiBzbmFwc2hvdCA9PiBnb3RvU25hcHNob3QkMShzdG9yZSwgc25hcHNob3QpLFxyXG4gICAgICB0cmFuc2FjdF9VTlNUQUJMRTogdHJhbnNhY3Rpb24gPT4gYXRvbWljVXBkYXRlciQxKHN0b3JlKSh0cmFuc2FjdGlvbilcclxuICAgIH0sIHtcclxuICAgICAgc25hcHNob3Q6ICgpID0+IHtcclxuICAgICAgICBjb25zdCBzbmFwc2hvdCA9IGNsb25lU25hcHNob3QkMihzdG9yZSk7XHJcbiAgICAgICAgcmVsZWFzZVNuYXBzaG90ID0gc25hcHNob3QucmV0YWluKCk7XHJcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGNhbGxiYWNrID0gZm4oY2FsbGJhY2tJbnRlcmZhY2UpO1xyXG5cclxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgUmVjb2lsX2VycihlcnJNc2cpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldCA9IGNhbGxiYWNrKC4uLmFyZ3MpO1xyXG4gIH0pO1xyXG4gICEhKHJldCBpbnN0YW5jZW9mIFNlbnRpbmVsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UsICdiYXRjaFVwZGF0ZXMgc2hvdWxkIHJldHVybiBpbW1lZGlhdGVseScpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcblxyXG4gIGlmIChSZWNvaWxfaXNQcm9taXNlKHJldCkpIHtcclxuICAgIHJldC5maW5hbGx5KCgpID0+IHtcclxuICAgICAgdmFyIF9yZWxlYXNlU25hcHNob3Q7XHJcblxyXG4gICAgICAoX3JlbGVhc2VTbmFwc2hvdCA9IHJlbGVhc2VTbmFwc2hvdCkgPT09IG51bGwgfHwgX3JlbGVhc2VTbmFwc2hvdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbGVhc2VTbmFwc2hvdCgpO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBfcmVsZWFzZVNuYXBzaG90MjtcclxuXHJcbiAgICAoX3JlbGVhc2VTbmFwc2hvdDIgPSByZWxlYXNlU25hcHNob3QpID09PSBudWxsIHx8IF9yZWxlYXNlU25hcHNob3QyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsZWFzZVNuYXBzaG90MigpO1xyXG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF1cclxuXHJcblxyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbENhbGxiYWNrKGZuLCBkZXBzKSB7XHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQ2KCk7XHJcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDMoIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLWNhbGxdXHJcbiAgKC4uLmFyZ3MpID0+IHtcclxuICAgIHJldHVybiByZWNvaWxDYWxsYmFjayhzdG9yZVJlZi5jdXJyZW50LCBmbiwgYXJncyk7XHJcbiAgfSwgZGVwcyAhPSBudWxsID8gWy4uLmRlcHMsIHN0b3JlUmVmXSA6IHVuZGVmaW5lZCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZiLXd3dy9yZWFjdC1ob29rcy1kZXBzXHJcbiAgKTtcclxufVxyXG5cclxudmFyIFJlY29pbF91c2VSZWNvaWxDYWxsYmFjayA9IHtcclxuICByZWNvaWxDYWxsYmFjayxcclxuICB1c2VSZWNvaWxDYWxsYmFja1xyXG59O1xyXG5cclxuY29uc3Qge1xyXG4gIHVzZVN0b3JlUmVmOiB1c2VTdG9yZVJlZiQ3XHJcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcclxuXHJcbmNvbnN0IHtcclxuICByZWZyZXNoUmVjb2lsVmFsdWU6IHJlZnJlc2hSZWNvaWxWYWx1ZSQyXHJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XHJcblxyXG5jb25zdCB7XHJcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrJDRcclxufSA9IHJlYWN0O1xyXG5cclxuZnVuY3Rpb24gdXNlUmVjb2lsUmVmcmVzaGVyKHJlY29pbFZhbHVlKSB7XHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQ3KCk7XHJcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDQoKCkgPT4ge1xyXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xyXG4gICAgcmVmcmVzaFJlY29pbFZhbHVlJDIoc3RvcmUsIHJlY29pbFZhbHVlKTtcclxuICB9LCBbcmVjb2lsVmFsdWUsIHN0b3JlUmVmXSk7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfdXNlUmVjb2lsUmVmcmVzaGVyID0gdXNlUmVjb2lsUmVmcmVzaGVyO1xyXG5cclxuY29uc3Qge1xyXG4gIGF0b21pY1VwZGF0ZXI6IGF0b21pY1VwZGF0ZXIkMlxyXG59ID0gUmVjb2lsX0F0b21pY1VwZGF0ZXMkMTtcclxuXHJcbmNvbnN0IHtcclxuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkOFxyXG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XHJcblxyXG5jb25zdCB7XHJcbiAgdXNlTWVtbzogdXNlTWVtbyQzXHJcbn0gPSByZWFjdDtcclxuXHJcbmZ1bmN0aW9uIHVzZVJlY29pbFRyYW5zYWN0aW9uKGZuLCBkZXBzKSB7XHJcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQ4KCk7XHJcbiAgcmV0dXJuIHVzZU1lbW8kMygoKSA9PiAoLi4uYXJncykgPT4ge1xyXG4gICAgY29uc3QgYXRvbWljVXBkYXRlID0gYXRvbWljVXBkYXRlciQyKHN0b3JlUmVmLmN1cnJlbnQpO1xyXG4gICAgYXRvbWljVXBkYXRlKHRyYW5zYWN0aW9uSW50ZXJmYWNlID0+IHtcclxuICAgICAgZm4odHJhbnNhY3Rpb25JbnRlcmZhY2UpKC4uLmFyZ3MpO1xyXG4gICAgfSk7XHJcbiAgfSwgZGVwcyAhPSBudWxsID8gWy4uLmRlcHMsIHN0b3JlUmVmXSA6IHVuZGVmaW5lZCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZiLXd3dy9yZWFjdC1ob29rcy1kZXBzXHJcbiAgKTtcclxufVxyXG5cclxudmFyIFJlY29pbF91c2VSZWNvaWxUcmFuc2FjdGlvbiA9IHVzZVJlY29pbFRyYW5zYWN0aW9uO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBcclxuICogQGZvcm1hdFxyXG4gKiBAb25jYWxsIHJlY29pbFxyXG4gKi9cclxuXHJcbmNsYXNzIFdyYXBwZWRWYWx1ZSB7XHJcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbnZhciBSZWNvaWxfV3JhcHBlciA9IHtcclxuICBXcmFwcGVkVmFsdWVcclxufTtcclxuXHJcbnZhciBSZWNvaWxfV3JhcHBlcl8xID0gUmVjb2lsX1dyYXBwZXIuV3JhcHBlZFZhbHVlO1xyXG5cclxudmFyIFJlY29pbF9XcmFwcGVyJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIFdyYXBwZWRWYWx1ZTogUmVjb2lsX1dyYXBwZXJfMVxyXG59KTtcclxuXHJcbmNvbnN0IHtcclxuICBpc0Zhc3RSZWZyZXNoRW5hYmxlZDogaXNGYXN0UmVmcmVzaEVuYWJsZWQkMlxyXG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcclxuXHJcblxyXG5cclxuY2xhc3MgQ2hhbmdlZFBhdGhFcnJvciBleHRlbmRzIEVycm9yIHt9XHJcblxyXG5jbGFzcyBUcmVlQ2FjaGUge1xyXG4gIC8vICRGbG93SXNzdWVbdW5jbGVhci10eXBlXVxyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgIHZhciBfb3B0aW9ucyRvbkhpdCwgX29wdGlvbnMkb25TZXQsIF9vcHRpb25zJG1hcE5vZGVWYWx1ZTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbmFtZVwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9udW1MZWFmc1wiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yb290XCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29uSGl0XCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29uU2V0XCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX21hcE5vZGVWYWx1ZVwiLCB2b2lkIDApO1xyXG5cclxuICAgIHRoaXMuX25hbWUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubmFtZTtcclxuICAgIHRoaXMuX251bUxlYWZzID0gMDtcclxuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xyXG4gICAgdGhpcy5fb25IaXQgPSAoX29wdGlvbnMkb25IaXQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25IaXQpICE9PSBudWxsICYmIF9vcHRpb25zJG9uSGl0ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRvbkhpdCA6ICgpID0+IHt9O1xyXG4gICAgdGhpcy5fb25TZXQgPSAoX29wdGlvbnMkb25TZXQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25TZXQpICE9PSBudWxsICYmIF9vcHRpb25zJG9uU2V0ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRvblNldCA6ICgpID0+IHt9O1xyXG4gICAgdGhpcy5fbWFwTm9kZVZhbHVlID0gKF9vcHRpb25zJG1hcE5vZGVWYWx1ZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXBOb2RlVmFsdWUpICE9PSBudWxsICYmIF9vcHRpb25zJG1hcE5vZGVWYWx1ZSAhPT0gdm9pZCAwID8gX29wdGlvbnMkbWFwTm9kZVZhbHVlIDogdmFsID0+IHZhbDtcclxuICB9XHJcblxyXG4gIHNpemUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbnVtTGVhZnM7XHJcbiAgfSAvLyAkRmxvd0lzc3VlW3VuY2xlYXItdHlwZV1cclxuXHJcblxyXG4gIHJvb3QoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcm9vdDtcclxuICB9XHJcblxyXG4gIGdldChnZXROb2RlVmFsdWUsIGhhbmRsZXJzKSB7XHJcbiAgICB2YXIgX3RoaXMkZ2V0TGVhZk5vZGU7XHJcblxyXG4gICAgcmV0dXJuIChfdGhpcyRnZXRMZWFmTm9kZSA9IHRoaXMuZ2V0TGVhZk5vZGUoZ2V0Tm9kZVZhbHVlLCBoYW5kbGVycykpID09PSBudWxsIHx8IF90aGlzJGdldExlYWZOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRMZWFmTm9kZS52YWx1ZTtcclxuICB9XHJcblxyXG4gIGdldExlYWZOb2RlKGdldE5vZGVWYWx1ZSwgaGFuZGxlcnMpIHtcclxuICAgIGlmICh0aGlzLl9yb290ID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH0gLy8gSXRlcmF0ZSBkb3duIHRoZSB0cmVlIGJhc2VkIG9uIHRoZSBjdXJyZW50IG5vZGUgdmFsdWVzIHVudGlsIHdlIGhpdCBhIGxlYWZcclxuICAgIC8vICRGbG93SXNzdWVbdW5jbGVhci10eXBlXVxyXG5cclxuXHJcbiAgICBsZXQgbm9kZSA9IHRoaXMuX3Jvb3Q7XHJcblxyXG4gICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgaGFuZGxlcnMgPT09IG51bGwgfHwgaGFuZGxlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uTm9kZVZpc2l0KG5vZGUpO1xyXG5cclxuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2xlYWYnKSB7XHJcbiAgICAgICAgdGhpcy5fb25IaXQobm9kZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBub2RlVmFsdWUgPSB0aGlzLl9tYXBOb2RlVmFsdWUoZ2V0Tm9kZVZhbHVlKG5vZGUubm9kZUtleSkpO1xyXG5cclxuICAgICAgbm9kZSA9IG5vZGUuYnJhbmNoZXMuZ2V0KG5vZGVWYWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIHNldChyb3V0ZSwgdmFsdWUsIGhhbmRsZXJzKSB7XHJcbiAgICBjb25zdCBhZGRMZWFmID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX25vZGUyLCBfbm9kZTMsIF90aGlzJF9yb290MiwgX2hhbmRsZXJzJG9uTm9kZVZpc2l0MjtcclxuXHJcbiAgICAgIC8vIEZpcnN0LCBzZXR1cCB0aGUgYnJhbmNoIG5vZGVzIGZvciB0aGUgcm91dGU6XHJcbiAgICAgIC8vIEl0ZXJhdGUgZG93biB0aGUgdHJlZSB0byBmaW5kIG9yIGFkZCBicmFuY2ggbm9kZXMgZm9sbG93aW5nIHRoZSByb3V0ZVxyXG4gICAgICBsZXQgbm9kZTtcclxuICAgICAgbGV0IGJyYW5jaEtleTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgW25vZGVLZXksIG5vZGVWYWx1ZV0gb2Ygcm91dGUpIHtcclxuICAgICAgICB2YXIgX25vZGUsIF9oYW5kbGVycyRvbk5vZGVWaXNpdCwgX3RoaXMkX3Jvb3Q7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyByb290IHdhcyBhIGxlYWYsIHdoaWxlIHdlIG5vdCBoYXZlIGEgZ2V0KCksIGl0IG1lYW5zXHJcbiAgICAgICAgLy8gdGhlIHNlbGVjdG9yIGhhcyBpbmNvbnNpc3RlbnQgdmFsdWVzIG9yIGltcGxlbWVudGF0aW9uIGNoYW5nZWQuXHJcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuX3Jvb3Q7XHJcblxyXG4gICAgICAgIGlmICgocm9vdCA9PT0gbnVsbCB8fCByb290ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb290LnR5cGUpID09PSAnbGVhZicpIHtcclxuICAgICAgICAgIHRocm93IHRoaXMuaW52YWxpZENhY2hlRXJyb3IoKTtcclxuICAgICAgICB9IC8vIG5vZGUgbm93IHJlZmVycyB0byB0aGUgbmV4dCBub2RlIGRvd24gaW4gdGhlIHRyZWVcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGU7IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxyXG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdXHJcblxyXG4gICAgICAgIG5vZGUgPSBwYXJlbnQgPyBwYXJlbnQuYnJhbmNoZXMuZ2V0KGJyYW5jaEtleSkgOiByb290OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cclxuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXVxyXG5cclxuICAgICAgICBub2RlID0gKF9ub2RlID0gbm9kZSkgIT09IG51bGwgJiYgX25vZGUgIT09IHZvaWQgMCA/IF9ub2RlIDoge1xyXG4gICAgICAgICAgdHlwZTogJ2JyYW5jaCcsXHJcbiAgICAgICAgICBub2RlS2V5LFxyXG4gICAgICAgICAgcGFyZW50LFxyXG4gICAgICAgICAgYnJhbmNoZXM6IG5ldyBNYXAoKSxcclxuICAgICAgICAgIGJyYW5jaEtleVxyXG4gICAgICAgIH07IC8vIElmIHdlIGZvdW5kIGFuIGV4aXN0aW5nIG5vZGUsIGNvbmZpcm0gaXQgaGFzIGEgY29uc2lzdGVudCB2YWx1ZVxyXG5cclxuICAgICAgICBpZiAobm9kZS50eXBlICE9PSAnYnJhbmNoJyB8fCBub2RlLm5vZGVLZXkgIT09IG5vZGVLZXkpIHtcclxuICAgICAgICAgIHRocm93IHRoaXMuaW52YWxpZENhY2hlRXJyb3IoKTtcclxuICAgICAgICB9IC8vIEFkZCB0aGUgYnJhbmNoIG5vZGUgdG8gdGhlIHRyZWVcclxuXHJcblxyXG4gICAgICAgIHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5icmFuY2hlcy5zZXQoYnJhbmNoS2V5LCBub2RlKTtcclxuICAgICAgICBoYW5kbGVycyA9PT0gbnVsbCB8fCBoYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9oYW5kbGVycyRvbk5vZGVWaXNpdCA9IGhhbmRsZXJzLm9uTm9kZVZpc2l0KSA9PT0gbnVsbCB8fCBfaGFuZGxlcnMkb25Ob2RlVmlzaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oYW5kbGVycyRvbk5vZGVWaXNpdC5jYWxsKGhhbmRsZXJzLCBub2RlKTsgLy8gUHJlcGFyZSBmb3IgbmV4dCBpdGVyYXRpb24gYW5kIGluc3RhbGwgcm9vdCBpZiBpdCBpcyBuZXcuXHJcblxyXG4gICAgICAgIGJyYW5jaEtleSA9IHRoaXMuX21hcE5vZGVWYWx1ZShub2RlVmFsdWUpO1xyXG4gICAgICAgIHRoaXMuX3Jvb3QgPSAoX3RoaXMkX3Jvb3QgPSB0aGlzLl9yb290KSAhPT0gbnVsbCAmJiBfdGhpcyRfcm9vdCAhPT0gdm9pZCAwID8gX3RoaXMkX3Jvb3QgOiBub2RlO1xyXG4gICAgICB9IC8vIFNlY29uZCwgc2V0dXAgdGhlIGxlYWYgbm9kZTpcclxuICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgbGVhZiBmb3IgdGhpcyByb3V0ZSBjb25maXJtIGl0IGlzIGNvbnNpc3RlbnRcclxuXHJcblxyXG4gICAgICBjb25zdCBvbGRMZWFmID0gbm9kZSA/IChfbm9kZTIgPSBub2RlKSA9PT0gbnVsbCB8fCBfbm9kZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlMi5icmFuY2hlcy5nZXQoYnJhbmNoS2V5KSA6IHRoaXMuX3Jvb3Q7XHJcblxyXG4gICAgICBpZiAob2xkTGVhZiAhPSBudWxsICYmIChvbGRMZWFmLnR5cGUgIT09ICdsZWFmJyB8fCBvbGRMZWFmLmJyYW5jaEtleSAhPT0gYnJhbmNoS2V5KSkge1xyXG4gICAgICAgIHRocm93IHRoaXMuaW52YWxpZENhY2hlRXJyb3IoKTtcclxuICAgICAgfSAvLyBDcmVhdGUgYSBuZXcgb3IgcmVwbGFjZW1lbnQgbGVhZi5cclxuXHJcblxyXG4gICAgICBjb25zdCBsZWFmTm9kZSA9IHtcclxuICAgICAgICB0eXBlOiAnbGVhZicsXHJcbiAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgcGFyZW50OiBub2RlLFxyXG4gICAgICAgIGJyYW5jaEtleVxyXG4gICAgICB9OyAvLyBJbnN0YWxsIHRoZSBsZWFmIGFuZCBjYWxsIGhhbmRsZXJzXHJcblxyXG4gICAgICAoX25vZGUzID0gbm9kZSkgPT09IG51bGwgfHwgX25vZGUzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZTMuYnJhbmNoZXMuc2V0KGJyYW5jaEtleSwgbGVhZk5vZGUpO1xyXG4gICAgICB0aGlzLl9yb290ID0gKF90aGlzJF9yb290MiA9IHRoaXMuX3Jvb3QpICE9PSBudWxsICYmIF90aGlzJF9yb290MiAhPT0gdm9pZCAwID8gX3RoaXMkX3Jvb3QyIDogbGVhZk5vZGU7XHJcbiAgICAgIHRoaXMuX251bUxlYWZzKys7XHJcblxyXG4gICAgICB0aGlzLl9vblNldChsZWFmTm9kZSk7XHJcblxyXG4gICAgICBoYW5kbGVycyA9PT0gbnVsbCB8fCBoYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9oYW5kbGVycyRvbk5vZGVWaXNpdDIgPSBoYW5kbGVycy5vbk5vZGVWaXNpdCkgPT09IG51bGwgfHwgX2hhbmRsZXJzJG9uTm9kZVZpc2l0MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2hhbmRsZXJzJG9uTm9kZVZpc2l0Mi5jYWxsKGhhbmRsZXJzLCBsZWFmTm9kZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGFkZExlYWYoKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIC8vIElmIHRoZSBjYWNoZSB3YXMgc3RhbGUgb3Igb2JzZXJ2ZWQgaW5jb25zaXN0ZW50IHZhbHVlcywgc3VjaCBhcyB3aXRoXHJcbiAgICAgIC8vIEZhc3QgUmVmcmVzaCwgdGhlbiBjbGVhciBpdCBhbmQgcmVidWlsZCB3aXRoIHRoZSBuZXcgdmFsdWVzLlxyXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDaGFuZ2VkUGF0aEVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgIGFkZExlYWYoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gLy8gUmV0dXJucyB0cnVlIGlmIGxlYWYgd2FzIGFjdHVhbGx5IGRlbGV0ZWQgZnJvbSB0aGUgdHJlZVxyXG5cclxuXHJcbiAgZGVsZXRlKGxlYWYpIHtcclxuICAgIGNvbnN0IHJvb3QgPSB0aGlzLnJvb3QoKTtcclxuXHJcbiAgICBpZiAoIXJvb3QpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChsZWFmID09PSByb290KSB7XHJcbiAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xyXG4gICAgICB0aGlzLl9udW1MZWFmcyA9IDA7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSAvLyBJdGVyYXRlIHVwIGZyb20gdGhlIGxlYWYgZGVsZXRlaW5nIGl0IGZyb20gaXQncyBwYXJlbnQncyBicmFuY2hlcy5cclxuXHJcblxyXG4gICAgbGV0IG5vZGUgPSBsZWFmLnBhcmVudDtcclxuICAgIGxldCBicmFuY2hLZXkgPSBsZWFmLmJyYW5jaEtleTtcclxuXHJcbiAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICB2YXIgX25vZGU0O1xyXG5cclxuICAgICAgbm9kZS5icmFuY2hlcy5kZWxldGUoYnJhbmNoS2V5KTsgLy8gU3RvcCBpdGVyYXRpbmcgaWYgd2UgaGl0IHRoZSByb290LlxyXG5cclxuICAgICAgaWYgKG5vZGUgPT09IHJvb3QpIHtcclxuICAgICAgICBpZiAobm9kZS5icmFuY2hlcy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcclxuICAgICAgICAgIHRoaXMuX251bUxlYWZzID0gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5fbnVtTGVhZnMtLTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9IC8vIFN0b3AgaXRlcmF0aW5nIGlmIHRoZXJlIGFyZSBvdGhlciBicmFuY2hlcyBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvXHJcbiAgICAgIC8vIHJlbW92ZSBhbnkgbW9yZSBub2Rlcy5cclxuXHJcblxyXG4gICAgICBpZiAobm9kZS5icmFuY2hlcy5zaXplID4gMCkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9IC8vIEl0ZXJhdGUgdXAgdG8gb3VyIHBhcmVudFxyXG5cclxuXHJcbiAgICAgIGJyYW5jaEtleSA9IChfbm9kZTQgPSBub2RlKSA9PT0gbnVsbCB8fCBfbm9kZTQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlNC5icmFuY2hLZXk7XHJcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgIH0gLy8gQ29uZmlybSB0aGF0IHRoZSBsZWFmIHdlIGFyZSBkZWxldGluZyBpcyBhY3R1YWxseSBhdHRhY2hlZCB0byBvdXIgdHJlZVxyXG5cclxuXHJcbiAgICBmb3IgKDsgbm9kZSAhPT0gcm9vdDsgbm9kZSA9IG5vZGUucGFyZW50KSB7XHJcbiAgICAgIGlmIChub2RlID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9udW1MZWFmcy0tO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBjbGVhcigpIHtcclxuICAgIHRoaXMuX251bUxlYWZzID0gMDtcclxuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgaW52YWxpZENhY2hlRXJyb3IoKSB7XHJcbiAgICBjb25zdCBDSEFOR0VEX1BBVEhfRVJST1JfTUVTU0FHRSA9IGlzRmFzdFJlZnJlc2hFbmFibGVkJDIoKSA/ICdQb3NzaWJsZSBGYXN0IFJlZnJlc2ggbW9kdWxlIHJlbG9hZCBkZXRlY3RlZC4gICcgKyAnVGhpcyBtYXkgYWxzbyBiZSBjYXVzZWQgYnkgYW4gc2VsZWN0b3IgcmV0dXJuaW5nIGluY29uc2lzdGVudCB2YWx1ZXMuICcgKyAnUmVzZXR0aW5nIGNhY2hlLicgOiAnSW52YWxpZCBjYWNoZSB2YWx1ZXMuICBUaGlzIGhhcHBlbnMgd2hlbiBzZWxlY3RvcnMgZG8gbm90IHJldHVybiAnICsgJ2NvbnNpc3RlbnQgdmFsdWVzIGZvciB0aGUgc2FtZSBpbnB1dCBkZXBlbmRlbmN5IHZhbHVlcy4gIFRoYXQgbWF5IGFsc28gJyArICdiZSBjYXVzZWQgd2hlbiB1c2luZyBGYXN0IFJlZnJlc2ggdG8gY2hhbmdlIGEgc2VsZWN0b3IgaW1wbGVtZW50YXRpb24uICAnICsgJ1Jlc2V0dGluZyBjYWNoZS4nO1xyXG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKENIQU5HRURfUEFUSF9FUlJPUl9NRVNTQUdFICsgKHRoaXMuX25hbWUgIT0gbnVsbCA/IGAgLSAke3RoaXMuX25hbWV9YCA6ICcnKSk7XHJcbiAgICB0aHJvdyBuZXcgQ2hhbmdlZFBhdGhFcnJvcigpO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbnZhciBSZWNvaWxfVHJlZUNhY2hlID0ge1xyXG4gIFRyZWVDYWNoZVxyXG59O1xyXG5cclxudmFyIFJlY29pbF9UcmVlQ2FjaGVfMSA9IFJlY29pbF9UcmVlQ2FjaGUuVHJlZUNhY2hlO1xyXG5cclxudmFyIFJlY29pbF9UcmVlQ2FjaGUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgVHJlZUNhY2hlOiBSZWNvaWxfVHJlZUNhY2hlXzFcclxufSk7XHJcblxyXG5jbGFzcyBMUlVDYWNoZSB7XHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgdmFyIF9vcHRpb25zJG1hcEtleTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWF4U2l6ZVwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zaXplXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2hlYWRcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGFpbFwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tYXBcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfa2V5TWFwcGVyXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy5fbWF4U2l6ZSA9IG9wdGlvbnMubWF4U2l6ZTtcclxuICAgIHRoaXMuX3NpemUgPSAwO1xyXG4gICAgdGhpcy5faGVhZCA9IG51bGw7XHJcbiAgICB0aGlzLl90YWlsID0gbnVsbDtcclxuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuX2tleU1hcHBlciA9IChfb3B0aW9ucyRtYXBLZXkgPSBvcHRpb25zLm1hcEtleSkgIT09IG51bGwgJiYgX29wdGlvbnMkbWFwS2V5ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRtYXBLZXkgOiB2ID0+IHY7XHJcbiAgfVxyXG5cclxuICBoZWFkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2hlYWQ7XHJcbiAgfVxyXG5cclxuICB0YWlsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3RhaWw7XHJcbiAgfVxyXG5cclxuICBzaXplKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XHJcbiAgfVxyXG5cclxuICBtYXhTaXplKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21heFNpemU7XHJcbiAgfVxyXG5cclxuICBoYXMoa2V5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyh0aGlzLl9rZXlNYXBwZXIoa2V5KSk7XHJcbiAgfVxyXG5cclxuICBnZXQoa2V5KSB7XHJcbiAgICBjb25zdCBtYXBwZWRLZXkgPSB0aGlzLl9rZXlNYXBwZXIoa2V5KTtcclxuXHJcbiAgICBjb25zdCBub2RlID0gdGhpcy5fbWFwLmdldChtYXBwZWRLZXkpO1xyXG5cclxuICAgIGlmICghbm9kZSkge1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2V0KGtleSwgbm9kZS52YWx1ZSk7XHJcbiAgICByZXR1cm4gbm9kZS52YWx1ZTtcclxuICB9XHJcblxyXG4gIHNldChrZXksIHZhbCkge1xyXG4gICAgY29uc3QgbWFwcGVkS2V5ID0gdGhpcy5fa2V5TWFwcGVyKGtleSk7XHJcblxyXG4gICAgY29uc3QgZXhpc3RpbmdOb2RlID0gdGhpcy5fbWFwLmdldChtYXBwZWRLZXkpO1xyXG5cclxuICAgIGlmIChleGlzdGluZ05vZGUpIHtcclxuICAgICAgdGhpcy5kZWxldGUoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoZWFkID0gdGhpcy5oZWFkKCk7XHJcbiAgICBjb25zdCBub2RlID0ge1xyXG4gICAgICBrZXksXHJcbiAgICAgIHJpZ2h0OiBoZWFkLFxyXG4gICAgICBsZWZ0OiBudWxsLFxyXG4gICAgICB2YWx1ZTogdmFsXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChoZWFkKSB7XHJcbiAgICAgIGhlYWQubGVmdCA9IG5vZGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl90YWlsID0gbm9kZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9tYXAuc2V0KG1hcHBlZEtleSwgbm9kZSk7XHJcblxyXG4gICAgdGhpcy5faGVhZCA9IG5vZGU7XHJcbiAgICB0aGlzLl9zaXplKys7XHJcblxyXG4gICAgdGhpcy5fbWF5YmVEZWxldGVMUlUoKTtcclxuICB9XHJcblxyXG4gIF9tYXliZURlbGV0ZUxSVSgpIHtcclxuICAgIGlmICh0aGlzLnNpemUoKSA+IHRoaXMubWF4U2l6ZSgpKSB7XHJcbiAgICAgIHRoaXMuZGVsZXRlTHJ1KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZWxldGVMcnUoKSB7XHJcbiAgICBjb25zdCB0YWlsID0gdGhpcy50YWlsKCk7XHJcblxyXG4gICAgaWYgKHRhaWwpIHtcclxuICAgICAgdGhpcy5kZWxldGUodGFpbC5rZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVsZXRlKGtleSkge1xyXG4gICAgY29uc3QgbWFwcGVkS2V5ID0gdGhpcy5fa2V5TWFwcGVyKGtleSk7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9zaXplIHx8ICF0aGlzLl9tYXAuaGFzKG1hcHBlZEtleSkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5vZGUgPSBSZWNvaWxfbnVsbHRocm93cyh0aGlzLl9tYXAuZ2V0KG1hcHBlZEtleSkpO1xyXG4gICAgY29uc3QgcmlnaHQgPSBub2RlLnJpZ2h0O1xyXG4gICAgY29uc3QgbGVmdCA9IG5vZGUubGVmdDtcclxuXHJcbiAgICBpZiAocmlnaHQpIHtcclxuICAgICAgcmlnaHQubGVmdCA9IG5vZGUubGVmdDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobGVmdCkge1xyXG4gICAgICBsZWZ0LnJpZ2h0ID0gbm9kZS5yaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKCkpIHtcclxuICAgICAgdGhpcy5faGVhZCA9IHJpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChub2RlID09PSB0aGlzLnRhaWwoKSkge1xyXG4gICAgICB0aGlzLl90YWlsID0gbGVmdDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9tYXAuZGVsZXRlKG1hcHBlZEtleSk7XHJcblxyXG4gICAgdGhpcy5fc2l6ZS0tO1xyXG4gIH1cclxuXHJcbiAgY2xlYXIoKSB7XHJcbiAgICB0aGlzLl9zaXplID0gMDtcclxuICAgIHRoaXMuX2hlYWQgPSBudWxsO1xyXG4gICAgdGhpcy5fdGFpbCA9IG51bGw7XHJcbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxudmFyIFJlY29pbF9MUlVDYWNoZSA9IHtcclxuICBMUlVDYWNoZVxyXG59O1xyXG5cclxudmFyIFJlY29pbF9MUlVDYWNoZV8xID0gUmVjb2lsX0xSVUNhY2hlLkxSVUNhY2hlO1xyXG5cclxudmFyIFJlY29pbF9MUlVDYWNoZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xyXG4gIF9fcHJvdG9fXzogbnVsbCxcclxuICBMUlVDYWNoZTogUmVjb2lsX0xSVUNhY2hlXzFcclxufSk7XHJcblxyXG5jb25zdCB7XHJcbiAgTFJVQ2FjaGU6IExSVUNhY2hlJDFcclxufSA9IFJlY29pbF9MUlVDYWNoZSQxO1xyXG5cclxuY29uc3Qge1xyXG4gIFRyZWVDYWNoZTogVHJlZUNhY2hlJDFcclxufSA9IFJlY29pbF9UcmVlQ2FjaGUkMTtcclxuXHJcbmZ1bmN0aW9uIHRyZWVDYWNoZUxSVSh7XHJcbiAgbmFtZSxcclxuICBtYXhTaXplLFxyXG4gIG1hcE5vZGVWYWx1ZSA9IHYgPT4gdlxyXG59KSB7XHJcbiAgY29uc3QgbHJ1Q2FjaGUgPSBuZXcgTFJVQ2FjaGUkMSh7XHJcbiAgICBtYXhTaXplXHJcbiAgfSk7XHJcbiAgY29uc3QgY2FjaGUgPSBuZXcgVHJlZUNhY2hlJDEoe1xyXG4gICAgbmFtZSxcclxuICAgIG1hcE5vZGVWYWx1ZSxcclxuICAgIG9uSGl0OiBub2RlID0+IHtcclxuICAgICAgbHJ1Q2FjaGUuc2V0KG5vZGUsIHRydWUpO1xyXG4gICAgfSxcclxuICAgIG9uU2V0OiBub2RlID0+IHtcclxuICAgICAgY29uc3QgbHJ1Tm9kZSA9IGxydUNhY2hlLnRhaWwoKTtcclxuICAgICAgbHJ1Q2FjaGUuc2V0KG5vZGUsIHRydWUpO1xyXG5cclxuICAgICAgaWYgKGxydU5vZGUgJiYgY2FjaGUuc2l6ZSgpID4gbWF4U2l6ZSkge1xyXG4gICAgICAgIGNhY2hlLmRlbGV0ZShscnVOb2RlLmtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gY2FjaGU7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfdHJlZUNhY2hlTFJVID0gdHJlZUNhY2hlTFJVO1xyXG5cclxuY29uc3QgVElNRV9XQVJOSU5HX1RIUkVTSE9MRF9NUyA9IDE1O1xyXG5cclxuZnVuY3Rpb24gc3RyaW5naWZ5KHgsIG9wdCwga2V5KSB7XHJcbiAgLy8gQSBvcHRpbWl6YXRpb24gdG8gYXZvaWQgdGhlIG1vcmUgZXhwZW5zaXZlIEpTT04uc3RyaW5naWZ5KCkgZm9yIHNpbXBsZSBzdHJpbmdzXHJcbiAgLy8gVGhpcyBtYXkgbG9zZSBwcm90ZWN0aW9uIGZvciB1MjAyOCBhbmQgdTIwMjksIHRob3VnaC5cclxuICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnICYmICF4LmluY2x1ZGVzKCdcIicpICYmICF4LmluY2x1ZGVzKCdcXFxcJykpIHtcclxuICAgIHJldHVybiBgXCIke3h9XCJgO1xyXG4gIH0gLy8gSGFuZGxlIHByaW1pdGl2ZSB0eXBlc1xyXG5cclxuXHJcbiAgc3dpdGNoICh0eXBlb2YgeCkge1xyXG4gICAgY2FzZSAndW5kZWZpbmVkJzpcclxuICAgICAgcmV0dXJuICcnO1xyXG4gICAgLy8gSlNPTi5zdHJpbmdpZnkodW5kZWZpbmVkKSByZXR1cm5zIHVuZGVmaW5lZCwgYnV0IHdlIGFsd2F5cyB3YW50IHRvIHJldHVybiBhIHN0cmluZ1xyXG5cclxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICByZXR1cm4geCA/ICd0cnVlJyA6ICdmYWxzZSc7XHJcblxyXG4gICAgY2FzZSAnbnVtYmVyJzpcclxuICAgIGNhc2UgJ3N5bWJvbCc6XHJcbiAgICAgIC8vIGNhc2UgJ2JpZ2ludCc6IC8vIEJpZ0ludCBpcyBub3Qgc3VwcG9ydGVkIGluIHd3d1xyXG4gICAgICByZXR1cm4gU3RyaW5nKHgpO1xyXG5cclxuICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgIC8vIEFkZCBzdXJyb3VuZGluZyBxdW90ZXMgYW5kIGVzY2FwZSBpbnRlcm5hbCBxdW90ZXNcclxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHgpO1xyXG5cclxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuICAgICAgaWYgKChvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuYWxsb3dGdW5jdGlvbnMpICE9PSB0cnVlKSB7XHJcbiAgICAgICAgdGhyb3cgUmVjb2lsX2VycignQXR0ZW1wdCB0byBzZXJpYWxpemUgZnVuY3Rpb24gaW4gYSBSZWNvaWwgY2FjaGUga2V5Jyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBgX19GVU5DVElPTigke3gubmFtZX0pX19gO1xyXG4gIH1cclxuXHJcbiAgaWYgKHggPT09IG51bGwpIHtcclxuICAgIHJldHVybiAnbnVsbCc7XHJcbiAgfSAvLyBGYWxsYmFjayBjYXNlIGZvciB1bmtub3duIHR5cGVzXHJcblxyXG5cclxuICBpZiAodHlwZW9mIHggIT09ICdvYmplY3QnKSB7XHJcbiAgICB2YXIgX0pTT04kc3RyaW5naWZ5O1xyXG5cclxuICAgIHJldHVybiAoX0pTT04kc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnkoeCkpICE9PSBudWxsICYmIF9KU09OJHN0cmluZ2lmeSAhPT0gdm9pZCAwID8gX0pTT04kc3RyaW5naWZ5IDogJyc7XHJcbiAgfSAvLyBEZWFsIHdpdGggYWxsIHByb21pc2VzIGFzIGVxdWl2YWxlbnQgZm9yIG5vdy5cclxuXHJcblxyXG4gIGlmIChSZWNvaWxfaXNQcm9taXNlKHgpKSB7XHJcbiAgICByZXR1cm4gJ19fUFJPTUlTRV9fJztcclxuICB9IC8vIEFycmF5cyBoYW5kbGUgcmVjdXJzaXZlIHN0cmluZ2lmaWNhdGlvblxyXG5cclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcclxuICAgIHJldHVybiBgWyR7eC5tYXAoKHYsIGkpID0+IHN0cmluZ2lmeSh2LCBvcHQsIGkudG9TdHJpbmcoKSkpfV1gO1xyXG4gIH0gLy8gSWYgYW4gb2JqZWN0IGRlZmluZXMgYSB0b0pTT04oKSBtZXRob2QsIHRoZW4gdXNlIHRoYXQgdG8gb3ZlcnJpZGUgdGhlXHJcbiAgLy8gc2VyaWFsaXphdGlvbi4gIFRoaXMgbWF0Y2hlcyB0aGUgYmVoYXZpb3Igb2YgSlNPTi5zdHJpbmdpZnkoKS5cclxuICAvLyBQYXNzIHRoZSBrZXkgZm9yIGNvbXBhdGliaWxpdHkuXHJcbiAgLy8gSW1tdXRhYmxlLmpzIGNvbGxlY3Rpb25zIGRlZmluZSB0aGlzIG1ldGhvZCB0byBhbGxvdyB1cyB0byBzZXJpYWxpemUgdGhlbS5cclxuXHJcblxyXG4gIGlmICh0eXBlb2YgeC50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcclxuICAgIC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxyXG4gICAgcmV0dXJuIHN0cmluZ2lmeSh4LnRvSlNPTihrZXkpLCBvcHQsIGtleSk7XHJcbiAgfSAvLyBGb3IgYnVpbHQtaW4gTWFwcywgc29ydCB0aGUga2V5cyBpbiBhIHN0YWJsZSBvcmRlciBpbnN0ZWFkIG9mIHRoZVxyXG4gIC8vIGRlZmF1bHQgaW5zZXJ0aW9uIG9yZGVyLiAgU3VwcG9ydCBub24tc3RyaW5nIGtleXMuXHJcblxyXG5cclxuICBpZiAoeCBpbnN0YW5jZW9mIE1hcCkge1xyXG4gICAgY29uc3Qgb2JqID0ge307XHJcblxyXG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgeCkge1xyXG4gICAgICAvLyBTdHJpbmdpZnkgd2lsbCBlc2NhcGUgYW55IG5lc3RlZCBxdW90ZXNcclxuICAgICAgb2JqW3R5cGVvZiBrID09PSAnc3RyaW5nJyA/IGsgOiBzdHJpbmdpZnkoaywgb3B0KV0gPSB2O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHJpbmdpZnkob2JqLCBvcHQsIGtleSk7XHJcbiAgfSAvLyBGb3IgYnVpbHQtaW4gU2V0cywgc29ydCB0aGUga2V5cyBpbiBhIHN0YWJsZSBvcmRlciBpbnN0ZWFkIG9mIHRoZVxyXG4gIC8vIGRlZmF1bHQgaW5zZXJ0aW9uIG9yZGVyLlxyXG5cclxuXHJcbiAgaWYgKHggaW5zdGFuY2VvZiBTZXQpIHtcclxuICAgIHJldHVybiBzdHJpbmdpZnkoQXJyYXkuZnJvbSh4KS5zb3J0KChhLCBiKSA9PiBzdHJpbmdpZnkoYSwgb3B0KS5sb2NhbGVDb21wYXJlKHN0cmluZ2lmeShiLCBvcHQpKSksIG9wdCwga2V5KTtcclxuICB9IC8vIEFueXRoaW5nIGVsc2UgdGhhdCBpcyBpdGVyYWJsZSBzZXJpYWxpemUgYXMgYW4gQXJyYXkuXHJcblxyXG5cclxuICBpZiAoU3ltYm9sICE9PSB1bmRlZmluZWQgJiYgeFtTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgJiYgdHlwZW9mIHhbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTogb2ZmXHJcbiAgICByZXR1cm4gc3RyaW5naWZ5KEFycmF5LmZyb20oeCksIG9wdCwga2V5KTtcclxuICB9IC8vIEZvciBhbGwgb3RoZXIgT2JqZWN0cywgc29ydCB0aGUga2V5cyBpbiBhIHN0YWJsZSBvcmRlci5cclxuXHJcblxyXG4gIHJldHVybiBgeyR7T2JqZWN0LmtleXMoeCkuZmlsdGVyKGsgPT4geFtrXSAhPT0gdW5kZWZpbmVkKS5zb3J0KCkgLy8gc3RyaW5naWZ5IHRoZSBrZXkgdG8gYWRkIHF1b3RlcyBhbmQgZXNjYXBlIGFueSBuZXN0ZWQgc2xhc2hlcyBvciBxdW90ZXMuXHJcbiAgLm1hcChrID0+IGAke3N0cmluZ2lmeShrLCBvcHQpfToke3N0cmluZ2lmeSh4W2tdLCBvcHQsIGspfWApLmpvaW4oJywnKX19YDtcclxufSAvLyBVdGlsaXR5IHNpbWlsYXIgdG8gSlNPTi5zdHJpbmdpZnkoKSBleGNlcHQ6XHJcbi8vICogU2VyaWFsaXplIGJ1aWx0LWluIFNldHMgYXMgYW4gQXJyYXlcclxuLy8gKiBTZXJpYWxpemUgYnVpbHQtaW4gTWFwcyBhcyBhbiBPYmplY3QuICBTdXBwb3J0cyBub24tc3RyaW5nIGtleXMuXHJcbi8vICogU2VyaWFsaXplIG90aGVyIGl0ZXJhYmxlcyBhcyBhcnJheXNcclxuLy8gKiBTb3J0IHRoZSBrZXlzIG9mIE9iamVjdHMgYW5kIE1hcHMgdG8gaGF2ZSBhIHN0YWJsZSBvcmRlciBiYXNlZCBvbiBzdHJpbmcgY29udmVyc2lvbi5cclxuLy8gICAgVGhpcyBvdmVycmlkZXMgdGhlaXIgZGVmYXVsdCBpbnNlcnRpb24gb3JkZXIuXHJcbi8vICogU3RpbGwgdXNlcyB0b0pTT04oKSBvZiBhbnkgb2JqZWN0IHRvIG92ZXJyaWRlIHNlcmlhbGl6YXRpb25cclxuLy8gKiBTdXBwb3J0IFN5bWJvbHMgKHRob3VnaCBkb24ndCBndWFyYW50ZWUgdW5pcXVlbmVzcylcclxuLy8gKiBXZSBjb3VsZCBzdXBwb3J0IEJpZ0ludCwgYnV0IEZsb3cgZG9lc24ndCBzZWVtIHRvIGxpa2UgaXQuXHJcbi8vIFNlZSBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5LXRlc3QuanMgZm9yIGV4YW1wbGVzXHJcblxyXG5cclxuZnVuY3Rpb24gc3RhYmxlU3RyaW5naWZ5KHgsIG9wdCA9IHtcclxuICBhbGxvd0Z1bmN0aW9uczogZmFsc2VcclxufSkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2UgPyB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOiAwO1xyXG4gICAgICBjb25zdCBzdHIgPSBzdHJpbmdpZnkoeCwgb3B0KTtcclxuICAgICAgY29uc3QgZW5kVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6IDA7XHJcblxyXG4gICAgICBpZiAoZW5kVGltZSAtIHN0YXJ0VGltZSA+IFRJTUVfV0FSTklOR19USFJFU0hPTERfTVMpIHtcclxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvbm8tY29uc29sZSAqL1xyXG4gICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoYFJlY29pbDogU3BlbnQgJHtlbmRUaW1lIC0gc3RhcnRUaW1lfW1zIGNvbXB1dGluZyBhIGNhY2hlIGtleWApO1xyXG4gICAgICAgIGNvbnNvbGUud2Fybih4LCBzdHIpO1xyXG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcclxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGZiLXd3dy9uby1jb25zb2xlICovXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyaW5naWZ5KHgsIG9wdCk7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5ID0gc3RhYmxlU3RyaW5naWZ5O1xyXG5cclxuY29uc3Qge1xyXG4gIFRyZWVDYWNoZTogVHJlZUNhY2hlJDJcclxufSA9IFJlY29pbF9UcmVlQ2FjaGUkMTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY29uc3QgZGVmYXVsdFBvbGljeSA9IHtcclxuICBlcXVhbGl0eTogJ3JlZmVyZW5jZScsXHJcbiAgZXZpY3Rpb246ICdrZWVwLWFsbCcsXHJcbiAgbWF4U2l6ZTogSW5maW5pdHlcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyZWVDYWNoZUZyb21Qb2xpY3koe1xyXG4gIGVxdWFsaXR5ID0gZGVmYXVsdFBvbGljeS5lcXVhbGl0eSxcclxuICBldmljdGlvbiA9IGRlZmF1bHRQb2xpY3kuZXZpY3Rpb24sXHJcbiAgbWF4U2l6ZSA9IGRlZmF1bHRQb2xpY3kubWF4U2l6ZVxyXG59ID0gZGVmYXVsdFBvbGljeSwgbmFtZSkge1xyXG4gIGNvbnN0IHZhbHVlTWFwcGVyID0gZ2V0VmFsdWVNYXBwZXIoZXF1YWxpdHkpO1xyXG4gIHJldHVybiBnZXRUcmVlQ2FjaGUoZXZpY3Rpb24sIG1heFNpemUsIHZhbHVlTWFwcGVyLCBuYW1lKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VmFsdWVNYXBwZXIoZXF1YWxpdHkpIHtcclxuICBzd2l0Y2ggKGVxdWFsaXR5KSB7XHJcbiAgICBjYXNlICdyZWZlcmVuY2UnOlxyXG4gICAgICByZXR1cm4gdmFsID0+IHZhbDtcclxuXHJcbiAgICBjYXNlICd2YWx1ZSc6XHJcbiAgICAgIHJldHVybiB2YWwgPT4gUmVjb2lsX3N0YWJsZVN0cmluZ2lmeSh2YWwpO1xyXG4gIH1cclxuXHJcbiAgdGhyb3cgUmVjb2lsX2VycihgVW5yZWNvZ25pemVkIGVxdWFsaXR5IHBvbGljeSAke2VxdWFsaXR5fWApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUcmVlQ2FjaGUoZXZpY3Rpb24sIG1heFNpemUsIG1hcE5vZGVWYWx1ZSwgbmFtZSkge1xyXG4gIHN3aXRjaCAoZXZpY3Rpb24pIHtcclxuICAgIGNhc2UgJ2tlZXAtYWxsJzpcclxuICAgICAgcmV0dXJuIG5ldyBUcmVlQ2FjaGUkMih7XHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBtYXBOb2RlVmFsdWVcclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSAnbHJ1JzpcclxuICAgICAgcmV0dXJuIFJlY29pbF90cmVlQ2FjaGVMUlUoe1xyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgbWF4U2l6ZTogUmVjb2lsX251bGx0aHJvd3MobWF4U2l6ZSksXHJcbiAgICAgICAgbWFwTm9kZVZhbHVlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgJ21vc3QtcmVjZW50JzpcclxuICAgICAgcmV0dXJuIFJlY29pbF90cmVlQ2FjaGVMUlUoe1xyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgbWF4U2l6ZTogMSxcclxuICAgICAgICBtYXBOb2RlVmFsdWVcclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICB0aHJvdyBSZWNvaWxfZXJyKGBVbnJlY29nbml6ZWQgZXZpY3Rpb24gcG9saWN5ICR7ZXZpY3Rpb259YCk7XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfdHJlZUNhY2hlRnJvbVBvbGljeSA9IHRyZWVDYWNoZUZyb21Qb2xpY3k7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xyXG4gIHZhciBfb3duZXJEb2N1bWVudCwgX2RvYyRkZWZhdWx0VmlldztcclxuXHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBjb25zdCBkb2MgPSBvYmplY3QgIT0gbnVsbCA/IChfb3duZXJEb2N1bWVudCA9IG9iamVjdC5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfb3duZXJEb2N1bWVudCAhPT0gdm9pZCAwID8gX293bmVyRG9jdW1lbnQgOiBvYmplY3QgOiBkb2N1bWVudDtcclxuICBjb25zdCBkZWZhdWx0VmlldyA9IChfZG9jJGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3KSAhPT0gbnVsbCAmJiBfZG9jJGRlZmF1bHRWaWV3ICE9PSB2b2lkIDAgPyBfZG9jJGRlZmF1bHRWaWV3IDogd2luZG93O1xyXG4gIHJldHVybiAhIShvYmplY3QgIT0gbnVsbCAmJiAodHlwZW9mIGRlZmF1bHRWaWV3Lk5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBkZWZhdWx0Vmlldy5Ob2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcclxufVxyXG5cclxudmFyIFJlY29pbF9pc05vZGUgPSBpc05vZGU7XHJcblxyXG5jb25zdCB7XHJcbiAgaXNSZWFjdE5hdGl2ZTogaXNSZWFjdE5hdGl2ZSQxLFxyXG4gIGlzV2luZG93OiBpc1dpbmRvdyQxXHJcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XHJcblxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gc2hvdWxkTm90QmVGcm96ZW4odmFsdWUpIHtcclxuICAvLyBQcmltaXRpdmVzIGFuZCBmdW5jdGlvbnM6XHJcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gLy8gUmVhY3QgZWxlbWVudHM6XHJcblxyXG5cclxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZS4kJHR5cGVvZikge1xyXG4gICAgY2FzZSAnc3ltYm9sJzpcclxuICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgfSAvLyBJbW11dGFibGUgc3RydWN0dXJlczpcclxuXHJcblxyXG4gIGlmICh2YWx1ZVsnQEBfX0lNTVVUQUJMRV9JVEVSQUJMRV9fQEAnXSAhPSBudWxsIHx8IHZhbHVlWydAQF9fSU1NVVRBQkxFX0tFWUVEX19AQCddICE9IG51bGwgfHwgdmFsdWVbJ0BAX19JTU1VVEFCTEVfSU5ERVhFRF9fQEAnXSAhPSBudWxsIHx8IHZhbHVlWydAQF9fSU1NVVRBQkxFX09SREVSRURfX0BAJ10gIT0gbnVsbCB8fCB2YWx1ZVsnQEBfX0lNTVVUQUJMRV9SRUNPUkRfX0BAJ10gIT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSAvLyBET00gbm9kZXM6XHJcblxyXG5cclxuICBpZiAoUmVjb2lsX2lzTm9kZSh2YWx1ZSkpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKFJlY29pbF9pc1Byb21pc2UodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IC8vIFNvbWUgZW52aXJvbm1lbnRzLCBqdXN0IGFzIEplc3QsIGRvbid0IHdvcmsgd2l0aCB0aGUgaW5zdGFuY2VvZiBjaGVja1xyXG5cclxuXHJcbiAgaWYgKCFpc1JlYWN0TmF0aXZlJDEgJiYgaXNXaW5kb3ckMSh2YWx1ZSkpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59IC8vIFJlY3Vyc2l2ZWx5IGZyZWV6ZSBhIHZhbHVlIHRvIGVuZm9yY2UgaXQgaXMgcmVhZC1vbmx5LlxyXG4vLyBUaGlzIG1heSBhbHNvIGhhdmUgbWluaW1hbCBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudHMgZm9yIGVudW1lcmF0aW5nXHJcbi8vIG9iamVjdHMgKGJhc2VkIG9uIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zLCBvZiBjb3Vyc2UpXHJcblxyXG5cclxuZnVuY3Rpb24gZGVlcEZyZWV6ZVZhbHVlKHZhbHVlKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgc2hvdWxkTm90QmVGcm96ZW4odmFsdWUpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBPYmplY3QuZnJlZXplKHZhbHVlKTsgLy8gTWFrZSBhbGwgcHJvcGVydGllcyByZWFkLW9ubHlcclxuXHJcbiAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcclxuICAgIC8vICRGbG93SXNzdWVbbWV0aG9kLXVuYmluZGluZ10gYWRkZWQgd2hlbiBpbXByb3ZpbmcgdHlwaW5nIGZvciB0aGlzIHBhcmFtZXRlcnNcclxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcclxuICAgICAgY29uc3QgcHJvcCA9IHZhbHVlW2tleV07IC8vIFByZXZlbnQgaW5maW5pdGUgcmVjdXJzc2lvbiBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcy5cclxuXHJcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ29iamVjdCcgJiYgcHJvcCAhPSBudWxsICYmICFPYmplY3QuaXNGcm96ZW4ocHJvcCkpIHtcclxuICAgICAgICBkZWVwRnJlZXplVmFsdWUocHJvcCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIE9iamVjdC5zZWFsKHZhbHVlKTsgLy8gVGhpcyBhbHNvIG1ha2VzIGV4aXN0aW5nIHByb3BlcnRpZXMgbm9uLWNvbmZpZ3VyYWJsZS5cclxufVxyXG5cclxudmFyIFJlY29pbF9kZWVwRnJlZXplVmFsdWUgPSBkZWVwRnJlZXplVmFsdWU7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIFRoaXMgaXMgYSBzdHViIGZvciBzb21lIGludGVncmF0aW9uIGludG8gRkIgaW50ZXJuYWwgc3R1ZmZcclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcbmZ1bmN0aW9uIHN0YXJ0UGVyZkJsb2NrKF9pZCkge1xyXG4gIHJldHVybiAoKSA9PiBudWxsO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX1BlcmZvcm1hbmNlVGltaW5ncyA9IHtcclxuICBzdGFydFBlcmZCbG9ja1xyXG59O1xyXG5cclxuY29uc3Qge1xyXG4gIGlzTG9hZGFibGU6IGlzTG9hZGFibGUkMSxcclxuICBsb2FkYWJsZVdpdGhFcnJvcjogbG9hZGFibGVXaXRoRXJyb3IkMSxcclxuICBsb2FkYWJsZVdpdGhQcm9taXNlOiBsb2FkYWJsZVdpdGhQcm9taXNlJDEsXHJcbiAgbG9hZGFibGVXaXRoVmFsdWU6IGxvYWRhYmxlV2l0aFZhbHVlJDJcclxufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xyXG5cclxuY29uc3Qge1xyXG4gIFdyYXBwZWRWYWx1ZTogV3JhcHBlZFZhbHVlJDFcclxufSA9IFJlY29pbF9XcmFwcGVyJDE7XHJcblxyXG5cclxuXHJcbmNvbnN0IHtcclxuICBnZXROb2RlTG9hZGFibGU6IGdldE5vZGVMb2FkYWJsZSQyLFxyXG4gIHBlZWtOb2RlTG9hZGFibGU6IHBlZWtOb2RlTG9hZGFibGUkMSxcclxuICBzZXROb2RlVmFsdWU6IHNldE5vZGVWYWx1ZSQzXHJcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XHJcblxyXG5jb25zdCB7XHJcbiAgc2F2ZURlcHNUb1N0b3JlOiBzYXZlRGVwc1RvU3RvcmUkMVxyXG59ID0gUmVjb2lsX0dyYXBoO1xyXG5cclxuY29uc3Qge1xyXG4gIERFRkFVTFRfVkFMVUU6IERFRkFVTFRfVkFMVUUkNixcclxuICBnZXRDb25maWdEZWxldGlvbkhhbmRsZXI6IGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQxLFxyXG4gIGdldE5vZGU6IGdldE5vZGUkNixcclxuICByZWdpc3Rlck5vZGU6IHJlZ2lzdGVyTm9kZSQxXHJcbn0gPSBSZWNvaWxfTm9kZTtcclxuXHJcbmNvbnN0IHtcclxuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDNcclxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xyXG5cclxuY29uc3Qge1xyXG4gIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkOiBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQxXHJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XHJcblxyXG5jb25zdCB7XHJcbiAgcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0OiByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQkMVxyXG59ID0gUmVjb2lsX1JldGVudGlvbjtcclxuXHJcbmNvbnN0IHtcclxuICByZWNvaWxDYWxsYmFjazogcmVjb2lsQ2FsbGJhY2skMVxyXG59ID0gUmVjb2lsX3VzZVJlY29pbENhbGxiYWNrO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY29uc3Qge1xyXG4gIHN0YXJ0UGVyZkJsb2NrOiBzdGFydFBlcmZCbG9jayQxXHJcbn0gPSBSZWNvaWxfUGVyZm9ybWFuY2VUaW1pbmdzO1xyXG5cclxuXHJcblxyXG5jbGFzcyBDYW5jZWxlZCB7fVxyXG5cclxuY29uc3QgQ0FOQ0VMRUQgPSBuZXcgQ2FuY2VsZWQoKTtcclxuLyoqXHJcbiAqIEFuIEV4ZWN1dGlvbklEIGlzIGFuIGFyYml0cmFyeSBJRCB0aGF0IGxldHMgdXMgZGlzdGluZ3Vpc2ggZXhlY3V0aW9ucyBmcm9tXHJcbiAqIGVhY2ggb3RoZXIuIFRoaXMgaXMgbmVjZXNzYXJ5IGFzIHdlIG5lZWQgYSB3YXkgb2Ygc29sdmluZyB0aGlzIHByb2JsZW06XHJcbiAqIFwiZ2l2ZW4gMyBhc3luYyBleGVjdXRpb25zLCBvbmx5IHVwZGF0ZSBzdGF0ZSBmb3IgdGhlICdsYXRlc3QnIGV4ZWN1dGlvbiB3aGVuXHJcbiAqIGl0IGZpbmlzaGVzIHJ1bm5pbmcgcmVnYXJkbGVzcyBvZiB3aGVuIHRoZSBvdGhlciAyIGZpbmlzaFwiLiBFeGVjdXRpb25JRHNcclxuICogcHJvdmlkZSBhIGNvbnZlbmllbnQgd2F5IG9mIGlkZW50aWZ5aW5nIGV4ZWN1dGlvbnMgc28gdGhhdCB3ZSBjYW4gdHJhY2sgYW5kXHJcbiAqIG1hbmFnZSB0aGVtIG92ZXIgdGltZS5cclxuICovXHJcblxyXG5jb25zdCBkZXBlbmRlbmN5U3RhY2sgPSBbXTsgLy8gZm9yIGRldGVjdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXHJcblxyXG5jb25zdCB3YWl0aW5nU3RvcmVzID0gbmV3IE1hcCgpO1xyXG5cclxuY29uc3QgZ2V0TmV3RXhlY3V0aW9uSUQgPSAoKCkgPT4ge1xyXG4gIGxldCBleGVjdXRpb25JRCA9IDA7XHJcbiAgcmV0dXJuICgpID0+IGV4ZWN1dGlvbklEKys7XHJcbn0pKCk7XHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIHNlbGVjdG9yKG9wdGlvbnMpIHtcclxuICBsZXQgcmVjb2lsVmFsdWUgPSBudWxsO1xyXG4gIGNvbnN0IHtcclxuICAgIGtleSxcclxuICAgIGdldCxcclxuICAgIGNhY2hlUG9saWN5X1VOU1RBQkxFOiBjYWNoZVBvbGljeVxyXG4gIH0gPSBvcHRpb25zO1xyXG4gIGNvbnN0IHNldCA9IG9wdGlvbnMuc2V0ICE9IG51bGwgPyBvcHRpb25zLnNldCA6IHVuZGVmaW5lZDsgLy8gZmxvd1xyXG5cclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgUmVjb2lsX2VycignQSBrZXkgb3B0aW9uIHdpdGggYSB1bmlxdWUgc3RyaW5nIHZhbHVlIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBjcmVhdGluZyBhIHNlbGVjdG9yLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IFJlY29pbF9lcnIoJ1NlbGVjdG9ycyBtdXN0IHNwZWNpZnkgYSBnZXQgY2FsbGJhY2sgb3B0aW9uIHRvIGdldCB0aGUgc2VsZWN0b3IgdmFsdWUuJyk7XHJcbiAgICB9XHJcbiAgfSAvLyBUaGlzIGlzIGV2ZXJ5IGRpc2NvdmVyZWQgZGVwZW5kZW5jeSBhY3Jvc3MgYWxsIGV4ZWN1dGlvbnNcclxuXHJcblxyXG4gIGNvbnN0IGRpc2NvdmVyZWREZXBlbmRlbmN5Tm9kZUtleXMgPSBuZXcgU2V0KCk7XHJcbiAgY29uc3QgY2FjaGUgPSBSZWNvaWxfdHJlZUNhY2hlRnJvbVBvbGljeShjYWNoZVBvbGljeSAhPT0gbnVsbCAmJiBjYWNoZVBvbGljeSAhPT0gdm9pZCAwID8gY2FjaGVQb2xpY3kgOiB7XHJcbiAgICBlcXVhbGl0eTogJ3JlZmVyZW5jZScsXHJcbiAgICBldmljdGlvbjogJ2tlZXAtYWxsJ1xyXG4gIH0sIGtleSk7XHJcbiAgY29uc3QgcmV0YWluZWRCeSA9IHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCQxKG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSk7XHJcbiAgY29uc3QgZXhlY3V0aW9uSW5mb01hcCA9IG5ldyBNYXAoKTtcclxuICBsZXQgbGl2ZVN0b3Jlc0NvdW50ID0gMDtcclxuXHJcbiAgZnVuY3Rpb24gc2VsZWN0b3JJc0xpdmUoKSB7XHJcbiAgICByZXR1cm4gIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykgfHwgbGl2ZVN0b3Jlc0NvdW50ID4gMDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNlbGVjdG9ySW5pdChzdG9yZSkge1xyXG4gICAgc3RvcmUuZ2V0U3RhdGUoKS5rbm93blNlbGVjdG9ycy5hZGQoa2V5KTtcclxuICAgIGxpdmVTdG9yZXNDb3VudCsrO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgbGl2ZVN0b3Jlc0NvdW50LS07XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2VsZWN0b3JTaG91bGREZWxldGVDb25maWdPblJlbGVhc2UoKSB7XHJcbiAgICByZXR1cm4gZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDEoa2V5KSAhPT0gdW5kZWZpbmVkICYmICFzZWxlY3RvcklzTGl2ZSgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVzb2x2ZUFzeW5jKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpIHtcclxuICAgIHNldENhY2hlKHN0YXRlLCBsb2FkYWJsZSwgZGVwVmFsdWVzKTtcclxuICAgIG5vdGlmeVN0b3Jlc09mUmVzb2x2ZWRBc3luYyhzdG9yZSwgZXhlY3V0aW9uSUQpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbm90aWZ5U3RvcmVzT2ZSZXNvbHZlZEFzeW5jKHN0b3JlLCBleGVjdXRpb25JRCkge1xyXG4gICAgaWYgKGlzTGF0ZXN0RXhlY3V0aW9uKHN0b3JlLCBleGVjdXRpb25JRCkpIHtcclxuICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcclxuICAgIH1cclxuXHJcbiAgICBub3RpZnlXYWl0aW5nU3RvcmVzKGV4ZWN1dGlvbklELCB0cnVlKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogTm90aWZ5IHN0b3JlcyB0byBwdWxsIHRoZSBzZWxlY3RvciBhZ2FpbiBpZiBhIG5ldyBhc3luYyBkZXAgd2FzIGRpc2NvdmVyZWQuXHJcbiAgICogMSkgQXN5bmMgc2VsZWN0b3IgYWRkcyBhIG5ldyBkZXAgYnV0IGRvZXNuJ3QgcmVzb2x2ZSB5ZXQuXHJcbiAgICogICAgTm90ZSB0aGF0IGRlcHMgZm9yIGFuIGFzeW5jIHNlbGVjdG9yIGFyZSBiYXNlZCBvbiB0aGUgc3RhdGUgd2hlbiB0aGVcclxuICAgKiAgICBldmFsdWF0aW9uIHN0YXJ0ZWQsIGluIG9yZGVyIHRvIHByb3ZpZGUgYSBjb25zaXN0ZW50IHBpY3R1cmUgb2Ygc3RhdGUuXHJcbiAgICogMikgQnV0LCBuZXcgdmFsdWUgb2YgZGVwIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIG1pZ2h0IGNhdXNlIHRoZSBzZWxlY3RvclxyXG4gICAqICAgIHRvIHJlc29sdmUgb3IgcmVzb2x2ZSBkaWZmZXJlbnRseS5cclxuICAgKiAzKSBUaGVyZWZvcmUsIHRoaXMgbm90aWZpY2F0aW9uIHdpbGwgcHVsbCB0aGUgc2VsZWN0b3IgYmFzZWQgb24gdGhlIGN1cnJlbnRcclxuICAgKiAgICBzdGF0ZSBmb3IgdGhlIGNvbXBvbmVudHNcclxuICAgKi9cclxuXHJcblxyXG4gIGZ1bmN0aW9uIG5vdGlmeVN0b3Jlc09mTmV3QXN5bmNEZXAoc3RvcmUsIGV4ZWN1dGlvbklEKSB7XHJcbiAgICBpZiAoaXNMYXRlc3RFeGVjdXRpb24oc3RvcmUsIGV4ZWN1dGlvbklEKSkge1xyXG4gICAgICBjb25zdCBleGVjdXRpb25JbmZvID0gUmVjb2lsX251bGx0aHJvd3MoZ2V0RXhlY3V0aW9uSW5mbyhzdG9yZSkpO1xyXG4gICAgICBleGVjdXRpb25JbmZvLnN0YXRlVmVyc2lvbnMuY2xlYXIoKTtcclxuICAgICAgbm90aWZ5V2FpdGluZ1N0b3JlcyhleGVjdXRpb25JRCwgZmFsc2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbm90aWZ5V2FpdGluZ1N0b3JlcyhleGVjdXRpb25JRCwgY2xlYXJXYWl0bGlzdCkge1xyXG4gICAgY29uc3Qgc3RvcmVzID0gd2FpdGluZ1N0b3Jlcy5nZXQoZXhlY3V0aW9uSUQpO1xyXG5cclxuICAgIGlmIChzdG9yZXMgIT0gbnVsbCkge1xyXG4gICAgICBmb3IgKGNvbnN0IHdhaXRpbmdTdG9yZSBvZiBzdG9yZXMpIHtcclxuICAgICAgICBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQxKHdhaXRpbmdTdG9yZSwgUmVjb2lsX251bGx0aHJvd3MocmVjb2lsVmFsdWUpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNsZWFyV2FpdGxpc3QpIHtcclxuICAgICAgICB3YWl0aW5nU3RvcmVzLmRlbGV0ZShleGVjdXRpb25JRCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG1hcmtTdG9yZVdhaXRpbmdGb3JSZXNvbHZlZEFzeW5jKHN0b3JlLCBleGVjdXRpb25JRCkge1xyXG4gICAgbGV0IHN0b3JlcyA9IHdhaXRpbmdTdG9yZXMuZ2V0KGV4ZWN1dGlvbklEKTtcclxuXHJcbiAgICBpZiAoc3RvcmVzID09IG51bGwpIHtcclxuICAgICAgd2FpdGluZ1N0b3Jlcy5zZXQoZXhlY3V0aW9uSUQsIHN0b3JlcyA9IG5ldyBTZXQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RvcmVzLmFkZChzdG9yZSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gYXR0YWNoZXMgYSB0aGVuKCkgYW5kIGEgY2F0Y2goKSB0byBhIHByb21pc2UgdGhhdCB3YXNcclxuICAgKiByZXR1cm5lZCBmcm9tIGEgc2VsZWN0b3IncyBnZXQoKSAoZWl0aGVyIGV4cGxpY2l0bHkgb3IgaW1wbGljaXRseSBieVxyXG4gICAqIHJ1bm5pbmcgYSBmdW5jdGlvbiB0aGF0IHVzZXMgdGhlIFwiYXN5bmNcIiBrZXl3b3JkKS4gSWYgYSBzZWxlY3RvcidzIGdldCgpXHJcbiAgICogcmV0dXJucyBhIHByb21pc2UsIHdlIGhhdmUgdHdvIHBvc3NpYmlsaXRpZXM6XHJcbiAgICpcclxuICAgKiAxLiBUaGUgcHJvbWlzZSB3aWxsIHJlc29sdmUsIGluIHdoaWNoIGNhc2UgaXQgd2lsbCBoYXZlIGNvbXBsZXRlbHkgZmluaXNoZWRcclxuICAgKiAgICBleGVjdXRpbmcgd2l0aG91dCBhbnkgcmVtYWluaW5nIHBlbmRpbmcgZGVwZW5kZW5jaWVzLiBObyBtb3JlIHJldHJpZXNcclxuICAgKiAgICBhcmUgbmVlZGVkIGFuZCB3ZSBjYW4gcHJvY2VlZCB3aXRoIHVwZGF0aW5nIHRoZSBjYWNoZSBhbmQgbm90aWZ5aW5nXHJcbiAgICogICAgc3Vic2NyaWJlcnMgKGlmIGl0IGlzIHRoZSBsYXRlc3QgZXhlY3V0aW9uLCBvdGhlcndpc2Ugb25seSB0aGUgY2FjaGVcclxuICAgKiAgICB3aWxsIGJlIHVwZGF0ZWQgYW5kIHN1YnNjcmlwdGlvbnMgd2lsbCBub3QgYmUgZmlyZWQpLiBUaGlzIGlzIHRoZSBjYXNlXHJcbiAgICogICAgaGFuZGxlZCBieSB0aGUgYXR0YWNoZWQgdGhlbigpIGhhbmRsZXIuXHJcbiAgICpcclxuICAgKiAyLiBUaGUgcHJvbWlzZSB3aWxsIHRocm93IGJlY2F1c2UgaXQgZWl0aGVyIGhhcyBhbiBlcnJvciBvciBpdCBjYW1lIGFjcm9zc1xyXG4gICAqICAgIGFuIGFzeW5jIGRlcGVuZGVuY3kgdGhhdCBoYXMgbm90IHlldCByZXNvbHZlZCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsXHJcbiAgICogICAgY2FsbCB3cmFwRGVwZGVuY3lQcm9taXNlKCksIHdob3NlIHJlc3BvbnNpYmlsaXR5IGlzIHRvIGhhbmRsZSBkZXBlbmRlbmN5XHJcbiAgICogICAgcHJvbWlzZXMuIFRoaXMgY2FzZSBpcyBoYW5kbGVkIGJ5IHRoZSBhdHRhY2hlZCBjYXRjaCgpIGhhbmRsZXIuXHJcbiAgICpcclxuICAgKiBCb3RoIGJyYW5jaGVzIHdpbGwgZXZlbnR1YWxseSByZXNvbHZlIHRvIHRoZSBmaW5hbCByZXN1bHQgb2YgdGhlIHNlbGVjdG9yXHJcbiAgICogKG9yIGFuIGVycm9yIGlmIGEgcmVhbCBlcnJvciBvY2N1cnJlZCkuXHJcbiAgICpcclxuICAgKiBUaGUgZXhlY3V0aW9uIHdpbGwgcnVuIHRvIGNvbXBsZXRpb24gZXZlbiBpZiBpdCBpcyBzdGFsZSwgYW5kIGl0cyB2YWx1ZVxyXG4gICAqIHdpbGwgYmUgY2FjaGVkLiBCdXQgc3RhbGUgZXhlY3V0aW9ucyB3aWxsIG5vdCB1cGRhdGUgZ2xvYmFsIHN0YXRlIG9yIHVwZGF0ZVxyXG4gICAqIGV4ZWN1dGlvbkluZm8gYXMgdGhhdCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlICdsYXRlc3QnIGV4ZWN1dGlvbi5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIHBhc3NlZCBhIHByb21pc2UgdGhhdCB3YXMgdGhyb3duLS1BS0EgYVxyXG4gICAqIGRlcGVuZGVuY3kgcHJvbWlzZS4gRGVwZW5kZW5jeSBwcm9taXNlcyBzaG91bGQgYmUgcGFzc2VkIHRvXHJcbiAgICogd3JhcFBlbmRpbmdEZXBlbmRlbmN5UHJvbWlzZSgpKS5cclxuICAgKi9cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHdyYXBSZXN1bHRQcm9taXNlKHN0b3JlLCBwcm9taXNlLCBzdGF0ZSwgZGVwVmFsdWVzLCBleGVjdXRpb25JRCwgbG9hZGluZ0RlcHNTdGF0ZSkge1xyXG4gICAgcmV0dXJuIHByb21pc2UudGhlbih2YWx1ZSA9PiB7XHJcbiAgICAgIGlmICghc2VsZWN0b3JJc0xpdmUoKSkge1xyXG4gICAgICAgIC8vIFRoZSBzZWxlY3RvciB3YXMgcmVsZWFzZWQgc2luY2UgdGhlIHJlcXVlc3QgYmVnYW47IGlnbm9yZSB0aGUgcmVzcG9uc2UuXHJcbiAgICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcclxuICAgICAgICB0aHJvdyBDQU5DRUxFRDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbG9hZGFibGUgPSBsb2FkYWJsZVdpdGhWYWx1ZSQyKHZhbHVlKTtcclxuICAgICAgcmVzb2x2ZUFzeW5jKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9KS5jYXRjaChlcnJvck9yUHJvbWlzZSA9PiB7XHJcbiAgICAgIGlmICghc2VsZWN0b3JJc0xpdmUoKSkge1xyXG4gICAgICAgIC8vIFRoZSBzZWxlY3RvciB3YXMgcmVsZWFzZWQgc2luY2UgdGhlIHJlcXVlc3QgYmVnYW47IGlnbm9yZSB0aGUgcmVzcG9uc2UuXHJcbiAgICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcclxuICAgICAgICB0aHJvdyBDQU5DRUxFRDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UoZXJyb3JPclByb21pc2UpKSB7XHJcbiAgICAgICAgcmV0dXJuIHdyYXBQZW5kaW5nRGVwZW5kZW5jeVByb21pc2Uoc3RvcmUsIGVycm9yT3JQcm9taXNlLCBzdGF0ZSwgZGVwVmFsdWVzLCBleGVjdXRpb25JRCwgbG9hZGluZ0RlcHNTdGF0ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGxvYWRhYmxlID0gbG9hZGFibGVXaXRoRXJyb3IkMShlcnJvck9yUHJvbWlzZSk7XHJcbiAgICAgIHJlc29sdmVBc3luYyhzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklELCBsb2FkYWJsZSwgZGVwVmFsdWVzKTtcclxuICAgICAgdGhyb3cgZXJyb3JPclByb21pc2U7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogVGhpcyBmdW5jdGlvbiBhdHRhY2hlcyBhIHRoZW4oKSBhbmQgYSBjYXRjaCgpIHRvIGEgcHJvbWlzZSB0aGF0IHdhc1xyXG4gICAqIHRocm93biBmcm9tIGEgc2VsZWN0b3IncyBnZXQoKS4gSWYgYSBzZWxlY3RvcidzIGdldCgpIHRocm93cyBhIHByb21pc2UsXHJcbiAgICogd2UgaGF2ZSB0d28gcG9zc2liaWxpdGllczpcclxuICAgKlxyXG4gICAqIDEuIFRoZSBwcm9taXNlIHdpbGwgcmVzb2x2ZSwgbWVhbmluZyBvbmUgb2Ygb3VyIHNlbGVjdG9yJ3MgZGVwZW5kZW5jaWVzIGlzXHJcbiAgICogICAgbm93IGF2YWlsYWJsZSBhbmQgd2Ugc2hvdWxkIFwicmV0cnlcIiBvdXIgZ2V0KCkgYnkgcnVubmluZyBpdCBhZ2Fpbi4gVGhpc1xyXG4gICAqICAgIGlzIHRoZSBjYXNlIGhhbmRsZWQgYnkgdGhlIGF0dGFjaGVkIHRoZW4oKSBoYW5kbGVyLlxyXG4gICAqXHJcbiAgICogMi4gVGhlIHByb21pc2Ugd2lsbCB0aHJvdyBiZWNhdXNlIHNvbWV0aGluZyB3ZW50IHdyb25nIHdpdGggdGhlIGRlcGVuZGVuY3lcclxuICAgKiAgICBwcm9taXNlIChpbiBvdGhlciB3b3JkcyBhIHJlYWwgZXJyb3Igb2NjdXJyZWQpLiBUaGlzIGNhc2UgaXMgaGFuZGxlZCBieVxyXG4gICAqICAgIHRoZSBhdHRhY2hlZCBjYXRjaCgpIGhhbmRsZXIuIElmIHRoZSBkZXBlbmRlbmN5IHByb21pc2UgdGhyb3dzLCBpdCBpc1xyXG4gICAqICAgIF9hbHdheXNfIGEgcmVhbCBlcnJvciBhbmQgbm90IGFub3RoZXIgZGVwZW5kZW5jeSBwcm9taXNlIChhbnkgZGVwZW5kZW5jeVxyXG4gICAqICAgIHByb21pc2VzIHdvdWxkIGhhdmUgYmVlbiBoYW5kbGVkIHVwc3RyZWFtKS5cclxuICAgKlxyXG4gICAqIFRoZSB0aGVuKCkgYnJhbmNoIHdpbGwgZXZlbnR1YWxseSByZXNvbHZlIHRvIHRoZSBmaW5hbCByZXN1bHQgb2YgdGhlXHJcbiAgICogc2VsZWN0b3IgKG9yIGFuIGVycm9yIGlmIGEgcmVhbCBlcnJvciBvY2N1cnMpLCBhbmQgdGhlIGNhdGNoKCkgd2lsbCBhbHdheXNcclxuICAgKiByZXNvbHZlIHRvIGFuIGVycm9yIGJlY2F1c2UgdGhlIGRlcGVuZGVuY3kgcHJvbWlzZSBpcyBhIHByb21pc2UgdGhhdCB3YXNcclxuICAgKiB3cmFwcGVkIHVwc3RyZWFtLCBtZWFuaW5nIGl0IHdpbGwgb25seSByZXNvbHZlIHRvIGl0cyByZWFsIHZhbHVlIG9yIHRvIGFcclxuICAgKiByZWFsIGVycm9yLlxyXG4gICAqXHJcbiAgICogVGhlIGV4ZWN1dGlvbiB3aWxsIHJ1biB0byBjb21wbGV0aW9uIGV2ZW4gaWYgaXQgaXMgc3RhbGUsIGFuZCBpdHMgdmFsdWVcclxuICAgKiB3aWxsIGJlIGNhY2hlZC4gQnV0IHN0YWxlIGV4ZWN1dGlvbnMgd2lsbCBub3QgdXBkYXRlIGdsb2JhbCBzdGF0ZSBvciB1cGRhdGVcclxuICAgKiBleGVjdXRpb25JbmZvIGFzIHRoYXQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSAnbGF0ZXN0JyBleGVjdXRpb24uXHJcbiAgICpcclxuICAgKiBOb3RlIHRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBwYXNzZWQgYSBwcm9taXNlIHRoYXQgd2FzIHJldHVybmVkIGZyb21cclxuICAgKiBnZXQoKS4gVGhlIGludGVudGlvbiBpcyB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgb25seSBwYXNzZWQgcHJvbWlzZXMgdGhhdFxyXG4gICAqIHdlcmUgdGhyb3duIGR1ZSB0byBhIHBlbmRpbmcgZGVwZW5kZW5jeS4gUHJvbWlzZXMgcmV0dXJuZWQgYnkgZ2V0KCkgc2hvdWxkXHJcbiAgICogYmUgcGFzc2VkIHRvIHdyYXBSZXN1bHRQcm9taXNlKCkgaW5zdGVhZC5cclxuICAgKi9cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHdyYXBQZW5kaW5nRGVwZW5kZW5jeVByb21pc2Uoc3RvcmUsIHByb21pc2UsIHN0YXRlLCBleGlzdGluZ0RlcHMsIGV4ZWN1dGlvbklELCBsb2FkaW5nRGVwc1N0YXRlKSB7XHJcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKHJlc29sdmVkRGVwID0+IHtcclxuICAgICAgaWYgKCFzZWxlY3RvcklzTGl2ZSgpKSB7XHJcbiAgICAgICAgLy8gVGhlIHNlbGVjdG9yIHdhcyByZWxlYXNlZCBzaW5jZSB0aGUgcmVxdWVzdCBiZWdhbjsgaWdub3JlIHRoZSByZXNwb25zZS5cclxuICAgICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xyXG4gICAgICAgIHRocm93IENBTkNFTEVEO1xyXG4gICAgICB9IC8vIENoZWNrIGlmIHdlIGFyZSBoYW5kbGluZyBhIHBlbmRpbmcgUmVjb2lsIGRlcGVuZGVuY3kgb3IgaWYgdGhlIHVzZXJcclxuICAgICAgLy8gdGhyZXcgdGhlaXIgb3duIFByb21pc2UgdG8gXCJzdXNwZW5kXCIgYSBzZWxlY3RvciBldmFsdWF0aW9uLiAgV2UgbmVlZFxyXG4gICAgICAvLyB0byBjaGVjayB0aGF0IHRoZSBsb2FkaW5nRGVwUHJvbWlzZSBhY3R1YWxseSBtYXRjaGVzIHRoZSBwcm9taXNlIHRoYXRcclxuICAgICAgLy8gd2UgY2F1Z2h0IGluIGNhc2UgdGhlIHNlbGVjdG9yIGhhcHBlbmVkIHRvIGNhdGNoIHRoZSBwcm9taXNlIHdlIHRocmV3XHJcbiAgICAgIC8vIGZvciBhIHBlbmRpbmcgUmVjb2lsIGRlcGVuZGVuY3kgZnJvbSBgZ2V0UmVjb2lsVmFsdWUoKWAgYW5kIHRocmV3XHJcbiAgICAgIC8vIHRoZWlyIG93biBwcm9taXNlIGluc3RlYWQuXHJcblxyXG5cclxuICAgICAgaWYgKGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcEtleSAhPSBudWxsICYmIGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcFByb21pc2UgPT09IHByb21pc2UpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOb3RlIGZvciBhc3luYyBhdG9tcywgdGhpcyBtZWFucyB3ZSBhcmUgY2hhbmdpbmcgdGhlIGF0b20ncyB2YWx1ZVxyXG4gICAgICAgICAqIGluIHRoZSBzdG9yZSBmb3IgdGhlIGdpdmVuIHZlcnNpb24uIFRoaXMgc2hvdWxkIGJlIGFscmlnaHQgYmVjYXVzZVxyXG4gICAgICAgICAqIHRoZSB2ZXJzaW9uIG9mIHN0YXRlIGlzIG5vdyBzdGFsZSBhbmQgYSBuZXcgdmVyc2lvbiB3aWxsIGhhdmVcclxuICAgICAgICAgKiBhbHJlYWR5IGJlZW4gdHJpZ2dlcmVkIGJ5IHRoZSBhdG9tIGJlaW5nIHJlc29sdmVkIChzZWUgdGhpcyBsb2dpY1xyXG4gICAgICAgICAqIGluIFJlY29pbF9hdG9tLmpzKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRlLmF0b21WYWx1ZXMuc2V0KGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcEtleSwgbG9hZGFibGVXaXRoVmFsdWUkMihyZXNvbHZlZERlcCkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHJlc29sdmVkRGVwS2V5IGlzIG5vdCBkZWZpbmVkLCB0aGUgcHJvbWlzZSB3YXMgYSB1c2VyLXRocm93blxyXG4gICAgICAgICAqIHByb21pc2UuIFVzZXItdGhyb3duIHByb21pc2VzIGFyZSBhbiBhZHZhbmNlZCBmZWF0dXJlIGFuZCB0aGV5XHJcbiAgICAgICAgICogc2hvdWxkIGJlIGF2b2lkZWQgaW4gYWxtb3N0IGFsbCBjYXNlcy4gVXNpbmcgYGxvYWRhYmxlLm1hcCgpYCBpbnNpZGVcclxuICAgICAgICAgKiBvZiBzZWxlY3RvcnMgZm9yIGxvYWRpbmcgbG9hZGFibGVzIGFuZCB0aGVuIHRocm93aW5nIHRoYXQgbWFwcGVkXHJcbiAgICAgICAgICogbG9hZGFibGUncyBwcm9taXNlIGlzIGFuIGV4YW1wbGUgb2YgYSB1c2VyLXRocm93biBwcm9taXNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiB3ZSBoaXQgYSB1c2VyLXRocm93biBwcm9taXNlLCB3ZSBoYXZlIHRvIGJhaWwgb3V0IG9mIGFuIG9wdGltaXphdGlvblxyXG4gICAgICAgICAqIHdoZXJlIHdlIGJ5cGFzcyBjYWxjdWxhdGluZyBzZWxlY3RvciBjYWNoZSBrZXlzIGZvciBzZWxlY3RvcnMgdGhhdFxyXG4gICAgICAgICAqIGhhdmUgYmVlbiBwcmV2aW91c2x5IHNlZW4gZm9yIGEgZ2l2ZW4gc3RhdGUgKHRoZXNlIHNlbGVjdG9ycyBhcmUgc2F2ZWQgaW5cclxuICAgICAgICAgKiBzdGF0ZS5hdG9tVmFsdWVzKSB0byBhdm9pZCBzdGFsZSBzdGF0ZSBhcyB3ZSBoYXZlIG5vIHdheSBvZiBrbm93aW5nXHJcbiAgICAgICAgICogd2hhdCBzdGF0ZSBjaGFuZ2VzIGhhcHBlbmVkIChpZiBhbnkpIGluIHJlc3VsdCB0byB0aGUgcHJvbWlzZSByZXNvbHZpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJZGVhbGx5IHdlIHdvdWxkIG9ubHkgYmFpbCBvdXQgc2VsZWN0b3JzIHRoYXQgYXJlIGluIHRoZSBjaGFpbiBvZlxyXG4gICAgICAgICAqIGRlcGVuZGVuY2llcyBmb3IgdGhpcyBzZWxlY3RvciwgYnV0IHRoZXJlJ3MgY3VycmVudGx5IG5vIHdheSB0byBnZXRcclxuICAgICAgICAgKiBhIGZ1bGwgbGlzdCBvZiBhIHNlbGVjdG9yJ3MgZG93bnN0cmVhbSBub2RlcyBiZWNhdXNlIHRoZSBzdGF0ZSB0aGF0XHJcbiAgICAgICAgICogaXMgZXhlY3V0aW5nIG1heSBiZSBhIGRpc2NhcmRlZCB0cmVlIChzbyBzdG9yZS5nZXRHcmFwaChzdGF0ZS52ZXJzaW9uKVxyXG4gICAgICAgICAqIHdpbGwgYmUgZW1wdHkpLCBhbmQgdGhlIGZ1bGwgZGVwIHRyZWUgbWF5IG5vdCBiZSBpbiB0aGUgc2VsZWN0b3JcclxuICAgICAgICAgKiBjYWNoZXMgaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHNlbGVjdG9yJ3MgY2FjaGUgd2FzIGNsZWFyZWQuIFRvIHNvbHZlXHJcbiAgICAgICAgICogZm9yIHRoaXMgd2Ugd291bGQgaGF2ZSB0byBrZWVwIHRyYWNrIG9mIGFsbCBydW5uaW5nIHNlbGVjdG9yXHJcbiAgICAgICAgICogZXhlY3V0aW9ucyBhbmQgdGhlaXIgZG93bnN0cmVhbSBkZXBzLiBCZWNhdXNlIHRoaXMgb25seSBjb3ZlcnMgZWRnZVxyXG4gICAgICAgICAqIGNhc2VzLCB0aGF0IGNvbXBsZXhpdHkgbWlnaHQgbm90IGJlIGp1c3RpZnlhYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkua25vd25TZWxlY3RvcnMuZm9yRWFjaChub2RlS2V5ID0+IHtcclxuICAgICAgICAgIHN0YXRlLmF0b21WYWx1ZXMuZGVsZXRlKG5vZGVLZXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBPcHRpbWl6YXRpb246IE5vdyB0aGF0IHRoZSBkZXBlbmRlbmN5IGhhcyByZXNvbHZlZCwgbGV0J3MgdHJ5IGhpdHRpbmdcclxuICAgICAgICogdGhlIGNhY2hlIGluIGNhc2UgdGhlIGRlcCByZXNvbHZlZCB0byBhIHZhbHVlIHdlIGhhdmUgcHJldmlvdXNseSBzZWVuLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBUT0RPOlxyXG4gICAgICAgKiBOb3RlIHRoaXMgb3B0aW1pemF0aW9uIGlzIG5vdCBwZXJmZWN0IGJlY2F1c2UgaXQgb25seSBwcmV2ZW50cyByZS1leGVjdXRpb25zXHJcbiAgICAgICAqIF9hZnRlcl8gdGhlIHBvaW50IHdoZXJlIGFuIGFzeW5jIGRlcGVuZGVuY3kgaXMgZm91bmQuIEFueSBjb2RlIGxlYWRpbmdcclxuICAgICAgICogdXAgdG8gdGhlIGFzeW5jIGRlcGVuZGVuY3kgbWF5IGhhdmUgcnVuIHVubmVjZXNzYXJpbHkuIFRoZSBpZGVhbCBjYXNlXHJcbiAgICAgICAqIHdvdWxkIGJlIHRvIHdhaXQgZm9yIHRoZSBhc3luYyBkZXBlbmRlbmN5IHRvIHJlc29sdmUgZmlyc3QsIGNoZWNrIHRoZVxyXG4gICAgICAgKiBjYWNoZSwgYW5kIHByZXZlbnQgX2FueV8gZXhlY3V0aW9uIG9mIHRoZSBzZWxlY3RvciBpZiB0aGUgcmVzdWx0aW5nXHJcbiAgICAgICAqIHZhbHVlIG9mIHRoZSBkZXBlbmRlbmN5IGxlYWRzIHRvIGEgcGF0aCB0aGF0IGlzIGZvdW5kIGluIHRoZSBjYWNoZS5cclxuICAgICAgICogVGhlIGlkZWFsIGNhc2UgaXMgbW9yZSBkaWZmaWN1bHQgdG8gaW1wbGVtZW50IGFzIGl0IHdvdWxkIHJlcXVpcmUgdGhhdFxyXG4gICAgICAgKiB3ZSBjYXB0dXJlIGFuZCB3YWl0IGZvciB0aGUgdGhlIGFzeW5jIGRlcGVuZGVuY3kgcmlnaHQgYWZ0ZXIgY2hlY2tpbmdcclxuICAgICAgICogdGhlIGNhY2hlLiBUaGUgY3VycmVudCBhcHByb2FjaCB0YWtlcyBhZHZhbnRhZ2Ugb2YgdGhlIGZhY3QgdGhhdCBydW5uaW5nXHJcbiAgICAgICAqIHRoZSBzZWxlY3RvciBhbHJlYWR5IGhhcyBhIGNvZGUgcGF0aCB0aGF0IGxldHMgdXMgZXhpdCBlYXJseSB3aGVuXHJcbiAgICAgICAqIGFuIGFzeW5jIGRlcCByZXNvbHZlcy5cclxuICAgICAgICovXHJcblxyXG5cclxuICAgICAgY29uc3QgY2FjaGVkTG9hZGFibGUgPSBnZXRMb2FkYWJsZUZyb21DYWNoZUFuZFVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlKTtcclxuXHJcbiAgICAgIGlmIChjYWNoZWRMb2FkYWJsZSAmJiBjYWNoZWRMb2FkYWJsZS5zdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBoYXMgdG8gbm90aWZ5IHN0b3JlcyBvZiBhIHJlc29sdmVkIGFzeW5jLCBldmVuIGlmIHRoZXJlIGlzIG5vXHJcbiAgICAgICAgICogY3VycmVudCBwZW5kaW5nIGV4ZWN1dGlvbiBmb3IgdGhlIGZvbGxvd2luZyBjYXNlOlxyXG4gICAgICAgICAqIDEpIEEgY29tcG9uZW50IHJlbmRlcnMgd2l0aCB0aGlzIHBlbmRpbmcgbG9hZGFibGUuXHJcbiAgICAgICAgICogMikgVGhlIHVwc3RyZWFtIGRlcGVuZGVuY3kgcmVzb2x2ZXMuXHJcbiAgICAgICAgICogMykgV2hpbGUgcHJvY2Vzc2luZyBzb21lIG90aGVyIHNlbGVjdG9yIGl0IHJlYWRzIHRoaXMgb25lLCBzdWNoIGFzXHJcbiAgICAgICAgICogICAgd2hpbGUgdHJhdmVyc2luZyBpdHMgZGVwZW5kZW5jaWVzLiAgQXQgdGhpcyBwb2ludCBpdCBnZXRzIHRoZVxyXG4gICAgICAgICAqICAgIG5ldyByZXNvbHZlZCB2YWx1ZSBzeW5jaHJvbm91c2x5IGFuZCBjbGVhcnMgdGhlIGN1cnJlbnRcclxuICAgICAgICAgKiAgICBleGVjdXRpb24gSUQuICBUaGUgY29tcG9uZW50IHdhc24ndCBnZXR0aW5nIHRoZSB2YWx1ZSBpdHNlbGYsXHJcbiAgICAgICAgICogICAgdGhvdWdoLCBzbyBpdCBzdGlsbCBoYXMgdGhlIHBlbmRpbmcgbG9hZGFibGUuXHJcbiAgICAgICAgICogNCkgV2hlbiB0aGlzIGNvZGUgZXhlY3V0ZXMgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGlkIHdhcyBjbGVhcmVkXHJcbiAgICAgICAgICogICAgYW5kIGl0IHdvdWxkbid0IG5vdGlmeSB0aGUgY29tcG9uZW50IG9mIHRoZSBuZXcgdmFsdWUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJIHRoaW5rIHRoaXMgaXMgb25seSBhbiBpc3N1ZSB3aXRoIFwiZWFybHlcIiByZW5kZXJpbmcgc2luY2UgdGhlXHJcbiAgICAgICAgICogY29tcG9uZW50cyBnb3QgdGhlaXIgdmFsdWUgdXNpbmcgdGhlIGluLXByb2dyZXNzIGV4ZWN1dGlvbi5cclxuICAgICAgICAgKiBXZSBkb24ndCBoYXZlIGEgdW5pdCB0ZXN0IGZvciB0aGlzIGNhc2UgeWV0LiAgSSdtIG5vdCBzdXJlIGl0IGlzXHJcbiAgICAgICAgICogbmVjZXNzYXJ5IHdpdGggcmVjb2lsX3RyYW5zaXRpb25fc3VwcG9ydCBtb2RlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmIChpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpIHx8IGdldEV4ZWN1dGlvbkluZm8oc3RvcmUpID09IG51bGwpIHtcclxuICAgICAgICAgIG5vdGlmeVN0b3Jlc09mUmVzb2x2ZWRBc3luYyhzdG9yZSwgZXhlY3V0aW9uSUQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhY2hlZExvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnKSB7XHJcbiAgICAgICAgICByZXR1cm4gY2FjaGVkTG9hZGFibGUuY29udGVudHM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRocm93IGNhY2hlZExvYWRhYmxlLmNvbnRlbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvKipcclxuICAgICAgICogSWYgdGhpcyBleGVjdXRpb24gaXMgc3RhbGUsIGxldCdzIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBzb21lIGluXHJcbiAgICAgICAqIHByb2dyZXNzIGV4ZWN1dGlvbiB3aXRoIGEgbWF0Y2hpbmcgc3RhdGUuIElmIHdlIGZpbmQgYSBtYXRjaCwgdGhlblxyXG4gICAgICAgKiB3ZSBjYW4gdGFrZSB0aGUgdmFsdWUgZnJvbSB0aGF0IGluLXByb2dyZXNzIGV4ZWN1dGlvbi4gTm90ZSB0aGlzIG1heVxyXG4gICAgICAgKiBzb3VuZCBsaWtlIGFuIGVkZ2UgY2FzZSwgYnV0IG1heSBiZSB2ZXJ5IGNvbW1vbiBpbiBjYXNlcyB3aGVyZSBhXHJcbiAgICAgICAqIGxvYWRpbmcgZGVwZW5kZW5jeSByZXNvbHZlcyBmcm9tIGxvYWRpbmcgdG8gaGF2aW5nIGEgdmFsdWUgKHRodXNcclxuICAgICAgICogcG9zc2libHkgdHJpZ2dlcmluZyBhIHJlLXJlbmRlciksIGFuZCBSZWFjdCByZS1yZW5kZXJzIGJlZm9yZSB0aGVcclxuICAgICAgICogY2hhaW5lZCAudGhlbigpIGZ1bmN0aW9ucyBydW4sIHRodXMgc3RhcnRpbmcgYSBuZXcgZXhlY3V0aW9uIGFzIHRoZVxyXG4gICAgICAgKiBkZXAgaGFzIGNoYW5nZWQgdmFsdWUuIFdpdGhvdXQgdGhpcyBjaGVjayB3ZSB3aWxsIHJ1biB0aGUgc2VsZWN0b3JcclxuICAgICAgICogdHdpY2UgKG9uY2UgaW4gdGhlIG5ldyBleGVjdXRpb24gYW5kIG9uY2UgYWdhaW4gaW4gdGhpcyAudGhlbigpLCBzb1xyXG4gICAgICAgKiB0aGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBrZWVwIHVubmVjZXNzYXJ5IHJlLWV4ZWN1dGlvbnMgdG8gYVxyXG4gICAgICAgKiBtaW5pbXVtKS5cclxuICAgICAgICpcclxuICAgICAgICogQWxzbyBub3RlIHRoaXMgY29kZSBkb2VzIG5vdCBjaGVjayBhY3Jvc3MgYWxsIGV4ZWN1dGlvbnMgdGhhdCBtYXkgYmVcclxuICAgICAgICogcnVubmluZy4gSXQgb25seSBvcHRpbWl6ZXMgZm9yIHRoZSBfbGF0ZXN0XyBleGVjdXRpb24gcGVyIHN0b3JlIGFzXHJcbiAgICAgICAqIHdlIGN1cnJlbnRseSBkbyBub3QgbWFpbnRhaW4gYSBsaXN0IG9mIGFsbCBjdXJyZW50bHkgcnVubmluZyBleGVjdXRpb25zLlxyXG4gICAgICAgKiBUaGlzIG1lYW5zIGluIHNvbWUgY2FzZXMgd2UgbWF5IHJ1biBzZWxlY3RvcnMgbW9yZSB0aGFuIHN0cmljdGx5XHJcbiAgICAgICAqIG5lY2Vzc2FyeSB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBleGVjdXRpb25zIHJ1bm5pbmcgZm9yIHRoZSBzYW1lXHJcbiAgICAgICAqIHNlbGVjdG9yLiBUaGlzIG1heSBiZSBhIHZhbGlkIHRyYWRlb2ZmIGFzIGNoZWNraW5nIGZvciBkZXAgY2hhbmdlc1xyXG4gICAgICAgKiBhY3Jvc3MgYWxsIGluLXByb2dyZXNzIGV4ZWN1dGlvbnMgbWF5IHRha2UgbG9uZ2VyIHRoYW4ganVzdFxyXG4gICAgICAgKiByZS1ydW5uaW5nIHRoZSBzZWxlY3Rvci4gVGhpcyB3aWxsIGJlIGFwcC1kZXBlbmRlbnQsIGFuZCBtYXliZSBpbiB0aGVcclxuICAgICAgICogZnV0dXJlIHdlIGNhbiBtYWtlIHRoZSBiZWhhdmlvciBjb25maWd1cmFibGUuIEFuIGlkZWFsIGZpeCBtYXkgYmVcclxuICAgICAgICogdG8gZXh0ZW5kIHRoZSB0cmVlIGNhY2hlIHRvIHN1cHBvcnQgY2FjaGluZyBsb2FkaW5nIHN0YXRlcy5cclxuICAgICAgICovXHJcblxyXG5cclxuICAgICAgaWYgKCFpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpKSB7XHJcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uSW5mbyA9IGdldEluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvKHN0b3JlLCBzdGF0ZSk7XHJcblxyXG4gICAgICAgIGlmIChleGVjdXRpb25JbmZvICE9IG51bGwpIHtcclxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogUmV0dXJuaW5nIHByb21pc2UgaGVyZSB3aXRob3V0IHdyYXBwaW5nIGFzIHRoZSB3cmFwcGVyIGxvZ2ljIHdhc1xyXG4gICAgICAgICAgICogYWxyZWFkeSBkb25lIHVwc3RyZWFtIHdoZW4gdGhpcyBwcm9taXNlIHdhcyBnZW5lcmF0ZWQuXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIHJldHVybiBleGVjdXRpb25JbmZvLmxvYWRpbmdMb2FkYWJsZS5jb250ZW50cztcclxuICAgICAgICB9XHJcbiAgICAgIH0gLy8gUmV0cnkgdGhlIHNlbGVjdG9yIGV2YWx1YXRpb24gbm93IHRoYXQgdGhlIGRlcGVuZGVuY3kgaGFzIHJlc29sdmVkXHJcblxyXG5cclxuICAgICAgY29uc3QgW2xvYWRhYmxlLCBkZXBWYWx1ZXNdID0gZXZhbHVhdGVTZWxlY3RvckdldHRlcihzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklEKTtcclxuXHJcbiAgICAgIGlmIChsb2FkYWJsZS5zdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XHJcbiAgICAgICAgcmVzb2x2ZUFzeW5jKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNFcnJvcicpIHtcclxuICAgICAgICB0aHJvdyBsb2FkYWJsZS5jb250ZW50cztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGxvYWRhYmxlLmNvbnRlbnRzO1xyXG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAvLyBUaGUgc2VsZWN0b3Igd2FzIHJlbGVhc2VkIHNpbmNlIHRoZSByZXF1ZXN0IGJlZ2FuOyBpZ25vcmUgdGhlIHJlc3BvbnNlLlxyXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDYW5jZWxlZCkge1xyXG4gICAgICAgIHRocm93IENBTkNFTEVEO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXNlbGVjdG9ySXNMaXZlKCkpIHtcclxuICAgICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xyXG4gICAgICAgIHRocm93IENBTkNFTEVEO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBsb2FkYWJsZSA9IGxvYWRhYmxlV2l0aEVycm9yJDEoZXJyb3IpO1xyXG4gICAgICByZXNvbHZlQXN5bmMoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCwgbG9hZGFibGUsIGV4aXN0aW5nRGVwcyk7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1cGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSwgZGVwcywgZXhlY3V0aW9uSUQpIHtcclxuICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUsIF9zdG9yZSRnZXRTdGF0ZSRjdXJyZSwgX3N0b3JlJGdldFN0YXRlMiwgX3N0b3JlJGdldFN0YXRlMiRuZXh0O1xyXG5cclxuICAgIGlmIChpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpIHx8IHN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlJGdldFN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3N0b3JlJGdldFN0YXRlJGN1cnJlID0gX3N0b3JlJGdldFN0YXRlLmN1cnJlbnRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUkY3VycmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZSRnZXRTdGF0ZSRjdXJyZS52ZXJzaW9uKSB8fCBzdGF0ZS52ZXJzaW9uID09PSAoKF9zdG9yZSRnZXRTdGF0ZTIgPSBzdG9yZS5nZXRTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3N0b3JlJGdldFN0YXRlMiRuZXh0ID0gX3N0b3JlJGdldFN0YXRlMi5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlMiRuZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUyJG5leHQudmVyc2lvbikpIHtcclxuICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCwgX3N0b3JlJGdldFN0YXRlMywgX3N0b3JlJGdldFN0YXRlMyRuZXh0O1xyXG5cclxuICAgICAgc2F2ZURlcHNUb1N0b3JlJDEoa2V5LCBkZXBzLCBzdG9yZSwgKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA9IChfc3RvcmUkZ2V0U3RhdGUzID0gc3RvcmUuZ2V0U3RhdGUoKSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zdG9yZSRnZXRTdGF0ZTMkbmV4dCA9IF9zdG9yZSRnZXRTdGF0ZTMubmV4dFRyZWUpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZTMkbmV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlJGdldFN0YXRlMyRuZXh0LnZlcnNpb24pICE9PSBudWxsICYmIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCAhPT0gdm9pZCAwID8gX3N0b3JlJGdldFN0YXRlJG5leHRUIDogc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZS52ZXJzaW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGNvbnN0IG5vZGVLZXkgb2YgZGVwcykge1xyXG4gICAgICBkaXNjb3ZlcmVkRGVwZW5kZW5jeU5vZGVLZXlzLmFkZChub2RlS2V5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGV2YWx1YXRlU2VsZWN0b3JHZXR0ZXIoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCkge1xyXG4gICAgY29uc3QgZW5kUGVyZkJsb2NrID0gc3RhcnRQZXJmQmxvY2skMShrZXkpOyAvLyBUT0RPIFQ2Mzk2NTg2NjogdXNlIGV4ZWN1dGlvbiBJRCBoZXJlXHJcblxyXG4gICAgbGV0IGR1cmluZ1N5bmNocm9ub3VzRXhlY3V0aW9uID0gdHJ1ZTtcclxuICAgIGxldCBkdXJpbmdBc3luY2hyb25vdXNFeGVjdXRpb24gPSB0cnVlO1xyXG5cclxuICAgIGNvbnN0IGZpbmlzaEV2YWx1YXRpb24gPSAoKSA9PiB7XHJcbiAgICAgIGVuZFBlcmZCbG9jaygpO1xyXG4gICAgICBkdXJpbmdBc3luY2hyb25vdXNFeGVjdXRpb24gPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgbGV0IHJlc3VsdDtcclxuICAgIGxldCByZXN1bHRJc0Vycm9yID0gZmFsc2U7XHJcbiAgICBsZXQgbG9hZGFibGU7XHJcbiAgICBjb25zdCBsb2FkaW5nRGVwc1N0YXRlID0ge1xyXG4gICAgICBsb2FkaW5nRGVwS2V5OiBudWxsLFxyXG4gICAgICBsb2FkaW5nRGVwUHJvbWlzZTogbnVsbFxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRpbmcgYSBmcmVzaCBzZXQgb2YgZGVwcyB0aGF0IHdlJ2xsIGJlIHVzaW5nIHRvIHVwZGF0ZSBzdGF0ZS4gV2UncmVcclxuICAgICAqIHN0YXJ0aW5nIGEgbmV3IHNldCB2ZXJzdXMgYWRkaW5nIGl0IGluIGV4aXN0aW5nIHN0YXRlIGRlcHMgYmVjYXVzZVxyXG4gICAgICogdGhlIHZlcnNpb24gb2Ygc3RhdGUgdGhhdCB3ZSB1cGRhdGUgZGVwcyBmb3IgbWF5IGJlIGEgbW9yZSByZWNlbnQgdmVyc2lvblxyXG4gICAgICogdGhhbiB0aGUgdmVyc2lvbiB0aGUgc2VsZWN0b3Igd2FzIGNhbGxlZCB3aXRoLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGxhdGVzdFxyXG4gICAgICogZXhlY3V0aW9uIHdpbGwgdXBkYXRlIHRoZSBkZXBzIG9mIHRoZSBjdXJyZW50L2xhdGVzdCB2ZXJzaW9uIG9mIHN0YXRlXHJcbiAgICAgKiAoVGhpcyBpcyBzYWZlIHRvIGRvIGJlY2F1c2UgdGhlIGZhY3QgdGhhdCB0aGUgc2VsZWN0b3IgaXMgdGhlIGxhdGVzdFxyXG4gICAgICogZXhlY3V0aW9uIG1lYW5zIHRoZSBkZXBzIHdlIGRpc2NvdmVyIGJlbG93IGFyZSBvdXIgYmVzdCBndWVzcyBhdCB0aGVcclxuICAgICAqIGRlcHMgZm9yIHRoZSBjdXJyZW50L2xhdGVzdCBzdGF0ZSBpbiB0aGUgc3RvcmUpXHJcbiAgICAgKi9cclxuXHJcbiAgICBjb25zdCBkZXBWYWx1ZXMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UmVjb2lsVmFsdWUoe1xyXG4gICAgICBrZXk6IGRlcEtleVxyXG4gICAgfSkge1xyXG4gICAgICBjb25zdCBkZXBMb2FkYWJsZSA9IGdldE5vZGVMb2FkYWJsZSQyKHN0b3JlLCBzdGF0ZSwgZGVwS2V5KTtcclxuICAgICAgZGVwVmFsdWVzLnNldChkZXBLZXksIGRlcExvYWRhYmxlKTsgLy8gV2UgbmVlZCB0byB1cGRhdGUgYXN5bmNocm9ub3VzIGRlcGVuZGVuY2llcyBhcyB3ZSBnbyBzbyB0aGUgc2VsZWN0b3JcclxuICAgICAgLy8ga25vd3MgaWYgaXQgaGFzIHRvIHJlc3RhcnQgZXZhbHVhdGlvbiBpZiBvbmUgb2YgdGhlbSBpcyB1cGRhdGVkIGJlZm9yZVxyXG4gICAgICAvLyB0aGUgYXN5bmNocm9ub3VzIHNlbGVjdG9yIGNvbXBsZXRlbHkgcmVzb2x2ZXMuXHJcblxyXG4gICAgICBpZiAoIWR1cmluZ1N5bmNocm9ub3VzRXhlY3V0aW9uKSB7XHJcbiAgICAgICAgdXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUsIG5ldyBTZXQoZGVwVmFsdWVzLmtleXMoKSksIGV4ZWN1dGlvbklEKTtcclxuICAgICAgICBub3RpZnlTdG9yZXNPZk5ld0FzeW5jRGVwKHN0b3JlLCBleGVjdXRpb25JRCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN3aXRjaCAoZGVwTG9hZGFibGUuc3RhdGUpIHtcclxuICAgICAgICBjYXNlICdoYXNWYWx1ZSc6XHJcbiAgICAgICAgICByZXR1cm4gZGVwTG9hZGFibGUuY29udGVudHM7XHJcblxyXG4gICAgICAgIGNhc2UgJ2hhc0Vycm9yJzpcclxuICAgICAgICAgIHRocm93IGRlcExvYWRhYmxlLmNvbnRlbnRzO1xyXG5cclxuICAgICAgICBjYXNlICdsb2FkaW5nJzpcclxuICAgICAgICAgIGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcEtleSA9IGRlcEtleTtcclxuICAgICAgICAgIGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcFByb21pc2UgPSBkZXBMb2FkYWJsZS5jb250ZW50cztcclxuICAgICAgICAgIHRocm93IGRlcExvYWRhYmxlLmNvbnRlbnRzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKCdJbnZhbGlkIExvYWRhYmxlIHN0YXRlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZ2V0Q2FsbGJhY2sgPSBmbiA9PiB7XHJcbiAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIGlmIChkdXJpbmdBc3luY2hyb25vdXNFeGVjdXRpb24pIHtcclxuICAgICAgICAgIHRocm93IFJlY29pbF9lcnIoJ0NhbGxiYWNrcyBmcm9tIGdldENhbGxiYWNrKCkgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSBzZWxlY3RvciBpcyBldmFsdXRhdGVkLiAgSXQgY2FuIGJlIHVzZWQgZm9yIHNlbGVjdG9ycyB0byByZXR1cm4gb2JqZWN0cyB3aXRoIGNhbGxiYWNrcyB0aGF0IGNhbiB3b3JrIHdpdGggUmVjb2lsIHN0YXRlIHdpdGhvdXQgYSBzdWJzY3JpcHRpb24uJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAhKHJlY29pbFZhbHVlICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ1JlY29pbCBWYWx1ZSBjYW4gbmV2ZXIgYmUgbnVsbCcpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcbiAgICAgICAgcmV0dXJuIHJlY29pbENhbGxiYWNrJDEoc3RvcmUsIGZuLCBhcmdzLCB7XHJcbiAgICAgICAgICBub2RlOiByZWNvaWxWYWx1ZVxyXG4gICAgICAgIH0gLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXHJcbiAgICAgICAgKTtcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgcmVzdWx0ID0gZ2V0KHtcclxuICAgICAgICBnZXQ6IGdldFJlY29pbFZhbHVlLFxyXG4gICAgICAgIGdldENhbGxiYWNrXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXN1bHQgPSBpc1JlY29pbFZhbHVlJDMocmVzdWx0KSA/IGdldFJlY29pbFZhbHVlKHJlc3VsdCkgOiByZXN1bHQ7XHJcblxyXG4gICAgICBpZiAoaXNMb2FkYWJsZSQxKHJlc3VsdCkpIHtcclxuICAgICAgICBpZiAocmVzdWx0LnN0YXRlID09PSAnaGFzRXJyb3InKSB7XHJcbiAgICAgICAgICByZXN1bHRJc0Vycm9yID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb250ZW50cztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UocmVzdWx0KSkge1xyXG4gICAgICAgIHJlc3VsdCA9IHdyYXBSZXN1bHRQcm9taXNlKHN0b3JlLCByZXN1bHQsIHN0YXRlLCBkZXBWYWx1ZXMsIGV4ZWN1dGlvbklELCBsb2FkaW5nRGVwc1N0YXRlKS5maW5hbGx5KGZpbmlzaEV2YWx1YXRpb24pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZpbmlzaEV2YWx1YXRpb24oKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVzdWx0ID0gcmVzdWx0IGluc3RhbmNlb2YgV3JhcHBlZFZhbHVlJDEgPyByZXN1bHQudmFsdWUgOiByZXN1bHQ7XHJcbiAgICB9IGNhdGNoIChlcnJvck9yRGVwUHJvbWlzZSkge1xyXG4gICAgICByZXN1bHQgPSBlcnJvck9yRGVwUHJvbWlzZTtcclxuXHJcbiAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKHJlc3VsdCkpIHtcclxuICAgICAgICByZXN1bHQgPSB3cmFwUGVuZGluZ0RlcGVuZGVuY3lQcm9taXNlKHN0b3JlLCByZXN1bHQsIHN0YXRlLCBkZXBWYWx1ZXMsIGV4ZWN1dGlvbklELCBsb2FkaW5nRGVwc1N0YXRlKS5maW5hbGx5KGZpbmlzaEV2YWx1YXRpb24pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdElzRXJyb3IgPSB0cnVlO1xyXG4gICAgICAgIGZpbmlzaEV2YWx1YXRpb24oKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZXN1bHRJc0Vycm9yKSB7XHJcbiAgICAgIGxvYWRhYmxlID0gbG9hZGFibGVXaXRoRXJyb3IkMShyZXN1bHQpO1xyXG4gICAgfSBlbHNlIGlmIChSZWNvaWxfaXNQcm9taXNlKHJlc3VsdCkpIHtcclxuICAgICAgbG9hZGFibGUgPSBsb2FkYWJsZVdpdGhQcm9taXNlJDEocmVzdWx0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxvYWRhYmxlID0gbG9hZGFibGVXaXRoVmFsdWUkMihyZXN1bHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGR1cmluZ1N5bmNocm9ub3VzRXhlY3V0aW9uID0gZmFsc2U7XHJcbiAgICB1cGRhdGVFeGVjdXRpb25JbmZvRGVwVmFsdWVzKHN0b3JlLCBleGVjdXRpb25JRCwgZGVwVmFsdWVzKTtcclxuICAgIHVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlLCBuZXcgU2V0KGRlcFZhbHVlcy5rZXlzKCkpLCBleGVjdXRpb25JRCk7XHJcbiAgICByZXR1cm4gW2xvYWRhYmxlLCBkZXBWYWx1ZXNdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0TG9hZGFibGVGcm9tQ2FjaGVBbmRVcGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSkge1xyXG4gICAgLy8gRmlyc3QsIGxvb2sgdXAgaW4gdGhlIHN0YXRlIGNhY2hlXHJcbiAgICAvLyBJZiBpdCdzIGhlcmUsIHRoZW4gdGhlIGRlcHMgaW4gdGhlIHN0b3JlIHNob3VsZCBhbHJlYWR5IGJlIHZhbGlkLlxyXG4gICAgbGV0IGNhY2hlZExvYWRhYmxlID0gc3RhdGUuYXRvbVZhbHVlcy5nZXQoa2V5KTtcclxuXHJcbiAgICBpZiAoY2FjaGVkTG9hZGFibGUgIT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gY2FjaGVkTG9hZGFibGU7XHJcbiAgICB9IC8vIFNlY29uZCwgbG9vayB1cCBpbiB0aGUgc2VsZWN0b3IgY2FjaGUgYW5kIHVwZGF0ZSB0aGUgZGVwcyBpbiB0aGUgc3RvcmVcclxuXHJcblxyXG4gICAgY29uc3QgZGVwc0FmdGVyQ2FjaGVMb29rdXAgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY2FjaGVkTG9hZGFibGUgPSBjYWNoZS5nZXQobm9kZUtleSA9PiB7XHJcbiAgICAgICAgISh0eXBlb2Ygbm9kZUtleSA9PT0gJ3N0cmluZycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ0NhY2hlIG5vZGVLZXkgaXMgdHlwZSBzdHJpbmcnKSA6IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gICAgICAgIHJldHVybiBnZXROb2RlTG9hZGFibGUkMihzdG9yZSwgc3RhdGUsIG5vZGVLZXkpLmNvbnRlbnRzO1xyXG4gICAgICB9LCB7XHJcbiAgICAgICAgb25Ob2RlVmlzaXQ6IG5vZGUgPT4ge1xyXG4gICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2JyYW5jaCcgJiYgbm9kZS5ub2RlS2V5ICE9PSBrZXkpIHtcclxuICAgICAgICAgICAgZGVwc0FmdGVyQ2FjaGVMb29rdXAuYWRkKG5vZGUubm9kZUtleSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRocm93IFJlY29pbF9lcnIoYFByb2JsZW0gd2l0aCBjYWNoZSBsb29rdXAgZm9yIHNlbGVjdG9yIFwiJHtrZXl9XCI6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FjaGVkTG9hZGFibGUpIHtcclxuICAgICAgdmFyIF9nZXRFeGVjdXRpb25JbmZvO1xyXG5cclxuICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdHMgaW4gdGhlIHN0YXRlIHRvIGFsbG93IGZvciBjaGVhcGVyIGxvb2t1cCB0aGFuXHJcbiAgICAgIC8vIGl0ZXJhdGluZyB0aGUgdHJlZSBjYWNoZSBvZiBkZXBlbmRlbmNpZXMuXHJcbiAgICAgIHN0YXRlLmF0b21WYWx1ZXMuc2V0KGtleSwgY2FjaGVkTG9hZGFibGUpO1xyXG4gICAgICAvKipcclxuICAgICAgICogRW5zdXJlIHN0b3JlIGNvbnRhaW5zIGNvcnJlY3QgZGVwZW5kZW5jaWVzIGlmIHdlIGhpdCB0aGUgY2FjaGUgc28gdGhhdFxyXG4gICAgICAgKiB0aGUgc3RvcmUgZGVwcyBhbmQgY2FjaGUgYXJlIGluIHN5bmMgZm9yIGEgZ2l2ZW4gc3RhdGUuIFRoaXMgaXMgaW1wb3J0YW50XHJcbiAgICAgICAqIGJlY2F1c2Ugc3RvcmUgZGVwcyBhcmUgbm9ybWFsbHkgdXBkYXRlZCB3aGVuIG5ldyBleGVjdXRpb25zIGFyZSBjcmVhdGVkLFxyXG4gICAgICAgKiBidXQgY2FjaGUgaGl0cyBkb24ndCB0cmlnZ2VyIG5ldyBleGVjdXRpb25zIGJ1dCB0aGV5IHN0aWxsIF9tYXlfIHNpZ25pZnlcclxuICAgICAgICogYSBjaGFuZ2UgaW4gZGVwcyBpbiB0aGUgc3RvcmUgaWYgdGhlIHN0b3JlIGRlcHMgZm9yIHRoaXMgc3RhdGUgYXJlIGVtcHR5XHJcbiAgICAgICAqIG9yIHN0YWxlLlxyXG4gICAgICAgKi9cclxuXHJcbiAgICAgIHVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlLCBkZXBzQWZ0ZXJDYWNoZUxvb2t1cCwgKF9nZXRFeGVjdXRpb25JbmZvID0gZ2V0RXhlY3V0aW9uSW5mbyhzdG9yZSkpID09PSBudWxsIHx8IF9nZXRFeGVjdXRpb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0RXhlY3V0aW9uSW5mby5leGVjdXRpb25JRCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNhY2hlZExvYWRhYmxlO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBHaXZlbiBhIHRyZWUgc3RhdGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIExvYWRhYmxlIG9mIHRoZSBjdXJyZW50IHN0YXRlLlxyXG4gICAqXHJcbiAgICogVGhlIHNlbGVjdG9yJ3MgZ2V0KCkgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIHJlLWV2YWx1YXRlZCBpZiBfYm90aF8gb2YgdGhlXHJcbiAgICogZm9sbG93aW5nIHN0YXRlbWVudHMgYXJlIHRydWU6XHJcbiAgICpcclxuICAgKiAxLiBUaGUgY3VycmVudCBkZXAgdmFsdWVzIGZyb20gdGhlIGdpdmVuIHN0YXRlIHByb2R1Y2VkIGEgY2FjaGUga2V5IHRoYXRcclxuICAgKiAgICB3YXMgbm90IGZvdW5kIGluIHRoZSBjYWNoZS5cclxuICAgKiAyLiBUaGVyZSBpcyBubyBjdXJyZW50bHkgcnVubmluZyBhc3luYyBleGVjdXRpb24gT1IgdGhlcmUgaXMgYW5cclxuICAgKiAgICBhc3luYyBleGVjdXRpb24gdGhhdCBpcyBydW5uaW5nLCBidXQgYWZ0ZXIgY29tcGFyaW5nIHRoZSBkZXAgdmFsdWVzIGluXHJcbiAgICogICAgdGhlIGdpdmVuIHN0YXRlIHdpdGggdGhlIGRlcCB2YWx1ZXMgdGhhdCB0aGUgZXhlY3V0aW9uIGhhcyBkaXNjb3ZlcmVkIHNvXHJcbiAgICogICAgZmFyIHdlIGZpbmQgdGhhdCBhdCBsZWFzdCBvbmUgZGVwIHZhbHVlIGhhcyBjaGFuZ2VkLCBpbiB3aGljaCBjYXNlIHdlXHJcbiAgICogICAgc3RhcnQgYSBuZXcgZXhlY3V0aW9uICh0aGUgcHJldmlvdXNseSBydW5uaW5nIGV4ZWN1dGlvbiB3aWxsIGNvbnRpbnVlIHRvXHJcbiAgICogICAgcnVuIHRvIGNvbXBsZXRpb24sIGJ1dCBvbmx5IHRoZSBuZXcgZXhlY3V0aW9uIHdpbGwgYmUgZGVlbWVkIHRoZVxyXG4gICAqICAgICdsYXRlc3QnIGV4ZWN1dGlvbiwgbWVhbmluZyBpdCB3aWxsIGJlIHRoZSBvbmx5IGV4ZWN1dGlvbiB0aGF0IHdpbGxcclxuICAgKiAgICB1cGRhdGUgZ2xvYmFsIHN0YXRlIHdoZW4gaXQgaXMgZmluaXNoZWQuIEFueSBub24tbGF0ZXN0IGV4ZWN1dGlvbnMgd2lsbFxyXG4gICAqICAgIHJ1biB0byBjb21wbGV0aW9uIGFuZCB1cGRhdGUgdGhlIHNlbGVjdG9yIGNhY2hlIGJ1dCBub3QgZ2xvYmFsIHN0YXRlKS5cclxuICAgKi9cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9yTG9hZGFibGVBbmRVcGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSkge1xyXG4gICAgLy8gRmlyc3QsIHNlZSBpZiBvdXIgY3VycmVudCBzdGF0ZSBpcyBjYWNoZWRcclxuICAgIGNvbnN0IGNhY2hlZFZhbCA9IGdldExvYWRhYmxlRnJvbUNhY2hlQW5kVXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUpO1xyXG5cclxuICAgIGlmIChjYWNoZWRWYWwgIT0gbnVsbCkge1xyXG4gICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xyXG4gICAgICByZXR1cm4gY2FjaGVkVmFsO1xyXG4gICAgfSAvLyBTZWNvbmQsIGNoZWNrIGlmIHRoZXJlIGlzIGFscmVhZHkgYW4gb25nb2luZyBleGVjdXRpb24gYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGVcclxuXHJcblxyXG4gICAgY29uc3QgaW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8gPSBnZXRJblByb2dyZXNzRXhlY3V0aW9uSW5mbyhzdG9yZSwgc3RhdGUpO1xyXG5cclxuICAgIGlmIChpblByb2dyZXNzRXhlY3V0aW9uSW5mbyAhPSBudWxsKSB7XHJcbiAgICAgIHZhciBfaW5Qcm9ncmVzc0V4ZWN1dGlvbkk7XHJcblxyXG4gICAgICBpZiAoKChfaW5Qcm9ncmVzc0V4ZWN1dGlvbkkgPSBpblByb2dyZXNzRXhlY3V0aW9uSW5mby5sb2FkaW5nTG9hZGFibGUpID09PSBudWxsIHx8IF9pblByb2dyZXNzRXhlY3V0aW9uSSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2luUHJvZ3Jlc3NFeGVjdXRpb25JLnN0YXRlKSA9PT0gJ2xvYWRpbmcnKSB7XHJcbiAgICAgICAgbWFya1N0b3JlV2FpdGluZ0ZvclJlc29sdmVkQXN5bmMoc3RvcmUsIGluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvLmV4ZWN1dGlvbklEKTtcclxuICAgICAgfSAvLyBGSVhNRTogY2hlY2sgYWZ0ZXIgdGhlIGZhY3QgdG8gc2VlIGlmIHdlIG1hZGUgdGhlIHJpZ2h0IGNob2ljZSBieSB3YWl0aW5nXHJcblxyXG5cclxuICAgICAgcmV0dXJuIGluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvLmxvYWRpbmdMb2FkYWJsZTtcclxuICAgIH0gLy8gVGhpcmQsIHN0YXJ0IGEgbmV3IGV2YWx1YXRpb24gb2YgdGhlIHNlbGVjdG9yXHJcblxyXG5cclxuICAgIGNvbnN0IG5ld0V4ZWN1dGlvbklEID0gZ2V0TmV3RXhlY3V0aW9uSUQoKTtcclxuICAgIGNvbnN0IFtsb2FkYWJsZSwgbmV3RGVwVmFsdWVzXSA9IGV2YWx1YXRlU2VsZWN0b3JHZXR0ZXIoc3RvcmUsIHN0YXRlLCBuZXdFeGVjdXRpb25JRCk7XHJcbiAgICAvKipcclxuICAgICAqIENvbmRpdGlvbmFsbHkgdXBkYXRlcyB0aGUgY2FjaGUgd2l0aCBhIGdpdmVuIGxvYWRhYmxlLlxyXG4gICAgICpcclxuICAgICAqIFdlIG9ubHkgY2FjaGUgbG9hZGFibGVzIHRoYXQgYXJlIG5vdCBsb2FkaW5nIGJlY2F1c2Ugb3VyIGNhY2hlIGtleXMgYXJlXHJcbiAgICAgKiBiYXNlZCBvbiBkZXAgdmFsdWVzLCB3aGljaCBhcmUgaW4gYW4gdW5maW5pc2hlZCBzdGF0ZSBmb3IgbG9hZGFibGVzIHRoYXRcclxuICAgICAqIGhhdmUgYSAnbG9hZGluZycgc3RhdGUgKG5ldyBkZXBzIG1heSBiZSBkaXNjb3ZlcmVkIHdoaWxlIHRoZSBzZWxlY3RvclxyXG4gICAgICogcnVucyBpdHMgYXN5bmMgY29kZSkuIFdlIG5ldmVyIHdhbnQgdG8gY2FjaGUgcGFydGlhbCBkZXBlbmRlbmNpZXMgYi9jIGl0XHJcbiAgICAgKiBjb3VsZCBsZWFkIHRvIGVycm9ycywgc3VjaCBhcyBwcmVtYXR1cmVseSByZXR1cm5pbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiBhXHJcbiAgICAgKiBwYXJ0aWFsIGxpc3Qgb2YgZGVwcy0tIHdlIG5lZWQgdGhlIGZ1bGwgbGlzdCBvZiBkZXBzIHRvIGVuc3VyZSB0aGF0IHdlXHJcbiAgICAgKiBhcmUgcmV0dXJuaW5nIHRoZSBjb3JyZWN0IHJlc3VsdCBmcm9tIGNhY2hlLlxyXG4gICAgICovXHJcblxyXG4gICAgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnbG9hZGluZycpIHtcclxuICAgICAgc2V0RXhlY3V0aW9uSW5mbyhzdG9yZSwgbmV3RXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBuZXdEZXBWYWx1ZXMsIHN0YXRlKTtcclxuICAgICAgbWFya1N0b3JlV2FpdGluZ0ZvclJlc29sdmVkQXN5bmMoc3RvcmUsIG5ld0V4ZWN1dGlvbklEKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSk7XHJcbiAgICAgIHNldENhY2hlKHN0YXRlLCBsb2FkYWJsZSwgbmV3RGVwVmFsdWVzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbG9hZGFibGU7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFNlYXJjaGVzIGV4ZWN1dGlvbiBpbmZvIGFjcm9zcyBhbGwgc3RvcmVzIHRvIHNlZSBpZiB0aGVyZSBpcyBhbiBpbi1wcm9ncmVzc1xyXG4gICAqIGV4ZWN1dGlvbiB3aG9zZSBkZXBlbmRlbmN5IHZhbHVlcyBtYXRjaCB0aGUgdmFsdWVzIG9mIHRoZSByZXF1ZXN0aW5nIHN0b3JlLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgZnVuY3Rpb24gZ2V0SW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8oc3RvcmUsIHN0YXRlKSB7XHJcbiAgICAvLyBTb3J0IHRoZSBwZW5kaW5nIGV4ZWN1dGlvbnMgc28gdGhhdCBvdXIgY3VycmVudCBzdG9yZSBpcyBjaGVja2VkIGZpcnN0LlxyXG4gICAgY29uc3QgcGVuZGluZ0V4ZWN1dGlvbnMgPSBSZWNvaWxfY29uY2F0SXRlcmFibGVzKFtleGVjdXRpb25JbmZvTWFwLmhhcyhzdG9yZSkgPyBbUmVjb2lsX251bGx0aHJvd3MoZXhlY3V0aW9uSW5mb01hcC5nZXQoc3RvcmUpKV0gOiBbXSwgUmVjb2lsX21hcEl0ZXJhYmxlKFJlY29pbF9maWx0ZXJJdGVyYWJsZShleGVjdXRpb25JbmZvTWFwLCAoW3NdKSA9PiBzICE9PSBzdG9yZSksIChbLCBleGVjSW5mb10pID0+IGV4ZWNJbmZvKV0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGFueURlcENoYW5nZWQoZXhlY0RlcFZhbHVlcykge1xyXG4gICAgICBmb3IgKGNvbnN0IFtkZXBLZXksIGV4ZWNMb2FkYWJsZV0gb2YgZXhlY0RlcFZhbHVlcykge1xyXG4gICAgICAgIGlmICghZ2V0Tm9kZUxvYWRhYmxlJDIoc3RvcmUsIHN0YXRlLCBkZXBLZXkpLmlzKGV4ZWNMb2FkYWJsZSkpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoY29uc3QgZXhlY0luZm8gb2YgcGVuZGluZ0V4ZWN1dGlvbnMpIHtcclxuICAgICAgaWYgKCAvLyBJZiB0aGlzIGV4ZWN1dGlvbiB3YXMgYWxyZWFkeSBjaGVja2VkIHRvIGJlIHZhbGlkIHdpdGggdGhpcyB2ZXJzaW9uXHJcbiAgICAgIC8vIG9mIHN0YXRlLCB0aGVuIGxldCdzIHVzZSBpdCFcclxuICAgICAgZXhlY0luZm8uc3RhdGVWZXJzaW9ucy5nZXQoc3RhdGUudmVyc2lvbikgfHwgLy8gSWYgdGhlIGRlcHMgZm9yIHRoZSBleGVjdXRpb24gbWF0Y2ggb3VyIGN1cnJlbnQgc3RhdGUsIHRoZW4gaXQncyB2YWxpZFxyXG4gICAgICAhYW55RGVwQ2hhbmdlZChleGVjSW5mby5kZXBWYWx1ZXNEaXNjb3ZlcmVkU29GYXJEdXJpbmdBc3luY1dvcmspKSB7XHJcbiAgICAgICAgZXhlY0luZm8uc3RhdGVWZXJzaW9ucy5zZXQoc3RhdGUudmVyc2lvbiwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGV4ZWNJbmZvO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGV4ZWNJbmZvLnN0YXRlVmVyc2lvbnMuc2V0KHN0YXRlLnZlcnNpb24sIGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRFeGVjdXRpb25JbmZvKHN0b3JlKSB7XHJcbiAgICByZXR1cm4gZXhlY3V0aW9uSW5mb01hcC5nZXQoc3RvcmUpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdXBkYXRlIHRoZSBzZWxlY3RvcidzIGV4ZWN1dGlvbiBpbmZvIHdoZW4gdGhlIHNlbGVjdG9yXHJcbiAgICogaGFzIGVpdGhlciBmaW5pc2hlZCBydW5uaW5nIGFuIGV4ZWN1dGlvbiBvciBoYXMgc3RhcnRlZCBhIG5ldyBleGVjdXRpb24uIElmXHJcbiAgICogdGhlIGdpdmVuIGxvYWRhYmxlIGlzIGluIGEgJ2xvYWRpbmcnIHN0YXRlLCB0aGUgaW50ZW50aW9uIGlzIHRoYXQgYSBuZXdcclxuICAgKiBleGVjdXRpb24gaGFzIHN0YXJ0ZWQuIE90aGVyd2lzZSwgdGhlIGludGVudGlvbiBpcyB0aGF0IGFuIGV4ZWN1dGlvbiBoYXNcclxuICAgKiBqdXN0IGZpbmlzaGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgZnVuY3Rpb24gc2V0RXhlY3V0aW9uSW5mbyhzdG9yZSwgbmV3RXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMsIHN0YXRlKSB7XHJcbiAgICBleGVjdXRpb25JbmZvTWFwLnNldChzdG9yZSwge1xyXG4gICAgICBkZXBWYWx1ZXNEaXNjb3ZlcmVkU29GYXJEdXJpbmdBc3luY1dvcms6IGRlcFZhbHVlcyxcclxuICAgICAgZXhlY3V0aW9uSUQ6IG5ld0V4ZWN1dGlvbklELFxyXG4gICAgICBsb2FkaW5nTG9hZGFibGU6IGxvYWRhYmxlLFxyXG4gICAgICBzdGF0ZVZlcnNpb25zOiBuZXcgTWFwKFtbc3RhdGUudmVyc2lvbiwgdHJ1ZV1dKVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1cGRhdGVFeGVjdXRpb25JbmZvRGVwVmFsdWVzKHN0b3JlLCBleGVjdXRpb25JRCwgZGVwVmFsdWVzKSB7XHJcbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gYm90aGVyIHVwZGF0aW5nIHRoZSBkZXBzIGZvciB0aGUgbGF0ZXN0IGV4ZWN1dGlvbiBiZWNhdXNlXHJcbiAgICAvLyB0aGF0J3MgYWxsIGdldEluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvKCkgd2lsbCBiZSBsb29raW5nIGZvci5cclxuICAgIGlmIChpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpKSB7XHJcbiAgICAgIGNvbnN0IGV4ZWN1dGlvbkluZm8gPSBnZXRFeGVjdXRpb25JbmZvKHN0b3JlKTtcclxuXHJcbiAgICAgIGlmIChleGVjdXRpb25JbmZvICE9IG51bGwpIHtcclxuICAgICAgICBleGVjdXRpb25JbmZvLmRlcFZhbHVlc0Rpc2NvdmVyZWRTb0ZhckR1cmluZ0FzeW5jV29yayA9IGRlcFZhbHVlcztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKSB7XHJcbiAgICBleGVjdXRpb25JbmZvTWFwLmRlbGV0ZShzdG9yZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpIHtcclxuICAgIHZhciBfZ2V0RXhlY3V0aW9uSW5mbzI7XHJcblxyXG4gICAgcmV0dXJuIGV4ZWN1dGlvbklEID09PSAoKF9nZXRFeGVjdXRpb25JbmZvMiA9IGdldEV4ZWN1dGlvbkluZm8oc3RvcmUpKSA9PT0gbnVsbCB8fCBfZ2V0RXhlY3V0aW9uSW5mbzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRFeGVjdXRpb25JbmZvMi5leGVjdXRpb25JRCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEZJWE1FOiBkZXAga2V5cyBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgdGhlIHN0YXRlIG9mIHRoZSBsb2FkYWJsZSB0b1xyXG4gICAqIHByZXZlbnQgdGhlIGVkZ2UgY2FzZSB3aGVyZSBhIGxvYWRhYmxlIHdpdGggYW4gZXJyb3IgYW5kIGEgbG9hZGFibGUgd2l0aFxyXG4gICAqIGFuIGVycm9yIGFzIGEgdmFsdWUgYXJlIHRyZWF0ZWQgYXMgdGhlIHNhbWUgdGhpbmcgaW5jb3JyZWN0bHkuIEZvciBleGFtcGxlXHJcbiAgICogdGhlc2UgdHdvIHNob3VsZCBiZSB0cmVhdGVkIGRpZmZlcmVudGx5OlxyXG4gICAqXHJcbiAgICogc2VsZWN0b3Ioe2tleTogJycsIGdldDogKCkgPT4gbmV3IEVycm9yKCdoaScpfSk7XHJcbiAgICogc2VsZWN0b3Ioe2tleTogJycsIGdldCAoKSA9PiB7dGhyb3cgbmV3IEVycm9yKCdoaScpfX0pO1xyXG4gICAqXHJcbiAgICogV2l0aCBjdXJyZW50IGltcGxlbWVudGF0aW9uIHRoZXkgYXJlIHRyZWF0ZWQgdGhlIHNhbWVcclxuICAgKi9cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGRlcFZhbHVlc1RvRGVwUm91dGUoZGVwVmFsdWVzKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbShkZXBWYWx1ZXMuZW50cmllcygpKS5tYXAoKFtkZXBLZXksIHZhbExvYWRhYmxlXSkgPT4gW2RlcEtleSwgdmFsTG9hZGFibGUuY29udGVudHNdKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldENhY2hlKHN0YXRlLCBsb2FkYWJsZSwgZGVwVmFsdWVzKSB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgIGlmIChsb2FkYWJsZS5zdGF0ZSAhPT0gJ2xvYWRpbmcnICYmIEJvb2xlYW4ob3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgUmVjb2lsX2RlZXBGcmVlemVWYWx1ZShsb2FkYWJsZS5jb250ZW50cyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0ZS5hdG9tVmFsdWVzLnNldChrZXksIGxvYWRhYmxlKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjYWNoZS5zZXQoZGVwVmFsdWVzVG9EZXBSb3V0ZShkZXBWYWx1ZXMpLCBsb2FkYWJsZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKGBQcm9ibGVtIHdpdGggc2V0dGluZyBjYWNoZSBmb3Igc2VsZWN0b3IgXCIke2tleX1cIjogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGV0ZWN0Q2lyY3VsYXJEZXBlbmRlbmNpZXMoZm4pIHtcclxuICAgIGlmIChkZXBlbmRlbmN5U3RhY2suaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICBjb25zdCBtZXNzYWdlID0gYFJlY29pbCBzZWxlY3RvciBoYXMgY2lyY3VsYXIgZGVwZW5kZW5jaWVzOiAke2RlcGVuZGVuY3lTdGFjay5zbGljZShkZXBlbmRlbmN5U3RhY2suaW5kZXhPZihrZXkpKS5qb2luKCcgXFx1MjE5MiAnKX1gO1xyXG4gICAgICByZXR1cm4gbG9hZGFibGVXaXRoRXJyb3IkMShSZWNvaWxfZXJyKG1lc3NhZ2UpKTtcclxuICAgIH1cclxuXHJcbiAgICBkZXBlbmRlbmN5U3RhY2sucHVzaChrZXkpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBmbigpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgZGVwZW5kZW5jeVN0YWNrLnBvcCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2VsZWN0b3JQZWVrKHN0b3JlLCBzdGF0ZSkge1xyXG4gICAgY29uc3QgY2FjaGVkTG9hZGFibGUgPSBzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpO1xyXG5cclxuICAgIGlmIChjYWNoZWRMb2FkYWJsZSAhPSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBjYWNoZWRMb2FkYWJsZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2FjaGUuZ2V0KG5vZGVLZXkgPT4ge1xyXG4gICAgICB2YXIgX3BlZWtOb2RlTG9hZGFibGU7XHJcblxyXG4gICAgICAhKHR5cGVvZiBub2RlS2V5ID09PSAnc3RyaW5nJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBSZWNvaWxfaW52YXJpYW50KGZhbHNlLCAnQ2FjaGUgbm9kZUtleSBpcyB0eXBlIHN0cmluZycpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcbiAgICAgIHJldHVybiAoX3BlZWtOb2RlTG9hZGFibGUgPSBwZWVrTm9kZUxvYWRhYmxlJDEoc3RvcmUsIHN0YXRlLCBub2RlS2V5KSkgPT09IG51bGwgfHwgX3BlZWtOb2RlTG9hZGFibGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wZWVrTm9kZUxvYWRhYmxlLmNvbnRlbnRzO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZWxlY3RvckdldChzdG9yZSwgc3RhdGUpIHtcclxuICAgIHJldHVybiBkZXRlY3RDaXJjdWxhckRlcGVuZGVuY2llcygoKSA9PiBnZXRTZWxlY3RvckxvYWRhYmxlQW5kVXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUpKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGludmFsaWRhdGVTZWxlY3RvcihzdGF0ZSkge1xyXG4gICAgc3RhdGUuYXRvbVZhbHVlcy5kZWxldGUoa2V5KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsZWFyU2VsZWN0b3JDYWNoZShzdG9yZSwgdHJlZVN0YXRlKSB7XHJcbiAgICAhKHJlY29pbFZhbHVlICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ1JlY29pbCBWYWx1ZSBjYW4gbmV2ZXIgYmUgbnVsbCcpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcblxyXG4gICAgZm9yIChjb25zdCBub2RlS2V5IG9mIGRpc2NvdmVyZWREZXBlbmRlbmN5Tm9kZUtleXMpIHtcclxuICAgICAgdmFyIF9ub2RlJGNsZWFyQ2FjaGU7XHJcblxyXG4gICAgICBjb25zdCBub2RlID0gZ2V0Tm9kZSQ2KG5vZGVLZXkpO1xyXG4gICAgICAoX25vZGUkY2xlYXJDYWNoZSA9IG5vZGUuY2xlYXJDYWNoZSkgPT09IG51bGwgfHwgX25vZGUkY2xlYXJDYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkY2xlYXJDYWNoZS5jYWxsKG5vZGUsIHN0b3JlLCB0cmVlU3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc2NvdmVyZWREZXBlbmRlbmN5Tm9kZUtleXMuY2xlYXIoKTtcclxuICAgIGludmFsaWRhdGVTZWxlY3Rvcih0cmVlU3RhdGUpO1xyXG4gICAgY2FjaGUuY2xlYXIoKTtcclxuICAgIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDEoc3RvcmUsIHJlY29pbFZhbHVlKTtcclxuICB9XHJcblxyXG4gIGlmIChzZXQgIT0gbnVsbCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBFUzUgc3RyaWN0IG1vZGUgcHJvaGliaXRzIGRlZmluaW5nIG5vbi10b3AtbGV2ZWwgZnVuY3Rpb24gZGVjbGFyYXRpb25zLFxyXG4gICAgICogc28gZG9uJ3QgdXNlIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIHN5bnRheCBoZXJlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHNlbGVjdG9yU2V0ID0gKHN0b3JlLCBzdGF0ZSwgbmV3VmFsdWUpID0+IHtcclxuICAgICAgbGV0IHN5bmNTZWxlY3RvclNldEZpbmlzaGVkID0gZmFsc2U7XHJcbiAgICAgIGNvbnN0IHdyaXRlcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGdldFJlY29pbFZhbHVlKHtcclxuICAgICAgICBrZXk6IGRlcEtleVxyXG4gICAgICB9KSB7XHJcbiAgICAgICAgaWYgKHN5bmNTZWxlY3RvclNldEZpbmlzaGVkKSB7XHJcbiAgICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdSZWNvaWw6IEFzeW5jIHNlbGVjdG9yIHNldHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbG9hZGFibGUgPSBnZXROb2RlTG9hZGFibGUkMihzdG9yZSwgc3RhdGUsIGRlcEtleSk7XHJcblxyXG4gICAgICAgIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJykge1xyXG4gICAgICAgICAgcmV0dXJuIGxvYWRhYmxlLmNvbnRlbnRzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xyXG4gICAgICAgICAgY29uc3QgbXNnID0gYEdldHRpbmcgdmFsdWUgb2YgYXN5bmNocm9ub3VzIGF0b20gb3Igc2VsZWN0b3IgXCIke2RlcEtleX1cIiBpbiBhIHBlbmRpbmcgc3RhdGUgd2hpbGUgc2V0dGluZyBzZWxlY3RvciBcIiR7a2V5fVwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLmA7XHJcbiAgICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24obXNnKTtcclxuICAgICAgICAgIHRocm93IFJlY29pbF9lcnIobXNnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgbG9hZGFibGUuY29udGVudHM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSwgdmFsdWVPclVwZGF0ZXIpIHtcclxuICAgICAgICBpZiAoc3luY1NlbGVjdG9yU2V0RmluaXNoZWQpIHtcclxuICAgICAgICAgIGNvbnN0IG1zZyA9ICdSZWNvaWw6IEFzeW5jIHNlbGVjdG9yIHNldHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLic7XHJcbiAgICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24obXNnKTtcclxuICAgICAgICAgIHRocm93IFJlY29pbF9lcnIobXNnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNldFZhbHVlID0gdHlwZW9mIHZhbHVlT3JVcGRhdGVyID09PSAnZnVuY3Rpb24nID8gLy8gY2FzdCB0byBhbnkgYmVjYXVzZSB3ZSBjYW4ndCByZXN0cmljdCB0eXBlIFMgZnJvbSBiZWluZyBhIGZ1bmN0aW9uIGl0c2VsZiB3aXRob3V0IGxvc2luZyBzdXBwb3J0IGZvciBvcGFxdWUgdHlwZXNcclxuICAgICAgICAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxyXG4gICAgICAgIHZhbHVlT3JVcGRhdGVyKGdldFJlY29pbFZhbHVlKHJlY29pbFN0YXRlKSkgOiB2YWx1ZU9yVXBkYXRlcjtcclxuICAgICAgICBjb25zdCB1cHN0cmVhbVdyaXRlcyA9IHNldE5vZGVWYWx1ZSQzKHN0b3JlLCBzdGF0ZSwgcmVjb2lsU3RhdGUua2V5LCBzZXRWYWx1ZSk7XHJcbiAgICAgICAgdXBzdHJlYW1Xcml0ZXMuZm9yRWFjaCgodiwgaykgPT4gd3JpdGVzLnNldChrLCB2KSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHJlc2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcclxuICAgICAgICBzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSwgREVGQVVMVF9WQUxVRSQ2KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcmV0ID0gc2V0KHtcclxuICAgICAgICBzZXQ6IHNldFJlY29pbFN0YXRlLFxyXG4gICAgICAgIGdldDogZ2V0UmVjb2lsVmFsdWUsXHJcbiAgICAgICAgcmVzZXQ6IHJlc2V0UmVjb2lsU3RhdGVcclxuICAgICAgfSwgbmV3VmFsdWUpOyAvLyBzZXQgc2hvdWxkIGJlIGEgdm9pZCBtZXRob2QsIGJ1dCBpZiB0aGUgdXNlciBtYWtlcyBpdCBgYXN5bmNgLCB0aGVuIGl0XHJcbiAgICAgIC8vIHdpbGwgcmV0dXJuIGEgUHJvbWlzZSwgd2hpY2ggd2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQuXHJcblxyXG4gICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyBSZWNvaWxfaXNQcm9taXNlKHJldCkgPyBSZWNvaWxfZXJyKCdSZWNvaWw6IEFzeW5jIHNlbGVjdG9yIHNldHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLicpIDogUmVjb2lsX2VycignUmVjb2lsOiBzZWxlY3RvciBzZXQgc2hvdWxkIGJlIGEgdm9pZCBmdW5jdGlvbi4nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3luY1NlbGVjdG9yU2V0RmluaXNoZWQgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gd3JpdGVzO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gcmVjb2lsVmFsdWUgPSByZWdpc3Rlck5vZGUkMSh7XHJcbiAgICAgIGtleSxcclxuICAgICAgbm9kZVR5cGU6ICdzZWxlY3RvcicsXHJcbiAgICAgIHBlZWs6IHNlbGVjdG9yUGVlayxcclxuICAgICAgZ2V0OiBzZWxlY3RvckdldCxcclxuICAgICAgc2V0OiBzZWxlY3RvclNldCxcclxuICAgICAgaW5pdDogc2VsZWN0b3JJbml0LFxyXG4gICAgICBpbnZhbGlkYXRlOiBpbnZhbGlkYXRlU2VsZWN0b3IsXHJcbiAgICAgIGNsZWFyQ2FjaGU6IGNsZWFyU2VsZWN0b3JDYWNoZSxcclxuICAgICAgc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlOiBzZWxlY3RvclNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZSxcclxuICAgICAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHksXHJcbiAgICAgIHNob3VsZFJlc3RvcmVGcm9tU25hcHNob3RzOiBmYWxzZSxcclxuICAgICAgcmV0YWluZWRCeVxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiByZWNvaWxWYWx1ZSA9IHJlZ2lzdGVyTm9kZSQxKHtcclxuICAgICAga2V5LFxyXG4gICAgICBub2RlVHlwZTogJ3NlbGVjdG9yJyxcclxuICAgICAgcGVlazogc2VsZWN0b3JQZWVrLFxyXG4gICAgICBnZXQ6IHNlbGVjdG9yR2V0LFxyXG4gICAgICBpbml0OiBzZWxlY3RvckluaXQsXHJcbiAgICAgIGludmFsaWRhdGU6IGludmFsaWRhdGVTZWxlY3RvcixcclxuICAgICAgY2xlYXJDYWNoZTogY2xlYXJTZWxlY3RvckNhY2hlLFxyXG4gICAgICBzaG91bGREZWxldGVDb25maWdPblJlbGVhc2U6IHNlbGVjdG9yU2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlLFxyXG4gICAgICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSxcclxuICAgICAgc2hvdWxkUmVzdG9yZUZyb21TbmFwc2hvdHM6IGZhbHNlLFxyXG4gICAgICByZXRhaW5lZEJ5XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuLyogZXNsaW50LWVuYWJsZSBuby1yZWRlY2xhcmUgKi9cclxuLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtdXNlXVxyXG5cclxuXHJcbnNlbGVjdG9yLnZhbHVlID0gdmFsdWUgPT4gbmV3IFdyYXBwZWRWYWx1ZSQxKHZhbHVlKTtcclxuXHJcbnZhciBSZWNvaWxfc2VsZWN0b3IgPSBzZWxlY3RvcjtcclxuXHJcbi8vIEBmYi1vbmx5OiBpbXBvcnQgdHlwZSB7U2NvcGVSdWxlc30gZnJvbSAnUmVjb2lsX1Njb3BlZEF0b20nO1xyXG4vLyBAZmItb25seTogY29uc3Qge3Njb3BlZEF0b219ID0gcmVxdWlyZSgnUmVjb2lsX1Njb3BlZEF0b20nKTtcclxuY29uc3Qge1xyXG4gIGlzTG9hZGFibGU6IGlzTG9hZGFibGUkMixcclxuICBsb2FkYWJsZVdpdGhFcnJvcjogbG9hZGFibGVXaXRoRXJyb3IkMixcclxuICBsb2FkYWJsZVdpdGhQcm9taXNlOiBsb2FkYWJsZVdpdGhQcm9taXNlJDIsXHJcbiAgbG9hZGFibGVXaXRoVmFsdWU6IGxvYWRhYmxlV2l0aFZhbHVlJDNcclxufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xyXG5cclxuY29uc3Qge1xyXG4gIFdyYXBwZWRWYWx1ZTogV3JhcHBlZFZhbHVlJDJcclxufSA9IFJlY29pbF9XcmFwcGVyJDE7XHJcblxyXG5jb25zdCB7XHJcbiAgcGVla05vZGVJbmZvOiBwZWVrTm9kZUluZm8kM1xyXG59ID0gUmVjb2lsX0Z1bmN0aW9uYWxDb3JlO1xyXG5cclxuY29uc3Qge1xyXG4gIERFRkFVTFRfVkFMVUU6IERFRkFVTFRfVkFMVUUkNyxcclxuICBEZWZhdWx0VmFsdWU6IERlZmF1bHRWYWx1ZSQyLFxyXG4gIGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlcjogZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDIsXHJcbiAgcmVnaXN0ZXJOb2RlOiByZWdpc3Rlck5vZGUkMixcclxuICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXI6IHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQxXHJcbn0gPSBSZWNvaWxfTm9kZTtcclxuXHJcbmNvbnN0IHtcclxuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDRcclxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xyXG5cclxuY29uc3Qge1xyXG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZTogZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDQsXHJcbiAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQ6IG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDIsXHJcbiAgc2V0UmVjb2lsVmFsdWU6IHNldFJlY29pbFZhbHVlJDQsXHJcbiAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZTogc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQyXHJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XHJcblxyXG5jb25zdCB7XHJcbiAgcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0OiByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQkMlxyXG59ID0gUmVjb2lsX1JldGVudGlvbjtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY29uc3QgdW53cmFwID0geCA9PiB4IGluc3RhbmNlb2YgV3JhcHBlZFZhbHVlJDIgPyB4LnZhbHVlIDogeDtcclxuXHJcbmZ1bmN0aW9uIGJhc2VBdG9tKG9wdGlvbnMpIHtcclxuICBjb25zdCB7XHJcbiAgICBrZXksXHJcbiAgICBwZXJzaXN0ZW5jZV9VTlNUQUJMRTogcGVyc2lzdGVuY2VcclxuICB9ID0gb3B0aW9ucztcclxuICBjb25zdCByZXRhaW5lZEJ5ID0gcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0JDIob3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFKTtcclxuICBsZXQgbGl2ZVN0b3Jlc0NvdW50ID0gMDtcclxuXHJcbiAgZnVuY3Rpb24gdW53cmFwUHJvbWlzZShwcm9taXNlKSB7XHJcbiAgICByZXR1cm4gbG9hZGFibGVXaXRoUHJvbWlzZSQyKHByb21pc2UudGhlbih2YWx1ZSA9PiB7XHJcbiAgICAgIGRlZmF1bHRMb2FkYWJsZSA9IGxvYWRhYmxlV2l0aFZhbHVlJDModmFsdWUpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgIGRlZmF1bHRMb2FkYWJsZSA9IGxvYWRhYmxlV2l0aEVycm9yJDIoZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gIGxldCBkZWZhdWx0TG9hZGFibGUgPSBSZWNvaWxfaXNQcm9taXNlKG9wdGlvbnMuZGVmYXVsdCkgPyB1bndyYXBQcm9taXNlKG9wdGlvbnMuZGVmYXVsdCkgOiBpc0xvYWRhYmxlJDIob3B0aW9ucy5kZWZhdWx0KSA/IG9wdGlvbnMuZGVmYXVsdC5zdGF0ZSA9PT0gJ2xvYWRpbmcnID8gdW53cmFwUHJvbWlzZShvcHRpb25zLmRlZmF1bHQuY29udGVudHMpIDogb3B0aW9ucy5kZWZhdWx0IDogbG9hZGFibGVXaXRoVmFsdWUkMyh1bndyYXAob3B0aW9ucy5kZWZhdWx0KSk7XHJcbiAgbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZShkZWZhdWx0TG9hZGFibGUuY29udGVudHMpO1xyXG4gIGxldCBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlID0gdW5kZWZpbmVkOyAvLyBDbGVhbnVwIGhhbmRsZXJzIGZvciB0aGlzIGF0b21cclxuICAvLyBSZWx5IG9uIHN0YWJsZSByZWZlcmVuY2UgZXF1YWxpdHkgb2YgdGhlIHN0b3JlIHRvIHVzZSBpdCBhcyBhIGtleSBwZXIgPFJlY29pbFJvb3Q+XHJcblxyXG4gIGNvbnN0IGNsZWFudXBFZmZlY3RzQnlTdG9yZSA9IG5ldyBNYXAoKTtcclxuXHJcbiAgZnVuY3Rpb24gbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZSh2YWx1ZU9yUHJvbWlzZSkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICBpZiAob3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKHZhbHVlT3JQcm9taXNlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlT3JQcm9taXNlLnRoZW4odmFsdWUgPT4ge1xyXG4gICAgICAgICAgICBSZWNvaWxfZGVlcEZyZWV6ZVZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIFJlY29pbF9kZWVwRnJlZXplVmFsdWUodmFsdWVPclByb21pc2UpO1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlT3JQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZU9yUHJvbWlzZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHdyYXBQZW5kaW5nUHJvbWlzZShzdG9yZSwgcHJvbWlzZSkge1xyXG4gICAgY29uc3Qgd3JhcHBlZFByb21pc2UgPSBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xyXG4gICAgICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRULCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQ7XHJcblxyXG4gICAgICBjb25zdCBzdGF0ZSA9IChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgIT09IHZvaWQgMCA/IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA6IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XHJcblxyXG4gICAgICBpZiAoKChfc3RhdGUkYXRvbVZhbHVlcyRnZXQgPSBzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZSRhdG9tVmFsdWVzJGdldC5jb250ZW50cykgPT09IHdyYXBwZWRQcm9taXNlKSB7XHJcbiAgICAgICAgc2V0UmVjb2lsVmFsdWUkNChzdG9yZSwgbm9kZSwgdmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQyLCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQyO1xyXG5cclxuICAgICAgY29uc3Qgc3RhdGUgPSAoX3N0b3JlJGdldFN0YXRlJG5leHRUMiA9IHN0b3JlLmdldFN0YXRlKCkubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDIgIT09IHZvaWQgMCA/IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDIgOiBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xyXG5cclxuICAgICAgaWYgKCgoX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MiA9IHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9zdGF0ZSRhdG9tVmFsdWVzJGdldDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZSRhdG9tVmFsdWVzJGdldDIuY29udGVudHMpID09PSB3cmFwcGVkUHJvbWlzZSkge1xyXG4gICAgICAgIHNldFJlY29pbFZhbHVlTG9hZGFibGUkMihzdG9yZSwgbm9kZSwgbG9hZGFibGVXaXRoRXJyb3IkMihlcnJvcikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHdyYXBwZWRQcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5pdEF0b20oc3RvcmUsIGluaXRTdGF0ZSwgdHJpZ2dlcikge1xyXG4gICAgdmFyIF9vcHRpb25zJGVmZmVjdHM7XHJcblxyXG4gICAgbGl2ZVN0b3Jlc0NvdW50Kys7XHJcblxyXG4gICAgY29uc3QgY2xlYW51cEF0b20gPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfY2xlYW51cEVmZmVjdHNCeVN0b3I7XHJcblxyXG4gICAgICBsaXZlU3RvcmVzQ291bnQtLTtcclxuICAgICAgKF9jbGVhbnVwRWZmZWN0c0J5U3RvciA9IGNsZWFudXBFZmZlY3RzQnlTdG9yZS5nZXQoc3RvcmUpKSA9PT0gbnVsbCB8fCBfY2xlYW51cEVmZmVjdHNCeVN0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jbGVhbnVwRWZmZWN0c0J5U3Rvci5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcclxuICAgICAgY2xlYW51cEVmZmVjdHNCeVN0b3JlLmRlbGV0ZShzdG9yZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHN0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcy5hZGQoa2V5KTsgLy8gU2V0dXAgYXN5bmMgZGVmYXVsdHMgdG8gbm90aWZ5IHN1YnNjcmliZXJzIHdoZW4gdGhleSByZXNvbHZlXHJcblxyXG4gICAgaWYgKGRlZmF1bHRMb2FkYWJsZS5zdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XHJcbiAgICAgIGNvbnN0IG5vdGlmeURlZmF1bHRTdWJzY3JpYmVycyA9ICgpID0+IHtcclxuICAgICAgICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRUMztcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSAoX3N0b3JlJGdldFN0YXRlJG5leHRUMyA9IHN0b3JlLmdldFN0YXRlKCkubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDMgIT09IHZvaWQgMCA/IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDMgOiBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xyXG5cclxuICAgICAgICBpZiAoIXN0YXRlLmF0b21WYWx1ZXMuaGFzKGtleSkpIHtcclxuICAgICAgICAgIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDIoc3RvcmUsIG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIGRlZmF1bHRMb2FkYWJsZS5jb250ZW50cy5maW5hbGx5KG5vdGlmeURlZmF1bHRTdWJzY3JpYmVycyk7XHJcbiAgICB9IC8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIC8vIFJ1biBBdG9tIEVmZmVjdHNcclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblxyXG4gICAgY29uc3QgZWZmZWN0cyA9IChfb3B0aW9ucyRlZmZlY3RzID0gb3B0aW9ucy5lZmZlY3RzKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRlZmZlY3RzICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRlZmZlY3RzIDogb3B0aW9ucy5lZmZlY3RzX1VOU1RBQkxFO1xyXG5cclxuICAgIGlmIChlZmZlY3RzICE9IG51bGwpIHtcclxuICAgICAgLy8gVGhpcyBzdGF0ZSBpcyBzY29wZWQgYnkgU3RvcmUsIHNpbmNlIHRoaXMgaXMgaW4gdGhlIGluaXRBdG9tKCkgY2xvc3VyZVxyXG4gICAgICBsZXQgaW5pdFZhbHVlID0gREVGQVVMVF9WQUxVRSQ3O1xyXG4gICAgICBsZXQgaXNEdXJpbmdJbml0ID0gdHJ1ZTtcclxuICAgICAgbGV0IGlzSW5pdEVycm9yID0gZmFsc2U7XHJcbiAgICAgIGxldCBwZW5kaW5nU2V0U2VsZiA9IG51bGw7XHJcblxyXG4gICAgICBmdW5jdGlvbiBnZXRMb2FkYWJsZShyZWNvaWxWYWx1ZSkge1xyXG4gICAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBqdXN0IGdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiBhbm90aGVyIGF0b20uXHJcbiAgICAgICAgLy8gQnV0IGZvciBvdXIgb3duIHZhbHVlIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgYSBwZW5kaW5nXHJcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQgdmFsdWUgb3IgZ2V0IHRoZSBmYWxsYmFjayBkZWZhdWx0IHZhbHVlLlxyXG4gICAgICAgIGlmIChpc0R1cmluZ0luaXQgJiYgcmVjb2lsVmFsdWUua2V5ID09PSBrZXkpIHtcclxuICAgICAgICAgIC8vIENhc3QgVCB0byBTXHJcbiAgICAgICAgICBjb25zdCByZXRWYWx1ZSA9IGluaXRWYWx1ZTsgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXHJcblxyXG4gICAgICAgICAgcmV0dXJuIHJldFZhbHVlIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDIgPyBwZWVrQXRvbShzdG9yZSwgaW5pdFN0YXRlKSAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcclxuICAgICAgICAgIDogUmVjb2lsX2lzUHJvbWlzZShyZXRWYWx1ZSkgPyBsb2FkYWJsZVdpdGhQcm9taXNlJDIocmV0VmFsdWUudGhlbih2ID0+IHYgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IC8vIENhc3QgVCB0byBTXHJcbiAgICAgICAgICBkZWZhdWx0TG9hZGFibGUudG9Qcm9taXNlKCkgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXHJcbiAgICAgICAgICA6IHYpKSA6IGxvYWRhYmxlV2l0aFZhbHVlJDMocmV0VmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQ0KHN0b3JlLCByZWNvaWxWYWx1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGdldFByb21pc2UocmVjb2lsVmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TG9hZGFibGUocmVjb2lsVmFsdWUpLnRvUHJvbWlzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBnZXRJbmZvX1VOU1RBQkxFKHJlY29pbFZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDQ7XHJcblxyXG4gICAgICAgIGNvbnN0IGluZm8gPSBwZWVrTm9kZUluZm8kMyhzdG9yZSwgKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDQgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ0ICE9PSB2b2lkIDAgPyBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ0IDogc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSwgcmVjb2lsVmFsdWUua2V5KTtcclxuICAgICAgICByZXR1cm4gaXNEdXJpbmdJbml0ICYmIHJlY29pbFZhbHVlLmtleSA9PT0ga2V5ICYmICEoaW5pdFZhbHVlIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDIpID8geyAuLi5pbmZvLFxyXG4gICAgICAgICAgaXNTZXQ6IHRydWUsXHJcbiAgICAgICAgICBsb2FkYWJsZTogZ2V0TG9hZGFibGUocmVjb2lsVmFsdWUpXHJcbiAgICAgICAgfSA6IGluZm87XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHNldFNlbGYgPSBlZmZlY3QgPT4gdmFsdWVPclVwZGF0ZXIgPT4ge1xyXG4gICAgICAgIGlmIChpc0R1cmluZ0luaXQpIHtcclxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRMb2FkYWJsZSA9IGdldExvYWRhYmxlKG5vZGUpO1xyXG4gICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gY3VycmVudExvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnID8gY3VycmVudExvYWRhYmxlLmNvbnRlbnRzIDogREVGQVVMVF9WQUxVRSQ3O1xyXG4gICAgICAgICAgaW5pdFZhbHVlID0gdHlwZW9mIHZhbHVlT3JVcGRhdGVyID09PSAnZnVuY3Rpb24nID8gLy8gY2FzdCB0byBhbnkgYmVjYXVzZSB3ZSBjYW4ndCByZXN0cmljdCBUIGZyb20gYmVpbmcgYSBmdW5jdGlvbiB3aXRob3V0IGxvc2luZyBzdXBwb3J0IGZvciBvcGFxdWUgdHlwZXNcclxuICAgICAgICAgIHZhbHVlT3JVcGRhdGVyKGN1cnJlbnRWYWx1ZSkgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXHJcbiAgICAgICAgICA6IHZhbHVlT3JVcGRhdGVyO1xyXG5cclxuICAgICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKGluaXRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgaW5pdFZhbHVlID0gaW5pdFZhbHVlLnRoZW4odmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAgIC8vIEF2b2lkIGNhbGxpbmcgb25TZXQoKSB3aGVuIHNldFNlbGYoKSBpbml0aWFsaXplcyB3aXRoIGEgUHJvbWlzZVxyXG4gICAgICAgICAgICAgIHBlbmRpbmdTZXRTZWxmID0ge1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0LFxyXG4gICAgICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKHZhbHVlT3JVcGRhdGVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdTZXR0aW5nIGF0b21zIHRvIGFzeW5jIHZhbHVlcyBpcyBub3QgaW1wbGVtZW50ZWQuJyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZU9yVXBkYXRlciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBwZW5kaW5nU2V0U2VsZiA9IHtcclxuICAgICAgICAgICAgICBlZmZlY3QsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHVud3JhcCh2YWx1ZU9yVXBkYXRlcilcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzZXRSZWNvaWxWYWx1ZSQ0KHN0b3JlLCBub2RlLCB0eXBlb2YgdmFsdWVPclVwZGF0ZXIgPT09ICdmdW5jdGlvbicgPyBjdXJyZW50VmFsdWUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHVud3JhcCggLy8gY2FzdCB0byBhbnkgYmVjYXVzZSB3ZSBjYW4ndCByZXN0cmljdCBUIGZyb20gYmVpbmcgYSBmdW5jdGlvbiB3aXRob3V0IGxvc2luZyBzdXBwb3J0IGZvciBvcGFxdWUgdHlwZXNcclxuICAgICAgICAgICAgdmFsdWVPclVwZGF0ZXIoY3VycmVudFZhbHVlKSAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcGVuZGluZ1NldFNlbGYgPSB7XHJcbiAgICAgICAgICAgICAgZWZmZWN0LFxyXG4gICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3VmFsdWU7XHJcbiAgICAgICAgICB9IDogdW53cmFwKHZhbHVlT3JVcGRhdGVyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3QgcmVzZXRTZWxmID0gZWZmZWN0ID0+ICgpID0+IHNldFNlbGYoZWZmZWN0KShERUZBVUxUX1ZBTFVFJDcpO1xyXG5cclxuICAgICAgY29uc3Qgb25TZXQgPSBlZmZlY3QgPT4gaGFuZGxlciA9PiB7XHJcbiAgICAgICAgdmFyIF9jbGVhbnVwRWZmZWN0c0J5U3RvcjI7XHJcblxyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgIHJlbGVhc2VcclxuICAgICAgICB9ID0gc3RvcmUuc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnMoY3VycmVudFN0b3JlID0+IHtcclxuICAgICAgICAgIHZhciBfY3VycmVudFRyZWUkYXRvbVZhbHU7XHJcblxyXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxyXG4gICAgICAgICAgbGV0IHtcclxuICAgICAgICAgICAgY3VycmVudFRyZWUsXHJcbiAgICAgICAgICAgIHByZXZpb3VzVHJlZVxyXG4gICAgICAgICAgfSA9IGN1cnJlbnRTdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgICAgIGlmICghcHJldmlvdXNUcmVlKSB7XHJcbiAgICAgICAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignVHJhbnNhY3Rpb24gc3Vic2NyaWJlcnMgbm90aWZpZWQgd2l0aG91dCBhIG5leHQgdHJlZSBiZWluZyBwcmVzZW50IC0tIHRoaXMgaXMgYSBidWcgaW4gUmVjb2lsJyk7XHJcbiAgICAgICAgICAgIHByZXZpb3VzVHJlZSA9IGN1cnJlbnRUcmVlOyAvLyBhdHRlbXB0IHRvIHRydW5kbGUgb25cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb25zdCBuZXdMb2FkYWJsZSA9IChfY3VycmVudFRyZWUkYXRvbVZhbHUgPSBjdXJyZW50VHJlZS5hdG9tVmFsdWVzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfY3VycmVudFRyZWUkYXRvbVZhbHUgIT09IHZvaWQgMCA/IF9jdXJyZW50VHJlZSRhdG9tVmFsdSA6IGRlZmF1bHRMb2FkYWJsZTtcclxuXHJcbiAgICAgICAgICBpZiAobmV3TG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScpIHtcclxuICAgICAgICAgICAgdmFyIF9wcmV2aW91c1RyZWUkYXRvbVZhbCwgX3BlbmRpbmdTZXRTZWxmLCBfcGVuZGluZ1NldFNlbGYyLCBfcGVuZGluZ1NldFNlbGYzO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBuZXdMb2FkYWJsZS5jb250ZW50cztcclxuICAgICAgICAgICAgY29uc3Qgb2xkTG9hZGFibGUgPSAoX3ByZXZpb3VzVHJlZSRhdG9tVmFsID0gcHJldmlvdXNUcmVlLmF0b21WYWx1ZXMuZ2V0KGtleSkpICE9PSBudWxsICYmIF9wcmV2aW91c1RyZWUkYXRvbVZhbCAhPT0gdm9pZCAwID8gX3ByZXZpb3VzVHJlZSRhdG9tVmFsIDogZGVmYXVsdExvYWRhYmxlO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IG9sZExvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnID8gb2xkTG9hZGFibGUuY29udGVudHMgOiBERUZBVUxUX1ZBTFVFJDc7IC8vIFRPRE8gVGhpcyBpc24ndCBhY3R1YWxseSB2YWxpZCwgdXNlIGFzIGEgcGxhY2Vob2xkZXIgZm9yIG5vdy5cclxuICAgICAgICAgICAgLy8gSWdub3JlIGF0b20gdmFsdWUgY2hhbmdlcyB0aGF0IHdlcmUgc2V0IHZpYSBzZXRTZWxmKCkgaW4gdGhlIHNhbWUgZWZmZWN0LlxyXG4gICAgICAgICAgICAvLyBXZSB3aWxsIHN0aWxsIHByb3Blcmx5IGNhbGwgdGhlIGhhbmRsZXIgaWYgdGhlcmUgd2FzIGEgc3Vic2VxdWVudFxyXG4gICAgICAgICAgICAvLyBzZXQgZnJvbSBzb21ldGhpbmcgb3RoZXIgdGhhbiBhbiBhdG9tIGVmZmVjdCB3aGljaCB3YXMgYmF0Y2hlZFxyXG4gICAgICAgICAgICAvLyB3aXRoIHRoZSBgc2V0U2VsZigpYCBjYWxsLiAgSG93ZXZlciwgd2UgbWF5IGluY29ycmVjdGx5IGlnbm9yZVxyXG4gICAgICAgICAgICAvLyB0aGUgaGFuZGxlciBpZiB0aGUgc3Vic2VxdWVudCBiYXRjaGVkIGNhbGwgaGFwcGVucyB0byBzZXQgdGhlXHJcbiAgICAgICAgICAgIC8vIGF0b20gdG8gdGhlIGV4YWN0IHNhbWUgdmFsdWUgYXMgdGhlIGBzZXRTZWxmKClgLiAgIEJ1dCwgaW4gdGhhdFxyXG4gICAgICAgICAgICAvLyBjYXNlLCBpdCB3YXMga2luZCBvZiBhIG5vb3AsIHNvIHRoZSBzZW1hbnRpY3MgYXJlIGRlYmF0YWJsZS4uXHJcblxyXG4gICAgICAgICAgICBpZiAoKChfcGVuZGluZ1NldFNlbGYgPSBwZW5kaW5nU2V0U2VsZikgPT09IG51bGwgfHwgX3BlbmRpbmdTZXRTZWxmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ1NldFNlbGYuZWZmZWN0KSAhPT0gZWZmZWN0IHx8ICgoX3BlbmRpbmdTZXRTZWxmMiA9IHBlbmRpbmdTZXRTZWxmKSA9PT0gbnVsbCB8fCBfcGVuZGluZ1NldFNlbGYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ1NldFNlbGYyLnZhbHVlKSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICBoYW5kbGVyKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgIWN1cnJlbnRUcmVlLmF0b21WYWx1ZXMuaGFzKGtleSkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoX3BlbmRpbmdTZXRTZWxmMyA9IHBlbmRpbmdTZXRTZWxmKSA9PT0gbnVsbCB8fCBfcGVuZGluZ1NldFNlbGYzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ1NldFNlbGYzLmVmZmVjdCkgPT09IGVmZmVjdCkge1xyXG4gICAgICAgICAgICAgIHBlbmRpbmdTZXRTZWxmID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIGtleSk7XHJcbiAgICAgICAgY2xlYW51cEVmZmVjdHNCeVN0b3JlLnNldChzdG9yZSwgWy4uLigoX2NsZWFudXBFZmZlY3RzQnlTdG9yMiA9IGNsZWFudXBFZmZlY3RzQnlTdG9yZS5nZXQoc3RvcmUpKSAhPT0gbnVsbCAmJiBfY2xlYW51cEVmZmVjdHNCeVN0b3IyICE9PSB2b2lkIDAgPyBfY2xlYW51cEVmZmVjdHNCeVN0b3IyIDogW10pLCByZWxlYXNlXSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBlZmZlY3Qoe1xyXG4gICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICBzdG9yZUlEOiBzdG9yZS5zdG9yZUlELFxyXG4gICAgICAgICAgICBwYXJlbnRTdG9yZUlEX1VOU1RBQkxFOiBzdG9yZS5wYXJlbnRTdG9yZUlELFxyXG4gICAgICAgICAgICB0cmlnZ2VyLFxyXG4gICAgICAgICAgICBzZXRTZWxmOiBzZXRTZWxmKGVmZmVjdCksXHJcbiAgICAgICAgICAgIHJlc2V0U2VsZjogcmVzZXRTZWxmKGVmZmVjdCksXHJcbiAgICAgICAgICAgIG9uU2V0OiBvblNldChlZmZlY3QpLFxyXG4gICAgICAgICAgICBnZXRQcm9taXNlLFxyXG4gICAgICAgICAgICBnZXRMb2FkYWJsZSxcclxuICAgICAgICAgICAgZ2V0SW5mb19VTlNUQUJMRVxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaWYgKGNsZWFudXAgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgX2NsZWFudXBFZmZlY3RzQnlTdG9yMztcclxuXHJcbiAgICAgICAgICAgIGNsZWFudXBFZmZlY3RzQnlTdG9yZS5zZXQoc3RvcmUsIFsuLi4oKF9jbGVhbnVwRWZmZWN0c0J5U3RvcjMgPSBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuZ2V0KHN0b3JlKSkgIT09IG51bGwgJiYgX2NsZWFudXBFZmZlY3RzQnlTdG9yMyAhPT0gdm9pZCAwID8gX2NsZWFudXBFZmZlY3RzQnlTdG9yMyA6IFtdKSwgY2xlYW51cF0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBpbml0VmFsdWUgPSBlcnJvcjtcclxuICAgICAgICAgIGlzSW5pdEVycm9yID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlzRHVyaW5nSW5pdCA9IGZhbHNlOyAvLyBNdXRhdGUgaW5pdGlhbCBzdGF0ZSBpbiBwbGFjZSBzaW5jZSB3ZSBrbm93IHRoZXJlIGFyZSBubyBvdGhlciBzdWJzY3JpYmVyc1xyXG4gICAgICAvLyBzaW5jZSB3ZSBhcmUgdGhlIG9uZXMgaW5pdGlhbGl6aW5nIG9uIGZpcnN0IHVzZS5cclxuXHJcbiAgICAgIGlmICghKGluaXRWYWx1ZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyKSkge1xyXG4gICAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1O1xyXG5cclxuICAgICAgICBjb25zdCBpbml0TG9hZGFibGUgPSBpc0luaXRFcnJvciA/IGxvYWRhYmxlV2l0aEVycm9yJDIoaW5pdFZhbHVlKSA6IFJlY29pbF9pc1Byb21pc2UoaW5pdFZhbHVlKSA/IGxvYWRhYmxlV2l0aFByb21pc2UkMih3cmFwUGVuZGluZ1Byb21pc2Uoc3RvcmUsIGluaXRWYWx1ZSkpIDogbG9hZGFibGVXaXRoVmFsdWUkMyh1bndyYXAoaW5pdFZhbHVlKSk7XHJcbiAgICAgICAgbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZShpbml0TG9hZGFibGUuY29udGVudHMpO1xyXG4gICAgICAgIGluaXRTdGF0ZS5hdG9tVmFsdWVzLnNldChrZXksIGluaXRMb2FkYWJsZSk7IC8vIElmIHRoZXJlIGlzIGEgcGVuZGluZyB0cmFuc2FjdGlvbiwgdGhlbiBhbHNvIG11dGF0ZSB0aGUgbmV4dCBzdGF0ZSB0cmVlLlxyXG4gICAgICAgIC8vIFRoaXMgY291bGQgaGFwcGVuIGlmIHRoZSBhdG9tIHdhcyBmaXJzdCBpbml0aWFsaXplZCBpbiBhbiBhY3Rpb24gdGhhdFxyXG4gICAgICAgIC8vIGFsc28gdXBkYXRlZCBzb21lIG90aGVyIGF0b20ncyBzdGF0ZS5cclxuXHJcbiAgICAgICAgKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1LmF0b21WYWx1ZXMuc2V0KGtleSwgaW5pdExvYWRhYmxlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjbGVhbnVwQXRvbTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBlZWtBdG9tKF9zdG9yZSwgc3RhdGUpIHtcclxuICAgIHZhciBfcmVmLCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQzO1xyXG5cclxuICAgIHJldHVybiAoX3JlZiA9IChfc3RhdGUkYXRvbVZhbHVlcyRnZXQzID0gc3RhdGUuYXRvbVZhbHVlcy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MyAhPT0gdm9pZCAwID8gX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MyA6IGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWUpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiBkZWZhdWx0TG9hZGFibGU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRBdG9tKF9zdG9yZSwgc3RhdGUpIHtcclxuICAgIGlmIChzdGF0ZS5hdG9tVmFsdWVzLmhhcyhrZXkpKSB7XHJcbiAgICAgIC8vIEF0b20gdmFsdWUgaXMgc3RvcmVkIGluIHN0YXRlOlxyXG4gICAgICByZXR1cm4gUmVjb2lsX251bGx0aHJvd3Moc3RhdGUuYXRvbVZhbHVlcy5nZXQoa2V5KSk7XHJcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmhhcyhrZXkpKSB7XHJcbiAgICAgIC8vIEF0b20gdmFsdWUgaXMgc3RvcmVkIGJ1dCBuZWVkcyB2YWxpZGF0aW9uIGJlZm9yZSB1c2UuXHJcbiAgICAgIC8vIFdlIG1pZ2h0IGhhdmUgYWxyZWFkeSB2YWxpZGF0ZWQgaXQgYW5kIGhhdmUgYSBjYWNoZWQgdmFsaWRhdGVkIHZhbHVlOlxyXG4gICAgICBpZiAoY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwZXJzaXN0ZW5jZSA9PSBudWxsKSB7XHJcbiAgICAgICAgUmVjb2lsX2V4cGVjdGF0aW9uVmlvbGF0aW9uKGBUcmllZCB0byByZXN0b3JlIGEgcGVyc2lzdGVkIHZhbHVlIGZvciBhdG9tICR7a2V5fSBidXQgaXQgaGFzIG5vIHBlcnNpc3RlbmNlIHNldHRpbmdzLmApO1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9hZGFibGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG5vbnZhbGlkYXRlZFZhbHVlID0gc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuZ2V0KGtleSk7XHJcbiAgICAgIGNvbnN0IHZhbGlkYXRvclJlc3VsdCA9IHBlcnNpc3RlbmNlLnZhbGlkYXRvcihub252YWxpZGF0ZWRWYWx1ZSwgREVGQVVMVF9WQUxVRSQ3KTtcclxuICAgICAgY29uc3QgdmFsaWRhdGVkVmFsdWVMb2FkYWJsZSA9IHZhbGlkYXRvclJlc3VsdCBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyID8gZGVmYXVsdExvYWRhYmxlIDogbG9hZGFibGVXaXRoVmFsdWUkMyh2YWxpZGF0b3JSZXN1bHQpO1xyXG4gICAgICBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlID0gdmFsaWRhdGVkVmFsdWVMb2FkYWJsZTtcclxuICAgICAgcmV0dXJuIGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZGVmYXVsdExvYWRhYmxlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW52YWxpZGF0ZUF0b20oKSB7XHJcbiAgICBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0QXRvbShfc3RvcmUsIHN0YXRlLCBuZXdWYWx1ZSkge1xyXG4gICAgLy8gQmFpbCBvdXQgaWYgd2UncmUgYmVpbmcgc2V0IHRvIHRoZSBleGlzdGluZyB2YWx1ZSwgb3IgaWYgd2UncmUgYmVpbmdcclxuICAgIC8vIHJlc2V0IGJ1dCBoYXZlIG5vIHN0b3JlZCB2YWx1ZSAodmFsaWRhdGVkIG9yIHVudmFsaWRhdGVkKSB0byByZXNldCBmcm9tOlxyXG4gICAgaWYgKHN0YXRlLmF0b21WYWx1ZXMuaGFzKGtleSkpIHtcclxuICAgICAgY29uc3QgZXhpc3RpbmcgPSBSZWNvaWxfbnVsbHRocm93cyhzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpKTtcclxuXHJcbiAgICAgIGlmIChleGlzdGluZy5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJyAmJiBuZXdWYWx1ZSA9PT0gZXhpc3RpbmcuY29udGVudHMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKCFzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5oYXMoa2V5KSAmJiBuZXdWYWx1ZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyKSB7XHJcbiAgICAgIHJldHVybiBuZXcgTWFwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZShuZXdWYWx1ZSk7XHJcbiAgICBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlID0gdW5kZWZpbmVkOyAvLyBjYW4gYmUgcmVsZWFzZWQgbm93IGlmIGl0IHdhcyBwcmV2aW91c2x5IGluIHVzZVxyXG5cclxuICAgIHJldHVybiBuZXcgTWFwKCkuc2V0KGtleSwgbG9hZGFibGVXaXRoVmFsdWUkMyhuZXdWYWx1ZSkpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlQXRvbSgpIHtcclxuICAgIHJldHVybiBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMihrZXkpICE9PSB1bmRlZmluZWQgJiYgbGl2ZVN0b3Jlc0NvdW50IDw9IDA7XHJcbiAgfVxyXG5cclxuICBjb25zdCBub2RlID0gcmVnaXN0ZXJOb2RlJDIoe1xyXG4gICAga2V5LFxyXG4gICAgbm9kZVR5cGU6ICdhdG9tJyxcclxuICAgIHBlZWs6IHBlZWtBdG9tLFxyXG4gICAgZ2V0OiBnZXRBdG9tLFxyXG4gICAgc2V0OiBzZXRBdG9tLFxyXG4gICAgaW5pdDogaW5pdEF0b20sXHJcbiAgICBpbnZhbGlkYXRlOiBpbnZhbGlkYXRlQXRvbSxcclxuICAgIHNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZTogc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlQXRvbSxcclxuICAgIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiBvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5LFxyXG4gICAgcGVyc2lzdGVuY2VfVU5TVEFCTEU6IG9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUgPyB7XHJcbiAgICAgIHR5cGU6IG9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUudHlwZSxcclxuICAgICAgYmFja0J1dHRvbjogb3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRS5iYWNrQnV0dG9uXHJcbiAgICB9IDogdW5kZWZpbmVkLFxyXG4gICAgc2hvdWxkUmVzdG9yZUZyb21TbmFwc2hvdHM6IHRydWUsXHJcbiAgICByZXRhaW5lZEJ5XHJcbiAgfSk7XHJcbiAgcmV0dXJuIG5vZGU7XHJcbn0gLy8gcHJldHRpZXItaWdub3JlXHJcblxyXG5cclxuZnVuY3Rpb24gYXRvbShvcHRpb25zKSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmtleSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgUmVjb2lsX2VycignQSBrZXkgb3B0aW9uIHdpdGggYSB1bmlxdWUgc3RyaW5nIHZhbHVlIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBjcmVhdGluZyBhbiBhdG9tLicpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgeyAvLyBAZmItb25seTogc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTLFxyXG4gICAgLi4ucmVzdE9wdGlvbnNcclxuICB9ID0gb3B0aW9ucztcclxuICBjb25zdCBvcHRpb25zRGVmYXVsdCA9ICdkZWZhdWx0JyBpbiBvcHRpb25zID8gLy8gJEZsb3dJc3N1ZVtwcm9wLW1pc3NpbmddIE5vIHdheSB0byByZWZpbmUgaW4gRmxvdyB0aGF0IHByb3BlcnR5IGlzIG5vdCBkZWZpbmVkXHJcbiAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtdHlwZV0gTm8gd2F5IHRvIHJlZmluZSBpbiBGbG93IHRoYXQgcHJvcGVydHkgaXMgbm90IGRlZmluZWRcclxuICBvcHRpb25zLmRlZmF1bHQgOiBuZXcgUHJvbWlzZSgoKSA9PiB7fSk7XHJcblxyXG4gIGlmIChpc1JlY29pbFZhbHVlJDQob3B0aW9uc0RlZmF1bHQpIC8vIENvbnRpbnVlIHRvIHVzZSBhdG9tV2l0aEZhbGxiYWNrIGZvciBwcm9taXNlIGRlZmF1bHRzIGZvciBzY29wZWQgYXRvbXNcclxuICAvLyBmb3Igbm93LCBzaW5jZSBzY29wZWQgYXRvbXMgZG9uJ3Qgc3VwcG9ydCBhc3luYyBkZWZhdWx0c1xyXG4gIC8vIEBmYi1vbmx5OiB8fCAoaXNQcm9taXNlKG9wdGlvbnNEZWZhdWx0KSAmJiBzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1MpXHJcbiAgLy8gQGZiLW9ubHk6IHx8IChpc0xvYWRhYmxlKG9wdGlvbnNEZWZhdWx0KSAmJiBzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1MpXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gYXRvbVdpdGhGYWxsYmFjayh7IC4uLnJlc3RPcHRpb25zLFxyXG4gICAgICBkZWZhdWx0OiBvcHRpb25zRGVmYXVsdCAvLyBAZmItb25seTogc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTLFxyXG5cclxuICAgIH0pOyAvLyBAZmItb25seTogfSBlbHNlIGlmIChzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1NcclxuICAgIC8vIEBmYi1vbmx5OiAmJiAhaXNQcm9taXNlKG9wdGlvbnNEZWZhdWx0KVxyXG4gICAgLy8gQGZiLW9ubHk6ICYmICFpc0xvYWRhYmxlKG9wdGlvbnNEZWZhdWx0KVxyXG4gICAgLy8gQGZiLW9ubHk6ICkge1xyXG4gICAgLy8gQGZiLW9ubHk6IHJldHVybiBzY29wZWRBdG9tPFQ+KHtcclxuICAgIC8vIEBmYi1vbmx5OiAuLi5yZXN0T3B0aW9ucyxcclxuICAgIC8vIEBmYi1vbmx5OiBkZWZhdWx0OiB1bndyYXA8VD4ob3B0aW9uc0RlZmF1bHQpLFxyXG4gICAgLy8gQGZiLW9ubHk6IHNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUyxcclxuICAgIC8vIEBmYi1vbmx5OiB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGJhc2VBdG9tKHsgLi4ucmVzdE9wdGlvbnMsXHJcbiAgICAgIGRlZmF1bHQ6IG9wdGlvbnNEZWZhdWx0XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGF0b21XaXRoRmFsbGJhY2sob3B0aW9ucykge1xyXG4gIGNvbnN0IGJhc2UgPSBhdG9tKHsgLi4ub3B0aW9ucyxcclxuICAgIGRlZmF1bHQ6IERFRkFVTFRfVkFMVUUkNyxcclxuICAgIHBlcnNpc3RlbmNlX1VOU1RBQkxFOiBvcHRpb25zLnBlcnNpc3RlbmNlX1VOU1RBQkxFID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB7IC4uLm9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUsXHJcbiAgICAgIHZhbGlkYXRvcjogc3RvcmVkVmFsdWUgPT4gc3RvcmVkVmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IHN0b3JlZFZhbHVlIDogUmVjb2lsX251bGx0aHJvd3Mob3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRSkudmFsaWRhdG9yKHN0b3JlZFZhbHVlLCBERUZBVUxUX1ZBTFVFJDcpXHJcbiAgICB9LFxyXG4gICAgLy8gVE9ETyBIYWNrIGZvciBub3cuXHJcbiAgICBlZmZlY3RzOiBvcHRpb25zLmVmZmVjdHMsXHJcbiAgICAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTogb2ZmXHJcbiAgICBlZmZlY3RzX1VOU1RBQkxFOiBvcHRpb25zLmVmZmVjdHNfVU5TVEFCTEUgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxyXG5cclxuICB9KTtcclxuICBjb25zdCBzZWwgPSBSZWNvaWxfc2VsZWN0b3Ioe1xyXG4gICAga2V5OiBgJHtvcHRpb25zLmtleX1fX3dpdGhGYWxsYmFja2AsXHJcbiAgICBnZXQ6ICh7XHJcbiAgICAgIGdldFxyXG4gICAgfSkgPT4ge1xyXG4gICAgICBjb25zdCBiYXNlVmFsdWUgPSBnZXQoYmFzZSk7XHJcbiAgICAgIHJldHVybiBiYXNlVmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IG9wdGlvbnMuZGVmYXVsdCA6IGJhc2VWYWx1ZTtcclxuICAgIH0sXHJcbiAgICBzZXQ6ICh7XHJcbiAgICAgIHNldFxyXG4gICAgfSwgbmV3VmFsdWUpID0+IHNldChiYXNlLCBuZXdWYWx1ZSksXHJcbiAgICAvLyBUaGlzIHNlbGVjdG9yIGRvZXMgbm90IG5lZWQgdG8gY2FjaGUgYXMgaXQgaXMgYSB3cmFwcGVyIHNlbGVjdG9yXHJcbiAgICAvLyBhbmQgdGhlIHNlbGVjdG9yIHdpdGhpbiB0aGUgd3JhcHBlciBzZWxlY3RvciB3aWxsIGhhdmUgYSBjYWNoZVxyXG4gICAgLy8gb3B0aW9uIGJ5IGRlZmF1bHRcclxuICAgIGNhY2hlUG9saWN5X1VOU1RBQkxFOiB7XHJcbiAgICAgIGV2aWN0aW9uOiAnbW9zdC1yZWNlbnQnXHJcbiAgICB9LFxyXG4gICAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHlcclxuICB9KTtcclxuICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMShzZWwua2V5LCBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMihvcHRpb25zLmtleSkpO1xyXG4gIHJldHVybiBzZWw7XHJcbn1cclxuXHJcbmF0b20udmFsdWUgPSB2YWx1ZSA9PiBuZXcgV3JhcHBlZFZhbHVlJDIodmFsdWUpO1xyXG5cclxudmFyIFJlY29pbF9hdG9tID0gYXRvbTtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogXHJcbiAqIEBmb3JtYXRcclxuICogQG9uY2FsbCByZWNvaWxcclxuICovXHJcblxyXG5jbGFzcyBNYXBDYWNoZSB7XHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgdmFyIF9vcHRpb25zJG1hcEtleTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWFwXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2tleU1hcHBlclwiLCB2b2lkIDApO1xyXG5cclxuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuX2tleU1hcHBlciA9IChfb3B0aW9ucyRtYXBLZXkgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWFwS2V5KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRtYXBLZXkgIT09IHZvaWQgMCA/IF9vcHRpb25zJG1hcEtleSA6IHYgPT4gdjtcclxuICB9XHJcblxyXG4gIHNpemUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLnNpemU7XHJcbiAgfVxyXG5cclxuICBoYXMoa2V5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyh0aGlzLl9rZXlNYXBwZXIoa2V5KSk7XHJcbiAgfVxyXG5cclxuICBnZXQoa2V5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldCh0aGlzLl9rZXlNYXBwZXIoa2V5KSk7XHJcbiAgfVxyXG5cclxuICBzZXQoa2V5LCB2YWwpIHtcclxuICAgIHRoaXMuX21hcC5zZXQodGhpcy5fa2V5TWFwcGVyKGtleSksIHZhbCk7XHJcbiAgfVxyXG5cclxuICBkZWxldGUoa2V5KSB7XHJcbiAgICB0aGlzLl9tYXAuZGVsZXRlKHRoaXMuX2tleU1hcHBlcihrZXkpKTtcclxuICB9XHJcblxyXG4gIGNsZWFyKCkge1xyXG4gICAgdGhpcy5fbWFwLmNsZWFyKCk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxudmFyIFJlY29pbF9NYXBDYWNoZSA9IHtcclxuICBNYXBDYWNoZVxyXG59O1xyXG5cclxudmFyIFJlY29pbF9NYXBDYWNoZV8xID0gUmVjb2lsX01hcENhY2hlLk1hcENhY2hlO1xyXG5cclxudmFyIFJlY29pbF9NYXBDYWNoZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xyXG4gIF9fcHJvdG9fXzogbnVsbCxcclxuICBNYXBDYWNoZTogUmVjb2lsX01hcENhY2hlXzFcclxufSk7XHJcblxyXG5jb25zdCB7XHJcbiAgTFJVQ2FjaGU6IExSVUNhY2hlJDJcclxufSA9IFJlY29pbF9MUlVDYWNoZSQxO1xyXG5cclxuY29uc3Qge1xyXG4gIE1hcENhY2hlOiBNYXBDYWNoZSQxXHJcbn0gPSBSZWNvaWxfTWFwQ2FjaGUkMTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IGRlZmF1bHRQb2xpY3kkMSA9IHtcclxuICBlcXVhbGl0eTogJ3JlZmVyZW5jZScsXHJcbiAgZXZpY3Rpb246ICdub25lJyxcclxuICBtYXhTaXplOiBJbmZpbml0eVxyXG59O1xyXG5cclxuZnVuY3Rpb24gY2FjaGVGcm9tUG9saWN5KHtcclxuICBlcXVhbGl0eSA9IGRlZmF1bHRQb2xpY3kkMS5lcXVhbGl0eSxcclxuICBldmljdGlvbiA9IGRlZmF1bHRQb2xpY3kkMS5ldmljdGlvbixcclxuICBtYXhTaXplID0gZGVmYXVsdFBvbGljeSQxLm1heFNpemVcclxufSA9IGRlZmF1bHRQb2xpY3kkMSkge1xyXG4gIGNvbnN0IHZhbHVlTWFwcGVyID0gZ2V0VmFsdWVNYXBwZXIkMShlcXVhbGl0eSk7XHJcbiAgY29uc3QgY2FjaGUgPSBnZXRDYWNoZShldmljdGlvbiwgbWF4U2l6ZSwgdmFsdWVNYXBwZXIpO1xyXG4gIHJldHVybiBjYWNoZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VmFsdWVNYXBwZXIkMShlcXVhbGl0eSkge1xyXG4gIHN3aXRjaCAoZXF1YWxpdHkpIHtcclxuICAgIGNhc2UgJ3JlZmVyZW5jZSc6XHJcbiAgICAgIHJldHVybiB2YWwgPT4gdmFsO1xyXG5cclxuICAgIGNhc2UgJ3ZhbHVlJzpcclxuICAgICAgcmV0dXJuIHZhbCA9PiBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5KHZhbCk7XHJcbiAgfVxyXG5cclxuICB0aHJvdyBSZWNvaWxfZXJyKGBVbnJlY29nbml6ZWQgZXF1YWxpdHkgcG9saWN5ICR7ZXF1YWxpdHl9YCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldENhY2hlKGV2aWN0aW9uLCBtYXhTaXplLCBtYXBLZXkpIHtcclxuICBzd2l0Y2ggKGV2aWN0aW9uKSB7XHJcbiAgICBjYXNlICdrZWVwLWFsbCc6XHJcbiAgICAgIHJldHVybiBuZXcgTWFwQ2FjaGUkMSh7XHJcbiAgICAgICAgbWFwS2V5XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgJ2xydSc6XHJcbiAgICAgIHJldHVybiBuZXcgTFJVQ2FjaGUkMih7XHJcbiAgICAgICAgbWFwS2V5LFxyXG4gICAgICAgIG1heFNpemU6IFJlY29pbF9udWxsdGhyb3dzKG1heFNpemUpXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgJ21vc3QtcmVjZW50JzpcclxuICAgICAgcmV0dXJuIG5ldyBMUlVDYWNoZSQyKHtcclxuICAgICAgICBtYXBLZXksXHJcbiAgICAgICAgbWF4U2l6ZTogMVxyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIHRocm93IFJlY29pbF9lcnIoYFVucmVjb2duaXplZCBldmljdGlvbiBwb2xpY3kgJHtldmljdGlvbn1gKTtcclxufVxyXG5cclxudmFyIFJlY29pbF9jYWNoZUZyb21Qb2xpY3kgPSBjYWNoZUZyb21Qb2xpY3k7XHJcblxyXG4vLyBAZmItb25seTogaW1wb3J0IHR5cGUge1Njb3BlUnVsZXN9IGZyb20gJ1JlY29pbF9TY29wZWRBdG9tJztcclxuXHJcblxyXG5jb25zdCB7XHJcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyOiBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMlxyXG59ID0gUmVjb2lsX05vZGU7XHJcblxyXG5cclxuXHJcblxyXG5cclxuLy8gUHJvY2VzcyBzY29wZVJ1bGVzIHRvIGhhbmRsZSBhbnkgZW50cmllcyB3aGljaCBhcmUgZnVuY3Rpb25zIHRha2luZyBwYXJhbWV0ZXJzXHJcbi8vIHByZXR0aWVyLWlnbm9yZVxyXG4vLyBAZmItb25seTogZnVuY3Rpb24gbWFwU2NvcGVSdWxlczxQPihcclxuLy8gQGZiLW9ubHk6IHNjb3BlUnVsZXM/OiBQYXJhbWV0ZXJpemVkU2NvcGVSdWxlczxQPixcclxuLy8gQGZiLW9ubHk6IHBhcmFtOiBQLFxyXG4vLyBAZmItb25seTogKTogU2NvcGVSdWxlcyB8IHZvaWQge1xyXG4vLyBAZmItb25seTogcmV0dXJuIHNjb3BlUnVsZXM/Lm1hcChydWxlID0+XHJcbi8vIEBmYi1vbmx5OiBBcnJheS5pc0FycmF5KHJ1bGUpXHJcbi8vIEBmYi1vbmx5OiA/IHJ1bGUubWFwKGVudHJ5ID0+ICh0eXBlb2YgZW50cnkgPT09ICdmdW5jdGlvbicgPyBlbnRyeShwYXJhbSkgOiBlbnRyeSkpXHJcbi8vIEBmYi1vbmx5OiA6IHJ1bGUsXHJcbi8vIEBmYi1vbmx5OiApO1xyXG4vLyBAZmItb25seTogfVxyXG5cclxuLypcclxuQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIGF0b20gYmFzZWQgb24gdGhlIGlucHV0IHBhcmFtZXRlci5cclxuXHJcbkVhY2ggdW5pcXVlIHBhcmFtZXRlciByZXR1cm5zIGEgdW5pcXVlIGF0b20uIEUuZy4sXHJcblxyXG4gIGNvbnN0IGYgPSBhdG9tRmFtaWx5KC4uLik7XHJcbiAgZih7YTogMX0pID0+IGFuIGF0b21cclxuICBmKHthOiAyfSkgPT4gYSBkaWZmZXJlbnQgYXRvbVxyXG5cclxuVGhpcyBhbGxvd3MgY29tcG9uZW50cyB0byBwZXJzaXN0IGxvY2FsLCBwcml2YXRlIHN0YXRlIHVzaW5nIGF0b21zLiAgRWFjaFxyXG5pbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50IG1heSBoYXZlIGEgZGlmZmVyZW50IGtleSwgd2hpY2ggaXQgdXNlcyBhcyB0aGVcclxucGFyYW1ldGVyIGZvciBhIGZhbWlseSBvZiBhdG9tczsgaW4gdGhpcyB3YXksIGVhY2ggY29tcG9uZW50IHdpbGwgaGF2ZVxyXG5pdHMgb3duIGF0b20gbm90IHNoYXJlZCBieSBvdGhlciBpbnN0YW5jZXMuICBUaGVzZSBzdGF0ZSBrZXlzIG1heSBiZSBjb21wb3NlZFxyXG5pbnRvIGNoaWxkcmVuJ3Mgc3RhdGUga2V5cyBhcyB3ZWxsLlxyXG4qL1xyXG5mdW5jdGlvbiBhdG9tRmFtaWx5KG9wdGlvbnMpIHtcclxuICB2YXIgX29wdGlvbnMkY2FjaGVQb2xpY3lGLCBfb3B0aW9ucyRjYWNoZVBvbGljeUYyO1xyXG5cclxuICBjb25zdCBhdG9tQ2FjaGUgPSBSZWNvaWxfY2FjaGVGcm9tUG9saWN5KHtcclxuICAgIGVxdWFsaXR5OiAoX29wdGlvbnMkY2FjaGVQb2xpY3lGID0gKF9vcHRpb25zJGNhY2hlUG9saWN5RjIgPSBvcHRpb25zLmNhY2hlUG9saWN5Rm9yUGFyYW1zX1VOU1RBQkxFKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRjYWNoZVBvbGljeUYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRjYWNoZVBvbGljeUYyLmVxdWFsaXR5KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRjYWNoZVBvbGljeUYgIT09IHZvaWQgMCA/IF9vcHRpb25zJGNhY2hlUG9saWN5RiA6ICd2YWx1ZScsXHJcbiAgICBldmljdGlvbjogJ2tlZXAtYWxsJ1xyXG4gIH0pOyAvLyBTaW1wbGUgYXRvbUZhbWlseSBpbXBsZW1lbnRhdGlvbiB0byBjYWNoZSBpbmRpdmlkdWFsIGF0b21zIGJhc2VkXHJcbiAgLy8gb24gdGhlIHBhcmFtZXRlciB2YWx1ZSBlcXVhbGl0eS5cclxuXHJcbiAgcmV0dXJuIHBhcmFtcyA9PiB7XHJcbiAgICB2YXIgX3N0YWJsZVN0cmluZ2lmeSwgX29wdGlvbnMkZWZmZWN0cztcclxuXHJcbiAgICBjb25zdCBjYWNoZWRBdG9tID0gYXRvbUNhY2hlLmdldChwYXJhbXMpO1xyXG5cclxuICAgIGlmIChjYWNoZWRBdG9tICE9IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGNhY2hlZEF0b207XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICBjYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRSxcclxuICAgICAgLi4uYXRvbU9wdGlvbnNcclxuICAgIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3Qgb3B0aW9uc0RlZmF1bHQgPSAnZGVmYXVsdCcgaW4gb3B0aW9ucyA/IC8vICRGbG93SXNzdWVbcHJvcC1taXNzaW5nXSBObyB3YXkgdG8gcmVmaW5lIGluIEZsb3cgdGhhdCBwcm9wZXJ0eSBpcyBub3QgZGVmaW5lZFxyXG4gICAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtdHlwZV0gTm8gd2F5IHRvIHJlZmluZSBpbiBGbG93IHRoYXQgcHJvcGVydHkgaXMgbm90IGRlZmluZWRcclxuICAgIG9wdGlvbnMuZGVmYXVsdCA6IG5ldyBQcm9taXNlKCgpID0+IHt9KTtcclxuICAgIGNvbnN0IG5ld0F0b20gPSBSZWNvaWxfYXRvbSh7IC4uLmF0b21PcHRpb25zLFxyXG4gICAgICBrZXk6IGAke29wdGlvbnMua2V5fV9fJHsoX3N0YWJsZVN0cmluZ2lmeSA9IFJlY29pbF9zdGFibGVTdHJpbmdpZnkocGFyYW1zKSkgIT09IG51bGwgJiYgX3N0YWJsZVN0cmluZ2lmeSAhPT0gdm9pZCAwID8gX3N0YWJsZVN0cmluZ2lmeSA6ICd2b2lkJ31gLFxyXG4gICAgICBkZWZhdWx0OiB0eXBlb2Ygb3B0aW9uc0RlZmF1bHQgPT09ICdmdW5jdGlvbicgPyAvLyBUaGUgZGVmYXVsdCB3YXMgcGFyYW1ldGVyaXplZFxyXG4gICAgICAvLyBGbG93IGRvZXNuJ3Qga25vdyB0aGF0IFQgaXNuJ3QgYSBmdW5jdGlvbiwgc28gd2UgbmVlZCB0byBjYXNlIHRvIGFueVxyXG4gICAgICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS11c2VdXHJcbiAgICAgIG9wdGlvbnNEZWZhdWx0KHBhcmFtcykgOiAvLyBEZWZhdWx0IG1heSBiZSBhIHN0YXRpYyB2YWx1ZSwgcHJvbWlzZSwgb3IgUmVjb2lsVmFsdWVcclxuICAgICAgb3B0aW9uc0RlZmF1bHQsXHJcbiAgICAgIHJldGFpbmVkQnlfVU5TVEFCTEU6IHR5cGVvZiBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUocGFyYW1zKSA6IG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSxcclxuICAgICAgZWZmZWN0czogdHlwZW9mIG9wdGlvbnMuZWZmZWN0cyA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZWZmZWN0cyhwYXJhbXMpIDogdHlwZW9mIG9wdGlvbnMuZWZmZWN0c19VTlNUQUJMRSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZWZmZWN0c19VTlNUQUJMRShwYXJhbXMpIDogKF9vcHRpb25zJGVmZmVjdHMgPSBvcHRpb25zLmVmZmVjdHMpICE9PSBudWxsICYmIF9vcHRpb25zJGVmZmVjdHMgIT09IHZvaWQgMCA/IF9vcHRpb25zJGVmZmVjdHMgOiBvcHRpb25zLmVmZmVjdHNfVU5TVEFCTEUgLy8gcHJldHRpZXItaWdub3JlXHJcbiAgICAgIC8vIEBmYi1vbmx5OiBzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1M6IG1hcFNjb3BlUnVsZXMoXHJcbiAgICAgIC8vIEBmYi1vbmx5OiBvcHRpb25zLnNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUyxcclxuICAgICAgLy8gQGZiLW9ubHk6IHBhcmFtcyxcclxuICAgICAgLy8gQGZiLW9ubHk6ICksXHJcblxyXG4gICAgfSk7XHJcbiAgICBhdG9tQ2FjaGUuc2V0KHBhcmFtcywgbmV3QXRvbSk7XHJcbiAgICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMihuZXdBdG9tLmtleSwgKCkgPT4ge1xyXG4gICAgICBhdG9tQ2FjaGUuZGVsZXRlKHBhcmFtcyk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXdBdG9tO1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfYXRvbUZhbWlseSA9IGF0b21GYW1pbHk7XHJcblxyXG5jb25zdCB7XHJcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyOiBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkM1xyXG59ID0gUmVjb2lsX05vZGU7XHJcblxyXG5cclxuXHJcblxyXG5cclxuIC8vIEtlZXAgaW4gbWluZCB0aGUgcGFyYW1ldGVyIG5lZWRzIHRvIGJlIHNlcmlhbGl6YWJsZSBhcyBhIGNhaGNoZSBrZXlcclxuLy8gdXNpbmcgUmVjb2lsX3N0YWJsZVN0cmluZ2lmeVxyXG5cclxuXHJcbi8vIEFkZCBhIHVuaXF1ZSBpbmRleCB0byBlYWNoIHNlbGVjdG9yIGluIGNhc2UgdGhlIGNhY2hlIGltcGxlbWVudGF0aW9uIGFsbG93c1xyXG4vLyBkdXBsaWNhdGUga2V5cyBiYXNlZCBvbiBlcXVpdmFsZW50IHN0cmluZ2lmaWVkIHBhcmFtZXRlcnNcclxubGV0IG5leHRJbmRleCA9IDA7XHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xyXG5cclxuLy8gUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG1lbWJlcnMgb2YgYSBmYW1pbHkgb2Ygc2VsZWN0b3JzIG9mIHRoZSBzYW1lIHR5cGVcclxuLy8gRS5nLixcclxuLy9cclxuLy8gY29uc3QgcyA9IHNlbGVjdG9yRmFtaWx5KC4uLik7XHJcbi8vIHMoe2E6IDF9KSA9PiBhIHNlbGVjdG9yXHJcbi8vIHMoe2E6IDJ9KSA9PiBhIGRpZmZlcmVudCBzZWxlY3RvclxyXG4vL1xyXG4vLyBCeSBkZWZhdWx0LCB0aGUgc2VsZWN0b3JzIGFyZSBkaXN0aW5ndWlzaGVkIGJ5IGRpc3RpbmN0IHZhbHVlcyBvZiB0aGVcclxuLy8gcGFyYW1ldGVyIGJhc2VkIG9uIHZhbHVlIGVxdWFsaXR5LCBub3QgcmVmZXJlbmNlIGVxdWFsaXR5LiAgVGhpcyBhbGxvd3MgdXNpbmdcclxuLy8gb2JqZWN0IGxpdGVyYWxzIG9yIG90aGVyIGVxdWl2YWxlbnQgb2JqZWN0cyBhdCBjYWxsc2l0ZXMgdG8gbm90IGNyZWF0ZVxyXG4vLyBkdXBsaWNhdGUgY2FjaGUgZW50cmllcy4gIFRoaXMgYmVoYXZpb3IgbWF5IGJlIG92ZXJyaWRkZW4gd2l0aCB0aGVcclxuLy8gY2FjaGVJbXBsZW1lbnRhdGlvbkZvclBhcmFtcyBvcHRpb24uXHJcbmZ1bmN0aW9uIHNlbGVjdG9yRmFtaWx5KG9wdGlvbnMpIHtcclxuICB2YXIgX29wdGlvbnMkY2FjaGVQb2xpY3lGLCBfb3B0aW9ucyRjYWNoZVBvbGljeUYyO1xyXG5cclxuICBjb25zdCBzZWxlY3RvckNhY2hlID0gUmVjb2lsX2NhY2hlRnJvbVBvbGljeSh7XHJcbiAgICBlcXVhbGl0eTogKF9vcHRpb25zJGNhY2hlUG9saWN5RiA9IChfb3B0aW9ucyRjYWNoZVBvbGljeUYyID0gb3B0aW9ucy5jYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRSkgPT09IG51bGwgfHwgX29wdGlvbnMkY2FjaGVQb2xpY3lGMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkY2FjaGVQb2xpY3lGMi5lcXVhbGl0eSkgIT09IG51bGwgJiYgX29wdGlvbnMkY2FjaGVQb2xpY3lGICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRjYWNoZVBvbGljeUYgOiAndmFsdWUnLFxyXG4gICAgZXZpY3Rpb246ICdrZWVwLWFsbCdcclxuICB9KTtcclxuICByZXR1cm4gcGFyYW1zID0+IHtcclxuICAgIHZhciBfc3RhYmxlU3RyaW5naWZ5O1xyXG5cclxuICAgIC8vIFRocm93IGFuIGVycm9yIHdpdGggc2VsZWN0b3Iga2V5IHNvIHRoYXQgaXQgaXMgY2xlYXIgd2hpY2hcclxuICAgIC8vIHNlbGVjdG9yIGlzIGNhdXNpbmcgYW4gZXJyb3JcclxuICAgIGxldCBjYWNoZWRTZWxlY3RvcjtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjYWNoZWRTZWxlY3RvciA9IHNlbGVjdG9yQ2FjaGUuZ2V0KHBhcmFtcyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKGBQcm9ibGVtIHdpdGggY2FjaGUgbG9va3VwIGZvciBzZWxlY3RvciAke29wdGlvbnMua2V5fTogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjYWNoZWRTZWxlY3RvciAhPSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBjYWNoZWRTZWxlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBteUtleSA9IGAke29wdGlvbnMua2V5fV9fc2VsZWN0b3JGYW1pbHkvJHsoX3N0YWJsZVN0cmluZ2lmeSA9IFJlY29pbF9zdGFibGVTdHJpbmdpZnkocGFyYW1zLCB7XHJcbiAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRvIHVzZSBmdW5jdGlvbnMgaW4gcGFyYW1ldGVycyBpZiB0aGUgdXNlciB1c2VzXHJcbiAgICAgIC8vIGEgY2FjaGUgd2l0aCByZWZlcmVuY2UgZXF1YWxpdHkgdGhhbmtzIHRvIHRoZSBpbmNyZW1lbnRpbmcgaW5kZXguXHJcbiAgICAgIGFsbG93RnVuY3Rpb25zOiB0cnVlXHJcbiAgICB9KSkgIT09IG51bGwgJiYgX3N0YWJsZVN0cmluZ2lmeSAhPT0gdm9pZCAwID8gX3N0YWJsZVN0cmluZ2lmeSA6ICd2b2lkJ30vJHtuZXh0SW5kZXgrK31gOyAvLyBBcHBlbmQgaW5kZXggaW4gY2FzZSB2YWx1ZXMgc2VyaWFsaXplIHRvIHRoZSBzYW1lIGtleSBzdHJpbmdcclxuXHJcbiAgICBjb25zdCBteUdldCA9IGNhbGxiYWNrcyA9PiBvcHRpb25zLmdldChwYXJhbXMpKGNhbGxiYWNrcyk7XHJcblxyXG4gICAgY29uc3QgbXlDYWNoZVBvbGljeSA9IG9wdGlvbnMuY2FjaGVQb2xpY3lfVU5TVEFCTEU7XHJcbiAgICBjb25zdCByZXRhaW5lZEJ5ID0gdHlwZW9mIG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRShwYXJhbXMpIDogb3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFO1xyXG4gICAgbGV0IG5ld1NlbGVjdG9yO1xyXG5cclxuICAgIGlmIChvcHRpb25zLnNldCAhPSBudWxsKSB7XHJcbiAgICAgIGNvbnN0IHNldCA9IG9wdGlvbnMuc2V0O1xyXG5cclxuICAgICAgY29uc3QgbXlTZXQgPSAoY2FsbGJhY2tzLCBuZXdWYWx1ZSkgPT4gc2V0KHBhcmFtcykoY2FsbGJhY2tzLCBuZXdWYWx1ZSk7XHJcblxyXG4gICAgICBuZXdTZWxlY3RvciA9IFJlY29pbF9zZWxlY3Rvcih7XHJcbiAgICAgICAga2V5OiBteUtleSxcclxuICAgICAgICBnZXQ6IG15R2V0LFxyXG4gICAgICAgIHNldDogbXlTZXQsXHJcbiAgICAgICAgY2FjaGVQb2xpY3lfVU5TVEFCTEU6IG15Q2FjaGVQb2xpY3ksXHJcbiAgICAgICAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHksXHJcbiAgICAgICAgcmV0YWluZWRCeV9VTlNUQUJMRTogcmV0YWluZWRCeVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG5ld1NlbGVjdG9yID0gUmVjb2lsX3NlbGVjdG9yKHtcclxuICAgICAgICBrZXk6IG15S2V5LFxyXG4gICAgICAgIGdldDogbXlHZXQsXHJcbiAgICAgICAgY2FjaGVQb2xpY3lfVU5TVEFCTEU6IG15Q2FjaGVQb2xpY3ksXHJcbiAgICAgICAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHksXHJcbiAgICAgICAgcmV0YWluZWRCeV9VTlNUQUJMRTogcmV0YWluZWRCeVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3RvckNhY2hlLnNldChwYXJhbXMsIG5ld1NlbGVjdG9yKTtcclxuICAgIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQzKG5ld1NlbGVjdG9yLmtleSwgKCkgPT4ge1xyXG4gICAgICBzZWxlY3RvckNhY2hlLmRlbGV0ZShwYXJhbXMpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbmV3U2VsZWN0b3I7XHJcbiAgfTtcclxufVxyXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXJlZGVjbGFyZSAqL1xyXG5cclxuXHJcbnZhciBSZWNvaWxfc2VsZWN0b3JGYW1pbHkgPSBzZWxlY3RvckZhbWlseTtcclxuXHJcbi8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXHJcblxyXG5cclxuY29uc3QgY29uc3RhbnRTZWxlY3RvciA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XHJcbiAga2V5OiAnX19jb25zdGFudCcsXHJcbiAgZ2V0OiBjb25zdGFudCA9PiAoKSA9PiBjb25zdGFudCxcclxuICBjYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRToge1xyXG4gICAgZXF1YWxpdHk6ICdyZWZlcmVuY2UnXHJcbiAgfVxyXG59KTsgLy8gRnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2VsZWN0b3Igd2hpY2ggYWx3YXlzIHByb2R1Y2VzIHRoZVxyXG4vLyBzYW1lIGNvbnN0YW50IHZhbHVlLiAgSXQgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIHRoZVxyXG4vLyBzYW1lIHZhbHVlLCBiYXNlZCBvbiByZWZlcmVuY2UgZXF1YWxpdHksIGFuZCB3aWxsIHByb3ZpZGUgdGhlXHJcbi8vIHNhbWUgc2VsZWN0b3IuXHJcblxyXG5mdW5jdGlvbiBjb25zdFNlbGVjdG9yKGNvbnN0YW50KSB7XHJcbiAgcmV0dXJuIGNvbnN0YW50U2VsZWN0b3IoY29uc3RhbnQpO1xyXG59XHJcblxyXG52YXIgUmVjb2lsX2NvbnN0U2VsZWN0b3IgPSBjb25zdFNlbGVjdG9yO1xyXG5cclxuLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcclxuXHJcblxyXG5jb25zdCB0aHJvd2luZ1NlbGVjdG9yID0gUmVjb2lsX3NlbGVjdG9yRmFtaWx5KHtcclxuICBrZXk6ICdfX2Vycm9yJyxcclxuICBnZXQ6IG1lc3NhZ2UgPT4gKCkgPT4ge1xyXG4gICAgdGhyb3cgUmVjb2lsX2VycihtZXNzYWdlKTtcclxuICB9LFxyXG4gIC8vIFRPRE8gV2h5P1xyXG4gIGNhY2hlUG9saWN5Rm9yUGFyYW1zX1VOU1RBQkxFOiB7XHJcbiAgICBlcXVhbGl0eTogJ3JlZmVyZW5jZSdcclxuICB9XHJcbn0pOyAvLyBGdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZWxlY3RvciB3aGljaCBhbHdheXMgdGhyb3dzIGFuIGVycm9yXHJcbi8vIHdpdGggdGhlIHByb3ZpZGVkIG1lc3NhZ2UuXHJcblxyXG5mdW5jdGlvbiBlcnJvclNlbGVjdG9yKG1lc3NhZ2UpIHtcclxuICByZXR1cm4gdGhyb3dpbmdTZWxlY3RvcihtZXNzYWdlKTtcclxufVxyXG5cclxudmFyIFJlY29pbF9lcnJvclNlbGVjdG9yID0gZXJyb3JTZWxlY3RvcjtcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICpcclxuICogV3JhcHMgYW5vdGhlciByZWNvaWwgdmFsdWUgYW5kIHByZXZlbnRzIHdyaXRpbmcgdG8gaXQuXHJcbiAqXHJcbiAqIFxyXG4gKiBAZm9ybWF0XHJcbiAqIEBvbmNhbGwgcmVjb2lsXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcmVhZE9ubHlTZWxlY3RvcihhdG9tKSB7XHJcbiAgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTogb2ZmXHJcbiAgcmV0dXJuIGF0b207XHJcbn1cclxuXHJcbnZhciBSZWNvaWxfcmVhZE9ubHlTZWxlY3RvciA9IHJlYWRPbmx5U2VsZWN0b3I7XHJcblxyXG5jb25zdCB7XHJcbiAgbG9hZGFibGVXaXRoRXJyb3I6IGxvYWRhYmxlV2l0aEVycm9yJDMsXHJcbiAgbG9hZGFibGVXaXRoUHJvbWlzZTogbG9hZGFibGVXaXRoUHJvbWlzZSQzLFxyXG4gIGxvYWRhYmxlV2l0aFZhbHVlOiBsb2FkYWJsZVdpdGhWYWx1ZSQ0XHJcbn0gPSBSZWNvaWxfTG9hZGFibGUkMTtcclxuXHJcblxyXG5cclxuXHJcblxyXG4gLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gIFRSVVRIIFRBQkxFXHJcbi8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIERlcGVuZGVuY2llcyAgICAgICAgd2FpdEZvck5vbmUgICAgICAgICB3YWl0Rm9yQW55ICAgICAgICB3YWl0Rm9yQWxsICAgICAgIHdhaXRGb3JBbGxTZXR0bGVkXHJcbi8vICBbbG9hZGluZywgbG9hZGluZ10gIFtQcm9taXNlLCBQcm9taXNlXSAgUHJvbWlzZSAgICAgICAgICAgUHJvbWlzZSAgICAgICAgIFByb21pc2VcclxuLy8gIFt2YWx1ZSwgbG9hZGluZ10gICAgW3ZhbHVlLCBQcm9taXNlXSAgICBbdmFsdWUsIFByb21pc2VdICBQcm9taXNlICAgICAgICAgUHJvbWlzZVxyXG4vLyAgW3ZhbHVlLCB2YWx1ZV0gICAgICBbdmFsdWUsIHZhbHVlXSAgICAgIFt2YWx1ZSwgdmFsdWVdICAgIFt2YWx1ZSwgdmFsdWVdICBbdmFsdWUsIHZhbHVlXVxyXG4vL1xyXG4vLyAgW2Vycm9yLCBsb2FkaW5nXSAgICBbRXJyb3IsIFByb21pc2VdICAgIFtFcnJvciwgUHJvbWlzZV0gIEVycm9yICAgICAgICAgICBQcm9taXNlXHJcbi8vICBbZXJyb3IsIGVycm9yXSAgICAgIFtFcnJvciwgRXJyb3JdICAgICAgW0Vycm9yLCBFcnJvcl0gICAgRXJyb3IgICAgICAgICAgIFtlcnJvciwgZXJyb3JdXHJcbi8vICBbdmFsdWUsIGVycm9yXSAgICAgIFt2YWx1ZSwgRXJyb3JdICAgICAgW3ZhbHVlLCBFcnJvcl0gICAgRXJyb3IgICAgICAgICAgIFt2YWx1ZSwgZXJyb3JdXHJcbi8vIElzc3VlIHBhcmFsbGVsIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGFuZCByZXR1cm4gdGhlIGN1cnJlbnRcclxuLy8gc3RhdHVzIGlmIHRoZXkgaGF2ZSByZXN1bHRzLCBoYXZlIHNvbWUgZXJyb3IsIG9yIGFyZSBzdGlsbCBwZW5kaW5nLlxyXG5cclxuXHJcbmZ1bmN0aW9uIGNvbmN1cnJlbnRSZXF1ZXN0cyhnZXRSZWNvaWxWYWx1ZSwgZGVwcykge1xyXG4gIGNvbnN0IHJlc3VsdHMgPSBBcnJheShkZXBzLmxlbmd0aCkuZmlsbCh1bmRlZmluZWQpO1xyXG4gIGNvbnN0IGV4Y2VwdGlvbnMgPSBBcnJheShkZXBzLmxlbmd0aCkuZmlsbCh1bmRlZmluZWQpO1xyXG5cclxuICBmb3IgKGNvbnN0IFtpLCBkZXBdIG9mIGRlcHMuZW50cmllcygpKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXN1bHRzW2ldID0gZ2V0UmVjb2lsVmFsdWUoZGVwKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgLy8gZXhjZXB0aW9ucyBjYW4gZWl0aGVyIGJlIFByb21pc2VzIG9mIHBlbmRpbmcgcmVzdWx0cyBvciByZWFsIGVycm9yc1xyXG4gICAgICBleGNlcHRpb25zW2ldID0gZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBbcmVzdWx0cywgZXhjZXB0aW9uc107XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRXJyb3IoZXhwKSB7XHJcbiAgcmV0dXJuIGV4cCAhPSBudWxsICYmICFSZWNvaWxfaXNQcm9taXNlKGV4cCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVud3JhcERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpIHtcclxuICByZXR1cm4gQXJyYXkuaXNBcnJheShkZXBlbmRlbmNpZXMpID8gZGVwZW5kZW5jaWVzIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGVwZW5kZW5jaWVzKS5tYXAoa2V5ID0+IGRlcGVuZGVuY2llc1trZXldKTtcclxufVxyXG5cclxuZnVuY3Rpb24gd3JhcFJlc3VsdHMoZGVwZW5kZW5jaWVzLFxyXG4vKiAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdIFRoZSB0eXBlIGFubm90YXRpb24ocykgcmVxdWlyZWQgYnkgRmxvdydzXHJcbiAqIExUSSB1cGRhdGUgY291bGQgbm90IGJlIGFkZGVkIHZpYSBjb2RlbW9kICovXHJcbnJlc3VsdHMpIHtcclxuICByZXR1cm4gQXJyYXkuaXNBcnJheShkZXBlbmRlbmNpZXMpID8gcmVzdWx0cyA6IC8vIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCkgaGFzIGNvbnNpc3RlbnQga2V5IG9yZGVyaW5nIHdpdGggRVM2XHJcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGVwZW5kZW5jaWVzKS5yZWR1Y2UoKG91dCwga2V5LCBpZHgpID0+ICh7IC4uLm91dCxcclxuICAgIFtrZXldOiByZXN1bHRzW2lkeF1cclxuICB9KSwge30pO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucykge1xyXG4gIGNvbnN0IG91dHB1dCA9IGV4Y2VwdGlvbnMubWFwKChleGNlcHRpb24sIGlkeCkgPT4gZXhjZXB0aW9uID09IG51bGwgPyBsb2FkYWJsZVdpdGhWYWx1ZSQ0KHJlc3VsdHNbaWR4XSkgOiBSZWNvaWxfaXNQcm9taXNlKGV4Y2VwdGlvbikgPyBsb2FkYWJsZVdpdGhQcm9taXNlJDMoZXhjZXB0aW9uKSA6IGxvYWRhYmxlV2l0aEVycm9yJDMoZXhjZXB0aW9uKSk7XHJcbiAgcmV0dXJuIHdyYXBSZXN1bHRzKGRlcGVuZGVuY2llcywgb3V0cHV0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tYmluZUFzeW5jUmVzdWx0c1dpdGhTeW5jUmVzdWx0cyhzeW5jUmVzdWx0cywgYXN5bmNSZXN1bHRzKSB7XHJcbiAgcmV0dXJuIGFzeW5jUmVzdWx0cy5tYXAoKHJlc3VsdCwgaWR4KSA9PlxyXG4gIC8qKlxyXG4gICAqIGl0J3MgaW1wb3J0YW50IHdlIHVzZSA9PT0gdW5kZWZpbmVkIGFzIG9wcG9zZWQgdG8gPT0gbnVsbCwgYmVjYXVzZSB0aGVcclxuICAgKiByZXNvbHZlZCB2YWx1ZSBvZiB0aGUgYXN5bmMgcHJvbWlzZSBjb3VsZCBiZSBgbnVsbGAsIGluIHdoaWNoIGNhc2Ugd2VcclxuICAgKiBkb24ndCB3YW50IHRvIHVzZSBzeW5jUmVzdWx0c1tpZHhdLCB3aGljaCB3b3VsZCBiZSB1bmRlZmluZWQuIElmIGFzeW5jXHJcbiAgICogcHJvbWlzZSByZXNvbHZlcyB0byBgdW5kZWZpbmVkYCwgdGhhdCdzIG9rIGJlY2F1c2UgYHN5bmNSZXN1bHRzW2lkeF1gXHJcbiAgICogd2lsbCBhbHNvIGJlIGB1bmRlZmluZWRgLiBUaGF0J3MgYSBsaXR0bGUgaGFja3ksIGJ1dCBpdCB3b3Jrcy5cclxuICAgKi9cclxuICByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHN5bmNSZXN1bHRzW2lkeF0gOiByZXN1bHQpO1xyXG59IC8vIFNlbGVjdG9yIHRoYXQgcmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbCBhbmQgaW1tZWRpYXRlbHkgcmV0dXJuc1xyXG4vLyBjdXJyZW50IHJlc3VsdHMgd2l0aG91dCB3YWl0aW5nLlxyXG5cclxuXHJcbmNvbnN0IHdhaXRGb3JOb25lID0gUmVjb2lsX3NlbGVjdG9yRmFtaWx5KHtcclxuICBrZXk6ICdfX3dhaXRGb3JOb25lJyxcclxuICBnZXQ6IGRlcGVuZGVuY2llcyA9PiAoe1xyXG4gICAgZ2V0XHJcbiAgfSkgPT4ge1xyXG4gICAgLy8gSXNzdWUgcmVxdWVzdHMgZm9yIGFsbCBkZXBlbmRlbmNpZXMgaW4gcGFyYWxsZWwuXHJcbiAgICBjb25zdCBkZXBzID0gdW53cmFwRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XHJcbiAgICBjb25zdCBbcmVzdWx0cywgZXhjZXB0aW9uc10gPSBjb25jdXJyZW50UmVxdWVzdHMoZ2V0LCBkZXBzKTsgLy8gQWx3YXlzIHJldHVybiB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIHJlc3VsdHM7IG5ldmVyIGJsb2NrLlxyXG5cclxuICAgIHJldHVybiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucyk7XHJcbiAgfSxcclxuICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogdHJ1ZVxyXG59KTsgLy8gU2VsZWN0b3IgdGhhdCByZXF1ZXN0cyBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsIGFuZCB3YWl0cyBmb3IgYXQgbGVhc3RcclxuLy8gb25lIHRvIGJlIGF2YWlsYWJsZSBiZWZvcmUgcmV0dXJuaW5nIHJlc3VsdHMuICBJdCB3aWxsIG9ubHkgZXJyb3IgaWYgYWxsXHJcbi8vIGRlcGVuZGVuY2llcyBoYXZlIGVycm9ycy5cclxuXHJcbmNvbnN0IHdhaXRGb3JBbnkgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xyXG4gIGtleTogJ19fd2FpdEZvckFueScsXHJcbiAgZ2V0OiBkZXBlbmRlbmNpZXMgPT4gKHtcclxuICAgIGdldFxyXG4gIH0pID0+IHtcclxuICAgIC8vIElzc3VlIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsLlxyXG4gICAgLy8gRXhjZXB0aW9ucyBjYW4gZWl0aGVyIGJlIFByb21pc2VzIG9mIHBlbmRpbmcgcmVzdWx0cyBvciByZWFsIGVycm9yc1xyXG4gICAgY29uc3QgZGVwcyA9IHVud3JhcERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpO1xyXG4gICAgY29uc3QgW3Jlc3VsdHMsIGV4Y2VwdGlvbnNdID0gY29uY3VycmVudFJlcXVlc3RzKGdldCwgZGVwcyk7IC8vIElmIGFueSByZXN1bHRzIGFyZSBhdmFpbGFibGUsIHZhbHVlIG9yIGVycm9yLCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdHVzXHJcblxyXG4gICAgaWYgKGV4Y2VwdGlvbnMuc29tZShleHAgPT4gIVJlY29pbF9pc1Byb21pc2UoZXhwKSkpIHtcclxuICAgICAgcmV0dXJuIHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKTtcclxuICAgIH0gLy8gT3RoZXJ3aXNlLCByZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gdGhlIG5leHQgcmVzdWx0IGlzXHJcbiAgICAvLyBhdmFpbGFibGUsIHdoaWNoZXZlciBvbmUgaGFwcGVucyB0byBiZSBuZXh0LiAgQnV0LCBpZiBhbGwgcGVuZGluZ1xyXG4gICAgLy8gZGVwZW5kZW5jaWVzIGVuZCB1cCB3aXRoIGVycm9ycywgdGhlbiByZWplY3QgdGhlIHByb21pc2UuXHJcblxyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgZm9yIChjb25zdCBbaSwgZXhwXSBvZiBleGNlcHRpb25zLmVudHJpZXMoKSkge1xyXG4gICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKGV4cCkpIHtcclxuICAgICAgICAgIGV4cC50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHJlc3VsdHNbaV0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIGV4Y2VwdGlvbnNbaV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHJlc29sdmUod3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpKTtcclxuICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgZXhjZXB0aW9uc1tpXSA9IGVycm9yO1xyXG4gICAgICAgICAgICByZXNvbHZlKHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IHRydWVcclxufSk7IC8vIFNlbGVjdG9yIHRoYXQgcmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbCBhbmQgd2FpdHMgZm9yIGFsbCB0byBiZVxyXG4vLyBhdmFpbGFibGUgYmVmb3JlIHJldHVybmluZyBhIHZhbHVlLiAgSXQgd2lsbCBlcnJvciBpZiBhbnkgZGVwZW5kZW5jaWVzIGVycm9yLlxyXG5cclxuY29uc3Qgd2FpdEZvckFsbCA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XHJcbiAga2V5OiAnX193YWl0Rm9yQWxsJyxcclxuICBnZXQ6IGRlcGVuZGVuY2llcyA9PiAoe1xyXG4gICAgZ2V0XHJcbiAgfSkgPT4ge1xyXG4gICAgLy8gSXNzdWUgcmVxdWVzdHMgZm9yIGFsbCBkZXBlbmRlbmNpZXMgaW4gcGFyYWxsZWwuXHJcbiAgICAvLyBFeGNlcHRpb25zIGNhbiBlaXRoZXIgYmUgUHJvbWlzZXMgb2YgcGVuZGluZyByZXN1bHRzIG9yIHJlYWwgZXJyb3JzXHJcbiAgICBjb25zdCBkZXBzID0gdW53cmFwRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XHJcbiAgICBjb25zdCBbcmVzdWx0cywgZXhjZXB0aW9uc10gPSBjb25jdXJyZW50UmVxdWVzdHMoZ2V0LCBkZXBzKTsgLy8gSWYgYWxsIHJlc3VsdHMgYXJlIGF2YWlsYWJsZSwgcmV0dXJuIHRoZSByZXN1bHRzXHJcblxyXG4gICAgaWYgKGV4Y2VwdGlvbnMuZXZlcnkoZXhwID0+IGV4cCA9PSBudWxsKSkge1xyXG4gICAgICByZXR1cm4gd3JhcFJlc3VsdHMoZGVwZW5kZW5jaWVzLCByZXN1bHRzKTtcclxuICAgIH0gLy8gSWYgd2UgaGF2ZSBhbnkgZXJyb3JzLCB0aHJvdyB0aGUgZmlyc3QgZXJyb3JcclxuXHJcblxyXG4gICAgY29uc3QgZXJyb3IgPSBleGNlcHRpb25zLmZpbmQoaXNFcnJvcik7XHJcblxyXG4gICAgaWYgKGVycm9yICE9IG51bGwpIHtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9IC8vIE90aGVyd2lzZSwgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIGFsbCByZXN1bHRzIGFyZSBhdmFpbGFibGVcclxuXHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGV4Y2VwdGlvbnMpLnRoZW4oZXhjZXB0aW9uUmVzdWx0cyA9PiB3cmFwUmVzdWx0cyhkZXBlbmRlbmNpZXMsIGNvbWJpbmVBc3luY1Jlc3VsdHNXaXRoU3luY1Jlc3VsdHMocmVzdWx0cywgZXhjZXB0aW9uUmVzdWx0cykpKTtcclxuICB9LFxyXG4gIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiB0cnVlXHJcbn0pO1xyXG5jb25zdCB3YWl0Rm9yQWxsU2V0dGxlZCA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XHJcbiAga2V5OiAnX193YWl0Rm9yQWxsU2V0dGxlZCcsXHJcbiAgZ2V0OiBkZXBlbmRlbmNpZXMgPT4gKHtcclxuICAgIGdldFxyXG4gIH0pID0+IHtcclxuICAgIC8vIElzc3VlIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsLlxyXG4gICAgLy8gRXhjZXB0aW9ucyBjYW4gZWl0aGVyIGJlIFByb21pc2VzIG9mIHBlbmRpbmcgcmVzdWx0cyBvciByZWFsIGVycm9yc1xyXG4gICAgY29uc3QgZGVwcyA9IHVud3JhcERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpO1xyXG4gICAgY29uc3QgW3Jlc3VsdHMsIGV4Y2VwdGlvbnNdID0gY29uY3VycmVudFJlcXVlc3RzKGdldCwgZGVwcyk7IC8vIElmIGFsbCByZXN1bHRzIGFyZSBhdmFpbGFibGUsIHJldHVybiB0aGUgcmVzdWx0c1xyXG5cclxuICAgIGlmIChleGNlcHRpb25zLmV2ZXJ5KGV4cCA9PiAhUmVjb2lsX2lzUHJvbWlzZShleHApKSkge1xyXG4gICAgICByZXR1cm4gd3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpO1xyXG4gICAgfSAvLyBXYWl0IGZvciBhbGwgcmVzdWx0cyB0byBzZXR0bGVcclxuXHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGV4Y2VwdGlvbnMubWFwKChleHAsIGkpID0+IFJlY29pbF9pc1Byb21pc2UoZXhwKSA/IGV4cC50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgIHJlc3VsdHNbaV0gPSByZXN1bHQ7XHJcbiAgICAgIGV4Y2VwdGlvbnNbaV0gPSB1bmRlZmluZWQ7XHJcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgIHJlc3VsdHNbaV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgIGV4Y2VwdGlvbnNbaV0gPSBlcnJvcjtcclxuICAgIH0pIDogbnVsbCkpIC8vIFRoZW4gd3JhcCB0aGVtIGFzIGxvYWRhYmxlc1xyXG4gICAgLnRoZW4oKCkgPT4gd3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpKTtcclxuICB9LFxyXG4gIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiB0cnVlXHJcbn0pO1xyXG5jb25zdCBub1dhaXQgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xyXG4gIGtleTogJ19fbm9XYWl0JyxcclxuICBnZXQ6IGRlcGVuZGVuY3kgPT4gKHtcclxuICAgIGdldFxyXG4gIH0pID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBSZWNvaWxfc2VsZWN0b3IudmFsdWUobG9hZGFibGVXaXRoVmFsdWUkNChnZXQoZGVwZW5kZW5jeSkpKTtcclxuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xyXG4gICAgICByZXR1cm4gUmVjb2lsX3NlbGVjdG9yLnZhbHVlKFJlY29pbF9pc1Byb21pc2UoZXhjZXB0aW9uKSA/IGxvYWRhYmxlV2l0aFByb21pc2UkMyhleGNlcHRpb24pIDogbG9hZGFibGVXaXRoRXJyb3IkMyhleGNlcHRpb24pKTtcclxuICAgIH1cclxuICB9LFxyXG4gIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiB0cnVlXHJcbn0pO1xyXG52YXIgUmVjb2lsX1dhaXRGb3IgPSB7XHJcbiAgd2FpdEZvck5vbmUsXHJcbiAgd2FpdEZvckFueSxcclxuICB3YWl0Rm9yQWxsLFxyXG4gIHdhaXRGb3JBbGxTZXR0bGVkLFxyXG4gIG5vV2FpdFxyXG59O1xyXG5cclxuY29uc3Qge1xyXG4gIFJlY29pbExvYWRhYmxlXHJcbn0gPSBSZWNvaWxfTG9hZGFibGUkMTtcclxuXHJcbmNvbnN0IHtcclxuICBEZWZhdWx0VmFsdWU6IERlZmF1bHRWYWx1ZSQzXHJcbn0gPSBSZWNvaWxfTm9kZTtcclxuXHJcbmNvbnN0IHtcclxuICBSZWNvaWxSb290OiBSZWNvaWxSb290JDIsXHJcbiAgdXNlUmVjb2lsU3RvcmVJRDogdXNlUmVjb2lsU3RvcmVJRCQxXHJcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcclxuXHJcbmNvbnN0IHtcclxuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDVcclxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xyXG5cclxuY29uc3Qge1xyXG4gIHJldGVudGlvblpvbmU6IHJldGVudGlvblpvbmUkMVxyXG59ID0gUmVjb2lsX1JldGVudGlvblpvbmU7XHJcblxyXG5jb25zdCB7XHJcbiAgZnJlc2hTbmFwc2hvdDogZnJlc2hTbmFwc2hvdCQyXHJcbn0gPSBSZWNvaWxfU25hcHNob3QkMTtcclxuXHJcbmNvbnN0IHtcclxuICB1c2VSZWNvaWxTdGF0ZTogdXNlUmVjb2lsU3RhdGUkMSxcclxuICB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxyXG4gIHVzZVJlY29pbFN0YXRlTG9hZGFibGU6IHVzZVJlY29pbFN0YXRlTG9hZGFibGUkMSxcclxuICB1c2VSZWNvaWxWYWx1ZTogdXNlUmVjb2lsVmFsdWUkMSxcclxuICB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxyXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGU6IHVzZVJlY29pbFZhbHVlTG9hZGFibGUkMSxcclxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSxcclxuICB1c2VSZXNldFJlY29pbFN0YXRlOiB1c2VSZXNldFJlY29pbFN0YXRlJDEsXHJcbiAgdXNlU2V0UmVjb2lsU3RhdGU6IHVzZVNldFJlY29pbFN0YXRlJDFcclxufSA9IFJlY29pbF9Ib29rcztcclxuXHJcbmNvbnN0IHtcclxuICB1c2VHb3RvUmVjb2lsU25hcHNob3Q6IHVzZUdvdG9SZWNvaWxTbmFwc2hvdCQxLFxyXG4gIHVzZVJlY29pbFNuYXBzaG90OiB1c2VSZWNvaWxTbmFwc2hvdCQxLFxyXG4gIHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXI6IHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXIkMVxyXG59ID0gUmVjb2lsX1NuYXBzaG90SG9va3M7XHJcblxyXG5cclxuXHJcblxyXG5cclxuY29uc3Qge1xyXG4gIHVzZVJlY29pbENhbGxiYWNrOiB1c2VSZWNvaWxDYWxsYmFjayQxXHJcbn0gPSBSZWNvaWxfdXNlUmVjb2lsQ2FsbGJhY2s7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IHtcclxuICBub1dhaXQ6IG5vV2FpdCQxLFxyXG4gIHdhaXRGb3JBbGw6IHdhaXRGb3JBbGwkMSxcclxuICB3YWl0Rm9yQWxsU2V0dGxlZDogd2FpdEZvckFsbFNldHRsZWQkMSxcclxuICB3YWl0Rm9yQW55OiB3YWl0Rm9yQW55JDEsXHJcbiAgd2FpdEZvck5vbmU6IHdhaXRGb3JOb25lJDFcclxufSA9IFJlY29pbF9XYWl0Rm9yO1xyXG5cclxudmFyIFJlY29pbF9pbmRleCA9IHtcclxuICAvLyBUeXBlc1xyXG4gIERlZmF1bHRWYWx1ZTogRGVmYXVsdFZhbHVlJDMsXHJcbiAgaXNSZWNvaWxWYWx1ZTogaXNSZWNvaWxWYWx1ZSQ1LFxyXG4gIFJlY29pbExvYWRhYmxlLFxyXG4gIC8vIFJlY29pbCBSb290XHJcbiAgUmVjb2lsUm9vdDogUmVjb2lsUm9vdCQyLFxyXG4gIHVzZVJlY29pbFN0b3JlSUQ6IHVzZVJlY29pbFN0b3JlSUQkMSxcclxuICB1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzX1VOU1RBQkxFOiBSZWNvaWxfdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cyxcclxuICAvLyBBdG9tcy9TZWxlY3RvcnNcclxuICBhdG9tOiBSZWNvaWxfYXRvbSxcclxuICBzZWxlY3RvcjogUmVjb2lsX3NlbGVjdG9yLFxyXG4gIC8vIENvbnZlbmllbmNlIEF0b21zL1NlbGVjdG9yc1xyXG4gIGF0b21GYW1pbHk6IFJlY29pbF9hdG9tRmFtaWx5LFxyXG4gIHNlbGVjdG9yRmFtaWx5OiBSZWNvaWxfc2VsZWN0b3JGYW1pbHksXHJcbiAgY29uc3RTZWxlY3RvcjogUmVjb2lsX2NvbnN0U2VsZWN0b3IsXHJcbiAgZXJyb3JTZWxlY3RvcjogUmVjb2lsX2Vycm9yU2VsZWN0b3IsXHJcbiAgcmVhZE9ubHlTZWxlY3RvcjogUmVjb2lsX3JlYWRPbmx5U2VsZWN0b3IsXHJcbiAgLy8gQ29uY3VycmVuY3kgSGVscGVycyBmb3IgQXRvbXMvU2VsZWN0b3JzXHJcbiAgbm9XYWl0OiBub1dhaXQkMSxcclxuICB3YWl0Rm9yTm9uZTogd2FpdEZvck5vbmUkMSxcclxuICB3YWl0Rm9yQW55OiB3YWl0Rm9yQW55JDEsXHJcbiAgd2FpdEZvckFsbDogd2FpdEZvckFsbCQxLFxyXG4gIHdhaXRGb3JBbGxTZXR0bGVkOiB3YWl0Rm9yQWxsU2V0dGxlZCQxLFxyXG4gIC8vIEhvb2tzIGZvciBBdG9tcy9TZWxlY3RvcnNcclxuICB1c2VSZWNvaWxWYWx1ZTogdXNlUmVjb2lsVmFsdWUkMSxcclxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlJDEsXHJcbiAgdXNlUmVjb2lsU3RhdGU6IHVzZVJlY29pbFN0YXRlJDEsXHJcbiAgdXNlUmVjb2lsU3RhdGVMb2FkYWJsZTogdXNlUmVjb2lsU3RhdGVMb2FkYWJsZSQxLFxyXG4gIHVzZVNldFJlY29pbFN0YXRlOiB1c2VTZXRSZWNvaWxTdGF0ZSQxLFxyXG4gIHVzZVJlc2V0UmVjb2lsU3RhdGU6IHVzZVJlc2V0UmVjb2lsU3RhdGUkMSxcclxuICB1c2VHZXRSZWNvaWxWYWx1ZUluZm9fVU5TVEFCTEU6IFJlY29pbF91c2VHZXRSZWNvaWxWYWx1ZUluZm8sXHJcbiAgdXNlUmVjb2lsUmVmcmVzaGVyX1VOU1RBQkxFOiBSZWNvaWxfdXNlUmVjb2lsUmVmcmVzaGVyLFxyXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxyXG4gIHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTogdXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEsXHJcbiAgdXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFOiB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSxcclxuICAvLyBIb29rcyBmb3IgY29tcGxleCBvcGVyYXRpb25zXHJcbiAgdXNlUmVjb2lsQ2FsbGJhY2s6IHVzZVJlY29pbENhbGxiYWNrJDEsXHJcbiAgdXNlUmVjb2lsVHJhbnNhY3Rpb25fVU5TVEFCTEU6IFJlY29pbF91c2VSZWNvaWxUcmFuc2FjdGlvbixcclxuICAvLyBTbmFwc2hvdHNcclxuICB1c2VHb3RvUmVjb2lsU25hcHNob3Q6IHVzZUdvdG9SZWNvaWxTbmFwc2hvdCQxLFxyXG4gIHVzZVJlY29pbFNuYXBzaG90OiB1c2VSZWNvaWxTbmFwc2hvdCQxLFxyXG4gIHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXJfVU5TVEFCTEU6IHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXIkMSxcclxuICBzbmFwc2hvdF9VTlNUQUJMRTogZnJlc2hTbmFwc2hvdCQyLFxyXG4gIC8vIE1lbW9yeSBNYW5hZ2VtZW50XHJcbiAgdXNlUmV0YWluOiBSZWNvaWxfdXNlUmV0YWluLFxyXG4gIHJldGVudGlvblpvbmU6IHJldGVudGlvblpvbmUkMVxyXG59O1xyXG52YXIgUmVjb2lsX2luZGV4XzEgPSBSZWNvaWxfaW5kZXguRGVmYXVsdFZhbHVlO1xyXG52YXIgUmVjb2lsX2luZGV4XzIgPSBSZWNvaWxfaW5kZXguaXNSZWNvaWxWYWx1ZTtcclxudmFyIFJlY29pbF9pbmRleF8zID0gUmVjb2lsX2luZGV4LlJlY29pbExvYWRhYmxlO1xyXG52YXIgUmVjb2lsX2luZGV4XzQgPSBSZWNvaWxfaW5kZXguUmVjb2lsUm9vdDtcclxudmFyIFJlY29pbF9pbmRleF81ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFN0b3JlSUQ7XHJcbnZhciBSZWNvaWxfaW5kZXhfNiA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzX1VOU1RBQkxFO1xyXG52YXIgUmVjb2lsX2luZGV4XzcgPSBSZWNvaWxfaW5kZXguYXRvbTtcclxudmFyIFJlY29pbF9pbmRleF84ID0gUmVjb2lsX2luZGV4LnNlbGVjdG9yO1xyXG52YXIgUmVjb2lsX2luZGV4XzkgPSBSZWNvaWxfaW5kZXguYXRvbUZhbWlseTtcclxudmFyIFJlY29pbF9pbmRleF8xMCA9IFJlY29pbF9pbmRleC5zZWxlY3RvckZhbWlseTtcclxudmFyIFJlY29pbF9pbmRleF8xMSA9IFJlY29pbF9pbmRleC5jb25zdFNlbGVjdG9yO1xyXG52YXIgUmVjb2lsX2luZGV4XzEyID0gUmVjb2lsX2luZGV4LmVycm9yU2VsZWN0b3I7XHJcbnZhciBSZWNvaWxfaW5kZXhfMTMgPSBSZWNvaWxfaW5kZXgucmVhZE9ubHlTZWxlY3RvcjtcclxudmFyIFJlY29pbF9pbmRleF8xNCA9IFJlY29pbF9pbmRleC5ub1dhaXQ7XHJcbnZhciBSZWNvaWxfaW5kZXhfMTUgPSBSZWNvaWxfaW5kZXgud2FpdEZvck5vbmU7XHJcbnZhciBSZWNvaWxfaW5kZXhfMTYgPSBSZWNvaWxfaW5kZXgud2FpdEZvckFueTtcclxudmFyIFJlY29pbF9pbmRleF8xNyA9IFJlY29pbF9pbmRleC53YWl0Rm9yQWxsO1xyXG52YXIgUmVjb2lsX2luZGV4XzE4ID0gUmVjb2lsX2luZGV4LndhaXRGb3JBbGxTZXR0bGVkO1xyXG52YXIgUmVjb2lsX2luZGV4XzE5ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFZhbHVlO1xyXG52YXIgUmVjb2lsX2luZGV4XzIwID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFZhbHVlTG9hZGFibGU7XHJcbnZhciBSZWNvaWxfaW5kZXhfMjEgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU3RhdGU7XHJcbnZhciBSZWNvaWxfaW5kZXhfMjIgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU3RhdGVMb2FkYWJsZTtcclxudmFyIFJlY29pbF9pbmRleF8yMyA9IFJlY29pbF9pbmRleC51c2VTZXRSZWNvaWxTdGF0ZTtcclxudmFyIFJlY29pbF9pbmRleF8yNCA9IFJlY29pbF9pbmRleC51c2VSZXNldFJlY29pbFN0YXRlO1xyXG52YXIgUmVjb2lsX2luZGV4XzI1ID0gUmVjb2lsX2luZGV4LnVzZUdldFJlY29pbFZhbHVlSW5mb19VTlNUQUJMRTtcclxudmFyIFJlY29pbF9pbmRleF8yNiA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxSZWZyZXNoZXJfVU5TVEFCTEU7XHJcbnZhciBSZWNvaWxfaW5kZXhfMjcgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU7XHJcbnZhciBSZWNvaWxfaW5kZXhfMjggPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFO1xyXG52YXIgUmVjb2lsX2luZGV4XzI5ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTtcclxudmFyIFJlY29pbF9pbmRleF8zMCA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxDYWxsYmFjaztcclxudmFyIFJlY29pbF9pbmRleF8zMSA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxUcmFuc2FjdGlvbl9VTlNUQUJMRTtcclxudmFyIFJlY29pbF9pbmRleF8zMiA9IFJlY29pbF9pbmRleC51c2VHb3RvUmVjb2lsU25hcHNob3Q7XHJcbnZhciBSZWNvaWxfaW5kZXhfMzMgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU25hcHNob3Q7XHJcbnZhciBSZWNvaWxfaW5kZXhfMzQgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlcl9VTlNUQUJMRTtcclxudmFyIFJlY29pbF9pbmRleF8zNSA9IFJlY29pbF9pbmRleC5zbmFwc2hvdF9VTlNUQUJMRTtcclxudmFyIFJlY29pbF9pbmRleF8zNiA9IFJlY29pbF9pbmRleC51c2VSZXRhaW47XHJcbnZhciBSZWNvaWxfaW5kZXhfMzcgPSBSZWNvaWxfaW5kZXgucmV0ZW50aW9uWm9uZTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJlY29pbF9pbmRleDtcclxuZXhwb3J0IHsgUmVjb2lsX2luZGV4XzEgYXMgRGVmYXVsdFZhbHVlLCBSZWNvaWxfaW5kZXhfMyBhcyBSZWNvaWxMb2FkYWJsZSwgUmVjb2lsX2luZGV4XzQgYXMgUmVjb2lsUm9vdCwgUmVjb2lsX2luZGV4XzcgYXMgYXRvbSwgUmVjb2lsX2luZGV4XzkgYXMgYXRvbUZhbWlseSwgUmVjb2lsX2luZGV4XzExIGFzIGNvbnN0U2VsZWN0b3IsIFJlY29pbF9pbmRleF8xMiBhcyBlcnJvclNlbGVjdG9yLCBSZWNvaWxfaW5kZXhfMiBhcyBpc1JlY29pbFZhbHVlLCBSZWNvaWxfaW5kZXhfMTQgYXMgbm9XYWl0LCBSZWNvaWxfaW5kZXhfMTMgYXMgcmVhZE9ubHlTZWxlY3RvciwgUmVjb2lsX2luZGV4XzM3IGFzIHJldGVudGlvblpvbmUsIFJlY29pbF9pbmRleF84IGFzIHNlbGVjdG9yLCBSZWNvaWxfaW5kZXhfMTAgYXMgc2VsZWN0b3JGYW1pbHksIFJlY29pbF9pbmRleF8zNSBhcyBzbmFwc2hvdF9VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzI1IGFzIHVzZUdldFJlY29pbFZhbHVlSW5mb19VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzMyIGFzIHVzZUdvdG9SZWNvaWxTbmFwc2hvdCwgUmVjb2lsX2luZGV4XzYgYXMgdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290c19VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzMwIGFzIHVzZVJlY29pbENhbGxiYWNrLCBSZWNvaWxfaW5kZXhfMjYgYXMgdXNlUmVjb2lsUmVmcmVzaGVyX1VOU1RBQkxFLCBSZWNvaWxfaW5kZXhfMzMgYXMgdXNlUmVjb2lsU25hcHNob3QsIFJlY29pbF9pbmRleF8yMSBhcyB1c2VSZWNvaWxTdGF0ZSwgUmVjb2lsX2luZGV4XzIyIGFzIHVzZVJlY29pbFN0YXRlTG9hZGFibGUsIFJlY29pbF9pbmRleF8yOSBhcyB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUsIFJlY29pbF9pbmRleF81IGFzIHVzZVJlY29pbFN0b3JlSUQsIFJlY29pbF9pbmRleF8zNCBhcyB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyX1VOU1RBQkxFLCBSZWNvaWxfaW5kZXhfMzEgYXMgdXNlUmVjb2lsVHJhbnNhY3Rpb25fVU5TVEFCTEUsIFJlY29pbF9pbmRleF8xOSBhcyB1c2VSZWNvaWxWYWx1ZSwgUmVjb2lsX2luZGV4XzIwIGFzIHVzZVJlY29pbFZhbHVlTG9hZGFibGUsIFJlY29pbF9pbmRleF8yNyBhcyB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzI4IGFzIHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzI0IGFzIHVzZVJlc2V0UmVjb2lsU3RhdGUsIFJlY29pbF9pbmRleF8zNiBhcyB1c2VSZXRhaW4sIFJlY29pbF9pbmRleF8yMyBhcyB1c2VTZXRSZWNvaWxTdGF0ZSwgUmVjb2lsX2luZGV4XzE3IGFzIHdhaXRGb3JBbGwsIFJlY29pbF9pbmRleF8xOCBhcyB3YWl0Rm9yQWxsU2V0dGxlZCwgUmVjb2lsX2luZGV4XzE2IGFzIHdhaXRGb3JBbnksIFJlY29pbF9pbmRleF8xNSBhcyB3YWl0Rm9yTm9uZSB9O1xyXG4iXSwibmFtZXMiOlsicmVhY3QiLCJyZWFjdERvbSIsImVyciIsIm1lc3NhZ2UiLCJlcnJvciIsIkVycm9yIiwic3RhY2siLCJ1bmRlZmluZWQiLCJfIiwiZXJyXzEiLCJSZWNvaWxfZXJyIiwiaXNQcm9taXNlIiwicCIsInRoZW4iLCJSZWNvaWxfaXNQcm9taXNlIiwibnVsbHRocm93cyIsIngiLCJSZWNvaWxfbnVsbHRocm93cyIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJCYXNlTG9hZGFibGUiLCJnZXRWYWx1ZSIsInRvUHJvbWlzZSIsInZhbHVlTWF5YmUiLCJ2YWx1ZU9yVGhyb3ciLCJzdGF0ZSIsInByb21pc2VNYXliZSIsInByb21pc2VPclRocm93IiwiZXJyb3JNYXliZSIsImVycm9yT3JUaHJvdyIsImlzIiwib3RoZXIiLCJjb250ZW50cyIsIm1hcCIsIl9tYXAiLCJWYWx1ZUxvYWRhYmxlIiwiY29uc3RydWN0b3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm5leHQiLCJsb2FkYWJsZVdpdGhQcm9taXNlIiwiaXNMb2FkYWJsZSIsImxvYWRhYmxlV2l0aFZhbHVlIiwiZSIsImxvYWRhYmxlV2l0aEVycm9yIiwiRXJyb3JMb2FkYWJsZSIsInJlamVjdCIsIkxvYWRpbmdMb2FkYWJsZSIsInByb21pc2UiLCJuZXh0TG9hZGFibGUiLCJjYXRjaCIsImZyZWV6ZSIsImxvYWRhYmxlTG9hZGluZyIsImxvYWRhYmxlQWxsQXJyYXkiLCJpbnB1dHMiLCJldmVyeSIsImkiLCJzb21lIiwiZmluZCIsImFsbCIsImxvYWRhYmxlQWxsIiwidW53cmFwZWRJbnB1dHMiLCJBcnJheSIsImlzQXJyYXkiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwibm9ybWFsaXplZElucHV0cyIsIm91dHB1dCIsIm91dHB1dHMiLCJyZWR1Y2UiLCJvdXQiLCJpZHgiLCJMb2FkYWJsZVN0YXRpY0ludGVyZmFjZSIsIm9mIiwibG9hZGluZyIsIlJlY29pbF9Mb2FkYWJsZSIsIlJlY29pbExvYWRhYmxlIiwiUmVjb2lsX0xvYWRhYmxlXzEiLCJSZWNvaWxfTG9hZGFibGVfMiIsIlJlY29pbF9Mb2FkYWJsZV8zIiwiUmVjb2lsX0xvYWRhYmxlXzQiLCJSZWNvaWxfTG9hZGFibGVfNSIsIlJlY29pbF9Mb2FkYWJsZV82IiwiUmVjb2lsX0xvYWRhYmxlXzciLCJSZWNvaWxfTG9hZGFibGUkMSIsIl9fcHJvdG9fXyIsImdrcyIsIk1hcCIsInNldCIsIlJlY29pbF9na3hfT1NTIiwiZ2siLCJfZ2tzJGdldCIsImdldCIsInNldFBhc3MiLCJzZXRGYWlsIiwiY2xlYXIiLCJSZWNvaWxfZ2t4IiwiX2NyZWF0ZU11dGFibGVTb3VyY2UiLCJfdXNlTXV0YWJsZVNvdXJjZSIsIl91c2VTeW5jRXh0ZXJuYWxTdG9yZSIsImNyZWF0ZU11dGFibGVTb3VyY2UiLCJ1bnN0YWJsZV9jcmVhdGVNdXRhYmxlU291cmNlIiwidXNlTXV0YWJsZVNvdXJjZSIsInVuc3RhYmxlX3VzZU11dGFibGVTb3VyY2UiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVuc3RhYmxlX3VzZVN5bmNFeHRlcm5hbFN0b3JlIiwicmVhY3RNb2RlIiwibW9kZSIsImVhcmx5IiwiY29uY3VycmVudCIsIndpbmRvdyIsIiRkaXNhYmxlUmVjb2lsVmFsdWVNdXRhYmxlU291cmNlX1RFTVBfSEFDS19ET19OT1RfVVNFIiwiaXNGYXN0UmVmcmVzaEVuYWJsZWQiLCJSZWNvaWxfUmVhY3RNb2RlIiwiQWJzdHJhY3RSZWNvaWxWYWx1ZSIsIm5ld0tleSIsInRvSlNPTiIsIlJlY29pbFN0YXRlIiwiUmVjb2lsVmFsdWVSZWFkT25seSIsImlzUmVjb2lsVmFsdWUiLCJSZWNvaWxfUmVjb2lsVmFsdWUiLCJSZWNvaWxfUmVjb2lsVmFsdWVfMSIsIlJlY29pbF9SZWNvaWxWYWx1ZV8yIiwiUmVjb2lsX1JlY29pbFZhbHVlXzMiLCJSZWNvaWxfUmVjb2lsVmFsdWVfNCIsIlJlY29pbF9SZWNvaWxWYWx1ZSQxIiwic3ByaW50ZiIsImZvcm1hdCIsImFyZ3MiLCJpbmRleCIsInJlcGxhY2UiLCJTdHJpbmciLCJzcHJpbnRmXzEiLCJleHBlY3RhdGlvblZpb2xhdGlvbiIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImNhbGwiLCJuYW1lIiwiY29uc29sZSIsImV4cGVjdGF0aW9uVmlvbGF0aW9uXzEiLCJSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24iLCJtYXBJdGVyYWJsZSIsIml0ZXJhYmxlIiwiY2FsbGJhY2siLCJSZWNvaWxfbWFwSXRlcmFibGUiLCJyZWNvdmVyYWJsZVZpb2xhdGlvbiIsIl9wcm9qZWN0TmFtZSIsInJlY292ZXJhYmxlVmlvbGF0aW9uXzEiLCJSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24iLCJpc0Zhc3RSZWZyZXNoRW5hYmxlZCQxIiwiRGVmYXVsdFZhbHVlIiwiREVGQVVMVF9WQUxVRSIsIm5vZGVzIiwicmVjb2lsVmFsdWVzIiwicmVjb2lsVmFsdWVzRm9yS2V5cyIsImtleXMiLCJyZWdpc3Rlck5vZGUiLCJub2RlIiwiaGFzIiwid2FybiIsInJlY29pbFZhbHVlIiwiTm9kZU1pc3NpbmdFcnJvciIsImdldE5vZGUiLCJnZXROb2RlTWF5YmUiLCJjb25maWdEZWxldGlvbkhhbmRsZXJzIiwiZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGUiLCJfbm9kZSRzaG91bGREZWxldGVDb24iLCJzaG91bGREZWxldGVDb25maWdPblJlbGVhc2UiLCJfZ2V0Q29uZmlnRGVsZXRpb25IYW4iLCJkZWxldGUiLCJnZXRDb25maWdEZWxldGlvbkhhbmRsZXIiLCJzZXRDb25maWdEZWxldGlvbkhhbmRsZXIiLCJmbiIsIlJlY29pbF9Ob2RlIiwiZW5xdWV1ZUV4ZWN1dGlvbiIsInMiLCJmIiwiUmVjb2lsX1F1ZXVlIiwiY3JlYXRlQ29tbW9uanNNb2R1bGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiaGFtdF8xIiwiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwicHJvdG90eXBlIiwiaGFtdCIsIlNJWkUiLCJCVUNLRVRfU0laRSIsIk1hdGgiLCJwb3ciLCJNQVNLIiwiTUFYX0lOREVYX05PREUiLCJNSU5fQVJSQVlfTk9ERSIsIm5vdGhpbmciLCJjb25zdGFudCIsImhhc2giLCJzdHIiLCJ0eXBlIiwibGVuIiwibGVuZ3RoIiwiYyIsImNoYXJDb2RlQXQiLCJwb3Bjb3VudCIsImhhc2hGcmFnbWVudCIsInNoaWZ0IiwiaCIsInRvQml0bWFwIiwiZnJvbUJpdG1hcCIsImJpdG1hcCIsImJpdCIsImFycmF5VXBkYXRlIiwibXV0YXRlIiwiYXQiLCJ2IiwiYXJyIiwiYXJyYXlTcGxpY2VPdXQiLCJuZXdMZW4iLCJnIiwiYXJyYXlTcGxpY2VJbiIsIl9pIiwiTEVBRiIsIkNPTExJU0lPTiIsIklOREVYIiwiQVJSQVkiLCJlbXB0eSIsIl9faGFtdF9pc0VtcHR5IiwiaXNFbXB0eU5vZGUiLCJMZWFmIiwiZWRpdCIsIl9tb2RpZnkiLCJMZWFmX19tb2RpZnkiLCJDb2xsaXNpb24iLCJjaGlsZHJlbiIsIkNvbGxpc2lvbl9fbW9kaWZ5IiwiSW5kZXhlZE5vZGUiLCJtYXNrIiwiSW5kZXhlZE5vZGVfX21vZGlmeSIsIkFycmF5Tm9kZSIsInNpemUiLCJBcnJheU5vZGVfX21vZGlmeSIsImlzTGVhZiIsImV4cGFuZCIsImZyYWciLCJjaGlsZCIsInN1Yk5vZGVzIiwiY291bnQiLCJwYWNrIiwicmVtb3ZlZCIsImVsZW1lbnRzIiwiZWxlbSIsIm1lcmdlTGVhdmVzIiwiaDEiLCJuMSIsImgyIiwibjIiLCJzdWJIMSIsInN1YkgyIiwidXBkYXRlQ29sbGlzaW9uTGlzdCIsImtleUVxIiwibGlzdCIsImsiLCJfbmV3VmFsdWUiLCJuZXdWYWx1ZSIsImNhbkVkaXROb2RlIiwiX3YiLCJjYW5FZGl0IiwiaW5keCIsImV4aXN0cyIsImN1cnJlbnQiLCJuZXdDaGlsZHJlbiIsIm5ld0NoaWxkIiwiZWRpdGFibGUiLCJjb25maWciLCJyb290IiwiX2VkaXRhYmxlIiwiX2VkaXQiLCJfY29uZmlnIiwiX3Jvb3QiLCJfc2l6ZSIsInNldFRyZWUiLCJuZXdSb290IiwibmV3U2l6ZSIsInRyeUdldEhhc2giLCJhbHQiLCJ0cnlHZXQiLCJnZXRIYXNoIiwiaGFzSGFzaCIsImRlZktleUNvbXBhcmUiLCJ5IiwibWFrZSIsImlzRW1wdHkiLCJtb2RpZnlIYXNoIiwiTmFOIiwibW9kaWZ5Iiwic2V0SGFzaCIsImRlbCIsInJlbW92ZUhhc2giLCJkZWxldGVIYXNoIiwicmVtb3ZlIiwiYmVnaW5NdXRhdGlvbiIsImVuZE11dGF0aW9uIiwidHJhbnNpZW50IiwiYXBwayIsImxhenlWaXNpdENoaWxkcmVuIiwibGF6eVZpc2l0IiwicmVzdCIsIkRPTkUiLCJkb25lIiwiTWFwSXRlcmF0b3IiLCJ2MCIsInZpc2l0IiwiYnVpbGRQYWlycyIsImVudHJpZXMiLCJidWlsZEtleXMiLCJidWlsZFZhbHVlcyIsInZhbHVlcyIsImZvbGQiLCJ6IiwibSIsInRvVmlzaXQiLCJwb3AiLCJwdXNoIiwiZm9yRWFjaCIsIkJ1aWx0SW5NYXAiLCJleGlzdGluZyIsImNsb25lIiwicGVyc2lzdGVudE1hcCIsInRvTWFwIiwiSGFzaEFycmF5TWFwcGVkVHJpZU1hcCIsIl9oYW10IiwiUmVjb2lsX1BlcnNpc3RlbnRNYXAiLCJSZWNvaWxfUGVyc2lzdGVudE1hcF8xIiwiUmVjb2lsX1BlcnNpc3RlbnRNYXAkMSIsImRpZmZlcmVuY2VTZXRzIiwic2V0c1dpdGhWYWx1ZXNUb1JlbW92ZSIsInJldCIsIlNldCIsIkZJUlNUIiwib3RoZXJTZXQiLCJhZGQiLCJSZWNvaWxfZGlmZmVyZW5jZVNldHMiLCJtYXBNYXAiLCJyZXN1bHQiLCJSZWNvaWxfbWFwTWFwIiwibWFrZUdyYXBoIiwibm9kZURlcHMiLCJub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucyIsImNsb25lR3JhcGgiLCJncmFwaCIsIm1lcmdlRGVwc0ludG9HcmFwaCIsIm5ld0RlcHMiLCJvbGRlckdyYXBoIiwib2xkRGVwcyIsImFkZGVkRGVwcyIsImRlcCIsInJlbW92ZWREZXBzIiwic2F2ZURlcHNUb1N0b3JlIiwiZGVwcyIsInN0b3JlIiwidmVyc2lvbiIsIl9zdG9yZVN0YXRlJG5leHRUcmVlIiwiX3N0b3JlU3RhdGUkcHJldmlvdXNUIiwiX3N0b3JlU3RhdGUkcHJldmlvdXNUMiIsIl9zdG9yZVN0YXRlJHByZXZpb3VzVDMiLCJzdG9yZVN0YXRlIiwiZ2V0U3RhdGUiLCJjdXJyZW50VHJlZSIsIm5leHRUcmVlIiwicHJldmlvdXNUcmVlIiwiZ2V0R3JhcGgiLCJjdXJyZW50R3JhcGgiLCJfc3RvcmVTdGF0ZSRuZXh0VHJlZTIiLCJuZXh0VmVyc2lvbiIsIm5leHRHcmFwaCIsIlJlY29pbF9HcmFwaCIsIm5leHRUcmVlU3RhdGVWZXJzaW9uIiwiZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24iLCJuZXh0U3RvcmVJRCIsImdldE5leHRTdG9yZUlEIiwibmV4dENvbXBvbmVudElEIiwiZ2V0TmV4dENvbXBvbmVudElEIiwiUmVjb2lsX0tleXMiLCJwZXJzaXN0ZW50TWFwJDEiLCJnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQxIiwibWFrZUVtcHR5VHJlZVN0YXRlIiwic3RhdGVJRCIsInRyYW5zYWN0aW9uTWV0YWRhdGEiLCJkaXJ0eUF0b21zIiwiYXRvbVZhbHVlcyIsIm5vbnZhbGlkYXRlZEF0b21zIiwibWFrZUVtcHR5U3RvcmVTdGF0ZSIsImNvbW1pdERlcHRoIiwia25vd25BdG9tcyIsImtub3duU2VsZWN0b3JzIiwidHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zIiwibm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucyIsIm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMiLCJxdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRCIsInN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVycyIsImdyYXBoc0J5VmVyc2lvbiIsInJldGVudGlvbiIsInJlZmVyZW5jZUNvdW50cyIsIm5vZGVzUmV0YWluZWRCeVpvbmUiLCJyZXRhaW5hYmxlc1RvQ2hlY2tGb3JSZWxlYXNlIiwibm9kZUNsZWFudXBGdW5jdGlvbnMiLCJSZWNvaWxfU3RhdGUiLCJSZXRlbnRpb25ab25lIiwicmV0ZW50aW9uWm9uZSIsIlJlY29pbF9SZXRlbnRpb25ab25lIiwic2V0QnlBZGRpbmdUb1NldCIsInNldEJ5RGVsZXRpbmdGcm9tU2V0IiwibWFwQnlTZXR0aW5nSW5NYXAiLCJtYXBCeVVwZGF0aW5nSW5NYXAiLCJ1cGRhdGVyIiwibWFwQnlEZWxldGluZ0Zyb21NYXAiLCJtYXBCeURlbGV0aW5nTXVsdGlwbGVGcm9tTWFwIiwia3MiLCJSZWNvaWxfQ29weU9uV3JpdGUiLCJmaWx0ZXJJdGVyYWJsZSIsInByZWRpY2F0ZSIsIlJlY29pbF9maWx0ZXJJdGVyYWJsZSIsImxhenlQcm94eSIsImJhc2UiLCJmYWN0b3JpZXMiLCJwcm94eSIsIlByb3h5IiwidGFyZ2V0IiwicHJvcCIsIm93bktleXMiLCJSZWNvaWxfbGF6eVByb3h5IiwiZ2V0Tm9kZSQxIiwiZ2V0Tm9kZU1heWJlJDEiLCJyZWNvaWxWYWx1ZXNGb3JLZXlzJDEiLCJSZXRlbnRpb25ab25lJDEiLCJzZXRCeUFkZGluZ1RvU2V0JDEiLCJlbXB0eVNldCIsIlJlYWRPbmx5UmVjb2lsVmFsdWVFcnJvciIsImluaXRpYWxpemVSZXRlbnRpb25Gb3JOb2RlIiwibm9kZUtleSIsInJldGFpbmVkQnkiLCJhZGRUb1pvbmUiLCJ6b25lIiwiZGVsZXRlRnJvbVpvbmUiLCJpbml0aWFsaXplTm9kZUlmTmV3VG9TdG9yZSIsInRyZWVTdGF0ZSIsInRyaWdnZXIiLCJyZXRlbnRpb25DbGVhbnVwIiwibm9kZUNsZWFudXAiLCJpbml0IiwiaW5pdGlhbGl6ZU5vZGUiLCJjbGVhblVwTm9kZSIsIl9zdGF0ZSRub2RlQ2xlYW51cEZ1biIsImdldE5vZGVMb2FkYWJsZSIsInBlZWtOb2RlTG9hZGFibGUiLCJwZWVrIiwic2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCIsIl9ub2RlJGludmFsaWRhdGUiLCJpbnZhbGlkYXRlIiwic2V0Tm9kZVZhbHVlIiwicGVla05vZGVJbmZvIiwibm9kZVR5cGUiLCJsb2FkYWJsZSIsImlzQWN0aXZlIiwiaXNTZXQiLCJpc01vZGlmaWVkIiwiX2dyYXBoJG5vZGVEZXBzJGdldCIsInN1YnNjcmliZXJzIiwiX3N0b3JlU3RhdGUkbm9kZVRvQ29tIiwiX3N0b3JlU3RhdGUkbm9kZVRvQ29tMiIsImdldERvd25zdHJlYW1Ob2RlcyIsImNvbXBvbmVudHMiLCJ2aXNpdGVkTm9kZXMiLCJ2aXNpdGluZ05vZGVzIiwiZnJvbSIsIl9ncmFwaCRub2RlVG9Ob2RlU3VicyIsInN1YnNjcmliZWROb2RlcyIsImRvd25zdHJlYW1Ob2RlIiwiUmVjb2lsX0Z1bmN0aW9uYWxDb3JlIiwiX2ludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90Iiwic2V0SW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QiLCJpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCIsIl9pbnZhbGlkYXRlTWVtb2l6ZWRTbiIsIlJlY29pbF9TbmFwc2hvdENhY2hlIiwiZ2V0RG93bnN0cmVhbU5vZGVzJDEiLCJnZXROb2RlTG9hZGFibGUkMSIsInNldE5vZGVWYWx1ZSQxIiwiZ2V0TmV4dENvbXBvbmVudElEJDEiLCJnZXROb2RlJDIiLCJnZXROb2RlTWF5YmUkMiIsIkRlZmF1bHRWYWx1ZSQxIiwicmVhY3RNb2RlJDEiLCJBYnN0cmFjdFJlY29pbFZhbHVlJDEiLCJSZWNvaWxTdGF0ZSQxIiwiUmVjb2lsVmFsdWVSZWFkT25seSQxIiwiaXNSZWNvaWxWYWx1ZSQxIiwiaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMSIsImdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSIsImFwcGx5QXRvbVZhbHVlV3JpdGVzIiwid3JpdGVzIiwidmFsdWVGcm9tVmFsdWVPclVwZGF0ZXIiLCJ2YWx1ZU9yVXBkYXRlciIsIm1zZyIsImFwcGx5QWN0aW9uIiwiYWN0aW9uIiwid3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlIiwidW52YWxpZGF0ZWRWYWx1ZSIsImFwcGx5QWN0aW9uc1RvU3RvcmUiLCJhY3Rpb25zIiwicmVwbGFjZVN0YXRlIiwibmV3U3RhdGUiLCJjb3B5VHJlZVN0YXRlIiwiaW52YWxpZGF0ZURvd25zdHJlYW1zIiwicXVldWVPclBlcmZvcm1TdGF0ZVVwZGF0ZSIsImJhdGNoU3RhY2siLCJhY3Rpb25zQnlTdG9yZSIsImJhdGNoU3RhcnQiLCJwb3BwZWQiLCJkb3duc3RyZWFtcyIsIl9nZXROb2RlTWF5YmUiLCJfZ2V0Tm9kZU1heWJlJGludmFsaWQiLCJzZXRSZWNvaWxWYWx1ZSIsInNldFJlY29pbFZhbHVlTG9hZGFibGUiLCJtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCIsInNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUiLCJzdWJzY3JpYmVUb1JlY29pbFZhbHVlIiwiY29tcG9uZW50RGVidWdOYW1lIiwic3ViSUQiLCJyZWxlYXNlIiwicmVsZWFzZVN0b3JlU3RhdGUiLCJzdWJzIiwicmVmcmVzaFJlY29pbFZhbHVlIiwiX25vZGUkY2xlYXJDYWNoZSIsImNsZWFyQ2FjaGUiLCJSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2UiLCJzb21lU2V0IiwiY29udGV4dCIsImVudHJ5IiwiUmVjb2lsX3NvbWVTZXQiLCJjbGVhblVwTm9kZSQxIiwiZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGUkMSIsImdldE5vZGUkMyIsIlJldGVudGlvblpvbmUkMiIsIlNVU1BFTlNFX1RJTUVPVVRfTVMiLCJlbXB0eVNldCQxIiwicmVsZWFzZVJldGFpbmFibGVzTm93T25DdXJyZW50VHJlZSIsInJldGFpbmFibGVzIiwiciIsIm4iLCJyZWxlYXNhYmxlTm9kZXMiLCJmaW5kUmVsZWFzYWJsZU5vZGVzIiwicmVsZWFzZU5vZGUiLCJzZWFyY2hGcm9tTm9kZXMiLCJub25SZWxlYXNhYmxlTm9kZXMiLCJmaW5kUmVsZWFzYWJsZU5vZGVzSW5uZXIiLCJyZWxlYXNhYmxlTm9kZXNGb3VuZFRoaXNJdGVyYXRpb24iLCJnZXREb3duc3RyZWFtTm9kZXNJblRvcG9sb2dpY2FsT3JkZXIiLCJfc3RvcmVTdGF0ZSRyZXRlbnRpb24iLCJ6b25lc1RoYXRDb3VsZFJldGFpbk5vZGUiLCJub2RlQ2hpbGRyZW4iLCJwYXJlbnRzIiwicGFyZW50IiwiZG9Ob3REZXNjZW5kSW50bzEiLCJkb05vdERlc2NlbmRJbnRvMiIsImFuc3dlciIsInZpc2l0ZWQiLCJ6b25lcyIsIl9zdG9yZVN0YXRlJHJldGVudGlvbjIiLCJfc3RvcmVTdGF0ZSRyZXRlbnRpb24zIiwic2NoZWR1bGVPclBlcmZvcm1Qb3NzaWJsZVJlbGVhc2VPZlJldGFpbmFibGUiLCJyZXRhaW5hYmxlIiwidXBkYXRlUmV0YWluQ291bnQiLCJkZWx0YSIsIl9tYXAkZ2V0IiwibmV3Q291bnQiLCJ1cGRhdGVSZXRhaW5Db3VudFRvWmVybyIsInJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdyIsInJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCIsIlJlY29pbF9SZXRlbnRpb24iLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsIlJlYWN0QmF0Y2hlZFVwZGF0ZXMiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQxIiwiUmVjb2lsX1JlYWN0QmF0Y2hlZFVwZGF0ZXMiLCJiYXRjaFN0YXJ0JDEiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQyIiwiYmF0Y2hlciIsInNldEJhdGNoZXIiLCJuZXdCYXRjaGVyIiwiZ2V0QmF0Y2hlciIsImJhdGNoVXBkYXRlcyIsImJhdGNoRW5kIiwiUmVjb2lsX0JhdGNoaW5nIiwiY29uY2F0SXRlcmFibGVzIiwiaXRlcnMiLCJpdGVyIiwidmFsIiwiUmVjb2lsX2NvbmNhdEl0ZXJhYmxlcyIsImlzU1NSIiwiV2luZG93IiwiaXNXaW5kb3ciLCJpc1JlYWN0TmF0aXZlIiwibmF2aWdhdG9yIiwicHJvZHVjdCIsIlJlY29pbF9FbnZpcm9ubWVudCIsIm1lbW9pemVXaXRoQXJnc0hhc2giLCJoYXNoRnVuY3Rpb24iLCJjYWNoZSIsIm1lbW9pemVkRm4iLCJoYXNPd25Qcm9wZXJ0eSIsIm1lbW9pemVPbmVXaXRoQXJnc0hhc2giLCJsYXN0S2V5IiwibGFzdFJlc3VsdCIsIm1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb24iLCJSZWNvaWxfTWVtb2l6ZSIsImJhdGNoVXBkYXRlcyQxIiwiaW5pdGlhbGl6ZU5vZGUkMSIsInBlZWtOb2RlSW5mbyQxIiwiZ3JhcGgkMSIsImdldE5leHRTdG9yZUlEJDEiLCJERUZBVUxUX1ZBTFVFJDEiLCJyZWNvaWxWYWx1ZXMkMSIsInJlY29pbFZhbHVlc0ZvcktleXMkMiIsIkFic3RyYWN0UmVjb2lsVmFsdWUkMiIsImdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQxIiwic2V0UmVjb2lsVmFsdWUkMSIsInNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMSIsInVwZGF0ZVJldGFpbkNvdW50JDEiLCJzZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQxIiwiZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMiIsIm1ha2VFbXB0eVN0b3JlU3RhdGUkMSIsImlzU1NSJDEiLCJtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uJDEiLCJyZXRhaW5XYXJuaW5nIiwiU25hcHNob3QiLCJwYXJlbnRTdG9yZUlEIiwiY2hlY2tSZWZDb3VudF9JTlRFUk5BTCIsIl9zdG9yZSIsImdldExvYWRhYmxlIiwib3B0IiwiaXNJbml0aWFsaXplZCIsIm1hcHBlciIsIm11dGFibGVTbmFwc2hvdCIsIk11dGFibGVTbmFwc2hvdCIsInJldGFpbiIsImF1dG9SZWxlYXNlX0lOVEVSTkFMIiwic3RvcmVJRCIsInJlcGxhY2VyIiwiZ3JhcGhzIiwibmV3R3JhcGgiLCJzdWJzY3JpYmVUb1RyYW5zYWN0aW9ucyIsImFkZFRyYW5zYWN0aW9uTWV0YWRhdGEiLCJfcmVmQ291bnQiLCJyZWxlYXNlZCIsIl9yZWxlYXNlIiwic2V0VGltZW91dCIsImNsZWFudXAiLCJpc1JldGFpbmVkIiwiZ2V0U3RvcmVfSU5URVJOQUwiLCJnZXRJRCIsImdldFN0b3JlSUQiLCJjbG9uZVN0b3JlU3RhdGUiLCJidW1wVmVyc2lvbiIsImZyZXNoU25hcHNob3QiLCJpbml0aWFsaXplU3RhdGUiLCJzbmFwc2hvdCIsIm1lbW9pemVkQ2xvbmVTbmFwc2hvdCIsImludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDIiLCJfc3RvcmUkZ2V0U3RhdGUkbmV4dFQiLCJfc3RvcmUkZ2V0U3RhdGUkcHJldmkiLCJjbG9uZVNuYXBzaG90IiwiYmF0Y2giLCJyZWNvaWxTdGF0ZSIsIm5ld1ZhbHVlT3JVcGRhdGVyIiwiX2JhdGNoIiwiUmVjb2lsX1NuYXBzaG90IiwiUmVjb2lsX1NuYXBzaG90XzEiLCJSZWNvaWxfU25hcHNob3RfMiIsIlJlY29pbF9TbmFwc2hvdF8zIiwiUmVjb2lsX1NuYXBzaG90XzQiLCJSZWNvaWxfU25hcHNob3QkMSIsInVuaW9uU2V0cyIsInNldHMiLCJSZWNvaWxfdW5pb25TZXRzIiwidXNlUmVmIiwidXNlUmVmSW5pdE9uY2UiLCJpbml0aWFsVmFsdWUiLCJyZWYiLCJSZWNvaWxfdXNlUmVmSW5pdE9uY2UiLCJnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQzIiwibWFrZUVtcHR5U3RvcmVTdGF0ZSQyIiwiY2xlYW5VcE5vZGUkMiIsImdldERvd25zdHJlYW1Ob2RlcyQyIiwiaW5pdGlhbGl6ZU5vZGUkMiIsInNldE5vZGVWYWx1ZSQyIiwic2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCQxIiwiZ3JhcGgkMiIsImNsb25lR3JhcGgkMSIsImdldE5leHRTdG9yZUlEJDIiLCJjcmVhdGVNdXRhYmxlU291cmNlJDEiLCJyZWFjdE1vZGUkMiIsImFwcGx5QXRvbVZhbHVlV3JpdGVzJDEiLCJyZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3ckMSIsImZyZXNoU25hcHNob3QkMSIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYkMSIsInVzZVN0YXRlIiwibm90SW5BQ29udGV4dCIsImRlZmF1bHRTdG9yZSIsInN0YXRlUmVwbGFjZXJJc0JlaW5nRXhlY3V0ZWQiLCJzdGFydE5leHRUcmVlSWZOZWVkZWQiLCJBcHBDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInVzZVN0b3JlUmVmIiwiTXV0YWJsZVNvdXJjZUNvbnRleHQiLCJ1c2VSZWNvaWxNdXRhYmxlU291cmNlIiwibXV0YWJsZVNvdXJjZSIsIm5vdGlmeUNvbXBvbmVudHMiLCJkZXBlbmRlbnROb2RlcyIsImNvbXBzIiwiX3N1YklEIiwiX2RlYnVnTmFtZSIsInNlbmRFbmRPZkJhdGNoTm90aWZpY2F0aW9ucyIsInN1YnNjcmlwdGlvbnMiLCJzdWJzY3JpcHRpb24iLCJjYiIsInNwbGljZSIsImVuZEJhdGNoIiwiQmF0Y2hlciIsInNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZSIsInN0b3JlUmVmIiwic2V0U3RhdGUiLCIkcmVjb2lsRGVidWdTdGF0ZXMiLCJpbml0aWFsU3RvcmVTdGF0ZV9ERVBSRUNBVEVEIiwiaW5pdGlhbCIsImF0b20iLCJ3cml0dGVuTm9kZXMiLCJzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMiLCJpbml0aWFsU3RvcmVTdGF0ZSIsIm5leHRJRCIsIlJlY29pbFJvb3RfSU5URVJOQUwiLCJpbml0aWFsaXplU3RhdGVfREVQUkVDQVRFRCIsInN0b3JlX0lOVEVSTkFMIiwic3RvcmVQcm9wIiwic3RvcmVTdGF0ZVJlZiIsImlkIiwibWV0YWRhdGEiLCJyZXBsYWNlZCIsIm5vdGlmeUJhdGNoZXJPZkNoYW5nZSIsImF0b21LZXkiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJSZWNvaWxSb290IiwicHJvcHMiLCJvdmVycmlkZSIsInByb3BzRXhjZXB0T3ZlcnJpZGUiLCJhbmNlc3RvclN0b3JlUmVmIiwidXNlUmVjb2lsU3RvcmVJRCIsIlJlY29pbF9SZWNvaWxSb290Iiwibm90aWZ5Q29tcG9uZW50c19GT1JfVEVTVElORyIsInNlbmRFbmRPZkJhdGNoTm90aWZpY2F0aW9uc19GT1JfVEVTVElORyIsInNoYWxsb3dBcnJheUVxdWFsIiwiYSIsImIiLCJsIiwiUmVjb2lsX3NoYWxsb3dBcnJheUVxdWFsIiwidXNlRWZmZWN0JDEiLCJ1c2VSZWYkMiIsInVzZVByZXZpb3VzIiwiUmVjb2lsX3VzZVByZXZpb3VzIiwidXNlU3RvcmVSZWYkMSIsIlNVU1BFTlNFX1RJTUVPVVRfTVMkMSIsInVwZGF0ZVJldGFpbkNvdW50JDIiLCJSZXRlbnRpb25ab25lJDMiLCJ1c2VFZmZlY3QkMiIsInVzZVJlZiQzIiwiaXNTU1IkMiIsInVzZVJldGFpbiIsInRvUmV0YWluIiwidXNlUmV0YWluX0FDVFVBTCIsImFycmF5IiwidGltZW91dElEIiwiY2xlYXJUaW1lb3V0IiwicHJldmlvdXNSZXRhaW5hYmxlcyIsIlJlY29pbF91c2VSZXRhaW4iLCJ1c2VDb21wb25lbnROYW1lIiwiUmVjb2lsX3VzZUNvbXBvbmVudE5hbWUiLCJiYXRjaFVwZGF0ZXMkMiIsIkRFRkFVTFRfVkFMVUUkMiIsInJlYWN0TW9kZSQzIiwidXNlTXV0YWJsZVNvdXJjZSQxIiwidXNlU3luY0V4dGVybmFsU3RvcmUkMSIsInVzZVJlY29pbE11dGFibGVTb3VyY2UkMSIsInVzZVN0b3JlUmVmJDIiLCJpc1JlY29pbFZhbHVlJDIiLCJBYnN0cmFjdFJlY29pbFZhbHVlJDMiLCJnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMiIsInNldFJlY29pbFZhbHVlJDIiLCJzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlJDIiLCJzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEiLCJ1c2VDYWxsYmFjayQxIiwidXNlRWZmZWN0JDMiLCJ1c2VNZW1vJDEiLCJ1c2VSZWYkNCIsInVzZVN0YXRlJDEiLCJzZXRCeUFkZGluZ1RvU2V0JDIiLCJoYW5kbGVMb2FkYWJsZSIsInZhbGlkYXRlUmVjb2lsVmFsdWUiLCJob29rTmFtZSIsInVzZVJlY29pbEludGVyZmFjZV9ERVBSRUNBVEVEIiwiY29tcG9uZW50TmFtZSIsImZvcmNlVXBkYXRlIiwicmVjb2lsVmFsdWVzVXNlZCIsInByZXZpb3VzU3Vic2NyaXB0aW9ucyIsInVuc3Vic2NyaWJlRnJvbSIsInN1YiIsInVwZGF0ZVN0YXRlIiwiX3N0YXRlIiwiY3VycmVudFN1YnNjcmlwdGlvbnMiLCJ1c2VTZXRSZWNvaWxTdGF0ZSIsInVzZVJlc2V0UmVjb2lsU3RhdGUiLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlIiwidXNlUmVjb2lsVmFsdWUiLCJ1c2VSZWNvaWxTdGF0ZSIsInVzZVJlY29pbFN0YXRlTG9hZGFibGUiLCJnZXRSZWNvaWxWYWx1ZSIsImdldFJlY29pbFZhbHVlTG9hZGFibGUiLCJnZXRSZWNvaWxTdGF0ZSIsImdldFJlY29pbFN0YXRlTG9hZGFibGUiLCJnZXRTZXRSZWNvaWxTdGF0ZSIsImdldFJlc2V0UmVjb2lsU3RhdGUiLCJyZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HIiwidXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9TWU5DX0VYVEVSTkFMX1NUT1JFIiwiZ2V0U25hcHNob3QiLCJtZW1vaXplUHJldmlvdXNTbmFwc2hvdCIsInByZXZTdGF0ZSIsIl9wcmV2U3RhdGUiLCJfcHJldlN0YXRlMiIsIm5leHRTdGF0ZSIsImdldE1lbW9pemVkU25hcHNob3QiLCJzdWJzY3JpYmUiLCJub3RpZnkiLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX01VVEFCTEVfU09VUkNFIiwiX3N0b3JlU3RhdGUkbmV4dFRyZWUzIiwiZ2V0TG9hZGFibGVXaXRoVGVzdGluZyIsIl9zdG9yZVN0YXRlIiwibmV3TG9hZGFibGUiLCJwcmV2TG9hZGFibGVSZWYiLCJzb3VyY2UiLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVCIsIl9zdG9yZVN0YXRlJG5leHRUcmVlNCIsInVzZVJlY29pbFZhbHVlTG9hZGFibGVfTEVHQUNZIiwiX3N0b3JlU3RhdGUkbmV4dFRyZWU1IiwiX3ByZXZMb2FkYWJsZVJlZiRjdXJyIiwiX3ByZXZMb2FkYWJsZVJlZiRjdXJyMiIsIlRSQU5TSVRJT05fU1VQUE9SVCIsIlNZTkNfRVhURVJOQUxfU1RPUkUiLCJNVVRBQkxFX1NPVVJDRSIsIkxFR0FDWSIsInVzZVNldFVudmFsaWRhdGVkQXRvbVZhbHVlcyIsInVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFIiwidXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFIiwidXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFIiwiUmVjb2lsX0hvb2tzIiwidXNlUmVjb2lsSW50ZXJmYWNlIiwiZmlsdGVyTWFwIiwiUmVjb2lsX2ZpbHRlck1hcCIsImZpbHRlclNldCIsIlJlY29pbF9maWx0ZXJTZXQiLCJtZXJnZU1hcHMiLCJtYXBzIiwibmV4dEtleSIsIlJlY29pbF9tZXJnZU1hcHMiLCJiYXRjaFVwZGF0ZXMkMyIsIkRFRkFVTFRfVkFMVUUkMyIsImdldE5vZGUkNCIsIm5vZGVzJDEiLCJ1c2VTdG9yZVJlZiQzIiwiQWJzdHJhY3RSZWNvaWxWYWx1ZSQ0Iiwic2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQxIiwiU1VTUEVOU0VfVElNRU9VVF9NUyQyIiwiY2xvbmVTbmFwc2hvdCQxIiwidXNlQ2FsbGJhY2skMiIsInVzZUVmZmVjdCQ0IiwidXNlUmVmJDUiLCJ1c2VTdGF0ZSQyIiwiaXNTU1IkMyIsInVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uIiwiZXh0ZXJuYWxseVZpc2libGVBdG9tVmFsdWVzSW5TdGF0ZSIsInBlcnNpc3RlZEF0b21Db250ZW50c1ZhbHVlcyIsInBlcnNpc3RlbmNlIiwicGVyc2lzdGVuY2VfVU5TVEFCTEUiLCJ1c2VUcmFuc2FjdGlvbk9ic2VydmF0aW9uX0RFUFJFQ0FURUQiLCJwcmV2aW91c0F0b21WYWx1ZXMiLCJhdG9tSW5mbyIsIl9ub2RlJHBlcnNpc3RlbmNlX1VOUyIsIl9ub2RlJHBlcnNpc3RlbmNlX1VOUzIiLCJfbm9kZSRwZXJzaXN0ZW5jZV9VTlMzIiwiX25vZGUkcGVyc2lzdGVuY2VfVU5TNCIsImJhY2tCdXR0b24iLCJtb2RpZmllZEF0b21zIiwidXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlciIsInByZXZpb3VzU25hcHNob3QiLCJ1c2VSZWNvaWxTbmFwc2hvdCIsInNldFNuYXBzaG90IiwicmVsZWFzZVJlZiIsIl9yZWxlYXNlUmVmJGN1cnJlbnQiLCJfcmVsZWFzZVJlZiRjdXJyZW50MiIsIl9yZWxlYXNlUmVmJGN1cnJlbnQzIiwiZ290b1NuYXBzaG90IiwicHJldiIsImtleXNUb1VwZGF0ZSIsIl9wcmV2JGF0b21WYWx1ZXMkZ2V0IiwiX25leHQkYXRvbVZhbHVlcyRnZXQiLCJzaG91bGRSZXN0b3JlRnJvbVNuYXBzaG90cyIsInVzZUdvdG9SZWNvaWxTbmFwc2hvdCIsIlJlY29pbF9TbmFwc2hvdEhvb2tzIiwidXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25fREVQUkVDQVRFRCIsInBlZWtOb2RlSW5mbyQyIiwidXNlU3RvcmVSZWYkNCIsInVzZUdldFJlY29pbFZhbHVlSW5mbyIsIlJlY29pbF91c2VHZXRSZWNvaWxWYWx1ZUluZm8iLCJyZWFjdE1vZGUkNCIsIlJlY29pbFJvb3QkMSIsInVzZVN0b3JlUmVmJDUiLCJ1c2VNZW1vJDIiLCJ1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzIiwiUmVjb2lsQnJpZGdlIiwiUmVjb2lsX3VzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHMiLCJsb2FkYWJsZVdpdGhWYWx1ZSQxIiwiaW5pdGlhbGl6ZU5vZGUkMyIsIkRFRkFVTFRfVkFMVUUkNCIsImdldE5vZGUkNSIsImNvcHlUcmVlU3RhdGUkMSIsImdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQzIiwiaW52YWxpZGF0ZURvd25zdHJlYW1zJDEiLCJ3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUkMSIsImlzQXRvbSIsIlRyYW5zYWN0aW9uSW50ZXJmYWNlSW1wbCIsIl9jaGFuZ2VzIiwiX3RyZWVTdGF0ZSIsIm5ld1RyZWVTdGF0ZV9JTlRFUk5BTCIsImF0b21pY1VwZGF0ZXIiLCJjaGFuZ2VzZXQiLCJSZWNvaWxfQXRvbWljVXBkYXRlcyIsIlJlY29pbF9BdG9taWNVcGRhdGVzXzEiLCJSZWNvaWxfQXRvbWljVXBkYXRlcyQxIiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwiaW52YXJpYW50XzEiLCJSZWNvaWxfaW52YXJpYW50IiwiYXRvbWljVXBkYXRlciQxIiwiYmF0Y2hVcGRhdGVzJDQiLCJERUZBVUxUX1ZBTFVFJDUiLCJ1c2VTdG9yZVJlZiQ2IiwicmVmcmVzaFJlY29pbFZhbHVlJDEiLCJzZXRSZWNvaWxWYWx1ZSQzIiwiY2xvbmVTbmFwc2hvdCQyIiwiZ290b1NuYXBzaG90JDEiLCJ1c2VDYWxsYmFjayQzIiwiU2VudGluZWwiLCJTRU5USU5FTCIsInJlY29pbENhbGxiYWNrIiwiZXh0cmFJbnRlcmZhY2UiLCJyZWxlYXNlU25hcHNob3QiLCJlcnJNc2ciLCJjYWxsYmFja0ludGVyZmFjZSIsInJlc2V0IiwicmVmcmVzaCIsInRyYW5zYWN0X1VOU1RBQkxFIiwidHJhbnNhY3Rpb24iLCJmaW5hbGx5IiwiX3JlbGVhc2VTbmFwc2hvdCIsIl9yZWxlYXNlU25hcHNob3QyIiwidXNlUmVjb2lsQ2FsbGJhY2siLCJSZWNvaWxfdXNlUmVjb2lsQ2FsbGJhY2siLCJ1c2VTdG9yZVJlZiQ3IiwicmVmcmVzaFJlY29pbFZhbHVlJDIiLCJ1c2VDYWxsYmFjayQ0IiwidXNlUmVjb2lsUmVmcmVzaGVyIiwiUmVjb2lsX3VzZVJlY29pbFJlZnJlc2hlciIsImF0b21pY1VwZGF0ZXIkMiIsInVzZVN0b3JlUmVmJDgiLCJ1c2VNZW1vJDMiLCJ1c2VSZWNvaWxUcmFuc2FjdGlvbiIsImF0b21pY1VwZGF0ZSIsInRyYW5zYWN0aW9uSW50ZXJmYWNlIiwiUmVjb2lsX3VzZVJlY29pbFRyYW5zYWN0aW9uIiwiV3JhcHBlZFZhbHVlIiwiUmVjb2lsX1dyYXBwZXIiLCJSZWNvaWxfV3JhcHBlcl8xIiwiUmVjb2lsX1dyYXBwZXIkMSIsImlzRmFzdFJlZnJlc2hFbmFibGVkJDIiLCJDaGFuZ2VkUGF0aEVycm9yIiwiVHJlZUNhY2hlIiwib3B0aW9ucyIsIl9vcHRpb25zJG9uSGl0IiwiX29wdGlvbnMkb25TZXQiLCJfb3B0aW9ucyRtYXBOb2RlVmFsdWUiLCJfbmFtZSIsIl9udW1MZWFmcyIsIl9vbkhpdCIsIm9uSGl0IiwiX29uU2V0Iiwib25TZXQiLCJfbWFwTm9kZVZhbHVlIiwibWFwTm9kZVZhbHVlIiwiZ2V0Tm9kZVZhbHVlIiwiaGFuZGxlcnMiLCJfdGhpcyRnZXRMZWFmTm9kZSIsImdldExlYWZOb2RlIiwib25Ob2RlVmlzaXQiLCJub2RlVmFsdWUiLCJicmFuY2hlcyIsInJvdXRlIiwiYWRkTGVhZiIsIl9ub2RlMiIsIl9ub2RlMyIsIl90aGlzJF9yb290MiIsIl9oYW5kbGVycyRvbk5vZGVWaXNpdDIiLCJicmFuY2hLZXkiLCJfbm9kZSIsIl9oYW5kbGVycyRvbk5vZGVWaXNpdCIsIl90aGlzJF9yb290IiwiaW52YWxpZENhY2hlRXJyb3IiLCJvbGRMZWFmIiwibGVhZk5vZGUiLCJsZWFmIiwiX25vZGU0IiwiQ0hBTkdFRF9QQVRIX0VSUk9SX01FU1NBR0UiLCJSZWNvaWxfVHJlZUNhY2hlIiwiUmVjb2lsX1RyZWVDYWNoZV8xIiwiUmVjb2lsX1RyZWVDYWNoZSQxIiwiTFJVQ2FjaGUiLCJfb3B0aW9ucyRtYXBLZXkiLCJfbWF4U2l6ZSIsIm1heFNpemUiLCJfaGVhZCIsIl90YWlsIiwiX2tleU1hcHBlciIsIm1hcEtleSIsImhlYWQiLCJ0YWlsIiwibWFwcGVkS2V5IiwiZXhpc3RpbmdOb2RlIiwicmlnaHQiLCJsZWZ0IiwiX21heWJlRGVsZXRlTFJVIiwiZGVsZXRlTHJ1IiwiUmVjb2lsX0xSVUNhY2hlIiwiUmVjb2lsX0xSVUNhY2hlXzEiLCJSZWNvaWxfTFJVQ2FjaGUkMSIsIkxSVUNhY2hlJDEiLCJUcmVlQ2FjaGUkMSIsInRyZWVDYWNoZUxSVSIsImxydUNhY2hlIiwibHJ1Tm9kZSIsIlJlY29pbF90cmVlQ2FjaGVMUlUiLCJUSU1FX1dBUk5JTkdfVEhSRVNIT0xEX01TIiwic3RyaW5naWZ5IiwiaW5jbHVkZXMiLCJKU09OIiwiYWxsb3dGdW5jdGlvbnMiLCJfSlNPTiRzdHJpbmdpZnkiLCJ0b1N0cmluZyIsInNvcnQiLCJsb2NhbGVDb21wYXJlIiwiZmlsdGVyIiwiam9pbiIsInN0YWJsZVN0cmluZ2lmeSIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZW5kVGltZSIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJSZWNvaWxfc3RhYmxlU3RyaW5naWZ5IiwiVHJlZUNhY2hlJDIiLCJkZWZhdWx0UG9saWN5IiwiZXF1YWxpdHkiLCJldmljdGlvbiIsIkluZmluaXR5IiwidHJlZUNhY2hlRnJvbVBvbGljeSIsInZhbHVlTWFwcGVyIiwiZ2V0VmFsdWVNYXBwZXIiLCJnZXRUcmVlQ2FjaGUiLCJSZWNvaWxfdHJlZUNhY2hlRnJvbVBvbGljeSIsImlzTm9kZSIsIm9iamVjdCIsIl9vd25lckRvY3VtZW50IiwiX2RvYyRkZWZhdWx0VmlldyIsImRvYyIsIm93bmVyRG9jdW1lbnQiLCJkb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiTm9kZSIsIm5vZGVOYW1lIiwiUmVjb2lsX2lzTm9kZSIsImlzUmVhY3ROYXRpdmUkMSIsImlzV2luZG93JDEiLCJzaG91bGROb3RCZUZyb3plbiIsIiQkdHlwZW9mIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJkZWVwRnJlZXplVmFsdWUiLCJpc0Zyb3plbiIsInNlYWwiLCJSZWNvaWxfZGVlcEZyZWV6ZVZhbHVlIiwic3RhcnRQZXJmQmxvY2siLCJfaWQiLCJSZWNvaWxfUGVyZm9ybWFuY2VUaW1pbmdzIiwiaXNMb2FkYWJsZSQxIiwibG9hZGFibGVXaXRoRXJyb3IkMSIsImxvYWRhYmxlV2l0aFByb21pc2UkMSIsImxvYWRhYmxlV2l0aFZhbHVlJDIiLCJXcmFwcGVkVmFsdWUkMSIsImdldE5vZGVMb2FkYWJsZSQyIiwicGVla05vZGVMb2FkYWJsZSQxIiwic2V0Tm9kZVZhbHVlJDMiLCJzYXZlRGVwc1RvU3RvcmUkMSIsIkRFRkFVTFRfVkFMVUUkNiIsImdldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQxIiwiZ2V0Tm9kZSQ2IiwicmVnaXN0ZXJOb2RlJDEiLCJpc1JlY29pbFZhbHVlJDMiLCJtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQxIiwicmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0JDEiLCJyZWNvaWxDYWxsYmFjayQxIiwic3RhcnRQZXJmQmxvY2skMSIsIkNhbmNlbGVkIiwiQ0FOQ0VMRUQiLCJkZXBlbmRlbmN5U3RhY2siLCJ3YWl0aW5nU3RvcmVzIiwiZ2V0TmV3RXhlY3V0aW9uSUQiLCJleGVjdXRpb25JRCIsInNlbGVjdG9yIiwiY2FjaGVQb2xpY3lfVU5TVEFCTEUiLCJjYWNoZVBvbGljeSIsImRpc2NvdmVyZWREZXBlbmRlbmN5Tm9kZUtleXMiLCJyZXRhaW5lZEJ5X1VOU1RBQkxFIiwiZXhlY3V0aW9uSW5mb01hcCIsImxpdmVTdG9yZXNDb3VudCIsInNlbGVjdG9ySXNMaXZlIiwic2VsZWN0b3JJbml0Iiwic2VsZWN0b3JTaG91bGREZWxldGVDb25maWdPblJlbGVhc2UiLCJyZXNvbHZlQXN5bmMiLCJkZXBWYWx1ZXMiLCJzZXRDYWNoZSIsIm5vdGlmeVN0b3Jlc09mUmVzb2x2ZWRBc3luYyIsImlzTGF0ZXN0RXhlY3V0aW9uIiwiY2xlYXJFeGVjdXRpb25JbmZvIiwibm90aWZ5V2FpdGluZ1N0b3JlcyIsIm5vdGlmeVN0b3Jlc09mTmV3QXN5bmNEZXAiLCJleGVjdXRpb25JbmZvIiwiZ2V0RXhlY3V0aW9uSW5mbyIsInN0YXRlVmVyc2lvbnMiLCJjbGVhcldhaXRsaXN0Iiwic3RvcmVzIiwid2FpdGluZ1N0b3JlIiwibWFya1N0b3JlV2FpdGluZ0ZvclJlc29sdmVkQXN5bmMiLCJ3cmFwUmVzdWx0UHJvbWlzZSIsImxvYWRpbmdEZXBzU3RhdGUiLCJlcnJvck9yUHJvbWlzZSIsIndyYXBQZW5kaW5nRGVwZW5kZW5jeVByb21pc2UiLCJleGlzdGluZ0RlcHMiLCJyZXNvbHZlZERlcCIsImxvYWRpbmdEZXBLZXkiLCJsb2FkaW5nRGVwUHJvbWlzZSIsImNhY2hlZExvYWRhYmxlIiwiZ2V0TG9hZGFibGVGcm9tQ2FjaGVBbmRVcGRhdGVEZXBzIiwiZ2V0SW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8iLCJsb2FkaW5nTG9hZGFibGUiLCJldmFsdWF0ZVNlbGVjdG9yR2V0dGVyIiwidXBkYXRlRGVwcyIsIl9zdG9yZSRnZXRTdGF0ZSIsIl9zdG9yZSRnZXRTdGF0ZSRjdXJyZSIsIl9zdG9yZSRnZXRTdGF0ZTIiLCJfc3RvcmUkZ2V0U3RhdGUyJG5leHQiLCJfc3RvcmUkZ2V0U3RhdGUzIiwiX3N0b3JlJGdldFN0YXRlMyRuZXh0IiwiZW5kUGVyZkJsb2NrIiwiZHVyaW5nU3luY2hyb25vdXNFeGVjdXRpb24iLCJkdXJpbmdBc3luY2hyb25vdXNFeGVjdXRpb24iLCJmaW5pc2hFdmFsdWF0aW9uIiwicmVzdWx0SXNFcnJvciIsImRlcEtleSIsImRlcExvYWRhYmxlIiwiZ2V0Q2FsbGJhY2siLCJlcnJvck9yRGVwUHJvbWlzZSIsInVwZGF0ZUV4ZWN1dGlvbkluZm9EZXBWYWx1ZXMiLCJkZXBzQWZ0ZXJDYWNoZUxvb2t1cCIsIl9nZXRFeGVjdXRpb25JbmZvIiwiZ2V0U2VsZWN0b3JMb2FkYWJsZUFuZFVwZGF0ZURlcHMiLCJjYWNoZWRWYWwiLCJpblByb2dyZXNzRXhlY3V0aW9uSW5mbyIsIl9pblByb2dyZXNzRXhlY3V0aW9uSSIsIm5ld0V4ZWN1dGlvbklEIiwibmV3RGVwVmFsdWVzIiwic2V0RXhlY3V0aW9uSW5mbyIsInBlbmRpbmdFeGVjdXRpb25zIiwiZXhlY0luZm8iLCJhbnlEZXBDaGFuZ2VkIiwiZXhlY0RlcFZhbHVlcyIsImV4ZWNMb2FkYWJsZSIsImRlcFZhbHVlc0Rpc2NvdmVyZWRTb0ZhckR1cmluZ0FzeW5jV29yayIsIl9nZXRFeGVjdXRpb25JbmZvMiIsImRlcFZhbHVlc1RvRGVwUm91dGUiLCJ2YWxMb2FkYWJsZSIsIkJvb2xlYW4iLCJkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSIsImRldGVjdENpcmN1bGFyRGVwZW5kZW5jaWVzIiwic2xpY2UiLCJpbmRleE9mIiwic2VsZWN0b3JQZWVrIiwiX3BlZWtOb2RlTG9hZGFibGUiLCJzZWxlY3RvckdldCIsImludmFsaWRhdGVTZWxlY3RvciIsImNsZWFyU2VsZWN0b3JDYWNoZSIsInNlbGVjdG9yU2V0Iiwic3luY1NlbGVjdG9yU2V0RmluaXNoZWQiLCJzZXRSZWNvaWxTdGF0ZSIsInNldFZhbHVlIiwidXBzdHJlYW1Xcml0ZXMiLCJyZXNldFJlY29pbFN0YXRlIiwiUmVjb2lsX3NlbGVjdG9yIiwiaXNMb2FkYWJsZSQyIiwibG9hZGFibGVXaXRoRXJyb3IkMiIsImxvYWRhYmxlV2l0aFByb21pc2UkMiIsImxvYWRhYmxlV2l0aFZhbHVlJDMiLCJXcmFwcGVkVmFsdWUkMiIsInBlZWtOb2RlSW5mbyQzIiwiREVGQVVMVF9WQUxVRSQ3IiwiRGVmYXVsdFZhbHVlJDIiLCJnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMiIsInJlZ2lzdGVyTm9kZSQyIiwic2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDEiLCJpc1JlY29pbFZhbHVlJDQiLCJnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkNCIsIm1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDIiLCJzZXRSZWNvaWxWYWx1ZSQ0Iiwic2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQyIiwicmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0JDIiLCJ1bndyYXAiLCJiYXNlQXRvbSIsInVud3JhcFByb21pc2UiLCJkZWZhdWx0TG9hZGFibGUiLCJkZWZhdWx0IiwibWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZSIsImNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWUiLCJjbGVhbnVwRWZmZWN0c0J5U3RvcmUiLCJ2YWx1ZU9yUHJvbWlzZSIsIndyYXBQZW5kaW5nUHJvbWlzZSIsIndyYXBwZWRQcm9taXNlIiwiX3N0YXRlJGF0b21WYWx1ZXMkZ2V0IiwiX3N0b3JlJGdldFN0YXRlJG5leHRUMiIsIl9zdGF0ZSRhdG9tVmFsdWVzJGdldDIiLCJpbml0QXRvbSIsImluaXRTdGF0ZSIsIl9vcHRpb25zJGVmZmVjdHMiLCJjbGVhbnVwQXRvbSIsIl9jbGVhbnVwRWZmZWN0c0J5U3RvciIsIm5vdGlmeURlZmF1bHRTdWJzY3JpYmVycyIsIl9zdG9yZSRnZXRTdGF0ZSRuZXh0VDMiLCJlZmZlY3RzIiwiZWZmZWN0c19VTlNUQUJMRSIsImluaXRWYWx1ZSIsImlzRHVyaW5nSW5pdCIsImlzSW5pdEVycm9yIiwicGVuZGluZ1NldFNlbGYiLCJyZXRWYWx1ZSIsInBlZWtBdG9tIiwiZ2V0UHJvbWlzZSIsImdldEluZm9fVU5TVEFCTEUiLCJfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ0IiwiaW5mbyIsInNldFNlbGYiLCJlZmZlY3QiLCJjdXJyZW50TG9hZGFibGUiLCJjdXJyZW50VmFsdWUiLCJyZXNldFNlbGYiLCJoYW5kbGVyIiwiX2NsZWFudXBFZmZlY3RzQnlTdG9yMiIsImN1cnJlbnRTdG9yZSIsIl9jdXJyZW50VHJlZSRhdG9tVmFsdSIsIl9wcmV2aW91c1RyZWUkYXRvbVZhbCIsIl9wZW5kaW5nU2V0U2VsZiIsIl9wZW5kaW5nU2V0U2VsZjIiLCJfcGVuZGluZ1NldFNlbGYzIiwib2xkTG9hZGFibGUiLCJvbGRWYWx1ZSIsInBhcmVudFN0b3JlSURfVU5TVEFCTEUiLCJfY2xlYW51cEVmZmVjdHNCeVN0b3IzIiwiX3N0b3JlJGdldFN0YXRlJG5leHRUNSIsImluaXRMb2FkYWJsZSIsIl9yZWYiLCJfc3RhdGUkYXRvbVZhbHVlcyRnZXQzIiwiZ2V0QXRvbSIsIm5vbnZhbGlkYXRlZFZhbHVlIiwidmFsaWRhdG9yUmVzdWx0IiwidmFsaWRhdG9yIiwidmFsaWRhdGVkVmFsdWVMb2FkYWJsZSIsImludmFsaWRhdGVBdG9tIiwic2V0QXRvbSIsInNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZUF0b20iLCJyZXN0T3B0aW9ucyIsIm9wdGlvbnNEZWZhdWx0IiwiYXRvbVdpdGhGYWxsYmFjayIsInN0b3JlZFZhbHVlIiwic2VsIiwiYmFzZVZhbHVlIiwiUmVjb2lsX2F0b20iLCJNYXBDYWNoZSIsIlJlY29pbF9NYXBDYWNoZSIsIlJlY29pbF9NYXBDYWNoZV8xIiwiUmVjb2lsX01hcENhY2hlJDEiLCJMUlVDYWNoZSQyIiwiTWFwQ2FjaGUkMSIsImRlZmF1bHRQb2xpY3kkMSIsImNhY2hlRnJvbVBvbGljeSIsImdldFZhbHVlTWFwcGVyJDEiLCJnZXRDYWNoZSIsIlJlY29pbF9jYWNoZUZyb21Qb2xpY3kiLCJzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMiIsImF0b21GYW1pbHkiLCJfb3B0aW9ucyRjYWNoZVBvbGljeUYiLCJfb3B0aW9ucyRjYWNoZVBvbGljeUYyIiwiYXRvbUNhY2hlIiwiY2FjaGVQb2xpY3lGb3JQYXJhbXNfVU5TVEFCTEUiLCJwYXJhbXMiLCJfc3RhYmxlU3RyaW5naWZ5IiwiY2FjaGVkQXRvbSIsImF0b21PcHRpb25zIiwibmV3QXRvbSIsIlJlY29pbF9hdG9tRmFtaWx5Iiwic2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDMiLCJuZXh0SW5kZXgiLCJzZWxlY3RvckZhbWlseSIsInNlbGVjdG9yQ2FjaGUiLCJjYWNoZWRTZWxlY3RvciIsIm15S2V5IiwibXlHZXQiLCJjYWxsYmFja3MiLCJteUNhY2hlUG9saWN5IiwibmV3U2VsZWN0b3IiLCJteVNldCIsIlJlY29pbF9zZWxlY3RvckZhbWlseSIsImNvbnN0YW50U2VsZWN0b3IiLCJjb25zdFNlbGVjdG9yIiwiUmVjb2lsX2NvbnN0U2VsZWN0b3IiLCJ0aHJvd2luZ1NlbGVjdG9yIiwiZXJyb3JTZWxlY3RvciIsIlJlY29pbF9lcnJvclNlbGVjdG9yIiwicmVhZE9ubHlTZWxlY3RvciIsIlJlY29pbF9yZWFkT25seVNlbGVjdG9yIiwibG9hZGFibGVXaXRoRXJyb3IkMyIsImxvYWRhYmxlV2l0aFByb21pc2UkMyIsImxvYWRhYmxlV2l0aFZhbHVlJDQiLCJjb25jdXJyZW50UmVxdWVzdHMiLCJyZXN1bHRzIiwiZmlsbCIsImV4Y2VwdGlvbnMiLCJpc0Vycm9yIiwiZXhwIiwidW53cmFwRGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jaWVzIiwid3JhcFJlc3VsdHMiLCJ3cmFwTG9hZGFibGVzIiwiZXhjZXB0aW9uIiwiY29tYmluZUFzeW5jUmVzdWx0c1dpdGhTeW5jUmVzdWx0cyIsInN5bmNSZXN1bHRzIiwiYXN5bmNSZXN1bHRzIiwid2FpdEZvck5vbmUiLCJ3YWl0Rm9yQW55Iiwid2FpdEZvckFsbCIsImV4Y2VwdGlvblJlc3VsdHMiLCJ3YWl0Rm9yQWxsU2V0dGxlZCIsIm5vV2FpdCIsImRlcGVuZGVuY3kiLCJSZWNvaWxfV2FpdEZvciIsIkRlZmF1bHRWYWx1ZSQzIiwiUmVjb2lsUm9vdCQyIiwidXNlUmVjb2lsU3RvcmVJRCQxIiwiaXNSZWNvaWxWYWx1ZSQ1IiwicmV0ZW50aW9uWm9uZSQxIiwiZnJlc2hTbmFwc2hvdCQyIiwidXNlUmVjb2lsU3RhdGUkMSIsInVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxIiwidXNlUmVjb2lsU3RhdGVMb2FkYWJsZSQxIiwidXNlUmVjb2lsVmFsdWUkMSIsInVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxIiwidXNlUmVjb2lsVmFsdWVMb2FkYWJsZSQxIiwidXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSIsInVzZVJlc2V0UmVjb2lsU3RhdGUkMSIsInVzZVNldFJlY29pbFN0YXRlJDEiLCJ1c2VHb3RvUmVjb2lsU25hcHNob3QkMSIsInVzZVJlY29pbFNuYXBzaG90JDEiLCJ1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyJDEiLCJ1c2VSZWNvaWxDYWxsYmFjayQxIiwibm9XYWl0JDEiLCJ3YWl0Rm9yQWxsJDEiLCJ3YWl0Rm9yQWxsU2V0dGxlZCQxIiwid2FpdEZvckFueSQxIiwid2FpdEZvck5vbmUkMSIsIlJlY29pbF9pbmRleCIsInVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHNfVU5TVEFCTEUiLCJ1c2VHZXRSZWNvaWxWYWx1ZUluZm9fVU5TVEFCTEUiLCJ1c2VSZWNvaWxSZWZyZXNoZXJfVU5TVEFCTEUiLCJ1c2VSZWNvaWxUcmFuc2FjdGlvbl9VTlNUQUJMRSIsInVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXJfVU5TVEFCTEUiLCJzbmFwc2hvdF9VTlNUQUJMRSIsIlJlY29pbF9pbmRleF8xIiwiUmVjb2lsX2luZGV4XzIiLCJSZWNvaWxfaW5kZXhfMyIsIlJlY29pbF9pbmRleF80IiwiUmVjb2lsX2luZGV4XzUiLCJSZWNvaWxfaW5kZXhfNiIsIlJlY29pbF9pbmRleF83IiwiUmVjb2lsX2luZGV4XzgiLCJSZWNvaWxfaW5kZXhfOSIsIlJlY29pbF9pbmRleF8xMCIsIlJlY29pbF9pbmRleF8xMSIsIlJlY29pbF9pbmRleF8xMiIsIlJlY29pbF9pbmRleF8xMyIsIlJlY29pbF9pbmRleF8xNCIsIlJlY29pbF9pbmRleF8xNSIsIlJlY29pbF9pbmRleF8xNiIsIlJlY29pbF9pbmRleF8xNyIsIlJlY29pbF9pbmRleF8xOCIsIlJlY29pbF9pbmRleF8xOSIsIlJlY29pbF9pbmRleF8yMCIsIlJlY29pbF9pbmRleF8yMSIsIlJlY29pbF9pbmRleF8yMiIsIlJlY29pbF9pbmRleF8yMyIsIlJlY29pbF9pbmRleF8yNCIsIlJlY29pbF9pbmRleF8yNSIsIlJlY29pbF9pbmRleF8yNiIsIlJlY29pbF9pbmRleF8yNyIsIlJlY29pbF9pbmRleF8yOCIsIlJlY29pbF9pbmRleF8yOSIsIlJlY29pbF9pbmRleF8zMCIsIlJlY29pbF9pbmRleF8zMSIsIlJlY29pbF9pbmRleF8zMiIsIlJlY29pbF9pbmRleF8zMyIsIlJlY29pbF9pbmRleF8zNCIsIlJlY29pbF9pbmRleF8zNSIsIlJlY29pbF9pbmRleF8zNiIsIlJlY29pbF9pbmRleF8zNyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/recoil/es/index.js\n"));

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\r\n * Copyright (c) 2014-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\nvar runtime = function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function (obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n    return generator;\n  }\n\n  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n\n  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n\n\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"); // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n    // do is to check its .name property.\n    (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n  };\n\n  exports.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  }; // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n\n\n  exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n\n        if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function (value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function (err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function (unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function (error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = // If enqueue has been called before, then we want to wait until\n      // all previous Promises have been resolved before calling invoke,\n      // so that results are always delivered in the correct order. If\n      // enqueue has not been called before, then it is important to\n      // call invoke immediately, without waiting on a callback to fire,\n      // so that the async generator function has the opportunity to do\n      // any necessary setup in a predictable way. This predictability\n      // is why the Promise constructor synchronously invokes its\n      // executor callback, and why async functions synchronously\n      // execute code before the first await. Since we implement simple\n      // async functions in terms of async generators, it is especially\n      // important to get this right, even though it requires care.\n      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n      // invocations of the iterator.\n      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    } // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n\n\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n\n  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n    : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        } // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n        var record = tryCatch(innerFn, self, context);\n\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted; // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  } // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (!info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n      context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    } // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n\n\n    context.delegate = null;\n    return ContinueSentinel;\n  } // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n\n\n  defineIteratorMethods(Gp);\n  define(Gp, toStringTagSymbol, \"Generator\"); // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n  define(Gp, iteratorSymbol, function () {\n    return this;\n  });\n  define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    keys.reverse(); // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      } // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n\n\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n          return next;\n        };\n\n        return next.next = next;\n      }\n    } // Return an iterator with no values.\n\n\n    return {\n      next: doneResult\n    };\n  }\n\n  exports.values = values;\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n    reset: function (skipTempReset) {\n      this.prev = 0;\n      this.next = 0; // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n      this.method = \"next\";\n      this.arg = undefined;\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n    stop: function () {\n      this.done = true;\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n    dispatchException: function (exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n    abrupt: function (type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n    complete: function (record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" || record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n    finish: function (finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n    \"catch\": function (tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      } // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function (iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  }; // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n\n  return exports;\n}( // If this script is executing as a CommonJS module, use module.exports\n// as the regeneratorRuntime namespace. Otherwise create a new empty\n// object. Either way, the resulting object will be used to initialize\n// the regeneratorRuntime variable at the top of this file.\n true ? module.exports : 0);\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLElBQUlBLE9BQU8sR0FBSSxVQUFVQyxPQUFWLEVBQW1CO0VBQ2hDOztFQUVBLElBQUlDLEVBQUUsR0FBR0MsTUFBTSxDQUFDQyxTQUFoQjtFQUNBLElBQUlDLE1BQU0sR0FBR0gsRUFBRSxDQUFDSSxjQUFoQjtFQUNBLElBQUlDLFNBQUosQ0FMZ0MsQ0FLakI7O0VBQ2YsSUFBSUMsT0FBTyxHQUFHLE9BQU9DLE1BQVAsS0FBa0IsVUFBbEIsR0FBK0JBLE1BQS9CLEdBQXdDLEVBQXREO0VBQ0EsSUFBSUMsY0FBYyxHQUFHRixPQUFPLENBQUNHLFFBQVIsSUFBb0IsWUFBekM7RUFDQSxJQUFJQyxtQkFBbUIsR0FBR0osT0FBTyxDQUFDSyxhQUFSLElBQXlCLGlCQUFuRDtFQUNBLElBQUlDLGlCQUFpQixHQUFHTixPQUFPLENBQUNPLFdBQVIsSUFBdUIsZUFBL0M7O0VBRUEsU0FBU0MsTUFBVCxDQUFnQkMsR0FBaEIsRUFBcUJDLEdBQXJCLEVBQTBCQyxLQUExQixFQUFpQztJQUMvQmhCLE1BQU0sQ0FBQ2lCLGNBQVAsQ0FBc0JILEdBQXRCLEVBQTJCQyxHQUEzQixFQUFnQztNQUM5QkMsS0FBSyxFQUFFQSxLQUR1QjtNQUU5QkUsVUFBVSxFQUFFLElBRmtCO01BRzlCQyxZQUFZLEVBQUUsSUFIZ0I7TUFJOUJDLFFBQVEsRUFBRTtJQUpvQixDQUFoQztJQU1BLE9BQU9OLEdBQUcsQ0FBQ0MsR0FBRCxDQUFWO0VBQ0Q7O0VBQ0QsSUFBSTtJQUNGO0lBQ0FGLE1BQU0sQ0FBQyxFQUFELEVBQUssRUFBTCxDQUFOO0VBQ0QsQ0FIRCxDQUdFLE9BQU9RLEdBQVAsRUFBWTtJQUNaUixNQUFNLEdBQUcsVUFBU0MsR0FBVCxFQUFjQyxHQUFkLEVBQW1CQyxLQUFuQixFQUEwQjtNQUNqQyxPQUFPRixHQUFH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SSxPQUFwQyxHQUE4QyxDQXJ0QmpDLENBQWY7O0FBd3RCQSxJQUFJO0VBQ0Y4SSxrQkFBa0IsR0FBRy9JLE9BQXJCO0FBQ0QsQ0FGRCxDQUVFLE9BQU9nSixvQkFBUCxFQUE2QjtFQUM3QjtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksT0FBT0MsVUFBUCxLQUFzQixRQUExQixFQUFvQztJQUNsQ0EsVUFBVSxDQUFDRixrQkFBWCxHQUFnQy9JLE9BQWhDO0VBQ0QsQ0FGRCxNQUVPO0lBQ0xrSixRQUFRLENBQUMsR0FBRCxFQUFNLHdCQUFOLENBQVIsQ0FBd0NsSixPQUF4QztFQUNEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcz9jNTZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICovXHJcblxyXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xyXG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcclxuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cclxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xyXG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XHJcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcclxuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xyXG5cclxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBvYmpba2V5XTtcclxuICB9XHJcbiAgdHJ5IHtcclxuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXHJcbiAgICBkZWZpbmUoe30sIFwiXCIpO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcclxuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxyXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XHJcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xyXG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XHJcblxyXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxyXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxyXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xyXG5cclxuICAgIHJldHVybiBnZW5lcmF0b3I7XHJcbiAgfVxyXG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XHJcblxyXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxyXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxyXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxyXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcclxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXHJcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xyXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXHJcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXHJcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxyXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cclxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcclxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcclxuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xyXG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XHJcblxyXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcclxuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXHJcbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcclxuXHJcbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXHJcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXHJcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcclxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxyXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XHJcbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxyXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cclxuXHJcbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxyXG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXHJcbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XHJcbiAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSk7XHJcblxyXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcclxuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XHJcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXHJcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxyXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XHJcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxyXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxyXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcclxuICB9XHJcblxyXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XHJcbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XHJcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XHJcbiAgZGVmaW5lKEdwLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcclxuICBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pO1xyXG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKFxyXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXHJcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcclxuICAgIFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxyXG4gICk7XHJcblxyXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXHJcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cclxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XHJcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcclxuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xyXG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xyXG4gICAgcmV0dXJuIGN0b3JcclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxyXG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cclxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXHJcbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXHJcbiAgICAgIDogZmFsc2U7XHJcbiAgfTtcclxuXHJcbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XHJcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XHJcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcclxuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XHJcbiAgICB9XHJcbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XHJcbiAgICByZXR1cm4gZ2VuRnVuO1xyXG4gIH07XHJcblxyXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xyXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XHJcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xyXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXHJcbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xyXG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XHJcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcclxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcclxuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcclxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xyXG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XHJcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xyXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXHJcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cclxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcclxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcclxuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cclxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XHJcblxyXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xyXG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cclxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXHJcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXHJcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxyXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXHJcbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXHJcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cclxuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XHJcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcclxuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxyXG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXHJcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcclxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXHJcbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXHJcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcclxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXHJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXHJcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xyXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXHJcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cclxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XHJcbiAgfVxyXG5cclxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xyXG4gIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSk7XHJcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcclxuXHJcbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxyXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxyXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxyXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcclxuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XHJcblxyXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcclxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXHJcbiAgICAgIFByb21pc2VJbXBsXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcclxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cclxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcclxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcclxuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcclxuICAgICAgICAgIHRocm93IGFyZztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxyXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xyXG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcclxuXHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcclxuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcclxuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcclxuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xyXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XHJcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcclxuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcclxuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcclxuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XHJcblxyXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcclxuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cclxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cclxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXHJcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcclxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xyXG5cclxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxyXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xyXG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcclxuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcclxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXHJcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcclxuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcclxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXHJcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXHJcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXHJcbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xyXG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcclxuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcclxuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cclxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XHJcblxyXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xyXG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXHJcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XHJcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXHJcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXHJcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XHJcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XHJcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXHJcbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxyXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xyXG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcclxuXHJcbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xyXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcclxuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xyXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcclxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xyXG5cclxuICAgIGlmICghIGluZm8pIHtcclxuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XHJcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xyXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcclxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGluZm8uZG9uZSkge1xyXG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxyXG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxyXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcclxuXHJcbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cclxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcclxuXHJcbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxyXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXHJcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXHJcbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xyXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxyXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXHJcbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xyXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XHJcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXHJcbiAgICAgIHJldHVybiBpbmZvO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXHJcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxyXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XHJcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcclxuICB9XHJcblxyXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXHJcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxyXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XHJcblxyXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xyXG5cclxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxyXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXHJcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cclxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cclxuICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0pO1xyXG5cclxuICBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcclxuICB9KTtcclxuXHJcbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcclxuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XHJcblxyXG4gICAgaWYgKDEgaW4gbG9jcykge1xyXG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKDIgaW4gbG9jcykge1xyXG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcclxuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcclxuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xyXG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xyXG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XHJcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xyXG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXHJcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXHJcbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXHJcbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xyXG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xyXG4gICAgdGhpcy5yZXNldCh0cnVlKTtcclxuICB9XHJcblxyXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xyXG4gICAgdmFyIGtleXMgPSBbXTtcclxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcclxuICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICB9XHJcbiAgICBrZXlzLnJldmVyc2UoKTtcclxuXHJcbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxyXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cclxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcclxuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xyXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcclxuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcclxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcclxuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXHJcbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XHJcbiAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcclxuICAgIGlmIChpdGVyYWJsZSkge1xyXG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XHJcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xyXG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICByZXR1cm4gaXRlcmFibGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xyXG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XHJcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xyXG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXHJcbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XHJcbiAgfVxyXG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xyXG5cclxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xyXG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xyXG4gIH1cclxuXHJcbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XHJcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xyXG4gICAgICB0aGlzLnByZXYgPSAwO1xyXG4gICAgICB0aGlzLm5leHQgPSAwO1xyXG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xyXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxyXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcclxuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XHJcblxyXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xyXG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xyXG5cclxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XHJcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxyXG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxyXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXHJcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xyXG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcclxuXHJcbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XHJcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XHJcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xyXG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XHJcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcclxuICAgICAgICB0aHJvdyBleGNlcHRpb247XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcclxuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XHJcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XHJcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcclxuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XHJcblxyXG4gICAgICAgIGlmIChjYXVnaHQpIHtcclxuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXHJcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxyXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcclxuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcclxuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcclxuXHJcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcclxuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXHJcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cclxuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXHJcbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcclxuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xyXG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xyXG5cclxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcclxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxyXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXHJcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcclxuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxyXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxyXG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcclxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXHJcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcclxuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXHJcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxyXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xyXG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XHJcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XHJcblxyXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XHJcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcclxuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcclxuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcclxuICAgIH0sXHJcblxyXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcclxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcclxuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxyXG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xyXG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XHJcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcclxuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XHJcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xyXG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XHJcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcclxuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XHJcbiAgICB9LFxyXG5cclxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xyXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xyXG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XHJcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcclxuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xyXG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XHJcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XHJcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcclxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XHJcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xyXG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB0aHJvd247XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cclxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XHJcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XHJcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXHJcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcclxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XHJcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcclxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXHJcbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcclxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcclxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcclxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxyXG4gIHJldHVybiBleHBvcnRzO1xyXG5cclxufShcclxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xyXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XHJcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxyXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXHJcbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cclxuKSk7XHJcblxyXG50cnkge1xyXG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XHJcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XHJcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcclxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcclxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIGluIG1vZGVybiBlbmdpbmVzXHJcbiAgLy8gd2UgY2FuIGV4cGxpY2l0bHkgYWNjZXNzIGdsb2JhbFRoaXMuIEluIG9sZGVyIGVuZ2luZXMgd2UgY2FuIGVzY2FwZVxyXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxyXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxyXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXHJcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcclxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcclxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cclxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIGdsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcclxuICB9IGVsc2Uge1xyXG4gICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJleHBvcnRzIiwiT3AiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsInVuZGVmaW5lZCIsIiRTeW1ib2wiLCJTeW1ib2wiLCJpdGVyYXRvclN5bWJvbCIsIml0ZXJhdG9yIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsInRvU3RyaW5nVGFnIiwiZGVmaW5lIiwib2JqIiwia2V5IiwidmFsdWUiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImVyciIsIndyYXAiLCJpbm5lckZuIiwib3V0ZXJGbiIsInNlbGYiLCJ0cnlMb2NzTGlzdCIsInByb3RvR2VuZXJhdG9yIiwiR2VuZXJhdG9yIiwiZ2VuZXJhdG9yIiwiY3JlYXRlIiwiY29udGV4dCIsIkNvbnRleHQiLCJfaW52b2tlIiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiZm4iLCJhcmciLCJ0eXBlIiwiY2FsbCIsIkdlblN0YXRlU3VzcGVuZGVkU3RhcnQiLCJHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkIiwiR2VuU3RhdGVFeGVjdXRpbmciLCJHZW5TdGF0ZUNvbXBsZXRlZCIsIkNvbnRpbnVlU2VudGluZWwiLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJnZXRQcm90byIsImdldFByb3RvdHlwZU9mIiwiTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUiLCJ2YWx1ZXMiLCJHcCIsImRpc3BsYXlOYW1lIiwiZGVmaW5lSXRlcmF0b3JNZXRob2RzIiwiZm9yRWFjaCIsIm1ldGhvZCIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5GdW4iLCJjdG9yIiwiY29uc3RydWN0b3IiLCJuYW1lIiwibWFyayIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiYXdyYXAiLCJfX2F3YWl0IiwiQXN5bmNJdGVyYXRvciIsIlByb21pc2VJbXBsIiwiaW52b2tlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlY29yZCIsInJlc3VsdCIsInRoZW4iLCJ1bndyYXBwZWQiLCJlcnJvciIsInByZXZpb3VzUHJvbWlzZSIsImVucXVldWUiLCJjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyIsImFzeW5jIiwiUHJvbWlzZSIsIml0ZXIiLCJuZXh0IiwiZG9uZSIsInN0YXRlIiwiRXJyb3IiLCJkb25lUmVzdWx0IiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZVJlc3VsdCIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsIlR5cGVFcnJvciIsImluZm8iLCJyZXN1bHROYW1lIiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJlbnRyeSIsInRyeUxvYyIsImNhdGNoTG9jIiwiZmluYWxseUxvYyIsImFmdGVyTG9jIiwidHJ5RW50cmllcyIsInB1c2giLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0Iiwia2V5cyIsIm9iamVjdCIsInJldmVyc2UiLCJsZW5ndGgiLCJwb3AiLCJpdGVyYWJsZSIsIml0ZXJhdG9yTWV0aG9kIiwiaXNOYU4iLCJpIiwic2tpcFRlbXBSZXNldCIsInByZXYiLCJjaGFyQXQiLCJzbGljZSIsInN0b3AiLCJyb290RW50cnkiLCJyb290UmVjb3JkIiwicnZhbCIsImV4Y2VwdGlvbiIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsImhhc0NhdGNoIiwiaGFzRmluYWxseSIsImZpbmFsbHlFbnRyeSIsImNvbXBsZXRlIiwiZmluaXNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsIm1vZHVsZSIsInJlZ2VuZXJhdG9yUnVudGltZSIsImFjY2lkZW50YWxTdHJpY3RNb2RlIiwiZ2xvYmFsVGhpcyIsIkZ1bmN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css":
/*!********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css ***!
  \********************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*\\r\\n! tailwindcss v3.0.24 | MIT License | https://tailwindcss.com\\r\\n*//*\\r\\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\\r\\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\\r\\n*/\\r\\n\\r\\n*,\\r\\n::before,\\r\\n::after {\\r\\n  box-sizing: border-box; /* 1 */\\r\\n  border-width: 0; /* 2 */\\r\\n  border-style: solid; /* 2 */\\r\\n  border-color: #e5e7eb; /* 2 */\\r\\n}\\r\\n\\r\\n::before,\\r\\n::after {\\r\\n  --tw-content: '';\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Use a consistent sensible line-height in all browsers.\\r\\n2. Prevent adjustments of font size after orientation changes in iOS.\\r\\n3. Use a more readable tab size.\\r\\n4. Use the user's configured `sans` font-family by default.\\r\\n*/\\r\\n\\r\\nhtml {\\r\\n  line-height: 1.5; /* 1 */\\r\\n  -webkit-text-size-adjust: 100%; /* 2 */\\r\\n  -moz-tab-size: 4; /* 3 */\\r\\n  -o-tab-size: 4;\\r\\n     tab-size: 4; /* 3 */\\r\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\"; /* 4 */\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Remove the margin in all browsers.\\r\\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\\r\\n*/\\r\\n\\r\\nbody {\\r\\n  margin: 0; /* 1 */\\r\\n  line-height: inherit; /* 2 */\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Add the correct height in Firefox.\\r\\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\\r\\n3. Ensure horizontal rules are visible by default.\\r\\n*/\\r\\n\\r\\nhr {\\r\\n  height: 0; /* 1 */\\r\\n  color: inherit; /* 2 */\\r\\n  border-top-width: 1px; /* 3 */\\r\\n}\\r\\n\\r\\n/*\\r\\nAdd the correct text decoration in Chrome, Edge, and Safari.\\r\\n*/\\r\\n\\r\\nabbr:where([title]) {\\r\\n  -webkit-text-decoration: underline dotted;\\r\\n          text-decoration: underline dotted;\\r\\n}\\r\\n\\r\\n/*\\r\\nRemove the default font size and weight for headings.\\r\\n*/\\r\\n\\r\\nh1,\\r\\nh2,\\r\\nh3,\\r\\nh4,\\r\\nh5,\\r\\nh6 {\\r\\n  font-size: inherit;\\r\\n  font-weight: inherit;\\r\\n}\\r\\n\\r\\n/*\\r\\nReset links to optimize for opt-in styling instead of opt-out.\\r\\n*/\\r\\n\\r\\na {\\r\\n  color: inherit;\\r\\n  text-decoration: inherit;\\r\\n}\\r\\n\\r\\n/*\\r\\nAdd the correct font weight in Edge and Safari.\\r\\n*/\\r\\n\\r\\nb,\\r\\nstrong {\\r\\n  font-weight: bolder;\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Use the user's configured `mono` font family by default.\\r\\n2. Correct the odd `em` font sizing in all browsers.\\r\\n*/\\r\\n\\r\\ncode,\\r\\nkbd,\\r\\nsamp,\\r\\npre {\\r\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace; /* 1 */\\r\\n  font-size: 1em; /* 2 */\\r\\n}\\r\\n\\r\\n/*\\r\\nAdd the correct font size in all browsers.\\r\\n*/\\r\\n\\r\\nsmall {\\r\\n  font-size: 80%;\\r\\n}\\r\\n\\r\\n/*\\r\\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\\r\\n*/\\r\\n\\r\\nsub,\\r\\nsup {\\r\\n  font-size: 75%;\\r\\n  line-height: 0;\\r\\n  position: relative;\\r\\n  vertical-align: baseline;\\r\\n}\\r\\n\\r\\nsub {\\r\\n  bottom: -0.25em;\\r\\n}\\r\\n\\r\\nsup {\\r\\n  top: -0.5em;\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\\r\\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\\r\\n3. Remove gaps between table borders by default.\\r\\n*/\\r\\n\\r\\ntable {\\r\\n  text-indent: 0; /* 1 */\\r\\n  border-color: inherit; /* 2 */\\r\\n  border-collapse: collapse; /* 3 */\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Change the font styles in all browsers.\\r\\n2. Remove the margin in Firefox and Safari.\\r\\n3. Remove default padding in all browsers.\\r\\n*/\\r\\n\\r\\nbutton,\\r\\ninput,\\r\\noptgroup,\\r\\nselect,\\r\\ntextarea {\\r\\n  font-family: inherit; /* 1 */\\r\\n  font-size: 100%; /* 1 */\\r\\n  line-height: inherit; /* 1 */\\r\\n  color: inherit; /* 1 */\\r\\n  margin: 0; /* 2 */\\r\\n  padding: 0; /* 3 */\\r\\n}\\r\\n\\r\\n/*\\r\\nRemove the inheritance of text transform in Edge and Firefox.\\r\\n*/\\r\\n\\r\\nbutton,\\r\\nselect {\\r\\n  text-transform: none;\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Correct the inability to style clickable types in iOS and Safari.\\r\\n2. Remove default button styles.\\r\\n*/\\r\\n\\r\\nbutton,\\r\\n[type='button'],\\r\\n[type='reset'],\\r\\n[type='submit'] {\\r\\n  -webkit-appearance: button; /* 1 */\\r\\n  background-color: transparent; /* 2 */\\r\\n  background-image: none; /* 2 */\\r\\n}\\r\\n\\r\\n/*\\r\\nUse the modern Firefox focus style for all focusable elements.\\r\\n*/\\r\\n\\r\\n:-moz-focusring {\\r\\n  outline: auto;\\r\\n}\\r\\n\\r\\n/*\\r\\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\\r\\n*/\\r\\n\\r\\n:-moz-ui-invalid {\\r\\n  box-shadow: none;\\r\\n}\\r\\n\\r\\n/*\\r\\nAdd the correct vertical alignment in Chrome and Firefox.\\r\\n*/\\r\\n\\r\\nprogress {\\r\\n  vertical-align: baseline;\\r\\n}\\r\\n\\r\\n/*\\r\\nCorrect the cursor style of increment and decrement buttons in Safari.\\r\\n*/\\r\\n\\r\\n::-webkit-inner-spin-button,\\r\\n::-webkit-outer-spin-button {\\r\\n  height: auto;\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Correct the odd appearance in Chrome and Safari.\\r\\n2. Correct the outline style in Safari.\\r\\n*/\\r\\n\\r\\n[type='search'] {\\r\\n  -webkit-appearance: textfield; /* 1 */\\r\\n  outline-offset: -2px; /* 2 */\\r\\n}\\r\\n\\r\\n/*\\r\\nRemove the inner padding in Chrome and Safari on macOS.\\r\\n*/\\r\\n\\r\\n::-webkit-search-decoration {\\r\\n  -webkit-appearance: none;\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Correct the inability to style clickable types in iOS and Safari.\\r\\n2. Change font properties to `inherit` in Safari.\\r\\n*/\\r\\n\\r\\n::-webkit-file-upload-button {\\r\\n  -webkit-appearance: button; /* 1 */\\r\\n  font: inherit; /* 2 */\\r\\n}\\r\\n\\r\\n/*\\r\\nAdd the correct display in Chrome and Safari.\\r\\n*/\\r\\n\\r\\nsummary {\\r\\n  display: list-item;\\r\\n}\\r\\n\\r\\n/*\\r\\nRemoves the default spacing and border for appropriate elements.\\r\\n*/\\r\\n\\r\\nblockquote,\\r\\ndl,\\r\\ndd,\\r\\nh1,\\r\\nh2,\\r\\nh3,\\r\\nh4,\\r\\nh5,\\r\\nh6,\\r\\nhr,\\r\\nfigure,\\r\\np,\\r\\npre {\\r\\n  margin: 0;\\r\\n}\\r\\n\\r\\nfieldset {\\r\\n  margin: 0;\\r\\n  padding: 0;\\r\\n}\\r\\n\\r\\nlegend {\\r\\n  padding: 0;\\r\\n}\\r\\n\\r\\nol,\\r\\nul,\\r\\nmenu {\\r\\n  list-style: none;\\r\\n  margin: 0;\\r\\n  padding: 0;\\r\\n}\\r\\n\\r\\n/*\\r\\nPrevent resizing textareas horizontally by default.\\r\\n*/\\r\\n\\r\\ntextarea {\\r\\n  resize: vertical;\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\\r\\n2. Set the default placeholder color to the user's configured gray 400 color.\\r\\n*/\\r\\n\\r\\ninput::-moz-placeholder, textarea::-moz-placeholder {\\r\\n  opacity: 1; /* 1 */\\r\\n  color: #9ca3af; /* 2 */\\r\\n}\\r\\n\\r\\ninput::placeholder,\\r\\ntextarea::placeholder {\\r\\n  opacity: 1; /* 1 */\\r\\n  color: #9ca3af; /* 2 */\\r\\n}\\r\\n\\r\\n/*\\r\\nSet the default cursor for buttons.\\r\\n*/\\r\\n\\r\\nbutton,\\r\\n[role=\\\"button\\\"] {\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n/*\\r\\nMake sure disabled buttons don't get the pointer cursor.\\r\\n*/\\r\\n:disabled {\\r\\n  cursor: default;\\r\\n}\\r\\n\\r\\n/*\\r\\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\\r\\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\\r\\n   This can trigger a poorly considered lint error in some tools but is included by design.\\r\\n*/\\r\\n\\r\\nimg,\\r\\nsvg,\\r\\nvideo,\\r\\ncanvas,\\r\\naudio,\\r\\niframe,\\r\\nembed,\\r\\nobject {\\r\\n  display: block; /* 1 */\\r\\n  vertical-align: middle; /* 2 */\\r\\n}\\r\\n\\r\\n/*\\r\\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\\r\\n*/\\r\\n\\r\\nimg,\\r\\nvideo {\\r\\n  max-width: 100%;\\r\\n  height: auto;\\r\\n}\\r\\n\\r\\n/*\\r\\nEnsure the default browser behavior of the `hidden` attribute.\\r\\n*/\\r\\n\\r\\n[hidden] {\\r\\n  display: none;\\r\\n}\\r\\n\\r\\n*, ::before, ::after {\\r\\n  --tw-translate-x: 0;\\r\\n  --tw-translate-y: 0;\\r\\n  --tw-rotate: 0;\\r\\n  --tw-skew-x: 0;\\r\\n  --tw-skew-y: 0;\\r\\n  --tw-scale-x: 1;\\r\\n  --tw-scale-y: 1;\\r\\n  --tw-pan-x:  ;\\r\\n  --tw-pan-y:  ;\\r\\n  --tw-pinch-zoom:  ;\\r\\n  --tw-scroll-snap-strictness: proximity;\\r\\n  --tw-ordinal:  ;\\r\\n  --tw-slashed-zero:  ;\\r\\n  --tw-numeric-figure:  ;\\r\\n  --tw-numeric-spacing:  ;\\r\\n  --tw-numeric-fraction:  ;\\r\\n  --tw-ring-inset:  ;\\r\\n  --tw-ring-offset-width: 0px;\\r\\n  --tw-ring-offset-color: #fff;\\r\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\r\\n  --tw-ring-offset-shadow: 0 0 #0000;\\r\\n  --tw-ring-shadow: 0 0 #0000;\\r\\n  --tw-shadow: 0 0 #0000;\\r\\n  --tw-shadow-colored: 0 0 #0000;\\r\\n  --tw-blur:  ;\\r\\n  --tw-brightness:  ;\\r\\n  --tw-contrast:  ;\\r\\n  --tw-grayscale:  ;\\r\\n  --tw-hue-rotate:  ;\\r\\n  --tw-invert:  ;\\r\\n  --tw-saturate:  ;\\r\\n  --tw-sepia:  ;\\r\\n  --tw-drop-shadow:  ;\\r\\n  --tw-backdrop-blur:  ;\\r\\n  --tw-backdrop-brightness:  ;\\r\\n  --tw-backdrop-contrast:  ;\\r\\n  --tw-backdrop-grayscale:  ;\\r\\n  --tw-backdrop-hue-rotate:  ;\\r\\n  --tw-backdrop-invert:  ;\\r\\n  --tw-backdrop-opacity:  ;\\r\\n  --tw-backdrop-saturate:  ;\\r\\n  --tw-backdrop-sepia:  ;\\r\\n}\\r\\n.pointer-events-none {\\r\\n  pointer-events: none;\\r\\n}\\r\\n.fixed {\\r\\n  position: fixed;\\r\\n}\\r\\n.absolute {\\r\\n  position: absolute;\\r\\n}\\r\\n.relative {\\r\\n  position: relative;\\r\\n}\\r\\n.-top-3 {\\r\\n  top: -0.75rem;\\r\\n}\\r\\n.-top-5 {\\r\\n  top: -1.25rem;\\r\\n}\\r\\n.-top-16 {\\r\\n  top: -4rem;\\r\\n}\\r\\n.bottom-\\\\[16\\\\.2rem\\\\] {\\r\\n  bottom: 16.2rem;\\r\\n}\\r\\n.right-0 {\\r\\n  right: 0px;\\r\\n}\\r\\n.right-24 {\\r\\n  right: 6rem;\\r\\n}\\r\\n.left-1\\\\/2 {\\r\\n  left: 50%;\\r\\n}\\r\\n.right-1\\\\/2 {\\r\\n  right: 50%;\\r\\n}\\r\\n.bottom-36 {\\r\\n  bottom: 9rem;\\r\\n}\\r\\n.top-\\\\[85\\\\%\\\\] {\\r\\n  top: 85%;\\r\\n}\\r\\n.bottom-\\\\[17\\\\.2rem\\\\] {\\r\\n  bottom: 17.2rem;\\r\\n}\\r\\n.bottom-0 {\\r\\n  bottom: 0px;\\r\\n}\\r\\n.top-0 {\\r\\n  top: 0px;\\r\\n}\\r\\n.right-9 {\\r\\n  right: 2.25rem;\\r\\n}\\r\\n.left-0 {\\r\\n  left: 0px;\\r\\n}\\r\\n.z-10 {\\r\\n  z-index: 10;\\r\\n}\\r\\n.z-20 {\\r\\n  z-index: 20;\\r\\n}\\r\\n.col-span-2 {\\r\\n  grid-column: span 2 / span 2;\\r\\n}\\r\\n.col-span-3 {\\r\\n  grid-column: span 3 / span 3;\\r\\n}\\r\\n.col-span-12 {\\r\\n  grid-column: span 12 / span 12;\\r\\n}\\r\\n.col-span-10 {\\r\\n  grid-column: span 10 / span 10;\\r\\n}\\r\\n.col-span-4 {\\r\\n  grid-column: span 4 / span 4;\\r\\n}\\r\\n.col-span-6 {\\r\\n  grid-column: span 6 / span 6;\\r\\n}\\r\\n.col-span-7 {\\r\\n  grid-column: span 7 / span 7;\\r\\n}\\r\\n.row-span-3 {\\r\\n  grid-row: span 3 / span 3;\\r\\n}\\r\\n.my-2 {\\r\\n  margin-top: 0.5rem;\\r\\n  margin-bottom: 0.5rem;\\r\\n}\\r\\n.mx-auto {\\r\\n  margin-left: auto;\\r\\n  margin-right: auto;\\r\\n}\\r\\n.mx-3 {\\r\\n  margin-left: 0.75rem;\\r\\n  margin-right: 0.75rem;\\r\\n}\\r\\n.mx-5 {\\r\\n  margin-left: 1.25rem;\\r\\n  margin-right: 1.25rem;\\r\\n}\\r\\n.mx-1 {\\r\\n  margin-left: 0.25rem;\\r\\n  margin-right: 0.25rem;\\r\\n}\\r\\n.my-1 {\\r\\n  margin-top: 0.25rem;\\r\\n  margin-bottom: 0.25rem;\\r\\n}\\r\\n.mx-2 {\\r\\n  margin-left: 0.5rem;\\r\\n  margin-right: 0.5rem;\\r\\n}\\r\\n.my-7 {\\r\\n  margin-top: 1.75rem;\\r\\n  margin-bottom: 1.75rem;\\r\\n}\\r\\n.mx-\\\\[0\\\\.35rem\\\\] {\\r\\n  margin-left: 0.35rem;\\r\\n  margin-right: 0.35rem;\\r\\n}\\r\\n.my-3 {\\r\\n  margin-top: 0.75rem;\\r\\n  margin-bottom: 0.75rem;\\r\\n}\\r\\n.mx-10 {\\r\\n  margin-left: 2.5rem;\\r\\n  margin-right: 2.5rem;\\r\\n}\\r\\n.mx-8 {\\r\\n  margin-left: 2rem;\\r\\n  margin-right: 2rem;\\r\\n}\\r\\n.my-12 {\\r\\n  margin-top: 3rem;\\r\\n  margin-bottom: 3rem;\\r\\n}\\r\\n.mt-16 {\\r\\n  margin-top: 4rem;\\r\\n}\\r\\n.mt-12 {\\r\\n  margin-top: 3rem;\\r\\n}\\r\\n.mt-8 {\\r\\n  margin-top: 2rem;\\r\\n}\\r\\n.mt-2 {\\r\\n  margin-top: 0.5rem;\\r\\n}\\r\\n.mr-5 {\\r\\n  margin-right: 1.25rem;\\r\\n}\\r\\n.mt-5 {\\r\\n  margin-top: 1.25rem;\\r\\n}\\r\\n.-mt-14 {\\r\\n  margin-top: -3.5rem;\\r\\n}\\r\\n.-mb-5 {\\r\\n  margin-bottom: -1.25rem;\\r\\n}\\r\\n.mb-5 {\\r\\n  margin-bottom: 1.25rem;\\r\\n}\\r\\n.mt-3 {\\r\\n  margin-top: 0.75rem;\\r\\n}\\r\\n.mt-10 {\\r\\n  margin-top: 2.5rem;\\r\\n}\\r\\n.mt-7 {\\r\\n  margin-top: 1.75rem;\\r\\n}\\r\\n.mb-10 {\\r\\n  margin-bottom: 2.5rem;\\r\\n}\\r\\n.mt-1 {\\r\\n  margin-top: 0.25rem;\\r\\n}\\r\\n.mt-4 {\\r\\n  margin-top: 1rem;\\r\\n}\\r\\n.ml-1 {\\r\\n  margin-left: 0.25rem;\\r\\n}\\r\\n.mb-7 {\\r\\n  margin-bottom: 1.75rem;\\r\\n}\\r\\n.mb-2 {\\r\\n  margin-bottom: 0.5rem;\\r\\n}\\r\\n.mr-16 {\\r\\n  margin-right: 4rem;\\r\\n}\\r\\n.ml-5 {\\r\\n  margin-left: 1.25rem;\\r\\n}\\r\\n.mt-\\\\[15px\\\\] {\\r\\n  margin-top: 15px;\\r\\n}\\r\\n.mt-\\\\[0\\\\.8px\\\\] {\\r\\n  margin-top: 0.8px;\\r\\n}\\r\\n.mt-6 {\\r\\n  margin-top: 1.5rem;\\r\\n}\\r\\n.mb-4 {\\r\\n  margin-bottom: 1rem;\\r\\n}\\r\\n.-mb-1 {\\r\\n  margin-bottom: -0.25rem;\\r\\n}\\r\\n.-ml-\\\\[100\\\\%\\\\] {\\r\\n  margin-left: -100%;\\r\\n}\\r\\n.-ml-\\\\[0\\\\%\\\\] {\\r\\n  margin-left: -0%;\\r\\n}\\r\\n.-ml-\\\\[200\\\\%\\\\] {\\r\\n  margin-left: -200%;\\r\\n}\\r\\n.-ml-\\\\[300\\\\%\\\\] {\\r\\n  margin-left: -300%;\\r\\n}\\r\\n.-ml-\\\\[50vw\\\\] {\\r\\n  margin-left: -50vw;\\r\\n}\\r\\n.-mr-\\\\[50vw\\\\] {\\r\\n  margin-right: -50vw;\\r\\n}\\r\\n.mr-\\\\[0\\\\.35rem\\\\] {\\r\\n  margin-right: 0.35rem;\\r\\n}\\r\\n.ml-3 {\\r\\n  margin-left: 0.75rem;\\r\\n}\\r\\n.mr-3 {\\r\\n  margin-right: 0.75rem;\\r\\n}\\r\\n.mb-1 {\\r\\n  margin-bottom: 0.25rem;\\r\\n}\\r\\n.mb-8 {\\r\\n  margin-bottom: 2rem;\\r\\n}\\r\\n.block {\\r\\n  display: block;\\r\\n}\\r\\n.inline-block {\\r\\n  display: inline-block;\\r\\n}\\r\\n.flex {\\r\\n  display: flex;\\r\\n}\\r\\n.inline-flex {\\r\\n  display: inline-flex;\\r\\n}\\r\\n.table {\\r\\n  display: table;\\r\\n}\\r\\n.grid {\\r\\n  display: grid;\\r\\n}\\r\\n.hidden {\\r\\n  display: none;\\r\\n}\\r\\n.aspect-square {\\r\\n  aspect-ratio: 1 / 1;\\r\\n}\\r\\n.h-5 {\\r\\n  height: 1.25rem;\\r\\n}\\r\\n.h-24 {\\r\\n  height: 6rem;\\r\\n}\\r\\n.h-72 {\\r\\n  height: 18rem;\\r\\n}\\r\\n.h-fit {\\r\\n  height: -webkit-fit-content;\\r\\n  height: -moz-fit-content;\\r\\n  height: fit-content;\\r\\n}\\r\\n.h-\\\\[330px\\\\] {\\r\\n  height: 330px;\\r\\n}\\r\\n.h-12 {\\r\\n  height: 3rem;\\r\\n}\\r\\n.h-max {\\r\\n  height: -webkit-max-content;\\r\\n  height: -moz-max-content;\\r\\n  height: max-content;\\r\\n}\\r\\n.h-\\\\[190\\\\] {\\r\\n  height: 190;\\r\\n}\\r\\n.h-\\\\[467px\\\\] {\\r\\n  height: 467px;\\r\\n}\\r\\n.h-6 {\\r\\n  height: 1.5rem;\\r\\n}\\r\\n.h-full {\\r\\n  height: 100%;\\r\\n}\\r\\n.h-\\\\[30px\\\\] {\\r\\n  height: 30px;\\r\\n}\\r\\n.h-56 {\\r\\n  height: 14rem;\\r\\n}\\r\\n.h-\\\\[45vh\\\\] {\\r\\n  height: 45vh;\\r\\n}\\r\\n.h-\\\\[250px\\\\] {\\r\\n  height: 250px;\\r\\n}\\r\\n.h-4 {\\r\\n  height: 1rem;\\r\\n}\\r\\n.h-\\\\[166px\\\\] {\\r\\n  height: 166px;\\r\\n}\\r\\n.h-\\\\[199\\\\.69px\\\\] {\\r\\n  height: 199.69px;\\r\\n}\\r\\n.h-\\\\[60px\\\\] {\\r\\n  height: 60px;\\r\\n}\\r\\n.h-48 {\\r\\n  height: 12rem;\\r\\n}\\r\\n.max-h-fit {\\r\\n  max-height: -webkit-fit-content;\\r\\n  max-height: -moz-fit-content;\\r\\n  max-height: fit-content;\\r\\n}\\r\\n.max-h-\\\\[250px\\\\] {\\r\\n  max-height: 250px;\\r\\n}\\r\\n.max-h-\\\\[24px\\\\] {\\r\\n  max-height: 24px;\\r\\n}\\r\\n.min-h-screen {\\r\\n  min-height: 100vh;\\r\\n}\\r\\n.min-h-\\\\[100vh\\\\] {\\r\\n  min-height: 100vh;\\r\\n}\\r\\n.min-h-\\\\[330px\\\\] {\\r\\n  min-height: 330px;\\r\\n}\\r\\n.min-h-\\\\[213px\\\\] {\\r\\n  min-height: 213px;\\r\\n}\\r\\n.w-full {\\r\\n  width: 100%;\\r\\n}\\r\\n.w-5 {\\r\\n  width: 1.25rem;\\r\\n}\\r\\n.w-3\\\\/4 {\\r\\n  width: 75%;\\r\\n}\\r\\n.w-24 {\\r\\n  width: 6rem;\\r\\n}\\r\\n.w-8 {\\r\\n  width: 2rem;\\r\\n}\\r\\n.w-\\\\[90vw\\\\] {\\r\\n  width: 90vw;\\r\\n}\\r\\n.w-12 {\\r\\n  width: 3rem;\\r\\n}\\r\\n.w-\\\\[48\\\\%\\\\] {\\r\\n  width: 48%;\\r\\n}\\r\\n.w-fit {\\r\\n  width: -webkit-fit-content;\\r\\n  width: -moz-fit-content;\\r\\n  width: fit-content;\\r\\n}\\r\\n.w-2\\\\/3 {\\r\\n  width: 66.666667%;\\r\\n}\\r\\n.w-\\\\[144px\\\\] {\\r\\n  width: 144px;\\r\\n}\\r\\n.w-80 {\\r\\n  width: 20rem;\\r\\n}\\r\\n.w-\\\\[100vw\\\\] {\\r\\n  width: 100vw;\\r\\n}\\r\\n.w-6 {\\r\\n  width: 1.5rem;\\r\\n}\\r\\n.w-\\\\[30px\\\\] {\\r\\n  width: 30px;\\r\\n}\\r\\n.w-\\\\[300\\\\%\\\\] {\\r\\n  width: 300%;\\r\\n}\\r\\n.w-\\\\[100\\\\%\\\\] {\\r\\n  width: 100%;\\r\\n}\\r\\n.w-4 {\\r\\n  width: 1rem;\\r\\n}\\r\\n.w-\\\\[108px\\\\] {\\r\\n  width: 108px;\\r\\n}\\r\\n.w-\\\\[142px\\\\] {\\r\\n  width: 142px;\\r\\n}\\r\\n.w-\\\\[4\\\\.2rem\\\\] {\\r\\n  width: 4.2rem;\\r\\n}\\r\\n.w-20 {\\r\\n  width: 5rem;\\r\\n}\\r\\n.w-2\\\\/4 {\\r\\n  width: 50%;\\r\\n}\\r\\n.min-w-\\\\[300px\\\\] {\\r\\n  min-width: 300px;\\r\\n}\\r\\n.min-w-\\\\[50px\\\\] {\\r\\n  min-width: 50px;\\r\\n}\\r\\n.min-w-\\\\[78px\\\\] {\\r\\n  min-width: 78px;\\r\\n}\\r\\n.min-w-\\\\[108px\\\\] {\\r\\n  min-width: 108px;\\r\\n}\\r\\n.min-w-\\\\[26px\\\\] {\\r\\n  min-width: 26px;\\r\\n}\\r\\n.max-w-\\\\[1200px\\\\] {\\r\\n  max-width: 1200px;\\r\\n}\\r\\n.max-w-\\\\[1500px\\\\] {\\r\\n  max-width: 1500px;\\r\\n}\\r\\n.max-w-\\\\[1300px\\\\] {\\r\\n  max-width: 1300px;\\r\\n}\\r\\n.max-w-\\\\[1100px\\\\] {\\r\\n  max-width: 1100px;\\r\\n}\\r\\n.max-w-\\\\[581px\\\\] {\\r\\n  max-width: 581px;\\r\\n}\\r\\n.-translate-x-1\\\\/2 {\\r\\n  --tw-translate-x: -50%;\\r\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\r\\n}\\r\\n.cursor-pointer {\\r\\n  cursor: pointer;\\r\\n}\\r\\n.select-none {\\r\\n  -webkit-user-select: none;\\r\\n     -moz-user-select: none;\\r\\n          user-select: none;\\r\\n}\\r\\n.appearance-none {\\r\\n  -webkit-appearance: none;\\r\\n     -moz-appearance: none;\\r\\n          appearance: none;\\r\\n}\\r\\n.grid-cols-2 {\\r\\n  grid-template-columns: repeat(2, minmax(0, 1fr));\\r\\n}\\r\\n.grid-cols-1 {\\r\\n  grid-template-columns: repeat(1, minmax(0, 1fr));\\r\\n}\\r\\n.grid-cols-4 {\\r\\n  grid-template-columns: repeat(4, minmax(0, 1fr));\\r\\n}\\r\\n.grid-cols-12 {\\r\\n  grid-template-columns: repeat(12, minmax(0, 1fr));\\r\\n}\\r\\n.grid-cols-10 {\\r\\n  grid-template-columns: repeat(10, minmax(0, 1fr));\\r\\n}\\r\\n.flex-col {\\r\\n  flex-direction: column;\\r\\n}\\r\\n.flex-wrap {\\r\\n  flex-wrap: wrap;\\r\\n}\\r\\n.place-content-between {\\r\\n  place-content: space-between;\\r\\n}\\r\\n.items-end {\\r\\n  align-items: flex-end;\\r\\n}\\r\\n.items-center {\\r\\n  align-items: center;\\r\\n}\\r\\n.justify-end {\\r\\n  justify-content: flex-end;\\r\\n}\\r\\n.justify-center {\\r\\n  justify-content: center;\\r\\n}\\r\\n.justify-between {\\r\\n  justify-content: space-between;\\r\\n}\\r\\n.gap-3 {\\r\\n  gap: 0.75rem;\\r\\n}\\r\\n.gap-10 {\\r\\n  gap: 2.5rem;\\r\\n}\\r\\n.gap-4 {\\r\\n  gap: 1rem;\\r\\n}\\r\\n.space-y-4 > :not([hidden]) ~ :not([hidden]) {\\r\\n  --tw-space-y-reverse: 0;\\r\\n  margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));\\r\\n  margin-bottom: calc(1rem * var(--tw-space-y-reverse));\\r\\n}\\r\\n.space-x-3 > :not([hidden]) ~ :not([hidden]) {\\r\\n  --tw-space-x-reverse: 0;\\r\\n  margin-right: calc(0.75rem * var(--tw-space-x-reverse));\\r\\n  margin-left: calc(0.75rem * calc(1 - var(--tw-space-x-reverse)));\\r\\n}\\r\\n.space-x-2 > :not([hidden]) ~ :not([hidden]) {\\r\\n  --tw-space-x-reverse: 0;\\r\\n  margin-right: calc(0.5rem * var(--tw-space-x-reverse));\\r\\n  margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));\\r\\n}\\r\\n.space-x-5 > :not([hidden]) ~ :not([hidden]) {\\r\\n  --tw-space-x-reverse: 0;\\r\\n  margin-right: calc(1.25rem * var(--tw-space-x-reverse));\\r\\n  margin-left: calc(1.25rem * calc(1 - var(--tw-space-x-reverse)));\\r\\n}\\r\\n.space-x-8 > :not([hidden]) ~ :not([hidden]) {\\r\\n  --tw-space-x-reverse: 0;\\r\\n  margin-right: calc(2rem * var(--tw-space-x-reverse));\\r\\n  margin-left: calc(2rem * calc(1 - var(--tw-space-x-reverse)));\\r\\n}\\r\\n.divide-solid > :not([hidden]) ~ :not([hidden]) {\\r\\n  border-style: solid;\\r\\n}\\r\\n.overflow-hidden {\\r\\n  overflow: hidden;\\r\\n}\\r\\n.overflow-x-auto {\\r\\n  overflow-x: auto;\\r\\n}\\r\\n.whitespace-nowrap {\\r\\n  white-space: nowrap;\\r\\n}\\r\\n.whitespace-pre-wrap {\\r\\n  white-space: pre-wrap;\\r\\n}\\r\\n.rounded-md {\\r\\n  border-radius: 0.375rem;\\r\\n}\\r\\n.rounded-3xl {\\r\\n  border-radius: 1.5rem;\\r\\n}\\r\\n.rounded-xl {\\r\\n  border-radius: 0.75rem;\\r\\n}\\r\\n.rounded-full {\\r\\n  border-radius: 9999px;\\r\\n}\\r\\n.rounded-lg {\\r\\n  border-radius: 0.5rem;\\r\\n}\\r\\n.rounded {\\r\\n  border-radius: 0.25rem;\\r\\n}\\r\\n.rounded-l-md {\\r\\n  border-top-left-radius: 0.375rem;\\r\\n  border-bottom-left-radius: 0.375rem;\\r\\n}\\r\\n.rounded-l-none {\\r\\n  border-top-left-radius: 0px;\\r\\n  border-bottom-left-radius: 0px;\\r\\n}\\r\\n.border {\\r\\n  border-width: 1px;\\r\\n}\\r\\n.border-\\\\[0\\\\.5px\\\\] {\\r\\n  border-width: 0.5px;\\r\\n}\\r\\n.border-2 {\\r\\n  border-width: 2px;\\r\\n}\\r\\n.border-\\\\[1px\\\\] {\\r\\n  border-width: 1px;\\r\\n}\\r\\n.border-4 {\\r\\n  border-width: 4px;\\r\\n}\\r\\n.border-b {\\r\\n  border-bottom-width: 1px;\\r\\n}\\r\\n.border-b-2 {\\r\\n  border-bottom-width: 2px;\\r\\n}\\r\\n.border-t {\\r\\n  border-top-width: 1px;\\r\\n}\\r\\n.border-b-\\\\[1px\\\\] {\\r\\n  border-bottom-width: 1px;\\r\\n}\\r\\n.border-t-2 {\\r\\n  border-top-width: 2px;\\r\\n}\\r\\n.border-t-\\\\[1px\\\\] {\\r\\n  border-top-width: 1px;\\r\\n}\\r\\n.border-r-0 {\\r\\n  border-right-width: 0px;\\r\\n}\\r\\n.border-solid {\\r\\n  border-style: solid;\\r\\n}\\r\\n.border-dashed {\\r\\n  border-style: dashed;\\r\\n}\\r\\n.border-blue-400 {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(96 165 250 / var(--tw-border-opacity));\\r\\n}\\r\\n.border-transparent {\\r\\n  border-color: transparent;\\r\\n}\\r\\n.border-gray-300 {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(209 213 219 / var(--tw-border-opacity));\\r\\n}\\r\\n.border-\\\\[\\\\#BBBBBB\\\\] {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(187 187 187 / var(--tw-border-opacity));\\r\\n}\\r\\n.border-\\\\[\\\\#e2e2e2\\\\] {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(226 226 226 / var(--tw-border-opacity));\\r\\n}\\r\\n.border-blue-800 {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(30 64 175 / var(--tw-border-opacity));\\r\\n}\\r\\n.bg-white {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\\r\\n}\\r\\n.bg-slate-400 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(148 163 184 / var(--tw-bg-opacity));\\r\\n}\\r\\n.bg-blue-500 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(59 130 246 / var(--tw-bg-opacity));\\r\\n}\\r\\n.bg-zinc-300 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(212 212 216 / var(--tw-bg-opacity));\\r\\n}\\r\\n.bg-zinc-400 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(161 161 170 / var(--tw-bg-opacity));\\r\\n}\\r\\n.bg-yellow-500 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(234 179 8 / var(--tw-bg-opacity));\\r\\n}\\r\\n.bg-indigo-500 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(99 102 241 / var(--tw-bg-opacity));\\r\\n}\\r\\n.bg-teal-500 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(20 184 166 / var(--tw-bg-opacity));\\r\\n}\\r\\n.bg-blue-200 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(191 219 254 / var(--tw-bg-opacity));\\r\\n}\\r\\n.bg-\\\\[\\\\#3D414D\\\\] {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(61 65 77 / var(--tw-bg-opacity));\\r\\n}\\r\\n.bg-gray-200 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(229 231 235 / var(--tw-bg-opacity));\\r\\n}\\r\\n.bg-black {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(0 0 0 / var(--tw-bg-opacity));\\r\\n}\\r\\n.bg-red-200 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(254 202 202 / var(--tw-bg-opacity));\\r\\n}\\r\\n.bg-slate-300 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(203 213 225 / var(--tw-bg-opacity));\\r\\n}\\r\\n.bg-slate-100 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(241 245 249 / var(--tw-bg-opacity));\\r\\n}\\r\\n.bg-gray-50 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(249 250 251 / var(--tw-bg-opacity));\\r\\n}\\r\\n.object-cover {\\r\\n  -o-object-fit: cover;\\r\\n     object-fit: cover;\\r\\n}\\r\\n.p-6 {\\r\\n  padding: 1.5rem;\\r\\n}\\r\\n.p-3 {\\r\\n  padding: 0.75rem;\\r\\n}\\r\\n.p-2 {\\r\\n  padding: 0.5rem;\\r\\n}\\r\\n.p-\\\\[0\\\\.12rem\\\\] {\\r\\n  padding: 0.12rem;\\r\\n}\\r\\n.p-1 {\\r\\n  padding: 0.25rem;\\r\\n}\\r\\n.p-\\\\[0\\\\.2rem\\\\] {\\r\\n  padding: 0.2rem;\\r\\n}\\r\\n.p-0 {\\r\\n  padding: 0px;\\r\\n}\\r\\n.px-4 {\\r\\n  padding-left: 1rem;\\r\\n  padding-right: 1rem;\\r\\n}\\r\\n.px-2 {\\r\\n  padding-left: 0.5rem;\\r\\n  padding-right: 0.5rem;\\r\\n}\\r\\n.py-2 {\\r\\n  padding-top: 0.5rem;\\r\\n  padding-bottom: 0.5rem;\\r\\n}\\r\\n.py-4 {\\r\\n  padding-top: 1rem;\\r\\n  padding-bottom: 1rem;\\r\\n}\\r\\n.py-20 {\\r\\n  padding-top: 5rem;\\r\\n  padding-bottom: 5rem;\\r\\n}\\r\\n.px-20 {\\r\\n  padding-left: 5rem;\\r\\n  padding-right: 5rem;\\r\\n}\\r\\n.px-8 {\\r\\n  padding-left: 2rem;\\r\\n  padding-right: 2rem;\\r\\n}\\r\\n.py-3 {\\r\\n  padding-top: 0.75rem;\\r\\n  padding-bottom: 0.75rem;\\r\\n}\\r\\n.px-3 {\\r\\n  padding-left: 0.75rem;\\r\\n  padding-right: 0.75rem;\\r\\n}\\r\\n.px-1 {\\r\\n  padding-left: 0.25rem;\\r\\n  padding-right: 0.25rem;\\r\\n}\\r\\n.py-\\\\[5px\\\\] {\\r\\n  padding-top: 5px;\\r\\n  padding-bottom: 5px;\\r\\n}\\r\\n.py-5 {\\r\\n  padding-top: 1.25rem;\\r\\n  padding-bottom: 1.25rem;\\r\\n}\\r\\n.px-10 {\\r\\n  padding-left: 2.5rem;\\r\\n  padding-right: 2.5rem;\\r\\n}\\r\\n.py-1 {\\r\\n  padding-top: 0.25rem;\\r\\n  padding-bottom: 0.25rem;\\r\\n}\\r\\n.pb-4 {\\r\\n  padding-bottom: 1rem;\\r\\n}\\r\\n.pt-2 {\\r\\n  padding-top: 0.5rem;\\r\\n}\\r\\n.pb-14 {\\r\\n  padding-bottom: 3.5rem;\\r\\n}\\r\\n.pb-\\\\[60px\\\\] {\\r\\n  padding-bottom: 60px;\\r\\n}\\r\\n.pb-3 {\\r\\n  padding-bottom: 0.75rem;\\r\\n}\\r\\n.pt-1 {\\r\\n  padding-top: 0.25rem;\\r\\n}\\r\\n.pt-3 {\\r\\n  padding-top: 0.75rem;\\r\\n}\\r\\n.pb-1 {\\r\\n  padding-bottom: 0.25rem;\\r\\n}\\r\\n.pb-2 {\\r\\n  padding-bottom: 0.5rem;\\r\\n}\\r\\n.pl-6 {\\r\\n  padding-left: 1.5rem;\\r\\n}\\r\\n.pl-3 {\\r\\n  padding-left: 0.75rem;\\r\\n}\\r\\n.pl-7 {\\r\\n  padding-left: 1.75rem;\\r\\n}\\r\\n.pr-3 {\\r\\n  padding-right: 0.75rem;\\r\\n}\\r\\n.text-center {\\r\\n  text-align: center;\\r\\n}\\r\\n.font-sans {\\r\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\";\\r\\n}\\r\\n.text-3xl {\\r\\n  font-size: 1.875rem;\\r\\n  line-height: 2.25rem;\\r\\n}\\r\\n.text-sm {\\r\\n  font-size: 0.875rem;\\r\\n  line-height: 1.25rem;\\r\\n}\\r\\n.text-xl {\\r\\n  font-size: 1.25rem;\\r\\n  line-height: 1.75rem;\\r\\n}\\r\\n.text-2xl {\\r\\n  font-size: 1.5rem;\\r\\n  line-height: 2rem;\\r\\n}\\r\\n.text-xs {\\r\\n  font-size: 0.75rem;\\r\\n  line-height: 1rem;\\r\\n}\\r\\n.text-lg {\\r\\n  font-size: 1.125rem;\\r\\n  line-height: 1.75rem;\\r\\n}\\r\\n.text-base {\\r\\n  font-size: 1rem;\\r\\n  line-height: 1.5rem;\\r\\n}\\r\\n.font-bold {\\r\\n  font-weight: 700;\\r\\n}\\r\\n.font-medium {\\r\\n  font-weight: 500;\\r\\n}\\r\\n.font-semibold {\\r\\n  font-weight: 600;\\r\\n}\\r\\n.uppercase {\\r\\n  text-transform: uppercase;\\r\\n}\\r\\n.leading-7 {\\r\\n  line-height: 1.75rem;\\r\\n}\\r\\n.leading-\\\\[1\\\\.8rem\\\\] {\\r\\n  line-height: 1.8rem;\\r\\n}\\r\\n.text-gray-500 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(107 114 128 / var(--tw-text-opacity));\\r\\n}\\r\\n.text-blue-300 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(147 197 253 / var(--tw-text-opacity));\\r\\n}\\r\\n.text-white {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(255 255 255 / var(--tw-text-opacity));\\r\\n}\\r\\n.text-gray-600 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(75 85 99 / var(--tw-text-opacity));\\r\\n}\\r\\n.text-\\\\[\\\\#666676\\\\] {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(102 102 118 / var(--tw-text-opacity));\\r\\n}\\r\\n.text-gray-400 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(156 163 175 / var(--tw-text-opacity));\\r\\n}\\r\\n.text-red-400 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(248 113 113 / var(--tw-text-opacity));\\r\\n}\\r\\n.text-blue-500 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(59 130 246 / var(--tw-text-opacity));\\r\\n}\\r\\n.text-blue-400 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(96 165 250 / var(--tw-text-opacity));\\r\\n}\\r\\n.text-gray-700 {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(55 65 81 / var(--tw-text-opacity));\\r\\n}\\r\\n.text-black {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(0 0 0 / var(--tw-text-opacity));\\r\\n}\\r\\n.placeholder-gray-400::-moz-placeholder {\\r\\n  --tw-placeholder-opacity: 1;\\r\\n  color: rgb(156 163 175 / var(--tw-placeholder-opacity));\\r\\n}\\r\\n.placeholder-gray-400::placeholder {\\r\\n  --tw-placeholder-opacity: 1;\\r\\n  color: rgb(156 163 175 / var(--tw-placeholder-opacity));\\r\\n}\\r\\n.opacity-60 {\\r\\n  opacity: 0.6;\\r\\n}\\r\\n.shadow-sm {\\r\\n  --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);\\r\\n  --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);\\r\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\r\\n}\\r\\n.shadow-xl {\\r\\n  --tw-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);\\r\\n  --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);\\r\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\r\\n}\\r\\n.ring-2 {\\r\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\r\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\r\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\r\\n}\\r\\n.ring-yellow-500 {\\r\\n  --tw-ring-opacity: 1;\\r\\n  --tw-ring-color: rgb(234 179 8 / var(--tw-ring-opacity));\\r\\n}\\r\\n.ring-indigo-500 {\\r\\n  --tw-ring-opacity: 1;\\r\\n  --tw-ring-color: rgb(99 102 241 / var(--tw-ring-opacity));\\r\\n}\\r\\n.ring-teal-500 {\\r\\n  --tw-ring-opacity: 1;\\r\\n  --tw-ring-color: rgb(20 184 166 / var(--tw-ring-opacity));\\r\\n}\\r\\n.ring-gray-500 {\\r\\n  --tw-ring-opacity: 1;\\r\\n  --tw-ring-color: rgb(107 114 128 / var(--tw-ring-opacity));\\r\\n}\\r\\n.ring-black {\\r\\n  --tw-ring-opacity: 1;\\r\\n  --tw-ring-color: rgb(0 0 0 / var(--tw-ring-opacity));\\r\\n}\\r\\n.ring-red-500 {\\r\\n  --tw-ring-opacity: 1;\\r\\n  --tw-ring-color: rgb(239 68 68 / var(--tw-ring-opacity));\\r\\n}\\r\\n.ring-blue-500 {\\r\\n  --tw-ring-opacity: 1;\\r\\n  --tw-ring-color: rgb(59 130 246 / var(--tw-ring-opacity));\\r\\n}\\r\\n.ring-offset-2 {\\r\\n  --tw-ring-offset-width: 2px;\\r\\n}\\r\\n.ring-offset-1 {\\r\\n  --tw-ring-offset-width: 1px;\\r\\n}\\r\\n.filter {\\r\\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\r\\n}\\r\\n.transition {\\r\\n  transition-property: color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;\\r\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\\r\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;\\r\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\r\\n  transition-duration: 150ms;\\r\\n}\\r\\n.transition-all {\\r\\n  transition-property: all;\\r\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\r\\n  transition-duration: 150ms;\\r\\n}\\r\\n.duration-\\\\[0ms\\\\] {\\r\\n  transition-duration: 0ms;\\r\\n}\\r\\n.duration-1000 {\\r\\n  transition-duration: 1000ms;\\r\\n}\\r\\n.last\\\\:border-b-0:last-child {\\r\\n  border-bottom-width: 0px;\\r\\n}\\r\\n.odd\\\\:bg-blue-50:nth-child(odd) {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(239 246 255 / var(--tw-bg-opacity));\\r\\n}\\r\\n.hover\\\\:cursor-pointer:hover {\\r\\n  cursor: pointer;\\r\\n}\\r\\n.hover\\\\:border-blue-500:hover {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(59 130 246 / var(--tw-border-opacity));\\r\\n}\\r\\n.hover\\\\:border-gray-400:hover {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(156 163 175 / var(--tw-border-opacity));\\r\\n}\\r\\n.hover\\\\:border-gray-300:hover {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(209 213 219 / var(--tw-border-opacity));\\r\\n}\\r\\n.hover\\\\:bg-gray-50:hover {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(249 250 251 / var(--tw-bg-opacity));\\r\\n}\\r\\n.hover\\\\:bg-teal-500:hover {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(20 184 166 / var(--tw-bg-opacity));\\r\\n}\\r\\n.hover\\\\:bg-gray-200:hover {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(229 231 235 / var(--tw-bg-opacity));\\r\\n}\\r\\n.hover\\\\:bg-gray-100:hover {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(243 244 246 / var(--tw-bg-opacity));\\r\\n}\\r\\n.hover\\\\:bg-white:hover {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\\r\\n}\\r\\n.hover\\\\:text-gray-400:hover {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(156 163 175 / var(--tw-text-opacity));\\r\\n}\\r\\n.hover\\\\:text-black:hover {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(0 0 0 / var(--tw-text-opacity));\\r\\n}\\r\\n.hover\\\\:text-blue-500:hover {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(59 130 246 / var(--tw-text-opacity));\\r\\n}\\r\\n.hover\\\\:text-red-500:hover {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(239 68 68 / var(--tw-text-opacity));\\r\\n}\\r\\n.hover\\\\:text-gray-500:hover {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(107 114 128 / var(--tw-text-opacity));\\r\\n}\\r\\n.hover\\\\:text-blue-400:hover {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(96 165 250 / var(--tw-text-opacity));\\r\\n}\\r\\n.hover\\\\:underline:hover {\\r\\n  -webkit-text-decoration-line: underline;\\r\\n          text-decoration-line: underline;\\r\\n}\\r\\n.focus\\\\:border-blue-400:focus {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(96 165 250 / var(--tw-border-opacity));\\r\\n}\\r\\n.focus\\\\:border-orange-500:focus {\\r\\n  --tw-border-opacity: 1;\\r\\n  border-color: rgb(249 115 22 / var(--tw-border-opacity));\\r\\n}\\r\\n.focus\\\\:bg-red-500:focus {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(239 68 68 / var(--tw-bg-opacity));\\r\\n}\\r\\n.focus\\\\:outline-none:focus {\\r\\n  outline: 2px solid transparent;\\r\\n  outline-offset: 2px;\\r\\n}\\r\\n.focus\\\\:ring-2:focus {\\r\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\r\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\r\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\r\\n}\\r\\n.focus\\\\:ring-blue-500:focus {\\r\\n  --tw-ring-opacity: 1;\\r\\n  --tw-ring-color: rgb(59 130 246 / var(--tw-ring-opacity));\\r\\n}\\r\\n.focus\\\\:ring-blue-400:focus {\\r\\n  --tw-ring-opacity: 1;\\r\\n  --tw-ring-color: rgb(96 165 250 / var(--tw-ring-opacity));\\r\\n}\\r\\n.focus\\\\:ring-orange-500:focus {\\r\\n  --tw-ring-opacity: 1;\\r\\n  --tw-ring-color: rgb(249 115 22 / var(--tw-ring-opacity));\\r\\n}\\r\\n.focus\\\\:ring-offset-2:focus {\\r\\n  --tw-ring-offset-width: 2px;\\r\\n}\\r\\n.active\\\\:bg-yellow-500:active {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(234 179 8 / var(--tw-bg-opacity));\\r\\n}\\r\\n.peer:checked ~ .peer-checked\\\\:bg-blue-600 {\\r\\n  --tw-bg-opacity: 1;\\r\\n  background-color: rgb(37 99 235 / var(--tw-bg-opacity));\\r\\n}\\r\\n.peer:checked ~ .peer-checked\\\\:text-white {\\r\\n  --tw-text-opacity: 1;\\r\\n  color: rgb(255 255 255 / var(--tw-text-opacity));\\r\\n}\\r\\n@media (min-width: 640px) {\\r\\n\\r\\n  .sm\\\\:col-span-10 {\\r\\n    grid-column: span 10 / span 10;\\r\\n  }\\r\\n\\r\\n  .sm\\\\:mt-7 {\\r\\n    margin-top: 1.75rem;\\r\\n  }\\r\\n\\r\\n  .sm\\\\:grid {\\r\\n    display: grid;\\r\\n  }\\r\\n\\r\\n  .sm\\\\:max-w-\\\\[380px\\\\] {\\r\\n    max-width: 380px;\\r\\n  }\\r\\n\\r\\n  .sm\\\\:grid-cols-5 {\\r\\n    grid-template-columns: repeat(5, minmax(0, 1fr));\\r\\n  }\\r\\n\\r\\n  .sm\\\\:grid-cols-1 {\\r\\n    grid-template-columns: repeat(1, minmax(0, 1fr));\\r\\n  }\\r\\n\\r\\n  .sm\\\\:grid-cols-3 {\\r\\n    grid-template-columns: repeat(3, minmax(0, 1fr));\\r\\n  }\\r\\n\\r\\n  .sm\\\\:grid-cols-10 {\\r\\n    grid-template-columns: repeat(10, minmax(0, 1fr));\\r\\n  }\\r\\n\\r\\n  .sm\\\\:pl-5 {\\r\\n    padding-left: 1.25rem;\\r\\n  }\\r\\n}\\r\\n@media (min-width: 768px) {\\r\\n\\r\\n  .md\\\\:grid-cols-5 {\\r\\n    grid-template-columns: repeat(5, minmax(0, 1fr));\\r\\n  }\\r\\n\\r\\n  .md\\\\:grid-cols-4 {\\r\\n    grid-template-columns: repeat(4, minmax(0, 1fr));\\r\\n  }\\r\\n\\r\\n  .md\\\\:grid-cols-3 {\\r\\n    grid-template-columns: repeat(3, minmax(0, 1fr));\\r\\n  }\\r\\n\\r\\n  .md\\\\:grid-cols-2 {\\r\\n    grid-template-columns: repeat(2, minmax(0, 1fr));\\r\\n  }\\r\\n}\\r\\n@media (min-width: 1024px) {\\r\\n\\r\\n  .lg\\\\:col-span-1 {\\r\\n    grid-column: span 1 / span 1;\\r\\n  }\\r\\n\\r\\n  .lg\\\\:col-span-10 {\\r\\n    grid-column: span 10 / span 10;\\r\\n  }\\r\\n\\r\\n  .lg\\\\:col-span-5 {\\r\\n    grid-column: span 5 / span 5;\\r\\n  }\\r\\n\\r\\n  .lg\\\\:grid-cols-8 {\\r\\n    grid-template-columns: repeat(8, minmax(0, 1fr));\\r\\n  }\\r\\n\\r\\n  .lg\\\\:grid-cols-6 {\\r\\n    grid-template-columns: repeat(6, minmax(0, 1fr));\\r\\n  }\\r\\n\\r\\n  .lg\\\\:grid-cols-4 {\\r\\n    grid-template-columns: repeat(4, minmax(0, 1fr));\\r\\n  }\\r\\n\\r\\n  .lg\\\\:grid-rows-5 {\\r\\n    grid-template-rows: repeat(5, minmax(0, 1fr));\\r\\n  }\\r\\n\\r\\n  .lg\\\\:px-5 {\\r\\n    padding-left: 1.25rem;\\r\\n    padding-right: 1.25rem;\\r\\n  }\\r\\n\\r\\n  .lg\\\\:px-0 {\\r\\n    padding-left: 0px;\\r\\n    padding-right: 0px;\\r\\n  }\\r\\n}\\r\\n@media (min-width: 1280px) {\\r\\n\\r\\n  .xl\\\\:grid-cols-5 {\\r\\n    grid-template-columns: repeat(5, minmax(0, 1fr));\\r\\n  }\\r\\n\\r\\n  .xl\\\\:grid-cols-3 {\\r\\n    grid-template-columns: repeat(3, minmax(0, 1fr));\\r\\n  }\\r\\n}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://styles/globals.css\",\"<no source>\"],\"names\":[],\"mappings\":\"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B;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,2BAAmB;EAAnB,wBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,2BAAmB;EAAnB,wBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,+BAAmB;EAAnB,4BAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,0BAAmB;EAA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;EDAA;CCAA;ADAA;EAAA,4GCAA;EDAA,0GCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;;EAAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;CAAA;ADAA;;EAAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;CAAA;ADAA;;EAAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA,sBCAA;IDAA;GCAA;;EDAA;IAAA,kBCAA;IDAA;GCAA;CAAA;ADAA;;EAAA;IAAA;GCAA;;EDAA;IAAA;GCAA;CAAA\",\"sourcesContent\":[\"@tailwind base;\\r\\n@tailwind components;\\r\\n@tailwind utilities;\\r\\n\",null],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls4XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOF0udXNlWzJdIS4vc3R5bGVzL2dsb2JhbHMuY3NzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ3dIO0FBQ3hILDhCQUE4QixrSEFBMkI7QUFDekQ7QUFDQSw2WUFBNlksOEJBQThCLDhCQUE4QixrQ0FBa0Msb0NBQW9DLFlBQVksOEJBQThCLHVCQUF1QixLQUFLLHVRQUF1USx3QkFBd0IsNkNBQTZDLCtCQUErQiw0QkFBNEIsc0JBQXNCLHlQQUF5UCxZQUFZLDhLQUE4SyxpQkFBaUIsbUNBQW1DLFlBQVksMk9BQTJPLGlCQUFpQiw2QkFBNkIsb0NBQW9DLFlBQVksNkdBQTZHLGdEQUFnRCxnREFBZ0QsS0FBSyx3SEFBd0gseUJBQXlCLDJCQUEyQixLQUFLLDZGQUE2RixxQkFBcUIsK0JBQStCLEtBQUsseUZBQXlGLDBCQUEwQixLQUFLLDhLQUE4SywySEFBMkgsNkJBQTZCLFlBQVksNkVBQTZFLHFCQUFxQixLQUFLLHlIQUF5SCxxQkFBcUIscUJBQXFCLHlCQUF5QiwrQkFBK0IsS0FBSyxhQUFhLHNCQUFzQixLQUFLLGFBQWEsa0JBQWtCLEtBQUssZ2NBQWdjLHNCQUFzQixvQ0FBb0Msd0NBQXdDLFlBQVksME5BQTBOLDRCQUE0Qiw4QkFBOEIsbUNBQW1DLDZCQUE2Qix3QkFBd0IseUJBQXlCLFlBQVksNEdBQTRHLDJCQUEyQixLQUFLLHVNQUF1TSxrQ0FBa0MsNENBQTRDLHFDQUFxQyxZQUFZLDJHQUEyRyxvQkFBb0IsS0FBSywyTkFBMk4sdUJBQXVCLEtBQUssK0ZBQStGLCtCQUEr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VyxNQUFNLE9BQU8sTUFBTSxLQUFLLHFCQUFxQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLGlCQUFpQixVQUFVLE1BQU0sS0FBSyxVQUFVLFVBQVUsTUFBTSxLQUFLLFVBQVUsTUFBTSxPQUFPLFdBQVcsVUFBVSxVQUFVLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE9BQU8sTUFBTSxLQUFLLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLE1BQU0sTUFBTSxLQUFLLEtBQUssVUFBVSxNQUFNLFFBQVEsTUFBTSxZQUFZLG9CQUFvQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLFVBQVUsTUFBTSxNQUFNLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxXQUFXLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxhQUFhLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLFdBQVcsS0FBSyxNQUFNLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxLQUFLLHdDQUF3Qyx5QkFBeUIsd0JBQXdCLDRCQUE0QjtBQUM3MjdDO0FBQ0EsK0RBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3R5bGVzL2dsb2JhbHMuY3NzPzRiYTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi8qXFxyXFxuISB0YWlsd2luZGNzcyB2My4wLjI0IHwgTUlUIExpY2Vuc2UgfCBodHRwczovL3RhaWx3aW5kY3NzLmNvbVxcclxcbiovLypcXHJcXG4xLiBQcmV2ZW50IHBhZGRpbmcgYW5kIGJvcmRlciBmcm9tIGFmZmVjdGluZyBlbGVtZW50IHdpZHRoLiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy80KVxcclxcbjIuIEFsbG93IGFkZGluZyBhIGJvcmRlciB0byBhbiBlbGVtZW50IGJ5IGp1c3QgYWRkaW5nIGEgYm9yZGVyLXdpZHRoLiAoaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kY3NzL3RhaWx3aW5kY3NzL3B1bGwvMTE2KVxcclxcbiovXFxyXFxuXFxyXFxuKixcXHJcXG46OmJlZm9yZSxcXHJcXG46OmFmdGVyIHtcXHJcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXHJcXG4gIGJvcmRlci13aWR0aDogMDsgLyogMiAqL1xcclxcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDsgLyogMiAqL1xcclxcbiAgYm9yZGVyLWNvbG9yOiAjZTVlN2ViOyAvKiAyICovXFxyXFxufVxcclxcblxcclxcbjo6YmVmb3JlLFxcclxcbjo6YWZ0ZXIge1xcclxcbiAgLS10dy1jb250ZW50OiAnJztcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG4xLiBVc2UgYSBjb25zaXN0ZW50IHNlbnNpYmxlIGxpbmUtaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cXHJcXG4yLiBQcmV2ZW50IGFkanVzdG1lbnRzIG9mIGZvbnQgc2l6ZSBhZnRlciBvcmllbnRhdGlvbiBjaGFuZ2VzIGluIGlPUy5cXHJcXG4zLiBVc2UgYSBtb3JlIHJlYWRhYmxlIHRhYiBzaXplLlxcclxcbjQuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYHNhbnNgIGZvbnQtZmFtaWx5IGJ5IGRlZmF1bHQuXFxyXFxuKi9cXHJcXG5cXHJcXG5odG1sIHtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7IC8qIDEgKi9cXHJcXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTsgLyogMiAqL1xcclxcbiAgLW1vei10YWItc2l6ZTogNDsgLyogMyAqL1xcclxcbiAgLW8tdGFiLXNpemU6IDQ7XFxyXFxuICAgICB0YWItc2l6ZTogNDsgLyogMyAqL1xcclxcbiAgZm9udC1mYW1pbHk6IHVpLXNhbnMtc2VyaWYsIHN5c3RlbS11aSwgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcXFwiU2Vnb2UgVUlcXFwiLCBSb2JvdG8sIFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsIEFyaWFsLCBcXFwiTm90byBTYW5zXFxcIiwgc2Fucy1zZXJpZiwgXFxcIkFwcGxlIENvbG9yIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIFN5bWJvbFxcXCIsIFxcXCJOb3RvIENvbG9yIEVtb2ppXFxcIjsgLyogNCAqL1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbjEuIFJlbW92ZSB0aGUgbWFyZ2luIGluIGFsbCBicm93c2Vycy5cXHJcXG4yLiBJbmhlcml0IGxpbmUtaGVpZ2h0IGZyb20gYGh0bWxgIHNvIHVzZXJzIGNhbiBzZXQgdGhlbSBhcyBhIGNsYXNzIGRpcmVjdGx5IG9uIHRoZSBgaHRtbGAgZWxlbWVudC5cXHJcXG4qL1xcclxcblxcclxcbmJvZHkge1xcclxcbiAgbWFyZ2luOiAwOyAvKiAxICovXFxyXFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgLyogMiAqL1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbjEuIEFkZCB0aGUgY29ycmVjdCBoZWlnaHQgaW4gRmlyZWZveC5cXHJcXG4yLiBDb3JyZWN0IHRoZSBpbmhlcml0YW5jZSBvZiBib3JkZXIgY29sb3IgaW4gRmlyZWZveC4gKGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE5MDY1NSlcXHJcXG4zLiBFbnN1cmUgaG9yaXpvbnRhbCBydWxlcyBhcmUgdmlzaWJsZSBieSBkZWZhdWx0LlxcclxcbiovXFxyXFxuXFxyXFxuaHIge1xcclxcbiAgaGVpZ2h0OiAwOyAvKiAxICovXFxyXFxuICBjb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcclxcbiAgYm9yZGVyLXRvcC13aWR0aDogMXB4OyAvKiAzICovXFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuQWRkIHRoZSBjb3JyZWN0IHRleHQgZGVjb3JhdGlvbiBpbiBDaHJvbWUsIEVkZ2UsIGFuZCBTYWZhcmkuXFxyXFxuKi9cXHJcXG5cXHJcXG5hYmJyOndoZXJlKFt0aXRsZV0pIHtcXHJcXG4gIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcclxcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuUmVtb3ZlIHRoZSBkZWZhdWx0IGZvbnQgc2l6ZSBhbmQgd2VpZ2h0IGZvciBoZWFkaW5ncy5cXHJcXG4qL1xcclxcblxcclxcbmgxLFxcclxcbmgyLFxcclxcbmgzLFxcclxcbmg0LFxcclxcbmg1LFxcclxcbmg2IHtcXHJcXG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBpbmhlcml0O1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcblJlc2V0IGxpbmtzIHRvIG9wdGltaXplIGZvciBvcHQtaW4gc3R5bGluZyBpbnN0ZWFkIG9mIG9wdC1vdXQuXFxyXFxuKi9cXHJcXG5cXHJcXG5hIHtcXHJcXG4gIGNvbG9yOiBpbmhlcml0O1xcclxcbiAgdGV4dC1kZWNvcmF0aW9uOiBpbmhlcml0O1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbkFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBFZGdlIGFuZCBTYWZhcmkuXFxyXFxuKi9cXHJcXG5cXHJcXG5iLFxcclxcbnN0cm9uZyB7XFxyXFxuICBmb250LXdlaWdodDogYm9sZGVyO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbjEuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYG1vbm9gIGZvbnQgZmFtaWx5IGJ5IGRlZmF1bHQuXFxyXFxuMi4gQ29ycmVjdCB0aGUgb2RkIGBlbWAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxcclxcbiovXFxyXFxuXFxyXFxuY29kZSxcXHJcXG5rYmQsXFxyXFxuc2FtcCxcXHJcXG5wcmUge1xcclxcbiAgZm9udC1mYW1pbHk6IHVpLW1vbm9zcGFjZSwgU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBcXFwiTGliZXJhdGlvbiBNb25vXFxcIiwgXFxcIkNvdXJpZXIgTmV3XFxcIiwgbW9ub3NwYWNlOyAvKiAxICovXFxyXFxuICBmb250LXNpemU6IDFlbTsgLyogMiAqL1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbkFkZCB0aGUgY29ycmVjdCBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxcclxcbiovXFxyXFxuXFxyXFxuc21hbGwge1xcclxcbiAgZm9udC1zaXplOiA4MCU7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuUHJldmVudCBgc3ViYCBhbmQgYHN1cGAgZWxlbWVudHMgZnJvbSBhZmZlY3RpbmcgdGhlIGxpbmUgaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cXHJcXG4qL1xcclxcblxcclxcbnN1YixcXHJcXG5zdXAge1xcclxcbiAgZm9udC1zaXplOiA3NSU7XFxyXFxuICBsaW5lLWhlaWdodDogMDtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXHJcXG59XFxyXFxuXFxyXFxuc3ViIHtcXHJcXG4gIGJvdHRvbTogLTAuMjVlbTtcXHJcXG59XFxyXFxuXFxyXFxuc3VwIHtcXHJcXG4gIHRvcDogLTAuNWVtO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbjEuIFJlbW92ZSB0ZXh0IGluZGVudGF0aW9uIGZyb20gdGFibGUgY29udGVudHMgaW4gQ2hyb21lIGFuZCBTYWZhcmkuIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05OTkwODgsIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDEyOTcpXFxyXFxuMi4gQ29ycmVjdCB0YWJsZSBib3JkZXIgY29sb3IgaW5oZXJpdGFuY2UgaW4gYWxsIENocm9tZSBhbmQgU2FmYXJpLiAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTM1NzI5LCBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTk1MDE2KVxcclxcbjMuIFJlbW92ZSBnYXBzIGJldHdlZW4gdGFibGUgYm9yZGVycyBieSBkZWZhdWx0LlxcclxcbiovXFxyXFxuXFxyXFxudGFibGUge1xcclxcbiAgdGV4dC1pbmRlbnQ6IDA7IC8qIDEgKi9cXHJcXG4gIGJvcmRlci1jb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcclxcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTsgLyogMyAqL1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbjEuIENoYW5nZSB0aGUgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzLlxcclxcbjIuIFJlbW92ZSB0aGUgbWFyZ2luIGluIEZpcmVmb3ggYW5kIFNhZmFyaS5cXHJcXG4zLiBSZW1vdmUgZGVmYXVsdCBwYWRkaW5nIGluIGFsbCBicm93c2Vycy5cXHJcXG4qL1xcclxcblxcclxcbmJ1dHRvbixcXHJcXG5pbnB1dCxcXHJcXG5vcHRncm91cCxcXHJcXG5zZWxlY3QsXFxyXFxudGV4dGFyZWEge1xcclxcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7IC8qIDEgKi9cXHJcXG4gIGZvbnQtc2l6ZTogMTAwJTsgLyogMSAqL1xcclxcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IC8qIDEgKi9cXHJcXG4gIGNvbG9yOiBpbmhlcml0OyAvKiAxICovXFxyXFxuICBtYXJnaW46IDA7IC8qIDIgKi9cXHJcXG4gIHBhZGRpbmc6IDA7IC8qIDMgKi9cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG5SZW1vdmUgdGhlIGluaGVyaXRhbmNlIG9mIHRleHQgdHJhbnNmb3JtIGluIEVkZ2UgYW5kIEZpcmVmb3guXFxyXFxuKi9cXHJcXG5cXHJcXG5idXR0b24sXFxyXFxuc2VsZWN0IHtcXHJcXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbjEuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXFxyXFxuMi4gUmVtb3ZlIGRlZmF1bHQgYnV0dG9uIHN0eWxlcy5cXHJcXG4qL1xcclxcblxcclxcbmJ1dHRvbixcXHJcXG5bdHlwZT0nYnV0dG9uJ10sXFxyXFxuW3R5cGU9J3Jlc2V0J10sXFxyXFxuW3R5cGU9J3N1Ym1pdCddIHtcXHJcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAxICovXFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgLyogMiAqL1xcclxcbiAgYmFja2dyb3VuZC1pbWFnZTogbm9uZTsgLyogMiAqL1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcblVzZSB0aGUgbW9kZXJuIEZpcmVmb3ggZm9jdXMgc3R5bGUgZm9yIGFsbCBmb2N1c2FibGUgZWxlbWVudHMuXFxyXFxuKi9cXHJcXG5cXHJcXG46LW1vei1mb2N1c3Jpbmcge1xcclxcbiAgb3V0bGluZTogYXV0bztcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG5SZW1vdmUgdGhlIGFkZGl0aW9uYWwgYDppbnZhbGlkYCBzdHlsZXMgaW4gRmlyZWZveC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2dlY2tvLWRldi9ibG9iLzJmOWVhY2Q5ZDNkOTk1YzkzN2I0MjUxYTU1NTdkOTVkNDk0YzliZTEvbGF5b3V0L3N0eWxlL3Jlcy9mb3Jtcy5jc3MjTDcyOC1MNzM3KVxcclxcbiovXFxyXFxuXFxyXFxuOi1tb3otdWktaW52YWxpZCB7XFxyXFxuICBib3gtc2hhZG93OiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbkFkZCB0aGUgY29ycmVjdCB2ZXJ0aWNhbCBhbGlnbm1lbnQgaW4gQ2hyb21lIGFuZCBGaXJlZm94LlxcclxcbiovXFxyXFxuXFxyXFxucHJvZ3Jlc3Mge1xcclxcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbkNvcnJlY3QgdGhlIGN1cnNvciBzdHlsZSBvZiBpbmNyZW1lbnQgYW5kIGRlY3JlbWVudCBidXR0b25zIGluIFNhZmFyaS5cXHJcXG4qL1xcclxcblxcclxcbjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXHJcXG46Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xcclxcbiAgaGVpZ2h0OiBhdXRvO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbjEuIENvcnJlY3QgdGhlIG9kZCBhcHBlYXJhbmNlIGluIENocm9tZSBhbmQgU2FmYXJpLlxcclxcbjIuIENvcnJlY3QgdGhlIG91dGxpbmUgc3R5bGUgaW4gU2FmYXJpLlxcclxcbiovXFxyXFxuXFxyXFxuW3R5cGU9J3NlYXJjaCddIHtcXHJcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogdGV4dGZpZWxkOyAvKiAxICovXFxyXFxuICBvdXRsaW5lLW9mZnNldDogLTJweDsgLyogMiAqL1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcblJlbW92ZSB0aGUgaW5uZXIgcGFkZGluZyBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBtYWNPUy5cXHJcXG4qL1xcclxcblxcclxcbjo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiB7XFxyXFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXHJcXG4yLiBDaGFuZ2UgZm9udCBwcm9wZXJ0aWVzIHRvIGBpbmhlcml0YCBpbiBTYWZhcmkuXFxyXFxuKi9cXHJcXG5cXHJcXG46Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcXHJcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAxICovXFxyXFxuICBmb250OiBpbmhlcml0OyAvKiAyICovXFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXFxyXFxuKi9cXHJcXG5cXHJcXG5zdW1tYXJ5IHtcXHJcXG4gIGRpc3BsYXk6IGxpc3QtaXRlbTtcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG5SZW1vdmVzIHRoZSBkZWZhdWx0IHNwYWNpbmcgYW5kIGJvcmRlciBmb3IgYXBwcm9wcmlhdGUgZWxlbWVudHMuXFxyXFxuKi9cXHJcXG5cXHJcXG5ibG9ja3F1b3RlLFxcclxcbmRsLFxcclxcbmRkLFxcclxcbmgxLFxcclxcbmgyLFxcclxcbmgzLFxcclxcbmg0LFxcclxcbmg1LFxcclxcbmg2LFxcclxcbmhyLFxcclxcbmZpZ3VyZSxcXHJcXG5wLFxcclxcbnByZSB7XFxyXFxuICBtYXJnaW46IDA7XFxyXFxufVxcclxcblxcclxcbmZpZWxkc2V0IHtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG4gIHBhZGRpbmc6IDA7XFxyXFxufVxcclxcblxcclxcbmxlZ2VuZCB7XFxyXFxuICBwYWRkaW5nOiAwO1xcclxcbn1cXHJcXG5cXHJcXG5vbCxcXHJcXG51bCxcXHJcXG5tZW51IHtcXHJcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxyXFxuICBtYXJnaW46IDA7XFxyXFxuICBwYWRkaW5nOiAwO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcblByZXZlbnQgcmVzaXppbmcgdGV4dGFyZWFzIGhvcml6b250YWxseSBieSBkZWZhdWx0LlxcclxcbiovXFxyXFxuXFxyXFxudGV4dGFyZWEge1xcclxcbiAgcmVzaXplOiB2ZXJ0aWNhbDtcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG4xLiBSZXNldCB0aGUgZGVmYXVsdCBwbGFjZWhvbGRlciBvcGFjaXR5IGluIEZpcmVmb3guIChodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL2lzc3Vlcy8zMzAwKVxcclxcbjIuIFNldCB0aGUgZGVmYXVsdCBwbGFjZWhvbGRlciBjb2xvciB0byB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgZ3JheSA0MDAgY29sb3IuXFxyXFxuKi9cXHJcXG5cXHJcXG5pbnB1dDo6LW1vei1wbGFjZWhvbGRlciwgdGV4dGFyZWE6Oi1tb3otcGxhY2Vob2xkZXIge1xcclxcbiAgb3BhY2l0eTogMTsgLyogMSAqL1xcclxcbiAgY29sb3I6ICM5Y2EzYWY7IC8qIDIgKi9cXHJcXG59XFxyXFxuXFxyXFxuaW5wdXQ6OnBsYWNlaG9sZGVyLFxcclxcbnRleHRhcmVhOjpwbGFjZWhvbGRlciB7XFxyXFxuICBvcGFjaXR5OiAxOyAvKiAxICovXFxyXFxuICBjb2xvcjogIzljYTNhZjsgLyogMiAqL1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcblNldCB0aGUgZGVmYXVsdCBjdXJzb3IgZm9yIGJ1dHRvbnMuXFxyXFxuKi9cXHJcXG5cXHJcXG5idXR0b24sXFxyXFxuW3JvbGU9XFxcImJ1dHRvblxcXCJdIHtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG5NYWtlIHN1cmUgZGlzYWJsZWQgYnV0dG9ucyBkb24ndCBnZXQgdGhlIHBvaW50ZXIgY3Vyc29yLlxcclxcbiovXFxyXFxuOmRpc2FibGVkIHtcXHJcXG4gIGN1cnNvcjogZGVmYXVsdDtcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG4xLiBNYWtlIHJlcGxhY2VkIGVsZW1lbnRzIGBkaXNwbGF5OiBibG9ja2AgYnkgZGVmYXVsdC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3pkZXZzL2Nzc3JlbWVkeS9pc3N1ZXMvMTQpXFxyXFxuMi4gQWRkIGB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlYCB0byBhbGlnbiByZXBsYWNlZCBlbGVtZW50cyBtb3JlIHNlbnNpYmx5IGJ5IGRlZmF1bHQuIChodHRwczovL2dpdGh1Yi5jb20vamVuc2ltbW9ucy9jc3NyZW1lZHkvaXNzdWVzLzE0I2lzc3VlY29tbWVudC02MzQ5MzQyMTApXFxyXFxuICAgVGhpcyBjYW4gdHJpZ2dlciBhIHBvb3JseSBjb25zaWRlcmVkIGxpbnQgZXJyb3IgaW4gc29tZSB0b29scyBidXQgaXMgaW5jbHVkZWQgYnkgZGVzaWduLlxcclxcbiovXFxyXFxuXFxyXFxuaW1nLFxcclxcbnN2ZyxcXHJcXG52aWRlbyxcXHJcXG5jYW52YXMsXFxyXFxuYXVkaW8sXFxyXFxuaWZyYW1lLFxcclxcbmVtYmVkLFxcclxcbm9iamVjdCB7XFxyXFxuICBkaXNwbGF5OiBibG9jazsgLyogMSAqL1xcclxcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgLyogMiAqL1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbkNvbnN0cmFpbiBpbWFnZXMgYW5kIHZpZGVvcyB0byB0aGUgcGFyZW50IHdpZHRoIGFuZCBwcmVzZXJ2ZSB0aGVpciBpbnRyaW5zaWMgYXNwZWN0IHJhdGlvLiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy8xNClcXHJcXG4qL1xcclxcblxcclxcbmltZyxcXHJcXG52aWRlbyB7XFxyXFxuICBtYXgtd2lkdGg6IDEwMCU7XFxyXFxuICBoZWlnaHQ6IGF1dG87XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuRW5zdXJlIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3Igb2YgdGhlIGBoaWRkZW5gIGF0dHJpYnV0ZS5cXHJcXG4qL1xcclxcblxcclxcbltoaWRkZW5dIHtcXHJcXG4gIGRpc3BsYXk6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbiosIDo6YmVmb3JlLCA6OmFmdGVyIHtcXHJcXG4gIC0tdHctdHJhbnNsYXRlLXg6IDA7XFxyXFxuICAtLXR3LXRyYW5zbGF0ZS15OiAwO1xcclxcbiAgLS10dy1yb3RhdGU6IDA7XFxyXFxuICAtLXR3LXNrZXcteDogMDtcXHJcXG4gIC0tdHctc2tldy15OiAwO1xcclxcbiAgLS10dy1zY2FsZS14OiAxO1xcclxcbiAgLS10dy1zY2FsZS15OiAxO1xcclxcbiAgLS10dy1wYW4teDogIDtcXHJcXG4gIC0tdHctcGFuLXk6ICA7XFxyXFxuICAtLXR3LXBpbmNoLXpvb206ICA7XFxyXFxuICAtLXR3LXNjcm9sbC1zbmFwLXN0cmljdG5lc3M6IHByb3hpbWl0eTtcXHJcXG4gIC0tdHctb3JkaW5hbDogIDtcXHJcXG4gIC0tdHctc2xhc2hlZC16ZXJvOiAgO1xcclxcbiAgLS10dy1udW1lcmljLWZpZ3VyZTogIDtcXHJcXG4gIC0tdHctbnVtZXJpYy1zcGFjaW5nOiAgO1xcclxcbiAgLS10dy1udW1lcmljLWZyYWN0aW9uOiAgO1xcclxcbiAgLS10dy1yaW5nLWluc2V0OiAgO1xcclxcbiAgLS10dy1yaW5nLW9mZnNldC13aWR0aDogMHB4O1xcclxcbiAgLS10dy1yaW5nLW9mZnNldC1jb2xvcjogI2ZmZjtcXHJcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDU5IDEzMCAyNDYgLyAwLjUpO1xcclxcbiAgLS10dy1yaW5nLW9mZnNldC1zaGFkb3c6IDAgMCAjMDAwMDtcXHJcXG4gIC0tdHctcmluZy1zaGFkb3c6IDAgMCAjMDAwMDtcXHJcXG4gIC0tdHctc2hhZG93OiAwIDAgIzAwMDA7XFxyXFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDAgIzAwMDA7XFxyXFxuICAtLXR3LWJsdXI6ICA7XFxyXFxuICAtLXR3LWJyaWdodG5lc3M6ICA7XFxyXFxuICAtLXR3LWNvbnRyYXN0OiAgO1xcclxcbiAgLS10dy1ncmF5c2NhbGU6ICA7XFxyXFxuICAtLXR3LWh1ZS1yb3RhdGU6ICA7XFxyXFxuICAtLXR3LWludmVydDogIDtcXHJcXG4gIC0tdHctc2F0dXJhdGU6ICA7XFxyXFxuICAtLXR3LXNlcGlhOiAgO1xcclxcbiAgLS10dy1kcm9wLXNoYWRvdzogIDtcXHJcXG4gIC0tdHctYmFja2Ryb3AtYmx1cjogIDtcXHJcXG4gIC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzczogIDtcXHJcXG4gIC0tdHctYmFja2Ryb3AtY29udHJhc3Q6ICA7XFxyXFxuICAtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZTogIDtcXHJcXG4gIC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZTogIDtcXHJcXG4gIC0tdHctYmFja2Ryb3AtaW52ZXJ0OiAgO1xcclxcbiAgLS10dy1iYWNrZHJvcC1vcGFjaXR5OiAgO1xcclxcbiAgLS10dy1iYWNrZHJvcC1zYXR1cmF0ZTogIDtcXHJcXG4gIC0tdHctYmFja2Ryb3Atc2VwaWE6ICA7XFxyXFxufVxcclxcbi5wb2ludGVyLWV2ZW50cy1ub25lIHtcXHJcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG4uZml4ZWQge1xcclxcbiAgcG9zaXRpb246IGZpeGVkO1xcclxcbn1cXHJcXG4uYWJzb2x1dGUge1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG4ucmVsYXRpdmUge1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbn1cXHJcXG4uLXRvcC0zIHtcXHJcXG4gIHRvcDogLTAuNzVyZW07XFxyXFxufVxcclxcbi4tdG9wLTUge1xcclxcbiAgdG9wOiAtMS4yNXJlbTtcXHJcXG59XFxyXFxuLi10b3AtMTYge1xcclxcbiAgdG9wOiAtNHJlbTtcXHJcXG59XFxyXFxuLmJvdHRvbS1cXFxcWzE2XFxcXC4ycmVtXFxcXF0ge1xcclxcbiAgYm90dG9tOiAxNi4ycmVtO1xcclxcbn1cXHJcXG4ucmlnaHQtMCB7XFxyXFxuICByaWdodDogMHB4O1xcclxcbn1cXHJcXG4ucmlnaHQtMjQge1xcclxcbiAgcmlnaHQ6IDZyZW07XFxyXFxufVxcclxcbi5sZWZ0LTFcXFxcLzIge1xcclxcbiAgbGVmdDogNTAlO1xcclxcbn1cXHJcXG4ucmlnaHQtMVxcXFwvMiB7XFxyXFxuICByaWdodDogNTAlO1xcclxcbn1cXHJcXG4uYm90dG9tLTM2IHtcXHJcXG4gIGJvdHRvbTogOXJlbTtcXHJcXG59XFxyXFxuLnRvcC1cXFxcWzg1XFxcXCVcXFxcXSB7XFxyXFxuICB0b3A6IDg1JTtcXHJcXG59XFxyXFxuLmJvdHRvbS1cXFxcWzE3XFxcXC4ycmVtXFxcXF0ge1xcclxcbiAgYm90dG9tOiAxNy4ycmVtO1xcclxcbn1cXHJcXG4uYm90dG9tLTAge1xcclxcbiAgYm90dG9tOiAwcHg7XFxyXFxufVxcclxcbi50b3AtMCB7XFxyXFxuICB0b3A6IDBweDtcXHJcXG59XFxyXFxuLnJpZ2h0LTkge1xcclxcbiAgcmlnaHQ6IDIuMjVyZW07XFxyXFxufVxcclxcbi5sZWZ0LTAge1xcclxcbiAgbGVmdDogMHB4O1xcclxcbn1cXHJcXG4uei0xMCB7XFxyXFxuICB6LWluZGV4OiAxMDtcXHJcXG59XFxyXFxuLnotMjAge1xcclxcbiAgei1pbmRleDogMjA7XFxyXFxufVxcclxcbi5jb2wtc3Bhbi0yIHtcXHJcXG4gIGdyaWQtY29sdW1uOiBzcGFuIDIgLyBzcGFuIDI7XFxyXFxufVxcclxcbi5jb2wtc3Bhbi0zIHtcXHJcXG4gIGdyaWQtY29sdW1uOiBzcGFuIDMgLyBzcGFuIDM7XFxyXFxufVxcclxcbi5jb2wtc3Bhbi0xMiB7XFxyXFxuICBncmlkLWNvbHVtbjogc3BhbiAxMiAvIHNwYW4gMTI7XFxyXFxufVxcclxcbi5jb2wtc3Bhbi0xMCB7XFxyXFxuICBncmlkLWNvbHVtbjogc3BhbiAxMCAvIHNwYW4gMTA7XFxyXFxufVxcclxcbi5jb2wtc3Bhbi00IHtcXHJcXG4gIGdyaWQtY29sdW1uOiBzcGFuIDQgLyBzcGFuIDQ7XFxyXFxufVxcclxcbi5jb2wtc3Bhbi02IHtcXHJcXG4gIGdyaWQtY29sdW1uOiBzcGFuIDYgLyBzcGFuIDY7XFxyXFxufVxcclxcbi5jb2wtc3Bhbi03IHtcXHJcXG4gIGdyaWQtY29sdW1uOiBzcGFuIDcgLyBzcGFuIDc7XFxyXFxufVxcclxcbi5yb3ctc3Bhbi0zIHtcXHJcXG4gIGdyaWQtcm93OiBzcGFuIDMgLyBzcGFuIDM7XFxyXFxufVxcclxcbi5teS0yIHtcXHJcXG4gIG1hcmdpbi10b3A6IDAuNXJlbTtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXHJcXG59XFxyXFxuLm14LWF1dG8ge1xcclxcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxyXFxuICBtYXJnaW4tcmlnaHQ6IGF1dG87XFxyXFxufVxcclxcbi5teC0zIHtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAwLjc1cmVtO1xcclxcbiAgbWFyZ2luLXJpZ2h0OiAwLjc1cmVtO1xcclxcbn1cXHJcXG4ubXgtNSB7XFxyXFxuICBtYXJnaW4tbGVmdDogMS4yNXJlbTtcXHJcXG4gIG1hcmdpbi1yaWdodDogMS4yNXJlbTtcXHJcXG59XFxyXFxuLm14LTEge1xcclxcbiAgbWFyZ2luLWxlZnQ6IDAuMjVyZW07XFxyXFxuICBtYXJnaW4tcmlnaHQ6IDAuMjVyZW07XFxyXFxufVxcclxcbi5teS0xIHtcXHJcXG4gIG1hcmdpbi10b3A6IDAuMjVyZW07XFxyXFxuICBtYXJnaW4tYm90dG9tOiAwLjI1cmVtO1xcclxcbn1cXHJcXG4ubXgtMiB7XFxyXFxuICBtYXJnaW4tbGVmdDogMC41cmVtO1xcclxcbiAgbWFyZ2luLXJpZ2h0OiAwLjVyZW07XFxyXFxufVxcclxcbi5teS03IHtcXHJcXG4gIG1hcmdpbi10b3A6IDEuNzVyZW07XFxyXFxuICBtYXJnaW4tYm90dG9tOiAxLjc1cmVtO1xcclxcbn1cXHJcXG4ubXgtXFxcXFswXFxcXC4zNXJlbVxcXFxdIHtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAwLjM1cmVtO1xcclxcbiAgbWFyZ2luLXJpZ2h0OiAwLjM1cmVtO1xcclxcbn1cXHJcXG4ubXktMyB7XFxyXFxuICBtYXJnaW4tdG9wOiAwLjc1cmVtO1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMC43NXJlbTtcXHJcXG59XFxyXFxuLm14LTEwIHtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAyLjVyZW07XFxyXFxuICBtYXJnaW4tcmlnaHQ6IDIuNXJlbTtcXHJcXG59XFxyXFxuLm14LTgge1xcclxcbiAgbWFyZ2luLWxlZnQ6IDJyZW07XFxyXFxuICBtYXJnaW4tcmlnaHQ6IDJyZW07XFxyXFxufVxcclxcbi5teS0xMiB7XFxyXFxuICBtYXJnaW4tdG9wOiAzcmVtO1xcclxcbiAgbWFyZ2luLWJvdHRvbTogM3JlbTtcXHJcXG59XFxyXFxuLm10LTE2IHtcXHJcXG4gIG1hcmdpbi10b3A6IDRyZW07XFxyXFxufVxcclxcbi5tdC0xMiB7XFxyXFxuICBtYXJnaW4tdG9wOiAzcmVtO1xcclxcbn1cXHJcXG4ubXQtOCB7XFxyXFxuICBtYXJnaW4tdG9wOiAycmVtO1xcclxcbn1cXHJcXG4ubXQtMiB7XFxyXFxuICBtYXJnaW4tdG9wOiAwLjVyZW07XFxyXFxufVxcclxcbi5tci01IHtcXHJcXG4gIG1hcmdpbi1yaWdodDogMS4yNXJlbTtcXHJcXG59XFxyXFxuLm10LTUge1xcclxcbiAgbWFyZ2luLXRvcDogMS4yNXJlbTtcXHJcXG59XFxyXFxuLi1tdC0xNCB7XFxyXFxuICBtYXJnaW4tdG9wOiAtMy41cmVtO1xcclxcbn1cXHJcXG4uLW1iLTUge1xcclxcbiAgbWFyZ2luLWJvdHRvbTogLTEuMjVyZW07XFxyXFxufVxcclxcbi5tYi01IHtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDEuMjVyZW07XFxyXFxufVxcclxcbi5tdC0zIHtcXHJcXG4gIG1hcmdpbi10b3A6IDAuNzVyZW07XFxyXFxufVxcclxcbi5tdC0xMCB7XFxyXFxuICBtYXJnaW4tdG9wOiAyLjVyZW07XFxyXFxufVxcclxcbi5tdC03IHtcXHJcXG4gIG1hcmdpbi10b3A6IDEuNzVyZW07XFxyXFxufVxcclxcbi5tYi0xMCB7XFxyXFxuICBtYXJnaW4tYm90dG9tOiAyLjVyZW07XFxyXFxufVxcclxcbi5tdC0xIHtcXHJcXG4gIG1hcmdpbi10b3A6IDAuMjVyZW07XFxyXFxufVxcclxcbi5tdC00IHtcXHJcXG4gIG1hcmdpbi10b3A6IDFyZW07XFxyXFxufVxcclxcbi5tbC0xIHtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAwLjI1cmVtO1xcclxcbn1cXHJcXG4ubWItNyB7XFxyXFxuICBtYXJnaW4tYm90dG9tOiAxLjc1cmVtO1xcclxcbn1cXHJcXG4ubWItMiB7XFxyXFxuICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxyXFxufVxcclxcbi5tci0xNiB7XFxyXFxuICBtYXJnaW4tcmlnaHQ6IDRyZW07XFxyXFxufVxcclxcbi5tbC01IHtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAxLjI1cmVtO1xcclxcbn1cXHJcXG4ubXQtXFxcXFsxNXB4XFxcXF0ge1xcclxcbiAgbWFyZ2luLXRvcDogMTVweDtcXHJcXG59XFxyXFxuLm10LVxcXFxbMFxcXFwuOHB4XFxcXF0ge1xcclxcbiAgbWFyZ2luLXRvcDogMC44cHg7XFxyXFxufVxcclxcbi5tdC02IHtcXHJcXG4gIG1hcmdpbi10b3A6IDEuNXJlbTtcXHJcXG59XFxyXFxuLm1iLTQge1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXHJcXG59XFxyXFxuLi1tYi0xIHtcXHJcXG4gIG1hcmdpbi1ib3R0b206IC0wLjI1cmVtO1xcclxcbn1cXHJcXG4uLW1sLVxcXFxbMTAwXFxcXCVcXFxcXSB7XFxyXFxuICBtYXJnaW4tbGVmdDogLTEwMCU7XFxyXFxufVxcclxcbi4tbWwtXFxcXFswXFxcXCVcXFxcXSB7XFxyXFxuICBtYXJnaW4tbGVmdDogLTAlO1xcclxcbn1cXHJcXG4uLW1sLVxcXFxbMjAwXFxcXCVcXFxcXSB7XFxyXFxuICBtYXJnaW4tbGVmdDogLTIwMCU7XFxyXFxufVxcclxcbi4tbWwtXFxcXFszMDBcXFxcJVxcXFxdIHtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAtMzAwJTtcXHJcXG59XFxyXFxuLi1tbC1cXFxcWzUwdndcXFxcXSB7XFxyXFxuICBtYXJnaW4tbGVmdDogLTUwdnc7XFxyXFxufVxcclxcbi4tbXItXFxcXFs1MHZ3XFxcXF0ge1xcclxcbiAgbWFyZ2luLXJpZ2h0OiAtNTB2dztcXHJcXG59XFxyXFxuLm1yLVxcXFxbMFxcXFwuMzVyZW1cXFxcXSB7XFxyXFxuICBtYXJnaW4tcmlnaHQ6IDAuMzVyZW07XFxyXFxufVxcclxcbi5tbC0zIHtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAwLjc1cmVtO1xcclxcbn1cXHJcXG4ubXItMyB7XFxyXFxuICBtYXJnaW4tcmlnaHQ6IDAuNzVyZW07XFxyXFxufVxcclxcbi5tYi0xIHtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDAuMjVyZW07XFxyXFxufVxcclxcbi5tYi04IHtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDJyZW07XFxyXFxufVxcclxcbi5ibG9jayB7XFxyXFxuICBkaXNwbGF5OiBibG9jaztcXHJcXG59XFxyXFxuLmlubGluZS1ibG9jayB7XFxyXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxufVxcclxcbi5mbGV4IHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxufVxcclxcbi5pbmxpbmUtZmxleCB7XFxyXFxuICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXHJcXG59XFxyXFxuLnRhYmxlIHtcXHJcXG4gIGRpc3BsYXk6IHRhYmxlO1xcclxcbn1cXHJcXG4uZ3JpZCB7XFxyXFxuICBkaXNwbGF5OiBncmlkO1xcclxcbn1cXHJcXG4uaGlkZGVuIHtcXHJcXG4gIGRpc3BsYXk6IG5vbmU7XFxyXFxufVxcclxcbi5hc3BlY3Qtc3F1YXJlIHtcXHJcXG4gIGFzcGVjdC1yYXRpbzogMSAvIDE7XFxyXFxufVxcclxcbi5oLTUge1xcclxcbiAgaGVpZ2h0OiAxLjI1cmVtO1xcclxcbn1cXHJcXG4uaC0yNCB7XFxyXFxuICBoZWlnaHQ6IDZyZW07XFxyXFxufVxcclxcbi5oLTcyIHtcXHJcXG4gIGhlaWdodDogMThyZW07XFxyXFxufVxcclxcbi5oLWZpdCB7XFxyXFxuICBoZWlnaHQ6IC13ZWJraXQtZml0LWNvbnRlbnQ7XFxyXFxuICBoZWlnaHQ6IC1tb3otZml0LWNvbnRlbnQ7XFxyXFxuICBoZWlnaHQ6IGZpdC1jb250ZW50O1xcclxcbn1cXHJcXG4uaC1cXFxcWzMzMHB4XFxcXF0ge1xcclxcbiAgaGVpZ2h0OiAzMzBweDtcXHJcXG59XFxyXFxuLmgtMTIge1xcclxcbiAgaGVpZ2h0OiAzcmVtO1xcclxcbn1cXHJcXG4uaC1tYXgge1xcclxcbiAgaGVpZ2h0OiAtd2Via2l0LW1heC1jb250ZW50O1xcclxcbiAgaGVpZ2h0OiAtbW96LW1heC1jb250ZW50O1xcclxcbiAgaGVpZ2h0OiBtYXgtY29udGVudDtcXHJcXG59XFxyXFxuLmgtXFxcXFsxOTBcXFxcXSB7XFxyXFxuICBoZWlnaHQ6IDE5MDtcXHJcXG59XFxyXFxuLmgtXFxcXFs0NjdweFxcXFxdIHtcXHJcXG4gIGhlaWdodDogNDY3cHg7XFxyXFxufVxcclxcbi5oLTYge1xcclxcbiAgaGVpZ2h0OiAxLjVyZW07XFxyXFxufVxcclxcbi5oLWZ1bGwge1xcclxcbiAgaGVpZ2h0OiAxMDAlO1xcclxcbn1cXHJcXG4uaC1cXFxcWzMwcHhcXFxcXSB7XFxyXFxuICBoZWlnaHQ6IDMwcHg7XFxyXFxufVxcclxcbi5oLTU2IHtcXHJcXG4gIGhlaWdodDogMTRyZW07XFxyXFxufVxcclxcbi5oLVxcXFxbNDV2aFxcXFxdIHtcXHJcXG4gIGhlaWdodDogNDV2aDtcXHJcXG59XFxyXFxuLmgtXFxcXFsyNTBweFxcXFxdIHtcXHJcXG4gIGhlaWdodDogMjUwcHg7XFxyXFxufVxcclxcbi5oLTQge1xcclxcbiAgaGVpZ2h0OiAxcmVtO1xcclxcbn1cXHJcXG4uaC1cXFxcWzE2NnB4XFxcXF0ge1xcclxcbiAgaGVpZ2h0OiAxNjZweDtcXHJcXG59XFxyXFxuLmgtXFxcXFsxOTlcXFxcLjY5cHhcXFxcXSB7XFxyXFxuICBoZWlnaHQ6IDE5OS42OXB4O1xcclxcbn1cXHJcXG4uaC1cXFxcWzYwcHhcXFxcXSB7XFxyXFxuICBoZWlnaHQ6IDYwcHg7XFxyXFxufVxcclxcbi5oLTQ4IHtcXHJcXG4gIGhlaWdodDogMTJyZW07XFxyXFxufVxcclxcbi5tYXgtaC1maXQge1xcclxcbiAgbWF4LWhlaWdodDogLXdlYmtpdC1maXQtY29udGVudDtcXHJcXG4gIG1heC1oZWlnaHQ6IC1tb3otZml0LWNvbnRlbnQ7XFxyXFxuICBtYXgtaGVpZ2h0OiBmaXQtY29udGVudDtcXHJcXG59XFxyXFxuLm1heC1oLVxcXFxbMjUwcHhcXFxcXSB7XFxyXFxuICBtYXgtaGVpZ2h0OiAyNTBweDtcXHJcXG59XFxyXFxuLm1heC1oLVxcXFxbMjRweFxcXFxdIHtcXHJcXG4gIG1heC1oZWlnaHQ6IDI0cHg7XFxyXFxufVxcclxcbi5taW4taC1zY3JlZW4ge1xcclxcbiAgbWluLWhlaWdodDogMTAwdmg7XFxyXFxufVxcclxcbi5taW4taC1cXFxcWzEwMHZoXFxcXF0ge1xcclxcbiAgbWluLWhlaWdodDogMTAwdmg7XFxyXFxufVxcclxcbi5taW4taC1cXFxcWzMzMHB4XFxcXF0ge1xcclxcbiAgbWluLWhlaWdodDogMzMwcHg7XFxyXFxufVxcclxcbi5taW4taC1cXFxcWzIxM3B4XFxcXF0ge1xcclxcbiAgbWluLWhlaWdodDogMjEzcHg7XFxyXFxufVxcclxcbi53LWZ1bGwge1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxufVxcclxcbi53LTUge1xcclxcbiAgd2lkdGg6IDEuMjVyZW07XFxyXFxufVxcclxcbi53LTNcXFxcLzQge1xcclxcbiAgd2lkdGg6IDc1JTtcXHJcXG59XFxyXFxuLnctMjQge1xcclxcbiAgd2lkdGg6IDZyZW07XFxyXFxufVxcclxcbi53LTgge1xcclxcbiAgd2lkdGg6IDJyZW07XFxyXFxufVxcclxcbi53LVxcXFxbOTB2d1xcXFxdIHtcXHJcXG4gIHdpZHRoOiA5MHZ3O1xcclxcbn1cXHJcXG4udy0xMiB7XFxyXFxuICB3aWR0aDogM3JlbTtcXHJcXG59XFxyXFxuLnctXFxcXFs0OFxcXFwlXFxcXF0ge1xcclxcbiAgd2lkdGg6IDQ4JTtcXHJcXG59XFxyXFxuLnctZml0IHtcXHJcXG4gIHdpZHRoOiAtd2Via2l0LWZpdC1jb250ZW50O1xcclxcbiAgd2lkdGg6IC1tb3otZml0LWNvbnRlbnQ7XFxyXFxuICB3aWR0aDogZml0LWNvbnRlbnQ7XFxyXFxufVxcclxcbi53LTJcXFxcLzMge1xcclxcbiAgd2lkdGg6IDY2LjY2NjY2NyU7XFxyXFxufVxcclxcbi53LVxcXFxbMTQ0cHhcXFxcXSB7XFxyXFxuICB3aWR0aDogMTQ0cHg7XFxyXFxufVxcclxcbi53LTgwIHtcXHJcXG4gIHdpZHRoOiAyMHJlbTtcXHJcXG59XFxyXFxuLnctXFxcXFsxMDB2d1xcXFxdIHtcXHJcXG4gIHdpZHRoOiAxMDB2dztcXHJcXG59XFxyXFxuLnctNiB7XFxyXFxuICB3aWR0aDogMS41cmVtO1xcclxcbn1cXHJcXG4udy1cXFxcWzMwcHhcXFxcXSB7XFxyXFxuICB3aWR0aDogMzBweDtcXHJcXG59XFxyXFxuLnctXFxcXFszMDBcXFxcJVxcXFxdIHtcXHJcXG4gIHdpZHRoOiAzMDAlO1xcclxcbn1cXHJcXG4udy1cXFxcWzEwMFxcXFwlXFxcXF0ge1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxufVxcclxcbi53LTQge1xcclxcbiAgd2lkdGg6IDFyZW07XFxyXFxufVxcclxcbi53LVxcXFxbMTA4cHhcXFxcXSB7XFxyXFxuICB3aWR0aDogMTA4cHg7XFxyXFxufVxcclxcbi53LVxcXFxbMTQycHhcXFxcXSB7XFxyXFxuICB3aWR0aDogMTQycHg7XFxyXFxufVxcclxcbi53LVxcXFxbNFxcXFwuMnJlbVxcXFxdIHtcXHJcXG4gIHdpZHRoOiA0LjJyZW07XFxyXFxufVxcclxcbi53LTIwIHtcXHJcXG4gIHdpZHRoOiA1cmVtO1xcclxcbn1cXHJcXG4udy0yXFxcXC80IHtcXHJcXG4gIHdpZHRoOiA1MCU7XFxyXFxufVxcclxcbi5taW4tdy1cXFxcWzMwMHB4XFxcXF0ge1xcclxcbiAgbWluLXdpZHRoOiAzMDBweDtcXHJcXG59XFxyXFxuLm1pbi13LVxcXFxbNTBweFxcXFxdIHtcXHJcXG4gIG1pbi13aWR0aDogNTBweDtcXHJcXG59XFxyXFxuLm1pbi13LVxcXFxbNzhweFxcXFxdIHtcXHJcXG4gIG1pbi13aWR0aDogNzhweDtcXHJcXG59XFxyXFxuLm1pbi13LVxcXFxbMTA4cHhcXFxcXSB7XFxyXFxuICBtaW4td2lkdGg6IDEwOHB4O1xcclxcbn1cXHJcXG4ubWluLXctXFxcXFsyNnB4XFxcXF0ge1xcclxcbiAgbWluLXdpZHRoOiAyNnB4O1xcclxcbn1cXHJcXG4ubWF4LXctXFxcXFsxMjAwcHhcXFxcXSB7XFxyXFxuICBtYXgtd2lkdGg6IDEyMDBweDtcXHJcXG59XFxyXFxuLm1heC13LVxcXFxbMTUwMHB4XFxcXF0ge1xcclxcbiAgbWF4LXdpZHRoOiAxNTAwcHg7XFxyXFxufVxcclxcbi5tYXgtdy1cXFxcWzEzMDBweFxcXFxdIHtcXHJcXG4gIG1heC13aWR0aDogMTMwMHB4O1xcclxcbn1cXHJcXG4ubWF4LXctXFxcXFsxMTAwcHhcXFxcXSB7XFxyXFxuICBtYXgtd2lkdGg6IDExMDBweDtcXHJcXG59XFxyXFxuLm1heC13LVxcXFxbNTgxcHhcXFxcXSB7XFxyXFxuICBtYXgtd2lkdGg6IDU4MXB4O1xcclxcbn1cXHJcXG4uLXRyYW5zbGF0ZS14LTFcXFxcLzIge1xcclxcbiAgLS10dy10cmFuc2xhdGUteDogLTUwJTtcXHJcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xcclxcbn1cXHJcXG4uY3Vyc29yLXBvaW50ZXIge1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG4uc2VsZWN0LW5vbmUge1xcclxcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG4gICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcclxcbn1cXHJcXG4uYXBwZWFyYW5jZS1ub25lIHtcXHJcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXHJcXG4gICAgIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXHJcXG4gICAgICAgICAgYXBwZWFyYW5jZTogbm9uZTtcXHJcXG59XFxyXFxuLmdyaWQtY29scy0yIHtcXHJcXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDIsIG1pbm1heCgwLCAxZnIpKTtcXHJcXG59XFxyXFxuLmdyaWQtY29scy0xIHtcXHJcXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDEsIG1pbm1heCgwLCAxZnIpKTtcXHJcXG59XFxyXFxuLmdyaWQtY29scy00IHtcXHJcXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDQsIG1pbm1heCgwLCAxZnIpKTtcXHJcXG59XFxyXFxuLmdyaWQtY29scy0xMiB7XFxyXFxuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgxMiwgbWlubWF4KDAsIDFmcikpO1xcclxcbn1cXHJcXG4uZ3JpZC1jb2xzLTEwIHtcXHJcXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDEwLCBtaW5tYXgoMCwgMWZyKSk7XFxyXFxufVxcclxcbi5mbGV4LWNvbCB7XFxyXFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbn1cXHJcXG4uZmxleC13cmFwIHtcXHJcXG4gIGZsZXgtd3JhcDogd3JhcDtcXHJcXG59XFxyXFxuLnBsYWNlLWNvbnRlbnQtYmV0d2VlbiB7XFxyXFxuICBwbGFjZS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcclxcbn1cXHJcXG4uaXRlbXMtZW5kIHtcXHJcXG4gIGFsaWduLWl0ZW1zOiBmbGV4LWVuZDtcXHJcXG59XFxyXFxuLml0ZW1zLWNlbnRlciB7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbn1cXHJcXG4uanVzdGlmeS1lbmQge1xcclxcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXHJcXG59XFxyXFxuLmp1c3RpZnktY2VudGVyIHtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbn1cXHJcXG4uanVzdGlmeS1iZXR3ZWVuIHtcXHJcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXHJcXG59XFxyXFxuLmdhcC0zIHtcXHJcXG4gIGdhcDogMC43NXJlbTtcXHJcXG59XFxyXFxuLmdhcC0xMCB7XFxyXFxuICBnYXA6IDIuNXJlbTtcXHJcXG59XFxyXFxuLmdhcC00IHtcXHJcXG4gIGdhcDogMXJlbTtcXHJcXG59XFxyXFxuLnNwYWNlLXktNCA+IDpub3QoW2hpZGRlbl0pIH4gOm5vdChbaGlkZGVuXSkge1xcclxcbiAgLS10dy1zcGFjZS15LXJldmVyc2U6IDA7XFxyXFxuICBtYXJnaW4tdG9wOiBjYWxjKDFyZW0gKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKSk7XFxyXFxuICBtYXJnaW4tYm90dG9tOiBjYWxjKDFyZW0gKiB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKTtcXHJcXG59XFxyXFxuLnNwYWNlLXgtMyA+IDpub3QoW2hpZGRlbl0pIH4gOm5vdChbaGlkZGVuXSkge1xcclxcbiAgLS10dy1zcGFjZS14LXJldmVyc2U6IDA7XFxyXFxuICBtYXJnaW4tcmlnaHQ6IGNhbGMoMC43NXJlbSAqIHZhcigtLXR3LXNwYWNlLXgtcmV2ZXJzZSkpO1xcclxcbiAgbWFyZ2luLWxlZnQ6IGNhbGMoMC43NXJlbSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXgtcmV2ZXJzZSkpKTtcXHJcXG59XFxyXFxuLnNwYWNlLXgtMiA+IDpub3QoW2hpZGRlbl0pIH4gOm5vdChbaGlkZGVuXSkge1xcclxcbiAgLS10dy1zcGFjZS14LXJldmVyc2U6IDA7XFxyXFxuICBtYXJnaW4tcmlnaHQ6IGNhbGMoMC41cmVtICogdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSk7XFxyXFxuICBtYXJnaW4tbGVmdDogY2FsYygwLjVyZW0gKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKSk7XFxyXFxufVxcclxcbi5zcGFjZS14LTUgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXHJcXG4gIC0tdHctc3BhY2UteC1yZXZlcnNlOiAwO1xcclxcbiAgbWFyZ2luLXJpZ2h0OiBjYWxjKDEuMjVyZW0gKiB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKTtcXHJcXG4gIG1hcmdpbi1sZWZ0OiBjYWxjKDEuMjVyZW0gKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKSk7XFxyXFxufVxcclxcbi5zcGFjZS14LTggPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXHJcXG4gIC0tdHctc3BhY2UteC1yZXZlcnNlOiAwO1xcclxcbiAgbWFyZ2luLXJpZ2h0OiBjYWxjKDJyZW0gKiB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKTtcXHJcXG4gIG1hcmdpbi1sZWZ0OiBjYWxjKDJyZW0gKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKSk7XFxyXFxufVxcclxcbi5kaXZpZGUtc29saWQgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXHJcXG4gIGJvcmRlci1zdHlsZTogc29saWQ7XFxyXFxufVxcclxcbi5vdmVyZmxvdy1oaWRkZW4ge1xcclxcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG59XFxyXFxuLm92ZXJmbG93LXgtYXV0byB7XFxyXFxuICBvdmVyZmxvdy14OiBhdXRvO1xcclxcbn1cXHJcXG4ud2hpdGVzcGFjZS1ub3dyYXAge1xcclxcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXHJcXG59XFxyXFxuLndoaXRlc3BhY2UtcHJlLXdyYXAge1xcclxcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcclxcbn1cXHJcXG4ucm91bmRlZC1tZCB7XFxyXFxuICBib3JkZXItcmFkaXVzOiAwLjM3NXJlbTtcXHJcXG59XFxyXFxuLnJvdW5kZWQtM3hsIHtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDEuNXJlbTtcXHJcXG59XFxyXFxuLnJvdW5kZWQteGwge1xcclxcbiAgYm9yZGVyLXJhZGl1czogMC43NXJlbTtcXHJcXG59XFxyXFxuLnJvdW5kZWQtZnVsbCB7XFxyXFxuICBib3JkZXItcmFkaXVzOiA5OTk5cHg7XFxyXFxufVxcclxcbi5yb3VuZGVkLWxnIHtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDAuNXJlbTtcXHJcXG59XFxyXFxuLnJvdW5kZWQge1xcclxcbiAgYm9yZGVyLXJhZGl1czogMC4yNXJlbTtcXHJcXG59XFxyXFxuLnJvdW5kZWQtbC1tZCB7XFxyXFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwLjM3NXJlbTtcXHJcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDAuMzc1cmVtO1xcclxcbn1cXHJcXG4ucm91bmRlZC1sLW5vbmUge1xcclxcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMHB4O1xcclxcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMHB4O1xcclxcbn1cXHJcXG4uYm9yZGVyIHtcXHJcXG4gIGJvcmRlci13aWR0aDogMXB4O1xcclxcbn1cXHJcXG4uYm9yZGVyLVxcXFxbMFxcXFwuNXB4XFxcXF0ge1xcclxcbiAgYm9yZGVyLXdpZHRoOiAwLjVweDtcXHJcXG59XFxyXFxuLmJvcmRlci0yIHtcXHJcXG4gIGJvcmRlci13aWR0aDogMnB4O1xcclxcbn1cXHJcXG4uYm9yZGVyLVxcXFxbMXB4XFxcXF0ge1xcclxcbiAgYm9yZGVyLXdpZHRoOiAxcHg7XFxyXFxufVxcclxcbi5ib3JkZXItNCB7XFxyXFxuICBib3JkZXItd2lkdGg6IDRweDtcXHJcXG59XFxyXFxuLmJvcmRlci1iIHtcXHJcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDtcXHJcXG59XFxyXFxuLmJvcmRlci1iLTIge1xcclxcbiAgYm9yZGVyLWJvdHRvbS13aWR0aDogMnB4O1xcclxcbn1cXHJcXG4uYm9yZGVyLXQge1xcclxcbiAgYm9yZGVyLXRvcC13aWR0aDogMXB4O1xcclxcbn1cXHJcXG4uYm9yZGVyLWItXFxcXFsxcHhcXFxcXSB7XFxyXFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAxcHg7XFxyXFxufVxcclxcbi5ib3JkZXItdC0yIHtcXHJcXG4gIGJvcmRlci10b3Atd2lkdGg6IDJweDtcXHJcXG59XFxyXFxuLmJvcmRlci10LVxcXFxbMXB4XFxcXF0ge1xcclxcbiAgYm9yZGVyLXRvcC13aWR0aDogMXB4O1xcclxcbn1cXHJcXG4uYm9yZGVyLXItMCB7XFxyXFxuICBib3JkZXItcmlnaHQtd2lkdGg6IDBweDtcXHJcXG59XFxyXFxuLmJvcmRlci1zb2xpZCB7XFxyXFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcclxcbn1cXHJcXG4uYm9yZGVyLWRhc2hlZCB7XFxyXFxuICBib3JkZXItc3R5bGU6IGRhc2hlZDtcXHJcXG59XFxyXFxuLmJvcmRlci1ibHVlLTQwMCB7XFxyXFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcclxcbiAgYm9yZGVyLWNvbG9yOiByZ2IoOTYgMTY1IDI1MCAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5ib3JkZXItdHJhbnNwYXJlbnQge1xcclxcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXHJcXG59XFxyXFxuLmJvcmRlci1ncmF5LTMwMCB7XFxyXFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcclxcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMjA5IDIxMyAyMTkgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uYm9yZGVyLVxcXFxbXFxcXCNCQkJCQkJcXFxcXSB7XFxyXFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcclxcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMTg3IDE4NyAxODcgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uYm9yZGVyLVxcXFxbXFxcXCNlMmUyZTJcXFxcXSB7XFxyXFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcclxcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMjI2IDIyNiAyMjYgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uYm9yZGVyLWJsdWUtODAwIHtcXHJcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxyXFxuICBib3JkZXItY29sb3I6IHJnYigzMCA2NCAxNzUgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uYmctd2hpdGUge1xcclxcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uYmctc2xhdGUtNDAwIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigxNDggMTYzIDE4NCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLmJnLWJsdWUtNTAwIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uYmctemluYy0zMDAge1xcclxcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIxMiAyMTIgMjE2IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uYmctemluYy00MDAge1xcclxcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDE2MSAxNjEgMTcwIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uYmcteWVsbG93LTUwMCB7XFxyXFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjM0IDE3OSA4IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uYmctaW5kaWdvLTUwMCB7XFxyXFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoOTkgMTAyIDI0MSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLmJnLXRlYWwtNTAwIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMCAxODQgMTY2IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uYmctYmx1ZS0yMDAge1xcclxcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDE5MSAyMTkgMjU0IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uYmctXFxcXFtcXFxcIzNENDE0RFxcXFxdIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYig2MSA2NSA3NyAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLmJnLWdyYXktMjAwIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMjkgMjMxIDIzNSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLmJnLWJsYWNrIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigwIDAgMCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLmJnLXJlZC0yMDAge1xcclxcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1NCAyMDIgMjAyIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uYmctc2xhdGUtMzAwIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMDMgMjEzIDIyNSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLmJnLXNsYXRlLTEwMCB7XFxyXFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjQxIDI0NSAyNDkgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5iZy1ncmF5LTUwIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNDkgMjUwIDI1MSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLm9iamVjdC1jb3ZlciB7XFxyXFxuICAtby1vYmplY3QtZml0OiBjb3ZlcjtcXHJcXG4gICAgIG9iamVjdC1maXQ6IGNvdmVyO1xcclxcbn1cXHJcXG4ucC02IHtcXHJcXG4gIHBhZGRpbmc6IDEuNXJlbTtcXHJcXG59XFxyXFxuLnAtMyB7XFxyXFxuICBwYWRkaW5nOiAwLjc1cmVtO1xcclxcbn1cXHJcXG4ucC0yIHtcXHJcXG4gIHBhZGRpbmc6IDAuNXJlbTtcXHJcXG59XFxyXFxuLnAtXFxcXFswXFxcXC4xMnJlbVxcXFxdIHtcXHJcXG4gIHBhZGRpbmc6IDAuMTJyZW07XFxyXFxufVxcclxcbi5wLTEge1xcclxcbiAgcGFkZGluZzogMC4yNXJlbTtcXHJcXG59XFxyXFxuLnAtXFxcXFswXFxcXC4ycmVtXFxcXF0ge1xcclxcbiAgcGFkZGluZzogMC4ycmVtO1xcclxcbn1cXHJcXG4ucC0wIHtcXHJcXG4gIHBhZGRpbmc6IDBweDtcXHJcXG59XFxyXFxuLnB4LTQge1xcclxcbiAgcGFkZGluZy1sZWZ0OiAxcmVtO1xcclxcbiAgcGFkZGluZy1yaWdodDogMXJlbTtcXHJcXG59XFxyXFxuLnB4LTIge1xcclxcbiAgcGFkZGluZy1sZWZ0OiAwLjVyZW07XFxyXFxuICBwYWRkaW5nLXJpZ2h0OiAwLjVyZW07XFxyXFxufVxcclxcbi5weS0yIHtcXHJcXG4gIHBhZGRpbmctdG9wOiAwLjVyZW07XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMC41cmVtO1xcclxcbn1cXHJcXG4ucHktNCB7XFxyXFxuICBwYWRkaW5nLXRvcDogMXJlbTtcXHJcXG4gIHBhZGRpbmctYm90dG9tOiAxcmVtO1xcclxcbn1cXHJcXG4ucHktMjAge1xcclxcbiAgcGFkZGluZy10b3A6IDVyZW07XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogNXJlbTtcXHJcXG59XFxyXFxuLnB4LTIwIHtcXHJcXG4gIHBhZGRpbmctbGVmdDogNXJlbTtcXHJcXG4gIHBhZGRpbmctcmlnaHQ6IDVyZW07XFxyXFxufVxcclxcbi5weC04IHtcXHJcXG4gIHBhZGRpbmctbGVmdDogMnJlbTtcXHJcXG4gIHBhZGRpbmctcmlnaHQ6IDJyZW07XFxyXFxufVxcclxcbi5weS0zIHtcXHJcXG4gIHBhZGRpbmctdG9wOiAwLjc1cmVtO1xcclxcbiAgcGFkZGluZy1ib3R0b206IDAuNzVyZW07XFxyXFxufVxcclxcbi5weC0zIHtcXHJcXG4gIHBhZGRpbmctbGVmdDogMC43NXJlbTtcXHJcXG4gIHBhZGRpbmctcmlnaHQ6IDAuNzVyZW07XFxyXFxufVxcclxcbi5weC0xIHtcXHJcXG4gIHBhZGRpbmctbGVmdDogMC4yNXJlbTtcXHJcXG4gIHBhZGRpbmctcmlnaHQ6IDAuMjVyZW07XFxyXFxufVxcclxcbi5weS1cXFxcWzVweFxcXFxdIHtcXHJcXG4gIHBhZGRpbmctdG9wOiA1cHg7XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogNXB4O1xcclxcbn1cXHJcXG4ucHktNSB7XFxyXFxuICBwYWRkaW5nLXRvcDogMS4yNXJlbTtcXHJcXG4gIHBhZGRpbmctYm90dG9tOiAxLjI1cmVtO1xcclxcbn1cXHJcXG4ucHgtMTAge1xcclxcbiAgcGFkZGluZy1sZWZ0OiAyLjVyZW07XFxyXFxuICBwYWRkaW5nLXJpZ2h0OiAyLjVyZW07XFxyXFxufVxcclxcbi5weS0xIHtcXHJcXG4gIHBhZGRpbmctdG9wOiAwLjI1cmVtO1xcclxcbiAgcGFkZGluZy1ib3R0b206IDAuMjVyZW07XFxyXFxufVxcclxcbi5wYi00IHtcXHJcXG4gIHBhZGRpbmctYm90dG9tOiAxcmVtO1xcclxcbn1cXHJcXG4ucHQtMiB7XFxyXFxuICBwYWRkaW5nLXRvcDogMC41cmVtO1xcclxcbn1cXHJcXG4ucGItMTQge1xcclxcbiAgcGFkZGluZy1ib3R0b206IDMuNXJlbTtcXHJcXG59XFxyXFxuLnBiLVxcXFxbNjBweFxcXFxdIHtcXHJcXG4gIHBhZGRpbmctYm90dG9tOiA2MHB4O1xcclxcbn1cXHJcXG4ucGItMyB7XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMC43NXJlbTtcXHJcXG59XFxyXFxuLnB0LTEge1xcclxcbiAgcGFkZGluZy10b3A6IDAuMjVyZW07XFxyXFxufVxcclxcbi5wdC0zIHtcXHJcXG4gIHBhZGRpbmctdG9wOiAwLjc1cmVtO1xcclxcbn1cXHJcXG4ucGItMSB7XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMC4yNXJlbTtcXHJcXG59XFxyXFxuLnBiLTIge1xcclxcbiAgcGFkZGluZy1ib3R0b206IDAuNXJlbTtcXHJcXG59XFxyXFxuLnBsLTYge1xcclxcbiAgcGFkZGluZy1sZWZ0OiAxLjVyZW07XFxyXFxufVxcclxcbi5wbC0zIHtcXHJcXG4gIHBhZGRpbmctbGVmdDogMC43NXJlbTtcXHJcXG59XFxyXFxuLnBsLTcge1xcclxcbiAgcGFkZGluZy1sZWZ0OiAxLjc1cmVtO1xcclxcbn1cXHJcXG4ucHItMyB7XFxyXFxuICBwYWRkaW5nLXJpZ2h0OiAwLjc1cmVtO1xcclxcbn1cXHJcXG4udGV4dC1jZW50ZXIge1xcclxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbn1cXHJcXG4uZm9udC1zYW5zIHtcXHJcXG4gIGZvbnQtZmFtaWx5OiB1aS1zYW5zLXNlcmlmLCBzeXN0ZW0tdWksIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXFxcIlNlZ29lIFVJXFxcIiwgUm9ib3RvLCBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBBcmlhbCwgXFxcIk5vdG8gU2Fuc1xcXCIsIHNhbnMtc2VyaWYsIFxcXCJBcHBsZSBDb2xvciBFbW9qaVxcXCIsIFxcXCJTZWdvZSBVSSBFbW9qaVxcXCIsIFxcXCJTZWdvZSBVSSBTeW1ib2xcXFwiLCBcXFwiTm90byBDb2xvciBFbW9qaVxcXCI7XFxyXFxufVxcclxcbi50ZXh0LTN4bCB7XFxyXFxuICBmb250LXNpemU6IDEuODc1cmVtO1xcclxcbiAgbGluZS1oZWlnaHQ6IDIuMjVyZW07XFxyXFxufVxcclxcbi50ZXh0LXNtIHtcXHJcXG4gIGZvbnQtc2l6ZTogMC44NzVyZW07XFxyXFxuICBsaW5lLWhlaWdodDogMS4yNXJlbTtcXHJcXG59XFxyXFxuLnRleHQteGwge1xcclxcbiAgZm9udC1zaXplOiAxLjI1cmVtO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuNzVyZW07XFxyXFxufVxcclxcbi50ZXh0LTJ4bCB7XFxyXFxuICBmb250LXNpemU6IDEuNXJlbTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAycmVtO1xcclxcbn1cXHJcXG4udGV4dC14cyB7XFxyXFxuICBmb250LXNpemU6IDAuNzVyZW07XFxyXFxuICBsaW5lLWhlaWdodDogMXJlbTtcXHJcXG59XFxyXFxuLnRleHQtbGcge1xcclxcbiAgZm9udC1zaXplOiAxLjEyNXJlbTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjc1cmVtO1xcclxcbn1cXHJcXG4udGV4dC1iYXNlIHtcXHJcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjVyZW07XFxyXFxufVxcclxcbi5mb250LWJvbGQge1xcclxcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG59XFxyXFxuLmZvbnQtbWVkaXVtIHtcXHJcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxyXFxufVxcclxcbi5mb250LXNlbWlib2xkIHtcXHJcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxyXFxufVxcclxcbi51cHBlcmNhc2Uge1xcclxcbiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXHJcXG59XFxyXFxuLmxlYWRpbmctNyB7XFxyXFxuICBsaW5lLWhlaWdodDogMS43NXJlbTtcXHJcXG59XFxyXFxuLmxlYWRpbmctXFxcXFsxXFxcXC44cmVtXFxcXF0ge1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuOHJlbTtcXHJcXG59XFxyXFxuLnRleHQtZ3JheS01MDAge1xcclxcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxyXFxuICBjb2xvcjogcmdiKDEwNyAxMTQgMTI4IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi50ZXh0LWJsdWUtMzAwIHtcXHJcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcclxcbiAgY29sb3I6IHJnYigxNDcgMTk3IDI1MyAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4udGV4dC13aGl0ZSB7XFxyXFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoMjU1IDI1NSAyNTUgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLnRleHQtZ3JheS02MDAge1xcclxcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxyXFxuICBjb2xvcjogcmdiKDc1IDg1IDk5IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi50ZXh0LVxcXFxbXFxcXCM2NjY2NzZcXFxcXSB7XFxyXFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoMTAyIDEwMiAxMTggLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLnRleHQtZ3JheS00MDAge1xcclxcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxyXFxuICBjb2xvcjogcmdiKDE1NiAxNjMgMTc1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi50ZXh0LXJlZC00MDAge1xcclxcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxyXFxuICBjb2xvcjogcmdiKDI0OCAxMTMgMTEzIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi50ZXh0LWJsdWUtNTAwIHtcXHJcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcclxcbiAgY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi50ZXh0LWJsdWUtNDAwIHtcXHJcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcclxcbiAgY29sb3I6IHJnYig5NiAxNjUgMjUwIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi50ZXh0LWdyYXktNzAwIHtcXHJcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcclxcbiAgY29sb3I6IHJnYig1NSA2NSA4MSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4udGV4dC1ibGFjayB7XFxyXFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoMCAwIDAgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLnBsYWNlaG9sZGVyLWdyYXktNDAwOjotbW96LXBsYWNlaG9sZGVyIHtcXHJcXG4gIC0tdHctcGxhY2Vob2xkZXItb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoMTU2IDE2MyAxNzUgLyB2YXIoLS10dy1wbGFjZWhvbGRlci1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5wbGFjZWhvbGRlci1ncmF5LTQwMDo6cGxhY2Vob2xkZXIge1xcclxcbiAgLS10dy1wbGFjZWhvbGRlci1vcGFjaXR5OiAxO1xcclxcbiAgY29sb3I6IHJnYigxNTYgMTYzIDE3NSAvIHZhcigtLXR3LXBsYWNlaG9sZGVyLW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLm9wYWNpdHktNjAge1xcclxcbiAgb3BhY2l0eTogMC42O1xcclxcbn1cXHJcXG4uc2hhZG93LXNtIHtcXHJcXG4gIC0tdHctc2hhZG93OiAwIDFweCAycHggMCByZ2IoMCAwIDAgLyAwLjA1KTtcXHJcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMXB4IDJweCAwIHZhcigtLXR3LXNoYWRvdy1jb2xvcik7XFxyXFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXJpbmctc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1zaGFkb3cpO1xcclxcbn1cXHJcXG4uc2hhZG93LXhsIHtcXHJcXG4gIC0tdHctc2hhZG93OiAwIDIwcHggMjVweCAtNXB4IHJnYigwIDAgMCAvIDAuMSksIDAgOHB4IDEwcHggLTZweCByZ2IoMCAwIDAgLyAwLjEpO1xcclxcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAyMHB4IDI1cHggLTVweCB2YXIoLS10dy1zaGFkb3ctY29sb3IpLCAwIDhweCAxMHB4IC02cHggdmFyKC0tdHctc2hhZG93LWNvbG9yKTtcXHJcXG4gIGJveC1zaGFkb3c6IHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctcmluZy1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXNoYWRvdyk7XFxyXFxufVxcclxcbi5yaW5nLTIge1xcclxcbiAgLS10dy1yaW5nLW9mZnNldC1zaGFkb3c6IHZhcigtLXR3LXJpbmctaW5zZXQpIDAgMCAwIHZhcigtLXR3LXJpbmctb2Zmc2V0LXdpZHRoKSB2YXIoLS10dy1yaW5nLW9mZnNldC1jb2xvcik7XFxyXFxuICAtLXR3LXJpbmctc2hhZG93OiB2YXIoLS10dy1yaW5nLWluc2V0KSAwIDAgMCBjYWxjKDJweCArIHZhcigtLXR3LXJpbmctb2Zmc2V0LXdpZHRoKSkgdmFyKC0tdHctcmluZy1jb2xvcik7XFxyXFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXNoYWRvdywgMCAwICMwMDAwKTtcXHJcXG59XFxyXFxuLnJpbmcteWVsbG93LTUwMCB7XFxyXFxuICAtLXR3LXJpbmctb3BhY2l0eTogMTtcXHJcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDIzNCAxNzkgOCAvIHZhcigtLXR3LXJpbmctb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4ucmluZy1pbmRpZ28tNTAwIHtcXHJcXG4gIC0tdHctcmluZy1vcGFjaXR5OiAxO1xcclxcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoOTkgMTAyIDI0MSAvIHZhcigtLXR3LXJpbmctb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4ucmluZy10ZWFsLTUwMCB7XFxyXFxuICAtLXR3LXJpbmctb3BhY2l0eTogMTtcXHJcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDIwIDE4NCAxNjYgLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLnJpbmctZ3JheS01MDAge1xcclxcbiAgLS10dy1yaW5nLW9wYWNpdHk6IDE7XFxyXFxuICAtLXR3LXJpbmctY29sb3I6IHJnYigxMDcgMTE0IDEyOCAvIHZhcigtLXR3LXJpbmctb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4ucmluZy1ibGFjayB7XFxyXFxuICAtLXR3LXJpbmctb3BhY2l0eTogMTtcXHJcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDAgMCAwIC8gdmFyKC0tdHctcmluZy1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5yaW5nLXJlZC01MDAge1xcclxcbiAgLS10dy1yaW5nLW9wYWNpdHk6IDE7XFxyXFxuICAtLXR3LXJpbmctY29sb3I6IHJnYigyMzkgNjggNjggLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLnJpbmctYmx1ZS01MDAge1xcclxcbiAgLS10dy1yaW5nLW9wYWNpdHk6IDE7XFxyXFxuICAtLXR3LXJpbmctY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gdmFyKC0tdHctcmluZy1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5yaW5nLW9mZnNldC0yIHtcXHJcXG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDJweDtcXHJcXG59XFxyXFxuLnJpbmctb2Zmc2V0LTEge1xcclxcbiAgLS10dy1yaW5nLW9mZnNldC13aWR0aDogMXB4O1xcclxcbn1cXHJcXG4uZmlsdGVyIHtcXHJcXG4gIGZpbHRlcjogdmFyKC0tdHctYmx1cikgdmFyKC0tdHctYnJpZ2h0bmVzcykgdmFyKC0tdHctY29udHJhc3QpIHZhcigtLXR3LWdyYXlzY2FsZSkgdmFyKC0tdHctaHVlLXJvdGF0ZSkgdmFyKC0tdHctaW52ZXJ0KSB2YXIoLS10dy1zYXR1cmF0ZSkgdmFyKC0tdHctc2VwaWEpIHZhcigtLXR3LWRyb3Atc2hhZG93KTtcXHJcXG59XFxyXFxuLnRyYW5zaXRpb24ge1xcclxcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGJvcmRlci1jb2xvciwgZmlsbCwgc3Ryb2tlLCBvcGFjaXR5LCBib3gtc2hhZG93LCB0cmFuc2Zvcm0sIGZpbHRlciwgLXdlYmtpdC10ZXh0LWRlY29yYXRpb24tY29sb3IsIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyO1xcclxcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGJvcmRlci1jb2xvciwgdGV4dC1kZWNvcmF0aW9uLWNvbG9yLCBmaWxsLCBzdHJva2UsIG9wYWNpdHksIGJveC1zaGFkb3csIHRyYW5zZm9ybSwgZmlsdGVyLCBiYWNrZHJvcC1maWx0ZXI7XFxyXFxuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBjb2xvciwgYmFja2dyb3VuZC1jb2xvciwgYm9yZGVyLWNvbG9yLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIGZpbGwsIHN0cm9rZSwgb3BhY2l0eSwgYm94LXNoYWRvdywgdHJhbnNmb3JtLCBmaWx0ZXIsIGJhY2tkcm9wLWZpbHRlciwgLXdlYmtpdC10ZXh0LWRlY29yYXRpb24tY29sb3IsIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyO1xcclxcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XFxyXFxuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcXHJcXG59XFxyXFxuLnRyYW5zaXRpb24tYWxsIHtcXHJcXG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IGFsbDtcXHJcXG4gIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO1xcclxcbiAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMTUwbXM7XFxyXFxufVxcclxcbi5kdXJhdGlvbi1cXFxcWzBtc1xcXFxdIHtcXHJcXG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDBtcztcXHJcXG59XFxyXFxuLmR1cmF0aW9uLTEwMDAge1xcclxcbiAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMTAwMG1zO1xcclxcbn1cXHJcXG4ubGFzdFxcXFw6Ym9yZGVyLWItMDpsYXN0LWNoaWxkIHtcXHJcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDBweDtcXHJcXG59XFxyXFxuLm9kZFxcXFw6YmctYmx1ZS01MDpudGgtY2hpbGQob2RkKSB7XFxyXFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjM5IDI0NiAyNTUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5ob3ZlclxcXFw6Y3Vyc29yLXBvaW50ZXI6aG92ZXIge1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG4uaG92ZXJcXFxcOmJvcmRlci1ibHVlLTUwMDpob3ZlciB7XFxyXFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcclxcbiAgYm9yZGVyLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5ob3ZlclxcXFw6Ym9yZGVyLWdyYXktNDAwOmhvdmVyIHtcXHJcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxyXFxuICBib3JkZXItY29sb3I6IHJnYigxNTYgMTYzIDE3NSAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5ob3ZlclxcXFw6Ym9yZGVyLWdyYXktMzAwOmhvdmVyIHtcXHJcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxyXFxuICBib3JkZXItY29sb3I6IHJnYigyMDkgMjEzIDIxOSAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5ob3ZlclxcXFw6YmctZ3JheS01MDpob3ZlciB7XFxyXFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjQ5IDI1MCAyNTEgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5ob3ZlclxcXFw6YmctdGVhbC01MDA6aG92ZXIge1xcclxcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIwIDE4NCAxNjYgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5ob3ZlclxcXFw6YmctZ3JheS0yMDA6aG92ZXIge1xcclxcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIyOSAyMzEgMjM1IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uaG92ZXJcXFxcOmJnLWdyYXktMTAwOmhvdmVyIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNDMgMjQ0IDI0NiAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLmhvdmVyXFxcXDpiZy13aGl0ZTpob3ZlciB7XFxyXFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjU1IDI1NSAyNTUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5ob3ZlclxcXFw6dGV4dC1ncmF5LTQwMDpob3ZlciB7XFxyXFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoMTU2IDE2MyAxNzUgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLmhvdmVyXFxcXDp0ZXh0LWJsYWNrOmhvdmVyIHtcXHJcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcclxcbiAgY29sb3I6IHJnYigwIDAgMCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uaG92ZXJcXFxcOnRleHQtYmx1ZS01MDA6aG92ZXIge1xcclxcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxyXFxuICBjb2xvcjogcmdiKDU5IDEzMCAyNDYgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLmhvdmVyXFxcXDp0ZXh0LXJlZC01MDA6aG92ZXIge1xcclxcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxyXFxuICBjb2xvcjogcmdiKDIzOSA2OCA2OCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uaG92ZXJcXFxcOnRleHQtZ3JheS01MDA6aG92ZXIge1xcclxcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxyXFxuICBjb2xvcjogcmdiKDEwNyAxMTQgMTI4IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5ob3ZlclxcXFw6dGV4dC1ibHVlLTQwMDpob3ZlciB7XFxyXFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoOTYgMTY1IDI1MCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uaG92ZXJcXFxcOnVuZGVybGluZTpob3ZlciB7XFxyXFxuICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbi1saW5lOiB1bmRlcmxpbmU7XFxyXFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbi1saW5lOiB1bmRlcmxpbmU7XFxyXFxufVxcclxcbi5mb2N1c1xcXFw6Ym9yZGVyLWJsdWUtNDAwOmZvY3VzIHtcXHJcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxyXFxuICBib3JkZXItY29sb3I6IHJnYig5NiAxNjUgMjUwIC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLmZvY3VzXFxcXDpib3JkZXItb3JhbmdlLTUwMDpmb2N1cyB7XFxyXFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcclxcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMjQ5IDExNSAyMiAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5mb2N1c1xcXFw6YmctcmVkLTUwMDpmb2N1cyB7XFxyXFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjM5IDY4IDY4IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4uZm9jdXNcXFxcOm91dGxpbmUtbm9uZTpmb2N1cyB7XFxyXFxuICBvdXRsaW5lOiAycHggc29saWQgdHJhbnNwYXJlbnQ7XFxyXFxuICBvdXRsaW5lLW9mZnNldDogMnB4O1xcclxcbn1cXHJcXG4uZm9jdXNcXFxcOnJpbmctMjpmb2N1cyB7XFxyXFxuICAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogdmFyKC0tdHctcmluZy1pbnNldCkgMCAwIDAgdmFyKC0tdHctcmluZy1vZmZzZXQtd2lkdGgpIHZhcigtLXR3LXJpbmctb2Zmc2V0LWNvbG9yKTtcXHJcXG4gIC0tdHctcmluZy1zaGFkb3c6IHZhcigtLXR3LXJpbmctaW5zZXQpIDAgMCAwIGNhbGMoMnB4ICsgdmFyKC0tdHctcmluZy1vZmZzZXQtd2lkdGgpKSB2YXIoLS10dy1yaW5nLWNvbG9yKTtcXHJcXG4gIGJveC1zaGFkb3c6IHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksIHZhcigtLXR3LXJpbmctc2hhZG93KSwgdmFyKC0tdHctc2hhZG93LCAwIDAgIzAwMDApO1xcclxcbn1cXHJcXG4uZm9jdXNcXFxcOnJpbmctYmx1ZS01MDA6Zm9jdXMge1xcclxcbiAgLS10dy1yaW5nLW9wYWNpdHk6IDE7XFxyXFxuICAtLXR3LXJpbmctY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gdmFyKC0tdHctcmluZy1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5mb2N1c1xcXFw6cmluZy1ibHVlLTQwMDpmb2N1cyB7XFxyXFxuICAtLXR3LXJpbmctb3BhY2l0eTogMTtcXHJcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDk2IDE2NSAyNTAgLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuLmZvY3VzXFxcXDpyaW5nLW9yYW5nZS01MDA6Zm9jdXMge1xcclxcbiAgLS10dy1yaW5nLW9wYWNpdHk6IDE7XFxyXFxuICAtLXR3LXJpbmctY29sb3I6IHJnYigyNDkgMTE1IDIyIC8gdmFyKC0tdHctcmluZy1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5mb2N1c1xcXFw6cmluZy1vZmZzZXQtMjpmb2N1cyB7XFxyXFxuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAycHg7XFxyXFxufVxcclxcbi5hY3RpdmVcXFxcOmJnLXllbGxvdy01MDA6YWN0aXZlIHtcXHJcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMzQgMTc5IDggLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxyXFxufVxcclxcbi5wZWVyOmNoZWNrZWQgfiAucGVlci1jaGVja2VkXFxcXDpiZy1ibHVlLTYwMCB7XFxyXFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMzcgOTkgMjM1IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcclxcbn1cXHJcXG4ucGVlcjpjaGVja2VkIH4gLnBlZXItY2hlY2tlZFxcXFw6dGV4dC13aGl0ZSB7XFxyXFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXHJcXG4gIGNvbG9yOiByZ2IoMjU1IDI1NSAyNTUgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXHJcXG59XFxyXFxuQG1lZGlhIChtaW4td2lkdGg6IDY0MHB4KSB7XFxyXFxuXFxyXFxuICAuc21cXFxcOmNvbC1zcGFuLTEwIHtcXHJcXG4gICAgZ3JpZC1jb2x1bW46IHNwYW4gMTAgLyBzcGFuIDEwO1xcclxcbiAgfVxcclxcblxcclxcbiAgLnNtXFxcXDptdC03IHtcXHJcXG4gICAgbWFyZ2luLXRvcDogMS43NXJlbTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5zbVxcXFw6Z3JpZCB7XFxyXFxuICAgIGRpc3BsYXk6IGdyaWQ7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuc21cXFxcOm1heC13LVxcXFxbMzgwcHhcXFxcXSB7XFxyXFxuICAgIG1heC13aWR0aDogMzgwcHg7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuc21cXFxcOmdyaWQtY29scy01IHtcXHJcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoNSwgbWlubWF4KDAsIDFmcikpO1xcclxcbiAgfVxcclxcblxcclxcbiAgLnNtXFxcXDpncmlkLWNvbHMtMSB7XFxyXFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDEsIG1pbm1heCgwLCAxZnIpKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5zbVxcXFw6Z3JpZC1jb2xzLTMge1xcclxcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgzLCBtaW5tYXgoMCwgMWZyKSk7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuc21cXFxcOmdyaWQtY29scy0xMCB7XFxyXFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDEwLCBtaW5tYXgoMCwgMWZyKSk7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuc21cXFxcOnBsLTUge1xcclxcbiAgICBwYWRkaW5nLWxlZnQ6IDEuMjVyZW07XFxyXFxuICB9XFxyXFxufVxcclxcbkBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xcclxcblxcclxcbiAgLm1kXFxcXDpncmlkLWNvbHMtNSB7XFxyXFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDUsIG1pbm1heCgwLCAxZnIpKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5tZFxcXFw6Z3JpZC1jb2xzLTQge1xcclxcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg0LCBtaW5tYXgoMCwgMWZyKSk7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAubWRcXFxcOmdyaWQtY29scy0zIHtcXHJcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMywgbWlubWF4KDAsIDFmcikpO1xcclxcbiAgfVxcclxcblxcclxcbiAgLm1kXFxcXDpncmlkLWNvbHMtMiB7XFxyXFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDIsIG1pbm1heCgwLCAxZnIpKTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuQG1lZGlhIChtaW4td2lkdGg6IDEwMjRweCkge1xcclxcblxcclxcbiAgLmxnXFxcXDpjb2wtc3Bhbi0xIHtcXHJcXG4gICAgZ3JpZC1jb2x1bW46IHNwYW4gMSAvIHNwYW4gMTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5sZ1xcXFw6Y29sLXNwYW4tMTAge1xcclxcbiAgICBncmlkLWNvbHVtbjogc3BhbiAxMCAvIHNwYW4gMTA7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAubGdcXFxcOmNvbC1zcGFuLTUge1xcclxcbiAgICBncmlkLWNvbHVtbjogc3BhbiA1IC8gc3BhbiA1O1xcclxcbiAgfVxcclxcblxcclxcbiAgLmxnXFxcXDpncmlkLWNvbHMtOCB7XFxyXFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDgsIG1pbm1heCgwLCAxZnIpKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5sZ1xcXFw6Z3JpZC1jb2xzLTYge1xcclxcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg2LCBtaW5tYXgoMCwgMWZyKSk7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAubGdcXFxcOmdyaWQtY29scy00IHtcXHJcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoNCwgbWlubWF4KDAsIDFmcikpO1xcclxcbiAgfVxcclxcblxcclxcbiAgLmxnXFxcXDpncmlkLXJvd3MtNSB7XFxyXFxuICAgIGdyaWQtdGVtcGxhdGUtcm93czogcmVwZWF0KDUsIG1pbm1heCgwLCAxZnIpKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5sZ1xcXFw6cHgtNSB7XFxyXFxuICAgIHBhZGRpbmctbGVmdDogMS4yNXJlbTtcXHJcXG4gICAgcGFkZGluZy1yaWdodDogMS4yNXJlbTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5sZ1xcXFw6cHgtMCB7XFxyXFxuICAgIHBhZGRpbmctbGVmdDogMHB4O1xcclxcbiAgICBwYWRkaW5nLXJpZ2h0OiAwcHg7XFxyXFxuICB9XFxyXFxufVxcclxcbkBtZWRpYSAobWluLXdpZHRoOiAxMjgwcHgpIHtcXHJcXG5cXHJcXG4gIC54bFxcXFw6Z3JpZC1jb2xzLTUge1xcclxcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg1LCBtaW5tYXgoMCwgMWZyKSk7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAueGxcXFxcOmdyaWQtY29scy0zIHtcXHJcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMywgbWlubWF4KDAsIDFmcikpO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vc3R5bGVzL2dsb2JhbHMuY3NzXCIsXCI8bm8gc291cmNlPlwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTs7Q0FBYyxDQUFkOzs7Q0FBYzs7QUFBZDs7O0VBQUEsc0JBQWMsRUFBZCxNQUFjO0VBQWQsZUFBYyxFQUFkLE1BQWM7RUFBZCxtQkFBYyxFQUFkLE1BQWM7RUFBZCxxQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7RUFBQSxnQkFBYztBQUFBOztBQUFkOzs7OztDQUFjOztBQUFkO0VBQUEsZ0JBQWMsRUFBZCxNQUFjO0VBQWQsOEJBQWMsRUFBZCxNQUFjO0VBQWQsZ0JBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYztLQUFkLFdBQWMsRUFBZCxNQUFjO0VBQWQsNE5BQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7OztDQUFjOztBQUFkO0VBQUEsU0FBYyxFQUFkLE1BQWM7RUFBZCxvQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7OztDQUFjOztBQUFkO0VBQUEsU0FBYyxFQUFkLE1BQWM7RUFBZCxjQUFjLEVBQWQsTUFBYztFQUFkLHFCQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkO0VBQUEseUNBQWM7VUFBZCxpQ0FBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOzs7Ozs7RUFBQSxrQkFBYztFQUFkLG9CQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSxjQUFjO0VBQWQsd0JBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDs7RUFBQSxtQkFBYztBQUFBOztBQUFkOzs7Q0FBYzs7QUFBZDs7OztFQUFBLCtHQUFjLEVBQWQsTUFBYztFQUFkLGNBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSxjQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7O0VBQUEsY0FBYztFQUFkLGNBQWM7RUFBZCxrQkFBYztFQUFkLHdCQUFjO0FBQUE7O0FBQWQ7RUFBQSxlQUFjO0FBQUE7O0FBQWQ7RUFBQSxXQUFjO0FBQUE7O0FBQWQ7Ozs7Q0FBYzs7QUFBZDtFQUFBLGNBQWMsRUFBZCxNQUFjO0VBQWQscUJBQWMsRUFBZCxNQUFjO0VBQWQseUJBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7Ozs7Q0FBYzs7QUFBZDs7Ozs7RUFBQSxvQkFBYyxFQUFkLE1BQWM7RUFBZCxlQUFjLEVBQWQsTUFBYztFQUFkLG9CQUFjLEVBQWQsTUFBYztFQUFkLGNBQWMsRUFBZCxNQUFjO0VBQWQsU0FBYyxFQUFkLE1BQWM7RUFBZCxVQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLG9CQUFjO0FBQUE7O0FBQWQ7OztDQUFjOztBQUFkOzs7O0VBQUEsMEJBQWMsRUFBZCxNQUFjO0VBQWQsNkJBQWMsRUFBZCxNQUFjO0VBQWQsc0JBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSxhQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSxnQkFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkO0VBQUEsd0JBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDs7RUFBQSxZQUFjO0FBQUE7O0FBQWQ7OztDQUFjOztBQUFkO0VBQUEsNkJBQWMsRUFBZCxNQUFjO0VBQWQsb0JBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSx3QkFBYztBQUFBOztBQUFkOzs7Q0FBYzs7QUFBZDtFQUFBLDBCQUFjLEVBQWQsTUFBYztFQUFkLGFBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSxrQkFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOzs7Ozs7Ozs7Ozs7O0VBQUEsU0FBYztBQUFBOztBQUFkO0VBQUEsU0FBYztFQUFkLFVBQWM7QUFBQTs7QUFBZDtFQUFBLFVBQWM7QUFBQTs7QUFBZDs7O0VBQUEsZ0JBQWM7RUFBZCxTQUFjO0VBQWQsVUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkO0VBQUEsZ0JBQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7RUFBQSxVQUFjLEVBQWQsTUFBYztFQUFkLGNBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0VBQUEsVUFBYyxFQUFkLE1BQWM7RUFBZCxjQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLGVBQWM7QUFBQTs7QUFBZDs7Q0FBYztBQUFkO0VBQUEsZUFBYztBQUFBOztBQUFkOzs7O0NBQWM7O0FBQWQ7Ozs7Ozs7O0VBQUEsY0FBYyxFQUFkLE1BQWM7RUFBZCxzQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDs7RUFBQSxlQUFjO0VBQWQsWUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkO0VBQUEsYUFBYztBQUFBOztBQUFkO0VBQUEsbUJBQWM7RUFBZCxtQkFBYztFQUFkLGNBQWM7RUFBZCxjQUFjO0VBQWQsY0FBYztFQUFkLGVBQWM7RUFBZCxlQUFjO0VBQWQsYUFBYztFQUFkLGFBQWM7RUFBZCxrQkFBYztFQUFkLHNDQUFjO0VBQWQsZUFBYztFQUFkLG9CQUFjO0VBQWQsc0JBQWM7RUFBZCx1QkFBYztFQUFkLHdCQUFjO0VBQWQsa0JBQWM7RUFBZCwyQkFBYztFQUFkLDRCQUFjO0VBQWQsc0NBQWM7RUFBZCxrQ0FBYztFQUFkLDJCQUFjO0VBQWQsc0JBQWM7RUFBZCw4QkFBYztFQUFkLFlBQWM7RUFBZCxrQkFBYztFQUFkLGdCQUFjO0VBQWQsaUJBQWM7RUFBZCxrQkFBYztFQUFkLGNBQWM7RUFBZCxnQkFBYztFQUFkLGFBQWM7RUFBZCxtQkFBYztFQUFkLHFCQUFjO0VBQWQsMkJBQWM7RUFBZCx5QkFBYztFQUFkLDBCQUFjO0VBQWQsMkJBQWM7RUFBZCx1QkFBYztFQUFkLHdCQUFjO0VBQWQseUJBQWM7RUFBZDtBQUFjO0FBRWQ7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsZ0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLDJCQUFtQjtFQUFuQix3QkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsMkJBQW1CO0VBQW5CLHdCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsK0JBQW1CO0VBQW5CLDRCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSwwQkFBbUI7RUFBbkIsdUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSx5QkFBbUI7S0FBbkIsc0JBQW1CO1VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsd0JBQW1CO0tBQW5CLHFCQUFtQjtVQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CLDREQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQix1REFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkIsc0RBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CLHVEQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQixvREFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsZ0NBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsMkJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0tBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxxQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxxQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxnQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxlQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDJCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDJCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsMENBQW1CO0VBQW5CLHVEQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGdGQUFtQjtFQUFuQixvR0FBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSwyR0FBbUI7RUFBbkIseUdBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsd0tBQW1CO0VBQW5CLHdKQUFtQjtFQUFuQixnTkFBbUI7RUFBbkIsd0RBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsd0JBQW1CO0VBQW5CLHdEQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFGbkI7RUFBQTtDQ0FBO0FEQUE7RUFBQSxtQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBO0NDQUE7QURBQTtFQUFBLHVCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEsdUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSx1QkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLG1CQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEsbUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxtQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLG1CQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEsbUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxxQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHFCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEscUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxxQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHFCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEscUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSx3Q0NBQTtVREFBO0NDQUE7QURBQTtFQUFBLHVCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEsdUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxtQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLCtCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEsNEdDQUE7RURBQSwwR0NBQTtFREFBO0NDQUE7QURBQTtFQUFBLHFCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEscUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxxQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBO0NDQUE7QURBQTtFQUFBLG1CQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEsbUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxxQkNBQTtFREFBO0NDQUE7QURBQTs7RUFBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTtDQUFBO0FEQUE7O0VBQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBO0NBQUE7QURBQTs7RUFBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQSxzQkNBQTtJREFBO0dDQUE7O0VEQUE7SUFBQSxrQkNBQTtJREFBO0dDQUE7Q0FBQTtBREFBOztFQUFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7Q0FBQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAdGFpbHdpbmQgYmFzZTtcXHJcXG5AdGFpbHdpbmQgY29tcG9uZW50cztcXHJcXG5AdGFpbHdpbmQgdXRpbGl0aWVzO1xcclxcblwiLG51bGxdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app! ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"./pages/_app.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1wcml2YXRlLW5leHQtcGFnZXMlMkZfYXBwJnBhZ2U9JTJGX2FwcCEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxpREFBeUI7QUFDaEQ7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzY3ODIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHBcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL19hcHBcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!\n"));

/***/ }),

/***/ "./public/fdb_logo.png":
/*!*****************************!*\
  !*** ./public/fdb_logo.png ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/fdb_logo.a5ea18a4.png\",\"height\":143,\"width\":173,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ffdb_logo.a5ea18a4.png&w=8&q=70\"});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wdWJsaWMvZmRiX2xvZ28ucG5nLmpzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHVLQUF1SyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvZmRiX2xvZ28ucG5nPzZlMjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1wic3JjXCI6XCIvX25leHQvc3RhdGljL21lZGlhL2ZkYl9sb2dvLmE1ZWExOGE0LnBuZ1wiLFwiaGVpZ2h0XCI6MTQzLFwid2lkdGhcIjoxNzMsXCJibHVyRGF0YVVSTFwiOlwiL19uZXh0L2ltYWdlP3VybD0lMkZfbmV4dCUyRnN0YXRpYyUyRm1lZGlhJTJGZmRiX2xvZ28uYTVlYTE4YTQucG5nJnc9OCZxPTcwXCJ9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./public/fdb_logo.png\n"));

/***/ }),

/***/ "./styles/globals.css":
/*!****************************!*\
  !*** ./styles/globals.css ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\r\n                    // These elements should always exist. If they do not,\r\n                    // this code should fail.\r\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\r\n                    var parentNode = anchorElement.parentNode// Normally <head>\r\n                    ;\r\n                    // Each style tag should be placed right before our\r\n                    // anchor. By inserting before and not after, we do not\r\n                    // need to track the last inserted element.\r\n                    parentNode.insertBefore(element, anchorElement);\r\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\r\n    if (!a && b || a && !b) {\r\n        return false;\r\n    }\r\n    let p;\r\n    for(p in a){\r\n        if (isNamedExport && p === \"default\") {\r\n            continue;\r\n        }\r\n        if (a[p] !== b[p]) {\r\n            return false;\r\n        }\r\n    }\r\n    for(p in b){\r\n        if (isNamedExport && p === \"default\") {\r\n            continue;\r\n        }\r\n        if (!a[p]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvZ2xvYmFscy5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLG9OQUF3RztBQUMxSCwwQkFBMEIsbUJBQU8sQ0FBQyx1ZUFBK087O0FBRWpSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLHVlQUErTztBQUNyUDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHVlQUErTzs7QUFFelE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxVQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3R5bGVzL2dsb2JhbHMuY3NzP2M5ODMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzhdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOF0udXNlWzJdIS4vZ2xvYmFscy5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNfX25leHRfY3NzX19ET19OT1RfVVNFX19cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBhbmNob3JFbGVtZW50LnBhcmVudE5vZGUvLyBOb3JtYWxseSA8aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH07XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcclxuICAgIGlmICghYSAmJiBiIHx8IGEgJiYgIWIpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBsZXQgcDtcclxuICAgIGZvcihwIGluIGEpe1xyXG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yKHAgaW4gYil7XHJcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYVtwXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOF0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls4XS51c2VbMl0hLi9nbG9iYWxzLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOF0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls4XS51c2VbMl0hLi9nbG9iYWxzLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nconst isOldIE = function isOldIE() {\r\n    let memo;\r\n    return function memorize() {\r\n        if (typeof memo === \"undefined\") {\r\n            // Test for IE <= 9 as proposed by Browserhacks\r\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\r\n            // Tests for existence of standard globals is to allow style-loader\r\n            // to operate correctly into non-standard environments\r\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\r\n            memo = Boolean(window && document && document.all && !window.atob);\r\n        }\r\n        return memo;\r\n    };\r\n}();\r\nconst getTarget = function getTarget() {\r\n    const memo = {};\r\n    return function memorize(target) {\r\n        if (typeof memo[target] === \"undefined\") {\r\n            let styleTarget = document.querySelector(target);\r\n            // Special case to return head of iframe instead of iframe itself\r\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\r\n                try {\r\n                    // This will throw an exception if access to iframe is blocked\r\n                    // due to cross-origin restrictions\r\n                    styleTarget = styleTarget.contentDocument.head;\r\n                } catch (e) {\r\n                    // istanbul ignore next\r\n                    styleTarget = null;\r\n                }\r\n            }\r\n            memo[target] = styleTarget;\r\n        }\r\n        return memo[target];\r\n    };\r\n}();\r\nconst stylesInDom = [];\r\nfunction getIndexByIdentifier(identifier) {\r\n    let result = -1;\r\n    for(let i = 0; i < stylesInDom.length; i++){\r\n        if (stylesInDom[i].identifier === identifier) {\r\n            result = i;\r\n            break;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction modulesToDom(list, options) {\r\n    const idCountMap = {};\r\n    const identifiers = [];\r\n    for(let i = 0; i < list.length; i++){\r\n        const item = list[i];\r\n        const id = options.base ? item[0] + options.base : item[0];\r\n        const count = idCountMap[id] || 0;\r\n        const identifier = id + \" \" + count.toString();\r\n        idCountMap[id] = count + 1;\r\n        const index = getIndexByIdentifier(identifier);\r\n        const obj = {\r\n            css: item[1],\r\n            media: item[2],\r\n            sourceMap: item[3]\r\n        };\r\n        if (index !== -1) {\r\n            stylesInDom[index].references++;\r\n            stylesInDom[index].updater(obj);\r\n        } else {\r\n            stylesInDom.push({\r\n                identifier: identifier,\r\n                updater: addStyle(obj, options),\r\n                references: 1\r\n            });\r\n        }\r\n        identifiers.push(identifier);\r\n    }\r\n    return identifiers;\r\n}\r\nfunction insertStyleElement(options) {\r\n    const style = document.createElement(\"style\");\r\n    const attributes = options.attributes || {};\r\n    if (typeof attributes.nonce === \"undefined\") {\r\n        const nonce = // eslint-disable-next-line no-undef\r\n         true ? __webpack_require__.nc : 0;\r\n        if (nonce) {\r\n            attributes.nonce = nonce;\r\n        }\r\n    }\r\n    Object.keys(attributes).forEach(function(key) {\r\n        style.setAttribute(key, attributes[key]);\r\n    });\r\n    if (typeof options.insert === \"function\") {\r\n        options.insert(style);\r\n    } else {\r\n        const target = getTarget(options.insert || \"head\");\r\n        if (!target) {\r\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\r\n        }\r\n        target.appendChild(style);\r\n    }\r\n    return style;\r\n}\r\nfunction removeStyleElement(style) {\r\n    // istanbul ignore if\r\n    if (style.parentNode === null) {\r\n        return false;\r\n    }\r\n    style.parentNode.removeChild(style);\r\n}\r\n/* istanbul ignore next  */ const replaceText = function replaceText() {\r\n    const textStore = [];\r\n    return function replace(index, replacement) {\r\n        textStore[index] = replacement;\r\n        return textStore.filter(Boolean).join(\"\\n\");\r\n    };\r\n}();\r\nfunction applyToSingletonTag(style, index, remove, obj) {\r\n    const css = remove ? \"\" : obj.media ? \"@media \" + obj.media + \" {\" + obj.css + \"}\" : obj.css;\r\n    // For old IE\r\n    /* istanbul ignore if  */ if (style.styleSheet) {\r\n        style.styleSheet.cssText = replaceText(index, css);\r\n    } else {\r\n        const cssNode = document.createTextNode(css);\r\n        const childNodes = style.childNodes;\r\n        if (childNodes[index]) {\r\n            style.removeChild(childNodes[index]);\r\n        }\r\n        if (childNodes.length) {\r\n            style.insertBefore(cssNode, childNodes[index]);\r\n        } else {\r\n            style.appendChild(cssNode);\r\n        }\r\n    }\r\n}\r\nfunction applyToTag(style, options, obj) {\r\n    let css = obj.css;\r\n    const media = obj.media;\r\n    const sourceMap = obj.sourceMap;\r\n    if (media) {\r\n        style.setAttribute(\"media\", media);\r\n    } else {\r\n        style.removeAttribute(\"media\");\r\n    }\r\n    if (sourceMap && typeof btoa !== \"undefined\") {\r\n        css += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n    }\r\n    // For old IE\r\n    /* istanbul ignore if  */ if (style.styleSheet) {\r\n        style.styleSheet.cssText = css;\r\n    } else {\r\n        while(style.firstChild){\r\n            style.removeChild(style.firstChild);\r\n        }\r\n        style.appendChild(document.createTextNode(css));\r\n    }\r\n}\r\nlet singleton = null;\r\nlet singletonCounter = 0;\r\nfunction addStyle(obj, options) {\r\n    let style;\r\n    let update;\r\n    let remove;\r\n    if (options.singleton) {\r\n        const styleIndex = singletonCounter++;\r\n        style = singleton || (singleton = insertStyleElement(options));\r\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\r\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\r\n    } else {\r\n        style = insertStyleElement(options);\r\n        update = applyToTag.bind(null, style, options);\r\n        remove = function() {\r\n            removeStyleElement(style);\r\n        };\r\n    }\r\n    update(obj);\r\n    return function updateStyle(newObj) {\r\n        if (newObj) {\r\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\r\n                return;\r\n            }\r\n            update(obj = newObj);\r\n        } else {\r\n            remove();\r\n        }\r\n    };\r\n}\r\nmodule.exports = function(list, options) {\r\n    options = options || {};\r\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n    // tags it will allow on a page\r\n    if (!options.singleton && typeof options.singleton !== \"boolean\") {\r\n        options.singleton = isOldIE();\r\n    }\r\n    list = list || [];\r\n    let lastIdentifiers = modulesToDom(list, options);\r\n    return function update(newList) {\r\n        newList = newList || [];\r\n        if (Object.prototype.toString.call(newList) !== \"[object Array]\") {\r\n            return;\r\n        }\r\n        for(let i = 0; i < lastIdentifiers.length; i++){\r\n            const identifier = lastIdentifiers[i];\r\n            const index = getIndexByIdentifier(identifier);\r\n            stylesInDom[index].references--;\r\n        }\r\n        const newLastIdentifiers = modulesToDom(newList, options);\r\n        for(let i1 = 0; i1 < lastIdentifiers.length; i1++){\r\n            const identifier = lastIdentifiers[i1];\r\n            const index = getIndexByIdentifier(identifier);\r\n            if (stylesInDom[index].references === 0) {\r\n                stylesInDom[index].updater();\r\n                stylesInDom.splice(index, 1);\r\n            }\r\n        }\r\n        lastIdentifiers = newLastIdentifiers;\r\n    };\r\n};\r\n\r\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUVBQXFFLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MjZlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuY29uc3QgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XHJcbiAgICBsZXQgbWVtbztcclxuICAgIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcclxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxyXG4gICAgICAgICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXHJcbiAgICAgICAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xyXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcclxuICAgICAgICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWVtbztcclxuICAgIH07XHJcbn0oKTtcclxuY29uc3QgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xyXG4gICAgY29uc3QgbWVtbyA9IHt9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIGxldCBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcclxuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcclxuICAgIH07XHJcbn0oKTtcclxuY29uc3Qgc3R5bGVzSW5Eb20gPSBbXTtcclxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xyXG4gICAgbGV0IHJlc3VsdCA9IC0xO1xyXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBpZENvdW50TWFwID0ge307XHJcbiAgICBjb25zdCBpZGVudGlmaWVycyA9IFtdO1xyXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIGNvbnN0IGl0ZW0gPSBsaXN0W2ldO1xyXG4gICAgICAgIGNvbnN0IGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XHJcbiAgICAgICAgY29uc3QgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xyXG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBpZCArIFwiIFwiICsgY291bnQudG9TdHJpbmcoKTtcclxuICAgICAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IHtcclxuICAgICAgICAgICAgY3NzOiBpdGVtWzFdLFxyXG4gICAgICAgICAgICBtZWRpYTogaXRlbVsyXSxcclxuICAgICAgICAgICAgc291cmNlTWFwOiBpdGVtWzNdXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XHJcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcclxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IDFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaWRlbnRpZmllcnM7XHJcbn1cclxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcclxuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIGNvbnN0IG5vbmNlID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXHJcbiAgICAgICAgdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xyXG4gICAgICAgIGlmIChub25jZSkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xyXG4gICAgfSk7XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCBcImhlYWRcIik7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdHlsZTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcclxuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxyXG4gICAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi8gY29uc3QgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcclxuICAgIGNvbnN0IHRleHRTdG9yZSA9IFtdO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XHJcbiAgICAgICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIik7XHJcbiAgICB9O1xyXG59KCk7XHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xyXG4gICAgY29uc3QgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiICsgb2JqLm1lZGlhICsgXCIge1wiICsgb2JqLmNzcyArIFwifVwiIDogb2JqLmNzcztcclxuICAgIC8vIEZvciBvbGQgSUVcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcclxuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XHJcbiAgICAgICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xyXG4gICAgbGV0IGNzcyA9IG9iai5jc3M7XHJcbiAgICBjb25zdCBtZWRpYSA9IG9iai5tZWRpYTtcclxuICAgIGNvbnN0IHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcbiAgICBpZiAobWVkaWEpIHtcclxuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuICAgIH1cclxuICAgIC8vIEZvciBvbGQgSUVcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcclxuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpe1xyXG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcbiAgICB9XHJcbn1cclxubGV0IHNpbmdsZXRvbiA9IG51bGw7XHJcbmxldCBzaW5nbGV0b25Db3VudGVyID0gMDtcclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcbiAgICBsZXQgc3R5bGU7XHJcbiAgICBsZXQgdXBkYXRlO1xyXG4gICAgbGV0IHJlbW92ZTtcclxuICAgIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG4gICAgICAgIGNvbnN0IHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcbiAgICAgICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XHJcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XHJcbiAgICAgICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XHJcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcclxuICAgICAgICByZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKG9iaik7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XHJcbiAgICAgICAgaWYgKG5ld09iaikge1xyXG4gICAgICAgICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XHJcbiAgICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcbiAgICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcclxuICAgIH1cclxuICAgIGxpc3QgPSBsaXN0IHx8IFtdO1xyXG4gICAgbGV0IGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xyXG4gICAgICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09IFwiW29iamVjdCBBcnJheV1cIikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XHJcbiAgICAgICAgZm9yKGxldCBpMSA9IDA7IGkxIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaTErKyl7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaTFdO1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBpZiAoc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKCk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcclxuICAgIH07XHJcbn07XHJcblxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n"));

/***/ }),

/***/ "./components/Footer.tsx":
/*!*******************************!*\
  !*** ./components/Footer.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Footer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction Footer() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"footer\", {\n        className: \" mt-10 px-10 text-center absolute bottom-0 h-[60px] w-full \",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: \"Copyright \\xa9 Sagan Jung 2022. All rights reserved.\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Footer.tsx\",\n                lineNumber: 4,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: \"contact - mk44879@gmail.com\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Footer.tsx\",\n                lineNumber: 5,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Footer.tsx\",\n        lineNumber: 3,\n        columnNumber: 5\n    }, this);\n};\n_c = Footer;\nvar _c;\n$RefreshReg$(_c, \"Footer\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports on update so we can compare the boundary\r\n                // signatures.\r\n                module.hot.dispose(function (data) {\r\n                    data.prevExports = currentExports;\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevExports !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevExports !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0Zvb3Rlci50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFBZSxTQUFTQSxNQUFNLEdBQUc7SUFDL0IscUJBQ0UsOERBQUNDLFFBQU07UUFBQ0MsU0FBUyxFQUFDLDZEQUE2RDs7MEJBQzdFLDhEQUFDQyxHQUFDOzBCQUFDLHNEQUFpRDs7Ozs7b0JBQUk7MEJBQ3hELDhEQUFDQSxHQUFDOzBCQUFDLDZCQUEyQjs7Ozs7b0JBQUk7Ozs7OztZQUMzQixDQUNUO0NBQ0g7QUFQdUJILEtBQUFBLE1BQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Gb290ZXIudHN4P2E3OWYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRm9vdGVyKCkge1xyXG4gIHJldHVybiAoXHJcbiAgICA8Zm9vdGVyIGNsYXNzTmFtZT1cIiBtdC0xMCBweC0xMCB0ZXh0LWNlbnRlciBhYnNvbHV0ZSBib3R0b20tMCBoLVs2MHB4XSB3LWZ1bGwgXCI+XHJcbiAgICAgIDxwPkNvcHlyaWdodCDCqSBTYWdhbiBKdW5nIDIwMjIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuPC9wPlxyXG4gICAgICA8cD5jb250YWN0IC0gbWs0NDg3OUBnbWFpbC5jb208L3A+XHJcbiAgICA8L2Zvb3Rlcj5cclxuICApO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJGb290ZXIiLCJmb290ZXIiLCJjbGFzc05hbWUiLCJwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Footer.tsx\n"));

/***/ }),

/***/ "./components/Gnb.tsx":
/*!****************************!*\
  !*** ./components/Gnb.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Gnb; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next-auth/react */ \"./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _libs_client_useUser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/client/useUser */ \"./libs/client/useUser.tsx\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _public_fdb_logo_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../public/fdb_logo.png */ \"./public/fdb_logo.png\");\n\n\n\n\n\n\nvar _s = $RefreshSig$();\nfunction Gnb() {\n    _s();\n    var ref = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_2__.useSession)(), nextSession = ref.data;\n    var ref1 = (0,_libs_client_useUser__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(), user = ref1.user, isLoading = ref1.isLoading;\n    var _image, _id;\n    // const { data: CredentailSession } = useSWR(\"/api/users/me\");\n    // console.log(user);\n    // console.log(nextSession);\n    // useEffect(() => {\n    //   if (data && !data.ok) {\n    //     router.replace(\"/enter\");\n    //   }\n    // }, [data, router]);\n    // console.log(data);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n        className: \"flex bg-blue-200 fixed top-0 w-full py-2 z-20\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n            className: \"flex w-full justify-between items-center\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                    className: \"flex uppercase font-bold \",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \" ml-3 mr-3 cursor-pointer\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                className: \" \",\n                                href: \"/\",\n                                passHref: true,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    className: \" flex items-center \",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_4___default()), {\n                                        className: \" rounded-xl border-blue-800 border-4 border-solid\",\n                                        src: _public_fdb_logo_png__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n                                        width: 26,\n                                        height: 26\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                        lineNumber: 26,\n                                        columnNumber: 17\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 25,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 24,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 23,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"mr-3\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                href: \"/fictions/all/all/all/1/all\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    children: \"\\uC791\\uD488\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 37,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 36,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 35,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"mr-3\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                href: \"/authors/1\",\n                                passHref: true,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    children: \"\\uC791\\uAC00\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 42,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 41,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 40,\n                            columnNumber: 11\n                        }, this),\n                        user ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"mr-3\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                href: \"/fictions/create\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    children: \"Create\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 51,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 50,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 49,\n                            columnNumber: 13\n                        }, this) : null\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                    lineNumber: 22,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                    className: \" flex font-bold items-center\",\n                    children: [\n                        user ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"mr-3\",\n                            children: \"Admin\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 57,\n                            columnNumber: 19\n                        }, this) : null,\n                        nextSession ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \" mr-3 p-0 flex items-center cursor-pointer min-w-[26px]\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                className: \" rounded-full\",\n                                href: \"/profile\",\n                                passHref: true,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    className: \" flex items-center\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_4___default()), {\n                                        className: \" rounded-full\",\n                                        src: (_image = nextSession.user.image) !== null && _image !== void 0 ? _image : \"\",\n                                        width: 26,\n                                        height: 26,\n                                        alt: (_id = nextSession.user.id) !== null && _id !== void 0 ? _id : \"\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                        lineNumber: 62,\n                                        columnNumber: 19\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 61,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 60,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 59,\n                            columnNumber: 13\n                        }, this) : null,\n                        nextSession ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            className: \" mr-5 font-bold\",\n                            onClick: function() {\n                                return (0,next_auth_react__WEBPACK_IMPORTED_MODULE_2__.signOut)();\n                            },\n                            children: \"Sign out\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 74,\n                            columnNumber: 13\n                        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                href: \"/enter\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    className: \" mr-5 hover:cursor-pointer\",\n                                    children: \"Enter\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 80,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 79,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 78,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n                    lineNumber: 56,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n            lineNumber: 21,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Gnb.tsx\",\n        lineNumber: 20,\n        columnNumber: 5\n    }, this);\n};\n_s(Gnb, \"hok5D1BpjBZA3UVuT/spEw5bbE0=\", false, function() {\n    return [\n        next_auth_react__WEBPACK_IMPORTED_MODULE_2__.useSession,\n        _libs_client_useUser__WEBPACK_IMPORTED_MODULE_3__[\"default\"]\n    ];\n});\n_c = Gnb;\nvar _c;\n$RefreshReg$(_c, \"Gnb\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports on update so we can compare the boundary\r\n                // signatures.\r\n                module.hot.dispose(function (data) {\r\n                    data.prevExports = currentExports;\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevExports !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevExports !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBdUIsR0FBSSxFQUFFO3dDQUNsQ1ksS0FBSyxFQUFFLEVBQUU7d0NBQ1RDLE1BQU0sRUFBRSxFQUFFO3dDQUNWRSxHQUFHLEVBQUVmLENBQUFBLEdBQW9CLEdBQXBCQSxXQUFXLENBQUNDLElBQUksQ0FBRWUsRUFBRSxjQUFwQmhCLEdBQW9CLGNBQXBCQSxHQUFvQixHQUFJLEVBQUU7Ozs7OzRDQUN4Qjs7Ozs7d0NBQ1A7Ozs7O29DQUNDOzs7OztnQ0FDSixHQUNILElBQUk7d0JBQ1BBLFdBQVcsaUJBQ1YsOERBQUNpQixRQUFNOzRCQUFDYixTQUFTLEVBQUMsaUJBQWlCOzRCQUFDYyxPQUFPLEVBQUU7dUNBQU14Qix3REFBTyxFQUFFOzZCQUFBO3NDQUFFLFVBRTlEOzs7OztnQ0FBUyxpQkFFVCw4REFBQ2EsSUFBRTtzQ0FDRCw0RUFBQ2Ysa0RBQUk7Z0NBQUNnQixJQUFJLEVBQUMsUUFBUTswQ0FDakIsNEVBQUNFLEdBQUM7b0NBQUNOLFNBQVMsRUFBQyw0QkFBNEI7OENBQUMsT0FBSzs7Ozs7d0NBQUk7Ozs7O29DQUM5Qzs7Ozs7Z0NBQ0o7Ozs7Ozt3QkFFSjs7Ozs7O2dCQUNEOzs7OztZQUNDLENBQ1Q7Q0FDSDtHQWpGdUJOLEdBQUc7O1FBQ0tMLHVEQUFVO1FBQ1pFLDREQUFPOzs7QUFGYkcsS0FBQUEsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0duYi50c3g/NWM4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTGluayBmcm9tIFwibmV4dC9saW5rXCI7XHJcbmltcG9ydCB7IHVzZVNlc3Npb24sIHNpZ25Jbiwgc2lnbk91dCB9IGZyb20gXCJuZXh0LWF1dGgvcmVhY3RcIjtcclxuaW1wb3J0IHVzZVVzZXIgZnJvbSBcIkBsaWJzL2NsaWVudC91c2VVc2VyXCI7XHJcbmltcG9ydCBJbWFnZSBmcm9tIFwibmV4dC9pbWFnZVwiO1xyXG5pbXBvcnQgbG9nbyBmcm9tIFwiLi4vcHVibGljL2ZkYl9sb2dvLnBuZ1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gR25iKCkge1xyXG4gIGNvbnN0IHsgZGF0YTogbmV4dFNlc3Npb24gfSA9IHVzZVNlc3Npb24oKTtcclxuICBjb25zdCB7IHVzZXIsIGlzTG9hZGluZyB9ID0gdXNlVXNlcigpO1xyXG4gIC8vIGNvbnN0IHsgZGF0YTogQ3JlZGVudGFpbFNlc3Npb24gfSA9IHVzZVNXUihcIi9hcGkvdXNlcnMvbWVcIik7XHJcbiAgLy8gY29uc29sZS5sb2codXNlcik7XHJcbiAgLy8gY29uc29sZS5sb2cobmV4dFNlc3Npb24pO1xyXG4gIC8vIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgLy8gICBpZiAoZGF0YSAmJiAhZGF0YS5vaykge1xyXG4gIC8vICAgICByb3V0ZXIucmVwbGFjZShcIi9lbnRlclwiKTtcclxuICAvLyAgIH1cclxuICAvLyB9LCBbZGF0YSwgcm91dGVyXSk7XHJcbiAgLy8gY29uc29sZS5sb2coZGF0YSk7XHJcbiAgcmV0dXJuIChcclxuICAgIDxoZWFkZXIgY2xhc3NOYW1lPVwiZmxleCBiZy1ibHVlLTIwMCBmaXhlZCB0b3AtMCB3LWZ1bGwgcHktMiB6LTIwXCI+XHJcbiAgICAgIDxuYXYgY2xhc3NOYW1lPVwiZmxleCB3LWZ1bGwganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlclwiPlxyXG4gICAgICAgIDx1bCBjbGFzc05hbWU9XCJmbGV4IHVwcGVyY2FzZSBmb250LWJvbGQgXCI+XHJcbiAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwiIG1sLTMgbXItMyBjdXJzb3ItcG9pbnRlclwiPlxyXG4gICAgICAgICAgICA8TGluayBjbGFzc05hbWU9XCIgXCIgaHJlZj1cIi9cIiBwYXNzSHJlZj5cclxuICAgICAgICAgICAgICA8YSBjbGFzc05hbWU9XCIgZmxleCBpdGVtcy1jZW50ZXIgXCI+XHJcbiAgICAgICAgICAgICAgICA8SW1hZ2VcclxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiIHJvdW5kZWQteGwgYm9yZGVyLWJsdWUtODAwIGJvcmRlci00IGJvcmRlci1zb2xpZFwiXHJcbiAgICAgICAgICAgICAgICAgIHNyYz17bG9nb31cclxuICAgICAgICAgICAgICAgICAgd2lkdGg9ezI2fVxyXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ9ezI2fVxyXG4gICAgICAgICAgICAgICAgPjwvSW1hZ2U+XHJcbiAgICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm1yLTNcIj5cclxuICAgICAgICAgICAgPExpbmsgaHJlZj1cIi9maWN0aW9ucy9hbGwvYWxsL2FsbC8xL2FsbFwiPlxyXG4gICAgICAgICAgICAgIDxhPuyeke2SiDwvYT5cclxuICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgPC9saT5cclxuICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJtci0zXCI+XHJcbiAgICAgICAgICAgIDxMaW5rIGhyZWY9XCIvYXV0aG9ycy8xXCIgcGFzc0hyZWY+XHJcbiAgICAgICAgICAgICAgPGE+7J6R6rCAPC9hPlxyXG4gICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgey8qIDxMaW5rIGhyZWY9XCIvcmFua2luZ1wiPlxyXG4gICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibXItM1wiPlJhbmtpbmc8L2xpPlxyXG4gICAgICAgICAgPC9MaW5rPiAqL31cclxuICAgICAgICAgIHt1c2VyID8gKFxyXG4gICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibXItM1wiPlxyXG4gICAgICAgICAgICAgIDxMaW5rIGhyZWY9XCIvZmljdGlvbnMvY3JlYXRlXCI+XHJcbiAgICAgICAgICAgICAgICA8YT5DcmVhdGU8L2E+XHJcbiAgICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgKSA6IG51bGx9XHJcbiAgICAgICAgPC91bD5cclxuICAgICAgICA8dWwgY2xhc3NOYW1lPVwiIGZsZXggZm9udC1ib2xkIGl0ZW1zLWNlbnRlclwiPlxyXG4gICAgICAgICAge3VzZXIgPyA8bGkgY2xhc3NOYW1lPVwibXItM1wiPkFkbWluPC9saT4gOiBudWxsfVxyXG4gICAgICAgICAge25leHRTZXNzaW9uID8gKFxyXG4gICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwiIG1yLTMgcC0wIGZsZXggaXRlbXMtY2VudGVyIGN1cnNvci1wb2ludGVyIG1pbi13LVsyNnB4XVwiPlxyXG4gICAgICAgICAgICAgIDxMaW5rIGNsYXNzTmFtZT1cIiByb3VuZGVkLWZ1bGxcIiBocmVmPVwiL3Byb2ZpbGVcIiBwYXNzSHJlZj5cclxuICAgICAgICAgICAgICAgIDxhIGNsYXNzTmFtZT1cIiBmbGV4IGl0ZW1zLWNlbnRlclwiPlxyXG4gICAgICAgICAgICAgICAgICA8SW1hZ2VcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCIgcm91bmRlZC1mdWxsXCJcclxuICAgICAgICAgICAgICAgICAgICBzcmM9e25leHRTZXNzaW9uLnVzZXIhLmltYWdlID8/IFwiXCJ9XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg9ezI2fVxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodD17MjZ9XHJcbiAgICAgICAgICAgICAgICAgICAgYWx0PXtuZXh0U2Vzc2lvbi51c2VyIS5pZCA/PyBcIlwifVxyXG4gICAgICAgICAgICAgICAgICA+PC9JbWFnZT5cclxuICAgICAgICAgICAgICAgIDwvYT5cclxuICAgICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICApIDogbnVsbH1cclxuICAgICAgICAgIHtuZXh0U2Vzc2lvbiA/IChcclxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCIgbXItNSBmb250LWJvbGRcIiBvbkNsaWNrPXsoKSA9PiBzaWduT3V0KCl9PlxyXG4gICAgICAgICAgICAgIFNpZ24gb3V0XHJcbiAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgKSA6IChcclxuICAgICAgICAgICAgPGxpPlxyXG4gICAgICAgICAgICAgIDxMaW5rIGhyZWY9XCIvZW50ZXJcIj5cclxuICAgICAgICAgICAgICAgIDxhIGNsYXNzTmFtZT1cIiBtci01IGhvdmVyOmN1cnNvci1wb2ludGVyXCI+RW50ZXI8L2E+XHJcbiAgICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgKX1cclxuICAgICAgICA8L3VsPlxyXG4gICAgICA8L25hdj5cclxuICAgIDwvaGVhZGVyPlxyXG4gICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbIkxpbmsiLCJ1c2VTZXNzaW9uIiwic2lnbk91dCIsInVzZVVzZXIiLCJJbWFnZSIsImxvZ28iLCJHbmIiLCJkYXRhIiwibmV4dFNlc3Npb24iLCJ1c2VyIiwiaXNMb2FkaW5nIiwiaGVhZGVyIiwiY2xhc3NOYW1lIiwibmF2IiwidWwiLCJsaSIsImhyZWYiLCJwYXNzSHJlZiIsImEiLCJzcmMiLCJ3aWR0aCIsImhlaWdodCIsImltYWdlIiwiYWx0IiwiaWQiLCJidXR0b24iLCJvbkNsaWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Gnb.tsx\n"));

/***/ }),

/***/ "./components/Top.tsx":
/*!****************************!*\
  !*** ./components/Top.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Top; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Gnb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Gnb */ \"./components/Gnb.tsx\");\n\n\nfunction Top() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Gnb__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\Top.tsx\",\n        lineNumber: 4,\n        columnNumber: 10\n    }, this);\n};\n_c = Top;\nvar _c;\n$RefreshReg$(_c, \"Top\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports on update so we can compare the boundary\r\n                // signatures.\r\n                module.hot.dispose(function (data) {\r\n                    data.prevExports = currentExports;\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevExports !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevExports !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1RvcC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQXdCO0FBRVQsU0FBU0MsR0FBRyxHQUFHO0lBQzVCLHFCQUFPLDhEQUFDRCw0Q0FBRzs7OztZQUFHLENBQUM7Q0FDaEI7QUFGdUJDLEtBQUFBLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Ub3AudHN4PzFmNWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEduYiBmcm9tIFwiLi9HbmJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRvcCgpIHtcclxuICByZXR1cm4gPEduYiAvPjtcclxufVxyXG4iXSwibmFtZXMiOlsiR25iIiwiVG9wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Top.tsx\n"));

/***/ }),

/***/ "./libs/client/useUser.tsx":
/*!*********************************!*\
  !*** ./libs/client/useUser.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ useUser; }\n/* harmony export */ });\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! swr */ \"./node_modules/swr/dist/index.mjs\");\n\n\n\nvar _s = $RefreshSig$();\nfunction useUser() {\n    _s();\n    var ref = (0,swr__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"/api/users/me\"), data = ref.data, error = ref.error;\n    // const { data: session } = useSession();\n    var router = (0,next_router__WEBPACK_IMPORTED_MODULE_0__.useRouter)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (data && !data.ok) {\n        // router.replace(\"/enter\");\n        }\n    }, [\n        data,\n        router\n    ]);\n    //   return router.replace(\"/enter\");\n    return {\n        user: data === null || data === void 0 ? void 0 : data.profile,\n        isLoading: !data && !error\n    };\n};\n_s(useUser, \"4W9O7/pgHSLAxPizl2rA7NDDAiw=\", false, function() {\n    return [\n        swr__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n        next_router__WEBPACK_IMPORTED_MODULE_0__.useRouter\n    ];\n});\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports on update so we can compare the boundary\r\n                // signatures.\r\n                module.hot.dispose(function (data) {\r\n                    data.prevExports = currentExports;\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevExports !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevExports !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL2NsaWVudC91c2VVc2VyLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBd0M7QUFDTjtBQUNUOztBQUVWLFNBQVNHLE9BQU8sR0FBRzs7SUFDaEMsSUFBd0JELEdBQXVCLEdBQXZCQSwrQ0FBTSxDQUFDLGVBQWUsQ0FBQyxFQUF2Q0UsSUFBSSxHQUFZRixHQUF1QixDQUF2Q0UsSUFBSSxFQUFFQyxLQUFLLEdBQUtILEdBQXVCLENBQWpDRyxLQUFLO0lBQ25CLDBDQUEwQztJQUMxQyxJQUFNQyxNQUFNLEdBQUdOLHNEQUFTLEVBQUU7SUFDMUJDLGdEQUFTLENBQUMsV0FBTTtRQUNkLElBQUlHLElBQUksSUFBSSxDQUFDQSxJQUFJLENBQUNHLEVBQUUsRUFBRTtRQUNwQiw0QkFBNEI7U0FDN0I7S0FDRixFQUFFO1FBQUNILElBQUk7UUFBRUUsTUFBTTtLQUFDLENBQUMsQ0FBQztJQUVuQixxQ0FBcUM7SUFFckMsT0FBTztRQUFFRSxJQUFJLEVBQUVKLElBQUksYUFBSkEsSUFBSSxXQUFTLEdBQWJBLEtBQUFBLENBQWEsR0FBYkEsSUFBSSxDQUFFSyxPQUFPO1FBQUVDLFNBQVMsRUFBRSxDQUFDTixJQUFJLElBQUksQ0FBQ0MsS0FBSztLQUFFLENBQUM7Q0FDNUQ7R0FidUJGLE9BQU87O1FBQ0xELDJDQUFNO1FBRWZGLGtEQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYnMvY2xpZW50L3VzZVVzZXIudHN4P2M2N2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvcm91dGVyXCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgdXNlU1dSIGZyb20gXCJzd3JcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZVVzZXIoKSB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gdXNlU1dSKFwiL2FwaS91c2Vycy9tZVwiKTtcclxuICAvLyBjb25zdCB7IGRhdGE6IHNlc3Npb24gfSA9IHVzZVNlc3Npb24oKTtcclxuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGRhdGEgJiYgIWRhdGEub2spIHtcclxuICAgICAgLy8gcm91dGVyLnJlcGxhY2UoXCIvZW50ZXJcIik7XHJcbiAgICB9XHJcbiAgfSwgW2RhdGEsIHJvdXRlcl0pO1xyXG5cclxuICAvLyAgIHJldHVybiByb3V0ZXIucmVwbGFjZShcIi9lbnRlclwiKTtcclxuXHJcbiAgcmV0dXJuIHsgdXNlcjogZGF0YT8ucHJvZmlsZSwgaXNMb2FkaW5nOiAhZGF0YSAmJiAhZXJyb3IgfTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlUm91dGVyIiwidXNlRWZmZWN0IiwidXNlU1dSIiwidXNlVXNlciIsImRhdGEiLCJlcnJvciIsInJvdXRlciIsIm9rIiwidXNlciIsInByb2ZpbGUiLCJpc0xvYWRpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./libs/client/useUser.tsx\n"));

/***/ }),

/***/ "./pages/_app.tsx":
/*!************************!*\
  !*** ./pages/_app.tsx ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @swc/helpers/src/_object_spread.mjs */ \"./node_modules/@swc/helpers/src/_object_spread.mjs\");\n/* harmony import */ var _swc_helpers_src_object_without_properties_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/src/_object_without_properties.mjs */ \"./node_modules/@swc/helpers/src/_object_without_properties.mjs\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../styles/globals.css */ \"./styles/globals.css\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_styles_globals_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Top__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @components/Top */ \"./components/Top.tsx\");\n/* harmony import */ var _components_Footer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @components/Footer */ \"./components/Footer.tsx\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next-auth/react */ \"./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! swr */ \"./node_modules/swr/dist/index.mjs\");\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! recoil */ \"./node_modules/recoil/es/index.js\");\n\n\n\n\n\n\n\n\n\nfunction MyApp(_param) {\n    var Component = _param.Component, session = _param.pageProps.session, pageProps = (0,_swc_helpers_src_object_without_properties_mjs__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(_param.pageProps, [\n        \"session\"\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_auth_react__WEBPACK_IMPORTED_MODULE_4__.SessionProvider, {\n        session: session,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(swr__WEBPACK_IMPORTED_MODULE_5__.SWRConfig, {\n            value: {\n                fetcher: function(url) {\n                    return fetch(url).then(function(response) {\n                        return response.json();\n                    });\n                }\n            },\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(recoil__WEBPACK_IMPORTED_MODULE_6__.RecoilRoot, {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \" min-w-[300px] max-h-fit flex flex-col items-center min-h-[100vh] relative\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Top__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                            lineNumber: 26,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                            className: \" mt-10 mx-3 flex-column items-center pb-[60px]\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, (0,_swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_8__[\"default\"])({}, pageProps), void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                                lineNumber: 28,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                            lineNumber: 27,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Footer__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                            lineNumber: 30,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                    lineNumber: 25,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                lineNumber: 24,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n            lineNumber: 18,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n        lineNumber: 17,\n        columnNumber: 5\n    }, this);\n}\n_c = MyApp;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MyApp);\nvar _c;\n$RefreshReg$(_c, \"MyApp\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports on update so we can compare the boundary\r\n                // signatures.\r\n                module.hot.dispose(function (data) {\r\n                    data.prevExports = currentExports;\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevExports !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevExports !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9fYXBwLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7OztBQUErQjtBQUVHO0FBQ007QUFDVTtBQUNsQjtBQU9oQjtBQUVoQixTQUFTSyxLQUFLLENBQUMsTUFBNkQsRUFBRTtRQUE3REMsU0FBUyxHQUFYLE1BQTZELENBQTNEQSxTQUFTLEVBQUVDLE9BQW9CLEdBQWpDLE1BQTZELENBQWhEQSxTQUFTLENBQUlDLE9BQU8sRUFBS0QsU0FBUyw4RkFBL0MsTUFBNkQsQ0FBaERBLFNBQVM7UUFBSUMsU0FBTzs7SUFDOUMscUJBQ0UsOERBQUNOLDREQUFlO1FBQUNNLE9BQU8sRUFBRUEsT0FBTztrQkFDL0IsNEVBQUNMLDBDQUFTO1lBQ1JNLEtBQUssRUFBRTtnQkFDTEMsT0FBTyxFQUFFLFNBQUNDLEdBQVc7MkJBQ25CQyxLQUFLLENBQUNELEdBQUcsQ0FBQyxDQUFDRSxJQUFJLENBQUMsU0FBQ0MsUUFBUTsrQkFBS0EsUUFBUSxDQUFDQyxJQUFJLEVBQUU7cUJBQUEsQ0FBQztpQkFBQTthQUNqRDtzQkFFRCw0RUFBQ1gsOENBQVU7MEJBQ1QsNEVBQUNZLEtBQUc7b0JBQUNDLFNBQVMsRUFBQyw0RUFBNkU7O3NDQUMxRiw4REFBQ2pCLHVEQUFHOzs7O2dDQUFHO3NDQUNQLDhEQUFDa0IsU0FBTzs0QkFBQ0QsU0FBUyxFQUFDLGdEQUFnRDtzQ0FDakUsNEVBQUNYLFNBQVMscUZBQUtDLFNBQVM7Ozs7b0NBQUk7Ozs7O2dDQUNwQjtzQ0FDViw4REFBQ04sMERBQU07Ozs7Z0NBQUc7Ozs7Ozt3QkFDTjs7Ozs7b0JBQ0s7Ozs7O2dCQUNIOzs7OztZQUNJLENBQ2xCO0NBQ0g7QUFyQlFJLEtBQUFBLEtBQUs7QUF1QmQsK0RBQWVBLEtBQUssRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9fYXBwLnRzeD8yZmJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBcIi4uL3N0eWxlcy9nbG9iYWxzLmNzc1wiO1xyXG5pbXBvcnQgdHlwZSB7IEFwcFByb3BzIH0gZnJvbSBcIm5leHQvYXBwXCI7XHJcbmltcG9ydCBUb3AgZnJvbSBcIkBjb21wb25lbnRzL1RvcFwiO1xyXG5pbXBvcnQgRm9vdGVyIGZyb20gXCJAY29tcG9uZW50cy9Gb290ZXJcIjtcclxuaW1wb3J0IHsgU2Vzc2lvblByb3ZpZGVyIH0gZnJvbSBcIm5leHQtYXV0aC9yZWFjdFwiO1xyXG5pbXBvcnQgeyBTV1JDb25maWcgfSBmcm9tIFwic3dyXCI7XHJcbmltcG9ydCB7XHJcbiAgUmVjb2lsUm9vdCxcclxuICBhdG9tLFxyXG4gIHNlbGVjdG9yLFxyXG4gIHVzZVJlY29pbFN0YXRlLFxyXG4gIHVzZVJlY29pbFZhbHVlLFxyXG59IGZyb20gXCJyZWNvaWxcIjtcclxuXHJcbmZ1bmN0aW9uIE15QXBwKHsgQ29tcG9uZW50LCBwYWdlUHJvcHM6IHsgc2Vzc2lvbiwgLi4ucGFnZVByb3BzIH0gfTogQXBwUHJvcHMpIHtcclxuICByZXR1cm4gKFxyXG4gICAgPFNlc3Npb25Qcm92aWRlciBzZXNzaW9uPXtzZXNzaW9ufT5cclxuICAgICAgPFNXUkNvbmZpZ1xyXG4gICAgICAgIHZhbHVlPXt7XHJcbiAgICAgICAgICBmZXRjaGVyOiAodXJsOiBzdHJpbmcpID0+XHJcbiAgICAgICAgICAgIGZldGNoKHVybCkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSksXHJcbiAgICAgICAgfX1cclxuICAgICAgPlxyXG4gICAgICAgIDxSZWNvaWxSb290PlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCIgbWluLXctWzMwMHB4XSAgbWF4LWgtZml0IGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIG1pbi1oLVsxMDB2aF0gcmVsYXRpdmVcIj5cclxuICAgICAgICAgICAgPFRvcCAvPlxyXG4gICAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCIgbXQtMTAgbXgtMyBmbGV4LWNvbHVtbiBpdGVtcy1jZW50ZXIgcGItWzYwcHhdXCI+XHJcbiAgICAgICAgICAgICAgPENvbXBvbmVudCB7Li4ucGFnZVByb3BzfSAvPlxyXG4gICAgICAgICAgICA8L3NlY3Rpb24+XHJcbiAgICAgICAgICAgIDxGb290ZXIgLz5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvUmVjb2lsUm9vdD5cclxuICAgICAgPC9TV1JDb25maWc+XHJcbiAgICA8L1Nlc3Npb25Qcm92aWRlcj5cclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNeUFwcDtcclxuIl0sIm5hbWVzIjpbIlRvcCIsIkZvb3RlciIsIlNlc3Npb25Qcm92aWRlciIsIlNXUkNvbmZpZyIsIlJlY29pbFJvb3QiLCJNeUFwcCIsIkNvbXBvbmVudCIsInBhZ2VQcm9wcyIsInNlc3Npb24iLCJ2YWx1ZSIsImZldGNoZXIiLCJ1cmwiLCJmZXRjaCIsInRoZW4iLCJyZXNwb25zZSIsImpzb24iLCJkaXYiLCJjbGFzc05hbWUiLCJzZWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/_app.tsx\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_define_property.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_define_property.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _defineProperty; }\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fZGVmaW5lX3Byb3BlcnR5Lm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWUsU0FBU0EsZUFBVCxDQUF5QkMsR0FBekIsRUFBOEJDLEdBQTlCLEVBQW1DQyxLQUFuQyxFQUEwQztFQUN2RCxJQUFJRCxHQUFHLElBQUlELEdBQVgsRUFBZ0I7SUFDZEcsTUFBTSxDQUFDQyxjQUFQLENBQXNCSixHQUF0QixFQUEyQkMsR0FBM0IsRUFBZ0M7TUFDOUJDLEtBQUssRUFBRUEsS0FEdUI7TUFFOUJHLFVBQVUsRUFBRSxJQUZrQjtNQUc5QkMsWUFBWSxFQUFFLElBSGdCO01BSTlCQyxRQUFRLEVBQUU7SUFKb0IsQ0FBaEM7RUFNRCxDQVBELE1BT087SUFDTFAsR0FBRyxDQUFDQyxHQUFELENBQUgsR0FBV0MsS0FBWDtFQUNEOztFQUVELE9BQU9GLEdBQVA7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fZGVmaW5lX3Byb3BlcnR5Lm1qcz9iNTEyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcclxuICBpZiAoa2V5IGluIG9iaikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIG9ialtrZXldID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb2JqO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_define_property.mjs\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_object_spread.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_object_spread.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectSpread; }\n/* harmony export */ });\n/* harmony import */ var _define_property_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_define_property.mjs */ \"./node_modules/@swc/helpers/src/_define_property.mjs\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      (0,_define_property_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]);\n    });\n  }\n\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fb2JqZWN0X3NwcmVhZC5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUVlLFNBQVNDLGFBQVQsQ0FBdUJDLE1BQXZCLEVBQStCO0VBQzVDLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0MsU0FBUyxDQUFDQyxNQUE5QixFQUFzQ0YsQ0FBQyxFQUF2QyxFQUEyQztJQUN6QyxJQUFJRyxNQUFNLEdBQUdGLFNBQVMsQ0FBQ0QsQ0FBRCxDQUFULElBQWdCLElBQWhCLEdBQXVCQyxTQUFTLENBQUNELENBQUQsQ0FBaEMsR0FBc0MsRUFBbkQ7SUFDQSxJQUFJSSxPQUFPLEdBQUdDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZSCxNQUFaLENBQWQ7O0lBRUEsSUFBSSxPQUFPRSxNQUFNLENBQUNFLHFCQUFkLEtBQXdDLFVBQTVDLEVBQXdEO01BQ3RESCxPQUFPLEdBQUdBLE9BQU8sQ0FBQ0ksTUFBUixDQUFlSCxNQUFNLENBQUNFLHFCQUFQLENBQTZCSixNQUE3QixFQUFxQ00sTUFBckMsQ0FBNEMsVUFBVUMsR0FBVixFQUFlO1FBQ2xGLE9BQU9MLE1BQU0sQ0FBQ00sd0JBQVAsQ0FBZ0NSLE1BQWhDLEVBQXdDTyxHQUF4QyxFQUE2Q0UsVUFBcEQ7TUFDRCxDQUZ3QixDQUFmLENBQVY7SUFHRDs7SUFFRFIsT0FBTyxDQUFDUyxPQUFSLENBQWdCLFVBQVVDLEdBQVYsRUFBZTtNQUM3QmpCLGdFQUFjLENBQUNFLE1BQUQsRUFBU2UsR0FBVCxFQUFjWCxNQUFNLENBQUNXLEdBQUQsQ0FBcEIsQ0FBZDtJQUNELENBRkQ7RUFHRDs7RUFFRCxPQUFPZixNQUFQO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9zcmMvX29iamVjdF9zcHJlYWQubWpzPzdkNDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gJy4vX2RlZmluZV9wcm9wZXJ0eS5tanMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcclxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XHJcbiAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0YXJnZXQ7XHJcbn0iXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydHkiLCJfb2JqZWN0U3ByZWFkIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsIm93bktleXMiLCJPYmplY3QiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiY29uY2F0IiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImZvckVhY2giLCJrZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_object_spread.mjs\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_object_without_properties.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_object_without_properties.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectWithoutProperties; }\n/* harmony export */ });\n/* harmony import */ var _object_without_properties_loose_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_object_without_properties_loose.mjs */ \"./node_modules/@swc/helpers/src/_object_without_properties_loose.mjs\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = (0,_object_without_properties_loose_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcy5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUVlLFNBQVNDLHdCQUFULENBQWtDQyxNQUFsQyxFQUEwQ0MsUUFBMUMsRUFBb0Q7RUFDakUsSUFBSUQsTUFBTSxJQUFJLElBQWQsRUFBb0IsT0FBTyxFQUFQO0VBQ3BCLElBQUlFLE1BQU0sR0FBR0osZ0ZBQTRCLENBQUNFLE1BQUQsRUFBU0MsUUFBVCxDQUF6QztFQUNBLElBQUlFLEdBQUosRUFBU0MsQ0FBVDs7RUFFQSxJQUFJQyxNQUFNLENBQUNDLHFCQUFYLEVBQWtDO0lBQ2hDLElBQUlDLGdCQUFnQixHQUFHRixNQUFNLENBQUNDLHFCQUFQLENBQTZCTixNQUE3QixDQUF2Qjs7SUFFQSxLQUFLSSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdHLGdCQUFnQixDQUFDQyxNQUFqQyxFQUF5Q0osQ0FBQyxFQUExQyxFQUE4QztNQUM1Q0QsR0FBRyxHQUFHSSxnQkFBZ0IsQ0FBQ0gsQ0FBRCxDQUF0QjtNQUNBLElBQUlILFFBQVEsQ0FBQ1EsT0FBVCxDQUFpQk4sR0FBakIsS0FBeUIsQ0FBN0IsRUFBZ0M7TUFDaEMsSUFBSSxDQUFDRSxNQUFNLENBQUNLLFNBQVAsQ0FBaUJDLG9CQUFqQixDQUFzQ0MsSUFBdEMsQ0FBMkNaLE1BQTNDLEVBQW1ERyxHQUFuRCxDQUFMLEVBQThEO01BQzlERCxNQUFNLENBQUNDLEdBQUQsQ0FBTixHQUFjSCxNQUFNLENBQUNHLEdBQUQsQ0FBcEI7SUFDRDtFQUNGOztFQUVELE9BQU9ELE1BQVA7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcy5tanM/ZDk2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tICcuL19vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlLm1qcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xyXG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xyXG4gIHZhciB0YXJnZXQgPSBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xyXG4gIHZhciBrZXksIGk7XHJcblxyXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XHJcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xyXG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xyXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xyXG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRhcmdldDtcclxufSJdLCJuYW1lcyI6WyJvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwic291cmNlIiwiZXhjbHVkZWQiLCJ0YXJnZXQiLCJrZXkiLCJpIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImxlbmd0aCIsImluZGV4T2YiLCJwcm90b3R5cGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImNhbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_object_without_properties.mjs\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_object_without_properties_loose.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_object_without_properties_loose.mjs ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectWithoutPropertiesLoose; }\n/* harmony export */ });\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZS5tanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlLFNBQVNBLDZCQUFULENBQXVDQyxNQUF2QyxFQUErQ0MsUUFBL0MsRUFBeUQ7RUFDdEUsSUFBSUQsTUFBTSxJQUFJLElBQWQsRUFBb0IsT0FBTyxFQUFQO0VBQ3BCLElBQUlFLE1BQU0sR0FBRyxFQUFiO0VBQ0EsSUFBSUMsVUFBVSxHQUFHQyxNQUFNLENBQUNDLElBQVAsQ0FBWUwsTUFBWixDQUFqQjtFQUNBLElBQUlNLEdBQUosRUFBU0MsQ0FBVDs7RUFFQSxLQUFLQSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdKLFVBQVUsQ0FBQ0ssTUFBM0IsRUFBbUNELENBQUMsRUFBcEMsRUFBd0M7SUFDdENELEdBQUcsR0FBR0gsVUFBVSxDQUFDSSxDQUFELENBQWhCO0lBQ0EsSUFBSU4sUUFBUSxDQUFDUSxPQUFULENBQWlCSCxHQUFqQixLQUF5QixDQUE3QixFQUFnQztJQUNoQ0osTUFBTSxDQUFDSSxHQUFELENBQU4sR0FBY04sTUFBTSxDQUFDTSxHQUFELENBQXBCO0VBQ0Q7O0VBRUQsT0FBT0osTUFBUDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvc3JjL19vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlLm1qcz8yMGI3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcclxuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcclxuICB2YXIgdGFyZ2V0ID0ge307XHJcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xyXG4gIHZhciBrZXksIGk7XHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xyXG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcclxuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsInNvdXJjZSIsImV4Y2x1ZGVkIiwidGFyZ2V0Iiwic291cmNlS2V5cyIsIk9iamVjdCIsImtleXMiLCJrZXkiLCJpIiwibGVuZ3RoIiwiaW5kZXhPZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_object_without_properties_loose.mjs\n"));

/***/ }),

/***/ "./node_modules/swr/dist/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/swr/dist/index.mjs ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SWRConfig\": function() { return /* binding */ SWRConfig; },\n/* harmony export */   \"default\": function() { return /* binding */ useSWR; },\n/* harmony export */   \"mutate\": function() { return /* binding */ mutate; },\n/* harmony export */   \"unstable_serialize\": function() { return /* binding */ unstable_serialize; },\n/* harmony export */   \"useSWRConfig\": function() { return /* binding */ useSWRConfig; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nvar noop = function () {}; // Using noop() as the undefined value as undefined can possibly be replaced\n// by something else.  Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\n\n\nvar UNDEFINED =\n/*#__NOINLINE__*/\nnoop();\nvar OBJECT = Object;\n\nvar isUndefined = function (v) {\n  return v === UNDEFINED;\n};\n\nvar isFunction = function (v) {\n  return typeof v == 'function';\n};\n\nvar mergeObjects = function (a, b) {\n  return OBJECT.assign({}, a, b);\n};\n\nvar STR_UNDEFINED = 'undefined'; // NOTE: Use function to guarantee it's re-evaluated between jsdom and node runtime for tests.\n\nvar hasWindow = function () {\n  return typeof window != STR_UNDEFINED;\n};\n\nvar hasDocument = function () {\n  return typeof document != STR_UNDEFINED;\n};\n\nvar hasRequestAnimationFrame = function () {\n  return hasWindow() && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\n}; // use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\n\n\nvar table = new WeakMap(); // counter of the key\n\nvar counter = 0; // A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsible.\n\nvar stableHash = function (arg) {\n  var type = typeof arg;\n  var constructor = arg && arg.constructor;\n  var isDate = constructor == Date;\n  var result;\n  var index;\n\n  if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n    // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n    // If it's already hashed, directly return the result.\n    result = table.get(arg);\n    if (result) return result; // Store the hash first for circular reference detection before entering the\n    // recursive `stableHash` calls.\n    // For other objects like set and map, we use this id directly as the hash.\n\n    result = ++counter + '~';\n    table.set(arg, result);\n\n    if (constructor == Array) {\n      // Array.\n      result = '@';\n\n      for (index = 0; index < arg.length; index++) {\n        result += stableHash(arg[index]) + ',';\n      }\n\n      table.set(arg, result);\n    }\n\n    if (constructor == OBJECT) {\n      // Object, sort keys.\n      result = '#';\n      var keys = OBJECT.keys(arg).sort();\n\n      while (!isUndefined(index = keys.pop())) {\n        if (!isUndefined(arg[index])) {\n          result += index + ':' + stableHash(arg[index]) + ',';\n        }\n      }\n\n      table.set(arg, result);\n    }\n  } else {\n    result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n  }\n\n  return result;\n};\n/**\r\n * Due to bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\r\n * it's not reliable to detect if the browser is currently online or offline\r\n * based on `navigator.onLine`.\r\n * As a work around, we always assume it's online on first load, and change\r\n * the status upon `online` or `offline` events.\r\n */\n\n\nvar online = true;\n\nvar isOnline = function () {\n  return online;\n};\n\nvar hasWin = hasWindow();\nvar hasDoc = hasDocument(); // For node and React Native, `add/removeEventListener` doesn't exist on window.\n\nvar onWindowEvent = hasWin && window.addEventListener ? window.addEventListener.bind(window) : noop;\nvar onDocumentEvent = hasDoc ? document.addEventListener.bind(document) : noop;\nvar offWindowEvent = hasWin && window.removeEventListener ? window.removeEventListener.bind(window) : noop;\nvar offDocumentEvent = hasDoc ? document.removeEventListener.bind(document) : noop;\n\nvar isVisible = function () {\n  var visibilityState = hasDoc && document.visibilityState;\n  return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\n\nvar initFocus = function (callback) {\n  // focus revalidate\n  onDocumentEvent('visibilitychange', callback);\n  onWindowEvent('focus', callback);\n  return function () {\n    offDocumentEvent('visibilitychange', callback);\n    offWindowEvent('focus', callback);\n  };\n};\n\nvar initReconnect = function (callback) {\n  // revalidate on reconnected\n  var onOnline = function () {\n    online = true;\n    callback();\n  }; // nothing to revalidate, just update the status\n\n\n  var onOffline = function () {\n    online = false;\n  };\n\n  onWindowEvent('online', onOnline);\n  onWindowEvent('offline', onOffline);\n  return function () {\n    offWindowEvent('online', onOnline);\n    offWindowEvent('offline', onOffline);\n  };\n};\n\nvar preset = {\n  isOnline: isOnline,\n  isVisible: isVisible\n};\nvar defaultConfigOptions = {\n  initFocus: initFocus,\n  initReconnect: initReconnect\n};\nvar IS_SERVER = !hasWindow() || 'Deno' in window; // Polyfill requestAnimationFrame\n\nvar rAF = function (f) {\n  return hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);\n}; // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\n\n\nvar useIsomorphicLayoutEffect = IS_SERVER ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect; // This assignment is to extend the Navigator type to use effectiveType.\n\nvar navigatorConnection = typeof navigator !== 'undefined' && navigator.connection; // Adjust the config based on slow connection status (<= 70Kbps).\n\nvar slowConnection = !IS_SERVER && navigatorConnection && (['slow-2g', '2g'].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\n\nvar serialize = function (key) {\n  if (isFunction(key)) {\n    try {\n      key = key();\n    } catch (err) {\n      // dependencies not ready\n      key = '';\n    }\n  }\n\n  var args = [].concat(key); // If key is not falsy, or not an empty array, hash it.\n\n  key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n  var infoKey = key ? '$swr$' + key : '';\n  return [key, args, infoKey];\n}; // Global state used to deduplicate requests and store listeners\n\n\nvar SWRGlobalState = new WeakMap();\nvar FOCUS_EVENT = 0;\nvar RECONNECT_EVENT = 1;\nvar MUTATE_EVENT = 2;\n\nvar broadcastState = function (cache, key, data, error, isValidating, revalidate, broadcast) {\n  if (broadcast === void 0) {\n    broadcast = true;\n  }\n\n  var _a = SWRGlobalState.get(cache),\n      EVENT_REVALIDATORS = _a[0],\n      STATE_UPDATERS = _a[1],\n      FETCH = _a[3];\n\n  var revalidators = EVENT_REVALIDATORS[key];\n  var updaters = STATE_UPDATERS[key]; // Cache was populated, update states of all hooks.\n\n  if (broadcast && updaters) {\n    for (var i = 0; i < updaters.length; ++i) {\n      updaters[i](data, error, isValidating);\n    }\n  } // If we also need to revalidate, only do it for the first hook.\n\n\n  if (revalidate) {\n    // Invalidate the key by deleting the concurrent request markers so new\n    // requests will not be deduped.\n    delete FETCH[key];\n\n    if (revalidators && revalidators[0]) {\n      return revalidators[0](MUTATE_EVENT).then(function () {\n        return cache.get(key);\n      });\n    }\n  }\n\n  return cache.get(key);\n}; // Global timestamp.\n\n\nvar __timestamp = 0;\n\nvar getTimestamp = function () {\n  return ++__timestamp;\n};\n\nvar internalMutate = function () {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  return __awaiter(void 0, void 0, void 0, function () {\n    var cache, _key, _data, _opts, options, populateCache, revalidate, rollbackOnError, customOptimisticData, _a, key, keyInfo, _b, MUTATION, data, error, beforeMutationTs, hasCustomOptimisticData, rollbackData, optimisticData, res;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          cache = args[0], _key = args[1], _data = args[2], _opts = args[3];\n          options = typeof _opts === 'boolean' ? {\n            revalidate: _opts\n          } : _opts || {};\n          populateCache = isUndefined(options.populateCache) ? true : options.populateCache;\n          revalidate = options.revalidate !== false;\n          rollbackOnError = options.rollbackOnError !== false;\n          customOptimisticData = options.optimisticData;\n          _a = serialize(_key), key = _a[0], keyInfo = _a[2];\n          if (!key) return [2\n          /*return*/\n          ];\n          _b = SWRGlobalState.get(cache), MUTATION = _b[2]; // If there is no new data provided, revalidate the key with current state.\n\n          if (args.length < 3) {\n            // Revalidate and broadcast state.\n            return [2\n            /*return*/\n            , broadcastState(cache, key, cache.get(key), UNDEFINED, UNDEFINED, revalidate, true)];\n          }\n\n          data = _data;\n          beforeMutationTs = getTimestamp();\n          MUTATION[key] = [beforeMutationTs, 0];\n          hasCustomOptimisticData = !isUndefined(customOptimisticData);\n          rollbackData = cache.get(key); // Do optimistic data update.\n\n          if (hasCustomOptimisticData) {\n            optimisticData = isFunction(customOptimisticData) ? customOptimisticData(rollbackData) : customOptimisticData;\n            cache.set(key, optimisticData);\n            broadcastState(cache, key, optimisticData);\n          }\n\n          if (isFunction(data)) {\n            // `data` is a function, call it passing current cache value.\n            try {\n              data = data(cache.get(key));\n            } catch (err) {\n              // If it throws an error synchronously, we shouldn't update the cache.\n              error = err;\n            }\n          }\n\n          if (!(data && isFunction(data.then))) return [3\n          /*break*/\n          , 2];\n          return [4\n          /*yield*/\n          , data.catch(function (err) {\n            error = err;\n          }) // Check if other mutations have occurred since we've started this mutation.\n          // If there's a race we don't update cache or broadcast the change,\n          // just return the data.\n          ];\n\n        case 1:\n          // This means that the mutation is async, we need to check timestamps to\n          // avoid race conditions.\n          data = _c.sent(); // Check if other mutations have occurred since we've started this mutation.\n          // If there's a race we don't update cache or broadcast the change,\n          // just return the data.\n\n          if (beforeMutationTs !== MUTATION[key][0]) {\n            if (error) throw error;\n            return [2\n            /*return*/\n            , data];\n          } else if (error && hasCustomOptimisticData && rollbackOnError) {\n            // Rollback. Always populate the cache in this case but without\n            // transforming the data.\n            populateCache = true;\n            data = rollbackData;\n            cache.set(key, rollbackData);\n          }\n\n          _c.label = 2;\n\n        case 2:\n          // If we should write back the cache after request.\n          if (populateCache) {\n            if (!error) {\n              // Transform the result into data.\n              if (isFunction(populateCache)) {\n                data = populateCache(data, rollbackData);\n              } // Only update cached data if there's no error. Data can be `undefined` here.\n\n\n              cache.set(key, data);\n            } // Always update or reset the error.\n\n\n            cache.set(keyInfo, mergeObjects(cache.get(keyInfo), {\n              error: error\n            }));\n          } // Reset the timestamp to mark the mutation has ended.\n\n\n          MUTATION[key][1] = getTimestamp();\n          return [4\n          /*yield*/\n          , broadcastState(cache, key, data, error, UNDEFINED, revalidate, !!populateCache) // Throw error or return data\n          ];\n\n        case 3:\n          res = _c.sent(); // Throw error or return data\n\n          if (error) throw error;\n          return [2\n          /*return*/\n          , populateCache ? res : data];\n      }\n    });\n  });\n};\n\nvar revalidateAllKeys = function (revalidators, type) {\n  for (var key in revalidators) {\n    if (revalidators[key][0]) revalidators[key][0](type);\n  }\n};\n\nvar initCache = function (provider, options) {\n  // The global state for a specific provider will be used to deduplicate\n  // requests and store listeners. As well as a mutate function that bound to\n  // the cache.\n  // Provider's global state might be already initialized. Let's try to get the\n  // global state associated with the provider first.\n  if (!SWRGlobalState.has(provider)) {\n    var opts = mergeObjects(defaultConfigOptions, options); // If there's no global state bound to the provider, create a new one with the\n    // new mutate function.\n\n    var EVENT_REVALIDATORS = {};\n    var mutate = internalMutate.bind(UNDEFINED, provider);\n    var unmount = noop; // Update the state if it's new, or the provider has been extended.\n\n    SWRGlobalState.set(provider, [EVENT_REVALIDATORS, {}, {}, {}, mutate]); // This is a new provider, we need to initialize it and setup DOM events\n    // listeners for `focus` and `reconnect` actions.\n\n    if (!IS_SERVER) {\n      // When listening to the native events for auto revalidations,\n      // we intentionally put a delay (setTimeout) here to make sure they are\n      // fired after immediate JavaScript executions, which can possibly be\n      // React's state updates.\n      // This avoids some unnecessary revalidations such as\n      // https://github.com/vercel/swr/issues/1680.\n      var releaseFocus_1 = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n      var releaseReconnect_1 = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n\n      unmount = function () {\n        releaseFocus_1 && releaseFocus_1();\n        releaseReconnect_1 && releaseReconnect_1(); // When un-mounting, we need to remove the cache provider from the state\n        // storage too because it's a side-effect. Otherwise when re-mounting we\n        // will not re-register those event listeners.\n\n        SWRGlobalState.delete(provider);\n      };\n    } // We might want to inject an extra layer on top of `provider` in the future,\n    // such as key serialization, auto GC, etc.\n    // For now, it's just a `Map` interface without any modifications.\n\n\n    return [provider, mutate, unmount];\n  }\n\n  return [provider, SWRGlobalState.get(provider)[4]];\n}; // error retry\n\n\nvar onErrorRetry = function (_, __, config, revalidate, opts) {\n  var maxRetryCount = config.errorRetryCount;\n  var currentRetryCount = opts.retryCount; // Exponential backoff\n\n  var timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n\n  if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n    return;\n  }\n\n  setTimeout(revalidate, timeout, opts);\n}; // Default cache provider\n\n\nvar _a = initCache(new Map()),\n    cache = _a[0],\n    mutate = _a[1]; // Default config\n\n\nvar defaultConfig = mergeObjects({\n  // events\n  onLoadingSlow: noop,\n  onSuccess: noop,\n  onError: noop,\n  onErrorRetry: onErrorRetry,\n  onDiscarded: noop,\n  // switches\n  revalidateOnFocus: true,\n  revalidateOnReconnect: true,\n  revalidateIfStale: true,\n  shouldRetryOnError: true,\n  // timeouts\n  errorRetryInterval: slowConnection ? 10000 : 5000,\n  focusThrottleInterval: 5 * 1000,\n  dedupingInterval: 2 * 1000,\n  loadingTimeout: slowConnection ? 5000 : 3000,\n  // providers\n  compare: function (currentData, newData) {\n    return stableHash(currentData) == stableHash(newData);\n  },\n  isPaused: function () {\n    return false;\n  },\n  cache: cache,\n  mutate: mutate,\n  fallback: {}\n}, // use web preset by default\npreset);\n\nvar mergeConfigs = function (a, b) {\n  // Need to create a new object to avoid mutating the original here.\n  var v = mergeObjects(a, b); // If two configs are provided, merge their `use` and `fallback` options.\n\n  if (b) {\n    var u1 = a.use,\n        f1 = a.fallback;\n    var u2 = b.use,\n        f2 = b.fallback;\n\n    if (u1 && u2) {\n      v.use = u1.concat(u2);\n    }\n\n    if (f1 && f2) {\n      v.fallback = mergeObjects(f1, f2);\n    }\n  }\n\n  return v;\n};\n\nvar SWRConfigContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\n\nvar SWRConfig$1 = function (props) {\n  var value = props.value; // Extend parent context values and middleware.\n\n  var extendedConfig = mergeConfigs((0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext), value); // Should not use the inherited provider.\n\n  var provider = value && value.provider; // Use a lazy initialized state to create the cache on first access.\n\n  var cacheContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function () {\n    return provider ? initCache(provider(extendedConfig.cache || cache), value) : UNDEFINED;\n  })[0]; // Override the cache if a new provider is given.\n\n  if (cacheContext) {\n    extendedConfig.cache = cacheContext[0];\n    extendedConfig.mutate = cacheContext[1];\n  } // Unsubscribe events.\n\n\n  useIsomorphicLayoutEffect(function () {\n    return cacheContext ? cacheContext[2] : UNDEFINED;\n  }, []);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SWRConfigContext.Provider, mergeObjects(props, {\n    value: extendedConfig\n  }));\n};\n/**\r\n * An implementation of state with dependency-tracking.\r\n */\n\n\nvar useStateWithDeps = function (state, unmountedRef) {\n  var rerender = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({})[1];\n  var stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state); // If a state property (data, error or isValidating) is accessed by the render\n  // function, we mark the property as a dependency so if it is updated again\n  // in the future, we trigger a rerender.\n  // This is also known as dependency-tracking.\n\n  var stateDependenciesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    data: false,\n    error: false,\n    isValidating: false\n  });\n  /**\r\n   * @param payload To change stateRef, pass the values explicitly to setState:\r\n   * @example\r\n   * ```js\r\n   * setState({\r\n   *   isValidating: false\r\n   *   data: newData // set data to newData\r\n   *   error: undefined // set error to undefined\r\n   * })\r\n   *\r\n   * setState({\r\n   *   isValidating: false\r\n   *   data: undefined // set data to undefined\r\n   *   error: err // set error to err\r\n   * })\r\n   * ```\r\n   */\n\n  var setState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (payload) {\n    var shouldRerender = false;\n    var currentState = stateRef.current;\n\n    for (var _ in payload) {\n      var k = _; // If the property has changed, update the state and mark rerender as\n      // needed.\n\n      if (currentState[k] !== payload[k]) {\n        currentState[k] = payload[k]; // If the property is accessed by the component, a rerender should be\n        // triggered.\n\n        if (stateDependenciesRef.current[k]) {\n          shouldRerender = true;\n        }\n      }\n    }\n\n    if (shouldRerender && !unmountedRef.current) {\n      rerender({});\n    }\n  }, // config.suspense isn't allowed to change during the lifecycle\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []); // Always update the state reference.\n\n  useIsomorphicLayoutEffect(function () {\n    stateRef.current = state;\n  });\n  return [stateRef, stateDependenciesRef.current, setState];\n};\n\nvar normalize = function (args) {\n  return isFunction(args[1]) ? [args[0], args[1], args[2] || {}] : [args[0], null, (args[1] === null ? args[2] : args[1]) || {}];\n};\n\nvar useSWRConfig = function () {\n  return mergeObjects(defaultConfig, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext));\n}; // It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\n\n\nvar withArgs = function (hook) {\n  return function useSWRArgs() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    } // Get the default and inherited configuration.\n\n\n    var fallbackConfig = useSWRConfig(); // Normalize arguments.\n\n    var _a = normalize(args),\n        key = _a[0],\n        fn = _a[1],\n        _config = _a[2]; // Merge configurations.\n\n\n    var config = mergeConfigs(fallbackConfig, _config); // Apply middleware\n\n    var next = hook;\n    var use = config.use;\n\n    if (use) {\n      for (var i = use.length; i-- > 0;) {\n        next = use[i](next);\n      }\n    }\n\n    return next(key, fn || config.fetcher, config);\n  };\n}; // Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\n\n\nvar subscribeCallback = function (key, callbacks, callback) {\n  var keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n  keyedRevalidators.push(callback);\n  return function () {\n    var index = keyedRevalidators.indexOf(callback);\n\n    if (index >= 0) {\n      // O(1): faster than splice\n      keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n      keyedRevalidators.pop();\n    }\n  };\n};\n\nvar WITH_DEDUPE = {\n  dedupe: true\n};\n\nvar useSWRHandler = function (_key, fetcher, config) {\n  var cache = config.cache,\n      compare = config.compare,\n      fallbackData = config.fallbackData,\n      suspense = config.suspense,\n      revalidateOnMount = config.revalidateOnMount,\n      refreshInterval = config.refreshInterval,\n      refreshWhenHidden = config.refreshWhenHidden,\n      refreshWhenOffline = config.refreshWhenOffline;\n\n  var _a = SWRGlobalState.get(cache),\n      EVENT_REVALIDATORS = _a[0],\n      STATE_UPDATERS = _a[1],\n      MUTATION = _a[2],\n      FETCH = _a[3]; // `key` is the identifier of the SWR `data` state, `keyInfo` holds extra\n  // states such as `error` and `isValidating` inside,\n  // all of them are derived from `_key`.\n  // `fnArgs` is an array of arguments parsed from the key, which will be passed\n  // to the fetcher.\n\n\n  var _b = serialize(_key),\n      key = _b[0],\n      fnArgs = _b[1],\n      keyInfo = _b[2]; // If it's the initial render of this hook.\n\n\n  var initialMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false); // If the hook is unmounted already. This will be used to prevent some effects\n  // to be called after unmounting.\n\n  var unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false); // Refs to keep the key and config.\n\n  var keyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(key);\n  var fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fetcher);\n  var configRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(config);\n\n  var getConfig = function () {\n    return configRef.current;\n  };\n\n  var isActive = function () {\n    return getConfig().isVisible() && getConfig().isOnline();\n  };\n\n  var patchFetchInfo = function (info) {\n    return cache.set(keyInfo, mergeObjects(cache.get(keyInfo), info));\n  }; // Get the current state that SWR should return.\n\n\n  var cached = cache.get(key);\n  var fallback = isUndefined(fallbackData) ? config.fallback[key] : fallbackData;\n  var data = isUndefined(cached) ? fallback : cached;\n  var info = cache.get(keyInfo) || {};\n  var error = info.error;\n  var isInitialMount = !initialMountedRef.current; // - Suspense mode and there's stale data for the initial render.\n  // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.\n  // - `revalidateIfStale` is enabled but `data` is not defined.\n\n  var shouldRevalidate = function () {\n    // If `revalidateOnMount` is set, we take the value directly.\n    if (isInitialMount && !isUndefined(revalidateOnMount)) return revalidateOnMount; // If it's paused, we skip revalidation.\n\n    if (getConfig().isPaused()) return false; // Under suspense mode, it will always fetch on render if there is no\n    // stale data so no need to revalidate immediately on mount again.\n    // If data exists, only revalidate if `revalidateIfStale` is true.\n\n    if (suspense) return isUndefined(data) ? false : config.revalidateIfStale; // If there is no stale data, we need to revalidate on mount;\n    // If `revalidateIfStale` is set to true, we will always revalidate.\n\n    return isUndefined(data) || config.revalidateIfStale;\n  }; // Resolve the current validating state.\n\n\n  var resolveValidating = function () {\n    if (!key || !fetcher) return false;\n    if (info.isValidating) return true; // If it's not mounted yet and it should revalidate on mount, revalidate.\n\n    return isInitialMount && shouldRevalidate();\n  };\n\n  var isValidating = resolveValidating();\n\n  var _c = useStateWithDeps({\n    data: data,\n    error: error,\n    isValidating: isValidating\n  }, unmountedRef),\n      stateRef = _c[0],\n      stateDependencies = _c[1],\n      setState = _c[2]; // The revalidation function is a carefully crafted wrapper of the original\n  // `fetcher`, to correctly handle the many edge cases.\n\n\n  var revalidate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (revalidateOpts) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var currentFetcher, newData, startAt, loading, opts, shouldStartNewRequest, isCurrentKeyMounted, cleanupState, newState, finishRequestAndUpdateState, mutationInfo, err_1;\n\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            currentFetcher = fetcherRef.current;\n\n            if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {\n              return [2\n              /*return*/\n              , false];\n            }\n\n            loading = true;\n            opts = revalidateOpts || {};\n            shouldStartNewRequest = !FETCH[key] || !opts.dedupe;\n\n            isCurrentKeyMounted = function () {\n              return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;\n            };\n\n            cleanupState = function () {\n              // Check if it's still the same request before deleting.\n              var requestInfo = FETCH[key];\n\n              if (requestInfo && requestInfo[1] === startAt) {\n                delete FETCH[key];\n              }\n            };\n\n            newState = {\n              isValidating: false\n            };\n\n            finishRequestAndUpdateState = function () {\n              patchFetchInfo({\n                isValidating: false\n              }); // We can only set state if it's safe (still mounted with the same key).\n\n              if (isCurrentKeyMounted()) {\n                setState(newState);\n              }\n            }; // Start fetching. Change the `isValidating` state, update the cache.\n\n\n            patchFetchInfo({\n              isValidating: true\n            });\n            setState({\n              isValidating: true\n            });\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n\n            if (shouldStartNewRequest) {\n              // Tell all other hooks to change the `isValidating` state.\n              broadcastState(cache, key, stateRef.current.data, stateRef.current.error, true); // If no cache being rendered currently (it shows a blank page),\n              // we trigger the loading slow event.\n\n              if (config.loadingTimeout && !cache.get(key)) {\n                setTimeout(function () {\n                  if (loading && isCurrentKeyMounted()) {\n                    getConfig().onLoadingSlow(key, config);\n                  }\n                }, config.loadingTimeout);\n              } // Start the request and save the timestamp.\n\n\n              FETCH[key] = [currentFetcher.apply(void 0, fnArgs), getTimestamp()];\n            }\n\n            _a = FETCH[key], newData = _a[0], startAt = _a[1];\n            return [4\n            /*yield*/\n            , newData];\n\n          case 2:\n            newData = _b.sent();\n\n            if (shouldStartNewRequest) {\n              // If the request isn't interrupted, clean it up after the\n              // deduplication interval.\n              setTimeout(cleanupState, config.dedupingInterval);\n            } // If there're other ongoing request(s), started after the current one,\n            // we need to ignore the current one to avoid possible race conditions:\n            //   req1------------------>res1        (current one)\n            //        req2---------------->res2\n            // the request that fired later will always be kept.\n            // The timestamp maybe be `undefined` or a number\n\n\n            if (!FETCH[key] || FETCH[key][1] !== startAt) {\n              if (shouldStartNewRequest) {\n                if (isCurrentKeyMounted()) {\n                  getConfig().onDiscarded(key);\n                }\n              }\n\n              return [2\n              /*return*/\n              , false];\n            } // Clear error.\n\n\n            patchFetchInfo({\n              error: UNDEFINED\n            });\n            newState.error = UNDEFINED;\n            mutationInfo = MUTATION[key];\n\n            if (!isUndefined(mutationInfo) && ( // case 1\n            startAt <= mutationInfo[0] || // case 2\n            startAt <= mutationInfo[1] || // case 3\n            mutationInfo[1] === 0)) {\n              finishRequestAndUpdateState();\n\n              if (shouldStartNewRequest) {\n                if (isCurrentKeyMounted()) {\n                  getConfig().onDiscarded(key);\n                }\n              }\n\n              return [2\n              /*return*/\n              , false];\n            } // Deep compare with latest state to avoid extra re-renders.\n            // For local state, compare and assign.\n\n\n            if (!compare(stateRef.current.data, newData)) {\n              newState.data = newData;\n            } else {\n              // data and newData are deeply equal\n              // it should be safe to broadcast the stale data\n              newState.data = stateRef.current.data; // At the end of this function, `brocastState` invokes the `onStateUpdate` function,\n              // which takes care of avoiding the re-render\n            } // For global state, it's possible that the key has changed.\n            // https://github.com/vercel/swr/pull/1058\n\n\n            if (!compare(cache.get(key), newData)) {\n              cache.set(key, newData);\n            } // Trigger the successful callback if it's the original request.\n\n\n            if (shouldStartNewRequest) {\n              if (isCurrentKeyMounted()) {\n                getConfig().onSuccess(newData, key, config);\n              }\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            err_1 = _b.sent();\n            cleanupState(); // Not paused, we continue handling the error. Otherwise discard it.\n\n            if (!getConfig().isPaused()) {\n              // Get a new error, don't use deep comparison for errors.\n              patchFetchInfo({\n                error: err_1\n              });\n              newState.error = err_1; // Error event and retry logic. Only for the actual request, not\n              // deduped ones.\n\n              if (shouldStartNewRequest && isCurrentKeyMounted()) {\n                getConfig().onError(err_1, key, config);\n\n                if (typeof config.shouldRetryOnError === 'boolean' && config.shouldRetryOnError || isFunction(config.shouldRetryOnError) && config.shouldRetryOnError(err_1)) {\n                  // When retrying, dedupe is always enabled\n                  if (isActive()) {\n                    // If it's active, stop. It will auto revalidate when refocusing\n                    // or reconnecting.\n                    getConfig().onErrorRetry(err_1, key, config, revalidate, {\n                      retryCount: (opts.retryCount || 0) + 1,\n                      dedupe: true\n                    });\n                  }\n                }\n              }\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            // Mark loading as stopped.\n            loading = false; // Update the current hook's state.\n\n            finishRequestAndUpdateState(); // Here is the source of the request, need to tell all other hooks to\n            // update their states.\n\n            if (isCurrentKeyMounted() && shouldStartNewRequest) {\n              broadcastState(cache, key, newState.data, newState.error, false);\n            }\n\n            return [2\n            /*return*/\n            , true];\n        }\n      });\n    });\n  }, // `setState` is immutable, and `eventsCallback`, `fnArgs`, `keyInfo`,\n  // and `keyValidating` are depending on `key`, so we can exclude them from\n  // the deps array.\n  //\n  // FIXME:\n  // `fn` and `config` might be changed during the lifecycle,\n  // but they might be changed every render like this.\n  // `useSWR('key', () => fetch('/api/'), { suspense: true })`\n  // So we omit the values from the deps array\n  // even though it might cause unexpected behaviors.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [key]); // Similar to the global mutate, but bound to the current cache and key.\n  // `cache` isn't allowed to change during the lifecycle.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  var boundMutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)( // By using `bind` we don't need to modify the size of the rest arguments.\n  // Due to https://github.com/microsoft/TypeScript/issues/37181, we have to\n  // cast it to any for now.\n  internalMutate.bind(UNDEFINED, cache, function () {\n    return keyRef.current;\n  }), // eslint-disable-next-line react-hooks/exhaustive-deps\n  []); // Always update fetcher and config refs.\n\n  useIsomorphicLayoutEffect(function () {\n    fetcherRef.current = fetcher;\n    configRef.current = config;\n  }); // After mounted or key changed.\n\n  useIsomorphicLayoutEffect(function () {\n    if (!key) return;\n    var keyChanged = key !== keyRef.current;\n    var softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE); // Expose state updater to global event listeners. So we can update hook's\n    // internal state from the outside.\n\n    var onStateUpdate = function (updatedData, updatedError, updatedIsValidating) {\n      setState(mergeObjects({\n        error: updatedError,\n        isValidating: updatedIsValidating\n      }, // Since `setState` only shallowly compares states, we do a deep\n      // comparison here.\n      compare(stateRef.current.data, updatedData) ? UNDEFINED : {\n        data: updatedData\n      }));\n    }; // Expose revalidators to global event listeners. So we can trigger\n    // revalidation from the outside.\n\n\n    var nextFocusRevalidatedAt = 0;\n\n    var onRevalidate = function (type) {\n      if (type == FOCUS_EVENT) {\n        var now = Date.now();\n\n        if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {\n          nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;\n          softRevalidate();\n        }\n      } else if (type == RECONNECT_EVENT) {\n        if (getConfig().revalidateOnReconnect && isActive()) {\n          softRevalidate();\n        }\n      } else if (type == MUTATE_EVENT) {\n        return revalidate();\n      }\n\n      return;\n    };\n\n    var unsubUpdate = subscribeCallback(key, STATE_UPDATERS, onStateUpdate);\n    var unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate); // Mark the component as mounted and update corresponding refs.\n\n    unmountedRef.current = false;\n    keyRef.current = key;\n    initialMountedRef.current = true; // When `key` updates, reset the state to the initial value\n    // and trigger a rerender if necessary.\n\n    if (keyChanged) {\n      setState({\n        data: data,\n        error: error,\n        isValidating: isValidating\n      });\n    } // Trigger a revalidation.\n\n\n    if (shouldRevalidate()) {\n      if (isUndefined(data) || IS_SERVER) {\n        // Revalidate immediately.\n        softRevalidate();\n      } else {\n        // Delay the revalidate if we have data to return so we won't block\n        // rendering.\n        rAF(softRevalidate);\n      }\n    }\n\n    return function () {\n      // Mark it as unmounted.\n      unmountedRef.current = true;\n      unsubUpdate();\n      unsubEvents();\n    };\n  }, [key, revalidate]); // Polling\n\n  useIsomorphicLayoutEffect(function () {\n    var timer;\n\n    function next() {\n      // Use the passed interval\n      // ...or invoke the function with the updated data to get the interval\n      var interval = isFunction(refreshInterval) ? refreshInterval(data) : refreshInterval; // We only start next interval if `refreshInterval` is not 0, and:\n      // - `force` is true, which is the start of polling\n      // - or `timer` is not 0, which means the effect wasn't canceled\n\n      if (interval && timer !== -1) {\n        timer = setTimeout(execute, interval);\n      }\n    }\n\n    function execute() {\n      // Check if it's OK to execute:\n      // Only revalidate when the page is visible, online and not errored.\n      if (!stateRef.current.error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {\n        revalidate(WITH_DEDUPE).then(next);\n      } else {\n        // Schedule next interval to check again.\n        next();\n      }\n    }\n\n    next();\n    return function () {\n      if (timer) {\n        clearTimeout(timer);\n        timer = -1;\n      }\n    };\n  }, [refreshInterval, refreshWhenHidden, refreshWhenOffline, revalidate]); // Display debug info in React DevTools.\n\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(data); // In Suspense mode, we can't return the empty `data` state.\n  // If there is `error`, the `error` needs to be thrown to the error boundary.\n  // If there is no `error`, the `revalidation` promise needs to be thrown to\n  // the suspense boundary.\n\n  if (suspense && isUndefined(data) && key) {\n    // Always update fetcher and config refs even with the Suspense mode.\n    fetcherRef.current = fetcher;\n    configRef.current = config;\n    unmountedRef.current = false;\n    throw isUndefined(error) ? revalidate(WITH_DEDUPE) : error;\n  }\n\n  return {\n    mutate: boundMutate,\n\n    get data() {\n      stateDependencies.data = true;\n      return data;\n    },\n\n    get error() {\n      stateDependencies.error = true;\n      return error;\n    },\n\n    get isValidating() {\n      stateDependencies.isValidating = true;\n      return isValidating;\n    }\n\n  };\n};\n\nvar SWRConfig = OBJECT.defineProperty(SWRConfig$1, 'default', {\n  value: defaultConfig\n});\n\nvar unstable_serialize = function (key) {\n  return serialize(key)[0];\n};\n\nvar useSWR = withArgs(useSWRHandler); // useSWR\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBMEM7SUFDdEM7SUFDQXNJLFVBQVUsQ0FBQzNCLE9BQVgsR0FBcUJVLE9BQXJCO0lBQ0FrQixTQUFTLENBQUM1QixPQUFWLEdBQW9CakQsTUFBcEI7SUFDQXlDLFlBQVksQ0FBQ1EsT0FBYixHQUF1QixLQUF2QjtJQUNBLE1BQU0zSyxXQUFXLENBQUM2RSxLQUFELENBQVgsR0FBcUJFLFVBQVUsQ0FBQzJHLFdBQUQsQ0FBL0IsR0FBK0M3RyxLQUFyRDtFQUNIOztFQUNELE9BQU87SUFDSHNDLE1BQU0sRUFBRTBHLFdBREw7O0lBRUgsSUFBSWpKLElBQUosR0FBVztNQUNQb0ksaUJBQWlCLENBQUNwSSxJQUFsQixHQUF5QixJQUF6QjtNQUNBLE9BQU9BLElBQVA7SUFDSCxDQUxFOztJQU1ILElBQUlDLEtBQUosR0FBWTtNQUNSbUksaUJBQWlCLENBQUNuSSxLQUFsQixHQUEwQixJQUExQjtNQUNBLE9BQU9BLEtBQVA7SUFDSCxDQVRFOztJQVVILElBQUlDLFlBQUosR0FBbUI7TUFDZmtJLGlCQUFpQixDQUFDbEksWUFBbEIsR0FBaUMsSUFBakM7TUFDQSxPQUFPQSxZQUFQO0lBQ0g7O0VBYkUsQ0FBUDtBQWVILENBeFpEOztBQXlaQSxJQUFJK0osU0FBUyxHQUFHL08sTUFBTSxDQUFDZ1AsY0FBUCxDQUFzQmxGLFdBQXRCLEVBQW1DLFNBQW5DLEVBQThDO0VBQzFEbk0sS0FBSyxFQUFFMks7QUFEbUQsQ0FBOUMsQ0FBaEI7O0FBR0EsSUFBSTJHLGtCQUFrQixHQUFHLFVBQVUvSyxHQUFWLEVBQWU7RUFBRSxPQUFPRCxTQUFTLENBQUNDLEdBQUQsQ0FBVCxDQUFlLENBQWYsQ0FBUDtBQUEyQixDQUFyRTs7QUFDQSxJQUFJZ0wsTUFBTSxHQUFHakUsUUFBUSxDQUFDYSxhQUFELENBQXJCLEVBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N3ci9kaXN0L2luZGV4Lm1qcz82MmUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgY3JlYXRlRWxlbWVudCwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlRGVidWdWYWx1ZSB9IGZyb20gJ3JlYWN0JztcclxuXHJcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XHJcbi8vIFVzaW5nIG5vb3AoKSBhcyB0aGUgdW5kZWZpbmVkIHZhbHVlIGFzIHVuZGVmaW5lZCBjYW4gcG9zc2libHkgYmUgcmVwbGFjZWRcclxuLy8gYnkgc29tZXRoaW5nIGVsc2UuICBQcmV0dGllciBpZ25vcmUgYW5kIGV4dHJhIHBhcmVudGhlc2VzIGFyZSBuZWNlc3NhcnkgaGVyZVxyXG4vLyB0byBlbnN1cmUgdGhhdCB0c2MgZG9lc24ndCByZW1vdmUgdGhlIF9fTk9JTkxJTkVfXyBjb21tZW50LlxyXG4vLyBwcmV0dGllci1pZ25vcmVcclxudmFyIFVOREVGSU5FRCA9ICggLyojX19OT0lOTElORV9fKi9ub29wKCkpO1xyXG52YXIgT0JKRUNUID0gT2JqZWN0O1xyXG52YXIgaXNVbmRlZmluZWQgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdiA9PT0gVU5ERUZJTkVEOyB9O1xyXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0eXBlb2YgdiA9PSAnZnVuY3Rpb24nOyB9O1xyXG52YXIgbWVyZ2VPYmplY3RzID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIE9CSkVDVC5hc3NpZ24oe30sIGEsIGIpOyB9O1xyXG52YXIgU1RSX1VOREVGSU5FRCA9ICd1bmRlZmluZWQnO1xyXG4vLyBOT1RFOiBVc2UgZnVuY3Rpb24gdG8gZ3VhcmFudGVlIGl0J3MgcmUtZXZhbHVhdGVkIGJldHdlZW4ganNkb20gYW5kIG5vZGUgcnVudGltZSBmb3IgdGVzdHMuXHJcbnZhciBoYXNXaW5kb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlb2Ygd2luZG93ICE9IFNUUl9VTkRFRklORUQ7IH07XHJcbnZhciBoYXNEb2N1bWVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPSBTVFJfVU5ERUZJTkVEOyB9O1xyXG52YXIgaGFzUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGhhc1dpbmRvdygpICYmIHR5cGVvZiB3aW5kb3dbJ3JlcXVlc3RBbmltYXRpb25GcmFtZSddICE9IFNUUl9VTkRFRklORUQ7XHJcbn07XHJcblxyXG4vLyB1c2UgV2Vha01hcCB0byBzdG9yZSB0aGUgb2JqZWN0LT5rZXkgbWFwcGluZ1xyXG4vLyBzbyB0aGUgb2JqZWN0cyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXHJcbi8vIFdlYWtNYXAgdXNlcyBhIGhhc2h0YWJsZSB1bmRlciB0aGUgaG9vZCwgc28gdGhlIGxvb2t1cFxyXG4vLyBjb21wbGV4aXR5IGlzIGFsbW9zdCBPKDEpLlxyXG52YXIgdGFibGUgPSBuZXcgV2Vha01hcCgpO1xyXG4vLyBjb3VudGVyIG9mIHRoZSBrZXlcclxudmFyIGNvdW50ZXIgPSAwO1xyXG4vLyBBIHN0YWJsZSBoYXNoIGltcGxlbWVudGF0aW9uIHRoYXQgc3VwcG9ydHM6XHJcbi8vIC0gRmFzdCBhbmQgZW5zdXJlcyB1bmlxdWUgaGFzaCBwcm9wZXJ0aWVzXHJcbi8vIC0gSGFuZGxlcyB1bnNlcmlhbGl6YWJsZSB2YWx1ZXNcclxuLy8gLSBIYW5kbGVzIG9iamVjdCBrZXkgb3JkZXJpbmdcclxuLy8gLSBHZW5lcmF0ZXMgc2hvcnQgcmVzdWx0c1xyXG4vL1xyXG4vLyBUaGlzIGlzIG5vdCBhIHNlcmlhbGl6YXRpb24gZnVuY3Rpb24sIGFuZCB0aGUgcmVzdWx0IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlXHJcbi8vIHBhcnNpYmxlLlxyXG52YXIgc3RhYmxlSGFzaCA9IGZ1bmN0aW9uIChhcmcpIHtcclxuICAgIHZhciB0eXBlID0gdHlwZW9mIGFyZztcclxuICAgIHZhciBjb25zdHJ1Y3RvciA9IGFyZyAmJiBhcmcuY29uc3RydWN0b3I7XHJcbiAgICB2YXIgaXNEYXRlID0gY29uc3RydWN0b3IgPT0gRGF0ZTtcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICB2YXIgaW5kZXg7XHJcbiAgICBpZiAoT0JKRUNUKGFyZykgPT09IGFyZyAmJiAhaXNEYXRlICYmIGNvbnN0cnVjdG9yICE9IFJlZ0V4cCkge1xyXG4gICAgICAgIC8vIE9iamVjdC9mdW5jdGlvbiwgbm90IG51bGwvZGF0ZS9yZWdleHAuIFVzZSBXZWFrTWFwIHRvIHN0b3JlIHRoZSBpZCBmaXJzdC5cclxuICAgICAgICAvLyBJZiBpdCdzIGFscmVhZHkgaGFzaGVkLCBkaXJlY3RseSByZXR1cm4gdGhlIHJlc3VsdC5cclxuICAgICAgICByZXN1bHQgPSB0YWJsZS5nZXQoYXJnKTtcclxuICAgICAgICBpZiAocmVzdWx0KVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIC8vIFN0b3JlIHRoZSBoYXNoIGZpcnN0IGZvciBjaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0aW9uIGJlZm9yZSBlbnRlcmluZyB0aGVcclxuICAgICAgICAvLyByZWN1cnNpdmUgYHN0YWJsZUhhc2hgIGNhbGxzLlxyXG4gICAgICAgIC8vIEZvciBvdGhlciBvYmplY3RzIGxpa2Ugc2V0IGFuZCBtYXAsIHdlIHVzZSB0aGlzIGlkIGRpcmVjdGx5IGFzIHRoZSBoYXNoLlxyXG4gICAgICAgIHJlc3VsdCA9ICsrY291bnRlciArICd+JztcclxuICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xyXG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PSBBcnJheSkge1xyXG4gICAgICAgICAgICAvLyBBcnJheS5cclxuICAgICAgICAgICAgcmVzdWx0ID0gJ0AnO1xyXG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBhcmcubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RhYmxlSGFzaChhcmdbaW5kZXhdKSArICcsJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT0gT0JKRUNUKSB7XHJcbiAgICAgICAgICAgIC8vIE9iamVjdCwgc29ydCBrZXlzLlxyXG4gICAgICAgICAgICByZXN1bHQgPSAnIyc7XHJcbiAgICAgICAgICAgIHZhciBrZXlzID0gT0JKRUNULmtleXMoYXJnKS5zb3J0KCk7XHJcbiAgICAgICAgICAgIHdoaWxlICghaXNVbmRlZmluZWQoKGluZGV4ID0ga2V5cy5wb3AoKSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGFyZ1tpbmRleF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGluZGV4ICsgJzonICsgc3RhYmxlSGFzaChhcmdbaW5kZXhdKSArICcsJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCA9IGlzRGF0ZVxyXG4gICAgICAgICAgICA/IGFyZy50b0pTT04oKVxyXG4gICAgICAgICAgICA6IHR5cGUgPT0gJ3N5bWJvbCdcclxuICAgICAgICAgICAgICAgID8gYXJnLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgICAgIDogdHlwZSA9PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoYXJnKVxyXG4gICAgICAgICAgICAgICAgICAgIDogJycgKyBhcmc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIER1ZSB0byBidWcgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Njc4MDc1LFxyXG4gKiBpdCdzIG5vdCByZWxpYWJsZSB0byBkZXRlY3QgaWYgdGhlIGJyb3dzZXIgaXMgY3VycmVudGx5IG9ubGluZSBvciBvZmZsaW5lXHJcbiAqIGJhc2VkIG9uIGBuYXZpZ2F0b3Iub25MaW5lYC5cclxuICogQXMgYSB3b3JrIGFyb3VuZCwgd2UgYWx3YXlzIGFzc3VtZSBpdCdzIG9ubGluZSBvbiBmaXJzdCBsb2FkLCBhbmQgY2hhbmdlXHJcbiAqIHRoZSBzdGF0dXMgdXBvbiBgb25saW5lYCBvciBgb2ZmbGluZWAgZXZlbnRzLlxyXG4gKi9cclxudmFyIG9ubGluZSA9IHRydWU7XHJcbnZhciBpc09ubGluZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ubGluZTsgfTtcclxudmFyIGhhc1dpbiA9IGhhc1dpbmRvdygpO1xyXG52YXIgaGFzRG9jID0gaGFzRG9jdW1lbnQoKTtcclxuLy8gRm9yIG5vZGUgYW5kIFJlYWN0IE5hdGl2ZSwgYGFkZC9yZW1vdmVFdmVudExpc3RlbmVyYCBkb2Vzbid0IGV4aXN0IG9uIHdpbmRvdy5cclxudmFyIG9uV2luZG93RXZlbnQgPSBoYXNXaW4gJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcclxuICAgID8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIuYmluZCh3aW5kb3cpXHJcbiAgICA6IG5vb3A7XHJcbnZhciBvbkRvY3VtZW50RXZlbnQgPSBoYXNEb2MgPyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLmJpbmQoZG9jdW1lbnQpIDogbm9vcDtcclxudmFyIG9mZldpbmRvd0V2ZW50ID0gaGFzV2luICYmIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyXHJcbiAgICA/IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQod2luZG93KVxyXG4gICAgOiBub29wO1xyXG52YXIgb2ZmRG9jdW1lbnRFdmVudCA9IGhhc0RvY1xyXG4gICAgPyBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQoZG9jdW1lbnQpXHJcbiAgICA6IG5vb3A7XHJcbnZhciBpc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdmlzaWJpbGl0eVN0YXRlID0gaGFzRG9jICYmIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZTtcclxuICAgIHJldHVybiBpc1VuZGVmaW5lZCh2aXNpYmlsaXR5U3RhdGUpIHx8IHZpc2liaWxpdHlTdGF0ZSAhPT0gJ2hpZGRlbic7XHJcbn07XHJcbnZhciBpbml0Rm9jdXMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgIC8vIGZvY3VzIHJldmFsaWRhdGVcclxuICAgIG9uRG9jdW1lbnRFdmVudCgndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKTtcclxuICAgIG9uV2luZG93RXZlbnQoJ2ZvY3VzJywgY2FsbGJhY2spO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvZmZEb2N1bWVudEV2ZW50KCd2aXNpYmlsaXR5Y2hhbmdlJywgY2FsbGJhY2spO1xyXG4gICAgICAgIG9mZldpbmRvd0V2ZW50KCdmb2N1cycsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbn07XHJcbnZhciBpbml0UmVjb25uZWN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAvLyByZXZhbGlkYXRlIG9uIHJlY29ubmVjdGVkXHJcbiAgICB2YXIgb25PbmxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb25saW5lID0gdHJ1ZTtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgfTtcclxuICAgIC8vIG5vdGhpbmcgdG8gcmV2YWxpZGF0ZSwganVzdCB1cGRhdGUgdGhlIHN0YXR1c1xyXG4gICAgdmFyIG9uT2ZmbGluZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvbmxpbmUgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICBvbldpbmRvd0V2ZW50KCdvbmxpbmUnLCBvbk9ubGluZSk7XHJcbiAgICBvbldpbmRvd0V2ZW50KCdvZmZsaW5lJywgb25PZmZsaW5lKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb2ZmV2luZG93RXZlbnQoJ29ubGluZScsIG9uT25saW5lKTtcclxuICAgICAgICBvZmZXaW5kb3dFdmVudCgnb2ZmbGluZScsIG9uT2ZmbGluZSk7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgcHJlc2V0ID0ge1xyXG4gICAgaXNPbmxpbmU6IGlzT25saW5lLFxyXG4gICAgaXNWaXNpYmxlOiBpc1Zpc2libGVcclxufTtcclxudmFyIGRlZmF1bHRDb25maWdPcHRpb25zID0ge1xyXG4gICAgaW5pdEZvY3VzOiBpbml0Rm9jdXMsXHJcbiAgICBpbml0UmVjb25uZWN0OiBpbml0UmVjb25uZWN0XHJcbn07XHJcblxyXG52YXIgSVNfU0VSVkVSID0gIWhhc1dpbmRvdygpIHx8ICdEZW5vJyBpbiB3aW5kb3c7XHJcbi8vIFBvbHlmaWxsIHJlcXVlc3RBbmltYXRpb25GcmFtZVxyXG52YXIgckFGID0gZnVuY3Rpb24gKGYpIHtcclxuICAgIHJldHVybiBoYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSA/IHdpbmRvd1sncmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10oZikgOiBzZXRUaW1lb3V0KGYsIDEpO1xyXG59O1xyXG4vLyBSZWFjdCBjdXJyZW50bHkgdGhyb3dzIGEgd2FybmluZyB3aGVuIHVzaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgc2VydmVyLlxyXG4vLyBUbyBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxyXG4vLyB1c2VMYXlvdXRFZmZlY3QgaW4gdGhlIGJyb3dzZXIuXHJcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gSVNfU0VSVkVSID8gdXNlRWZmZWN0IDogdXNlTGF5b3V0RWZmZWN0O1xyXG4vLyBUaGlzIGFzc2lnbm1lbnQgaXMgdG8gZXh0ZW5kIHRoZSBOYXZpZ2F0b3IgdHlwZSB0byB1c2UgZWZmZWN0aXZlVHlwZS5cclxudmFyIG5hdmlnYXRvckNvbm5lY3Rpb24gPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgbmF2aWdhdG9yLmNvbm5lY3Rpb247XHJcbi8vIEFkanVzdCB0aGUgY29uZmlnIGJhc2VkIG9uIHNsb3cgY29ubmVjdGlvbiBzdGF0dXMgKDw9IDcwS2JwcykuXHJcbnZhciBzbG93Q29ubmVjdGlvbiA9ICFJU19TRVJWRVIgJiZcclxuICAgIG5hdmlnYXRvckNvbm5lY3Rpb24gJiZcclxuICAgIChbJ3Nsb3ctMmcnLCAnMmcnXS5pbmNsdWRlcyhuYXZpZ2F0b3JDb25uZWN0aW9uLmVmZmVjdGl2ZVR5cGUpIHx8XHJcbiAgICAgICAgbmF2aWdhdG9yQ29ubmVjdGlvbi5zYXZlRGF0YSk7XHJcblxyXG52YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oa2V5KSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGtleSA9IGtleSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIC8vIGRlcGVuZGVuY2llcyBub3QgcmVhZHlcclxuICAgICAgICAgICAga2V5ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGFyZ3MgPSBbXS5jb25jYXQoa2V5KTtcclxuICAgIC8vIElmIGtleSBpcyBub3QgZmFsc3ksIG9yIG5vdCBhbiBlbXB0eSBhcnJheSwgaGFzaCBpdC5cclxuICAgIGtleSA9XHJcbiAgICAgICAgdHlwZW9mIGtleSA9PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICA/IGtleVxyXG4gICAgICAgICAgICA6IChBcnJheS5pc0FycmF5KGtleSkgPyBrZXkubGVuZ3RoIDoga2V5KVxyXG4gICAgICAgICAgICAgICAgPyBzdGFibGVIYXNoKGtleSlcclxuICAgICAgICAgICAgICAgIDogJyc7XHJcbiAgICB2YXIgaW5mb0tleSA9IGtleSA/ICckc3dyJCcgKyBrZXkgOiAnJztcclxuICAgIHJldHVybiBba2V5LCBhcmdzLCBpbmZvS2V5XTtcclxufTtcclxuXHJcbi8vIEdsb2JhbCBzdGF0ZSB1c2VkIHRvIGRlZHVwbGljYXRlIHJlcXVlc3RzIGFuZCBzdG9yZSBsaXN0ZW5lcnNcclxudmFyIFNXUkdsb2JhbFN0YXRlID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbnZhciBGT0NVU19FVkVOVCA9IDA7XHJcbnZhciBSRUNPTk5FQ1RfRVZFTlQgPSAxO1xyXG52YXIgTVVUQVRFX0VWRU5UID0gMjtcclxuXHJcbnZhciBicm9hZGNhc3RTdGF0ZSA9IGZ1bmN0aW9uIChjYWNoZSwga2V5LCBkYXRhLCBlcnJvciwgaXNWYWxpZGF0aW5nLCByZXZhbGlkYXRlLCBicm9hZGNhc3QpIHtcclxuICAgIGlmIChicm9hZGNhc3QgPT09IHZvaWQgMCkgeyBicm9hZGNhc3QgPSB0cnVlOyB9XHJcbiAgICB2YXIgX2EgPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpLCBFVkVOVF9SRVZBTElEQVRPUlMgPSBfYVswXSwgU1RBVEVfVVBEQVRFUlMgPSBfYVsxXSwgRkVUQ0ggPSBfYVszXTtcclxuICAgIHZhciByZXZhbGlkYXRvcnMgPSBFVkVOVF9SRVZBTElEQVRPUlNba2V5XTtcclxuICAgIHZhciB1cGRhdGVycyA9IFNUQVRFX1VQREFURVJTW2tleV07XHJcbiAgICAvLyBDYWNoZSB3YXMgcG9wdWxhdGVkLCB1cGRhdGUgc3RhdGVzIG9mIGFsbCBob29rcy5cclxuICAgIGlmIChicm9hZGNhc3QgJiYgdXBkYXRlcnMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXJzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZXJzW2ldKGRhdGEsIGVycm9yLCBpc1ZhbGlkYXRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIElmIHdlIGFsc28gbmVlZCB0byByZXZhbGlkYXRlLCBvbmx5IGRvIGl0IGZvciB0aGUgZmlyc3QgaG9vay5cclxuICAgIGlmIChyZXZhbGlkYXRlKSB7XHJcbiAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUga2V5IGJ5IGRlbGV0aW5nIHRoZSBjb25jdXJyZW50IHJlcXVlc3QgbWFya2VycyBzbyBuZXdcclxuICAgICAgICAvLyByZXF1ZXN0cyB3aWxsIG5vdCBiZSBkZWR1cGVkLlxyXG4gICAgICAgIGRlbGV0ZSBGRVRDSFtrZXldO1xyXG4gICAgICAgIGlmIChyZXZhbGlkYXRvcnMgJiYgcmV2YWxpZGF0b3JzWzBdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXZhbGlkYXRvcnNbMF0oTVVUQVRFX0VWRU5UKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xyXG59O1xyXG5cclxuLy8gR2xvYmFsIHRpbWVzdGFtcC5cclxudmFyIF9fdGltZXN0YW1wID0gMDtcclxudmFyIGdldFRpbWVzdGFtcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICsrX190aW1lc3RhbXA7IH07XHJcblxyXG52YXIgaW50ZXJuYWxNdXRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2FjaGUsIF9rZXksIF9kYXRhLCBfb3B0cywgb3B0aW9ucywgcG9wdWxhdGVDYWNoZSwgcmV2YWxpZGF0ZSwgcm9sbGJhY2tPbkVycm9yLCBjdXN0b21PcHRpbWlzdGljRGF0YSwgX2EsIGtleSwga2V5SW5mbywgX2IsIE1VVEFUSU9OLCBkYXRhLCBlcnJvciwgYmVmb3JlTXV0YXRpb25UcywgaGFzQ3VzdG9tT3B0aW1pc3RpY0RhdGEsIHJvbGxiYWNrRGF0YSwgb3B0aW1pc3RpY0RhdGEsIHJlcztcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IGFyZ3NbMF0sIF9rZXkgPSBhcmdzWzFdLCBfZGF0YSA9IGFyZ3NbMl0sIF9vcHRzID0gYXJnc1szXTtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIF9vcHRzID09PSAnYm9vbGVhbicgPyB7IHJldmFsaWRhdGU6IF9vcHRzIH0gOiBfb3B0cyB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICBwb3B1bGF0ZUNhY2hlID0gaXNVbmRlZmluZWQob3B0aW9ucy5wb3B1bGF0ZUNhY2hlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcHRpb25zLnBvcHVsYXRlQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZSA9IG9wdGlvbnMucmV2YWxpZGF0ZSAhPT0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9sbGJhY2tPbkVycm9yID0gb3B0aW9ucy5yb2xsYmFja09uRXJyb3IgIT09IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbU9wdGltaXN0aWNEYXRhID0gb3B0aW9ucy5vcHRpbWlzdGljRGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBfYSA9IHNlcmlhbGl6ZShfa2V5KSwga2V5ID0gX2FbMF0sIGtleUluZm8gPSBfYVsyXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWtleSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgICAgIF9iID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKSwgTVVUQVRJT04gPSBfYlsyXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBuZXcgZGF0YSBwcm92aWRlZCwgcmV2YWxpZGF0ZSB0aGUga2V5IHdpdGggY3VycmVudCBzdGF0ZS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldmFsaWRhdGUgYW5kIGJyb2FkY2FzdCBzdGF0ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJyb2FkY2FzdFN0YXRlKGNhY2hlLCBrZXksIGNhY2hlLmdldChrZXkpLCBVTkRFRklORUQsIFVOREVGSU5FRCwgcmV2YWxpZGF0ZSwgdHJ1ZSldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2RhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlTXV0YXRpb25UcyA9IGdldFRpbWVzdGFtcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIE1VVEFUSU9OW2tleV0gPSBbYmVmb3JlTXV0YXRpb25UcywgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzQ3VzdG9tT3B0aW1pc3RpY0RhdGEgPSAhaXNVbmRlZmluZWQoY3VzdG9tT3B0aW1pc3RpY0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvbGxiYWNrRGF0YSA9IGNhY2hlLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG9wdGltaXN0aWMgZGF0YSB1cGRhdGUuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0N1c3RvbU9wdGltaXN0aWNEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWNEYXRhID0gaXNGdW5jdGlvbihjdXN0b21PcHRpbWlzdGljRGF0YSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY3VzdG9tT3B0aW1pc3RpY0RhdGEocm9sbGJhY2tEYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXN0b21PcHRpbWlzdGljRGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgb3B0aW1pc3RpY0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBvcHRpbWlzdGljRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBkYXRhYCBpcyBhIGZ1bmN0aW9uLCBjYWxsIGl0IHBhc3NpbmcgY3VycmVudCBjYWNoZSB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhKGNhY2hlLmdldChrZXkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCB0aHJvd3MgYW4gZXJyb3Igc3luY2hyb25vdXNseSwgd2Ugc2hvdWxkbid0IHVwZGF0ZSB0aGUgY2FjaGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShkYXRhICYmIGlzRnVuY3Rpb24oZGF0YS50aGVuKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGRhdGEuY2F0Y2goZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG90aGVyIG11dGF0aW9ucyBoYXZlIG9jY3VycmVkIHNpbmNlIHdlJ3ZlIHN0YXJ0ZWQgdGhpcyBtdXRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHJhY2Ugd2UgZG9uJ3QgdXBkYXRlIGNhY2hlIG9yIGJyb2FkY2FzdCB0aGUgY2hhbmdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHJldHVybiB0aGUgZGF0YS5cclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgbXV0YXRpb24gaXMgYXN5bmMsIHdlIG5lZWQgdG8gY2hlY2sgdGltZXN0YW1wcyB0b1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGF2b2lkIHJhY2UgY29uZGl0aW9ucy5cclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG90aGVyIG11dGF0aW9ucyBoYXZlIG9jY3VycmVkIHNpbmNlIHdlJ3ZlIHN0YXJ0ZWQgdGhpcyBtdXRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcmFjZSB3ZSBkb24ndCB1cGRhdGUgY2FjaGUgb3IgYnJvYWRjYXN0IHRoZSBjaGFuZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCByZXR1cm4gdGhlIGRhdGEuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZU11dGF0aW9uVHMgIT09IE1VVEFUSU9OW2tleV1bMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgaGFzQ3VzdG9tT3B0aW1pc3RpY0RhdGEgJiYgcm9sbGJhY2tPbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvbGxiYWNrLiBBbHdheXMgcG9wdWxhdGUgdGhlIGNhY2hlIGluIHRoaXMgY2FzZSBidXQgd2l0aG91dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm1pbmcgdGhlIGRhdGEuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlQ2FjaGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcm9sbGJhY2tEYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCByb2xsYmFja0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2Ugc2hvdWxkIHdyaXRlIGJhY2sgdGhlIGNhY2hlIGFmdGVyIHJlcXVlc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcHVsYXRlQ2FjaGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSByZXN1bHQgaW50byBkYXRhLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocG9wdWxhdGVDYWNoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcG9wdWxhdGVDYWNoZShkYXRhLCByb2xsYmFja0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgY2FjaGVkIGRhdGEgaWYgdGhlcmUncyBubyBlcnJvci4gRGF0YSBjYW4gYmUgYHVuZGVmaW5lZGAgaGVyZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldChrZXksIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyB1cGRhdGUgb3IgcmVzZXQgdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5SW5mbywgbWVyZ2VPYmplY3RzKGNhY2hlLmdldChrZXlJbmZvKSwgeyBlcnJvcjogZXJyb3IgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdGltZXN0YW1wIHRvIG1hcmsgdGhlIG11dGF0aW9uIGhhcyBlbmRlZC5cclxuICAgICAgICAgICAgICAgICAgICBNVVRBVElPTltrZXldWzFdID0gZ2V0VGltZXN0YW1wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgZGF0YSwgZXJyb3IsIFVOREVGSU5FRCwgcmV2YWxpZGF0ZSwgISFwb3B1bGF0ZUNhY2hlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBlcnJvciBvciByZXR1cm4gZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRocm93IGVycm9yIG9yIHJldHVybiBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcG9wdWxhdGVDYWNoZSA/IHJlcyA6IGRhdGFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbnZhciByZXZhbGlkYXRlQWxsS2V5cyA9IGZ1bmN0aW9uIChyZXZhbGlkYXRvcnMsIHR5cGUpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiByZXZhbGlkYXRvcnMpIHtcclxuICAgICAgICBpZiAocmV2YWxpZGF0b3JzW2tleV1bMF0pXHJcbiAgICAgICAgICAgIHJldmFsaWRhdG9yc1trZXldWzBdKHR5cGUpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgaW5pdENhY2hlID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBvcHRpb25zKSB7XHJcbiAgICAvLyBUaGUgZ2xvYmFsIHN0YXRlIGZvciBhIHNwZWNpZmljIHByb3ZpZGVyIHdpbGwgYmUgdXNlZCB0byBkZWR1cGxpY2F0ZVxyXG4gICAgLy8gcmVxdWVzdHMgYW5kIHN0b3JlIGxpc3RlbmVycy4gQXMgd2VsbCBhcyBhIG11dGF0ZSBmdW5jdGlvbiB0aGF0IGJvdW5kIHRvXHJcbiAgICAvLyB0aGUgY2FjaGUuXHJcbiAgICAvLyBQcm92aWRlcidzIGdsb2JhbCBzdGF0ZSBtaWdodCBiZSBhbHJlYWR5IGluaXRpYWxpemVkLiBMZXQncyB0cnkgdG8gZ2V0IHRoZVxyXG4gICAgLy8gZ2xvYmFsIHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZXIgZmlyc3QuXHJcbiAgICBpZiAoIVNXUkdsb2JhbFN0YXRlLmhhcyhwcm92aWRlcikpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0Q29uZmlnT3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBnbG9iYWwgc3RhdGUgYm91bmQgdG8gdGhlIHByb3ZpZGVyLCBjcmVhdGUgYSBuZXcgb25lIHdpdGggdGhlXHJcbiAgICAgICAgLy8gbmV3IG11dGF0ZSBmdW5jdGlvbi5cclxuICAgICAgICB2YXIgRVZFTlRfUkVWQUxJREFUT1JTID0ge307XHJcbiAgICAgICAgdmFyIG11dGF0ZSA9IGludGVybmFsTXV0YXRlLmJpbmQoVU5ERUZJTkVELCBwcm92aWRlcik7XHJcbiAgICAgICAgdmFyIHVubW91bnQgPSBub29wO1xyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RhdGUgaWYgaXQncyBuZXcsIG9yIHRoZSBwcm92aWRlciBoYXMgYmVlbiBleHRlbmRlZC5cclxuICAgICAgICBTV1JHbG9iYWxTdGF0ZS5zZXQocHJvdmlkZXIsIFtFVkVOVF9SRVZBTElEQVRPUlMsIHt9LCB7fSwge30sIG11dGF0ZV0pO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgcHJvdmlkZXIsIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSBpdCBhbmQgc2V0dXAgRE9NIGV2ZW50c1xyXG4gICAgICAgIC8vIGxpc3RlbmVycyBmb3IgYGZvY3VzYCBhbmQgYHJlY29ubmVjdGAgYWN0aW9ucy5cclxuICAgICAgICBpZiAoIUlTX1NFUlZFUikge1xyXG4gICAgICAgICAgICAvLyBXaGVuIGxpc3RlbmluZyB0byB0aGUgbmF0aXZlIGV2ZW50cyBmb3IgYXV0byByZXZhbGlkYXRpb25zLFxyXG4gICAgICAgICAgICAvLyB3ZSBpbnRlbnRpb25hbGx5IHB1dCBhIGRlbGF5IChzZXRUaW1lb3V0KSBoZXJlIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZVxyXG4gICAgICAgICAgICAvLyBmaXJlZCBhZnRlciBpbW1lZGlhdGUgSmF2YVNjcmlwdCBleGVjdXRpb25zLCB3aGljaCBjYW4gcG9zc2libHkgYmVcclxuICAgICAgICAgICAgLy8gUmVhY3QncyBzdGF0ZSB1cGRhdGVzLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGF2b2lkcyBzb21lIHVubmVjZXNzYXJ5IHJldmFsaWRhdGlvbnMgc3VjaCBhc1xyXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL3N3ci9pc3N1ZXMvMTY4MC5cclxuICAgICAgICAgICAgdmFyIHJlbGVhc2VGb2N1c18xID0gb3B0cy5pbml0Rm9jdXMoc2V0VGltZW91dC5iaW5kKFVOREVGSU5FRCwgcmV2YWxpZGF0ZUFsbEtleXMuYmluZChVTkRFRklORUQsIEVWRU5UX1JFVkFMSURBVE9SUywgRk9DVVNfRVZFTlQpKSk7XHJcbiAgICAgICAgICAgIHZhciByZWxlYXNlUmVjb25uZWN0XzEgPSBvcHRzLmluaXRSZWNvbm5lY3Qoc2V0VGltZW91dC5iaW5kKFVOREVGSU5FRCwgcmV2YWxpZGF0ZUFsbEtleXMuYmluZChVTkRFRklORUQsIEVWRU5UX1JFVkFMSURBVE9SUywgUkVDT05ORUNUX0VWRU5UKSkpO1xyXG4gICAgICAgICAgICB1bm1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmVsZWFzZUZvY3VzXzEgJiYgcmVsZWFzZUZvY3VzXzEoKTtcclxuICAgICAgICAgICAgICAgIHJlbGVhc2VSZWNvbm5lY3RfMSAmJiByZWxlYXNlUmVjb25uZWN0XzEoKTtcclxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdW4tbW91bnRpbmcsIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBjYWNoZSBwcm92aWRlciBmcm9tIHRoZSBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgLy8gc3RvcmFnZSB0b28gYmVjYXVzZSBpdCdzIGEgc2lkZS1lZmZlY3QuIE90aGVyd2lzZSB3aGVuIHJlLW1vdW50aW5nIHdlXHJcbiAgICAgICAgICAgICAgICAvLyB3aWxsIG5vdCByZS1yZWdpc3RlciB0aG9zZSBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgICAgICBTV1JHbG9iYWxTdGF0ZS5kZWxldGUocHJvdmlkZXIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBtaWdodCB3YW50IHRvIGluamVjdCBhbiBleHRyYSBsYXllciBvbiB0b3Agb2YgYHByb3ZpZGVyYCBpbiB0aGUgZnV0dXJlLFxyXG4gICAgICAgIC8vIHN1Y2ggYXMga2V5IHNlcmlhbGl6YXRpb24sIGF1dG8gR0MsIGV0Yy5cclxuICAgICAgICAvLyBGb3Igbm93LCBpdCdzIGp1c3QgYSBgTWFwYCBpbnRlcmZhY2Ugd2l0aG91dCBhbnkgbW9kaWZpY2F0aW9ucy5cclxuICAgICAgICByZXR1cm4gW3Byb3ZpZGVyLCBtdXRhdGUsIHVubW91bnRdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtwcm92aWRlciwgU1dSR2xvYmFsU3RhdGUuZ2V0KHByb3ZpZGVyKVs0XV07XHJcbn07XHJcblxyXG4vLyBlcnJvciByZXRyeVxyXG52YXIgb25FcnJvclJldHJ5ID0gZnVuY3Rpb24gKF8sIF9fLCBjb25maWcsIHJldmFsaWRhdGUsIG9wdHMpIHtcclxuICAgIHZhciBtYXhSZXRyeUNvdW50ID0gY29uZmlnLmVycm9yUmV0cnlDb3VudDtcclxuICAgIHZhciBjdXJyZW50UmV0cnlDb3VudCA9IG9wdHMucmV0cnlDb3VudDtcclxuICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcclxuICAgIHZhciB0aW1lb3V0ID0gfn4oKE1hdGgucmFuZG9tKCkgKyAwLjUpICpcclxuICAgICAgICAoMSA8PCAoY3VycmVudFJldHJ5Q291bnQgPCA4ID8gY3VycmVudFJldHJ5Q291bnQgOiA4KSkpICogY29uZmlnLmVycm9yUmV0cnlJbnRlcnZhbDtcclxuICAgIGlmICghaXNVbmRlZmluZWQobWF4UmV0cnlDb3VudCkgJiYgY3VycmVudFJldHJ5Q291bnQgPiBtYXhSZXRyeUNvdW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgc2V0VGltZW91dChyZXZhbGlkYXRlLCB0aW1lb3V0LCBvcHRzKTtcclxufTtcclxuLy8gRGVmYXVsdCBjYWNoZSBwcm92aWRlclxyXG52YXIgX2EgPSBpbml0Q2FjaGUobmV3IE1hcCgpKSwgY2FjaGUgPSBfYVswXSwgbXV0YXRlID0gX2FbMV07XHJcbi8vIERlZmF1bHQgY29uZmlnXHJcbnZhciBkZWZhdWx0Q29uZmlnID0gbWVyZ2VPYmplY3RzKHtcclxuICAgIC8vIGV2ZW50c1xyXG4gICAgb25Mb2FkaW5nU2xvdzogbm9vcCxcclxuICAgIG9uU3VjY2Vzczogbm9vcCxcclxuICAgIG9uRXJyb3I6IG5vb3AsXHJcbiAgICBvbkVycm9yUmV0cnk6IG9uRXJyb3JSZXRyeSxcclxuICAgIG9uRGlzY2FyZGVkOiBub29wLFxyXG4gICAgLy8gc3dpdGNoZXNcclxuICAgIHJldmFsaWRhdGVPbkZvY3VzOiB0cnVlLFxyXG4gICAgcmV2YWxpZGF0ZU9uUmVjb25uZWN0OiB0cnVlLFxyXG4gICAgcmV2YWxpZGF0ZUlmU3RhbGU6IHRydWUsXHJcbiAgICBzaG91bGRSZXRyeU9uRXJyb3I6IHRydWUsXHJcbiAgICAvLyB0aW1lb3V0c1xyXG4gICAgZXJyb3JSZXRyeUludGVydmFsOiBzbG93Q29ubmVjdGlvbiA/IDEwMDAwIDogNTAwMCxcclxuICAgIGZvY3VzVGhyb3R0bGVJbnRlcnZhbDogNSAqIDEwMDAsXHJcbiAgICBkZWR1cGluZ0ludGVydmFsOiAyICogMTAwMCxcclxuICAgIGxvYWRpbmdUaW1lb3V0OiBzbG93Q29ubmVjdGlvbiA/IDUwMDAgOiAzMDAwLFxyXG4gICAgLy8gcHJvdmlkZXJzXHJcbiAgICBjb21wYXJlOiBmdW5jdGlvbiAoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcclxuICAgICAgICByZXR1cm4gc3RhYmxlSGFzaChjdXJyZW50RGF0YSkgPT0gc3RhYmxlSGFzaChuZXdEYXRhKTtcclxuICAgIH0sXHJcbiAgICBpc1BhdXNlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0sXHJcbiAgICBjYWNoZTogY2FjaGUsXHJcbiAgICBtdXRhdGU6IG11dGF0ZSxcclxuICAgIGZhbGxiYWNrOiB7fVxyXG59LCBcclxuLy8gdXNlIHdlYiBwcmVzZXQgYnkgZGVmYXVsdFxyXG5wcmVzZXQpO1xyXG5cclxudmFyIG1lcmdlQ29uZmlncyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAvLyBOZWVkIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3QgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIGhlcmUuXHJcbiAgICB2YXIgdiA9IG1lcmdlT2JqZWN0cyhhLCBiKTtcclxuICAgIC8vIElmIHR3byBjb25maWdzIGFyZSBwcm92aWRlZCwgbWVyZ2UgdGhlaXIgYHVzZWAgYW5kIGBmYWxsYmFja2Agb3B0aW9ucy5cclxuICAgIGlmIChiKSB7XHJcbiAgICAgICAgdmFyIHUxID0gYS51c2UsIGYxID0gYS5mYWxsYmFjaztcclxuICAgICAgICB2YXIgdTIgPSBiLnVzZSwgZjIgPSBiLmZhbGxiYWNrO1xyXG4gICAgICAgIGlmICh1MSAmJiB1Mikge1xyXG4gICAgICAgICAgICB2LnVzZSA9IHUxLmNvbmNhdCh1Mik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmMSAmJiBmMikge1xyXG4gICAgICAgICAgICB2LmZhbGxiYWNrID0gbWVyZ2VPYmplY3RzKGYxLCBmMik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHY7XHJcbn07XHJcblxyXG52YXIgU1dSQ29uZmlnQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xyXG52YXIgU1dSQ29uZmlnJDEgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xyXG4gICAgLy8gRXh0ZW5kIHBhcmVudCBjb250ZXh0IHZhbHVlcyBhbmQgbWlkZGxld2FyZS5cclxuICAgIHZhciBleHRlbmRlZENvbmZpZyA9IG1lcmdlQ29uZmlncyh1c2VDb250ZXh0KFNXUkNvbmZpZ0NvbnRleHQpLCB2YWx1ZSk7XHJcbiAgICAvLyBTaG91bGQgbm90IHVzZSB0aGUgaW5oZXJpdGVkIHByb3ZpZGVyLlxyXG4gICAgdmFyIHByb3ZpZGVyID0gdmFsdWUgJiYgdmFsdWUucHJvdmlkZXI7XHJcbiAgICAvLyBVc2UgYSBsYXp5IGluaXRpYWxpemVkIHN0YXRlIHRvIGNyZWF0ZSB0aGUgY2FjaGUgb24gZmlyc3QgYWNjZXNzLlxyXG4gICAgdmFyIGNhY2hlQ29udGV4dCA9IHVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gcHJvdmlkZXJcclxuICAgICAgICAgICAgPyBpbml0Q2FjaGUocHJvdmlkZXIoZXh0ZW5kZWRDb25maWcuY2FjaGUgfHwgY2FjaGUpLCB2YWx1ZSlcclxuICAgICAgICAgICAgOiBVTkRFRklORUQ7XHJcbiAgICB9KVswXTtcclxuICAgIC8vIE92ZXJyaWRlIHRoZSBjYWNoZSBpZiBhIG5ldyBwcm92aWRlciBpcyBnaXZlbi5cclxuICAgIGlmIChjYWNoZUNvbnRleHQpIHtcclxuICAgICAgICBleHRlbmRlZENvbmZpZy5jYWNoZSA9IGNhY2hlQ29udGV4dFswXTtcclxuICAgICAgICBleHRlbmRlZENvbmZpZy5tdXRhdGUgPSBjYWNoZUNvbnRleHRbMV07XHJcbiAgICB9XHJcbiAgICAvLyBVbnN1YnNjcmliZSBldmVudHMuXHJcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIChjYWNoZUNvbnRleHQgPyBjYWNoZUNvbnRleHRbMl0gOiBVTkRFRklORUQpOyB9LCBbXSk7XHJcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChTV1JDb25maWdDb250ZXh0LlByb3ZpZGVyLCBtZXJnZU9iamVjdHMocHJvcHMsIHtcclxuICAgICAgICB2YWx1ZTogZXh0ZW5kZWRDb25maWdcclxuICAgIH0pKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBzdGF0ZSB3aXRoIGRlcGVuZGVuY3ktdHJhY2tpbmcuXHJcbiAqL1xyXG52YXIgdXNlU3RhdGVXaXRoRGVwcyA9IGZ1bmN0aW9uIChzdGF0ZSwgdW5tb3VudGVkUmVmKSB7XHJcbiAgICB2YXIgcmVyZW5kZXIgPSB1c2VTdGF0ZSh7fSlbMV07XHJcbiAgICB2YXIgc3RhdGVSZWYgPSB1c2VSZWYoc3RhdGUpO1xyXG4gICAgLy8gSWYgYSBzdGF0ZSBwcm9wZXJ0eSAoZGF0YSwgZXJyb3Igb3IgaXNWYWxpZGF0aW5nKSBpcyBhY2Nlc3NlZCBieSB0aGUgcmVuZGVyXHJcbiAgICAvLyBmdW5jdGlvbiwgd2UgbWFyayB0aGUgcHJvcGVydHkgYXMgYSBkZXBlbmRlbmN5IHNvIGlmIGl0IGlzIHVwZGF0ZWQgYWdhaW5cclxuICAgIC8vIGluIHRoZSBmdXR1cmUsIHdlIHRyaWdnZXIgYSByZXJlbmRlci5cclxuICAgIC8vIFRoaXMgaXMgYWxzbyBrbm93biBhcyBkZXBlbmRlbmN5LXRyYWNraW5nLlxyXG4gICAgdmFyIHN0YXRlRGVwZW5kZW5jaWVzUmVmID0gdXNlUmVmKHtcclxuICAgICAgICBkYXRhOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogZmFsc2UsXHJcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFRvIGNoYW5nZSBzdGF0ZVJlZiwgcGFzcyB0aGUgdmFsdWVzIGV4cGxpY2l0bHkgdG8gc2V0U3RhdGU6XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBganNcclxuICAgICAqIHNldFN0YXRlKHtcclxuICAgICAqICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxyXG4gICAgICogICBkYXRhOiBuZXdEYXRhIC8vIHNldCBkYXRhIHRvIG5ld0RhdGFcclxuICAgICAqICAgZXJyb3I6IHVuZGVmaW5lZCAvLyBzZXQgZXJyb3IgdG8gdW5kZWZpbmVkXHJcbiAgICAgKiB9KVxyXG4gICAgICpcclxuICAgICAqIHNldFN0YXRlKHtcclxuICAgICAqICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxyXG4gICAgICogICBkYXRhOiB1bmRlZmluZWQgLy8gc2V0IGRhdGEgdG8gdW5kZWZpbmVkXHJcbiAgICAgKiAgIGVycm9yOiBlcnIgLy8gc2V0IGVycm9yIHRvIGVyclxyXG4gICAgICogfSlcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICB2YXIgc2V0U3RhdGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAocGF5bG9hZCkge1xyXG4gICAgICAgIHZhciBzaG91bGRSZXJlbmRlciA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBzdGF0ZVJlZi5jdXJyZW50O1xyXG4gICAgICAgIGZvciAodmFyIF8gaW4gcGF5bG9hZCkge1xyXG4gICAgICAgICAgICB2YXIgayA9IF87XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBoYXMgY2hhbmdlZCwgdXBkYXRlIHRoZSBzdGF0ZSBhbmQgbWFyayByZXJlbmRlciBhc1xyXG4gICAgICAgICAgICAvLyBuZWVkZWQuXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGVba10gIT09IHBheWxvYWRba10pIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZVtrXSA9IHBheWxvYWRba107XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQgYnkgdGhlIGNvbXBvbmVudCwgYSByZXJlbmRlciBzaG91bGQgYmVcclxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXJlZC5cclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZURlcGVuZGVuY2llc1JlZi5jdXJyZW50W2tdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVyZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaG91bGRSZXJlbmRlciAmJiAhdW5tb3VudGVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgcmVyZW5kZXIoe30pO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFxyXG4gICAgLy8gY29uZmlnLnN1c3BlbnNlIGlzbid0IGFsbG93ZWQgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZWN5Y2xlXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICBbXSk7XHJcbiAgICAvLyBBbHdheXMgdXBkYXRlIHRoZSBzdGF0ZSByZWZlcmVuY2UuXHJcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzdGF0ZVJlZi5jdXJyZW50ID0gc3RhdGU7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBbc3RhdGVSZWYsIHN0YXRlRGVwZW5kZW5jaWVzUmVmLmN1cnJlbnQsIHNldFN0YXRlXTtcclxufTtcclxuXHJcbnZhciBub3JtYWxpemUgPSBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oYXJnc1sxXSlcclxuICAgICAgICA/IFthcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdIHx8IHt9XVxyXG4gICAgICAgIDogW2FyZ3NbMF0sIG51bGwsIChhcmdzWzFdID09PSBudWxsID8gYXJnc1syXSA6IGFyZ3NbMV0pIHx8IHt9XTtcclxufTtcclxuXHJcbnZhciB1c2VTV1JDb25maWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RzKGRlZmF1bHRDb25maWcsIHVzZUNvbnRleHQoU1dSQ29uZmlnQ29udGV4dCkpO1xyXG59O1xyXG5cclxuLy8gSXQncyB0cmlja3kgdG8gcGFzcyBnZW5lcmljIHR5cGVzIGFzIHBhcmFtZXRlcnMsIHNvIHdlIGp1c3QgZGlyZWN0bHkgb3ZlcnJpZGVcclxuLy8gdGhlIHR5cGVzIGhlcmUuXHJcbnZhciB3aXRoQXJncyA9IGZ1bmN0aW9uIChob29rKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gdXNlU1dSQXJncygpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2V0IHRoZSBkZWZhdWx0IGFuZCBpbmhlcml0ZWQgY29uZmlndXJhdGlvbi5cclxuICAgICAgICB2YXIgZmFsbGJhY2tDb25maWcgPSB1c2VTV1JDb25maWcoKTtcclxuICAgICAgICAvLyBOb3JtYWxpemUgYXJndW1lbnRzLlxyXG4gICAgICAgIHZhciBfYSA9IG5vcm1hbGl6ZShhcmdzKSwga2V5ID0gX2FbMF0sIGZuID0gX2FbMV0sIF9jb25maWcgPSBfYVsyXTtcclxuICAgICAgICAvLyBNZXJnZSBjb25maWd1cmF0aW9ucy5cclxuICAgICAgICB2YXIgY29uZmlnID0gbWVyZ2VDb25maWdzKGZhbGxiYWNrQ29uZmlnLCBfY29uZmlnKTtcclxuICAgICAgICAvLyBBcHBseSBtaWRkbGV3YXJlXHJcbiAgICAgICAgdmFyIG5leHQgPSBob29rO1xyXG4gICAgICAgIHZhciB1c2UgPSBjb25maWcudXNlO1xyXG4gICAgICAgIGlmICh1c2UpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHVzZS5sZW5ndGg7IGktLSA+IDA7KSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gdXNlW2ldKG5leHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXh0KGtleSwgZm4gfHwgY29uZmlnLmZldGNoZXIsIGNvbmZpZyk7XHJcbiAgICB9O1xyXG59O1xyXG5cclxuLy8gQWRkIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYSBsaXN0IG9mIGtleWVkIGNhbGxiYWNrIGZ1bmN0aW9ucyBhbmQgcmV0dXJuXHJcbi8vIHRoZSB1bnN1YnNjcmliZSBmdW5jdGlvbi5cclxudmFyIHN1YnNjcmliZUNhbGxiYWNrID0gZnVuY3Rpb24gKGtleSwgY2FsbGJhY2tzLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIGtleWVkUmV2YWxpZGF0b3JzID0gY2FsbGJhY2tzW2tleV0gfHwgKGNhbGxiYWNrc1trZXldID0gW10pO1xyXG4gICAga2V5ZWRSZXZhbGlkYXRvcnMucHVzaChjYWxsYmFjayk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IGtleWVkUmV2YWxpZGF0b3JzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIE8oMSk6IGZhc3RlciB0aGFuIHNwbGljZVxyXG4gICAgICAgICAgICBrZXllZFJldmFsaWRhdG9yc1tpbmRleF0gPSBrZXllZFJldmFsaWRhdG9yc1trZXllZFJldmFsaWRhdG9ycy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAga2V5ZWRSZXZhbGlkYXRvcnMucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcbnZhciBXSVRIX0RFRFVQRSA9IHsgZGVkdXBlOiB0cnVlIH07XHJcbnZhciB1c2VTV1JIYW5kbGVyID0gZnVuY3Rpb24gKF9rZXksIGZldGNoZXIsIGNvbmZpZykge1xyXG4gICAgdmFyIGNhY2hlID0gY29uZmlnLmNhY2hlLCBjb21wYXJlID0gY29uZmlnLmNvbXBhcmUsIGZhbGxiYWNrRGF0YSA9IGNvbmZpZy5mYWxsYmFja0RhdGEsIHN1c3BlbnNlID0gY29uZmlnLnN1c3BlbnNlLCByZXZhbGlkYXRlT25Nb3VudCA9IGNvbmZpZy5yZXZhbGlkYXRlT25Nb3VudCwgcmVmcmVzaEludGVydmFsID0gY29uZmlnLnJlZnJlc2hJbnRlcnZhbCwgcmVmcmVzaFdoZW5IaWRkZW4gPSBjb25maWcucmVmcmVzaFdoZW5IaWRkZW4sIHJlZnJlc2hXaGVuT2ZmbGluZSA9IGNvbmZpZy5yZWZyZXNoV2hlbk9mZmxpbmU7XHJcbiAgICB2YXIgX2EgPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpLCBFVkVOVF9SRVZBTElEQVRPUlMgPSBfYVswXSwgU1RBVEVfVVBEQVRFUlMgPSBfYVsxXSwgTVVUQVRJT04gPSBfYVsyXSwgRkVUQ0ggPSBfYVszXTtcclxuICAgIC8vIGBrZXlgIGlzIHRoZSBpZGVudGlmaWVyIG9mIHRoZSBTV1IgYGRhdGFgIHN0YXRlLCBga2V5SW5mb2AgaG9sZHMgZXh0cmFcclxuICAgIC8vIHN0YXRlcyBzdWNoIGFzIGBlcnJvcmAgYW5kIGBpc1ZhbGlkYXRpbmdgIGluc2lkZSxcclxuICAgIC8vIGFsbCBvZiB0aGVtIGFyZSBkZXJpdmVkIGZyb20gYF9rZXlgLlxyXG4gICAgLy8gYGZuQXJnc2AgaXMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIHBhcnNlZCBmcm9tIHRoZSBrZXksIHdoaWNoIHdpbGwgYmUgcGFzc2VkXHJcbiAgICAvLyB0byB0aGUgZmV0Y2hlci5cclxuICAgIHZhciBfYiA9IHNlcmlhbGl6ZShfa2V5KSwga2V5ID0gX2JbMF0sIGZuQXJncyA9IF9iWzFdLCBrZXlJbmZvID0gX2JbMl07XHJcbiAgICAvLyBJZiBpdCdzIHRoZSBpbml0aWFsIHJlbmRlciBvZiB0aGlzIGhvb2suXHJcbiAgICB2YXIgaW5pdGlhbE1vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xyXG4gICAgLy8gSWYgdGhlIGhvb2sgaXMgdW5tb3VudGVkIGFscmVhZHkuIFRoaXMgd2lsbCBiZSB1c2VkIHRvIHByZXZlbnQgc29tZSBlZmZlY3RzXHJcbiAgICAvLyB0byBiZSBjYWxsZWQgYWZ0ZXIgdW5tb3VudGluZy5cclxuICAgIHZhciB1bm1vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xyXG4gICAgLy8gUmVmcyB0byBrZWVwIHRoZSBrZXkgYW5kIGNvbmZpZy5cclxuICAgIHZhciBrZXlSZWYgPSB1c2VSZWYoa2V5KTtcclxuICAgIHZhciBmZXRjaGVyUmVmID0gdXNlUmVmKGZldGNoZXIpO1xyXG4gICAgdmFyIGNvbmZpZ1JlZiA9IHVzZVJlZihjb25maWcpO1xyXG4gICAgdmFyIGdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZ1JlZi5jdXJyZW50OyB9O1xyXG4gICAgdmFyIGlzQWN0aXZlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0Q29uZmlnKCkuaXNWaXNpYmxlKCkgJiYgZ2V0Q29uZmlnKCkuaXNPbmxpbmUoKTsgfTtcclxuICAgIHZhciBwYXRjaEZldGNoSW5mbyA9IGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlLnNldChrZXlJbmZvLCBtZXJnZU9iamVjdHMoY2FjaGUuZ2V0KGtleUluZm8pLCBpbmZvKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0YXRlIHRoYXQgU1dSIHNob3VsZCByZXR1cm4uXHJcbiAgICB2YXIgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XHJcbiAgICB2YXIgZmFsbGJhY2sgPSBpc1VuZGVmaW5lZChmYWxsYmFja0RhdGEpXHJcbiAgICAgICAgPyBjb25maWcuZmFsbGJhY2tba2V5XVxyXG4gICAgICAgIDogZmFsbGJhY2tEYXRhO1xyXG4gICAgdmFyIGRhdGEgPSBpc1VuZGVmaW5lZChjYWNoZWQpID8gZmFsbGJhY2sgOiBjYWNoZWQ7XHJcbiAgICB2YXIgaW5mbyA9IGNhY2hlLmdldChrZXlJbmZvKSB8fCB7fTtcclxuICAgIHZhciBlcnJvciA9IGluZm8uZXJyb3I7XHJcbiAgICB2YXIgaXNJbml0aWFsTW91bnQgPSAhaW5pdGlhbE1vdW50ZWRSZWYuY3VycmVudDtcclxuICAgIC8vIC0gU3VzcGVuc2UgbW9kZSBhbmQgdGhlcmUncyBzdGFsZSBkYXRhIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXHJcbiAgICAvLyAtIE5vdCBzdXNwZW5zZSBtb2RlIGFuZCB0aGVyZSBpcyBubyBmYWxsYmFjayBkYXRhIGFuZCBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIGVuYWJsZWQuXHJcbiAgICAvLyAtIGByZXZhbGlkYXRlSWZTdGFsZWAgaXMgZW5hYmxlZCBidXQgYGRhdGFgIGlzIG5vdCBkZWZpbmVkLlxyXG4gICAgdmFyIHNob3VsZFJldmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gSWYgYHJldmFsaWRhdGVPbk1vdW50YCBpcyBzZXQsIHdlIHRha2UgdGhlIHZhbHVlIGRpcmVjdGx5LlxyXG4gICAgICAgIGlmIChpc0luaXRpYWxNb3VudCAmJiAhaXNVbmRlZmluZWQocmV2YWxpZGF0ZU9uTW91bnQpKVxyXG4gICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0ZU9uTW91bnQ7XHJcbiAgICAgICAgLy8gSWYgaXQncyBwYXVzZWQsIHdlIHNraXAgcmV2YWxpZGF0aW9uLlxyXG4gICAgICAgIGlmIChnZXRDb25maWcoKS5pc1BhdXNlZCgpKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgLy8gVW5kZXIgc3VzcGVuc2UgbW9kZSwgaXQgd2lsbCBhbHdheXMgZmV0Y2ggb24gcmVuZGVyIGlmIHRoZXJlIGlzIG5vXHJcbiAgICAgICAgLy8gc3RhbGUgZGF0YSBzbyBubyBuZWVkIHRvIHJldmFsaWRhdGUgaW1tZWRpYXRlbHkgb24gbW91bnQgYWdhaW4uXHJcbiAgICAgICAgLy8gSWYgZGF0YSBleGlzdHMsIG9ubHkgcmV2YWxpZGF0ZSBpZiBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIHRydWUuXHJcbiAgICAgICAgaWYgKHN1c3BlbnNlKVxyXG4gICAgICAgICAgICByZXR1cm4gaXNVbmRlZmluZWQoZGF0YSkgPyBmYWxzZSA6IGNvbmZpZy5yZXZhbGlkYXRlSWZTdGFsZTtcclxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBzdGFsZSBkYXRhLCB3ZSBuZWVkIHRvIHJldmFsaWRhdGUgb24gbW91bnQ7XHJcbiAgICAgICAgLy8gSWYgYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBzZXQgdG8gdHJ1ZSwgd2Ugd2lsbCBhbHdheXMgcmV2YWxpZGF0ZS5cclxuICAgICAgICByZXR1cm4gaXNVbmRlZmluZWQoZGF0YSkgfHwgY29uZmlnLnJldmFsaWRhdGVJZlN0YWxlO1xyXG4gICAgfTtcclxuICAgIC8vIFJlc29sdmUgdGhlIGN1cnJlbnQgdmFsaWRhdGluZyBzdGF0ZS5cclxuICAgIHZhciByZXNvbHZlVmFsaWRhdGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIWtleSB8fCAhZmV0Y2hlcilcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChpbmZvLmlzVmFsaWRhdGluZylcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgLy8gSWYgaXQncyBub3QgbW91bnRlZCB5ZXQgYW5kIGl0IHNob3VsZCByZXZhbGlkYXRlIG9uIG1vdW50LCByZXZhbGlkYXRlLlxyXG4gICAgICAgIHJldHVybiBpc0luaXRpYWxNb3VudCAmJiBzaG91bGRSZXZhbGlkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGlzVmFsaWRhdGluZyA9IHJlc29sdmVWYWxpZGF0aW5nKCk7XHJcbiAgICB2YXIgX2MgPSB1c2VTdGF0ZVdpdGhEZXBzKHtcclxuICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgIGVycm9yOiBlcnJvcixcclxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGlzVmFsaWRhdGluZ1xyXG4gICAgfSwgdW5tb3VudGVkUmVmKSwgc3RhdGVSZWYgPSBfY1swXSwgc3RhdGVEZXBlbmRlbmNpZXMgPSBfY1sxXSwgc2V0U3RhdGUgPSBfY1syXTtcclxuICAgIC8vIFRoZSByZXZhbGlkYXRpb24gZnVuY3Rpb24gaXMgYSBjYXJlZnVsbHkgY3JhZnRlZCB3cmFwcGVyIG9mIHRoZSBvcmlnaW5hbFxyXG4gICAgLy8gYGZldGNoZXJgLCB0byBjb3JyZWN0bHkgaGFuZGxlIHRoZSBtYW55IGVkZ2UgY2FzZXMuXHJcbiAgICB2YXIgcmV2YWxpZGF0ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChyZXZhbGlkYXRlT3B0cykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY3VycmVudEZldGNoZXIsIG5ld0RhdGEsIHN0YXJ0QXQsIGxvYWRpbmcsIG9wdHMsIHNob3VsZFN0YXJ0TmV3UmVxdWVzdCwgaXNDdXJyZW50S2V5TW91bnRlZCwgY2xlYW51cFN0YXRlLCBuZXdTdGF0ZSwgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlLCBtdXRhdGlvbkluZm8sIGVycl8xO1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RmV0Y2hlciA9IGZldGNoZXJSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWtleSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhY3VycmVudEZldGNoZXIgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkuaXNQYXVzZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBvcHRzID0gcmV2YWxpZGF0ZU9wdHMgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RhcnROZXdSZXF1ZXN0ID0gIUZFVENIW2tleV0gfHwgIW9wdHMuZGVkdXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQ3VycmVudEtleU1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhdW5tb3VudGVkUmVmLmN1cnJlbnQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9PT0ga2V5UmVmLmN1cnJlbnQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwU3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3Mgc3RpbGwgdGhlIHNhbWUgcmVxdWVzdCBiZWZvcmUgZGVsZXRpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0SW5mbyA9IEZFVENIW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0SW5mbyAmJiByZXF1ZXN0SW5mb1sxXSA9PT0gc3RhcnRBdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIEZFVENIW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0geyBpc1ZhbGlkYXRpbmc6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaEZldGNoSW5mbyh7IGlzVmFsaWRhdGluZzogZmFsc2UgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBvbmx5IHNldCBzdGF0ZSBpZiBpdCdzIHNhZmUgKHN0aWxsIG1vdW50ZWQgd2l0aCB0aGUgc2FtZSBrZXkpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTdGF0ZShuZXdTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGZldGNoaW5nLiBDaGFuZ2UgdGhlIGBpc1ZhbGlkYXRpbmdgIHN0YXRlLCB1cGRhdGUgdGhlIGNhY2hlLlxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmV0Y2hJbmZvKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdGUoeyBpc1ZhbGlkYXRpbmc6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUZWxsIGFsbCBvdGhlciBob29rcyB0byBjaGFuZ2UgdGhlIGBpc1ZhbGlkYXRpbmdgIHN0YXRlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBzdGF0ZVJlZi5jdXJyZW50LmRhdGEsIHN0YXRlUmVmLmN1cnJlbnQuZXJyb3IsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBjYWNoZSBiZWluZyByZW5kZXJlZCBjdXJyZW50bHkgKGl0IHNob3dzIGEgYmxhbmsgcGFnZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHRyaWdnZXIgdGhlIGxvYWRpbmcgc2xvdyBldmVudC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2FkaW5nVGltZW91dCAmJiAhY2FjaGUuZ2V0KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2FkaW5nICYmIGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vbkxvYWRpbmdTbG93KGtleSwgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjb25maWcubG9hZGluZ1RpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSByZXF1ZXN0IGFuZCBzYXZlIHRoZSB0aW1lc3RhbXAuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZFVENIW2tleV0gPSBbY3VycmVudEZldGNoZXIuYXBwbHkodm9pZCAwLCBmbkFyZ3MpLCBnZXRUaW1lc3RhbXAoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF9hID0gRkVUQ0hba2V5XSwgbmV3RGF0YSA9IF9hWzBdLCBzdGFydEF0ID0gX2FbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbmV3RGF0YV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IGlzbid0IGludGVycnVwdGVkLCBjbGVhbiBpdCB1cCBhZnRlciB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVkdXBsaWNhdGlvbiBpbnRlcnZhbC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjbGVhbnVwU3RhdGUsIGNvbmZpZy5kZWR1cGluZ0ludGVydmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncmUgb3RoZXIgb25nb2luZyByZXF1ZXN0KHMpLCBzdGFydGVkIGFmdGVyIHRoZSBjdXJyZW50IG9uZSxcclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGlnbm9yZSB0aGUgY3VycmVudCBvbmUgdG8gYXZvaWQgcG9zc2libGUgcmFjZSBjb25kaXRpb25zOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgcmVxMS0tLS0tLS0tLS0tLS0tLS0tLT5yZXMxICAgICAgICAoY3VycmVudCBvbmUpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgIHJlcTItLS0tLS0tLS0tLS0tLS0tPnJlczJcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCB0aGF0IGZpcmVkIGxhdGVyIHdpbGwgYWx3YXlzIGJlIGtlcHQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRpbWVzdGFtcCBtYXliZSBiZSBgdW5kZWZpbmVkYCBvciBhIG51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghRkVUQ0hba2V5XSB8fCBGRVRDSFtrZXldWzFdICE9PSBzdGFydEF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRLZXlNb3VudGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vbkRpc2NhcmRlZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmYWxzZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmV0Y2hJbmZvKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFVOREVGSU5FRFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmVycm9yID0gVU5ERUZJTkVEO1xyXG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSW5mbyA9IE1VVEFUSU9OW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChtdXRhdGlvbkluZm8pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhcnRBdCA8PSBtdXRhdGlvbkluZm9bMF0gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRBdCA8PSBtdXRhdGlvbkluZm9bMV0gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgM1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25JbmZvWzFdID09PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRGlzY2FyZGVkKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVlcCBjb21wYXJlIHdpdGggbGF0ZXN0IHN0YXRlIHRvIGF2b2lkIGV4dHJhIHJlLXJlbmRlcnMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGxvY2FsIHN0YXRlLCBjb21wYXJlIGFuZCBhc3NpZ24uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKHN0YXRlUmVmLmN1cnJlbnQuZGF0YSwgbmV3RGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUuZGF0YSA9IG5ld0RhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkYXRhIGFuZCBuZXdEYXRhIGFyZSBkZWVwbHkgZXF1YWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIGJlIHNhZmUgdG8gYnJvYWRjYXN0IHRoZSBzdGFsZSBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmRhdGEgPSBzdGF0ZVJlZi5jdXJyZW50LmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0IHRoZSBlbmQgb2YgdGhpcyBmdW5jdGlvbiwgYGJyb2Nhc3RTdGF0ZWAgaW52b2tlcyB0aGUgYG9uU3RhdGVVcGRhdGVgIGZ1bmN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB0YWtlcyBjYXJlIG9mIGF2b2lkaW5nIHRoZSByZS1yZW5kZXJcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGdsb2JhbCBzdGF0ZSwgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBrZXkgaGFzIGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9zd3IvcHVsbC8xMDU4XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKGNhY2hlLmdldChrZXkpLCBuZXdEYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCBuZXdEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciB0aGUgc3VjY2Vzc2Z1bCBjYWxsYmFjayBpZiBpdCdzIHRoZSBvcmlnaW5hbCByZXF1ZXN0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25TdWNjZXNzKG5ld0RhdGEsIGtleSwgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBlcnJfMSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwU3RhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgcGF1c2VkLCB3ZSBjb250aW51ZSBoYW5kbGluZyB0aGUgZXJyb3IuIE90aGVyd2lzZSBkaXNjYXJkIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2V0Q29uZmlnKCkuaXNQYXVzZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBuZXcgZXJyb3IsIGRvbid0IHVzZSBkZWVwIGNvbXBhcmlzb24gZm9yIGVycm9ycy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hGZXRjaEluZm8oeyBlcnJvcjogZXJyXzEgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmVycm9yID0gZXJyXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9yIGV2ZW50IGFuZCByZXRyeSBsb2dpYy4gT25seSBmb3IgdGhlIGFjdHVhbCByZXF1ZXN0LCBub3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVkdXBlZCBvbmVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0ICYmIGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25FcnJvcihlcnJfMSwga2V5LCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgY29uZmlnLnNob3VsZFJldHJ5T25FcnJvciA9PT0gJ2Jvb2xlYW4nICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnNob3VsZFJldHJ5T25FcnJvcikgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNGdW5jdGlvbihjb25maWcuc2hvdWxkUmV0cnlPbkVycm9yKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc2hvdWxkUmV0cnlPbkVycm9yKGVycl8xKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHJldHJ5aW5nLCBkZWR1cGUgaXMgYWx3YXlzIGVuYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGFjdGl2ZSwgc3RvcC4gSXQgd2lsbCBhdXRvIHJldmFsaWRhdGUgd2hlbiByZWZvY3VzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIHJlY29ubmVjdGluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25FcnJvclJldHJ5KGVycl8xLCBrZXksIGNvbmZpZywgcmV2YWxpZGF0ZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudDogKG9wdHMucmV0cnlDb3VudCB8fCAwKSArIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWR1cGU6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hcmsgbG9hZGluZyBhcyBzdG9wcGVkLlxyXG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgaG9vaydzIHN0YXRlLlxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhlcmUgaXMgdGhlIHNvdXJjZSBvZiB0aGUgcmVxdWVzdCwgbmVlZCB0byB0ZWxsIGFsbCBvdGhlciBob29rcyB0b1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGVpciBzdGF0ZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEtleU1vdW50ZWQoKSAmJiBzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgbmV3U3RhdGUuZGF0YSwgbmV3U3RhdGUuZXJyb3IsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRydWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTsgfSwgXHJcbiAgICAvLyBgc2V0U3RhdGVgIGlzIGltbXV0YWJsZSwgYW5kIGBldmVudHNDYWxsYmFja2AsIGBmbkFyZ3NgLCBga2V5SW5mb2AsXHJcbiAgICAvLyBhbmQgYGtleVZhbGlkYXRpbmdgIGFyZSBkZXBlbmRpbmcgb24gYGtleWAsIHNvIHdlIGNhbiBleGNsdWRlIHRoZW0gZnJvbVxyXG4gICAgLy8gdGhlIGRlcHMgYXJyYXkuXHJcbiAgICAvL1xyXG4gICAgLy8gRklYTUU6XHJcbiAgICAvLyBgZm5gIGFuZCBgY29uZmlnYCBtaWdodCBiZSBjaGFuZ2VkIGR1cmluZyB0aGUgbGlmZWN5Y2xlLFxyXG4gICAgLy8gYnV0IHRoZXkgbWlnaHQgYmUgY2hhbmdlZCBldmVyeSByZW5kZXIgbGlrZSB0aGlzLlxyXG4gICAgLy8gYHVzZVNXUigna2V5JywgKCkgPT4gZmV0Y2goJy9hcGkvJyksIHsgc3VzcGVuc2U6IHRydWUgfSlgXHJcbiAgICAvLyBTbyB3ZSBvbWl0IHRoZSB2YWx1ZXMgZnJvbSB0aGUgZGVwcyBhcnJheVxyXG4gICAgLy8gZXZlbiB0aG91Z2ggaXQgbWlnaHQgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvcnMuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICBba2V5XSk7XHJcbiAgICAvLyBTaW1pbGFyIHRvIHRoZSBnbG9iYWwgbXV0YXRlLCBidXQgYm91bmQgdG8gdGhlIGN1cnJlbnQgY2FjaGUgYW5kIGtleS5cclxuICAgIC8vIGBjYWNoZWAgaXNuJ3QgYWxsb3dlZCB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZlY3ljbGUuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICB2YXIgYm91bmRNdXRhdGUgPSB1c2VDYWxsYmFjayhcclxuICAgIC8vIEJ5IHVzaW5nIGBiaW5kYCB3ZSBkb24ndCBuZWVkIHRvIG1vZGlmeSB0aGUgc2l6ZSBvZiB0aGUgcmVzdCBhcmd1bWVudHMuXHJcbiAgICAvLyBEdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zNzE4MSwgd2UgaGF2ZSB0b1xyXG4gICAgLy8gY2FzdCBpdCB0byBhbnkgZm9yIG5vdy5cclxuICAgIGludGVybmFsTXV0YXRlLmJpbmQoVU5ERUZJTkVELCBjYWNoZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4ga2V5UmVmLmN1cnJlbnQ7IH0pLCBcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcclxuICAgIFtdKTtcclxuICAgIC8vIEFsd2F5cyB1cGRhdGUgZmV0Y2hlciBhbmQgY29uZmlnIHJlZnMuXHJcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmZXRjaGVyUmVmLmN1cnJlbnQgPSBmZXRjaGVyO1xyXG4gICAgICAgIGNvbmZpZ1JlZi5jdXJyZW50ID0gY29uZmlnO1xyXG4gICAgfSk7XHJcbiAgICAvLyBBZnRlciBtb3VudGVkIG9yIGtleSBjaGFuZ2VkLlxyXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFrZXkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIga2V5Q2hhbmdlZCA9IGtleSAhPT0ga2V5UmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgdmFyIHNvZnRSZXZhbGlkYXRlID0gcmV2YWxpZGF0ZS5iaW5kKFVOREVGSU5FRCwgV0lUSF9ERURVUEUpO1xyXG4gICAgICAgIC8vIEV4cG9zZSBzdGF0ZSB1cGRhdGVyIHRvIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMuIFNvIHdlIGNhbiB1cGRhdGUgaG9vaydzXHJcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGUgZnJvbSB0aGUgb3V0c2lkZS5cclxuICAgICAgICB2YXIgb25TdGF0ZVVwZGF0ZSA9IGZ1bmN0aW9uICh1cGRhdGVkRGF0YSwgdXBkYXRlZEVycm9yLCB1cGRhdGVkSXNWYWxpZGF0aW5nKSB7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKG1lcmdlT2JqZWN0cyh7XHJcbiAgICAgICAgICAgICAgICBlcnJvcjogdXBkYXRlZEVycm9yLFxyXG4gICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiB1cGRhdGVkSXNWYWxpZGF0aW5nXHJcbiAgICAgICAgICAgIH0sIFxyXG4gICAgICAgICAgICAvLyBTaW5jZSBgc2V0U3RhdGVgIG9ubHkgc2hhbGxvd2x5IGNvbXBhcmVzIHN0YXRlcywgd2UgZG8gYSBkZWVwXHJcbiAgICAgICAgICAgIC8vIGNvbXBhcmlzb24gaGVyZS5cclxuICAgICAgICAgICAgY29tcGFyZShzdGF0ZVJlZi5jdXJyZW50LmRhdGEsIHVwZGF0ZWREYXRhKVxyXG4gICAgICAgICAgICAgICAgPyBVTkRFRklORURcclxuICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHVwZGF0ZWREYXRhXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBFeHBvc2UgcmV2YWxpZGF0b3JzIHRvIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMuIFNvIHdlIGNhbiB0cmlnZ2VyXHJcbiAgICAgICAgLy8gcmV2YWxpZGF0aW9uIGZyb20gdGhlIG91dHNpZGUuXHJcbiAgICAgICAgdmFyIG5leHRGb2N1c1JldmFsaWRhdGVkQXQgPSAwO1xyXG4gICAgICAgIHZhciBvblJldmFsaWRhdGUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PSBGT0NVU19FVkVOVCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Q29uZmlnKCkucmV2YWxpZGF0ZU9uRm9jdXMgJiZcclxuICAgICAgICAgICAgICAgICAgICBub3cgPiBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRGb2N1c1JldmFsaWRhdGVkQXQgPSBub3cgKyBnZXRDb25maWcoKS5mb2N1c1Rocm90dGxlSW50ZXJ2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFJFQ09OTkVDVF9FVkVOVCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdldENvbmZpZygpLnJldmFsaWRhdGVPblJlY29ubmVjdCAmJiBpc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IE1VVEFURV9FVkVOVCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdW5zdWJVcGRhdGUgPSBzdWJzY3JpYmVDYWxsYmFjayhrZXksIFNUQVRFX1VQREFURVJTLCBvblN0YXRlVXBkYXRlKTtcclxuICAgICAgICB2YXIgdW5zdWJFdmVudHMgPSBzdWJzY3JpYmVDYWxsYmFjayhrZXksIEVWRU5UX1JFVkFMSURBVE9SUywgb25SZXZhbGlkYXRlKTtcclxuICAgICAgICAvLyBNYXJrIHRoZSBjb21wb25lbnQgYXMgbW91bnRlZCBhbmQgdXBkYXRlIGNvcnJlc3BvbmRpbmcgcmVmcy5cclxuICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICAgIGtleVJlZi5jdXJyZW50ID0ga2V5O1xyXG4gICAgICAgIGluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgIC8vIFdoZW4gYGtleWAgdXBkYXRlcywgcmVzZXQgdGhlIHN0YXRlIHRvIHRoZSBpbml0aWFsIHZhbHVlXHJcbiAgICAgICAgLy8gYW5kIHRyaWdnZXIgYSByZXJlbmRlciBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgaWYgKGtleUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcclxuICAgICAgICAgICAgICAgIGlzVmFsaWRhdGluZzogaXNWYWxpZGF0aW5nXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcmlnZ2VyIGEgcmV2YWxpZGF0aW9uLlxyXG4gICAgICAgIGlmIChzaG91bGRSZXZhbGlkYXRlKCkpIHtcclxuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGRhdGEpIHx8IElTX1NFUlZFUikge1xyXG4gICAgICAgICAgICAgICAgLy8gUmV2YWxpZGF0ZSBpbW1lZGlhdGVseS5cclxuICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEZWxheSB0aGUgcmV2YWxpZGF0ZSBpZiB3ZSBoYXZlIGRhdGEgdG8gcmV0dXJuIHNvIHdlIHdvbid0IGJsb2NrXHJcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJpbmcuXHJcbiAgICAgICAgICAgICAgICByQUYoc29mdFJldmFsaWRhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIE1hcmsgaXQgYXMgdW5tb3VudGVkLlxyXG4gICAgICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIHVuc3ViVXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHVuc3ViRXZlbnRzKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtrZXksIHJldmFsaWRhdGVdKTtcclxuICAgIC8vIFBvbGxpbmdcclxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aW1lcjtcclxuICAgICAgICBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgICAgICAgICAvLyBVc2UgdGhlIHBhc3NlZCBpbnRlcnZhbFxyXG4gICAgICAgICAgICAvLyAuLi5vciBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHVwZGF0ZWQgZGF0YSB0byBnZXQgdGhlIGludGVydmFsXHJcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IGlzRnVuY3Rpb24ocmVmcmVzaEludGVydmFsKVxyXG4gICAgICAgICAgICAgICAgPyByZWZyZXNoSW50ZXJ2YWwoZGF0YSlcclxuICAgICAgICAgICAgICAgIDogcmVmcmVzaEludGVydmFsO1xyXG4gICAgICAgICAgICAvLyBXZSBvbmx5IHN0YXJ0IG5leHQgaW50ZXJ2YWwgaWYgYHJlZnJlc2hJbnRlcnZhbGAgaXMgbm90IDAsIGFuZDpcclxuICAgICAgICAgICAgLy8gLSBgZm9yY2VgIGlzIHRydWUsIHdoaWNoIGlzIHRoZSBzdGFydCBvZiBwb2xsaW5nXHJcbiAgICAgICAgICAgIC8vIC0gb3IgYHRpbWVyYCBpcyBub3QgMCwgd2hpY2ggbWVhbnMgdGhlIGVmZmVjdCB3YXNuJ3QgY2FuY2VsZWRcclxuICAgICAgICAgICAgaWYgKGludGVydmFsICYmIHRpbWVyICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWN1dGUsIGludGVydmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlKCkge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIE9LIHRvIGV4ZWN1dGU6XHJcbiAgICAgICAgICAgIC8vIE9ubHkgcmV2YWxpZGF0ZSB3aGVuIHRoZSBwYWdlIGlzIHZpc2libGUsIG9ubGluZSBhbmQgbm90IGVycm9yZWQuXHJcbiAgICAgICAgICAgIGlmICghc3RhdGVSZWYuY3VycmVudC5lcnJvciAmJlxyXG4gICAgICAgICAgICAgICAgKHJlZnJlc2hXaGVuSGlkZGVuIHx8IGdldENvbmZpZygpLmlzVmlzaWJsZSgpKSAmJlxyXG4gICAgICAgICAgICAgICAgKHJlZnJlc2hXaGVuT2ZmbGluZSB8fCBnZXRDb25maWcoKS5pc09ubGluZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZShXSVRIX0RFRFVQRSkudGhlbihuZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIG5leHQgaW50ZXJ2YWwgdG8gY2hlY2sgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICBuZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbmV4dCgpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICAgICAgICAgIHRpbWVyID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSwgW3JlZnJlc2hJbnRlcnZhbCwgcmVmcmVzaFdoZW5IaWRkZW4sIHJlZnJlc2hXaGVuT2ZmbGluZSwgcmV2YWxpZGF0ZV0pO1xyXG4gICAgLy8gRGlzcGxheSBkZWJ1ZyBpbmZvIGluIFJlYWN0IERldlRvb2xzLlxyXG4gICAgdXNlRGVidWdWYWx1ZShkYXRhKTtcclxuICAgIC8vIEluIFN1c3BlbnNlIG1vZGUsIHdlIGNhbid0IHJldHVybiB0aGUgZW1wdHkgYGRhdGFgIHN0YXRlLlxyXG4gICAgLy8gSWYgdGhlcmUgaXMgYGVycm9yYCwgdGhlIGBlcnJvcmAgbmVlZHMgdG8gYmUgdGhyb3duIHRvIHRoZSBlcnJvciBib3VuZGFyeS5cclxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGBlcnJvcmAsIHRoZSBgcmV2YWxpZGF0aW9uYCBwcm9taXNlIG5lZWRzIHRvIGJlIHRocm93biB0b1xyXG4gICAgLy8gdGhlIHN1c3BlbnNlIGJvdW5kYXJ5LlxyXG4gICAgaWYgKHN1c3BlbnNlICYmIGlzVW5kZWZpbmVkKGRhdGEpICYmIGtleSkge1xyXG4gICAgICAgIC8vIEFsd2F5cyB1cGRhdGUgZmV0Y2hlciBhbmQgY29uZmlnIHJlZnMgZXZlbiB3aXRoIHRoZSBTdXNwZW5zZSBtb2RlLlxyXG4gICAgICAgIGZldGNoZXJSZWYuY3VycmVudCA9IGZldGNoZXI7XHJcbiAgICAgICAgY29uZmlnUmVmLmN1cnJlbnQgPSBjb25maWc7XHJcbiAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICB0aHJvdyBpc1VuZGVmaW5lZChlcnJvcikgPyByZXZhbGlkYXRlKFdJVEhfREVEVVBFKSA6IGVycm9yO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtdXRhdGU6IGJvdW5kTXV0YXRlLFxyXG4gICAgICAgIGdldCBkYXRhKCkge1xyXG4gICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5kYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgZXJyb3IoKSB7XHJcbiAgICAgICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzLmVycm9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IGlzVmFsaWRhdGluZygpIHtcclxuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuaXNWYWxpZGF0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRhdGluZztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG52YXIgU1dSQ29uZmlnID0gT0JKRUNULmRlZmluZVByb3BlcnR5KFNXUkNvbmZpZyQxLCAnZGVmYXVsdCcsIHtcclxuICAgIHZhbHVlOiBkZWZhdWx0Q29uZmlnXHJcbn0pO1xyXG52YXIgdW5zdGFibGVfc2VyaWFsaXplID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc2VyaWFsaXplKGtleSlbMF07IH07XHJcbnZhciB1c2VTV1IgPSB3aXRoQXJncyh1c2VTV1JIYW5kbGVyKTtcclxuXHJcbi8vIHVzZVNXUlxyXG5cclxuZXhwb3J0IHsgU1dSQ29uZmlnLCB1c2VTV1IgYXMgZGVmYXVsdCwgbXV0YXRlLCB1bnN0YWJsZV9zZXJpYWxpemUsIHVzZVNXUkNvbmZpZyB9O1xyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsInVzZURlYnVnVmFsdWUiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJfX2dlbmVyYXRvciIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidCIsInRyeXMiLCJvcHMiLCJmIiwieSIsImciLCJ2ZXJiIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJuIiwidiIsIm9wIiwiVHlwZUVycm9yIiwiY2FsbCIsInBvcCIsImxlbmd0aCIsInB1c2giLCJub29wIiwiVU5ERUZJTkVEIiwiT0JKRUNUIiwiT2JqZWN0IiwiaXNVbmRlZmluZWQiLCJpc0Z1bmN0aW9uIiwibWVyZ2VPYmplY3RzIiwiYSIsImIiLCJhc3NpZ24iLCJTVFJfVU5ERUZJTkVEIiwiaGFzV2luZG93Iiwid2luZG93IiwiaGFzRG9jdW1lbnQiLCJkb2N1bWVudCIsImhhc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsInRhYmxlIiwiV2Vha01hcCIsImNvdW50ZXIiLCJzdGFibGVIYXNoIiwiYXJnIiwidHlwZSIsImNvbnN0cnVjdG9yIiwiaXNEYXRlIiwiRGF0ZSIsImluZGV4IiwiUmVnRXhwIiwiZ2V0Iiwic2V0IiwiQXJyYXkiLCJrZXlzIiwic29ydCIsInRvSlNPTiIsInRvU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsIm9ubGluZSIsImlzT25saW5lIiwiaGFzV2luIiwiaGFzRG9jIiwib25XaW5kb3dFdmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJiaW5kIiwib25Eb2N1bWVudEV2ZW50Iiwib2ZmV2luZG93RXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib2ZmRG9jdW1lbnRFdmVudCIsImlzVmlzaWJsZSIsInZpc2liaWxpdHlTdGF0ZSIsImluaXRGb2N1cyIsImNhbGxiYWNrIiwiaW5pdFJlY29ubmVjdCIsIm9uT25saW5lIiwib25PZmZsaW5lIiwicHJlc2V0IiwiZGVmYXVsdENvbmZpZ09wdGlvbnMiLCJJU19TRVJWRVIiLCJyQUYiLCJzZXRUaW1lb3V0IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIm5hdmlnYXRvckNvbm5lY3Rpb24iLCJuYXZpZ2F0b3IiLCJjb25uZWN0aW9uIiwic2xvd0Nvbm5lY3Rpb24iLCJpbmNsdWRlcyIsImVmZmVjdGl2ZVR5cGUiLCJzYXZlRGF0YSIsInNlcmlhbGl6ZSIsImtleSIsImVyciIsImFyZ3MiLCJjb25jYXQiLCJpc0FycmF5IiwiaW5mb0tleSIsIlNXUkdsb2JhbFN0YXRlIiwiRk9DVVNfRVZFTlQiLCJSRUNPTk5FQ1RfRVZFTlQiLCJNVVRBVEVfRVZFTlQiLCJicm9hZGNhc3RTdGF0ZSIsImNhY2hlIiwiZGF0YSIsImVycm9yIiwiaXNWYWxpZGF0aW5nIiwicmV2YWxpZGF0ZSIsImJyb2FkY2FzdCIsIl9hIiwiRVZFTlRfUkVWQUxJREFUT1JTIiwiU1RBVEVfVVBEQVRFUlMiLCJGRVRDSCIsInJldmFsaWRhdG9ycyIsInVwZGF0ZXJzIiwiaSIsIl9fdGltZXN0YW1wIiwiZ2V0VGltZXN0YW1wIiwiaW50ZXJuYWxNdXRhdGUiLCJfaSIsImFyZ3VtZW50cyIsIl9rZXkiLCJfZGF0YSIsIl9vcHRzIiwib3B0aW9ucyIsInBvcHVsYXRlQ2FjaGUiLCJyb2xsYmFja09uRXJyb3IiLCJjdXN0b21PcHRpbWlzdGljRGF0YSIsImtleUluZm8iLCJfYiIsIk1VVEFUSU9OIiwiYmVmb3JlTXV0YXRpb25UcyIsImhhc0N1c3RvbU9wdGltaXN0aWNEYXRhIiwicm9sbGJhY2tEYXRhIiwib3B0aW1pc3RpY0RhdGEiLCJyZXMiLCJfYyIsImNhdGNoIiwicmV2YWxpZGF0ZUFsbEtleXMiLCJpbml0Q2FjaGUiLCJwcm92aWRlciIsImhhcyIsIm9wdHMiLCJtdXRhdGUiLCJ1bm1vdW50IiwicmVsZWFzZUZvY3VzXzEiLCJyZWxlYXNlUmVjb25uZWN0XzEiLCJkZWxldGUiLCJvbkVycm9yUmV0cnkiLCJfXyIsImNvbmZpZyIsIm1heFJldHJ5Q291bnQiLCJlcnJvclJldHJ5Q291bnQiLCJjdXJyZW50UmV0cnlDb3VudCIsInJldHJ5Q291bnQiLCJ0aW1lb3V0IiwiTWF0aCIsInJhbmRvbSIsImVycm9yUmV0cnlJbnRlcnZhbCIsIk1hcCIsImRlZmF1bHRDb25maWciLCJvbkxvYWRpbmdTbG93Iiwib25TdWNjZXNzIiwib25FcnJvciIsIm9uRGlzY2FyZGVkIiwicmV2YWxpZGF0ZU9uRm9jdXMiLCJyZXZhbGlkYXRlT25SZWNvbm5lY3QiLCJyZXZhbGlkYXRlSWZTdGFsZSIsInNob3VsZFJldHJ5T25FcnJvciIsImZvY3VzVGhyb3R0bGVJbnRlcnZhbCIsImRlZHVwaW5nSW50ZXJ2YWwiLCJsb2FkaW5nVGltZW91dCIsImNvbXBhcmUiLCJjdXJyZW50RGF0YSIsIm5ld0RhdGEiLCJpc1BhdXNlZCIsImZhbGxiYWNrIiwibWVyZ2VDb25maWdzIiwidTEiLCJ1c2UiLCJmMSIsInUyIiwiZjIiLCJTV1JDb25maWdDb250ZXh0IiwiU1dSQ29uZmlnJDEiLCJwcm9wcyIsImV4dGVuZGVkQ29uZmlnIiwiY2FjaGVDb250ZXh0IiwiUHJvdmlkZXIiLCJ1c2VTdGF0ZVdpdGhEZXBzIiwic3RhdGUiLCJ1bm1vdW50ZWRSZWYiLCJyZXJlbmRlciIsInN0YXRlUmVmIiwic3RhdGVEZXBlbmRlbmNpZXNSZWYiLCJzZXRTdGF0ZSIsInBheWxvYWQiLCJzaG91bGRSZXJlbmRlciIsImN1cnJlbnRTdGF0ZSIsImN1cnJlbnQiLCJrIiwibm9ybWFsaXplIiwidXNlU1dSQ29uZmlnIiwid2l0aEFyZ3MiLCJob29rIiwidXNlU1dSQXJncyIsImZhbGxiYWNrQ29uZmlnIiwiZm4iLCJfY29uZmlnIiwiZmV0Y2hlciIsInN1YnNjcmliZUNhbGxiYWNrIiwiY2FsbGJhY2tzIiwia2V5ZWRSZXZhbGlkYXRvcnMiLCJpbmRleE9mIiwiV0lUSF9ERURVUEUiLCJkZWR1cGUiLCJ1c2VTV1JIYW5kbGVyIiwiZmFsbGJhY2tEYXRhIiwic3VzcGVuc2UiLCJyZXZhbGlkYXRlT25Nb3VudCIsInJlZnJlc2hJbnRlcnZhbCIsInJlZnJlc2hXaGVuSGlkZGVuIiwicmVmcmVzaFdoZW5PZmZsaW5lIiwiZm5BcmdzIiwiaW5pdGlhbE1vdW50ZWRSZWYiLCJrZXlSZWYiLCJmZXRjaGVyUmVmIiwiY29uZmlnUmVmIiwiZ2V0Q29uZmlnIiwiaXNBY3RpdmUiLCJwYXRjaEZldGNoSW5mbyIsImluZm8iLCJjYWNoZWQiLCJpc0luaXRpYWxNb3VudCIsInNob3VsZFJldmFsaWRhdGUiLCJyZXNvbHZlVmFsaWRhdGluZyIsInN0YXRlRGVwZW5kZW5jaWVzIiwicmV2YWxpZGF0ZU9wdHMiLCJjdXJyZW50RmV0Y2hlciIsInN0YXJ0QXQiLCJsb2FkaW5nIiwic2hvdWxkU3RhcnROZXdSZXF1ZXN0IiwiaXNDdXJyZW50S2V5TW91bnRlZCIsImNsZWFudXBTdGF0ZSIsIm5ld1N0YXRlIiwiZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlIiwibXV0YXRpb25JbmZvIiwiZXJyXzEiLCJyZXF1ZXN0SW5mbyIsImJvdW5kTXV0YXRlIiwia2V5Q2hhbmdlZCIsInNvZnRSZXZhbGlkYXRlIiwib25TdGF0ZVVwZGF0ZSIsInVwZGF0ZWREYXRhIiwidXBkYXRlZEVycm9yIiwidXBkYXRlZElzVmFsaWRhdGluZyIsIm5leHRGb2N1c1JldmFsaWRhdGVkQXQiLCJvblJldmFsaWRhdGUiLCJub3ciLCJ1bnN1YlVwZGF0ZSIsInVuc3ViRXZlbnRzIiwidGltZXIiLCJpbnRlcnZhbCIsImV4ZWN1dGUiLCJjbGVhclRpbWVvdXQiLCJTV1JDb25maWciLCJkZWZpbmVQcm9wZXJ0eSIsInVuc3RhYmxlX3NlcmlhbGl6ZSIsInVzZVNXUiIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/swr/dist/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!"), __webpack_exec__("./node_modules/next/dist/client/router.js"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);