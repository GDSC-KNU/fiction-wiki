/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLGlCQUFULENBQTJCQyxHQUEzQixFQUFnQ0MsR0FBaEMsRUFBcUM7RUFDbkMsSUFBSUEsR0FBRyxJQUFJLElBQVAsSUFBZUEsR0FBRyxHQUFHRCxHQUFHLENBQUNFLE1BQTdCLEVBQXFDRCxHQUFHLEdBQUdELEdBQUcsQ0FBQ0UsTUFBVjs7RUFFckMsS0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBUixFQUFXQyxJQUFJLEdBQUcsSUFBSUMsS0FBSixDQUFVSixHQUFWLENBQXZCLEVBQXVDRSxDQUFDLEdBQUdGLEdBQTNDLEVBQWdERSxDQUFDLEVBQWpELEVBQXFEO0lBQ25EQyxJQUFJLENBQUNELENBQUQsQ0FBSixHQUFVSCxHQUFHLENBQUNHLENBQUQsQ0FBYjtFQUNEOztFQUVELE9BQU9DLElBQVA7QUFDRDs7QUFFREUsTUFBTSxDQUFDQyxPQUFQLEdBQWlCUixpQkFBakIsRUFBb0NPLHlCQUFBLEdBQTRCLElBQWhFLEVBQXNFQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF6RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzP2NmMDkiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9hcnJheUxpa2VUb0FycmF5IiwiYXJyIiwibGVuIiwibGVuZ3RoIiwiaSIsImFycjIiLCJBcnJheSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/arrayLikeToArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxHQUF6QixFQUE4QjtFQUM1QixJQUFJQyxLQUFLLENBQUNDLE9BQU4sQ0FBY0YsR0FBZCxDQUFKLEVBQXdCLE9BQU9BLEdBQVA7QUFDekI7O0FBRURHLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsZUFBakIsRUFBa0NJLHlCQUFBLEdBQTRCLElBQTlELEVBQW9FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF2RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcz9hNTI1Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2FycmF5V2l0aEhvbGVzIiwiYXJyIiwiQXJyYXkiLCJpc0FycmF5IiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/arrayWithHoles.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0Esc0JBQVQsQ0FBZ0NDLElBQWhDLEVBQXNDO0VBQ3BDLElBQUlBLElBQUksS0FBSyxLQUFLLENBQWxCLEVBQXFCO0lBQ25CLE1BQU0sSUFBSUMsY0FBSixDQUFtQiwyREFBbkIsQ0FBTjtFQUNEOztFQUVELE9BQU9ELElBQVA7QUFDRDs7QUFFREUsTUFBTSxDQUFDQyxPQUFQLEdBQWlCSixzQkFBakIsRUFBeUNHLHlCQUFBLEdBQTRCLElBQXJFLEVBQTJFQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUE5RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/MjAxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/assertThisInitialized.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLGtCQUFULENBQTRCQyxHQUE1QixFQUFpQ0MsT0FBakMsRUFBMENDLE1BQTFDLEVBQWtEQyxLQUFsRCxFQUF5REMsTUFBekQsRUFBaUVDLEdBQWpFLEVBQXNFQyxHQUF0RSxFQUEyRTtFQUN6RSxJQUFJO0lBQ0YsSUFBSUMsSUFBSSxHQUFHUCxHQUFHLENBQUNLLEdBQUQsQ0FBSCxDQUFTQyxHQUFULENBQVg7SUFDQSxJQUFJRSxLQUFLLEdBQUdELElBQUksQ0FBQ0MsS0FBakI7RUFDRCxDQUhELENBR0UsT0FBT0MsS0FBUCxFQUFjO0lBQ2RQLE1BQU0sQ0FBQ08sS0FBRCxDQUFOO0lBQ0E7RUFDRDs7RUFFRCxJQUFJRixJQUFJLENBQUNHLElBQVQsRUFBZTtJQUNiVCxPQUFPLENBQUNPLEtBQUQsQ0FBUDtFQUNELENBRkQsTUFFTztJQUNMRyxPQUFPLENBQUNWLE9BQVIsQ0FBZ0JPLEtBQWhCLEVBQXVCSSxJQUF2QixDQUE0QlQsS0FBNUIsRUFBbUNDLE1BQW5DO0VBQ0Q7QUFDRjs7QUFFRCxTQUFTUyxpQkFBVCxDQUEyQkMsRUFBM0IsRUFBK0I7RUFDN0IsT0FBTyxZQUFZO0lBQ2pCLElBQUlDLElBQUksR0FBRyxJQUFYO0lBQUEsSUFDSUMsSUFBSSxHQUFHQyxTQURYO0lBRUEsT0FBTyxJQUFJTixPQUFKLENBQVksVUFBVVYsT0FBVixFQUFtQkMsTUFBbkIsRUFBMkI7TUFDNUMsSUFBSUYsR0FBRyxHQUFHYyxFQUFFLENBQUNJLEtBQUgsQ0FBU0gsSUFBVCxFQUFlQyxJQUFmLENBQVY7O01BRUEsU0FBU2IsS0FBVCxDQUFlSyxLQUFmLEVBQXNCO1FBQ3BCVCxrQkFBa0IsQ0FBQ0MsR0FBRCxFQUFNQyxPQUFOLEVBQWVDLE1BQWYsRUFBdUJDLEtBQXZCLEVBQThCQyxNQUE5QixFQUFzQyxNQUF0QyxFQUE4Q0ksS0FBOUMsQ0FBbEI7TUFDRDs7TUFFRCxTQUFTSixNQUFULENBQWdCZSxHQUFoQixFQUFxQjtRQUNuQnBCLGtCQUFrQixDQUFDQyxHQUFELEVBQU1DLE9BQU4sRUFBZUMsTUFBZixFQUF1QkMsS0FBdkIsRUFBOEJDLE1BQTlCLEVBQXNDLE9BQXRDLEVBQStDZSxHQUEvQyxDQUFsQjtNQUNEOztNQUVEaEIsS0FBSyxDQUFDaUIsU0FBRCxDQUFMO0lBQ0QsQ0FaTSxDQUFQO0VBYUQsQ0FoQkQ7QUFpQkQ7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQlQsaUJBQWpCLEVBQW9DUSx5QkFBQSxHQUE0QixJQUFoRSxFQUFzRUEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBekciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcz9kMzEyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbImFzeW5jR2VuZXJhdG9yU3RlcCIsImdlbiIsInJlc29sdmUiLCJyZWplY3QiLCJfbmV4dCIsIl90aHJvdyIsImtleSIsImFyZyIsImluZm8iLCJ2YWx1ZSIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJmbiIsInNlbGYiLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJlcnIiLCJ1bmRlZmluZWQiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/asyncToGenerator.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxRQUF6QixFQUFtQ0MsV0FBbkMsRUFBZ0Q7RUFDOUMsSUFBSSxFQUFFRCxRQUFRLFlBQVlDLFdBQXRCLENBQUosRUFBd0M7SUFDdEMsTUFBTSxJQUFJQyxTQUFKLENBQWMsbUNBQWQsQ0FBTjtFQUNEO0FBQ0Y7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsZUFBakIsRUFBa0NJLHlCQUFBLEdBQTRCLElBQTlELEVBQW9FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF2RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcz9iN2FlIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/classCallCheck.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nvar isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct.js */ \"./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js\");\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsY0FBYyxHQUFHQyxtQkFBTyxDQUFDLG9GQUFELENBQTVCOztBQUVBLElBQUlDLHdCQUF3QixHQUFHRCxtQkFBTyxDQUFDLHdHQUFELENBQXRDOztBQUVBLFNBQVNFLFVBQVQsQ0FBb0JDLE1BQXBCLEVBQTRCQyxJQUE1QixFQUFrQ0MsS0FBbEMsRUFBeUM7RUFDdkMsSUFBSUosd0JBQXdCLEVBQTVCLEVBQWdDO0lBQzlCSyxNQUFNLENBQUNDLE9BQVAsR0FBaUJMLFVBQVUsR0FBR00sT0FBTyxDQUFDQyxTQUF0QyxFQUFpREgseUJBQUEsR0FBNEIsSUFBN0UsRUFBbUZBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQXRIO0VBQ0QsQ0FGRCxNQUVPO0lBQ0xELE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsVUFBVSxHQUFHLFNBQVNBLFVBQVQsQ0FBb0JDLE1BQXBCLEVBQTRCQyxJQUE1QixFQUFrQ0MsS0FBbEMsRUFBeUM7TUFDckUsSUFBSU0sQ0FBQyxHQUFHLENBQUMsSUFBRCxDQUFSO01BQ0FBLENBQUMsQ0FBQ0MsSUFBRixDQUFPQyxLQUFQLENBQWFGLENBQWIsRUFBZ0JQLElBQWhCO01BQ0EsSUFBSVUsV0FBVyxHQUFHQyxRQUFRLENBQUNDLElBQVQsQ0FBY0gsS0FBZCxDQUFvQlYsTUFBcEIsRUFBNEJRLENBQTVCLENBQWxCO01BQ0EsSUFBSU0sUUFBUSxHQUFHLElBQUlILFdBQUosRUFBZjtNQUNBLElBQUlULEtBQUosRUFBV04sY0FBYyxDQUFDa0IsUUFBRCxFQUFXWixLQUFLLENBQUNhLFNBQWpCLENBQWQ7TUFDWCxPQUFPRCxRQUFQO0lBQ0QsQ0FQRCxFQU9HWCx5QkFBQSxHQUE0QixJQVAvQixFQU9xQ0EseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FQeEU7RUFRRDs7RUFFRCxPQUFPTCxVQUFVLENBQUNXLEtBQVgsQ0FBaUIsSUFBakIsRUFBdUJNLFNBQXZCLENBQVA7QUFDRDs7QUFFRGIsTUFBTSxDQUFDQyxPQUFQLEdBQWlCTCxVQUFqQixFQUE2QkkseUJBQUEsR0FBNEIsSUFBekQsRUFBK0RBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQWxHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcz8yOTFlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuXG52YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcmVxdWlyZShcIi4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzXCIpO1xuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3QsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIHNldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgfVxuXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJzZXRQcm90b3R5cGVPZiIsInJlcXVpcmUiLCJpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY29uc3RydWN0IiwiUGFyZW50IiwiYXJncyIsIkNsYXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJfX2VzTW9kdWxlIiwiYSIsInB1c2giLCJhcHBseSIsIkNvbnN0cnVjdG9yIiwiRnVuY3Rpb24iLCJiaW5kIiwiaW5zdGFuY2UiLCJwcm90b3R5cGUiLCJhcmd1bWVudHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/construct.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxpQkFBVCxDQUEyQkMsTUFBM0IsRUFBbUNDLEtBQW5DLEVBQTBDO0VBQ3hDLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsS0FBSyxDQUFDRSxNQUExQixFQUFrQ0QsQ0FBQyxFQUFuQyxFQUF1QztJQUNyQyxJQUFJRSxVQUFVLEdBQUdILEtBQUssQ0FBQ0MsQ0FBRCxDQUF0QjtJQUNBRSxVQUFVLENBQUNDLFVBQVgsR0FBd0JELFVBQVUsQ0FBQ0MsVUFBWCxJQUF5QixLQUFqRDtJQUNBRCxVQUFVLENBQUNFLFlBQVgsR0FBMEIsSUFBMUI7SUFDQSxJQUFJLFdBQVdGLFVBQWYsRUFBMkJBLFVBQVUsQ0FBQ0csUUFBWCxHQUFzQixJQUF0QjtJQUMzQkMsTUFBTSxDQUFDQyxjQUFQLENBQXNCVCxNQUF0QixFQUE4QkksVUFBVSxDQUFDTSxHQUF6QyxFQUE4Q04sVUFBOUM7RUFDRDtBQUNGOztBQUVELFNBQVNPLFlBQVQsQ0FBc0JDLFdBQXRCLEVBQW1DQyxVQUFuQyxFQUErQ0MsV0FBL0MsRUFBNEQ7RUFDMUQsSUFBSUQsVUFBSixFQUFnQmQsaUJBQWlCLENBQUNhLFdBQVcsQ0FBQ0csU0FBYixFQUF3QkYsVUFBeEIsQ0FBakI7RUFDaEIsSUFBSUMsV0FBSixFQUFpQmYsaUJBQWlCLENBQUNhLFdBQUQsRUFBY0UsV0FBZCxDQUFqQjtFQUNqQk4sTUFBTSxDQUFDQyxjQUFQLENBQXNCRyxXQUF0QixFQUFtQyxXQUFuQyxFQUFnRDtJQUM5Q0wsUUFBUSxFQUFFO0VBRG9DLENBQWhEO0VBR0EsT0FBT0ssV0FBUDtBQUNEOztBQUVESSxNQUFNLENBQUNDLE9BQVAsR0FBaUJOLFlBQWpCLEVBQStCSyx5QkFBQSxHQUE0QixJQUEzRCxFQUFpRUEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBcEciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanM/NTQ2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3MsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/createClass.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxHQUF6QixFQUE4QkMsR0FBOUIsRUFBbUNDLEtBQW5DLEVBQTBDO0VBQ3hDLElBQUlELEdBQUcsSUFBSUQsR0FBWCxFQUFnQjtJQUNkRyxNQUFNLENBQUNDLGNBQVAsQ0FBc0JKLEdBQXRCLEVBQTJCQyxHQUEzQixFQUFnQztNQUM5QkMsS0FBSyxFQUFFQSxLQUR1QjtNQUU5QkcsVUFBVSxFQUFFLElBRmtCO01BRzlCQyxZQUFZLEVBQUUsSUFIZ0I7TUFJOUJDLFFBQVEsRUFBRTtJQUpvQixDQUFoQztFQU1ELENBUEQsTUFPTztJQUNMUCxHQUFHLENBQUNDLEdBQUQsQ0FBSCxHQUFXQyxLQUFYO0VBQ0Q7O0VBRUQsT0FBT0YsR0FBUDtBQUNEOztBQUVEUSxNQUFNLENBQUNDLE9BQVAsR0FBaUJWLGVBQWpCLEVBQWtDUyx5QkFBQSxHQUE0QixJQUE5RCxFQUFvRUEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBdkciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanM/ZDk0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/defineProperty.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxDQUF6QixFQUE0QjtFQUMxQkMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCSCxlQUFlLEdBQUdJLE1BQU0sQ0FBQ0MsY0FBUCxHQUF3QkQsTUFBTSxDQUFDRSxjQUEvQixHQUFnRCxTQUFTTixlQUFULENBQXlCQyxDQUF6QixFQUE0QjtJQUM3RyxPQUFPQSxDQUFDLENBQUNNLFNBQUYsSUFBZUgsTUFBTSxDQUFDRSxjQUFQLENBQXNCTCxDQUF0QixDQUF0QjtFQUNELENBRkQsRUFFR0MseUJBQUEsR0FBNEIsSUFGL0IsRUFFcUNBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BRnhFO0VBR0EsT0FBT0gsZUFBZSxDQUFDQyxDQUFELENBQXRCO0FBQ0Q7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkgsZUFBakIsRUFBa0NFLHlCQUFBLEdBQTRCLElBQTlELEVBQW9FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF2RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcz85MDAzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9nZXRQcm90b3R5cGVPZiIsIm8iLCJtb2R1bGUiLCJleHBvcnRzIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/getPrototypeOf.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxjQUFjLEdBQUdDLG1CQUFPLENBQUMsb0ZBQUQsQ0FBNUI7O0FBRUEsU0FBU0MsU0FBVCxDQUFtQkMsUUFBbkIsRUFBNkJDLFVBQTdCLEVBQXlDO0VBQ3ZDLElBQUksT0FBT0EsVUFBUCxLQUFzQixVQUF0QixJQUFvQ0EsVUFBVSxLQUFLLElBQXZELEVBQTZEO0lBQzNELE1BQU0sSUFBSUMsU0FBSixDQUFjLG9EQUFkLENBQU47RUFDRDs7RUFFREYsUUFBUSxDQUFDRyxTQUFULEdBQXFCQyxNQUFNLENBQUNDLE1BQVAsQ0FBY0osVUFBVSxJQUFJQSxVQUFVLENBQUNFLFNBQXZDLEVBQWtEO0lBQ3JFRyxXQUFXLEVBQUU7TUFDWEMsS0FBSyxFQUFFUCxRQURJO01BRVhRLFFBQVEsRUFBRSxJQUZDO01BR1hDLFlBQVksRUFBRTtJQUhIO0VBRHdELENBQWxELENBQXJCO0VBT0FMLE1BQU0sQ0FBQ00sY0FBUCxDQUFzQlYsUUFBdEIsRUFBZ0MsV0FBaEMsRUFBNkM7SUFDM0NRLFFBQVEsRUFBRTtFQURpQyxDQUE3QztFQUdBLElBQUlQLFVBQUosRUFBZ0JKLGNBQWMsQ0FBQ0csUUFBRCxFQUFXQyxVQUFYLENBQWQ7QUFDakI7O0FBRURVLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQmIsU0FBakIsRUFBNEJZLHlCQUFBLEdBQTRCLElBQXhELEVBQThEQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUFqRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcz9mMzViIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsic2V0UHJvdG90eXBlT2YiLCJyZXF1aXJlIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiVHlwZUVycm9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/inherits.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0Esc0JBQVQsQ0FBZ0NDLEdBQWhDLEVBQXFDO0VBQ25DLE9BQU9BLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFYLEdBQXdCRCxHQUF4QixHQUE4QjtJQUNuQyxXQUFXQTtFQUR3QixDQUFyQztBQUdEOztBQUVERSxNQUFNLENBQUNDLE9BQVAsR0FBaUJKLHNCQUFqQixFQUF5Q0cseUJBQUEsR0FBNEIsSUFBckUsRUFBMkVBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQTlHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcz9lZThjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/interopRequireDefault.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeFunction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeFunction.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nmodule.exports = _isNativeFunction, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZUZ1bmN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLGlCQUFULENBQTJCQyxFQUEzQixFQUErQjtFQUM3QixPQUFPQyxRQUFRLENBQUNDLFFBQVQsQ0FBa0JDLElBQWxCLENBQXVCSCxFQUF2QixFQUEyQkksT0FBM0IsQ0FBbUMsZUFBbkMsTUFBd0QsQ0FBQyxDQUFoRTtBQUNEOztBQUVEQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJQLGlCQUFqQixFQUFvQ00seUJBQUEsR0FBNEIsSUFBaEUsRUFBc0VBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQXpHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlRnVuY3Rpb24uanM/OGM4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZUZ1bmN0aW9uLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9pc05hdGl2ZUZ1bmN0aW9uIiwiZm4iLCJGdW5jdGlvbiIsInRvU3RyaW5nIiwiY2FsbCIsImluZGV4T2YiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/isNativeFunction.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nmodule.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EseUJBQVQsR0FBcUM7RUFDbkMsSUFBSSxPQUFPQyxPQUFQLEtBQW1CLFdBQW5CLElBQWtDLENBQUNBLE9BQU8sQ0FBQ0MsU0FBL0MsRUFBMEQsT0FBTyxLQUFQO0VBQzFELElBQUlELE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkMsSUFBdEIsRUFBNEIsT0FBTyxLQUFQO0VBQzVCLElBQUksT0FBT0MsS0FBUCxLQUFpQixVQUFyQixFQUFpQyxPQUFPLElBQVA7O0VBRWpDLElBQUk7SUFDRkMsT0FBTyxDQUFDQyxTQUFSLENBQWtCQyxPQUFsQixDQUEwQkMsSUFBMUIsQ0FBK0JQLE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkcsT0FBbEIsRUFBMkIsRUFBM0IsRUFBK0IsWUFBWSxDQUFFLENBQTdDLENBQS9CO0lBQ0EsT0FBTyxJQUFQO0VBQ0QsQ0FIRCxDQUdFLE9BQU9JLENBQVAsRUFBVTtJQUNWLE9BQU8sS0FBUDtFQUNEO0FBQ0Y7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQlgseUJBQWpCLEVBQTRDVSx5QkFBQSxHQUE0QixJQUF4RSxFQUE4RUEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBakgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzPzFkNTQiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNoYW0iLCJQcm94eSIsIkJvb2xlYW4iLCJwcm90b3R5cGUiLCJ2YWx1ZU9mIiwiY2FsbCIsImUiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxxQkFBVCxDQUErQkMsR0FBL0IsRUFBb0NDLENBQXBDLEVBQXVDO0VBQ3JDLElBQUlDLEVBQUUsR0FBR0YsR0FBRyxJQUFJLElBQVAsR0FBYyxJQUFkLEdBQXFCLE9BQU9HLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNILEdBQUcsQ0FBQ0csTUFBTSxDQUFDQyxRQUFSLENBQXBDLElBQXlESixHQUFHLENBQUMsWUFBRCxDQUExRjs7RUFFQSxJQUFJRSxFQUFFLElBQUksSUFBVixFQUFnQjtFQUNoQixJQUFJRyxJQUFJLEdBQUcsRUFBWDtFQUNBLElBQUlDLEVBQUUsR0FBRyxJQUFUO0VBQ0EsSUFBSUMsRUFBRSxHQUFHLEtBQVQ7O0VBRUEsSUFBSUMsRUFBSixFQUFRQyxFQUFSOztFQUVBLElBQUk7SUFDRixLQUFLUCxFQUFFLEdBQUdBLEVBQUUsQ0FBQ1EsSUFBSCxDQUFRVixHQUFSLENBQVYsRUFBd0IsRUFBRU0sRUFBRSxHQUFHLENBQUNFLEVBQUUsR0FBR04sRUFBRSxDQUFDUyxJQUFILEVBQU4sRUFBaUJDLElBQXhCLENBQXhCLEVBQXVETixFQUFFLEdBQUcsSUFBNUQsRUFBa0U7TUFDaEVELElBQUksQ0FBQ1EsSUFBTCxDQUFVTCxFQUFFLENBQUNNLEtBQWI7O01BRUEsSUFBSWIsQ0FBQyxJQUFJSSxJQUFJLENBQUNVLE1BQUwsS0FBZ0JkLENBQXpCLEVBQTRCO0lBQzdCO0VBQ0YsQ0FORCxDQU1FLE9BQU9lLEdBQVAsRUFBWTtJQUNaVCxFQUFFLEdBQUcsSUFBTDtJQUNBRSxFQUFFLEdBQUdPLEdBQUw7RUFDRCxDQVRELFNBU1U7SUFDUixJQUFJO01BQ0YsSUFBSSxDQUFDVixFQUFELElBQU9KLEVBQUUsQ0FBQyxRQUFELENBQUYsSUFBZ0IsSUFBM0IsRUFBaUNBLEVBQUUsQ0FBQyxRQUFELENBQUY7SUFDbEMsQ0FGRCxTQUVVO01BQ1IsSUFBSUssRUFBSixFQUFRLE1BQU1FLEVBQU47SUFDVDtFQUNGOztFQUVELE9BQU9KLElBQVA7QUFDRDs7QUFFRFksTUFBTSxDQUFDQyxPQUFQLEdBQWlCbkIscUJBQWpCLEVBQXdDa0IseUJBQUEsR0FBNEIsSUFBcEUsRUFBMEVBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQTdHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzP2FmZTciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJhcnIiLCJpIiwiX2kiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9hcnIiLCJfbiIsIl9kIiwiX3MiLCJfZSIsImNhbGwiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImxlbmd0aCIsImVyciIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EsZ0JBQVQsR0FBNEI7RUFDMUIsTUFBTSxJQUFJQyxTQUFKLENBQWMsMklBQWQsQ0FBTjtBQUNEOztBQUVEQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJILGdCQUFqQixFQUFtQ0UseUJBQUEsR0FBNEIsSUFBL0QsRUFBcUVBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQXhHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcz80YzIwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/nonIterableRest.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\n\nvar assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized.js */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLE9BQU8sR0FBR0Msc0dBQWQ7O0FBRUEsSUFBSUMscUJBQXFCLEdBQUdELG1CQUFPLENBQUMsa0dBQUQsQ0FBbkM7O0FBRUEsU0FBU0UsMEJBQVQsQ0FBb0NDLElBQXBDLEVBQTBDQyxJQUExQyxFQUFnRDtFQUM5QyxJQUFJQSxJQUFJLEtBQUtMLE9BQU8sQ0FBQ0ssSUFBRCxDQUFQLEtBQWtCLFFBQWxCLElBQThCLE9BQU9BLElBQVAsS0FBZ0IsVUFBbkQsQ0FBUixFQUF3RTtJQUN0RSxPQUFPQSxJQUFQO0VBQ0QsQ0FGRCxNQUVPLElBQUlBLElBQUksS0FBSyxLQUFLLENBQWxCLEVBQXFCO0lBQzFCLE1BQU0sSUFBSUMsU0FBSixDQUFjLDBEQUFkLENBQU47RUFDRDs7RUFFRCxPQUFPSixxQkFBcUIsQ0FBQ0UsSUFBRCxDQUE1QjtBQUNEOztBQUVERyxNQUFNLENBQUNDLE9BQVAsR0FBaUJMLDBCQUFqQixFQUE2Q0kseUJBQUEsR0FBNEIsSUFBekUsRUFBK0VBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQWxIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanM/MGViOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIik7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJyZXF1aXJlIiwiYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJzZWxmIiwiY2FsbCIsIlR5cGVFcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxDQUF6QixFQUE0QkMsQ0FBNUIsRUFBK0I7RUFDN0JDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkosZUFBZSxHQUFHSyxNQUFNLENBQUNDLGNBQVAsSUFBeUIsU0FBU04sZUFBVCxDQUF5QkMsQ0FBekIsRUFBNEJDLENBQTVCLEVBQStCO0lBQ3pGRCxDQUFDLENBQUNNLFNBQUYsR0FBY0wsQ0FBZDtJQUNBLE9BQU9ELENBQVA7RUFDRCxDQUhELEVBR0dFLHlCQUFBLEdBQTRCLElBSC9CLEVBR3FDQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUh4RTtFQUlBLE9BQU9KLGVBQWUsQ0FBQ0MsQ0FBRCxFQUFJQyxDQUFKLENBQXRCO0FBQ0Q7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkosZUFBakIsRUFBa0NHLHlCQUFBLEdBQTRCLElBQTlELEVBQW9FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF2RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcz8wNTI2Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9zZXRQcm90b3R5cGVPZiIsIm8iLCJwIiwibW9kdWxlIiwiZXhwb3J0cyIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/setPrototypeOf.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles.js */ \"./node_modules/@babel/runtime/helpers/arrayWithHoles.js\");\n\nvar iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit.js */ \"./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\");\n\nvar unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ \"./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\");\n\nvar nonIterableRest = __webpack_require__(/*! ./nonIterableRest.js */ \"./node_modules/@babel/runtime/helpers/nonIterableRest.js\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLGNBQWMsR0FBR0MsbUJBQU8sQ0FBQyxvRkFBRCxDQUE1Qjs7QUFFQSxJQUFJQyxvQkFBb0IsR0FBR0QsbUJBQU8sQ0FBQyxnR0FBRCxDQUFsQzs7QUFFQSxJQUFJRSwwQkFBMEIsR0FBR0YsbUJBQU8sQ0FBQyw0R0FBRCxDQUF4Qzs7QUFFQSxJQUFJRyxlQUFlLEdBQUdILG1CQUFPLENBQUMsc0ZBQUQsQ0FBN0I7O0FBRUEsU0FBU0ksY0FBVCxDQUF3QkMsR0FBeEIsRUFBNkJDLENBQTdCLEVBQWdDO0VBQzlCLE9BQU9QLGNBQWMsQ0FBQ00sR0FBRCxDQUFkLElBQXVCSixvQkFBb0IsQ0FBQ0ksR0FBRCxFQUFNQyxDQUFOLENBQTNDLElBQXVESiwwQkFBMEIsQ0FBQ0csR0FBRCxFQUFNQyxDQUFOLENBQWpGLElBQTZGSCxlQUFlLEVBQW5IO0FBQ0Q7O0FBRURJLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkosY0FBakIsRUFBaUNHLHlCQUFBLEdBQTRCLElBQTdELEVBQW1FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF0RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzP2Y1MGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXMuanNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzXCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiKTtcblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdC5qc1wiKTtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJhcnJheVdpdGhIb2xlcyIsInJlcXVpcmUiLCJpdGVyYWJsZVRvQXJyYXlMaW1pdCIsInVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5Iiwibm9uSXRlcmFibGVSZXN0IiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJpIiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/slicedToArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(obj);\n}\n\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0I7RUFDcEI7O0VBRUEsT0FBTyxDQUFDQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJILE9BQU8sR0FBRyxjQUFjLE9BQU9JLE1BQXJCLElBQStCLFlBQVksT0FBT0EsTUFBTSxDQUFDQyxRQUF6RCxHQUFvRSxVQUFVSixHQUFWLEVBQWU7SUFDcEgsT0FBTyxPQUFPQSxHQUFkO0VBQ0QsQ0FGa0MsR0FFL0IsVUFBVUEsR0FBVixFQUFlO0lBQ2pCLE9BQU9BLEdBQUcsSUFBSSxjQUFjLE9BQU9HLE1BQTVCLElBQXNDSCxHQUFHLENBQUNLLFdBQUosS0FBb0JGLE1BQTFELElBQW9FSCxHQUFHLEtBQUtHLE1BQU0sQ0FBQ0csU0FBbkYsR0FBK0YsUUFBL0YsR0FBMEcsT0FBT04sR0FBeEg7RUFDRCxDQUpPLEVBSUxDLHlCQUFBLEdBQTRCLElBSnZCLEVBSTZCQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUpqRSxHQUkyRUgsT0FBTyxDQUFDQyxHQUFELENBSnpGO0FBS0Q7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkgsT0FBakIsRUFBMEJFLHlCQUFBLEdBQTRCLElBQXRELEVBQTREQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUEvRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanM/ZjMzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIChtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzKSwgX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIm1vZHVsZSIsImV4cG9ydHMiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/typeof.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ \"./node_modules/@babel/runtime/helpers/arrayLikeToArray.js\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxnQkFBZ0IsR0FBR0MsbUJBQU8sQ0FBQyx3RkFBRCxDQUE5Qjs7QUFFQSxTQUFTQywyQkFBVCxDQUFxQ0MsQ0FBckMsRUFBd0NDLE1BQXhDLEVBQWdEO0VBQzlDLElBQUksQ0FBQ0QsQ0FBTCxFQUFRO0VBQ1IsSUFBSSxPQUFPQSxDQUFQLEtBQWEsUUFBakIsRUFBMkIsT0FBT0gsZ0JBQWdCLENBQUNHLENBQUQsRUFBSUMsTUFBSixDQUF2QjtFQUMzQixJQUFJQyxDQUFDLEdBQUdDLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkMsUUFBakIsQ0FBMEJDLElBQTFCLENBQStCTixDQUEvQixFQUFrQ08sS0FBbEMsQ0FBd0MsQ0FBeEMsRUFBMkMsQ0FBQyxDQUE1QyxDQUFSO0VBQ0EsSUFBSUwsQ0FBQyxLQUFLLFFBQU4sSUFBa0JGLENBQUMsQ0FBQ1EsV0FBeEIsRUFBcUNOLENBQUMsR0FBR0YsQ0FBQyxDQUFDUSxXQUFGLENBQWNDLElBQWxCO0VBQ3JDLElBQUlQLENBQUMsS0FBSyxLQUFOLElBQWVBLENBQUMsS0FBSyxLQUF6QixFQUFnQyxPQUFPUSxLQUFLLENBQUNDLElBQU4sQ0FBV1gsQ0FBWCxDQUFQO0VBQ2hDLElBQUlFLENBQUMsS0FBSyxXQUFOLElBQXFCLDJDQUEyQ1UsSUFBM0MsQ0FBZ0RWLENBQWhELENBQXpCLEVBQTZFLE9BQU9MLGdCQUFnQixDQUFDRyxDQUFELEVBQUlDLE1BQUosQ0FBdkI7QUFDOUU7O0FBRURZLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQmYsMkJBQWpCLEVBQThDYyx5QkFBQSxHQUE0QixJQUExRSxFQUFnRkEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBbkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanM/ZGE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbImFycmF5TGlrZVRvQXJyYXkiLCJyZXF1aXJlIiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwibyIsIm1pbkxlbiIsIm4iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/wrapNativeSuper.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\n\nvar setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nvar isNativeFunction = __webpack_require__(/*! ./isNativeFunction.js */ \"./node_modules/@babel/runtime/helpers/isNativeFunction.js\");\n\nvar construct = __webpack_require__(/*! ./construct.js */ \"./node_modules/@babel/runtime/helpers/construct.js\");\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _wrapNativeSuper(Class);\n}\n\nmodule.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsY0FBYyxHQUFHQyxtQkFBTyxDQUFDLG9GQUFELENBQTVCOztBQUVBLElBQUlDLGNBQWMsR0FBR0QsbUJBQU8sQ0FBQyxvRkFBRCxDQUE1Qjs7QUFFQSxJQUFJRSxnQkFBZ0IsR0FBR0YsbUJBQU8sQ0FBQyx3RkFBRCxDQUE5Qjs7QUFFQSxJQUFJRyxTQUFTLEdBQUdILG1CQUFPLENBQUMsMEVBQUQsQ0FBdkI7O0FBRUEsU0FBU0ksZ0JBQVQsQ0FBMEJDLEtBQTFCLEVBQWlDO0VBQy9CLElBQUlDLE1BQU0sR0FBRyxPQUFPQyxHQUFQLEtBQWUsVUFBZixHQUE0QixJQUFJQSxHQUFKLEVBQTVCLEdBQXdDQyxTQUFyRDs7RUFFQUMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCTixnQkFBZ0IsR0FBRyxTQUFTQSxnQkFBVCxDQUEwQkMsS0FBMUIsRUFBaUM7SUFDbkUsSUFBSUEsS0FBSyxLQUFLLElBQVYsSUFBa0IsQ0FBQ0gsZ0JBQWdCLENBQUNHLEtBQUQsQ0FBdkMsRUFBZ0QsT0FBT0EsS0FBUDs7SUFFaEQsSUFBSSxPQUFPQSxLQUFQLEtBQWlCLFVBQXJCLEVBQWlDO01BQy9CLE1BQU0sSUFBSU0sU0FBSixDQUFjLG9EQUFkLENBQU47SUFDRDs7SUFFRCxJQUFJLE9BQU9MLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7TUFDakMsSUFBSUEsTUFBTSxDQUFDTSxHQUFQLENBQVdQLEtBQVgsQ0FBSixFQUF1QixPQUFPQyxNQUFNLENBQUNPLEdBQVAsQ0FBV1IsS0FBWCxDQUFQOztNQUV2QkMsTUFBTSxDQUFDUSxHQUFQLENBQVdULEtBQVgsRUFBa0JVLE9BQWxCO0lBQ0Q7O0lBRUQsU0FBU0EsT0FBVCxHQUFtQjtNQUNqQixPQUFPWixTQUFTLENBQUNFLEtBQUQsRUFBUVcsU0FBUixFQUFtQmpCLGNBQWMsQ0FBQyxJQUFELENBQWQsQ0FBcUJrQixXQUF4QyxDQUFoQjtJQUNEOztJQUVERixPQUFPLENBQUNHLFNBQVIsR0FBb0JDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjZixLQUFLLENBQUNhLFNBQXBCLEVBQStCO01BQ2pERCxXQUFXLEVBQUU7UUFDWEksS0FBSyxFQUFFTixPQURJO1FBRVhPLFVBQVUsRUFBRSxLQUZEO1FBR1hDLFFBQVEsRUFBRSxJQUhDO1FBSVhDLFlBQVksRUFBRTtNQUpIO0lBRG9DLENBQS9CLENBQXBCO0lBUUEsT0FBT3ZCLGNBQWMsQ0FBQ2MsT0FBRCxFQUFVVixLQUFWLENBQXJCO0VBQ0QsQ0ExQkQsRUEwQkdJLHlCQUFBLEdBQTRCLElBMUIvQixFQTBCcUNBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BMUJ4RTtFQTJCQSxPQUFPTixnQkFBZ0IsQ0FBQ0MsS0FBRCxDQUF2QjtBQUNEOztBQUVESSxNQUFNLENBQUNDLE9BQVAsR0FBaUJOLGdCQUFqQixFQUFtQ0sseUJBQUEsR0FBNEIsSUFBL0QsRUFBcUVBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQXhHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlci5qcz9mNTIxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mLmpzXCIpO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcblxudmFyIGlzTmF0aXZlRnVuY3Rpb24gPSByZXF1aXJlKFwiLi9pc05hdGl2ZUZ1bmN0aW9uLmpzXCIpO1xuXG52YXIgY29uc3RydWN0ID0gcmVxdWlyZShcIi4vY29uc3RydWN0LmpzXCIpO1xuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcblxuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF93cmFwTmF0aXZlU3VwZXIsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiZ2V0UHJvdG90eXBlT2YiLCJyZXF1aXJlIiwic2V0UHJvdG90eXBlT2YiLCJpc05hdGl2ZUZ1bmN0aW9uIiwiY29uc3RydWN0IiwiX3dyYXBOYXRpdmVTdXBlciIsIkNsYXNzIiwiX2NhY2hlIiwiTWFwIiwidW5kZWZpbmVkIiwibW9kdWxlIiwiZXhwb3J0cyIsIlR5cGVFcnJvciIsImhhcyIsImdldCIsInNldCIsIldyYXBwZXIiLCJhcmd1bWVudHMiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsInZhbHVlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/wrapNativeSuper.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUFBLGdIQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcz84MTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/regenerator/index.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/client/_utils.js":
/*!*************************************************!*\
  !*** ./node_modules/next-auth/client/_utils.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BroadcastChannel = BroadcastChannel;\nexports.apiBaseUrl = apiBaseUrl;\nexports.fetchData = fetchData;\nexports.now = now;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction fetchData(_x, _x2, _x3) {\n  return _fetchData.apply(this, arguments);\n}\n\nfunction _fetchData() {\n  _fetchData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(path, __NEXTAUTH, logger) {\n    var _ref,\n        ctx,\n        _ref$req,\n        req,\n        url,\n        options,\n        res,\n        data,\n        _args = arguments;\n\n    return _regenerator.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref = _args.length > 3 && _args[3] !== undefined ? _args[3] : {}, ctx = _ref.ctx, _ref$req = _ref.req, req = _ref$req === void 0 ? ctx === null || ctx === void 0 ? void 0 : ctx.req : _ref$req;\n            url = \"\".concat(apiBaseUrl(__NEXTAUTH), \"/\").concat(path);\n            _context.prev = 2;\n            options = req !== null && req !== void 0 && req.headers.cookie ? {\n              headers: {\n                cookie: req.headers.cookie\n              }\n            } : {};\n            _context.next = 6;\n            return fetch(url, options);\n\n          case 6:\n            res = _context.sent;\n            _context.next = 9;\n            return res.json();\n\n          case 9:\n            data = _context.sent;\n\n            if (res.ok) {\n              _context.next = 12;\n              break;\n            }\n\n            throw data;\n\n          case 12:\n            return _context.abrupt(\"return\", Object.keys(data).length > 0 ? data : null);\n\n          case 15:\n            _context.prev = 15;\n            _context.t0 = _context[\"catch\"](2);\n            logger.error(\"CLIENT_FETCH_ERROR\", {\n              error: _context.t0,\n              url: url\n            });\n            return _context.abrupt(\"return\", null);\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[2, 15]]);\n  }));\n  return _fetchData.apply(this, arguments);\n}\n\nfunction apiBaseUrl(__NEXTAUTH) {\n  if (typeof window === \"undefined\") {\n    return \"\".concat(__NEXTAUTH.baseUrlServer).concat(__NEXTAUTH.basePathServer);\n  }\n\n  return __NEXTAUTH.basePath;\n}\n\nfunction now() {\n  return Math.floor(Date.now() / 1000);\n}\n\nfunction BroadcastChannel() {\n  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"nextauth.message\";\n  return {\n    receive: function receive(onReceive) {\n      var handler = function handler(event) {\n        var _event$newValue;\n\n        if (event.key !== name) return;\n        var message = JSON.parse((_event$newValue = event.newValue) !== null && _event$newValue !== void 0 ? _event$newValue : \"{}\");\n        if ((message === null || message === void 0 ? void 0 : message.event) !== \"session\" || !(message !== null && message !== void 0 && message.data)) return;\n        onReceive(message);\n      };\n\n      window.addEventListener(\"storage\", handler);\n      return function () {\n        return window.removeEventListener(\"storage\", handler);\n      };\n    },\n    post: function post(message) {\n      if (typeof window === \"undefined\") return;\n      localStorage.setItem(name, JSON.stringify(_objectSpread(_objectSpread({}, message), {}, {\n        timestamp: now()\n      })));\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2NsaWVudC9fdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSUEsc0JBQXNCLEdBQUdDLG1CQUFPLENBQUMsb0hBQUQsQ0FBcEM7O0FBRUFDLDhDQUE2QztFQUMzQ0csS0FBSyxFQUFFO0FBRG9DLENBQTdDO0FBR0FELHdCQUFBLEdBQTJCRSxnQkFBM0I7QUFDQUYsa0JBQUEsR0FBcUJHLFVBQXJCO0FBQ0FILGlCQUFBLEdBQW9CSSxTQUFwQjtBQUNBSixXQUFBLEdBQWNLLEdBQWQ7O0FBRUEsSUFBSUMsWUFBWSxHQUFHVixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxzRkFBRCxDQUFSLENBQXpDOztBQUVBLElBQUlVLGdCQUFnQixHQUFHWCxzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxzR0FBRCxDQUFSLENBQTdDOztBQUVBLElBQUlXLGtCQUFrQixHQUFHWixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQywwR0FBRCxDQUFSLENBQS9DOztBQUVBLFNBQVNZLE9BQVQsQ0FBaUJDLE1BQWpCLEVBQXlCQyxjQUF6QixFQUF5QztFQUFFLElBQUlDLElBQUksR0FBR2QsTUFBTSxDQUFDYyxJQUFQLENBQVlGLE1BQVosQ0FBWDs7RUFBZ0MsSUFBSVosTUFBTSxDQUFDZSxxQkFBWCxFQUFrQztJQUFFLElBQUlDLE9BQU8sR0FBR2hCLE1BQU0sQ0FBQ2UscUJBQVAsQ0FBNkJILE1BQTdCLENBQWQ7SUFBb0RDLGNBQWMsS0FBS0csT0FBTyxHQUFHQSxPQUFPLENBQUNDLE1BQVIsQ0FBZSxVQUFVQyxHQUFWLEVBQWU7TUFBRSxPQUFPbEIsTUFBTSxDQUFDbUIsd0JBQVAsQ0FBZ0NQLE1BQWhDLEVBQXdDTSxHQUF4QyxFQUE2Q0UsVUFBcEQ7SUFBaUUsQ0FBakcsQ0FBZixDQUFkLEVBQWtJTixJQUFJLENBQUNPLElBQUwsQ0FBVUMsS0FBVixDQUFnQlIsSUFBaEIsRUFBc0JFLE9BQXRCLENBQWxJO0VBQW1LOztFQUFD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QUFTLEVBQUVyRixHQUFHO01BRHdFLENBQWpDLENBQTVCLENBQTNCO0lBR0Q7RUFyQkksQ0FBUDtBQXVCRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2NsaWVudC9fdXRpbHMuanM/MGRhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkJyb2FkY2FzdENoYW5uZWwgPSBCcm9hZGNhc3RDaGFubmVsO1xuZXhwb3J0cy5hcGlCYXNlVXJsID0gYXBpQmFzZVVybDtcbmV4cG9ydHMuZmV0Y2hEYXRhID0gZmV0Y2hEYXRhO1xuZXhwb3J0cy5ub3cgPSBub3c7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGZldGNoRGF0YShfeCwgX3gyLCBfeDMpIHtcbiAgcmV0dXJuIF9mZXRjaERhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2ZldGNoRGF0YSgpIHtcbiAgX2ZldGNoRGF0YSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKHBhdGgsIF9fTkVYVEFVVEgsIGxvZ2dlcikge1xuICAgIHZhciBfcmVmLFxuICAgICAgICBjdHgsXG4gICAgICAgIF9yZWYkcmVxLFxuICAgICAgICByZXEsXG4gICAgICAgIHVybCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgcmVzLFxuICAgICAgICBkYXRhLFxuICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX3JlZiA9IF9hcmdzLmxlbmd0aCA+IDMgJiYgX2FyZ3NbM10gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzNdIDoge30sIGN0eCA9IF9yZWYuY3R4LCBfcmVmJHJlcSA9IF9yZWYucmVxLCByZXEgPSBfcmVmJHJlcSA9PT0gdm9pZCAwID8gY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnJlcSA6IF9yZWYkcmVxO1xuICAgICAgICAgICAgdXJsID0gXCJcIi5jb25jYXQoYXBpQmFzZVVybChfX05FWFRBVVRIKSwgXCIvXCIpLmNvbmNhdChwYXRoKTtcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHJlcSAhPT0gbnVsbCAmJiByZXEgIT09IHZvaWQgMCAmJiByZXEuaGVhZGVycy5jb29raWUgPyB7XG4gICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBjb29raWU6IHJlcS5oZWFkZXJzLmNvb2tpZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IDoge307XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBkYXRhID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBkYXRhO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgT2JqZWN0LmtleXMoZGF0YSkubGVuZ3RoID4gMCA/IGRhdGEgOiBudWxsKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTU7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMik7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJDTElFTlRfRkVUQ0hfRVJST1JcIiwge1xuICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQudDAsXG4gICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzIsIDE1XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZmV0Y2hEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGFwaUJhc2VVcmwoX19ORVhUQVVUSCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChfX05FWFRBVVRILmJhc2VVcmxTZXJ2ZXIpLmNvbmNhdChfX05FWFRBVVRILmJhc2VQYXRoU2VydmVyKTtcbiAgfVxuXG4gIHJldHVybiBfX05FWFRBVVRILmJhc2VQYXRoO1xufVxuXG5mdW5jdGlvbiBub3coKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbn1cblxuZnVuY3Rpb24gQnJvYWRjYXN0Q2hhbm5lbCgpIHtcbiAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwibmV4dGF1dGgubWVzc2FnZVwiO1xuICByZXR1cm4ge1xuICAgIHJlY2VpdmU6IGZ1bmN0aW9uIHJlY2VpdmUob25SZWNlaXZlKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9ldmVudCRuZXdWYWx1ZTtcblxuICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSBuYW1lKSByZXR1cm47XG4gICAgICAgIHZhciBtZXNzYWdlID0gSlNPTi5wYXJzZSgoX2V2ZW50JG5ld1ZhbHVlID0gZXZlbnQubmV3VmFsdWUpICE9PSBudWxsICYmIF9ldmVudCRuZXdWYWx1ZSAhPT0gdm9pZCAwID8gX2V2ZW50JG5ld1ZhbHVlIDogXCJ7fVwiKTtcbiAgICAgICAgaWYgKChtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2UuZXZlbnQpICE9PSBcInNlc3Npb25cIiB8fCAhKG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwICYmIG1lc3NhZ2UuZGF0YSkpIHJldHVybjtcbiAgICAgICAgb25SZWNlaXZlKG1lc3NhZ2UpO1xuICAgICAgfTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzdG9yYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwic3RvcmFnZVwiLCBoYW5kbGVyKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBwb3N0OiBmdW5jdGlvbiBwb3N0KG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShuYW1lLCBKU09OLnN0cmluZ2lmeShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG1lc3NhZ2UpLCB7fSwge1xuICAgICAgICB0aW1lc3RhbXA6IG5vdygpXG4gICAgICB9KSkpO1xuICAgIH1cbiAgfTtcbn0iXSwibmFtZXMiOlsiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJyb2FkY2FzdENoYW5uZWwiLCJhcGlCYXNlVXJsIiwiZmV0Y2hEYXRhIiwibm93IiwiX3JlZ2VuZXJhdG9yIiwiX2RlZmluZVByb3BlcnR5MiIsIl9hc3luY1RvR2VuZXJhdG9yMiIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwiZm9yRWFjaCIsImtleSIsImRlZmF1bHQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl94IiwiX3gyIiwiX3gzIiwiX2ZldGNoRGF0YSIsIm1hcmsiLCJfY2FsbGVlIiwicGF0aCIsIl9fTkVYVEFVVEgiLCJsb2dnZXIiLCJfcmVmIiwiY3R4IiwiX3JlZiRyZXEiLCJyZXEiLCJ1cmwiLCJvcHRpb25zIiwicmVzIiwiZGF0YSIsIl9hcmdzIiwid3JhcCIsIl9jYWxsZWUkIiwiX2NvbnRleHQiLCJwcmV2IiwibmV4dCIsInVuZGVmaW5lZCIsImNvbmNhdCIsImhlYWRlcnMiLCJjb29raWUiLCJmZXRjaCIsInNlbnQiLCJqc29uIiwib2siLCJhYnJ1cHQiLCJ0MCIsImVycm9yIiwic3RvcCIsIndpbmRvdyIsImJhc2VVcmxTZXJ2ZXIiLCJiYXNlUGF0aFNlcnZlciIsImJhc2VQYXRoIiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsIm5hbWUiLCJyZWNlaXZlIiwib25SZWNlaXZlIiwiaGFuZGxlciIsImV2ZW50IiwiX2V2ZW50JG5ld1ZhbHVlIiwibWVzc2FnZSIsIkpTT04iLCJwYXJzZSIsIm5ld1ZhbHVlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwb3N0IiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInRpbWVzdGFtcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next-auth/client/_utils.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/core/errors.js":
/*!***********************************************!*\
  !*** ./node_modules/next-auth/core/errors.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.UnsupportedStrategy = exports.UnknownError = exports.OAuthCallbackError = exports.MissingSecret = exports.MissingAuthorize = exports.MissingAdapter = exports.MissingAPIRoute = exports.InvalidCallbackUrl = exports.AccountNotLinkedError = void 0;\nexports.adapterErrorHandler = adapterErrorHandler;\nexports.capitalize = capitalize;\nexports.eventsErrorHandler = eventsErrorHandler;\nexports.upperSnake = upperSnake;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ \"./node_modules/@babel/runtime/helpers/wrapNativeSuper.js\"));\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar UnknownError = function (_Error) {\n  (0, _inherits2.default)(UnknownError, _Error);\n\n  var _super = _createSuper(UnknownError);\n\n  function UnknownError(error) {\n    var _message;\n\n    var _this;\n\n    (0, _classCallCheck2.default)(this, UnknownError);\n    _this = _super.call(this, (_message = error === null || error === void 0 ? void 0 : error.message) !== null && _message !== void 0 ? _message : error);\n    _this.name = \"UnknownError\";\n    _this.code = error.code;\n\n    if (error instanceof Error) {\n      _this.stack = error.stack;\n    }\n\n    return _this;\n  }\n\n  (0, _createClass2.default)(UnknownError, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        name: this.name,\n        message: this.message,\n        stack: this.stack\n      };\n    }\n  }]);\n  return UnknownError;\n}((0, _wrapNativeSuper2.default)(Error));\n\nexports.UnknownError = UnknownError;\n\nvar OAuthCallbackError = function (_UnknownError) {\n  (0, _inherits2.default)(OAuthCallbackError, _UnknownError);\n\n  var _super2 = _createSuper(OAuthCallbackError);\n\n  function OAuthCallbackError() {\n    var _this2;\n\n    (0, _classCallCheck2.default)(this, OAuthCallbackError);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this2 = _super2.call.apply(_super2, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), \"name\", \"OAuthCallbackError\");\n    return _this2;\n  }\n\n  return (0, _createClass2.default)(OAuthCallbackError);\n}(UnknownError);\n\nexports.OAuthCallbackError = OAuthCallbackError;\n\nvar AccountNotLinkedError = function (_UnknownError2) {\n  (0, _inherits2.default)(AccountNotLinkedError, _UnknownError2);\n\n  var _super3 = _createSuper(AccountNotLinkedError);\n\n  function AccountNotLinkedError() {\n    var _this3;\n\n    (0, _classCallCheck2.default)(this, AccountNotLinkedError);\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    _this3 = _super3.call.apply(_super3, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this3), \"name\", \"AccountNotLinkedError\");\n    return _this3;\n  }\n\n  return (0, _createClass2.default)(AccountNotLinkedError);\n}(UnknownError);\n\nexports.AccountNotLinkedError = AccountNotLinkedError;\n\nvar MissingAPIRoute = function (_UnknownError3) {\n  (0, _inherits2.default)(MissingAPIRoute, _UnknownError3);\n\n  var _super4 = _createSuper(MissingAPIRoute);\n\n  function MissingAPIRoute() {\n    var _this4;\n\n    (0, _classCallCheck2.default)(this, MissingAPIRoute);\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    _this4 = _super4.call.apply(_super4, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), \"name\", \"MissingAPIRouteError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), \"code\", \"MISSING_NEXTAUTH_API_ROUTE_ERROR\");\n    return _this4;\n  }\n\n  return (0, _createClass2.default)(MissingAPIRoute);\n}(UnknownError);\n\nexports.MissingAPIRoute = MissingAPIRoute;\n\nvar MissingSecret = function (_UnknownError4) {\n  (0, _inherits2.default)(MissingSecret, _UnknownError4);\n\n  var _super5 = _createSuper(MissingSecret);\n\n  function MissingSecret() {\n    var _this5;\n\n    (0, _classCallCheck2.default)(this, MissingSecret);\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    _this5 = _super5.call.apply(_super5, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), \"name\", \"MissingSecretError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), \"code\", \"NO_SECRET\");\n    return _this5;\n  }\n\n  return (0, _createClass2.default)(MissingSecret);\n}(UnknownError);\n\nexports.MissingSecret = MissingSecret;\n\nvar MissingAuthorize = function (_UnknownError5) {\n  (0, _inherits2.default)(MissingAuthorize, _UnknownError5);\n\n  var _super6 = _createSuper(MissingAuthorize);\n\n  function MissingAuthorize() {\n    var _this6;\n\n    (0, _classCallCheck2.default)(this, MissingAuthorize);\n\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    _this6 = _super6.call.apply(_super6, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), \"name\", \"MissingAuthorizeError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), \"code\", \"CALLBACK_CREDENTIALS_HANDLER_ERROR\");\n    return _this6;\n  }\n\n  return (0, _createClass2.default)(MissingAuthorize);\n}(UnknownError);\n\nexports.MissingAuthorize = MissingAuthorize;\n\nvar MissingAdapter = function (_UnknownError6) {\n  (0, _inherits2.default)(MissingAdapter, _UnknownError6);\n\n  var _super7 = _createSuper(MissingAdapter);\n\n  function MissingAdapter() {\n    var _this7;\n\n    (0, _classCallCheck2.default)(this, MissingAdapter);\n\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    _this7 = _super7.call.apply(_super7, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), \"name\", \"MissingAdapterError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), \"code\", \"EMAIL_REQUIRES_ADAPTER_ERROR\");\n    return _this7;\n  }\n\n  return (0, _createClass2.default)(MissingAdapter);\n}(UnknownError);\n\nexports.MissingAdapter = MissingAdapter;\n\nvar UnsupportedStrategy = function (_UnknownError7) {\n  (0, _inherits2.default)(UnsupportedStrategy, _UnknownError7);\n\n  var _super8 = _createSuper(UnsupportedStrategy);\n\n  function UnsupportedStrategy() {\n    var _this8;\n\n    (0, _classCallCheck2.default)(this, UnsupportedStrategy);\n\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    _this8 = _super8.call.apply(_super8, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this8), \"name\", \"UnsupportedStrategyError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this8), \"code\", \"CALLBACK_CREDENTIALS_JWT_ERROR\");\n    return _this8;\n  }\n\n  return (0, _createClass2.default)(UnsupportedStrategy);\n}(UnknownError);\n\nexports.UnsupportedStrategy = UnsupportedStrategy;\n\nvar InvalidCallbackUrl = function (_UnknownError8) {\n  (0, _inherits2.default)(InvalidCallbackUrl, _UnknownError8);\n\n  var _super9 = _createSuper(InvalidCallbackUrl);\n\n  function InvalidCallbackUrl() {\n    var _this9;\n\n    (0, _classCallCheck2.default)(this, InvalidCallbackUrl);\n\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n\n    _this9 = _super9.call.apply(_super9, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this9), \"name\", \"InvalidCallbackUrl\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this9), \"code\", \"INVALID_CALLBACK_URL_ERROR\");\n    return _this9;\n  }\n\n  return (0, _createClass2.default)(InvalidCallbackUrl);\n}(UnknownError);\n\nexports.InvalidCallbackUrl = InvalidCallbackUrl;\n\nfunction upperSnake(s) {\n  return s.replace(/([A-Z])/g, \"_$1\").toUpperCase();\n}\n\nfunction capitalize(s) {\n  return \"\".concat(s[0].toUpperCase()).concat(s.slice(1));\n}\n\nfunction eventsErrorHandler(methods, logger) {\n  return Object.keys(methods).reduce(function (acc, name) {\n    acc[name] = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {\n      var method,\n          _args = arguments;\n      return _regenerator.default.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              method = methods[name];\n              _context.next = 4;\n              return method.apply(void 0, _args);\n\n            case 4:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 7:\n              _context.prev = 7;\n              _context.t0 = _context[\"catch\"](0);\n              logger.error(\"\".concat(upperSnake(name), \"_EVENT_ERROR\"), _context.t0);\n\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 7]]);\n    }));\n    return acc;\n  }, {});\n}\n\nfunction adapterErrorHandler(adapter, logger) {\n  if (!adapter) return;\n  return Object.keys(adapter).reduce(function (acc, name) {\n    acc[name] = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {\n      var _len9,\n          args,\n          _key9,\n          method,\n          e,\n          _args2 = arguments;\n\n      return _regenerator.default.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n\n              for (_len9 = _args2.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n                args[_key9] = _args2[_key9];\n              }\n\n              logger.debug(\"adapter_\".concat(name), {\n                args: args\n              });\n              method = adapter[name];\n              _context2.next = 6;\n              return method.apply(void 0, args);\n\n            case 6:\n              return _context2.abrupt(\"return\", _context2.sent);\n\n            case 9:\n              _context2.prev = 9;\n              _context2.t0 = _context2[\"catch\"](0);\n              logger.error(\"adapter_error_\".concat(name), _context2.t0);\n              e = new UnknownError(_context2.t0);\n              e.name = \"\".concat(capitalize(name), \"Error\");\n              throw e;\n\n            case 15:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[0, 9]]);\n    }));\n    return acc;\n  }, {});\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2NvcmUvZXJyb3JzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUlBLHNCQUFzQixHQUFHQyxtQkFBTyxDQUFDLG9IQUFELENBQXBDOztBQUVBQyw4Q0FBNkM7RUFDM0NHLEtBQUssRUFBRTtBQURvQyxDQUE3QztBQUdBRCwyQkFBQSxHQUE4QkEsb0JBQUEsR0FBdUJBLDBCQUFBLEdBQTZCQSxxQkFBQSxHQUF3QkEsd0JBQUEsR0FBMkJBLHNCQUFBLEdBQXlCQSx1QkFBQSxHQUEwQkEsMEJBQUEsR0FBNkJBLDZCQUFBLEdBQWdDLEtBQUssQ0FBMVA7QUFDQUEsMkJBQUEsR0FBOEJXLG1CQUE5QjtBQUNBWCxrQkFBQSxHQUFxQlksVUFBckI7QUFDQVosMEJBQUEsR0FBNkJhLGtCQUE3QjtBQUNBYixrQkFBQSxHQUFxQmMsVUFBckI7O0FBRUEsSUFBSUMsWUFBWSxHQUFHbkIsc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsc0ZBQUQsQ0FBUixDQUF6Qzs7QUFFQSxJQUFJbUIsa0JBQWtCLEdBQUdwQixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQywwR0FBRCxDQUFSLENBQS9DOztBQUVBLElBQUlvQix1QkFBdUIsR0FBR3JCLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLG9IQUFELENBQVIsQ0FBcEQ7O0FBRUEsSUFBSXFCLGdCQUFnQixHQUFHdEIsc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsc0dBQUQsQ0FBUixDQUE3Qzs7QUFFQSxJQUFJc0IsZ0JBQWdCLEdBQUd2QixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxzR0FBRCxDQUFSLENBQTdDOztBQUVBLElBQUl1QixhQUFhLEdBQUd4QixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxnR0FBRCxDQUFSLENBQTFDOztBQUVBLElBQUl3QixVQUFVLEdBQUd6QixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQywwRkFBRCxDQUFSLENBQXZDOztBQUVBLElBQUl5QiwyQkFBMkIsR0FB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QUEzQixDQUFKO2NBQ0E3RSxDQUFDLENBQUNPLElBQUYsR0FBUyxHQUFHYyxNQUFILENBQVV0RCxVQUFVLENBQUN3QyxJQUFELENBQXBCLEVBQTRCLE9BQTVCLENBQVQ7Y0FDQSxNQUFNUCxDQUFOOztZQUVGLEtBQUssRUFBTDtZQUNBLEtBQUssS0FBTDtjQUNFLE9BQU9xRixTQUFTLENBQUNQLElBQVYsRUFBUDtVQTVCSjtRQThCRDtNQUNGLENBakNNLEVBaUNKRSxRQWpDSSxFQWlDTSxJQWpDTixFQWlDWSxDQUFDLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBRCxDQWpDWixDQUFQO0lBa0NELENBMUMyQyxDQUFoQyxDQUFaO0lBMkNBLE9BQU9mLEdBQVA7RUFDRCxDQTdDTSxFQTZDSixFQTdDSSxDQUFQO0FBOENEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvY29yZS9lcnJvcnMuanM/ZGRjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlVuc3VwcG9ydGVkU3RyYXRlZ3kgPSBleHBvcnRzLlVua25vd25FcnJvciA9IGV4cG9ydHMuT0F1dGhDYWxsYmFja0Vycm9yID0gZXhwb3J0cy5NaXNzaW5nU2VjcmV0ID0gZXhwb3J0cy5NaXNzaW5nQXV0aG9yaXplID0gZXhwb3J0cy5NaXNzaW5nQWRhcHRlciA9IGV4cG9ydHMuTWlzc2luZ0FQSVJvdXRlID0gZXhwb3J0cy5JbnZhbGlkQ2FsbGJhY2tVcmwgPSBleHBvcnRzLkFjY291bnROb3RMaW5rZWRFcnJvciA9IHZvaWQgMDtcbmV4cG9ydHMuYWRhcHRlckVycm9ySGFuZGxlciA9IGFkYXB0ZXJFcnJvckhhbmRsZXI7XG5leHBvcnRzLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuZXhwb3J0cy5ldmVudHNFcnJvckhhbmRsZXIgPSBldmVudHNFcnJvckhhbmRsZXI7XG5leHBvcnRzLnVwcGVyU25ha2UgPSB1cHBlclNuYWtlO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF93cmFwTmF0aXZlU3VwZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXJcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFVua25vd25FcnJvciA9IGZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVW5rbm93bkVycm9yLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVW5rbm93bkVycm9yKTtcblxuICBmdW5jdGlvbiBVbmtub3duRXJyb3IoZXJyb3IpIHtcbiAgICB2YXIgX21lc3NhZ2U7XG5cbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBVbmtub3duRXJyb3IpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgKF9tZXNzYWdlID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpICE9PSBudWxsICYmIF9tZXNzYWdlICE9PSB2b2lkIDAgPyBfbWVzc2FnZSA6IGVycm9yKTtcbiAgICBfdGhpcy5uYW1lID0gXCJVbmtub3duRXJyb3JcIjtcbiAgICBfdGhpcy5jb2RlID0gZXJyb3IuY29kZTtcblxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBfdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFVua25vd25FcnJvciwgW3tcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICBzdGFjazogdGhpcy5zdGFja1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFVua25vd25FcnJvcjtcbn0oKDAsIF93cmFwTmF0aXZlU3VwZXIyLmRlZmF1bHQpKEVycm9yKSk7XG5cbmV4cG9ydHMuVW5rbm93bkVycm9yID0gVW5rbm93bkVycm9yO1xuXG52YXIgT0F1dGhDYWxsYmFja0Vycm9yID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3IpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoT0F1dGhDYWxsYmFja0Vycm9yLCBfVW5rbm93bkVycm9yKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihPQXV0aENhbGxiYWNrRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIE9BdXRoQ2FsbGJhY2tFcnJvcigpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgT0F1dGhDYWxsYmFja0Vycm9yKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpczIgPSBfc3VwZXIyLmNhbGwuYXBwbHkoX3N1cGVyMiwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzMiksIFwibmFtZVwiLCBcIk9BdXRoQ2FsbGJhY2tFcnJvclwiKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgcmV0dXJuICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKE9BdXRoQ2FsbGJhY2tFcnJvcik7XG59KFVua25vd25FcnJvcik7XG5cbmV4cG9ydHMuT0F1dGhDYWxsYmFja0Vycm9yID0gT0F1dGhDYWxsYmFja0Vycm9yO1xuXG52YXIgQWNjb3VudE5vdExpbmtlZEVycm9yID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3IyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEFjY291bnROb3RMaW5rZWRFcnJvciwgX1Vua25vd25FcnJvcjIpO1xuXG4gIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKEFjY291bnROb3RMaW5rZWRFcnJvcik7XG5cbiAgZnVuY3Rpb24gQWNjb3VudE5vdExpbmtlZEVycm9yKCkge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBBY2NvdW50Tm90TGlua2VkRXJyb3IpO1xuXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgX3RoaXMzID0gX3N1cGVyMy5jYWxsLmFwcGx5KF9zdXBlcjMsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczMpLCBcIm5hbWVcIiwgXCJBY2NvdW50Tm90TGlua2VkRXJyb3JcIik7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShBY2NvdW50Tm90TGlua2VkRXJyb3IpO1xufShVbmtub3duRXJyb3IpO1xuXG5leHBvcnRzLkFjY291bnROb3RMaW5rZWRFcnJvciA9IEFjY291bnROb3RMaW5rZWRFcnJvcjtcblxudmFyIE1pc3NpbmdBUElSb3V0ZSA9IGZ1bmN0aW9uIChfVW5rbm93bkVycm9yMykge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShNaXNzaW5nQVBJUm91dGUsIF9Vbmtub3duRXJyb3IzKTtcblxuICB2YXIgX3N1cGVyNCA9IF9jcmVhdGVTdXBlcihNaXNzaW5nQVBJUm91dGUpO1xuXG4gIGZ1bmN0aW9uIE1pc3NpbmdBUElSb3V0ZSgpIHtcbiAgICB2YXIgX3RoaXM0O1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgTWlzc2luZ0FQSVJvdXRlKTtcblxuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cblxuICAgIF90aGlzNCA9IF9zdXBlcjQuY2FsbC5hcHBseShfc3VwZXI0LCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM0KSwgXCJuYW1lXCIsIFwiTWlzc2luZ0FQSVJvdXRlRXJyb3JcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNCksIFwiY29kZVwiLCBcIk1JU1NJTkdfTkVYVEFVVEhfQVBJX1JPVVRFX0VSUk9SXCIpO1xuICAgIHJldHVybiBfdGhpczQ7XG4gIH1cblxuICByZXR1cm4gKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoTWlzc2luZ0FQSVJvdXRlKTtcbn0oVW5rbm93bkVycm9yKTtcblxuZXhwb3J0cy5NaXNzaW5nQVBJUm91dGUgPSBNaXNzaW5nQVBJUm91dGU7XG5cbnZhciBNaXNzaW5nU2VjcmV0ID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3I0KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKE1pc3NpbmdTZWNyZXQsIF9Vbmtub3duRXJyb3I0KTtcblxuICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihNaXNzaW5nU2VjcmV0KTtcblxuICBmdW5jdGlvbiBNaXNzaW5nU2VjcmV0KCkge1xuICAgIHZhciBfdGhpczU7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBNaXNzaW5nU2VjcmV0KTtcblxuICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgIH1cblxuICAgIF90aGlzNSA9IF9zdXBlcjUuY2FsbC5hcHBseShfc3VwZXI1LCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM1KSwgXCJuYW1lXCIsIFwiTWlzc2luZ1NlY3JldEVycm9yXCIpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczUpLCBcImNvZGVcIiwgXCJOT19TRUNSRVRcIik7XG4gICAgcmV0dXJuIF90aGlzNTtcbiAgfVxuXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShNaXNzaW5nU2VjcmV0KTtcbn0oVW5rbm93bkVycm9yKTtcblxuZXhwb3J0cy5NaXNzaW5nU2VjcmV0ID0gTWlzc2luZ1NlY3JldDtcblxudmFyIE1pc3NpbmdBdXRob3JpemUgPSBmdW5jdGlvbiAoX1Vua25vd25FcnJvcjUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoTWlzc2luZ0F1dGhvcml6ZSwgX1Vua25vd25FcnJvcjUpO1xuXG4gIHZhciBfc3VwZXI2ID0gX2NyZWF0ZVN1cGVyKE1pc3NpbmdBdXRob3JpemUpO1xuXG4gIGZ1bmN0aW9uIE1pc3NpbmdBdXRob3JpemUoKSB7XG4gICAgdmFyIF90aGlzNjtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIE1pc3NpbmdBdXRob3JpemUpO1xuXG4gICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgfVxuXG4gICAgX3RoaXM2ID0gX3N1cGVyNi5jYWxsLmFwcGx5KF9zdXBlcjYsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczYpLCBcIm5hbWVcIiwgXCJNaXNzaW5nQXV0aG9yaXplRXJyb3JcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNiksIFwiY29kZVwiLCBcIkNBTExCQUNLX0NSRURFTlRJQUxTX0hBTkRMRVJfRVJST1JcIik7XG4gICAgcmV0dXJuIF90aGlzNjtcbiAgfVxuXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShNaXNzaW5nQXV0aG9yaXplKTtcbn0oVW5rbm93bkVycm9yKTtcblxuZXhwb3J0cy5NaXNzaW5nQXV0aG9yaXplID0gTWlzc2luZ0F1dGhvcml6ZTtcblxudmFyIE1pc3NpbmdBZGFwdGVyID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3I2KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKE1pc3NpbmdBZGFwdGVyLCBfVW5rbm93bkVycm9yNik7XG5cbiAgdmFyIF9zdXBlcjcgPSBfY3JlYXRlU3VwZXIoTWlzc2luZ0FkYXB0ZXIpO1xuXG4gIGZ1bmN0aW9uIE1pc3NpbmdBZGFwdGVyKCkge1xuICAgIHZhciBfdGhpczc7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBNaXNzaW5nQWRhcHRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICAgIGFyZ3NbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgICB9XG5cbiAgICBfdGhpczcgPSBfc3VwZXI3LmNhbGwuYXBwbHkoX3N1cGVyNywgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNyksIFwibmFtZVwiLCBcIk1pc3NpbmdBZGFwdGVyRXJyb3JcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNyksIFwiY29kZVwiLCBcIkVNQUlMX1JFUVVJUkVTX0FEQVBURVJfRVJST1JcIik7XG4gICAgcmV0dXJuIF90aGlzNztcbiAgfVxuXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShNaXNzaW5nQWRhcHRlcik7XG59KFVua25vd25FcnJvcik7XG5cbmV4cG9ydHMuTWlzc2luZ0FkYXB0ZXIgPSBNaXNzaW5nQWRhcHRlcjtcblxudmFyIFVuc3VwcG9ydGVkU3RyYXRlZ3kgPSBmdW5jdGlvbiAoX1Vua25vd25FcnJvcjcpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVW5zdXBwb3J0ZWRTdHJhdGVneSwgX1Vua25vd25FcnJvcjcpO1xuXG4gIHZhciBfc3VwZXI4ID0gX2NyZWF0ZVN1cGVyKFVuc3VwcG9ydGVkU3RyYXRlZ3kpO1xuXG4gIGZ1bmN0aW9uIFVuc3VwcG9ydGVkU3RyYXRlZ3koKSB7XG4gICAgdmFyIF90aGlzODtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFVuc3VwcG9ydGVkU3RyYXRlZ3kpO1xuXG4gICAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43KSwgX2tleTcgPSAwOyBfa2V5NyA8IF9sZW43OyBfa2V5NysrKSB7XG4gICAgICBhcmdzW19rZXk3XSA9IGFyZ3VtZW50c1tfa2V5N107XG4gICAgfVxuXG4gICAgX3RoaXM4ID0gX3N1cGVyOC5jYWxsLmFwcGx5KF9zdXBlcjgsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczgpLCBcIm5hbWVcIiwgXCJVbnN1cHBvcnRlZFN0cmF0ZWd5RXJyb3JcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzOCksIFwiY29kZVwiLCBcIkNBTExCQUNLX0NSRURFTlRJQUxTX0pXVF9FUlJPUlwiKTtcbiAgICByZXR1cm4gX3RoaXM4O1xuICB9XG5cbiAgcmV0dXJuICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFVuc3VwcG9ydGVkU3RyYXRlZ3kpO1xufShVbmtub3duRXJyb3IpO1xuXG5leHBvcnRzLlVuc3VwcG9ydGVkU3RyYXRlZ3kgPSBVbnN1cHBvcnRlZFN0cmF0ZWd5O1xuXG52YXIgSW52YWxpZENhbGxiYWNrVXJsID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3I4KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEludmFsaWRDYWxsYmFja1VybCwgX1Vua25vd25FcnJvcjgpO1xuXG4gIHZhciBfc3VwZXI5ID0gX2NyZWF0ZVN1cGVyKEludmFsaWRDYWxsYmFja1VybCk7XG5cbiAgZnVuY3Rpb24gSW52YWxpZENhbGxiYWNrVXJsKCkge1xuICAgIHZhciBfdGhpczk7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBJbnZhbGlkQ2FsbGJhY2tVcmwpO1xuXG4gICAgZm9yICh2YXIgX2xlbjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW44KSwgX2tleTggPSAwOyBfa2V5OCA8IF9sZW44OyBfa2V5OCsrKSB7XG4gICAgICBhcmdzW19rZXk4XSA9IGFyZ3VtZW50c1tfa2V5OF07XG4gICAgfVxuXG4gICAgX3RoaXM5ID0gX3N1cGVyOS5jYWxsLmFwcGx5KF9zdXBlcjksIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczkpLCBcIm5hbWVcIiwgXCJJbnZhbGlkQ2FsbGJhY2tVcmxcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzOSksIFwiY29kZVwiLCBcIklOVkFMSURfQ0FMTEJBQ0tfVVJMX0VSUk9SXCIpO1xuICAgIHJldHVybiBfdGhpczk7XG4gIH1cblxuICByZXR1cm4gKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoSW52YWxpZENhbGxiYWNrVXJsKTtcbn0oVW5rbm93bkVycm9yKTtcblxuZXhwb3J0cy5JbnZhbGlkQ2FsbGJhY2tVcmwgPSBJbnZhbGlkQ2FsbGJhY2tVcmw7XG5cbmZ1bmN0aW9uIHVwcGVyU25ha2Uocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC8oW0EtWl0pL2csIFwiXyQxXCIpLnRvVXBwZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUocykge1xuICByZXR1cm4gXCJcIi5jb25jYXQoc1swXS50b1VwcGVyQ2FzZSgpKS5jb25jYXQocy5zbGljZSgxKSk7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c0Vycm9ySGFuZGxlcihtZXRob2RzLCBsb2dnZXIpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1ldGhvZHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBuYW1lKSB7XG4gICAgYWNjW25hbWVdID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICB2YXIgbWV0aG9kLFxuICAgICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgICBtZXRob2QgPSBtZXRob2RzW25hbWVdO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh2b2lkIDAsIF9hcmdzKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA3O1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIlwiLmNvbmNhdCh1cHBlclNuYWtlKG5hbWUpLCBcIl9FVkVOVF9FUlJPUlwiKSwgX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1swLCA3XV0pO1xuICAgIH0pKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGFkYXB0ZXJFcnJvckhhbmRsZXIoYWRhcHRlciwgbG9nZ2VyKSB7XG4gIGlmICghYWRhcHRlcikgcmV0dXJuO1xuICByZXR1cm4gT2JqZWN0LmtleXMoYWRhcHRlcikucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5hbWUpIHtcbiAgICBhY2NbbmFtZV0gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICB2YXIgX2xlbjksXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgICBfa2V5OSxcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgZSxcbiAgICAgICAgICBfYXJnczIgPSBhcmd1bWVudHM7XG5cbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAwO1xuXG4gICAgICAgICAgICAgIGZvciAoX2xlbjkgPSBfYXJnczIubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW45KSwgX2tleTkgPSAwOyBfa2V5OSA8IF9sZW45OyBfa2V5OSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5OV0gPSBfYXJnczJbX2tleTldO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiYWRhcHRlcl9cIi5jb25jYXQobmFtZSksIHtcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBtZXRob2QgPSBhZGFwdGVyW25hbWVdO1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodm9pZCAwLCBhcmdzKTtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA5O1xuICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiYWRhcHRlcl9lcnJvcl9cIi5jb25jYXQobmFtZSksIF9jb250ZXh0Mi50MCk7XG4gICAgICAgICAgICAgIGUgPSBuZXcgVW5rbm93bkVycm9yKF9jb250ZXh0Mi50MCk7XG4gICAgICAgICAgICAgIGUubmFtZSA9IFwiXCIuY29uY2F0KGNhcGl0YWxpemUobmFtZSksIFwiRXJyb3JcIik7XG4gICAgICAgICAgICAgIHRocm93IGU7XG5cbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbMCwgOV1dKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufSJdLCJuYW1lcyI6WyJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVW5zdXBwb3J0ZWRTdHJhdGVneSIsIlVua25vd25FcnJvciIsIk9BdXRoQ2FsbGJhY2tFcnJvciIsIk1pc3NpbmdTZWNyZXQiLCJNaXNzaW5nQXV0aG9yaXplIiwiTWlzc2luZ0FkYXB0ZXIiLCJNaXNzaW5nQVBJUm91dGUiLCJJbnZhbGlkQ2FsbGJhY2tVcmwiLCJBY2NvdW50Tm90TGlua2VkRXJyb3IiLCJhZGFwdGVyRXJyb3JIYW5kbGVyIiwiY2FwaXRhbGl6ZSIsImV2ZW50c0Vycm9ySGFuZGxlciIsInVwcGVyU25ha2UiLCJfcmVnZW5lcmF0b3IiLCJfYXN5bmNUb0dlbmVyYXRvcjIiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkMiIsIl9kZWZpbmVQcm9wZXJ0eTIiLCJfY2xhc3NDYWxsQ2hlY2syIiwiX2NyZWF0ZUNsYXNzMiIsIl9pbmhlcml0czIiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIiLCJfZ2V0UHJvdG90eXBlT2YyIiwiX3dyYXBOYXRpdmVTdXBlcjIiLCJfY3JlYXRlU3VwZXIiLCJEZXJpdmVkIiwiaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY3JlYXRlU3VwZXJJbnRlcm5hbCIsIlN1cGVyIiwiZGVmYXVsdCIsInJlc3VsdCIsIk5ld1RhcmdldCIsImNvbnN0cnVjdG9yIiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsImFyZ3VtZW50cyIsImFwcGx5Iiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInByb3RvdHlwZSIsInZhbHVlT2YiLCJjYWxsIiwiZSIsIl9FcnJvciIsIl9zdXBlciIsImVycm9yIiwiX21lc3NhZ2UiLCJfdGhpcyIsIm1lc3NhZ2UiLCJuYW1lIiwiY29kZSIsIkVycm9yIiwic3RhY2siLCJrZXkiLCJ0b0pTT04iLCJfVW5rbm93bkVycm9yIiwiX3N1cGVyMiIsIl90aGlzMiIsIl9sZW4iLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiY29uY2F0IiwiX1Vua25vd25FcnJvcjIiLCJfc3VwZXIzIiwiX3RoaXMzIiwiX2xlbjIiLCJfa2V5MiIsIl9Vbmtub3duRXJyb3IzIiwiX3N1cGVyNCIsIl90aGlzNCIsIl9sZW4zIiwiX2tleTMiLCJfVW5rbm93bkVycm9yNCIsIl9zdXBlcjUiLCJfdGhpczUiLCJfbGVuNCIsIl9rZXk0IiwiX1Vua25vd25FcnJvcjUiLCJfc3VwZXI2IiwiX3RoaXM2IiwiX2xlbjUiLCJfa2V5NSIsIl9Vbmtub3duRXJyb3I2IiwiX3N1cGVyNyIsIl90aGlzNyIsIl9sZW42IiwiX2tleTYiLCJfVW5rbm93bkVycm9yNyIsIl9zdXBlcjgiLCJfdGhpczgiLCJfbGVuNyIsIl9rZXk3IiwiX1Vua25vd25FcnJvcjgiLCJfc3VwZXI5IiwiX3RoaXM5IiwiX2xlbjgiLCJfa2V5OCIsInMiLCJyZXBsYWNlIiwidG9VcHBlckNhc2UiLCJzbGljZSIsIm1ldGhvZHMiLCJsb2dnZXIiLCJrZXlzIiwicmVkdWNlIiwiYWNjIiwibWFyayIsIl9jYWxsZWUiLCJtZXRob2QiLCJfYXJncyIsIndyYXAiLCJfY2FsbGVlJCIsIl9jb250ZXh0IiwicHJldiIsIm5leHQiLCJhYnJ1cHQiLCJzZW50IiwidDAiLCJzdG9wIiwiYWRhcHRlciIsIl9jYWxsZWUyIiwiX2xlbjkiLCJfa2V5OSIsIl9hcmdzMiIsIl9jYWxsZWUyJCIsIl9jb250ZXh0MiIsImRlYnVnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next-auth/core/errors.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/react/index.js":
/*!***********************************************!*\
  !*** ./node_modules/next-auth/react/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar _exportNames = {\n  useSession: true,\n  getSession: true,\n  getCsrfToken: true,\n  getProviders: true,\n  signIn: true,\n  signOut: true,\n  SessionProvider: true\n};\nexports.SessionProvider = SessionProvider;\nexports.getCsrfToken = getCsrfToken;\nexports.getProviders = getProviders;\nexports.getSession = getSession;\nexports.signIn = signIn;\nexports.signOut = signOut;\nexports.useSession = useSession;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _logger2 = _interopRequireWildcard(__webpack_require__(/*! ../utils/logger */ \"./node_modules/next-auth/utils/logger.js\"));\n\nvar _parseUrl = _interopRequireDefault(__webpack_require__(/*! ../utils/parse-url */ \"./node_modules/next-auth/utils/parse-url.js\"));\n\nvar _utils = __webpack_require__(/*! ../client/_utils */ \"./node_modules/next-auth/client/_utils.js\");\n\nvar _jsxRuntime = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/next-auth/react/types.js\");\n\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _types[key];\n    }\n  });\n});\n\nvar _process$env$NEXTAUTH, _ref, _process$env$NEXTAUTH2, _process$env$NEXTAUTH3;\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nvar __NEXTAUTH = {\n  baseUrl: (0, _parseUrl.default)((_process$env$NEXTAUTH = process.env.NEXTAUTH_URL) !== null && _process$env$NEXTAUTH !== void 0 ? _process$env$NEXTAUTH : process.env.VERCEL_URL).origin,\n  basePath: (0, _parseUrl.default)(process.env.NEXTAUTH_URL).path,\n  baseUrlServer: (0, _parseUrl.default)((_ref = (_process$env$NEXTAUTH2 = process.env.NEXTAUTH_URL_INTERNAL) !== null && _process$env$NEXTAUTH2 !== void 0 ? _process$env$NEXTAUTH2 : process.env.NEXTAUTH_URL) !== null && _ref !== void 0 ? _ref : process.env.VERCEL_URL).origin,\n  basePathServer: (0, _parseUrl.default)((_process$env$NEXTAUTH3 = process.env.NEXTAUTH_URL_INTERNAL) !== null && _process$env$NEXTAUTH3 !== void 0 ? _process$env$NEXTAUTH3 : process.env.NEXTAUTH_URL).path,\n  _lastSync: 0,\n  _session: undefined,\n  _getSession: function _getSession() {}\n};\nvar broadcast = (0, _utils.BroadcastChannel)();\nvar logger = (0, _logger2.proxyLogger)(_logger2.default, __NEXTAUTH.basePath);\nvar SessionContext = React.createContext(undefined);\n\nfunction useSession(options) {\n  var value = React.useContext(SessionContext);\n\n  if (!value && \"development\" !== \"production\") {\n    throw new Error(\"[next-auth]: `useSession` must be wrapped in a <SessionProvider />\");\n  }\n\n  var _ref2 = options !== null && options !== void 0 ? options : {},\n      required = _ref2.required,\n      onUnauthenticated = _ref2.onUnauthenticated;\n\n  var requiredAndNotLoading = required && value.status === \"unauthenticated\";\n  React.useEffect(function () {\n    if (requiredAndNotLoading) {\n      var url = \"/api/auth/signin?\".concat(new URLSearchParams({\n        error: \"SessionRequired\",\n        callbackUrl: window.location.href\n      }));\n      if (onUnauthenticated) onUnauthenticated();else window.location.href = url;\n    }\n  }, [requiredAndNotLoading, onUnauthenticated]);\n\n  if (requiredAndNotLoading) {\n    return {\n      data: value.data,\n      status: \"loading\"\n    };\n  }\n\n  return value;\n}\n\nfunction getSession(_x) {\n  return _getSession2.apply(this, arguments);\n}\n\nfunction _getSession2() {\n  _getSession2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(params) {\n    var _params$broadcast;\n\n    var session;\n    return _regenerator.default.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return (0, _utils.fetchData)(\"session\", __NEXTAUTH, logger, params);\n\n          case 2:\n            session = _context2.sent;\n\n            if ((_params$broadcast = params === null || params === void 0 ? void 0 : params.broadcast) !== null && _params$broadcast !== void 0 ? _params$broadcast : true) {\n              broadcast.post({\n                event: \"session\",\n                data: {\n                  trigger: \"getSession\"\n                }\n              });\n            }\n\n            return _context2.abrupt(\"return\", session);\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getSession2.apply(this, arguments);\n}\n\nfunction getCsrfToken(_x2) {\n  return _getCsrfToken.apply(this, arguments);\n}\n\nfunction _getCsrfToken() {\n  _getCsrfToken = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(params) {\n    var response;\n    return _regenerator.default.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return (0, _utils.fetchData)(\"csrf\", __NEXTAUTH, logger, params);\n\n          case 2:\n            response = _context3.sent;\n            return _context3.abrupt(\"return\", response === null || response === void 0 ? void 0 : response.csrfToken);\n\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getCsrfToken.apply(this, arguments);\n}\n\nfunction getProviders() {\n  return _getProviders.apply(this, arguments);\n}\n\nfunction _getProviders() {\n  _getProviders = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4() {\n    return _regenerator.default.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return (0, _utils.fetchData)(\"providers\", __NEXTAUTH, logger);\n\n          case 2:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 3:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _getProviders.apply(this, arguments);\n}\n\nfunction signIn(_x3, _x4, _x5) {\n  return _signIn.apply(this, arguments);\n}\n\nfunction _signIn() {\n  _signIn = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5(provider, options, authorizationParams) {\n    var _ref5, _ref5$callbackUrl, callbackUrl, _ref5$redirect, redirect, baseUrl, providers, isCredentials, isEmail, isSupportingReturn, signInUrl, _signInUrl, res, data, _data$url, url, error;\n\n    return _regenerator.default.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _ref5 = options !== null && options !== void 0 ? options : {}, _ref5$callbackUrl = _ref5.callbackUrl, callbackUrl = _ref5$callbackUrl === void 0 ? window.location.href : _ref5$callbackUrl, _ref5$redirect = _ref5.redirect, redirect = _ref5$redirect === void 0 ? true : _ref5$redirect;\n            baseUrl = (0, _utils.apiBaseUrl)(__NEXTAUTH);\n            _context5.next = 4;\n            return getProviders();\n\n          case 4:\n            providers = _context5.sent;\n\n            if (providers) {\n              _context5.next = 8;\n              break;\n            }\n\n            window.location.href = \"\".concat(baseUrl, \"/error\");\n            return _context5.abrupt(\"return\");\n\n          case 8:\n            if (!(!provider || !(provider in providers))) {\n              _context5.next = 11;\n              break;\n            }\n\n            window.location.href = \"\".concat(baseUrl, \"/signin?\").concat(new URLSearchParams({\n              callbackUrl: callbackUrl\n            }));\n            return _context5.abrupt(\"return\");\n\n          case 11:\n            isCredentials = providers[provider].type === \"credentials\";\n            isEmail = providers[provider].type === \"email\";\n            isSupportingReturn = isCredentials || isEmail;\n            signInUrl = \"\".concat(baseUrl, \"/\").concat(isCredentials ? \"callback\" : \"signin\", \"/\").concat(provider);\n            _signInUrl = \"\".concat(signInUrl, \"?\").concat(new URLSearchParams(authorizationParams));\n            _context5.t0 = fetch;\n            _context5.t1 = _signInUrl;\n            _context5.t2 = {\n              \"Content-Type\": \"application/x-www-form-urlencoded\"\n            };\n            _context5.t3 = URLSearchParams;\n            _context5.t4 = _objectSpread;\n            _context5.t5 = _objectSpread({}, options);\n            _context5.t6 = {};\n            _context5.next = 25;\n            return getCsrfToken();\n\n          case 25:\n            _context5.t7 = _context5.sent;\n            _context5.t8 = callbackUrl;\n            _context5.t9 = {\n              csrfToken: _context5.t7,\n              callbackUrl: _context5.t8,\n              json: true\n            };\n            _context5.t10 = (0, _context5.t4)(_context5.t5, _context5.t6, _context5.t9);\n            _context5.t11 = new _context5.t3(_context5.t10);\n            _context5.t12 = {\n              method: \"post\",\n              headers: _context5.t2,\n              body: _context5.t11\n            };\n            _context5.next = 33;\n            return (0, _context5.t0)(_context5.t1, _context5.t12);\n\n          case 33:\n            res = _context5.sent;\n            _context5.next = 36;\n            return res.json();\n\n          case 36:\n            data = _context5.sent;\n\n            if (!(redirect || !isSupportingReturn)) {\n              _context5.next = 42;\n              break;\n            }\n\n            url = (_data$url = data.url) !== null && _data$url !== void 0 ? _data$url : callbackUrl;\n            window.location.href = url;\n            if (url.includes(\"#\")) window.location.reload();\n            return _context5.abrupt(\"return\");\n\n          case 42:\n            error = new URL(data.url).searchParams.get(\"error\");\n\n            if (!res.ok) {\n              _context5.next = 46;\n              break;\n            }\n\n            _context5.next = 46;\n            return __NEXTAUTH._getSession({\n              event: \"storage\"\n            });\n\n          case 46:\n            return _context5.abrupt(\"return\", {\n              error: error,\n              status: res.status,\n              ok: res.ok,\n              url: error ? null : data.url\n            });\n\n          case 47:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _signIn.apply(this, arguments);\n}\n\nfunction signOut(_x6) {\n  return _signOut.apply(this, arguments);\n}\n\nfunction _signOut() {\n  _signOut = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee6(options) {\n    var _options$redirect;\n\n    var _ref6, _ref6$callbackUrl, callbackUrl, baseUrl, fetchOptions, res, data, _data$url2, url;\n\n    return _regenerator.default.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _ref6 = options !== null && options !== void 0 ? options : {}, _ref6$callbackUrl = _ref6.callbackUrl, callbackUrl = _ref6$callbackUrl === void 0 ? window.location.href : _ref6$callbackUrl;\n            baseUrl = (0, _utils.apiBaseUrl)(__NEXTAUTH);\n            _context6.t0 = {\n              \"Content-Type\": \"application/x-www-form-urlencoded\"\n            };\n            _context6.t1 = URLSearchParams;\n            _context6.next = 6;\n            return getCsrfToken();\n\n          case 6:\n            _context6.t2 = _context6.sent;\n            _context6.t3 = callbackUrl;\n            _context6.t4 = {\n              csrfToken: _context6.t2,\n              callbackUrl: _context6.t3,\n              json: true\n            };\n            _context6.t5 = new _context6.t1(_context6.t4);\n            fetchOptions = {\n              method: \"post\",\n              headers: _context6.t0,\n              body: _context6.t5\n            };\n            _context6.next = 13;\n            return fetch(\"\".concat(baseUrl, \"/signout\"), fetchOptions);\n\n          case 13:\n            res = _context6.sent;\n            _context6.next = 16;\n            return res.json();\n\n          case 16:\n            data = _context6.sent;\n            broadcast.post({\n              event: \"session\",\n              data: {\n                trigger: \"signout\"\n              }\n            });\n\n            if (!((_options$redirect = options === null || options === void 0 ? void 0 : options.redirect) !== null && _options$redirect !== void 0 ? _options$redirect : true)) {\n              _context6.next = 23;\n              break;\n            }\n\n            url = (_data$url2 = data.url) !== null && _data$url2 !== void 0 ? _data$url2 : callbackUrl;\n            window.location.href = url;\n            if (url.includes(\"#\")) window.location.reload();\n            return _context6.abrupt(\"return\");\n\n          case 23:\n            _context6.next = 25;\n            return __NEXTAUTH._getSession({\n              event: \"storage\"\n            });\n\n          case 25:\n            return _context6.abrupt(\"return\", data);\n\n          case 26:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _signOut.apply(this, arguments);\n}\n\nfunction SessionProvider(props) {\n  var children = props.children,\n      basePath = props.basePath;\n  if (basePath) __NEXTAUTH.basePath = basePath;\n  var hasInitialSession = props.session !== undefined;\n  __NEXTAUTH._lastSync = hasInitialSession ? (0, _utils.now)() : 0;\n\n  var _React$useState = React.useState(function () {\n    if (hasInitialSession) __NEXTAUTH._session = props.session;\n    return props.session;\n  }),\n      _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),\n      session = _React$useState2[0],\n      setSession = _React$useState2[1];\n\n  var _React$useState3 = React.useState(!hasInitialSession),\n      _React$useState4 = (0, _slicedToArray2.default)(_React$useState3, 2),\n      loading = _React$useState4[0],\n      setLoading = _React$useState4[1];\n\n  React.useEffect(function () {\n    __NEXTAUTH._getSession = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {\n      var _ref4,\n          event,\n          storageEvent,\n          _args = arguments;\n\n      return _regenerator.default.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _ref4 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, event = _ref4.event;\n              _context.prev = 1;\n              storageEvent = event === \"storage\";\n\n              if (!(storageEvent || __NEXTAUTH._session === undefined)) {\n                _context.next = 10;\n                break;\n              }\n\n              __NEXTAUTH._lastSync = (0, _utils.now)();\n              _context.next = 7;\n              return getSession({\n                broadcast: !storageEvent\n              });\n\n            case 7:\n              __NEXTAUTH._session = _context.sent;\n              setSession(__NEXTAUTH._session);\n              return _context.abrupt(\"return\");\n\n            case 10:\n              if (!(!event || __NEXTAUTH._session === null || (0, _utils.now)() < __NEXTAUTH._lastSync)) {\n                _context.next = 12;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 12:\n              __NEXTAUTH._lastSync = (0, _utils.now)();\n              _context.next = 15;\n              return getSession();\n\n            case 15:\n              __NEXTAUTH._session = _context.sent;\n              setSession(__NEXTAUTH._session);\n              _context.next = 22;\n              break;\n\n            case 19:\n              _context.prev = 19;\n              _context.t0 = _context[\"catch\"](1);\n              logger.error(\"CLIENT_SESSION_ERROR\", _context.t0);\n\n            case 22:\n              _context.prev = 22;\n              setLoading(false);\n              return _context.finish(22);\n\n            case 25:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 19, 22, 25]]);\n    }));\n\n    __NEXTAUTH._getSession();\n\n    return function () {\n      __NEXTAUTH._lastSync = 0;\n      __NEXTAUTH._session = undefined;\n\n      __NEXTAUTH._getSession = function () {};\n    };\n  }, []);\n  React.useEffect(function () {\n    var unsubscribe = broadcast.receive(function () {\n      return __NEXTAUTH._getSession({\n        event: \"storage\"\n      });\n    });\n    return function () {\n      return unsubscribe();\n    };\n  }, []);\n  React.useEffect(function () {\n    var _props$refetchOnWindo = props.refetchOnWindowFocus,\n        refetchOnWindowFocus = _props$refetchOnWindo === void 0 ? true : _props$refetchOnWindo;\n\n    var visibilityHandler = function visibilityHandler() {\n      if (refetchOnWindowFocus && document.visibilityState === \"visible\") __NEXTAUTH._getSession({\n        event: \"visibilitychange\"\n      });\n    };\n\n    document.addEventListener(\"visibilitychange\", visibilityHandler, false);\n    return function () {\n      return document.removeEventListener(\"visibilitychange\", visibilityHandler, false);\n    };\n  }, [props.refetchOnWindowFocus]);\n  React.useEffect(function () {\n    var refetchInterval = props.refetchInterval;\n\n    if (refetchInterval) {\n      var refetchIntervalTimer = setInterval(function () {\n        if (__NEXTAUTH._session) {\n          __NEXTAUTH._getSession({\n            event: \"poll\"\n          });\n        }\n      }, refetchInterval * 1000);\n      return function () {\n        return clearInterval(refetchIntervalTimer);\n      };\n    }\n  }, [props.refetchInterval]);\n  var value = React.useMemo(function () {\n    return {\n      data: session,\n      status: loading ? \"loading\" : session ? \"authenticated\" : \"unauthenticated\"\n    };\n  }, [session, loading]);\n  return (0, _jsxRuntime.jsx)(SessionContext.Provider, {\n    value: value,\n    children: children\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTs7QUFFYixJQUFJQSxzQkFBc0IsR0FBR0MsbUJBQU8sQ0FBQyxvSEFBRCxDQUFwQzs7QUFFQSxJQUFJQyxPQUFPLEdBQUdELG1CQUFPLENBQUMsc0ZBQUQsQ0FBckI7O0FBRUFFLDhDQUE2QztFQUMzQ0csS0FBSyxFQUFFO0FBRG9DLENBQTdDO0FBR0EsSUFBSUMsWUFBWSxHQUFHO0VBQ2pCQyxVQUFVLEVBQUUsSUFESztFQUVqQkMsVUFBVSxFQUFFLElBRks7RUFHakJDLFlBQVksRUFBRSxJQUhHO0VBSWpCQyxZQUFZLEVBQUUsSUFKRztFQUtqQkMsTUFBTSxFQUFFLElBTFM7RUFNakJDLE9BQU8sRUFBRSxJQU5RO0VBT2pCQyxlQUFlLEVBQUU7QUFQQSxDQUFuQjtBQVNBVCx1QkFBQSxHQUEwQlMsZUFBMUI7QUFDQVQsb0JBQUEsR0FBdUJLLFlBQXZCO0FBQ0FMLG9CQUFBLEdBQXVCTSxZQUF2QjtBQUNBTixrQkFBQSxHQUFxQkksVUFBckI7QUFDQUosY0FBQSxHQUFpQk8sTUFBakI7QUFDQVAsZUFBQSxHQUFrQlEsT0FBbEI7QUFDQVIsa0JBQUEsR0FBcUJHLFVBQXJCOztBQUVBLElBQUlPLFlBQVksR0FBR2Ysc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsc0ZBQUQsQ0FBUixDQUF6Qzs7QUFFQSxJQUFJZSxnQkFBZ0IsR0FBR2hCLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLHNHQUFELENBQVIsQ0FBN0M7O0FBRUEsSUFBSWdCLGVBQWUsR0FBR2pCLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLG9HQUFELENBQVIsQ0FBNUM7O0FBRUEsSUFBSWlCLGtCQUFrQixHQUFHbEIsc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsMEdBQUQsQ0FBUixDQUEvQzs7QUFFQSxJQUFJa0IsS0FBSyxHQUFHQyx1QkFBdUIsQ0FBQ25CLG1CQUFPLENBQUMsNENBQUQsQ0FBUixD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MUIsSUFBSTRILGVBQWUsR0FBRzVCLEtBQUssQ0FBQzRCLGVBQTVCOztJQUVBLElBQUlBLGVBQUosRUFBcUI7TUFDbkIsSUFBSUMsb0JBQW9CLEdBQUdDLFdBQVcsQ0FBQyxZQUFZO1FBQ2pELElBQUk3SixVQUFVLENBQUNhLFFBQWYsRUFBeUI7VUFDdkJiLFVBQVUsQ0FBQ2UsV0FBWCxDQUF1QjtZQUNyQnlDLEtBQUssRUFBRTtVQURjLENBQXZCO1FBR0Q7TUFDRixDQU5xQyxFQU1uQ21HLGVBQWUsR0FBRyxJQU5pQixDQUF0QztNQU9BLE9BQU8sWUFBWTtRQUNqQixPQUFPRyxhQUFhLENBQUNGLG9CQUFELENBQXBCO01BQ0QsQ0FGRDtJQUdEO0VBQ0YsQ0FmRCxFQWVHLENBQUM3QixLQUFLLENBQUM0QixlQUFQLENBZkg7RUFnQkEsSUFBSTNOLEtBQUssR0FBR2EsS0FBSyxDQUFDa04sT0FBTixDQUFjLFlBQVk7SUFDcEMsT0FBTztNQUNMdkgsSUFBSSxFQUFFTyxPQUREO01BRUxqQixNQUFNLEVBQUUyRyxPQUFPLEdBQUcsU0FBSCxHQUFlMUYsT0FBTyxHQUFHLGVBQUgsR0FBcUI7SUFGckQsQ0FBUDtFQUlELENBTFcsRUFLVCxDQUFDQSxPQUFELEVBQVUwRixPQUFWLENBTFMsQ0FBWjtFQU1BLE9BQU8sQ0FBQyxHQUFHdkwsV0FBVyxDQUFDOE0sR0FBaEIsRUFBcUI1SSxjQUFjLENBQUM2SSxRQUFwQyxFQUE4QztJQUNuRGpPLEtBQUssRUFBRUEsS0FENEM7SUFFbkRnTSxRQUFRLEVBQUVBO0VBRnlDLENBQTlDLENBQVA7QUFJRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0L2luZGV4LmpzP2MxOWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBfZXhwb3J0TmFtZXMgPSB7XG4gIHVzZVNlc3Npb246IHRydWUsXG4gIGdldFNlc3Npb246IHRydWUsXG4gIGdldENzcmZUb2tlbjogdHJ1ZSxcbiAgZ2V0UHJvdmlkZXJzOiB0cnVlLFxuICBzaWduSW46IHRydWUsXG4gIHNpZ25PdXQ6IHRydWUsXG4gIFNlc3Npb25Qcm92aWRlcjogdHJ1ZVxufTtcbmV4cG9ydHMuU2Vzc2lvblByb3ZpZGVyID0gU2Vzc2lvblByb3ZpZGVyO1xuZXhwb3J0cy5nZXRDc3JmVG9rZW4gPSBnZXRDc3JmVG9rZW47XG5leHBvcnRzLmdldFByb3ZpZGVycyA9IGdldFByb3ZpZGVycztcbmV4cG9ydHMuZ2V0U2Vzc2lvbiA9IGdldFNlc3Npb247XG5leHBvcnRzLnNpZ25JbiA9IHNpZ25JbjtcbmV4cG9ydHMuc2lnbk91dCA9IHNpZ25PdXQ7XG5leHBvcnRzLnVzZVNlc3Npb24gPSB1c2VTZXNzaW9uO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5XCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfbG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuLi91dGlscy9sb2dnZXJcIikpO1xuXG52YXIgX3BhcnNlVXJsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvcGFyc2UtdXJsXCIpKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi9jbGllbnQvX3V0aWxzXCIpO1xuXG52YXIgX2pzeFJ1bnRpbWUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxuT2JqZWN0LmtleXMoX3R5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfdHlwZXNba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfdHlwZXNba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBfcHJvY2VzcyRlbnYkTkVYVEFVVEgsIF9yZWYsIF9wcm9jZXNzJGVudiRORVhUQVVUSDIsIF9wcm9jZXNzJGVudiRORVhUQVVUSDM7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgX19ORVhUQVVUSCA9IHtcbiAgYmFzZVVybDogKDAsIF9wYXJzZVVybC5kZWZhdWx0KSgoX3Byb2Nlc3MkZW52JE5FWFRBVVRIID0gcHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMKSAhPT0gbnVsbCAmJiBfcHJvY2VzcyRlbnYkTkVYVEFVVEggIT09IHZvaWQgMCA/IF9wcm9jZXNzJGVudiRORVhUQVVUSCA6IHByb2Nlc3MuZW52LlZFUkNFTF9VUkwpLm9yaWdpbixcbiAgYmFzZVBhdGg6ICgwLCBfcGFyc2VVcmwuZGVmYXVsdCkocHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMKS5wYXRoLFxuICBiYXNlVXJsU2VydmVyOiAoMCwgX3BhcnNlVXJsLmRlZmF1bHQpKChfcmVmID0gKF9wcm9jZXNzJGVudiRORVhUQVVUSDIgPSBwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkxfSU5URVJOQUwpICE9PSBudWxsICYmIF9wcm9jZXNzJGVudiRORVhUQVVUSDIgIT09IHZvaWQgMCA/IF9wcm9jZXNzJGVudiRORVhUQVVUSDIgOiBwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkwpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiBwcm9jZXNzLmVudi5WRVJDRUxfVVJMKS5vcmlnaW4sXG4gIGJhc2VQYXRoU2VydmVyOiAoMCwgX3BhcnNlVXJsLmRlZmF1bHQpKChfcHJvY2VzcyRlbnYkTkVYVEFVVEgzID0gcHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMX0lOVEVSTkFMKSAhPT0gbnVsbCAmJiBfcHJvY2VzcyRlbnYkTkVYVEFVVEgzICE9PSB2b2lkIDAgPyBfcHJvY2VzcyRlbnYkTkVYVEFVVEgzIDogcHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMKS5wYXRoLFxuICBfbGFzdFN5bmM6IDAsXG4gIF9zZXNzaW9uOiB1bmRlZmluZWQsXG4gIF9nZXRTZXNzaW9uOiBmdW5jdGlvbiBfZ2V0U2Vzc2lvbigpIHt9XG59O1xudmFyIGJyb2FkY2FzdCA9ICgwLCBfdXRpbHMuQnJvYWRjYXN0Q2hhbm5lbCkoKTtcbnZhciBsb2dnZXIgPSAoMCwgX2xvZ2dlcjIucHJveHlMb2dnZXIpKF9sb2dnZXIyLmRlZmF1bHQsIF9fTkVYVEFVVEguYmFzZVBhdGgpO1xudmFyIFNlc3Npb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuXG5mdW5jdGlvbiB1c2VTZXNzaW9uKG9wdGlvbnMpIHtcbiAgdmFyIHZhbHVlID0gUmVhY3QudXNlQ29udGV4dChTZXNzaW9uQ29udGV4dCk7XG5cbiAgaWYgKCF2YWx1ZSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbmV4dC1hdXRoXTogYHVzZVNlc3Npb25gIG11c3QgYmUgd3JhcHBlZCBpbiBhIDxTZXNzaW9uUHJvdmlkZXIgLz5cIik7XG4gIH1cblxuICB2YXIgX3JlZjIgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSxcbiAgICAgIHJlcXVpcmVkID0gX3JlZjIucmVxdWlyZWQsXG4gICAgICBvblVuYXV0aGVudGljYXRlZCA9IF9yZWYyLm9uVW5hdXRoZW50aWNhdGVkO1xuXG4gIHZhciByZXF1aXJlZEFuZE5vdExvYWRpbmcgPSByZXF1aXJlZCAmJiB2YWx1ZS5zdGF0dXMgPT09IFwidW5hdXRoZW50aWNhdGVkXCI7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJlcXVpcmVkQW5kTm90TG9hZGluZykge1xuICAgICAgdmFyIHVybCA9IFwiL2FwaS9hdXRoL3NpZ25pbj9cIi5jb25jYXQobmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGVycm9yOiBcIlNlc3Npb25SZXF1aXJlZFwiLFxuICAgICAgICBjYWxsYmFja1VybDogd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICAgIH0pKTtcbiAgICAgIGlmIChvblVuYXV0aGVudGljYXRlZCkgb25VbmF1dGhlbnRpY2F0ZWQoKTtlbHNlIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgIH1cbiAgfSwgW3JlcXVpcmVkQW5kTm90TG9hZGluZywgb25VbmF1dGhlbnRpY2F0ZWRdKTtcblxuICBpZiAocmVxdWlyZWRBbmROb3RMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHZhbHVlLmRhdGEsXG4gICAgICBzdGF0dXM6IFwibG9hZGluZ1wiXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Vzc2lvbihfeCkge1xuICByZXR1cm4gX2dldFNlc3Npb24yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRTZXNzaW9uMigpIHtcbiAgX2dldFNlc3Npb24yID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHBhcmFtcykge1xuICAgIHZhciBfcGFyYW1zJGJyb2FkY2FzdDtcblxuICAgIHZhciBzZXNzaW9uO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmZldGNoRGF0YSkoXCJzZXNzaW9uXCIsIF9fTkVYVEFVVEgsIGxvZ2dlciwgcGFyYW1zKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHNlc3Npb24gPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgaWYgKChfcGFyYW1zJGJyb2FkY2FzdCA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5icm9hZGNhc3QpICE9PSBudWxsICYmIF9wYXJhbXMkYnJvYWRjYXN0ICE9PSB2b2lkIDAgPyBfcGFyYW1zJGJyb2FkY2FzdCA6IHRydWUpIHtcbiAgICAgICAgICAgICAgYnJvYWRjYXN0LnBvc3Qoe1xuICAgICAgICAgICAgICAgIGV2ZW50OiBcInNlc3Npb25cIixcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICB0cmlnZ2VyOiBcImdldFNlc3Npb25cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHNlc3Npb24pO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0U2Vzc2lvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q3NyZlRva2VuKF94Mikge1xuICByZXR1cm4gX2dldENzcmZUb2tlbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0Q3NyZlRva2VuKCkge1xuICBfZ2V0Q3NyZlRva2VuID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKHBhcmFtcykge1xuICAgIHZhciByZXNwb25zZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF91dGlscy5mZXRjaERhdGEpKFwiY3NyZlwiLCBfX05FWFRBVVRILCBsb2dnZXIsIHBhcmFtcyk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmNzcmZUb2tlbik7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRDc3JmVG9rZW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvdmlkZXJzKCkge1xuICByZXR1cm4gX2dldFByb3ZpZGVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdmlkZXJzKCkge1xuICBfZ2V0UHJvdmlkZXJzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KCkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmZldGNoRGF0YSkoXCJwcm92aWRlcnNcIiwgX19ORVhUQVVUSCwgbG9nZ2VyKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0KTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFByb3ZpZGVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBzaWduSW4oX3gzLCBfeDQsIF94NSkge1xuICByZXR1cm4gX3NpZ25Jbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfc2lnbkluKCkge1xuICBfc2lnbkluID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KHByb3ZpZGVyLCBvcHRpb25zLCBhdXRob3JpemF0aW9uUGFyYW1zKSB7XG4gICAgdmFyIF9yZWY1LCBfcmVmNSRjYWxsYmFja1VybCwgY2FsbGJhY2tVcmwsIF9yZWY1JHJlZGlyZWN0LCByZWRpcmVjdCwgYmFzZVVybCwgcHJvdmlkZXJzLCBpc0NyZWRlbnRpYWxzLCBpc0VtYWlsLCBpc1N1cHBvcnRpbmdSZXR1cm4sIHNpZ25JblVybCwgX3NpZ25JblVybCwgcmVzLCBkYXRhLCBfZGF0YSR1cmwsIHVybCwgZXJyb3I7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfcmVmNSA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCBfcmVmNSRjYWxsYmFja1VybCA9IF9yZWY1LmNhbGxiYWNrVXJsLCBjYWxsYmFja1VybCA9IF9yZWY1JGNhbGxiYWNrVXJsID09PSB2b2lkIDAgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6IF9yZWY1JGNhbGxiYWNrVXJsLCBfcmVmNSRyZWRpcmVjdCA9IF9yZWY1LnJlZGlyZWN0LCByZWRpcmVjdCA9IF9yZWY1JHJlZGlyZWN0ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjUkcmVkaXJlY3Q7XG4gICAgICAgICAgICBiYXNlVXJsID0gKDAsIF91dGlscy5hcGlCYXNlVXJsKShfX05FWFRBVVRIKTtcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiBnZXRQcm92aWRlcnMoKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHByb3ZpZGVycyA9IF9jb250ZXh0NS5zZW50O1xuXG4gICAgICAgICAgICBpZiAocHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gXCJcIi5jb25jYXQoYmFzZVVybCwgXCIvZXJyb3JcIik7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGlmICghKCFwcm92aWRlciB8fCAhKHByb3ZpZGVyIGluIHByb3ZpZGVycykpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IFwiXCIuY29uY2F0KGJhc2VVcmwsIFwiL3NpZ25pbj9cIikuY29uY2F0KG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgICBjYWxsYmFja1VybDogY2FsbGJhY2tVcmxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGlzQ3JlZGVudGlhbHMgPSBwcm92aWRlcnNbcHJvdmlkZXJdLnR5cGUgPT09IFwiY3JlZGVudGlhbHNcIjtcbiAgICAgICAgICAgIGlzRW1haWwgPSBwcm92aWRlcnNbcHJvdmlkZXJdLnR5cGUgPT09IFwiZW1haWxcIjtcbiAgICAgICAgICAgIGlzU3VwcG9ydGluZ1JldHVybiA9IGlzQ3JlZGVudGlhbHMgfHwgaXNFbWFpbDtcbiAgICAgICAgICAgIHNpZ25JblVybCA9IFwiXCIuY29uY2F0KGJhc2VVcmwsIFwiL1wiKS5jb25jYXQoaXNDcmVkZW50aWFscyA/IFwiY2FsbGJhY2tcIiA6IFwic2lnbmluXCIsIFwiL1wiKS5jb25jYXQocHJvdmlkZXIpO1xuICAgICAgICAgICAgX3NpZ25JblVybCA9IFwiXCIuY29uY2F0KHNpZ25JblVybCwgXCI/XCIpLmNvbmNhdChuZXcgVVJMU2VhcmNoUGFyYW1zKGF1dGhvcml6YXRpb25QYXJhbXMpKTtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IGZldGNoO1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQxID0gX3NpZ25JblVybDtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MiA9IHtcbiAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MyA9IFVSTFNlYXJjaFBhcmFtcztcbiAgICAgICAgICAgIF9jb250ZXh0NS50NCA9IF9vYmplY3RTcHJlYWQ7XG4gICAgICAgICAgICBfY29udGV4dDUudDUgPSBfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIF9jb250ZXh0NS50NiA9IHt9O1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAyNTtcbiAgICAgICAgICAgIHJldHVybiBnZXRDc3JmVG9rZW4oKTtcblxuICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICBfY29udGV4dDUudDcgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0NS50OCA9IGNhbGxiYWNrVXJsO1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQ5ID0ge1xuICAgICAgICAgICAgICBjc3JmVG9rZW46IF9jb250ZXh0NS50NyxcbiAgICAgICAgICAgICAgY2FsbGJhY2tVcmw6IF9jb250ZXh0NS50OCxcbiAgICAgICAgICAgICAganNvbjogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MTAgPSAoMCwgX2NvbnRleHQ1LnQ0KShfY29udGV4dDUudDUsIF9jb250ZXh0NS50NiwgX2NvbnRleHQ1LnQ5KTtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MTEgPSBuZXcgX2NvbnRleHQ1LnQzKF9jb250ZXh0NS50MTApO1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQxMiA9IHtcbiAgICAgICAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgICAgICAgaGVhZGVyczogX2NvbnRleHQ1LnQyLFxuICAgICAgICAgICAgICBib2R5OiBfY29udGV4dDUudDExXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzMztcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2NvbnRleHQ1LnQwKShfY29udGV4dDUudDEsIF9jb250ZXh0NS50MTIpO1xuXG4gICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgIHJlcyA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzNjtcbiAgICAgICAgICAgIHJldHVybiByZXMuanNvbigpO1xuXG4gICAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDUuc2VudDtcblxuICAgICAgICAgICAgaWYgKCEocmVkaXJlY3QgfHwgIWlzU3VwcG9ydGluZ1JldHVybikpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0MjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVybCA9IChfZGF0YSR1cmwgPSBkYXRhLnVybCkgIT09IG51bGwgJiYgX2RhdGEkdXJsICE9PSB2b2lkIDAgPyBfZGF0YSR1cmwgOiBjYWxsYmFja1VybDtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgaWYgKHVybC5pbmNsdWRlcyhcIiNcIikpIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFVSTChkYXRhLnVybCkuc2VhcmNoUGFyYW1zLmdldChcImVycm9yXCIpO1xuXG4gICAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQ2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0NjtcbiAgICAgICAgICAgIHJldHVybiBfX05FWFRBVVRILl9nZXRTZXNzaW9uKHtcbiAgICAgICAgICAgICAgZXZlbnQ6IFwic3RvcmFnZVwiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNDY6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgICAgICAgICBvazogcmVzLm9rLFxuICAgICAgICAgICAgICB1cmw6IGVycm9yID8gbnVsbCA6IGRhdGEudXJsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9zaWduSW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gc2lnbk91dChfeDYpIHtcbiAgcmV0dXJuIF9zaWduT3V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9zaWduT3V0KCkge1xuICBfc2lnbk91dCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNihvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zJHJlZGlyZWN0O1xuXG4gICAgdmFyIF9yZWY2LCBfcmVmNiRjYWxsYmFja1VybCwgY2FsbGJhY2tVcmwsIGJhc2VVcmwsIGZldGNoT3B0aW9ucywgcmVzLCBkYXRhLCBfZGF0YSR1cmwyLCB1cmw7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfcmVmNiA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCBfcmVmNiRjYWxsYmFja1VybCA9IF9yZWY2LmNhbGxiYWNrVXJsLCBjYWxsYmFja1VybCA9IF9yZWY2JGNhbGxiYWNrVXJsID09PSB2b2lkIDAgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6IF9yZWY2JGNhbGxiYWNrVXJsO1xuICAgICAgICAgICAgYmFzZVVybCA9ICgwLCBfdXRpbHMuYXBpQmFzZVVybCkoX19ORVhUQVVUSCk7XG4gICAgICAgICAgICBfY29udGV4dDYudDAgPSB7XG4gICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfY29udGV4dDYudDEgPSBVUkxTZWFyY2hQYXJhbXM7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q3NyZlRva2VuKCk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBfY29udGV4dDYudDIgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Ni50MyA9IGNhbGxiYWNrVXJsO1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQ0ID0ge1xuICAgICAgICAgICAgICBjc3JmVG9rZW46IF9jb250ZXh0Ni50MixcbiAgICAgICAgICAgICAgY2FsbGJhY2tVcmw6IF9jb250ZXh0Ni50MyxcbiAgICAgICAgICAgICAganNvbjogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9jb250ZXh0Ni50NSA9IG5ldyBfY29udGV4dDYudDEoX2NvbnRleHQ2LnQ0KTtcbiAgICAgICAgICAgIGZldGNoT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgICAgICAgaGVhZGVyczogX2NvbnRleHQ2LnQwLFxuICAgICAgICAgICAgICBib2R5OiBfY29udGV4dDYudDVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDEzO1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKFwiXCIuY29uY2F0KGJhc2VVcmwsIFwiL3NpZ25vdXRcIiksIGZldGNoT3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgYnJvYWRjYXN0LnBvc3Qoe1xuICAgICAgICAgICAgICBldmVudDogXCJzZXNzaW9uXCIsXG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBcInNpZ25vdXRcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCEoKF9vcHRpb25zJHJlZGlyZWN0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZGlyZWN0KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRyZWRpcmVjdCAhPT0gdm9pZCAwID8gX29wdGlvbnMkcmVkaXJlY3QgOiB0cnVlKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDIzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXJsID0gKF9kYXRhJHVybDIgPSBkYXRhLnVybCkgIT09IG51bGwgJiYgX2RhdGEkdXJsMiAhPT0gdm9pZCAwID8gX2RhdGEkdXJsMiA6IGNhbGxiYWNrVXJsO1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICBpZiAodXJsLmluY2x1ZGVzKFwiI1wiKSkgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAyNTtcbiAgICAgICAgICAgIHJldHVybiBfX05FWFRBVVRILl9nZXRTZXNzaW9uKHtcbiAgICAgICAgICAgICAgZXZlbnQ6IFwic3RvcmFnZVwiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBkYXRhKTtcblxuICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNik7XG4gIH0pKTtcbiAgcmV0dXJuIF9zaWduT3V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIFNlc3Npb25Qcm92aWRlcihwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGJhc2VQYXRoID0gcHJvcHMuYmFzZVBhdGg7XG4gIGlmIChiYXNlUGF0aCkgX19ORVhUQVVUSC5iYXNlUGF0aCA9IGJhc2VQYXRoO1xuICB2YXIgaGFzSW5pdGlhbFNlc3Npb24gPSBwcm9wcy5zZXNzaW9uICE9PSB1bmRlZmluZWQ7XG4gIF9fTkVYVEFVVEguX2xhc3RTeW5jID0gaGFzSW5pdGlhbFNlc3Npb24gPyAoMCwgX3V0aWxzLm5vdykoKSA6IDA7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGFzSW5pdGlhbFNlc3Npb24pIF9fTkVYVEFVVEguX3Nlc3Npb24gPSBwcm9wcy5zZXNzaW9uO1xuICAgIHJldHVybiBwcm9wcy5zZXNzaW9uO1xuICB9KSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSAoMCwgX3NsaWNlZFRvQXJyYXkyLmRlZmF1bHQpKF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICBzZXNzaW9uID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldFNlc3Npb24gPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoIWhhc0luaXRpYWxTZXNzaW9uKSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTQgPSAoMCwgX3NsaWNlZFRvQXJyYXkyLmRlZmF1bHQpKF9SZWFjdCR1c2VTdGF0ZTMsIDIpLFxuICAgICAgbG9hZGluZyA9IF9SZWFjdCR1c2VTdGF0ZTRbMF0sXG4gICAgICBzZXRMb2FkaW5nID0gX1JlYWN0JHVzZVN0YXRlNFsxXTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIF9fTkVYVEFVVEguX2dldFNlc3Npb24gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgIHZhciBfcmVmNCxcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgICBzdG9yYWdlRXZlbnQsXG4gICAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfcmVmNCA9IF9hcmdzLmxlbmd0aCA+IDAgJiYgX2FyZ3NbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzBdIDoge30sIGV2ZW50ID0gX3JlZjQuZXZlbnQ7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuICAgICAgICAgICAgICBzdG9yYWdlRXZlbnQgPSBldmVudCA9PT0gXCJzdG9yYWdlXCI7XG5cbiAgICAgICAgICAgICAgaWYgKCEoc3RvcmFnZUV2ZW50IHx8IF9fTkVYVEFVVEguX3Nlc3Npb24gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfX05FWFRBVVRILl9sYXN0U3luYyA9ICgwLCBfdXRpbHMubm93KSgpO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuIGdldFNlc3Npb24oe1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdDogIXN0b3JhZ2VFdmVudFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfX05FWFRBVVRILl9zZXNzaW9uID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgc2V0U2Vzc2lvbihfX05FWFRBVVRILl9zZXNzaW9uKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgaWYgKCEoIWV2ZW50IHx8IF9fTkVYVEFVVEguX3Nlc3Npb24gPT09IG51bGwgfHwgKDAsIF91dGlscy5ub3cpKCkgPCBfX05FWFRBVVRILl9sYXN0U3luYykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBfX05FWFRBVVRILl9sYXN0U3luYyA9ICgwLCBfdXRpbHMubm93KSgpO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRTZXNzaW9uKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIF9fTkVYVEFVVEguX3Nlc3Npb24gPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBzZXRTZXNzaW9uKF9fTkVYVEFVVEguX3Nlc3Npb24pO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTk7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiQ0xJRU5UX1NFU1NJT05fRVJST1JcIiwgX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjI7XG4gICAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDIyKTtcblxuICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMSwgMTksIDIyLCAyNV1dKTtcbiAgICB9KSk7XG5cbiAgICBfX05FWFRBVVRILl9nZXRTZXNzaW9uKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgX19ORVhUQVVUSC5fbGFzdFN5bmMgPSAwO1xuICAgICAgX19ORVhUQVVUSC5fc2Vzc2lvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIH07XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdW5zdWJzY3JpYmUgPSBicm9hZGNhc3QucmVjZWl2ZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7XG4gICAgICAgIGV2ZW50OiBcInN0b3JhZ2VcIlxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB1bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3Byb3BzJHJlZmV0Y2hPbldpbmRvID0gcHJvcHMucmVmZXRjaE9uV2luZG93Rm9jdXMsXG4gICAgICAgIHJlZmV0Y2hPbldpbmRvd0ZvY3VzID0gX3Byb3BzJHJlZmV0Y2hPbldpbmRvID09PSB2b2lkIDAgPyB0cnVlIDogX3Byb3BzJHJlZmV0Y2hPbldpbmRvO1xuXG4gICAgdmFyIHZpc2liaWxpdHlIYW5kbGVyID0gZnVuY3Rpb24gdmlzaWJpbGl0eUhhbmRsZXIoKSB7XG4gICAgICBpZiAocmVmZXRjaE9uV2luZG93Rm9jdXMgJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIikgX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7XG4gICAgICAgIGV2ZW50OiBcInZpc2liaWxpdHljaGFuZ2VcIlxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHZpc2liaWxpdHlIYW5kbGVyLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB2aXNpYmlsaXR5SGFuZGxlciwgZmFsc2UpO1xuICAgIH07XG4gIH0sIFtwcm9wcy5yZWZldGNoT25XaW5kb3dGb2N1c10pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWZldGNoSW50ZXJ2YWwgPSBwcm9wcy5yZWZldGNoSW50ZXJ2YWw7XG5cbiAgICBpZiAocmVmZXRjaEludGVydmFsKSB7XG4gICAgICB2YXIgcmVmZXRjaEludGVydmFsVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfX05FWFRBVVRILl9zZXNzaW9uKSB7XG4gICAgICAgICAgX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7XG4gICAgICAgICAgICBldmVudDogXCJwb2xsXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgcmVmZXRjaEludGVydmFsICogMTAwMCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2xlYXJJbnRlcnZhbChyZWZldGNoSW50ZXJ2YWxUaW1lcik7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3Byb3BzLnJlZmV0Y2hJbnRlcnZhbF0pO1xuICB2YXIgdmFsdWUgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogc2Vzc2lvbixcbiAgICAgIHN0YXR1czogbG9hZGluZyA/IFwibG9hZGluZ1wiIDogc2Vzc2lvbiA/IFwiYXV0aGVudGljYXRlZFwiIDogXCJ1bmF1dGhlbnRpY2F0ZWRcIlxuICAgIH07XG4gIH0sIFtzZXNzaW9uLCBsb2FkaW5nXSk7XG4gIHJldHVybiAoMCwgX2pzeFJ1bnRpbWUuanN4KShTZXNzaW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59Il0sIm5hbWVzIjpbIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3R5cGVvZiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX2V4cG9ydE5hbWVzIiwidXNlU2Vzc2lvbiIsImdldFNlc3Npb24iLCJnZXRDc3JmVG9rZW4iLCJnZXRQcm92aWRlcnMiLCJzaWduSW4iLCJzaWduT3V0IiwiU2Vzc2lvblByb3ZpZGVyIiwiX3JlZ2VuZXJhdG9yIiwiX2RlZmluZVByb3BlcnR5MiIsIl9zbGljZWRUb0FycmF5MiIsIl9hc3luY1RvR2VuZXJhdG9yMiIsIlJlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfbG9nZ2VyMiIsIl9wYXJzZVVybCIsIl91dGlscyIsIl9qc3hSdW50aW1lIiwiX3R5cGVzIiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3Byb2Nlc3MkZW52JE5FWFRBVVRIIiwiX3JlZiIsIl9wcm9jZXNzJGVudiRORVhUQVVUSDIiLCJfcHJvY2VzcyRlbnYkTkVYVEFVVEgzIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwibm9kZUludGVyb3AiLCJXZWFrTWFwIiwiY2FjaGVCYWJlbEludGVyb3AiLCJjYWNoZU5vZGVJbnRlcm9wIiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJjYWNoZSIsImhhcyIsIm5ld09iaiIsImhhc1Byb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlc2MiLCJzZXQiLCJvd25LZXlzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9fTkVYVEFVVEgiLCJiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRBVVRIX1VSTCIsIlZFUkNFTF9VUkwiLCJvcmlnaW4iLCJiYXNlUGF0aCIsInBhdGgiLCJiYXNlVXJsU2VydmVyIiwiTkVYVEFVVEhfVVJMX0lOVEVSTkFMIiwiYmFzZVBhdGhTZXJ2ZXIiLCJfbGFzdFN5bmMiLCJfc2Vzc2lvbiIsInVuZGVmaW5lZCIsIl9nZXRTZXNzaW9uIiwiYnJvYWRjYXN0IiwiQnJvYWRjYXN0Q2hhbm5lbCIsImxvZ2dlciIsInByb3h5TG9nZ2VyIiwiU2Vzc2lvbkNvbnRleHQiLCJjcmVhdGVDb250ZXh0Iiwib3B0aW9ucyIsInVzZUNvbnRleHQiLCJOT0RFX0VOViIsIkVycm9yIiwiX3JlZjIiLCJyZXF1aXJlZCIsIm9uVW5hdXRoZW50aWNhdGVkIiwicmVxdWlyZWRBbmROb3RMb2FkaW5nIiwic3RhdHVzIiwidXNlRWZmZWN0IiwidXJsIiwiY29uY2F0IiwiVVJMU2VhcmNoUGFyYW1zIiwiZXJyb3IiLCJjYWxsYmFja1VybCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsImRhdGEiLCJfeCIsIl9nZXRTZXNzaW9uMiIsIm1hcmsiLCJfY2FsbGVlMiIsInBhcmFtcyIsIl9wYXJhbXMkYnJvYWRjYXN0Iiwic2Vzc2lvbiIsIndyYXAiLCJfY2FsbGVlMiQiLCJfY29udGV4dDIiLCJwcmV2IiwibmV4dCIsImZldGNoRGF0YSIsInNlbnQiLCJwb3N0IiwiZXZlbnQiLCJ0cmlnZ2VyIiwiYWJydXB0Iiwic3RvcCIsIl94MiIsIl9nZXRDc3JmVG9rZW4iLCJfY2FsbGVlMyIsInJlc3BvbnNlIiwiX2NhbGxlZTMkIiwiX2NvbnRleHQzIiwiY3NyZlRva2VuIiwiX2dldFByb3ZpZGVycyIsIl9jYWxsZWU0IiwiX2NhbGxlZTQkIiwiX2NvbnRleHQ0IiwiX3gzIiwiX3g0IiwiX3g1IiwiX3NpZ25JbiIsIl9jYWxsZWU1IiwicHJvdmlkZXIiLCJhdXRob3JpemF0aW9uUGFyYW1zIiwiX3JlZjUiLCJfcmVmNSRjYWxsYmFja1VybCIsIl9yZWY1JHJlZGlyZWN0IiwicmVkaXJlY3QiLCJwcm92aWRlcnMiLCJpc0NyZWRlbnRpYWxzIiwiaXNFbWFpbCIsImlzU3VwcG9ydGluZ1JldHVybiIsInNpZ25JblVybCIsIl9zaWduSW5VcmwiLCJyZXMiLCJfZGF0YSR1cmwiLCJfY2FsbGVlNSQiLCJfY29udGV4dDUiLCJhcGlCYXNlVXJsIiwidHlwZSIsInQwIiwiZmV0Y2giLCJ0MSIsInQyIiwidDMiLCJ0NCIsInQ1IiwidDYiLCJ0NyIsInQ4IiwidDkiLCJqc29uIiwidDEwIiwidDExIiwidDEyIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJpbmNsdWRlcyIsInJlbG9hZCIsIlVSTCIsInNlYXJjaFBhcmFtcyIsIm9rIiwiX3g2IiwiX3NpZ25PdXQiLCJfY2FsbGVlNiIsIl9vcHRpb25zJHJlZGlyZWN0IiwiX3JlZjYiLCJfcmVmNiRjYWxsYmFja1VybCIsImZldGNoT3B0aW9ucyIsIl9kYXRhJHVybDIiLCJfY2FsbGVlNiQiLCJfY29udGV4dDYiLCJwcm9wcyIsImNoaWxkcmVuIiwiaGFzSW5pdGlhbFNlc3Npb24iLCJub3ciLCJfUmVhY3QkdXNlU3RhdGUiLCJ1c2VTdGF0ZSIsIl9SZWFjdCR1c2VTdGF0ZTIiLCJzZXRTZXNzaW9uIiwiX1JlYWN0JHVzZVN0YXRlMyIsIl9SZWFjdCR1c2VTdGF0ZTQiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsIl9jYWxsZWUiLCJfcmVmNCIsInN0b3JhZ2VFdmVudCIsIl9hcmdzIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsImZpbmlzaCIsInVuc3Vic2NyaWJlIiwicmVjZWl2ZSIsIl9wcm9wcyRyZWZldGNoT25XaW5kbyIsInJlZmV0Y2hPbldpbmRvd0ZvY3VzIiwidmlzaWJpbGl0eUhhbmRsZXIiLCJkb2N1bWVudCIsInZpc2liaWxpdHlTdGF0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVmZXRjaEludGVydmFsIiwicmVmZXRjaEludGVydmFsVGltZXIiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJ1c2VNZW1vIiwianN4IiwiUHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next-auth/react/index.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/react/types.js":
/*!***********************************************!*\
  !*** ./node_modules/next-auth/react/types.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0L3R5cGVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViQSw4Q0FBNkM7RUFDM0NHLEtBQUssRUFBRTtBQURvQyxDQUE3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0L3R5cGVzLmpzPzFlNWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next-auth/react/types.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/utils/logger.js":
/*!************************************************!*\
  !*** ./node_modules/next-auth/utils/logger.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nexports.proxyLogger = proxyLogger;\nexports.setLogger = setLogger;\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _errors = __webpack_require__(/*! ../core/errors */ \"./node_modules/next-auth/core/errors.js\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction formatError(o) {\n  if (o instanceof Error && !(o instanceof _errors.UnknownError)) {\n    return {\n      message: o.message,\n      stack: o.stack,\n      name: o.name\n    };\n  }\n\n  if (hasErrorProperty(o)) {\n    var _o$message;\n\n    o.error = formatError(o.error);\n    o.message = (_o$message = o.message) !== null && _o$message !== void 0 ? _o$message : o.error.message;\n  }\n\n  return o;\n}\n\nfunction hasErrorProperty(x) {\n  return !!(x !== null && x !== void 0 && x.error);\n}\n\nvar _logger = {\n  error: function error(code, metadata) {\n    metadata = formatError(metadata);\n    console.error(\"[next-auth][error][\".concat(code, \"]\"), \"\\nhttps://next-auth.js.org/errors#\".concat(code.toLowerCase()), metadata.message, metadata);\n  },\n  warn: function warn(code) {\n    console.warn(\"[next-auth][warn][\".concat(code, \"]\"), \"\\nhttps://next-auth.js.org/warnings#\".concat(code.toLowerCase()));\n  },\n  debug: function debug(code, metadata) {\n    console.log(\"[next-auth][debug][\".concat(code, \"]\"), metadata);\n  }\n};\n\nfunction setLogger() {\n  var newLogger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var debug = arguments.length > 1 ? arguments[1] : undefined;\n  if (!debug) _logger.debug = function () {};\n  if (newLogger.error) _logger.error = newLogger.error;\n  if (newLogger.warn) _logger.warn = newLogger.warn;\n  if (newLogger.debug) _logger.debug = newLogger.debug;\n}\n\nvar _default = _logger;\nexports[\"default\"] = _default;\n\nfunction proxyLogger() {\n  var logger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _logger;\n  var basePath = arguments.length > 1 ? arguments[1] : undefined;\n\n  try {\n    if (typeof window === \"undefined\") {\n      return logger;\n    }\n\n    var clientLogger = {};\n\n    var _loop = function _loop(level) {\n      clientLogger[level] = function (code, metadata) {\n        _logger[level](code, metadata);\n\n        if (level === \"error\") {\n          metadata = formatError(metadata);\n        }\n\n        ;\n        metadata.client = true;\n        var url = \"\".concat(basePath, \"/_log\");\n        var body = new URLSearchParams(_objectSpread({\n          level: level,\n          code: code\n        }, metadata));\n\n        if (navigator.sendBeacon) {\n          return navigator.sendBeacon(url, body);\n        }\n\n        return fetch(url, {\n          method: \"POST\",\n          body: body,\n          keepalive: true\n        });\n      };\n    };\n\n    for (var level in logger) {\n      _loop(level);\n    }\n\n    return clientLogger;\n  } catch (_unused) {\n    return _logger;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3V0aWxzL2xvZ2dlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJQSxzQkFBc0IsR0FBR0MsbUJBQU8sQ0FBQyxvSEFBRCxDQUFwQzs7QUFFQUMsOENBQTZDO0VBQzNDRyxLQUFLLEVBQUU7QUFEb0MsQ0FBN0M7QUFHQUQsa0JBQUEsR0FBa0IsS0FBSyxDQUF2QjtBQUNBQSxtQkFBQSxHQUFzQkcsV0FBdEI7QUFDQUgsaUJBQUEsR0FBb0JJLFNBQXBCOztBQUVBLElBQUlDLGdCQUFnQixHQUFHVCxzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxzR0FBRCxDQUFSLENBQTdDOztBQUVBLElBQUlTLE9BQU8sR0FBR1QsbUJBQU8sQ0FBQywrREFBRCxDQUFyQjs7QUFFQSxTQUFTVSxPQUFULENBQWlCQyxNQUFqQixFQUF5QkMsY0FBekIsRUFBeUM7RUFBRSxJQUFJQyxJQUFJLEdBQUdaLE1BQU0sQ0FBQ1ksSUFBUCxDQUFZRixNQUFaLENBQVg7O0VBQWdDLElBQUlWLE1BQU0sQ0FBQ2EscUJBQVgsRUFBa0M7SUFBRSxJQUFJQyxPQUFPLEdBQUdkLE1BQU0sQ0FBQ2EscUJBQVAsQ0FBNkJILE1BQTdCLENBQWQ7SUFBb0RDLGNBQWMsS0FBS0csT0FBTyxHQUFHQSxPQUFPLENBQUNDLE1BQVIsQ0FBZSxVQUFVQyxHQUFWLEVBQWU7TUFBRSxPQUFPaEIsTUFBTSxDQUFDaUIsd0JBQVAsQ0FBZ0NQLE1BQWhDLEVBQXdDTSxHQUF4QyxFQUE2Q0UsVUFBcEQ7SUFBaUUsQ0FBakcsQ0FBZixDQUFkLEVBQWtJTixJQUFJLENBQUNPLElBQUwsQ0FBVUMsS0FBVixDQUFnQlIsSUFBaEIsRUFBc0JFLE9BQXRCLENBQWxJO0VBQW1LOztFQUFDLE9BQU9GLElBQVA7QUFBYzs7QUFFclYsU0FBU1MsYUFBVCxDQUF1QkMsTUFBdkIsRUFBK0I7RUFBRSxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdDLFNBQVMsQ0FBQ0MsTUFBOUIsRUFBc0NGLENBQUMsRUFBdkMsRUFBMkM7SUFBRSxJQUFJRyxNQUFNLEdBQUcsUUFBUUYsU0FBUyxDQUFDRCxDQUFELENBQWpCLEdBQXVCQyxTQUFTLENBQUNELENBQUQsQ0FBaEMsR0FBc0MsRUFBbkQ7SUFBdURBLENBQUMsR0FBRyxDQUFKLEdBQVFkLE9BQU8sQ0FBQ1QsTUFBTSxDQUFDMEIsTUFBRCxDQUFQLEVBQWlCLENBQUMsQ0FBbEIsQ0FBUCxDQUE0QkMsT0FBNUIsQ0FBb0MsVUFBVUMsR0FBVixFQUFlO01BQUUsQ0FBQyxHQUFHckIsZ0JBQWdCLENBQUNILE9BQXJCLEVBQThCa0IsTUFBOUIsRUFBc0NNLEdBQXRDLEVBQTJDRixNQUFNLENBQUNFLEdBQUQsQ0FBakQ7SUFBMEQsQ0FBL0csQ0FBUixHQUEySDVCLE1BQU0sQ0FBQzZCLHlCQUFQLEdBQW1DN0IsTUFBTSxDQUFDOEIsZ0JBQVAsQ0FBd0JSLE1BQXhCLEVBQWdDdEIsTUFBTSxDQUFDNkIseUJBQVAsQ0FBaUNILE1BQWpDLENBQWhDLENBQW5DLEdBQStHakIsT0FBTyxDQUFDVCxNQUFNLENBQUMwQixNQUFELENBQVAsQ0FBUCxDQUF3QkMsT0FBeEIsQ0FBZ0MsVUFBVUMsR0FBVixFQUFlO01BQUU1QixNQUFNLENBQUNDLGNBQVAsQ0FBc0JxQixNQUF0QixFQUE4Qk0sR0FBOUIsRUFBbUM1QixNQUFNLENBQUNpQix3QkFBUCxDQUFnQ1MsTUFBaEMsRUFBd0NFLEdBQXhDLENBQW5DO0lBQW1GLENBQXBJLENBQTFPO0VBQWtYOztFQUFDLE9BQU9OLE1BQVA7QUFBZ0I7O0FBRXhnQixTQUFTUyxXQUFULENBQXFCQyxDQUFyQixFQUF3QjtFQUN0QixJQUFJQSxDQUFDLFlBQVlDLEtBQWIsSUFBc0IsRUFBRUQsQ0FBQyxZQUFZeEIsT0FBTyxDQUFDMEIsWUFBdkIsQ0FBMUIsRUFBZ0U7SUFDOUQsT0FBTztNQUNMQyxPQUFPLEVBQUVILENBQUMsQ0FBQ0csT0FETjtNQUVMQyxLQUFLLEVBQUVKLENBQUMsQ0FBQ0ksS0FGSjtNQUdMQyxJQUFJLEVBQUVMLENBQUMsQ0FBQ0s7SUFISCxDQUFQO0VBS0Q7O0VBRUQsSUFBSUMsZ0JBQWdCLENBQUNOLENBQUQsQ0FBcEIsRUFBeUI7SUFDdkIsSUFBSU8sVUFBSjs7SUFFQVAsQ0FBQyxDQUFDUSxLQUFGLEdBQVVULFdBQVcsQ0FBQ0MsQ0FBQyxDQUFDUSxLQUFILENBQXJCO0lBQ0FSLENBQUMsQ0FBQ0csT0FBRixHQUFZLENBQUNJLFVBQVUsR0FBR1AsQ0FBQyxDQUFDRyxPQUFoQixNQUE2QixJQUE3QixJQUFxQ0ksVUFBVSxLQUFLLEtBQUssQ0FBekQsR0FBNkRBLFVBQTdELEdBQTBFUCxDQUFDLENBQUNRLEtBQUYsQ0FBUUwsT0FBOUY7RUFDRDs7RUFFRCxPQUFPSCxDQUFQO0FBQ0Q7O0FBRUQsU0FBU00sZ0JBQVQsQ0FBMEJHLENBQTFCLEVBQTZCO0VBQzNCLE9BQU8sQ0FBQyxFQUFFQSxDQUFDLEtBQUssSUFBTixJQUFjQSxDQUFDLEtBQUssS0FBSyxDQUF6QixJQUE4QkEsQ0FBQyxDQUFDRCxLQUFsQyxDQUFSO0FBQ0Q7O0FBRUQsSUFBSUUsT0FBTyxHQUFHO0VBQ1pGLEtBQUssRUFBRSxTQUFTQSxLQUFULENBQWVHLElBQWYsRUFBcUJDLFFBQXJCLEVBQStCO0lBQ3BDQSxRQUFRLEdBQUdiLFdBQVcsQ0FBQ2EsUUFBRCxDQUF0QjtJQUNBQyxPQUFPLENBQUNMLEtBQVIsQ0FBYyxzQkFBc0JNLE1BQXRCLENBQTZCSCxJQUE3QixFQUFtQyxHQUFuQyxDQUFkLEVBQXVELHFDQUFxQ0csTUFBckMsQ0FBNENILElBQUksQ0FBQ0ksV0FBTCxFQUE1QyxDQUF2RCxFQUF3SEgsUUFBUSxDQUFDVCxPQUFqSSxFQUEwSVMsUUFBMUk7RUFDRCxDQUpXO0VBS1pJLElBQUksRUFBRSxTQUFTQSxJQUFULENBQWNMLElBQWQsRUFBb0I7SUFDeEJFLE9BQU8sQ0FBQ0csSUFBUixDQUFhLHFCQUFxQkYsTUFBckIsQ0FBNEJILElBQTVCLEVBQWtDLEdBQWxDLENBQWIsRUFBcUQsdUNBQXVDRyxNQUF2QyxDQUE4Q0gsSUFBSSxDQUFDSSxXQUFMLEVBQTlDLENBQXJEO0VBQ0QsQ0FQVztFQVFaRSxLQUFLLEVBQUUsU0FBU0EsS0FBVCxDQUFlTixJQUFmLEVBQXFCQyxRQUFyQixFQUErQjtJQUNwQ0MsT0FBTyxDQUFDSyxHQUFSLENBQVksc0JBQXNCSixNQUF0QixDQUE2QkgsSUFBN0IsRUFBbUMsR0FBbkMsQ0FBWixFQUFxREMsUUFBckQ7RUFDRDtBQVZXLENBQWQ7O0FBYUEsU0FBU3RDLFNBQVQsR0FBcUI7RUFDbkIsSUFBSTZDLFNBQVMsR0FBRzNCLFNBQVMsQ0FBQ0MsTUFBVixHQUFtQixDQUFuQixJQUF3QkQsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjRCLFNBQXpDLEdBQXFENUIsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsRUFBcEY7RUFDQSxJQUFJeUIsS0FBSyxHQUFHekIsU0FBUyxDQUFDQyxNQUFWLEdBQW1CLENBQW5CLEdBQXVCRCxTQUFTLENBQUMsQ0FBRCxDQUFoQyxHQUFzQzRCLFNBQWxEO0VBQ0EsSUFBSSxDQUFDSCxLQUFMLEVBQVlQLE9BQU8sQ0FBQ08sS0FBUixHQUFnQixZQUFZLENBQUUsQ0FBOUI7RUFDWixJQUFJRSxTQUFTLENBQUNYLEtBQWQsRUFBcUJFLE9BQU8sQ0FBQ0YsS0FBUixHQUFnQlcsU0FBUyxDQUFDWCxLQUExQjtFQUNyQixJQUFJVyxTQUFTLENBQUNILElBQWQsRUFBb0JOLE9BQU8sQ0FBQ00sSUFBUixHQUFlRyxTQUFTLENBQUNILElBQXpCO0VBQ3BCLElBQUlHLFNBQVMsQ0FBQ0YsS0FBZCxFQUFxQlAsT0FBTyxDQUFDTyxLQUFSLEdBQWdCRSxTQUFTLENBQUNGLEtBQTFCO0FBQ3RCOztBQUVELElBQUlJLFFBQVEsR0FBR1gsT0FBZjtBQUNBeEMsa0JBQUEsR0FBa0JtRCxRQUFsQjs7QUFFQSxTQUFTaEQsV0FBVCxHQUF1QjtFQUNyQixJQUFJaUQsTUFBTSxHQUFHOUIsU0FBUyxDQUFDQyxNQUFWLEdBQW1CLENBQW5CLElBQXdCRCxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCNEIsU0FBekMsR0FBcUQ1QixTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRWtCLE9BQWpGO0VBQ0EsSUFBSWEsUUFBUSxHQUFHL0IsU0FBUyxDQUFDQyxNQUFWLEdBQW1CLENBQW5CLEdBQXVCRCxTQUFTLENBQUMsQ0FBRCxDQUFoQyxHQUFzQzRCLFNBQXJEOztFQUVBLElBQUk7SUFDRixJQUFJLE9BQU9JLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7TUFDakMsT0FBT0YsTUFBUDtJQUNEOztJQUVELElBQUlHLFlBQVksR0FBRyxFQUFuQjs7SUFFQSxJQUFJQyxLQUFLLEdBQUcsU0FBU0EsS0FBVCxDQUFlQyxLQUFmLEVBQXNCO01BQ2hDRixZQUFZLENBQUNFLEtBQUQsQ0FBWixHQUFzQixVQUFVaEIsSUFBVixFQUFnQkMsUUFBaEIsRUFBMEI7UUFDOUNGLE9BQU8sQ0FBQ2lCLEtBQUQsQ0FBUCxDQUFlaEIsSUFBZixFQUFxQkMsUUFBckI7O1FBRUEsSUFBSWUsS0FBSyxLQUFLLE9BQWQsRUFBdUI7VUFDckJmLFFBQVEsR0FBR2IsV0FBVyxDQUFDYSxRQUFELENBQXRCO1FBQ0Q7O1FBRUQ7UUFDQUEsUUFBUSxDQUFDZ0IsTUFBVCxHQUFrQixJQUFsQjtRQUNBLElBQUlDLEdBQUcsR0FBRyxHQUFHZixNQUFILENBQVVTLFFBQVYsRUFBb0IsT0FBcEIsQ0FBVjtRQUNBLElBQUlPLElBQUksR0FBRyxJQUFJQyxlQUFKLENBQW9CMUMsYUFBYSxDQUFDO1VBQzNDc0MsS0FBSyxFQUFFQSxLQURvQztVQUUzQ2hCLElBQUksRUFBRUE7UUFGcUMsQ0FBRCxFQUd6Q0MsUUFIeUMsQ0FBakMsQ0FBWDs7UUFLQSxJQUFJb0IsU0FBUyxDQUFDQyxVQUFkLEVBQTBCO1VBQ3hCLE9BQU9ELFNBQVMsQ0FBQ0MsVUFBVixDQUFxQkosR0FBckIsRUFBMEJDLElBQTFCLENBQVA7UUFDRDs7UUFFRCxPQUFPSSxLQUFLLENBQUNMLEdBQUQsRUFBTTtVQUNoQk0sTUFBTSxFQUFFLE1BRFE7VUFFaEJMLElBQUksRUFBRUEsSUFGVTtVQUdoQk0sU0FBUyxFQUFFO1FBSEssQ0FBTixDQUFaO01BS0QsQ0F4QkQ7SUF5QkQsQ0ExQkQ7O0lBNEJBLEtBQUssSUFBSVQsS0FBVCxJQUFrQkwsTUFBbEIsRUFBMEI7TUFDeEJJLEtBQUssQ0FBQ0MsS0FBRCxDQUFMO0lBQ0Q7O0lBRUQsT0FBT0YsWUFBUDtFQUNELENBeENELENBd0NFLE9BQU9ZLE9BQVAsRUFBZ0I7SUFDaEIsT0FBTzNCLE9BQVA7RUFDRDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvdXRpbHMvbG9nZ2VyLmpzP2YyOTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuZXhwb3J0cy5wcm94eUxvZ2dlciA9IHByb3h5TG9nZ2VyO1xuZXhwb3J0cy5zZXRMb2dnZXIgPSBzZXRMb2dnZXI7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfZXJyb3JzID0gcmVxdWlyZShcIi4uL2NvcmUvZXJyb3JzXCIpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBFcnJvciAmJiAhKG8gaW5zdGFuY2VvZiBfZXJyb3JzLlVua25vd25FcnJvcikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogby5tZXNzYWdlLFxuICAgICAgc3RhY2s6IG8uc3RhY2ssXG4gICAgICBuYW1lOiBvLm5hbWVcbiAgICB9O1xuICB9XG5cbiAgaWYgKGhhc0Vycm9yUHJvcGVydHkobykpIHtcbiAgICB2YXIgX28kbWVzc2FnZTtcblxuICAgIG8uZXJyb3IgPSBmb3JtYXRFcnJvcihvLmVycm9yKTtcbiAgICBvLm1lc3NhZ2UgPSAoX28kbWVzc2FnZSA9IG8ubWVzc2FnZSkgIT09IG51bGwgJiYgX28kbWVzc2FnZSAhPT0gdm9pZCAwID8gX28kbWVzc2FnZSA6IG8uZXJyb3IubWVzc2FnZTtcbiAgfVxuXG4gIHJldHVybiBvO1xufVxuXG5mdW5jdGlvbiBoYXNFcnJvclByb3BlcnR5KHgpIHtcbiAgcmV0dXJuICEhKHggIT09IG51bGwgJiYgeCAhPT0gdm9pZCAwICYmIHguZXJyb3IpO1xufVxuXG52YXIgX2xvZ2dlciA9IHtcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKGNvZGUsIG1ldGFkYXRhKSB7XG4gICAgbWV0YWRhdGEgPSBmb3JtYXRFcnJvcihtZXRhZGF0YSk7XG4gICAgY29uc29sZS5lcnJvcihcIltuZXh0LWF1dGhdW2Vycm9yXVtcIi5jb25jYXQoY29kZSwgXCJdXCIpLCBcIlxcbmh0dHBzOi8vbmV4dC1hdXRoLmpzLm9yZy9lcnJvcnMjXCIuY29uY2F0KGNvZGUudG9Mb3dlckNhc2UoKSksIG1ldGFkYXRhLm1lc3NhZ2UsIG1ldGFkYXRhKTtcbiAgfSxcbiAgd2FybjogZnVuY3Rpb24gd2Fybihjb2RlKSB7XG4gICAgY29uc29sZS53YXJuKFwiW25leHQtYXV0aF1bd2Fybl1bXCIuY29uY2F0KGNvZGUsIFwiXVwiKSwgXCJcXG5odHRwczovL25leHQtYXV0aC5qcy5vcmcvd2FybmluZ3MjXCIuY29uY2F0KGNvZGUudG9Mb3dlckNhc2UoKSkpO1xuICB9LFxuICBkZWJ1ZzogZnVuY3Rpb24gZGVidWcoY29kZSwgbWV0YWRhdGEpIHtcbiAgICBjb25zb2xlLmxvZyhcIltuZXh0LWF1dGhdW2RlYnVnXVtcIi5jb25jYXQoY29kZSwgXCJdXCIpLCBtZXRhZGF0YSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldExvZ2dlcigpIHtcbiAgdmFyIG5ld0xvZ2dlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICBpZiAoIWRlYnVnKSBfbG9nZ2VyLmRlYnVnID0gZnVuY3Rpb24gKCkge307XG4gIGlmIChuZXdMb2dnZXIuZXJyb3IpIF9sb2dnZXIuZXJyb3IgPSBuZXdMb2dnZXIuZXJyb3I7XG4gIGlmIChuZXdMb2dnZXIud2FybikgX2xvZ2dlci53YXJuID0gbmV3TG9nZ2VyLndhcm47XG4gIGlmIChuZXdMb2dnZXIuZGVidWcpIF9sb2dnZXIuZGVidWcgPSBuZXdMb2dnZXIuZGVidWc7XG59XG5cbnZhciBfZGVmYXVsdCA9IF9sb2dnZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcblxuZnVuY3Rpb24gcHJveHlMb2dnZXIoKSB7XG4gIHZhciBsb2dnZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9sb2dnZXI7XG4gIHZhciBiYXNlUGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfVxuXG4gICAgdmFyIGNsaWVudExvZ2dlciA9IHt9O1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AobGV2ZWwpIHtcbiAgICAgIGNsaWVudExvZ2dlcltsZXZlbF0gPSBmdW5jdGlvbiAoY29kZSwgbWV0YWRhdGEpIHtcbiAgICAgICAgX2xvZ2dlcltsZXZlbF0oY29kZSwgbWV0YWRhdGEpO1xuXG4gICAgICAgIGlmIChsZXZlbCA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgbWV0YWRhdGEgPSBmb3JtYXRFcnJvcihtZXRhZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICA7XG4gICAgICAgIG1ldGFkYXRhLmNsaWVudCA9IHRydWU7XG4gICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChiYXNlUGF0aCwgXCIvX2xvZ1wiKTtcbiAgICAgICAgdmFyIGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgICBjb2RlOiBjb2RlXG4gICAgICAgIH0sIG1ldGFkYXRhKSk7XG5cbiAgICAgICAgaWYgKG5hdmlnYXRvci5zZW5kQmVhY29uKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5zZW5kQmVhY29uKHVybCwgYm9keSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgIGtlZXBhbGl2ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZvciAodmFyIGxldmVsIGluIGxvZ2dlcikge1xuICAgICAgX2xvb3AobGV2ZWwpO1xuICAgIH1cblxuICAgIHJldHVybiBjbGllbnRMb2dnZXI7XG4gIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICByZXR1cm4gX2xvZ2dlcjtcbiAgfVxufSJdLCJuYW1lcyI6WyJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsInByb3h5TG9nZ2VyIiwic2V0TG9nZ2VyIiwiX2RlZmluZVByb3BlcnR5MiIsIl9lcnJvcnMiLCJvd25LZXlzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImZvckVhY2giLCJrZXkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImZvcm1hdEVycm9yIiwibyIsIkVycm9yIiwiVW5rbm93bkVycm9yIiwibWVzc2FnZSIsInN0YWNrIiwibmFtZSIsImhhc0Vycm9yUHJvcGVydHkiLCJfbyRtZXNzYWdlIiwiZXJyb3IiLCJ4IiwiX2xvZ2dlciIsImNvZGUiLCJtZXRhZGF0YSIsImNvbnNvbGUiLCJjb25jYXQiLCJ0b0xvd2VyQ2FzZSIsIndhcm4iLCJkZWJ1ZyIsImxvZyIsIm5ld0xvZ2dlciIsInVuZGVmaW5lZCIsIl9kZWZhdWx0IiwibG9nZ2VyIiwiYmFzZVBhdGgiLCJ3aW5kb3ciLCJjbGllbnRMb2dnZXIiLCJfbG9vcCIsImxldmVsIiwiY2xpZW50IiwidXJsIiwiYm9keSIsIlVSTFNlYXJjaFBhcmFtcyIsIm5hdmlnYXRvciIsInNlbmRCZWFjb24iLCJmZXRjaCIsIm1ldGhvZCIsImtlZXBhbGl2ZSIsIl91bnVzZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next-auth/utils/logger.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/utils/parse-url.js":
/*!***************************************************!*\
  !*** ./node_modules/next-auth/utils/parse-url.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = parseUrl;\n\nfunction parseUrl(url) {\n  var _url2;\n\n  const defaultUrl = new URL(\"http://localhost:3000/api/auth\");\n\n  if (url && !url.startsWith(\"http\")) {\n    url = `https://${url}`;\n  }\n\n  const _url = new URL((_url2 = url) !== null && _url2 !== void 0 ? _url2 : defaultUrl);\n\n  const path = (_url.pathname === \"/\" ? defaultUrl.pathname : _url.pathname).replace(/\\/$/, \"\");\n  const base = `${_url.origin}${path}`;\n  return {\n    origin: _url.origin,\n    host: _url.host,\n    path,\n    base,\n    toString: () => base\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3V0aWxzL3BhcnNlLXVybC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYkEsOENBQTZDO0VBQzNDRyxLQUFLLEVBQUU7QUFEb0MsQ0FBN0M7QUFHQUQsa0JBQUEsR0FBa0JHLFFBQWxCOztBQUVBLFNBQVNBLFFBQVQsQ0FBa0JDLEdBQWxCLEVBQXVCO0VBQ3JCLElBQUlDLEtBQUo7O0VBRUEsTUFBTUMsVUFBVSxHQUFHLElBQUlDLEdBQUosQ0FBUSxnQ0FBUixDQUFuQjs7RUFFQSxJQUFJSCxHQUFHLElBQUksQ0FBQ0EsR0FBRyxDQUFDSSxVQUFKLENBQWUsTUFBZixDQUFaLEVBQW9DO0lBQ2xDSixHQUFHLEdBQUksV0FBVUEsR0FBSSxFQUFyQjtFQUNEOztFQUVELE1BQU1LLElBQUksR0FBRyxJQUFJRixHQUFKLENBQVEsQ0FBQ0YsS0FBSyxHQUFHRCxHQUFULE1BQWtCLElBQWxCLElBQTBCQyxLQUFLLEtBQUssS0FBSyxDQUF6QyxHQUE2Q0EsS0FBN0MsR0FBcURDLFVBQTdELENBQWI7O0VBRUEsTUFBTUksSUFBSSxHQUFHLENBQUNELElBQUksQ0FBQ0UsUUFBTCxLQUFrQixHQUFsQixHQUF3QkwsVUFBVSxDQUFDSyxRQUFuQyxHQUE4Q0YsSUFBSSxDQUFDRSxRQUFwRCxFQUE4REMsT0FBOUQsQ0FBc0UsS0FBdEUsRUFBNkUsRUFBN0UsQ0FBYjtFQUNBLE1BQU1DLElBQUksR0FBSSxHQUFFSixJQUFJLENBQUNLLE1BQU8sR0FBRUosSUFBSyxFQUFuQztFQUNBLE9BQU87SUFDTEksTUFBTSxFQUFFTCxJQUFJLENBQUNLLE1BRFI7SUFFTEMsSUFBSSxFQUFFTixJQUFJLENBQUNNLElBRk47SUFHTEwsSUFISztJQUlMRyxJQUpLO0lBS0xHLFFBQVEsRUFBRSxNQUFNSDtFQUxYLENBQVA7QUFPRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3V0aWxzL3BhcnNlLXVybC5qcz9jMzM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VVcmw7XG5cbmZ1bmN0aW9uIHBhcnNlVXJsKHVybCkge1xuICB2YXIgX3VybDI7XG5cbiAgY29uc3QgZGVmYXVsdFVybCA9IG5ldyBVUkwoXCJodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGhcIik7XG5cbiAgaWYgKHVybCAmJiAhdXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgdXJsID0gYGh0dHBzOi8vJHt1cmx9YDtcbiAgfVxuXG4gIGNvbnN0IF91cmwgPSBuZXcgVVJMKChfdXJsMiA9IHVybCkgIT09IG51bGwgJiYgX3VybDIgIT09IHZvaWQgMCA/IF91cmwyIDogZGVmYXVsdFVybCk7XG5cbiAgY29uc3QgcGF0aCA9IChfdXJsLnBhdGhuYW1lID09PSBcIi9cIiA/IGRlZmF1bHRVcmwucGF0aG5hbWUgOiBfdXJsLnBhdGhuYW1lKS5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gIGNvbnN0IGJhc2UgPSBgJHtfdXJsLm9yaWdpbn0ke3BhdGh9YDtcbiAgcmV0dXJuIHtcbiAgICBvcmlnaW46IF91cmwub3JpZ2luLFxuICAgIGhvc3Q6IF91cmwuaG9zdCxcbiAgICBwYXRoLFxuICAgIGJhc2UsXG4gICAgdG9TdHJpbmc6ICgpID0+IGJhc2VcbiAgfTtcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwicGFyc2VVcmwiLCJ1cmwiLCJfdXJsMiIsImRlZmF1bHRVcmwiLCJVUkwiLCJzdGFydHNXaXRoIiwiX3VybCIsInBhdGgiLCJwYXRobmFtZSIsInJlcGxhY2UiLCJiYXNlIiwib3JpZ2luIiwiaG9zdCIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next-auth/utils/parse-url.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar ref, ref1;\nmodule.exports = ((ref = __webpack_require__.g.process) == null ? void 0 : ref.env) && typeof ((ref1 = __webpack_require__.g.process) == null ? void 0 : ref1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! ../../compiled/process */ \"./node_modules/next/dist/compiled/process/browser.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBQTs7SUFDRUMsS0FBOEJBO0FBRGhDRCxNQUFNLENBQUNFLE9BQVBGLEdBQ0VDLEtBQWMsR0FBZEEscUJBQU0sQ0FBQ0UsT0FBUEYsS0FBYyxJQUFkQSxlQUFjLENBQUVHLEdBQWhCSCxLQUF1QixRQUFPQSxLQUFjLEdBQWRBLHFCQUFNLENBQUNFLE9BQVBGLEtBQWMsSUFBZEEsZ0JBQWMsQ0FBRUcsR0FBdkIsTUFBK0IsUUFBdERILEdBQ0lBLHFCQUFNLENBQUNFLE9BRFhGLEdBRUlJLG1CQUFPLENBQUMsb0ZBQUQsQ0FIYkwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzPzkyOWIiXSwibmFtZXMiOlsibW9kdWxlIiwiZ2xvYmFsIiwiZXhwb3J0cyIsInByb2Nlc3MiLCJlbnYiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function (useSourceMap) {\n  var list = [] // return the list of modules as css string\n  ;\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  } // import a list of modules into the list\n  ; // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \"\" // eslint-disable-next-line prefer-destructuring\n  ;\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \"function\") {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFNQUE7QUFOQTs7OztBQUlBO0FBQ0E7O0FBQ0FBLE1BQU0sQ0FBQ0MsT0FBUEQsR0FBaUIsVUFBVUUsWUFBVixFQUF3QjtFQUN2QyxJQUFJQyxJQUFJLEdBQUcsRUFBWCxDQUFjO0VBQWQ7O0VBRUFBLElBQUksQ0FBQ0MsUUFBTEQsR0FBZ0IsU0FBU0MsUUFBVCxHQUFvQjtJQUNsQyxPQUFPLEtBQUtDLEdBQUwsQ0FBUyxVQUFVQyxJQUFWLEVBQWdCO01BQzlCLElBQUlDLE9BQU8sR0FBR0Msc0JBQXNCLENBQUNGLElBQUQsRUFBT0osWUFBUCxDQUFwQzs7TUFFQSxJQUFJSSxJQUFJLENBQUMsQ0FBRCxDQUFSLEVBQWE7UUFDWCxPQUFPLFVBQVVHLE1BQVYsQ0FBaUJILElBQUksQ0FBQyxDQUFELENBQXJCLEVBQTBCLElBQTFCLEVBQWdDRyxNQUFoQyxDQUF1Q0YsT0FBdkMsRUFBZ0QsR0FBaEQsQ0FBUDtNQUNEOztNQUVELE9BQU9BLE9BQVA7SUFDRCxDQVJNLEVBUUpHLElBUkksQ0FRQyxFQVJELENBQVA7RUFTRCxDQVZEUCxDQVVFO0VBVkZBLENBSHVDLENBY3ZDOzs7RUFFQUEsSUFBSSxDQUFDUSxDQUFMUixHQUFTLFVBQVVTLE9BQVYsRUFBbUJDLFVBQW5CLEVBQStCQyxNQUEvQixFQUF1QztJQUM5QyxJQUFJLE9BQU9GLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7TUFDL0I7TUFDQUEsT0FBTyxHQUFHLENBQUMsQ0FBQyxJQUFELEVBQU9BLE9BQVAsRUFBZ0IsRUFBaEIsQ0FBRCxDQUFWQTtJQUNEOztJQUVELElBQUlHLHNCQUFzQixHQUFHLEVBQTdCOztJQUVBLElBQUlELE1BQUosRUFBWTtNQUNWLEtBQUssSUFBSUgsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLSyxNQUF6QixFQUFpQ0wsQ0FBQyxFQUFsQyxFQUFzQztRQUNwQztRQUNBLElBQUlNLEVBQUUsR0FBRyxLQUFLTixDQUFMLEVBQVEsQ0FBUixDQUFUOztRQUVBLElBQUlNLEVBQUUsSUFBSSxJQUFWLEVBQWdCO1VBQ2RGLHNCQUFzQixDQUFDRSxFQUFELENBQXRCRixHQUE2QixJQUE3QkE7UUFDRDtNQUNGO0lBQ0Y7O0lBRUQsS0FBSyxJQUFJRyxFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxHQUFHTixPQUFPLENBQUNJLE1BQTlCLEVBQXNDRSxFQUFFLEVBQXhDLEVBQTRDO01BQzFDLElBQUlaLElBQUksR0FBRyxHQUFHRyxNQUFILENBQVVHLE9BQU8sQ0FBQ00sRUFBRCxDQUFqQixDQUFYOztNQUVBLElBQUlKLE1BQU0sSUFBSUMsc0JBQXNCLENBQUNULElBQUksQ0FBQyxDQUFELENBQUwsQ0FBcEMsRUFBK0M7UUFFN0M7TUFDRDs7TUFFRCxJQUFJTyxVQUFKLEVBQWdCO1FBQ2QsSUFBSSxDQUFDUCxJQUFJLENBQUMsQ0FBRCxDQUFULEVBQWM7VUFDWkEsSUFBSSxDQUFDLENBQUQsQ0FBSkEsR0FBVU8sVUFBVlA7UUFDRCxDQUZELE1BRU87VUFDTEEsSUFBSSxDQUFDLENBQUQsQ0FBSkEsR0FBVSxHQUFHRyxNQUFILENBQVVJLFVBQVYsRUFBc0IsT0FBdEIsRUFBK0JKLE1BQS9CLENBQXNDSCxJQUFJLENBQUMsQ0FBRCxDQUExQyxDQUFWQTtRQUNEO01BQ0Y7O01BRURILElBQUksQ0FBQ2dCLElBQUxoQixDQUFVRyxJQUFWSDtJQUNEO0VBQ0YsQ0FyQ0RBOztFQXVDQSxPQUFPQSxJQUFQO0FBQ0QsQ0F4RERIOztBQTBEQSxTQUFTUSxzQkFBVCxDQUFnQ0YsSUFBaEMsRUFBc0NKLFlBQXRDLEVBQW9EO0VBQ2xELElBQUlLLE9BQU8sR0FBR0QsSUFBSSxDQUFDLENBQUQsQ0FBSkEsSUFBVyxFQUF6QixDQUE0QjtFQUE1QjtFQUVBLElBQUljLFVBQVUsR0FBR2QsSUFBSSxDQUFDLENBQUQsQ0FBckI7O0VBRUEsSUFBSSxDQUFDYyxVQUFMLEVBQWlCO0lBQ2YsT0FBT2IsT0FBUDtFQUNEOztFQUVELElBQUlMLFlBQVksSUFBSSxPQUFPbUIsSUFBUCxLQUFnQixVQUFwQyxFQUFnRDtJQUM5QyxJQUFJQyxhQUFhLEdBQUdDLFNBQVMsQ0FBQ0gsVUFBRCxDQUE3QjtJQUNBLElBQUlJLFVBQVUsR0FBR0osVUFBVSxDQUFDSyxPQUFYTCxDQUFtQmYsR0FBbkJlLENBQXVCLFVBQVVNLE1BQVYsRUFBa0I7TUFDeEQsT0FBTyxpQkFDSmpCLE1BREksQ0FDR1csVUFBVSxDQUFDTyxVQUFYUCxJQUF5QixFQUQ1QixFQUVKWCxNQUZJLENBRUdpQixNQUZILEVBRVcsS0FGWCxDQUFQO0lBR0QsQ0FKZ0JOLENBQWpCO0lBS0EsT0FBTyxDQUFDYixPQUFELEVBQVVFLE1BQVYsQ0FBaUJlLFVBQWpCLEVBQTZCZixNQUE3QixDQUFvQyxDQUFDYSxhQUFELENBQXBDLEVBQXFEWixJQUFyRCxDQUEwRCxJQUExRCxDQUFQO0VBQ0Q7O0VBRUQsT0FBTyxDQUFDSCxPQUFELEVBQVVHLElBQVYsQ0FBZSxJQUFmLENBQVA7QUFDRCxDLENBQUM7OztBQUVGLFNBQVNhLFNBQVQsQ0FBbUJLLFNBQW5CLEVBQThCO0VBQzVCO0VBQ0EsSUFBSUMsTUFBTSxHQUFHUixJQUFJLENBQUNTLFFBQVEsQ0FBQ0Msa0JBQWtCLENBQUNDLElBQUksQ0FBQ0MsU0FBTEQsQ0FBZUosU0FBZkksQ0FBRCxDQUFuQixDQUFULENBQWpCO0VBQ0EsSUFBSUUsSUFBSSxHQUNOLCtEQUErRHpCLE1BQS9ELENBQ0VvQixNQURGLENBREY7RUFJQSxPQUFPLE9BQU9wQixNQUFQLENBQWN5QixJQUFkLEVBQW9CLEtBQXBCLENBQVA7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzP2E0YjUiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVzZVNvdXJjZU1hcCIsImxpc3QiLCJ0b1N0cmluZyIsIm1hcCIsIml0ZW0iLCJjb250ZW50IiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsImNvbmNhdCIsImpvaW4iLCJpIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJkZWR1cGUiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwibGVuZ3RoIiwiaWQiLCJfaSIsInB1c2giLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZSIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getDomainLocale = getDomainLocale;\nvar basePath =  false || \"\";\n\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n  if (false) { var finalLocale, proto, domain, target, detectDomainLocale, normalizeLocalePath; } else {\n    return false;\n  }\n}\n\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n  Object.defineProperty(exports.default, \"__esModule\", {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0NILEVBQUFBO0FBR0FFLHVCQUFBQSxHQUEwQkUsZUFBMUJGO0FBQ0EsSUFBTUcsUUFBUSxHQUFHQyxNQUFBQSxJQUFzQyxFQUF2RDs7QUFDQSxTQUFTRixlQUFULENBQXlCSyxJQUF6QixFQUErQkMsTUFBL0IsRUFBdUNDLE9BQXZDLEVBQWdEQyxhQUFoRCxFQUErRDtFQUMzRCxJQUFJTixLQUFKLEVBQXFDLG9GQUFyQyxNQVdPO0lBQ0gsT0FBTyxLQUFQO0VBQ0g7QUFDSjs7QUFFRCxJQUFJLENBQUMsT0FBT0osT0FBTyxDQUFDd0IsT0FBZixLQUEyQixVQUEzQixJQUEwQyxPQUFPeEIsT0FBTyxDQUFDd0IsT0FBZixLQUEyQixRQUEzQixJQUF1Q3hCLE9BQU8sQ0FBQ3dCLE9BQVJ4QixLQUFvQixJQUF0RyxLQUFnSCxPQUFPQSxPQUFPLENBQUN3QixPQUFSeEIsQ0FBZ0J5QixVQUF2QixLQUFzQyxXQUExSixFQUF1SztFQUNySzNCLE1BQU0sQ0FBQ0MsY0FBUEQsQ0FBc0JFLE9BQU8sQ0FBQ3dCLE9BQTlCMUIsRUFBdUMsWUFBdkNBLEVBQXFEO0lBQUVHLEtBQUssRUFBRTtFQUFULENBQXJESDtFQUNBQSxNQUFNLENBQUM0QixNQUFQNUIsQ0FBY0UsT0FBTyxDQUFDd0IsT0FBdEIxQixFQUErQkUsT0FBL0JGO0VBQ0E2QixNQUFNLENBQUMzQixPQUFQMkIsR0FBaUIzQixPQUFPLENBQUN3QixPQUF6Qkc7QUFDRCxDLENBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZ2V0LWRvbWFpbi1sb2NhbGUuanM/NWMyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0RG9tYWluTG9jYWxlID0gZ2V0RG9tYWluTG9jYWxlO1xuY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnO1xuZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKHBhdGgsIGxvY2FsZSwgbG9jYWxlcywgZG9tYWluTG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZUxvY2FsZVBhdGggPSByZXF1aXJlKCcuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCcpLm5vcm1hbGl6ZUxvY2FsZVBhdGg7XG4gICAgICAgIGNvbnN0IGRldGVjdERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoJy4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKS5kZXRlY3REb21haW5Mb2NhbGU7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGxvY2FsZSB8fCBub3JtYWxpemVMb2NhbGVQYXRoKHBhdGgsIGxvY2FsZXMpLmRldGVjdGVkTG9jYWxlO1xuICAgICAgICBjb25zdCBkb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUoZG9tYWluTG9jYWxlcywgdW5kZWZpbmVkLCB0YXJnZXQpO1xuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICBjb25zdCBwcm90byA9IGBodHRwJHtkb21haW4uaHR0cCA/ICcnIDogJ3MnfTovL2A7XG4gICAgICAgICAgICBjb25zdCBmaW5hbExvY2FsZSA9IHRhcmdldCA9PT0gZG9tYWluLmRlZmF1bHRMb2NhbGUgPyAnJyA6IGAvJHt0YXJnZXR9YDtcbiAgICAgICAgICAgIHJldHVybiBgJHtwcm90b30ke2RvbWFpbi5kb21haW59JHtiYXNlUGF0aH0ke2ZpbmFsTG9jYWxlfSR7cGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtZG9tYWluLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXREb21haW5Mb2NhbGUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsImxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJyZXF1aXJlIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwidGFyZ2V0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJkb21haW4iLCJ1bmRlZmluZWQiLCJwcm90byIsImNvbmNhdCIsImh0dHAiLCJmaW5hbExvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/image.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/image.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _define_property = (__webpack_require__(/*! @swc/helpers/lib/_define_property.js */ \"./node_modules/@swc/helpers/lib/_define_property.js\")[\"default\"]);\n\nvar _sliced_to_array = (__webpack_require__(/*! @swc/helpers/lib/_sliced_to_array.js */ \"./node_modules/@swc/helpers/lib/_sliced_to_array.js\")[\"default\"]);\n\nvar _to_consumable_array = (__webpack_require__(/*! @swc/helpers/lib/_to_consumable_array.js */ \"./node_modules/@swc/helpers/lib/_to_consumable_array.js\")[\"default\"]);\n\nvar _s = $RefreshSig$(),\n    _s1 = $RefreshSig$();\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = Image;\n\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _head = _interopRequireDefault(__webpack_require__(/*! ../shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\"));\n\nvar _imageConfig = __webpack_require__(/*! ../shared/lib/image-config */ \"./node_modules/next/dist/shared/lib/image-config.js\");\n\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\n\nvar _imageConfigContext = __webpack_require__(/*! ../shared/lib/image-config-context */ \"./node_modules/next/dist/shared/lib/image-config-context.js\");\n\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\n\nvar _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\n\nfunction Image(_param) {\n  _s();\n\n  var src = _param.src,\n      sizes = _param.sizes,\n      _unoptimized = _param.unoptimized,\n      unoptimized = _unoptimized === void 0 ? false : _unoptimized,\n      _priority = _param.priority,\n      priority = _priority === void 0 ? false : _priority,\n      loading = _param.loading,\n      _lazyRoot = _param.lazyRoot,\n      lazyRoot = _lazyRoot === void 0 ? null : _lazyRoot,\n      lazyBoundary = _param.lazyBoundary,\n      className = _param.className,\n      quality = _param.quality,\n      width = _param.width,\n      height = _param.height,\n      style = _param.style,\n      objectFit = _param.objectFit,\n      objectPosition = _param.objectPosition,\n      onLoadingComplete = _param.onLoadingComplete,\n      _placeholder = _param.placeholder,\n      placeholder = _placeholder === void 0 ? \"empty\" : _placeholder,\n      blurDataURL = _param.blurDataURL,\n      all = _objectWithoutPropertiesLoose(_param, [\"src\", \"sizes\", \"unoptimized\", \"priority\", \"loading\", \"lazyRoot\", \"lazyBoundary\", \"className\", \"quality\", \"width\", \"height\", \"style\", \"objectFit\", \"objectPosition\", \"onLoadingComplete\", \"placeholder\", \"blurDataURL\"]);\n\n  var configContext = (0, _react).useContext(_imageConfigContext.ImageConfigContext);\n  var config = (0, _react).useMemo(function () {\n    var c = configEnv || configContext || _imageConfig.imageConfigDefault;\n\n    var allSizes = _to_consumable_array(c.deviceSizes).concat(_to_consumable_array(c.imageSizes)).sort(function (a, b) {\n      return a - b;\n    });\n\n    var deviceSizes = c.deviceSizes.sort(function (a, b) {\n      return a - b;\n    });\n    return _extends({}, c, {\n      allSizes: allSizes,\n      deviceSizes: deviceSizes\n    });\n  }, [configContext]);\n  var rest = all;\n  var layout = sizes ? \"responsive\" : \"intrinsic\";\n\n  if (\"layout\" in rest) {\n    // Override default layout if the user specified one:\n    if (rest.layout) layout = rest.layout; // Remove property so it's not spread on <img>:\n\n    delete rest.layout;\n  }\n\n  var loader = defaultImageLoader;\n\n  if (\"loader\" in rest) {\n    if (rest.loader) {\n      var customImageLoader = rest.loader;\n\n      var _tmp;\n\n      _tmp = function (obj) {\n        var _ = obj.config,\n            opts = _objectWithoutPropertiesLoose(obj, [\"config\"]); // The config object is internal only so we must\n        // not pass it to the user-defined loader()\n\n\n        return customImageLoader(opts);\n      }, loader = _tmp, _tmp;\n    } // Remove property so it's not spread on <img>\n\n\n    delete rest.loader;\n  }\n\n  var staticSrc = \"\";\n\n  if (isStaticImport(src)) {\n    var staticImageData = isStaticRequire(src) ? src.default : src;\n\n    if (!staticImageData.src) {\n      throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \".concat(JSON.stringify(staticImageData)));\n    }\n\n    blurDataURL = blurDataURL || staticImageData.blurDataURL;\n    staticSrc = staticImageData.src;\n\n    if (!layout || layout !== \"fill\") {\n      height = height || staticImageData.height;\n      width = width || staticImageData.width;\n\n      if (!staticImageData.height || !staticImageData.width) {\n        throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \".concat(JSON.stringify(staticImageData)));\n      }\n    }\n  }\n\n  src = typeof src === \"string\" ? src : staticSrc;\n  var widthInt = getInt(width);\n  var heightInt = getInt(height);\n  var qualityInt = getInt(quality);\n  var isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n\n  if (src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n    unoptimized = true;\n    isLazy = false;\n  }\n\n  if ( true && loadedImageURLs.has(src)) {\n    isLazy = false;\n  }\n\n  if (experimentalUnoptimized) {\n    unoptimized = true;\n  }\n\n  var ref = _sliced_to_array((0, _react).useState(false), 2),\n      blurComplete = ref[0],\n      setBlurComplete = ref[1];\n\n  var ref1 = _sliced_to_array((0, _useIntersection).useIntersection({\n    rootRef: lazyRoot,\n    rootMargin: lazyBoundary || \"200px\",\n    disabled: !isLazy\n  }), 3),\n      setIntersection = ref1[0],\n      isIntersected = ref1[1],\n      resetIntersected = ref1[2];\n\n  var isVisible = !isLazy || isIntersected;\n  var wrapperStyle = {\n    boxSizing: \"border-box\",\n    display: \"block\",\n    overflow: \"hidden\",\n    width: \"initial\",\n    height: \"initial\",\n    background: \"none\",\n    opacity: 1,\n    border: 0,\n    margin: 0,\n    padding: 0\n  };\n  var sizerStyle = {\n    boxSizing: \"border-box\",\n    display: \"block\",\n    width: \"initial\",\n    height: \"initial\",\n    background: \"none\",\n    opacity: 1,\n    border: 0,\n    margin: 0,\n    padding: 0\n  };\n  var hasSizer = false;\n  var sizerSvgUrl;\n  var layoutStyle = {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0,\n    boxSizing: \"border-box\",\n    padding: 0,\n    border: \"none\",\n    margin: \"auto\",\n    display: \"block\",\n    width: 0,\n    height: 0,\n    minWidth: \"100%\",\n    maxWidth: \"100%\",\n    minHeight: \"100%\",\n    maxHeight: \"100%\",\n    objectFit: objectFit,\n    objectPosition: objectPosition\n  };\n\n  if (true) {\n    if (!src) {\n      throw new Error('Image is missing required \"src\" property. Make sure you pass \"src\" in props to the `next/image` component. Received: '.concat(JSON.stringify({\n        width: width,\n        height: height,\n        quality: quality\n      })));\n    }\n\n    if (!VALID_LAYOUT_VALUES.includes(layout)) {\n      if (layout === \"raw\") {\n        throw new Error('The layout=\"raw\" experiment has been moved to a new module. Please import `next/future/image` instead.');\n      }\n\n      throw new Error('Image with src \"'.concat(src, '\" has invalid \"layout\" property. Provided \"').concat(layout, '\" should be one of ').concat(VALID_LAYOUT_VALUES.map(String).join(\",\"), \".\"));\n    }\n\n    if (typeof widthInt !== \"undefined\" && isNaN(widthInt) || typeof heightInt !== \"undefined\" && isNaN(heightInt)) {\n      throw new Error('Image with src \"'.concat(src, '\" has invalid \"width\" or \"height\" property. These should be numeric values.'));\n    }\n\n    if (layout === \"fill\" && (width || height)) {\n      (0, _utils).warnOnce('Image with src \"'.concat(src, '\" and \"layout=\\'fill\\'\" has unused properties assigned. Please remove \"width\" and \"height\".'));\n    }\n\n    if (!VALID_LOADING_VALUES.includes(loading)) {\n      throw new Error('Image with src \"'.concat(src, '\" has invalid \"loading\" property. Provided \"').concat(loading, '\" should be one of ').concat(VALID_LOADING_VALUES.map(String).join(\",\"), \".\"));\n    }\n\n    if (priority && loading === \"lazy\") {\n      throw new Error('Image with src \"'.concat(src, '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.'));\n    }\n\n    if (sizes && layout !== \"fill\" && layout !== \"responsive\") {\n      (0, _utils).warnOnce('Image with src \"'.concat(src, '\" has \"sizes\" property but it will be ignored. Only use \"sizes\" with \"layout=\\'fill\\'\" or \"layout=\\'responsive\\'\"'));\n    }\n\n    if (placeholder === \"blur\") {\n      if (layout !== \"fill\" && (widthInt || 0) * (heightInt || 0) < 1600) {\n        (0, _utils).warnOnce('Image with src \"'.concat(src, '\" is smaller than 40x40. Consider removing the \"placeholder=\\'blur\\'\" property to improve performance.'));\n      }\n\n      if (!blurDataURL) {\n        var VALID_BLUR_EXT = [\"jpeg\", \"png\", \"webp\", \"avif\"] // should match next-image-loader\n        ;\n        throw new Error('Image with src \"'.concat(src, '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n          Possible solutions:\\n            - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n            - Change the \"src\" property to a static import with one of the supported file types: ').concat(VALID_BLUR_EXT.join(\",\"), '\\n            - Remove the \"placeholder\" property, effectively no blur effect\\n          Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url'));\n      }\n    }\n\n    if (\"ref\" in rest) {\n      (0, _utils).warnOnce('Image with src \"'.concat(src, '\" is using unsupported \"ref\" property. Consider using the \"onLoadingComplete\" property instead.'));\n    }\n\n    if (!unoptimized && loader !== defaultImageLoader) {\n      var urlStr = loader({\n        config: config,\n        src: src,\n        width: widthInt || 400,\n        quality: qualityInt || 75\n      });\n      var url;\n\n      try {\n        url = new URL(urlStr);\n      } catch (err) {}\n\n      if (urlStr === src || url && url.pathname === src && !url.search) {\n        (0, _utils).warnOnce('Image with src \"'.concat(src, '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.') + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n      }\n    }\n\n    if (style) {\n      var overwrittenStyles = Object.keys(style).filter(function (key) {\n        return key in layoutStyle;\n      });\n\n      if (overwrittenStyles.length) {\n        (0, _utils).warnOnce(\"Image with src \".concat(src, \" is assigned the following styles, which are overwritten by automatically-generated styles: \").concat(overwrittenStyles.join(\", \")));\n      }\n    }\n\n    if ( true && !perfObserver && window.PerformanceObserver) {\n      perfObserver = new PerformanceObserver(function (entryList) {\n        var _iteratorNormalCompletion = true,\n            _didIteratorError = false,\n            _iteratorError = undefined;\n\n        try {\n          for (var _iterator = entryList.getEntries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var entry = _step.value;\n            var ref; // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n\n            var imgSrc = (entry == null ? void 0 : (ref = entry.element) == null ? void 0 : ref.src) || \"\";\n            var lcpImage = allImgs.get(imgSrc);\n\n            if (lcpImage && !lcpImage.priority && lcpImage.placeholder !== \"blur\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n              // https://web.dev/lcp/#measure-lcp-in-javascript\n              (0, _utils).warnOnce('Image with src \"'.concat(lcpImage.src, '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.') + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      });\n\n      try {\n        perfObserver.observe({\n          type: \"largest-contentful-paint\",\n          buffered: true\n        });\n      } catch (err1) {\n        // Log error but don't crash the app\n        console.error(err1);\n      }\n    }\n  }\n\n  var imgStyle = Object.assign({}, style, layoutStyle);\n  var blurStyle = placeholder === \"blur\" && !blurComplete ? {\n    backgroundSize: objectFit || \"cover\",\n    backgroundPosition: objectPosition || \"0% 0%\",\n    filter: \"blur(20px)\",\n    backgroundImage: 'url(\"'.concat(blurDataURL, '\")')\n  } : {};\n\n  if (layout === \"fill\") {\n    // <Image src=\"i.png\" layout=\"fill\" />\n    wrapperStyle.display = \"block\";\n    wrapperStyle.position = \"absolute\";\n    wrapperStyle.top = 0;\n    wrapperStyle.left = 0;\n    wrapperStyle.bottom = 0;\n    wrapperStyle.right = 0;\n  } else if (typeof widthInt !== \"undefined\" && typeof heightInt !== \"undefined\") {\n    // <Image src=\"i.png\" width=\"100\" height=\"100\" />\n    var quotient = heightInt / widthInt;\n    var paddingTop = isNaN(quotient) ? \"100%\" : \"\".concat(quotient * 100, \"%\");\n\n    if (layout === \"responsive\") {\n      // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"responsive\" />\n      wrapperStyle.display = \"block\";\n      wrapperStyle.position = \"relative\";\n      hasSizer = true;\n      sizerStyle.paddingTop = paddingTop;\n    } else if (layout === \"intrinsic\") {\n      // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"intrinsic\" />\n      wrapperStyle.display = \"inline-block\";\n      wrapperStyle.position = \"relative\";\n      wrapperStyle.maxWidth = \"100%\";\n      hasSizer = true;\n      sizerStyle.maxWidth = \"100%\";\n      sizerSvgUrl = \"data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27\".concat(widthInt, \"%27%20height=%27\").concat(heightInt, \"%27/%3e\");\n    } else if (layout === \"fixed\") {\n      // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"fixed\" />\n      wrapperStyle.display = \"inline-block\";\n      wrapperStyle.position = \"relative\";\n      wrapperStyle.width = widthInt;\n      wrapperStyle.height = heightInt;\n    }\n  } else {\n    // <Image src=\"i.png\" />\n    if (true) {\n      throw new Error('Image with src \"'.concat(src, '\" must use \"width\" and \"height\" properties or \"layout=\\'fill\\'\" property.'));\n    }\n  }\n\n  var imgAttributes = {\n    src: emptyDataURL,\n    srcSet: undefined,\n    sizes: undefined\n  };\n\n  if (isVisible) {\n    imgAttributes = generateImgAttrs({\n      config: config,\n      src: src,\n      unoptimized: unoptimized,\n      layout: layout,\n      width: widthInt,\n      quality: qualityInt,\n      sizes: sizes,\n      loader: loader\n    });\n  }\n\n  var srcString = src;\n\n  if (true) {\n    if (true) {\n      var fullUrl;\n\n      try {\n        fullUrl = new URL(imgAttributes.src);\n      } catch (e) {\n        fullUrl = new URL(imgAttributes.src, window.location.href);\n      }\n\n      allImgs.set(fullUrl.href, {\n        src: src,\n        priority: priority,\n        placeholder: placeholder\n      });\n    }\n  }\n\n  var imageSrcSetPropName = \"imagesrcset\";\n  var imageSizesPropName = \"imagesizes\";\n\n  if (false) {}\n\n  var _obj;\n\n  var linkProps = (_obj = {}, // Note: imagesrcset and imagesizes are not in the link element type with react 17.\n  _define_property(_obj, imageSrcSetPropName, imgAttributes.srcSet), _define_property(_obj, imageSizesPropName, imgAttributes.sizes), _obj);\n  var useLayoutEffect =  false ? 0 : _react.default.useLayoutEffect;\n  var onLoadingCompleteRef = (0, _react).useRef(onLoadingComplete);\n  var previousImageSrc = (0, _react).useRef(src);\n  (0, _react).useEffect(function () {\n    onLoadingCompleteRef.current = onLoadingComplete;\n  }, [onLoadingComplete]);\n  useLayoutEffect(function () {\n    if (previousImageSrc.current !== src) {\n      resetIntersected();\n      previousImageSrc.current = src;\n    }\n  }, [resetIntersected, src]);\n\n  var imgElementArgs = _extends({\n    isLazy: isLazy,\n    imgAttributes: imgAttributes,\n    heightInt: heightInt,\n    widthInt: widthInt,\n    qualityInt: qualityInt,\n    layout: layout,\n    className: className,\n    imgStyle: imgStyle,\n    blurStyle: blurStyle,\n    loading: loading,\n    config: config,\n    unoptimized: unoptimized,\n    placeholder: placeholder,\n    loader: loader,\n    srcString: srcString,\n    onLoadingCompleteRef: onLoadingCompleteRef,\n    setBlurComplete: setBlurComplete,\n    setIntersection: setIntersection,\n    isVisible: isVisible,\n    noscriptSizes: sizes\n  }, rest);\n\n  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"span\", {\n    style: wrapperStyle\n  }, hasSizer ? /*#__PURE__*/_react.default.createElement(\"span\", {\n    style: sizerStyle\n  }, sizerSvgUrl ? /*#__PURE__*/_react.default.createElement(\"img\", {\n    style: {\n      display: \"block\",\n      maxWidth: \"100%\",\n      width: \"initial\",\n      height: \"initial\",\n      background: \"none\",\n      opacity: 1,\n      border: 0,\n      margin: 0,\n      padding: 0\n    },\n    alt: \"\",\n    \"aria-hidden\": true,\n    src: sizerSvgUrl\n  }) : null) : null, /*#__PURE__*/_react.default.createElement(ImageElement, Object.assign({}, imgElementArgs))), priority ? // for browsers that do not support `imagesrcset`, and in those cases\n  // it would likely cause the incorrect image to be preloaded.\n  //\n  // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n\n  /*#__PURE__*/\n  _react.default.createElement(_head.default, null, /*#__PURE__*/_react.default.createElement(\"link\", Object.assign({\n    key: \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes,\n    rel: \"preload\",\n    as: \"image\",\n    href: imgAttributes.srcSet ? undefined : imgAttributes.src\n  }, linkProps))) : null);\n}\n\n_s(Image, \"JC32V8ZswcgqIp1SSTncST29uwM=\");\n\n_c = Image;\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar ref = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"experimentalLayoutRaw\":false,\"domains\":[\"lh3.googleusercontent.com\",\"avatars.githubusercontent.com\",\"imagedelivery.net\"],\"experimentalRemotePatterns\":[]} || {},\n    _experimentalRemotePatterns = ref.experimentalRemotePatterns,\n    experimentalRemotePatterns = _experimentalRemotePatterns === void 0 ? [] : _experimentalRemotePatterns,\n    experimentalUnoptimized = ref.experimentalUnoptimized;\nvar configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"experimentalLayoutRaw\":false,\"domains\":[\"lh3.googleusercontent.com\",\"avatars.githubusercontent.com\",\"imagedelivery.net\"],\"experimentalRemotePatterns\":[]};\nvar loadedImageURLs = new Set();\nvar allImgs = new Map();\nvar perfObserver;\nvar emptyDataURL = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n\nif (false) {}\n\nvar VALID_LOADING_VALUES = [\"lazy\", \"eager\", undefined];\nvar loaders = new Map([[\"default\", defaultLoader], [\"imgix\", imgixLoader], [\"cloudinary\", cloudinaryLoader], [\"akamai\", akamaiLoader], [\"custom\", customLoader]]);\nvar VALID_LAYOUT_VALUES = [\"fill\", \"fixed\", \"intrinsic\", \"responsive\", undefined];\n\nfunction isStaticRequire(src) {\n  return src.default !== undefined;\n}\n\nfunction isStaticImageData(src) {\n  return src.src !== undefined;\n}\n\nfunction isStaticImport(src) {\n  return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\n\nfunction getWidths(param, width, layout, sizes) {\n  var deviceSizes = param.deviceSizes,\n      allSizes = param.allSizes;\n\n  if (sizes && (layout === \"fill\" || layout === \"responsive\")) {\n    // Find all the \"vw\" percent sizes used in the sizes prop\n    var viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n    var percentSizes = [];\n\n    for (var match; match = viewportWidthRe.exec(sizes); match) {\n      percentSizes.push(parseInt(match[2]));\n    }\n\n    if (percentSizes.length) {\n      var _Math;\n\n      var smallestRatio = (_Math = Math).min.apply(_Math, _to_consumable_array(percentSizes)) * 0.01;\n      return {\n        widths: allSizes.filter(function (s) {\n          return s >= deviceSizes[0] * smallestRatio;\n        }),\n        kind: \"w\"\n      };\n    }\n\n    return {\n      widths: allSizes,\n      kind: \"w\"\n    };\n  }\n\n  if (typeof width !== \"number\" || layout === \"fill\" || layout === \"responsive\") {\n    return {\n      widths: deviceSizes,\n      kind: \"w\"\n    };\n  }\n\n  var widths = _to_consumable_array(new Set( // > are actually 3x in the green color, but only 1.5x in the red and\n  // > blue colors. Showing a 3x resolution image in the app vs a 2x\n  // > resolution image will be visually the same, though the 3x image\n  // > takes significantly more data. Even true 3x resolution screens are\n  // > wasteful as the human eye cannot see that level of detail without\n  // > something like a magnifying glass.\n  // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n  [width, width * 2\n  /*, width * 3*/\n  ].map(function (w) {\n    return allSizes.find(function (p) {\n      return p >= w;\n    }) || allSizes[allSizes.length - 1];\n  })));\n\n  return {\n    widths: widths,\n    kind: \"x\"\n  };\n}\n\nfunction generateImgAttrs(param) {\n  var config = param.config,\n      src = param.src,\n      unoptimized = param.unoptimized,\n      layout = param.layout,\n      width = param.width,\n      quality = param.quality,\n      sizes = param.sizes,\n      loader = param.loader;\n\n  if (unoptimized) {\n    return {\n      src: src,\n      srcSet: undefined,\n      sizes: undefined\n    };\n  }\n\n  var ref = getWidths(config, width, layout, sizes),\n      widths = ref.widths,\n      kind = ref.kind;\n  var last = widths.length - 1;\n  return {\n    sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n    srcSet: widths.map(function (w, i) {\n      return \"\".concat(loader({\n        config: config,\n        src: src,\n        quality: quality,\n        width: w\n      }), \" \").concat(kind === \"w\" ? w : i + 1).concat(kind);\n    }).join(\", \"),\n    // It's intended to keep `src` the last attribute because React updates\n    // attributes in order. If we keep `src` the first one, Safari will\n    // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n    // updated by React. That causes multiple unnecessary requests if `srcSet`\n    // and `sizes` are defined.\n    // This bug cannot be reproduced in Chrome or Firefox.\n    src: loader({\n      config: config,\n      src: src,\n      quality: quality,\n      width: widths[last]\n    })\n  };\n}\n\nfunction getInt(x) {\n  if (typeof x === \"number\") {\n    return x;\n  }\n\n  if (typeof x === \"string\") {\n    return parseInt(x, 10);\n  }\n\n  return undefined;\n}\n\nfunction defaultImageLoader(loaderProps) {\n  var ref;\n  var loaderKey = ((ref = loaderProps.config) == null ? void 0 : ref.loader) || \"default\";\n  var load = loaders.get(loaderKey);\n\n  if (load) {\n    return load(loaderProps);\n  }\n\n  throw new Error('Unknown \"loader\" found in \"next.config.js\". Expected: '.concat(_imageConfig.VALID_LOADERS.join(\", \"), \". Received: \").concat(loaderKey));\n} // See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\n\n\nfunction handleLoading(img, src, layout, placeholder, onLoadingCompleteRef, setBlurComplete) {\n  if (!img || img.src === emptyDataURL || img[\"data-loaded-src\"] === src) {\n    return;\n  }\n\n  img[\"data-loaded-src\"] = src;\n  var p = \"decode\" in img ? img.decode() : Promise.resolve();\n  p.catch(function () {}).then(function () {\n    if (!img.parentNode) {\n      // Exit early in case of race condition:\n      // - onload() is called\n      // - decode() is called but incomplete\n      // - unmount is called\n      // - decode() completes\n      return;\n    }\n\n    loadedImageURLs.add(src);\n\n    if (placeholder === \"blur\") {\n      setBlurComplete(true);\n    }\n\n    if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n      var naturalWidth = img.naturalWidth,\n          naturalHeight = img.naturalHeight; // Pass back read-only primitive values but not the\n      // underlying DOM element because it could be misused.\n\n      onLoadingCompleteRef.current({\n        naturalWidth: naturalWidth,\n        naturalHeight: naturalHeight\n      });\n    }\n\n    if (true) {\n      var ref;\n\n      if ((ref = img.parentElement) == null ? void 0 : ref.parentElement) {\n        var parent = getComputedStyle(img.parentElement.parentElement);\n\n        if (!parent.position) {// The parent has not been rendered to the dom yet and therefore it has no position. Skip the warnings for such cases.\n        } else if (layout === \"responsive\" && parent.display === \"flex\") {\n          (0, _utils).warnOnce('Image with src \"'.concat(src, '\" may not render properly as a child of a flex container. Consider wrapping the image with a div to configure the width.'));\n        } else if (layout === \"fill\" && parent.position !== \"relative\" && parent.position !== \"fixed\" && parent.position !== \"absolute\") {\n          (0, _utils).warnOnce('Image with src \"'.concat(src, '\" may not render properly with a parent using position:\"').concat(parent.position, '\". Consider changing the parent style to position:\"relative\" with a width and height.'));\n        }\n      }\n    }\n  });\n}\n\nvar ImageElement = function (_param) {\n  _s1();\n\n  var imgAttributes = _param.imgAttributes,\n      heightInt = _param.heightInt,\n      widthInt = _param.widthInt,\n      qualityInt = _param.qualityInt,\n      layout = _param.layout,\n      className = _param.className,\n      imgStyle = _param.imgStyle,\n      blurStyle = _param.blurStyle,\n      isLazy = _param.isLazy,\n      placeholder = _param.placeholder,\n      loading = _param.loading,\n      srcString = _param.srcString,\n      config = _param.config,\n      unoptimized = _param.unoptimized,\n      loader = _param.loader,\n      onLoadingCompleteRef = _param.onLoadingCompleteRef,\n      setBlurComplete = _param.setBlurComplete,\n      setIntersection = _param.setIntersection,\n      onLoad = _param.onLoad,\n      onError = _param.onError,\n      isVisible = _param.isVisible,\n      noscriptSizes = _param.noscriptSizes,\n      rest = _objectWithoutPropertiesLoose(_param, [\"imgAttributes\", \"heightInt\", \"widthInt\", \"qualityInt\", \"layout\", \"className\", \"imgStyle\", \"blurStyle\", \"isLazy\", \"placeholder\", \"loading\", \"srcString\", \"config\", \"unoptimized\", \"loader\", \"onLoadingCompleteRef\", \"setBlurComplete\", \"setIntersection\", \"onLoad\", \"onError\", \"isVisible\", \"noscriptSizes\"]);\n\n  loading = isLazy ? \"lazy\" : loading;\n  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"img\", Object.assign({}, rest, imgAttributes, {\n    decoding: \"async\",\n    \"data-nimg\": layout,\n    className: className,\n    style: _extends({}, imgStyle, blurStyle),\n    ref: (0, _react).useCallback(function (img) {\n      setIntersection(img);\n\n      if (img == null ? void 0 : img.complete) {\n        handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);\n      }\n    }, [setIntersection, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete]),\n    onLoad: function (event) {\n      var img = event.currentTarget;\n      handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);\n\n      if (onLoad) {\n        onLoad(event);\n      }\n    },\n    onError: function (event) {\n      if (placeholder === \"blur\") {\n        // If the real image fails to load, this will still remove the placeholder.\n        setBlurComplete(true);\n      }\n\n      if (onError) {\n        onError(event);\n      }\n    }\n  })), (isLazy || placeholder === \"blur\") && /*#__PURE__*/_react.default.createElement(\"noscript\", null, /*#__PURE__*/_react.default.createElement(\"img\", Object.assign({}, rest, generateImgAttrs({\n    config: config,\n    src: srcString,\n    unoptimized: unoptimized,\n    layout: layout,\n    width: widthInt,\n    quality: qualityInt,\n    sizes: noscriptSizes,\n    loader: loader\n  }), {\n    decoding: \"async\",\n    \"data-nimg\": layout,\n    style: imgStyle,\n    className: className,\n    // @ts-ignore - TODO: upgrade to `@types/react@17`\n    loading: loading\n  }))));\n};\n\n_s1(ImageElement, \"epj4qY15NHsef74wNqHIp5fdZmg=\");\n\n_c1 = ImageElement;\n\nfunction normalizeSrc(src) {\n  return src[0] === \"/\" ? src.slice(1) : src;\n}\n\nfunction imgixLoader(param) {\n  var config = param.config,\n      src = param.src,\n      width = param.width,\n      quality = param.quality; // Demo: https://static.imgix.net/daisy.png?auto=format&fit=max&w=300\n\n  var url = new URL(\"\".concat(config.path).concat(normalizeSrc(src)));\n  var params = url.searchParams;\n  params.set(\"auto\", params.get(\"auto\") || \"format\");\n  params.set(\"fit\", params.get(\"fit\") || \"max\");\n  params.set(\"w\", params.get(\"w\") || width.toString());\n\n  if (quality) {\n    params.set(\"q\", quality.toString());\n  }\n\n  return url.href;\n}\n\nfunction akamaiLoader(param) {\n  var config = param.config,\n      src = param.src,\n      width = param.width;\n  return \"\".concat(config.path).concat(normalizeSrc(src), \"?imwidth=\").concat(width);\n}\n\nfunction cloudinaryLoader(param) {\n  var config = param.config,\n      src = param.src,\n      width = param.width,\n      quality = param.quality; // Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg\n\n  var params = [\"f_auto\", \"c_limit\", \"w_\" + width, \"q_\" + (quality || \"auto\")];\n  var paramsString = params.join(\",\") + \"/\";\n  return \"\".concat(config.path).concat(paramsString).concat(normalizeSrc(src));\n}\n\nfunction customLoader(param) {\n  var src = param.src;\n  throw new Error('Image with src \"'.concat(src, '\" is missing \"loader\" prop.') + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n}\n\nfunction defaultLoader(param) {\n  var config = param.config,\n      src = param.src,\n      width = param.width,\n      quality = param.quality;\n\n  if (true) {\n    var missingValues = []; // these should always be provided but make sure they are\n\n    if (!src) missingValues.push(\"src\");\n    if (!width) missingValues.push(\"width\");\n\n    if (missingValues.length > 0) {\n      throw new Error(\"Next Image Optimization requires \".concat(missingValues.join(\", \"), \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \").concat(JSON.stringify({\n        src: src,\n        width: width,\n        quality: quality\n      })));\n    }\n\n    if (src.startsWith(\"//\")) {\n      throw new Error('Failed to parse src \"'.concat(src, '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)'));\n    }\n\n    if (!src.startsWith(\"/\") && (config.domains || experimentalRemotePatterns)) {\n      var parsedSrc;\n\n      try {\n        parsedSrc = new URL(src);\n      } catch (err) {\n        console.error(err);\n        throw new Error('Failed to parse src \"'.concat(src, '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)'));\n      }\n\n      if (true) {\n        // We use dynamic require because this should only error in development\n        var hasMatch = (__webpack_require__(/*! ../shared/lib/match-remote-pattern */ \"./node_modules/next/dist/shared/lib/match-remote-pattern.js\").hasMatch);\n\n        if (!hasMatch(config.domains, experimentalRemotePatterns, parsedSrc)) {\n          throw new Error(\"Invalid src prop (\".concat(src, ') on `next/image`, hostname \"').concat(parsedSrc.hostname, '\" is not configured under images in your `next.config.js`\\n') + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n        }\n      }\n    }\n  }\n\n  if (src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n    // Special case to make svg serve as-is to avoid proxying\n    // through the built-in Image Optimization API.\n    return src;\n  }\n\n  return \"\".concat((0, _normalizeTrailingSlash).normalizePathTrailingSlash(config.path), \"?url=\").concat(encodeURIComponent(src), \"&w=\").concat(width, \"&q=\").concat(quality || 75);\n}\n\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n  Object.defineProperty(exports.default, \"__esModule\", {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n} //# sourceMappingURL=image.js.map\n\n\nvar _c, _c1;\n\n$RefreshReg$(_c, \"Image\");\n$RefreshReg$(_c1, \"ImageElement\");\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7Ozs7Ozs7Ozs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0NILEVBQUFBO0FBR0FFLGtCQUFBQSxHQUFrQkcsS0FBbEJIOztBQUNBLElBQUlJLE1BQU0sR0FBR0MsdUJBQXVCLENBQUNDLG1CQUFPLENBQUMsNENBQUQsQ0FBUixDQUFwQzs7QUFDQSxJQUFJQyxLQUFLLEdBQUdDLHNCQUFzQixDQUFDRixtQkFBTyxDQUFDLHVFQUFELENBQVIsQ0FBbEM7O0FBQ0EsSUFBSUcsWUFBWSxHQUFHSCxtQkFBTyxDQUFDLHVGQUFELENBQTFCOztBQUNBLElBQUlJLGdCQUFnQixHQUFHSixtQkFBTyxDQUFDLCtFQUFELENBQTlCOztBQUNBLElBQUlLLG1CQUFtQixHQUFHTCxtQkFBTyxDQUFDLHVHQUFELENBQWpDOztBQUNBLElBQUlNLE1BQU0sR0FBR04sbUJBQU8sQ0FBQyx5RUFBRCxDQUFwQjs7QUFDQSxJQUFJTyx1QkFBdUIsR0FBR1AsbUJBQU8sQ0FBQywrRkFBRCxDQUFyQzs7QUFDQSxTQUFTSCxLQUFULENBQWVXLE1BQWYsRUFBdUI7OztFQUNuQixJQUFNQyxHQUFHLEdBQW9PRCxNQUFNLENBQTdPQyxHQUFOO0VBQUEsSUFBWUMsS0FBSyxHQUE0TkYsTUFBTSxDQUF2T0UsS0FBWjtFQUFBLElBQWlCQyxlQUE0TkgsTUFBTSxDQUEvTkksV0FBcEI7RUFBQSxJQUFvQkEsV0FBVyw2QkFBRSxLQUFGLEdBQU9ELFlBQXRDO0VBQUEsSUFBc0NFLFlBQXVNTCxNQUFNLENBQTFNTSxRQUF6QztFQUFBLElBQXlDQSxRQUFRLDBCQUFFLEtBQUYsR0FBT0QsU0FBeEQ7RUFBQSxJQUEyREUsT0FBTyxHQUEyS1AsTUFBTSxDQUF4TE8sT0FBM0Q7RUFBQSxJQUFrRUMsWUFBMktSLE1BQU0sQ0FBOUtTLFFBQXJFO0VBQUEsSUFBcUVBLFFBQVEs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K0VxUSxrQkFBa0IsQ0FBQ2pSLEdBQUQsQ0FBakcsRUFBdUcsS0FBdkcsRUFBdUhXLE1BQXZILENBQTRHQyxLQUE1RyxFQUFrSCxLQUFsSCxFQUFxSXdDLE1BQXJJLENBQXVIekMsT0FBTyxJQUFJLEVBQWxJLENBQVA7QUFDSDs7QUFFRCxJQUFJLENBQUMsT0FBTzFCLE9BQU8sQ0FBQ0UsT0FBZixLQUEyQixVQUEzQixJQUEwQyxPQUFPRixPQUFPLENBQUNFLE9BQWYsS0FBMkIsUUFBM0IsSUFBdUNGLE9BQU8sQ0FBQ0UsT0FBUkYsS0FBb0IsSUFBdEcsS0FBZ0gsT0FBT0EsT0FBTyxDQUFDRSxPQUFSRixDQUFnQjZNLFVBQXZCLEtBQXNDLFdBQTFKLEVBQXVLO0VBQ3JLL00sTUFBTSxDQUFDQyxjQUFQRCxDQUFzQkUsT0FBTyxDQUFDRSxPQUE5QkosRUFBdUMsWUFBdkNBLEVBQXFEO0lBQUVHLEtBQUssRUFBRTtFQUFULENBQXJESDtFQUNBQSxNQUFNLENBQUNnSyxNQUFQaEssQ0FBY0UsT0FBTyxDQUFDRSxPQUF0QkosRUFBK0JFLE9BQS9CRjtFQUNBb1MsTUFBTSxDQUFDbFMsT0FBUGtTLEdBQWlCbFMsT0FBTyxDQUFDRSxPQUF6QmdTO0FBQ0QsQyxDQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLmpzPzgyZjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBJbWFnZTtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9oZWFkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9oZWFkXCIpKTtcbnZhciBfaW1hZ2VDb25maWcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWdcIik7XG52YXIgX3VzZUludGVyc2VjdGlvbiA9IHJlcXVpcmUoXCIuL3VzZS1pbnRlcnNlY3Rpb25cIik7XG52YXIgX2ltYWdlQ29uZmlnQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0XCIpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzXCIpO1xudmFyIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoXCIpO1xuZnVuY3Rpb24gSW1hZ2UoX3BhcmFtKSB7XG4gICAgdmFyIHsgc3JjICwgc2l6ZXMgLCB1bm9wdGltaXplZCA9ZmFsc2UgLCBwcmlvcml0eSA9ZmFsc2UgLCBsb2FkaW5nICwgbGF6eVJvb3QgPW51bGwgLCBsYXp5Qm91bmRhcnkgLCBjbGFzc05hbWUgLCBxdWFsaXR5ICwgd2lkdGggLCBoZWlnaHQgLCBzdHlsZSAsIG9iamVjdEZpdCAsIG9iamVjdFBvc2l0aW9uICwgb25Mb2FkaW5nQ29tcGxldGUgLCBwbGFjZWhvbGRlciA9J2VtcHR5JyAsIGJsdXJEYXRhVVJMICB9ID0gX3BhcmFtLCBhbGwgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcGFyYW0sIFtcbiAgICAgICAgXCJzcmNcIixcbiAgICAgICAgXCJzaXplc1wiLFxuICAgICAgICBcInVub3B0aW1pemVkXCIsXG4gICAgICAgIFwicHJpb3JpdHlcIixcbiAgICAgICAgXCJsb2FkaW5nXCIsXG4gICAgICAgIFwibGF6eVJvb3RcIixcbiAgICAgICAgXCJsYXp5Qm91bmRhcnlcIixcbiAgICAgICAgXCJjbGFzc05hbWVcIixcbiAgICAgICAgXCJxdWFsaXR5XCIsXG4gICAgICAgIFwid2lkdGhcIixcbiAgICAgICAgXCJoZWlnaHRcIixcbiAgICAgICAgXCJzdHlsZVwiLFxuICAgICAgICBcIm9iamVjdEZpdFwiLFxuICAgICAgICBcIm9iamVjdFBvc2l0aW9uXCIsXG4gICAgICAgIFwib25Mb2FkaW5nQ29tcGxldGVcIixcbiAgICAgICAgXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICBcImJsdXJEYXRhVVJMXCJcbiAgICBdKTtcbiAgICBjb25zdCBjb25maWdDb250ZXh0ID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfaW1hZ2VDb25maWdDb250ZXh0LkltYWdlQ29uZmlnQ29udGV4dCk7XG4gICAgY29uc3QgY29uZmlnID0gKDAsIF9yZWFjdCkudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCBjID0gY29uZmlnRW52IHx8IGNvbmZpZ0NvbnRleHQgfHwgX2ltYWdlQ29uZmlnLmltYWdlQ29uZmlnRGVmYXVsdDtcbiAgICAgICAgY29uc3QgYWxsU2l6ZXMgPSBbXG4gICAgICAgICAgICAuLi5jLmRldmljZVNpemVzLFxuICAgICAgICAgICAgLi4uYy5pbWFnZVNpemVzXG4gICAgICAgIF0uc29ydCgoYSwgYik9PmEgLSBiKTtcbiAgICAgICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBjLmRldmljZVNpemVzLnNvcnQoKGEsIGIpPT5hIC0gYik7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYywge1xuICAgICAgICAgICAgYWxsU2l6ZXMsXG4gICAgICAgICAgICBkZXZpY2VTaXplc1xuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIGNvbmZpZ0NvbnRleHRcbiAgICBdKTtcbiAgICBsZXQgcmVzdCA9IGFsbDtcbiAgICBsZXQgbGF5b3V0ID0gc2l6ZXMgPyAncmVzcG9uc2l2ZScgOiAnaW50cmluc2ljJztcbiAgICBpZiAoJ2xheW91dCcgaW4gcmVzdCkge1xuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0IGxheW91dCBpZiB0aGUgdXNlciBzcGVjaWZpZWQgb25lOlxuICAgICAgICBpZiAocmVzdC5sYXlvdXQpIGxheW91dCA9IHJlc3QubGF5b3V0O1xuICAgICAgICAvLyBSZW1vdmUgcHJvcGVydHkgc28gaXQncyBub3Qgc3ByZWFkIG9uIDxpbWc+OlxuICAgICAgICBkZWxldGUgcmVzdC5sYXlvdXQ7XG4gICAgfVxuICAgIGxldCBsb2FkZXIgPSBkZWZhdWx0SW1hZ2VMb2FkZXI7XG4gICAgaWYgKCdsb2FkZXInIGluIHJlc3QpIHtcbiAgICAgICAgaWYgKHJlc3QubG9hZGVyKSB7XG4gICAgICAgICAgICBjb25zdCBjdXN0b21JbWFnZUxvYWRlciA9IHJlc3QubG9hZGVyO1xuICAgICAgICAgICAgdmFyIF90bXA7XG4gICAgICAgICAgICBfdG1wID0gKG9iaik9PntcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvbmZpZzogXyAgfSA9IG9iaiwgb3B0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKG9iaiwgW1xuICAgICAgICAgICAgICAgICAgICBcImNvbmZpZ1wiXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbmZpZyBvYmplY3QgaXMgaW50ZXJuYWwgb25seSBzbyB3ZSBtdXN0XG4gICAgICAgICAgICAgICAgLy8gbm90IHBhc3MgaXQgdG8gdGhlIHVzZXItZGVmaW5lZCBsb2FkZXIoKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21JbWFnZUxvYWRlcihvcHRzKTtcbiAgICAgICAgICAgIH0sIGxvYWRlciA9IF90bXAsIF90bXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHByb3BlcnR5IHNvIGl0J3Mgbm90IHNwcmVhZCBvbiA8aW1nPlxuICAgICAgICBkZWxldGUgcmVzdC5sb2FkZXI7XG4gICAgfVxuICAgIGxldCBzdGF0aWNTcmMgPSAnJztcbiAgICBpZiAoaXNTdGF0aWNJbXBvcnQoc3JjKSkge1xuICAgICAgICBjb25zdCBzdGF0aWNJbWFnZURhdGEgPSBpc1N0YXRpY1JlcXVpcmUoc3JjKSA/IHNyYy5kZWZhdWx0IDogc3JjO1xuICAgICAgICBpZiAoIXN0YXRpY0ltYWdlRGF0YS5zcmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBzcmMuIFJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoc3RhdGljSW1hZ2VEYXRhKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBibHVyRGF0YVVSTCA9IGJsdXJEYXRhVVJMIHx8IHN0YXRpY0ltYWdlRGF0YS5ibHVyRGF0YVVSTDtcbiAgICAgICAgc3RhdGljU3JjID0gc3RhdGljSW1hZ2VEYXRhLnNyYztcbiAgICAgICAgaWYgKCFsYXlvdXQgfHwgbGF5b3V0ICE9PSAnZmlsbCcpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCBzdGF0aWNJbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgd2lkdGggPSB3aWR0aCB8fCBzdGF0aWNJbWFnZURhdGEud2lkdGg7XG4gICAgICAgICAgICBpZiAoIXN0YXRpY0ltYWdlRGF0YS5oZWlnaHQgfHwgIXN0YXRpY0ltYWdlRGF0YS53aWR0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBoZWlnaHQgYW5kIHdpZHRoLiBSZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHN0YXRpY0ltYWdlRGF0YSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3JjID0gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyBzcmMgOiBzdGF0aWNTcmM7XG4gICAgY29uc3Qgd2lkdGhJbnQgPSBnZXRJbnQod2lkdGgpO1xuICAgIGNvbnN0IGhlaWdodEludCA9IGdldEludChoZWlnaHQpO1xuICAgIGNvbnN0IHF1YWxpdHlJbnQgPSBnZXRJbnQocXVhbGl0eSk7XG4gICAgbGV0IGlzTGF6eSA9ICFwcmlvcml0eSAmJiAobG9hZGluZyA9PT0gJ2xhenknIHx8IHR5cGVvZiBsb2FkaW5nID09PSAndW5kZWZpbmVkJyk7XG4gICAgaWYgKHNyYy5zdGFydHNXaXRoKCdkYXRhOicpIHx8IHNyYy5zdGFydHNXaXRoKCdibG9iOicpKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvRGF0YV9VUklzXG4gICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgaXNMYXp5ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBsb2FkZWRJbWFnZVVSTHMuaGFzKHNyYykpIHtcbiAgICAgICAgaXNMYXp5ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChleHBlcmltZW50YWxVbm9wdGltaXplZCkge1xuICAgICAgICB1bm9wdGltaXplZCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IFtibHVyQ29tcGxldGUsIHNldEJsdXJDb21wbGV0ZV0gPSAoMCwgX3JlYWN0KS51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3NldEludGVyc2VjdGlvbiwgaXNJbnRlcnNlY3RlZCwgcmVzZXRJbnRlcnNlY3RlZF0gPSAoMCwgX3VzZUludGVyc2VjdGlvbikudXNlSW50ZXJzZWN0aW9uKHtcbiAgICAgICAgcm9vdFJlZjogbGF6eVJvb3QsXG4gICAgICAgIHJvb3RNYXJnaW46IGxhenlCb3VuZGFyeSB8fCAnMjAwcHgnLFxuICAgICAgICBkaXNhYmxlZDogIWlzTGF6eVxuICAgIH0pO1xuICAgIGNvbnN0IGlzVmlzaWJsZSA9ICFpc0xhenkgfHwgaXNJbnRlcnNlY3RlZDtcbiAgICBjb25zdCB3cmFwcGVyU3R5bGUgPSB7XG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIHdpZHRoOiAnaW5pdGlhbCcsXG4gICAgICAgIGhlaWdodDogJ2luaXRpYWwnLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBwYWRkaW5nOiAwXG4gICAgfTtcbiAgICBjb25zdCBzaXplclN0eWxlID0ge1xuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgd2lkdGg6ICdpbml0aWFsJyxcbiAgICAgICAgaGVpZ2h0OiAnaW5pdGlhbCcsXG4gICAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBhZGRpbmc6IDBcbiAgICB9O1xuICAgIGxldCBoYXNTaXplciA9IGZhbHNlO1xuICAgIGxldCBzaXplclN2Z1VybDtcbiAgICBjb25zdCBsYXlvdXRTdHlsZSA9IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICBtYXJnaW46ICdhdXRvJyxcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgbWluV2lkdGg6ICcxMDAlJyxcbiAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgbWluSGVpZ2h0OiAnMTAwJScsXG4gICAgICAgIG1heEhlaWdodDogJzEwMCUnLFxuICAgICAgICBvYmplY3RGaXQsXG4gICAgICAgIG9iamVjdFBvc2l0aW9uXG4gICAgfTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSBpcyBtaXNzaW5nIHJlcXVpcmVkIFwic3JjXCIgcHJvcGVydHkuIE1ha2Ugc3VyZSB5b3UgcGFzcyBcInNyY1wiIGluIHByb3BzIHRvIHRoZSBcXGBuZXh0L2ltYWdlXFxgIGNvbXBvbmVudC4gUmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICBxdWFsaXR5XG4gICAgICAgICAgICB9KX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVZBTElEX0xBWU9VVF9WQUxVRVMuaW5jbHVkZXMobGF5b3V0KSkge1xuICAgICAgICAgICAgaWYgKGxheW91dCA9PT0gJ3JhdycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBsYXlvdXQ9XCJyYXdcIiBleHBlcmltZW50IGhhcyBiZWVuIG1vdmVkIHRvIGEgbmV3IG1vZHVsZS4gUGxlYXNlIGltcG9ydCBcXGBuZXh0L2Z1dHVyZS9pbWFnZVxcYCBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwibGF5b3V0XCIgcHJvcGVydHkuIFByb3ZpZGVkIFwiJHtsYXlvdXR9XCIgc2hvdWxkIGJlIG9uZSBvZiAke1ZBTElEX0xBWU9VVF9WQUxVRVMubWFwKFN0cmluZykuam9pbignLCcpfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpZHRoSW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hTih3aWR0aEludCkgfHwgdHlwZW9mIGhlaWdodEludCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYU4oaGVpZ2h0SW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwid2lkdGhcIiBvciBcImhlaWdodFwiIHByb3BlcnR5LiBUaGVzZSBzaG91bGQgYmUgbnVtZXJpYyB2YWx1ZXMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxheW91dCA9PT0gJ2ZpbGwnICYmICh3aWR0aCB8fCBoZWlnaHQpKSB7XG4gICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBhbmQgXCJsYXlvdXQ9J2ZpbGwnXCIgaGFzIHVudXNlZCBwcm9wZXJ0aWVzIGFzc2lnbmVkLiBQbGVhc2UgcmVtb3ZlIFwid2lkdGhcIiBhbmQgXCJoZWlnaHRcIi5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVZBTElEX0xPQURJTkdfVkFMVUVTLmluY2x1ZGVzKGxvYWRpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGludmFsaWQgXCJsb2FkaW5nXCIgcHJvcGVydHkuIFByb3ZpZGVkIFwiJHtsb2FkaW5nfVwiIHNob3VsZCBiZSBvbmUgb2YgJHtWQUxJRF9MT0FESU5HX1ZBTFVFUy5tYXAoU3RyaW5nKS5qb2luKCcsJyl9LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmlvcml0eSAmJiBsb2FkaW5nID09PSAnbGF6eScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYm90aCBcInByaW9yaXR5XCIgYW5kIFwibG9hZGluZz0nbGF6eSdcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2l6ZXMgJiYgbGF5b3V0ICE9PSAnZmlsbCcgJiYgbGF5b3V0ICE9PSAncmVzcG9uc2l2ZScpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbHMpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBcInNpemVzXCIgcHJvcGVydHkgYnV0IGl0IHdpbGwgYmUgaWdub3JlZC4gT25seSB1c2UgXCJzaXplc1wiIHdpdGggXCJsYXlvdXQ9J2ZpbGwnXCIgb3IgXCJsYXlvdXQ9J3Jlc3BvbnNpdmUnXCJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2Vob2xkZXIgPT09ICdibHVyJykge1xuICAgICAgICAgICAgaWYgKGxheW91dCAhPT0gJ2ZpbGwnICYmICh3aWR0aEludCB8fCAwKSAqIChoZWlnaHRJbnQgfHwgMCkgPCAxNjAwKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgc21hbGxlciB0aGFuIDQweDQwLiBDb25zaWRlciByZW1vdmluZyB0aGUgXCJwbGFjZWhvbGRlcj0nYmx1cidcIiBwcm9wZXJ0eSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFibHVyRGF0YVVSTCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFZBTElEX0JMVVJfRVhUID0gW1xuICAgICAgICAgICAgICAgICAgICAnanBlZycsXG4gICAgICAgICAgICAgICAgICAgICdwbmcnLFxuICAgICAgICAgICAgICAgICAgICAnd2VicCcsXG4gICAgICAgICAgICAgICAgICAgICdhdmlmJ1xuICAgICAgICAgICAgICAgIF0gLy8gc2hvdWxkIG1hdGNoIG5leHQtaW1hZ2UtbG9hZGVyXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgXCJwbGFjZWhvbGRlcj0nYmx1cidcIiBwcm9wZXJ0eSBidXQgaXMgbWlzc2luZyB0aGUgXCJibHVyRGF0YVVSTFwiIHByb3BlcnR5LlxuICAgICAgICAgIFBvc3NpYmxlIHNvbHV0aW9uczpcbiAgICAgICAgICAgIC0gQWRkIGEgXCJibHVyRGF0YVVSTFwiIHByb3BlcnR5LCB0aGUgY29udGVudHMgc2hvdWxkIGJlIGEgc21hbGwgRGF0YSBVUkwgdG8gcmVwcmVzZW50IHRoZSBpbWFnZVxuICAgICAgICAgICAgLSBDaGFuZ2UgdGhlIFwic3JjXCIgcHJvcGVydHkgdG8gYSBzdGF0aWMgaW1wb3J0IHdpdGggb25lIG9mIHRoZSBzdXBwb3J0ZWQgZmlsZSB0eXBlczogJHtWQUxJRF9CTFVSX0VYVC5qb2luKCcsJyl9XG4gICAgICAgICAgICAtIFJlbW92ZSB0aGUgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5LCBlZmZlY3RpdmVseSBubyBibHVyIGVmZmVjdFxuICAgICAgICAgIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcGxhY2Vob2xkZXItYmx1ci1kYXRhLXVybGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgncmVmJyBpbiByZXN0KSB7XG4gICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyB1c2luZyB1bnN1cHBvcnRlZCBcInJlZlwiIHByb3BlcnR5LiBDb25zaWRlciB1c2luZyB0aGUgXCJvbkxvYWRpbmdDb21wbGV0ZVwiIHByb3BlcnR5IGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1bm9wdGltaXplZCAmJiBsb2FkZXIgIT09IGRlZmF1bHRJbWFnZUxvYWRlcikge1xuICAgICAgICAgICAgY29uc3QgdXJsU3RyID0gbG9hZGVyKHtcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aEludCB8fCA0MDAsXG4gICAgICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCB8fCA3NVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgdXJsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHVybFN0cik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICBpZiAodXJsU3RyID09PSBzcmMgfHwgdXJsICYmIHVybC5wYXRobmFtZSA9PT0gc3JjICYmICF1cmwuc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGEgXCJsb2FkZXJcIiBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IGltcGxlbWVudCB3aWR0aC4gUGxlYXNlIGltcGxlbWVudCBpdCBvciB1c2UgdGhlIFwidW5vcHRpbWl6ZWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLmAgKyBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyLXdpZHRoYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcndyaXR0ZW5TdHlsZXMgPSBPYmplY3Qua2V5cyhzdHlsZSkuZmlsdGVyKChrZXkpPT5rZXkgaW4gbGF5b3V0U3R5bGUpO1xuICAgICAgICAgICAgaWYgKG92ZXJ3cml0dGVuU3R5bGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbHMpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyAke3NyY30gaXMgYXNzaWduZWQgdGhlIGZvbGxvd2luZyBzdHlsZXMsIHdoaWNoIGFyZSBvdmVyd3JpdHRlbiBieSBhdXRvbWF0aWNhbGx5LWdlbmVyYXRlZCBzdHlsZXM6ICR7b3ZlcndyaXR0ZW5TdHlsZXMuam9pbignLCAnKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXBlcmZPYnNlcnZlciAmJiB3aW5kb3cuUGVyZm9ybWFuY2VPYnNlcnZlcikge1xuICAgICAgICAgICAgcGVyZk9ic2VydmVyID0gbmV3IFBlcmZvcm1hbmNlT2JzZXJ2ZXIoKGVudHJ5TGlzdCk9PntcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJ5TGlzdC5nZXRFbnRyaWVzKCkpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gbWlzc2luZyBcIkxhcmdlc3RDb250ZW50ZnVsUGFpbnRcIiBjbGFzcyB3aXRoIFwiZWxlbWVudFwiIHByb3BcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1nU3JjID0gKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiAocmVmID0gZW50cnkuZWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5zcmMpIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsY3BJbWFnZSA9IGFsbEltZ3MuZ2V0KGltZ1NyYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsY3BJbWFnZSAmJiAhbGNwSW1hZ2UucHJpb3JpdHkgJiYgbGNwSW1hZ2UucGxhY2Vob2xkZXIgIT09ICdibHVyJyAmJiAhbGNwSW1hZ2Uuc3JjLnN0YXJ0c1dpdGgoJ2RhdGE6JykgJiYgIWxjcEltYWdlLnNyYy5zdGFydHNXaXRoKCdibG9iOicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3dlYi5kZXYvbGNwLyNtZWFzdXJlLWxjcC1pbi1qYXZhc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke2xjcEltYWdlLnNyY31cIiB3YXMgZGV0ZWN0ZWQgYXMgdGhlIExhcmdlc3QgQ29udGVudGZ1bCBQYWludCAoTENQKS4gUGxlYXNlIGFkZCB0aGUgXCJwcmlvcml0eVwiIHByb3BlcnR5IGlmIHRoaXMgaW1hZ2UgaXMgYWJvdmUgdGhlIGZvbGQuYCArIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNwcmlvcml0eWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBlcmZPYnNlcnZlci5vYnNlcnZlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xhcmdlc3QtY29udGVudGZ1bC1wYWludCcsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2cgZXJyb3IgYnV0IGRvbid0IGNyYXNoIHRoZSBhcHBcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW1nU3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwgbGF5b3V0U3R5bGUpO1xuICAgIGNvbnN0IGJsdXJTdHlsZSA9IHBsYWNlaG9sZGVyID09PSAnYmx1cicgJiYgIWJsdXJDb21wbGV0ZSA/IHtcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IG9iamVjdEZpdCB8fCAnY292ZXInLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IG9iamVjdFBvc2l0aW9uIHx8ICcwJSAwJScsXG4gICAgICAgIGZpbHRlcjogJ2JsdXIoMjBweCknLFxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoXCIke2JsdXJEYXRhVVJMfVwiKWBcbiAgICB9IDoge307XG4gICAgaWYgKGxheW91dCA9PT0gJ2ZpbGwnKSB7XG4gICAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIGxheW91dD1cImZpbGxcIiAvPlxuICAgICAgICB3cmFwcGVyU3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHdyYXBwZXJTdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHdyYXBwZXJTdHlsZS50b3AgPSAwO1xuICAgICAgICB3cmFwcGVyU3R5bGUubGVmdCA9IDA7XG4gICAgICAgIHdyYXBwZXJTdHlsZS5ib3R0b20gPSAwO1xuICAgICAgICB3cmFwcGVyU3R5bGUucmlnaHQgPSAwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpZHRoSW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaGVpZ2h0SW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIC8+XG4gICAgICAgIGNvbnN0IHF1b3RpZW50ID0gaGVpZ2h0SW50IC8gd2lkdGhJbnQ7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdUb3AgPSBpc05hTihxdW90aWVudCkgPyAnMTAwJScgOiBgJHtxdW90aWVudCAqIDEwMH0lYDtcbiAgICAgICAgaWYgKGxheW91dCA9PT0gJ3Jlc3BvbnNpdmUnKSB7XG4gICAgICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIGxheW91dD1cInJlc3BvbnNpdmVcIiAvPlxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgIGhhc1NpemVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHNpemVyU3R5bGUucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3A7XG4gICAgICAgIH0gZWxzZSBpZiAobGF5b3V0ID09PSAnaW50cmluc2ljJykge1xuICAgICAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiBsYXlvdXQ9XCJpbnRyaW5zaWNcIiAvPlxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUubWF4V2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgICBoYXNTaXplciA9IHRydWU7XG4gICAgICAgICAgICBzaXplclN0eWxlLm1heFdpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgc2l6ZXJTdmdVcmwgPSBgZGF0YTppbWFnZS9zdmcreG1sLCUzY3N2ZyUyMHhtbG5zPSUyN2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJTI3JTIwdmVyc2lvbj0lMjcxLjElMjclMjB3aWR0aD0lMjcke3dpZHRoSW50fSUyNyUyMGhlaWdodD0lMjcke2hlaWdodEludH0lMjcvJTNlYDtcbiAgICAgICAgfSBlbHNlIGlmIChsYXlvdXQgPT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgbGF5b3V0PVwiZml4ZWRcIiAvPlxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUud2lkdGggPSB3aWR0aEludDtcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5oZWlnaHQgPSBoZWlnaHRJbnQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiAvPlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIG11c3QgdXNlIFwid2lkdGhcIiBhbmQgXCJoZWlnaHRcIiBwcm9wZXJ0aWVzIG9yIFwibGF5b3V0PSdmaWxsJ1wiIHByb3BlcnR5LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBpbWdBdHRyaWJ1dGVzID0ge1xuICAgICAgICBzcmM6IGVtcHR5RGF0YVVSTCxcbiAgICAgICAgc3JjU2V0OiB1bmRlZmluZWQsXG4gICAgICAgIHNpemVzOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgaW1nQXR0cmlidXRlcyA9IGdlbmVyYXRlSW1nQXR0cnMoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgICAgICBsYXlvdXQsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGhJbnQsXG4gICAgICAgICAgICBxdWFsaXR5OiBxdWFsaXR5SW50LFxuICAgICAgICAgICAgc2l6ZXMsXG4gICAgICAgICAgICBsb2FkZXJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBzcmNTdHJpbmcgPSBzcmM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsZXQgZnVsbFVybDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnVsbFVybCA9IG5ldyBVUkwoaW1nQXR0cmlidXRlcy5zcmMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGZ1bGxVcmwgPSBuZXcgVVJMKGltZ0F0dHJpYnV0ZXMuc3JjLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbGxJbWdzLnNldChmdWxsVXJsLmhyZWYsIHtcbiAgICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBpbWFnZVNyY1NldFByb3BOYW1lID0gJ2ltYWdlc3Jjc2V0JztcbiAgICBsZXQgaW1hZ2VTaXplc1Byb3BOYW1lID0gJ2ltYWdlc2l6ZXMnO1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfUkVBQ1RfUk9PVCkge1xuICAgICAgICBpbWFnZVNyY1NldFByb3BOYW1lID0gJ2ltYWdlU3JjU2V0JztcbiAgICAgICAgaW1hZ2VTaXplc1Byb3BOYW1lID0gJ2ltYWdlU2l6ZXMnO1xuICAgIH1cbiAgICBjb25zdCBsaW5rUHJvcHMgPSB7XG4gICAgICAgIC8vIE5vdGU6IGltYWdlc3Jjc2V0IGFuZCBpbWFnZXNpemVzIGFyZSBub3QgaW4gdGhlIGxpbmsgZWxlbWVudCB0eXBlIHdpdGggcmVhY3QgMTcuXG4gICAgICAgIFtpbWFnZVNyY1NldFByb3BOYW1lXTogaW1nQXR0cmlidXRlcy5zcmNTZXQsXG4gICAgICAgIFtpbWFnZVNpemVzUHJvcE5hbWVdOiBpbWdBdHRyaWJ1dGVzLnNpemVzXG4gICAgfTtcbiAgICBjb25zdCB1c2VMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCA6IF9yZWFjdC5kZWZhdWx0LnVzZUxheW91dEVmZmVjdDtcbiAgICBjb25zdCBvbkxvYWRpbmdDb21wbGV0ZVJlZiA9ICgwLCBfcmVhY3QpLnVzZVJlZihvbkxvYWRpbmdDb21wbGV0ZSk7XG4gICAgY29uc3QgcHJldmlvdXNJbWFnZVNyYyA9ICgwLCBfcmVhY3QpLnVzZVJlZihzcmMpO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50ID0gb25Mb2FkaW5nQ29tcGxldGU7XG4gICAgfSwgW1xuICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVxuICAgIF0pO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAocHJldmlvdXNJbWFnZVNyYy5jdXJyZW50ICE9PSBzcmMpIHtcbiAgICAgICAgICAgIHJlc2V0SW50ZXJzZWN0ZWQoKTtcbiAgICAgICAgICAgIHByZXZpb3VzSW1hZ2VTcmMuY3VycmVudCA9IHNyYztcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgcmVzZXRJbnRlcnNlY3RlZCxcbiAgICAgICAgc3JjXG4gICAgXSk7XG4gICAgY29uc3QgaW1nRWxlbWVudEFyZ3MgPSBfZXh0ZW5kcyh7XG4gICAgICAgIGlzTGF6eSxcbiAgICAgICAgaW1nQXR0cmlidXRlcyxcbiAgICAgICAgaGVpZ2h0SW50LFxuICAgICAgICB3aWR0aEludCxcbiAgICAgICAgcXVhbGl0eUludCxcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIGltZ1N0eWxlLFxuICAgICAgICBibHVyU3R5bGUsXG4gICAgICAgIGxvYWRpbmcsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICBsb2FkZXIsXG4gICAgICAgIHNyY1N0cmluZyxcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgICAgc2V0SW50ZXJzZWN0aW9uLFxuICAgICAgICBpc1Zpc2libGUsXG4gICAgICAgIG5vc2NyaXB0U2l6ZXM6IHNpemVzXG4gICAgfSwgcmVzdCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIHN0eWxlOiB3cmFwcGVyU3R5bGVcbiAgICB9LCBoYXNTaXplciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBzdHlsZTogc2l6ZXJTdHlsZVxuICAgIH0sIHNpemVyU3ZnVXJsID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgd2lkdGg6ICdpbml0aWFsJyxcbiAgICAgICAgICAgIGhlaWdodDogJ2luaXRpYWwnLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogJ25vbmUnLFxuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICAgIHBhZGRpbmc6IDBcbiAgICAgICAgfSxcbiAgICAgICAgYWx0OiBcIlwiLFxuICAgICAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgICAgIHNyYzogc2l6ZXJTdmdVcmxcbiAgICB9KSA6IG51bGwpIDogbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEltYWdlRWxlbWVudCwgT2JqZWN0LmFzc2lnbih7fSwgaW1nRWxlbWVudEFyZ3MpKSksIHByaW9yaXR5ID8gLy8gTm90ZSBob3cgd2Ugb21pdCB0aGUgYGhyZWZgIGF0dHJpYnV0ZSwgYXMgaXQgd291bGQgb25seSBiZSByZWxldmFudFxuICAgIC8vIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGBpbWFnZXNyY3NldGAsIGFuZCBpbiB0aG9zZSBjYXNlc1xuICAgIC8vIGl0IHdvdWxkIGxpa2VseSBjYXVzZSB0aGUgaW5jb3JyZWN0IGltYWdlIHRvIGJlIHByZWxvYWRlZC5cbiAgICAvL1xuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI2F0dHItbGluay1pbWFnZXNyY3NldFxuICAgIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaGVhZC5kZWZhdWx0LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBrZXk6ICdfX25pbWctJyArIGltZ0F0dHJpYnV0ZXMuc3JjICsgaW1nQXR0cmlidXRlcy5zcmNTZXQgKyBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICBhczogXCJpbWFnZVwiLFxuICAgICAgICBocmVmOiBpbWdBdHRyaWJ1dGVzLnNyY1NldCA/IHVuZGVmaW5lZCA6IGltZ0F0dHJpYnV0ZXMuc3JjXG4gICAgfSwgbGlua1Byb3BzKSkpIDogbnVsbCk7XG59XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSl7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICAgIGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuICAgIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgfTtcbiAgICByZXR1cm4gY2FjaGU7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IG9ialxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTtcbiAgICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmdldChvYmopO1xuICAgIH1cbiAgICB2YXIgbmV3T2JqID0ge307XG4gICAgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgIGZvcih2YXIga2V5IGluIG9iail7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgICBjYWNoZS5zZXQob2JqLCBuZXdPYmopO1xuICAgIH1cbiAgICByZXR1cm4gbmV3T2JqO1xufVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgdmFyIGtleSwgaTtcbiAgICBmb3IoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmNvbnN0IHsgZXhwZXJpbWVudGFsUmVtb3RlUGF0dGVybnMgPVtdICwgZXhwZXJpbWVudGFsVW5vcHRpbWl6ZWQgIH0gPSBwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUUyB8fCB7fTtcbmNvbnN0IGNvbmZpZ0VudiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTO1xuY29uc3QgbG9hZGVkSW1hZ2VVUkxzID0gbmV3IFNldCgpO1xuY29uc3QgYWxsSW1ncyA9IG5ldyBNYXAoKTtcbmxldCBwZXJmT2JzZXJ2ZXI7XG5jb25zdCBlbXB0eURhdGFVUkwgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3JztcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIGdsb2JhbC5fX05FWFRfSU1BR0VfSU1QT1JURUQgPSB0cnVlO1xufVxuY29uc3QgVkFMSURfTE9BRElOR19WQUxVRVMgPSBbXG4gICAgJ2xhenknLFxuICAgICdlYWdlcicsXG4gICAgdW5kZWZpbmVkXG5dO1xuY29uc3QgbG9hZGVycyA9IG5ldyBNYXAoW1xuICAgIFtcbiAgICAgICAgJ2RlZmF1bHQnLFxuICAgICAgICBkZWZhdWx0TG9hZGVyXG4gICAgXSxcbiAgICBbXG4gICAgICAgICdpbWdpeCcsXG4gICAgICAgIGltZ2l4TG9hZGVyXG4gICAgXSxcbiAgICBbXG4gICAgICAgICdjbG91ZGluYXJ5JyxcbiAgICAgICAgY2xvdWRpbmFyeUxvYWRlclxuICAgIF0sXG4gICAgW1xuICAgICAgICAnYWthbWFpJyxcbiAgICAgICAgYWthbWFpTG9hZGVyXG4gICAgXSxcbiAgICBbXG4gICAgICAgICdjdXN0b20nLFxuICAgICAgICBjdXN0b21Mb2FkZXJcbiAgICBdLCBcbl0pO1xuY29uc3QgVkFMSURfTEFZT1VUX1ZBTFVFUyA9IFtcbiAgICAnZmlsbCcsXG4gICAgJ2ZpeGVkJyxcbiAgICAnaW50cmluc2ljJyxcbiAgICAncmVzcG9uc2l2ZScsXG4gICAgdW5kZWZpbmVkLCBcbl07XG5mdW5jdGlvbiBpc1N0YXRpY1JlcXVpcmUoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5kZWZhdWx0ICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc1N0YXRpY0ltYWdlRGF0YShzcmMpIHtcbiAgICByZXR1cm4gc3JjLnNyYyAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNTdGF0aWNJbXBvcnQoc3JjKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzcmMgPT09ICdvYmplY3QnICYmIChpc1N0YXRpY1JlcXVpcmUoc3JjKSB8fCBpc1N0YXRpY0ltYWdlRGF0YShzcmMpKTtcbn1cbmZ1bmN0aW9uIGdldFdpZHRocyh7IGRldmljZVNpemVzICwgYWxsU2l6ZXMgIH0sIHdpZHRoLCBsYXlvdXQsIHNpemVzKSB7XG4gICAgaWYgKHNpemVzICYmIChsYXlvdXQgPT09ICdmaWxsJyB8fCBsYXlvdXQgPT09ICdyZXNwb25zaXZlJykpIHtcbiAgICAgICAgLy8gRmluZCBhbGwgdGhlIFwidndcIiBwZXJjZW50IHNpemVzIHVzZWQgaW4gdGhlIHNpemVzIHByb3BcbiAgICAgICAgY29uc3Qgdmlld3BvcnRXaWR0aFJlID0gLyhefFxccykoMT9cXGQ/XFxkKXZ3L2c7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRTaXplcyA9IFtdO1xuICAgICAgICBmb3IobGV0IG1hdGNoOyBtYXRjaCA9IHZpZXdwb3J0V2lkdGhSZS5leGVjKHNpemVzKTsgbWF0Y2gpe1xuICAgICAgICAgICAgcGVyY2VudFNpemVzLnB1c2gocGFyc2VJbnQobWF0Y2hbMl0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVyY2VudFNpemVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc21hbGxlc3RSYXRpbyA9IE1hdGgubWluKC4uLnBlcmNlbnRTaXplcykgKiAwLjAxO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aHM6IGFsbFNpemVzLmZpbHRlcigocyk9PnMgPj0gZGV2aWNlU2l6ZXNbMF0gKiBzbWFsbGVzdFJhdGlvKSxcbiAgICAgICAgICAgICAgICBraW5kOiAndydcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoczogYWxsU2l6ZXMsXG4gICAgICAgICAgICBraW5kOiAndydcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ251bWJlcicgfHwgbGF5b3V0ID09PSAnZmlsbCcgfHwgbGF5b3V0ID09PSAncmVzcG9uc2l2ZScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoczogZGV2aWNlU2l6ZXMsXG4gICAgICAgICAgICBraW5kOiAndydcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGhzID0gW1xuICAgICAgICAuLi5uZXcgU2V0KC8vID4gVGhpcyBtZWFucyB0aGF0IG1vc3QgT0xFRCBzY3JlZW5zIHRoYXQgc2F5IHRoZXkgYXJlIDN4IHJlc29sdXRpb24sXG4gICAgICAgIC8vID4gYXJlIGFjdHVhbGx5IDN4IGluIHRoZSBncmVlbiBjb2xvciwgYnV0IG9ubHkgMS41eCBpbiB0aGUgcmVkIGFuZFxuICAgICAgICAvLyA+IGJsdWUgY29sb3JzLiBTaG93aW5nIGEgM3ggcmVzb2x1dGlvbiBpbWFnZSBpbiB0aGUgYXBwIHZzIGEgMnhcbiAgICAgICAgLy8gPiByZXNvbHV0aW9uIGltYWdlIHdpbGwgYmUgdmlzdWFsbHkgdGhlIHNhbWUsIHRob3VnaCB0aGUgM3ggaW1hZ2VcbiAgICAgICAgLy8gPiB0YWtlcyBzaWduaWZpY2FudGx5IG1vcmUgZGF0YS4gRXZlbiB0cnVlIDN4IHJlc29sdXRpb24gc2NyZWVucyBhcmVcbiAgICAgICAgLy8gPiB3YXN0ZWZ1bCBhcyB0aGUgaHVtYW4gZXllIGNhbm5vdCBzZWUgdGhhdCBsZXZlbCBvZiBkZXRhaWwgd2l0aG91dFxuICAgICAgICAvLyA+IHNvbWV0aGluZyBsaWtlIGEgbWFnbmlmeWluZyBnbGFzcy5cbiAgICAgICAgLy8gaHR0cHM6Ly9ibG9nLnR3aXR0ZXIuY29tL2VuZ2luZWVyaW5nL2VuX3VzL3RvcGljcy9pbmZyYXN0cnVjdHVyZS8yMDE5L2NhcHBpbmctaW1hZ2UtZmlkZWxpdHktb24tdWx0cmEtaGlnaC1yZXNvbHV0aW9uLWRldmljZXMuaHRtbFxuICAgICAgICBbXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIHdpZHRoICogMiAvKiwgd2lkdGggKiAzKi8gXG4gICAgICAgIF0ubWFwKCh3KT0+YWxsU2l6ZXMuZmluZCgocCk9PnAgPj0gdykgfHwgYWxsU2l6ZXNbYWxsU2l6ZXMubGVuZ3RoIC0gMV0pKSwgXG4gICAgXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aHMsXG4gICAgICAgIGtpbmQ6ICd4J1xuICAgIH07XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltZ0F0dHJzKHsgY29uZmlnICwgc3JjICwgdW5vcHRpbWl6ZWQgLCBsYXlvdXQgLCB3aWR0aCAsIHF1YWxpdHkgLCBzaXplcyAsIGxvYWRlciAgfSkge1xuICAgIGlmICh1bm9wdGltaXplZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgc3JjU2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaXplczogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHsgd2lkdGhzICwga2luZCAgfSA9IGdldFdpZHRocyhjb25maWcsIHdpZHRoLCBsYXlvdXQsIHNpemVzKTtcbiAgICBjb25zdCBsYXN0ID0gd2lkdGhzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2l6ZXM6ICFzaXplcyAmJiBraW5kID09PSAndycgPyAnMTAwdncnIDogc2l6ZXMsXG4gICAgICAgIHNyY1NldDogd2lkdGhzLm1hcCgodywgaSk9PmAke2xvYWRlcih7XG4gICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICBxdWFsaXR5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3XG4gICAgICAgICAgICB9KX0gJHtraW5kID09PSAndycgPyB3IDogaSArIDF9JHtraW5kfWApLmpvaW4oJywgJyksXG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgc3JjYCB0aGUgbGFzdCBhdHRyaWJ1dGUgYmVjYXVzZSBSZWFjdCB1cGRhdGVzXG4gICAgICAgIC8vIGF0dHJpYnV0ZXMgaW4gb3JkZXIuIElmIHdlIGtlZXAgYHNyY2AgdGhlIGZpcnN0IG9uZSwgU2FmYXJpIHdpbGxcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgc3RhcnQgdG8gZmV0Y2ggYHNyY2AsIGJlZm9yZSBgc2l6ZXNgIGFuZCBgc3JjU2V0YCBhcmUgZXZlblxuICAgICAgICAvLyB1cGRhdGVkIGJ5IFJlYWN0LiBUaGF0IGNhdXNlcyBtdWx0aXBsZSB1bm5lY2Vzc2FyeSByZXF1ZXN0cyBpZiBgc3JjU2V0YFxuICAgICAgICAvLyBhbmQgYHNpemVzYCBhcmUgZGVmaW5lZC5cbiAgICAgICAgLy8gVGhpcyBidWcgY2Fubm90IGJlIHJlcHJvZHVjZWQgaW4gQ2hyb21lIG9yIEZpcmVmb3guXG4gICAgICAgIHNyYzogbG9hZGVyKHtcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHF1YWxpdHksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGhzW2xhc3RdXG4gICAgICAgIH0pXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEludCh4KSB7XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoeCwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZGVmYXVsdEltYWdlTG9hZGVyKGxvYWRlclByb3BzKSB7XG4gICAgdmFyIHJlZjtcbiAgICBjb25zdCBsb2FkZXJLZXkgPSAoKHJlZiA9IGxvYWRlclByb3BzLmNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5sb2FkZXIpIHx8ICdkZWZhdWx0JztcbiAgICBjb25zdCBsb2FkID0gbG9hZGVycy5nZXQobG9hZGVyS2V5KTtcbiAgICBpZiAobG9hZCkge1xuICAgICAgICByZXR1cm4gbG9hZChsb2FkZXJQcm9wcyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBcImxvYWRlclwiIGZvdW5kIGluIFwibmV4dC5jb25maWcuanNcIi4gRXhwZWN0ZWQ6ICR7X2ltYWdlQ29uZmlnLlZBTElEX0xPQURFUlMuam9pbignLCAnKX0uIFJlY2VpdmVkOiAke2xvYWRlcktleX1gKTtcbn1cbi8vIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzk3Nzc4MzMvMjY2NTM1IGZvciB3aHkgd2UgdXNlIHRoaXMgcmVmXG4vLyBoYW5kbGVyIGluc3RlYWQgb2YgdGhlIGltZydzIG9uTG9hZCBhdHRyaWJ1dGUuXG5mdW5jdGlvbiBoYW5kbGVMb2FkaW5nKGltZywgc3JjLCBsYXlvdXQsIHBsYWNlaG9sZGVyLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlKSB7XG4gICAgaWYgKCFpbWcgfHwgaW1nLnNyYyA9PT0gZW1wdHlEYXRhVVJMIHx8IGltZ1snZGF0YS1sb2FkZWQtc3JjJ10gPT09IHNyYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGltZ1snZGF0YS1sb2FkZWQtc3JjJ10gPSBzcmM7XG4gICAgY29uc3QgcCA9ICdkZWNvZGUnIGluIGltZyA/IGltZy5kZWNvZGUoKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHAuY2F0Y2goKCk9Pnt9KS50aGVuKCgpPT57XG4gICAgICAgIGlmICghaW1nLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaW4gY2FzZSBvZiByYWNlIGNvbmRpdGlvbjpcbiAgICAgICAgICAgIC8vIC0gb25sb2FkKCkgaXMgY2FsbGVkXG4gICAgICAgICAgICAvLyAtIGRlY29kZSgpIGlzIGNhbGxlZCBidXQgaW5jb21wbGV0ZVxuICAgICAgICAgICAgLy8gLSB1bm1vdW50IGlzIGNhbGxlZFxuICAgICAgICAgICAgLy8gLSBkZWNvZGUoKSBjb21wbGV0ZXNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZWRJbWFnZVVSTHMuYWRkKHNyYyk7XG4gICAgICAgIGlmIChwbGFjZWhvbGRlciA9PT0gJ2JsdXInKSB7XG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTG9hZGluZ0NvbXBsZXRlUmVmID09IG51bGwgPyB2b2lkIDAgOiBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hdHVyYWxXaWR0aCAsIG5hdHVyYWxIZWlnaHQgIH0gPSBpbWc7XG4gICAgICAgICAgICAvLyBQYXNzIGJhY2sgcmVhZC1vbmx5IHByaW1pdGl2ZSB2YWx1ZXMgYnV0IG5vdCB0aGVcbiAgICAgICAgICAgIC8vIHVuZGVybHlpbmcgRE9NIGVsZW1lbnQgYmVjYXVzZSBpdCBjb3VsZCBiZSBtaXN1c2VkLlxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYuY3VycmVudCh7XG4gICAgICAgICAgICAgICAgbmF0dXJhbFdpZHRoLFxuICAgICAgICAgICAgICAgIG5hdHVyYWxIZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgaWYgKChyZWYgPSBpbWcucGFyZW50RWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZ2V0Q29tcHV0ZWRTdHlsZShpbWcucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudC5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwYXJlbnQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIHRvIHRoZSBkb20geWV0IGFuZCB0aGVyZWZvcmUgaXQgaGFzIG5vIHBvc2l0aW9uLiBTa2lwIHRoZSB3YXJuaW5ncyBmb3Igc3VjaCBjYXNlcy5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxheW91dCA9PT0gJ3Jlc3BvbnNpdmUnICYmIHBhcmVudC5kaXNwbGF5ID09PSAnZmxleCcpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgbWF5IG5vdCByZW5kZXIgcHJvcGVybHkgYXMgYSBjaGlsZCBvZiBhIGZsZXggY29udGFpbmVyLiBDb25zaWRlciB3cmFwcGluZyB0aGUgaW1hZ2Ugd2l0aCBhIGRpdiB0byBjb25maWd1cmUgdGhlIHdpZHRoLmApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5b3V0ID09PSAnZmlsbCcgJiYgcGFyZW50LnBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBhcmVudC5wb3NpdGlvbiAhPT0gJ2ZpeGVkJyAmJiBwYXJlbnQucG9zaXRpb24gIT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgbWF5IG5vdCByZW5kZXIgcHJvcGVybHkgd2l0aCBhIHBhcmVudCB1c2luZyBwb3NpdGlvbjpcIiR7cGFyZW50LnBvc2l0aW9ufVwiLiBDb25zaWRlciBjaGFuZ2luZyB0aGUgcGFyZW50IHN0eWxlIHRvIHBvc2l0aW9uOlwicmVsYXRpdmVcIiB3aXRoIGEgd2lkdGggYW5kIGhlaWdodC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IEltYWdlRWxlbWVudCA9IChfcGFyYW0pPT57XG4gICAgdmFyIHsgaW1nQXR0cmlidXRlcyAsIGhlaWdodEludCAsIHdpZHRoSW50ICwgcXVhbGl0eUludCAsIGxheW91dCAsIGNsYXNzTmFtZSAsIGltZ1N0eWxlICwgYmx1clN0eWxlICwgaXNMYXp5ICwgcGxhY2Vob2xkZXIgLCBsb2FkaW5nICwgc3JjU3RyaW5nICwgY29uZmlnICwgdW5vcHRpbWl6ZWQgLCBsb2FkZXIgLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiAsIHNldEJsdXJDb21wbGV0ZSAsIHNldEludGVyc2VjdGlvbiAsIG9uTG9hZCAsIG9uRXJyb3IgLCBpc1Zpc2libGUgLCBub3NjcmlwdFNpemVzICB9ID0gX3BhcmFtLCByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3BhcmFtLCBbXG4gICAgICAgIFwiaW1nQXR0cmlidXRlc1wiLFxuICAgICAgICBcImhlaWdodEludFwiLFxuICAgICAgICBcIndpZHRoSW50XCIsXG4gICAgICAgIFwicXVhbGl0eUludFwiLFxuICAgICAgICBcImxheW91dFwiLFxuICAgICAgICBcImNsYXNzTmFtZVwiLFxuICAgICAgICBcImltZ1N0eWxlXCIsXG4gICAgICAgIFwiYmx1clN0eWxlXCIsXG4gICAgICAgIFwiaXNMYXp5XCIsXG4gICAgICAgIFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgXCJsb2FkaW5nXCIsXG4gICAgICAgIFwic3JjU3RyaW5nXCIsXG4gICAgICAgIFwiY29uZmlnXCIsXG4gICAgICAgIFwidW5vcHRpbWl6ZWRcIixcbiAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgXCJvbkxvYWRpbmdDb21wbGV0ZVJlZlwiLFxuICAgICAgICBcInNldEJsdXJDb21wbGV0ZVwiLFxuICAgICAgICBcInNldEludGVyc2VjdGlvblwiLFxuICAgICAgICBcIm9uTG9hZFwiLFxuICAgICAgICBcIm9uRXJyb3JcIixcbiAgICAgICAgXCJpc1Zpc2libGVcIixcbiAgICAgICAgXCJub3NjcmlwdFNpemVzXCJcbiAgICBdKTtcbiAgICBsb2FkaW5nID0gaXNMYXp5ID8gJ2xhenknIDogbG9hZGluZztcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwgT2JqZWN0LmFzc2lnbih7fSwgcmVzdCwgaW1nQXR0cmlidXRlcywge1xuICAgICAgICBkZWNvZGluZzogXCJhc3luY1wiLFxuICAgICAgICBcImRhdGEtbmltZ1wiOiBsYXlvdXQsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIGltZ1N0eWxlLCBibHVyU3R5bGUpLFxuICAgICAgICByZWY6ICgwLCBfcmVhY3QpLnVzZUNhbGxiYWNrKChpbWcpPT57XG4gICAgICAgICAgICBzZXRJbnRlcnNlY3Rpb24oaW1nKTtcbiAgICAgICAgICAgIGlmIChpbWcgPT0gbnVsbCA/IHZvaWQgMCA6IGltZy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBzcmNTdHJpbmcsIGxheW91dCwgcGxhY2Vob2xkZXIsIG9uTG9hZGluZ0NvbXBsZXRlUmVmLCBzZXRCbHVyQ29tcGxldGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXG4gICAgICAgICAgICBzZXRJbnRlcnNlY3Rpb24sXG4gICAgICAgICAgICBzcmNTdHJpbmcsXG4gICAgICAgICAgICBsYXlvdXQsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLFxuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlLCBcbiAgICAgICAgXSksXG4gICAgICAgIG9uTG9hZDogKGV2ZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgaW1nID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBzcmNTdHJpbmcsIGxheW91dCwgcGxhY2Vob2xkZXIsIG9uTG9hZGluZ0NvbXBsZXRlUmVmLCBzZXRCbHVyQ29tcGxldGUpO1xuICAgICAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgICAgICAgIG9uTG9hZChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChldmVudCk9PntcbiAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlciA9PT0gJ2JsdXInKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlYWwgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgdGhpcyB3aWxsIHN0aWxsIHJlbW92ZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKSwgKGlzTGF6eSB8fCBwbGFjZWhvbGRlciA9PT0gJ2JsdXInKSAmJiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJub3NjcmlwdFwiLCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwgT2JqZWN0LmFzc2lnbih7fSwgcmVzdCwgZ2VuZXJhdGVJbWdBdHRycyh7XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgc3JjOiBzcmNTdHJpbmcsXG4gICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCxcbiAgICAgICAgc2l6ZXM6IG5vc2NyaXB0U2l6ZXMsXG4gICAgICAgIGxvYWRlclxuICAgIH0pLCB7XG4gICAgICAgIGRlY29kaW5nOiBcImFzeW5jXCIsXG4gICAgICAgIFwiZGF0YS1uaW1nXCI6IGxheW91dCxcbiAgICAgICAgc3R5bGU6IGltZ1N0eWxlLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgLy8gQHRzLWlnbm9yZSAtIFRPRE86IHVwZ3JhZGUgdG8gYEB0eXBlcy9yZWFjdEAxN2BcbiAgICAgICAgbG9hZGluZzogbG9hZGluZ1xuICAgIH0pKSkpO1xufTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNyYyhzcmMpIHtcbiAgICByZXR1cm4gc3JjWzBdID09PSAnLycgPyBzcmMuc2xpY2UoMSkgOiBzcmM7XG59XG5mdW5jdGlvbiBpbWdpeExvYWRlcih7IGNvbmZpZyAsIHNyYyAsIHdpZHRoICwgcXVhbGl0eSAgfSkge1xuICAgIC8vIERlbW86IGh0dHBzOi8vc3RhdGljLmltZ2l4Lm5ldC9kYWlzeS5wbmc/YXV0bz1mb3JtYXQmZml0PW1heCZ3PTMwMFxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7Y29uZmlnLnBhdGh9JHtub3JtYWxpemVTcmMoc3JjKX1gKTtcbiAgICBjb25zdCBwYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xuICAgIHBhcmFtcy5zZXQoJ2F1dG8nLCBwYXJhbXMuZ2V0KCdhdXRvJykgfHwgJ2Zvcm1hdCcpO1xuICAgIHBhcmFtcy5zZXQoJ2ZpdCcsIHBhcmFtcy5nZXQoJ2ZpdCcpIHx8ICdtYXgnKTtcbiAgICBwYXJhbXMuc2V0KCd3JywgcGFyYW1zLmdldCgndycpIHx8IHdpZHRoLnRvU3RyaW5nKCkpO1xuICAgIGlmIChxdWFsaXR5KSB7XG4gICAgICAgIHBhcmFtcy5zZXQoJ3EnLCBxdWFsaXR5LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsLmhyZWY7XG59XG5mdW5jdGlvbiBha2FtYWlMb2FkZXIoeyBjb25maWcgLCBzcmMgLCB3aWR0aCAgfSkge1xuICAgIHJldHVybiBgJHtjb25maWcucGF0aH0ke25vcm1hbGl6ZVNyYyhzcmMpfT9pbXdpZHRoPSR7d2lkdGh9YDtcbn1cbmZ1bmN0aW9uIGNsb3VkaW5hcnlMb2FkZXIoeyBjb25maWcgLCBzcmMgLCB3aWR0aCAsIHF1YWxpdHkgIH0pIHtcbiAgICAvLyBEZW1vOiBodHRwczovL3Jlcy5jbG91ZGluYXJ5LmNvbS9kZW1vL2ltYWdlL3VwbG9hZC93XzMwMCxjX2xpbWl0LHFfYXV0by90dXJ0bGVzLmpwZ1xuICAgIGNvbnN0IHBhcmFtcyA9IFtcbiAgICAgICAgJ2ZfYXV0bycsXG4gICAgICAgICdjX2xpbWl0JyxcbiAgICAgICAgJ3dfJyArIHdpZHRoLFxuICAgICAgICAncV8nICsgKHF1YWxpdHkgfHwgJ2F1dG8nKVxuICAgIF07XG4gICAgY29uc3QgcGFyYW1zU3RyaW5nID0gcGFyYW1zLmpvaW4oJywnKSArICcvJztcbiAgICByZXR1cm4gYCR7Y29uZmlnLnBhdGh9JHtwYXJhbXNTdHJpbmd9JHtub3JtYWxpemVTcmMoc3JjKX1gO1xufVxuZnVuY3Rpb24gY3VzdG9tTG9hZGVyKHsgc3JjICB9KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIG1pc3NpbmcgXCJsb2FkZXJcIiBwcm9wLmAgKyBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyYCk7XG59XG5mdW5jdGlvbiBkZWZhdWx0TG9hZGVyKHsgY29uZmlnICwgc3JjICwgd2lkdGggLCBxdWFsaXR5ICB9KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ1ZhbHVlcyA9IFtdO1xuICAgICAgICAvLyB0aGVzZSBzaG91bGQgYWx3YXlzIGJlIHByb3ZpZGVkIGJ1dCBtYWtlIHN1cmUgdGhleSBhcmVcbiAgICAgICAgaWYgKCFzcmMpIG1pc3NpbmdWYWx1ZXMucHVzaCgnc3JjJyk7XG4gICAgICAgIGlmICghd2lkdGgpIG1pc3NpbmdWYWx1ZXMucHVzaCgnd2lkdGgnKTtcbiAgICAgICAgaWYgKG1pc3NpbmdWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXh0IEltYWdlIE9wdGltaXphdGlvbiByZXF1aXJlcyAke21pc3NpbmdWYWx1ZXMuam9pbignLCAnKX0gdG8gYmUgcHJvdmlkZWQuIE1ha2Ugc3VyZSB5b3UgcGFzcyB0aGVtIGFzIHByb3BzIHRvIHRoZSBcXGBuZXh0L2ltYWdlXFxgIGNvbXBvbmVudC4gUmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBxdWFsaXR5XG4gICAgICAgICAgICB9KX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3JjLnN0YXJ0c1dpdGgoJy8vJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHNyYyBcIiR7c3JjfVwiIG9uIFxcYG5leHQvaW1hZ2VcXGAsIHByb3RvY29sLXJlbGF0aXZlIFVSTCAoLy8pIG11c3QgYmUgY2hhbmdlZCB0byBhbiBhYnNvbHV0ZSBVUkwgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzcmMuc3RhcnRzV2l0aCgnLycpICYmIChjb25maWcuZG9tYWlucyB8fCBleHBlcmltZW50YWxSZW1vdGVQYXR0ZXJucykpIHtcbiAgICAgICAgICAgIGxldCBwYXJzZWRTcmM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBhcnNlZFNyYyA9IG5ldyBVUkwoc3JjKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzcmMgXCIke3NyY31cIiBvbiBcXGBuZXh0L2ltYWdlXFxgLCBpZiB1c2luZyByZWxhdGl2ZSBpbWFnZSBpdCBtdXN0IHN0YXJ0IHdpdGggYSBsZWFkaW5nIHNsYXNoIFwiL1wiIG9yIGJlIGFuIGFic29sdXRlIFVSTCAoaHR0cDovLyBvciBodHRwczovLylgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIGR5bmFtaWMgcmVxdWlyZSBiZWNhdXNlIHRoaXMgc2hvdWxkIG9ubHkgZXJyb3IgaW4gZGV2ZWxvcG1lbnRcbiAgICAgICAgICAgICAgICBjb25zdCB7IGhhc01hdGNoICB9ID0gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybicpO1xuICAgICAgICAgICAgICAgIGlmICghaGFzTWF0Y2goY29uZmlnLmRvbWFpbnMsIGV4cGVyaW1lbnRhbFJlbW90ZVBhdHRlcm5zLCBwYXJzZWRTcmMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzcmMgcHJvcCAoJHtzcmN9KSBvbiBcXGBuZXh0L2ltYWdlXFxgLCBob3N0bmFtZSBcIiR7cGFyc2VkU3JjLmhvc3RuYW1lfVwiIGlzIG5vdCBjb25maWd1cmVkIHVuZGVyIGltYWdlcyBpbiB5b3VyIFxcYG5leHQuY29uZmlnLmpzXFxgXFxuYCArIGBTZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1ob3N0YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzcmMuZW5kc1dpdGgoJy5zdmcnKSAmJiAhY29uZmlnLmRhbmdlcm91c2x5QWxsb3dTVkcpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIG1ha2Ugc3ZnIHNlcnZlIGFzLWlzIHRvIGF2b2lkIHByb3h5aW5nXG4gICAgICAgIC8vIHRocm91Z2ggdGhlIGJ1aWx0LWluIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXG4gICAgICAgIHJldHVybiBzcmM7XG4gICAgfVxuICAgIHJldHVybiBgJHsoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGNvbmZpZy5wYXRoKX0/dXJsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHNyYyl9Jnc9JHt3aWR0aH0mcT0ke3F1YWxpdHkgfHwgNzV9YDtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIkltYWdlIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX2hlYWQiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2ltYWdlQ29uZmlnIiwiX3VzZUludGVyc2VjdGlvbiIsIl9pbWFnZUNvbmZpZ0NvbnRleHQiLCJfdXRpbHMiLCJfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCIsIl9wYXJhbSIsInNyYyIsInNpemVzIiwiX3Vub3B0aW1pemVkIiwidW5vcHRpbWl6ZWQiLCJfcHJpb3JpdHkiLCJwcmlvcml0eSIsImxvYWRpbmciLCJfbGF6eVJvb3QiLCJsYXp5Um9vdCIsImxhenlCb3VuZGFyeSIsImNsYXNzTmFtZSIsInF1YWxpdHkiLCJ3aWR0aCIsImhlaWdodCIsInN0eWxlIiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJvbkxvYWRpbmdDb21wbGV0ZSIsIl9wbGFjZWhvbGRlciIsInBsYWNlaG9sZGVyIiwiYmx1ckRhdGFVUkwiLCJhbGwiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImNvbmZpZ0NvbnRleHQiLCJ1c2VDb250ZXh0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwiY29uZmlnIiwidXNlTWVtbyIsImMiLCJjb25maWdFbnYiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJhbGxTaXplcyIsIl90b19jb25zdW1hYmxlX2FycmF5IiwiZGV2aWNlU2l6ZXMiLCJpbWFnZVNpemVzIiwic29ydCIsImEiLCJiIiwiX2V4dGVuZHMiLCJyZXN0IiwibGF5b3V0IiwibG9hZGVyIiwiZGVmYXVsdEltYWdlTG9hZGVyIiwiY3VzdG9tSW1hZ2VMb2FkZXIiLCJfdG1wIiwib2JqIiwib3B0cyIsInN0YXRpY1NyYyIsImlzU3RhdGljSW1wb3J0Iiwic3RhdGljSW1hZ2VEYXRhIiwiaXNTdGF0aWNSZXF1aXJlIiwiRXJyb3IiLCJjb25jYXQiLCJKU09OIiwic3RyaW5naWZ5Iiwid2lkdGhJbnQiLCJnZXRJbnQiLCJoZWlnaHRJbnQiLCJxdWFsaXR5SW50IiwiaXNMYXp5Iiwic3RhcnRzV2l0aCIsImxvYWRlZEltYWdlVVJMcyIsImhhcyIsImV4cGVyaW1lbnRhbFVub3B0aW1pemVkIiwicmVmIiwidXNlU3RhdGUiLCJibHVyQ29tcGxldGUiLCJzZXRCbHVyQ29tcGxldGUiLCJyZWYxIiwidXNlSW50ZXJzZWN0aW9uIiwicm9vdFJlZiIsInJvb3RNYXJnaW4iLCJkaXNhYmxlZCIsInNldEludGVyc2VjdGlvbiIsImlzSW50ZXJzZWN0ZWQiLCJyZXNldEludGVyc2VjdGVkIiwiaXNWaXNpYmxlIiwid3JhcHBlclN0eWxlIiwiYm94U2l6aW5nIiwiZGlzcGxheSIsIm92ZXJmbG93IiwiYmFja2dyb3VuZCIsIm9wYWNpdHkiLCJib3JkZXIiLCJtYXJnaW4iLCJwYWRkaW5nIiwic2l6ZXJTdHlsZSIsImhhc1NpemVyIiwic2l6ZXJTdmdVcmwiLCJsYXlvdXRTdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsImJvdHRvbSIsInJpZ2h0IiwibWluV2lkdGgiLCJtYXhXaWR0aCIsIm1pbkhlaWdodCIsIm1heEhlaWdodCIsInByb2Nlc3MiLCJWQUxJRF9MQVlPVVRfVkFMVUVTIiwiaW5jbHVkZXMiLCJtYXAiLCJTdHJpbmciLCJqb2luIiwiaXNOYU4iLCJ3YXJuT25jZSIsIlZBTElEX0xPQURJTkdfVkFMVUVTIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJ1cmwiLCJVUkwiLCJlcnIiLCJwYXRobmFtZSIsInNlYXJjaCIsIm92ZXJ3cml0dGVuU3R5bGVzIiwia2V5cyIsImZpbHRlciIsImtleSIsImxlbmd0aCIsInBlcmZPYnNlcnZlciIsIndpbmRvdyIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJlbnRyeUxpc3QiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uIiwiX2RpZEl0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvciIsImdldEVudHJpZXMiLCJTeW1ib2wiLCJfc3RlcCIsImVudHJ5IiwiaW1nU3JjIiwiZWxlbWVudCIsImxjcEltYWdlIiwiYWxsSW1ncyIsImdldCIsIm9ic2VydmUiLCJ0eXBlIiwiYnVmZmVyZWQiLCJjb25zb2xlIiwiZXJyb3IiLCJpbWdTdHlsZSIsImFzc2lnbiIsImJsdXJTdHlsZSIsImJhY2tncm91bmRTaXplIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZEltYWdlIiwicXVvdGllbnQiLCJwYWRkaW5nVG9wIiwiaW1nQXR0cmlidXRlcyIsImVtcHR5RGF0YVVSTCIsInNyY1NldCIsInVuZGVmaW5lZCIsImdlbmVyYXRlSW1nQXR0cnMiLCJzcmNTdHJpbmciLCJmdWxsVXJsIiwiZSIsImxvY2F0aW9uIiwiaHJlZiIsInNldCIsImltYWdlU3JjU2V0UHJvcE5hbWUiLCJpbWFnZVNpemVzUHJvcE5hbWUiLCJlbnYiLCJfX05FWFRfUkVBQ1RfUk9PVCIsIl9vYmoiLCJsaW5rUHJvcHMiLCJfZGVmaW5lX3Byb3BlcnR5IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0Iiwib25Mb2FkaW5nQ29tcGxldGVSZWYiLCJ1c2VSZWYiLCJwcmV2aW91c0ltYWdlU3JjIiwiY3VycmVudCIsImltZ0VsZW1lbnRBcmdzIiwibm9zY3JpcHRTaXplcyIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsImFsdCIsIkltYWdlRWxlbWVudCIsInJlbCIsImFzIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsInNvdXJjZSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsIldlYWtNYXAiLCJjYWNoZSIsIm5ld09iaiIsImhhc1Byb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlc2MiLCJleGNsdWRlZCIsInNvdXJjZUtleXMiLCJpbmRleE9mIiwiX19ORVhUX0lNQUdFX09QVFMiLCJfZXhwZXJpbWVudGFsUmVtb3RlUGF0dGVybnMiLCJleHBlcmltZW50YWxSZW1vdGVQYXR0ZXJucyIsIlNldCIsIk1hcCIsImdsb2JhbCIsIl9fTkVYVF9JTUFHRV9JTVBPUlRFRCIsImxvYWRlcnMiLCJkZWZhdWx0TG9hZGVyIiwiaW1naXhMb2FkZXIiLCJjbG91ZGluYXJ5TG9hZGVyIiwiYWthbWFpTG9hZGVyIiwiY3VzdG9tTG9hZGVyIiwiaXNTdGF0aWNJbWFnZURhdGEiLCJnZXRXaWR0aHMiLCJwYXJhbSIsInZpZXdwb3J0V2lkdGhSZSIsInBlcmNlbnRTaXplcyIsIm1hdGNoIiwiZXhlYyIsInB1c2giLCJwYXJzZUludCIsIk1hdGgiLCJzbWFsbGVzdFJhdGlvIiwibWluIiwid2lkdGhzIiwicyIsImtpbmQiLCJ3IiwiZmluZCIsInAiLCJsYXN0IiwieCIsImxvYWRlclByb3BzIiwibG9hZGVyS2V5IiwibG9hZCIsIlZBTElEX0xPQURFUlMiLCJoYW5kbGVMb2FkaW5nIiwiaW1nIiwiZGVjb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsInRoZW4iLCJwYXJlbnROb2RlIiwiYWRkIiwibmF0dXJhbFdpZHRoIiwibmF0dXJhbEhlaWdodCIsInBhcmVudEVsZW1lbnQiLCJwYXJlbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwib25Mb2FkIiwib25FcnJvciIsImRlY29kaW5nIiwidXNlQ2FsbGJhY2siLCJjb21wbGV0ZSIsImV2ZW50IiwiY3VycmVudFRhcmdldCIsIm5vcm1hbGl6ZVNyYyIsInNsaWNlIiwicGF0aCIsInBhcmFtcyIsInNlYXJjaFBhcmFtcyIsInRvU3RyaW5nIiwicGFyYW1zU3RyaW5nIiwibWlzc2luZ1ZhbHVlcyIsImRvbWFpbnMiLCJwYXJzZWRTcmMiLCJoYXNNYXRjaCIsImhvc3RuYW1lIiwiZW5kc1dpdGgiLCJkYW5nZXJvdXNseUFsbG93U1ZHIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/image.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _sliced_to_array = (__webpack_require__(/*! @swc/helpers/lib/_sliced_to_array.js */ \"./node_modules/@swc/helpers/lib/_sliced_to_array.js\")[\"default\"]);\n\nvar _type_of = (__webpack_require__(/*! @swc/helpers/lib/_type_of.js */ \"./node_modules/@swc/helpers/lib/_type_of.js\")[\"default\"]);\n\nvar _s = $RefreshSig$();\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _router = __webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\");\n\nvar _addLocale = __webpack_require__(/*! ./add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\n\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\n\nvar _appRouterContext = __webpack_require__(/*! ../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\n\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\n\nvar _getDomainLocale = __webpack_require__(/*! ./get-domain-locale */ \"./node_modules/next/dist/client/get-domain-locale.js\");\n\nvar _addBasePath = __webpack_require__(/*! ./add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n} // @ts-ignore useTransition exist\n\n\nvar hasUseTransition = typeof _react.default.useTransition !== \"undefined\";\nvar prefetched = {};\n\nfunction prefetch(router, href, as, options) {\n  if ( false || !router) return;\n  if (!(0, _router).isLocalURL(href)) return; // Prefetch the JSON page if asked (only in the client)\n  // We need to handle a prefetch error here since we may be\n  // loading with priority which can reject but we don't\n  // want to force navigation since this is only a prefetch\n\n  router.prefetch(href, as, options).catch(function (err) {\n    if (true) {\n      // rethrow to show invalid URL errors\n      throw err;\n    }\n  });\n  var curLocale = options && typeof options.locale !== \"undefined\" ? options.locale : router && router.locale; // Join on an invalid URI character\n\n  prefetched[href + \"%\" + as + (curLocale ? \"%\" + curLocale : \"\")] = true;\n}\n\nfunction isModifiedEvent(event) {\n  var target = event.currentTarget.target;\n  return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || event.nativeEvent && event.nativeEvent.which === 2;\n}\n\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, startTransition) {\n  var nodeName = e.currentTarget.nodeName; // anchors inside an svg have a lowercase nodeName\n\n  var isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n\n  if (isAnchorNodeName && (isModifiedEvent(e) || !(0, _router).isLocalURL(href))) {\n    // ignore click for browser’s default behavior\n    return;\n  }\n\n  e.preventDefault();\n\n  var navigate = function () {\n    // replace state instead of push if prop is present\n    router[replace ? \"replace\" : \"push\"](href, as, {\n      shallow: shallow,\n      locale: locale,\n      scroll: scroll\n    });\n  };\n\n  if (startTransition) {\n    startTransition(navigate);\n  } else {\n    navigate();\n  }\n}\n\nvar Link = /*#__PURE__*/_s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n  _s();\n\n  if (true) {\n    var createPropError = function createPropError(args) {\n      return new Error(\"Failed prop type: The prop `\".concat(args.key, \"` expects a \").concat(args.expected, \" in `<Link>`, but got `\").concat(args.actual, \"` instead.\") + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0));\n    }; // TypeScript trick for type-guarding:\n\n\n    var requiredPropsGuard = {\n      href: true\n    };\n    var requiredProps = Object.keys(requiredPropsGuard);\n    requiredProps.forEach(function (key) {\n      if (key === \"href\") {\n        if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n          throw createPropError({\n            key: key,\n            expected: \"`string` or `object`\",\n            actual: props[key] === null ? \"null\" : _type_of(props[key])\n          });\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _ = key;\n      }\n    }); // TypeScript trick for type-guarding:\n\n    var optionalPropsGuard = {\n      as: true,\n      replace: true,\n      scroll: true,\n      shallow: true,\n      passHref: true,\n      prefetch: true,\n      locale: true,\n      onClick: true,\n      onMouseEnter: true,\n      legacyBehavior: true\n    };\n    var optionalProps = Object.keys(optionalPropsGuard);\n    optionalProps.forEach(function (key) {\n      var valType = _type_of(props[key]);\n\n      if (key === \"as\") {\n        if (props[key] && valType !== \"string\" && valType !== \"object\") {\n          throw createPropError({\n            key: key,\n            expected: \"`string` or `object`\",\n            actual: valType\n          });\n        }\n      } else if (key === \"locale\") {\n        if (props[key] && valType !== \"string\") {\n          throw createPropError({\n            key: key,\n            expected: \"`string`\",\n            actual: valType\n          });\n        }\n      } else if (key === \"onClick\" || key === \"onMouseEnter\") {\n        if (props[key] && valType !== \"function\") {\n          throw createPropError({\n            key: key,\n            expected: \"`function`\",\n            actual: valType\n          });\n        }\n      } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n        if (props[key] != null && valType !== \"boolean\") {\n          throw createPropError({\n            key: key,\n            expected: \"`boolean`\",\n            actual: valType\n          });\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _ = key;\n      }\n    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n\n    var hasWarned = _react.default.useRef(false);\n\n    if (props.prefetch && !hasWarned.current) {\n      hasWarned.current = true;\n      console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n    }\n  }\n\n  var children;\n\n  var hrefProp = props.href,\n      asProp = props.as,\n      childrenProp = props.children,\n      prefetchProp = props.prefetch,\n      passHref = props.passHref,\n      replace = props.replace,\n      shallow = props.shallow,\n      scroll = props.scroll,\n      locale = props.locale,\n      onClick = props.onClick,\n      onMouseEnter = props.onMouseEnter,\n      _legacyBehavior = props.legacyBehavior,\n      legacyBehavior = _legacyBehavior === void 0 ? Boolean(false) !== true : _legacyBehavior,\n      restProps = _objectWithoutPropertiesLoose(props, [\"href\", \"as\", \"children\", \"prefetch\", \"passHref\", \"replace\", \"shallow\", \"scroll\", \"locale\", \"onClick\", \"onMouseEnter\", \"legacyBehavior\"]);\n\n  children = childrenProp;\n\n  if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n    children = /*#__PURE__*/_react.default.createElement(\"a\", null, children);\n  }\n\n  var p = prefetchProp !== false;\n\n  var ref = _sliced_to_array(hasUseTransition ? // @ts-ignore useTransition exists\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  _react.default.useTransition() : [], 2),\n\n  /* isPending */\n  startTransition = ref[1];\n\n  var router = _react.default.useContext(_routerContext.RouterContext);\n\n  var appRouter = _react.default.useContext(_appRouterContext.AppRouterContext);\n\n  if (appRouter) {\n    router = appRouter;\n  }\n\n  var ref1 = _react.default.useMemo(function () {\n    var ref = _sliced_to_array((0, _router).resolveHref(router, hrefProp, true), 2),\n        resolvedHref = ref[0],\n        resolvedAs = ref[1];\n\n    return {\n      href: resolvedHref,\n      as: asProp ? (0, _router).resolveHref(router, asProp) : resolvedAs || resolvedHref\n    };\n  }, [router, hrefProp, asProp]),\n      href = ref1.href,\n      as = ref1.as;\n\n  var previousHref = _react.default.useRef(href);\n\n  var previousAs = _react.default.useRef(as); // This will return the first child, if multiple are provided it will throw an error\n\n\n  var child;\n\n  if (legacyBehavior) {\n    if (true) {\n      if (onClick) {\n        console.warn('\"onClick\" was passed to <Link> with `href` of `'.concat(hrefProp, '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link'));\n      }\n\n      if (onMouseEnter) {\n        console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `'.concat(hrefProp, '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link'));\n      }\n\n      try {\n        child = _react.default.Children.only(children);\n      } catch (err) {\n        if (!children) {\n          throw new Error(\"No children were passed to <Link> with `href` of `\".concat(hrefProp, \"` but one child is required https://nextjs.org/docs/messages/link-no-children\"));\n        }\n\n        throw new Error(\"Multiple children were passed to <Link> with `href` of `\".concat(hrefProp, \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\") + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0));\n      }\n    } else {}\n  }\n\n  var childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n\n  var ref2 = _sliced_to_array((0, _useIntersection).useIntersection({\n    rootMargin: \"200px\"\n  }), 3),\n      setIntersectionRef = ref2[0],\n      isVisible = ref2[1],\n      resetVisible = ref2[2];\n\n  var setRef = _react.default.useCallback(function (el) {\n    // Before the link getting observed, check if visible state need to be reset\n    if (previousAs.current !== as || previousHref.current !== href) {\n      resetVisible();\n      previousAs.current = as;\n      previousHref.current = href;\n    }\n\n    setIntersectionRef(el);\n\n    if (childRef) {\n      if (typeof childRef === \"function\") childRef(el);else if (typeof childRef === \"object\") {\n        childRef.current = el;\n      }\n    }\n  }, [as, childRef, href, resetVisible, setIntersectionRef]);\n\n  _react.default.useEffect(function () {\n    var shouldPrefetch = isVisible && p && (0, _router).isLocalURL(href);\n    var curLocale = typeof locale !== \"undefined\" ? locale : router && router.locale;\n    var isPrefetched = prefetched[href + \"%\" + as + (curLocale ? \"%\" + curLocale : \"\")];\n\n    if (shouldPrefetch && !isPrefetched) {\n      prefetch(router, href, as, {\n        locale: curLocale\n      });\n    }\n  }, [as, href, isVisible, locale, p, router]);\n\n  var childProps = {\n    ref: setRef,\n    onClick: function (e) {\n      if (true) {\n        if (!e) {\n          throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n        }\n      }\n\n      if (!legacyBehavior && typeof onClick === \"function\") {\n        onClick(e);\n      }\n\n      if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n        child.props.onClick(e);\n      }\n\n      if (!e.defaultPrevented) {\n        linkClicked(e, router, href, as, replace, shallow, scroll, locale, appRouter ? startTransition : undefined);\n      }\n    },\n    onMouseEnter: function (e) {\n      if (!legacyBehavior && typeof onMouseEnter === \"function\") {\n        onMouseEnter(e);\n      }\n\n      if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n        child.props.onMouseEnter(e);\n      }\n\n      if ((0, _router).isLocalURL(href)) {\n        prefetch(router, href, as, {\n          priority: true\n        });\n      }\n    }\n  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n  // defined, we specify the current 'href', so that repetition is not needed by the user\n\n  if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n    var curLocale = typeof locale !== \"undefined\" ? locale : router && router.locale; // we only render domain locales if we are currently on a domain locale\n    // so that locale links are still visitable in development/preview envs\n\n    var localeDomain = router && router.isLocaleDomain && (0, _getDomainLocale).getDomainLocale(as, curLocale, router.locales, router.domainLocales);\n    childProps.href = localeDomain || (0, _addBasePath).addBasePath((0, _addLocale).addLocale(as, curLocale, router && router.defaultLocale));\n  }\n\n  return legacyBehavior ? /*#__PURE__*/_react.default.cloneElement(child, childProps) : /*#__PURE__*/_react.default.createElement(\"a\", Object.assign({}, restProps, childProps), children);\n}, \"BtO78wD/8ZHkXeJW04HXE0IXA8Y=\")), \"BtO78wD/8ZHkXeJW04HXE0IXA8Y=\");\n\n_c1 = Link;\nvar _default = Link;\nexports[\"default\"] = _default;\n\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n  Object.defineProperty(exports.default, \"__esModule\", {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\n\n\nvar _c, _c1;\n\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOzs7Ozs7OztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3Q0gsRUFBQUE7QUFHQUUsa0JBQUFBLEdBQWtCLEtBQUssQ0FBdkJBOztBQUNBLElBQUlHLE1BQU0sR0FBR0Msc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsNENBQUQsQ0FBUixDQUFuQzs7QUFDQSxJQUFJQyxPQUFPLEdBQUdELG1CQUFPLENBQUMseUZBQUQsQ0FBckI7O0FBQ0EsSUFBSUUsVUFBVSxHQUFHRixtQkFBTyxDQUFDLG1FQUFELENBQXhCOztBQUNBLElBQUlHLGNBQWMsR0FBR0gsbUJBQU8sQ0FBQywyRkFBRCxDQUE1Qjs7QUFDQSxJQUFJSSxpQkFBaUIsR0FBR0osbUJBQU8sQ0FBQyxtR0FBRCxDQUEvQjs7QUFDQSxJQUFJSyxnQkFBZ0IsR0FBR0wsbUJBQU8sQ0FBQywrRUFBRCxDQUE5Qjs7QUFDQSxJQUFJTSxnQkFBZ0IsR0FBR04sbUJBQU8sQ0FBQyxpRkFBRCxDQUE5Qjs7QUFDQSxJQUFJTyxZQUFZLEdBQUdQLG1CQUFPLENBQUMseUVBQUQsQ0FBMUI7O0FBQ0EsU0FBU0Qsc0JBQVQsQ0FBZ0NTLEdBQWhDLEVBQXFDO0VBQ2pDLE9BQU9BLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFYRCxHQUF3QkEsR0FBeEJBLEdBQThCO0lBQ2pDWCxPQUFPLEVBQUVXO0VBRHdCLENBQXJDO0FBR0g7O0FBQ0QsU0FBU0UsNkJBQVQsQ0FBdUNDLE1BQXZDLEVBQStDQyxRQUEvQyxFQUF5RDtFQUNyRCxJQUFJRCxNQUFNLElBQUksSUFBZCxFQUFvQixPQUFPLEVBQVA7RUFDcEIsSUFBSUUsTUFBTSxHQUFHLEVBQWI7RUFDQSxJQUFJQyxVQUFVLEdBQUdyQixNQUFNLENBQUNzQixJQUFQdEIsQ0FBWWtCLE1BQVpsQixDQUFqQjtFQUNBLElBQUl1QixHQUFKLEVBQVNDLENB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QU8sQ0FBQ0UsT0FBekI2STtBQUNELEMsQ0FFRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzP2U0ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yb3V0ZXIgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyXCIpO1xudmFyIF9hZGRMb2NhbGUgPSByZXF1aXJlKFwiLi9hZGQtbG9jYWxlXCIpO1xudmFyIF9yb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHRcIik7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG52YXIgX3VzZUludGVyc2VjdGlvbiA9IHJlcXVpcmUoXCIuL3VzZS1pbnRlcnNlY3Rpb25cIik7XG52YXIgX2dldERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoXCIuL2dldC1kb21haW4tbG9jYWxlXCIpO1xudmFyIF9hZGRCYXNlUGF0aCA9IHJlcXVpcmUoXCIuL2FkZC1iYXNlLXBhdGhcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICB2YXIga2V5LCBpO1xuICAgIGZvcihpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuLy8gQHRzLWlnbm9yZSB1c2VUcmFuc2l0aW9uIGV4aXN0XG5jb25zdCBoYXNVc2VUcmFuc2l0aW9uID0gdHlwZW9mIF9yZWFjdC5kZWZhdWx0LnVzZVRyYW5zaXRpb24gIT09ICd1bmRlZmluZWQnO1xuY29uc3QgcHJlZmV0Y2hlZCA9IHt9O1xuZnVuY3Rpb24gcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhcm91dGVyKSByZXR1cm47XG4gICAgaWYgKCEoMCwgX3JvdXRlcikuaXNMb2NhbFVSTChocmVmKSkgcmV0dXJuO1xuICAgIC8vIFByZWZldGNoIHRoZSBKU09OIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgICAvLyBXZSBuZWVkIHRvIGhhbmRsZSBhIHByZWZldGNoIGVycm9yIGhlcmUgc2luY2Ugd2UgbWF5IGJlXG4gICAgLy8gbG9hZGluZyB3aXRoIHByaW9yaXR5IHdoaWNoIGNhbiByZWplY3QgYnV0IHdlIGRvbid0XG4gICAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gICAgcm91dGVyLnByZWZldGNoKGhyZWYsIGFzLCBvcHRpb25zKS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgY3VyTG9jYWxlID0gb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5sb2NhbGUgOiByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZTtcbiAgICAvLyBKb2luIG9uIGFuIGludmFsaWQgVVJJIGNoYXJhY3RlclxuICAgIHByZWZldGNoZWRbaHJlZiArICclJyArIGFzICsgKGN1ckxvY2FsZSA/ICclJyArIGN1ckxvY2FsZSA6ICcnKV0gPSB0cnVlO1xufVxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgeyB0YXJnZXQgIH0gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0ICE9PSAnX3NlbGYnIHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDI7XG59XG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSwgc3RhcnRUcmFuc2l0aW9uKSB7XG4gICAgY29uc3QgeyBub2RlTmFtZSAgfSA9IGUuY3VycmVudFRhcmdldDtcbiAgICAvLyBhbmNob3JzIGluc2lkZSBhbiBzdmcgaGF2ZSBhIGxvd2VyY2FzZSBub2RlTmFtZVxuICAgIGNvbnN0IGlzQW5jaG9yTm9kZU5hbWUgPSBub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQSc7XG4gICAgaWYgKGlzQW5jaG9yTm9kZU5hbWUgJiYgKGlzTW9kaWZpZWRFdmVudChlKSB8fCAhKDAsIF9yb3V0ZXIpLmlzTG9jYWxVUkwoaHJlZikpKSB7XG4gICAgICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBuYXZpZ2F0ZSA9ICgpPT57XG4gICAgICAgIC8vIHJlcGxhY2Ugc3RhdGUgaW5zdGVhZCBvZiBwdXNoIGlmIHByb3AgaXMgcHJlc2VudFxuICAgICAgICByb3V0ZXJbcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdwdXNoJ10oaHJlZiwgYXMsIHtcbiAgICAgICAgICAgIHNoYWxsb3csXG4gICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICBzY3JvbGxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoc3RhcnRUcmFuc2l0aW9uKSB7XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbihuYXZpZ2F0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmF2aWdhdGUoKTtcbiAgICB9XG59XG5jb25zdCBMaW5rID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIExpbmtDb21wb25lbnQocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3BFcnJvcihhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBGYWlsZWQgcHJvcCB0eXBlOiBUaGUgcHJvcCBcXGAke2FyZ3Mua2V5fVxcYCBleHBlY3RzIGEgJHthcmdzLmV4cGVjdGVkfSBpbiBcXGA8TGluaz5cXGAsIGJ1dCBnb3QgXFxgJHthcmdzLmFjdHVhbH1cXGAgaW5zdGVhZC5gICsgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gXCJcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiIDogJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICBjb25zdCByZXF1aXJlZFByb3BzR3VhcmQgPSB7XG4gICAgICAgICAgICBocmVmOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcHMgPSBPYmplY3Qua2V5cyhyZXF1aXJlZFByb3BzR3VhcmQpO1xuICAgICAgICByZXF1aXJlZFByb3BzLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdocmVmJykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldID09IG51bGwgfHwgdHlwZW9mIHByb3BzW2tleV0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcm9wc1trZXldICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCBvciBgb2JqZWN0YCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHByb3BzW2tleV0gPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcHJvcHNba2V5XVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAgIGNvbnN0IF8gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICBjb25zdCBvcHRpb25hbFByb3BzR3VhcmQgPSB7XG4gICAgICAgICAgICBhczogdHJ1ZSxcbiAgICAgICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgICAgICBzY3JvbGw6IHRydWUsXG4gICAgICAgICAgICBzaGFsbG93OiB0cnVlLFxuICAgICAgICAgICAgcGFzc0hyZWY6IHRydWUsXG4gICAgICAgICAgICBwcmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgICAgIGxvY2FsZTogdHJ1ZSxcbiAgICAgICAgICAgIG9uQ2xpY2s6IHRydWUsXG4gICAgICAgICAgICBvbk1vdXNlRW50ZXI6IHRydWUsXG4gICAgICAgICAgICBsZWdhY3lCZWhhdmlvcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvcHRpb25hbFByb3BzID0gT2JqZWN0LmtleXMob3B0aW9uYWxQcm9wc0d1YXJkKTtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICBjb25zdCB2YWxUeXBlID0gdHlwZW9mIHByb3BzW2tleV07XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnYXMnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycgJiYgdmFsVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnbG9jYWxlJykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ29uQ2xpY2snIHx8IGtleSA9PT0gJ29uTW91c2VFbnRlcicpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2BmdW5jdGlvbmAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncmVwbGFjZScgfHwga2V5ID09PSAnc2Nyb2xsJyB8fCBrZXkgPT09ICdzaGFsbG93JyB8fCBrZXkgPT09ICdwYXNzSHJlZicgfHwga2V5ID09PSAncHJlZmV0Y2gnIHx8IGtleSA9PT0gJ2xlZ2FjeUJlaGF2aW9yJykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICE9IG51bGwgJiYgdmFsVHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2Bib29sZWFuYCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICBjb25zdCBfID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIGNvbnN0IGhhc1dhcm5lZCA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihmYWxzZSk7XG4gICAgICAgIGlmIChwcm9wcy5wcmVmZXRjaCAmJiAhaGFzV2FybmVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTmV4dC5qcyBhdXRvLXByZWZldGNoZXMgYXV0b21hdGljYWxseSBiYXNlZCBvbiB2aWV3cG9ydC4gVGhlIHByZWZldGNoIGF0dHJpYnV0ZSBpcyBubyBsb25nZXIgbmVlZGVkLiBNb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wcmVmZXRjaC10cnVlLWRlcHJlY2F0ZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY2hpbGRyZW47XG4gICAgY29uc3QgeyBocmVmOiBocmVmUHJvcCAsIGFzOiBhc1Byb3AgLCBjaGlsZHJlbjogY2hpbGRyZW5Qcm9wICwgcHJlZmV0Y2g6IHByZWZldGNoUHJvcCAsIHBhc3NIcmVmICwgcmVwbGFjZSAsIHNoYWxsb3cgLCBzY3JvbGwgLCBsb2NhbGUgLCBvbkNsaWNrICwgb25Nb3VzZUVudGVyICwgbGVnYWN5QmVoYXZpb3IgPUJvb2xlYW4ocHJvY2Vzcy5lbnYuX19ORVhUX05FV19MSU5LX0JFSEFWSU9SKSAhPT0gdHJ1ZSAgfSA9IHByb3BzLCByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgW1xuICAgICAgICBcImhyZWZcIixcbiAgICAgICAgXCJhc1wiLFxuICAgICAgICBcImNoaWxkcmVuXCIsXG4gICAgICAgIFwicHJlZmV0Y2hcIixcbiAgICAgICAgXCJwYXNzSHJlZlwiLFxuICAgICAgICBcInJlcGxhY2VcIixcbiAgICAgICAgXCJzaGFsbG93XCIsXG4gICAgICAgIFwic2Nyb2xsXCIsXG4gICAgICAgIFwibG9jYWxlXCIsXG4gICAgICAgIFwib25DbGlja1wiLFxuICAgICAgICBcIm9uTW91c2VFbnRlclwiLFxuICAgICAgICBcImxlZ2FjeUJlaGF2aW9yXCJcbiAgICBdKTtcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuUHJvcDtcbiAgICBpZiAobGVnYWN5QmVoYXZpb3IgJiYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkcmVuID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgY2hpbGRyZW4gPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgY29uc3QgcCA9IHByZWZldGNoUHJvcCAhPT0gZmFsc2U7XG4gICAgY29uc3QgWywgLyogaXNQZW5kaW5nICovIHN0YXJ0VHJhbnNpdGlvbl0gPSBoYXNVc2VUcmFuc2l0aW9uID8gLy8gVGhlcmUgaXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIHJlbmRlcnMgaW4gdGhpcyBjYXNlLCBvbmx5IGJldHdlZW4gdXNpbmcgUmVhY3QgMTggdnMgMTcuXG4gICAgLy8gQHRzLWlnbm9yZSB1c2VUcmFuc2l0aW9uIGV4aXN0c1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIF9yZWFjdC5kZWZhdWx0LnVzZVRyYW5zaXRpb24oKSA6IFtdO1xuICAgIGxldCByb3V0ZXIgPSBfcmVhY3QuZGVmYXVsdC51c2VDb250ZXh0KF9yb3V0ZXJDb250ZXh0LlJvdXRlckNvbnRleHQpO1xuICAgIGNvbnN0IGFwcFJvdXRlciA9IF9yZWFjdC5kZWZhdWx0LnVzZUNvbnRleHQoX2FwcFJvdXRlckNvbnRleHQuQXBwUm91dGVyQ29udGV4dCk7XG4gICAgaWYgKGFwcFJvdXRlcikge1xuICAgICAgICByb3V0ZXIgPSBhcHBSb3V0ZXI7XG4gICAgfVxuICAgIGNvbnN0IHsgaHJlZiAsIGFzICB9ID0gX3JlYWN0LmRlZmF1bHQudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9ICgwLCBfcm91dGVyKS5yZXNvbHZlSHJlZihyb3V0ZXIsIGhyZWZQcm9wLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhyZWY6IHJlc29sdmVkSHJlZixcbiAgICAgICAgICAgIGFzOiBhc1Byb3AgPyAoMCwgX3JvdXRlcikucmVzb2x2ZUhyZWYocm91dGVyLCBhc1Byb3ApIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWZcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHJvdXRlcixcbiAgICAgICAgaHJlZlByb3AsXG4gICAgICAgIGFzUHJvcFxuICAgIF0pO1xuICAgIGNvbnN0IHByZXZpb3VzSHJlZiA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihocmVmKTtcbiAgICBjb25zdCBwcmV2aW91c0FzID0gX3JlYWN0LmRlZmF1bHQudXNlUmVmKGFzKTtcbiAgICAvLyBUaGlzIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBjaGlsZCwgaWYgbXVsdGlwbGUgYXJlIHByb3ZpZGVkIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgICBsZXQgY2hpbGQ7XG4gICAgaWYgKGxlZ2FjeUJlaGF2aW9yKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFwib25DbGlja1wiIHdhcyBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgXCJsZWdhY3lCZWhhdmlvclwiIHdhcyBzZXQuIFRoZSBsZWdhY3kgYmVoYXZpb3IgcmVxdWlyZXMgb25DbGljayBiZSBzZXQgb24gdGhlIGNoaWxkIG9mIG5leHQvbGlua2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uTW91c2VFbnRlcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgXCJvbk1vdXNlRW50ZXJcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uTW91c2VFbnRlciBiZSBzZXQgb24gdGhlIGNoaWxkIG9mIG5leHQvbGlua2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IG9uZSBjaGlsZCBpcyByZXF1aXJlZCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9saW5rLW5vLWNoaWxkcmVuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwbGUgY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgb25seSBvbmUgY2hpbGQgaXMgc3VwcG9ydGVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbXVsdGlwbGUtY2hpbGRyZW5gICsgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gXCIgXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIiA6ICcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZCA9IF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkUmVmID0gbGVnYWN5QmVoYXZpb3IgPyBjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkLnJlZiA6IGZvcndhcmRlZFJlZjtcbiAgICBjb25zdCBbc2V0SW50ZXJzZWN0aW9uUmVmLCBpc1Zpc2libGUsIHJlc2V0VmlzaWJsZV0gPSAoMCwgX3VzZUludGVyc2VjdGlvbikudXNlSW50ZXJzZWN0aW9uKHtcbiAgICAgICAgcm9vdE1hcmdpbjogJzIwMHB4J1xuICAgIH0pO1xuICAgIGNvbnN0IHNldFJlZiA9IF9yZWFjdC5kZWZhdWx0LnVzZUNhbGxiYWNrKChlbCk9PntcbiAgICAgICAgLy8gQmVmb3JlIHRoZSBsaW5rIGdldHRpbmcgb2JzZXJ2ZWQsIGNoZWNrIGlmIHZpc2libGUgc3RhdGUgbmVlZCB0byBiZSByZXNldFxuICAgICAgICBpZiAocHJldmlvdXNBcy5jdXJyZW50ICE9PSBhcyB8fCBwcmV2aW91c0hyZWYuY3VycmVudCAhPT0gaHJlZikge1xuICAgICAgICAgICAgcmVzZXRWaXNpYmxlKCk7XG4gICAgICAgICAgICBwcmV2aW91c0FzLmN1cnJlbnQgPSBhcztcbiAgICAgICAgICAgIHByZXZpb3VzSHJlZi5jdXJyZW50ID0gaHJlZjtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbnRlcnNlY3Rpb25SZWYoZWwpO1xuICAgICAgICBpZiAoY2hpbGRSZWYpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09ICdmdW5jdGlvbicpIGNoaWxkUmVmKGVsKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFJlZi5jdXJyZW50ID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGFzLFxuICAgICAgICBjaGlsZFJlZixcbiAgICAgICAgaHJlZixcbiAgICAgICAgcmVzZXRWaXNpYmxlLFxuICAgICAgICBzZXRJbnRlcnNlY3Rpb25SZWZcbiAgICBdKTtcbiAgICBfcmVhY3QuZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgY29uc3Qgc2hvdWxkUHJlZmV0Y2ggPSBpc1Zpc2libGUgJiYgcCAmJiAoMCwgX3JvdXRlcikuaXNMb2NhbFVSTChocmVmKTtcbiAgICAgICAgY29uc3QgY3VyTG9jYWxlID0gdHlwZW9mIGxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhbGUgOiByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZTtcbiAgICAgICAgY29uc3QgaXNQcmVmZXRjaGVkID0gcHJlZmV0Y2hlZFtocmVmICsgJyUnICsgYXMgKyAoY3VyTG9jYWxlID8gJyUnICsgY3VyTG9jYWxlIDogJycpXTtcbiAgICAgICAgaWYgKHNob3VsZFByZWZldGNoICYmICFpc1ByZWZldGNoZWQpIHtcbiAgICAgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICAgICAgICBsb2NhbGU6IGN1ckxvY2FsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGFzLFxuICAgICAgICBocmVmLFxuICAgICAgICBpc1Zpc2libGUsXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgcCxcbiAgICAgICAgcm91dGVyXG4gICAgXSk7XG4gICAgY29uc3QgY2hpbGRQcm9wcyA9IHtcbiAgICAgICAgcmVmOiBzZXRSZWYsXG4gICAgICAgIG9uQ2xpY2s6IChlKT0+e1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgcmVuZGVyZWQgaW5zaWRlIG5leHQvbGluayBoYXMgdG8gcGFzcyBjbGljayBldmVudCB0byBcIm9uQ2xpY2tcIiBwcm9wLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgbGlua0NsaWNrZWQoZSwgcm91dGVyLCBocmVmLCBhcywgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUsIGFwcFJvdXRlciA/IHN0YXJ0VHJhbnNpdGlvbiA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VFbnRlcjogKGUpPT57XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbk1vdXNlRW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXIoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVnYWN5QmVoYXZpb3IgJiYgY2hpbGQucHJvcHMgJiYgdHlwZW9mIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgX3JvdXRlcikuaXNMb2NhbFVSTChocmVmKSkge1xuICAgICAgICAgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSWYgY2hpbGQgaXMgYW4gPGE+IHRhZyBhbmQgZG9lc24ndCBoYXZlIGEgaHJlZiBhdHRyaWJ1dGUsIG9yIGlmIHRoZSAncGFzc0hyZWYnIHByb3BlcnR5IGlzXG4gICAgLy8gZGVmaW5lZCwgd2Ugc3BlY2lmeSB0aGUgY3VycmVudCAnaHJlZicsIHNvIHRoYXQgcmVwZXRpdGlvbiBpcyBub3QgbmVlZGVkIGJ5IHRoZSB1c2VyXG4gICAgaWYgKCFsZWdhY3lCZWhhdmlvciB8fCBwYXNzSHJlZiB8fCBjaGlsZC50eXBlID09PSAnYScgJiYgISgnaHJlZicgaW4gY2hpbGQucHJvcHMpKSB7XG4gICAgICAgIGNvbnN0IGN1ckxvY2FsZSA9IHR5cGVvZiBsb2NhbGUgIT09ICd1bmRlZmluZWQnID8gbG9jYWxlIDogcm91dGVyICYmIHJvdXRlci5sb2NhbGU7XG4gICAgICAgIC8vIHdlIG9ubHkgcmVuZGVyIGRvbWFpbiBsb2NhbGVzIGlmIHdlIGFyZSBjdXJyZW50bHkgb24gYSBkb21haW4gbG9jYWxlXG4gICAgICAgIC8vIHNvIHRoYXQgbG9jYWxlIGxpbmtzIGFyZSBzdGlsbCB2aXNpdGFibGUgaW4gZGV2ZWxvcG1lbnQvcHJldmlldyBlbnZzXG4gICAgICAgIGNvbnN0IGxvY2FsZURvbWFpbiA9IHJvdXRlciAmJiByb3V0ZXIuaXNMb2NhbGVEb21haW4gJiYgKDAsIF9nZXREb21haW5Mb2NhbGUpLmdldERvbWFpbkxvY2FsZShhcywgY3VyTG9jYWxlLCByb3V0ZXIubG9jYWxlcywgcm91dGVyLmRvbWFpbkxvY2FsZXMpO1xuICAgICAgICBjaGlsZFByb3BzLmhyZWYgPSBsb2NhbGVEb21haW4gfHwgKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShhcywgY3VyTG9jYWxlLCByb3V0ZXIgJiYgcm91dGVyLmRlZmF1bHRMb2NhbGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2FjeUJlaGF2aW9yID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpIDogLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYVwiLCBPYmplY3QuYXNzaWduKHt9LCByZXN0UHJvcHMsIGNoaWxkUHJvcHMpLCBjaGlsZHJlbik7XG59KTtcbnZhciBfZGVmYXVsdCA9IExpbms7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluay5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfcm91dGVyIiwiX2FkZExvY2FsZSIsIl9yb3V0ZXJDb250ZXh0IiwiX2FwcFJvdXRlckNvbnRleHQiLCJfdXNlSW50ZXJzZWN0aW9uIiwiX2dldERvbWFpbkxvY2FsZSIsIl9hZGRCYXNlUGF0aCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsInNvdXJjZSIsImV4Y2x1ZGVkIiwidGFyZ2V0Iiwic291cmNlS2V5cyIsImtleXMiLCJrZXkiLCJpIiwibGVuZ3RoIiwiaW5kZXhPZiIsImhhc1VzZVRyYW5zaXRpb24iLCJ1c2VUcmFuc2l0aW9uIiwicHJlZmV0Y2hlZCIsInByZWZldGNoIiwicm91dGVyIiwiaHJlZiIsImFzIiwib3B0aW9ucyIsImlzTG9jYWxVUkwiLCJjYXRjaCIsImVyciIsInByb2Nlc3MiLCJjdXJMb2NhbGUiLCJsb2NhbGUiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsImN1cnJlbnRUYXJnZXQiLCJtZXRhS2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiYWx0S2V5IiwibmF0aXZlRXZlbnQiLCJ3aGljaCIsImxpbmtDbGlja2VkIiwiZSIsInJlcGxhY2UiLCJzaGFsbG93Iiwic2Nyb2xsIiwic3RhcnRUcmFuc2l0aW9uIiwibm9kZU5hbWUiLCJpc0FuY2hvck5vZGVOYW1lIiwidG9VcHBlckNhc2UiLCJwcmV2ZW50RGVmYXVsdCIsIm5hdmlnYXRlIiwiTGluayIsImZvcndhcmRSZWYiLCJfYyIsIkxpbmtDb21wb25lbnQiLCJwcm9wcyIsImZvcndhcmRlZFJlZiIsImNyZWF0ZVByb3BFcnJvciIsImFyZ3MiLCJFcnJvciIsImV4cGVjdGVkIiwiY29uY2F0IiwiYWN0dWFsIiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsImZvckVhY2giLCJfdHlwZV9vZiIsIl8iLCJvcHRpb25hbFByb3BzR3VhcmQiLCJwYXNzSHJlZiIsIm9uQ2xpY2siLCJvbk1vdXNlRW50ZXIiLCJsZWdhY3lCZWhhdmlvciIsIm9wdGlvbmFsUHJvcHMiLCJ2YWxUeXBlIiwiaGFzV2FybmVkIiwidXNlUmVmIiwiY3VycmVudCIsImNvbnNvbGUiLCJ3YXJuIiwiY2hpbGRyZW4iLCJfbGVnYWN5QmVoYXZpb3IiLCJCb29sZWFuIiwiZW52IiwiX19ORVhUX05FV19MSU5LX0JFSEFWSU9SIiwicmVzdFByb3BzIiwiY2hpbGRyZW5Qcm9wIiwiY3JlYXRlRWxlbWVudCIsInAiLCJwcmVmZXRjaFByb3AiLCJ1c2VDb250ZXh0IiwiUm91dGVyQ29udGV4dCIsImFwcFJvdXRlciIsIkFwcFJvdXRlckNvbnRleHQiLCJ1c2VNZW1vIiwicmVmIiwicmVzb2x2ZUhyZWYiLCJocmVmUHJvcCIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJhc1Byb3AiLCJwcmV2aW91c0hyZWYiLCJwcmV2aW91c0FzIiwiY2hpbGQiLCJDaGlsZHJlbiIsIm9ubHkiLCJjaGlsZFJlZiIsInJlZjIiLCJ1c2VJbnRlcnNlY3Rpb24iLCJyb290TWFyZ2luIiwic2V0SW50ZXJzZWN0aW9uUmVmIiwiaXNWaXNpYmxlIiwicmVzZXRWaXNpYmxlIiwic2V0UmVmIiwidXNlQ2FsbGJhY2siLCJlbCIsInVzZUVmZmVjdCIsInNob3VsZFByZWZldGNoIiwiaXNQcmVmZXRjaGVkIiwiY2hpbGRQcm9wcyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJ1bmRlZmluZWQiLCJwcmlvcml0eSIsInR5cGUiLCJsb2NhbGVEb21haW4iLCJpc0xvY2FsZURvbWFpbiIsImdldERvbWFpbkxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiYWRkQmFzZVBhdGgiLCJhZGRMb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwiY2xvbmVFbGVtZW50IiwiYXNzaWduIiwiX2RlZmF1bHQiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _sliced_to_array = (__webpack_require__(/*! @swc/helpers/lib/_sliced_to_array.js */ \"./node_modules/@swc/helpers/lib/_sliced_to_array.js\")[\"default\"]);\n\nvar _s = $RefreshSig$();\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.useIntersection = useIntersection;\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\n\nvar hasIntersectionObserver = typeof IntersectionObserver === \"function\";\n\nfunction useIntersection(param) {\n  var rootRef = param.rootRef,\n      rootMargin = param.rootMargin,\n      disabled = param.disabled;\n\n  _s();\n\n  var isDisabled = disabled || !hasIntersectionObserver;\n  var unobserve = (0, _react).useRef();\n\n  var ref = _sliced_to_array((0, _react).useState(false), 2),\n      visible = ref[0],\n      setVisible = ref[1];\n\n  var ref1 = _sliced_to_array((0, _react).useState(null), 2),\n      element = ref1[0],\n      setElement = ref1[1];\n\n  (0, _react).useEffect(function () {\n    if (hasIntersectionObserver) {\n      if (unobserve.current) {\n        unobserve.current();\n        unobserve.current = undefined;\n      }\n\n      if (isDisabled || visible) return;\n\n      if (element && element.tagName) {\n        unobserve.current = observe(element, function (isVisible) {\n          return isVisible && setVisible(isVisible);\n        }, {\n          root: rootRef == null ? void 0 : rootRef.current,\n          rootMargin: rootMargin\n        });\n      }\n\n      return function () {\n        unobserve.current == null ? void 0 : unobserve.current();\n        unobserve.current = undefined;\n      };\n    } else {\n      if (!visible) {\n        var idleCallback = (0, _requestIdleCallback).requestIdleCallback(function () {\n          return setVisible(true);\n        });\n        return function () {\n          return (0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n        };\n      }\n    }\n  }, [element, isDisabled, rootMargin, rootRef, visible]);\n  var resetVisible = (0, _react).useCallback(function () {\n    setVisible(false);\n  }, []);\n  return [setElement, visible, resetVisible];\n}\n\n_s(useIntersection, \"Ftx7DdZ+Ab721MTRqq19v5g/6/E=\");\n\nfunction observe(element, callback, options) {\n  var ref = createObserver(options),\n      id = ref.id,\n      observer = ref.observer,\n      elements = ref.elements;\n  elements.set(element, callback);\n  observer.observe(element);\n  return function unobserve() {\n    elements.delete(element);\n    observer.unobserve(element); // Destroy observer when there's nothing left to watch:\n\n    if (elements.size === 0) {\n      observer.disconnect();\n      observers.delete(id);\n      var index = idList.findIndex(function (obj) {\n        return obj.root === id.root && obj.margin === id.margin;\n      });\n\n      if (index > -1) {\n        idList.splice(index, 1);\n      }\n    }\n  };\n}\n\nvar observers = new Map();\nvar idList = [];\n\nfunction createObserver(options) {\n  var id = {\n    root: options.root || null,\n    margin: options.rootMargin || \"\"\n  };\n  var existing = idList.find(function (obj) {\n    return obj.root === id.root && obj.margin === id.margin;\n  });\n  var instance;\n\n  if (existing) {\n    instance = observers.get(existing);\n\n    if (instance) {\n      return instance;\n    }\n  }\n\n  var elements = new Map();\n  var observer = new IntersectionObserver(function (entries) {\n    entries.forEach(function (entry) {\n      var callback = elements.get(entry.target);\n      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n\n      if (callback && isVisible) {\n        callback(isVisible);\n      }\n    });\n  }, options);\n  instance = {\n    id: id,\n    observer: observer,\n    elements: elements\n  };\n  idList.push(id);\n  observers.set(id, instance);\n  return instance;\n}\n\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n  Object.defineProperty(exports.default, \"__esModule\", {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOzs7Ozs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0NILEVBQUFBO0FBR0FFLHVCQUFBQSxHQUEwQkUsZUFBMUJGOztBQUNBLElBQUlHLE1BQU0sR0FBR0MsbUJBQU8sQ0FBQyw0Q0FBRCxDQUFwQjs7QUFDQSxJQUFJQyxvQkFBb0IsR0FBR0QsbUJBQU8sQ0FBQyx5RkFBRCxDQUFsQzs7QUFDQSxJQUFNRSx1QkFBdUIsR0FBRyxPQUFPQyxvQkFBUCxLQUFnQyxVQUFoRTs7QUFDQSxTQUFTTCxlQUFULENBQXlCTSxLQUF6QixFQUErRDtNQUFwQ0MsT0FBTyxHQUFURCxLQUFvQyxDQUFsQ0M7TUFBVUMsVUFBVSxHQUF0QkYsS0FBb0MsQ0FBeEJFO01BQWFDLFFBQVEsR0FBakNILEtBQW9DLENBQVhHOzs7O0VBQzlDLElBQU1DLFVBQVUsR0FBR0QsUUFBUSxJQUFJLENBQUNMLHVCQUFoQztFQUNBLElBQU1PLFNBQVMsR0FBRyxDQUFDLEdBQUdWLE1BQUosRUFBWVcsTUFBWixFQUFsQjs7RUFDQSxJQUE4QkMsR0FBMkIsb0JBQTNCLENBQUMsR0FBR1osTUFBSixFQUFZYSxRQUFaLENBQXFCLEtBQXJCLENBQTJCLElBQXpEO0VBQUEsSUFBT0MsT0FBTyxHQUFnQkYsR0FBMkIsR0FBekQ7RUFBQSxJQUFnQkcsVUFBVSxHQUFJSCxHQUEyQixHQUF6RDs7RUFDQSxJQUE4QkksSUFBMEIsb0JBQTFCLENBQUMsR0FBR2hCLE1BQUosRUFBWWEsUUFBWixDQUFxQixJQUFyQixDQUEwQixJQUF4RDtFQUFBLElBQU9JLE9BQU8sR0FBZ0JELElBQTBCLEdBQXhEO0VBQUEsSUFBZ0JFLFVBQVUsR0FBSUYsSUFBMEIsR0FBeEQ7O0VBQ0EsQ0FBQyxHQUFHaEIsTUFBSixFQUFZbUIsU0FBWixDQUFzQixZQUFJO0lBQ3RCLElBQUlo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QSxLQUFLLENBQUNHLGlCQUFOSCxHQUEwQixDQUFwRTs7TUFDQSxJQUFJeEIsUUFBUSxJQUFJUCxTQUFoQixFQUEyQjtRQUN2Qk8sUUFBUSxDQUFDUCxTQUFELENBQVJPO01BQ0g7SUFDSixDQU5Ec0I7RUFPSCxDQVJnQixFQVFkckIsT0FSYyxDQUFqQjtFQVNBbUIsUUFBUSxHQUFHO0lBQ1BqQixFQUFFLEVBQUZBLEVBRE87SUFFUEMsUUFBUSxFQUFSQSxRQUZPO0lBR1BDLFFBQVEsRUFBUkE7RUFITyxDQUFYZTtFQUtBUixNQUFNLENBQUNnQixJQUFQaEIsQ0FBWVQsRUFBWlM7RUFDQUYsU0FBUyxDQUFDSixHQUFWSSxDQUFjUCxFQUFkTyxFQUFrQlUsUUFBbEJWO0VBQ0EsT0FBT1UsUUFBUDtBQUNIOztBQUVELElBQUksQ0FBQyxPQUFPdEQsT0FBTyxDQUFDK0QsT0FBZixLQUEyQixVQUEzQixJQUEwQyxPQUFPL0QsT0FBTyxDQUFDK0QsT0FBZixLQUEyQixRQUEzQixJQUF1Qy9ELE9BQU8sQ0FBQytELE9BQVIvRCxLQUFvQixJQUF0RyxLQUFnSCxPQUFPQSxPQUFPLENBQUMrRCxPQUFSL0QsQ0FBZ0JnRSxVQUF2QixLQUFzQyxXQUExSixFQUF1SztFQUNyS2xFLE1BQU0sQ0FBQ0MsY0FBUEQsQ0FBc0JFLE9BQU8sQ0FBQytELE9BQTlCakUsRUFBdUMsWUFBdkNBLEVBQXFEO0lBQUVHLEtBQUssRUFBRTtFQUFULENBQXJESDtFQUNBQSxNQUFNLENBQUNtRSxNQUFQbkUsQ0FBY0UsT0FBTyxDQUFDK0QsT0FBdEJqRSxFQUErQkUsT0FBL0JGO0VBQ0FvRSxNQUFNLENBQUNsRSxPQUFQa0UsR0FBaUJsRSxPQUFPLENBQUMrRCxPQUF6Qkc7QUFDRCxDLENBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvdXNlLWludGVyc2VjdGlvbi5qcz9mZDk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy51c2VJbnRlcnNlY3Rpb24gPSB1c2VJbnRlcnNlY3Rpb247XG52YXIgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIF9yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWlyZShcIi4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrXCIpO1xuY29uc3QgaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbic7XG5mdW5jdGlvbiB1c2VJbnRlcnNlY3Rpb24oeyByb290UmVmICwgcm9vdE1hcmdpbiAsIGRpc2FibGVkICB9KSB7XG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IGRpc2FibGVkIHx8ICFoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbiAgICBjb25zdCB1bm9ic2VydmUgPSAoMCwgX3JlYWN0KS51c2VSZWYoKTtcbiAgICBjb25zdCBbdmlzaWJsZSwgc2V0VmlzaWJsZV0gPSAoMCwgX3JlYWN0KS51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2VsZW1lbnQsIHNldEVsZW1lbnRdID0gKDAsIF9yZWFjdCkudXNlU3RhdGUobnVsbCk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgaWYgKHVub2JzZXJ2ZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQoKTtcbiAgICAgICAgICAgICAgICB1bm9ic2VydmUuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHZpc2libGUpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID0gb2JzZXJ2ZShlbGVtZW50LCAoaXNWaXNpYmxlKT0+aXNWaXNpYmxlICYmIHNldFZpc2libGUoaXNWaXNpYmxlKSwge1xuICAgICAgICAgICAgICAgICAgICByb290OiByb290UmVmID09IG51bGwgPyB2b2lkIDAgOiByb290UmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIHJvb3RNYXJnaW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiB1bm9ic2VydmUuY3VycmVudCgpO1xuICAgICAgICAgICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVDYWxsYmFjayA9ICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+c2V0VmlzaWJsZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpPT4oMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLmNhbmNlbElkbGVDYWxsYmFjayhpZGxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICByb290TWFyZ2luLFxuICAgICAgICByb290UmVmLFxuICAgICAgICB2aXNpYmxlXG4gICAgXSk7XG4gICAgY29uc3QgcmVzZXRWaXNpYmxlID0gKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNldEVsZW1lbnQsXG4gICAgICAgIHZpc2libGUsXG4gICAgICAgIHJlc2V0VmlzaWJsZVxuICAgIF07XG59XG5mdW5jdGlvbiBvYnNlcnZlKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBpZCAsIG9ic2VydmVyICwgZWxlbWVudHMgIH0gPSBjcmVhdGVPYnNlcnZlcihvcHRpb25zKTtcbiAgICBlbGVtZW50cy5zZXQoZWxlbWVudCwgY2FsbGJhY2spO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVub2JzZXJ2ZSgpIHtcbiAgICAgICAgZWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgIC8vIERlc3Ryb3kgb2JzZXJ2ZXIgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byB3YXRjaDpcbiAgICAgICAgaWYgKGVsZW1lbnRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIG9ic2VydmVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpZExpc3QuZmluZEluZGV4KChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW4pO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZExpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBvYnNlcnZlcnMgPSBuZXcgTWFwKCk7XG5jb25zdCBpZExpc3QgPSBbXTtcbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpIHtcbiAgICBjb25zdCBpZCA9IHtcbiAgICAgICAgcm9vdDogb3B0aW9ucy5yb290IHx8IG51bGwsXG4gICAgICAgIG1hcmdpbjogb3B0aW9ucy5yb290TWFyZ2luIHx8ICcnXG4gICAgfTtcbiAgICBjb25zdCBleGlzdGluZyA9IGlkTGlzdC5maW5kKChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW4pO1xuICAgIGxldCBpbnN0YW5jZTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYnNlcnZlcnMuZ2V0KGV4aXN0aW5nKTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpPT57XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpPT57XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGVsZW1lbnRzLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaXNJbnRlcnNlY3RpbmcgfHwgZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGlzVmlzaWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIG9wdGlvbnMpO1xuICAgIGluc3RhbmNlID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgb2JzZXJ2ZXIsXG4gICAgICAgIGVsZW1lbnRzXG4gICAgfTtcbiAgICBpZExpc3QucHVzaChpZCk7XG4gICAgb2JzZXJ2ZXJzLnNldChpZCwgaW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWludGVyc2VjdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1c2VJbnRlcnNlY3Rpb24iLCJfcmVhY3QiLCJyZXF1aXJlIiwiX3JlcXVlc3RJZGxlQ2FsbGJhY2siLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwicGFyYW0iLCJyb290UmVmIiwicm9vdE1hcmdpbiIsImRpc2FibGVkIiwiaXNEaXNhYmxlZCIsInVub2JzZXJ2ZSIsInVzZVJlZiIsInJlZiIsInVzZVN0YXRlIiwidmlzaWJsZSIsInNldFZpc2libGUiLCJyZWYxIiwiZWxlbWVudCIsInNldEVsZW1lbnQiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwidW5kZWZpbmVkIiwidGFnTmFtZSIsIm9ic2VydmUiLCJpc1Zpc2libGUiLCJyb290IiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsInJlc2V0VmlzaWJsZSIsInVzZUNhbGxiYWNrIiwiY2FsbGJhY2siLCJvcHRpb25zIiwiY3JlYXRlT2JzZXJ2ZXIiLCJpZCIsIm9ic2VydmVyIiwiZWxlbWVudHMiLCJzZXQiLCJkZWxldGUiLCJzaXplIiwiZGlzY29ubmVjdCIsIm9ic2VydmVycyIsImluZGV4IiwiaWRMaXN0IiwiZmluZEluZGV4Iiwib2JqIiwibWFyZ2luIiwic3BsaWNlIiwiTWFwIiwiZXhpc3RpbmciLCJmaW5kIiwiaW5zdGFuY2UiLCJnZXQiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwidGFyZ2V0IiwiaXNJbnRlcnNlY3RpbmciLCJpbnRlcnNlY3Rpb25SYXRpbyIsInB1c2giLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/app-router-context.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/app-router-context.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AppRouterContext = void 0;\n\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar AppRouterContext = _react.default.createContext(null);\n\nexports.AppRouterContext = AppRouterContext;\n\nif (true) {\n  AppRouterContext.displayName = \"AppRouterContext\";\n} //# sourceMappingURL=app-router-context.js.map\n\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3Q0gsRUFBQUE7QUFHQUUsd0JBQUFBLEdBQTJCLEtBQUssQ0FBaENBOztBQUNBLElBQUlHLE1BQU0sR0FBR0Msc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsNENBQUQsQ0FBUixDQUFuQzs7QUFDQSxTQUFTRCxzQkFBVCxDQUFnQ0UsR0FBaEMsRUFBcUM7RUFDakMsT0FBT0EsR0FBRyxJQUFJQSxHQUFHLENBQUNDLFVBQVhELEdBQXdCQSxHQUF4QkEsR0FBOEI7SUFDakNFLE9BQU8sRUFBRUY7RUFEd0IsQ0FBckM7QUFHSDs7QUFDRCxJQUFNSixnQkFBZ0IsR0FBR0MsTUFBTSxDQUFDSyxPQUFQTCxDQUFlTSxhQUFmTixDQUE2QixJQUE3QkEsQ0FBekI7O0FBQ0FILHdCQUFBQSxHQUEyQkUsZ0JBQTNCRjs7QUFDQSxJQUFJVSxJQUFKLEVBQTJDO0VBQ3ZDUixnQkFBZ0IsQ0FBQ1MsV0FBakJULEdBQStCLGtCQUEvQkE7QUFDSCxDLENBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5qcz9kYmRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5BcHBSb3V0ZXJDb250ZXh0ID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmNvbnN0IEFwcFJvdXRlckNvbnRleHQgPSBfcmVhY3QuZGVmYXVsdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuZXhwb3J0cy5BcHBSb3V0ZXJDb250ZXh0ID0gQXBwUm91dGVyQ29udGV4dDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBBcHBSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJBcHBSb3V0ZXJDb250ZXh0XCI7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZXItY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBcHBSb3V0ZXJDb250ZXh0IiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJvYmoiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/app-router-context.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.matchRemotePattern = matchRemotePattern;\nexports.hasMatch = hasMatch;\n\nvar _micromatch = __webpack_require__(/*! next/dist/compiled/micromatch */ \"./node_modules/next/dist/compiled/micromatch/index.js\");\n\nfunction matchRemotePattern(pattern, url) {\n  if (pattern.protocol !== undefined) {\n    var actualProto = url.protocol.slice(0, -1);\n\n    if (pattern.protocol !== actualProto) {\n      return false;\n    }\n  }\n\n  if (pattern.port !== undefined) {\n    if (pattern.port !== url.port) {\n      return false;\n    }\n  }\n\n  if (pattern.hostname === undefined) {\n    throw new Error(\"Pattern should define hostname but found\\n\".concat(JSON.stringify(pattern)));\n  } else {\n    if (!(0, _micromatch).makeRe(pattern.hostname).test(url.hostname)) {\n      return false;\n    }\n  }\n\n  var _pathname;\n\n  if (!(0, _micromatch).makeRe((_pathname = pattern.pathname) != null ? _pathname : \"**\").test(url.pathname)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction hasMatch(domains, remotePatterns, url) {\n  return domains.some(function (domain) {\n    return url.hostname === domain;\n  }) || remotePatterns.some(function (p) {\n    return matchRemotePattern(p, url);\n  });\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbWF0Y2gtcmVtb3RlLXBhdHRlcm4uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDSCxFQUFBQTtBQUdBRSwwQkFBQUEsR0FBNkJFLGtCQUE3QkY7QUFDQUEsZ0JBQUFBLEdBQW1CRyxRQUFuQkg7O0FBQ0EsSUFBSUksV0FBVyxHQUFHQyxtQkFBTyxDQUFDLDRGQUFELENBQXpCOztBQUNBLFNBQVNILGtCQUFULENBQTRCSSxPQUE1QixFQUFxQ0MsR0FBckMsRUFBMEM7RUFDdEMsSUFBSUQsT0FBTyxDQUFDRSxRQUFSRixLQUFxQkcsU0FBekIsRUFBb0M7SUFDaEMsSUFBTUMsV0FBVyxHQUFHSCxHQUFHLENBQUNDLFFBQUpELENBQWFJLEtBQWJKLENBQW1CLENBQW5CQSxFQUFzQixDQUFDLENBQXZCQSxDQUFwQjs7SUFDQSxJQUFJRCxPQUFPLENBQUNFLFFBQVJGLEtBQXFCSSxXQUF6QixFQUFzQztNQUNsQyxPQUFPLEtBQVA7SUFDSDtFQUNKOztFQUNELElBQUlKLE9BQU8sQ0FBQ00sSUFBUk4sS0FBaUJHLFNBQXJCLEVBQWdDO0lBQzVCLElBQUlILE9BQU8sQ0FBQ00sSUFBUk4sS0FBaUJDLEdBQUcsQ0FBQ0ssSUFBekIsRUFBK0I7TUFDM0IsT0FBTyxLQUFQO0lBQ0g7RUFDSjs7RUFDRCxJQUFJTixPQUFPLENBQUNPLFFBQVJQLEtBQXFCRyxTQUF6QixFQUFvQztJQUNoQyxNQUFNLElBQUlLLEtBQUosQ0FBVSw2Q0FBcUVDLE1BQXJFLENBQTZDQyxJQUFJLENBQUNDLFNBQUxELENBQWVWLE9BQWZVLENBQTdDLENBQVYsQ0FBTjtFQUNILENBRkQsTUFFTztJQUNILElBQUksQ0FBQyxDQUFDLEdBQUdaLFdBQUosRUFBaUJjLE1BQWpCLENBQXdCWixPQUFPLENBQUNPLFFBQWhDLEVBQTBDTSxJQUExQyxDQUErQ1osR0FBRyxDQUFDTSxRQUFuRCxDQUFMLEVBQW1FO01BQy9ELE9BQU8sS0FBUDtJQUNIO0VBQ0o7O0VBQ0QsSUFBSU8sU0FBSjs7RUFDQSxJQUFJLENBQUMsQ0FBQyxHQUFHaEIsV0FBSixFQUFpQmMsTUFBakIsQ0FBd0IsQ0FBQ0UsU0FBUyxHQUFHZCxPQUFPLENBQUNlLFFBQXJCLEtBQWtDLElBQWxDLEdBQXlDRCxTQUF6QyxHQUFxRCxJQUE3RSxFQUFtRkQsSUFBbkYsQ0FBd0ZaLEdBQUcsQ0FBQ2MsUUFBNUYsQ0FBTCxFQUE0RztJQUN4RyxPQUFPLEtBQVA7RUFDSDs7RUFDRCxPQUFPLElBQVA7QUFDSDs7QUFDRCxTQUFTbEIsUUFBVCxDQUFrQm1CLE9BQWxCLEVBQTJCQyxjQUEzQixFQUEyQ2hCLEdBQTNDLEVBQWdEO0VBQzVDLE9BQU9lLE9BQU8sQ0FBQ0UsSUFBUkYsQ0FBYSxVQUFDRyxNQUFELEVBQU87V0FBR2xCLEdBQUcsQ0FBQ00sUUFBSk4sS0FBaUJrQjtFQUFNLENBQTlDSCxLQUFtREMsY0FBYyxDQUFDQyxJQUFmRCxDQUFvQixVQUFDRyxDQUFELEVBQUU7V0FBR3hCLGtCQUFrQixDQUFDd0IsQ0FBRCxFQUFJbkIsR0FBSjtFQUFRLENBQW5EZ0IsQ0FBMUQ7QUFDSCxDLENBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL21hdGNoLXJlbW90ZS1wYXR0ZXJuLmpzPzBjOWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1hdGNoUmVtb3RlUGF0dGVybiA9IG1hdGNoUmVtb3RlUGF0dGVybjtcbmV4cG9ydHMuaGFzTWF0Y2ggPSBoYXNNYXRjaDtcbnZhciBfbWljcm9tYXRjaCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvbWljcm9tYXRjaFwiKTtcbmZ1bmN0aW9uIG1hdGNoUmVtb3RlUGF0dGVybihwYXR0ZXJuLCB1cmwpIHtcbiAgICBpZiAocGF0dGVybi5wcm90b2NvbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGFjdHVhbFByb3RvID0gdXJsLnByb3RvY29sLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgaWYgKHBhdHRlcm4ucHJvdG9jb2wgIT09IGFjdHVhbFByb3RvKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdHRlcm4ucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuLnBvcnQgIT09IHVybC5wb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdHRlcm4uaG9zdG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdHRlcm4gc2hvdWxkIGRlZmluZSBob3N0bmFtZSBidXQgZm91bmRcXG4ke0pTT04uc3RyaW5naWZ5KHBhdHRlcm4pfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKDAsIF9taWNyb21hdGNoKS5tYWtlUmUocGF0dGVybi5ob3N0bmFtZSkudGVzdCh1cmwuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9wYXRobmFtZTtcbiAgICBpZiAoISgwLCBfbWljcm9tYXRjaCkubWFrZVJlKChfcGF0aG5hbWUgPSBwYXR0ZXJuLnBhdGhuYW1lKSAhPSBudWxsID8gX3BhdGhuYW1lIDogXCIqKlwiKS50ZXN0KHVybC5wYXRobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGhhc01hdGNoKGRvbWFpbnMsIHJlbW90ZVBhdHRlcm5zLCB1cmwpIHtcbiAgICByZXR1cm4gZG9tYWlucy5zb21lKChkb21haW4pPT51cmwuaG9zdG5hbWUgPT09IGRvbWFpbikgfHwgcmVtb3RlUGF0dGVybnMuc29tZSgocCk9Pm1hdGNoUmVtb3RlUGF0dGVybihwLCB1cmwpKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0Y2gtcmVtb3RlLXBhdHRlcm4uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibWF0Y2hSZW1vdGVQYXR0ZXJuIiwiaGFzTWF0Y2giLCJfbWljcm9tYXRjaCIsInJlcXVpcmUiLCJwYXR0ZXJuIiwidXJsIiwicHJvdG9jb2wiLCJ1bmRlZmluZWQiLCJhY3R1YWxQcm90byIsInNsaWNlIiwicG9ydCIsImhvc3RuYW1lIiwiRXJyb3IiLCJjb25jYXQiLCJKU09OIiwic3RyaW5naWZ5IiwibWFrZVJlIiwidGVzdCIsIl9wYXRobmFtZSIsInBhdGhuYW1lIiwiZG9tYWlucyIsInJlbW90ZVBhdHRlcm5zIiwic29tZSIsImRvbWFpbiIsInAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function () {\n  var e = {\n    449: function (e, r) {\n      \"use strict\";\n\n      r.byteLength = byteLength;\n      r.toByteArray = toByteArray;\n      r.fromByteArray = fromByteArray;\n      var t = [];\n      var f = [];\n      var n = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n      var i = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n      for (var o = 0, u = i.length; o < u; ++o) {\n        t[o] = i[o];\n        f[i.charCodeAt(o)] = o;\n      }\n\n      f[\"-\".charCodeAt(0)] = 62;\n      f[\"_\".charCodeAt(0)] = 63;\n\n      function getLens(e) {\n        var r = e.length;\n\n        if (r % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n\n        var t = e.indexOf(\"=\");\n        if (t === -1) t = r;\n        var f = t === r ? 0 : 4 - t % 4;\n        return [t, f];\n      }\n\n      function byteLength(e) {\n        var r = getLens(e);\n        var t = r[0];\n        var f = r[1];\n        return (t + f) * 3 / 4 - f;\n      }\n\n      function _byteLength(e, r, t) {\n        return (r + t) * 3 / 4 - t;\n      }\n\n      function toByteArray(e) {\n        var r;\n        var t = getLens(e);\n        var i = t[0];\n        var o = t[1];\n        var u = new n(_byteLength(e, i, o));\n        var a = 0;\n        var s = o > 0 ? i - 4 : i;\n        var h;\n\n        for (h = 0; h < s; h += 4) {\n          r = f[e.charCodeAt(h)] << 18 | f[e.charCodeAt(h + 1)] << 12 | f[e.charCodeAt(h + 2)] << 6 | f[e.charCodeAt(h + 3)];\n          u[a++] = r >> 16 & 255;\n          u[a++] = r >> 8 & 255;\n          u[a++] = r & 255;\n        }\n\n        if (o === 2) {\n          r = f[e.charCodeAt(h)] << 2 | f[e.charCodeAt(h + 1)] >> 4;\n          u[a++] = r & 255;\n        }\n\n        if (o === 1) {\n          r = f[e.charCodeAt(h)] << 10 | f[e.charCodeAt(h + 1)] << 4 | f[e.charCodeAt(h + 2)] >> 2;\n          u[a++] = r >> 8 & 255;\n          u[a++] = r & 255;\n        }\n\n        return u;\n      }\n\n      function tripletToBase64(e) {\n        return t[e >> 18 & 63] + t[e >> 12 & 63] + t[e >> 6 & 63] + t[e & 63];\n      }\n\n      function encodeChunk(e, r, t) {\n        var f;\n        var n = [];\n\n        for (var i = r; i < t; i += 3) {\n          f = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255);\n          n.push(tripletToBase64(f));\n        }\n\n        return n.join(\"\");\n      }\n\n      function fromByteArray(e) {\n        var r;\n        var f = e.length;\n        var n = f % 3;\n        var i = [];\n        var o = 16383;\n\n        for (var u = 0, a = f - n; u < a; u += o) {\n          i.push(encodeChunk(e, u, u + o > a ? a : u + o));\n        }\n\n        if (n === 1) {\n          r = e[f - 1];\n          i.push(t[r >> 2] + t[r << 4 & 63] + \"==\");\n        } else if (n === 2) {\n          r = (e[f - 2] << 8) + e[f - 1];\n          i.push(t[r >> 10] + t[r >> 4 & 63] + t[r << 2 & 63] + \"=\");\n        }\n\n        return i.join(\"\");\n      }\n    },\n    877: function (e, r, t) {\n      \"use strict\";\n      /*!\n       * The buffer module from node.js, for the browser.\n       *\n       * @author   Feross Aboukhadijeh <https://feross.org>\n       * @license  MIT\n       */\n\n      var f = t(449);\n      var n = t(543);\n      var i = typeof Symbol === \"function\" && typeof Symbol.for === \"function\" ? Symbol.for(\"nodejs.util.inspect.custom\") : null;\n      r.Buffer = Buffer;\n      r.SlowBuffer = SlowBuffer;\n      r.INSPECT_MAX_BYTES = 50;\n      var o = 2147483647;\n      r.kMaxLength = o;\n      Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\n      if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(\"This browser lacks typed array (Uint8Array) support which is required by \" + \"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\n      }\n\n      function typedArraySupport() {\n        try {\n          var e = new Uint8Array(1);\n          var r = {\n            foo: function () {\n              return 42;\n            }\n          };\n          Object.setPrototypeOf(r, Uint8Array.prototype);\n          Object.setPrototypeOf(e, r);\n          return e.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n\n      Object.defineProperty(Buffer.prototype, \"parent\", {\n        enumerable: true,\n        get: function () {\n          if (!Buffer.isBuffer(this)) return undefined;\n          return this.buffer;\n        }\n      });\n      Object.defineProperty(Buffer.prototype, \"offset\", {\n        enumerable: true,\n        get: function () {\n          if (!Buffer.isBuffer(this)) return undefined;\n          return this.byteOffset;\n        }\n      });\n\n      function createBuffer(e) {\n        if (e > o) {\n          throw new RangeError('The value \"' + e + '\" is invalid for option \"size\"');\n        }\n\n        var r = new Uint8Array(e);\n        Object.setPrototypeOf(r, Buffer.prototype);\n        return r;\n      }\n\n      function Buffer(e, r, t) {\n        if (typeof e === \"number\") {\n          if (typeof r === \"string\") {\n            throw new TypeError('The \"string\" argument must be of type string. Received type number');\n          }\n\n          return allocUnsafe(e);\n        }\n\n        return from(e, r, t);\n      }\n\n      Buffer.poolSize = 8192;\n\n      function from(e, r, t) {\n        if (typeof e === \"string\") {\n          return fromString(e, r);\n        }\n\n        if (ArrayBuffer.isView(e)) {\n          return fromArrayLike(e);\n        }\n\n        if (e == null) {\n          throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \" + \"or Array-like Object. Received type \" + typeof e);\n        }\n\n        if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) {\n          return fromArrayBuffer(e, r, t);\n        }\n\n        if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(e, SharedArrayBuffer) || e && isInstance(e.buffer, SharedArrayBuffer))) {\n          return fromArrayBuffer(e, r, t);\n        }\n\n        if (typeof e === \"number\") {\n          throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n        }\n\n        var f = e.valueOf && e.valueOf();\n\n        if (f != null && f !== e) {\n          return Buffer.from(f, r, t);\n        }\n\n        var n = fromObject(e);\n        if (n) return n;\n\n        if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === \"function\") {\n          return Buffer.from(e[Symbol.toPrimitive](\"string\"), r, t);\n        }\n\n        throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \" + \"or Array-like Object. Received type \" + typeof e);\n      }\n\n      Buffer.from = function (e, r, t) {\n        return from(e, r, t);\n      };\n\n      Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\n      Object.setPrototypeOf(Buffer, Uint8Array);\n\n      function assertSize(e) {\n        if (typeof e !== \"number\") {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (e < 0) {\n          throw new RangeError('The value \"' + e + '\" is invalid for option \"size\"');\n        }\n      }\n\n      function alloc(e, r, t) {\n        assertSize(e);\n\n        if (e <= 0) {\n          return createBuffer(e);\n        }\n\n        if (r !== undefined) {\n          return typeof t === \"string\" ? createBuffer(e).fill(r, t) : createBuffer(e).fill(r);\n        }\n\n        return createBuffer(e);\n      }\n\n      Buffer.alloc = function (e, r, t) {\n        return alloc(e, r, t);\n      };\n\n      function allocUnsafe(e) {\n        assertSize(e);\n        return createBuffer(e < 0 ? 0 : checked(e) | 0);\n      }\n\n      Buffer.allocUnsafe = function (e) {\n        return allocUnsafe(e);\n      };\n\n      Buffer.allocUnsafeSlow = function (e) {\n        return allocUnsafe(e);\n      };\n\n      function fromString(e, r) {\n        if (typeof r !== \"string\" || r === \"\") {\n          r = \"utf8\";\n        }\n\n        if (!Buffer.isEncoding(r)) {\n          throw new TypeError(\"Unknown encoding: \" + r);\n        }\n\n        var t = byteLength(e, r) | 0;\n        var f = createBuffer(t);\n        var n = f.write(e, r);\n\n        if (n !== t) {\n          f = f.slice(0, n);\n        }\n\n        return f;\n      }\n\n      function fromArrayLike(e) {\n        var r = e.length < 0 ? 0 : checked(e.length) | 0;\n        var t = createBuffer(r);\n\n        for (var f = 0; f < r; f += 1) {\n          t[f] = e[f] & 255;\n        }\n\n        return t;\n      }\n\n      function fromArrayBuffer(e, r, t) {\n        if (r < 0 || e.byteLength < r) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n\n        if (e.byteLength < r + (t || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n\n        var f;\n\n        if (r === undefined && t === undefined) {\n          f = new Uint8Array(e);\n        } else if (t === undefined) {\n          f = new Uint8Array(e, r);\n        } else {\n          f = new Uint8Array(e, r, t);\n        }\n\n        Object.setPrototypeOf(f, Buffer.prototype);\n        return f;\n      }\n\n      function fromObject(e) {\n        if (Buffer.isBuffer(e)) {\n          var r = checked(e.length) | 0;\n          var t = createBuffer(r);\n\n          if (t.length === 0) {\n            return t;\n          }\n\n          e.copy(t, 0, 0, r);\n          return t;\n        }\n\n        if (e.length !== undefined) {\n          if (typeof e.length !== \"number\" || numberIsNaN(e.length)) {\n            return createBuffer(0);\n          }\n\n          return fromArrayLike(e);\n        }\n\n        if (e.type === \"Buffer\" && Array.isArray(e.data)) {\n          return fromArrayLike(e.data);\n        }\n      }\n\n      function checked(e) {\n        if (e >= o) {\n          throw new RangeError(\"Attempt to allocate Buffer larger than maximum \" + \"size: 0x\" + o.toString(16) + \" bytes\");\n        }\n\n        return e | 0;\n      }\n\n      function SlowBuffer(e) {\n        if (+e != e) {\n          e = 0;\n        }\n\n        return Buffer.alloc(+e);\n      }\n\n      Buffer.isBuffer = function isBuffer(e) {\n        return e != null && e._isBuffer === true && e !== Buffer.prototype;\n      };\n\n      Buffer.compare = function compare(e, r) {\n        if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);\n        if (isInstance(r, Uint8Array)) r = Buffer.from(r, r.offset, r.byteLength);\n\n        if (!Buffer.isBuffer(e) || !Buffer.isBuffer(r)) {\n          throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n        }\n\n        if (e === r) return 0;\n        var t = e.length;\n        var f = r.length;\n\n        for (var n = 0, i = Math.min(t, f); n < i; ++n) {\n          if (e[n] !== r[n]) {\n            t = e[n];\n            f = r[n];\n            break;\n          }\n        }\n\n        if (t < f) return -1;\n        if (f < t) return 1;\n        return 0;\n      };\n\n      Buffer.isEncoding = function isEncoding(e) {\n        switch (String(e).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return true;\n\n          default:\n            return false;\n        }\n      };\n\n      Buffer.concat = function concat(e, r) {\n        if (!Array.isArray(e)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n\n        if (e.length === 0) {\n          return Buffer.alloc(0);\n        }\n\n        var t;\n\n        if (r === undefined) {\n          r = 0;\n\n          for (t = 0; t < e.length; ++t) {\n            r += e[t].length;\n          }\n        }\n\n        var f = Buffer.allocUnsafe(r);\n        var n = 0;\n\n        for (t = 0; t < e.length; ++t) {\n          var i = e[t];\n\n          if (isInstance(i, Uint8Array)) {\n            i = Buffer.from(i);\n          }\n\n          if (!Buffer.isBuffer(i)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          }\n\n          i.copy(f, n);\n          n += i.length;\n        }\n\n        return f;\n      };\n\n      function byteLength(e, r) {\n        if (Buffer.isBuffer(e)) {\n          return e.length;\n        }\n\n        if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {\n          return e.byteLength;\n        }\n\n        if (typeof e !== \"string\") {\n          throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + \"Received type \" + typeof e);\n        }\n\n        var t = e.length;\n        var f = arguments.length > 2 && arguments[2] === true;\n        if (!f && t === 0) return 0;\n        var n = false;\n\n        for (;;) {\n          switch (r) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return t;\n\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8ToBytes(e).length;\n\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return t * 2;\n\n            case \"hex\":\n              return t >>> 1;\n\n            case \"base64\":\n              return base64ToBytes(e).length;\n\n            default:\n              if (n) {\n                return f ? -1 : utf8ToBytes(e).length;\n              }\n\n              r = (\"\" + r).toLowerCase();\n              n = true;\n          }\n        }\n      }\n\n      Buffer.byteLength = byteLength;\n\n      function slowToString(e, r, t) {\n        var f = false;\n\n        if (r === undefined || r < 0) {\n          r = 0;\n        }\n\n        if (r > this.length) {\n          return \"\";\n        }\n\n        if (t === undefined || t > this.length) {\n          t = this.length;\n        }\n\n        if (t <= 0) {\n          return \"\";\n        }\n\n        t >>>= 0;\n        r >>>= 0;\n\n        if (t <= r) {\n          return \"\";\n        }\n\n        if (!e) e = \"utf8\";\n\n        while (true) {\n          switch (e) {\n            case \"hex\":\n              return hexSlice(this, r, t);\n\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Slice(this, r, t);\n\n            case \"ascii\":\n              return asciiSlice(this, r, t);\n\n            case \"latin1\":\n            case \"binary\":\n              return latin1Slice(this, r, t);\n\n            case \"base64\":\n              return base64Slice(this, r, t);\n\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return utf16leSlice(this, r, t);\n\n            default:\n              if (f) throw new TypeError(\"Unknown encoding: \" + e);\n              e = (e + \"\").toLowerCase();\n              f = true;\n          }\n        }\n      }\n\n      Buffer.prototype._isBuffer = true;\n\n      function swap(e, r, t) {\n        var f = e[r];\n        e[r] = e[t];\n        e[t] = f;\n      }\n\n      Buffer.prototype.swap16 = function swap16() {\n        var e = this.length;\n\n        if (e % 2 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n        }\n\n        for (var r = 0; r < e; r += 2) {\n          swap(this, r, r + 1);\n        }\n\n        return this;\n      };\n\n      Buffer.prototype.swap32 = function swap32() {\n        var e = this.length;\n\n        if (e % 4 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n        }\n\n        for (var r = 0; r < e; r += 4) {\n          swap(this, r, r + 3);\n          swap(this, r + 1, r + 2);\n        }\n\n        return this;\n      };\n\n      Buffer.prototype.swap64 = function swap64() {\n        var e = this.length;\n\n        if (e % 8 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n        }\n\n        for (var r = 0; r < e; r += 8) {\n          swap(this, r, r + 7);\n          swap(this, r + 1, r + 6);\n          swap(this, r + 2, r + 5);\n          swap(this, r + 3, r + 4);\n        }\n\n        return this;\n      };\n\n      Buffer.prototype.toString = function toString() {\n        var e = this.length;\n        if (e === 0) return \"\";\n        if (arguments.length === 0) return utf8Slice(this, 0, e);\n        return slowToString.apply(this, arguments);\n      };\n\n      Buffer.prototype.toLocaleString = Buffer.prototype.toString;\n\n      Buffer.prototype.equals = function equals(e) {\n        if (!Buffer.isBuffer(e)) throw new TypeError(\"Argument must be a Buffer\");\n        if (this === e) return true;\n        return Buffer.compare(this, e) === 0;\n      };\n\n      Buffer.prototype.inspect = function inspect() {\n        var e = \"\";\n        var t = r.INSPECT_MAX_BYTES;\n        e = this.toString(\"hex\", 0, t).replace(/(.{2})/g, \"$1 \").trim();\n        if (this.length > t) e += \" ... \";\n        return \"<Buffer \" + e + \">\";\n      };\n\n      if (i) {\n        Buffer.prototype[i] = Buffer.prototype.inspect;\n      }\n\n      Buffer.prototype.compare = function compare(e, r, t, f, n) {\n        if (isInstance(e, Uint8Array)) {\n          e = Buffer.from(e, e.offset, e.byteLength);\n        }\n\n        if (!Buffer.isBuffer(e)) {\n          throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. ' + \"Received type \" + typeof e);\n        }\n\n        if (r === undefined) {\n          r = 0;\n        }\n\n        if (t === undefined) {\n          t = e ? e.length : 0;\n        }\n\n        if (f === undefined) {\n          f = 0;\n        }\n\n        if (n === undefined) {\n          n = this.length;\n        }\n\n        if (r < 0 || t > e.length || f < 0 || n > this.length) {\n          throw new RangeError(\"out of range index\");\n        }\n\n        if (f >= n && r >= t) {\n          return 0;\n        }\n\n        if (f >= n) {\n          return -1;\n        }\n\n        if (r >= t) {\n          return 1;\n        }\n\n        r >>>= 0;\n        t >>>= 0;\n        f >>>= 0;\n        n >>>= 0;\n        if (this === e) return 0;\n        var i = n - f;\n        var o = t - r;\n        var u = Math.min(i, o);\n        var a = this.slice(f, n);\n        var s = e.slice(r, t);\n\n        for (var h = 0; h < u; ++h) {\n          if (a[h] !== s[h]) {\n            i = a[h];\n            o = s[h];\n            break;\n          }\n        }\n\n        if (i < o) return -1;\n        if (o < i) return 1;\n        return 0;\n      };\n\n      function bidirectionalIndexOf(e, r, t, f, n) {\n        if (e.length === 0) return -1;\n\n        if (typeof t === \"string\") {\n          f = t;\n          t = 0;\n        } else if (t > 2147483647) {\n          t = 2147483647;\n        } else if (t < -2147483648) {\n          t = -2147483648;\n        }\n\n        t = +t;\n\n        if (numberIsNaN(t)) {\n          t = n ? 0 : e.length - 1;\n        }\n\n        if (t < 0) t = e.length + t;\n\n        if (t >= e.length) {\n          if (n) return -1;else t = e.length - 1;\n        } else if (t < 0) {\n          if (n) t = 0;else return -1;\n        }\n\n        if (typeof r === \"string\") {\n          r = Buffer.from(r, f);\n        }\n\n        if (Buffer.isBuffer(r)) {\n          if (r.length === 0) {\n            return -1;\n          }\n\n          return arrayIndexOf(e, r, t, f, n);\n        } else if (typeof r === \"number\") {\n          r = r & 255;\n\n          if (typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (n) {\n              return Uint8Array.prototype.indexOf.call(e, r, t);\n            } else {\n              return Uint8Array.prototype.lastIndexOf.call(e, r, t);\n            }\n          }\n\n          return arrayIndexOf(e, [r], t, f, n);\n        }\n\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n\n      function arrayIndexOf(e, r, t, f, n) {\n        var i = 1;\n        var o = e.length;\n        var u = r.length;\n\n        if (f !== undefined) {\n          f = String(f).toLowerCase();\n\n          if (f === \"ucs2\" || f === \"ucs-2\" || f === \"utf16le\" || f === \"utf-16le\") {\n            if (e.length < 2 || r.length < 2) {\n              return -1;\n            }\n\n            i = 2;\n            o /= 2;\n            u /= 2;\n            t /= 2;\n          }\n        }\n\n        function read(e, r) {\n          if (i === 1) {\n            return e[r];\n          } else {\n            return e.readUInt16BE(r * i);\n          }\n        }\n\n        var a;\n\n        if (n) {\n          var s = -1;\n\n          for (a = t; a < o; a++) {\n            if (read(e, a) === read(r, s === -1 ? 0 : a - s)) {\n              if (s === -1) s = a;\n              if (a - s + 1 === u) return s * i;\n            } else {\n              if (s !== -1) a -= a - s;\n              s = -1;\n            }\n          }\n        } else {\n          if (t + u > o) t = o - u;\n\n          for (a = t; a >= 0; a--) {\n            var h = true;\n\n            for (var c = 0; c < u; c++) {\n              if (read(e, a + c) !== read(r, c)) {\n                h = false;\n                break;\n              }\n            }\n\n            if (h) return a;\n          }\n        }\n\n        return -1;\n      }\n\n      Buffer.prototype.includes = function includes(e, r, t) {\n        return this.indexOf(e, r, t) !== -1;\n      };\n\n      Buffer.prototype.indexOf = function indexOf(e, r, t) {\n        return bidirectionalIndexOf(this, e, r, t, true);\n      };\n\n      Buffer.prototype.lastIndexOf = function lastIndexOf(e, r, t) {\n        return bidirectionalIndexOf(this, e, r, t, false);\n      };\n\n      function hexWrite(e, r, t, f) {\n        t = Number(t) || 0;\n        var n = e.length - t;\n\n        if (!f) {\n          f = n;\n        } else {\n          f = Number(f);\n\n          if (f > n) {\n            f = n;\n          }\n        }\n\n        var i = r.length;\n\n        if (f > i / 2) {\n          f = i / 2;\n        }\n\n        for (var o = 0; o < f; ++o) {\n          var u = parseInt(r.substr(o * 2, 2), 16);\n          if (numberIsNaN(u)) return o;\n          e[t + o] = u;\n        }\n\n        return o;\n      }\n\n      function utf8Write(e, r, t, f) {\n        return blitBuffer(utf8ToBytes(r, e.length - t), e, t, f);\n      }\n\n      function asciiWrite(e, r, t, f) {\n        return blitBuffer(asciiToBytes(r), e, t, f);\n      }\n\n      function latin1Write(e, r, t, f) {\n        return asciiWrite(e, r, t, f);\n      }\n\n      function base64Write(e, r, t, f) {\n        return blitBuffer(base64ToBytes(r), e, t, f);\n      }\n\n      function ucs2Write(e, r, t, f) {\n        return blitBuffer(utf16leToBytes(r, e.length - t), e, t, f);\n      }\n\n      Buffer.prototype.write = function write(e, r, t, f) {\n        if (r === undefined) {\n          f = \"utf8\";\n          t = this.length;\n          r = 0;\n        } else if (t === undefined && typeof r === \"string\") {\n          f = r;\n          t = this.length;\n          r = 0;\n        } else if (isFinite(r)) {\n          r = r >>> 0;\n\n          if (isFinite(t)) {\n            t = t >>> 0;\n            if (f === undefined) f = \"utf8\";\n          } else {\n            f = t;\n            t = undefined;\n          }\n        } else {\n          throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n        }\n\n        var n = this.length - r;\n        if (t === undefined || t > n) t = n;\n\n        if (e.length > 0 && (t < 0 || r < 0) || r > this.length) {\n          throw new RangeError(\"Attempt to write outside buffer bounds\");\n        }\n\n        if (!f) f = \"utf8\";\n        var i = false;\n\n        for (;;) {\n          switch (f) {\n            case \"hex\":\n              return hexWrite(this, e, r, t);\n\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Write(this, e, r, t);\n\n            case \"ascii\":\n              return asciiWrite(this, e, r, t);\n\n            case \"latin1\":\n            case \"binary\":\n              return latin1Write(this, e, r, t);\n\n            case \"base64\":\n              return base64Write(this, e, r, t);\n\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return ucs2Write(this, e, r, t);\n\n            default:\n              if (i) throw new TypeError(\"Unknown encoding: \" + f);\n              f = (\"\" + f).toLowerCase();\n              i = true;\n          }\n        }\n      };\n\n      Buffer.prototype.toJSON = function toJSON() {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n\n      function base64Slice(e, r, t) {\n        if (r === 0 && t === e.length) {\n          return f.fromByteArray(e);\n        } else {\n          return f.fromByteArray(e.slice(r, t));\n        }\n      }\n\n      function utf8Slice(e, r, t) {\n        t = Math.min(e.length, t);\n        var f = [];\n        var n = r;\n\n        while (n < t) {\n          var i = e[n];\n          var o = null;\n          var u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;\n\n          if (n + u <= t) {\n            var a, s, h, c;\n\n            switch (u) {\n              case 1:\n                if (i < 128) {\n                  o = i;\n                }\n\n                break;\n\n              case 2:\n                a = e[n + 1];\n\n                if ((a & 192) === 128) {\n                  c = (i & 31) << 6 | a & 63;\n\n                  if (c > 127) {\n                    o = c;\n                  }\n                }\n\n                break;\n\n              case 3:\n                a = e[n + 1];\n                s = e[n + 2];\n\n                if ((a & 192) === 128 && (s & 192) === 128) {\n                  c = (i & 15) << 12 | (a & 63) << 6 | s & 63;\n\n                  if (c > 2047 && (c < 55296 || c > 57343)) {\n                    o = c;\n                  }\n                }\n\n                break;\n\n              case 4:\n                a = e[n + 1];\n                s = e[n + 2];\n                h = e[n + 3];\n\n                if ((a & 192) === 128 && (s & 192) === 128 && (h & 192) === 128) {\n                  c = (i & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | h & 63;\n\n                  if (c > 65535 && c < 1114112) {\n                    o = c;\n                  }\n                }\n\n            }\n          }\n\n          if (o === null) {\n            o = 65533;\n            u = 1;\n          } else if (o > 65535) {\n            o -= 65536;\n            f.push(o >>> 10 & 1023 | 55296);\n            o = 56320 | o & 1023;\n          }\n\n          f.push(o);\n          n += u;\n        }\n\n        return decodeCodePointsArray(f);\n      }\n\n      var u = 4096;\n\n      function decodeCodePointsArray(e) {\n        var r = e.length;\n\n        if (r <= u) {\n          return String.fromCharCode.apply(String, e);\n        }\n\n        var t = \"\";\n        var f = 0;\n\n        while (f < r) {\n          t += String.fromCharCode.apply(String, e.slice(f, f += u));\n        }\n\n        return t;\n      }\n\n      function asciiSlice(e, r, t) {\n        var f = \"\";\n        t = Math.min(e.length, t);\n\n        for (var n = r; n < t; ++n) {\n          f += String.fromCharCode(e[n] & 127);\n        }\n\n        return f;\n      }\n\n      function latin1Slice(e, r, t) {\n        var f = \"\";\n        t = Math.min(e.length, t);\n\n        for (var n = r; n < t; ++n) {\n          f += String.fromCharCode(e[n]);\n        }\n\n        return f;\n      }\n\n      function hexSlice(e, r, t) {\n        var f = e.length;\n        if (!r || r < 0) r = 0;\n        if (!t || t < 0 || t > f) t = f;\n        var n = \"\";\n\n        for (var i = r; i < t; ++i) {\n          n += s[e[i]];\n        }\n\n        return n;\n      }\n\n      function utf16leSlice(e, r, t) {\n        var f = e.slice(r, t);\n        var n = \"\";\n\n        for (var i = 0; i < f.length; i += 2) {\n          n += String.fromCharCode(f[i] + f[i + 1] * 256);\n        }\n\n        return n;\n      }\n\n      Buffer.prototype.slice = function slice(e, r) {\n        var t = this.length;\n        e = ~~e;\n        r = r === undefined ? t : ~~r;\n\n        if (e < 0) {\n          e += t;\n          if (e < 0) e = 0;\n        } else if (e > t) {\n          e = t;\n        }\n\n        if (r < 0) {\n          r += t;\n          if (r < 0) r = 0;\n        } else if (r > t) {\n          r = t;\n        }\n\n        if (r < e) r = e;\n        var f = this.subarray(e, r);\n        Object.setPrototypeOf(f, Buffer.prototype);\n        return f;\n      };\n\n      function checkOffset(e, r, t) {\n        if (e % 1 !== 0 || e < 0) throw new RangeError(\"offset is not uint\");\n        if (e + r > t) throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n\n      Buffer.prototype.readUIntLE = function readUIntLE(e, r, t) {\n        e = e >>> 0;\n        r = r >>> 0;\n        if (!t) checkOffset(e, r, this.length);\n        var f = this[e];\n        var n = 1;\n        var i = 0;\n\n        while (++i < r && (n *= 256)) {\n          f += this[e + i] * n;\n        }\n\n        return f;\n      };\n\n      Buffer.prototype.readUIntBE = function readUIntBE(e, r, t) {\n        e = e >>> 0;\n        r = r >>> 0;\n\n        if (!t) {\n          checkOffset(e, r, this.length);\n        }\n\n        var f = this[e + --r];\n        var n = 1;\n\n        while (r > 0 && (n *= 256)) {\n          f += this[e + --r] * n;\n        }\n\n        return f;\n      };\n\n      Buffer.prototype.readUInt8 = function readUInt8(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 1, this.length);\n        return this[e];\n      };\n\n      Buffer.prototype.readUInt16LE = function readUInt16LE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 2, this.length);\n        return this[e] | this[e + 1] << 8;\n      };\n\n      Buffer.prototype.readUInt16BE = function readUInt16BE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 2, this.length);\n        return this[e] << 8 | this[e + 1];\n      };\n\n      Buffer.prototype.readUInt32LE = function readUInt32LE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 4, this.length);\n        return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;\n      };\n\n      Buffer.prototype.readUInt32BE = function readUInt32BE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 4, this.length);\n        return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);\n      };\n\n      Buffer.prototype.readIntLE = function readIntLE(e, r, t) {\n        e = e >>> 0;\n        r = r >>> 0;\n        if (!t) checkOffset(e, r, this.length);\n        var f = this[e];\n        var n = 1;\n        var i = 0;\n\n        while (++i < r && (n *= 256)) {\n          f += this[e + i] * n;\n        }\n\n        n *= 128;\n        if (f >= n) f -= Math.pow(2, 8 * r);\n        return f;\n      };\n\n      Buffer.prototype.readIntBE = function readIntBE(e, r, t) {\n        e = e >>> 0;\n        r = r >>> 0;\n        if (!t) checkOffset(e, r, this.length);\n        var f = r;\n        var n = 1;\n        var i = this[e + --f];\n\n        while (f > 0 && (n *= 256)) {\n          i += this[e + --f] * n;\n        }\n\n        n *= 128;\n        if (i >= n) i -= Math.pow(2, 8 * r);\n        return i;\n      };\n\n      Buffer.prototype.readInt8 = function readInt8(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 1, this.length);\n        if (!(this[e] & 128)) return this[e];\n        return (255 - this[e] + 1) * -1;\n      };\n\n      Buffer.prototype.readInt16LE = function readInt16LE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 2, this.length);\n        var t = this[e] | this[e + 1] << 8;\n        return t & 32768 ? t | 4294901760 : t;\n      };\n\n      Buffer.prototype.readInt16BE = function readInt16BE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 2, this.length);\n        var t = this[e + 1] | this[e] << 8;\n        return t & 32768 ? t | 4294901760 : t;\n      };\n\n      Buffer.prototype.readInt32LE = function readInt32LE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 4, this.length);\n        return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;\n      };\n\n      Buffer.prototype.readInt32BE = function readInt32BE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 4, this.length);\n        return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];\n      };\n\n      Buffer.prototype.readFloatLE = function readFloatLE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 4, this.length);\n        return n.read(this, e, true, 23, 4);\n      };\n\n      Buffer.prototype.readFloatBE = function readFloatBE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 4, this.length);\n        return n.read(this, e, false, 23, 4);\n      };\n\n      Buffer.prototype.readDoubleLE = function readDoubleLE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 8, this.length);\n        return n.read(this, e, true, 52, 8);\n      };\n\n      Buffer.prototype.readDoubleBE = function readDoubleBE(e, r) {\n        e = e >>> 0;\n        if (!r) checkOffset(e, 8, this.length);\n        return n.read(this, e, false, 52, 8);\n      };\n\n      function checkInt(e, r, t, f, n, i) {\n        if (!Buffer.isBuffer(e)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (r > n || r < i) throw new RangeError('\"value\" argument is out of bounds');\n        if (t + f > e.length) throw new RangeError(\"Index out of range\");\n      }\n\n      Buffer.prototype.writeUIntLE = function writeUIntLE(e, r, t, f) {\n        e = +e;\n        r = r >>> 0;\n        t = t >>> 0;\n\n        if (!f) {\n          var n = Math.pow(2, 8 * t) - 1;\n          checkInt(this, e, r, t, n, 0);\n        }\n\n        var i = 1;\n        var o = 0;\n        this[r] = e & 255;\n\n        while (++o < t && (i *= 256)) {\n          this[r + o] = e / i & 255;\n        }\n\n        return r + t;\n      };\n\n      Buffer.prototype.writeUIntBE = function writeUIntBE(e, r, t, f) {\n        e = +e;\n        r = r >>> 0;\n        t = t >>> 0;\n\n        if (!f) {\n          var n = Math.pow(2, 8 * t) - 1;\n          checkInt(this, e, r, t, n, 0);\n        }\n\n        var i = t - 1;\n        var o = 1;\n        this[r + i] = e & 255;\n\n        while (--i >= 0 && (o *= 256)) {\n          this[r + i] = e / o & 255;\n        }\n\n        return r + t;\n      };\n\n      Buffer.prototype.writeUInt8 = function writeUInt8(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 1, 255, 0);\n        this[r] = e & 255;\n        return r + 1;\n      };\n\n      Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 2, 65535, 0);\n        this[r] = e & 255;\n        this[r + 1] = e >>> 8;\n        return r + 2;\n      };\n\n      Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 2, 65535, 0);\n        this[r] = e >>> 8;\n        this[r + 1] = e & 255;\n        return r + 2;\n      };\n\n      Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 4, 4294967295, 0);\n        this[r + 3] = e >>> 24;\n        this[r + 2] = e >>> 16;\n        this[r + 1] = e >>> 8;\n        this[r] = e & 255;\n        return r + 4;\n      };\n\n      Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 4, 4294967295, 0);\n        this[r] = e >>> 24;\n        this[r + 1] = e >>> 16;\n        this[r + 2] = e >>> 8;\n        this[r + 3] = e & 255;\n        return r + 4;\n      };\n\n      Buffer.prototype.writeIntLE = function writeIntLE(e, r, t, f) {\n        e = +e;\n        r = r >>> 0;\n\n        if (!f) {\n          var n = Math.pow(2, 8 * t - 1);\n          checkInt(this, e, r, t, n - 1, -n);\n        }\n\n        var i = 0;\n        var o = 1;\n        var u = 0;\n        this[r] = e & 255;\n\n        while (++i < t && (o *= 256)) {\n          if (e < 0 && u === 0 && this[r + i - 1] !== 0) {\n            u = 1;\n          }\n\n          this[r + i] = (e / o >> 0) - u & 255;\n        }\n\n        return r + t;\n      };\n\n      Buffer.prototype.writeIntBE = function writeIntBE(e, r, t, f) {\n        e = +e;\n        r = r >>> 0;\n\n        if (!f) {\n          var n = Math.pow(2, 8 * t - 1);\n          checkInt(this, e, r, t, n - 1, -n);\n        }\n\n        var i = t - 1;\n        var o = 1;\n        var u = 0;\n        this[r + i] = e & 255;\n\n        while (--i >= 0 && (o *= 256)) {\n          if (e < 0 && u === 0 && this[r + i + 1] !== 0) {\n            u = 1;\n          }\n\n          this[r + i] = (e / o >> 0) - u & 255;\n        }\n\n        return r + t;\n      };\n\n      Buffer.prototype.writeInt8 = function writeInt8(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 1, 127, -128);\n        if (e < 0) e = 255 + e + 1;\n        this[r] = e & 255;\n        return r + 1;\n      };\n\n      Buffer.prototype.writeInt16LE = function writeInt16LE(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 2, 32767, -32768);\n        this[r] = e & 255;\n        this[r + 1] = e >>> 8;\n        return r + 2;\n      };\n\n      Buffer.prototype.writeInt16BE = function writeInt16BE(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 2, 32767, -32768);\n        this[r] = e >>> 8;\n        this[r + 1] = e & 255;\n        return r + 2;\n      };\n\n      Buffer.prototype.writeInt32LE = function writeInt32LE(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);\n        this[r] = e & 255;\n        this[r + 1] = e >>> 8;\n        this[r + 2] = e >>> 16;\n        this[r + 3] = e >>> 24;\n        return r + 4;\n      };\n\n      Buffer.prototype.writeInt32BE = function writeInt32BE(e, r, t) {\n        e = +e;\n        r = r >>> 0;\n        if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);\n        if (e < 0) e = 4294967295 + e + 1;\n        this[r] = e >>> 24;\n        this[r + 1] = e >>> 16;\n        this[r + 2] = e >>> 8;\n        this[r + 3] = e & 255;\n        return r + 4;\n      };\n\n      function checkIEEE754(e, r, t, f, n, i) {\n        if (t + f > e.length) throw new RangeError(\"Index out of range\");\n        if (t < 0) throw new RangeError(\"Index out of range\");\n      }\n\n      function writeFloat(e, r, t, f, i) {\n        r = +r;\n        t = t >>> 0;\n\n        if (!i) {\n          checkIEEE754(e, r, t, 4, 34028234663852886e22, -34028234663852886e22);\n        }\n\n        n.write(e, r, t, f, 23, 4);\n        return t + 4;\n      }\n\n      Buffer.prototype.writeFloatLE = function writeFloatLE(e, r, t) {\n        return writeFloat(this, e, r, true, t);\n      };\n\n      Buffer.prototype.writeFloatBE = function writeFloatBE(e, r, t) {\n        return writeFloat(this, e, r, false, t);\n      };\n\n      function writeDouble(e, r, t, f, i) {\n        r = +r;\n        t = t >>> 0;\n\n        if (!i) {\n          checkIEEE754(e, r, t, 8, 17976931348623157e292, -17976931348623157e292);\n        }\n\n        n.write(e, r, t, f, 52, 8);\n        return t + 8;\n      }\n\n      Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, r, t) {\n        return writeDouble(this, e, r, true, t);\n      };\n\n      Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, r, t) {\n        return writeDouble(this, e, r, false, t);\n      };\n\n      Buffer.prototype.copy = function copy(e, r, t, f) {\n        if (!Buffer.isBuffer(e)) throw new TypeError(\"argument should be a Buffer\");\n        if (!t) t = 0;\n        if (!f && f !== 0) f = this.length;\n        if (r >= e.length) r = e.length;\n        if (!r) r = 0;\n        if (f > 0 && f < t) f = t;\n        if (f === t) return 0;\n        if (e.length === 0 || this.length === 0) return 0;\n\n        if (r < 0) {\n          throw new RangeError(\"targetStart out of bounds\");\n        }\n\n        if (t < 0 || t >= this.length) throw new RangeError(\"Index out of range\");\n        if (f < 0) throw new RangeError(\"sourceEnd out of bounds\");\n        if (f > this.length) f = this.length;\n\n        if (e.length - r < f - t) {\n          f = e.length - r + t;\n        }\n\n        var n = f - t;\n\n        if (this === e && typeof Uint8Array.prototype.copyWithin === \"function\") {\n          this.copyWithin(r, t, f);\n        } else if (this === e && t < r && r < f) {\n          for (var i = n - 1; i >= 0; --i) {\n            e[i + r] = this[i + t];\n          }\n        } else {\n          Uint8Array.prototype.set.call(e, this.subarray(t, f), r);\n        }\n\n        return n;\n      };\n\n      Buffer.prototype.fill = function fill(e, r, t, f) {\n        if (typeof e === \"string\") {\n          if (typeof r === \"string\") {\n            f = r;\n            r = 0;\n            t = this.length;\n          } else if (typeof t === \"string\") {\n            f = t;\n            t = this.length;\n          }\n\n          if (f !== undefined && typeof f !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n          }\n\n          if (typeof f === \"string\" && !Buffer.isEncoding(f)) {\n            throw new TypeError(\"Unknown encoding: \" + f);\n          }\n\n          if (e.length === 1) {\n            var n = e.charCodeAt(0);\n\n            if (f === \"utf8\" && n < 128 || f === \"latin1\") {\n              e = n;\n            }\n          }\n        } else if (typeof e === \"number\") {\n          e = e & 255;\n        } else if (typeof e === \"boolean\") {\n          e = Number(e);\n        }\n\n        if (r < 0 || this.length < r || this.length < t) {\n          throw new RangeError(\"Out of range index\");\n        }\n\n        if (t <= r) {\n          return this;\n        }\n\n        r = r >>> 0;\n        t = t === undefined ? this.length : t >>> 0;\n        if (!e) e = 0;\n        var i;\n\n        if (typeof e === \"number\") {\n          for (i = r; i < t; ++i) {\n            this[i] = e;\n          }\n        } else {\n          var o = Buffer.isBuffer(e) ? e : Buffer.from(e, f);\n          var u = o.length;\n\n          if (u === 0) {\n            throw new TypeError('The value \"' + e + '\" is invalid for argument \"value\"');\n          }\n\n          for (i = 0; i < t - r; ++i) {\n            this[i + r] = o[i % u];\n          }\n        }\n\n        return this;\n      };\n\n      var a = /[^+/0-9A-Za-z-_]/g;\n\n      function base64clean(e) {\n        e = e.split(\"=\")[0];\n        e = e.trim().replace(a, \"\");\n        if (e.length < 2) return \"\";\n\n        while (e.length % 4 !== 0) {\n          e = e + \"=\";\n        }\n\n        return e;\n      }\n\n      function utf8ToBytes(e, r) {\n        r = r || Infinity;\n        var t;\n        var f = e.length;\n        var n = null;\n        var i = [];\n\n        for (var o = 0; o < f; ++o) {\n          t = e.charCodeAt(o);\n\n          if (t > 55295 && t < 57344) {\n            if (!n) {\n              if (t > 56319) {\n                if ((r -= 3) > -1) i.push(239, 191, 189);\n                continue;\n              } else if (o + 1 === f) {\n                if ((r -= 3) > -1) i.push(239, 191, 189);\n                continue;\n              }\n\n              n = t;\n              continue;\n            }\n\n            if (t < 56320) {\n              if ((r -= 3) > -1) i.push(239, 191, 189);\n              n = t;\n              continue;\n            }\n\n            t = (n - 55296 << 10 | t - 56320) + 65536;\n          } else if (n) {\n            if ((r -= 3) > -1) i.push(239, 191, 189);\n          }\n\n          n = null;\n\n          if (t < 128) {\n            if ((r -= 1) < 0) break;\n            i.push(t);\n          } else if (t < 2048) {\n            if ((r -= 2) < 0) break;\n            i.push(t >> 6 | 192, t & 63 | 128);\n          } else if (t < 65536) {\n            if ((r -= 3) < 0) break;\n            i.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);\n          } else if (t < 1114112) {\n            if ((r -= 4) < 0) break;\n            i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);\n          } else {\n            throw new Error(\"Invalid code point\");\n          }\n        }\n\n        return i;\n      }\n\n      function asciiToBytes(e) {\n        var r = [];\n\n        for (var t = 0; t < e.length; ++t) {\n          r.push(e.charCodeAt(t) & 255);\n        }\n\n        return r;\n      }\n\n      function utf16leToBytes(e, r) {\n        var t, f, n;\n        var i = [];\n\n        for (var o = 0; o < e.length; ++o) {\n          if ((r -= 2) < 0) break;\n          t = e.charCodeAt(o);\n          f = t >> 8;\n          n = t % 256;\n          i.push(n);\n          i.push(f);\n        }\n\n        return i;\n      }\n\n      function base64ToBytes(e) {\n        return f.toByteArray(base64clean(e));\n      }\n\n      function blitBuffer(e, r, t, f) {\n        for (var n = 0; n < f; ++n) {\n          if (n + t >= r.length || n >= e.length) break;\n          r[n + t] = e[n];\n        }\n\n        return n;\n      }\n\n      function isInstance(e, r) {\n        return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;\n      }\n\n      function numberIsNaN(e) {\n        return e !== e;\n      }\n\n      var s = function () {\n        var e = \"0123456789abcdef\";\n        var r = new Array(256);\n\n        for (var t = 0; t < 16; ++t) {\n          var f = t * 16;\n\n          for (var n = 0; n < 16; ++n) {\n            r[f + n] = e[t] + e[n];\n          }\n        }\n\n        return r;\n      }();\n    },\n    543: function (e, r) {\n      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n      r.read = function (e, r, t, f, n) {\n        var i, o;\n        var u = n * 8 - f - 1;\n        var a = (1 << u) - 1;\n        var s = a >> 1;\n        var h = -7;\n        var c = t ? n - 1 : 0;\n        var l = t ? -1 : 1;\n        var p = e[r + c];\n        c += l;\n        i = p & (1 << -h) - 1;\n        p >>= -h;\n        h += u;\n\n        for (; h > 0; i = i * 256 + e[r + c], c += l, h -= 8) {}\n\n        o = i & (1 << -h) - 1;\n        i >>= -h;\n        h += f;\n\n        for (; h > 0; o = o * 256 + e[r + c], c += l, h -= 8) {}\n\n        if (i === 0) {\n          i = 1 - s;\n        } else if (i === a) {\n          return o ? NaN : (p ? -1 : 1) * Infinity;\n        } else {\n          o = o + Math.pow(2, f);\n          i = i - s;\n        }\n\n        return (p ? -1 : 1) * o * Math.pow(2, i - f);\n      };\n\n      r.write = function (e, r, t, f, n, i) {\n        var o, u, a;\n        var s = i * 8 - n - 1;\n        var h = (1 << s) - 1;\n        var c = h >> 1;\n        var l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var p = f ? 0 : i - 1;\n        var y = f ? 1 : -1;\n        var g = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;\n        r = Math.abs(r);\n\n        if (isNaN(r) || r === Infinity) {\n          u = isNaN(r) ? 1 : 0;\n          o = h;\n        } else {\n          o = Math.floor(Math.log(r) / Math.LN2);\n\n          if (r * (a = Math.pow(2, -o)) < 1) {\n            o--;\n            a *= 2;\n          }\n\n          if (o + c >= 1) {\n            r += l / a;\n          } else {\n            r += l * Math.pow(2, 1 - c);\n          }\n\n          if (r * a >= 2) {\n            o++;\n            a /= 2;\n          }\n\n          if (o + c >= h) {\n            u = 0;\n            o = h;\n          } else if (o + c >= 1) {\n            u = (r * a - 1) * Math.pow(2, n);\n            o = o + c;\n          } else {\n            u = r * Math.pow(2, c - 1) * Math.pow(2, n);\n            o = 0;\n          }\n        }\n\n        for (; n >= 8; e[t + p] = u & 255, p += y, u /= 256, n -= 8) {}\n\n        o = o << n | u;\n        s += n;\n\n        for (; s > 0; e[t + p] = o & 255, p += y, o /= 256, s -= 8) {}\n\n        e[t + p - y] |= g * 128;\n      };\n    }\n  };\n  var r = {};\n\n  function __nccwpck_require__(t) {\n    var f = r[t];\n\n    if (f !== undefined) {\n      return f.exports;\n    }\n\n    var n = r[t] = {\n      exports: {}\n    };\n    var i = true;\n\n    try {\n      e[t](n, n.exports, __nccwpck_require__);\n      i = false;\n    } finally {\n      if (i) delete r[t];\n    }\n\n    return n.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var t = __nccwpck_require__(877);\n\n  module.exports = t;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2J1ZmZlci9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsQ0FBQyxZQUFVO0VBQUMsSUFBSUEsQ0FBQyxHQUFDO0lBQUMsS0FBSSxVQUFTQSxDQUFULEVBQVdDLENBQVgsRUFBYTtNQUFDOztNQUFhQSxDQUFDLENBQUNDLFVBQUYsR0FBYUEsVUFBYjtNQUF3QkQsQ0FBQyxDQUFDRSxXQUFGLEdBQWNBLFdBQWQ7TUFBMEJGLENBQUMsQ0FBQ0csYUFBRixHQUFnQkEsYUFBaEI7TUFBOEIsSUFBSUMsQ0FBQyxHQUFDLEVBQU47TUFBUyxJQUFJQyxDQUFDLEdBQUMsRUFBTjtNQUFTLElBQUlDLENBQUMsR0FBQyxPQUFPQyxVQUFQLEtBQW9CLFdBQXBCLEdBQWdDQSxVQUFoQyxHQUEyQ0MsS0FBakQ7TUFBdUQsSUFBSUMsQ0FBQyxHQUFDLGtFQUFOOztNQUF5RSxLQUFJLElBQUlDLENBQUMsR0FBQyxDQUFOLEVBQVFDLENBQUMsR0FBQ0YsQ0FBQyxDQUFDRyxNQUFoQixFQUF1QkYsQ0FBQyxHQUFDQyxDQUF6QixFQUEyQixFQUFFRCxDQUE3QixFQUErQjtRQUFDTixDQUFDLENBQUNNLENBQUQsQ0FBRCxHQUFLRCxDQUFDLENBQUNDLENBQUQsQ0FBTjtRQUFVTCxDQUFDLENBQUNJLENBQUMsQ0FBQ0ksVUFBRixDQUFhSCxDQUFiLENBQUQsQ0FBRCxHQUFtQkEsQ0FBbkI7TUFBcUI7O01BQUFMLENBQUMsQ0FBQyxJQUFJUSxVQUFKLENBQWUsQ0FBZixDQUFELENBQUQsR0FBcUIsRUFBckI7TUFBd0JSLENBQUMsQ0FBQyxJQUFJUSxVQUFKLENBQWUsQ0FBZixDQUFELENBQUQsR0FBcUIsRUFBckI7O01BQXdCLFNBQVNDLE9BQVQsQ0FBaUJmLENBQWpCLEVBQW1CO1FBQUMsSUFBSUMsQ0FBQyxHQUFDRCxDQUFDLENBQUNhLE1BQVI7O1FBQWUsSUFBR1osQ0FBQyxHQUFDLENBQUYsR0FBSSxDQUFQLEVBQVM7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ZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2J1ZmZlci9pbmRleC5qcz8zNzc2Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXs0NDk6ZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtyLnRvQnl0ZUFycmF5PXRvQnl0ZUFycmF5O3IuZnJvbUJ5dGVBcnJheT1mcm9tQnl0ZUFycmF5O3ZhciB0PVtdO3ZhciBmPVtdO3ZhciBuPXR5cGVvZiBVaW50OEFycmF5IT09XCJ1bmRlZmluZWRcIj9VaW50OEFycmF5OkFycmF5O3ZhciBpPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO2Zvcih2YXIgbz0wLHU9aS5sZW5ndGg7bzx1Oysrbyl7dFtvXT1pW29dO2ZbaS5jaGFyQ29kZUF0KG8pXT1vfWZbXCItXCIuY2hhckNvZGVBdCgwKV09NjI7ZltcIl9cIi5jaGFyQ29kZUF0KDApXT02MztmdW5jdGlvbiBnZXRMZW5zKGUpe3ZhciByPWUubGVuZ3RoO2lmKHIlND4wKXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpfXZhciB0PWUuaW5kZXhPZihcIj1cIik7aWYodD09PS0xKXQ9cjt2YXIgZj10PT09cj8wOjQtdCU0O3JldHVyblt0LGZdfWZ1bmN0aW9uIGJ5dGVMZW5ndGgoZSl7dmFyIHI9Z2V0TGVucyhlKTt2YXIgdD1yWzBdO3ZhciBmPXJbMV07cmV0dXJuKHQrZikqMy80LWZ9ZnVuY3Rpb24gX2J5dGVMZW5ndGgoZSxyLHQpe3JldHVybihyK3QpKjMvNC10fWZ1bmN0aW9uIHRvQnl0ZUFycmF5KGUpe3ZhciByO3ZhciB0PWdldExlbnMoZSk7dmFyIGk9dFswXTt2YXIgbz10WzFdO3ZhciB1PW5ldyBuKF9ieXRlTGVuZ3RoKGUsaSxvKSk7dmFyIGE9MDt2YXIgcz1vPjA/aS00Omk7dmFyIGg7Zm9yKGg9MDtoPHM7aCs9NCl7cj1mW2UuY2hhckNvZGVBdChoKV08PDE4fGZbZS5jaGFyQ29kZUF0KGgrMSldPDwxMnxmW2UuY2hhckNvZGVBdChoKzIpXTw8NnxmW2UuY2hhckNvZGVBdChoKzMpXTt1W2ErK109cj4+MTYmMjU1O3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9aWYobz09PTIpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwyfGZbZS5jaGFyQ29kZUF0KGgrMSldPj40O3VbYSsrXT1yJjI1NX1pZihvPT09MSl7cj1mW2UuY2hhckNvZGVBdChoKV08PDEwfGZbZS5jaGFyQ29kZUF0KGgrMSldPDw0fGZbZS5jaGFyQ29kZUF0KGgrMildPj4yO3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9cmV0dXJuIHV9ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KGUpe3JldHVybiB0W2U+PjE4JjYzXSt0W2U+PjEyJjYzXSt0W2U+PjYmNjNdK3RbZSY2M119ZnVuY3Rpb24gZW5jb2RlQ2h1bmsoZSxyLHQpe3ZhciBmO3ZhciBuPVtdO2Zvcih2YXIgaT1yO2k8dDtpKz0zKXtmPShlW2ldPDwxNiYxNjcxMTY4MCkrKGVbaSsxXTw8OCY2NTI4MCkrKGVbaSsyXSYyNTUpO24ucHVzaCh0cmlwbGV0VG9CYXNlNjQoZikpfXJldHVybiBuLmpvaW4oXCJcIil9ZnVuY3Rpb24gZnJvbUJ5dGVBcnJheShlKXt2YXIgcjt2YXIgZj1lLmxlbmd0aDt2YXIgbj1mJTM7dmFyIGk9W107dmFyIG89MTYzODM7Zm9yKHZhciB1PTAsYT1mLW47dTxhO3UrPW8pe2kucHVzaChlbmNvZGVDaHVuayhlLHUsdStvPmE/YTp1K28pKX1pZihuPT09MSl7cj1lW2YtMV07aS5wdXNoKHRbcj4+Ml0rdFtyPDw0JjYzXStcIj09XCIpfWVsc2UgaWYobj09PTIpe3I9KGVbZi0yXTw8OCkrZVtmLTFdO2kucHVzaCh0W3I+PjEwXSt0W3I+PjQmNjNdK3Rbcjw8MiY2M10rXCI9XCIpfXJldHVybiBpLmpvaW4oXCJcIil9fSw4Nzc6ZnVuY3Rpb24oZSxyLHQpe1widXNlIHN0cmljdFwiO1xuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovdmFyIGY9dCg0NDkpO3ZhciBuPXQoNTQzKTt2YXIgaT10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLmZvcj09PVwiZnVuY3Rpb25cIj9TeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIik6bnVsbDtyLkJ1ZmZlcj1CdWZmZXI7ci5TbG93QnVmZmVyPVNsb3dCdWZmZXI7ci5JTlNQRUNUX01BWF9CWVRFUz01MDt2YXIgbz0yMTQ3NDgzNjQ3O3Iua01heExlbmd0aD1vO0J1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUPXR5cGVkQXJyYXlTdXBwb3J0KCk7aWYoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUJiZ0eXBlb2YgY29uc29sZSE9PVwidW5kZWZpbmVkXCImJnR5cGVvZiBjb25zb2xlLmVycm9yPT09XCJmdW5jdGlvblwiKXtjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5IFwiK1wiYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC5cIil9ZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQoKXt0cnl7dmFyIGU9bmV3IFVpbnQ4QXJyYXkoMSk7dmFyIHI9e2ZvbzpmdW5jdGlvbigpe3JldHVybiA0Mn19O09iamVjdC5zZXRQcm90b3R5cGVPZihyLFVpbnQ4QXJyYXkucHJvdG90eXBlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoZSxyKTtyZXR1cm4gZS5mb28oKT09PTQyfWNhdGNoKGUpe3JldHVybiBmYWxzZX19T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsXCJwYXJlbnRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe2lmKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpcmV0dXJuIHVuZGVmaW5lZDtyZXR1cm4gdGhpcy5idWZmZXJ9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsXCJvZmZzZXRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe2lmKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpcmV0dXJuIHVuZGVmaW5lZDtyZXR1cm4gdGhpcy5ieXRlT2Zmc2V0fX0pO2Z1bmN0aW9uIGNyZWF0ZUJ1ZmZlcihlKXtpZihlPm8pe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpfXZhciByPW5ldyBVaW50OEFycmF5KGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihyLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiByfWZ1bmN0aW9uIEJ1ZmZlcihlLHIsdCl7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtpZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyl9cmV0dXJuIGFsbG9jVW5zYWZlKGUpfXJldHVybiBmcm9tKGUscix0KX1CdWZmZXIucG9vbFNpemU9ODE5MjtmdW5jdGlvbiBmcm9tKGUscix0KXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBmcm9tU3RyaW5nKGUscil9aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpKXtyZXR1cm4gZnJvbUFycmF5TGlrZShlKX1pZihlPT1udWxsKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgXCIrXCJvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9aWYoaXNJbnN0YW5jZShlLEFycmF5QnVmZmVyKXx8ZSYmaXNJbnN0YW5jZShlLmJ1ZmZlcixBcnJheUJ1ZmZlcikpe3JldHVybiBmcm9tQXJyYXlCdWZmZXIoZSxyLHQpfWlmKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCImJihpc0luc3RhbmNlKGUsU2hhcmVkQXJyYXlCdWZmZXIpfHxlJiZpc0luc3RhbmNlKGUuYnVmZmVyLFNoYXJlZEFycmF5QnVmZmVyKSkpe3JldHVybiBmcm9tQXJyYXlCdWZmZXIoZSxyLHQpfWlmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKX12YXIgZj1lLnZhbHVlT2YmJmUudmFsdWVPZigpO2lmKGYhPW51bGwmJmYhPT1lKXtyZXR1cm4gQnVmZmVyLmZyb20oZixyLHQpfXZhciBuPWZyb21PYmplY3QoZSk7aWYobilyZXR1cm4gbjtpZih0eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIiYmU3ltYm9sLnRvUHJpbWl0aXZlIT1udWxsJiZ0eXBlb2YgZVtTeW1ib2wudG9QcmltaXRpdmVdPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gQnVmZmVyLmZyb20oZVtTeW1ib2wudG9QcmltaXRpdmVdKFwic3RyaW5nXCIpLHIsdCl9dGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIFwiK1wib3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfUJ1ZmZlci5mcm9tPWZ1bmN0aW9uKGUscix0KXtyZXR1cm4gZnJvbShlLHIsdCl9O09iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLFVpbnQ4QXJyYXkucHJvdG90eXBlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLFVpbnQ4QXJyYXkpO2Z1bmN0aW9uIGFzc2VydFNpemUoZSl7aWYodHlwZW9mIGUhPT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJyl9ZWxzZSBpZihlPDApe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpfX1mdW5jdGlvbiBhbGxvYyhlLHIsdCl7YXNzZXJ0U2l6ZShlKTtpZihlPD0wKXtyZXR1cm4gY3JlYXRlQnVmZmVyKGUpfWlmKHIhPT11bmRlZmluZWQpe3JldHVybiB0eXBlb2YgdD09PVwic3RyaW5nXCI/Y3JlYXRlQnVmZmVyKGUpLmZpbGwocix0KTpjcmVhdGVCdWZmZXIoZSkuZmlsbChyKX1yZXR1cm4gY3JlYXRlQnVmZmVyKGUpfUJ1ZmZlci5hbGxvYz1mdW5jdGlvbihlLHIsdCl7cmV0dXJuIGFsbG9jKGUscix0KX07ZnVuY3Rpb24gYWxsb2NVbnNhZmUoZSl7YXNzZXJ0U2l6ZShlKTtyZXR1cm4gY3JlYXRlQnVmZmVyKGU8MD8wOmNoZWNrZWQoZSl8MCl9QnVmZmVyLmFsbG9jVW5zYWZlPWZ1bmN0aW9uKGUpe3JldHVybiBhbGxvY1Vuc2FmZShlKX07QnVmZmVyLmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbihlKXtyZXR1cm4gYWxsb2NVbnNhZmUoZSl9O2Z1bmN0aW9uIGZyb21TdHJpbmcoZSxyKXtpZih0eXBlb2YgciE9PVwic3RyaW5nXCJ8fHI9PT1cIlwiKXtyPVwidXRmOFwifWlmKCFCdWZmZXIuaXNFbmNvZGluZyhyKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3IpfXZhciB0PWJ5dGVMZW5ndGgoZSxyKXwwO3ZhciBmPWNyZWF0ZUJ1ZmZlcih0KTt2YXIgbj1mLndyaXRlKGUscik7aWYobiE9PXQpe2Y9Zi5zbGljZSgwLG4pfXJldHVybiBmfWZ1bmN0aW9uIGZyb21BcnJheUxpa2UoZSl7dmFyIHI9ZS5sZW5ndGg8MD8wOmNoZWNrZWQoZS5sZW5ndGgpfDA7dmFyIHQ9Y3JlYXRlQnVmZmVyKHIpO2Zvcih2YXIgZj0wO2Y8cjtmKz0xKXt0W2ZdPWVbZl0mMjU1fXJldHVybiB0fWZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl7aWYocjwwfHxlLmJ5dGVMZW5ndGg8cil7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyl9aWYoZS5ieXRlTGVuZ3RoPHIrKHR8fDApKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKX12YXIgZjtpZihyPT09dW5kZWZpbmVkJiZ0PT09dW5kZWZpbmVkKXtmPW5ldyBVaW50OEFycmF5KGUpfWVsc2UgaWYodD09PXVuZGVmaW5lZCl7Zj1uZXcgVWludDhBcnJheShlLHIpfWVsc2V7Zj1uZXcgVWludDhBcnJheShlLHIsdCl9T2JqZWN0LnNldFByb3RvdHlwZU9mKGYsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIGZ9ZnVuY3Rpb24gZnJvbU9iamVjdChlKXtpZihCdWZmZXIuaXNCdWZmZXIoZSkpe3ZhciByPWNoZWNrZWQoZS5sZW5ndGgpfDA7dmFyIHQ9Y3JlYXRlQnVmZmVyKHIpO2lmKHQubGVuZ3RoPT09MCl7cmV0dXJuIHR9ZS5jb3B5KHQsMCwwLHIpO3JldHVybiB0fWlmKGUubGVuZ3RoIT09dW5kZWZpbmVkKXtpZih0eXBlb2YgZS5sZW5ndGghPT1cIm51bWJlclwifHxudW1iZXJJc05hTihlLmxlbmd0aCkpe3JldHVybiBjcmVhdGVCdWZmZXIoMCl9cmV0dXJuIGZyb21BcnJheUxpa2UoZSl9aWYoZS50eXBlPT09XCJCdWZmZXJcIiYmQXJyYXkuaXNBcnJheShlLmRhdGEpKXtyZXR1cm4gZnJvbUFycmF5TGlrZShlLmRhdGEpfX1mdW5jdGlvbiBjaGVja2VkKGUpe2lmKGU+PW8pe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBcIitcInNpemU6IDB4XCIrby50b1N0cmluZygxNikrXCIgYnl0ZXNcIil9cmV0dXJuIGV8MH1mdW5jdGlvbiBTbG93QnVmZmVyKGUpe2lmKCtlIT1lKXtlPTB9cmV0dXJuIEJ1ZmZlci5hbGxvYygrZSl9QnVmZmVyLmlzQnVmZmVyPWZ1bmN0aW9uIGlzQnVmZmVyKGUpe3JldHVybiBlIT1udWxsJiZlLl9pc0J1ZmZlcj09PXRydWUmJmUhPT1CdWZmZXIucHJvdG90eXBlfTtCdWZmZXIuY29tcGFyZT1mdW5jdGlvbiBjb21wYXJlKGUscil7aWYoaXNJbnN0YW5jZShlLFVpbnQ4QXJyYXkpKWU9QnVmZmVyLmZyb20oZSxlLm9mZnNldCxlLmJ5dGVMZW5ndGgpO2lmKGlzSW5zdGFuY2UocixVaW50OEFycmF5KSlyPUJ1ZmZlci5mcm9tKHIsci5vZmZzZXQsci5ieXRlTGVuZ3RoKTtpZighQnVmZmVyLmlzQnVmZmVyKGUpfHwhQnVmZmVyLmlzQnVmZmVyKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5Jyl9aWYoZT09PXIpcmV0dXJuIDA7dmFyIHQ9ZS5sZW5ndGg7dmFyIGY9ci5sZW5ndGg7Zm9yKHZhciBuPTAsaT1NYXRoLm1pbih0LGYpO248aTsrK24pe2lmKGVbbl0hPT1yW25dKXt0PWVbbl07Zj1yW25dO2JyZWFrfX1pZih0PGYpcmV0dXJuLTE7aWYoZjx0KXJldHVybiAxO3JldHVybiAwfTtCdWZmZXIuaXNFbmNvZGluZz1mdW5jdGlvbiBpc0VuY29kaW5nKGUpe3N3aXRjaChTdHJpbmcoZSkudG9Mb3dlckNhc2UoKSl7Y2FzZVwiaGV4XCI6Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpjYXNlXCJiYXNlNjRcIjpjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdHJ1ZTtkZWZhdWx0OnJldHVybiBmYWxzZX19O0J1ZmZlci5jb25jYXQ9ZnVuY3Rpb24gY29uY2F0KGUscil7aWYoIUFycmF5LmlzQXJyYXkoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpfWlmKGUubGVuZ3RoPT09MCl7cmV0dXJuIEJ1ZmZlci5hbGxvYygwKX12YXIgdDtpZihyPT09dW5kZWZpbmVkKXtyPTA7Zm9yKHQ9MDt0PGUubGVuZ3RoOysrdCl7cis9ZVt0XS5sZW5ndGh9fXZhciBmPUJ1ZmZlci5hbGxvY1Vuc2FmZShyKTt2YXIgbj0wO2Zvcih0PTA7dDxlLmxlbmd0aDsrK3Qpe3ZhciBpPWVbdF07aWYoaXNJbnN0YW5jZShpLFVpbnQ4QXJyYXkpKXtpPUJ1ZmZlci5mcm9tKGkpfWlmKCFCdWZmZXIuaXNCdWZmZXIoaSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpfWkuY29weShmLG4pO24rPWkubGVuZ3RofXJldHVybiBmfTtmdW5jdGlvbiBieXRlTGVuZ3RoKGUscil7aWYoQnVmZmVyLmlzQnVmZmVyKGUpKXtyZXR1cm4gZS5sZW5ndGh9aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpfHxpc0luc3RhbmNlKGUsQXJyYXlCdWZmZXIpKXtyZXR1cm4gZS5ieXRlTGVuZ3RofWlmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcrXCJSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX12YXIgdD1lLmxlbmd0aDt2YXIgZj1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXT09PXRydWU7aWYoIWYmJnQ9PT0wKXJldHVybiAwO3ZhciBuPWZhbHNlO2Zvcig7Oyl7c3dpdGNoKHIpe2Nhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIHQ7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhUb0J5dGVzKGUpLmxlbmd0aDtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdCoyO2Nhc2VcImhleFwiOnJldHVybiB0Pj4+MTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0VG9CeXRlcyhlKS5sZW5ndGg7ZGVmYXVsdDppZihuKXtyZXR1cm4gZj8tMTp1dGY4VG9CeXRlcyhlKS5sZW5ndGh9cj0oXCJcIityKS50b0xvd2VyQ2FzZSgpO249dHJ1ZX19fUJ1ZmZlci5ieXRlTGVuZ3RoPWJ5dGVMZW5ndGg7ZnVuY3Rpb24gc2xvd1RvU3RyaW5nKGUscix0KXt2YXIgZj1mYWxzZTtpZihyPT09dW5kZWZpbmVkfHxyPDApe3I9MH1pZihyPnRoaXMubGVuZ3RoKXtyZXR1cm5cIlwifWlmKHQ9PT11bmRlZmluZWR8fHQ+dGhpcy5sZW5ndGgpe3Q9dGhpcy5sZW5ndGh9aWYodDw9MCl7cmV0dXJuXCJcIn10Pj4+PTA7cj4+Pj0wO2lmKHQ8PXIpe3JldHVyblwiXCJ9aWYoIWUpZT1cInV0ZjhcIjt3aGlsZSh0cnVlKXtzd2l0Y2goZSl7Y2FzZVwiaGV4XCI6cmV0dXJuIGhleFNsaWNlKHRoaXMscix0KTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFNsaWNlKHRoaXMscix0KTtjYXNlXCJhc2NpaVwiOnJldHVybiBhc2NpaVNsaWNlKHRoaXMscix0KTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gbGF0aW4xU2xpY2UodGhpcyxyLHQpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRTbGljZSh0aGlzLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLHIsdCk7ZGVmYXVsdDppZihmKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitlKTtlPShlK1wiXCIpLnRvTG93ZXJDYXNlKCk7Zj10cnVlfX19QnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXI9dHJ1ZTtmdW5jdGlvbiBzd2FwKGUscix0KXt2YXIgZj1lW3JdO2Vbcl09ZVt0XTtlW3RdPWZ9QnVmZmVyLnByb3RvdHlwZS5zd2FwMTY9ZnVuY3Rpb24gc3dhcDE2KCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSUyIT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9Mil7c3dhcCh0aGlzLHIscisxKX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS5zd2FwMzI9ZnVuY3Rpb24gc3dhcDMyKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU0IT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9NCl7c3dhcCh0aGlzLHIsciszKTtzd2FwKHRoaXMscisxLHIrMil9cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUuc3dhcDY0PWZ1bmN0aW9uIHN3YXA2NCgpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlOCE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHNcIil9Zm9yKHZhciByPTA7cjxlO3IrPTgpe3N3YXAodGhpcyxyLHIrNyk7c3dhcCh0aGlzLHIrMSxyKzYpO3N3YXAodGhpcyxyKzIscis1KTtzd2FwKHRoaXMsciszLHIrNCl9cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24gdG9TdHJpbmcoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlPT09MClyZXR1cm5cIlwiO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0wKXJldHVybiB1dGY4U2xpY2UodGhpcywwLGUpO3JldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtCdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nPUJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc7QnVmZmVyLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24gZXF1YWxzKGUpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7aWYodGhpcz09PWUpcmV0dXJuIHRydWU7cmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsZSk9PT0wfTtCdWZmZXIucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24gaW5zcGVjdCgpe3ZhciBlPVwiXCI7dmFyIHQ9ci5JTlNQRUNUX01BWF9CWVRFUztlPXRoaXMudG9TdHJpbmcoXCJoZXhcIiwwLHQpLnJlcGxhY2UoLyguezJ9KS9nLFwiJDEgXCIpLnRyaW0oKTtpZih0aGlzLmxlbmd0aD50KWUrPVwiIC4uLiBcIjtyZXR1cm5cIjxCdWZmZXIgXCIrZStcIj5cIn07aWYoaSl7QnVmZmVyLnByb3RvdHlwZVtpXT1CdWZmZXIucHJvdG90eXBlLmluc3BlY3R9QnVmZmVyLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uIGNvbXBhcmUoZSxyLHQsZixuKXtpZihpc0luc3RhbmNlKGUsVWludDhBcnJheSkpe2U9QnVmZmVyLmZyb20oZSxlLm9mZnNldCxlLmJ5dGVMZW5ndGgpfWlmKCFCdWZmZXIuaXNCdWZmZXIoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcrXCJSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1pZihyPT09dW5kZWZpbmVkKXtyPTB9aWYodD09PXVuZGVmaW5lZCl7dD1lP2UubGVuZ3RoOjB9aWYoZj09PXVuZGVmaW5lZCl7Zj0wfWlmKG49PT11bmRlZmluZWQpe249dGhpcy5sZW5ndGh9aWYocjwwfHx0PmUubGVuZ3RofHxmPDB8fG4+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJhbmdlIGluZGV4XCIpfWlmKGY+PW4mJnI+PXQpe3JldHVybiAwfWlmKGY+PW4pe3JldHVybi0xfWlmKHI+PXQpe3JldHVybiAxfXI+Pj49MDt0Pj4+PTA7Zj4+Pj0wO24+Pj49MDtpZih0aGlzPT09ZSlyZXR1cm4gMDt2YXIgaT1uLWY7dmFyIG89dC1yO3ZhciB1PU1hdGgubWluKGksbyk7dmFyIGE9dGhpcy5zbGljZShmLG4pO3ZhciBzPWUuc2xpY2Uocix0KTtmb3IodmFyIGg9MDtoPHU7KytoKXtpZihhW2hdIT09c1toXSl7aT1hW2hdO289c1toXTticmVha319aWYoaTxvKXJldHVybi0xO2lmKG88aSlyZXR1cm4gMTtyZXR1cm4gMH07ZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YoZSxyLHQsZixuKXtpZihlLmxlbmd0aD09PTApcmV0dXJuLTE7aWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtmPXQ7dD0wfWVsc2UgaWYodD4yMTQ3NDgzNjQ3KXt0PTIxNDc0ODM2NDd9ZWxzZSBpZih0PC0yMTQ3NDgzNjQ4KXt0PS0yMTQ3NDgzNjQ4fXQ9K3Q7aWYobnVtYmVySXNOYU4odCkpe3Q9bj8wOmUubGVuZ3RoLTF9aWYodDwwKXQ9ZS5sZW5ndGgrdDtpZih0Pj1lLmxlbmd0aCl7aWYobilyZXR1cm4tMTtlbHNlIHQ9ZS5sZW5ndGgtMX1lbHNlIGlmKHQ8MCl7aWYobil0PTA7ZWxzZSByZXR1cm4tMX1pZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe3I9QnVmZmVyLmZyb20ocixmKX1pZihCdWZmZXIuaXNCdWZmZXIocikpe2lmKHIubGVuZ3RoPT09MCl7cmV0dXJuLTF9cmV0dXJuIGFycmF5SW5kZXhPZihlLHIsdCxmLG4pfWVsc2UgaWYodHlwZW9mIHI9PT1cIm51bWJlclwiKXtyPXImMjU1O2lmKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mPT09XCJmdW5jdGlvblwiKXtpZihuKXtyZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGUscix0KX1lbHNle3JldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGUscix0KX19cmV0dXJuIGFycmF5SW5kZXhPZihlLFtyXSx0LGYsbil9dGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlclwiKX1mdW5jdGlvbiBhcnJheUluZGV4T2YoZSxyLHQsZixuKXt2YXIgaT0xO3ZhciBvPWUubGVuZ3RoO3ZhciB1PXIubGVuZ3RoO2lmKGYhPT11bmRlZmluZWQpe2Y9U3RyaW5nKGYpLnRvTG93ZXJDYXNlKCk7aWYoZj09PVwidWNzMlwifHxmPT09XCJ1Y3MtMlwifHxmPT09XCJ1dGYxNmxlXCJ8fGY9PT1cInV0Zi0xNmxlXCIpe2lmKGUubGVuZ3RoPDJ8fHIubGVuZ3RoPDIpe3JldHVybi0xfWk9MjtvLz0yO3UvPTI7dC89Mn19ZnVuY3Rpb24gcmVhZChlLHIpe2lmKGk9PT0xKXtyZXR1cm4gZVtyXX1lbHNle3JldHVybiBlLnJlYWRVSW50MTZCRShyKmkpfX12YXIgYTtpZihuKXt2YXIgcz0tMTtmb3IoYT10O2E8bzthKyspe2lmKHJlYWQoZSxhKT09PXJlYWQocixzPT09LTE/MDphLXMpKXtpZihzPT09LTEpcz1hO2lmKGEtcysxPT09dSlyZXR1cm4gcyppfWVsc2V7aWYocyE9PS0xKWEtPWEtcztzPS0xfX19ZWxzZXtpZih0K3U+byl0PW8tdTtmb3IoYT10O2E+PTA7YS0tKXt2YXIgaD10cnVlO2Zvcih2YXIgYz0wO2M8dTtjKyspe2lmKHJlYWQoZSxhK2MpIT09cmVhZChyLGMpKXtoPWZhbHNlO2JyZWFrfX1pZihoKXJldHVybiBhfX1yZXR1cm4tMX1CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzPWZ1bmN0aW9uIGluY2x1ZGVzKGUscix0KXtyZXR1cm4gdGhpcy5pbmRleE9mKGUscix0KSE9PS0xfTtCdWZmZXIucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24gaW5kZXhPZihlLHIsdCl7cmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsZSxyLHQsdHJ1ZSl9O0J1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2Y9ZnVuY3Rpb24gbGFzdEluZGV4T2YoZSxyLHQpe3JldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLGUscix0LGZhbHNlKX07ZnVuY3Rpb24gaGV4V3JpdGUoZSxyLHQsZil7dD1OdW1iZXIodCl8fDA7dmFyIG49ZS5sZW5ndGgtdDtpZighZil7Zj1ufWVsc2V7Zj1OdW1iZXIoZik7aWYoZj5uKXtmPW59fXZhciBpPXIubGVuZ3RoO2lmKGY+aS8yKXtmPWkvMn1mb3IodmFyIG89MDtvPGY7KytvKXt2YXIgdT1wYXJzZUludChyLnN1YnN0cihvKjIsMiksMTYpO2lmKG51bWJlcklzTmFOKHUpKXJldHVybiBvO2VbdCtvXT11fXJldHVybiBvfWZ1bmN0aW9uIHV0ZjhXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhyLGUubGVuZ3RoLXQpLGUsdCxmKX1mdW5jdGlvbiBhc2NpaVdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhyKSxlLHQsZil9ZnVuY3Rpb24gbGF0aW4xV3JpdGUoZSxyLHQsZil7cmV0dXJuIGFzY2lpV3JpdGUoZSxyLHQsZil9ZnVuY3Rpb24gYmFzZTY0V3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhyKSxlLHQsZil9ZnVuY3Rpb24gdWNzMldyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHIsZS5sZW5ndGgtdCksZSx0LGYpfUJ1ZmZlci5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24gd3JpdGUoZSxyLHQsZil7aWYocj09PXVuZGVmaW5lZCl7Zj1cInV0ZjhcIjt0PXRoaXMubGVuZ3RoO3I9MH1lbHNlIGlmKHQ9PT11bmRlZmluZWQmJnR5cGVvZiByPT09XCJzdHJpbmdcIil7Zj1yO3Q9dGhpcy5sZW5ndGg7cj0wfWVsc2UgaWYoaXNGaW5pdGUocikpe3I9cj4+PjA7aWYoaXNGaW5pdGUodCkpe3Q9dD4+PjA7aWYoZj09PXVuZGVmaW5lZClmPVwidXRmOFwifWVsc2V7Zj10O3Q9dW5kZWZpbmVkfX1lbHNle3Rocm93IG5ldyBFcnJvcihcIkJ1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCIpfXZhciBuPXRoaXMubGVuZ3RoLXI7aWYodD09PXVuZGVmaW5lZHx8dD5uKXQ9bjtpZihlLmxlbmd0aD4wJiYodDwwfHxyPDApfHxyPnRoaXMubGVuZ3RoKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzXCIpfWlmKCFmKWY9XCJ1dGY4XCI7dmFyIGk9ZmFsc2U7Zm9yKDs7KXtzd2l0Y2goZil7Y2FzZVwiaGV4XCI6cmV0dXJuIGhleFdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gYXNjaWlXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gbGF0aW4xV3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB1Y3MyV3JpdGUodGhpcyxlLHIsdCk7ZGVmYXVsdDppZihpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitmKTtmPShcIlwiK2YpLnRvTG93ZXJDYXNlKCk7aT10cnVlfX19O0J1ZmZlci5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uIHRvSlNPTigpe3JldHVybnt0eXBlOlwiQnVmZmVyXCIsZGF0YTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnJ8fHRoaXMsMCl9fTtmdW5jdGlvbiBiYXNlNjRTbGljZShlLHIsdCl7aWYocj09PTAmJnQ9PT1lLmxlbmd0aCl7cmV0dXJuIGYuZnJvbUJ5dGVBcnJheShlKX1lbHNle3JldHVybiBmLmZyb21CeXRlQXJyYXkoZS5zbGljZShyLHQpKX19ZnVuY3Rpb24gdXRmOFNsaWNlKGUscix0KXt0PU1hdGgubWluKGUubGVuZ3RoLHQpO3ZhciBmPVtdO3ZhciBuPXI7d2hpbGUobjx0KXt2YXIgaT1lW25dO3ZhciBvPW51bGw7dmFyIHU9aT4yMzk/NDppPjIyMz8zOmk+MTkxPzI6MTtpZihuK3U8PXQpe3ZhciBhLHMsaCxjO3N3aXRjaCh1KXtjYXNlIDE6aWYoaTwxMjgpe289aX1icmVhaztjYXNlIDI6YT1lW24rMV07aWYoKGEmMTkyKT09PTEyOCl7Yz0oaSYzMSk8PDZ8YSY2MztpZihjPjEyNyl7bz1jfX1icmVhaztjYXNlIDM6YT1lW24rMV07cz1lW24rMl07aWYoKGEmMTkyKT09PTEyOCYmKHMmMTkyKT09PTEyOCl7Yz0oaSYxNSk8PDEyfChhJjYzKTw8NnxzJjYzO2lmKGM+MjA0NyYmKGM8NTUyOTZ8fGM+NTczNDMpKXtvPWN9fWJyZWFrO2Nhc2UgNDphPWVbbisxXTtzPWVbbisyXTtoPWVbbiszXTtpZigoYSYxOTIpPT09MTI4JiYocyYxOTIpPT09MTI4JiYoaCYxOTIpPT09MTI4KXtjPShpJjE1KTw8MTh8KGEmNjMpPDwxMnwocyY2Myk8PDZ8aCY2MztpZihjPjY1NTM1JiZjPDExMTQxMTIpe289Y319fX1pZihvPT09bnVsbCl7bz02NTUzMzt1PTF9ZWxzZSBpZihvPjY1NTM1KXtvLT02NTUzNjtmLnB1c2gobz4+PjEwJjEwMjN8NTUyOTYpO289NTYzMjB8byYxMDIzfWYucHVzaChvKTtuKz11fXJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoZil9dmFyIHU9NDA5NjtmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoZSl7dmFyIHI9ZS5sZW5ndGg7aWYocjw9dSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGUpfXZhciB0PVwiXCI7dmFyIGY9MDt3aGlsZShmPHIpe3QrPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGUuc2xpY2UoZixmKz11KSl9cmV0dXJuIHR9ZnVuY3Rpb24gYXNjaWlTbGljZShlLHIsdCl7dmFyIGY9XCJcIjt0PU1hdGgubWluKGUubGVuZ3RoLHQpO2Zvcih2YXIgbj1yO248dDsrK24pe2YrPVN0cmluZy5mcm9tQ2hhckNvZGUoZVtuXSYxMjcpfXJldHVybiBmfWZ1bmN0aW9uIGxhdGluMVNsaWNlKGUscix0KXt2YXIgZj1cIlwiO3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7Zm9yKHZhciBuPXI7bjx0Oysrbil7Zis9U3RyaW5nLmZyb21DaGFyQ29kZShlW25dKX1yZXR1cm4gZn1mdW5jdGlvbiBoZXhTbGljZShlLHIsdCl7dmFyIGY9ZS5sZW5ndGg7aWYoIXJ8fHI8MClyPTA7aWYoIXR8fHQ8MHx8dD5mKXQ9Zjt2YXIgbj1cIlwiO2Zvcih2YXIgaT1yO2k8dDsrK2kpe24rPXNbZVtpXV19cmV0dXJuIG59ZnVuY3Rpb24gdXRmMTZsZVNsaWNlKGUscix0KXt2YXIgZj1lLnNsaWNlKHIsdCk7dmFyIG49XCJcIjtmb3IodmFyIGk9MDtpPGYubGVuZ3RoO2krPTIpe24rPVN0cmluZy5mcm9tQ2hhckNvZGUoZltpXStmW2krMV0qMjU2KX1yZXR1cm4gbn1CdWZmZXIucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uIHNsaWNlKGUscil7dmFyIHQ9dGhpcy5sZW5ndGg7ZT1+fmU7cj1yPT09dW5kZWZpbmVkP3Q6fn5yO2lmKGU8MCl7ZSs9dDtpZihlPDApZT0wfWVsc2UgaWYoZT50KXtlPXR9aWYocjwwKXtyKz10O2lmKHI8MClyPTB9ZWxzZSBpZihyPnQpe3I9dH1pZihyPGUpcj1lO3ZhciBmPXRoaXMuc3ViYXJyYXkoZSxyKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoZixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gZn07ZnVuY3Rpb24gY2hlY2tPZmZzZXQoZSxyLHQpe2lmKGUlMSE9PTB8fGU8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm9mZnNldCBpcyBub3QgdWludFwiKTtpZihlK3I+dCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFPWZ1bmN0aW9uIHJlYWRVSW50TEUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCljaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpO3ZhciBmPXRoaXNbZV07dmFyIG49MTt2YXIgaT0wO3doaWxlKCsraTxyJiYobio9MjU2KSl7Zis9dGhpc1tlK2ldKm59cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRT1mdW5jdGlvbiByZWFkVUludEJFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpe2NoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCl9dmFyIGY9dGhpc1tlKy0tcl07dmFyIG49MTt3aGlsZShyPjAmJihuKj0yNTYpKXtmKz10aGlzW2UrLS1yXSpufXJldHVybiBmfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OD1mdW5jdGlvbiByZWFkVUludDgoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMSx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV19O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFPWZ1bmN0aW9uIHJlYWRVSW50MTZMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXXx0aGlzW2UrMV08PDh9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFPWZ1bmN0aW9uIHJlYWRVSW50MTZCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXTw8OHx0aGlzW2UrMV19O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFPWZ1bmN0aW9uIHJlYWRVSW50MzJMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4odGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNikrdGhpc1tlKzNdKjE2Nzc3MjE2fTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRT1mdW5jdGlvbiByZWFkVUludDMyQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV0qMTY3NzcyMTYrKHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXSl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludExFPWZ1bmN0aW9uIHJlYWRJbnRMRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9dGhpc1tlXTt2YXIgbj0xO3ZhciBpPTA7d2hpbGUoKytpPHImJihuKj0yNTYpKXtmKz10aGlzW2UraV0qbn1uKj0xMjg7aWYoZj49bilmLT1NYXRoLnBvdygyLDgqcik7cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludEJFPWZ1bmN0aW9uIHJlYWRJbnRCRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9cjt2YXIgbj0xO3ZhciBpPXRoaXNbZSstLWZdO3doaWxlKGY+MCYmKG4qPTI1Nikpe2krPXRoaXNbZSstLWZdKm59bio9MTI4O2lmKGk+PW4paS09TWF0aC5wb3coMiw4KnIpO3JldHVybiBpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4PWZ1bmN0aW9uIHJlYWRJbnQ4KGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDEsdGhpcy5sZW5ndGgpO2lmKCEodGhpc1tlXSYxMjgpKXJldHVybiB0aGlzW2VdO3JldHVybigyNTUtdGhpc1tlXSsxKSotMX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbiByZWFkSW50MTZMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTt2YXIgdD10aGlzW2VdfHRoaXNbZSsxXTw8ODtyZXR1cm4gdCYzMjc2OD90fDQyOTQ5MDE3NjA6dH07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRT1mdW5jdGlvbiByZWFkSW50MTZCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTt2YXIgdD10aGlzW2UrMV18dGhpc1tlXTw8ODtyZXR1cm4gdCYzMjc2OD90fDQyOTQ5MDE3NjA6dH07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRT1mdW5jdGlvbiByZWFkSW50MzJMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNnx0aGlzW2UrM108PDI0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uIHJlYWRJbnQzMkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdPDwyNHx0aGlzW2UrMV08PDE2fHRoaXNbZSsyXTw8OHx0aGlzW2UrM119O0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEU9ZnVuY3Rpb24gcmVhZEZsb2F0TEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsdHJ1ZSwyMyw0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbiByZWFkRmxvYXRCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSxmYWxzZSwyMyw0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEU9ZnVuY3Rpb24gcmVhZERvdWJsZUxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDgsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLHRydWUsNTIsOCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFPWZ1bmN0aW9uIHJlYWREb3VibGVCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw4LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSxmYWxzZSw1Miw4KX07ZnVuY3Rpb24gY2hlY2tJbnQoZSxyLHQsZixuLGkpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7aWYocj5ufHxyPGkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7aWYodCtmPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEU9ZnVuY3Rpb24gd3JpdGVVSW50TEUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO3Q9dD4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0KS0xO2NoZWNrSW50KHRoaXMsZSxyLHQsbiwwKX12YXIgaT0xO3ZhciBvPTA7dGhpc1tyXT1lJjI1NTt3aGlsZSgrK288dCYmKGkqPTI1Nikpe3RoaXNbcitvXT1lL2kmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24gd3JpdGVVSW50QkUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO3Q9dD4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0KS0xO2NoZWNrSW50KHRoaXMsZSxyLHQsbiwwKX12YXIgaT10LTE7dmFyIG89MTt0aGlzW3IraV09ZSYyNTU7d2hpbGUoLS1pPj0wJiYobyo9MjU2KSl7dGhpc1tyK2ldPWUvbyYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4PWZ1bmN0aW9uIHdyaXRlVUludDgoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwxLDI1NSwwKTt0aGlzW3JdPWUmMjU1O3JldHVybiByKzF9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRT1mdW5jdGlvbiB3cml0ZVVJbnQxNkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiw2NTUzNSwwKTt0aGlzW3JdPWUmMjU1O3RoaXNbcisxXT1lPj4+ODtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24gd3JpdGVVSW50MTZCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsNjU1MzUsMCk7dGhpc1tyXT1lPj4+ODt0aGlzW3IrMV09ZSYyNTU7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlVUludDMyTEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDQyOTQ5NjcyOTUsMCk7dGhpc1tyKzNdPWU+Pj4yNDt0aGlzW3IrMl09ZT4+PjE2O3RoaXNbcisxXT1lPj4+ODt0aGlzW3JdPWUmMjU1O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRT1mdW5jdGlvbiB3cml0ZVVJbnQzMkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCw0Mjk0OTY3Mjk1LDApO3RoaXNbcl09ZT4+PjI0O3RoaXNbcisxXT1lPj4+MTY7dGhpc1tyKzJdPWU+Pj44O3RoaXNbciszXT1lJjI1NTtyZXR1cm4gcis0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24gd3JpdGVJbnRMRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0LTEpO2NoZWNrSW50KHRoaXMsZSxyLHQsbi0xLC1uKX12YXIgaT0wO3ZhciBvPTE7dmFyIHU9MDt0aGlzW3JdPWUmMjU1O3doaWxlKCsraTx0JiYobyo9MjU2KSl7aWYoZTwwJiZ1PT09MCYmdGhpc1tyK2ktMV0hPT0wKXt1PTF9dGhpc1tyK2ldPShlL28+PjApLXUmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRT1mdW5jdGlvbiB3cml0ZUludEJFKGUscix0LGYpe2U9K2U7cj1yPj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQtMSk7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLTEsLW4pfXZhciBpPXQtMTt2YXIgbz0xO3ZhciB1PTA7dGhpc1tyK2ldPWUmMjU1O3doaWxlKC0taT49MCYmKG8qPTI1Nikpe2lmKGU8MCYmdT09PTAmJnRoaXNbcitpKzFdIT09MCl7dT0xfXRoaXNbcitpXT0oZS9vPj4wKS11JjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbiB3cml0ZUludDgoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwxLDEyNywtMTI4KTtpZihlPDApZT0yNTUrZSsxO3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrMX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEU9ZnVuY3Rpb24gd3JpdGVJbnQxNkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiwzMjc2NywtMzI3NjgpO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFPWZ1bmN0aW9uIHdyaXRlSW50MTZCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsMzI3NjcsLTMyNzY4KTt0aGlzW3JdPWU+Pj44O3RoaXNbcisxXT1lJjI1NTtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbiB3cml0ZUludDMyTEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3RoaXNbcisyXT1lPj4+MTY7dGhpc1tyKzNdPWU+Pj4yNDtyZXR1cm4gcis0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRT1mdW5jdGlvbiB3cml0ZUludDMyQkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpO2lmKGU8MCllPTQyOTQ5NjcyOTUrZSsxO3RoaXNbcl09ZT4+PjI0O3RoaXNbcisxXT1lPj4+MTY7dGhpc1tyKzJdPWU+Pj44O3RoaXNbciszXT1lJjI1NTtyZXR1cm4gcis0fTtmdW5jdGlvbiBjaGVja0lFRUU3NTQoZSxyLHQsZixuLGkpe2lmKHQrZj5lLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZih0PDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gd3JpdGVGbG9hdChlLHIsdCxmLGkpe3I9K3I7dD10Pj4+MDtpZighaSl7Y2hlY2tJRUVFNzU0KGUscix0LDQsMzQwMjgyMzQ2NjM4NTI4ODZlMjIsLTM0MDI4MjM0NjYzODUyODg2ZTIyKX1uLndyaXRlKGUscix0LGYsMjMsNCk7cmV0dXJuIHQrNH1CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRT1mdW5jdGlvbiB3cml0ZUZsb2F0TEUoZSxyLHQpe3JldHVybiB3cml0ZUZsb2F0KHRoaXMsZSxyLHRydWUsdCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFPWZ1bmN0aW9uIHdyaXRlRmxvYXRCRShlLHIsdCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyxlLHIsZmFsc2UsdCl9O2Z1bmN0aW9uIHdyaXRlRG91YmxlKGUscix0LGYsaSl7cj0rcjt0PXQ+Pj4wO2lmKCFpKXtjaGVja0lFRUU3NTQoZSxyLHQsOCwxNzk3NjkzMTM0ODYyMzE1N2UyOTIsLTE3OTc2OTMxMzQ4NjIzMTU3ZTI5Mil9bi53cml0ZShlLHIsdCxmLDUyLDgpO3JldHVybiB0Kzh9QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFPWZ1bmN0aW9uIHdyaXRlRG91YmxlTEUoZSxyLHQpe3JldHVybiB3cml0ZURvdWJsZSh0aGlzLGUscix0cnVlLHQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkU9ZnVuY3Rpb24gd3JpdGVEb3VibGVCRShlLHIsdCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsZSxyLGZhbHNlLHQpfTtCdWZmZXIucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24gY29weShlLHIsdCxmKXtpZighQnVmZmVyLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXJcIik7aWYoIXQpdD0wO2lmKCFmJiZmIT09MClmPXRoaXMubGVuZ3RoO2lmKHI+PWUubGVuZ3RoKXI9ZS5sZW5ndGg7aWYoIXIpcj0wO2lmKGY+MCYmZjx0KWY9dDtpZihmPT09dClyZXR1cm4gMDtpZihlLmxlbmd0aD09PTB8fHRoaXMubGVuZ3RoPT09MClyZXR1cm4gMDtpZihyPDApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1wiKX1pZih0PDB8fHQ+PXRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKGY8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXCIpO2lmKGY+dGhpcy5sZW5ndGgpZj10aGlzLmxlbmd0aDtpZihlLmxlbmd0aC1yPGYtdCl7Zj1lLmxlbmd0aC1yK3R9dmFyIG49Zi10O2lmKHRoaXM9PT1lJiZ0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbj09PVwiZnVuY3Rpb25cIil7dGhpcy5jb3B5V2l0aGluKHIsdCxmKX1lbHNlIGlmKHRoaXM9PT1lJiZ0PHImJnI8Zil7Zm9yKHZhciBpPW4tMTtpPj0wOy0taSl7ZVtpK3JdPXRoaXNbaSt0XX19ZWxzZXtVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChlLHRoaXMuc3ViYXJyYXkodCxmKSxyKX1yZXR1cm4gbn07QnVmZmVyLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uIGZpbGwoZSxyLHQsZil7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtpZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe2Y9cjtyPTA7dD10aGlzLmxlbmd0aH1lbHNlIGlmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7Zj10O3Q9dGhpcy5sZW5ndGh9aWYoZiE9PXVuZGVmaW5lZCYmdHlwZW9mIGYhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZ1wiKX1pZih0eXBlb2YgZj09PVwic3RyaW5nXCImJiFCdWZmZXIuaXNFbmNvZGluZyhmKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2YpfWlmKGUubGVuZ3RoPT09MSl7dmFyIG49ZS5jaGFyQ29kZUF0KDApO2lmKGY9PT1cInV0ZjhcIiYmbjwxMjh8fGY9PT1cImxhdGluMVwiKXtlPW59fX1lbHNlIGlmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7ZT1lJjI1NX1lbHNlIGlmKHR5cGVvZiBlPT09XCJib29sZWFuXCIpe2U9TnVtYmVyKGUpfWlmKHI8MHx8dGhpcy5sZW5ndGg8cnx8dGhpcy5sZW5ndGg8dCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJPdXQgb2YgcmFuZ2UgaW5kZXhcIil9aWYodDw9cil7cmV0dXJuIHRoaXN9cj1yPj4+MDt0PXQ9PT11bmRlZmluZWQ/dGhpcy5sZW5ndGg6dD4+PjA7aWYoIWUpZT0wO3ZhciBpO2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7Zm9yKGk9cjtpPHQ7KytpKXt0aGlzW2ldPWV9fWVsc2V7dmFyIG89QnVmZmVyLmlzQnVmZmVyKGUpP2U6QnVmZmVyLmZyb20oZSxmKTt2YXIgdT1vLmxlbmd0aDtpZih1PT09MCl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJytlKydcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKX1mb3IoaT0wO2k8dC1yOysraSl7dGhpc1tpK3JdPW9baSV1XX19cmV0dXJuIHRoaXN9O3ZhciBhPS9bXisvMC05QS1aYS16LV9dL2c7ZnVuY3Rpb24gYmFzZTY0Y2xlYW4oZSl7ZT1lLnNwbGl0KFwiPVwiKVswXTtlPWUudHJpbSgpLnJlcGxhY2UoYSxcIlwiKTtpZihlLmxlbmd0aDwyKXJldHVyblwiXCI7d2hpbGUoZS5sZW5ndGglNCE9PTApe2U9ZStcIj1cIn1yZXR1cm4gZX1mdW5jdGlvbiB1dGY4VG9CeXRlcyhlLHIpe3I9cnx8SW5maW5pdHk7dmFyIHQ7dmFyIGY9ZS5sZW5ndGg7dmFyIG49bnVsbDt2YXIgaT1bXTtmb3IodmFyIG89MDtvPGY7KytvKXt0PWUuY2hhckNvZGVBdChvKTtpZih0PjU1Mjk1JiZ0PDU3MzQ0KXtpZighbil7aWYodD41NjMxOSl7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9ZWxzZSBpZihvKzE9PT1mKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1uPXQ7Y29udGludWV9aWYodDw1NjMyMCl7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSk7bj10O2NvbnRpbnVlfXQ9KG4tNTUyOTY8PDEwfHQtNTYzMjApKzY1NTM2fWVsc2UgaWYobil7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSl9bj1udWxsO2lmKHQ8MTI4KXtpZigoci09MSk8MClicmVhaztpLnB1c2godCl9ZWxzZSBpZih0PDIwNDgpe2lmKChyLT0yKTwwKWJyZWFrO2kucHVzaCh0Pj42fDE5Mix0JjYzfDEyOCl9ZWxzZSBpZih0PDY1NTM2KXtpZigoci09Myk8MClicmVhaztpLnB1c2godD4+MTJ8MjI0LHQ+PjYmNjN8MTI4LHQmNjN8MTI4KX1lbHNlIGlmKHQ8MTExNDExMil7aWYoKHItPTQpPDApYnJlYWs7aS5wdXNoKHQ+PjE4fDI0MCx0Pj4xMiY2M3wxMjgsdD4+NiY2M3wxMjgsdCY2M3wxMjgpfWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50XCIpfX1yZXR1cm4gaX1mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoZSl7dmFyIHI9W107Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDsrK3Qpe3IucHVzaChlLmNoYXJDb2RlQXQodCkmMjU1KX1yZXR1cm4gcn1mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyhlLHIpe3ZhciB0LGYsbjt2YXIgaT1bXTtmb3IodmFyIG89MDtvPGUubGVuZ3RoOysrbyl7aWYoKHItPTIpPDApYnJlYWs7dD1lLmNoYXJDb2RlQXQobyk7Zj10Pj44O249dCUyNTY7aS5wdXNoKG4pO2kucHVzaChmKX1yZXR1cm4gaX1mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKGUpe3JldHVybiBmLnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKGUpKX1mdW5jdGlvbiBibGl0QnVmZmVyKGUscix0LGYpe2Zvcih2YXIgbj0wO248ZjsrK24pe2lmKG4rdD49ci5sZW5ndGh8fG4+PWUubGVuZ3RoKWJyZWFrO3Jbbit0XT1lW25dfXJldHVybiBufWZ1bmN0aW9uIGlzSW5zdGFuY2UoZSxyKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHJ8fGUhPW51bGwmJmUuY29uc3RydWN0b3IhPW51bGwmJmUuY29uc3RydWN0b3IubmFtZSE9bnVsbCYmZS5jb25zdHJ1Y3Rvci5uYW1lPT09ci5uYW1lfWZ1bmN0aW9uIG51bWJlcklzTmFOKGUpe3JldHVybiBlIT09ZX12YXIgcz1mdW5jdGlvbigpe3ZhciBlPVwiMDEyMzQ1Njc4OWFiY2RlZlwiO3ZhciByPW5ldyBBcnJheSgyNTYpO2Zvcih2YXIgdD0wO3Q8MTY7Kyt0KXt2YXIgZj10KjE2O2Zvcih2YXIgbj0wO248MTY7KytuKXtyW2Yrbl09ZVt0XStlW25dfX1yZXR1cm4gcn0oKX0sNTQzOmZ1bmN0aW9uKGUscil7XG4vKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuci5yZWFkPWZ1bmN0aW9uKGUscix0LGYsbil7dmFyIGksbzt2YXIgdT1uKjgtZi0xO3ZhciBhPSgxPDx1KS0xO3ZhciBzPWE+PjE7dmFyIGg9LTc7dmFyIGM9dD9uLTE6MDt2YXIgbD10Py0xOjE7dmFyIHA9ZVtyK2NdO2MrPWw7aT1wJigxPDwtaCktMTtwPj49LWg7aCs9dTtmb3IoO2g+MDtpPWkqMjU2K2VbcitjXSxjKz1sLGgtPTgpe31vPWkmKDE8PC1oKS0xO2k+Pj0taDtoKz1mO2Zvcig7aD4wO289byoyNTYrZVtyK2NdLGMrPWwsaC09OCl7fWlmKGk9PT0wKXtpPTEtc31lbHNlIGlmKGk9PT1hKXtyZXR1cm4gbz9OYU46KHA/LTE6MSkqSW5maW5pdHl9ZWxzZXtvPW8rTWF0aC5wb3coMixmKTtpPWktc31yZXR1cm4ocD8tMToxKSpvKk1hdGgucG93KDIsaS1mKX07ci53cml0ZT1mdW5jdGlvbihlLHIsdCxmLG4saSl7dmFyIG8sdSxhO3ZhciBzPWkqOC1uLTE7dmFyIGg9KDE8PHMpLTE7dmFyIGM9aD4+MTt2YXIgbD1uPT09MjM/TWF0aC5wb3coMiwtMjQpLU1hdGgucG93KDIsLTc3KTowO3ZhciBwPWY/MDppLTE7dmFyIHk9Zj8xOi0xO3ZhciBnPXI8MHx8cj09PTAmJjEvcjwwPzE6MDtyPU1hdGguYWJzKHIpO2lmKGlzTmFOKHIpfHxyPT09SW5maW5pdHkpe3U9aXNOYU4ocik/MTowO289aH1lbHNle289TWF0aC5mbG9vcihNYXRoLmxvZyhyKS9NYXRoLkxOMik7aWYociooYT1NYXRoLnBvdygyLC1vKSk8MSl7by0tO2EqPTJ9aWYobytjPj0xKXtyKz1sL2F9ZWxzZXtyKz1sKk1hdGgucG93KDIsMS1jKX1pZihyKmE+PTIpe28rKzthLz0yfWlmKG8rYz49aCl7dT0wO289aH1lbHNlIGlmKG8rYz49MSl7dT0ociphLTEpKk1hdGgucG93KDIsbik7bz1vK2N9ZWxzZXt1PXIqTWF0aC5wb3coMixjLTEpKk1hdGgucG93KDIsbik7bz0wfX1mb3IoO24+PTg7ZVt0K3BdPXUmMjU1LHArPXksdS89MjU2LG4tPTgpe31vPW88PG58dTtzKz1uO2Zvcig7cz4wO2VbdCtwXT1vJjI1NSxwKz15LG8vPTI1NixzLT04KXt9ZVt0K3AteV18PWcqMTI4fX19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIGY9clt0XTtpZihmIT09dW5kZWZpbmVkKXtyZXR1cm4gZi5leHBvcnRzfXZhciBuPXJbdF09e2V4cG9ydHM6e319O3ZhciBpPXRydWU7dHJ5e2VbdF0obixuLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7aT1mYWxzZX1maW5hbGx5e2lmKGkpZGVsZXRlIHJbdF19cmV0dXJuIG4uZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXyg4NzcpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6WyJlIiwiciIsImJ5dGVMZW5ndGgiLCJ0b0J5dGVBcnJheSIsImZyb21CeXRlQXJyYXkiLCJ0IiwiZiIsIm4iLCJVaW50OEFycmF5IiwiQXJyYXkiLCJpIiwibyIsInUiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiZ2V0TGVucyIsIkVycm9yIiwiaW5kZXhPZiIsIl9ieXRlTGVuZ3RoIiwiYSIsInMiLCJoIiwidHJpcGxldFRvQmFzZTY0IiwiZW5jb2RlQ2h1bmsiLCJwdXNoIiwiam9pbiIsIlN5bWJvbCIsImZvciIsIkJ1ZmZlciIsIlNsb3dCdWZmZXIiLCJJTlNQRUNUX01BWF9CWVRFUyIsImtNYXhMZW5ndGgiLCJUWVBFRF9BUlJBWV9TVVBQT1JUIiwidHlwZWRBcnJheVN1cHBvcnQiLCJjb25zb2xlIiwiZXJyb3IiLCJmb28iLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsImlzQnVmZmVyIiwidW5kZWZpbmVkIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImNyZWF0ZUJ1ZmZlciIsIlJhbmdlRXJyb3IiLCJUeXBlRXJyb3IiLCJhbGxvY1Vuc2FmZSIsImZyb20iLCJwb29sU2l6ZSIsImZyb21TdHJpbmciLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImZyb21BcnJheUxpa2UiLCJpc0luc3RhbmNlIiwiZnJvbUFycmF5QnVmZmVyIiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJ2YWx1ZU9mIiwiZnJvbU9iamVjdCIsInRvUHJpbWl0aXZlIiwiYXNzZXJ0U2l6ZSIsImFsbG9jIiwiZmlsbCIsImNoZWNrZWQiLCJhbGxvY1Vuc2FmZVNsb3ciLCJpc0VuY29kaW5nIiwid3JpdGUiLCJzbGljZSIsImNvcHkiLCJudW1iZXJJc05hTiIsInR5cGUiLCJpc0FycmF5IiwiZGF0YSIsInRvU3RyaW5nIiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsIm9mZnNldCIsIk1hdGgiLCJtaW4iLCJTdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImNvbmNhdCIsImFyZ3VtZW50cyIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiYXBwbHkiLCJ0b0xvY2FsZVN0cmluZyIsImVxdWFscyIsImluc3BlY3QiLCJyZXBsYWNlIiwidHJpbSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwiYXJyYXlJbmRleE9mIiwiY2FsbCIsImxhc3RJbmRleE9mIiwicmVhZCIsInJlYWRVSW50MTZCRSIsImMiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJ1dGY4V3JpdGUiLCJibGl0QnVmZmVyIiwiYXNjaWlXcml0ZSIsImFzY2lpVG9CeXRlcyIsImxhdGluMVdyaXRlIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsImlzRmluaXRlIiwidG9KU09OIiwiX2FyciIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsImZyb21DaGFyQ29kZSIsInN1YmFycmF5IiwiY2hlY2tPZmZzZXQiLCJyZWFkVUludExFIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIndyaXRlVUludEJFIiwid3JpdGVVSW50OCIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwid3JpdGVJbnRCRSIsIndyaXRlSW50OCIsIndyaXRlSW50MTZMRSIsIndyaXRlSW50MTZCRSIsIndyaXRlSW50MzJMRSIsIndyaXRlSW50MzJCRSIsImNoZWNrSUVFRTc1NCIsIndyaXRlRmxvYXQiLCJ3cml0ZUZsb2F0TEUiLCJ3cml0ZUZsb2F0QkUiLCJ3cml0ZURvdWJsZSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZURvdWJsZUJFIiwiY29weVdpdGhpbiIsInNldCIsImJhc2U2NGNsZWFuIiwic3BsaXQiLCJJbmZpbml0eSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImwiLCJwIiwiTmFOIiwieSIsImciLCJhYnMiLCJpc05hTiIsImZsb29yIiwibG9nIiwiTE4yIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsImV4cG9ydHMiLCJhYiIsIl9fZGlybmFtZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/micromatch/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/micromatch/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n(() => {\n  \"use strict\";\n\n  var e = {\n    526: (e, t, r) => {\n      const n = r(119);\n      const u = r(769);\n      const s = r(722);\n      const o = r(407);\n\n      const braces = (e, t = {}) => {\n        let r = [];\n\n        if (Array.isArray(e)) {\n          for (let n of e) {\n            let e = braces.create(n, t);\n\n            if (Array.isArray(e)) {\n              r.push(...e);\n            } else {\n              r.push(e);\n            }\n          }\n        } else {\n          r = [].concat(braces.create(e, t));\n        }\n\n        if (t && t.expand === true && t.nodupes === true) {\n          r = [...new Set(r)];\n        }\n\n        return r;\n      };\n\n      braces.parse = (e, t = {}) => o(e, t);\n\n      braces.stringify = (e, t = {}) => {\n        if (typeof e === \"string\") {\n          return n(braces.parse(e, t), t);\n        }\n\n        return n(e, t);\n      };\n\n      braces.compile = (e, t = {}) => {\n        if (typeof e === \"string\") {\n          e = braces.parse(e, t);\n        }\n\n        return u(e, t);\n      };\n\n      braces.expand = (e, t = {}) => {\n        if (typeof e === \"string\") {\n          e = braces.parse(e, t);\n        }\n\n        let r = s(e, t);\n\n        if (t.noempty === true) {\n          r = r.filter(Boolean);\n        }\n\n        if (t.nodupes === true) {\n          r = [...new Set(r)];\n        }\n\n        return r;\n      };\n\n      braces.create = (e, t = {}) => {\n        if (e === \"\" || e.length < 3) {\n          return [e];\n        }\n\n        return t.expand !== true ? braces.compile(e, t) : braces.expand(e, t);\n      };\n\n      e.exports = braces;\n    },\n    769: (e, t, r) => {\n      const n = r(789);\n      const u = r(15);\n\n      const compile = (e, t = {}) => {\n        let walk = (e, r = {}) => {\n          let s = u.isInvalidBrace(r);\n          let o = e.invalid === true && t.escapeInvalid === true;\n          let i = s === true || o === true;\n          let a = t.escapeInvalid === true ? \"\\\\\" : \"\";\n          let l = \"\";\n\n          if (e.isOpen === true) {\n            return a + e.value;\n          }\n\n          if (e.isClose === true) {\n            return a + e.value;\n          }\n\n          if (e.type === \"open\") {\n            return i ? a + e.value : \"(\";\n          }\n\n          if (e.type === \"close\") {\n            return i ? a + e.value : \")\";\n          }\n\n          if (e.type === \"comma\") {\n            return e.prev.type === \"comma\" ? \"\" : i ? e.value : \"|\";\n          }\n\n          if (e.value) {\n            return e.value;\n          }\n\n          if (e.nodes && e.ranges > 0) {\n            let r = u.reduce(e.nodes);\n            let s = n(...r, { ...t,\n              wrap: false,\n              toRegex: true\n            });\n\n            if (s.length !== 0) {\n              return r.length > 1 && s.length > 1 ? `(${s})` : s;\n            }\n          }\n\n          if (e.nodes) {\n            for (let t of e.nodes) {\n              l += walk(t, e);\n            }\n          }\n\n          return l;\n        };\n\n        return walk(e);\n      };\n\n      e.exports = compile;\n    },\n    262: e => {\n      e.exports = {\n        MAX_LENGTH: 1024 * 64,\n        CHAR_0: \"0\",\n        CHAR_9: \"9\",\n        CHAR_UPPERCASE_A: \"A\",\n        CHAR_LOWERCASE_A: \"a\",\n        CHAR_UPPERCASE_Z: \"Z\",\n        CHAR_LOWERCASE_Z: \"z\",\n        CHAR_LEFT_PARENTHESES: \"(\",\n        CHAR_RIGHT_PARENTHESES: \")\",\n        CHAR_ASTERISK: \"*\",\n        CHAR_AMPERSAND: \"&\",\n        CHAR_AT: \"@\",\n        CHAR_BACKSLASH: \"\\\\\",\n        CHAR_BACKTICK: \"`\",\n        CHAR_CARRIAGE_RETURN: \"\\r\",\n        CHAR_CIRCUMFLEX_ACCENT: \"^\",\n        CHAR_COLON: \":\",\n        CHAR_COMMA: \",\",\n        CHAR_DOLLAR: \"$\",\n        CHAR_DOT: \".\",\n        CHAR_DOUBLE_QUOTE: '\"',\n        CHAR_EQUAL: \"=\",\n        CHAR_EXCLAMATION_MARK: \"!\",\n        CHAR_FORM_FEED: \"\\f\",\n        CHAR_FORWARD_SLASH: \"/\",\n        CHAR_HASH: \"#\",\n        CHAR_HYPHEN_MINUS: \"-\",\n        CHAR_LEFT_ANGLE_BRACKET: \"<\",\n        CHAR_LEFT_CURLY_BRACE: \"{\",\n        CHAR_LEFT_SQUARE_BRACKET: \"[\",\n        CHAR_LINE_FEED: \"\\n\",\n        CHAR_NO_BREAK_SPACE: \" \",\n        CHAR_PERCENT: \"%\",\n        CHAR_PLUS: \"+\",\n        CHAR_QUESTION_MARK: \"?\",\n        CHAR_RIGHT_ANGLE_BRACKET: \">\",\n        CHAR_RIGHT_CURLY_BRACE: \"}\",\n        CHAR_RIGHT_SQUARE_BRACKET: \"]\",\n        CHAR_SEMICOLON: \";\",\n        CHAR_SINGLE_QUOTE: \"'\",\n        CHAR_SPACE: \" \",\n        CHAR_TAB: \"\\t\",\n        CHAR_UNDERSCORE: \"_\",\n        CHAR_VERTICAL_LINE: \"|\",\n        CHAR_ZERO_WIDTH_NOBREAK_SPACE: \"\\ufeff\"\n      };\n    },\n    722: (e, t, r) => {\n      const n = r(789);\n      const u = r(119);\n      const s = r(15);\n\n      const append = (e = \"\", t = \"\", r = false) => {\n        let n = [];\n        e = [].concat(e);\n        t = [].concat(t);\n        if (!t.length) return e;\n\n        if (!e.length) {\n          return r ? s.flatten(t).map(e => `{${e}}`) : t;\n        }\n\n        for (let u of e) {\n          if (Array.isArray(u)) {\n            for (let e of u) {\n              n.push(append(e, t, r));\n            }\n          } else {\n            for (let e of t) {\n              if (r === true && typeof e === \"string\") e = `{${e}}`;\n              n.push(Array.isArray(e) ? append(u, e, r) : u + e);\n            }\n          }\n        }\n\n        return s.flatten(n);\n      };\n\n      const expand = (e, t = {}) => {\n        let r = t.rangeLimit === void 0 ? 1e3 : t.rangeLimit;\n\n        let walk = (e, o = {}) => {\n          e.queue = [];\n          let i = o;\n          let a = o.queue;\n\n          while (i.type !== \"brace\" && i.type !== \"root\" && i.parent) {\n            i = i.parent;\n            a = i.queue;\n          }\n\n          if (e.invalid || e.dollar) {\n            a.push(append(a.pop(), u(e, t)));\n            return;\n          }\n\n          if (e.type === \"brace\" && e.invalid !== true && e.nodes.length === 2) {\n            a.push(append(a.pop(), [\"{}\"]));\n            return;\n          }\n\n          if (e.nodes && e.ranges > 0) {\n            let o = s.reduce(e.nodes);\n\n            if (s.exceedsLimit(...o, t.step, r)) {\n              throw new RangeError(\"expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.\");\n            }\n\n            let i = n(...o, t);\n\n            if (i.length === 0) {\n              i = u(e, t);\n            }\n\n            a.push(append(a.pop(), i));\n            e.nodes = [];\n            return;\n          }\n\n          let l = s.encloseBrace(e);\n          let c = e.queue;\n          let p = e;\n\n          while (p.type !== \"brace\" && p.type !== \"root\" && p.parent) {\n            p = p.parent;\n            c = p.queue;\n          }\n\n          for (let t = 0; t < e.nodes.length; t++) {\n            let r = e.nodes[t];\n\n            if (r.type === \"comma\" && e.type === \"brace\") {\n              if (t === 1) c.push(\"\");\n              c.push(\"\");\n              continue;\n            }\n\n            if (r.type === \"close\") {\n              a.push(append(a.pop(), c, l));\n              continue;\n            }\n\n            if (r.value && r.type !== \"open\") {\n              c.push(append(c.pop(), r.value));\n              continue;\n            }\n\n            if (r.nodes) {\n              walk(r, e);\n            }\n          }\n\n          return c;\n        };\n\n        return s.flatten(walk(e));\n      };\n\n      e.exports = expand;\n    },\n    407: (e, t, r) => {\n      const n = r(119);\n      const {\n        MAX_LENGTH: u,\n        CHAR_BACKSLASH: s,\n        CHAR_BACKTICK: o,\n        CHAR_COMMA: i,\n        CHAR_DOT: a,\n        CHAR_LEFT_PARENTHESES: l,\n        CHAR_RIGHT_PARENTHESES: c,\n        CHAR_LEFT_CURLY_BRACE: p,\n        CHAR_RIGHT_CURLY_BRACE: f,\n        CHAR_LEFT_SQUARE_BRACKET: A,\n        CHAR_RIGHT_SQUARE_BRACKET: R,\n        CHAR_DOUBLE_QUOTE: _,\n        CHAR_SINGLE_QUOTE: h,\n        CHAR_NO_BREAK_SPACE: g,\n        CHAR_ZERO_WIDTH_NOBREAK_SPACE: E\n      } = r(262);\n\n      const parse = (e, t = {}) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(\"Expected a string\");\n        }\n\n        let r = t || {};\n        let C = typeof r.maxLength === \"number\" ? Math.min(u, r.maxLength) : u;\n\n        if (e.length > C) {\n          throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${C})`);\n        }\n\n        let y = {\n          type: \"root\",\n          input: e,\n          nodes: []\n        };\n        let d = [y];\n        let x = y;\n        let b = y;\n        let S = 0;\n        let H = e.length;\n        let v = 0;\n        let $ = 0;\n        let m;\n        let T = {};\n\n        const advance = () => e[v++];\n\n        const push = e => {\n          if (e.type === \"text\" && b.type === \"dot\") {\n            b.type = \"text\";\n          }\n\n          if (b && b.type === \"text\" && e.type === \"text\") {\n            b.value += e.value;\n            return;\n          }\n\n          x.nodes.push(e);\n          e.parent = x;\n          e.prev = b;\n          b = e;\n          return e;\n        };\n\n        push({\n          type: \"bos\"\n        });\n\n        while (v < H) {\n          x = d[d.length - 1];\n          m = advance();\n\n          if (m === E || m === g) {\n            continue;\n          }\n\n          if (m === s) {\n            push({\n              type: \"text\",\n              value: (t.keepEscaping ? m : \"\") + advance()\n            });\n            continue;\n          }\n\n          if (m === R) {\n            push({\n              type: \"text\",\n              value: \"\\\\\" + m\n            });\n            continue;\n          }\n\n          if (m === A) {\n            S++;\n            let e = true;\n            let t;\n\n            while (v < H && (t = advance())) {\n              m += t;\n\n              if (t === A) {\n                S++;\n                continue;\n              }\n\n              if (t === s) {\n                m += advance();\n                continue;\n              }\n\n              if (t === R) {\n                S--;\n\n                if (S === 0) {\n                  break;\n                }\n              }\n            }\n\n            push({\n              type: \"text\",\n              value: m\n            });\n            continue;\n          }\n\n          if (m === l) {\n            x = push({\n              type: \"paren\",\n              nodes: []\n            });\n            d.push(x);\n            push({\n              type: \"text\",\n              value: m\n            });\n            continue;\n          }\n\n          if (m === c) {\n            if (x.type !== \"paren\") {\n              push({\n                type: \"text\",\n                value: m\n              });\n              continue;\n            }\n\n            x = d.pop();\n            push({\n              type: \"text\",\n              value: m\n            });\n            x = d[d.length - 1];\n            continue;\n          }\n\n          if (m === _ || m === h || m === o) {\n            let e = m;\n            let r;\n\n            if (t.keepQuotes !== true) {\n              m = \"\";\n            }\n\n            while (v < H && (r = advance())) {\n              if (r === s) {\n                m += r + advance();\n                continue;\n              }\n\n              if (r === e) {\n                if (t.keepQuotes === true) m += r;\n                break;\n              }\n\n              m += r;\n            }\n\n            push({\n              type: \"text\",\n              value: m\n            });\n            continue;\n          }\n\n          if (m === p) {\n            $++;\n            let e = b.value && b.value.slice(-1) === \"$\" || x.dollar === true;\n            let t = {\n              type: \"brace\",\n              open: true,\n              close: false,\n              dollar: e,\n              depth: $,\n              commas: 0,\n              ranges: 0,\n              nodes: []\n            };\n            x = push(t);\n            d.push(x);\n            push({\n              type: \"open\",\n              value: m\n            });\n            continue;\n          }\n\n          if (m === f) {\n            if (x.type !== \"brace\") {\n              push({\n                type: \"text\",\n                value: m\n              });\n              continue;\n            }\n\n            let e = \"close\";\n            x = d.pop();\n            x.close = true;\n            push({\n              type: e,\n              value: m\n            });\n            $--;\n            x = d[d.length - 1];\n            continue;\n          }\n\n          if (m === i && $ > 0) {\n            if (x.ranges > 0) {\n              x.ranges = 0;\n              let e = x.nodes.shift();\n              x.nodes = [e, {\n                type: \"text\",\n                value: n(x)\n              }];\n            }\n\n            push({\n              type: \"comma\",\n              value: m\n            });\n            x.commas++;\n            continue;\n          }\n\n          if (m === a && $ > 0 && x.commas === 0) {\n            let e = x.nodes;\n\n            if ($ === 0 || e.length === 0) {\n              push({\n                type: \"text\",\n                value: m\n              });\n              continue;\n            }\n\n            if (b.type === \"dot\") {\n              x.range = [];\n              b.value += m;\n              b.type = \"range\";\n\n              if (x.nodes.length !== 3 && x.nodes.length !== 5) {\n                x.invalid = true;\n                x.ranges = 0;\n                b.type = \"text\";\n                continue;\n              }\n\n              x.ranges++;\n              x.args = [];\n              continue;\n            }\n\n            if (b.type === \"range\") {\n              e.pop();\n              let t = e[e.length - 1];\n              t.value += b.value + m;\n              b = t;\n              x.ranges--;\n              continue;\n            }\n\n            push({\n              type: \"dot\",\n              value: m\n            });\n            continue;\n          }\n\n          push({\n            type: \"text\",\n            value: m\n          });\n        }\n\n        do {\n          x = d.pop();\n\n          if (x.type !== \"root\") {\n            x.nodes.forEach(e => {\n              if (!e.nodes) {\n                if (e.type === \"open\") e.isOpen = true;\n                if (e.type === \"close\") e.isClose = true;\n                if (!e.nodes) e.type = \"text\";\n                e.invalid = true;\n              }\n            });\n            let e = d[d.length - 1];\n            let t = e.nodes.indexOf(x);\n            e.nodes.splice(t, 1, ...x.nodes);\n          }\n        } while (d.length > 0);\n\n        push({\n          type: \"eos\"\n        });\n        return y;\n      };\n\n      e.exports = parse;\n    },\n    119: (e, t, r) => {\n      const n = r(15);\n\n      e.exports = (e, t = {}) => {\n        let stringify = (e, r = {}) => {\n          let u = t.escapeInvalid && n.isInvalidBrace(r);\n          let s = e.invalid === true && t.escapeInvalid === true;\n          let o = \"\";\n\n          if (e.value) {\n            if ((u || s) && n.isOpenOrClose(e)) {\n              return \"\\\\\" + e.value;\n            }\n\n            return e.value;\n          }\n\n          if (e.value) {\n            return e.value;\n          }\n\n          if (e.nodes) {\n            for (let t of e.nodes) {\n              o += stringify(t);\n            }\n          }\n\n          return o;\n        };\n\n        return stringify(e);\n      };\n    },\n    15: (e, t) => {\n      t.isInteger = e => {\n        if (typeof e === \"number\") {\n          return Number.isInteger(e);\n        }\n\n        if (typeof e === \"string\" && e.trim() !== \"\") {\n          return Number.isInteger(Number(e));\n        }\n\n        return false;\n      };\n\n      t.find = (e, t) => e.nodes.find(e => e.type === t);\n\n      t.exceedsLimit = (e, r, n = 1, u) => {\n        if (u === false) return false;\n        if (!t.isInteger(e) || !t.isInteger(r)) return false;\n        return (Number(r) - Number(e)) / Number(n) >= u;\n      };\n\n      t.escapeNode = (e, t = 0, r) => {\n        let n = e.nodes[t];\n        if (!n) return;\n\n        if (r && n.type === r || n.type === \"open\" || n.type === \"close\") {\n          if (n.escaped !== true) {\n            n.value = \"\\\\\" + n.value;\n            n.escaped = true;\n          }\n        }\n      };\n\n      t.encloseBrace = e => {\n        if (e.type !== \"brace\") return false;\n\n        if (e.commas >> 0 + e.ranges >> 0 === 0) {\n          e.invalid = true;\n          return true;\n        }\n\n        return false;\n      };\n\n      t.isInvalidBrace = e => {\n        if (e.type !== \"brace\") return false;\n        if (e.invalid === true || e.dollar) return true;\n\n        if (e.commas >> 0 + e.ranges >> 0 === 0) {\n          e.invalid = true;\n          return true;\n        }\n\n        if (e.open !== true || e.close !== true) {\n          e.invalid = true;\n          return true;\n        }\n\n        return false;\n      };\n\n      t.isOpenOrClose = e => {\n        if (e.type === \"open\" || e.type === \"close\") {\n          return true;\n        }\n\n        return e.open === true || e.close === true;\n      };\n\n      t.reduce = e => e.reduce((e, t) => {\n        if (t.type === \"text\") e.push(t.value);\n        if (t.type === \"range\") t.type = \"text\";\n        return e;\n      }, []);\n\n      t.flatten = (...e) => {\n        const t = [];\n\n        const flat = e => {\n          for (let r = 0; r < e.length; r++) {\n            let n = e[r];\n            Array.isArray(n) ? flat(n, t) : n !== void 0 && t.push(n);\n          }\n\n          return t;\n        };\n\n        flat(e);\n        return t;\n      };\n    },\n    789: (e, t, r) => {\n      /*!\n       * fill-range <https://github.com/jonschlinkert/fill-range>\n       *\n       * Copyright (c) 2014-present, Jon Schlinkert.\n       * Licensed under the MIT License.\n       */\n      const n = r(837);\n      const u = r(368);\n\n      const isObject = e => e !== null && typeof e === \"object\" && !Array.isArray(e);\n\n      const transform = e => t => e === true ? Number(t) : String(t);\n\n      const isValidValue = e => typeof e === \"number\" || typeof e === \"string\" && e !== \"\";\n\n      const isNumber = e => Number.isInteger(+e);\n\n      const zeros = e => {\n        let t = `${e}`;\n        let r = -1;\n        if (t[0] === \"-\") t = t.slice(1);\n        if (t === \"0\") return false;\n\n        while (t[++r] === \"0\");\n\n        return r > 0;\n      };\n\n      const stringify = (e, t, r) => {\n        if (typeof e === \"string\" || typeof t === \"string\") {\n          return true;\n        }\n\n        return r.stringify === true;\n      };\n\n      const pad = (e, t, r) => {\n        if (t > 0) {\n          let r = e[0] === \"-\" ? \"-\" : \"\";\n          if (r) e = e.slice(1);\n          e = r + e.padStart(r ? t - 1 : t, \"0\");\n        }\n\n        if (r === false) {\n          return String(e);\n        }\n\n        return e;\n      };\n\n      const toMaxLen = (e, t) => {\n        let r = e[0] === \"-\" ? \"-\" : \"\";\n\n        if (r) {\n          e = e.slice(1);\n          t--;\n        }\n\n        while (e.length < t) e = \"0\" + e;\n\n        return r ? \"-\" + e : e;\n      };\n\n      const toSequence = (e, t) => {\n        e.negatives.sort((e, t) => e < t ? -1 : e > t ? 1 : 0);\n        e.positives.sort((e, t) => e < t ? -1 : e > t ? 1 : 0);\n        let r = t.capture ? \"\" : \"?:\";\n        let n = \"\";\n        let u = \"\";\n        let s;\n\n        if (e.positives.length) {\n          n = e.positives.join(\"|\");\n        }\n\n        if (e.negatives.length) {\n          u = `-(${r}${e.negatives.join(\"|\")})`;\n        }\n\n        if (n && u) {\n          s = `${n}|${u}`;\n        } else {\n          s = n || u;\n        }\n\n        if (t.wrap) {\n          return `(${r}${s})`;\n        }\n\n        return s;\n      };\n\n      const toRange = (e, t, r, n) => {\n        if (r) {\n          return u(e, t, {\n            wrap: false,\n            ...n\n          });\n        }\n\n        let s = String.fromCharCode(e);\n        if (e === t) return s;\n        let o = String.fromCharCode(t);\n        return `[${s}-${o}]`;\n      };\n\n      const toRegex = (e, t, r) => {\n        if (Array.isArray(e)) {\n          let t = r.wrap === true;\n          let n = r.capture ? \"\" : \"?:\";\n          return t ? `(${n}${e.join(\"|\")})` : e.join(\"|\");\n        }\n\n        return u(e, t, r);\n      };\n\n      const rangeError = (...e) => new RangeError(\"Invalid range arguments: \" + n.inspect(...e));\n\n      const invalidRange = (e, t, r) => {\n        if (r.strictRanges === true) throw rangeError([e, t]);\n        return [];\n      };\n\n      const invalidStep = (e, t) => {\n        if (t.strictRanges === true) {\n          throw new TypeError(`Expected step \"${e}\" to be a number`);\n        }\n\n        return [];\n      };\n\n      const fillNumbers = (e, t, r = 1, n = {}) => {\n        let u = Number(e);\n        let s = Number(t);\n\n        if (!Number.isInteger(u) || !Number.isInteger(s)) {\n          if (n.strictRanges === true) throw rangeError([e, t]);\n          return [];\n        }\n\n        if (u === 0) u = 0;\n        if (s === 0) s = 0;\n        let o = u > s;\n        let i = String(e);\n        let a = String(t);\n        let l = String(r);\n        r = Math.max(Math.abs(r), 1);\n        let c = zeros(i) || zeros(a) || zeros(l);\n        let p = c ? Math.max(i.length, a.length, l.length) : 0;\n        let f = c === false && stringify(e, t, n) === false;\n        let A = n.transform || transform(f);\n\n        if (n.toRegex && r === 1) {\n          return toRange(toMaxLen(e, p), toMaxLen(t, p), true, n);\n        }\n\n        let R = {\n          negatives: [],\n          positives: []\n        };\n\n        let push = e => R[e < 0 ? \"negatives\" : \"positives\"].push(Math.abs(e));\n\n        let _ = [];\n        let h = 0;\n\n        while (o ? u >= s : u <= s) {\n          if (n.toRegex === true && r > 1) {\n            push(u);\n          } else {\n            _.push(pad(A(u, h), p, f));\n          }\n\n          u = o ? u - r : u + r;\n          h++;\n        }\n\n        if (n.toRegex === true) {\n          return r > 1 ? toSequence(R, n) : toRegex(_, null, {\n            wrap: false,\n            ...n\n          });\n        }\n\n        return _;\n      };\n\n      const fillLetters = (e, t, r = 1, n = {}) => {\n        if (!isNumber(e) && e.length > 1 || !isNumber(t) && t.length > 1) {\n          return invalidRange(e, t, n);\n        }\n\n        let u = n.transform || (e => String.fromCharCode(e));\n\n        let s = `${e}`.charCodeAt(0);\n        let o = `${t}`.charCodeAt(0);\n        let i = s > o;\n        let a = Math.min(s, o);\n        let l = Math.max(s, o);\n\n        if (n.toRegex && r === 1) {\n          return toRange(a, l, false, n);\n        }\n\n        let c = [];\n        let p = 0;\n\n        while (i ? s >= o : s <= o) {\n          c.push(u(s, p));\n          s = i ? s - r : s + r;\n          p++;\n        }\n\n        if (n.toRegex === true) {\n          return toRegex(c, null, {\n            wrap: false,\n            options: n\n          });\n        }\n\n        return c;\n      };\n\n      const fill = (e, t, r, n = {}) => {\n        if (t == null && isValidValue(e)) {\n          return [e];\n        }\n\n        if (!isValidValue(e) || !isValidValue(t)) {\n          return invalidRange(e, t, n);\n        }\n\n        if (typeof r === \"function\") {\n          return fill(e, t, 1, {\n            transform: r\n          });\n        }\n\n        if (isObject(r)) {\n          return fill(e, t, 0, r);\n        }\n\n        let u = { ...n\n        };\n        if (u.capture === true) u.wrap = true;\n        r = r || u.step || 1;\n\n        if (!isNumber(r)) {\n          if (r != null && !isObject(r)) return invalidStep(r, u);\n          return fill(e, t, 1, r);\n        }\n\n        if (isNumber(e) && isNumber(t)) {\n          return fillNumbers(e, t, r, u);\n        }\n\n        return fillLetters(e, t, Math.max(Math.abs(r), 1), u);\n      };\n\n      e.exports = fill;\n    },\n    773: e => {\n      /*!\n       * is-number <https://github.com/jonschlinkert/is-number>\n       *\n       * Copyright (c) 2014-present, Jon Schlinkert.\n       * Released under the MIT License.\n       */\n      e.exports = function (e) {\n        if (typeof e === \"number\") {\n          return e - e === 0;\n        }\n\n        if (typeof e === \"string\" && e.trim() !== \"\") {\n          return Number.isFinite ? Number.isFinite(+e) : isFinite(+e);\n        }\n\n        return false;\n      };\n    },\n    888: (e, t, r) => {\n      const n = r(837);\n      const u = r(526);\n      const s = r(601);\n      const o = r(243);\n\n      const isEmptyString = e => e === \"\" || e === \"./\";\n\n      const micromatch = (e, t, r) => {\n        t = [].concat(t);\n        e = [].concat(e);\n        let n = new Set();\n        let u = new Set();\n        let o = new Set();\n        let i = 0;\n\n        let onResult = e => {\n          o.add(e.output);\n\n          if (r && r.onResult) {\n            r.onResult(e);\n          }\n        };\n\n        for (let o = 0; o < t.length; o++) {\n          let a = s(String(t[o]), { ...r,\n            onResult: onResult\n          }, true);\n          let l = a.state.negated || a.state.negatedExtglob;\n          if (l) i++;\n\n          for (let t of e) {\n            let e = a(t, true);\n            let r = l ? !e.isMatch : e.isMatch;\n            if (!r) continue;\n\n            if (l) {\n              n.add(e.output);\n            } else {\n              n.delete(e.output);\n              u.add(e.output);\n            }\n          }\n        }\n\n        let a = i === t.length ? [...o] : [...u];\n        let l = a.filter(e => !n.has(e));\n\n        if (r && l.length === 0) {\n          if (r.failglob === true) {\n            throw new Error(`No matches found for \"${t.join(\", \")}\"`);\n          }\n\n          if (r.nonull === true || r.nullglob === true) {\n            return r.unescape ? t.map(e => e.replace(/\\\\/g, \"\")) : t;\n          }\n        }\n\n        return l;\n      };\n\n      micromatch.match = micromatch;\n\n      micromatch.matcher = (e, t) => s(e, t);\n\n      micromatch.isMatch = (e, t, r) => s(t, r)(e);\n\n      micromatch.any = micromatch.isMatch;\n\n      micromatch.not = (e, t, r = {}) => {\n        t = [].concat(t).map(String);\n        let n = new Set();\n        let u = [];\n\n        let onResult = e => {\n          if (r.onResult) r.onResult(e);\n          u.push(e.output);\n        };\n\n        let s = micromatch(e, t, { ...r,\n          onResult: onResult\n        });\n\n        for (let e of u) {\n          if (!s.includes(e)) {\n            n.add(e);\n          }\n        }\n\n        return [...n];\n      };\n\n      micromatch.contains = (e, t, r) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(`Expected a string: \"${n.inspect(e)}\"`);\n        }\n\n        if (Array.isArray(t)) {\n          return t.some(t => micromatch.contains(e, t, r));\n        }\n\n        if (typeof t === \"string\") {\n          if (isEmptyString(e) || isEmptyString(t)) {\n            return false;\n          }\n\n          if (e.includes(t) || e.startsWith(\"./\") && e.slice(2).includes(t)) {\n            return true;\n          }\n        }\n\n        return micromatch.isMatch(e, t, { ...r,\n          contains: true\n        });\n      };\n\n      micromatch.matchKeys = (e, t, r) => {\n        if (!o.isObject(e)) {\n          throw new TypeError(\"Expected the first argument to be an object\");\n        }\n\n        let n = micromatch(Object.keys(e), t, r);\n        let u = {};\n\n        for (let t of n) u[t] = e[t];\n\n        return u;\n      };\n\n      micromatch.some = (e, t, r) => {\n        let n = [].concat(e);\n\n        for (let e of [].concat(t)) {\n          let t = s(String(e), r);\n\n          if (n.some(e => t(e))) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      micromatch.every = (e, t, r) => {\n        let n = [].concat(e);\n\n        for (let e of [].concat(t)) {\n          let t = s(String(e), r);\n\n          if (!n.every(e => t(e))) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n\n      micromatch.all = (e, t, r) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(`Expected a string: \"${n.inspect(e)}\"`);\n        }\n\n        return [].concat(t).every(t => s(t, r)(e));\n      };\n\n      micromatch.capture = (e, t, r) => {\n        let n = o.isWindows(r);\n        let u = s.makeRe(String(e), { ...r,\n          capture: true\n        });\n        let i = u.exec(n ? o.toPosixSlashes(t) : t);\n\n        if (i) {\n          return i.slice(1).map(e => e === void 0 ? \"\" : e);\n        }\n      };\n\n      micromatch.makeRe = (...e) => s.makeRe(...e);\n\n      micromatch.scan = (...e) => s.scan(...e);\n\n      micromatch.parse = (e, t) => {\n        let r = [];\n\n        for (let n of [].concat(e || [])) {\n          for (let e of u(String(n), t)) {\n            r.push(s.parse(e, t));\n          }\n        }\n\n        return r;\n      };\n\n      micromatch.braces = (e, t) => {\n        if (typeof e !== \"string\") throw new TypeError(\"Expected a string\");\n\n        if (t && t.nobrace === true || !/\\{.*\\}/.test(e)) {\n          return [e];\n        }\n\n        return u(e, t);\n      };\n\n      micromatch.braceExpand = (e, t) => {\n        if (typeof e !== \"string\") throw new TypeError(\"Expected a string\");\n        return micromatch.braces(e, { ...t,\n          expand: true\n        });\n      };\n\n      e.exports = micromatch;\n    },\n    601: (e, t, r) => {\n      e.exports = r(509);\n    },\n    871: (e, t, r) => {\n      const n = r(17);\n      const u = \"\\\\\\\\/\";\n      const s = `[^${u}]`;\n      const o = \"\\\\.\";\n      const i = \"\\\\+\";\n      const a = \"\\\\?\";\n      const l = \"\\\\/\";\n      const c = \"(?=.)\";\n      const p = \"[^/]\";\n      const f = `(?:${l}|$)`;\n      const A = `(?:^|${l})`;\n      const R = `${o}{1,2}${f}`;\n      const _ = `(?!${o})`;\n      const h = `(?!${A}${R})`;\n      const g = `(?!${o}{0,1}${f})`;\n      const E = `(?!${R})`;\n      const C = `[^.${l}]`;\n      const y = `${p}*?`;\n      const d = {\n        DOT_LITERAL: o,\n        PLUS_LITERAL: i,\n        QMARK_LITERAL: a,\n        SLASH_LITERAL: l,\n        ONE_CHAR: c,\n        QMARK: p,\n        END_ANCHOR: f,\n        DOTS_SLASH: R,\n        NO_DOT: _,\n        NO_DOTS: h,\n        NO_DOT_SLASH: g,\n        NO_DOTS_SLASH: E,\n        QMARK_NO_DOT: C,\n        STAR: y,\n        START_ANCHOR: A\n      };\n      const x = { ...d,\n        SLASH_LITERAL: `[${u}]`,\n        QMARK: s,\n        STAR: `${s}*?`,\n        DOTS_SLASH: `${o}{1,2}(?:[${u}]|$)`,\n        NO_DOT: `(?!${o})`,\n        NO_DOTS: `(?!(?:^|[${u}])${o}{1,2}(?:[${u}]|$))`,\n        NO_DOT_SLASH: `(?!${o}{0,1}(?:[${u}]|$))`,\n        NO_DOTS_SLASH: `(?!${o}{1,2}(?:[${u}]|$))`,\n        QMARK_NO_DOT: `[^.${u}]`,\n        START_ANCHOR: `(?:^|[${u}])`,\n        END_ANCHOR: `(?:[${u}]|$)`\n      };\n      const b = {\n        alnum: \"a-zA-Z0-9\",\n        alpha: \"a-zA-Z\",\n        ascii: \"\\\\x00-\\\\x7F\",\n        blank: \" \\\\t\",\n        cntrl: \"\\\\x00-\\\\x1F\\\\x7F\",\n        digit: \"0-9\",\n        graph: \"\\\\x21-\\\\x7E\",\n        lower: \"a-z\",\n        print: \"\\\\x20-\\\\x7E \",\n        punct: \"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",\n        space: \" \\\\t\\\\r\\\\n\\\\v\\\\f\",\n        upper: \"A-Z\",\n        word: \"A-Za-z0-9_\",\n        xdigit: \"A-Fa-f0-9\"\n      };\n      e.exports = {\n        MAX_LENGTH: 1024 * 64,\n        POSIX_REGEX_SOURCE: b,\n        REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n        REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n        REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n        REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n        REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n        REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n        REPLACEMENTS: {\n          \"***\": \"*\",\n          \"**/**\": \"**\",\n          \"**/**/**\": \"**\"\n        },\n        CHAR_0: 48,\n        CHAR_9: 57,\n        CHAR_UPPERCASE_A: 65,\n        CHAR_LOWERCASE_A: 97,\n        CHAR_UPPERCASE_Z: 90,\n        CHAR_LOWERCASE_Z: 122,\n        CHAR_LEFT_PARENTHESES: 40,\n        CHAR_RIGHT_PARENTHESES: 41,\n        CHAR_ASTERISK: 42,\n        CHAR_AMPERSAND: 38,\n        CHAR_AT: 64,\n        CHAR_BACKWARD_SLASH: 92,\n        CHAR_CARRIAGE_RETURN: 13,\n        CHAR_CIRCUMFLEX_ACCENT: 94,\n        CHAR_COLON: 58,\n        CHAR_COMMA: 44,\n        CHAR_DOT: 46,\n        CHAR_DOUBLE_QUOTE: 34,\n        CHAR_EQUAL: 61,\n        CHAR_EXCLAMATION_MARK: 33,\n        CHAR_FORM_FEED: 12,\n        CHAR_FORWARD_SLASH: 47,\n        CHAR_GRAVE_ACCENT: 96,\n        CHAR_HASH: 35,\n        CHAR_HYPHEN_MINUS: 45,\n        CHAR_LEFT_ANGLE_BRACKET: 60,\n        CHAR_LEFT_CURLY_BRACE: 123,\n        CHAR_LEFT_SQUARE_BRACKET: 91,\n        CHAR_LINE_FEED: 10,\n        CHAR_NO_BREAK_SPACE: 160,\n        CHAR_PERCENT: 37,\n        CHAR_PLUS: 43,\n        CHAR_QUESTION_MARK: 63,\n        CHAR_RIGHT_ANGLE_BRACKET: 62,\n        CHAR_RIGHT_CURLY_BRACE: 125,\n        CHAR_RIGHT_SQUARE_BRACKET: 93,\n        CHAR_SEMICOLON: 59,\n        CHAR_SINGLE_QUOTE: 39,\n        CHAR_SPACE: 32,\n        CHAR_TAB: 9,\n        CHAR_UNDERSCORE: 95,\n        CHAR_VERTICAL_LINE: 124,\n        CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n        SEP: n.sep,\n\n        extglobChars(e) {\n          return {\n            \"!\": {\n              type: \"negate\",\n              open: \"(?:(?!(?:\",\n              close: `))${e.STAR})`\n            },\n            \"?\": {\n              type: \"qmark\",\n              open: \"(?:\",\n              close: \")?\"\n            },\n            \"+\": {\n              type: \"plus\",\n              open: \"(?:\",\n              close: \")+\"\n            },\n            \"*\": {\n              type: \"star\",\n              open: \"(?:\",\n              close: \")*\"\n            },\n            \"@\": {\n              type: \"at\",\n              open: \"(?:\",\n              close: \")\"\n            }\n          };\n        },\n\n        globChars(e) {\n          return e === true ? x : d;\n        }\n\n      };\n    },\n    821: (e, t, r) => {\n      const n = r(871);\n      const u = r(243);\n      const {\n        MAX_LENGTH: s,\n        POSIX_REGEX_SOURCE: o,\n        REGEX_NON_SPECIAL_CHARS: i,\n        REGEX_SPECIAL_CHARS_BACKREF: a,\n        REPLACEMENTS: l\n      } = n;\n\n      const expandRange = (e, t) => {\n        if (typeof t.expandRange === \"function\") {\n          return t.expandRange(...e, t);\n        }\n\n        e.sort();\n        const r = `[${e.join(\"-\")}]`;\n\n        try {\n          new RegExp(r);\n        } catch (t) {\n          return e.map(e => u.escapeRegex(e)).join(\"..\");\n        }\n\n        return r;\n      };\n\n      const syntaxError = (e, t) => `Missing ${e}: \"${t}\" - use \"\\\\\\\\${t}\" to match literal characters`;\n\n      const parse = (e, t) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(\"Expected a string\");\n        }\n\n        e = l[e] || e;\n        const r = { ...t\n        };\n        const c = typeof r.maxLength === \"number\" ? Math.min(s, r.maxLength) : s;\n        let p = e.length;\n\n        if (p > c) {\n          throw new SyntaxError(`Input length: ${p}, exceeds maximum allowed length: ${c}`);\n        }\n\n        const f = {\n          type: \"bos\",\n          value: \"\",\n          output: r.prepend || \"\"\n        };\n        const A = [f];\n        const R = r.capture ? \"\" : \"?:\";\n\n        const _ = u.isWindows(t);\n\n        const h = n.globChars(_);\n        const g = n.extglobChars(h);\n        const {\n          DOT_LITERAL: E,\n          PLUS_LITERAL: C,\n          SLASH_LITERAL: y,\n          ONE_CHAR: d,\n          DOTS_SLASH: x,\n          NO_DOT: b,\n          NO_DOT_SLASH: S,\n          NO_DOTS_SLASH: H,\n          QMARK: v,\n          QMARK_NO_DOT: $,\n          STAR: m,\n          START_ANCHOR: T\n        } = h;\n\n        const globstar = e => `(${R}(?:(?!${T}${e.dot ? x : E}).)*?)`;\n\n        const L = r.dot ? \"\" : b;\n        const O = r.dot ? v : $;\n        let w = r.bash === true ? globstar(r) : m;\n\n        if (r.capture) {\n          w = `(${w})`;\n        }\n\n        if (typeof r.noext === \"boolean\") {\n          r.noextglob = r.noext;\n        }\n\n        const N = {\n          input: e,\n          index: -1,\n          start: 0,\n          dot: r.dot === true,\n          consumed: \"\",\n          output: \"\",\n          prefix: \"\",\n          backtrack: false,\n          negated: false,\n          brackets: 0,\n          braces: 0,\n          parens: 0,\n          quotes: 0,\n          globstar: false,\n          tokens: A\n        };\n        e = u.removePrefix(e, N);\n        p = e.length;\n        const k = [];\n        const I = [];\n        const M = [];\n        let P = f;\n        let B;\n\n        const eos = () => N.index === p - 1;\n\n        const G = N.peek = (t = 1) => e[N.index + t];\n\n        const D = N.advance = () => e[++N.index];\n\n        const remaining = () => e.slice(N.index + 1);\n\n        const consume = (e = \"\", t = 0) => {\n          N.consumed += e;\n          N.index += t;\n        };\n\n        const append = e => {\n          N.output += e.output != null ? e.output : e.value;\n          consume(e.value);\n        };\n\n        const negate = () => {\n          let e = 1;\n\n          while (G() === \"!\" && (G(2) !== \"(\" || G(3) === \"?\")) {\n            D();\n            N.start++;\n            e++;\n          }\n\n          if (e % 2 === 0) {\n            return false;\n          }\n\n          N.negated = true;\n          N.start++;\n          return true;\n        };\n\n        const increment = e => {\n          N[e]++;\n          M.push(e);\n        };\n\n        const decrement = e => {\n          N[e]--;\n          M.pop();\n        };\n\n        const push = e => {\n          if (P.type === \"globstar\") {\n            const t = N.braces > 0 && (e.type === \"comma\" || e.type === \"brace\");\n            const r = e.extglob === true || k.length && (e.type === \"pipe\" || e.type === \"paren\");\n\n            if (e.type !== \"slash\" && e.type !== \"paren\" && !t && !r) {\n              N.output = N.output.slice(0, -P.output.length);\n              P.type = \"star\";\n              P.value = \"*\";\n              P.output = w;\n              N.output += P.output;\n            }\n          }\n\n          if (k.length && e.type !== \"paren\" && !g[e.value]) {\n            k[k.length - 1].inner += e.value;\n          }\n\n          if (e.value || e.output) append(e);\n\n          if (P && P.type === \"text\" && e.type === \"text\") {\n            P.value += e.value;\n            P.output = (P.output || \"\") + e.value;\n            return;\n          }\n\n          e.prev = P;\n          A.push(e);\n          P = e;\n        };\n\n        const extglobOpen = (e, t) => {\n          const n = { ...g[t],\n            conditions: 1,\n            inner: \"\"\n          };\n          n.prev = P;\n          n.parens = N.parens;\n          n.output = N.output;\n          const u = (r.capture ? \"(\" : \"\") + n.open;\n          increment(\"parens\");\n          push({\n            type: e,\n            value: t,\n            output: N.output ? \"\" : d\n          });\n          push({\n            type: \"paren\",\n            extglob: true,\n            value: D(),\n            output: u\n          });\n          k.push(n);\n        };\n\n        const extglobClose = e => {\n          let t = e.close + (r.capture ? \")\" : \"\");\n\n          if (e.type === \"negate\") {\n            let n = w;\n\n            if (e.inner && e.inner.length > 1 && e.inner.includes(\"/\")) {\n              n = globstar(r);\n            }\n\n            if (n !== w || eos() || /^\\)+$/.test(remaining())) {\n              t = e.close = `)$))${n}`;\n            }\n\n            if (e.prev.type === \"bos\") {\n              N.negatedExtglob = true;\n            }\n          }\n\n          push({\n            type: \"paren\",\n            extglob: true,\n            value: B,\n            output: t\n          });\n          decrement(\"parens\");\n        };\n\n        if (r.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(e)) {\n          let n = false;\n          let s = e.replace(a, (e, t, r, u, s, o) => {\n            if (u === \"\\\\\") {\n              n = true;\n              return e;\n            }\n\n            if (u === \"?\") {\n              if (t) {\n                return t + u + (s ? v.repeat(s.length) : \"\");\n              }\n\n              if (o === 0) {\n                return O + (s ? v.repeat(s.length) : \"\");\n              }\n\n              return v.repeat(r.length);\n            }\n\n            if (u === \".\") {\n              return E.repeat(r.length);\n            }\n\n            if (u === \"*\") {\n              if (t) {\n                return t + u + (s ? w : \"\");\n              }\n\n              return w;\n            }\n\n            return t ? e : `\\\\${e}`;\n          });\n\n          if (n === true) {\n            if (r.unescape === true) {\n              s = s.replace(/\\\\/g, \"\");\n            } else {\n              s = s.replace(/\\\\+/g, e => e.length % 2 === 0 ? \"\\\\\\\\\" : e ? \"\\\\\" : \"\");\n            }\n          }\n\n          if (s === e && r.contains === true) {\n            N.output = e;\n            return N;\n          }\n\n          N.output = u.wrapOutput(s, N, t);\n          return N;\n        }\n\n        while (!eos()) {\n          B = D();\n\n          if (B === \"\\0\") {\n            continue;\n          }\n\n          if (B === \"\\\\\") {\n            const e = G();\n\n            if (e === \"/\" && r.bash !== true) {\n              continue;\n            }\n\n            if (e === \".\" || e === \";\") {\n              continue;\n            }\n\n            if (!e) {\n              B += \"\\\\\";\n              push({\n                type: \"text\",\n                value: B\n              });\n              continue;\n            }\n\n            const t = /^\\\\+/.exec(remaining());\n            let n = 0;\n\n            if (t && t[0].length > 2) {\n              n = t[0].length;\n              N.index += n;\n\n              if (n % 2 !== 0) {\n                B += \"\\\\\";\n              }\n            }\n\n            if (r.unescape === true) {\n              B = D() || \"\";\n            } else {\n              B += D() || \"\";\n            }\n\n            if (N.brackets === 0) {\n              push({\n                type: \"text\",\n                value: B\n              });\n              continue;\n            }\n          }\n\n          if (N.brackets > 0 && (B !== \"]\" || P.value === \"[\" || P.value === \"[^\")) {\n            if (r.posix !== false && B === \":\") {\n              const e = P.value.slice(1);\n\n              if (e.includes(\"[\")) {\n                P.posix = true;\n\n                if (e.includes(\":\")) {\n                  const e = P.value.lastIndexOf(\"[\");\n                  const t = P.value.slice(0, e);\n                  const r = P.value.slice(e + 2);\n                  const n = o[r];\n\n                  if (n) {\n                    P.value = t + n;\n                    N.backtrack = true;\n                    D();\n\n                    if (!f.output && A.indexOf(P) === 1) {\n                      f.output = d;\n                    }\n\n                    continue;\n                  }\n                }\n              }\n            }\n\n            if (B === \"[\" && G() !== \":\" || B === \"-\" && G() === \"]\") {\n              B = `\\\\${B}`;\n            }\n\n            if (B === \"]\" && (P.value === \"[\" || P.value === \"[^\")) {\n              B = `\\\\${B}`;\n            }\n\n            if (r.posix === true && B === \"!\" && P.value === \"[\") {\n              B = \"^\";\n            }\n\n            P.value += B;\n            append({\n              value: B\n            });\n            continue;\n          }\n\n          if (N.quotes === 1 && B !== '\"') {\n            B = u.escapeRegex(B);\n            P.value += B;\n            append({\n              value: B\n            });\n            continue;\n          }\n\n          if (B === '\"') {\n            N.quotes = N.quotes === 1 ? 0 : 1;\n\n            if (r.keepQuotes === true) {\n              push({\n                type: \"text\",\n                value: B\n              });\n            }\n\n            continue;\n          }\n\n          if (B === \"(\") {\n            increment(\"parens\");\n            push({\n              type: \"paren\",\n              value: B\n            });\n            continue;\n          }\n\n          if (B === \")\") {\n            if (N.parens === 0 && r.strictBrackets === true) {\n              throw new SyntaxError(syntaxError(\"opening\", \"(\"));\n            }\n\n            const e = k[k.length - 1];\n\n            if (e && N.parens === e.parens + 1) {\n              extglobClose(k.pop());\n              continue;\n            }\n\n            push({\n              type: \"paren\",\n              value: B,\n              output: N.parens ? \")\" : \"\\\\)\"\n            });\n            decrement(\"parens\");\n            continue;\n          }\n\n          if (B === \"[\") {\n            if (r.nobracket === true || !remaining().includes(\"]\")) {\n              if (r.nobracket !== true && r.strictBrackets === true) {\n                throw new SyntaxError(syntaxError(\"closing\", \"]\"));\n              }\n\n              B = `\\\\${B}`;\n            } else {\n              increment(\"brackets\");\n            }\n\n            push({\n              type: \"bracket\",\n              value: B\n            });\n            continue;\n          }\n\n          if (B === \"]\") {\n            if (r.nobracket === true || P && P.type === \"bracket\" && P.value.length === 1) {\n              push({\n                type: \"text\",\n                value: B,\n                output: `\\\\${B}`\n              });\n              continue;\n            }\n\n            if (N.brackets === 0) {\n              if (r.strictBrackets === true) {\n                throw new SyntaxError(syntaxError(\"opening\", \"[\"));\n              }\n\n              push({\n                type: \"text\",\n                value: B,\n                output: `\\\\${B}`\n              });\n              continue;\n            }\n\n            decrement(\"brackets\");\n            const e = P.value.slice(1);\n\n            if (P.posix !== true && e[0] === \"^\" && !e.includes(\"/\")) {\n              B = `/${B}`;\n            }\n\n            P.value += B;\n            append({\n              value: B\n            });\n\n            if (r.literalBrackets === false || u.hasRegexChars(e)) {\n              continue;\n            }\n\n            const t = u.escapeRegex(P.value);\n            N.output = N.output.slice(0, -P.value.length);\n\n            if (r.literalBrackets === true) {\n              N.output += t;\n              P.value = t;\n              continue;\n            }\n\n            P.value = `(${R}${t}|${P.value})`;\n            N.output += P.value;\n            continue;\n          }\n\n          if (B === \"{\" && r.nobrace !== true) {\n            increment(\"braces\");\n            const e = {\n              type: \"brace\",\n              value: B,\n              output: \"(\",\n              outputIndex: N.output.length,\n              tokensIndex: N.tokens.length\n            };\n            I.push(e);\n            push(e);\n            continue;\n          }\n\n          if (B === \"}\") {\n            const e = I[I.length - 1];\n\n            if (r.nobrace === true || !e) {\n              push({\n                type: \"text\",\n                value: B,\n                output: B\n              });\n              continue;\n            }\n\n            let t = \")\";\n\n            if (e.dots === true) {\n              const e = A.slice();\n              const n = [];\n\n              for (let t = e.length - 1; t >= 0; t--) {\n                A.pop();\n\n                if (e[t].type === \"brace\") {\n                  break;\n                }\n\n                if (e[t].type !== \"dots\") {\n                  n.unshift(e[t].value);\n                }\n              }\n\n              t = expandRange(n, r);\n              N.backtrack = true;\n            }\n\n            if (e.comma !== true && e.dots !== true) {\n              const r = N.output.slice(0, e.outputIndex);\n              const n = N.tokens.slice(e.tokensIndex);\n              e.value = e.output = \"\\\\{\";\n              B = t = \"\\\\}\";\n              N.output = r;\n\n              for (const e of n) {\n                N.output += e.output || e.value;\n              }\n            }\n\n            push({\n              type: \"brace\",\n              value: B,\n              output: t\n            });\n            decrement(\"braces\");\n            I.pop();\n            continue;\n          }\n\n          if (B === \"|\") {\n            if (k.length > 0) {\n              k[k.length - 1].conditions++;\n            }\n\n            push({\n              type: \"text\",\n              value: B\n            });\n            continue;\n          }\n\n          if (B === \",\") {\n            let e = B;\n            const t = I[I.length - 1];\n\n            if (t && M[M.length - 1] === \"braces\") {\n              t.comma = true;\n              e = \"|\";\n            }\n\n            push({\n              type: \"comma\",\n              value: B,\n              output: e\n            });\n            continue;\n          }\n\n          if (B === \"/\") {\n            if (P.type === \"dot\" && N.index === N.start + 1) {\n              N.start = N.index + 1;\n              N.consumed = \"\";\n              N.output = \"\";\n              A.pop();\n              P = f;\n              continue;\n            }\n\n            push({\n              type: \"slash\",\n              value: B,\n              output: y\n            });\n            continue;\n          }\n\n          if (B === \".\") {\n            if (N.braces > 0 && P.type === \"dot\") {\n              if (P.value === \".\") P.output = E;\n              const e = I[I.length - 1];\n              P.type = \"dots\";\n              P.output += B;\n              P.value += B;\n              e.dots = true;\n              continue;\n            }\n\n            if (N.braces + N.parens === 0 && P.type !== \"bos\" && P.type !== \"slash\") {\n              push({\n                type: \"text\",\n                value: B,\n                output: E\n              });\n              continue;\n            }\n\n            push({\n              type: \"dot\",\n              value: B,\n              output: E\n            });\n            continue;\n          }\n\n          if (B === \"?\") {\n            const e = P && P.value === \"(\";\n\n            if (!e && r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n              extglobOpen(\"qmark\", B);\n              continue;\n            }\n\n            if (P && P.type === \"paren\") {\n              const e = G();\n              let t = B;\n\n              if (e === \"<\" && !u.supportsLookbehinds()) {\n                throw new Error(\"Node.js v10 or higher is required for regex lookbehinds\");\n              }\n\n              if (P.value === \"(\" && !/[!=<:]/.test(e) || e === \"<\" && !/<([!=]|\\w+>)/.test(remaining())) {\n                t = `\\\\${B}`;\n              }\n\n              push({\n                type: \"text\",\n                value: B,\n                output: t\n              });\n              continue;\n            }\n\n            if (r.dot !== true && (P.type === \"slash\" || P.type === \"bos\")) {\n              push({\n                type: \"qmark\",\n                value: B,\n                output: $\n              });\n              continue;\n            }\n\n            push({\n              type: \"qmark\",\n              value: B,\n              output: v\n            });\n            continue;\n          }\n\n          if (B === \"!\") {\n            if (r.noextglob !== true && G() === \"(\") {\n              if (G(2) !== \"?\" || !/[!=<:]/.test(G(3))) {\n                extglobOpen(\"negate\", B);\n                continue;\n              }\n            }\n\n            if (r.nonegate !== true && N.index === 0) {\n              negate();\n              continue;\n            }\n          }\n\n          if (B === \"+\") {\n            if (r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n              extglobOpen(\"plus\", B);\n              continue;\n            }\n\n            if (P && P.value === \"(\" || r.regex === false) {\n              push({\n                type: \"plus\",\n                value: B,\n                output: C\n              });\n              continue;\n            }\n\n            if (P && (P.type === \"bracket\" || P.type === \"paren\" || P.type === \"brace\") || N.parens > 0) {\n              push({\n                type: \"plus\",\n                value: B\n              });\n              continue;\n            }\n\n            push({\n              type: \"plus\",\n              value: C\n            });\n            continue;\n          }\n\n          if (B === \"@\") {\n            if (r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n              push({\n                type: \"at\",\n                extglob: true,\n                value: B,\n                output: \"\"\n              });\n              continue;\n            }\n\n            push({\n              type: \"text\",\n              value: B\n            });\n            continue;\n          }\n\n          if (B !== \"*\") {\n            if (B === \"$\" || B === \"^\") {\n              B = `\\\\${B}`;\n            }\n\n            const e = i.exec(remaining());\n\n            if (e) {\n              B += e[0];\n              N.index += e[0].length;\n            }\n\n            push({\n              type: \"text\",\n              value: B\n            });\n            continue;\n          }\n\n          if (P && (P.type === \"globstar\" || P.star === true)) {\n            P.type = \"star\";\n            P.star = true;\n            P.value += B;\n            P.output = w;\n            N.backtrack = true;\n            N.globstar = true;\n            consume(B);\n            continue;\n          }\n\n          let t = remaining();\n\n          if (r.noextglob !== true && /^\\([^?]/.test(t)) {\n            extglobOpen(\"star\", B);\n            continue;\n          }\n\n          if (P.type === \"star\") {\n            if (r.noglobstar === true) {\n              consume(B);\n              continue;\n            }\n\n            const n = P.prev;\n            const u = n.prev;\n            const s = n.type === \"slash\" || n.type === \"bos\";\n            const o = u && (u.type === \"star\" || u.type === \"globstar\");\n\n            if (r.bash === true && (!s || t[0] && t[0] !== \"/\")) {\n              push({\n                type: \"star\",\n                value: B,\n                output: \"\"\n              });\n              continue;\n            }\n\n            const i = N.braces > 0 && (n.type === \"comma\" || n.type === \"brace\");\n            const a = k.length && (n.type === \"pipe\" || n.type === \"paren\");\n\n            if (!s && n.type !== \"paren\" && !i && !a) {\n              push({\n                type: \"star\",\n                value: B,\n                output: \"\"\n              });\n              continue;\n            }\n\n            while (t.slice(0, 3) === \"/**\") {\n              const r = e[N.index + 4];\n\n              if (r && r !== \"/\") {\n                break;\n              }\n\n              t = t.slice(3);\n              consume(\"/**\", 3);\n            }\n\n            if (n.type === \"bos\" && eos()) {\n              P.type = \"globstar\";\n              P.value += B;\n              P.output = globstar(r);\n              N.output = P.output;\n              N.globstar = true;\n              consume(B);\n              continue;\n            }\n\n            if (n.type === \"slash\" && n.prev.type !== \"bos\" && !o && eos()) {\n              N.output = N.output.slice(0, -(n.output + P.output).length);\n              n.output = `(?:${n.output}`;\n              P.type = \"globstar\";\n              P.output = globstar(r) + (r.strictSlashes ? \")\" : \"|$)\");\n              P.value += B;\n              N.globstar = true;\n              N.output += n.output + P.output;\n              consume(B);\n              continue;\n            }\n\n            if (n.type === \"slash\" && n.prev.type !== \"bos\" && t[0] === \"/\") {\n              const e = t[1] !== void 0 ? \"|$\" : \"\";\n              N.output = N.output.slice(0, -(n.output + P.output).length);\n              n.output = `(?:${n.output}`;\n              P.type = \"globstar\";\n              P.output = `${globstar(r)}${y}|${y}${e})`;\n              P.value += B;\n              N.output += n.output + P.output;\n              N.globstar = true;\n              consume(B + D());\n              push({\n                type: \"slash\",\n                value: \"/\",\n                output: \"\"\n              });\n              continue;\n            }\n\n            if (n.type === \"bos\" && t[0] === \"/\") {\n              P.type = \"globstar\";\n              P.value += B;\n              P.output = `(?:^|${y}|${globstar(r)}${y})`;\n              N.output = P.output;\n              N.globstar = true;\n              consume(B + D());\n              push({\n                type: \"slash\",\n                value: \"/\",\n                output: \"\"\n              });\n              continue;\n            }\n\n            N.output = N.output.slice(0, -P.output.length);\n            P.type = \"globstar\";\n            P.output = globstar(r);\n            P.value += B;\n            N.output += P.output;\n            N.globstar = true;\n            consume(B);\n            continue;\n          }\n\n          const n = {\n            type: \"star\",\n            value: B,\n            output: w\n          };\n\n          if (r.bash === true) {\n            n.output = \".*?\";\n\n            if (P.type === \"bos\" || P.type === \"slash\") {\n              n.output = L + n.output;\n            }\n\n            push(n);\n            continue;\n          }\n\n          if (P && (P.type === \"bracket\" || P.type === \"paren\") && r.regex === true) {\n            n.output = B;\n            push(n);\n            continue;\n          }\n\n          if (N.index === N.start || P.type === \"slash\" || P.type === \"dot\") {\n            if (P.type === \"dot\") {\n              N.output += S;\n              P.output += S;\n            } else if (r.dot === true) {\n              N.output += H;\n              P.output += H;\n            } else {\n              N.output += L;\n              P.output += L;\n            }\n\n            if (G() !== \"*\") {\n              N.output += d;\n              P.output += d;\n            }\n          }\n\n          push(n);\n        }\n\n        while (N.brackets > 0) {\n          if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \"]\"));\n          N.output = u.escapeLast(N.output, \"[\");\n          decrement(\"brackets\");\n        }\n\n        while (N.parens > 0) {\n          if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \")\"));\n          N.output = u.escapeLast(N.output, \"(\");\n          decrement(\"parens\");\n        }\n\n        while (N.braces > 0) {\n          if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \"}\"));\n          N.output = u.escapeLast(N.output, \"{\");\n          decrement(\"braces\");\n        }\n\n        if (r.strictSlashes !== true && (P.type === \"star\" || P.type === \"bracket\")) {\n          push({\n            type: \"maybe_slash\",\n            value: \"\",\n            output: `${y}?`\n          });\n        }\n\n        if (N.backtrack === true) {\n          N.output = \"\";\n\n          for (const e of N.tokens) {\n            N.output += e.output != null ? e.output : e.value;\n\n            if (e.suffix) {\n              N.output += e.suffix;\n            }\n          }\n        }\n\n        return N;\n      };\n\n      parse.fastpaths = (e, t) => {\n        const r = { ...t\n        };\n        const o = typeof r.maxLength === \"number\" ? Math.min(s, r.maxLength) : s;\n        const i = e.length;\n\n        if (i > o) {\n          throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${o}`);\n        }\n\n        e = l[e] || e;\n        const a = u.isWindows(t);\n        const {\n          DOT_LITERAL: c,\n          SLASH_LITERAL: p,\n          ONE_CHAR: f,\n          DOTS_SLASH: A,\n          NO_DOT: R,\n          NO_DOTS: _,\n          NO_DOTS_SLASH: h,\n          STAR: g,\n          START_ANCHOR: E\n        } = n.globChars(a);\n        const C = r.dot ? _ : R;\n        const y = r.dot ? h : R;\n        const d = r.capture ? \"\" : \"?:\";\n        const x = {\n          negated: false,\n          prefix: \"\"\n        };\n        let b = r.bash === true ? \".*?\" : g;\n\n        if (r.capture) {\n          b = `(${b})`;\n        }\n\n        const globstar = e => {\n          if (e.noglobstar === true) return b;\n          return `(${d}(?:(?!${E}${e.dot ? A : c}).)*?)`;\n        };\n\n        const create = e => {\n          switch (e) {\n            case \"*\":\n              return `${C}${f}${b}`;\n\n            case \".*\":\n              return `${c}${f}${b}`;\n\n            case \"*.*\":\n              return `${C}${b}${c}${f}${b}`;\n\n            case \"*/*\":\n              return `${C}${b}${p}${f}${y}${b}`;\n\n            case \"**\":\n              return C + globstar(r);\n\n            case \"**/*\":\n              return `(?:${C}${globstar(r)}${p})?${y}${f}${b}`;\n\n            case \"**/*.*\":\n              return `(?:${C}${globstar(r)}${p})?${y}${b}${c}${f}${b}`;\n\n            case \"**/.*\":\n              return `(?:${C}${globstar(r)}${p})?${c}${f}${b}`;\n\n            default:\n              {\n                const t = /^(.*?)\\.(\\w+)$/.exec(e);\n                if (!t) return;\n                const r = create(t[1]);\n                if (!r) return;\n                return r + c + t[2];\n              }\n          }\n        };\n\n        const S = u.removePrefix(e, x);\n        let H = create(S);\n\n        if (H && r.strictSlashes !== true) {\n          H += `${p}?`;\n        }\n\n        return H;\n      };\n\n      e.exports = parse;\n    },\n    509: (e, t, r) => {\n      const n = r(17);\n      const u = r(216);\n      const s = r(821);\n      const o = r(243);\n      const i = r(871);\n\n      const isObject = e => e && typeof e === \"object\" && !Array.isArray(e);\n\n      const picomatch = (e, t, r = false) => {\n        if (Array.isArray(e)) {\n          const n = e.map(e => picomatch(e, t, r));\n\n          const arrayMatcher = e => {\n            for (const t of n) {\n              const r = t(e);\n              if (r) return r;\n            }\n\n            return false;\n          };\n\n          return arrayMatcher;\n        }\n\n        const n = isObject(e) && e.tokens && e.input;\n\n        if (e === \"\" || typeof e !== \"string\" && !n) {\n          throw new TypeError(\"Expected pattern to be a non-empty string\");\n        }\n\n        const u = t || {};\n        const s = o.isWindows(t);\n        const i = n ? picomatch.compileRe(e, t) : picomatch.makeRe(e, t, false, true);\n        const a = i.state;\n        delete i.state;\n\n        let isIgnored = () => false;\n\n        if (u.ignore) {\n          const e = { ...t,\n            ignore: null,\n            onMatch: null,\n            onResult: null\n          };\n          isIgnored = picomatch(u.ignore, e, r);\n        }\n\n        const matcher = (r, n = false) => {\n          const {\n            isMatch: o,\n            match: l,\n            output: c\n          } = picomatch.test(r, i, t, {\n            glob: e,\n            posix: s\n          });\n          const p = {\n            glob: e,\n            state: a,\n            regex: i,\n            posix: s,\n            input: r,\n            output: c,\n            match: l,\n            isMatch: o\n          };\n\n          if (typeof u.onResult === \"function\") {\n            u.onResult(p);\n          }\n\n          if (o === false) {\n            p.isMatch = false;\n            return n ? p : false;\n          }\n\n          if (isIgnored(r)) {\n            if (typeof u.onIgnore === \"function\") {\n              u.onIgnore(p);\n            }\n\n            p.isMatch = false;\n            return n ? p : false;\n          }\n\n          if (typeof u.onMatch === \"function\") {\n            u.onMatch(p);\n          }\n\n          return n ? p : true;\n        };\n\n        if (r) {\n          matcher.state = a;\n        }\n\n        return matcher;\n      };\n\n      picomatch.test = (e, t, r, {\n        glob: n,\n        posix: u\n      } = {}) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(\"Expected input to be a string\");\n        }\n\n        if (e === \"\") {\n          return {\n            isMatch: false,\n            output: \"\"\n          };\n        }\n\n        const s = r || {};\n        const i = s.format || (u ? o.toPosixSlashes : null);\n        let a = e === n;\n        let l = a && i ? i(e) : e;\n\n        if (a === false) {\n          l = i ? i(e) : e;\n          a = l === n;\n        }\n\n        if (a === false || s.capture === true) {\n          if (s.matchBase === true || s.basename === true) {\n            a = picomatch.matchBase(e, t, r, u);\n          } else {\n            a = t.exec(l);\n          }\n        }\n\n        return {\n          isMatch: Boolean(a),\n          match: a,\n          output: l\n        };\n      };\n\n      picomatch.matchBase = (e, t, r, u = o.isWindows(r)) => {\n        const s = t instanceof RegExp ? t : picomatch.makeRe(t, r);\n        return s.test(n.basename(e));\n      };\n\n      picomatch.isMatch = (e, t, r) => picomatch(t, r)(e);\n\n      picomatch.parse = (e, t) => {\n        if (Array.isArray(e)) return e.map(e => picomatch.parse(e, t));\n        return s(e, { ...t,\n          fastpaths: false\n        });\n      };\n\n      picomatch.scan = (e, t) => u(e, t);\n\n      picomatch.compileRe = (e, t, r = false, n = false) => {\n        if (r === true) {\n          return e.output;\n        }\n\n        const u = t || {};\n        const s = u.contains ? \"\" : \"^\";\n        const o = u.contains ? \"\" : \"$\";\n        let i = `${s}(?:${e.output})${o}`;\n\n        if (e && e.negated === true) {\n          i = `^(?!${i}).*$`;\n        }\n\n        const a = picomatch.toRegex(i, t);\n\n        if (n === true) {\n          a.state = e;\n        }\n\n        return a;\n      };\n\n      picomatch.makeRe = (e, t, r = false, n = false) => {\n        if (!e || typeof e !== \"string\") {\n          throw new TypeError(\"Expected a non-empty string\");\n        }\n\n        const u = t || {};\n        let o = {\n          negated: false,\n          fastpaths: true\n        };\n        let i = \"\";\n        let a;\n\n        if (e.startsWith(\"./\")) {\n          e = e.slice(2);\n          i = o.prefix = \"./\";\n        }\n\n        if (u.fastpaths !== false && (e[0] === \".\" || e[0] === \"*\")) {\n          a = s.fastpaths(e, t);\n        }\n\n        if (a === undefined) {\n          o = s(e, t);\n          o.prefix = i + (o.prefix || \"\");\n        } else {\n          o.output = a;\n        }\n\n        return picomatch.compileRe(o, t, r, n);\n      };\n\n      picomatch.toRegex = (e, t) => {\n        try {\n          const r = t || {};\n          return new RegExp(e, r.flags || (r.nocase ? \"i\" : \"\"));\n        } catch (e) {\n          if (t && t.debug === true) throw e;\n          return /$^/;\n        }\n      };\n\n      picomatch.constants = i;\n      e.exports = picomatch;\n    },\n    216: (e, t, r) => {\n      const n = r(243);\n      const {\n        CHAR_ASTERISK: u,\n        CHAR_AT: s,\n        CHAR_BACKWARD_SLASH: o,\n        CHAR_COMMA: i,\n        CHAR_DOT: a,\n        CHAR_EXCLAMATION_MARK: l,\n        CHAR_FORWARD_SLASH: c,\n        CHAR_LEFT_CURLY_BRACE: p,\n        CHAR_LEFT_PARENTHESES: f,\n        CHAR_LEFT_SQUARE_BRACKET: A,\n        CHAR_PLUS: R,\n        CHAR_QUESTION_MARK: _,\n        CHAR_RIGHT_CURLY_BRACE: h,\n        CHAR_RIGHT_PARENTHESES: g,\n        CHAR_RIGHT_SQUARE_BRACKET: E\n      } = r(871);\n\n      const isPathSeparator = e => e === c || e === o;\n\n      const depth = e => {\n        if (e.isPrefix !== true) {\n          e.depth = e.isGlobstar ? Infinity : 1;\n        }\n      };\n\n      const scan = (e, t) => {\n        const r = t || {};\n        const C = e.length - 1;\n        const y = r.parts === true || r.scanToEnd === true;\n        const d = [];\n        const x = [];\n        const b = [];\n        let S = e;\n        let H = -1;\n        let v = 0;\n        let $ = 0;\n        let m = false;\n        let T = false;\n        let L = false;\n        let O = false;\n        let w = false;\n        let N = false;\n        let k = false;\n        let I = false;\n        let M = false;\n        let P = 0;\n        let B;\n        let G;\n        let D = {\n          value: \"\",\n          depth: 0,\n          isGlob: false\n        };\n\n        const eos = () => H >= C;\n\n        const peek = () => S.charCodeAt(H + 1);\n\n        const advance = () => {\n          B = G;\n          return S.charCodeAt(++H);\n        };\n\n        while (H < C) {\n          G = advance();\n          let e;\n\n          if (G === o) {\n            k = D.backslashes = true;\n            G = advance();\n\n            if (G === p) {\n              N = true;\n            }\n\n            continue;\n          }\n\n          if (N === true || G === p) {\n            P++;\n\n            while (eos() !== true && (G = advance())) {\n              if (G === o) {\n                k = D.backslashes = true;\n                advance();\n                continue;\n              }\n\n              if (G === p) {\n                P++;\n                continue;\n              }\n\n              if (N !== true && G === a && (G = advance()) === a) {\n                m = D.isBrace = true;\n                L = D.isGlob = true;\n                M = true;\n\n                if (y === true) {\n                  continue;\n                }\n\n                break;\n              }\n\n              if (N !== true && G === i) {\n                m = D.isBrace = true;\n                L = D.isGlob = true;\n                M = true;\n\n                if (y === true) {\n                  continue;\n                }\n\n                break;\n              }\n\n              if (G === h) {\n                P--;\n\n                if (P === 0) {\n                  N = false;\n                  m = D.isBrace = true;\n                  M = true;\n                  break;\n                }\n              }\n            }\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n\n          if (G === c) {\n            d.push(H);\n            x.push(D);\n            D = {\n              value: \"\",\n              depth: 0,\n              isGlob: false\n            };\n            if (M === true) continue;\n\n            if (B === a && H === v + 1) {\n              v += 2;\n              continue;\n            }\n\n            $ = H + 1;\n            continue;\n          }\n\n          if (r.noext !== true) {\n            const e = G === R || G === s || G === u || G === _ || G === l;\n\n            if (e === true && peek() === f) {\n              L = D.isGlob = true;\n              O = D.isExtglob = true;\n              M = true;\n\n              if (y === true) {\n                while (eos() !== true && (G = advance())) {\n                  if (G === o) {\n                    k = D.backslashes = true;\n                    G = advance();\n                    continue;\n                  }\n\n                  if (G === g) {\n                    L = D.isGlob = true;\n                    M = true;\n                    break;\n                  }\n                }\n\n                continue;\n              }\n\n              break;\n            }\n          }\n\n          if (G === u) {\n            if (B === u) w = D.isGlobstar = true;\n            L = D.isGlob = true;\n            M = true;\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n\n          if (G === _) {\n            L = D.isGlob = true;\n            M = true;\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n\n          if (G === A) {\n            while (eos() !== true && (e = advance())) {\n              if (e === o) {\n                k = D.backslashes = true;\n                advance();\n                continue;\n              }\n\n              if (e === E) {\n                T = D.isBracket = true;\n                L = D.isGlob = true;\n                M = true;\n                break;\n              }\n            }\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n\n          if (r.nonegate !== true && G === l && H === v) {\n            I = D.negated = true;\n            v++;\n            continue;\n          }\n\n          if (r.noparen !== true && G === f) {\n            L = D.isGlob = true;\n\n            if (y === true) {\n              while (eos() !== true && (G = advance())) {\n                if (G === f) {\n                  k = D.backslashes = true;\n                  G = advance();\n                  continue;\n                }\n\n                if (G === g) {\n                  M = true;\n                  break;\n                }\n              }\n\n              continue;\n            }\n\n            break;\n          }\n\n          if (L === true) {\n            M = true;\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n        }\n\n        if (r.noext === true) {\n          O = false;\n          L = false;\n        }\n\n        let U = S;\n        let K = \"\";\n        let F = \"\";\n\n        if (v > 0) {\n          K = S.slice(0, v);\n          S = S.slice(v);\n          $ -= v;\n        }\n\n        if (U && L === true && $ > 0) {\n          U = S.slice(0, $);\n          F = S.slice($);\n        } else if (L === true) {\n          U = \"\";\n          F = S;\n        } else {\n          U = S;\n        }\n\n        if (U && U !== \"\" && U !== \"/\" && U !== S) {\n          if (isPathSeparator(U.charCodeAt(U.length - 1))) {\n            U = U.slice(0, -1);\n          }\n        }\n\n        if (r.unescape === true) {\n          if (F) F = n.removeBackslashes(F);\n\n          if (U && k === true) {\n            U = n.removeBackslashes(U);\n          }\n        }\n\n        const Q = {\n          prefix: K,\n          input: e,\n          start: v,\n          base: U,\n          glob: F,\n          isBrace: m,\n          isBracket: T,\n          isGlob: L,\n          isExtglob: O,\n          isGlobstar: w,\n          negated: I\n        };\n\n        if (r.tokens === true) {\n          Q.maxDepth = 0;\n\n          if (!isPathSeparator(G)) {\n            x.push(D);\n          }\n\n          Q.tokens = x;\n        }\n\n        if (r.parts === true || r.tokens === true) {\n          let t;\n\n          for (let n = 0; n < d.length; n++) {\n            const u = t ? t + 1 : v;\n            const s = d[n];\n            const o = e.slice(u, s);\n\n            if (r.tokens) {\n              if (n === 0 && v !== 0) {\n                x[n].isPrefix = true;\n                x[n].value = K;\n              } else {\n                x[n].value = o;\n              }\n\n              depth(x[n]);\n              Q.maxDepth += x[n].depth;\n            }\n\n            if (n !== 0 || o !== \"\") {\n              b.push(o);\n            }\n\n            t = s;\n          }\n\n          if (t && t + 1 < e.length) {\n            const n = e.slice(t + 1);\n            b.push(n);\n\n            if (r.tokens) {\n              x[x.length - 1].value = n;\n              depth(x[x.length - 1]);\n              Q.maxDepth += x[x.length - 1].depth;\n            }\n          }\n\n          Q.slashes = d;\n          Q.parts = b;\n        }\n\n        return Q;\n      };\n\n      e.exports = scan;\n    },\n    243: (e, t, r) => {\n      const n = r(17);\n      const u = process.platform === \"win32\";\n      const {\n        REGEX_BACKSLASH: s,\n        REGEX_REMOVE_BACKSLASH: o,\n        REGEX_SPECIAL_CHARS: i,\n        REGEX_SPECIAL_CHARS_GLOBAL: a\n      } = r(871);\n\n      t.isObject = e => e !== null && typeof e === \"object\" && !Array.isArray(e);\n\n      t.hasRegexChars = e => i.test(e);\n\n      t.isRegexChar = e => e.length === 1 && t.hasRegexChars(e);\n\n      t.escapeRegex = e => e.replace(a, \"\\\\$1\");\n\n      t.toPosixSlashes = e => e.replace(s, \"/\");\n\n      t.removeBackslashes = e => e.replace(o, e => e === \"\\\\\" ? \"\" : e);\n\n      t.supportsLookbehinds = () => {\n        const e = process.version.slice(1).split(\".\").map(Number);\n\n        if (e.length === 3 && e[0] >= 9 || e[0] === 8 && e[1] >= 10) {\n          return true;\n        }\n\n        return false;\n      };\n\n      t.isWindows = e => {\n        if (e && typeof e.windows === \"boolean\") {\n          return e.windows;\n        }\n\n        return u === true || n.sep === \"\\\\\";\n      };\n\n      t.escapeLast = (e, r, n) => {\n        const u = e.lastIndexOf(r, n);\n        if (u === -1) return e;\n        if (e[u - 1] === \"\\\\\") return t.escapeLast(e, r, u - 1);\n        return `${e.slice(0, u)}\\\\${e.slice(u)}`;\n      };\n\n      t.removePrefix = (e, t = {}) => {\n        let r = e;\n\n        if (r.startsWith(\"./\")) {\n          r = r.slice(2);\n          t.prefix = \"./\";\n        }\n\n        return r;\n      };\n\n      t.wrapOutput = (e, t = {}, r = {}) => {\n        const n = r.contains ? \"\" : \"^\";\n        const u = r.contains ? \"\" : \"$\";\n        let s = `${n}(?:${e})${u}`;\n\n        if (t.negated === true) {\n          s = `(?:^(?!${s}).*$)`;\n        }\n\n        return s;\n      };\n    },\n    368: (e, t, r) => {\n      /*!\n       * to-regex-range <https://github.com/micromatch/to-regex-range>\n       *\n       * Copyright (c) 2015-present, Jon Schlinkert.\n       * Released under the MIT License.\n       */\n      const n = r(773);\n\n      const toRegexRange = (e, t, r) => {\n        if (n(e) === false) {\n          throw new TypeError(\"toRegexRange: expected the first argument to be a number\");\n        }\n\n        if (t === void 0 || e === t) {\n          return String(e);\n        }\n\n        if (n(t) === false) {\n          throw new TypeError(\"toRegexRange: expected the second argument to be a number.\");\n        }\n\n        let u = {\n          relaxZeros: true,\n          ...r\n        };\n\n        if (typeof u.strictZeros === \"boolean\") {\n          u.relaxZeros = u.strictZeros === false;\n        }\n\n        let s = String(u.relaxZeros);\n        let o = String(u.shorthand);\n        let i = String(u.capture);\n        let a = String(u.wrap);\n        let l = e + \":\" + t + \"=\" + s + o + i + a;\n\n        if (toRegexRange.cache.hasOwnProperty(l)) {\n          return toRegexRange.cache[l].result;\n        }\n\n        let c = Math.min(e, t);\n        let p = Math.max(e, t);\n\n        if (Math.abs(c - p) === 1) {\n          let r = e + \"|\" + t;\n\n          if (u.capture) {\n            return `(${r})`;\n          }\n\n          if (u.wrap === false) {\n            return r;\n          }\n\n          return `(?:${r})`;\n        }\n\n        let f = hasPadding(e) || hasPadding(t);\n        let A = {\n          min: e,\n          max: t,\n          a: c,\n          b: p\n        };\n        let R = [];\n        let _ = [];\n\n        if (f) {\n          A.isPadded = f;\n          A.maxLen = String(A.max).length;\n        }\n\n        if (c < 0) {\n          let e = p < 0 ? Math.abs(p) : 1;\n          _ = splitToPatterns(e, Math.abs(c), A, u);\n          c = A.a = 0;\n        }\n\n        if (p >= 0) {\n          R = splitToPatterns(c, p, A, u);\n        }\n\n        A.negatives = _;\n        A.positives = R;\n        A.result = collatePatterns(_, R, u);\n\n        if (u.capture === true) {\n          A.result = `(${A.result})`;\n        } else if (u.wrap !== false && R.length + _.length > 1) {\n          A.result = `(?:${A.result})`;\n        }\n\n        toRegexRange.cache[l] = A;\n        return A.result;\n      };\n\n      function collatePatterns(e, t, r) {\n        let n = filterPatterns(e, t, \"-\", false, r) || [];\n        let u = filterPatterns(t, e, \"\", false, r) || [];\n        let s = filterPatterns(e, t, \"-?\", true, r) || [];\n        let o = n.concat(s).concat(u);\n        return o.join(\"|\");\n      }\n\n      function splitToRanges(e, t) {\n        let r = 1;\n        let n = 1;\n        let u = countNines(e, r);\n        let s = new Set([t]);\n\n        while (e <= u && u <= t) {\n          s.add(u);\n          r += 1;\n          u = countNines(e, r);\n        }\n\n        u = countZeros(t + 1, n) - 1;\n\n        while (e < u && u <= t) {\n          s.add(u);\n          n += 1;\n          u = countZeros(t + 1, n) - 1;\n        }\n\n        s = [...s];\n        s.sort(compare);\n        return s;\n      }\n\n      function rangeToPattern(e, t, r) {\n        if (e === t) {\n          return {\n            pattern: e,\n            count: [],\n            digits: 0\n          };\n        }\n\n        let n = zip(e, t);\n        let u = n.length;\n        let s = \"\";\n        let o = 0;\n\n        for (let e = 0; e < u; e++) {\n          let [t, u] = n[e];\n\n          if (t === u) {\n            s += t;\n          } else if (t !== \"0\" || u !== \"9\") {\n            s += toCharacterClass(t, u, r);\n          } else {\n            o++;\n          }\n        }\n\n        if (o) {\n          s += r.shorthand === true ? \"\\\\d\" : \"[0-9]\";\n        }\n\n        return {\n          pattern: s,\n          count: [o],\n          digits: u\n        };\n      }\n\n      function splitToPatterns(e, t, r, n) {\n        let u = splitToRanges(e, t);\n        let s = [];\n        let o = e;\n        let i;\n\n        for (let e = 0; e < u.length; e++) {\n          let t = u[e];\n          let a = rangeToPattern(String(o), String(t), n);\n          let l = \"\";\n\n          if (!r.isPadded && i && i.pattern === a.pattern) {\n            if (i.count.length > 1) {\n              i.count.pop();\n            }\n\n            i.count.push(a.count[0]);\n            i.string = i.pattern + toQuantifier(i.count);\n            o = t + 1;\n            continue;\n          }\n\n          if (r.isPadded) {\n            l = padZeros(t, r, n);\n          }\n\n          a.string = l + a.pattern + toQuantifier(a.count);\n          s.push(a);\n          o = t + 1;\n          i = a;\n        }\n\n        return s;\n      }\n\n      function filterPatterns(e, t, r, n, u) {\n        let s = [];\n\n        for (let u of e) {\n          let {\n            string: e\n          } = u;\n\n          if (!n && !contains(t, \"string\", e)) {\n            s.push(r + e);\n          }\n\n          if (n && contains(t, \"string\", e)) {\n            s.push(r + e);\n          }\n        }\n\n        return s;\n      }\n\n      function zip(e, t) {\n        let r = [];\n\n        for (let n = 0; n < e.length; n++) r.push([e[n], t[n]]);\n\n        return r;\n      }\n\n      function compare(e, t) {\n        return e > t ? 1 : t > e ? -1 : 0;\n      }\n\n      function contains(e, t, r) {\n        return e.some(e => e[t] === r);\n      }\n\n      function countNines(e, t) {\n        return Number(String(e).slice(0, -t) + \"9\".repeat(t));\n      }\n\n      function countZeros(e, t) {\n        return e - e % Math.pow(10, t);\n      }\n\n      function toQuantifier(e) {\n        let [t = 0, r = \"\"] = e;\n\n        if (r || t > 1) {\n          return `{${t + (r ? \",\" + r : \"\")}}`;\n        }\n\n        return \"\";\n      }\n\n      function toCharacterClass(e, t, r) {\n        return `[${e}${t - e === 1 ? \"\" : \"-\"}${t}]`;\n      }\n\n      function hasPadding(e) {\n        return /^-?(0+)\\d/.test(e);\n      }\n\n      function padZeros(e, t, r) {\n        if (!t.isPadded) {\n          return e;\n        }\n\n        let n = Math.abs(t.maxLen - String(e).length);\n        let u = r.relaxZeros !== false;\n\n        switch (n) {\n          case 0:\n            return \"\";\n\n          case 1:\n            return u ? \"0?\" : \"0\";\n\n          case 2:\n            return u ? \"0{0,2}\" : \"00\";\n\n          default:\n            {\n              return u ? `0{0,${n}}` : `0{${n}}`;\n            }\n        }\n      }\n\n      toRegexRange.cache = {};\n\n      toRegexRange.clearCache = () => toRegexRange.cache = {};\n\n      e.exports = toRegexRange;\n    },\n    17: e => {\n      e.exports = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\n    },\n    837: e => {\n      e.exports = __webpack_require__(/*! util */ \"./node_modules/next/dist/compiled/util/util.js\");\n    }\n  };\n  var t = {};\n\n  function __nccwpck_require__(r) {\n    var n = t[r];\n\n    if (n !== undefined) {\n      return n.exports;\n    }\n\n    var u = t[r] = {\n      exports: {}\n    };\n    var s = true;\n\n    try {\n      e[r](u, u.exports, __nccwpck_require__);\n      s = false;\n    } finally {\n      if (s) delete t[r];\n    }\n\n    return u.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var r = __nccwpck_require__(888);\n\n  module.exports = r;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2gvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQSxDQUFDLE1BQUk7RUFBQzs7RUFBYSxJQUFJQSxDQUFDLEdBQUM7SUFBQyxLQUFJLENBQUNBLENBQUQsRUFBR0MsQ0FBSCxFQUFLQyxDQUFMLEtBQVM7TUFBQyxNQUFNQyxDQUFDLEdBQUNELENBQUMsQ0FBQyxHQUFELENBQVQ7TUFBZSxNQUFNRSxDQUFDLEdBQUNGLENBQUMsQ0FBQyxHQUFELENBQVQ7TUFBZSxNQUFNRyxDQUFDLEdBQUNILENBQUMsQ0FBQyxHQUFELENBQVQ7TUFBZSxNQUFNSSxDQUFDLEdBQUNKLENBQUMsQ0FBQyxHQUFELENBQVQ7O01BQWUsTUFBTUssTUFBTSxHQUFDLENBQUNQLENBQUQsRUFBR0MsQ0FBQyxHQUFDLEVBQUwsS0FBVTtRQUFDLElBQUlDLENBQUMsR0FBQyxFQUFOOztRQUFTLElBQUdNLEtBQUssQ0FBQ0MsT0FBTixDQUFjVCxDQUFkLENBQUgsRUFBb0I7VUFBQyxLQUFJLElBQUlHLENBQVIsSUFBYUgsQ0FBYixFQUFlO1lBQUMsSUFBSUEsQ0FBQyxHQUFDTyxNQUFNLENBQUNHLE1BQVAsQ0FBY1AsQ0FBZCxFQUFnQkYsQ0FBaEIsQ0FBTjs7WUFBeUIsSUFBR08sS0FBSyxDQUFDQyxPQUFOLENBQWNULENBQWQsQ0FBSCxFQUFvQjtjQUFDRSxDQUFDLENBQUNTLElBQUYsQ0FBTyxHQUFHWCxDQUFWO1lBQWEsQ0FBbEMsTUFBc0M7Y0FBQ0UsQ0FBQyxDQUFDUyxJQUFGLENBQU9YLENBQVA7WUFBVTtVQUFDO1FBQUMsQ0FBakgsTUFBcUg7VUFBQ0UsQ0FBQyxHQUFDLEdBQUdVLE1BQUgsQ0FBVUwsTUFBTSxDQUFDRyxNQUFQLENBQWNWLENBQWQsRUFBZ0JDLENBQWhCLENBQVYsQ0FBRjtRQUFnQzs7UUFBQSxJQUFHQSxDQUFDLElBQUVBLENBQUMsQ0FBQ1ksTUFBRixLQUFXLElBQWQsSUFBb0Ja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OztJQUFXLElBQUc7TUFBQ0wsQ0FBQyxDQUFDRSxDQUFELENBQUQsQ0FBS0UsQ0FBTCxFQUFPQSxDQUFDLENBQUNtQixPQUFULEVBQWlCa1gsbUJBQWpCO01BQXNDcFksQ0FBQyxHQUFDLEtBQUY7SUFBUSxDQUFsRCxTQUF5RDtNQUFDLElBQUdBLENBQUgsRUFBSyxPQUFPSixDQUFDLENBQUNDLENBQUQsQ0FBUjtJQUFZOztJQUFBLE9BQU9FLENBQUMsQ0FBQ21CLE9BQVQ7RUFBaUI7O0VBQUEsSUFBRyxPQUFPa1gsbUJBQVAsS0FBNkIsV0FBaEMsRUFBNENBLG1CQUFtQixDQUFDQyxFQUFwQixHQUF1QkMsU0FBUyxHQUFDLEdBQWpDOztFQUFxQyxJQUFJelksQ0FBQyxHQUFDdVksbUJBQW1CLENBQUMsR0FBRCxDQUF6Qjs7RUFBK0JHLE1BQU0sQ0FBQ3JYLE9BQVAsR0FBZXJCLENBQWY7QUFBaUIsQ0FyQnh2SCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2gvaW5kZXguanM/M2NlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17NTI2OihlLHQscik9Pntjb25zdCBuPXIoMTE5KTtjb25zdCB1PXIoNzY5KTtjb25zdCBzPXIoNzIyKTtjb25zdCBvPXIoNDA3KTtjb25zdCBicmFjZXM9KGUsdD17fSk9PntsZXQgcj1bXTtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IobGV0IG4gb2YgZSl7bGV0IGU9YnJhY2VzLmNyZWF0ZShuLHQpO2lmKEFycmF5LmlzQXJyYXkoZSkpe3IucHVzaCguLi5lKX1lbHNle3IucHVzaChlKX19fWVsc2V7cj1bXS5jb25jYXQoYnJhY2VzLmNyZWF0ZShlLHQpKX1pZih0JiZ0LmV4cGFuZD09PXRydWUmJnQubm9kdXBlcz09PXRydWUpe3I9Wy4uLm5ldyBTZXQocildfXJldHVybiByfTticmFjZXMucGFyc2U9KGUsdD17fSk9Pm8oZSx0KTticmFjZXMuc3RyaW5naWZ5PShlLHQ9e30pPT57aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gbihicmFjZXMucGFyc2UoZSx0KSx0KX1yZXR1cm4gbihlLHQpfTticmFjZXMuY29tcGlsZT0oZSx0PXt9KT0+e2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7ZT1icmFjZXMucGFyc2UoZSx0KX1yZXR1cm4gdShlLHQpfTticmFjZXMuZXhwYW5kPShlLHQ9e30pPT57aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtlPWJyYWNlcy5wYXJzZShlLHQpfWxldCByPXMoZSx0KTtpZih0Lm5vZW1wdHk9PT10cnVlKXtyPXIuZmlsdGVyKEJvb2xlYW4pfWlmKHQubm9kdXBlcz09PXRydWUpe3I9Wy4uLm5ldyBTZXQocildfXJldHVybiByfTticmFjZXMuY3JlYXRlPShlLHQ9e30pPT57aWYoZT09PVwiXCJ8fGUubGVuZ3RoPDMpe3JldHVybltlXX1yZXR1cm4gdC5leHBhbmQhPT10cnVlP2JyYWNlcy5jb21waWxlKGUsdCk6YnJhY2VzLmV4cGFuZChlLHQpfTtlLmV4cG9ydHM9YnJhY2VzfSw3Njk6KGUsdCxyKT0+e2NvbnN0IG49cig3ODkpO2NvbnN0IHU9cigxNSk7Y29uc3QgY29tcGlsZT0oZSx0PXt9KT0+e2xldCB3YWxrPShlLHI9e30pPT57bGV0IHM9dS5pc0ludmFsaWRCcmFjZShyKTtsZXQgbz1lLmludmFsaWQ9PT10cnVlJiZ0LmVzY2FwZUludmFsaWQ9PT10cnVlO2xldCBpPXM9PT10cnVlfHxvPT09dHJ1ZTtsZXQgYT10LmVzY2FwZUludmFsaWQ9PT10cnVlP1wiXFxcXFwiOlwiXCI7bGV0IGw9XCJcIjtpZihlLmlzT3Blbj09PXRydWUpe3JldHVybiBhK2UudmFsdWV9aWYoZS5pc0Nsb3NlPT09dHJ1ZSl7cmV0dXJuIGErZS52YWx1ZX1pZihlLnR5cGU9PT1cIm9wZW5cIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKFwifWlmKGUudHlwZT09PVwiY2xvc2VcIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKVwifWlmKGUudHlwZT09PVwiY29tbWFcIil7cmV0dXJuIGUucHJldi50eXBlPT09XCJjb21tYVwiP1wiXCI6aT9lLnZhbHVlOlwifFwifWlmKGUudmFsdWUpe3JldHVybiBlLnZhbHVlfWlmKGUubm9kZXMmJmUucmFuZ2VzPjApe2xldCByPXUucmVkdWNlKGUubm9kZXMpO2xldCBzPW4oLi4ucix7Li4udCx3cmFwOmZhbHNlLHRvUmVnZXg6dHJ1ZX0pO2lmKHMubGVuZ3RoIT09MCl7cmV0dXJuIHIubGVuZ3RoPjEmJnMubGVuZ3RoPjE/YCgke3N9KWA6c319aWYoZS5ub2Rlcyl7Zm9yKGxldCB0IG9mIGUubm9kZXMpe2wrPXdhbGsodCxlKX19cmV0dXJuIGx9O3JldHVybiB3YWxrKGUpfTtlLmV4cG9ydHM9Y29tcGlsZX0sMjYyOmU9PntlLmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxDSEFSXzA6XCIwXCIsQ0hBUl85OlwiOVwiLENIQVJfVVBQRVJDQVNFX0E6XCJBXCIsQ0hBUl9MT1dFUkNBU0VfQTpcImFcIixDSEFSX1VQUEVSQ0FTRV9aOlwiWlwiLENIQVJfTE9XRVJDQVNFX1o6XCJ6XCIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOlwiKFwiLENIQVJfUklHSFRfUEFSRU5USEVTRVM6XCIpXCIsQ0hBUl9BU1RFUklTSzpcIipcIixDSEFSX0FNUEVSU0FORDpcIiZcIixDSEFSX0FUOlwiQFwiLENIQVJfQkFDS1NMQVNIOlwiXFxcXFwiLENIQVJfQkFDS1RJQ0s6XCJgXCIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46XCJcXHJcIixDSEFSX0NJUkNVTUZMRVhfQUNDRU5UOlwiXlwiLENIQVJfQ09MT046XCI6XCIsQ0hBUl9DT01NQTpcIixcIixDSEFSX0RPTExBUjpcIiRcIixDSEFSX0RPVDpcIi5cIixDSEFSX0RPVUJMRV9RVU9URTonXCInLENIQVJfRVFVQUw6XCI9XCIsQ0hBUl9FWENMQU1BVElPTl9NQVJLOlwiIVwiLENIQVJfRk9STV9GRUVEOlwiXFxmXCIsQ0hBUl9GT1JXQVJEX1NMQVNIOlwiL1wiLENIQVJfSEFTSDpcIiNcIixDSEFSX0hZUEhFTl9NSU5VUzpcIi1cIixDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDpcIjxcIixDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6XCJ7XCIsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOlwiW1wiLENIQVJfTElORV9GRUVEOlwiXFxuXCIsQ0hBUl9OT19CUkVBS19TUEFDRTpcIsKgXCIsQ0hBUl9QRVJDRU5UOlwiJVwiLENIQVJfUExVUzpcIitcIixDSEFSX1FVRVNUSU9OX01BUks6XCI/XCIsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOlwiPlwiLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6XCJ9XCIsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpcIl1cIixDSEFSX1NFTUlDT0xPTjpcIjtcIixDSEFSX1NJTkdMRV9RVU9URTpcIidcIixDSEFSX1NQQUNFOlwiIFwiLENIQVJfVEFCOlwiXFx0XCIsQ0hBUl9VTkRFUlNDT1JFOlwiX1wiLENIQVJfVkVSVElDQUxfTElORTpcInxcIixDSEFSX1pFUk9fV0lEVEhfTk9CUkVBS19TUEFDRTpcIlxcdWZlZmZcIn19LDcyMjooZSx0LHIpPT57Y29uc3Qgbj1yKDc4OSk7Y29uc3QgdT1yKDExOSk7Y29uc3Qgcz1yKDE1KTtjb25zdCBhcHBlbmQ9KGU9XCJcIix0PVwiXCIscj1mYWxzZSk9PntsZXQgbj1bXTtlPVtdLmNvbmNhdChlKTt0PVtdLmNvbmNhdCh0KTtpZighdC5sZW5ndGgpcmV0dXJuIGU7aWYoIWUubGVuZ3RoKXtyZXR1cm4gcj9zLmZsYXR0ZW4odCkubWFwKChlPT5geyR7ZX19YCkpOnR9Zm9yKGxldCB1IG9mIGUpe2lmKEFycmF5LmlzQXJyYXkodSkpe2ZvcihsZXQgZSBvZiB1KXtuLnB1c2goYXBwZW5kKGUsdCxyKSl9fWVsc2V7Zm9yKGxldCBlIG9mIHQpe2lmKHI9PT10cnVlJiZ0eXBlb2YgZT09PVwic3RyaW5nXCIpZT1geyR7ZX19YDtuLnB1c2goQXJyYXkuaXNBcnJheShlKT9hcHBlbmQodSxlLHIpOnUrZSl9fX1yZXR1cm4gcy5mbGF0dGVuKG4pfTtjb25zdCBleHBhbmQ9KGUsdD17fSk9PntsZXQgcj10LnJhbmdlTGltaXQ9PT12b2lkIDA/MWUzOnQucmFuZ2VMaW1pdDtsZXQgd2Fsaz0oZSxvPXt9KT0+e2UucXVldWU9W107bGV0IGk9bztsZXQgYT1vLnF1ZXVlO3doaWxlKGkudHlwZSE9PVwiYnJhY2VcIiYmaS50eXBlIT09XCJyb290XCImJmkucGFyZW50KXtpPWkucGFyZW50O2E9aS5xdWV1ZX1pZihlLmludmFsaWR8fGUuZG9sbGFyKXthLnB1c2goYXBwZW5kKGEucG9wKCksdShlLHQpKSk7cmV0dXJufWlmKGUudHlwZT09PVwiYnJhY2VcIiYmZS5pbnZhbGlkIT09dHJ1ZSYmZS5ub2Rlcy5sZW5ndGg9PT0yKXthLnB1c2goYXBwZW5kKGEucG9wKCksW1wie31cIl0pKTtyZXR1cm59aWYoZS5ub2RlcyYmZS5yYW5nZXM+MCl7bGV0IG89cy5yZWR1Y2UoZS5ub2Rlcyk7aWYocy5leGNlZWRzTGltaXQoLi4ubyx0LnN0ZXAscikpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiZXhwYW5kZWQgYXJyYXkgbGVuZ3RoIGV4Y2VlZHMgcmFuZ2UgbGltaXQuIFVzZSBvcHRpb25zLnJhbmdlTGltaXQgdG8gaW5jcmVhc2Ugb3IgZGlzYWJsZSB0aGUgbGltaXQuXCIpfWxldCBpPW4oLi4ubyx0KTtpZihpLmxlbmd0aD09PTApe2k9dShlLHQpfWEucHVzaChhcHBlbmQoYS5wb3AoKSxpKSk7ZS5ub2Rlcz1bXTtyZXR1cm59bGV0IGw9cy5lbmNsb3NlQnJhY2UoZSk7bGV0IGM9ZS5xdWV1ZTtsZXQgcD1lO3doaWxlKHAudHlwZSE9PVwiYnJhY2VcIiYmcC50eXBlIT09XCJyb290XCImJnAucGFyZW50KXtwPXAucGFyZW50O2M9cC5xdWV1ZX1mb3IobGV0IHQ9MDt0PGUubm9kZXMubGVuZ3RoO3QrKyl7bGV0IHI9ZS5ub2Rlc1t0XTtpZihyLnR5cGU9PT1cImNvbW1hXCImJmUudHlwZT09PVwiYnJhY2VcIil7aWYodD09PTEpYy5wdXNoKFwiXCIpO2MucHVzaChcIlwiKTtjb250aW51ZX1pZihyLnR5cGU9PT1cImNsb3NlXCIpe2EucHVzaChhcHBlbmQoYS5wb3AoKSxjLGwpKTtjb250aW51ZX1pZihyLnZhbHVlJiZyLnR5cGUhPT1cIm9wZW5cIil7Yy5wdXNoKGFwcGVuZChjLnBvcCgpLHIudmFsdWUpKTtjb250aW51ZX1pZihyLm5vZGVzKXt3YWxrKHIsZSl9fXJldHVybiBjfTtyZXR1cm4gcy5mbGF0dGVuKHdhbGsoZSkpfTtlLmV4cG9ydHM9ZXhwYW5kfSw0MDc6KGUsdCxyKT0+e2NvbnN0IG49cigxMTkpO2NvbnN0e01BWF9MRU5HVEg6dSxDSEFSX0JBQ0tTTEFTSDpzLENIQVJfQkFDS1RJQ0s6byxDSEFSX0NPTU1BOmksQ0hBUl9ET1Q6YSxDSEFSX0xFRlRfUEFSRU5USEVTRVM6bCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmMsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOnAsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6UixDSEFSX0RPVUJMRV9RVU9URTpfLENIQVJfU0lOR0xFX1FVT1RFOmgsQ0hBUl9OT19CUkVBS19TUEFDRTpnLENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOkV9PXIoMjYyKTtjb25zdCBwYXJzZT0oZSx0PXt9KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpfWxldCByPXR8fHt9O2xldCBDPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4odSxyLm1heExlbmd0aCk6dTtpZihlLmxlbmd0aD5DKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aCAoJHtlLmxlbmd0aH0pLCBleGNlZWRzIG1heCBjaGFyYWN0ZXJzICgke0N9KWApfWxldCB5PXt0eXBlOlwicm9vdFwiLGlucHV0OmUsbm9kZXM6W119O2xldCBkPVt5XTtsZXQgeD15O2xldCBiPXk7bGV0IFM9MDtsZXQgSD1lLmxlbmd0aDtsZXQgdj0wO2xldCAkPTA7bGV0IG07bGV0IFQ9e307Y29uc3QgYWR2YW5jZT0oKT0+ZVt2KytdO2NvbnN0IHB1c2g9ZT0+e2lmKGUudHlwZT09PVwidGV4dFwiJiZiLnR5cGU9PT1cImRvdFwiKXtiLnR5cGU9XCJ0ZXh0XCJ9aWYoYiYmYi50eXBlPT09XCJ0ZXh0XCImJmUudHlwZT09PVwidGV4dFwiKXtiLnZhbHVlKz1lLnZhbHVlO3JldHVybn14Lm5vZGVzLnB1c2goZSk7ZS5wYXJlbnQ9eDtlLnByZXY9YjtiPWU7cmV0dXJuIGV9O3B1c2goe3R5cGU6XCJib3NcIn0pO3doaWxlKHY8SCl7eD1kW2QubGVuZ3RoLTFdO209YWR2YW5jZSgpO2lmKG09PT1FfHxtPT09Zyl7Y29udGludWV9aWYobT09PXMpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6KHQua2VlcEVzY2FwaW5nP206XCJcIikrYWR2YW5jZSgpfSk7Y29udGludWV9aWYobT09PVIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6XCJcXFxcXCIrbX0pO2NvbnRpbnVlfWlmKG09PT1BKXtTKys7bGV0IGU9dHJ1ZTtsZXQgdDt3aGlsZSh2PEgmJih0PWFkdmFuY2UoKSkpe20rPXQ7aWYodD09PUEpe1MrKztjb250aW51ZX1pZih0PT09cyl7bSs9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKHQ9PT1SKXtTLS07aWYoUz09PTApe2JyZWFrfX19cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWwpe3g9cHVzaCh7dHlwZTpcInBhcmVuXCIsbm9kZXM6W119KTtkLnB1c2goeCk7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWMpe2lmKHgudHlwZSE9PVwicGFyZW5cIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9eD1kLnBvcCgpO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09X3x8bT09PWh8fG09PT1vKXtsZXQgZT1tO2xldCByO2lmKHQua2VlcFF1b3RlcyE9PXRydWUpe209XCJcIn13aGlsZSh2PEgmJihyPWFkdmFuY2UoKSkpe2lmKHI9PT1zKXttKz1yK2FkdmFuY2UoKTtjb250aW51ZX1pZihyPT09ZSl7aWYodC5rZWVwUXVvdGVzPT09dHJ1ZSltKz1yO2JyZWFrfW0rPXJ9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PXApeyQrKztsZXQgZT1iLnZhbHVlJiZiLnZhbHVlLnNsaWNlKC0xKT09PVwiJFwifHx4LmRvbGxhcj09PXRydWU7bGV0IHQ9e3R5cGU6XCJicmFjZVwiLG9wZW46dHJ1ZSxjbG9zZTpmYWxzZSxkb2xsYXI6ZSxkZXB0aDokLGNvbW1hczowLHJhbmdlczowLG5vZGVzOltdfTt4PXB1c2godCk7ZC5wdXNoKHgpO3B1c2goe3R5cGU6XCJvcGVuXCIsdmFsdWU6bX0pO2NvbnRpbnVlfWlmKG09PT1mKXtpZih4LnR5cGUhPT1cImJyYWNlXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO2NvbnRpbnVlfWxldCBlPVwiY2xvc2VcIjt4PWQucG9wKCk7eC5jbG9zZT10cnVlO3B1c2goe3R5cGU6ZSx2YWx1ZTptfSk7JC0tO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09aSYmJD4wKXtpZih4LnJhbmdlcz4wKXt4LnJhbmdlcz0wO2xldCBlPXgubm9kZXMuc2hpZnQoKTt4Lm5vZGVzPVtlLHt0eXBlOlwidGV4dFwiLHZhbHVlOm4oeCl9XX1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTptfSk7eC5jb21tYXMrKztjb250aW51ZX1pZihtPT09YSYmJD4wJiZ4LmNvbW1hcz09PTApe2xldCBlPXgubm9kZXM7aWYoJD09PTB8fGUubGVuZ3RoPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYoYi50eXBlPT09XCJkb3RcIil7eC5yYW5nZT1bXTtiLnZhbHVlKz1tO2IudHlwZT1cInJhbmdlXCI7aWYoeC5ub2Rlcy5sZW5ndGghPT0zJiZ4Lm5vZGVzLmxlbmd0aCE9PTUpe3guaW52YWxpZD10cnVlO3gucmFuZ2VzPTA7Yi50eXBlPVwidGV4dFwiO2NvbnRpbnVlfXgucmFuZ2VzKys7eC5hcmdzPVtdO2NvbnRpbnVlfWlmKGIudHlwZT09PVwicmFuZ2VcIil7ZS5wb3AoKTtsZXQgdD1lW2UubGVuZ3RoLTFdO3QudmFsdWUrPWIudmFsdWUrbTtiPXQ7eC5yYW5nZXMtLTtjb250aW51ZX1wdXNoKHt0eXBlOlwiZG90XCIsdmFsdWU6bX0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pfWRve3g9ZC5wb3AoKTtpZih4LnR5cGUhPT1cInJvb3RcIil7eC5ub2Rlcy5mb3JFYWNoKChlPT57aWYoIWUubm9kZXMpe2lmKGUudHlwZT09PVwib3BlblwiKWUuaXNPcGVuPXRydWU7aWYoZS50eXBlPT09XCJjbG9zZVwiKWUuaXNDbG9zZT10cnVlO2lmKCFlLm5vZGVzKWUudHlwZT1cInRleHRcIjtlLmludmFsaWQ9dHJ1ZX19KSk7bGV0IGU9ZFtkLmxlbmd0aC0xXTtsZXQgdD1lLm5vZGVzLmluZGV4T2YoeCk7ZS5ub2Rlcy5zcGxpY2UodCwxLC4uLngubm9kZXMpfX13aGlsZShkLmxlbmd0aD4wKTtwdXNoKHt0eXBlOlwiZW9zXCJ9KTtyZXR1cm4geX07ZS5leHBvcnRzPXBhcnNlfSwxMTk6KGUsdCxyKT0+e2NvbnN0IG49cigxNSk7ZS5leHBvcnRzPShlLHQ9e30pPT57bGV0IHN0cmluZ2lmeT0oZSxyPXt9KT0+e2xldCB1PXQuZXNjYXBlSW52YWxpZCYmbi5pc0ludmFsaWRCcmFjZShyKTtsZXQgcz1lLmludmFsaWQ9PT10cnVlJiZ0LmVzY2FwZUludmFsaWQ9PT10cnVlO2xldCBvPVwiXCI7aWYoZS52YWx1ZSl7aWYoKHV8fHMpJiZuLmlzT3Blbk9yQ2xvc2UoZSkpe3JldHVyblwiXFxcXFwiK2UudmFsdWV9cmV0dXJuIGUudmFsdWV9aWYoZS52YWx1ZSl7cmV0dXJuIGUudmFsdWV9aWYoZS5ub2Rlcyl7Zm9yKGxldCB0IG9mIGUubm9kZXMpe28rPXN0cmluZ2lmeSh0KX19cmV0dXJuIG99O3JldHVybiBzdHJpbmdpZnkoZSl9fSwxNTooZSx0KT0+e3QuaXNJbnRlZ2VyPWU9PntpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGUpfWlmKHR5cGVvZiBlPT09XCJzdHJpbmdcIiYmZS50cmltKCkhPT1cIlwiKXtyZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihOdW1iZXIoZSkpfXJldHVybiBmYWxzZX07dC5maW5kPShlLHQpPT5lLm5vZGVzLmZpbmQoKGU9PmUudHlwZT09PXQpKTt0LmV4Y2VlZHNMaW1pdD0oZSxyLG49MSx1KT0+e2lmKHU9PT1mYWxzZSlyZXR1cm4gZmFsc2U7aWYoIXQuaXNJbnRlZ2VyKGUpfHwhdC5pc0ludGVnZXIocikpcmV0dXJuIGZhbHNlO3JldHVybihOdW1iZXIociktTnVtYmVyKGUpKS9OdW1iZXIobik+PXV9O3QuZXNjYXBlTm9kZT0oZSx0PTAscik9PntsZXQgbj1lLm5vZGVzW3RdO2lmKCFuKXJldHVybjtpZihyJiZuLnR5cGU9PT1yfHxuLnR5cGU9PT1cIm9wZW5cInx8bi50eXBlPT09XCJjbG9zZVwiKXtpZihuLmVzY2FwZWQhPT10cnVlKXtuLnZhbHVlPVwiXFxcXFwiK24udmFsdWU7bi5lc2NhcGVkPXRydWV9fX07dC5lbmNsb3NlQnJhY2U9ZT0+e2lmKGUudHlwZSE9PVwiYnJhY2VcIilyZXR1cm4gZmFsc2U7aWYoZS5jb21tYXM+PjArZS5yYW5nZXM+PjA9PT0wKXtlLmludmFsaWQ9dHJ1ZTtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9O3QuaXNJbnZhbGlkQnJhY2U9ZT0+e2lmKGUudHlwZSE9PVwiYnJhY2VcIilyZXR1cm4gZmFsc2U7aWYoZS5pbnZhbGlkPT09dHJ1ZXx8ZS5kb2xsYXIpcmV0dXJuIHRydWU7aWYoZS5jb21tYXM+PjArZS5yYW5nZXM+PjA9PT0wKXtlLmludmFsaWQ9dHJ1ZTtyZXR1cm4gdHJ1ZX1pZihlLm9wZW4hPT10cnVlfHxlLmNsb3NlIT09dHJ1ZSl7ZS5pbnZhbGlkPXRydWU7cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlfTt0LmlzT3Blbk9yQ2xvc2U9ZT0+e2lmKGUudHlwZT09PVwib3BlblwifHxlLnR5cGU9PT1cImNsb3NlXCIpe3JldHVybiB0cnVlfXJldHVybiBlLm9wZW49PT10cnVlfHxlLmNsb3NlPT09dHJ1ZX07dC5yZWR1Y2U9ZT0+ZS5yZWR1Y2UoKChlLHQpPT57aWYodC50eXBlPT09XCJ0ZXh0XCIpZS5wdXNoKHQudmFsdWUpO2lmKHQudHlwZT09PVwicmFuZ2VcIil0LnR5cGU9XCJ0ZXh0XCI7cmV0dXJuIGV9KSxbXSk7dC5mbGF0dGVuPSguLi5lKT0+e2NvbnN0IHQ9W107Y29uc3QgZmxhdD1lPT57Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2xldCBuPWVbcl07QXJyYXkuaXNBcnJheShuKT9mbGF0KG4sdCk6biE9PXZvaWQgMCYmdC5wdXNoKG4pfXJldHVybiB0fTtmbGF0KGUpO3JldHVybiB0fX0sNzg5OihlLHQscik9Pntcbi8qIVxuICogZmlsbC1yYW5nZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvZmlsbC1yYW5nZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmNvbnN0IG49cig4MzcpO2NvbnN0IHU9cigzNjgpO2NvbnN0IGlzT2JqZWN0PWU9PmUhPT1udWxsJiZ0eXBlb2YgZT09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KGUpO2NvbnN0IHRyYW5zZm9ybT1lPT50PT5lPT09dHJ1ZT9OdW1iZXIodCk6U3RyaW5nKHQpO2NvbnN0IGlzVmFsaWRWYWx1ZT1lPT50eXBlb2YgZT09PVwibnVtYmVyXCJ8fHR5cGVvZiBlPT09XCJzdHJpbmdcIiYmZSE9PVwiXCI7Y29uc3QgaXNOdW1iZXI9ZT0+TnVtYmVyLmlzSW50ZWdlcigrZSk7Y29uc3QgemVyb3M9ZT0+e2xldCB0PWAke2V9YDtsZXQgcj0tMTtpZih0WzBdPT09XCItXCIpdD10LnNsaWNlKDEpO2lmKHQ9PT1cIjBcIilyZXR1cm4gZmFsc2U7d2hpbGUodFsrK3JdPT09XCIwXCIpO3JldHVybiByPjB9O2NvbnN0IHN0cmluZ2lmeT0oZSx0LHIpPT57aWYodHlwZW9mIGU9PT1cInN0cmluZ1wifHx0eXBlb2YgdD09PVwic3RyaW5nXCIpe3JldHVybiB0cnVlfXJldHVybiByLnN0cmluZ2lmeT09PXRydWV9O2NvbnN0IHBhZD0oZSx0LHIpPT57aWYodD4wKXtsZXQgcj1lWzBdPT09XCItXCI/XCItXCI6XCJcIjtpZihyKWU9ZS5zbGljZSgxKTtlPXIrZS5wYWRTdGFydChyP3QtMTp0LFwiMFwiKX1pZihyPT09ZmFsc2Upe3JldHVybiBTdHJpbmcoZSl9cmV0dXJuIGV9O2NvbnN0IHRvTWF4TGVuPShlLHQpPT57bGV0IHI9ZVswXT09PVwiLVwiP1wiLVwiOlwiXCI7aWYocil7ZT1lLnNsaWNlKDEpO3QtLX13aGlsZShlLmxlbmd0aDx0KWU9XCIwXCIrZTtyZXR1cm4gcj9cIi1cIitlOmV9O2NvbnN0IHRvU2VxdWVuY2U9KGUsdCk9PntlLm5lZ2F0aXZlcy5zb3J0KCgoZSx0KT0+ZTx0Py0xOmU+dD8xOjApKTtlLnBvc2l0aXZlcy5zb3J0KCgoZSx0KT0+ZTx0Py0xOmU+dD8xOjApKTtsZXQgcj10LmNhcHR1cmU/XCJcIjpcIj86XCI7bGV0IG49XCJcIjtsZXQgdT1cIlwiO2xldCBzO2lmKGUucG9zaXRpdmVzLmxlbmd0aCl7bj1lLnBvc2l0aXZlcy5qb2luKFwifFwiKX1pZihlLm5lZ2F0aXZlcy5sZW5ndGgpe3U9YC0oJHtyfSR7ZS5uZWdhdGl2ZXMuam9pbihcInxcIil9KWB9aWYobiYmdSl7cz1gJHtufXwke3V9YH1lbHNle3M9bnx8dX1pZih0LndyYXApe3JldHVybmAoJHtyfSR7c30pYH1yZXR1cm4gc307Y29uc3QgdG9SYW5nZT0oZSx0LHIsbik9PntpZihyKXtyZXR1cm4gdShlLHQse3dyYXA6ZmFsc2UsLi4ubn0pfWxldCBzPVN0cmluZy5mcm9tQ2hhckNvZGUoZSk7aWYoZT09PXQpcmV0dXJuIHM7bGV0IG89U3RyaW5nLmZyb21DaGFyQ29kZSh0KTtyZXR1cm5gWyR7c30tJHtvfV1gfTtjb25zdCB0b1JlZ2V4PShlLHQscik9PntpZihBcnJheS5pc0FycmF5KGUpKXtsZXQgdD1yLndyYXA9PT10cnVlO2xldCBuPXIuY2FwdHVyZT9cIlwiOlwiPzpcIjtyZXR1cm4gdD9gKCR7bn0ke2Uuam9pbihcInxcIil9KWA6ZS5qb2luKFwifFwiKX1yZXR1cm4gdShlLHQscil9O2NvbnN0IHJhbmdlRXJyb3I9KC4uLmUpPT5uZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcmFuZ2UgYXJndW1lbnRzOiBcIituLmluc3BlY3QoLi4uZSkpO2NvbnN0IGludmFsaWRSYW5nZT0oZSx0LHIpPT57aWYoci5zdHJpY3RSYW5nZXM9PT10cnVlKXRocm93IHJhbmdlRXJyb3IoW2UsdF0pO3JldHVybltdfTtjb25zdCBpbnZhbGlkU3RlcD0oZSx0KT0+e2lmKHQuc3RyaWN0UmFuZ2VzPT09dHJ1ZSl7dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgc3RlcCBcIiR7ZX1cIiB0byBiZSBhIG51bWJlcmApfXJldHVybltdfTtjb25zdCBmaWxsTnVtYmVycz0oZSx0LHI9MSxuPXt9KT0+e2xldCB1PU51bWJlcihlKTtsZXQgcz1OdW1iZXIodCk7aWYoIU51bWJlci5pc0ludGVnZXIodSl8fCFOdW1iZXIuaXNJbnRlZ2VyKHMpKXtpZihuLnN0cmljdFJhbmdlcz09PXRydWUpdGhyb3cgcmFuZ2VFcnJvcihbZSx0XSk7cmV0dXJuW119aWYodT09PTApdT0wO2lmKHM9PT0wKXM9MDtsZXQgbz11PnM7bGV0IGk9U3RyaW5nKGUpO2xldCBhPVN0cmluZyh0KTtsZXQgbD1TdHJpbmcocik7cj1NYXRoLm1heChNYXRoLmFicyhyKSwxKTtsZXQgYz16ZXJvcyhpKXx8emVyb3MoYSl8fHplcm9zKGwpO2xldCBwPWM/TWF0aC5tYXgoaS5sZW5ndGgsYS5sZW5ndGgsbC5sZW5ndGgpOjA7bGV0IGY9Yz09PWZhbHNlJiZzdHJpbmdpZnkoZSx0LG4pPT09ZmFsc2U7bGV0IEE9bi50cmFuc2Zvcm18fHRyYW5zZm9ybShmKTtpZihuLnRvUmVnZXgmJnI9PT0xKXtyZXR1cm4gdG9SYW5nZSh0b01heExlbihlLHApLHRvTWF4TGVuKHQscCksdHJ1ZSxuKX1sZXQgUj17bmVnYXRpdmVzOltdLHBvc2l0aXZlczpbXX07bGV0IHB1c2g9ZT0+UltlPDA/XCJuZWdhdGl2ZXNcIjpcInBvc2l0aXZlc1wiXS5wdXNoKE1hdGguYWJzKGUpKTtsZXQgXz1bXTtsZXQgaD0wO3doaWxlKG8/dT49czp1PD1zKXtpZihuLnRvUmVnZXg9PT10cnVlJiZyPjEpe3B1c2godSl9ZWxzZXtfLnB1c2gocGFkKEEodSxoKSxwLGYpKX11PW8/dS1yOnUrcjtoKyt9aWYobi50b1JlZ2V4PT09dHJ1ZSl7cmV0dXJuIHI+MT90b1NlcXVlbmNlKFIsbik6dG9SZWdleChfLG51bGwse3dyYXA6ZmFsc2UsLi4ubn0pfXJldHVybiBffTtjb25zdCBmaWxsTGV0dGVycz0oZSx0LHI9MSxuPXt9KT0+e2lmKCFpc051bWJlcihlKSYmZS5sZW5ndGg+MXx8IWlzTnVtYmVyKHQpJiZ0Lmxlbmd0aD4xKXtyZXR1cm4gaW52YWxpZFJhbmdlKGUsdCxuKX1sZXQgdT1uLnRyYW5zZm9ybXx8KGU9PlN0cmluZy5mcm9tQ2hhckNvZGUoZSkpO2xldCBzPWAke2V9YC5jaGFyQ29kZUF0KDApO2xldCBvPWAke3R9YC5jaGFyQ29kZUF0KDApO2xldCBpPXM+bztsZXQgYT1NYXRoLm1pbihzLG8pO2xldCBsPU1hdGgubWF4KHMsbyk7aWYobi50b1JlZ2V4JiZyPT09MSl7cmV0dXJuIHRvUmFuZ2UoYSxsLGZhbHNlLG4pfWxldCBjPVtdO2xldCBwPTA7d2hpbGUoaT9zPj1vOnM8PW8pe2MucHVzaCh1KHMscCkpO3M9aT9zLXI6cytyO3ArK31pZihuLnRvUmVnZXg9PT10cnVlKXtyZXR1cm4gdG9SZWdleChjLG51bGwse3dyYXA6ZmFsc2Usb3B0aW9uczpufSl9cmV0dXJuIGN9O2NvbnN0IGZpbGw9KGUsdCxyLG49e30pPT57aWYodD09bnVsbCYmaXNWYWxpZFZhbHVlKGUpKXtyZXR1cm5bZV19aWYoIWlzVmFsaWRWYWx1ZShlKXx8IWlzVmFsaWRWYWx1ZSh0KSl7cmV0dXJuIGludmFsaWRSYW5nZShlLHQsbil9aWYodHlwZW9mIHI9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBmaWxsKGUsdCwxLHt0cmFuc2Zvcm06cn0pfWlmKGlzT2JqZWN0KHIpKXtyZXR1cm4gZmlsbChlLHQsMCxyKX1sZXQgdT17Li4ubn07aWYodS5jYXB0dXJlPT09dHJ1ZSl1LndyYXA9dHJ1ZTtyPXJ8fHUuc3RlcHx8MTtpZighaXNOdW1iZXIocikpe2lmKHIhPW51bGwmJiFpc09iamVjdChyKSlyZXR1cm4gaW52YWxpZFN0ZXAocix1KTtyZXR1cm4gZmlsbChlLHQsMSxyKX1pZihpc051bWJlcihlKSYmaXNOdW1iZXIodCkpe3JldHVybiBmaWxsTnVtYmVycyhlLHQscix1KX1yZXR1cm4gZmlsbExldHRlcnMoZSx0LE1hdGgubWF4KE1hdGguYWJzKHIpLDEpLHUpfTtlLmV4cG9ydHM9ZmlsbH0sNzczOmU9Pntcbi8qIVxuICogaXMtbnVtYmVyIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1udW1iZXI+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtyZXR1cm4gZS1lPT09MH1pZih0eXBlb2YgZT09PVwic3RyaW5nXCImJmUudHJpbSgpIT09XCJcIil7cmV0dXJuIE51bWJlci5pc0Zpbml0ZT9OdW1iZXIuaXNGaW5pdGUoK2UpOmlzRmluaXRlKCtlKX1yZXR1cm4gZmFsc2V9fSw4ODg6KGUsdCxyKT0+e2NvbnN0IG49cig4MzcpO2NvbnN0IHU9cig1MjYpO2NvbnN0IHM9cig2MDEpO2NvbnN0IG89cigyNDMpO2NvbnN0IGlzRW1wdHlTdHJpbmc9ZT0+ZT09PVwiXCJ8fGU9PT1cIi4vXCI7Y29uc3QgbWljcm9tYXRjaD0oZSx0LHIpPT57dD1bXS5jb25jYXQodCk7ZT1bXS5jb25jYXQoZSk7bGV0IG49bmV3IFNldDtsZXQgdT1uZXcgU2V0O2xldCBvPW5ldyBTZXQ7bGV0IGk9MDtsZXQgb25SZXN1bHQ9ZT0+e28uYWRkKGUub3V0cHV0KTtpZihyJiZyLm9uUmVzdWx0KXtyLm9uUmVzdWx0KGUpfX07Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDtvKyspe2xldCBhPXMoU3RyaW5nKHRbb10pLHsuLi5yLG9uUmVzdWx0Om9uUmVzdWx0fSx0cnVlKTtsZXQgbD1hLnN0YXRlLm5lZ2F0ZWR8fGEuc3RhdGUubmVnYXRlZEV4dGdsb2I7aWYobClpKys7Zm9yKGxldCB0IG9mIGUpe2xldCBlPWEodCx0cnVlKTtsZXQgcj1sPyFlLmlzTWF0Y2g6ZS5pc01hdGNoO2lmKCFyKWNvbnRpbnVlO2lmKGwpe24uYWRkKGUub3V0cHV0KX1lbHNle24uZGVsZXRlKGUub3V0cHV0KTt1LmFkZChlLm91dHB1dCl9fX1sZXQgYT1pPT09dC5sZW5ndGg/Wy4uLm9dOlsuLi51XTtsZXQgbD1hLmZpbHRlcigoZT0+IW4uaGFzKGUpKSk7aWYociYmbC5sZW5ndGg9PT0wKXtpZihyLmZhaWxnbG9iPT09dHJ1ZSl7dGhyb3cgbmV3IEVycm9yKGBObyBtYXRjaGVzIGZvdW5kIGZvciBcIiR7dC5qb2luKFwiLCBcIil9XCJgKX1pZihyLm5vbnVsbD09PXRydWV8fHIubnVsbGdsb2I9PT10cnVlKXtyZXR1cm4gci51bmVzY2FwZT90Lm1hcCgoZT0+ZS5yZXBsYWNlKC9cXFxcL2csXCJcIikpKTp0fX1yZXR1cm4gbH07bWljcm9tYXRjaC5tYXRjaD1taWNyb21hdGNoO21pY3JvbWF0Y2gubWF0Y2hlcj0oZSx0KT0+cyhlLHQpO21pY3JvbWF0Y2guaXNNYXRjaD0oZSx0LHIpPT5zKHQscikoZSk7bWljcm9tYXRjaC5hbnk9bWljcm9tYXRjaC5pc01hdGNoO21pY3JvbWF0Y2gubm90PShlLHQscj17fSk9Pnt0PVtdLmNvbmNhdCh0KS5tYXAoU3RyaW5nKTtsZXQgbj1uZXcgU2V0O2xldCB1PVtdO2xldCBvblJlc3VsdD1lPT57aWYoci5vblJlc3VsdClyLm9uUmVzdWx0KGUpO3UucHVzaChlLm91dHB1dCl9O2xldCBzPW1pY3JvbWF0Y2goZSx0LHsuLi5yLG9uUmVzdWx0Om9uUmVzdWx0fSk7Zm9yKGxldCBlIG9mIHUpe2lmKCFzLmluY2x1ZGVzKGUpKXtuLmFkZChlKX19cmV0dXJuWy4uLm5dfTttaWNyb21hdGNoLmNvbnRhaW5zPShlLHQscik9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nOiBcIiR7bi5pbnNwZWN0KGUpfVwiYCl9aWYoQXJyYXkuaXNBcnJheSh0KSl7cmV0dXJuIHQuc29tZSgodD0+bWljcm9tYXRjaC5jb250YWlucyhlLHQscikpKX1pZih0eXBlb2YgdD09PVwic3RyaW5nXCIpe2lmKGlzRW1wdHlTdHJpbmcoZSl8fGlzRW1wdHlTdHJpbmcodCkpe3JldHVybiBmYWxzZX1pZihlLmluY2x1ZGVzKHQpfHxlLnN0YXJ0c1dpdGgoXCIuL1wiKSYmZS5zbGljZSgyKS5pbmNsdWRlcyh0KSl7cmV0dXJuIHRydWV9fXJldHVybiBtaWNyb21hdGNoLmlzTWF0Y2goZSx0LHsuLi5yLGNvbnRhaW5zOnRydWV9KX07bWljcm9tYXRjaC5tYXRjaEtleXM9KGUsdCxyKT0+e2lmKCFvLmlzT2JqZWN0KGUpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdFwiKX1sZXQgbj1taWNyb21hdGNoKE9iamVjdC5rZXlzKGUpLHQscik7bGV0IHU9e307Zm9yKGxldCB0IG9mIG4pdVt0XT1lW3RdO3JldHVybiB1fTttaWNyb21hdGNoLnNvbWU9KGUsdCxyKT0+e2xldCBuPVtdLmNvbmNhdChlKTtmb3IobGV0IGUgb2ZbXS5jb25jYXQodCkpe2xldCB0PXMoU3RyaW5nKGUpLHIpO2lmKG4uc29tZSgoZT0+dChlKSkpKXtyZXR1cm4gdHJ1ZX19cmV0dXJuIGZhbHNlfTttaWNyb21hdGNoLmV2ZXJ5PShlLHQscik9PntsZXQgbj1bXS5jb25jYXQoZSk7Zm9yKGxldCBlIG9mW10uY29uY2F0KHQpKXtsZXQgdD1zKFN0cmluZyhlKSxyKTtpZighbi5ldmVyeSgoZT0+dChlKSkpKXtyZXR1cm4gZmFsc2V9fXJldHVybiB0cnVlfTttaWNyb21hdGNoLmFsbD0oZSx0LHIpPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBhIHN0cmluZzogXCIke24uaW5zcGVjdChlKX1cImApfXJldHVybltdLmNvbmNhdCh0KS5ldmVyeSgodD0+cyh0LHIpKGUpKSl9O21pY3JvbWF0Y2guY2FwdHVyZT0oZSx0LHIpPT57bGV0IG49by5pc1dpbmRvd3Mocik7bGV0IHU9cy5tYWtlUmUoU3RyaW5nKGUpLHsuLi5yLGNhcHR1cmU6dHJ1ZX0pO2xldCBpPXUuZXhlYyhuP28udG9Qb3NpeFNsYXNoZXModCk6dCk7aWYoaSl7cmV0dXJuIGkuc2xpY2UoMSkubWFwKChlPT5lPT09dm9pZCAwP1wiXCI6ZSkpfX07bWljcm9tYXRjaC5tYWtlUmU9KC4uLmUpPT5zLm1ha2VSZSguLi5lKTttaWNyb21hdGNoLnNjYW49KC4uLmUpPT5zLnNjYW4oLi4uZSk7bWljcm9tYXRjaC5wYXJzZT0oZSx0KT0+e2xldCByPVtdO2ZvcihsZXQgbiBvZltdLmNvbmNhdChlfHxbXSkpe2ZvcihsZXQgZSBvZiB1KFN0cmluZyhuKSx0KSl7ci5wdXNoKHMucGFyc2UoZSx0KSl9fXJldHVybiByfTttaWNyb21hdGNoLmJyYWNlcz0oZSx0KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBzdHJpbmdcIik7aWYodCYmdC5ub2JyYWNlPT09dHJ1ZXx8IS9cXHsuKlxcfS8udGVzdChlKSl7cmV0dXJuW2VdfXJldHVybiB1KGUsdCl9O21pY3JvbWF0Y2guYnJhY2VFeHBhbmQ9KGUsdCk9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpO3JldHVybiBtaWNyb21hdGNoLmJyYWNlcyhlLHsuLi50LGV4cGFuZDp0cnVlfSl9O2UuZXhwb3J0cz1taWNyb21hdGNofSw2MDE6KGUsdCxyKT0+e2UuZXhwb3J0cz1yKDUwOSl9LDg3MTooZSx0LHIpPT57Y29uc3Qgbj1yKDE3KTtjb25zdCB1PVwiXFxcXFxcXFwvXCI7Y29uc3Qgcz1gW14ke3V9XWA7Y29uc3Qgbz1cIlxcXFwuXCI7Y29uc3QgaT1cIlxcXFwrXCI7Y29uc3QgYT1cIlxcXFw/XCI7Y29uc3QgbD1cIlxcXFwvXCI7Y29uc3QgYz1cIig/PS4pXCI7Y29uc3QgcD1cIlteL11cIjtjb25zdCBmPWAoPzoke2x9fCQpYDtjb25zdCBBPWAoPzpefCR7bH0pYDtjb25zdCBSPWAke299ezEsMn0ke2Z9YDtjb25zdCBfPWAoPyEke299KWA7Y29uc3QgaD1gKD8hJHtBfSR7Un0pYDtjb25zdCBnPWAoPyEke299ezAsMX0ke2Z9KWA7Y29uc3QgRT1gKD8hJHtSfSlgO2NvbnN0IEM9YFteLiR7bH1dYDtjb25zdCB5PWAke3B9Kj9gO2NvbnN0IGQ9e0RPVF9MSVRFUkFMOm8sUExVU19MSVRFUkFMOmksUU1BUktfTElURVJBTDphLFNMQVNIX0xJVEVSQUw6bCxPTkVfQ0hBUjpjLFFNQVJLOnAsRU5EX0FOQ0hPUjpmLERPVFNfU0xBU0g6UixOT19ET1Q6XyxOT19ET1RTOmgsTk9fRE9UX1NMQVNIOmcsTk9fRE9UU19TTEFTSDpFLFFNQVJLX05PX0RPVDpDLFNUQVI6eSxTVEFSVF9BTkNIT1I6QX07Y29uc3QgeD17Li4uZCxTTEFTSF9MSVRFUkFMOmBbJHt1fV1gLFFNQVJLOnMsU1RBUjpgJHtzfSo/YCxET1RTX1NMQVNIOmAke299ezEsMn0oPzpbJHt1fV18JClgLE5PX0RPVDpgKD8hJHtvfSlgLE5PX0RPVFM6YCg/ISg/Ol58WyR7dX1dKSR7b317MSwyfSg/Olske3V9XXwkKSlgLE5PX0RPVF9TTEFTSDpgKD8hJHtvfXswLDF9KD86WyR7dX1dfCQpKWAsTk9fRE9UU19TTEFTSDpgKD8hJHtvfXsxLDJ9KD86WyR7dX1dfCQpKWAsUU1BUktfTk9fRE9UOmBbXi4ke3V9XWAsU1RBUlRfQU5DSE9SOmAoPzpefFske3V9XSlgLEVORF9BTkNIT1I6YCg/Olske3V9XXwkKWB9O2NvbnN0IGI9e2FsbnVtOlwiYS16QS1aMC05XCIsYWxwaGE6XCJhLXpBLVpcIixhc2NpaTpcIlxcXFx4MDAtXFxcXHg3RlwiLGJsYW5rOlwiIFxcXFx0XCIsY250cmw6XCJcXFxceDAwLVxcXFx4MUZcXFxceDdGXCIsZGlnaXQ6XCIwLTlcIixncmFwaDpcIlxcXFx4MjEtXFxcXHg3RVwiLGxvd2VyOlwiYS16XCIscHJpbnQ6XCJcXFxceDIwLVxcXFx4N0UgXCIscHVuY3Q6XCJcXFxcLSFcXFwiIyQlJicoKVxcXFwqKywuLzo7PD0+P0BbXFxcXF1eX2B7fH1+XCIsc3BhY2U6XCIgXFxcXHRcXFxcclxcXFxuXFxcXHZcXFxcZlwiLHVwcGVyOlwiQS1aXCIsd29yZDpcIkEtWmEtejAtOV9cIix4ZGlnaXQ6XCJBLUZhLWYwLTlcIn07ZS5leHBvcnRzPXtNQVhfTEVOR1RIOjEwMjQqNjQsUE9TSVhfUkVHRVhfU09VUkNFOmIsUkVHRVhfQkFDS1NMQVNIOi9cXFxcKD8hWyorP14ke30ofClbXFxdXSkvZyxSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzovXlteQCFbXFxdLiwkKis/Xnt9KCl8XFxcXC9dKy8sUkVHRVhfU1BFQ0lBTF9DSEFSUzovWy0qKz8uXiR7fSh8KVtcXF1dLyxSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUY6LyhcXFxcPykoKFxcVykoXFwzKikpL2csUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUw6LyhbLSorPy5eJHt9KHwpW1xcXV0pL2csUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSDovKD86XFxbLio/W15cXFxcXVxcXXxcXFxcKD89LikpL2csUkVQTEFDRU1FTlRTOntcIioqKlwiOlwiKlwiLFwiKiovKipcIjpcIioqXCIsXCIqKi8qKi8qKlwiOlwiKipcIn0sQ0hBUl8wOjQ4LENIQVJfOTo1NyxDSEFSX1VQUEVSQ0FTRV9BOjY1LENIQVJfTE9XRVJDQVNFX0E6OTcsQ0hBUl9VUFBFUkNBU0VfWjo5MCxDSEFSX0xPV0VSQ0FTRV9aOjEyMixDSEFSX0xFRlRfUEFSRU5USEVTRVM6NDAsQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUzo0MSxDSEFSX0FTVEVSSVNLOjQyLENIQVJfQU1QRVJTQU5EOjM4LENIQVJfQVQ6NjQsQ0hBUl9CQUNLV0FSRF9TTEFTSDo5MixDSEFSX0NBUlJJQUdFX1JFVFVSTjoxMyxDSEFSX0NJUkNVTUZMRVhfQUNDRU5UOjk0LENIQVJfQ09MT046NTgsQ0hBUl9DT01NQTo0NCxDSEFSX0RPVDo0NixDSEFSX0RPVUJMRV9RVU9URTozNCxDSEFSX0VRVUFMOjYxLENIQVJfRVhDTEFNQVRJT05fTUFSSzozMyxDSEFSX0ZPUk1fRkVFRDoxMixDSEFSX0ZPUldBUkRfU0xBU0g6NDcsQ0hBUl9HUkFWRV9BQ0NFTlQ6OTYsQ0hBUl9IQVNIOjM1LENIQVJfSFlQSEVOX01JTlVTOjQ1LENIQVJfTEVGVF9BTkdMRV9CUkFDS0VUOjYwLENIQVJfTEVGVF9DVVJMWV9CUkFDRToxMjMsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOjkxLENIQVJfTElORV9GRUVEOjEwLENIQVJfTk9fQlJFQUtfU1BBQ0U6MTYwLENIQVJfUEVSQ0VOVDozNyxDSEFSX1BMVVM6NDMsQ0hBUl9RVUVTVElPTl9NQVJLOjYzLENIQVJfUklHSFRfQU5HTEVfQlJBQ0tFVDo2MixDSEFSX1JJR0hUX0NVUkxZX0JSQUNFOjEyNSxDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUOjkzLENIQVJfU0VNSUNPTE9OOjU5LENIQVJfU0lOR0xFX1FVT1RFOjM5LENIQVJfU1BBQ0U6MzIsQ0hBUl9UQUI6OSxDSEFSX1VOREVSU0NPUkU6OTUsQ0hBUl9WRVJUSUNBTF9MSU5FOjEyNCxDSEFSX1pFUk9fV0lEVEhfTk9CUkVBS19TUEFDRTo2NTI3OSxTRVA6bi5zZXAsZXh0Z2xvYkNoYXJzKGUpe3JldHVybntcIiFcIjp7dHlwZTpcIm5lZ2F0ZVwiLG9wZW46XCIoPzooPyEoPzpcIixjbG9zZTpgKSkke2UuU1RBUn0pYH0sXCI/XCI6e3R5cGU6XCJxbWFya1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIik/XCJ9LFwiK1wiOnt0eXBlOlwicGx1c1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIikrXCJ9LFwiKlwiOnt0eXBlOlwic3RhclwiLG9wZW46XCIoPzpcIixjbG9zZTpcIikqXCJ9LFwiQFwiOnt0eXBlOlwiYXRcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpXCJ9fX0sZ2xvYkNoYXJzKGUpe3JldHVybiBlPT09dHJ1ZT94OmR9fX0sODIxOihlLHQscik9Pntjb25zdCBuPXIoODcxKTtjb25zdCB1PXIoMjQzKTtjb25zdHtNQVhfTEVOR1RIOnMsUE9TSVhfUkVHRVhfU09VUkNFOm8sUkVHRVhfTk9OX1NQRUNJQUxfQ0hBUlM6aSxSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUY6YSxSRVBMQUNFTUVOVFM6bH09bjtjb25zdCBleHBhbmRSYW5nZT0oZSx0KT0+e2lmKHR5cGVvZiB0LmV4cGFuZFJhbmdlPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gdC5leHBhbmRSYW5nZSguLi5lLHQpfWUuc29ydCgpO2NvbnN0IHI9YFske2Uuam9pbihcIi1cIil9XWA7dHJ5e25ldyBSZWdFeHAocil9Y2F0Y2godCl7cmV0dXJuIGUubWFwKChlPT51LmVzY2FwZVJlZ2V4KGUpKSkuam9pbihcIi4uXCIpfXJldHVybiByfTtjb25zdCBzeW50YXhFcnJvcj0oZSx0KT0+YE1pc3NpbmcgJHtlfTogXCIke3R9XCIgLSB1c2UgXCJcXFxcXFxcXCR7dH1cIiB0byBtYXRjaCBsaXRlcmFsIGNoYXJhY3RlcnNgO2NvbnN0IHBhcnNlPShlLHQpPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBzdHJpbmdcIil9ZT1sW2VdfHxlO2NvbnN0IHI9ey4uLnR9O2NvbnN0IGM9dHlwZW9mIHIubWF4TGVuZ3RoPT09XCJudW1iZXJcIj9NYXRoLm1pbihzLHIubWF4TGVuZ3RoKTpzO2xldCBwPWUubGVuZ3RoO2lmKHA+Yyl7dGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7cH0sIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIGxlbmd0aDogJHtjfWApfWNvbnN0IGY9e3R5cGU6XCJib3NcIix2YWx1ZTpcIlwiLG91dHB1dDpyLnByZXBlbmR8fFwiXCJ9O2NvbnN0IEE9W2ZdO2NvbnN0IFI9ci5jYXB0dXJlP1wiXCI6XCI/OlwiO2NvbnN0IF89dS5pc1dpbmRvd3ModCk7Y29uc3QgaD1uLmdsb2JDaGFycyhfKTtjb25zdCBnPW4uZXh0Z2xvYkNoYXJzKGgpO2NvbnN0e0RPVF9MSVRFUkFMOkUsUExVU19MSVRFUkFMOkMsU0xBU0hfTElURVJBTDp5LE9ORV9DSEFSOmQsRE9UU19TTEFTSDp4LE5PX0RPVDpiLE5PX0RPVF9TTEFTSDpTLE5PX0RPVFNfU0xBU0g6SCxRTUFSSzp2LFFNQVJLX05PX0RPVDokLFNUQVI6bSxTVEFSVF9BTkNIT1I6VH09aDtjb25zdCBnbG9ic3Rhcj1lPT5gKCR7Un0oPzooPyEke1R9JHtlLmRvdD94OkV9KS4pKj8pYDtjb25zdCBMPXIuZG90P1wiXCI6Yjtjb25zdCBPPXIuZG90P3Y6JDtsZXQgdz1yLmJhc2g9PT10cnVlP2dsb2JzdGFyKHIpOm07aWYoci5jYXB0dXJlKXt3PWAoJHt3fSlgfWlmKHR5cGVvZiByLm5vZXh0PT09XCJib29sZWFuXCIpe3Iubm9leHRnbG9iPXIubm9leHR9Y29uc3QgTj17aW5wdXQ6ZSxpbmRleDotMSxzdGFydDowLGRvdDpyLmRvdD09PXRydWUsY29uc3VtZWQ6XCJcIixvdXRwdXQ6XCJcIixwcmVmaXg6XCJcIixiYWNrdHJhY2s6ZmFsc2UsbmVnYXRlZDpmYWxzZSxicmFja2V0czowLGJyYWNlczowLHBhcmVuczowLHF1b3RlczowLGdsb2JzdGFyOmZhbHNlLHRva2VuczpBfTtlPXUucmVtb3ZlUHJlZml4KGUsTik7cD1lLmxlbmd0aDtjb25zdCBrPVtdO2NvbnN0IEk9W107Y29uc3QgTT1bXTtsZXQgUD1mO2xldCBCO2NvbnN0IGVvcz0oKT0+Ti5pbmRleD09PXAtMTtjb25zdCBHPU4ucGVlaz0odD0xKT0+ZVtOLmluZGV4K3RdO2NvbnN0IEQ9Ti5hZHZhbmNlPSgpPT5lWysrTi5pbmRleF07Y29uc3QgcmVtYWluaW5nPSgpPT5lLnNsaWNlKE4uaW5kZXgrMSk7Y29uc3QgY29uc3VtZT0oZT1cIlwiLHQ9MCk9PntOLmNvbnN1bWVkKz1lO04uaW5kZXgrPXR9O2NvbnN0IGFwcGVuZD1lPT57Ti5vdXRwdXQrPWUub3V0cHV0IT1udWxsP2Uub3V0cHV0OmUudmFsdWU7Y29uc3VtZShlLnZhbHVlKX07Y29uc3QgbmVnYXRlPSgpPT57bGV0IGU9MTt3aGlsZShHKCk9PT1cIiFcIiYmKEcoMikhPT1cIihcInx8RygzKT09PVwiP1wiKSl7RCgpO04uc3RhcnQrKztlKyt9aWYoZSUyPT09MCl7cmV0dXJuIGZhbHNlfU4ubmVnYXRlZD10cnVlO04uc3RhcnQrKztyZXR1cm4gdHJ1ZX07Y29uc3QgaW5jcmVtZW50PWU9PntOW2VdKys7TS5wdXNoKGUpfTtjb25zdCBkZWNyZW1lbnQ9ZT0+e05bZV0tLTtNLnBvcCgpfTtjb25zdCBwdXNoPWU9PntpZihQLnR5cGU9PT1cImdsb2JzdGFyXCIpe2NvbnN0IHQ9Ti5icmFjZXM+MCYmKGUudHlwZT09PVwiY29tbWFcInx8ZS50eXBlPT09XCJicmFjZVwiKTtjb25zdCByPWUuZXh0Z2xvYj09PXRydWV8fGsubGVuZ3RoJiYoZS50eXBlPT09XCJwaXBlXCJ8fGUudHlwZT09PVwicGFyZW5cIik7aWYoZS50eXBlIT09XCJzbGFzaFwiJiZlLnR5cGUhPT1cInBhcmVuXCImJiF0JiYhcil7Ti5vdXRwdXQ9Ti5vdXRwdXQuc2xpY2UoMCwtUC5vdXRwdXQubGVuZ3RoKTtQLnR5cGU9XCJzdGFyXCI7UC52YWx1ZT1cIipcIjtQLm91dHB1dD13O04ub3V0cHV0Kz1QLm91dHB1dH19aWYoay5sZW5ndGgmJmUudHlwZSE9PVwicGFyZW5cIiYmIWdbZS52YWx1ZV0pe2tbay5sZW5ndGgtMV0uaW5uZXIrPWUudmFsdWV9aWYoZS52YWx1ZXx8ZS5vdXRwdXQpYXBwZW5kKGUpO2lmKFAmJlAudHlwZT09PVwidGV4dFwiJiZlLnR5cGU9PT1cInRleHRcIil7UC52YWx1ZSs9ZS52YWx1ZTtQLm91dHB1dD0oUC5vdXRwdXR8fFwiXCIpK2UudmFsdWU7cmV0dXJufWUucHJldj1QO0EucHVzaChlKTtQPWV9O2NvbnN0IGV4dGdsb2JPcGVuPShlLHQpPT57Y29uc3Qgbj17Li4uZ1t0XSxjb25kaXRpb25zOjEsaW5uZXI6XCJcIn07bi5wcmV2PVA7bi5wYXJlbnM9Ti5wYXJlbnM7bi5vdXRwdXQ9Ti5vdXRwdXQ7Y29uc3QgdT0oci5jYXB0dXJlP1wiKFwiOlwiXCIpK24ub3BlbjtpbmNyZW1lbnQoXCJwYXJlbnNcIik7cHVzaCh7dHlwZTplLHZhbHVlOnQsb3V0cHV0Ok4ub3V0cHV0P1wiXCI6ZH0pO3B1c2goe3R5cGU6XCJwYXJlblwiLGV4dGdsb2I6dHJ1ZSx2YWx1ZTpEKCksb3V0cHV0OnV9KTtrLnB1c2gobil9O2NvbnN0IGV4dGdsb2JDbG9zZT1lPT57bGV0IHQ9ZS5jbG9zZSsoci5jYXB0dXJlP1wiKVwiOlwiXCIpO2lmKGUudHlwZT09PVwibmVnYXRlXCIpe2xldCBuPXc7aWYoZS5pbm5lciYmZS5pbm5lci5sZW5ndGg+MSYmZS5pbm5lci5pbmNsdWRlcyhcIi9cIikpe249Z2xvYnN0YXIocil9aWYobiE9PXd8fGVvcygpfHwvXlxcKSskLy50ZXN0KHJlbWFpbmluZygpKSl7dD1lLmNsb3NlPWApJCkpJHtufWB9aWYoZS5wcmV2LnR5cGU9PT1cImJvc1wiKXtOLm5lZ2F0ZWRFeHRnbG9iPXRydWV9fXB1c2goe3R5cGU6XCJwYXJlblwiLGV4dGdsb2I6dHJ1ZSx2YWx1ZTpCLG91dHB1dDp0fSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpfTtpZihyLmZhc3RwYXRocyE9PWZhbHNlJiYhLyheWyohXXxbLygpW1xcXXt9XCJdKS8udGVzdChlKSl7bGV0IG49ZmFsc2U7bGV0IHM9ZS5yZXBsYWNlKGEsKChlLHQscix1LHMsbyk9PntpZih1PT09XCJcXFxcXCIpe249dHJ1ZTtyZXR1cm4gZX1pZih1PT09XCI/XCIpe2lmKHQpe3JldHVybiB0K3UrKHM/di5yZXBlYXQocy5sZW5ndGgpOlwiXCIpfWlmKG89PT0wKXtyZXR1cm4gTysocz92LnJlcGVhdChzLmxlbmd0aCk6XCJcIil9cmV0dXJuIHYucmVwZWF0KHIubGVuZ3RoKX1pZih1PT09XCIuXCIpe3JldHVybiBFLnJlcGVhdChyLmxlbmd0aCl9aWYodT09PVwiKlwiKXtpZih0KXtyZXR1cm4gdCt1KyhzP3c6XCJcIil9cmV0dXJuIHd9cmV0dXJuIHQ/ZTpgXFxcXCR7ZX1gfSkpO2lmKG49PT10cnVlKXtpZihyLnVuZXNjYXBlPT09dHJ1ZSl7cz1zLnJlcGxhY2UoL1xcXFwvZyxcIlwiKX1lbHNle3M9cy5yZXBsYWNlKC9cXFxcKy9nLChlPT5lLmxlbmd0aCUyPT09MD9cIlxcXFxcXFxcXCI6ZT9cIlxcXFxcIjpcIlwiKSl9fWlmKHM9PT1lJiZyLmNvbnRhaW5zPT09dHJ1ZSl7Ti5vdXRwdXQ9ZTtyZXR1cm4gTn1OLm91dHB1dD11LndyYXBPdXRwdXQocyxOLHQpO3JldHVybiBOfXdoaWxlKCFlb3MoKSl7Qj1EKCk7aWYoQj09PVwiXFwwXCIpe2NvbnRpbnVlfWlmKEI9PT1cIlxcXFxcIil7Y29uc3QgZT1HKCk7aWYoZT09PVwiL1wiJiZyLmJhc2ghPT10cnVlKXtjb250aW51ZX1pZihlPT09XCIuXCJ8fGU9PT1cIjtcIil7Y29udGludWV9aWYoIWUpe0IrPVwiXFxcXFwiO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWNvbnN0IHQ9L15cXFxcKy8uZXhlYyhyZW1haW5pbmcoKSk7bGV0IG49MDtpZih0JiZ0WzBdLmxlbmd0aD4yKXtuPXRbMF0ubGVuZ3RoO04uaW5kZXgrPW47aWYobiUyIT09MCl7Qis9XCJcXFxcXCJ9fWlmKHIudW5lc2NhcGU9PT10cnVlKXtCPUQoKXx8XCJcIn1lbHNle0IrPUQoKXx8XCJcIn1pZihOLmJyYWNrZXRzPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCfSk7Y29udGludWV9fWlmKE4uYnJhY2tldHM+MCYmKEIhPT1cIl1cInx8UC52YWx1ZT09PVwiW1wifHxQLnZhbHVlPT09XCJbXlwiKSl7aWYoci5wb3NpeCE9PWZhbHNlJiZCPT09XCI6XCIpe2NvbnN0IGU9UC52YWx1ZS5zbGljZSgxKTtpZihlLmluY2x1ZGVzKFwiW1wiKSl7UC5wb3NpeD10cnVlO2lmKGUuaW5jbHVkZXMoXCI6XCIpKXtjb25zdCBlPVAudmFsdWUubGFzdEluZGV4T2YoXCJbXCIpO2NvbnN0IHQ9UC52YWx1ZS5zbGljZSgwLGUpO2NvbnN0IHI9UC52YWx1ZS5zbGljZShlKzIpO2NvbnN0IG49b1tyXTtpZihuKXtQLnZhbHVlPXQrbjtOLmJhY2t0cmFjaz10cnVlO0QoKTtpZighZi5vdXRwdXQmJkEuaW5kZXhPZihQKT09PTEpe2Yub3V0cHV0PWR9Y29udGludWV9fX19aWYoQj09PVwiW1wiJiZHKCkhPT1cIjpcInx8Qj09PVwiLVwiJiZHKCk9PT1cIl1cIil7Qj1gXFxcXCR7Qn1gfWlmKEI9PT1cIl1cIiYmKFAudmFsdWU9PT1cIltcInx8UC52YWx1ZT09PVwiW15cIikpe0I9YFxcXFwke0J9YH1pZihyLnBvc2l4PT09dHJ1ZSYmQj09PVwiIVwiJiZQLnZhbHVlPT09XCJbXCIpe0I9XCJeXCJ9UC52YWx1ZSs9QjthcHBlbmQoe3ZhbHVlOkJ9KTtjb250aW51ZX1pZihOLnF1b3Rlcz09PTEmJkIhPT0nXCInKXtCPXUuZXNjYXBlUmVnZXgoQik7UC52YWx1ZSs9QjthcHBlbmQoe3ZhbHVlOkJ9KTtjb250aW51ZX1pZihCPT09J1wiJyl7Ti5xdW90ZXM9Ti5xdW90ZXM9PT0xPzA6MTtpZihyLmtlZXBRdW90ZXM9PT10cnVlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KX1jb250aW51ZX1pZihCPT09XCIoXCIpe2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpCfSk7Y29udGludWV9aWYoQj09PVwiKVwiKXtpZihOLnBhcmVucz09PTAmJnIuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCIoXCIpKX1jb25zdCBlPWtbay5sZW5ndGgtMV07aWYoZSYmTi5wYXJlbnM9PT1lLnBhcmVucysxKXtleHRnbG9iQ2xvc2Uoay5wb3AoKSk7Y29udGludWV9cHVzaCh7dHlwZTpcInBhcmVuXCIsdmFsdWU6QixvdXRwdXQ6Ti5wYXJlbnM/XCIpXCI6XCJcXFxcKVwifSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpO2NvbnRpbnVlfWlmKEI9PT1cIltcIil7aWYoci5ub2JyYWNrZXQ9PT10cnVlfHwhcmVtYWluaW5nKCkuaW5jbHVkZXMoXCJdXCIpKXtpZihyLm5vYnJhY2tldCE9PXRydWUmJnIuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJdXCIpKX1CPWBcXFxcJHtCfWB9ZWxzZXtpbmNyZW1lbnQoXCJicmFja2V0c1wiKX1wdXNoKHt0eXBlOlwiYnJhY2tldFwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihCPT09XCJdXCIpe2lmKHIubm9icmFja2V0PT09dHJ1ZXx8UCYmUC50eXBlPT09XCJicmFja2V0XCImJlAudmFsdWUubGVuZ3RoPT09MSl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDpgXFxcXCR7Qn1gfSk7Y29udGludWV9aWYoTi5icmFja2V0cz09PTApe2lmKHIuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCJbXCIpKX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OmBcXFxcJHtCfWB9KTtjb250aW51ZX1kZWNyZW1lbnQoXCJicmFja2V0c1wiKTtjb25zdCBlPVAudmFsdWUuc2xpY2UoMSk7aWYoUC5wb3NpeCE9PXRydWUmJmVbMF09PT1cIl5cIiYmIWUuaW5jbHVkZXMoXCIvXCIpKXtCPWAvJHtCfWB9UC52YWx1ZSs9QjthcHBlbmQoe3ZhbHVlOkJ9KTtpZihyLmxpdGVyYWxCcmFja2V0cz09PWZhbHNlfHx1Lmhhc1JlZ2V4Q2hhcnMoZSkpe2NvbnRpbnVlfWNvbnN0IHQ9dS5lc2NhcGVSZWdleChQLnZhbHVlKTtOLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC1QLnZhbHVlLmxlbmd0aCk7aWYoci5saXRlcmFsQnJhY2tldHM9PT10cnVlKXtOLm91dHB1dCs9dDtQLnZhbHVlPXQ7Y29udGludWV9UC52YWx1ZT1gKCR7Un0ke3R9fCR7UC52YWx1ZX0pYDtOLm91dHB1dCs9UC52YWx1ZTtjb250aW51ZX1pZihCPT09XCJ7XCImJnIubm9icmFjZSE9PXRydWUpe2luY3JlbWVudChcImJyYWNlc1wiKTtjb25zdCBlPXt0eXBlOlwiYnJhY2VcIix2YWx1ZTpCLG91dHB1dDpcIihcIixvdXRwdXRJbmRleDpOLm91dHB1dC5sZW5ndGgsdG9rZW5zSW5kZXg6Ti50b2tlbnMubGVuZ3RofTtJLnB1c2goZSk7cHVzaChlKTtjb250aW51ZX1pZihCPT09XCJ9XCIpe2NvbnN0IGU9SVtJLmxlbmd0aC0xXTtpZihyLm5vYnJhY2U9PT10cnVlfHwhZSl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDpCfSk7Y29udGludWV9bGV0IHQ9XCIpXCI7aWYoZS5kb3RzPT09dHJ1ZSl7Y29uc3QgZT1BLnNsaWNlKCk7Y29uc3Qgbj1bXTtmb3IobGV0IHQ9ZS5sZW5ndGgtMTt0Pj0wO3QtLSl7QS5wb3AoKTtpZihlW3RdLnR5cGU9PT1cImJyYWNlXCIpe2JyZWFrfWlmKGVbdF0udHlwZSE9PVwiZG90c1wiKXtuLnVuc2hpZnQoZVt0XS52YWx1ZSl9fXQ9ZXhwYW5kUmFuZ2UobixyKTtOLmJhY2t0cmFjaz10cnVlfWlmKGUuY29tbWEhPT10cnVlJiZlLmRvdHMhPT10cnVlKXtjb25zdCByPU4ub3V0cHV0LnNsaWNlKDAsZS5vdXRwdXRJbmRleCk7Y29uc3Qgbj1OLnRva2Vucy5zbGljZShlLnRva2Vuc0luZGV4KTtlLnZhbHVlPWUub3V0cHV0PVwiXFxcXHtcIjtCPXQ9XCJcXFxcfVwiO04ub3V0cHV0PXI7Zm9yKGNvbnN0IGUgb2Ygbil7Ti5vdXRwdXQrPWUub3V0cHV0fHxlLnZhbHVlfX1wdXNoKHt0eXBlOlwiYnJhY2VcIix2YWx1ZTpCLG91dHB1dDp0fSk7ZGVjcmVtZW50KFwiYnJhY2VzXCIpO0kucG9wKCk7Y29udGludWV9aWYoQj09PVwifFwiKXtpZihrLmxlbmd0aD4wKXtrW2subGVuZ3RoLTFdLmNvbmRpdGlvbnMrK31wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihCPT09XCIsXCIpe2xldCBlPUI7Y29uc3QgdD1JW0kubGVuZ3RoLTFdO2lmKHQmJk1bTS5sZW5ndGgtMV09PT1cImJyYWNlc1wiKXt0LmNvbW1hPXRydWU7ZT1cInxcIn1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTpCLG91dHB1dDplfSk7Y29udGludWV9aWYoQj09PVwiL1wiKXtpZihQLnR5cGU9PT1cImRvdFwiJiZOLmluZGV4PT09Ti5zdGFydCsxKXtOLnN0YXJ0PU4uaW5kZXgrMTtOLmNvbnN1bWVkPVwiXCI7Ti5vdXRwdXQ9XCJcIjtBLnBvcCgpO1A9Zjtjb250aW51ZX1wdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpCLG91dHB1dDp5fSk7Y29udGludWV9aWYoQj09PVwiLlwiKXtpZihOLmJyYWNlcz4wJiZQLnR5cGU9PT1cImRvdFwiKXtpZihQLnZhbHVlPT09XCIuXCIpUC5vdXRwdXQ9RTtjb25zdCBlPUlbSS5sZW5ndGgtMV07UC50eXBlPVwiZG90c1wiO1Aub3V0cHV0Kz1CO1AudmFsdWUrPUI7ZS5kb3RzPXRydWU7Y29udGludWV9aWYoTi5icmFjZXMrTi5wYXJlbnM9PT0wJiZQLnR5cGUhPT1cImJvc1wiJiZQLnR5cGUhPT1cInNsYXNoXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6QixvdXRwdXQ6RX0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJkb3RcIix2YWx1ZTpCLG91dHB1dDpFfSk7Y29udGludWV9aWYoQj09PVwiP1wiKXtjb25zdCBlPVAmJlAudmFsdWU9PT1cIihcIjtpZighZSYmci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIiYmRygyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInFtYXJrXCIsQik7Y29udGludWV9aWYoUCYmUC50eXBlPT09XCJwYXJlblwiKXtjb25zdCBlPUcoKTtsZXQgdD1CO2lmKGU9PT1cIjxcIiYmIXUuc3VwcG9ydHNMb29rYmVoaW5kcygpKXt0aHJvdyBuZXcgRXJyb3IoXCJOb2RlLmpzIHYxMCBvciBoaWdoZXIgaXMgcmVxdWlyZWQgZm9yIHJlZ2V4IGxvb2tiZWhpbmRzXCIpfWlmKFAudmFsdWU9PT1cIihcIiYmIS9bIT08Ol0vLnRlc3QoZSl8fGU9PT1cIjxcIiYmIS88KFshPV18XFx3Kz4pLy50ZXN0KHJlbWFpbmluZygpKSl7dD1gXFxcXCR7Qn1gfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6QixvdXRwdXQ6dH0pO2NvbnRpbnVlfWlmKHIuZG90IT09dHJ1ZSYmKFAudHlwZT09PVwic2xhc2hcInx8UC50eXBlPT09XCJib3NcIikpe3B1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkIsb3V0cHV0OiR9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicW1hcmtcIix2YWx1ZTpCLG91dHB1dDp2fSk7Y29udGludWV9aWYoQj09PVwiIVwiKXtpZihyLm5vZXh0Z2xvYiE9PXRydWUmJkcoKT09PVwiKFwiKXtpZihHKDIpIT09XCI/XCJ8fCEvWyE9PDpdLy50ZXN0KEcoMykpKXtleHRnbG9iT3BlbihcIm5lZ2F0ZVwiLEIpO2NvbnRpbnVlfX1pZihyLm5vbmVnYXRlIT09dHJ1ZSYmTi5pbmRleD09PTApe25lZ2F0ZSgpO2NvbnRpbnVlfX1pZihCPT09XCIrXCIpe2lmKHIubm9leHRnbG9iIT09dHJ1ZSYmRygpPT09XCIoXCImJkcoMikhPT1cIj9cIil7ZXh0Z2xvYk9wZW4oXCJwbHVzXCIsQik7Y29udGludWV9aWYoUCYmUC52YWx1ZT09PVwiKFwifHxyLnJlZ2V4PT09ZmFsc2Upe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6QixvdXRwdXQ6Q30pO2NvbnRpbnVlfWlmKFAmJihQLnR5cGU9PT1cImJyYWNrZXRcInx8UC50eXBlPT09XCJwYXJlblwifHxQLnR5cGU9PT1cImJyYWNlXCIpfHxOLnBhcmVucz4wKXtwdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOkJ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOkN9KTtjb250aW51ZX1pZihCPT09XCJAXCIpe2lmKHIubm9leHRnbG9iIT09dHJ1ZSYmRygpPT09XCIoXCImJkcoMikhPT1cIj9cIil7cHVzaCh7dHlwZTpcImF0XCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihCIT09XCIqXCIpe2lmKEI9PT1cIiRcInx8Qj09PVwiXlwiKXtCPWBcXFxcJHtCfWB9Y29uc3QgZT1pLmV4ZWMocmVtYWluaW5nKCkpO2lmKGUpe0IrPWVbMF07Ti5pbmRleCs9ZVswXS5sZW5ndGh9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCfSk7Y29udGludWV9aWYoUCYmKFAudHlwZT09PVwiZ2xvYnN0YXJcInx8UC5zdGFyPT09dHJ1ZSkpe1AudHlwZT1cInN0YXJcIjtQLnN0YXI9dHJ1ZTtQLnZhbHVlKz1CO1Aub3V0cHV0PXc7Ti5iYWNrdHJhY2s9dHJ1ZTtOLmdsb2JzdGFyPXRydWU7Y29uc3VtZShCKTtjb250aW51ZX1sZXQgdD1yZW1haW5pbmcoKTtpZihyLm5vZXh0Z2xvYiE9PXRydWUmJi9eXFwoW14/XS8udGVzdCh0KSl7ZXh0Z2xvYk9wZW4oXCJzdGFyXCIsQik7Y29udGludWV9aWYoUC50eXBlPT09XCJzdGFyXCIpe2lmKHIubm9nbG9ic3Rhcj09PXRydWUpe2NvbnN1bWUoQik7Y29udGludWV9Y29uc3Qgbj1QLnByZXY7Y29uc3QgdT1uLnByZXY7Y29uc3Qgcz1uLnR5cGU9PT1cInNsYXNoXCJ8fG4udHlwZT09PVwiYm9zXCI7Y29uc3Qgbz11JiYodS50eXBlPT09XCJzdGFyXCJ8fHUudHlwZT09PVwiZ2xvYnN0YXJcIik7aWYoci5iYXNoPT09dHJ1ZSYmKCFzfHx0WzBdJiZ0WzBdIT09XCIvXCIpKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1jb25zdCBpPU4uYnJhY2VzPjAmJihuLnR5cGU9PT1cImNvbW1hXCJ8fG4udHlwZT09PVwiYnJhY2VcIik7Y29uc3QgYT1rLmxlbmd0aCYmKG4udHlwZT09PVwicGlwZVwifHxuLnR5cGU9PT1cInBhcmVuXCIpO2lmKCFzJiZuLnR5cGUhPT1cInBhcmVuXCImJiFpJiYhYSl7cHVzaCh7dHlwZTpcInN0YXJcIix2YWx1ZTpCLG91dHB1dDpcIlwifSk7Y29udGludWV9d2hpbGUodC5zbGljZSgwLDMpPT09XCIvKipcIil7Y29uc3Qgcj1lW04uaW5kZXgrNF07aWYociYmciE9PVwiL1wiKXticmVha310PXQuc2xpY2UoMyk7Y29uc3VtZShcIi8qKlwiLDMpfWlmKG4udHlwZT09PVwiYm9zXCImJmVvcygpKXtQLnR5cGU9XCJnbG9ic3RhclwiO1AudmFsdWUrPUI7UC5vdXRwdXQ9Z2xvYnN0YXIocik7Ti5vdXRwdXQ9UC5vdXRwdXQ7Ti5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoQik7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJiFvJiZlb3MoKSl7Ti5vdXRwdXQ9Ti5vdXRwdXQuc2xpY2UoMCwtKG4ub3V0cHV0K1Aub3V0cHV0KS5sZW5ndGgpO24ub3V0cHV0PWAoPzoke24ub3V0cHV0fWA7UC50eXBlPVwiZ2xvYnN0YXJcIjtQLm91dHB1dD1nbG9ic3RhcihyKSsoci5zdHJpY3RTbGFzaGVzP1wiKVwiOlwifCQpXCIpO1AudmFsdWUrPUI7Ti5nbG9ic3Rhcj10cnVlO04ub3V0cHV0Kz1uLm91dHB1dCtQLm91dHB1dDtjb25zdW1lKEIpO2NvbnRpbnVlfWlmKG4udHlwZT09PVwic2xhc2hcIiYmbi5wcmV2LnR5cGUhPT1cImJvc1wiJiZ0WzBdPT09XCIvXCIpe2NvbnN0IGU9dFsxXSE9PXZvaWQgMD9cInwkXCI6XCJcIjtOLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrUC5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtQLnR5cGU9XCJnbG9ic3RhclwiO1Aub3V0cHV0PWAke2dsb2JzdGFyKHIpfSR7eX18JHt5fSR7ZX0pYDtQLnZhbHVlKz1CO04ub3V0cHV0Kz1uLm91dHB1dCtQLm91dHB1dDtOLmdsb2JzdGFyPXRydWU7Y29uc3VtZShCK0QoKSk7cHVzaCh7dHlwZTpcInNsYXNoXCIsdmFsdWU6XCIvXCIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1pZihuLnR5cGU9PT1cImJvc1wiJiZ0WzBdPT09XCIvXCIpe1AudHlwZT1cImdsb2JzdGFyXCI7UC52YWx1ZSs9QjtQLm91dHB1dD1gKD86Xnwke3l9fCR7Z2xvYnN0YXIocil9JHt5fSlgO04ub3V0cHV0PVAub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIrRCgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfU4ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLVAub3V0cHV0Lmxlbmd0aCk7UC50eXBlPVwiZ2xvYnN0YXJcIjtQLm91dHB1dD1nbG9ic3RhcihyKTtQLnZhbHVlKz1CO04ub3V0cHV0Kz1QLm91dHB1dDtOLmdsb2JzdGFyPXRydWU7Y29uc3VtZShCKTtjb250aW51ZX1jb25zdCBuPXt0eXBlOlwic3RhclwiLHZhbHVlOkIsb3V0cHV0Ond9O2lmKHIuYmFzaD09PXRydWUpe24ub3V0cHV0PVwiLio/XCI7aWYoUC50eXBlPT09XCJib3NcInx8UC50eXBlPT09XCJzbGFzaFwiKXtuLm91dHB1dD1MK24ub3V0cHV0fXB1c2gobik7Y29udGludWV9aWYoUCYmKFAudHlwZT09PVwiYnJhY2tldFwifHxQLnR5cGU9PT1cInBhcmVuXCIpJiZyLnJlZ2V4PT09dHJ1ZSl7bi5vdXRwdXQ9QjtwdXNoKG4pO2NvbnRpbnVlfWlmKE4uaW5kZXg9PT1OLnN0YXJ0fHxQLnR5cGU9PT1cInNsYXNoXCJ8fFAudHlwZT09PVwiZG90XCIpe2lmKFAudHlwZT09PVwiZG90XCIpe04ub3V0cHV0Kz1TO1Aub3V0cHV0Kz1TfWVsc2UgaWYoci5kb3Q9PT10cnVlKXtOLm91dHB1dCs9SDtQLm91dHB1dCs9SH1lbHNle04ub3V0cHV0Kz1MO1Aub3V0cHV0Kz1MfWlmKEcoKSE9PVwiKlwiKXtOLm91dHB1dCs9ZDtQLm91dHB1dCs9ZH19cHVzaChuKX13aGlsZShOLmJyYWNrZXRzPjApe2lmKHIuc3RyaWN0QnJhY2tldHM9PT10cnVlKXRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpO04ub3V0cHV0PXUuZXNjYXBlTGFzdChOLm91dHB1dCxcIltcIik7ZGVjcmVtZW50KFwiYnJhY2tldHNcIil9d2hpbGUoTi5wYXJlbnM+MCl7aWYoci5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiKVwiKSk7Ti5vdXRwdXQ9dS5lc2NhcGVMYXN0KE4ub3V0cHV0LFwiKFwiKTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9d2hpbGUoTi5icmFjZXM+MCl7aWYoci5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwifVwiKSk7Ti5vdXRwdXQ9dS5lc2NhcGVMYXN0KE4ub3V0cHV0LFwie1wiKTtkZWNyZW1lbnQoXCJicmFjZXNcIil9aWYoci5zdHJpY3RTbGFzaGVzIT09dHJ1ZSYmKFAudHlwZT09PVwic3RhclwifHxQLnR5cGU9PT1cImJyYWNrZXRcIikpe3B1c2goe3R5cGU6XCJtYXliZV9zbGFzaFwiLHZhbHVlOlwiXCIsb3V0cHV0OmAke3l9P2B9KX1pZihOLmJhY2t0cmFjaz09PXRydWUpe04ub3V0cHV0PVwiXCI7Zm9yKGNvbnN0IGUgb2YgTi50b2tlbnMpe04ub3V0cHV0Kz1lLm91dHB1dCE9bnVsbD9lLm91dHB1dDplLnZhbHVlO2lmKGUuc3VmZml4KXtOLm91dHB1dCs9ZS5zdWZmaXh9fX1yZXR1cm4gTn07cGFyc2UuZmFzdHBhdGhzPShlLHQpPT57Y29uc3Qgcj17Li4udH07Y29uc3Qgbz10eXBlb2Ygci5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsci5tYXhMZW5ndGgpOnM7Y29uc3QgaT1lLmxlbmd0aDtpZihpPm8pe3Rocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke2l9LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7b31gKX1lPWxbZV18fGU7Y29uc3QgYT11LmlzV2luZG93cyh0KTtjb25zdHtET1RfTElURVJBTDpjLFNMQVNIX0xJVEVSQUw6cCxPTkVfQ0hBUjpmLERPVFNfU0xBU0g6QSxOT19ET1Q6UixOT19ET1RTOl8sTk9fRE9UU19TTEFTSDpoLFNUQVI6ZyxTVEFSVF9BTkNIT1I6RX09bi5nbG9iQ2hhcnMoYSk7Y29uc3QgQz1yLmRvdD9fOlI7Y29uc3QgeT1yLmRvdD9oOlI7Y29uc3QgZD1yLmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgeD17bmVnYXRlZDpmYWxzZSxwcmVmaXg6XCJcIn07bGV0IGI9ci5iYXNoPT09dHJ1ZT9cIi4qP1wiOmc7aWYoci5jYXB0dXJlKXtiPWAoJHtifSlgfWNvbnN0IGdsb2JzdGFyPWU9PntpZihlLm5vZ2xvYnN0YXI9PT10cnVlKXJldHVybiBiO3JldHVybmAoJHtkfSg/Oig/ISR7RX0ke2UuZG90P0E6Y30pLikqPylgfTtjb25zdCBjcmVhdGU9ZT0+e3N3aXRjaChlKXtjYXNlXCIqXCI6cmV0dXJuYCR7Q30ke2Z9JHtifWA7Y2FzZVwiLipcIjpyZXR1cm5gJHtjfSR7Zn0ke2J9YDtjYXNlXCIqLipcIjpyZXR1cm5gJHtDfSR7Yn0ke2N9JHtmfSR7Yn1gO2Nhc2VcIiovKlwiOnJldHVybmAke0N9JHtifSR7cH0ke2Z9JHt5fSR7Yn1gO2Nhc2VcIioqXCI6cmV0dXJuIEMrZ2xvYnN0YXIocik7Y2FzZVwiKiovKlwiOnJldHVybmAoPzoke0N9JHtnbG9ic3RhcihyKX0ke3B9KT8ke3l9JHtmfSR7Yn1gO2Nhc2VcIioqLyouKlwiOnJldHVybmAoPzoke0N9JHtnbG9ic3RhcihyKX0ke3B9KT8ke3l9JHtifSR7Y30ke2Z9JHtifWA7Y2FzZVwiKiovLipcIjpyZXR1cm5gKD86JHtDfSR7Z2xvYnN0YXIocil9JHtwfSk/JHtjfSR7Zn0ke2J9YDtkZWZhdWx0Ontjb25zdCB0PS9eKC4qPylcXC4oXFx3KykkLy5leGVjKGUpO2lmKCF0KXJldHVybjtjb25zdCByPWNyZWF0ZSh0WzFdKTtpZighcilyZXR1cm47cmV0dXJuIHIrYyt0WzJdfX19O2NvbnN0IFM9dS5yZW1vdmVQcmVmaXgoZSx4KTtsZXQgSD1jcmVhdGUoUyk7aWYoSCYmci5zdHJpY3RTbGFzaGVzIT09dHJ1ZSl7SCs9YCR7cH0/YH1yZXR1cm4gSH07ZS5leHBvcnRzPXBhcnNlfSw1MDk6KGUsdCxyKT0+e2NvbnN0IG49cigxNyk7Y29uc3QgdT1yKDIxNik7Y29uc3Qgcz1yKDgyMSk7Y29uc3Qgbz1yKDI0Myk7Y29uc3QgaT1yKDg3MSk7Y29uc3QgaXNPYmplY3Q9ZT0+ZSYmdHlwZW9mIGU9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheShlKTtjb25zdCBwaWNvbWF0Y2g9KGUsdCxyPWZhbHNlKT0+e2lmKEFycmF5LmlzQXJyYXkoZSkpe2NvbnN0IG49ZS5tYXAoKGU9PnBpY29tYXRjaChlLHQscikpKTtjb25zdCBhcnJheU1hdGNoZXI9ZT0+e2Zvcihjb25zdCB0IG9mIG4pe2NvbnN0IHI9dChlKTtpZihyKXJldHVybiByfXJldHVybiBmYWxzZX07cmV0dXJuIGFycmF5TWF0Y2hlcn1jb25zdCBuPWlzT2JqZWN0KGUpJiZlLnRva2VucyYmZS5pbnB1dDtpZihlPT09XCJcInx8dHlwZW9mIGUhPT1cInN0cmluZ1wiJiYhbil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWNvbnN0IHU9dHx8e307Y29uc3Qgcz1vLmlzV2luZG93cyh0KTtjb25zdCBpPW4/cGljb21hdGNoLmNvbXBpbGVSZShlLHQpOnBpY29tYXRjaC5tYWtlUmUoZSx0LGZhbHNlLHRydWUpO2NvbnN0IGE9aS5zdGF0ZTtkZWxldGUgaS5zdGF0ZTtsZXQgaXNJZ25vcmVkPSgpPT5mYWxzZTtpZih1Lmlnbm9yZSl7Y29uc3QgZT17Li4udCxpZ25vcmU6bnVsbCxvbk1hdGNoOm51bGwsb25SZXN1bHQ6bnVsbH07aXNJZ25vcmVkPXBpY29tYXRjaCh1Lmlnbm9yZSxlLHIpfWNvbnN0IG1hdGNoZXI9KHIsbj1mYWxzZSk9Pntjb25zdHtpc01hdGNoOm8sbWF0Y2g6bCxvdXRwdXQ6Y309cGljb21hdGNoLnRlc3QocixpLHQse2dsb2I6ZSxwb3NpeDpzfSk7Y29uc3QgcD17Z2xvYjplLHN0YXRlOmEscmVnZXg6aSxwb3NpeDpzLGlucHV0OnIsb3V0cHV0OmMsbWF0Y2g6bCxpc01hdGNoOm99O2lmKHR5cGVvZiB1Lm9uUmVzdWx0PT09XCJmdW5jdGlvblwiKXt1Lm9uUmVzdWx0KHApfWlmKG89PT1mYWxzZSl7cC5pc01hdGNoPWZhbHNlO3JldHVybiBuP3A6ZmFsc2V9aWYoaXNJZ25vcmVkKHIpKXtpZih0eXBlb2YgdS5vbklnbm9yZT09PVwiZnVuY3Rpb25cIil7dS5vbklnbm9yZShwKX1wLmlzTWF0Y2g9ZmFsc2U7cmV0dXJuIG4/cDpmYWxzZX1pZih0eXBlb2YgdS5vbk1hdGNoPT09XCJmdW5jdGlvblwiKXt1Lm9uTWF0Y2gocCl9cmV0dXJuIG4/cDp0cnVlfTtpZihyKXttYXRjaGVyLnN0YXRlPWF9cmV0dXJuIG1hdGNoZXJ9O3BpY29tYXRjaC50ZXN0PShlLHQscix7Z2xvYjpuLHBvc2l4OnV9PXt9KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGlucHV0IHRvIGJlIGEgc3RyaW5nXCIpfWlmKGU9PT1cIlwiKXtyZXR1cm57aXNNYXRjaDpmYWxzZSxvdXRwdXQ6XCJcIn19Y29uc3Qgcz1yfHx7fTtjb25zdCBpPXMuZm9ybWF0fHwodT9vLnRvUG9zaXhTbGFzaGVzOm51bGwpO2xldCBhPWU9PT1uO2xldCBsPWEmJmk/aShlKTplO2lmKGE9PT1mYWxzZSl7bD1pP2koZSk6ZTthPWw9PT1ufWlmKGE9PT1mYWxzZXx8cy5jYXB0dXJlPT09dHJ1ZSl7aWYocy5tYXRjaEJhc2U9PT10cnVlfHxzLmJhc2VuYW1lPT09dHJ1ZSl7YT1waWNvbWF0Y2gubWF0Y2hCYXNlKGUsdCxyLHUpfWVsc2V7YT10LmV4ZWMobCl9fXJldHVybntpc01hdGNoOkJvb2xlYW4oYSksbWF0Y2g6YSxvdXRwdXQ6bH19O3BpY29tYXRjaC5tYXRjaEJhc2U9KGUsdCxyLHU9by5pc1dpbmRvd3MocikpPT57Y29uc3Qgcz10IGluc3RhbmNlb2YgUmVnRXhwP3Q6cGljb21hdGNoLm1ha2VSZSh0LHIpO3JldHVybiBzLnRlc3Qobi5iYXNlbmFtZShlKSl9O3BpY29tYXRjaC5pc01hdGNoPShlLHQscik9PnBpY29tYXRjaCh0LHIpKGUpO3BpY29tYXRjaC5wYXJzZT0oZSx0KT0+e2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGUubWFwKChlPT5waWNvbWF0Y2gucGFyc2UoZSx0KSkpO3JldHVybiBzKGUsey4uLnQsZmFzdHBhdGhzOmZhbHNlfSl9O3BpY29tYXRjaC5zY2FuPShlLHQpPT51KGUsdCk7cGljb21hdGNoLmNvbXBpbGVSZT0oZSx0LHI9ZmFsc2Usbj1mYWxzZSk9PntpZihyPT09dHJ1ZSl7cmV0dXJuIGUub3V0cHV0fWNvbnN0IHU9dHx8e307Y29uc3Qgcz11LmNvbnRhaW5zP1wiXCI6XCJeXCI7Y29uc3Qgbz11LmNvbnRhaW5zP1wiXCI6XCIkXCI7bGV0IGk9YCR7c30oPzoke2Uub3V0cHV0fSkke299YDtpZihlJiZlLm5lZ2F0ZWQ9PT10cnVlKXtpPWBeKD8hJHtpfSkuKiRgfWNvbnN0IGE9cGljb21hdGNoLnRvUmVnZXgoaSx0KTtpZihuPT09dHJ1ZSl7YS5zdGF0ZT1lfXJldHVybiBhfTtwaWNvbWF0Y2gubWFrZVJlPShlLHQscj1mYWxzZSxuPWZhbHNlKT0+e2lmKCFlfHx0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIG5vbi1lbXB0eSBzdHJpbmdcIil9Y29uc3QgdT10fHx7fTtsZXQgbz17bmVnYXRlZDpmYWxzZSxmYXN0cGF0aHM6dHJ1ZX07bGV0IGk9XCJcIjtsZXQgYTtpZihlLnN0YXJ0c1dpdGgoXCIuL1wiKSl7ZT1lLnNsaWNlKDIpO2k9by5wcmVmaXg9XCIuL1wifWlmKHUuZmFzdHBhdGhzIT09ZmFsc2UmJihlWzBdPT09XCIuXCJ8fGVbMF09PT1cIipcIikpe2E9cy5mYXN0cGF0aHMoZSx0KX1pZihhPT09dW5kZWZpbmVkKXtvPXMoZSx0KTtvLnByZWZpeD1pKyhvLnByZWZpeHx8XCJcIil9ZWxzZXtvLm91dHB1dD1hfXJldHVybiBwaWNvbWF0Y2guY29tcGlsZVJlKG8sdCxyLG4pfTtwaWNvbWF0Y2gudG9SZWdleD0oZSx0KT0+e3RyeXtjb25zdCByPXR8fHt9O3JldHVybiBuZXcgUmVnRXhwKGUsci5mbGFnc3x8KHIubm9jYXNlP1wiaVwiOlwiXCIpKX1jYXRjaChlKXtpZih0JiZ0LmRlYnVnPT09dHJ1ZSl0aHJvdyBlO3JldHVybi8kXi99fTtwaWNvbWF0Y2guY29uc3RhbnRzPWk7ZS5leHBvcnRzPXBpY29tYXRjaH0sMjE2OihlLHQscik9Pntjb25zdCBuPXIoMjQzKTtjb25zdHtDSEFSX0FTVEVSSVNLOnUsQ0hBUl9BVDpzLENIQVJfQkFDS1dBUkRfU0xBU0g6byxDSEFSX0NPTU1BOmksQ0hBUl9ET1Q6YSxDSEFSX0VYQ0xBTUFUSU9OX01BUks6bCxDSEFSX0ZPUldBUkRfU0xBU0g6YyxDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6cCxDSEFSX0xFRlRfUEFSRU5USEVTRVM6ZixDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQ6QSxDSEFSX1BMVVM6UixDSEFSX1FVRVNUSU9OX01BUks6XyxDSEFSX1JJR0hUX0NVUkxZX0JSQUNFOmgsQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUzpnLENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6RX09cig4NzEpO2NvbnN0IGlzUGF0aFNlcGFyYXRvcj1lPT5lPT09Y3x8ZT09PW87Y29uc3QgZGVwdGg9ZT0+e2lmKGUuaXNQcmVmaXghPT10cnVlKXtlLmRlcHRoPWUuaXNHbG9ic3Rhcj9JbmZpbml0eToxfX07Y29uc3Qgc2Nhbj0oZSx0KT0+e2NvbnN0IHI9dHx8e307Y29uc3QgQz1lLmxlbmd0aC0xO2NvbnN0IHk9ci5wYXJ0cz09PXRydWV8fHIuc2NhblRvRW5kPT09dHJ1ZTtjb25zdCBkPVtdO2NvbnN0IHg9W107Y29uc3QgYj1bXTtsZXQgUz1lO2xldCBIPS0xO2xldCB2PTA7bGV0ICQ9MDtsZXQgbT1mYWxzZTtsZXQgVD1mYWxzZTtsZXQgTD1mYWxzZTtsZXQgTz1mYWxzZTtsZXQgdz1mYWxzZTtsZXQgTj1mYWxzZTtsZXQgaz1mYWxzZTtsZXQgST1mYWxzZTtsZXQgTT1mYWxzZTtsZXQgUD0wO2xldCBCO2xldCBHO2xldCBEPXt2YWx1ZTpcIlwiLGRlcHRoOjAsaXNHbG9iOmZhbHNlfTtjb25zdCBlb3M9KCk9Pkg+PUM7Y29uc3QgcGVlaz0oKT0+Uy5jaGFyQ29kZUF0KEgrMSk7Y29uc3QgYWR2YW5jZT0oKT0+e0I9RztyZXR1cm4gUy5jaGFyQ29kZUF0KCsrSCl9O3doaWxlKEg8Qyl7Rz1hZHZhbmNlKCk7bGV0IGU7aWYoRz09PW8pe2s9RC5iYWNrc2xhc2hlcz10cnVlO0c9YWR2YW5jZSgpO2lmKEc9PT1wKXtOPXRydWV9Y29udGludWV9aWYoTj09PXRydWV8fEc9PT1wKXtQKys7d2hpbGUoZW9zKCkhPT10cnVlJiYoRz1hZHZhbmNlKCkpKXtpZihHPT09byl7az1ELmJhY2tzbGFzaGVzPXRydWU7YWR2YW5jZSgpO2NvbnRpbnVlfWlmKEc9PT1wKXtQKys7Y29udGludWV9aWYoTiE9PXRydWUmJkc9PT1hJiYoRz1hZHZhbmNlKCkpPT09YSl7bT1ELmlzQnJhY2U9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2lmKHk9PT10cnVlKXtjb250aW51ZX1icmVha31pZihOIT09dHJ1ZSYmRz09PWkpe209RC5pc0JyYWNlPXRydWU7TD1ELmlzR2xvYj10cnVlO009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoRz09PWgpe1AtLTtpZihQPT09MCl7Tj1mYWxzZTttPUQuaXNCcmFjZT10cnVlO009dHJ1ZTticmVha319fWlmKHk9PT10cnVlKXtjb250aW51ZX1icmVha31pZihHPT09Yyl7ZC5wdXNoKEgpO3gucHVzaChEKTtEPXt2YWx1ZTpcIlwiLGRlcHRoOjAsaXNHbG9iOmZhbHNlfTtpZihNPT09dHJ1ZSljb250aW51ZTtpZihCPT09YSYmSD09PXYrMSl7dis9Mjtjb250aW51ZX0kPUgrMTtjb250aW51ZX1pZihyLm5vZXh0IT09dHJ1ZSl7Y29uc3QgZT1HPT09Unx8Rz09PXN8fEc9PT11fHxHPT09X3x8Rz09PWw7aWYoZT09PXRydWUmJnBlZWsoKT09PWYpe0w9RC5pc0dsb2I9dHJ1ZTtPPUQuaXNFeHRnbG9iPXRydWU7TT10cnVlO2lmKHk9PT10cnVlKXt3aGlsZShlb3MoKSE9PXRydWUmJihHPWFkdmFuY2UoKSkpe2lmKEc9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTtHPWFkdmFuY2UoKTtjb250aW51ZX1pZihHPT09Zyl7TD1ELmlzR2xvYj10cnVlO009dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9fWlmKEc9PT11KXtpZihCPT09dSl3PUQuaXNHbG9ic3Rhcj10cnVlO0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1fKXtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2lmKHk9PT10cnVlKXtjb250aW51ZX1icmVha31pZihHPT09QSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoZT1hZHZhbmNlKCkpKXtpZihlPT09byl7az1ELmJhY2tzbGFzaGVzPXRydWU7YWR2YW5jZSgpO2NvbnRpbnVlfWlmKGU9PT1FKXtUPUQuaXNCcmFja2V0PXRydWU7TD1ELmlzR2xvYj10cnVlO009dHJ1ZTticmVha319aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKHIubm9uZWdhdGUhPT10cnVlJiZHPT09bCYmSD09PXYpe0k9RC5uZWdhdGVkPXRydWU7disrO2NvbnRpbnVlfWlmKHIubm9wYXJlbiE9PXRydWUmJkc9PT1mKXtMPUQuaXNHbG9iPXRydWU7aWYoeT09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKEc9YWR2YW5jZSgpKSl7aWYoRz09PWYpe2s9RC5iYWNrc2xhc2hlcz10cnVlO0c9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKEc9PT1nKXtNPXRydWU7YnJlYWt9fWNvbnRpbnVlfWJyZWFrfWlmKEw9PT10cnVlKXtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfX1pZihyLm5vZXh0PT09dHJ1ZSl7Tz1mYWxzZTtMPWZhbHNlfWxldCBVPVM7bGV0IEs9XCJcIjtsZXQgRj1cIlwiO2lmKHY+MCl7Sz1TLnNsaWNlKDAsdik7Uz1TLnNsaWNlKHYpOyQtPXZ9aWYoVSYmTD09PXRydWUmJiQ+MCl7VT1TLnNsaWNlKDAsJCk7Rj1TLnNsaWNlKCQpfWVsc2UgaWYoTD09PXRydWUpe1U9XCJcIjtGPVN9ZWxzZXtVPVN9aWYoVSYmVSE9PVwiXCImJlUhPT1cIi9cIiYmVSE9PVMpe2lmKGlzUGF0aFNlcGFyYXRvcihVLmNoYXJDb2RlQXQoVS5sZW5ndGgtMSkpKXtVPVUuc2xpY2UoMCwtMSl9fWlmKHIudW5lc2NhcGU9PT10cnVlKXtpZihGKUY9bi5yZW1vdmVCYWNrc2xhc2hlcyhGKTtpZihVJiZrPT09dHJ1ZSl7VT1uLnJlbW92ZUJhY2tzbGFzaGVzKFUpfX1jb25zdCBRPXtwcmVmaXg6SyxpbnB1dDplLHN0YXJ0OnYsYmFzZTpVLGdsb2I6Rixpc0JyYWNlOm0saXNCcmFja2V0OlQsaXNHbG9iOkwsaXNFeHRnbG9iOk8saXNHbG9ic3Rhcjp3LG5lZ2F0ZWQ6SX07aWYoci50b2tlbnM9PT10cnVlKXtRLm1heERlcHRoPTA7aWYoIWlzUGF0aFNlcGFyYXRvcihHKSl7eC5wdXNoKEQpfVEudG9rZW5zPXh9aWYoci5wYXJ0cz09PXRydWV8fHIudG9rZW5zPT09dHJ1ZSl7bGV0IHQ7Zm9yKGxldCBuPTA7bjxkLmxlbmd0aDtuKyspe2NvbnN0IHU9dD90KzE6djtjb25zdCBzPWRbbl07Y29uc3Qgbz1lLnNsaWNlKHUscyk7aWYoci50b2tlbnMpe2lmKG49PT0wJiZ2IT09MCl7eFtuXS5pc1ByZWZpeD10cnVlO3hbbl0udmFsdWU9S31lbHNle3hbbl0udmFsdWU9b31kZXB0aCh4W25dKTtRLm1heERlcHRoKz14W25dLmRlcHRofWlmKG4hPT0wfHxvIT09XCJcIil7Yi5wdXNoKG8pfXQ9c31pZih0JiZ0KzE8ZS5sZW5ndGgpe2NvbnN0IG49ZS5zbGljZSh0KzEpO2IucHVzaChuKTtpZihyLnRva2Vucyl7eFt4Lmxlbmd0aC0xXS52YWx1ZT1uO2RlcHRoKHhbeC5sZW5ndGgtMV0pO1EubWF4RGVwdGgrPXhbeC5sZW5ndGgtMV0uZGVwdGh9fVEuc2xhc2hlcz1kO1EucGFydHM9Yn1yZXR1cm4gUX07ZS5leHBvcnRzPXNjYW59LDI0MzooZSx0LHIpPT57Y29uc3Qgbj1yKDE3KTtjb25zdCB1PXByb2Nlc3MucGxhdGZvcm09PT1cIndpbjMyXCI7Y29uc3R7UkVHRVhfQkFDS1NMQVNIOnMsUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSDpvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6aSxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDphfT1yKDg3MSk7dC5pc09iamVjdD1lPT5lIT09bnVsbCYmdHlwZW9mIGU9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheShlKTt0Lmhhc1JlZ2V4Q2hhcnM9ZT0+aS50ZXN0KGUpO3QuaXNSZWdleENoYXI9ZT0+ZS5sZW5ndGg9PT0xJiZ0Lmhhc1JlZ2V4Q2hhcnMoZSk7dC5lc2NhcGVSZWdleD1lPT5lLnJlcGxhY2UoYSxcIlxcXFwkMVwiKTt0LnRvUG9zaXhTbGFzaGVzPWU9PmUucmVwbGFjZShzLFwiL1wiKTt0LnJlbW92ZUJhY2tzbGFzaGVzPWU9PmUucmVwbGFjZShvLChlPT5lPT09XCJcXFxcXCI/XCJcIjplKSk7dC5zdXBwb3J0c0xvb2tiZWhpbmRzPSgpPT57Y29uc3QgZT1wcm9jZXNzLnZlcnNpb24uc2xpY2UoMSkuc3BsaXQoXCIuXCIpLm1hcChOdW1iZXIpO2lmKGUubGVuZ3RoPT09MyYmZVswXT49OXx8ZVswXT09PTgmJmVbMV0+PTEwKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9O3QuaXNXaW5kb3dzPWU9PntpZihlJiZ0eXBlb2YgZS53aW5kb3dzPT09XCJib29sZWFuXCIpe3JldHVybiBlLndpbmRvd3N9cmV0dXJuIHU9PT10cnVlfHxuLnNlcD09PVwiXFxcXFwifTt0LmVzY2FwZUxhc3Q9KGUscixuKT0+e2NvbnN0IHU9ZS5sYXN0SW5kZXhPZihyLG4pO2lmKHU9PT0tMSlyZXR1cm4gZTtpZihlW3UtMV09PT1cIlxcXFxcIilyZXR1cm4gdC5lc2NhcGVMYXN0KGUscix1LTEpO3JldHVybmAke2Uuc2xpY2UoMCx1KX1cXFxcJHtlLnNsaWNlKHUpfWB9O3QucmVtb3ZlUHJlZml4PShlLHQ9e30pPT57bGV0IHI9ZTtpZihyLnN0YXJ0c1dpdGgoXCIuL1wiKSl7cj1yLnNsaWNlKDIpO3QucHJlZml4PVwiLi9cIn1yZXR1cm4gcn07dC53cmFwT3V0cHV0PShlLHQ9e30scj17fSk9Pntjb25zdCBuPXIuY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCB1PXIuY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgcz1gJHtufSg/OiR7ZX0pJHt1fWA7aWYodC5uZWdhdGVkPT09dHJ1ZSl7cz1gKD86Xig/ISR7c30pLiokKWB9cmV0dXJuIHN9fSwzNjg6KGUsdCxyKT0+e1xuLyohXG4gKiB0by1yZWdleC1yYW5nZSA8aHR0cHM6Ly9naXRodWIuY29tL21pY3JvbWF0Y2gvdG8tcmVnZXgtcmFuZ2U+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5jb25zdCBuPXIoNzczKTtjb25zdCB0b1JlZ2V4UmFuZ2U9KGUsdCxyKT0+e2lmKG4oZSk9PT1mYWxzZSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcInRvUmVnZXhSYW5nZTogZXhwZWN0ZWQgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGEgbnVtYmVyXCIpfWlmKHQ9PT12b2lkIDB8fGU9PT10KXtyZXR1cm4gU3RyaW5nKGUpfWlmKG4odCk9PT1mYWxzZSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcInRvUmVnZXhSYW5nZTogZXhwZWN0ZWQgdGhlIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIG51bWJlci5cIil9bGV0IHU9e3JlbGF4WmVyb3M6dHJ1ZSwuLi5yfTtpZih0eXBlb2YgdS5zdHJpY3RaZXJvcz09PVwiYm9vbGVhblwiKXt1LnJlbGF4WmVyb3M9dS5zdHJpY3RaZXJvcz09PWZhbHNlfWxldCBzPVN0cmluZyh1LnJlbGF4WmVyb3MpO2xldCBvPVN0cmluZyh1LnNob3J0aGFuZCk7bGV0IGk9U3RyaW5nKHUuY2FwdHVyZSk7bGV0IGE9U3RyaW5nKHUud3JhcCk7bGV0IGw9ZStcIjpcIit0K1wiPVwiK3MrbytpK2E7aWYodG9SZWdleFJhbmdlLmNhY2hlLmhhc093blByb3BlcnR5KGwpKXtyZXR1cm4gdG9SZWdleFJhbmdlLmNhY2hlW2xdLnJlc3VsdH1sZXQgYz1NYXRoLm1pbihlLHQpO2xldCBwPU1hdGgubWF4KGUsdCk7aWYoTWF0aC5hYnMoYy1wKT09PTEpe2xldCByPWUrXCJ8XCIrdDtpZih1LmNhcHR1cmUpe3JldHVybmAoJHtyfSlgfWlmKHUud3JhcD09PWZhbHNlKXtyZXR1cm4gcn1yZXR1cm5gKD86JHtyfSlgfWxldCBmPWhhc1BhZGRpbmcoZSl8fGhhc1BhZGRpbmcodCk7bGV0IEE9e21pbjplLG1heDp0LGE6YyxiOnB9O2xldCBSPVtdO2xldCBfPVtdO2lmKGYpe0EuaXNQYWRkZWQ9ZjtBLm1heExlbj1TdHJpbmcoQS5tYXgpLmxlbmd0aH1pZihjPDApe2xldCBlPXA8MD9NYXRoLmFicyhwKToxO189c3BsaXRUb1BhdHRlcm5zKGUsTWF0aC5hYnMoYyksQSx1KTtjPUEuYT0wfWlmKHA+PTApe1I9c3BsaXRUb1BhdHRlcm5zKGMscCxBLHUpfUEubmVnYXRpdmVzPV87QS5wb3NpdGl2ZXM9UjtBLnJlc3VsdD1jb2xsYXRlUGF0dGVybnMoXyxSLHUpO2lmKHUuY2FwdHVyZT09PXRydWUpe0EucmVzdWx0PWAoJHtBLnJlc3VsdH0pYH1lbHNlIGlmKHUud3JhcCE9PWZhbHNlJiZSLmxlbmd0aCtfLmxlbmd0aD4xKXtBLnJlc3VsdD1gKD86JHtBLnJlc3VsdH0pYH10b1JlZ2V4UmFuZ2UuY2FjaGVbbF09QTtyZXR1cm4gQS5yZXN1bHR9O2Z1bmN0aW9uIGNvbGxhdGVQYXR0ZXJucyhlLHQscil7bGV0IG49ZmlsdGVyUGF0dGVybnMoZSx0LFwiLVwiLGZhbHNlLHIpfHxbXTtsZXQgdT1maWx0ZXJQYXR0ZXJucyh0LGUsXCJcIixmYWxzZSxyKXx8W107bGV0IHM9ZmlsdGVyUGF0dGVybnMoZSx0LFwiLT9cIix0cnVlLHIpfHxbXTtsZXQgbz1uLmNvbmNhdChzKS5jb25jYXQodSk7cmV0dXJuIG8uam9pbihcInxcIil9ZnVuY3Rpb24gc3BsaXRUb1JhbmdlcyhlLHQpe2xldCByPTE7bGV0IG49MTtsZXQgdT1jb3VudE5pbmVzKGUscik7bGV0IHM9bmV3IFNldChbdF0pO3doaWxlKGU8PXUmJnU8PXQpe3MuYWRkKHUpO3IrPTE7dT1jb3VudE5pbmVzKGUscil9dT1jb3VudFplcm9zKHQrMSxuKS0xO3doaWxlKGU8dSYmdTw9dCl7cy5hZGQodSk7bis9MTt1PWNvdW50WmVyb3ModCsxLG4pLTF9cz1bLi4uc107cy5zb3J0KGNvbXBhcmUpO3JldHVybiBzfWZ1bmN0aW9uIHJhbmdlVG9QYXR0ZXJuKGUsdCxyKXtpZihlPT09dCl7cmV0dXJue3BhdHRlcm46ZSxjb3VudDpbXSxkaWdpdHM6MH19bGV0IG49emlwKGUsdCk7bGV0IHU9bi5sZW5ndGg7bGV0IHM9XCJcIjtsZXQgbz0wO2ZvcihsZXQgZT0wO2U8dTtlKyspe2xldFt0LHVdPW5bZV07aWYodD09PXUpe3MrPXR9ZWxzZSBpZih0IT09XCIwXCJ8fHUhPT1cIjlcIil7cys9dG9DaGFyYWN0ZXJDbGFzcyh0LHUscil9ZWxzZXtvKyt9fWlmKG8pe3MrPXIuc2hvcnRoYW5kPT09dHJ1ZT9cIlxcXFxkXCI6XCJbMC05XVwifXJldHVybntwYXR0ZXJuOnMsY291bnQ6W29dLGRpZ2l0czp1fX1mdW5jdGlvbiBzcGxpdFRvUGF0dGVybnMoZSx0LHIsbil7bGV0IHU9c3BsaXRUb1JhbmdlcyhlLHQpO2xldCBzPVtdO2xldCBvPWU7bGV0IGk7Zm9yKGxldCBlPTA7ZTx1Lmxlbmd0aDtlKyspe2xldCB0PXVbZV07bGV0IGE9cmFuZ2VUb1BhdHRlcm4oU3RyaW5nKG8pLFN0cmluZyh0KSxuKTtsZXQgbD1cIlwiO2lmKCFyLmlzUGFkZGVkJiZpJiZpLnBhdHRlcm49PT1hLnBhdHRlcm4pe2lmKGkuY291bnQubGVuZ3RoPjEpe2kuY291bnQucG9wKCl9aS5jb3VudC5wdXNoKGEuY291bnRbMF0pO2kuc3RyaW5nPWkucGF0dGVybit0b1F1YW50aWZpZXIoaS5jb3VudCk7bz10KzE7Y29udGludWV9aWYoci5pc1BhZGRlZCl7bD1wYWRaZXJvcyh0LHIsbil9YS5zdHJpbmc9bCthLnBhdHRlcm4rdG9RdWFudGlmaWVyKGEuY291bnQpO3MucHVzaChhKTtvPXQrMTtpPWF9cmV0dXJuIHN9ZnVuY3Rpb24gZmlsdGVyUGF0dGVybnMoZSx0LHIsbix1KXtsZXQgcz1bXTtmb3IobGV0IHUgb2YgZSl7bGV0e3N0cmluZzplfT11O2lmKCFuJiYhY29udGFpbnModCxcInN0cmluZ1wiLGUpKXtzLnB1c2gocitlKX1pZihuJiZjb250YWlucyh0LFwic3RyaW5nXCIsZSkpe3MucHVzaChyK2UpfX1yZXR1cm4gc31mdW5jdGlvbiB6aXAoZSx0KXtsZXQgcj1bXTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKylyLnB1c2goW2Vbbl0sdFtuXV0pO3JldHVybiByfWZ1bmN0aW9uIGNvbXBhcmUoZSx0KXtyZXR1cm4gZT50PzE6dD5lPy0xOjB9ZnVuY3Rpb24gY29udGFpbnMoZSx0LHIpe3JldHVybiBlLnNvbWUoKGU9PmVbdF09PT1yKSl9ZnVuY3Rpb24gY291bnROaW5lcyhlLHQpe3JldHVybiBOdW1iZXIoU3RyaW5nKGUpLnNsaWNlKDAsLXQpK1wiOVwiLnJlcGVhdCh0KSl9ZnVuY3Rpb24gY291bnRaZXJvcyhlLHQpe3JldHVybiBlLWUlTWF0aC5wb3coMTAsdCl9ZnVuY3Rpb24gdG9RdWFudGlmaWVyKGUpe2xldFt0PTAscj1cIlwiXT1lO2lmKHJ8fHQ+MSl7cmV0dXJuYHske3QrKHI/XCIsXCIrcjpcIlwiKX19YH1yZXR1cm5cIlwifWZ1bmN0aW9uIHRvQ2hhcmFjdGVyQ2xhc3MoZSx0LHIpe3JldHVybmBbJHtlfSR7dC1lPT09MT9cIlwiOlwiLVwifSR7dH1dYH1mdW5jdGlvbiBoYXNQYWRkaW5nKGUpe3JldHVybi9eLT8oMCspXFxkLy50ZXN0KGUpfWZ1bmN0aW9uIHBhZFplcm9zKGUsdCxyKXtpZighdC5pc1BhZGRlZCl7cmV0dXJuIGV9bGV0IG49TWF0aC5hYnModC5tYXhMZW4tU3RyaW5nKGUpLmxlbmd0aCk7bGV0IHU9ci5yZWxheFplcm9zIT09ZmFsc2U7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm5cIlwiO2Nhc2UgMTpyZXR1cm4gdT9cIjA/XCI6XCIwXCI7Y2FzZSAyOnJldHVybiB1P1wiMHswLDJ9XCI6XCIwMFwiO2RlZmF1bHQ6e3JldHVybiB1P2AwezAsJHtufX1gOmAweyR7bn19YH19fXRvUmVnZXhSYW5nZS5jYWNoZT17fTt0b1JlZ2V4UmFuZ2UuY2xlYXJDYWNoZT0oKT0+dG9SZWdleFJhbmdlLmNhY2hlPXt9O2UuZXhwb3J0cz10b1JlZ2V4UmFuZ2V9LDE3OmU9PntlLmV4cG9ydHM9cmVxdWlyZShcInBhdGhcIil9LDgzNzplPT57ZS5leHBvcnRzPXJlcXVpcmUoXCJ1dGlsXCIpfX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIHU9dFtyXT17ZXhwb3J0czp7fX07dmFyIHM9dHJ1ZTt0cnl7ZVtyXSh1LHUuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtzPWZhbHNlfWZpbmFsbHl7aWYocylkZWxldGUgdFtyXX1yZXR1cm4gdS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj1fX25jY3dwY2tfcmVxdWlyZV9fKDg4OCk7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbImUiLCJ0IiwiciIsIm4iLCJ1IiwicyIsIm8iLCJicmFjZXMiLCJBcnJheSIsImlzQXJyYXkiLCJjcmVhdGUiLCJwdXNoIiwiY29uY2F0IiwiZXhwYW5kIiwibm9kdXBlcyIsIlNldCIsInBhcnNlIiwic3RyaW5naWZ5IiwiY29tcGlsZSIsIm5vZW1wdHkiLCJmaWx0ZXIiLCJCb29sZWFuIiwibGVuZ3RoIiwiZXhwb3J0cyIsIndhbGsiLCJpc0ludmFsaWRCcmFjZSIsImludmFsaWQiLCJlc2NhcGVJbnZhbGlkIiwiaSIsImEiLCJsIiwiaXNPcGVuIiwidmFsdWUiLCJpc0Nsb3NlIiwidHlwZSIsInByZXYiLCJub2RlcyIsInJhbmdlcyIsInJlZHVjZSIsIndyYXAiLCJ0b1JlZ2V4IiwiTUFYX0xFTkdUSCIsIkNIQVJfMCIsIkNIQVJfOSIsIkNIQVJfVVBQRVJDQVNFX0EiLCJDSEFSX0xPV0VSQ0FTRV9BIiwiQ0hBUl9VUFBFUkNBU0VfWiIsIkNIQVJfTE9XRVJDQVNFX1oiLCJDSEFSX0xFRlRfUEFSRU5USEVTRVMiLCJDSEFSX1JJR0hUX1BBUkVOVEhFU0VTIiwiQ0hBUl9BU1RFUklTSyIsIkNIQVJfQU1QRVJTQU5EIiwiQ0hBUl9BVCIsIkNIQVJfQkFDS1NMQVNIIiwiQ0hBUl9CQUNLVElDSyIsIkNIQVJfQ0FSUklBR0VfUkVUVVJOIiwiQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVCIsIkNIQVJfQ09MT04iLCJDSEFSX0NPTU1BIiwiQ0hBUl9ET0xMQVIiLCJDSEFSX0RPVCIsIkNIQVJfRE9VQkxFX1FVT1RFIiwiQ0hBUl9FUVVBTCIsIkNIQVJfRVhDTEFNQVRJT05fTUFSSyIsIkNIQVJfRk9STV9GRUVEIiwiQ0hBUl9GT1JXQVJEX1NMQVNIIiwiQ0hBUl9IQVNIIiwiQ0hBUl9IWVBIRU5fTUlOVVMiLCJDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVCIsIkNIQVJfTEVGVF9DVVJMWV9CUkFDRSIsIkNIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCIsIkNIQVJfTElORV9GRUVEIiwiQ0hBUl9OT19CUkVBS19TUEFDRSIsIkNIQVJfUEVSQ0VOVCIsIkNIQVJfUExVUyIsIkNIQVJfUVVFU1RJT05fTUFSSyIsIkNIQVJfUklHSFRfQU5HTEVfQlJBQ0tFVCIsIkNIQVJfUklHSFRfQ1VSTFlfQlJBQ0UiLCJDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUIiwiQ0hBUl9TRU1JQ09MT04iLCJDSEFSX1NJTkdMRV9RVU9URSIsIkNIQVJfU1BBQ0UiLCJDSEFSX1RBQiIsIkNIQVJfVU5ERVJTQ09SRSIsIkNIQVJfVkVSVElDQUxfTElORSIsIkNIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFIiwiYXBwZW5kIiwiZmxhdHRlbiIsIm1hcCIsInJhbmdlTGltaXQiLCJxdWV1ZSIsInBhcmVudCIsImRvbGxhciIsInBvcCIsImV4Y2VlZHNMaW1pdCIsInN0ZXAiLCJSYW5nZUVycm9yIiwiZW5jbG9zZUJyYWNlIiwiYyIsInAiLCJmIiwiQSIsIlIiLCJfIiwiaCIsImciLCJFIiwiVHlwZUVycm9yIiwiQyIsIm1heExlbmd0aCIsIk1hdGgiLCJtaW4iLCJTeW50YXhFcnJvciIsInkiLCJpbnB1dCIsImQiLCJ4IiwiYiIsIlMiLCJIIiwidiIsIiQiLCJtIiwiVCIsImFkdmFuY2UiLCJrZWVwRXNjYXBpbmciLCJrZWVwUXVvdGVzIiwic2xpY2UiLCJvcGVuIiwiY2xvc2UiLCJkZXB0aCIsImNvbW1hcyIsInNoaWZ0IiwicmFuZ2UiLCJhcmdzIiwiZm9yRWFjaCIsImluZGV4T2YiLCJzcGxpY2UiLCJpc09wZW5PckNsb3NlIiwiaXNJbnRlZ2VyIiwiTnVtYmVyIiwidHJpbSIsImZpbmQiLCJlc2NhcGVOb2RlIiwiZXNjYXBlZCIsImZsYXQiLCJpc09iamVjdCIsInRyYW5zZm9ybSIsIlN0cmluZyIsImlzVmFsaWRWYWx1ZSIsImlzTnVtYmVyIiwiemVyb3MiLCJwYWQiLCJwYWRTdGFydCIsInRvTWF4TGVuIiwidG9TZXF1ZW5jZSIsIm5lZ2F0aXZlcyIsInNvcnQiLCJwb3NpdGl2ZXMiLCJjYXB0dXJlIiwiam9pbiIsInRvUmFuZ2UiLCJmcm9tQ2hhckNvZGUiLCJyYW5nZUVycm9yIiwiaW5zcGVjdCIsImludmFsaWRSYW5nZSIsInN0cmljdFJhbmdlcyIsImludmFsaWRTdGVwIiwiZmlsbE51bWJlcnMiLCJtYXgiLCJhYnMiLCJmaWxsTGV0dGVycyIsImNoYXJDb2RlQXQiLCJvcHRpb25zIiwiZmlsbCIsImlzRmluaXRlIiwiaXNFbXB0eVN0cmluZyIsIm1pY3JvbWF0Y2giLCJvblJlc3VsdCIsImFkZCIsIm91dHB1dCIsInN0YXRlIiwibmVnYXRlZCIsIm5lZ2F0ZWRFeHRnbG9iIiwiaXNNYXRjaCIsImRlbGV0ZSIsImhhcyIsImZhaWxnbG9iIiwiRXJyb3IiLCJub251bGwiLCJudWxsZ2xvYiIsInVuZXNjYXBlIiwicmVwbGFjZSIsIm1hdGNoIiwibWF0Y2hlciIsImFueSIsIm5vdCIsImluY2x1ZGVzIiwiY29udGFpbnMiLCJzb21lIiwic3RhcnRzV2l0aCIsIm1hdGNoS2V5cyIsIk9iamVjdCIsImtleXMiLCJldmVyeSIsImFsbCIsImlzV2luZG93cyIsIm1ha2VSZSIsImV4ZWMiLCJ0b1Bvc2l4U2xhc2hlcyIsInNjYW4iLCJub2JyYWNlIiwidGVzdCIsImJyYWNlRXhwYW5kIiwiRE9UX0xJVEVSQUwiLCJQTFVTX0xJVEVSQUwiLCJRTUFSS19MSVRFUkFMIiwiU0xBU0hfTElURVJBTCIsIk9ORV9DSEFSIiwiUU1BUksiLCJFTkRfQU5DSE9SIiwiRE9UU19TTEFTSCIsIk5PX0RPVCIsIk5PX0RPVFMiLCJOT19ET1RfU0xBU0giLCJOT19ET1RTX1NMQVNIIiwiUU1BUktfTk9fRE9UIiwiU1RBUiIsIlNUQVJUX0FOQ0hPUiIsImFsbnVtIiwiYWxwaGEiLCJhc2NpaSIsImJsYW5rIiwiY250cmwiLCJkaWdpdCIsImdyYXBoIiwibG93ZXIiLCJwcmludCIsInB1bmN0Iiwic3BhY2UiLCJ1cHBlciIsIndvcmQiLCJ4ZGlnaXQiLCJQT1NJWF9SRUdFWF9TT1VSQ0UiLCJSRUdFWF9CQUNLU0xBU0giLCJSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUyIsIlJFR0VYX1NQRUNJQUxfQ0hBUlMiLCJSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUYiLCJSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTCIsIlJFR0VYX1JFTU9WRV9CQUNLU0xBU0giLCJSRVBMQUNFTUVOVFMiLCJDSEFSX0JBQ0tXQVJEX1NMQVNIIiwiQ0hBUl9HUkFWRV9BQ0NFTlQiLCJTRVAiLCJzZXAiLCJleHRnbG9iQ2hhcnMiLCJnbG9iQ2hhcnMiLCJleHBhbmRSYW5nZSIsIlJlZ0V4cCIsImVzY2FwZVJlZ2V4Iiwic3ludGF4RXJyb3IiLCJwcmVwZW5kIiwiZ2xvYnN0YXIiLCJkb3QiLCJMIiwiTyIsInciLCJiYXNoIiwibm9leHQiLCJub2V4dGdsb2IiLCJOIiwiaW5kZXgiLCJzdGFydCIsImNvbnN1bWVkIiwicHJlZml4IiwiYmFja3RyYWNrIiwiYnJhY2tldHMiLCJwYXJlbnMiLCJxdW90ZXMiLCJ0b2tlbnMiLCJyZW1vdmVQcmVmaXgiLCJrIiwiSSIsIk0iLCJQIiwiQiIsImVvcyIsIkciLCJwZWVrIiwiRCIsInJlbWFpbmluZyIsImNvbnN1bWUiLCJuZWdhdGUiLCJpbmNyZW1lbnQiLCJkZWNyZW1lbnQiLCJleHRnbG9iIiwiaW5uZXIiLCJleHRnbG9iT3BlbiIsImNvbmRpdGlvbnMiLCJleHRnbG9iQ2xvc2UiLCJmYXN0cGF0aHMiLCJyZXBlYXQiLCJ3cmFwT3V0cHV0IiwicG9zaXgiLCJsYXN0SW5kZXhPZiIsInN0cmljdEJyYWNrZXRzIiwibm9icmFja2V0IiwibGl0ZXJhbEJyYWNrZXRzIiwiaGFzUmVnZXhDaGFycyIsIm91dHB1dEluZGV4IiwidG9rZW5zSW5kZXgiLCJkb3RzIiwidW5zaGlmdCIsImNvbW1hIiwic3VwcG9ydHNMb29rYmVoaW5kcyIsIm5vbmVnYXRlIiwicmVnZXgiLCJzdGFyIiwibm9nbG9ic3RhciIsInN0cmljdFNsYXNoZXMiLCJlc2NhcGVMYXN0Iiwic3VmZml4IiwicGljb21hdGNoIiwiYXJyYXlNYXRjaGVyIiwiY29tcGlsZVJlIiwiaXNJZ25vcmVkIiwiaWdub3JlIiwib25NYXRjaCIsImdsb2IiLCJvbklnbm9yZSIsImZvcm1hdCIsIm1hdGNoQmFzZSIsImJhc2VuYW1lIiwidW5kZWZpbmVkIiwiZmxhZ3MiLCJub2Nhc2UiLCJkZWJ1ZyIsImNvbnN0YW50cyIsImlzUGF0aFNlcGFyYXRvciIsImlzUHJlZml4IiwiaXNHbG9ic3RhciIsIkluZmluaXR5IiwicGFydHMiLCJzY2FuVG9FbmQiLCJpc0dsb2IiLCJiYWNrc2xhc2hlcyIsImlzQnJhY2UiLCJpc0V4dGdsb2IiLCJpc0JyYWNrZXQiLCJub3BhcmVuIiwiVSIsIksiLCJGIiwicmVtb3ZlQmFja3NsYXNoZXMiLCJRIiwiYmFzZSIsIm1heERlcHRoIiwic2xhc2hlcyIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsImlzUmVnZXhDaGFyIiwidmVyc2lvbiIsInNwbGl0Iiwid2luZG93cyIsInRvUmVnZXhSYW5nZSIsInJlbGF4WmVyb3MiLCJzdHJpY3RaZXJvcyIsInNob3J0aGFuZCIsImNhY2hlIiwiaGFzT3duUHJvcGVydHkiLCJyZXN1bHQiLCJoYXNQYWRkaW5nIiwiaXNQYWRkZWQiLCJtYXhMZW4iLCJzcGxpdFRvUGF0dGVybnMiLCJjb2xsYXRlUGF0dGVybnMiLCJmaWx0ZXJQYXR0ZXJucyIsInNwbGl0VG9SYW5nZXMiLCJjb3VudE5pbmVzIiwiY291bnRaZXJvcyIsImNvbXBhcmUiLCJyYW5nZVRvUGF0dGVybiIsInBhdHRlcm4iLCJjb3VudCIsImRpZ2l0cyIsInppcCIsInRvQ2hhcmFjdGVyQ2xhc3MiLCJzdHJpbmciLCJ0b1F1YW50aWZpZXIiLCJwYWRaZXJvcyIsInBvdyIsImNsZWFyQ2FjaGUiLCJyZXF1aXJlIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsImFiIiwiX19kaXJuYW1lIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/micromatch/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-browserify/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-browserify/index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function () {\n  \"use strict\";\n\n  var e = {\n    113: function (e) {\n      function assertPath(e) {\n        if (typeof e !== \"string\") {\n          throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(e));\n        }\n      }\n\n      function normalizeStringPosix(e, r) {\n        var t = \"\";\n        var i = 0;\n        var n = -1;\n        var a = 0;\n        var f;\n\n        for (var l = 0; l <= e.length; ++l) {\n          if (l < e.length) f = e.charCodeAt(l);else if (f === 47) break;else f = 47;\n\n          if (f === 47) {\n            if (n === l - 1 || a === 1) {} else if (n !== l - 1 && a === 2) {\n              if (t.length < 2 || i !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {\n                if (t.length > 2) {\n                  var s = t.lastIndexOf(\"/\");\n\n                  if (s !== t.length - 1) {\n                    if (s === -1) {\n                      t = \"\";\n                      i = 0;\n                    } else {\n                      t = t.slice(0, s);\n                      i = t.length - 1 - t.lastIndexOf(\"/\");\n                    }\n\n                    n = l;\n                    a = 0;\n                    continue;\n                  }\n                } else if (t.length === 2 || t.length === 1) {\n                  t = \"\";\n                  i = 0;\n                  n = l;\n                  a = 0;\n                  continue;\n                }\n              }\n\n              if (r) {\n                if (t.length > 0) t += \"/..\";else t = \"..\";\n                i = 2;\n              }\n            } else {\n              if (t.length > 0) t += \"/\" + e.slice(n + 1, l);else t = e.slice(n + 1, l);\n              i = l - n - 1;\n            }\n\n            n = l;\n            a = 0;\n          } else if (f === 46 && a !== -1) {\n            ++a;\n          } else {\n            a = -1;\n          }\n        }\n\n        return t;\n      }\n\n      function _format(e, r) {\n        var t = r.dir || r.root;\n        var i = r.base || (r.name || \"\") + (r.ext || \"\");\n\n        if (!t) {\n          return i;\n        }\n\n        if (t === r.root) {\n          return t + i;\n        }\n\n        return t + e + i;\n      }\n\n      var r = {\n        resolve: function resolve() {\n          var e = \"\";\n          var r = false;\n          var t;\n\n          for (var i = arguments.length - 1; i >= -1 && !r; i--) {\n            var n;\n            if (i >= 0) n = arguments[i];else {\n              if (t === undefined) t = \"\";\n              n = t;\n            }\n            assertPath(n);\n\n            if (n.length === 0) {\n              continue;\n            }\n\n            e = n + \"/\" + e;\n            r = n.charCodeAt(0) === 47;\n          }\n\n          e = normalizeStringPosix(e, !r);\n\n          if (r) {\n            if (e.length > 0) return \"/\" + e;else return \"/\";\n          } else if (e.length > 0) {\n            return e;\n          } else {\n            return \".\";\n          }\n        },\n        normalize: function normalize(e) {\n          assertPath(e);\n          if (e.length === 0) return \".\";\n          var r = e.charCodeAt(0) === 47;\n          var t = e.charCodeAt(e.length - 1) === 47;\n          e = normalizeStringPosix(e, !r);\n          if (e.length === 0 && !r) e = \".\";\n          if (e.length > 0 && t) e += \"/\";\n          if (r) return \"/\" + e;\n          return e;\n        },\n        isAbsolute: function isAbsolute(e) {\n          assertPath(e);\n          return e.length > 0 && e.charCodeAt(0) === 47;\n        },\n        join: function join() {\n          if (arguments.length === 0) return \".\";\n          var e;\n\n          for (var t = 0; t < arguments.length; ++t) {\n            var i = arguments[t];\n            assertPath(i);\n\n            if (i.length > 0) {\n              if (e === undefined) e = i;else e += \"/\" + i;\n            }\n          }\n\n          if (e === undefined) return \".\";\n          return r.normalize(e);\n        },\n        relative: function relative(e, t) {\n          assertPath(e);\n          assertPath(t);\n          if (e === t) return \"\";\n          e = r.resolve(e);\n          t = r.resolve(t);\n          if (e === t) return \"\";\n          var i = 1;\n\n          for (; i < e.length; ++i) {\n            if (e.charCodeAt(i) !== 47) break;\n          }\n\n          var n = e.length;\n          var a = n - i;\n          var f = 1;\n\n          for (; f < t.length; ++f) {\n            if (t.charCodeAt(f) !== 47) break;\n          }\n\n          var l = t.length;\n          var s = l - f;\n          var o = a < s ? a : s;\n          var u = -1;\n          var h = 0;\n\n          for (; h <= o; ++h) {\n            if (h === o) {\n              if (s > o) {\n                if (t.charCodeAt(f + h) === 47) {\n                  return t.slice(f + h + 1);\n                } else if (h === 0) {\n                  return t.slice(f + h);\n                }\n              } else if (a > o) {\n                if (e.charCodeAt(i + h) === 47) {\n                  u = h;\n                } else if (h === 0) {\n                  u = 0;\n                }\n              }\n\n              break;\n            }\n\n            var c = e.charCodeAt(i + h);\n            var v = t.charCodeAt(f + h);\n            if (c !== v) break;else if (c === 47) u = h;\n          }\n\n          var g = \"\";\n\n          for (h = i + u + 1; h <= n; ++h) {\n            if (h === n || e.charCodeAt(h) === 47) {\n              if (g.length === 0) g += \"..\";else g += \"/..\";\n            }\n          }\n\n          if (g.length > 0) return g + t.slice(f + u);else {\n            f += u;\n            if (t.charCodeAt(f) === 47) ++f;\n            return t.slice(f);\n          }\n        },\n        _makeLong: function _makeLong(e) {\n          return e;\n        },\n        dirname: function dirname(e) {\n          assertPath(e);\n          if (e.length === 0) return \".\";\n          var r = e.charCodeAt(0);\n          var t = r === 47;\n          var i = -1;\n          var n = true;\n\n          for (var a = e.length - 1; a >= 1; --a) {\n            r = e.charCodeAt(a);\n\n            if (r === 47) {\n              if (!n) {\n                i = a;\n                break;\n              }\n            } else {\n              n = false;\n            }\n          }\n\n          if (i === -1) return t ? \"/\" : \".\";\n          if (t && i === 1) return \"//\";\n          return e.slice(0, i);\n        },\n        basename: function basename(e, r) {\n          if (r !== undefined && typeof r !== \"string\") throw new TypeError('\"ext\" argument must be a string');\n          assertPath(e);\n          var t = 0;\n          var i = -1;\n          var n = true;\n          var a;\n\n          if (r !== undefined && r.length > 0 && r.length <= e.length) {\n            if (r.length === e.length && r === e) return \"\";\n            var f = r.length - 1;\n            var l = -1;\n\n            for (a = e.length - 1; a >= 0; --a) {\n              var s = e.charCodeAt(a);\n\n              if (s === 47) {\n                if (!n) {\n                  t = a + 1;\n                  break;\n                }\n              } else {\n                if (l === -1) {\n                  n = false;\n                  l = a + 1;\n                }\n\n                if (f >= 0) {\n                  if (s === r.charCodeAt(f)) {\n                    if (--f === -1) {\n                      i = a;\n                    }\n                  } else {\n                    f = -1;\n                    i = l;\n                  }\n                }\n              }\n            }\n\n            if (t === i) i = l;else if (i === -1) i = e.length;\n            return e.slice(t, i);\n          } else {\n            for (a = e.length - 1; a >= 0; --a) {\n              if (e.charCodeAt(a) === 47) {\n                if (!n) {\n                  t = a + 1;\n                  break;\n                }\n              } else if (i === -1) {\n                n = false;\n                i = a + 1;\n              }\n            }\n\n            if (i === -1) return \"\";\n            return e.slice(t, i);\n          }\n        },\n        extname: function extname(e) {\n          assertPath(e);\n          var r = -1;\n          var t = 0;\n          var i = -1;\n          var n = true;\n          var a = 0;\n\n          for (var f = e.length - 1; f >= 0; --f) {\n            var l = e.charCodeAt(f);\n\n            if (l === 47) {\n              if (!n) {\n                t = f + 1;\n                break;\n              }\n\n              continue;\n            }\n\n            if (i === -1) {\n              n = false;\n              i = f + 1;\n            }\n\n            if (l === 46) {\n              if (r === -1) r = f;else if (a !== 1) a = 1;\n            } else if (r !== -1) {\n              a = -1;\n            }\n          }\n\n          if (r === -1 || i === -1 || a === 0 || a === 1 && r === i - 1 && r === t + 1) {\n            return \"\";\n          }\n\n          return e.slice(r, i);\n        },\n        format: function format(e) {\n          if (e === null || typeof e !== \"object\") {\n            throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof e);\n          }\n\n          return _format(\"/\", e);\n        },\n        parse: function parse(e) {\n          assertPath(e);\n          var r = {\n            root: \"\",\n            dir: \"\",\n            base: \"\",\n            ext: \"\",\n            name: \"\"\n          };\n          if (e.length === 0) return r;\n          var t = e.charCodeAt(0);\n          var i = t === 47;\n          var n;\n\n          if (i) {\n            r.root = \"/\";\n            n = 1;\n          } else {\n            n = 0;\n          }\n\n          var a = -1;\n          var f = 0;\n          var l = -1;\n          var s = true;\n          var o = e.length - 1;\n          var u = 0;\n\n          for (; o >= n; --o) {\n            t = e.charCodeAt(o);\n\n            if (t === 47) {\n              if (!s) {\n                f = o + 1;\n                break;\n              }\n\n              continue;\n            }\n\n            if (l === -1) {\n              s = false;\n              l = o + 1;\n            }\n\n            if (t === 46) {\n              if (a === -1) a = o;else if (u !== 1) u = 1;\n            } else if (a !== -1) {\n              u = -1;\n            }\n          }\n\n          if (a === -1 || l === -1 || u === 0 || u === 1 && a === l - 1 && a === f + 1) {\n            if (l !== -1) {\n              if (f === 0 && i) r.base = r.name = e.slice(1, l);else r.base = r.name = e.slice(f, l);\n            }\n          } else {\n            if (f === 0 && i) {\n              r.name = e.slice(1, a);\n              r.base = e.slice(1, l);\n            } else {\n              r.name = e.slice(f, a);\n              r.base = e.slice(f, l);\n            }\n\n            r.ext = e.slice(a, l);\n          }\n\n          if (f > 0) r.dir = e.slice(0, f - 1);else if (i) r.dir = \"/\";\n          return r;\n        },\n        sep: \"/\",\n        delimiter: \":\",\n        win32: null,\n        posix: null\n      };\n      r.posix = r;\n      e.exports = r;\n    }\n  };\n  var r = {};\n\n  function __nccwpck_require__(t) {\n    var i = r[t];\n\n    if (i !== undefined) {\n      return i.exports;\n    }\n\n    var n = r[t] = {\n      exports: {}\n    };\n    var a = true;\n\n    try {\n      e[t](n, n.exports, __nccwpck_require__);\n      a = false;\n    } finally {\n      if (a) delete r[t];\n    }\n\n    return n.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var t = __nccwpck_require__(113);\n\n  module.exports = t;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsQ0FBQyxZQUFVO0VBQUM7O0VBQWEsSUFBSUEsQ0FBQyxHQUFDO0lBQUMsS0FBSSxVQUFTQSxDQUFULEVBQVc7TUFBQyxTQUFTQyxVQUFULENBQW9CRCxDQUFwQixFQUFzQjtRQUFDLElBQUcsT0FBT0EsQ0FBUCxLQUFXLFFBQWQsRUFBdUI7VUFBQyxNQUFNLElBQUlFLFNBQUosQ0FBYyxxQ0FBbUNDLElBQUksQ0FBQ0MsU0FBTCxDQUFlSixDQUFmLENBQWpELENBQU47UUFBMEU7TUFBQzs7TUFBQSxTQUFTSyxvQkFBVCxDQUE4QkwsQ0FBOUIsRUFBZ0NNLENBQWhDLEVBQWtDO1FBQUMsSUFBSUMsQ0FBQyxHQUFDLEVBQU47UUFBUyxJQUFJQyxDQUFDLEdBQUMsQ0FBTjtRQUFRLElBQUlDLENBQUMsR0FBQyxDQUFDLENBQVA7UUFBUyxJQUFJQyxDQUFDLEdBQUMsQ0FBTjtRQUFRLElBQUlDLENBQUo7O1FBQU0sS0FBSSxJQUFJQyxDQUFDLEdBQUMsQ0FBVixFQUFZQSxDQUFDLElBQUVaLENBQUMsQ0FBQ2EsTUFBakIsRUFBd0IsRUFBRUQsQ0FBMUIsRUFBNEI7VUFBQyxJQUFHQSxDQUFDLEdBQUNaLENBQUMsQ0FBQ2EsTUFBUCxFQUFjRixDQUFDLEdBQUNYLENBQUMsQ0FBQ2MsVUFBRixDQUFhRixDQUFiLENBQUYsQ0FBZCxLQUFxQyxJQUFHRCxDQUFDLEtBQUcsRUFBUCxFQUFVLE1BQVYsS0FBcUJBLENBQUMsR0FBQyxFQUFGOztVQUFLLElBQUdBLENBQUMsS0FBRyxFQUFQLEVBQVU7WUFBQyxJQUFHRixDQUFDLEtBQUdHLENBQUMsR0FBQyxDQUFOLElBQVNGLENBQUMsS0FBRyxDQUFoQixFQUFrQixDQUFFLENBQXBCLE1BQXlCLElBQUdELENBQUMsS0FBR0csQ0FBQyxHQUFDLENBQU4sSUFBU0YsQ0FBQyxLQUFHLENB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QUssRUFBQyxJQUFoNUg7UUFBcTVIQyxLQUFLLEVBQUM7TUFBMzVILENBQU47TUFBdTZIeEMsQ0FBQyxDQUFDd0MsS0FBRixHQUFReEMsQ0FBUjtNQUFVTixDQUFDLENBQUMrQyxPQUFGLEdBQVV6QyxDQUFWO0lBQVk7RUFBbjRKLENBQU47RUFBMjRKLElBQUlBLENBQUMsR0FBQyxFQUFOOztFQUFTLFNBQVMwQyxtQkFBVCxDQUE2QnpDLENBQTdCLEVBQStCO0lBQUMsSUFBSUMsQ0FBQyxHQUFDRixDQUFDLENBQUNDLENBQUQsQ0FBUDs7SUFBVyxJQUFHQyxDQUFDLEtBQUdrQixTQUFQLEVBQWlCO01BQUMsT0FBT2xCLENBQUMsQ0FBQ3VDLE9BQVQ7SUFBaUI7O0lBQUEsSUFBSXRDLENBQUMsR0FBQ0gsQ0FBQyxDQUFDQyxDQUFELENBQUQsR0FBSztNQUFDd0MsT0FBTyxFQUFDO0lBQVQsQ0FBWDtJQUF3QixJQUFJckMsQ0FBQyxHQUFDLElBQU47O0lBQVcsSUFBRztNQUFDVixDQUFDLENBQUNPLENBQUQsQ0FBRCxDQUFLRSxDQUFMLEVBQU9BLENBQUMsQ0FBQ3NDLE9BQVQsRUFBaUJDLG1CQUFqQjtNQUFzQ3RDLENBQUMsR0FBQyxLQUFGO0lBQVEsQ0FBbEQsU0FBeUQ7TUFBQyxJQUFHQSxDQUFILEVBQUssT0FBT0osQ0FBQyxDQUFDQyxDQUFELENBQVI7SUFBWTs7SUFBQSxPQUFPRSxDQUFDLENBQUNzQyxPQUFUO0VBQWlCOztFQUFBLElBQUcsT0FBT0MsbUJBQVAsS0FBNkIsV0FBaEMsRUFBNENBLG1CQUFtQixDQUFDQyxFQUFwQixHQUF1QkMsU0FBUyxHQUFDLEdBQWpDOztFQUFxQyxJQUFJM0MsQ0FBQyxHQUFDeUMsbUJBQW1CLENBQUMsR0FBRCxDQUF6Qjs7RUFBK0JHLE1BQU0sQ0FBQ0osT0FBUCxHQUFleEMsQ0FBZjtBQUFpQixDQUEzdksiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanM/M2NkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT17MTEzOmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGFzc2VydFBhdGgoZSl7aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShlKSl9fWZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KGUscil7dmFyIHQ9XCJcIjt2YXIgaT0wO3ZhciBuPS0xO3ZhciBhPTA7dmFyIGY7Zm9yKHZhciBsPTA7bDw9ZS5sZW5ndGg7KytsKXtpZihsPGUubGVuZ3RoKWY9ZS5jaGFyQ29kZUF0KGwpO2Vsc2UgaWYoZj09PTQ3KWJyZWFrO2Vsc2UgZj00NztpZihmPT09NDcpe2lmKG49PT1sLTF8fGE9PT0xKXt9ZWxzZSBpZihuIT09bC0xJiZhPT09Mil7aWYodC5sZW5ndGg8Mnx8aSE9PTJ8fHQuY2hhckNvZGVBdCh0Lmxlbmd0aC0xKSE9PTQ2fHx0LmNoYXJDb2RlQXQodC5sZW5ndGgtMikhPT00Nil7aWYodC5sZW5ndGg+Mil7dmFyIHM9dC5sYXN0SW5kZXhPZihcIi9cIik7aWYocyE9PXQubGVuZ3RoLTEpe2lmKHM9PT0tMSl7dD1cIlwiO2k9MH1lbHNle3Q9dC5zbGljZSgwLHMpO2k9dC5sZW5ndGgtMS10Lmxhc3RJbmRleE9mKFwiL1wiKX1uPWw7YT0wO2NvbnRpbnVlfX1lbHNlIGlmKHQubGVuZ3RoPT09Mnx8dC5sZW5ndGg9PT0xKXt0PVwiXCI7aT0wO249bDthPTA7Y29udGludWV9fWlmKHIpe2lmKHQubGVuZ3RoPjApdCs9XCIvLi5cIjtlbHNlIHQ9XCIuLlwiO2k9Mn19ZWxzZXtpZih0Lmxlbmd0aD4wKXQrPVwiL1wiK2Uuc2xpY2UobisxLGwpO2Vsc2UgdD1lLnNsaWNlKG4rMSxsKTtpPWwtbi0xfW49bDthPTB9ZWxzZSBpZihmPT09NDYmJmEhPT0tMSl7KythfWVsc2V7YT0tMX19cmV0dXJuIHR9ZnVuY3Rpb24gX2Zvcm1hdChlLHIpe3ZhciB0PXIuZGlyfHxyLnJvb3Q7dmFyIGk9ci5iYXNlfHwoci5uYW1lfHxcIlwiKSsoci5leHR8fFwiXCIpO2lmKCF0KXtyZXR1cm4gaX1pZih0PT09ci5yb290KXtyZXR1cm4gdCtpfXJldHVybiB0K2UraX12YXIgcj17cmVzb2x2ZTpmdW5jdGlvbiByZXNvbHZlKCl7dmFyIGU9XCJcIjt2YXIgcj1mYWxzZTt2YXIgdDtmb3IodmFyIGk9YXJndW1lbnRzLmxlbmd0aC0xO2k+PS0xJiYhcjtpLS0pe3ZhciBuO2lmKGk+PTApbj1hcmd1bWVudHNbaV07ZWxzZXtpZih0PT09dW5kZWZpbmVkKXQ9XCJcIjtuPXR9YXNzZXJ0UGF0aChuKTtpZihuLmxlbmd0aD09PTApe2NvbnRpbnVlfWU9bitcIi9cIitlO3I9bi5jaGFyQ29kZUF0KDApPT09NDd9ZT1ub3JtYWxpemVTdHJpbmdQb3NpeChlLCFyKTtpZihyKXtpZihlLmxlbmd0aD4wKXJldHVyblwiL1wiK2U7ZWxzZSByZXR1cm5cIi9cIn1lbHNlIGlmKGUubGVuZ3RoPjApe3JldHVybiBlfWVsc2V7cmV0dXJuXCIuXCJ9fSxub3JtYWxpemU6ZnVuY3Rpb24gbm9ybWFsaXplKGUpe2Fzc2VydFBhdGgoZSk7aWYoZS5sZW5ndGg9PT0wKXJldHVyblwiLlwiO3ZhciByPWUuY2hhckNvZGVBdCgwKT09PTQ3O3ZhciB0PWUuY2hhckNvZGVBdChlLmxlbmd0aC0xKT09PTQ3O2U9bm9ybWFsaXplU3RyaW5nUG9zaXgoZSwhcik7aWYoZS5sZW5ndGg9PT0wJiYhcillPVwiLlwiO2lmKGUubGVuZ3RoPjAmJnQpZSs9XCIvXCI7aWYocilyZXR1cm5cIi9cIitlO3JldHVybiBlfSxpc0Fic29sdXRlOmZ1bmN0aW9uIGlzQWJzb2x1dGUoZSl7YXNzZXJ0UGF0aChlKTtyZXR1cm4gZS5sZW5ndGg+MCYmZS5jaGFyQ29kZUF0KDApPT09NDd9LGpvaW46ZnVuY3Rpb24gam9pbigpe2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0wKXJldHVyblwiLlwiO3ZhciBlO2Zvcih2YXIgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDsrK3Qpe3ZhciBpPWFyZ3VtZW50c1t0XTthc3NlcnRQYXRoKGkpO2lmKGkubGVuZ3RoPjApe2lmKGU9PT11bmRlZmluZWQpZT1pO2Vsc2UgZSs9XCIvXCIraX19aWYoZT09PXVuZGVmaW5lZClyZXR1cm5cIi5cIjtyZXR1cm4gci5ub3JtYWxpemUoZSl9LHJlbGF0aXZlOmZ1bmN0aW9uIHJlbGF0aXZlKGUsdCl7YXNzZXJ0UGF0aChlKTthc3NlcnRQYXRoKHQpO2lmKGU9PT10KXJldHVyblwiXCI7ZT1yLnJlc29sdmUoZSk7dD1yLnJlc29sdmUodCk7aWYoZT09PXQpcmV0dXJuXCJcIjt2YXIgaT0xO2Zvcig7aTxlLmxlbmd0aDsrK2kpe2lmKGUuY2hhckNvZGVBdChpKSE9PTQ3KWJyZWFrfXZhciBuPWUubGVuZ3RoO3ZhciBhPW4taTt2YXIgZj0xO2Zvcig7Zjx0Lmxlbmd0aDsrK2Ype2lmKHQuY2hhckNvZGVBdChmKSE9PTQ3KWJyZWFrfXZhciBsPXQubGVuZ3RoO3ZhciBzPWwtZjt2YXIgbz1hPHM/YTpzO3ZhciB1PS0xO3ZhciBoPTA7Zm9yKDtoPD1vOysraCl7aWYoaD09PW8pe2lmKHM+byl7aWYodC5jaGFyQ29kZUF0KGYraCk9PT00Nyl7cmV0dXJuIHQuc2xpY2UoZitoKzEpfWVsc2UgaWYoaD09PTApe3JldHVybiB0LnNsaWNlKGYraCl9fWVsc2UgaWYoYT5vKXtpZihlLmNoYXJDb2RlQXQoaStoKT09PTQ3KXt1PWh9ZWxzZSBpZihoPT09MCl7dT0wfX1icmVha312YXIgYz1lLmNoYXJDb2RlQXQoaStoKTt2YXIgdj10LmNoYXJDb2RlQXQoZitoKTtpZihjIT09dilicmVhaztlbHNlIGlmKGM9PT00Nyl1PWh9dmFyIGc9XCJcIjtmb3IoaD1pK3UrMTtoPD1uOysraCl7aWYoaD09PW58fGUuY2hhckNvZGVBdChoKT09PTQ3KXtpZihnLmxlbmd0aD09PTApZys9XCIuLlwiO2Vsc2UgZys9XCIvLi5cIn19aWYoZy5sZW5ndGg+MClyZXR1cm4gZyt0LnNsaWNlKGYrdSk7ZWxzZXtmKz11O2lmKHQuY2hhckNvZGVBdChmKT09PTQ3KSsrZjtyZXR1cm4gdC5zbGljZShmKX19LF9tYWtlTG9uZzpmdW5jdGlvbiBfbWFrZUxvbmcoZSl7cmV0dXJuIGV9LGRpcm5hbWU6ZnVuY3Rpb24gZGlybmFtZShlKXthc3NlcnRQYXRoKGUpO2lmKGUubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgcj1lLmNoYXJDb2RlQXQoMCk7dmFyIHQ9cj09PTQ3O3ZhciBpPS0xO3ZhciBuPXRydWU7Zm9yKHZhciBhPWUubGVuZ3RoLTE7YT49MTstLWEpe3I9ZS5jaGFyQ29kZUF0KGEpO2lmKHI9PT00Nyl7aWYoIW4pe2k9YTticmVha319ZWxzZXtuPWZhbHNlfX1pZihpPT09LTEpcmV0dXJuIHQ/XCIvXCI6XCIuXCI7aWYodCYmaT09PTEpcmV0dXJuXCIvL1wiO3JldHVybiBlLnNsaWNlKDAsaSl9LGJhc2VuYW1lOmZ1bmN0aW9uIGJhc2VuYW1lKGUscil7aWYociE9PXVuZGVmaW5lZCYmdHlwZW9mIHIhPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXh0XCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO2Fzc2VydFBhdGgoZSk7dmFyIHQ9MDt2YXIgaT0tMTt2YXIgbj10cnVlO3ZhciBhO2lmKHIhPT11bmRlZmluZWQmJnIubGVuZ3RoPjAmJnIubGVuZ3RoPD1lLmxlbmd0aCl7aWYoci5sZW5ndGg9PT1lLmxlbmd0aCYmcj09PWUpcmV0dXJuXCJcIjt2YXIgZj1yLmxlbmd0aC0xO3ZhciBsPS0xO2ZvcihhPWUubGVuZ3RoLTE7YT49MDstLWEpe3ZhciBzPWUuY2hhckNvZGVBdChhKTtpZihzPT09NDcpe2lmKCFuKXt0PWErMTticmVha319ZWxzZXtpZihsPT09LTEpe249ZmFsc2U7bD1hKzF9aWYoZj49MCl7aWYocz09PXIuY2hhckNvZGVBdChmKSl7aWYoLS1mPT09LTEpe2k9YX19ZWxzZXtmPS0xO2k9bH19fX1pZih0PT09aSlpPWw7ZWxzZSBpZihpPT09LTEpaT1lLmxlbmd0aDtyZXR1cm4gZS5zbGljZSh0LGkpfWVsc2V7Zm9yKGE9ZS5sZW5ndGgtMTthPj0wOy0tYSl7aWYoZS5jaGFyQ29kZUF0KGEpPT09NDcpe2lmKCFuKXt0PWErMTticmVha319ZWxzZSBpZihpPT09LTEpe249ZmFsc2U7aT1hKzF9fWlmKGk9PT0tMSlyZXR1cm5cIlwiO3JldHVybiBlLnNsaWNlKHQsaSl9fSxleHRuYW1lOmZ1bmN0aW9uIGV4dG5hbWUoZSl7YXNzZXJ0UGF0aChlKTt2YXIgcj0tMTt2YXIgdD0wO3ZhciBpPS0xO3ZhciBuPXRydWU7dmFyIGE9MDtmb3IodmFyIGY9ZS5sZW5ndGgtMTtmPj0wOy0tZil7dmFyIGw9ZS5jaGFyQ29kZUF0KGYpO2lmKGw9PT00Nyl7aWYoIW4pe3Q9ZisxO2JyZWFrfWNvbnRpbnVlfWlmKGk9PT0tMSl7bj1mYWxzZTtpPWYrMX1pZihsPT09NDYpe2lmKHI9PT0tMSlyPWY7ZWxzZSBpZihhIT09MSlhPTF9ZWxzZSBpZihyIT09LTEpe2E9LTF9fWlmKHI9PT0tMXx8aT09PS0xfHxhPT09MHx8YT09PTEmJnI9PT1pLTEmJnI9PT10KzEpe3JldHVyblwiXCJ9cmV0dXJuIGUuc2xpY2UocixpKX0sZm9ybWF0OmZ1bmN0aW9uIGZvcm1hdChlKXtpZihlPT09bnVsbHx8dHlwZW9mIGUhPT1cIm9iamVjdFwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJwYXRoT2JqZWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnK3R5cGVvZiBlKX1yZXR1cm4gX2Zvcm1hdChcIi9cIixlKX0scGFyc2U6ZnVuY3Rpb24gcGFyc2UoZSl7YXNzZXJ0UGF0aChlKTt2YXIgcj17cm9vdDpcIlwiLGRpcjpcIlwiLGJhc2U6XCJcIixleHQ6XCJcIixuYW1lOlwiXCJ9O2lmKGUubGVuZ3RoPT09MClyZXR1cm4gcjt2YXIgdD1lLmNoYXJDb2RlQXQoMCk7dmFyIGk9dD09PTQ3O3ZhciBuO2lmKGkpe3Iucm9vdD1cIi9cIjtuPTF9ZWxzZXtuPTB9dmFyIGE9LTE7dmFyIGY9MDt2YXIgbD0tMTt2YXIgcz10cnVlO3ZhciBvPWUubGVuZ3RoLTE7dmFyIHU9MDtmb3IoO28+PW47LS1vKXt0PWUuY2hhckNvZGVBdChvKTtpZih0PT09NDcpe2lmKCFzKXtmPW8rMTticmVha31jb250aW51ZX1pZihsPT09LTEpe3M9ZmFsc2U7bD1vKzF9aWYodD09PTQ2KXtpZihhPT09LTEpYT1vO2Vsc2UgaWYodSE9PTEpdT0xfWVsc2UgaWYoYSE9PS0xKXt1PS0xfX1pZihhPT09LTF8fGw9PT0tMXx8dT09PTB8fHU9PT0xJiZhPT09bC0xJiZhPT09ZisxKXtpZihsIT09LTEpe2lmKGY9PT0wJiZpKXIuYmFzZT1yLm5hbWU9ZS5zbGljZSgxLGwpO2Vsc2Ugci5iYXNlPXIubmFtZT1lLnNsaWNlKGYsbCl9fWVsc2V7aWYoZj09PTAmJmkpe3IubmFtZT1lLnNsaWNlKDEsYSk7ci5iYXNlPWUuc2xpY2UoMSxsKX1lbHNle3IubmFtZT1lLnNsaWNlKGYsYSk7ci5iYXNlPWUuc2xpY2UoZixsKX1yLmV4dD1lLnNsaWNlKGEsbCl9aWYoZj4wKXIuZGlyPWUuc2xpY2UoMCxmLTEpO2Vsc2UgaWYoaSlyLmRpcj1cIi9cIjtyZXR1cm4gcn0sc2VwOlwiL1wiLGRlbGltaXRlcjpcIjpcIix3aW4zMjpudWxsLHBvc2l4Om51bGx9O3IucG9zaXg9cjtlLmV4cG9ydHM9cn19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIGk9clt0XTtpZihpIT09dW5kZWZpbmVkKXtyZXR1cm4gaS5leHBvcnRzfXZhciBuPXJbdF09e2V4cG9ydHM6e319O3ZhciBhPXRydWU7dHJ5e2VbdF0obixuLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7YT1mYWxzZX1maW5hbGx5e2lmKGEpZGVsZXRlIHJbdF19cmV0dXJuIG4uZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXygxMTMpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6WyJlIiwiYXNzZXJ0UGF0aCIsIlR5cGVFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJub3JtYWxpemVTdHJpbmdQb3NpeCIsInIiLCJ0IiwiaSIsIm4iLCJhIiwiZiIsImwiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwicyIsImxhc3RJbmRleE9mIiwic2xpY2UiLCJfZm9ybWF0IiwiZGlyIiwicm9vdCIsImJhc2UiLCJuYW1lIiwiZXh0IiwicmVzb2x2ZSIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsIm5vcm1hbGl6ZSIsImlzQWJzb2x1dGUiLCJqb2luIiwicmVsYXRpdmUiLCJvIiwidSIsImgiLCJjIiwidiIsImciLCJfbWFrZUxvbmciLCJkaXJuYW1lIiwiYmFzZW5hbWUiLCJleHRuYW1lIiwiZm9ybWF0IiwicGFyc2UiLCJzZXAiLCJkZWxpbWl0ZXIiLCJ3aW4zMiIsInBvc2l4IiwiZXhwb3J0cyIsIl9fbmNjd3Bja19yZXF1aXJlX18iLCJhYiIsIl9fZGlybmFtZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/path-browserify/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function () {\n  var e = {\n    308: function (e) {\n      var t = e.exports = {};\n      var r;\n      var n;\n\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n\n      (function () {\n        try {\n          if (typeof setTimeout === \"function\") {\n            r = setTimeout;\n          } else {\n            r = defaultSetTimout;\n          }\n        } catch (e) {\n          r = defaultSetTimout;\n        }\n\n        try {\n          if (typeof clearTimeout === \"function\") {\n            n = clearTimeout;\n          } else {\n            n = defaultClearTimeout;\n          }\n        } catch (e) {\n          n = defaultClearTimeout;\n        }\n      })();\n\n      function runTimeout(e) {\n        if (r === setTimeout) {\n          return setTimeout(e, 0);\n        }\n\n        if ((r === defaultSetTimout || !r) && setTimeout) {\n          r = setTimeout;\n          return setTimeout(e, 0);\n        }\n\n        try {\n          return r(e, 0);\n        } catch (t) {\n          try {\n            return r.call(null, e, 0);\n          } catch (t) {\n            return r.call(this, e, 0);\n          }\n        }\n      }\n\n      function runClearTimeout(e) {\n        if (n === clearTimeout) {\n          return clearTimeout(e);\n        }\n\n        if ((n === defaultClearTimeout || !n) && clearTimeout) {\n          n = clearTimeout;\n          return clearTimeout(e);\n        }\n\n        try {\n          return n(e);\n        } catch (t) {\n          try {\n            return n.call(null, e);\n          } catch (t) {\n            return n.call(this, e);\n          }\n        }\n      }\n\n      var i = [];\n      var o = false;\n      var u;\n      var a = -1;\n\n      function cleanUpNextTick() {\n        if (!o || !u) {\n          return;\n        }\n\n        o = false;\n\n        if (u.length) {\n          i = u.concat(i);\n        } else {\n          a = -1;\n        }\n\n        if (i.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (o) {\n          return;\n        }\n\n        var e = runTimeout(cleanUpNextTick);\n        o = true;\n        var t = i.length;\n\n        while (t) {\n          u = i;\n          i = [];\n\n          while (++a < t) {\n            if (u) {\n              u[a].run();\n            }\n          }\n\n          a = -1;\n          t = i.length;\n        }\n\n        u = null;\n        o = false;\n        runClearTimeout(e);\n      }\n\n      t.nextTick = function (e) {\n        var t = new Array(arguments.length - 1);\n\n        if (arguments.length > 1) {\n          for (var r = 1; r < arguments.length; r++) {\n            t[r - 1] = arguments[r];\n          }\n        }\n\n        i.push(new Item(e, t));\n\n        if (i.length === 1 && !o) {\n          runTimeout(drainQueue);\n        }\n      };\n\n      function Item(e, t) {\n        this.fun = e;\n        this.array = t;\n      }\n\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n\n      t.title = \"browser\";\n      t.browser = true;\n      t.env = {};\n      t.argv = [];\n      t.version = \"\";\n      t.versions = {};\n\n      function noop() {}\n\n      t.on = noop;\n      t.addListener = noop;\n      t.once = noop;\n      t.off = noop;\n      t.removeListener = noop;\n      t.removeAllListeners = noop;\n      t.emit = noop;\n      t.prependListener = noop;\n      t.prependOnceListener = noop;\n\n      t.listeners = function (e) {\n        return [];\n      };\n\n      t.binding = function (e) {\n        throw new Error(\"process.binding is not supported\");\n      };\n\n      t.cwd = function () {\n        return \"/\";\n      };\n\n      t.chdir = function (e) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n\n      t.umask = function () {\n        return 0;\n      };\n    }\n  };\n  var t = {};\n\n  function __nccwpck_require__(r) {\n    var n = t[r];\n\n    if (n !== undefined) {\n      return n.exports;\n    }\n\n    var i = t[r] = {\n      exports: {}\n    };\n    var o = true;\n\n    try {\n      e[r](i, i.exports, __nccwpck_require__);\n      o = false;\n    } finally {\n      if (o) delete t[r];\n    }\n\n    return i.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var r = __nccwpck_require__(308);\n\n  module.exports = r;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsQ0FBQyxZQUFVO0VBQUMsSUFBSUEsQ0FBQyxHQUFDO0lBQUMsS0FBSSxVQUFTQSxDQUFULEVBQVc7TUFBQyxJQUFJQyxDQUFDLEdBQUNELENBQUMsQ0FBQ0UsT0FBRixHQUFVLEVBQWhCO01BQW1CLElBQUlDLENBQUo7TUFBTSxJQUFJQyxDQUFKOztNQUFNLFNBQVNDLGdCQUFULEdBQTJCO1FBQUMsTUFBTSxJQUFJQyxLQUFKLENBQVUsaUNBQVYsQ0FBTjtNQUFtRDs7TUFBQSxTQUFTQyxtQkFBVCxHQUE4QjtRQUFDLE1BQU0sSUFBSUQsS0FBSixDQUFVLG1DQUFWLENBQU47TUFBcUQ7O01BQUEsQ0FBQyxZQUFVO1FBQUMsSUFBRztVQUFDLElBQUcsT0FBT0UsVUFBUCxLQUFvQixVQUF2QixFQUFrQztZQUFDTCxDQUFDLEdBQUNLLFVBQUY7VUFBYSxDQUFoRCxNQUFvRDtZQUFDTCxDQUFDLEdBQUNFLGdCQUFGO1VBQW1CO1FBQUMsQ0FBN0UsQ0FBNkUsT0FBTUwsQ0FBTixFQUFRO1VBQUNHLENBQUMsR0FBQ0UsZ0JBQUY7UUFBbUI7O1FBQUEsSUFBRztVQUFDLElBQUcsT0FBT0ksWUFBUCxLQUFzQixVQUF6QixFQUFvQztZQUFDTCxDQUFDLEdBQUNLLFlBQUY7VUFBZSxDQUFwRCxNQUF3RDtZQUFDTCxDQUFDLEdBQUNHLG1CQUFGO1VBQXNCO1FBQUMsQ0FBcEYsQ0FBb0YsT0FBTVAsQ0FBTixFQUFRO1VBQUNJLENBQUMsR0FBQ0csbUJBQUY7UUFBc0I7TUFBQyxDQUF6Tzs7TUFBNk8sU0FBU0csVUFBVCxDQUFvQlYsQ0FBcEIsRUFBc0I7UUFBQyxJQUFHRyxDQUFDLEtBQUdLLFVBQVAsRUFBa0I7VUFBQyxPQUFPQSxVQUFVLENBQUNSLENBQUQsRUFBRyxDQUFILENBQWpCO1FBQXVCOztRQUFBLElBQUcsQ0FBQ0csQ0FBQyxLQUFH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SUFBaUI7O0lBQUEsSUFBSVcsQ0FBQyxHQUFDWixDQUFDLENBQUNFLENBQUQsQ0FBRCxHQUFLO01BQUNELE9BQU8sRUFBQztJQUFULENBQVg7SUFBd0IsSUFBSVksQ0FBQyxHQUFDLElBQU47O0lBQVcsSUFBRztNQUFDZCxDQUFDLENBQUNHLENBQUQsQ0FBRCxDQUFLVSxDQUFMLEVBQU9BLENBQUMsQ0FBQ1gsT0FBVCxFQUFpQmtELG1CQUFqQjtNQUFzQ3RDLENBQUMsR0FBQyxLQUFGO0lBQVEsQ0FBbEQsU0FBeUQ7TUFBQyxJQUFHQSxDQUFILEVBQUssT0FBT2IsQ0FBQyxDQUFDRSxDQUFELENBQVI7SUFBWTs7SUFBQSxPQUFPVSxDQUFDLENBQUNYLE9BQVQ7RUFBaUI7O0VBQUEsSUFBRyxPQUFPa0QsbUJBQVAsS0FBNkIsV0FBaEMsRUFBNENBLG1CQUFtQixDQUFDRSxFQUFwQixHQUF1QkMsU0FBUyxHQUFDLEdBQWpDOztFQUFxQyxJQUFJcEQsQ0FBQyxHQUFDaUQsbUJBQW1CLENBQUMsR0FBRCxDQUF6Qjs7RUFBK0JJLE1BQU0sQ0FBQ3RELE9BQVAsR0FBZUMsQ0FBZjtBQUFpQixDQUF0NEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanM/MWIxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17MzA4OmZ1bmN0aW9uKGUpe3ZhciB0PWUuZXhwb3J0cz17fTt2YXIgcjt2YXIgbjtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfShmdW5jdGlvbigpe3RyeXtpZih0eXBlb2Ygc2V0VGltZW91dD09PVwiZnVuY3Rpb25cIil7cj1zZXRUaW1lb3V0fWVsc2V7cj1kZWZhdWx0U2V0VGltb3V0fX1jYXRjaChlKXtyPWRlZmF1bHRTZXRUaW1vdXR9dHJ5e2lmKHR5cGVvZiBjbGVhclRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe249Y2xlYXJUaW1lb3V0fWVsc2V7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX1jYXRjaChlKXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fSkoKTtmdW5jdGlvbiBydW5UaW1lb3V0KGUpe2lmKHI9PT1zZXRUaW1lb3V0KXtyZXR1cm4gc2V0VGltZW91dChlLDApfWlmKChyPT09ZGVmYXVsdFNldFRpbW91dHx8IXIpJiZzZXRUaW1lb3V0KXtyPXNldFRpbWVvdXQ7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX10cnl7cmV0dXJuIHIoZSwwKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUsMCl9Y2F0Y2godCl7cmV0dXJuIHIuY2FsbCh0aGlzLGUsMCl9fX1mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQoZSl7aWYobj09PWNsZWFyVGltZW91dCl7cmV0dXJuIGNsZWFyVGltZW91dChlKX1pZigobj09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCFuKSYmY2xlYXJUaW1lb3V0KXtuPWNsZWFyVGltZW91dDtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfXRyeXtyZXR1cm4gbihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlKX19fXZhciBpPVtdO3ZhciBvPWZhbHNlO3ZhciB1O3ZhciBhPS0xO2Z1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpe2lmKCFvfHwhdSl7cmV0dXJufW89ZmFsc2U7aWYodS5sZW5ndGgpe2k9dS5jb25jYXQoaSl9ZWxzZXthPS0xfWlmKGkubGVuZ3RoKXtkcmFpblF1ZXVlKCl9fWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZihvKXtyZXR1cm59dmFyIGU9cnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO289dHJ1ZTt2YXIgdD1pLmxlbmd0aDt3aGlsZSh0KXt1PWk7aT1bXTt3aGlsZSgrK2E8dCl7aWYodSl7dVthXS5ydW4oKX19YT0tMTt0PWkubGVuZ3RofXU9bnVsbDtvPWZhbHNlO3J1bkNsZWFyVGltZW91dChlKX10Lm5leHRUaWNrPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dFtyLTFdPWFyZ3VtZW50c1tyXX19aS5wdXNoKG5ldyBJdGVtKGUsdCkpO2lmKGkubGVuZ3RoPT09MSYmIW8pe3J1blRpbWVvdXQoZHJhaW5RdWV1ZSl9fTtmdW5jdGlvbiBJdGVtKGUsdCl7dGhpcy5mdW49ZTt0aGlzLmFycmF5PXR9SXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX07dC50aXRsZT1cImJyb3dzZXJcIjt0LmJyb3dzZXI9dHJ1ZTt0LmVudj17fTt0LmFyZ3Y9W107dC52ZXJzaW9uPVwiXCI7dC52ZXJzaW9ucz17fTtmdW5jdGlvbiBub29wKCl7fXQub249bm9vcDt0LmFkZExpc3RlbmVyPW5vb3A7dC5vbmNlPW5vb3A7dC5vZmY9bm9vcDt0LnJlbW92ZUxpc3RlbmVyPW5vb3A7dC5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDt0LmVtaXQ9bm9vcDt0LnByZXBlbmRMaXN0ZW5lcj1ub29wO3QucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wO3QubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybltdfTt0LmJpbmRpbmc9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3QuY2hkaXI9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGk9dFtyXT17ZXhwb3J0czp7fX07dmFyIG89dHJ1ZTt0cnl7ZVtyXShpLGkuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtvPWZhbHNlfWZpbmFsbHl7aWYobylkZWxldGUgdFtyXX1yZXR1cm4gaS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj1fX25jY3dwY2tfcmVxdWlyZV9fKDMwOCk7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbImUiLCJ0IiwiZXhwb3J0cyIsInIiLCJuIiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiY2FsbCIsInJ1bkNsZWFyVGltZW91dCIsImkiLCJvIiwidSIsImEiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwicnVuIiwibmV4dFRpY2siLCJBcnJheSIsImFyZ3VtZW50cyIsInB1c2giLCJJdGVtIiwiZnVuIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwidW5kZWZpbmVkIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/util/util.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/compiled/util/util.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n(function () {\n  var r = {\n    997: function (r) {\n      r.exports = function (r, t, n) {\n        if (r.filter) return r.filter(t, n);\n        if (void 0 === r || null === r) throw new TypeError();\n        if (\"function\" != typeof t) throw new TypeError();\n        var o = [];\n\n        for (var i = 0; i < r.length; i++) {\n          if (!e.call(r, i)) continue;\n          var a = r[i];\n          if (t.call(n, a, i, r)) o.push(a);\n        }\n\n        return o;\n      };\n\n      var e = Object.prototype.hasOwnProperty;\n    },\n    171: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(627);\n      var o = t(302);\n      var i = o(n(\"String.prototype.indexOf\"));\n\n      r.exports = function callBoundIntrinsic(r, e) {\n        var t = n(r, !!e);\n\n        if (typeof t === \"function\" && i(r, \".prototype.\") > -1) {\n          return o(t);\n        }\n\n        return t;\n      };\n    },\n    302: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(194);\n      var o = t(627);\n      var i = o(\"%Function.prototype.apply%\");\n      var a = o(\"%Function.prototype.call%\");\n      var f = o(\"%Reflect.apply%\", true) || n.call(a, i);\n      var u = o(\"%Object.getOwnPropertyDescriptor%\", true);\n      var s = o(\"%Object.defineProperty%\", true);\n      var c = o(\"%Math.max%\");\n\n      if (s) {\n        try {\n          s({}, \"a\", {\n            value: 1\n          });\n        } catch (r) {\n          s = null;\n        }\n      }\n\n      r.exports = function callBind(r) {\n        var e = f(n, a, arguments);\n\n        if (u && s) {\n          var t = u(e, \"length\");\n\n          if (t.configurable) {\n            s(e, \"length\", {\n              value: 1 + c(0, r.length - (arguments.length - 1))\n            });\n          }\n        }\n\n        return e;\n      };\n\n      var y = function applyBind() {\n        return f(n, i, arguments);\n      };\n\n      if (s) {\n        s(r.exports, \"apply\", {\n          value: y\n        });\n      } else {\n        r.exports.apply = y;\n      }\n    },\n    981: function (r) {\n      var e = Object.prototype.hasOwnProperty;\n      var t = Object.prototype.toString;\n\n      r.exports = function forEach(r, n, o) {\n        if (t.call(n) !== \"[object Function]\") {\n          throw new TypeError(\"iterator must be a function\");\n        }\n\n        var i = r.length;\n\n        if (i === +i) {\n          for (var a = 0; a < i; a++) {\n            n.call(o, r[a], a, r);\n          }\n        } else {\n          for (var f in r) {\n            if (e.call(r, f)) {\n              n.call(o, r[f], f, r);\n            }\n          }\n        }\n      };\n    },\n    861: function (r) {\n      \"use strict\";\n\n      var e = \"Function.prototype.bind called on incompatible \";\n      var t = Array.prototype.slice;\n      var n = Object.prototype.toString;\n      var o = \"[object Function]\";\n\n      r.exports = function bind(r) {\n        var i = this;\n\n        if (typeof i !== \"function\" || n.call(i) !== o) {\n          throw new TypeError(e + i);\n        }\n\n        var a = t.call(arguments, 1);\n        var f;\n\n        var binder = function () {\n          if (this instanceof f) {\n            var e = i.apply(this, a.concat(t.call(arguments)));\n\n            if (Object(e) === e) {\n              return e;\n            }\n\n            return this;\n          } else {\n            return i.apply(r, a.concat(t.call(arguments)));\n          }\n        };\n\n        var u = Math.max(0, i.length - a.length);\n        var s = [];\n\n        for (var c = 0; c < u; c++) {\n          s.push(\"$\" + c);\n        }\n\n        f = Function(\"binder\", \"return function (\" + s.join(\",\") + \"){ return binder.apply(this,arguments); }\")(binder);\n\n        if (i.prototype) {\n          var y = function Empty() {};\n\n          y.prototype = i.prototype;\n          f.prototype = new y();\n          y.prototype = null;\n        }\n\n        return f;\n      };\n    },\n    194: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(861);\n      r.exports = Function.prototype.bind || n;\n    },\n    627: function (r, e, t) {\n      \"use strict\";\n\n      var n;\n      var o = SyntaxError;\n      var i = Function;\n      var a = TypeError;\n\n      var getEvalledConstructor = function (r) {\n        try {\n          return i('\"use strict\"; return (' + r + \").constructor;\")();\n        } catch (r) {}\n      };\n\n      var f = Object.getOwnPropertyDescriptor;\n\n      if (f) {\n        try {\n          f({}, \"\");\n        } catch (r) {\n          f = null;\n        }\n      }\n\n      var throwTypeError = function () {\n        throw new a();\n      };\n\n      var u = f ? function () {\n        try {\n          arguments.callee;\n          return throwTypeError;\n        } catch (r) {\n          try {\n            return f(arguments, \"callee\").get;\n          } catch (r) {\n            return throwTypeError;\n          }\n        }\n      }() : throwTypeError;\n      var s = t(567)();\n\n      var c = Object.getPrototypeOf || function (r) {\n        return r.__proto__;\n      };\n\n      var y = {};\n      var p = typeof Uint8Array === \"undefined\" ? n : c(Uint8Array);\n      var l = {\n        \"%AggregateError%\": typeof AggregateError === \"undefined\" ? n : AggregateError,\n        \"%Array%\": Array,\n        \"%ArrayBuffer%\": typeof ArrayBuffer === \"undefined\" ? n : ArrayBuffer,\n        \"%ArrayIteratorPrototype%\": s ? c([][Symbol.iterator]()) : n,\n        \"%AsyncFromSyncIteratorPrototype%\": n,\n        \"%AsyncFunction%\": y,\n        \"%AsyncGenerator%\": y,\n        \"%AsyncGeneratorFunction%\": y,\n        \"%AsyncIteratorPrototype%\": y,\n        \"%Atomics%\": typeof Atomics === \"undefined\" ? n : Atomics,\n        \"%BigInt%\": typeof BigInt === \"undefined\" ? n : BigInt,\n        \"%Boolean%\": Boolean,\n        \"%DataView%\": typeof DataView === \"undefined\" ? n : DataView,\n        \"%Date%\": Date,\n        \"%decodeURI%\": decodeURI,\n        \"%decodeURIComponent%\": decodeURIComponent,\n        \"%encodeURI%\": encodeURI,\n        \"%encodeURIComponent%\": encodeURIComponent,\n        \"%Error%\": Error,\n        \"%eval%\": eval,\n        \"%EvalError%\": EvalError,\n        \"%Float32Array%\": typeof Float32Array === \"undefined\" ? n : Float32Array,\n        \"%Float64Array%\": typeof Float64Array === \"undefined\" ? n : Float64Array,\n        \"%FinalizationRegistry%\": typeof FinalizationRegistry === \"undefined\" ? n : FinalizationRegistry,\n        \"%Function%\": i,\n        \"%GeneratorFunction%\": y,\n        \"%Int8Array%\": typeof Int8Array === \"undefined\" ? n : Int8Array,\n        \"%Int16Array%\": typeof Int16Array === \"undefined\" ? n : Int16Array,\n        \"%Int32Array%\": typeof Int32Array === \"undefined\" ? n : Int32Array,\n        \"%isFinite%\": isFinite,\n        \"%isNaN%\": isNaN,\n        \"%IteratorPrototype%\": s ? c(c([][Symbol.iterator]())) : n,\n        \"%JSON%\": typeof JSON === \"object\" ? JSON : n,\n        \"%Map%\": typeof Map === \"undefined\" ? n : Map,\n        \"%MapIteratorPrototype%\": typeof Map === \"undefined\" || !s ? n : c(new Map()[Symbol.iterator]()),\n        \"%Math%\": Math,\n        \"%Number%\": Number,\n        \"%Object%\": Object,\n        \"%parseFloat%\": parseFloat,\n        \"%parseInt%\": parseInt,\n        \"%Promise%\": typeof Promise === \"undefined\" ? n : Promise,\n        \"%Proxy%\": typeof Proxy === \"undefined\" ? n : Proxy,\n        \"%RangeError%\": RangeError,\n        \"%ReferenceError%\": ReferenceError,\n        \"%Reflect%\": typeof Reflect === \"undefined\" ? n : Reflect,\n        \"%RegExp%\": RegExp,\n        \"%Set%\": typeof Set === \"undefined\" ? n : Set,\n        \"%SetIteratorPrototype%\": typeof Set === \"undefined\" || !s ? n : c(new Set()[Symbol.iterator]()),\n        \"%SharedArrayBuffer%\": typeof SharedArrayBuffer === \"undefined\" ? n : SharedArrayBuffer,\n        \"%String%\": String,\n        \"%StringIteratorPrototype%\": s ? c(\"\"[Symbol.iterator]()) : n,\n        \"%Symbol%\": s ? Symbol : n,\n        \"%SyntaxError%\": o,\n        \"%ThrowTypeError%\": u,\n        \"%TypedArray%\": p,\n        \"%TypeError%\": a,\n        \"%Uint8Array%\": typeof Uint8Array === \"undefined\" ? n : Uint8Array,\n        \"%Uint8ClampedArray%\": typeof Uint8ClampedArray === \"undefined\" ? n : Uint8ClampedArray,\n        \"%Uint16Array%\": typeof Uint16Array === \"undefined\" ? n : Uint16Array,\n        \"%Uint32Array%\": typeof Uint32Array === \"undefined\" ? n : Uint32Array,\n        \"%URIError%\": URIError,\n        \"%WeakMap%\": typeof WeakMap === \"undefined\" ? n : WeakMap,\n        \"%WeakRef%\": typeof WeakRef === \"undefined\" ? n : WeakRef,\n        \"%WeakSet%\": typeof WeakSet === \"undefined\" ? n : WeakSet\n      };\n\n      var g = function doEval(r) {\n        var e;\n\n        if (r === \"%AsyncFunction%\") {\n          e = getEvalledConstructor(\"async function () {}\");\n        } else if (r === \"%GeneratorFunction%\") {\n          e = getEvalledConstructor(\"function* () {}\");\n        } else if (r === \"%AsyncGeneratorFunction%\") {\n          e = getEvalledConstructor(\"async function* () {}\");\n        } else if (r === \"%AsyncGenerator%\") {\n          var t = doEval(\"%AsyncGeneratorFunction%\");\n\n          if (t) {\n            e = t.prototype;\n          }\n        } else if (r === \"%AsyncIteratorPrototype%\") {\n          var n = doEval(\"%AsyncGenerator%\");\n\n          if (n) {\n            e = c(n.prototype);\n          }\n        }\n\n        l[r] = e;\n        return e;\n      };\n\n      var d = {\n        \"%ArrayBufferPrototype%\": [\"ArrayBuffer\", \"prototype\"],\n        \"%ArrayPrototype%\": [\"Array\", \"prototype\"],\n        \"%ArrayProto_entries%\": [\"Array\", \"prototype\", \"entries\"],\n        \"%ArrayProto_forEach%\": [\"Array\", \"prototype\", \"forEach\"],\n        \"%ArrayProto_keys%\": [\"Array\", \"prototype\", \"keys\"],\n        \"%ArrayProto_values%\": [\"Array\", \"prototype\", \"values\"],\n        \"%AsyncFunctionPrototype%\": [\"AsyncFunction\", \"prototype\"],\n        \"%AsyncGenerator%\": [\"AsyncGeneratorFunction\", \"prototype\"],\n        \"%AsyncGeneratorPrototype%\": [\"AsyncGeneratorFunction\", \"prototype\", \"prototype\"],\n        \"%BooleanPrototype%\": [\"Boolean\", \"prototype\"],\n        \"%DataViewPrototype%\": [\"DataView\", \"prototype\"],\n        \"%DatePrototype%\": [\"Date\", \"prototype\"],\n        \"%ErrorPrototype%\": [\"Error\", \"prototype\"],\n        \"%EvalErrorPrototype%\": [\"EvalError\", \"prototype\"],\n        \"%Float32ArrayPrototype%\": [\"Float32Array\", \"prototype\"],\n        \"%Float64ArrayPrototype%\": [\"Float64Array\", \"prototype\"],\n        \"%FunctionPrototype%\": [\"Function\", \"prototype\"],\n        \"%Generator%\": [\"GeneratorFunction\", \"prototype\"],\n        \"%GeneratorPrototype%\": [\"GeneratorFunction\", \"prototype\", \"prototype\"],\n        \"%Int8ArrayPrototype%\": [\"Int8Array\", \"prototype\"],\n        \"%Int16ArrayPrototype%\": [\"Int16Array\", \"prototype\"],\n        \"%Int32ArrayPrototype%\": [\"Int32Array\", \"prototype\"],\n        \"%JSONParse%\": [\"JSON\", \"parse\"],\n        \"%JSONStringify%\": [\"JSON\", \"stringify\"],\n        \"%MapPrototype%\": [\"Map\", \"prototype\"],\n        \"%NumberPrototype%\": [\"Number\", \"prototype\"],\n        \"%ObjectPrototype%\": [\"Object\", \"prototype\"],\n        \"%ObjProto_toString%\": [\"Object\", \"prototype\", \"toString\"],\n        \"%ObjProto_valueOf%\": [\"Object\", \"prototype\", \"valueOf\"],\n        \"%PromisePrototype%\": [\"Promise\", \"prototype\"],\n        \"%PromiseProto_then%\": [\"Promise\", \"prototype\", \"then\"],\n        \"%Promise_all%\": [\"Promise\", \"all\"],\n        \"%Promise_reject%\": [\"Promise\", \"reject\"],\n        \"%Promise_resolve%\": [\"Promise\", \"resolve\"],\n        \"%RangeErrorPrototype%\": [\"RangeError\", \"prototype\"],\n        \"%ReferenceErrorPrototype%\": [\"ReferenceError\", \"prototype\"],\n        \"%RegExpPrototype%\": [\"RegExp\", \"prototype\"],\n        \"%SetPrototype%\": [\"Set\", \"prototype\"],\n        \"%SharedArrayBufferPrototype%\": [\"SharedArrayBuffer\", \"prototype\"],\n        \"%StringPrototype%\": [\"String\", \"prototype\"],\n        \"%SymbolPrototype%\": [\"Symbol\", \"prototype\"],\n        \"%SyntaxErrorPrototype%\": [\"SyntaxError\", \"prototype\"],\n        \"%TypedArrayPrototype%\": [\"TypedArray\", \"prototype\"],\n        \"%TypeErrorPrototype%\": [\"TypeError\", \"prototype\"],\n        \"%Uint8ArrayPrototype%\": [\"Uint8Array\", \"prototype\"],\n        \"%Uint8ClampedArrayPrototype%\": [\"Uint8ClampedArray\", \"prototype\"],\n        \"%Uint16ArrayPrototype%\": [\"Uint16Array\", \"prototype\"],\n        \"%Uint32ArrayPrototype%\": [\"Uint32Array\", \"prototype\"],\n        \"%URIErrorPrototype%\": [\"URIError\", \"prototype\"],\n        \"%WeakMapPrototype%\": [\"WeakMap\", \"prototype\"],\n        \"%WeakSetPrototype%\": [\"WeakSet\", \"prototype\"]\n      };\n      var v = t(194);\n      var b = t(646);\n      var A = v.call(Function.call, Array.prototype.concat);\n      var m = v.call(Function.apply, Array.prototype.splice);\n      var S = v.call(Function.call, String.prototype.replace);\n      var h = v.call(Function.call, String.prototype.slice);\n      var O = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\n      var w = /\\\\(\\\\)?/g;\n\n      var j = function stringToPath(r) {\n        var e = h(r, 0, 1);\n        var t = h(r, -1);\n\n        if (e === \"%\" && t !== \"%\") {\n          throw new o(\"invalid intrinsic syntax, expected closing `%`\");\n        } else if (t === \"%\" && e !== \"%\") {\n          throw new o(\"invalid intrinsic syntax, expected opening `%`\");\n        }\n\n        var n = [];\n        S(r, O, function (r, e, t, o) {\n          n[n.length] = t ? S(o, w, \"$1\") : e || r;\n        });\n        return n;\n      };\n\n      var P = function getBaseIntrinsic(r, e) {\n        var t = r;\n        var n;\n\n        if (b(d, t)) {\n          n = d[t];\n          t = \"%\" + n[0] + \"%\";\n        }\n\n        if (b(l, t)) {\n          var i = l[t];\n\n          if (i === y) {\n            i = g(t);\n          }\n\n          if (typeof i === \"undefined\" && !e) {\n            throw new a(\"intrinsic \" + r + \" exists, but is not available. Please file an issue!\");\n          }\n\n          return {\n            alias: n,\n            name: t,\n            value: i\n          };\n        }\n\n        throw new o(\"intrinsic \" + r + \" does not exist!\");\n      };\n\n      r.exports = function GetIntrinsic(r, e) {\n        if (typeof r !== \"string\" || r.length === 0) {\n          throw new a(\"intrinsic name must be a non-empty string\");\n        }\n\n        if (arguments.length > 1 && typeof e !== \"boolean\") {\n          throw new a('\"allowMissing\" argument must be a boolean');\n        }\n\n        var t = j(r);\n        var i = t.length > 0 ? t[0] : \"\";\n        var u = P(\"%\" + i + \"%\", e);\n        var s = u.name;\n        var c = u.value;\n        var y = false;\n        var p = u.alias;\n\n        if (p) {\n          i = p[0];\n          m(t, A([0, 1], p));\n        }\n\n        for (var g = 1, d = true; g < t.length; g += 1) {\n          var v = t[g];\n          var S = h(v, 0, 1);\n          var O = h(v, -1);\n\n          if ((S === '\"' || S === \"'\" || S === \"`\" || O === '\"' || O === \"'\" || O === \"`\") && S !== O) {\n            throw new o(\"property names with quotes must have matching quotes\");\n          }\n\n          if (v === \"constructor\" || !d) {\n            y = true;\n          }\n\n          i += \".\" + v;\n          s = \"%\" + i + \"%\";\n\n          if (b(l, s)) {\n            c = l[s];\n          } else if (c != null) {\n            if (!(v in c)) {\n              if (!e) {\n                throw new a(\"base intrinsic for \" + r + \" exists, but the property is not available.\");\n              }\n\n              return void n;\n            }\n\n            if (f && g + 1 >= t.length) {\n              var w = f(c, v);\n              d = !!w;\n\n              if (d && \"get\" in w && !(\"originalValue\" in w.get)) {\n                c = w.get;\n              } else {\n                c = c[v];\n              }\n            } else {\n              d = b(c, v);\n              c = c[v];\n            }\n\n            if (d && !y) {\n              l[s] = c;\n            }\n          }\n        }\n\n        return c;\n      };\n    },\n    567: function (r, e, t) {\n      \"use strict\";\n\n      var n = typeof Symbol !== \"undefined\" && Symbol;\n      var o = t(186);\n\n      r.exports = function hasNativeSymbols() {\n        if (typeof n !== \"function\") {\n          return false;\n        }\n\n        if (typeof Symbol !== \"function\") {\n          return false;\n        }\n\n        if (typeof n(\"foo\") !== \"symbol\") {\n          return false;\n        }\n\n        if (typeof Symbol(\"bar\") !== \"symbol\") {\n          return false;\n        }\n\n        return o();\n      };\n    },\n    186: function (r) {\n      \"use strict\";\n\n      r.exports = function hasSymbols() {\n        if (typeof Symbol !== \"function\" || typeof Object.getOwnPropertySymbols !== \"function\") {\n          return false;\n        }\n\n        if (typeof Symbol.iterator === \"symbol\") {\n          return true;\n        }\n\n        var r = {};\n        var e = Symbol(\"test\");\n        var t = Object(e);\n\n        if (typeof e === \"string\") {\n          return false;\n        }\n\n        if (Object.prototype.toString.call(e) !== \"[object Symbol]\") {\n          return false;\n        }\n\n        if (Object.prototype.toString.call(t) !== \"[object Symbol]\") {\n          return false;\n        }\n\n        var n = 42;\n        r[e] = n;\n\n        for (e in r) {\n          return false;\n        }\n\n        if (typeof Object.keys === \"function\" && Object.keys(r).length !== 0) {\n          return false;\n        }\n\n        if (typeof Object.getOwnPropertyNames === \"function\" && Object.getOwnPropertyNames(r).length !== 0) {\n          return false;\n        }\n\n        var o = Object.getOwnPropertySymbols(r);\n\n        if (o.length !== 1 || o[0] !== e) {\n          return false;\n        }\n\n        if (!Object.prototype.propertyIsEnumerable.call(r, e)) {\n          return false;\n        }\n\n        if (typeof Object.getOwnPropertyDescriptor === \"function\") {\n          var i = Object.getOwnPropertyDescriptor(r, e);\n\n          if (i.value !== n || i.enumerable !== true) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n    },\n    646: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(194);\n      r.exports = n.call(Function.call, Object.prototype.hasOwnProperty);\n    },\n    140: function (r) {\n      if (typeof Object.create === \"function\") {\n        r.exports = function inherits(r, e) {\n          if (e) {\n            r.super_ = e;\n            r.prototype = Object.create(e.prototype, {\n              constructor: {\n                value: r,\n                enumerable: false,\n                writable: true,\n                configurable: true\n              }\n            });\n          }\n        };\n      } else {\n        r.exports = function inherits(r, e) {\n          if (e) {\n            r.super_ = e;\n\n            var TempCtor = function () {};\n\n            TempCtor.prototype = e.prototype;\n            r.prototype = new TempCtor();\n            r.prototype.constructor = r;\n          }\n        };\n      }\n    },\n    749: function (r) {\n      \"use strict\";\n\n      var e = typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\";\n      var t = Object.prototype.toString;\n\n      var n = function isArguments(r) {\n        if (e && r && typeof r === \"object\" && Symbol.toStringTag in r) {\n          return false;\n        }\n\n        return t.call(r) === \"[object Arguments]\";\n      };\n\n      var o = function isArguments(r) {\n        if (n(r)) {\n          return true;\n        }\n\n        return r !== null && typeof r === \"object\" && typeof r.length === \"number\" && r.length >= 0 && t.call(r) !== \"[object Array]\" && t.call(r.callee) === \"[object Function]\";\n      };\n\n      var i = function () {\n        return n(arguments);\n      }();\n\n      n.isLegacyArguments = o;\n      r.exports = i ? n : o;\n    },\n    611: function (r) {\n      \"use strict\";\n\n      var e = Object.prototype.toString;\n      var t = Function.prototype.toString;\n      var n = /^\\s*(?:function)?\\*/;\n      var o = typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\";\n      var i = Object.getPrototypeOf;\n\n      var getGeneratorFunc = function () {\n        if (!o) {\n          return false;\n        }\n\n        try {\n          return Function(\"return function*() {}\")();\n        } catch (r) {}\n      };\n\n      var a = getGeneratorFunc();\n      var f = a ? i(a) : {};\n\n      r.exports = function isGeneratorFunction(r) {\n        if (typeof r !== \"function\") {\n          return false;\n        }\n\n        if (n.test(t.call(r))) {\n          return true;\n        }\n\n        if (!o) {\n          var a = e.call(r);\n          return a === \"[object GeneratorFunction]\";\n        }\n\n        return i(r) === f;\n      };\n    },\n    387: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(981);\n      var o = t(382);\n      var i = t(171);\n      var a = i(\"Object.prototype.toString\");\n      var f = t(567)();\n      var u = f && typeof Symbol.toStringTag === \"symbol\";\n      var s = o();\n\n      var c = i(\"Array.prototype.indexOf\", true) || function indexOf(r, e) {\n        for (var t = 0; t < r.length; t += 1) {\n          if (r[t] === e) {\n            return t;\n          }\n        }\n\n        return -1;\n      };\n\n      var y = i(\"String.prototype.slice\");\n      var p = {};\n      var l = t(30);\n      var g = Object.getPrototypeOf;\n\n      if (u && l && g) {\n        n(s, function (r) {\n          var e = new __webpack_require__.g[r]();\n\n          if (!(Symbol.toStringTag in e)) {\n            throw new EvalError(\"this engine has support for Symbol.toStringTag, but \" + r + \" does not have the property! Please report this.\");\n          }\n\n          var t = g(e);\n          var n = l(t, Symbol.toStringTag);\n\n          if (!n) {\n            var o = g(t);\n            n = l(o, Symbol.toStringTag);\n          }\n\n          p[r] = n.get;\n        });\n      }\n\n      var d = function tryAllTypedArrays(r) {\n        var e = false;\n        n(p, function (t, n) {\n          if (!e) {\n            try {\n              e = t.call(r) === n;\n            } catch (r) {}\n          }\n        });\n        return e;\n      };\n\n      r.exports = function isTypedArray(r) {\n        if (!r || typeof r !== \"object\") {\n          return false;\n        }\n\n        if (!u) {\n          var e = y(a(r), 8, -1);\n          return c(s, e) > -1;\n        }\n\n        if (!l) {\n          return false;\n        }\n\n        return d(r);\n      };\n    },\n    913: function (r) {\n      r.exports = function isBuffer(r) {\n        return r instanceof Buffer;\n      };\n    },\n    989: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(749);\n      var o = t(611);\n      var i = t(728);\n      var a = t(387);\n\n      function uncurryThis(r) {\n        return r.call.bind(r);\n      }\n\n      var f = typeof BigInt !== \"undefined\";\n      var u = typeof Symbol !== \"undefined\";\n      var s = uncurryThis(Object.prototype.toString);\n      var c = uncurryThis(Number.prototype.valueOf);\n      var y = uncurryThis(String.prototype.valueOf);\n      var p = uncurryThis(Boolean.prototype.valueOf);\n\n      if (f) {\n        var l = uncurryThis(BigInt.prototype.valueOf);\n      }\n\n      if (u) {\n        var g = uncurryThis(Symbol.prototype.valueOf);\n      }\n\n      function checkBoxedPrimitive(r, e) {\n        if (typeof r !== \"object\") {\n          return false;\n        }\n\n        try {\n          e(r);\n          return true;\n        } catch (r) {\n          return false;\n        }\n      }\n\n      e.isArgumentsObject = n;\n      e.isGeneratorFunction = o;\n      e.isTypedArray = a;\n\n      function isPromise(r) {\n        return typeof Promise !== \"undefined\" && r instanceof Promise || r !== null && typeof r === \"object\" && typeof r.then === \"function\" && typeof r.catch === \"function\";\n      }\n\n      e.isPromise = isPromise;\n\n      function isArrayBufferView(r) {\n        if (typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView) {\n          return ArrayBuffer.isView(r);\n        }\n\n        return a(r) || isDataView(r);\n      }\n\n      e.isArrayBufferView = isArrayBufferView;\n\n      function isUint8Array(r) {\n        return i(r) === \"Uint8Array\";\n      }\n\n      e.isUint8Array = isUint8Array;\n\n      function isUint8ClampedArray(r) {\n        return i(r) === \"Uint8ClampedArray\";\n      }\n\n      e.isUint8ClampedArray = isUint8ClampedArray;\n\n      function isUint16Array(r) {\n        return i(r) === \"Uint16Array\";\n      }\n\n      e.isUint16Array = isUint16Array;\n\n      function isUint32Array(r) {\n        return i(r) === \"Uint32Array\";\n      }\n\n      e.isUint32Array = isUint32Array;\n\n      function isInt8Array(r) {\n        return i(r) === \"Int8Array\";\n      }\n\n      e.isInt8Array = isInt8Array;\n\n      function isInt16Array(r) {\n        return i(r) === \"Int16Array\";\n      }\n\n      e.isInt16Array = isInt16Array;\n\n      function isInt32Array(r) {\n        return i(r) === \"Int32Array\";\n      }\n\n      e.isInt32Array = isInt32Array;\n\n      function isFloat32Array(r) {\n        return i(r) === \"Float32Array\";\n      }\n\n      e.isFloat32Array = isFloat32Array;\n\n      function isFloat64Array(r) {\n        return i(r) === \"Float64Array\";\n      }\n\n      e.isFloat64Array = isFloat64Array;\n\n      function isBigInt64Array(r) {\n        return i(r) === \"BigInt64Array\";\n      }\n\n      e.isBigInt64Array = isBigInt64Array;\n\n      function isBigUint64Array(r) {\n        return i(r) === \"BigUint64Array\";\n      }\n\n      e.isBigUint64Array = isBigUint64Array;\n\n      function isMapToString(r) {\n        return s(r) === \"[object Map]\";\n      }\n\n      isMapToString.working = typeof Map !== \"undefined\" && isMapToString(new Map());\n\n      function isMap(r) {\n        if (typeof Map === \"undefined\") {\n          return false;\n        }\n\n        return isMapToString.working ? isMapToString(r) : r instanceof Map;\n      }\n\n      e.isMap = isMap;\n\n      function isSetToString(r) {\n        return s(r) === \"[object Set]\";\n      }\n\n      isSetToString.working = typeof Set !== \"undefined\" && isSetToString(new Set());\n\n      function isSet(r) {\n        if (typeof Set === \"undefined\") {\n          return false;\n        }\n\n        return isSetToString.working ? isSetToString(r) : r instanceof Set;\n      }\n\n      e.isSet = isSet;\n\n      function isWeakMapToString(r) {\n        return s(r) === \"[object WeakMap]\";\n      }\n\n      isWeakMapToString.working = typeof WeakMap !== \"undefined\" && isWeakMapToString(new WeakMap());\n\n      function isWeakMap(r) {\n        if (typeof WeakMap === \"undefined\") {\n          return false;\n        }\n\n        return isWeakMapToString.working ? isWeakMapToString(r) : r instanceof WeakMap;\n      }\n\n      e.isWeakMap = isWeakMap;\n\n      function isWeakSetToString(r) {\n        return s(r) === \"[object WeakSet]\";\n      }\n\n      isWeakSetToString.working = typeof WeakSet !== \"undefined\" && isWeakSetToString(new WeakSet());\n\n      function isWeakSet(r) {\n        return isWeakSetToString(r);\n      }\n\n      e.isWeakSet = isWeakSet;\n\n      function isArrayBufferToString(r) {\n        return s(r) === \"[object ArrayBuffer]\";\n      }\n\n      isArrayBufferToString.working = typeof ArrayBuffer !== \"undefined\" && isArrayBufferToString(new ArrayBuffer());\n\n      function isArrayBuffer(r) {\n        if (typeof ArrayBuffer === \"undefined\") {\n          return false;\n        }\n\n        return isArrayBufferToString.working ? isArrayBufferToString(r) : r instanceof ArrayBuffer;\n      }\n\n      e.isArrayBuffer = isArrayBuffer;\n\n      function isDataViewToString(r) {\n        return s(r) === \"[object DataView]\";\n      }\n\n      isDataViewToString.working = typeof ArrayBuffer !== \"undefined\" && typeof DataView !== \"undefined\" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));\n\n      function isDataView(r) {\n        if (typeof DataView === \"undefined\") {\n          return false;\n        }\n\n        return isDataViewToString.working ? isDataViewToString(r) : r instanceof DataView;\n      }\n\n      e.isDataView = isDataView;\n      var d = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : undefined;\n\n      function isSharedArrayBufferToString(r) {\n        return s(r) === \"[object SharedArrayBuffer]\";\n      }\n\n      function isSharedArrayBuffer(r) {\n        if (typeof d === \"undefined\") {\n          return false;\n        }\n\n        if (typeof isSharedArrayBufferToString.working === \"undefined\") {\n          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new d());\n        }\n\n        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(r) : r instanceof d;\n      }\n\n      e.isSharedArrayBuffer = isSharedArrayBuffer;\n\n      function isAsyncFunction(r) {\n        return s(r) === \"[object AsyncFunction]\";\n      }\n\n      e.isAsyncFunction = isAsyncFunction;\n\n      function isMapIterator(r) {\n        return s(r) === \"[object Map Iterator]\";\n      }\n\n      e.isMapIterator = isMapIterator;\n\n      function isSetIterator(r) {\n        return s(r) === \"[object Set Iterator]\";\n      }\n\n      e.isSetIterator = isSetIterator;\n\n      function isGeneratorObject(r) {\n        return s(r) === \"[object Generator]\";\n      }\n\n      e.isGeneratorObject = isGeneratorObject;\n\n      function isWebAssemblyCompiledModule(r) {\n        return s(r) === \"[object WebAssembly.Module]\";\n      }\n\n      e.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\n      function isNumberObject(r) {\n        return checkBoxedPrimitive(r, c);\n      }\n\n      e.isNumberObject = isNumberObject;\n\n      function isStringObject(r) {\n        return checkBoxedPrimitive(r, y);\n      }\n\n      e.isStringObject = isStringObject;\n\n      function isBooleanObject(r) {\n        return checkBoxedPrimitive(r, p);\n      }\n\n      e.isBooleanObject = isBooleanObject;\n\n      function isBigIntObject(r) {\n        return f && checkBoxedPrimitive(r, l);\n      }\n\n      e.isBigIntObject = isBigIntObject;\n\n      function isSymbolObject(r) {\n        return u && checkBoxedPrimitive(r, g);\n      }\n\n      e.isSymbolObject = isSymbolObject;\n\n      function isBoxedPrimitive(r) {\n        return isNumberObject(r) || isStringObject(r) || isBooleanObject(r) || isBigIntObject(r) || isSymbolObject(r);\n      }\n\n      e.isBoxedPrimitive = isBoxedPrimitive;\n\n      function isAnyArrayBuffer(r) {\n        return typeof Uint8Array !== \"undefined\" && (isArrayBuffer(r) || isSharedArrayBuffer(r));\n      }\n\n      e.isAnyArrayBuffer = isAnyArrayBuffer;\n      [\"isProxy\", \"isExternal\", \"isModuleNamespaceObject\"].forEach(function (r) {\n        Object.defineProperty(e, r, {\n          enumerable: false,\n          value: function () {\n            throw new Error(r + \" is not supported in userland\");\n          }\n        });\n      });\n    },\n    467: function (r, e, t) {\n      var n = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(r) {\n        var e = Object.keys(r);\n        var t = {};\n\n        for (var n = 0; n < e.length; n++) {\n          t[e[n]] = Object.getOwnPropertyDescriptor(r, e[n]);\n        }\n\n        return t;\n      };\n\n      var o = /%[sdj%]/g;\n\n      e.format = function (r) {\n        if (!isString(r)) {\n          var e = [];\n\n          for (var t = 0; t < arguments.length; t++) {\n            e.push(inspect(arguments[t]));\n          }\n\n          return e.join(\" \");\n        }\n\n        var t = 1;\n        var n = arguments;\n        var i = n.length;\n        var a = String(r).replace(o, function (r) {\n          if (r === \"%%\") return \"%\";\n          if (t >= i) return r;\n\n          switch (r) {\n            case \"%s\":\n              return String(n[t++]);\n\n            case \"%d\":\n              return Number(n[t++]);\n\n            case \"%j\":\n              try {\n                return JSON.stringify(n[t++]);\n              } catch (r) {\n                return \"[Circular]\";\n              }\n\n            default:\n              return r;\n          }\n        });\n\n        for (var f = n[t]; t < i; f = n[++t]) {\n          if (isNull(f) || !isObject(f)) {\n            a += \" \" + f;\n          } else {\n            a += \" \" + inspect(f);\n          }\n        }\n\n        return a;\n      };\n\n      e.deprecate = function (r, t) {\n        if (typeof process !== \"undefined\" && process.noDeprecation === true) {\n          return r;\n        }\n\n        if (typeof process === \"undefined\") {\n          return function () {\n            return e.deprecate(r, t).apply(this, arguments);\n          };\n        }\n\n        var n = false;\n\n        function deprecated() {\n          if (!n) {\n            if (process.throwDeprecation) {\n              throw new Error(t);\n            } else if (process.traceDeprecation) {\n              console.trace(t);\n            } else {\n              console.error(t);\n            }\n\n            n = true;\n          }\n\n          return r.apply(this, arguments);\n        }\n\n        return deprecated;\n      };\n\n      var i = {};\n      var a = /^$/;\n\n      if (process.env.NODE_DEBUG) {\n        var f = process.env.NODE_DEBUG;\n        f = f.replace(/[|\\\\{}()[\\]^$+?.]/g, \"\\\\$&\").replace(/\\*/g, \".*\").replace(/,/g, \"$|^\").toUpperCase();\n        a = new RegExp(\"^\" + f + \"$\", \"i\");\n      }\n\n      e.debuglog = function (r) {\n        r = r.toUpperCase();\n\n        if (!i[r]) {\n          if (a.test(r)) {\n            var t = process.pid;\n\n            i[r] = function () {\n              var n = e.format.apply(e, arguments);\n              console.error(\"%s %d: %s\", r, t, n);\n            };\n          } else {\n            i[r] = function () {};\n          }\n        }\n\n        return i[r];\n      };\n\n      function inspect(r, t) {\n        var n = {\n          seen: [],\n          stylize: stylizeNoColor\n        };\n        if (arguments.length >= 3) n.depth = arguments[2];\n        if (arguments.length >= 4) n.colors = arguments[3];\n\n        if (isBoolean(t)) {\n          n.showHidden = t;\n        } else if (t) {\n          e._extend(n, t);\n        }\n\n        if (isUndefined(n.showHidden)) n.showHidden = false;\n        if (isUndefined(n.depth)) n.depth = 2;\n        if (isUndefined(n.colors)) n.colors = false;\n        if (isUndefined(n.customInspect)) n.customInspect = true;\n        if (n.colors) n.stylize = stylizeWithColor;\n        return formatValue(n, r, n.depth);\n      }\n\n      e.inspect = inspect;\n      inspect.colors = {\n        bold: [1, 22],\n        italic: [3, 23],\n        underline: [4, 24],\n        inverse: [7, 27],\n        white: [37, 39],\n        grey: [90, 39],\n        black: [30, 39],\n        blue: [34, 39],\n        cyan: [36, 39],\n        green: [32, 39],\n        magenta: [35, 39],\n        red: [31, 39],\n        yellow: [33, 39]\n      };\n      inspect.styles = {\n        special: \"cyan\",\n        number: \"yellow\",\n        boolean: \"yellow\",\n        undefined: \"grey\",\n        null: \"bold\",\n        string: \"green\",\n        date: \"magenta\",\n        regexp: \"red\"\n      };\n\n      function stylizeWithColor(r, e) {\n        var t = inspect.styles[e];\n\n        if (t) {\n          return \"\u001b[\" + inspect.colors[t][0] + \"m\" + r + \"\u001b[\" + inspect.colors[t][1] + \"m\";\n        } else {\n          return r;\n        }\n      }\n\n      function stylizeNoColor(r, e) {\n        return r;\n      }\n\n      function arrayToHash(r) {\n        var e = {};\n        r.forEach(function (r, t) {\n          e[r] = true;\n        });\n        return e;\n      }\n\n      function formatValue(r, t, n) {\n        if (r.customInspect && t && isFunction(t.inspect) && t.inspect !== e.inspect && !(t.constructor && t.constructor.prototype === t)) {\n          var o = t.inspect(n, r);\n\n          if (!isString(o)) {\n            o = formatValue(r, o, n);\n          }\n\n          return o;\n        }\n\n        var i = formatPrimitive(r, t);\n\n        if (i) {\n          return i;\n        }\n\n        var a = Object.keys(t);\n        var f = arrayToHash(a);\n\n        if (r.showHidden) {\n          a = Object.getOwnPropertyNames(t);\n        }\n\n        if (isError(t) && (a.indexOf(\"message\") >= 0 || a.indexOf(\"description\") >= 0)) {\n          return formatError(t);\n        }\n\n        if (a.length === 0) {\n          if (isFunction(t)) {\n            var u = t.name ? \": \" + t.name : \"\";\n            return r.stylize(\"[Function\" + u + \"]\", \"special\");\n          }\n\n          if (isRegExp(t)) {\n            return r.stylize(RegExp.prototype.toString.call(t), \"regexp\");\n          }\n\n          if (isDate(t)) {\n            return r.stylize(Date.prototype.toString.call(t), \"date\");\n          }\n\n          if (isError(t)) {\n            return formatError(t);\n          }\n        }\n\n        var s = \"\",\n            c = false,\n            y = [\"{\", \"}\"];\n\n        if (isArray(t)) {\n          c = true;\n          y = [\"[\", \"]\"];\n        }\n\n        if (isFunction(t)) {\n          var p = t.name ? \": \" + t.name : \"\";\n          s = \" [Function\" + p + \"]\";\n        }\n\n        if (isRegExp(t)) {\n          s = \" \" + RegExp.prototype.toString.call(t);\n        }\n\n        if (isDate(t)) {\n          s = \" \" + Date.prototype.toUTCString.call(t);\n        }\n\n        if (isError(t)) {\n          s = \" \" + formatError(t);\n        }\n\n        if (a.length === 0 && (!c || t.length == 0)) {\n          return y[0] + s + y[1];\n        }\n\n        if (n < 0) {\n          if (isRegExp(t)) {\n            return r.stylize(RegExp.prototype.toString.call(t), \"regexp\");\n          } else {\n            return r.stylize(\"[Object]\", \"special\");\n          }\n        }\n\n        r.seen.push(t);\n        var l;\n\n        if (c) {\n          l = formatArray(r, t, n, f, a);\n        } else {\n          l = a.map(function (e) {\n            return formatProperty(r, t, n, f, e, c);\n          });\n        }\n\n        r.seen.pop();\n        return reduceToSingleString(l, s, y);\n      }\n\n      function formatPrimitive(r, e) {\n        if (isUndefined(e)) return r.stylize(\"undefined\", \"undefined\");\n\n        if (isString(e)) {\n          var t = \"'\" + JSON.stringify(e).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n          return r.stylize(t, \"string\");\n        }\n\n        if (isNumber(e)) return r.stylize(\"\" + e, \"number\");\n        if (isBoolean(e)) return r.stylize(\"\" + e, \"boolean\");\n        if (isNull(e)) return r.stylize(\"null\", \"null\");\n      }\n\n      function formatError(r) {\n        return \"[\" + Error.prototype.toString.call(r) + \"]\";\n      }\n\n      function formatArray(r, e, t, n, o) {\n        var i = [];\n\n        for (var a = 0, f = e.length; a < f; ++a) {\n          if (hasOwnProperty(e, String(a))) {\n            i.push(formatProperty(r, e, t, n, String(a), true));\n          } else {\n            i.push(\"\");\n          }\n        }\n\n        o.forEach(function (o) {\n          if (!o.match(/^\\d+$/)) {\n            i.push(formatProperty(r, e, t, n, o, true));\n          }\n        });\n        return i;\n      }\n\n      function formatProperty(r, e, t, n, o, i) {\n        var a, f, u;\n        u = Object.getOwnPropertyDescriptor(e, o) || {\n          value: e[o]\n        };\n\n        if (u.get) {\n          if (u.set) {\n            f = r.stylize(\"[Getter/Setter]\", \"special\");\n          } else {\n            f = r.stylize(\"[Getter]\", \"special\");\n          }\n        } else {\n          if (u.set) {\n            f = r.stylize(\"[Setter]\", \"special\");\n          }\n        }\n\n        if (!hasOwnProperty(n, o)) {\n          a = \"[\" + o + \"]\";\n        }\n\n        if (!f) {\n          if (r.seen.indexOf(u.value) < 0) {\n            if (isNull(t)) {\n              f = formatValue(r, u.value, null);\n            } else {\n              f = formatValue(r, u.value, t - 1);\n            }\n\n            if (f.indexOf(\"\\n\") > -1) {\n              if (i) {\n                f = f.split(\"\\n\").map(function (r) {\n                  return \"  \" + r;\n                }).join(\"\\n\").substr(2);\n              } else {\n                f = \"\\n\" + f.split(\"\\n\").map(function (r) {\n                  return \"   \" + r;\n                }).join(\"\\n\");\n              }\n            }\n          } else {\n            f = r.stylize(\"[Circular]\", \"special\");\n          }\n        }\n\n        if (isUndefined(a)) {\n          if (i && o.match(/^\\d+$/)) {\n            return f;\n          }\n\n          a = JSON.stringify(\"\" + o);\n\n          if (a.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n            a = a.substr(1, a.length - 2);\n            a = r.stylize(a, \"name\");\n          } else {\n            a = a.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n            a = r.stylize(a, \"string\");\n          }\n        }\n\n        return a + \": \" + f;\n      }\n\n      function reduceToSingleString(r, e, t) {\n        var n = 0;\n        var o = r.reduce(function (r, e) {\n          n++;\n          if (e.indexOf(\"\\n\") >= 0) n++;\n          return r + e.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n        }, 0);\n\n        if (o > 60) {\n          return t[0] + (e === \"\" ? \"\" : e + \"\\n \") + \" \" + r.join(\",\\n  \") + \" \" + t[1];\n        }\n\n        return t[0] + e + \" \" + r.join(\", \") + \" \" + t[1];\n      }\n\n      e.types = t(989);\n\n      function isArray(r) {\n        return Array.isArray(r);\n      }\n\n      e.isArray = isArray;\n\n      function isBoolean(r) {\n        return typeof r === \"boolean\";\n      }\n\n      e.isBoolean = isBoolean;\n\n      function isNull(r) {\n        return r === null;\n      }\n\n      e.isNull = isNull;\n\n      function isNullOrUndefined(r) {\n        return r == null;\n      }\n\n      e.isNullOrUndefined = isNullOrUndefined;\n\n      function isNumber(r) {\n        return typeof r === \"number\";\n      }\n\n      e.isNumber = isNumber;\n\n      function isString(r) {\n        return typeof r === \"string\";\n      }\n\n      e.isString = isString;\n\n      function isSymbol(r) {\n        return typeof r === \"symbol\";\n      }\n\n      e.isSymbol = isSymbol;\n\n      function isUndefined(r) {\n        return r === void 0;\n      }\n\n      e.isUndefined = isUndefined;\n\n      function isRegExp(r) {\n        return isObject(r) && objectToString(r) === \"[object RegExp]\";\n      }\n\n      e.isRegExp = isRegExp;\n      e.types.isRegExp = isRegExp;\n\n      function isObject(r) {\n        return typeof r === \"object\" && r !== null;\n      }\n\n      e.isObject = isObject;\n\n      function isDate(r) {\n        return isObject(r) && objectToString(r) === \"[object Date]\";\n      }\n\n      e.isDate = isDate;\n      e.types.isDate = isDate;\n\n      function isError(r) {\n        return isObject(r) && (objectToString(r) === \"[object Error]\" || r instanceof Error);\n      }\n\n      e.isError = isError;\n      e.types.isNativeError = isError;\n\n      function isFunction(r) {\n        return typeof r === \"function\";\n      }\n\n      e.isFunction = isFunction;\n\n      function isPrimitive(r) {\n        return r === null || typeof r === \"boolean\" || typeof r === \"number\" || typeof r === \"string\" || typeof r === \"symbol\" || typeof r === \"undefined\";\n      }\n\n      e.isPrimitive = isPrimitive;\n      e.isBuffer = t(913);\n\n      function objectToString(r) {\n        return Object.prototype.toString.call(r);\n      }\n\n      function pad(r) {\n        return r < 10 ? \"0\" + r.toString(10) : r.toString(10);\n      }\n\n      var u = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n      function timestamp() {\n        var r = new Date();\n        var e = [pad(r.getHours()), pad(r.getMinutes()), pad(r.getSeconds())].join(\":\");\n        return [r.getDate(), u[r.getMonth()], e].join(\" \");\n      }\n\n      e.log = function () {\n        console.log(\"%s - %s\", timestamp(), e.format.apply(e, arguments));\n      };\n\n      e.inherits = t(140);\n\n      e._extend = function (r, e) {\n        if (!e || !isObject(e)) return r;\n        var t = Object.keys(e);\n        var n = t.length;\n\n        while (n--) {\n          r[t[n]] = e[t[n]];\n        }\n\n        return r;\n      };\n\n      function hasOwnProperty(r, e) {\n        return Object.prototype.hasOwnProperty.call(r, e);\n      }\n\n      var s = typeof Symbol !== \"undefined\" ? Symbol(\"util.promisify.custom\") : undefined;\n\n      e.promisify = function promisify(r) {\n        if (typeof r !== \"function\") throw new TypeError('The \"original\" argument must be of type Function');\n\n        if (s && r[s]) {\n          var e = r[s];\n\n          if (typeof e !== \"function\") {\n            throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n          }\n\n          Object.defineProperty(e, s, {\n            value: e,\n            enumerable: false,\n            writable: false,\n            configurable: true\n          });\n          return e;\n        }\n\n        function e() {\n          var e, t;\n          var n = new Promise(function (r, n) {\n            e = r;\n            t = n;\n          });\n          var o = [];\n\n          for (var i = 0; i < arguments.length; i++) {\n            o.push(arguments[i]);\n          }\n\n          o.push(function (r, n) {\n            if (r) {\n              t(r);\n            } else {\n              e(n);\n            }\n          });\n\n          try {\n            r.apply(this, o);\n          } catch (r) {\n            t(r);\n          }\n\n          return n;\n        }\n\n        Object.setPrototypeOf(e, Object.getPrototypeOf(r));\n        if (s) Object.defineProperty(e, s, {\n          value: e,\n          enumerable: false,\n          writable: false,\n          configurable: true\n        });\n        return Object.defineProperties(e, n(r));\n      };\n\n      e.promisify.custom = s;\n\n      function callbackifyOnRejected(r, e) {\n        if (!r) {\n          var t = new Error(\"Promise was rejected with a falsy value\");\n          t.reason = r;\n          r = t;\n        }\n\n        return e(r);\n      }\n\n      function callbackify(r) {\n        if (typeof r !== \"function\") {\n          throw new TypeError('The \"original\" argument must be of type Function');\n        }\n\n        function callbackified() {\n          var e = [];\n\n          for (var t = 0; t < arguments.length; t++) {\n            e.push(arguments[t]);\n          }\n\n          var n = e.pop();\n\n          if (typeof n !== \"function\") {\n            throw new TypeError(\"The last argument must be of type Function\");\n          }\n\n          var o = this;\n\n          var cb = function () {\n            return n.apply(o, arguments);\n          };\n\n          r.apply(this, e).then(function (r) {\n            process.nextTick(cb.bind(null, null, r));\n          }, function (r) {\n            process.nextTick(callbackifyOnRejected.bind(null, r, cb));\n          });\n        }\n\n        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(r));\n        Object.defineProperties(callbackified, n(r));\n        return callbackified;\n      }\n\n      e.callbackify = callbackify;\n    },\n    728: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(981);\n      var o = t(382);\n      var i = t(171);\n      var a = i(\"Object.prototype.toString\");\n      var f = t(567)();\n      var u = f && typeof Symbol.toStringTag === \"symbol\";\n      var s = o();\n      var c = i(\"String.prototype.slice\");\n      var y = {};\n      var p = t(30);\n      var l = Object.getPrototypeOf;\n\n      if (u && p && l) {\n        n(s, function (r) {\n          if (typeof __webpack_require__.g[r] === \"function\") {\n            var e = new __webpack_require__.g[r]();\n\n            if (!(Symbol.toStringTag in e)) {\n              throw new EvalError(\"this engine has support for Symbol.toStringTag, but \" + r + \" does not have the property! Please report this.\");\n            }\n\n            var t = l(e);\n            var n = p(t, Symbol.toStringTag);\n\n            if (!n) {\n              var o = l(t);\n              n = p(o, Symbol.toStringTag);\n            }\n\n            y[r] = n.get;\n          }\n        });\n      }\n\n      var g = function tryAllTypedArrays(r) {\n        var e = false;\n        n(y, function (t, n) {\n          if (!e) {\n            try {\n              var o = t.call(r);\n\n              if (o === n) {\n                e = o;\n              }\n            } catch (r) {}\n          }\n        });\n        return e;\n      };\n\n      var d = t(387);\n\n      r.exports = function whichTypedArray(r) {\n        if (!d(r)) {\n          return false;\n        }\n\n        if (!u) {\n          return c(a(r), 8, -1);\n        }\n\n        return g(r);\n      };\n    },\n    382: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(997);\n\n      r.exports = function availableTypedArrays() {\n        return n([\"BigInt64Array\", \"BigUint64Array\", \"Float32Array\", \"Float64Array\", \"Int16Array\", \"Int32Array\", \"Int8Array\", \"Uint16Array\", \"Uint32Array\", \"Uint8Array\", \"Uint8ClampedArray\"], function (r) {\n          return typeof __webpack_require__.g[r] === \"function\";\n        });\n      };\n    },\n    30: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(627);\n      var o = n(\"%Object.getOwnPropertyDescriptor%\", true);\n\n      if (o) {\n        try {\n          o([], \"length\");\n        } catch (r) {\n          o = null;\n        }\n      }\n\n      r.exports = o;\n    }\n  };\n  var e = {};\n\n  function __nccwpck_require__(t) {\n    var n = e[t];\n\n    if (n !== undefined) {\n      return n.exports;\n    }\n\n    var o = e[t] = {\n      exports: {}\n    };\n    var i = true;\n\n    try {\n      r[t](o, o.exports, __nccwpck_require__);\n      i = false;\n    } finally {\n      if (i) delete e[t];\n    }\n\n    return o.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var t = __nccwpck_require__(467);\n\n  module.exports = t;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3V0aWwvdXRpbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxDQUFDLFlBQVU7RUFBQyxJQUFJQSxDQUFDLEdBQUM7SUFBQyxLQUFJLFVBQVNBLENBQVQsRUFBVztNQUFDQSxDQUFDLENBQUNDLE9BQUYsR0FBVSxVQUFTRCxDQUFULEVBQVdFLENBQVgsRUFBYUMsQ0FBYixFQUFlO1FBQUMsSUFBR0gsQ0FBQyxDQUFDSSxNQUFMLEVBQVksT0FBT0osQ0FBQyxDQUFDSSxNQUFGLENBQVNGLENBQVQsRUFBV0MsQ0FBWCxDQUFQO1FBQXFCLElBQUcsS0FBSyxDQUFMLEtBQVNILENBQVQsSUFBWSxTQUFPQSxDQUF0QixFQUF3QixNQUFNLElBQUlLLFNBQUosRUFBTjtRQUFvQixJQUFHLGNBQVksT0FBT0gsQ0FBdEIsRUFBd0IsTUFBTSxJQUFJRyxTQUFKLEVBQU47UUFBb0IsSUFBSUMsQ0FBQyxHQUFDLEVBQU47O1FBQVMsS0FBSSxJQUFJQyxDQUFDLEdBQUMsQ0FBVixFQUFZQSxDQUFDLEdBQUNQLENBQUMsQ0FBQ1EsTUFBaEIsRUFBdUJELENBQUMsRUFBeEIsRUFBMkI7VUFBQyxJQUFHLENBQUNFLENBQUMsQ0FBQ0MsSUFBRixDQUFPVixDQUFQLEVBQVNPLENBQVQsQ0FBSixFQUFnQjtVQUFTLElBQUlJLENBQUMsR0FBQ1gsQ0FBQyxDQUFDTyxDQUFELENBQVA7VUFBVyxJQUFHTCxDQUFDLENBQUNRLElBQUYsQ0FBT1AsQ0FBUCxFQUFTUSxDQUFULEVBQVdKLENBQVgsRUFBYVAsQ0FBYixDQUFILEVBQW1CTSxDQUFDLENBQUNNLElBQUYsQ0FBT0QsQ0FBUDtRQUFVOztRQUFBLE9BQU9MLENBQVA7TUFBUyxDQUFsUTs7TUFBbVEsSUFBSUcsQ0FBQyxHQUFDSSxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLGNBQXZCO0lBQXNDLENBQTFUO0lBQTJULEtBQUksVUFBU2YsQ0FBVCxFQUFXUyxDQUFYLEVBQWFQLENB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aXN0L2NvbXBpbGVkL3V0aWwvdXRpbC5qcz9hYzE0Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciByPXs5OTc6ZnVuY3Rpb24ocil7ci5leHBvcnRzPWZ1bmN0aW9uKHIsdCxuKXtpZihyLmZpbHRlcilyZXR1cm4gci5maWx0ZXIodCxuKTtpZih2b2lkIDA9PT1yfHxudWxsPT09cil0aHJvdyBuZXcgVHlwZUVycm9yO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgbz1bXTtmb3IodmFyIGk9MDtpPHIubGVuZ3RoO2krKyl7aWYoIWUuY2FsbChyLGkpKWNvbnRpbnVlO3ZhciBhPXJbaV07aWYodC5jYWxsKG4sYSxpLHIpKW8ucHVzaChhKX1yZXR1cm4gb307dmFyIGU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eX0sMTcxOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KDYyNyk7dmFyIG89dCgzMDIpO3ZhciBpPW8obihcIlN0cmluZy5wcm90b3R5cGUuaW5kZXhPZlwiKSk7ci5leHBvcnRzPWZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhyLGUpe3ZhciB0PW4ociwhIWUpO2lmKHR5cGVvZiB0PT09XCJmdW5jdGlvblwiJiZpKHIsXCIucHJvdG90eXBlLlwiKT4tMSl7cmV0dXJuIG8odCl9cmV0dXJuIHR9fSwzMDI6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoMTk0KTt2YXIgbz10KDYyNyk7dmFyIGk9byhcIiVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklXCIpO3ZhciBhPW8oXCIlRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlXCIpO3ZhciBmPW8oXCIlUmVmbGVjdC5hcHBseSVcIix0cnVlKXx8bi5jYWxsKGEsaSk7dmFyIHU9byhcIiVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJVwiLHRydWUpO3ZhciBzPW8oXCIlT2JqZWN0LmRlZmluZVByb3BlcnR5JVwiLHRydWUpO3ZhciBjPW8oXCIlTWF0aC5tYXglXCIpO2lmKHMpe3RyeXtzKHt9LFwiYVwiLHt2YWx1ZToxfSl9Y2F0Y2gocil7cz1udWxsfX1yLmV4cG9ydHM9ZnVuY3Rpb24gY2FsbEJpbmQocil7dmFyIGU9ZihuLGEsYXJndW1lbnRzKTtpZih1JiZzKXt2YXIgdD11KGUsXCJsZW5ndGhcIik7aWYodC5jb25maWd1cmFibGUpe3MoZSxcImxlbmd0aFwiLHt2YWx1ZToxK2MoMCxyLmxlbmd0aC0oYXJndW1lbnRzLmxlbmd0aC0xKSl9KX19cmV0dXJuIGV9O3ZhciB5PWZ1bmN0aW9uIGFwcGx5QmluZCgpe3JldHVybiBmKG4saSxhcmd1bWVudHMpfTtpZihzKXtzKHIuZXhwb3J0cyxcImFwcGx5XCIse3ZhbHVlOnl9KX1lbHNle3IuZXhwb3J0cy5hcHBseT15fX0sOTgxOmZ1bmN0aW9uKHIpe3ZhciBlPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztyLmV4cG9ydHM9ZnVuY3Rpb24gZm9yRWFjaChyLG4sbyl7aWYodC5jYWxsKG4pIT09XCJbb2JqZWN0IEZ1bmN0aW9uXVwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpfXZhciBpPXIubGVuZ3RoO2lmKGk9PT0raSl7Zm9yKHZhciBhPTA7YTxpO2ErKyl7bi5jYWxsKG8sclthXSxhLHIpfX1lbHNle2Zvcih2YXIgZiBpbiByKXtpZihlLmNhbGwocixmKSl7bi5jYWxsKG8scltmXSxmLHIpfX19fX0sODYxOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3ZhciBlPVwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSBcIjt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2U7dmFyIG49T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgbz1cIltvYmplY3QgRnVuY3Rpb25dXCI7ci5leHBvcnRzPWZ1bmN0aW9uIGJpbmQocil7dmFyIGk9dGhpcztpZih0eXBlb2YgaSE9PVwiZnVuY3Rpb25cInx8bi5jYWxsKGkpIT09byl7dGhyb3cgbmV3IFR5cGVFcnJvcihlK2kpfXZhciBhPXQuY2FsbChhcmd1bWVudHMsMSk7dmFyIGY7dmFyIGJpbmRlcj1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiBmKXt2YXIgZT1pLmFwcGx5KHRoaXMsYS5jb25jYXQodC5jYWxsKGFyZ3VtZW50cykpKTtpZihPYmplY3QoZSk9PT1lKXtyZXR1cm4gZX1yZXR1cm4gdGhpc31lbHNle3JldHVybiBpLmFwcGx5KHIsYS5jb25jYXQodC5jYWxsKGFyZ3VtZW50cykpKX19O3ZhciB1PU1hdGgubWF4KDAsaS5sZW5ndGgtYS5sZW5ndGgpO3ZhciBzPVtdO2Zvcih2YXIgYz0wO2M8dTtjKyspe3MucHVzaChcIiRcIitjKX1mPUZ1bmN0aW9uKFwiYmluZGVyXCIsXCJyZXR1cm4gZnVuY3Rpb24gKFwiK3Muam9pbihcIixcIikrXCIpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfVwiKShiaW5kZXIpO2lmKGkucHJvdG90eXBlKXt2YXIgeT1mdW5jdGlvbiBFbXB0eSgpe307eS5wcm90b3R5cGU9aS5wcm90b3R5cGU7Zi5wcm90b3R5cGU9bmV3IHk7eS5wcm90b3R5cGU9bnVsbH1yZXR1cm4gZn19LDE5NDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCg4NjEpO3IuZXhwb3J0cz1GdW5jdGlvbi5wcm90b3R5cGUuYmluZHx8bn0sNjI3OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbjt2YXIgbz1TeW50YXhFcnJvcjt2YXIgaT1GdW5jdGlvbjt2YXIgYT1UeXBlRXJyb3I7dmFyIGdldEV2YWxsZWRDb25zdHJ1Y3Rvcj1mdW5jdGlvbihyKXt0cnl7cmV0dXJuIGkoJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcrcitcIikuY29uc3RydWN0b3I7XCIpKCl9Y2F0Y2gocil7fX07dmFyIGY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtpZihmKXt0cnl7Zih7fSxcIlwiKX1jYXRjaChyKXtmPW51bGx9fXZhciB0aHJvd1R5cGVFcnJvcj1mdW5jdGlvbigpe3Rocm93IG5ldyBhfTt2YXIgdT1mP2Z1bmN0aW9uKCl7dHJ5e2FyZ3VtZW50cy5jYWxsZWU7cmV0dXJuIHRocm93VHlwZUVycm9yfWNhdGNoKHIpe3RyeXtyZXR1cm4gZihhcmd1bWVudHMsXCJjYWxsZWVcIikuZ2V0fWNhdGNoKHIpe3JldHVybiB0aHJvd1R5cGVFcnJvcn19fSgpOnRocm93VHlwZUVycm9yO3ZhciBzPXQoNTY3KSgpO3ZhciBjPU9iamVjdC5nZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24ocil7cmV0dXJuIHIuX19wcm90b19ffTt2YXIgeT17fTt2YXIgcD10eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bjpjKFVpbnQ4QXJyYXkpO3ZhciBsPXtcIiVBZ2dyZWdhdGVFcnJvciVcIjp0eXBlb2YgQWdncmVnYXRlRXJyb3I9PT1cInVuZGVmaW5lZFwiP246QWdncmVnYXRlRXJyb3IsXCIlQXJyYXklXCI6QXJyYXksXCIlQXJyYXlCdWZmZXIlXCI6dHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9uOkFycmF5QnVmZmVyLFwiJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlXCI6cz9jKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk6bixcIiVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlXCI6bixcIiVBc3luY0Z1bmN0aW9uJVwiOnksXCIlQXN5bmNHZW5lcmF0b3IlXCI6eSxcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiOnksXCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIjp5LFwiJUF0b21pY3MlXCI6dHlwZW9mIEF0b21pY3M9PT1cInVuZGVmaW5lZFwiP246QXRvbWljcyxcIiVCaWdJbnQlXCI6dHlwZW9mIEJpZ0ludD09PVwidW5kZWZpbmVkXCI/bjpCaWdJbnQsXCIlQm9vbGVhbiVcIjpCb29sZWFuLFwiJURhdGFWaWV3JVwiOnR5cGVvZiBEYXRhVmlldz09PVwidW5kZWZpbmVkXCI/bjpEYXRhVmlldyxcIiVEYXRlJVwiOkRhdGUsXCIlZGVjb2RlVVJJJVwiOmRlY29kZVVSSSxcIiVkZWNvZGVVUklDb21wb25lbnQlXCI6ZGVjb2RlVVJJQ29tcG9uZW50LFwiJWVuY29kZVVSSSVcIjplbmNvZGVVUkksXCIlZW5jb2RlVVJJQ29tcG9uZW50JVwiOmVuY29kZVVSSUNvbXBvbmVudCxcIiVFcnJvciVcIjpFcnJvcixcIiVldmFsJVwiOmV2YWwsXCIlRXZhbEVycm9yJVwiOkV2YWxFcnJvcixcIiVGbG9hdDMyQXJyYXklXCI6dHlwZW9mIEZsb2F0MzJBcnJheT09PVwidW5kZWZpbmVkXCI/bjpGbG9hdDMyQXJyYXksXCIlRmxvYXQ2NEFycmF5JVwiOnR5cGVvZiBGbG9hdDY0QXJyYXk9PT1cInVuZGVmaW5lZFwiP246RmxvYXQ2NEFycmF5LFwiJUZpbmFsaXphdGlvblJlZ2lzdHJ5JVwiOnR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeT09PVwidW5kZWZpbmVkXCI/bjpGaW5hbGl6YXRpb25SZWdpc3RyeSxcIiVGdW5jdGlvbiVcIjppLFwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiOnksXCIlSW50OEFycmF5JVwiOnR5cGVvZiBJbnQ4QXJyYXk9PT1cInVuZGVmaW5lZFwiP246SW50OEFycmF5LFwiJUludDE2QXJyYXklXCI6dHlwZW9mIEludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP246SW50MTZBcnJheSxcIiVJbnQzMkFycmF5JVwiOnR5cGVvZiBJbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9uOkludDMyQXJyYXksXCIlaXNGaW5pdGUlXCI6aXNGaW5pdGUsXCIlaXNOYU4lXCI6aXNOYU4sXCIlSXRlcmF0b3JQcm90b3R5cGUlXCI6cz9jKGMoW11bU3ltYm9sLml0ZXJhdG9yXSgpKSk6bixcIiVKU09OJVwiOnR5cGVvZiBKU09OPT09XCJvYmplY3RcIj9KU09OOm4sXCIlTWFwJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwiP246TWFwLFwiJU1hcEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwifHwhcz9uOmMoKG5ldyBNYXApW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlTWF0aCVcIjpNYXRoLFwiJU51bWJlciVcIjpOdW1iZXIsXCIlT2JqZWN0JVwiOk9iamVjdCxcIiVwYXJzZUZsb2F0JVwiOnBhcnNlRmxvYXQsXCIlcGFyc2VJbnQlXCI6cGFyc2VJbnQsXCIlUHJvbWlzZSVcIjp0eXBlb2YgUHJvbWlzZT09PVwidW5kZWZpbmVkXCI/bjpQcm9taXNlLFwiJVByb3h5JVwiOnR5cGVvZiBQcm94eT09PVwidW5kZWZpbmVkXCI/bjpQcm94eSxcIiVSYW5nZUVycm9yJVwiOlJhbmdlRXJyb3IsXCIlUmVmZXJlbmNlRXJyb3IlXCI6UmVmZXJlbmNlRXJyb3IsXCIlUmVmbGVjdCVcIjp0eXBlb2YgUmVmbGVjdD09PVwidW5kZWZpbmVkXCI/bjpSZWZsZWN0LFwiJVJlZ0V4cCVcIjpSZWdFeHAsXCIlU2V0JVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiP246U2V0LFwiJVNldEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwifHwhcz9uOmMoKG5ldyBTZXQpW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlU2hhcmVkQXJyYXlCdWZmZXIlXCI6dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9uOlNoYXJlZEFycmF5QnVmZmVyLFwiJVN0cmluZyVcIjpTdHJpbmcsXCIlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlXCI6cz9jKFwiXCJbU3ltYm9sLml0ZXJhdG9yXSgpKTpuLFwiJVN5bWJvbCVcIjpzP1N5bWJvbDpuLFwiJVN5bnRheEVycm9yJVwiOm8sXCIlVGhyb3dUeXBlRXJyb3IlXCI6dSxcIiVUeXBlZEFycmF5JVwiOnAsXCIlVHlwZUVycm9yJVwiOmEsXCIlVWludDhBcnJheSVcIjp0eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bjpVaW50OEFycmF5LFwiJVVpbnQ4Q2xhbXBlZEFycmF5JVwiOnR5cGVvZiBVaW50OENsYW1wZWRBcnJheT09PVwidW5kZWZpbmVkXCI/bjpVaW50OENsYW1wZWRBcnJheSxcIiVVaW50MTZBcnJheSVcIjp0eXBlb2YgVWludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP246VWludDE2QXJyYXksXCIlVWludDMyQXJyYXklXCI6dHlwZW9mIFVpbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9uOlVpbnQzMkFycmF5LFwiJVVSSUVycm9yJVwiOlVSSUVycm9yLFwiJVdlYWtNYXAlXCI6dHlwZW9mIFdlYWtNYXA9PT1cInVuZGVmaW5lZFwiP246V2Vha01hcCxcIiVXZWFrUmVmJVwiOnR5cGVvZiBXZWFrUmVmPT09XCJ1bmRlZmluZWRcIj9uOldlYWtSZWYsXCIlV2Vha1NldCVcIjp0eXBlb2YgV2Vha1NldD09PVwidW5kZWZpbmVkXCI/bjpXZWFrU2V0fTt2YXIgZz1mdW5jdGlvbiBkb0V2YWwocil7dmFyIGU7aWYocj09PVwiJUFzeW5jRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24gKCkge31cIil9ZWxzZSBpZihyPT09XCIlR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yJVwiKXt2YXIgdD1kb0V2YWwoXCIlQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiVcIik7aWYodCl7ZT10LnByb3RvdHlwZX19ZWxzZSBpZihyPT09XCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIil7dmFyIG49ZG9FdmFsKFwiJUFzeW5jR2VuZXJhdG9yJVwiKTtpZihuKXtlPWMobi5wcm90b3R5cGUpfX1sW3JdPWU7cmV0dXJuIGV9O3ZhciBkPXtcIiVBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjpbXCJBcnJheUJ1ZmZlclwiLFwicHJvdG90eXBlXCJdLFwiJUFycmF5UHJvdG90eXBlJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlQXJyYXlQcm90b19lbnRyaWVzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImVudHJpZXNcIl0sXCIlQXJyYXlQcm90b19mb3JFYWNoJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImZvckVhY2hcIl0sXCIlQXJyYXlQcm90b19rZXlzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImtleXNcIl0sXCIlQXJyYXlQcm90b192YWx1ZXMlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwidmFsdWVzXCJdLFwiJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiQXN5bmNGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUFzeW5jR2VuZXJhdG9yJVwiOltcIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVBc3luY0dlbmVyYXRvclByb3RvdHlwZSVcIjpbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIixcInByb3RvdHlwZVwiXSxcIiVCb29sZWFuUHJvdG90eXBlJVwiOltcIkJvb2xlYW5cIixcInByb3RvdHlwZVwiXSxcIiVEYXRhVmlld1Byb3RvdHlwZSVcIjpbXCJEYXRhVmlld1wiLFwicHJvdG90eXBlXCJdLFwiJURhdGVQcm90b3R5cGUlXCI6W1wiRGF0ZVwiLFwicHJvdG90eXBlXCJdLFwiJUVycm9yUHJvdG90eXBlJVwiOltcIkVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlRXZhbEVycm9yUHJvdG90eXBlJVwiOltcIkV2YWxFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJUZsb2F0MzJBcnJheVByb3RvdHlwZSVcIjpbXCJGbG9hdDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVGbG9hdDY0QXJyYXlQcm90b3R5cGUlXCI6W1wiRmxvYXQ2NEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3IlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3JQcm90b3R5cGUlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiLFwicHJvdG90eXBlXCJdLFwiJUludDhBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIkludDE2QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQzMkFycmF5UHJvdG90eXBlJVwiOltcIkludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVKU09OUGFyc2UlXCI6W1wiSlNPTlwiLFwicGFyc2VcIl0sXCIlSlNPTlN0cmluZ2lmeSVcIjpbXCJKU09OXCIsXCJzdHJpbmdpZnlcIl0sXCIlTWFwUHJvdG90eXBlJVwiOltcIk1hcFwiLFwicHJvdG90eXBlXCJdLFwiJU51bWJlclByb3RvdHlwZSVcIjpbXCJOdW1iZXJcIixcInByb3RvdHlwZVwiXSxcIiVPYmplY3RQcm90b3R5cGUlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIl0sXCIlT2JqUHJvdG9fdG9TdHJpbmclXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInRvU3RyaW5nXCJdLFwiJU9ialByb3RvX3ZhbHVlT2YlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInZhbHVlT2ZcIl0sXCIlUHJvbWlzZVByb3RvdHlwZSVcIjpbXCJQcm9taXNlXCIsXCJwcm90b3R5cGVcIl0sXCIlUHJvbWlzZVByb3RvX3RoZW4lXCI6W1wiUHJvbWlzZVwiLFwicHJvdG90eXBlXCIsXCJ0aGVuXCJdLFwiJVByb21pc2VfYWxsJVwiOltcIlByb21pc2VcIixcImFsbFwiXSxcIiVQcm9taXNlX3JlamVjdCVcIjpbXCJQcm9taXNlXCIsXCJyZWplY3RcIl0sXCIlUHJvbWlzZV9yZXNvbHZlJVwiOltcIlByb21pc2VcIixcInJlc29sdmVcIl0sXCIlUmFuZ2VFcnJvclByb3RvdHlwZSVcIjpbXCJSYW5nZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlXCI6W1wiUmVmZXJlbmNlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVSZWdFeHBQcm90b3R5cGUlXCI6W1wiUmVnRXhwXCIsXCJwcm90b3R5cGVcIl0sXCIlU2V0UHJvdG90eXBlJVwiOltcIlNldFwiLFwicHJvdG90eXBlXCJdLFwiJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJVwiOltcIlNoYXJlZEFycmF5QnVmZmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlU3RyaW5nUHJvdG90eXBlJVwiOltcIlN0cmluZ1wiLFwicHJvdG90eXBlXCJdLFwiJVN5bWJvbFByb3RvdHlwZSVcIjpbXCJTeW1ib2xcIixcInByb3RvdHlwZVwiXSxcIiVTeW50YXhFcnJvclByb3RvdHlwZSVcIjpbXCJTeW50YXhFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVkQXJyYXlQcm90b3R5cGUlXCI6W1wiVHlwZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVFcnJvclByb3RvdHlwZSVcIjpbXCJUeXBlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OEFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50OENsYW1wZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQxNkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVUklFcnJvclByb3RvdHlwZSVcIjpbXCJVUklFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtNYXBQcm90b3R5cGUlXCI6W1wiV2Vha01hcFwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtTZXRQcm90b3R5cGUlXCI6W1wiV2Vha1NldFwiLFwicHJvdG90eXBlXCJdfTt2YXIgdj10KDE5NCk7dmFyIGI9dCg2NDYpO3ZhciBBPXYuY2FsbChGdW5jdGlvbi5jYWxsLEFycmF5LnByb3RvdHlwZS5jb25jYXQpO3ZhciBtPXYuY2FsbChGdW5jdGlvbi5hcHBseSxBcnJheS5wcm90b3R5cGUuc3BsaWNlKTt2YXIgUz12LmNhbGwoRnVuY3Rpb24uY2FsbCxTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO3ZhciBoPXYuY2FsbChGdW5jdGlvbi5jYWxsLFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO3ZhciBPPS9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO3ZhciB3PS9cXFxcKFxcXFwpPy9nO3ZhciBqPWZ1bmN0aW9uIHN0cmluZ1RvUGF0aChyKXt2YXIgZT1oKHIsMCwxKTt2YXIgdD1oKHIsLTEpO2lmKGU9PT1cIiVcIiYmdCE9PVwiJVwiKXt0aHJvdyBuZXcgbyhcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWBcIil9ZWxzZSBpZih0PT09XCIlXCImJmUhPT1cIiVcIil7dGhyb3cgbmV3IG8oXCJpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgXCIpfXZhciBuPVtdO1MocixPLChmdW5jdGlvbihyLGUsdCxvKXtuW24ubGVuZ3RoXT10P1Mobyx3LFwiJDFcIik6ZXx8cn0pKTtyZXR1cm4gbn07dmFyIFA9ZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhyLGUpe3ZhciB0PXI7dmFyIG47aWYoYihkLHQpKXtuPWRbdF07dD1cIiVcIituWzBdK1wiJVwifWlmKGIobCx0KSl7dmFyIGk9bFt0XTtpZihpPT09eSl7aT1nKHQpfWlmKHR5cGVvZiBpPT09XCJ1bmRlZmluZWRcIiYmIWUpe3Rocm93IG5ldyBhKFwiaW50cmluc2ljIFwiK3IrXCIgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhXCIpfXJldHVybnthbGlhczpuLG5hbWU6dCx2YWx1ZTppfX10aHJvdyBuZXcgbyhcImludHJpbnNpYyBcIityK1wiIGRvZXMgbm90IGV4aXN0IVwiKX07ci5leHBvcnRzPWZ1bmN0aW9uIEdldEludHJpbnNpYyhyLGUpe2lmKHR5cGVvZiByIT09XCJzdHJpbmdcInx8ci5sZW5ndGg9PT0wKXt0aHJvdyBuZXcgYShcImludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWlmKGFyZ3VtZW50cy5sZW5ndGg+MSYmdHlwZW9mIGUhPT1cImJvb2xlYW5cIil7dGhyb3cgbmV3IGEoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKX12YXIgdD1qKHIpO3ZhciBpPXQubGVuZ3RoPjA/dFswXTpcIlwiO3ZhciB1PVAoXCIlXCIraStcIiVcIixlKTt2YXIgcz11Lm5hbWU7dmFyIGM9dS52YWx1ZTt2YXIgeT1mYWxzZTt2YXIgcD11LmFsaWFzO2lmKHApe2k9cFswXTttKHQsQShbMCwxXSxwKSl9Zm9yKHZhciBnPTEsZD10cnVlO2c8dC5sZW5ndGg7Zys9MSl7dmFyIHY9dFtnXTt2YXIgUz1oKHYsMCwxKTt2YXIgTz1oKHYsLTEpO2lmKChTPT09J1wiJ3x8Uz09PVwiJ1wifHxTPT09XCJgXCJ8fChPPT09J1wiJ3x8Tz09PVwiJ1wifHxPPT09XCJgXCIpKSYmUyE9PU8pe3Rocm93IG5ldyBvKFwicHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3Rlc1wiKX1pZih2PT09XCJjb25zdHJ1Y3RvclwifHwhZCl7eT10cnVlfWkrPVwiLlwiK3Y7cz1cIiVcIitpK1wiJVwiO2lmKGIobCxzKSl7Yz1sW3NdfWVsc2UgaWYoYyE9bnVsbCl7aWYoISh2IGluIGMpKXtpZighZSl7dGhyb3cgbmV3IGEoXCJiYXNlIGludHJpbnNpYyBmb3IgXCIrcitcIiBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS5cIil9cmV0dXJuIHZvaWQgbn1pZihmJiZnKzE+PXQubGVuZ3RoKXt2YXIgdz1mKGMsdik7ZD0hIXc7aWYoZCYmXCJnZXRcImluIHcmJiEoXCJvcmlnaW5hbFZhbHVlXCJpbiB3LmdldCkpe2M9dy5nZXR9ZWxzZXtjPWNbdl19fWVsc2V7ZD1iKGMsdik7Yz1jW3ZdfWlmKGQmJiF5KXtsW3NdPWN9fX1yZXR1cm4gY319LDU2NzpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dHlwZW9mIFN5bWJvbCE9PVwidW5kZWZpbmVkXCImJlN5bWJvbDt2YXIgbz10KDE4Nik7ci5leHBvcnRzPWZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKXtpZih0eXBlb2YgbiE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBTeW1ib2whPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgbihcImZvb1wiKSE9PVwic3ltYm9sXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sKFwiYmFyXCIpIT09XCJzeW1ib2xcIil7cmV0dXJuIGZhbHNlfXJldHVybiBvKCl9fSwxODY6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7ci5leHBvcnRzPWZ1bmN0aW9uIGhhc1N5bWJvbHMoKXtpZih0eXBlb2YgU3ltYm9sIT09XCJmdW5jdGlvblwifHx0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3I9PT1cInN5bWJvbFwiKXtyZXR1cm4gdHJ1ZX12YXIgcj17fTt2YXIgZT1TeW1ib2woXCJ0ZXN0XCIpO3ZhciB0PU9iamVjdChlKTtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBmYWxzZX1pZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkhPT1cIltvYmplY3QgU3ltYm9sXVwiKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpIT09XCJbb2JqZWN0IFN5bWJvbF1cIil7cmV0dXJuIGZhbHNlfXZhciBuPTQyO3JbZV09bjtmb3IoZSBpbiByKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIE9iamVjdC5rZXlzPT09XCJmdW5jdGlvblwiJiZPYmplY3Qua2V5cyhyKS5sZW5ndGghPT0wKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzPT09XCJmdW5jdGlvblwiJiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhyKS5sZW5ndGghPT0wKXtyZXR1cm4gZmFsc2V9dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhyKTtpZihvLmxlbmd0aCE9PTF8fG9bMF0hPT1lKXtyZXR1cm4gZmFsc2V9aWYoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChyLGUpKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I9PT1cImZ1bmN0aW9uXCIpe3ZhciBpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocixlKTtpZihpLnZhbHVlIT09bnx8aS5lbnVtZXJhYmxlIT09dHJ1ZSl7cmV0dXJuIGZhbHNlfX1yZXR1cm4gdHJ1ZX19LDY0NjpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCgxOTQpO3IuZXhwb3J0cz1uLmNhbGwoRnVuY3Rpb24uY2FsbCxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KX0sMTQwOmZ1bmN0aW9uKHIpe2lmKHR5cGVvZiBPYmplY3QuY3JlYXRlPT09XCJmdW5jdGlvblwiKXtyLmV4cG9ydHM9ZnVuY3Rpb24gaW5oZXJpdHMocixlKXtpZihlKXtyLnN1cGVyXz1lO3IucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpyLGVudW1lcmFibGU6ZmFsc2Usd3JpdGFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZX19KX19fWVsc2V7ci5leHBvcnRzPWZ1bmN0aW9uIGluaGVyaXRzKHIsZSl7aWYoZSl7ci5zdXBlcl89ZTt2YXIgVGVtcEN0b3I9ZnVuY3Rpb24oKXt9O1RlbXBDdG9yLnByb3RvdHlwZT1lLnByb3RvdHlwZTtyLnByb3RvdHlwZT1uZXcgVGVtcEN0b3I7ci5wcm90b3R5cGUuY29uc3RydWN0b3I9cn19fX0sNzQ5OmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3ZhciBlPXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PT1cInN5bWJvbFwiO3ZhciB0PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7dmFyIG49ZnVuY3Rpb24gaXNBcmd1bWVudHMocil7aWYoZSYmciYmdHlwZW9mIHI9PT1cIm9iamVjdFwiJiZTeW1ib2wudG9TdHJpbmdUYWcgaW4gcil7cmV0dXJuIGZhbHNlfXJldHVybiB0LmNhbGwocik9PT1cIltvYmplY3QgQXJndW1lbnRzXVwifTt2YXIgbz1mdW5jdGlvbiBpc0FyZ3VtZW50cyhyKXtpZihuKHIpKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gciE9PW51bGwmJnR5cGVvZiByPT09XCJvYmplY3RcIiYmdHlwZW9mIHIubGVuZ3RoPT09XCJudW1iZXJcIiYmci5sZW5ndGg+PTAmJnQuY2FsbChyKSE9PVwiW29iamVjdCBBcnJheV1cIiYmdC5jYWxsKHIuY2FsbGVlKT09PVwiW29iamVjdCBGdW5jdGlvbl1cIn07dmFyIGk9ZnVuY3Rpb24oKXtyZXR1cm4gbihhcmd1bWVudHMpfSgpO24uaXNMZWdhY3lBcmd1bWVudHM9bztyLmV4cG9ydHM9aT9uOm99LDYxMTpmdW5jdGlvbihyKXtcInVzZSBzdHJpY3RcIjt2YXIgZT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO3ZhciB0PUZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZzt2YXIgbj0vXlxccyooPzpmdW5jdGlvbik/XFwqLzt2YXIgbz10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT09XCJzeW1ib2xcIjt2YXIgaT1PYmplY3QuZ2V0UHJvdG90eXBlT2Y7dmFyIGdldEdlbmVyYXRvckZ1bmM9ZnVuY3Rpb24oKXtpZighbyl7cmV0dXJuIGZhbHNlfXRyeXtyZXR1cm4gRnVuY3Rpb24oXCJyZXR1cm4gZnVuY3Rpb24qKCkge31cIikoKX1jYXRjaChyKXt9fTt2YXIgYT1nZXRHZW5lcmF0b3JGdW5jKCk7dmFyIGY9YT9pKGEpOnt9O3IuZXhwb3J0cz1mdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKHIpe2lmKHR5cGVvZiByIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYobi50ZXN0KHQuY2FsbChyKSkpe3JldHVybiB0cnVlfWlmKCFvKXt2YXIgYT1lLmNhbGwocik7cmV0dXJuIGE9PT1cIltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dXCJ9cmV0dXJuIGkocik9PT1mfX0sMzg3OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KDk4MSk7dmFyIG89dCgzODIpO3ZhciBpPXQoMTcxKTt2YXIgYT1pKFwiT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1wiKTt2YXIgZj10KDU2NykoKTt2YXIgdT1mJiZ0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT09XCJzeW1ib2xcIjt2YXIgcz1vKCk7dmFyIGM9aShcIkFycmF5LnByb3RvdHlwZS5pbmRleE9mXCIsdHJ1ZSl8fGZ1bmN0aW9uIGluZGV4T2YocixlKXtmb3IodmFyIHQ9MDt0PHIubGVuZ3RoO3QrPTEpe2lmKHJbdF09PT1lKXtyZXR1cm4gdH19cmV0dXJuLTF9O3ZhciB5PWkoXCJTdHJpbmcucHJvdG90eXBlLnNsaWNlXCIpO3ZhciBwPXt9O3ZhciBsPXQoMzApO3ZhciBnPU9iamVjdC5nZXRQcm90b3R5cGVPZjtpZih1JiZsJiZnKXtuKHMsKGZ1bmN0aW9uKHIpe3ZhciBlPW5ldyBnbG9iYWxbcl07aWYoIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gZSkpe3Rocm93IG5ldyBFdmFsRXJyb3IoXCJ0aGlzIGVuZ2luZSBoYXMgc3VwcG9ydCBmb3IgU3ltYm9sLnRvU3RyaW5nVGFnLCBidXQgXCIrcitcIiBkb2VzIG5vdCBoYXZlIHRoZSBwcm9wZXJ0eSEgUGxlYXNlIHJlcG9ydCB0aGlzLlwiKX12YXIgdD1nKGUpO3ZhciBuPWwodCxTeW1ib2wudG9TdHJpbmdUYWcpO2lmKCFuKXt2YXIgbz1nKHQpO249bChvLFN5bWJvbC50b1N0cmluZ1RhZyl9cFtyXT1uLmdldH0pKX12YXIgZD1mdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyhyKXt2YXIgZT1mYWxzZTtuKHAsKGZ1bmN0aW9uKHQsbil7aWYoIWUpe3RyeXtlPXQuY2FsbChyKT09PW59Y2F0Y2gocil7fX19KSk7cmV0dXJuIGV9O3IuZXhwb3J0cz1mdW5jdGlvbiBpc1R5cGVkQXJyYXkocil7aWYoIXJ8fHR5cGVvZiByIT09XCJvYmplY3RcIil7cmV0dXJuIGZhbHNlfWlmKCF1KXt2YXIgZT15KGEociksOCwtMSk7cmV0dXJuIGMocyxlKT4tMX1pZighbCl7cmV0dXJuIGZhbHNlfXJldHVybiBkKHIpfX0sOTEzOmZ1bmN0aW9uKHIpe3IuZXhwb3J0cz1mdW5jdGlvbiBpc0J1ZmZlcihyKXtyZXR1cm4gciBpbnN0YW5jZW9mIEJ1ZmZlcn19LDk4OTpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCg3NDkpO3ZhciBvPXQoNjExKTt2YXIgaT10KDcyOCk7dmFyIGE9dCgzODcpO2Z1bmN0aW9uIHVuY3VycnlUaGlzKHIpe3JldHVybiByLmNhbGwuYmluZChyKX12YXIgZj10eXBlb2YgQmlnSW50IT09XCJ1bmRlZmluZWRcIjt2YXIgdT10eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIjt2YXIgcz11bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTt2YXIgYz11bmN1cnJ5VGhpcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YpO3ZhciB5PXVuY3VycnlUaGlzKFN0cmluZy5wcm90b3R5cGUudmFsdWVPZik7dmFyIHA9dW5jdXJyeVRoaXMoQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZik7aWYoZil7dmFyIGw9dW5jdXJyeVRoaXMoQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mKX1pZih1KXt2YXIgZz11bmN1cnJ5VGhpcyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpfWZ1bmN0aW9uIGNoZWNrQm94ZWRQcmltaXRpdmUocixlKXtpZih0eXBlb2YgciE9PVwib2JqZWN0XCIpe3JldHVybiBmYWxzZX10cnl7ZShyKTtyZXR1cm4gdHJ1ZX1jYXRjaChyKXtyZXR1cm4gZmFsc2V9fWUuaXNBcmd1bWVudHNPYmplY3Q9bjtlLmlzR2VuZXJhdG9yRnVuY3Rpb249bztlLmlzVHlwZWRBcnJheT1hO2Z1bmN0aW9uIGlzUHJvbWlzZShyKXtyZXR1cm4gdHlwZW9mIFByb21pc2UhPT1cInVuZGVmaW5lZFwiJiZyIGluc3RhbmNlb2YgUHJvbWlzZXx8ciE9PW51bGwmJnR5cGVvZiByPT09XCJvYmplY3RcIiYmdHlwZW9mIHIudGhlbj09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIHIuY2F0Y2g9PT1cImZ1bmN0aW9uXCJ9ZS5pc1Byb21pc2U9aXNQcm9taXNlO2Z1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHIpe2lmKHR5cGVvZiBBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCImJkFycmF5QnVmZmVyLmlzVmlldyl7cmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhyKX1yZXR1cm4gYShyKXx8aXNEYXRhVmlldyhyKX1lLmlzQXJyYXlCdWZmZXJWaWV3PWlzQXJyYXlCdWZmZXJWaWV3O2Z1bmN0aW9uIGlzVWludDhBcnJheShyKXtyZXR1cm4gaShyKT09PVwiVWludDhBcnJheVwifWUuaXNVaW50OEFycmF5PWlzVWludDhBcnJheTtmdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJVaW50OENsYW1wZWRBcnJheVwifWUuaXNVaW50OENsYW1wZWRBcnJheT1pc1VpbnQ4Q2xhbXBlZEFycmF5O2Z1bmN0aW9uIGlzVWludDE2QXJyYXkocil7cmV0dXJuIGkocik9PT1cIlVpbnQxNkFycmF5XCJ9ZS5pc1VpbnQxNkFycmF5PWlzVWludDE2QXJyYXk7ZnVuY3Rpb24gaXNVaW50MzJBcnJheShyKXtyZXR1cm4gaShyKT09PVwiVWludDMyQXJyYXlcIn1lLmlzVWludDMyQXJyYXk9aXNVaW50MzJBcnJheTtmdW5jdGlvbiBpc0ludDhBcnJheShyKXtyZXR1cm4gaShyKT09PVwiSW50OEFycmF5XCJ9ZS5pc0ludDhBcnJheT1pc0ludDhBcnJheTtmdW5jdGlvbiBpc0ludDE2QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkludDE2QXJyYXlcIn1lLmlzSW50MTZBcnJheT1pc0ludDE2QXJyYXk7ZnVuY3Rpb24gaXNJbnQzMkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJJbnQzMkFycmF5XCJ9ZS5pc0ludDMyQXJyYXk9aXNJbnQzMkFycmF5O2Z1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJGbG9hdDMyQXJyYXlcIn1lLmlzRmxvYXQzMkFycmF5PWlzRmxvYXQzMkFycmF5O2Z1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJGbG9hdDY0QXJyYXlcIn1lLmlzRmxvYXQ2NEFycmF5PWlzRmxvYXQ2NEFycmF5O2Z1bmN0aW9uIGlzQmlnSW50NjRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiQmlnSW50NjRBcnJheVwifWUuaXNCaWdJbnQ2NEFycmF5PWlzQmlnSW50NjRBcnJheTtmdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJCaWdVaW50NjRBcnJheVwifWUuaXNCaWdVaW50NjRBcnJheT1pc0JpZ1VpbnQ2NEFycmF5O2Z1bmN0aW9uIGlzTWFwVG9TdHJpbmcocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgTWFwXVwifWlzTWFwVG9TdHJpbmcud29ya2luZz10eXBlb2YgTWFwIT09XCJ1bmRlZmluZWRcIiYmaXNNYXBUb1N0cmluZyhuZXcgTWFwKTtmdW5jdGlvbiBpc01hcChyKXtpZih0eXBlb2YgTWFwPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc01hcFRvU3RyaW5nLndvcmtpbmc/aXNNYXBUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgTWFwfWUuaXNNYXA9aXNNYXA7ZnVuY3Rpb24gaXNTZXRUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBTZXRdXCJ9aXNTZXRUb1N0cmluZy53b3JraW5nPXR5cGVvZiBTZXQhPT1cInVuZGVmaW5lZFwiJiZpc1NldFRvU3RyaW5nKG5ldyBTZXQpO2Z1bmN0aW9uIGlzU2V0KHIpe2lmKHR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGlzU2V0VG9TdHJpbmcud29ya2luZz9pc1NldFRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBTZXR9ZS5pc1NldD1pc1NldDtmdW5jdGlvbiBpc1dlYWtNYXBUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBXZWFrTWFwXVwifWlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIFdlYWtNYXAhPT1cInVuZGVmaW5lZFwiJiZpc1dlYWtNYXBUb1N0cmluZyhuZXcgV2Vha01hcCk7ZnVuY3Rpb24gaXNXZWFrTWFwKHIpe2lmKHR5cGVvZiBXZWFrTWFwPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc1dlYWtNYXBUb1N0cmluZy53b3JraW5nP2lzV2Vha01hcFRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBXZWFrTWFwfWUuaXNXZWFrTWFwPWlzV2Vha01hcDtmdW5jdGlvbiBpc1dlYWtTZXRUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBXZWFrU2V0XVwifWlzV2Vha1NldFRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIFdlYWtTZXQhPT1cInVuZGVmaW5lZFwiJiZpc1dlYWtTZXRUb1N0cmluZyhuZXcgV2Vha1NldCk7ZnVuY3Rpb24gaXNXZWFrU2V0KHIpe3JldHVybiBpc1dlYWtTZXRUb1N0cmluZyhyKX1lLmlzV2Vha1NldD1pc1dlYWtTZXQ7ZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IEFycmF5QnVmZmVyXVwifWlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nPXR5cGVvZiBBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCImJmlzQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgQXJyYXlCdWZmZXIpO2Z1bmN0aW9uIGlzQXJyYXlCdWZmZXIocil7aWYodHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz9pc0FycmF5QnVmZmVyVG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfWUuaXNBcnJheUJ1ZmZlcj1pc0FycmF5QnVmZmVyO2Z1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBEYXRhVmlld11cIn1pc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZz10eXBlb2YgQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiZ0eXBlb2YgRGF0YVZpZXchPT1cInVuZGVmaW5lZFwiJiZpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwwLDEpKTtmdW5jdGlvbiBpc0RhdGFWaWV3KHIpe2lmKHR5cGVvZiBEYXRhVmlldz09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmc/aXNEYXRhVmlld1RvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBEYXRhVmlld31lLmlzRGF0YVZpZXc9aXNEYXRhVmlldzt2YXIgZD10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiP1NoYXJlZEFycmF5QnVmZmVyOnVuZGVmaW5lZDtmdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdXCJ9ZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlcihyKXtpZih0eXBlb2YgZD09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc9PT1cInVuZGVmaW5lZFwiKXtpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz1pc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcobmV3IGQpfXJldHVybiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz9pc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIGR9ZS5pc1NoYXJlZEFycmF5QnVmZmVyPWlzU2hhcmVkQXJyYXlCdWZmZXI7ZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dXCJ9ZS5pc0FzeW5jRnVuY3Rpb249aXNBc3luY0Z1bmN0aW9uO2Z1bmN0aW9uIGlzTWFwSXRlcmF0b3Iocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgTWFwIEl0ZXJhdG9yXVwifWUuaXNNYXBJdGVyYXRvcj1pc01hcEl0ZXJhdG9yO2Z1bmN0aW9uIGlzU2V0SXRlcmF0b3Iocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgU2V0IEl0ZXJhdG9yXVwifWUuaXNTZXRJdGVyYXRvcj1pc1NldEl0ZXJhdG9yO2Z1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IEdlbmVyYXRvcl1cIn1lLmlzR2VuZXJhdG9yT2JqZWN0PWlzR2VuZXJhdG9yT2JqZWN0O2Z1bmN0aW9uIGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZShyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBXZWJBc3NlbWJseS5Nb2R1bGVdXCJ9ZS5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU9aXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlO2Z1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHIpe3JldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHIsYyl9ZS5pc051bWJlck9iamVjdD1pc051bWJlck9iamVjdDtmdW5jdGlvbiBpc1N0cmluZ09iamVjdChyKXtyZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZShyLHkpfWUuaXNTdHJpbmdPYmplY3Q9aXNTdHJpbmdPYmplY3Q7ZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHIpe3JldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHIscCl9ZS5pc0Jvb2xlYW5PYmplY3Q9aXNCb29sZWFuT2JqZWN0O2Z1bmN0aW9uIGlzQmlnSW50T2JqZWN0KHIpe3JldHVybiBmJiZjaGVja0JveGVkUHJpbWl0aXZlKHIsbCl9ZS5pc0JpZ0ludE9iamVjdD1pc0JpZ0ludE9iamVjdDtmdW5jdGlvbiBpc1N5bWJvbE9iamVjdChyKXtyZXR1cm4gdSYmY2hlY2tCb3hlZFByaW1pdGl2ZShyLGcpfWUuaXNTeW1ib2xPYmplY3Q9aXNTeW1ib2xPYmplY3Q7ZnVuY3Rpb24gaXNCb3hlZFByaW1pdGl2ZShyKXtyZXR1cm4gaXNOdW1iZXJPYmplY3Qocil8fGlzU3RyaW5nT2JqZWN0KHIpfHxpc0Jvb2xlYW5PYmplY3Qocil8fGlzQmlnSW50T2JqZWN0KHIpfHxpc1N5bWJvbE9iamVjdChyKX1lLmlzQm94ZWRQcmltaXRpdmU9aXNCb3hlZFByaW1pdGl2ZTtmdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHIpe3JldHVybiB0eXBlb2YgVWludDhBcnJheSE9PVwidW5kZWZpbmVkXCImJihpc0FycmF5QnVmZmVyKHIpfHxpc1NoYXJlZEFycmF5QnVmZmVyKHIpKX1lLmlzQW55QXJyYXlCdWZmZXI9aXNBbnlBcnJheUJ1ZmZlcjtbXCJpc1Byb3h5XCIsXCJpc0V4dGVybmFsXCIsXCJpc01vZHVsZU5hbWVzcGFjZU9iamVjdFwiXS5mb3JFYWNoKChmdW5jdGlvbihyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOmZhbHNlLHZhbHVlOmZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKHIrXCIgaXMgbm90IHN1cHBvcnRlZCBpbiB1c2VybGFuZFwiKX19KX0pKX0sNDY3OmZ1bmN0aW9uKHIsZSx0KXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yc3x8ZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhyKXt2YXIgZT1PYmplY3Qua2V5cyhyKTt2YXIgdD17fTtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dFtlW25dXT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZVtuXSl9cmV0dXJuIHR9O3ZhciBvPS8lW3NkaiVdL2c7ZS5mb3JtYXQ9ZnVuY3Rpb24ocil7aWYoIWlzU3RyaW5nKHIpKXt2YXIgZT1bXTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXtlLnB1c2goaW5zcGVjdChhcmd1bWVudHNbdF0pKX1yZXR1cm4gZS5qb2luKFwiIFwiKX12YXIgdD0xO3ZhciBuPWFyZ3VtZW50czt2YXIgaT1uLmxlbmd0aDt2YXIgYT1TdHJpbmcocikucmVwbGFjZShvLChmdW5jdGlvbihyKXtpZihyPT09XCIlJVwiKXJldHVyblwiJVwiO2lmKHQ+PWkpcmV0dXJuIHI7c3dpdGNoKHIpe2Nhc2VcIiVzXCI6cmV0dXJuIFN0cmluZyhuW3QrK10pO2Nhc2VcIiVkXCI6cmV0dXJuIE51bWJlcihuW3QrK10pO2Nhc2VcIiVqXCI6dHJ5e3JldHVybiBKU09OLnN0cmluZ2lmeShuW3QrK10pfWNhdGNoKHIpe3JldHVyblwiW0NpcmN1bGFyXVwifWRlZmF1bHQ6cmV0dXJuIHJ9fSkpO2Zvcih2YXIgZj1uW3RdO3Q8aTtmPW5bKyt0XSl7aWYoaXNOdWxsKGYpfHwhaXNPYmplY3QoZikpe2ErPVwiIFwiK2Z9ZWxzZXthKz1cIiBcIitpbnNwZWN0KGYpfX1yZXR1cm4gYX07ZS5kZXByZWNhdGU9ZnVuY3Rpb24ocix0KXtpZih0eXBlb2YgcHJvY2VzcyE9PVwidW5kZWZpbmVkXCImJnByb2Nlc3Mubm9EZXByZWNhdGlvbj09PXRydWUpe3JldHVybiByfWlmKHR5cGVvZiBwcm9jZXNzPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUuZGVwcmVjYXRlKHIsdCkuYXBwbHkodGhpcyxhcmd1bWVudHMpfX12YXIgbj1mYWxzZTtmdW5jdGlvbiBkZXByZWNhdGVkKCl7aWYoIW4pe2lmKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbil7dGhyb3cgbmV3IEVycm9yKHQpfWVsc2UgaWYocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKXtjb25zb2xlLnRyYWNlKHQpfWVsc2V7Y29uc29sZS5lcnJvcih0KX1uPXRydWV9cmV0dXJuIHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBkZXByZWNhdGVkfTt2YXIgaT17fTt2YXIgYT0vXiQvO2lmKHByb2Nlc3MuZW52Lk5PREVfREVCVUcpe3ZhciBmPXByb2Nlc3MuZW52Lk5PREVfREVCVUc7Zj1mLnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csXCJcXFxcJCZcIikucmVwbGFjZSgvXFwqL2csXCIuKlwiKS5yZXBsYWNlKC8sL2csXCIkfF5cIikudG9VcHBlckNhc2UoKTthPW5ldyBSZWdFeHAoXCJeXCIrZitcIiRcIixcImlcIil9ZS5kZWJ1Z2xvZz1mdW5jdGlvbihyKXtyPXIudG9VcHBlckNhc2UoKTtpZighaVtyXSl7aWYoYS50ZXN0KHIpKXt2YXIgdD1wcm9jZXNzLnBpZDtpW3JdPWZ1bmN0aW9uKCl7dmFyIG49ZS5mb3JtYXQuYXBwbHkoZSxhcmd1bWVudHMpO2NvbnNvbGUuZXJyb3IoXCIlcyAlZDogJXNcIixyLHQsbil9fWVsc2V7aVtyXT1mdW5jdGlvbigpe319fXJldHVybiBpW3JdfTtmdW5jdGlvbiBpbnNwZWN0KHIsdCl7dmFyIG49e3NlZW46W10sc3R5bGl6ZTpzdHlsaXplTm9Db2xvcn07aWYoYXJndW1lbnRzLmxlbmd0aD49MyluLmRlcHRoPWFyZ3VtZW50c1syXTtpZihhcmd1bWVudHMubGVuZ3RoPj00KW4uY29sb3JzPWFyZ3VtZW50c1szXTtpZihpc0Jvb2xlYW4odCkpe24uc2hvd0hpZGRlbj10fWVsc2UgaWYodCl7ZS5fZXh0ZW5kKG4sdCl9aWYoaXNVbmRlZmluZWQobi5zaG93SGlkZGVuKSluLnNob3dIaWRkZW49ZmFsc2U7aWYoaXNVbmRlZmluZWQobi5kZXB0aCkpbi5kZXB0aD0yO2lmKGlzVW5kZWZpbmVkKG4uY29sb3JzKSluLmNvbG9ycz1mYWxzZTtpZihpc1VuZGVmaW5lZChuLmN1c3RvbUluc3BlY3QpKW4uY3VzdG9tSW5zcGVjdD10cnVlO2lmKG4uY29sb3JzKW4uc3R5bGl6ZT1zdHlsaXplV2l0aENvbG9yO3JldHVybiBmb3JtYXRWYWx1ZShuLHIsbi5kZXB0aCl9ZS5pbnNwZWN0PWluc3BlY3Q7aW5zcGVjdC5jb2xvcnM9e2JvbGQ6WzEsMjJdLGl0YWxpYzpbMywyM10sdW5kZXJsaW5lOls0LDI0XSxpbnZlcnNlOls3LDI3XSx3aGl0ZTpbMzcsMzldLGdyZXk6WzkwLDM5XSxibGFjazpbMzAsMzldLGJsdWU6WzM0LDM5XSxjeWFuOlszNiwzOV0sZ3JlZW46WzMyLDM5XSxtYWdlbnRhOlszNSwzOV0scmVkOlszMSwzOV0seWVsbG93OlszMywzOV19O2luc3BlY3Quc3R5bGVzPXtzcGVjaWFsOlwiY3lhblwiLG51bWJlcjpcInllbGxvd1wiLGJvb2xlYW46XCJ5ZWxsb3dcIix1bmRlZmluZWQ6XCJncmV5XCIsbnVsbDpcImJvbGRcIixzdHJpbmc6XCJncmVlblwiLGRhdGU6XCJtYWdlbnRhXCIscmVnZXhwOlwicmVkXCJ9O2Z1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3IocixlKXt2YXIgdD1pbnNwZWN0LnN0eWxlc1tlXTtpZih0KXtyZXR1cm5cIlx1MDAxYltcIitpbnNwZWN0LmNvbG9yc1t0XVswXStcIm1cIityK1wiXHUwMDFiW1wiK2luc3BlY3QuY29sb3JzW3RdWzFdK1wibVwifWVsc2V7cmV0dXJuIHJ9fWZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHIsZSl7cmV0dXJuIHJ9ZnVuY3Rpb24gYXJyYXlUb0hhc2gocil7dmFyIGU9e307ci5mb3JFYWNoKChmdW5jdGlvbihyLHQpe2Vbcl09dHJ1ZX0pKTtyZXR1cm4gZX1mdW5jdGlvbiBmb3JtYXRWYWx1ZShyLHQsbil7aWYoci5jdXN0b21JbnNwZWN0JiZ0JiZpc0Z1bmN0aW9uKHQuaW5zcGVjdCkmJnQuaW5zcGVjdCE9PWUuaW5zcGVjdCYmISh0LmNvbnN0cnVjdG9yJiZ0LmNvbnN0cnVjdG9yLnByb3RvdHlwZT09PXQpKXt2YXIgbz10Lmluc3BlY3QobixyKTtpZighaXNTdHJpbmcobykpe289Zm9ybWF0VmFsdWUocixvLG4pfXJldHVybiBvfXZhciBpPWZvcm1hdFByaW1pdGl2ZShyLHQpO2lmKGkpe3JldHVybiBpfXZhciBhPU9iamVjdC5rZXlzKHQpO3ZhciBmPWFycmF5VG9IYXNoKGEpO2lmKHIuc2hvd0hpZGRlbil7YT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0KX1pZihpc0Vycm9yKHQpJiYoYS5pbmRleE9mKFwibWVzc2FnZVwiKT49MHx8YS5pbmRleE9mKFwiZGVzY3JpcHRpb25cIik+PTApKXtyZXR1cm4gZm9ybWF0RXJyb3IodCl9aWYoYS5sZW5ndGg9PT0wKXtpZihpc0Z1bmN0aW9uKHQpKXt2YXIgdT10Lm5hbWU/XCI6IFwiK3QubmFtZTpcIlwiO3JldHVybiByLnN0eWxpemUoXCJbRnVuY3Rpb25cIit1K1wiXVwiLFwic3BlY2lhbFwiKX1pZihpc1JlZ0V4cCh0KSl7cmV0dXJuIHIuc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCksXCJyZWdleHBcIil9aWYoaXNEYXRlKHQpKXtyZXR1cm4gci5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCksXCJkYXRlXCIpfWlmKGlzRXJyb3IodCkpe3JldHVybiBmb3JtYXRFcnJvcih0KX19dmFyIHM9XCJcIixjPWZhbHNlLHk9W1wie1wiLFwifVwiXTtpZihpc0FycmF5KHQpKXtjPXRydWU7eT1bXCJbXCIsXCJdXCJdfWlmKGlzRnVuY3Rpb24odCkpe3ZhciBwPXQubmFtZT9cIjogXCIrdC5uYW1lOlwiXCI7cz1cIiBbRnVuY3Rpb25cIitwK1wiXVwifWlmKGlzUmVnRXhwKHQpKXtzPVwiIFwiK1JlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX1pZihpc0RhdGUodCkpe3M9XCIgXCIrRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh0KX1pZihpc0Vycm9yKHQpKXtzPVwiIFwiK2Zvcm1hdEVycm9yKHQpfWlmKGEubGVuZ3RoPT09MCYmKCFjfHx0Lmxlbmd0aD09MCkpe3JldHVybiB5WzBdK3MreVsxXX1pZihuPDApe2lmKGlzUmVnRXhwKHQpKXtyZXR1cm4gci5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSxcInJlZ2V4cFwiKX1lbHNle3JldHVybiByLnN0eWxpemUoXCJbT2JqZWN0XVwiLFwic3BlY2lhbFwiKX19ci5zZWVuLnB1c2godCk7dmFyIGw7aWYoYyl7bD1mb3JtYXRBcnJheShyLHQsbixmLGEpfWVsc2V7bD1hLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGZvcm1hdFByb3BlcnR5KHIsdCxuLGYsZSxjKX0pKX1yLnNlZW4ucG9wKCk7cmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKGwscyx5KX1mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUocixlKXtpZihpc1VuZGVmaW5lZChlKSlyZXR1cm4gci5zdHlsaXplKFwidW5kZWZpbmVkXCIsXCJ1bmRlZmluZWRcIik7aWYoaXNTdHJpbmcoZSkpe3ZhciB0PVwiJ1wiK0pTT04uc3RyaW5naWZ5KGUpLnJlcGxhY2UoL15cInxcIiQvZyxcIlwiKS5yZXBsYWNlKC8nL2csXCJcXFxcJ1wiKS5yZXBsYWNlKC9cXFxcXCIvZywnXCInKStcIidcIjtyZXR1cm4gci5zdHlsaXplKHQsXCJzdHJpbmdcIil9aWYoaXNOdW1iZXIoZSkpcmV0dXJuIHIuc3R5bGl6ZShcIlwiK2UsXCJudW1iZXJcIik7aWYoaXNCb29sZWFuKGUpKXJldHVybiByLnN0eWxpemUoXCJcIitlLFwiYm9vbGVhblwiKTtpZihpc051bGwoZSkpcmV0dXJuIHIuc3R5bGl6ZShcIm51bGxcIixcIm51bGxcIil9ZnVuY3Rpb24gZm9ybWF0RXJyb3Iocil7cmV0dXJuXCJbXCIrRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocikrXCJdXCJ9ZnVuY3Rpb24gZm9ybWF0QXJyYXkocixlLHQsbixvKXt2YXIgaT1bXTtmb3IodmFyIGE9MCxmPWUubGVuZ3RoO2E8ZjsrK2Epe2lmKGhhc093blByb3BlcnR5KGUsU3RyaW5nKGEpKSl7aS5wdXNoKGZvcm1hdFByb3BlcnR5KHIsZSx0LG4sU3RyaW5nKGEpLHRydWUpKX1lbHNle2kucHVzaChcIlwiKX19by5mb3JFYWNoKChmdW5jdGlvbihvKXtpZighby5tYXRjaCgvXlxcZCskLykpe2kucHVzaChmb3JtYXRQcm9wZXJ0eShyLGUsdCxuLG8sdHJ1ZSkpfX0pKTtyZXR1cm4gaX1mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShyLGUsdCxuLG8saSl7dmFyIGEsZix1O3U9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG8pfHx7dmFsdWU6ZVtvXX07aWYodS5nZXQpe2lmKHUuc2V0KXtmPXIuc3R5bGl6ZShcIltHZXR0ZXIvU2V0dGVyXVwiLFwic3BlY2lhbFwiKX1lbHNle2Y9ci5zdHlsaXplKFwiW0dldHRlcl1cIixcInNwZWNpYWxcIil9fWVsc2V7aWYodS5zZXQpe2Y9ci5zdHlsaXplKFwiW1NldHRlcl1cIixcInNwZWNpYWxcIil9fWlmKCFoYXNPd25Qcm9wZXJ0eShuLG8pKXthPVwiW1wiK28rXCJdXCJ9aWYoIWYpe2lmKHIuc2Vlbi5pbmRleE9mKHUudmFsdWUpPDApe2lmKGlzTnVsbCh0KSl7Zj1mb3JtYXRWYWx1ZShyLHUudmFsdWUsbnVsbCl9ZWxzZXtmPWZvcm1hdFZhbHVlKHIsdS52YWx1ZSx0LTEpfWlmKGYuaW5kZXhPZihcIlxcblwiKT4tMSl7aWYoaSl7Zj1mLnNwbGl0KFwiXFxuXCIpLm1hcCgoZnVuY3Rpb24ocil7cmV0dXJuXCIgIFwiK3J9KSkuam9pbihcIlxcblwiKS5zdWJzdHIoMil9ZWxzZXtmPVwiXFxuXCIrZi5zcGxpdChcIlxcblwiKS5tYXAoKGZ1bmN0aW9uKHIpe3JldHVyblwiICAgXCIrcn0pKS5qb2luKFwiXFxuXCIpfX19ZWxzZXtmPXIuc3R5bGl6ZShcIltDaXJjdWxhcl1cIixcInNwZWNpYWxcIil9fWlmKGlzVW5kZWZpbmVkKGEpKXtpZihpJiZvLm1hdGNoKC9eXFxkKyQvKSl7cmV0dXJuIGZ9YT1KU09OLnN0cmluZ2lmeShcIlwiK28pO2lmKGEubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKXthPWEuc3Vic3RyKDEsYS5sZW5ndGgtMik7YT1yLnN0eWxpemUoYSxcIm5hbWVcIil9ZWxzZXthPWEucmVwbGFjZSgvJy9nLFwiXFxcXCdcIikucmVwbGFjZSgvXFxcXFwiL2csJ1wiJykucmVwbGFjZSgvKF5cInxcIiQpL2csXCInXCIpO2E9ci5zdHlsaXplKGEsXCJzdHJpbmdcIil9fXJldHVybiBhK1wiOiBcIitmfWZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKHIsZSx0KXt2YXIgbj0wO3ZhciBvPXIucmVkdWNlKChmdW5jdGlvbihyLGUpe24rKztpZihlLmluZGV4T2YoXCJcXG5cIik+PTApbisrO3JldHVybiByK2UucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csXCJcIikubGVuZ3RoKzF9KSwwKTtpZihvPjYwKXtyZXR1cm4gdFswXSsoZT09PVwiXCI/XCJcIjplK1wiXFxuIFwiKStcIiBcIityLmpvaW4oXCIsXFxuICBcIikrXCIgXCIrdFsxXX1yZXR1cm4gdFswXStlK1wiIFwiK3Iuam9pbihcIiwgXCIpK1wiIFwiK3RbMV19ZS50eXBlcz10KDk4OSk7ZnVuY3Rpb24gaXNBcnJheShyKXtyZXR1cm4gQXJyYXkuaXNBcnJheShyKX1lLmlzQXJyYXk9aXNBcnJheTtmdW5jdGlvbiBpc0Jvb2xlYW4ocil7cmV0dXJuIHR5cGVvZiByPT09XCJib29sZWFuXCJ9ZS5pc0Jvb2xlYW49aXNCb29sZWFuO2Z1bmN0aW9uIGlzTnVsbChyKXtyZXR1cm4gcj09PW51bGx9ZS5pc051bGw9aXNOdWxsO2Z1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHIpe3JldHVybiByPT1udWxsfWUuaXNOdWxsT3JVbmRlZmluZWQ9aXNOdWxsT3JVbmRlZmluZWQ7ZnVuY3Rpb24gaXNOdW1iZXIocil7cmV0dXJuIHR5cGVvZiByPT09XCJudW1iZXJcIn1lLmlzTnVtYmVyPWlzTnVtYmVyO2Z1bmN0aW9uIGlzU3RyaW5nKHIpe3JldHVybiB0eXBlb2Ygcj09PVwic3RyaW5nXCJ9ZS5pc1N0cmluZz1pc1N0cmluZztmdW5jdGlvbiBpc1N5bWJvbChyKXtyZXR1cm4gdHlwZW9mIHI9PT1cInN5bWJvbFwifWUuaXNTeW1ib2w9aXNTeW1ib2w7ZnVuY3Rpb24gaXNVbmRlZmluZWQocil7cmV0dXJuIHI9PT12b2lkIDB9ZS5pc1VuZGVmaW5lZD1pc1VuZGVmaW5lZDtmdW5jdGlvbiBpc1JlZ0V4cChyKXtyZXR1cm4gaXNPYmplY3QocikmJm9iamVjdFRvU3RyaW5nKHIpPT09XCJbb2JqZWN0IFJlZ0V4cF1cIn1lLmlzUmVnRXhwPWlzUmVnRXhwO2UudHlwZXMuaXNSZWdFeHA9aXNSZWdFeHA7ZnVuY3Rpb24gaXNPYmplY3Qocil7cmV0dXJuIHR5cGVvZiByPT09XCJvYmplY3RcIiYmciE9PW51bGx9ZS5pc09iamVjdD1pc09iamVjdDtmdW5jdGlvbiBpc0RhdGUocil7cmV0dXJuIGlzT2JqZWN0KHIpJiZvYmplY3RUb1N0cmluZyhyKT09PVwiW29iamVjdCBEYXRlXVwifWUuaXNEYXRlPWlzRGF0ZTtlLnR5cGVzLmlzRGF0ZT1pc0RhdGU7ZnVuY3Rpb24gaXNFcnJvcihyKXtyZXR1cm4gaXNPYmplY3QocikmJihvYmplY3RUb1N0cmluZyhyKT09PVwiW29iamVjdCBFcnJvcl1cInx8ciBpbnN0YW5jZW9mIEVycm9yKX1lLmlzRXJyb3I9aXNFcnJvcjtlLnR5cGVzLmlzTmF0aXZlRXJyb3I9aXNFcnJvcjtmdW5jdGlvbiBpc0Z1bmN0aW9uKHIpe3JldHVybiB0eXBlb2Ygcj09PVwiZnVuY3Rpb25cIn1lLmlzRnVuY3Rpb249aXNGdW5jdGlvbjtmdW5jdGlvbiBpc1ByaW1pdGl2ZShyKXtyZXR1cm4gcj09PW51bGx8fHR5cGVvZiByPT09XCJib29sZWFuXCJ8fHR5cGVvZiByPT09XCJudW1iZXJcInx8dHlwZW9mIHI9PT1cInN0cmluZ1wifHx0eXBlb2Ygcj09PVwic3ltYm9sXCJ8fHR5cGVvZiByPT09XCJ1bmRlZmluZWRcIn1lLmlzUHJpbWl0aXZlPWlzUHJpbWl0aXZlO2UuaXNCdWZmZXI9dCg5MTMpO2Z1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHIpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocil9ZnVuY3Rpb24gcGFkKHIpe3JldHVybiByPDEwP1wiMFwiK3IudG9TdHJpbmcoMTApOnIudG9TdHJpbmcoMTApfXZhciB1PVtcIkphblwiLFwiRmViXCIsXCJNYXJcIixcIkFwclwiLFwiTWF5XCIsXCJKdW5cIixcIkp1bFwiLFwiQXVnXCIsXCJTZXBcIixcIk9jdFwiLFwiTm92XCIsXCJEZWNcIl07ZnVuY3Rpb24gdGltZXN0YW1wKCl7dmFyIHI9bmV3IERhdGU7dmFyIGU9W3BhZChyLmdldEhvdXJzKCkpLHBhZChyLmdldE1pbnV0ZXMoKSkscGFkKHIuZ2V0U2Vjb25kcygpKV0uam9pbihcIjpcIik7cmV0dXJuW3IuZ2V0RGF0ZSgpLHVbci5nZXRNb250aCgpXSxlXS5qb2luKFwiIFwiKX1lLmxvZz1mdW5jdGlvbigpe2NvbnNvbGUubG9nKFwiJXMgLSAlc1wiLHRpbWVzdGFtcCgpLGUuZm9ybWF0LmFwcGx5KGUsYXJndW1lbnRzKSl9O2UuaW5oZXJpdHM9dCgxNDApO2UuX2V4dGVuZD1mdW5jdGlvbihyLGUpe2lmKCFlfHwhaXNPYmplY3QoZSkpcmV0dXJuIHI7dmFyIHQ9T2JqZWN0LmtleXMoZSk7dmFyIG49dC5sZW5ndGg7d2hpbGUobi0tKXtyW3Rbbl1dPWVbdFtuXV19cmV0dXJuIHJ9O2Z1bmN0aW9uIGhhc093blByb3BlcnR5KHIsZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLGUpfXZhciBzPXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiP1N5bWJvbChcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiKTp1bmRlZmluZWQ7ZS5wcm9taXNpZnk9ZnVuY3Rpb24gcHJvbWlzaWZ5KHIpe2lmKHR5cGVvZiByIT09XCJmdW5jdGlvblwiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7aWYocyYmcltzXSl7dmFyIGU9cltzXTtpZih0eXBlb2YgZSE9PVwiZnVuY3Rpb25cIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscyx7dmFsdWU6ZSxlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOmZhbHNlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7cmV0dXJuIGV9ZnVuY3Rpb24gZSgpe3ZhciBlLHQ7dmFyIG49bmV3IFByb21pc2UoKGZ1bmN0aW9uKHIsbil7ZT1yO3Q9bn0pKTt2YXIgbz1bXTtmb3IodmFyIGk9MDtpPGFyZ3VtZW50cy5sZW5ndGg7aSsrKXtvLnB1c2goYXJndW1lbnRzW2ldKX1vLnB1c2goKGZ1bmN0aW9uKHIsbil7aWYocil7dChyKX1lbHNle2Uobil9fSkpO3RyeXtyLmFwcGx5KHRoaXMsbyl9Y2F0Y2gocil7dChyKX1yZXR1cm4gbn1PYmplY3Quc2V0UHJvdG90eXBlT2YoZSxPYmplY3QuZ2V0UHJvdG90eXBlT2YocikpO2lmKHMpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscyx7dmFsdWU6ZSxlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOmZhbHNlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsbihyKSl9O2UucHJvbWlzaWZ5LmN1c3RvbT1zO2Z1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyLGUpe2lmKCFyKXt2YXIgdD1uZXcgRXJyb3IoXCJQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWVcIik7dC5yZWFzb249cjtyPXR9cmV0dXJuIGUocil9ZnVuY3Rpb24gY2FsbGJhY2tpZnkocil7aWYodHlwZW9mIHIhPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyl9ZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpe3ZhciBlPVtdO2Zvcih2YXIgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe2UucHVzaChhcmd1bWVudHNbdF0pfXZhciBuPWUucG9wKCk7aWYodHlwZW9mIG4hPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb25cIil9dmFyIG89dGhpczt2YXIgY2I9ZnVuY3Rpb24oKXtyZXR1cm4gbi5hcHBseShvLGFyZ3VtZW50cyl9O3IuYXBwbHkodGhpcyxlKS50aGVuKChmdW5jdGlvbihyKXtwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCxudWxsLHIpKX0pLChmdW5jdGlvbihyKXtwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZC5iaW5kKG51bGwscixjYikpfSkpfU9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLE9iamVjdC5nZXRQcm90b3R5cGVPZihyKSk7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxuKHIpKTtyZXR1cm4gY2FsbGJhY2tpZmllZH1lLmNhbGxiYWNraWZ5PWNhbGxiYWNraWZ5fSw3Mjg6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoOTgxKTt2YXIgbz10KDM4Mik7dmFyIGk9dCgxNzEpO3ZhciBhPWkoXCJPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXCIpO3ZhciBmPXQoNTY3KSgpO3ZhciB1PWYmJnR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PT1cInN5bWJvbFwiO3ZhciBzPW8oKTt2YXIgYz1pKFwiU3RyaW5nLnByb3RvdHlwZS5zbGljZVwiKTt2YXIgeT17fTt2YXIgcD10KDMwKTt2YXIgbD1PYmplY3QuZ2V0UHJvdG90eXBlT2Y7aWYodSYmcCYmbCl7bihzLChmdW5jdGlvbihyKXtpZih0eXBlb2YgZ2xvYmFsW3JdPT09XCJmdW5jdGlvblwiKXt2YXIgZT1uZXcgZ2xvYmFsW3JdO2lmKCEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGUpKXt0aHJvdyBuZXcgRXZhbEVycm9yKFwidGhpcyBlbmdpbmUgaGFzIHN1cHBvcnQgZm9yIFN5bWJvbC50b1N0cmluZ1RhZywgYnV0IFwiK3IrXCIgZG9lcyBub3QgaGF2ZSB0aGUgcHJvcGVydHkhIFBsZWFzZSByZXBvcnQgdGhpcy5cIil9dmFyIHQ9bChlKTt2YXIgbj1wKHQsU3ltYm9sLnRvU3RyaW5nVGFnKTtpZighbil7dmFyIG89bCh0KTtuPXAobyxTeW1ib2wudG9TdHJpbmdUYWcpfXlbcl09bi5nZXR9fSkpfXZhciBnPWZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHIpe3ZhciBlPWZhbHNlO24oeSwoZnVuY3Rpb24odCxuKXtpZighZSl7dHJ5e3ZhciBvPXQuY2FsbChyKTtpZihvPT09bil7ZT1vfX1jYXRjaChyKXt9fX0pKTtyZXR1cm4gZX07dmFyIGQ9dCgzODcpO3IuZXhwb3J0cz1mdW5jdGlvbiB3aGljaFR5cGVkQXJyYXkocil7aWYoIWQocikpe3JldHVybiBmYWxzZX1pZighdSl7cmV0dXJuIGMoYShyKSw4LC0xKX1yZXR1cm4gZyhyKX19LDM4MjpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCg5OTcpO3IuZXhwb3J0cz1mdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5cygpe3JldHVybiBuKFtcIkJpZ0ludDY0QXJyYXlcIixcIkJpZ1VpbnQ2NEFycmF5XCIsXCJGbG9hdDMyQXJyYXlcIixcIkZsb2F0NjRBcnJheVwiLFwiSW50MTZBcnJheVwiLFwiSW50MzJBcnJheVwiLFwiSW50OEFycmF5XCIsXCJVaW50MTZBcnJheVwiLFwiVWludDMyQXJyYXlcIixcIlVpbnQ4QXJyYXlcIixcIlVpbnQ4Q2xhbXBlZEFycmF5XCJdLChmdW5jdGlvbihyKXtyZXR1cm4gdHlwZW9mIGdsb2JhbFtyXT09PVwiZnVuY3Rpb25cIn0pKX19LDMwOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KDYyNyk7dmFyIG89bihcIiVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJVwiLHRydWUpO2lmKG8pe3RyeXtvKFtdLFwibGVuZ3RoXCIpfWNhdGNoKHIpe289bnVsbH19ci5leHBvcnRzPW99fTt2YXIgZT17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPWVbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgbz1lW3RdPXtleHBvcnRzOnt9fTt2YXIgaT10cnVlO3RyeXtyW3RdKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2k9ZmFsc2V9ZmluYWxseXtpZihpKWRlbGV0ZSBlW3RdfXJldHVybiBvLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNDY3KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOlsiciIsImV4cG9ydHMiLCJ0IiwibiIsImZpbHRlciIsIlR5cGVFcnJvciIsIm8iLCJpIiwibGVuZ3RoIiwiZSIsImNhbGwiLCJhIiwicHVzaCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbEJvdW5kSW50cmluc2ljIiwiZiIsInUiLCJzIiwiYyIsInZhbHVlIiwiY2FsbEJpbmQiLCJhcmd1bWVudHMiLCJjb25maWd1cmFibGUiLCJ5IiwiYXBwbHlCaW5kIiwiYXBwbHkiLCJ0b1N0cmluZyIsImZvckVhY2giLCJBcnJheSIsInNsaWNlIiwiYmluZCIsImJpbmRlciIsImNvbmNhdCIsIk1hdGgiLCJtYXgiLCJGdW5jdGlvbiIsImpvaW4iLCJFbXB0eSIsIlN5bnRheEVycm9yIiwiZ2V0RXZhbGxlZENvbnN0cnVjdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidGhyb3dUeXBlRXJyb3IiLCJjYWxsZWUiLCJnZXQiLCJnZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsInAiLCJVaW50OEFycmF5IiwibCIsIkFnZ3JlZ2F0ZUVycm9yIiwiQXJyYXlCdWZmZXIiLCJTeW1ib2wiLCJpdGVyYXRvciIsIkF0b21pY3MiLCJCaWdJbnQiLCJCb29sZWFuIiwiRGF0YVZpZXciLCJEYXRlIiwiZGVjb2RlVVJJIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZW5jb2RlVVJJIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiRXJyb3IiLCJldmFsIiwiRXZhbEVycm9yIiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsImlzRmluaXRlIiwiaXNOYU4iLCJKU09OIiwiTWFwIiwiTnVtYmVyIiwicGFyc2VGbG9hdCIsInBhcnNlSW50IiwiUHJvbWlzZSIsIlByb3h5IiwiUmFuZ2VFcnJvciIsIlJlZmVyZW5jZUVycm9yIiwiUmVmbGVjdCIsIlJlZ0V4cCIsIlNldCIsIlNoYXJlZEFycmF5QnVmZmVyIiwiU3RyaW5nIiwiVWludDhDbGFtcGVkQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiVVJJRXJyb3IiLCJXZWFrTWFwIiwiV2Vha1JlZiIsIldlYWtTZXQiLCJnIiwiZG9FdmFsIiwiZCIsInYiLCJiIiwiQSIsIm0iLCJzcGxpY2UiLCJTIiwicmVwbGFjZSIsImgiLCJPIiwidyIsImoiLCJzdHJpbmdUb1BhdGgiLCJQIiwiZ2V0QmFzZUludHJpbnNpYyIsImFsaWFzIiwibmFtZSIsIkdldEludHJpbnNpYyIsImhhc05hdGl2ZVN5bWJvbHMiLCJoYXNTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwia2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImVudW1lcmFibGUiLCJjcmVhdGUiLCJpbmhlcml0cyIsInN1cGVyXyIsImNvbnN0cnVjdG9yIiwid3JpdGFibGUiLCJUZW1wQ3RvciIsInRvU3RyaW5nVGFnIiwiaXNBcmd1bWVudHMiLCJpc0xlZ2FjeUFyZ3VtZW50cyIsImdldEdlbmVyYXRvckZ1bmMiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwidGVzdCIsImluZGV4T2YiLCJnbG9iYWwiLCJ0cnlBbGxUeXBlZEFycmF5cyIsImlzVHlwZWRBcnJheSIsImlzQnVmZmVyIiwiQnVmZmVyIiwidW5jdXJyeVRoaXMiLCJ2YWx1ZU9mIiwiY2hlY2tCb3hlZFByaW1pdGl2ZSIsImlzQXJndW1lbnRzT2JqZWN0IiwiaXNQcm9taXNlIiwidGhlbiIsImNhdGNoIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJpc1ZpZXciLCJpc0RhdGFWaWV3IiwiaXNVaW50OEFycmF5IiwiaXNVaW50OENsYW1wZWRBcnJheSIsImlzVWludDE2QXJyYXkiLCJpc1VpbnQzMkFycmF5IiwiaXNJbnQ4QXJyYXkiLCJpc0ludDE2QXJyYXkiLCJpc0ludDMyQXJyYXkiLCJpc0Zsb2F0MzJBcnJheSIsImlzRmxvYXQ2NEFycmF5IiwiaXNCaWdJbnQ2NEFycmF5IiwiaXNCaWdVaW50NjRBcnJheSIsImlzTWFwVG9TdHJpbmciLCJ3b3JraW5nIiwiaXNNYXAiLCJpc1NldFRvU3RyaW5nIiwiaXNTZXQiLCJpc1dlYWtNYXBUb1N0cmluZyIsImlzV2Vha01hcCIsImlzV2Vha1NldFRvU3RyaW5nIiwiaXNXZWFrU2V0IiwiaXNBcnJheUJ1ZmZlclRvU3RyaW5nIiwiaXNBcnJheUJ1ZmZlciIsImlzRGF0YVZpZXdUb1N0cmluZyIsInVuZGVmaW5lZCIsImlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyIsImlzU2hhcmVkQXJyYXlCdWZmZXIiLCJpc0FzeW5jRnVuY3Rpb24iLCJpc01hcEl0ZXJhdG9yIiwiaXNTZXRJdGVyYXRvciIsImlzR2VuZXJhdG9yT2JqZWN0IiwiaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlIiwiaXNOdW1iZXJPYmplY3QiLCJpc1N0cmluZ09iamVjdCIsImlzQm9vbGVhbk9iamVjdCIsImlzQmlnSW50T2JqZWN0IiwiaXNTeW1ib2xPYmplY3QiLCJpc0JveGVkUHJpbWl0aXZlIiwiaXNBbnlBcnJheUJ1ZmZlciIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImZvcm1hdCIsImlzU3RyaW5nIiwiaW5zcGVjdCIsInN0cmluZ2lmeSIsImlzTnVsbCIsImlzT2JqZWN0IiwiZGVwcmVjYXRlIiwicHJvY2VzcyIsIm5vRGVwcmVjYXRpb24iLCJkZXByZWNhdGVkIiwidGhyb3dEZXByZWNhdGlvbiIsInRyYWNlRGVwcmVjYXRpb24iLCJjb25zb2xlIiwidHJhY2UiLCJlcnJvciIsImVudiIsIk5PREVfREVCVUciLCJ0b1VwcGVyQ2FzZSIsImRlYnVnbG9nIiwicGlkIiwic2VlbiIsInN0eWxpemUiLCJzdHlsaXplTm9Db2xvciIsImRlcHRoIiwiY29sb3JzIiwiaXNCb29sZWFuIiwic2hvd0hpZGRlbiIsIl9leHRlbmQiLCJpc1VuZGVmaW5lZCIsImN1c3RvbUluc3BlY3QiLCJzdHlsaXplV2l0aENvbG9yIiwiZm9ybWF0VmFsdWUiLCJib2xkIiwiaXRhbGljIiwidW5kZXJsaW5lIiwiaW52ZXJzZSIsIndoaXRlIiwiZ3JleSIsImJsYWNrIiwiYmx1ZSIsImN5YW4iLCJncmVlbiIsIm1hZ2VudGEiLCJyZWQiLCJ5ZWxsb3ciLCJzdHlsZXMiLCJzcGVjaWFsIiwibnVtYmVyIiwiYm9vbGVhbiIsIm51bGwiLCJzdHJpbmciLCJkYXRlIiwicmVnZXhwIiwiYXJyYXlUb0hhc2giLCJpc0Z1bmN0aW9uIiwiZm9ybWF0UHJpbWl0aXZlIiwiaXNFcnJvciIsImZvcm1hdEVycm9yIiwiaXNSZWdFeHAiLCJpc0RhdGUiLCJpc0FycmF5IiwidG9VVENTdHJpbmciLCJmb3JtYXRBcnJheSIsIm1hcCIsImZvcm1hdFByb3BlcnR5IiwicG9wIiwicmVkdWNlVG9TaW5nbGVTdHJpbmciLCJpc051bWJlciIsIm1hdGNoIiwic2V0Iiwic3BsaXQiLCJzdWJzdHIiLCJyZWR1Y2UiLCJ0eXBlcyIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNTeW1ib2wiLCJvYmplY3RUb1N0cmluZyIsImlzTmF0aXZlRXJyb3IiLCJpc1ByaW1pdGl2ZSIsInBhZCIsInRpbWVzdGFtcCIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJsb2ciLCJwcm9taXNpZnkiLCJzZXRQcm90b3R5cGVPZiIsImRlZmluZVByb3BlcnRpZXMiLCJjdXN0b20iLCJjYWxsYmFja2lmeU9uUmVqZWN0ZWQiLCJyZWFzb24iLCJjYWxsYmFja2lmeSIsImNhbGxiYWNraWZpZWQiLCJjYiIsIm5leHRUaWNrIiwid2hpY2hUeXBlZEFycmF5IiwiYXZhaWxhYmxlVHlwZWRBcnJheXMiLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/util/util.js\n"));

/***/ }),

/***/ "./node_modules/next/image.js":
/*!************************************!*\
  !*** ./node_modules/next/image.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/image */ \"./node_modules/next/dist/client/image.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQUEsMkdBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvaW1hZ2UuanM/MDUzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGllbnQvaW1hZ2UnKVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/image.js\n"));

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/link */ \"./node_modules/next/dist/client/link.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBQSx5R0FBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzPzc1YjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/link.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/** @license React v17.0.2\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nif (true) {\n  (function () {\n    'use strict';\n\n    var React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n    var _assign = __webpack_require__(/*! object-assign */ \"./node_modules/next/dist/build/polyfills/object-assign.js\"); // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n\n    var REACT_ELEMENT_TYPE = 0xeac7;\n    var REACT_PORTAL_TYPE = 0xeaca;\n    exports.Fragment = 0xeacb;\n    var REACT_STRICT_MODE_TYPE = 0xeacc;\n    var REACT_PROFILER_TYPE = 0xead2;\n    var REACT_PROVIDER_TYPE = 0xeacd;\n    var REACT_CONTEXT_TYPE = 0xeace;\n    var REACT_FORWARD_REF_TYPE = 0xead0;\n    var REACT_SUSPENSE_TYPE = 0xead1;\n    var REACT_SUSPENSE_LIST_TYPE = 0xead8;\n    var REACT_MEMO_TYPE = 0xead3;\n    var REACT_LAZY_TYPE = 0xead4;\n    var REACT_BLOCK_TYPE = 0xead9;\n    var REACT_SERVER_BLOCK_TYPE = 0xeada;\n    var REACT_FUNDAMENTAL_TYPE = 0xead5;\n    var REACT_SCOPE_TYPE = 0xead7;\n    var REACT_OPAQUE_ID_TYPE = 0xeae0;\n    var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\n    var REACT_OFFSCREEN_TYPE = 0xeae2;\n    var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\n\n    if (typeof Symbol === 'function' && Symbol.for) {\n      var symbolFor = Symbol.for;\n      REACT_ELEMENT_TYPE = symbolFor('react.element');\n      REACT_PORTAL_TYPE = symbolFor('react.portal');\n      exports.Fragment = symbolFor('react.fragment');\n      REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\n      REACT_PROFILER_TYPE = symbolFor('react.profiler');\n      REACT_PROVIDER_TYPE = symbolFor('react.provider');\n      REACT_CONTEXT_TYPE = symbolFor('react.context');\n      REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n      REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\n      REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\n      REACT_MEMO_TYPE = symbolFor('react.memo');\n      REACT_LAZY_TYPE = symbolFor('react.lazy');\n      REACT_BLOCK_TYPE = symbolFor('react.block');\n      REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');\n      REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');\n      REACT_SCOPE_TYPE = symbolFor('react.scope');\n      REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');\n      REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\n      REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\n      REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\n    }\n\n    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable !== 'object') {\n        return null;\n      }\n\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n\n      return null;\n    }\n\n    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n    function error(format) {\n      {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        printWarning('error', format, args);\n      }\n    }\n\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        }\n\n        var argsWithFormat = args.map(function (item) {\n          return '' + item;\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    } // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.\n\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n      if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {\n        return true;\n      }\n\n      if (typeof type === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var functionName = innerType.displayName || innerType.name || '';\n      return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n    }\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    }\n\n    function getComponentName(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      switch (type) {\n        case exports.Fragment:\n          return 'Fragment';\n\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n\n        case REACT_PROFILER_TYPE:\n          return 'Profiler';\n\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n\n        case REACT_SUSPENSE_TYPE:\n          return 'Suspense';\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return 'SuspenseList';\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n\n          case REACT_MEMO_TYPE:\n            return getComponentName(type.type);\n\n          case REACT_BLOCK_TYPE:\n            return getComponentName(type._render);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                return getComponentName(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n        }\n      }\n\n      return null;\n    } // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n\n\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n\n    function disabledLog() {}\n\n    disabledLog.__reactDisabledLog = true;\n\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        disabledDepth++;\n      }\n    }\n\n    function reenableLogs() {\n      {\n        disabledDepth--;\n\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: _assign({}, props, {\n              value: prevLog\n            }),\n            info: _assign({}, props, {\n              value: prevInfo\n            }),\n            warn: _assign({}, props, {\n              value: prevWarn\n            }),\n            error: _assign({}, props, {\n              value: prevError\n            }),\n            group: _assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: _assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: _assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n\n    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n        return '\\n' + prefix + name;\n      }\n    }\n\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n\n      {\n        var frame = componentFrameCache.get(fn);\n\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher.current = null;\n        disableLogs();\n      }\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\n\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame('Suspense');\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n          case REACT_BLOCK_TYPE:\n            return describeFunctionComponentFrame(type._render);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n\n      return '';\n    }\n\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n              setCurrentlyValidatingElement(null);\n            }\n\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n\n    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown;\n    var specialPropRefWarningShown;\n    var didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n\n    function warnIfStringRefCannotBeAutoConverted(config, self) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n          var componentName = getComponentName(ReactCurrentOwner.current.type);\n\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n\n    function defineKeyPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingKey = function () {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingKey.isReactWarning = true;\n        Object.defineProperty(props, 'key', {\n          get: warnAboutAccessingKey,\n          configurable: true\n        });\n      }\n    }\n\n    function defineRefPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingRef = function () {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingRef.isReactWarning = true;\n        Object.defineProperty(props, 'ref', {\n          get: warnAboutAccessingRef,\n          configurable: true\n        });\n      }\n    }\n    /**\n     * Factory method to create a new React element. This no longer adheres to\n     * the class pattern, so do not use new to call it. Also, instanceof check\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n     * if something is a React Element.\n     *\n     * @param {*} type\n     * @param {*} props\n     * @param {*} key\n     * @param {string|object} ref\n     * @param {*} owner\n     * @param {*} self A *temporary* helper to detect places where `this` is\n     * different from the `owner` when React.createElement is called, so that we\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n     * functions, and as long as `this` and owner are the same, there will be no\n     * change in behavior.\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\n     * indicating filename, line number, and/or other information.\n     * @internal\n     */\n\n\n    var ReactElement = function (type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\n     * https://github.com/reactjs/rfcs/pull/107\n     * @param {*} type\n     * @param {object} props\n     * @param {string} key\n     */\n\n\n    function jsxDEV(type, config, maybeKey, source, self) {\n      {\n        var propName; // Reserved names are extracted\n\n        var props = {};\n        var key = null;\n        var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n        // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n        // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n        // but as an intermediary step, we will use jsxDEV for everything except\n        // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n        // key is explicitly declared to be undefined or not.\n\n        if (maybeKey !== undefined) {\n          key = '' + maybeKey;\n        }\n\n        if (hasValidKey(config)) {\n          key = '' + config.key;\n        }\n\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          warnIfStringRefCannotBeAutoConverted(config, self);\n        } // Remaining properties are added to a new props object\n\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        } // Resolve default props\n\n\n        if (type && type.defaultProps) {\n          var defaultProps = type.defaultProps;\n\n          for (propName in defaultProps) {\n            if (props[propName] === undefined) {\n              props[propName] = defaultProps[propName];\n            }\n          }\n        }\n\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n\n        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n      }\n    }\n\n    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n    /**\n     * Verifies the object is a ReactElement.\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\n     * @param {?object} object\n     * @return {boolean} True if `object` is a ReactElement.\n     * @final\n     */\n\n    function isValidElement(object) {\n      {\n        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n      }\n    }\n\n    function getDeclarationErrorAddendum() {\n      {\n        if (ReactCurrentOwner$1.current) {\n          var name = getComponentName(ReactCurrentOwner$1.current.type);\n\n          if (name) {\n            return '\\n\\nCheck the render method of `' + name + '`.';\n          }\n        }\n\n        return '';\n      }\n    }\n\n    function getSourceInfoErrorAddendum(source) {\n      {\n        if (source !== undefined) {\n          var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n          var lineNumber = source.lineNumber;\n          return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n        }\n\n        return '';\n      }\n    }\n    /**\n     * Warn if there's no key explicitly set on dynamic arrays of children or\n     * object keys are not valid. This allows us to keep track of children between\n     * updates.\n     */\n\n\n    var ownerHasKeyUseWarning = {};\n\n    function getCurrentComponentErrorInfo(parentType) {\n      {\n        var info = getDeclarationErrorAddendum();\n\n        if (!info) {\n          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n          if (parentName) {\n            info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n          }\n        }\n\n        return info;\n      }\n    }\n    /**\n     * Warn if the element doesn't have an explicit key assigned to it.\n     * This element is in an array. The array could grow and shrink or be\n     * reordered. All children that haven't already been validated are required to\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n     * will only be shown once.\n     *\n     * @internal\n     * @param {ReactElement} element Element that requires a key.\n     * @param {*} parentType element's parent's type.\n     */\n\n\n    function validateExplicitKey(element, parentType) {\n      {\n        if (!element._store || element._store.validated || element.key != null) {\n          return;\n        }\n\n        element._store.validated = true;\n        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n          return;\n        }\n\n        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n        // property, it may be the creator of the child that's responsible for\n        // assigning it a key.\n\n        var childOwner = '';\n\n        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n          // Give the component that originally created this child.\n          childOwner = \" It was passed a child from \" + getComponentName(element._owner.type) + \".\";\n        }\n\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\n     * Ensure that every element either is passed in a static location, in an\n     * array with an explicit keys property defined, or in an object literal\n     * with valid key property.\n     *\n     * @internal\n     * @param {ReactNode} node Statically passed child of any type.\n     * @param {*} parentType node's parent's type.\n     */\n\n\n    function validateChildKeys(node, parentType) {\n      {\n        if (typeof node !== 'object') {\n          return;\n        }\n\n        if (Array.isArray(node)) {\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n\n            if (isValidElement(child)) {\n              validateExplicitKey(child, parentType);\n            }\n          }\n        } else if (isValidElement(node)) {\n          // This element was passed in a valid location.\n          if (node._store) {\n            node._store.validated = true;\n          }\n        } else if (node) {\n          var iteratorFn = getIteratorFn(node);\n\n          if (typeof iteratorFn === 'function') {\n            // Entry iterators used to provide implicit keys,\n            // but now we print a separate warning for them later.\n            if (iteratorFn !== node.entries) {\n              var iterator = iteratorFn.call(node);\n              var step;\n\n              while (!(step = iterator.next()).done) {\n                if (isValidElement(step.value)) {\n                  validateExplicitKey(step.value, parentType);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Given an element, validate that its props follow the propTypes definition,\n     * provided by the type.\n     *\n     * @param {ReactElement} element\n     */\n\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n\n        var propTypes;\n\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentName(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentName(type);\n\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\n     * Given a fragment, validate that it can only be provided with fragment props\n     * @param {ReactElement} fragment\n     */\n\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n\n    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n      {\n        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n        // succeed and there will likely be errors in render.\n\n        if (!validType) {\n          var info = '';\n\n          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n            info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n          }\n\n          var sourceInfo = getSourceInfoErrorAddendum(source);\n\n          if (sourceInfo) {\n            info += sourceInfo;\n          } else {\n            info += getDeclarationErrorAddendum();\n          }\n\n          var typeString;\n\n          if (type === null) {\n            typeString = 'null';\n          } else if (Array.isArray(type)) {\n            typeString = 'array';\n          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n            typeString = \"<\" + (getComponentName(type.type) || 'Unknown') + \" />\";\n            info = ' Did you accidentally export a JSX literal instead of a component?';\n          } else {\n            typeString = typeof type;\n          }\n\n          error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n\n        var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n        // TODO: Drop this when these are no longer allowed as the type argument.\n\n        if (element == null) {\n          return element;\n        } // Skip key warning if the type isn't valid since our key validation logic\n        // doesn't expect a non-string/function type and can throw confusing errors.\n        // We don't want exception behavior to differ between dev and prod.\n        // (Rendering will throw with a helpful message and as soon as the type is\n        // fixed, the key warnings will appear.)\n\n\n        if (validType) {\n          var children = props.children;\n\n          if (children !== undefined) {\n            if (isStaticChildren) {\n              if (Array.isArray(children)) {\n                for (var i = 0; i < children.length; i++) {\n                  validateChildKeys(children[i], type);\n                }\n\n                if (Object.freeze) {\n                  Object.freeze(children);\n                }\n              } else {\n                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n              }\n            } else {\n              validateChildKeys(children, type);\n            }\n          }\n        }\n\n        if (type === exports.Fragment) {\n          validateFragmentProps(element);\n        } else {\n          validatePropTypes(element);\n        }\n\n        return element;\n      }\n    } // These two functions exist to still get child warnings in dev\n\n\n    var jsxDEV$1 = jsxWithValidation;\n    exports.jsxDEV = jsxDEV$1;\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRWE7O0FBRWIsSUFBSUEsSUFBSixFQUEyQztFQUN6QyxDQUFDLFlBQVc7SUFDZDs7SUFFQSxJQUFJRyxLQUFLLEdBQUdDLG1CQUFPLENBQUMsNENBQUQsQ0FBbkI7O0lBQ0EsSUFBSUMsT0FBTyxHQUFHRCxtQkFBTyxDQUFDLGdGQUFELENBQXJCLENBSmMsQ0FNZDtJQUNBO0lBQ0E7SUFDQTtJQUNBOzs7SUFDQSxJQUFJRSxrQkFBa0IsR0FBRyxNQUF6QjtJQUNBLElBQUlDLGlCQUFpQixHQUFHLE1BQXhCO0lBQ0FDLGdCQUFBLEdBQW1CLE1BQW5CO0lBQ0EsSUFBSUUsc0JBQXNCLEdBQUcsTUFBN0I7SUFDQSxJQUFJQyxtQkFBbUIsR0FBRyxNQUExQjtJQUNBLElBQUlDLG1CQUFtQixHQUFHLE1BQTFCO0lBQ0EsSUFBSUMsa0JBQWtCLEdBQUcsTUFBekI7SUFDQSxJQUFJQyxzQkFBc0IsR0FBRyxNQUE3QjtJQUNBLElBQUlDLG1CQUFtQixHQUFHLE1BQTFCO0lBQ0EsSUFBSUMsd0JBQXdCLEdBQUcsTUFBL0I7SUFDQSxJQUFJQyxlQUFlLEdBQUcsTUFBdEI7SUFDQSxJQUFJQyxlQUFlLEdBQUcsTUFBdEI7SUFDQSxJQUFJQyxnQkFBZ0IsR0FBRyxNQUF2QjtJQUNBLElBQUlDLHVCQUF1QixHQUFHLE1BQTlCO0lBQ0EsSUFBSUMsc0JBQXNCLEdBQUcsTUFBN0I7SUFDQSxJQUFJQyxnQkFBZ0IsR0FBRyxNQUF2QjtJQUNBLElBQUlDLG9CQUFvQixHQUFHLE1BQTNCO0lBQ0EsSUFBSUMsNkJBQTZCLEdBQUcsTUFBcEM7SUFDQSxJQUFJQyxvQkFBb0IsR0FBRyxNQUEzQjtJQUNBLElBQUlDLHdCQUF3QixHQUFHLE1BQS9COztJQUVBLElBQUksT0FBT0Ms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Q0FBRCxDQUFULEVBQWNoSyxJQUFkLENBQWpCO2dCQUNEOztnQkFFRCxJQUFJNkMsTUFBTSxDQUFDeUYsTUFBWCxFQUFtQjtrQkFDakJ6RixNQUFNLENBQUN5RixNQUFQLENBQWMrQyxRQUFkO2dCQUNEO2NBQ0YsQ0FSRCxNQVFPO2dCQUNMOU0sS0FBSyxDQUFDLDJEQUEyRCxnRUFBM0QsR0FBOEgsa0NBQS9ILENBQUw7Y0FDRDtZQUNGLENBWkQsTUFZTztjQUNMc0wsaUJBQWlCLENBQUN3QixRQUFELEVBQVdyTCxJQUFYLENBQWpCO1lBQ0Q7VUFDRjtRQUNGOztRQUVELElBQUlBLElBQUksS0FBS3ZELE9BQU8sQ0FBQ0MsUUFBckIsRUFBK0I7VUFDN0JtTyxxQkFBcUIsQ0FBQ2pGLE9BQUQsQ0FBckI7UUFDRCxDQUZELE1BRU87VUFDTDJFLGlCQUFpQixDQUFDM0UsT0FBRCxDQUFqQjtRQUNEOztRQUVELE9BQU9BLE9BQVA7TUFDRDtJQUNGLENBaHFDYSxDQWdxQ1o7OztJQUVGLElBQUkwRixRQUFRLEdBQUlOLGlCQUFoQjtJQUVBdk8sY0FBQSxHQUFpQjZPLFFBQWpCO0VBQ0csQ0FycUNEO0FBc3FDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz8xN2UxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG5leHBvcnRzLkZyYWdtZW50ID0gMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBleHBvcnRzLkZyYWdtZW50ID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50IHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSB8fCB0eXBlWzBdID09PSBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLkZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcblxudmFyIGpzeERFViQxID0gIGpzeFdpdGhWYWxpZGF0aW9uIDtcblxuZXhwb3J0cy5qc3hERVYgPSBqc3hERVYkMTtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJSZWFjdCIsInJlcXVpcmUiLCJfYXNzaWduIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJleHBvcnRzIiwiRnJhZ21lbnQiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX0JMT0NLX1RZUEUiLCJSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSIsIlJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUiLCJSRUFDVF9TQ09QRV9UWVBFIiwiUkVBQ1RfT1BBUVVFX0lEX1RZUEUiLCJSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIiwiU3ltYm9sIiwiZm9yIiwic3ltYm9sRm9yIiwiTUFZQkVfSVRFUkFUT1JfU1lNQk9MIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwibWF5YmVJdGVyYXRvciIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJlcnJvciIsImZvcm1hdCIsIl9sZW4yIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleTIiLCJwcmludFdhcm5pbmciLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJzdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiZW5hYmxlU2NvcGVBUEkiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZnVuY3Rpb25OYW1lIiwiZGlzcGxheU5hbWUiLCJuYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lIiwidGFnIiwiY29udGV4dCIsInByb3ZpZGVyIiwiX2NvbnRleHQiLCJyZW5kZXIiLCJfcmVuZGVyIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJ1bmRlZmluZWQiLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwiY29udHJvbCIsInByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsImN1cnJlbnQiLCJGYWtlIiwiZGVmaW5lUHJvcGVydHkiLCJzZXQiLCJSZWZsZWN0Iiwic2FtcGxlIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiX2ZyYW1lIiwicmVwbGFjZSIsInN5bnRoZXRpY0ZyYW1lIiwiZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lIiwic2hvdWxkQ29uc3RydWN0IiwiQ29tcG9uZW50IiwiaXNSZWFjdENvbXBvbmVudCIsImRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFViIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50IiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsImhhc093blByb3BlcnR5IiwidHlwZVNwZWNOYW1lIiwiZXJyb3IkMSIsImVyciIsImV4IiwibWVzc2FnZSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYiLCJtYXliZUtleSIsInByb3BOYW1lIiwiZGVmYXVsdFByb3BzIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpc0FycmF5IiwiaSIsImNoaWxkIiwiaXRlcmF0b3JGbiIsImVudHJpZXMiLCJzdGVwIiwibmV4dCIsImRvbmUiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsIl9uYW1lIiwiZ2V0RGVmYXVsdFByb3BzIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJmcmFnbWVudCIsImtleXMiLCJqc3hXaXRoVmFsaWRhdGlvbiIsImlzU3RhdGljQ2hpbGRyZW4iLCJ2YWxpZFR5cGUiLCJzb3VyY2VJbmZvIiwidHlwZVN0cmluZyIsImNoaWxkcmVuIiwianN4REVWJDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/** @license React v17.0.2\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nif (true) {\n  (function () {\n    'use strict';\n\n    var React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n    var _assign = __webpack_require__(/*! object-assign */ \"./node_modules/next/dist/build/polyfills/object-assign.js\"); // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n\n    var REACT_ELEMENT_TYPE = 0xeac7;\n    var REACT_PORTAL_TYPE = 0xeaca;\n    exports.Fragment = 0xeacb;\n    var REACT_STRICT_MODE_TYPE = 0xeacc;\n    var REACT_PROFILER_TYPE = 0xead2;\n    var REACT_PROVIDER_TYPE = 0xeacd;\n    var REACT_CONTEXT_TYPE = 0xeace;\n    var REACT_FORWARD_REF_TYPE = 0xead0;\n    var REACT_SUSPENSE_TYPE = 0xead1;\n    var REACT_SUSPENSE_LIST_TYPE = 0xead8;\n    var REACT_MEMO_TYPE = 0xead3;\n    var REACT_LAZY_TYPE = 0xead4;\n    var REACT_BLOCK_TYPE = 0xead9;\n    var REACT_SERVER_BLOCK_TYPE = 0xeada;\n    var REACT_FUNDAMENTAL_TYPE = 0xead5;\n    var REACT_SCOPE_TYPE = 0xead7;\n    var REACT_OPAQUE_ID_TYPE = 0xeae0;\n    var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\n    var REACT_OFFSCREEN_TYPE = 0xeae2;\n    var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\n\n    if (typeof Symbol === 'function' && Symbol.for) {\n      var symbolFor = Symbol.for;\n      REACT_ELEMENT_TYPE = symbolFor('react.element');\n      REACT_PORTAL_TYPE = symbolFor('react.portal');\n      exports.Fragment = symbolFor('react.fragment');\n      REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\n      REACT_PROFILER_TYPE = symbolFor('react.profiler');\n      REACT_PROVIDER_TYPE = symbolFor('react.provider');\n      REACT_CONTEXT_TYPE = symbolFor('react.context');\n      REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n      REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\n      REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\n      REACT_MEMO_TYPE = symbolFor('react.memo');\n      REACT_LAZY_TYPE = symbolFor('react.lazy');\n      REACT_BLOCK_TYPE = symbolFor('react.block');\n      REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');\n      REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');\n      REACT_SCOPE_TYPE = symbolFor('react.scope');\n      REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');\n      REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\n      REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\n      REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\n    }\n\n    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable !== 'object') {\n        return null;\n      }\n\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n\n      return null;\n    }\n\n    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n    function error(format) {\n      {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        printWarning('error', format, args);\n      }\n    }\n\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        }\n\n        var argsWithFormat = args.map(function (item) {\n          return '' + item;\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    } // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.\n\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n      if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {\n        return true;\n      }\n\n      if (typeof type === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var functionName = innerType.displayName || innerType.name || '';\n      return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n    }\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    }\n\n    function getComponentName(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      switch (type) {\n        case exports.Fragment:\n          return 'Fragment';\n\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n\n        case REACT_PROFILER_TYPE:\n          return 'Profiler';\n\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n\n        case REACT_SUSPENSE_TYPE:\n          return 'Suspense';\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return 'SuspenseList';\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n\n          case REACT_MEMO_TYPE:\n            return getComponentName(type.type);\n\n          case REACT_BLOCK_TYPE:\n            return getComponentName(type._render);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                return getComponentName(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n        }\n      }\n\n      return null;\n    } // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n\n\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n\n    function disabledLog() {}\n\n    disabledLog.__reactDisabledLog = true;\n\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        disabledDepth++;\n      }\n    }\n\n    function reenableLogs() {\n      {\n        disabledDepth--;\n\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: _assign({}, props, {\n              value: prevLog\n            }),\n            info: _assign({}, props, {\n              value: prevInfo\n            }),\n            warn: _assign({}, props, {\n              value: prevWarn\n            }),\n            error: _assign({}, props, {\n              value: prevError\n            }),\n            group: _assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: _assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: _assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n\n    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n        return '\\n' + prefix + name;\n      }\n    }\n\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n\n      {\n        var frame = componentFrameCache.get(fn);\n\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher.current = null;\n        disableLogs();\n      }\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\n\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame('Suspense');\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n          case REACT_BLOCK_TYPE:\n            return describeFunctionComponentFrame(type._render);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n\n      return '';\n    }\n\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n              setCurrentlyValidatingElement(null);\n            }\n\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n\n    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown;\n    var specialPropRefWarningShown;\n    var didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n\n    function warnIfStringRefCannotBeAutoConverted(config, self) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n          var componentName = getComponentName(ReactCurrentOwner.current.type);\n\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n\n    function defineKeyPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingKey = function () {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingKey.isReactWarning = true;\n        Object.defineProperty(props, 'key', {\n          get: warnAboutAccessingKey,\n          configurable: true\n        });\n      }\n    }\n\n    function defineRefPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingRef = function () {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingRef.isReactWarning = true;\n        Object.defineProperty(props, 'ref', {\n          get: warnAboutAccessingRef,\n          configurable: true\n        });\n      }\n    }\n    /**\n     * Factory method to create a new React element. This no longer adheres to\n     * the class pattern, so do not use new to call it. Also, instanceof check\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n     * if something is a React Element.\n     *\n     * @param {*} type\n     * @param {*} props\n     * @param {*} key\n     * @param {string|object} ref\n     * @param {*} owner\n     * @param {*} self A *temporary* helper to detect places where `this` is\n     * different from the `owner` when React.createElement is called, so that we\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n     * functions, and as long as `this` and owner are the same, there will be no\n     * change in behavior.\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\n     * indicating filename, line number, and/or other information.\n     * @internal\n     */\n\n\n    var ReactElement = function (type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\n     * https://github.com/reactjs/rfcs/pull/107\n     * @param {*} type\n     * @param {object} props\n     * @param {string} key\n     */\n\n\n    function jsxDEV(type, config, maybeKey, source, self) {\n      {\n        var propName; // Reserved names are extracted\n\n        var props = {};\n        var key = null;\n        var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n        // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n        // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n        // but as an intermediary step, we will use jsxDEV for everything except\n        // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n        // key is explicitly declared to be undefined or not.\n\n        if (maybeKey !== undefined) {\n          key = '' + maybeKey;\n        }\n\n        if (hasValidKey(config)) {\n          key = '' + config.key;\n        }\n\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          warnIfStringRefCannotBeAutoConverted(config, self);\n        } // Remaining properties are added to a new props object\n\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        } // Resolve default props\n\n\n        if (type && type.defaultProps) {\n          var defaultProps = type.defaultProps;\n\n          for (propName in defaultProps) {\n            if (props[propName] === undefined) {\n              props[propName] = defaultProps[propName];\n            }\n          }\n        }\n\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n\n        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n      }\n    }\n\n    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n    /**\n     * Verifies the object is a ReactElement.\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\n     * @param {?object} object\n     * @return {boolean} True if `object` is a ReactElement.\n     * @final\n     */\n\n    function isValidElement(object) {\n      {\n        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n      }\n    }\n\n    function getDeclarationErrorAddendum() {\n      {\n        if (ReactCurrentOwner$1.current) {\n          var name = getComponentName(ReactCurrentOwner$1.current.type);\n\n          if (name) {\n            return '\\n\\nCheck the render method of `' + name + '`.';\n          }\n        }\n\n        return '';\n      }\n    }\n\n    function getSourceInfoErrorAddendum(source) {\n      {\n        if (source !== undefined) {\n          var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n          var lineNumber = source.lineNumber;\n          return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n        }\n\n        return '';\n      }\n    }\n    /**\n     * Warn if there's no key explicitly set on dynamic arrays of children or\n     * object keys are not valid. This allows us to keep track of children between\n     * updates.\n     */\n\n\n    var ownerHasKeyUseWarning = {};\n\n    function getCurrentComponentErrorInfo(parentType) {\n      {\n        var info = getDeclarationErrorAddendum();\n\n        if (!info) {\n          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n          if (parentName) {\n            info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n          }\n        }\n\n        return info;\n      }\n    }\n    /**\n     * Warn if the element doesn't have an explicit key assigned to it.\n     * This element is in an array. The array could grow and shrink or be\n     * reordered. All children that haven't already been validated are required to\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n     * will only be shown once.\n     *\n     * @internal\n     * @param {ReactElement} element Element that requires a key.\n     * @param {*} parentType element's parent's type.\n     */\n\n\n    function validateExplicitKey(element, parentType) {\n      {\n        if (!element._store || element._store.validated || element.key != null) {\n          return;\n        }\n\n        element._store.validated = true;\n        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n          return;\n        }\n\n        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n        // property, it may be the creator of the child that's responsible for\n        // assigning it a key.\n\n        var childOwner = '';\n\n        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n          // Give the component that originally created this child.\n          childOwner = \" It was passed a child from \" + getComponentName(element._owner.type) + \".\";\n        }\n\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\n     * Ensure that every element either is passed in a static location, in an\n     * array with an explicit keys property defined, or in an object literal\n     * with valid key property.\n     *\n     * @internal\n     * @param {ReactNode} node Statically passed child of any type.\n     * @param {*} parentType node's parent's type.\n     */\n\n\n    function validateChildKeys(node, parentType) {\n      {\n        if (typeof node !== 'object') {\n          return;\n        }\n\n        if (Array.isArray(node)) {\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n\n            if (isValidElement(child)) {\n              validateExplicitKey(child, parentType);\n            }\n          }\n        } else if (isValidElement(node)) {\n          // This element was passed in a valid location.\n          if (node._store) {\n            node._store.validated = true;\n          }\n        } else if (node) {\n          var iteratorFn = getIteratorFn(node);\n\n          if (typeof iteratorFn === 'function') {\n            // Entry iterators used to provide implicit keys,\n            // but now we print a separate warning for them later.\n            if (iteratorFn !== node.entries) {\n              var iterator = iteratorFn.call(node);\n              var step;\n\n              while (!(step = iterator.next()).done) {\n                if (isValidElement(step.value)) {\n                  validateExplicitKey(step.value, parentType);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Given an element, validate that its props follow the propTypes definition,\n     * provided by the type.\n     *\n     * @param {ReactElement} element\n     */\n\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n\n        var propTypes;\n\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentName(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentName(type);\n\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\n     * Given a fragment, validate that it can only be provided with fragment props\n     * @param {ReactElement} fragment\n     */\n\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n\n    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n      {\n        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n        // succeed and there will likely be errors in render.\n\n        if (!validType) {\n          var info = '';\n\n          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n            info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n          }\n\n          var sourceInfo = getSourceInfoErrorAddendum(source);\n\n          if (sourceInfo) {\n            info += sourceInfo;\n          } else {\n            info += getDeclarationErrorAddendum();\n          }\n\n          var typeString;\n\n          if (type === null) {\n            typeString = 'null';\n          } else if (Array.isArray(type)) {\n            typeString = 'array';\n          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n            typeString = \"<\" + (getComponentName(type.type) || 'Unknown') + \" />\";\n            info = ' Did you accidentally export a JSX literal instead of a component?';\n          } else {\n            typeString = typeof type;\n          }\n\n          error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n\n        var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n        // TODO: Drop this when these are no longer allowed as the type argument.\n\n        if (element == null) {\n          return element;\n        } // Skip key warning if the type isn't valid since our key validation logic\n        // doesn't expect a non-string/function type and can throw confusing errors.\n        // We don't want exception behavior to differ between dev and prod.\n        // (Rendering will throw with a helpful message and as soon as the type is\n        // fixed, the key warnings will appear.)\n\n\n        if (validType) {\n          var children = props.children;\n\n          if (children !== undefined) {\n            if (isStaticChildren) {\n              if (Array.isArray(children)) {\n                for (var i = 0; i < children.length; i++) {\n                  validateChildKeys(children[i], type);\n                }\n\n                if (Object.freeze) {\n                  Object.freeze(children);\n                }\n              } else {\n                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n              }\n            } else {\n              validateChildKeys(children, type);\n            }\n          }\n        }\n\n        if (type === exports.Fragment) {\n          validateFragmentProps(element);\n        } else {\n          validatePropTypes(element);\n        }\n\n        return element;\n      }\n    } // These two functions exist to still get child warnings in dev\n    // even with the prod transform. This means that jsxDEV is purely\n    // opt-in behavior for better messages but that we won't stop\n    // giving you warnings if you use production apis.\n\n\n    function jsxWithValidationStatic(type, props, key) {\n      {\n        return jsxWithValidation(type, props, key, true);\n      }\n    }\n\n    function jsxWithValidationDynamic(type, props, key) {\n      {\n        return jsxWithValidation(type, props, key, false);\n      }\n    }\n\n    var jsx = jsxWithValidationDynamic; // we may want to special case jsxs internally to take advantage of static children.\n    // for now we can ship identical prod functions\n\n    var jsxs = jsxWithValidationStatic;\n    exports.jsx = jsx;\n    exports.jsxs = jsxs;\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFYTs7QUFFYixJQUFJQSxJQUFKLEVBQTJDO0VBQ3pDLENBQUMsWUFBVztJQUNkOztJQUVBLElBQUlHLEtBQUssR0FBR0MsbUJBQU8sQ0FBQyw0Q0FBRCxDQUFuQjs7SUFDQSxJQUFJQyxPQUFPLEdBQUdELG1CQUFPLENBQUMsZ0ZBQUQsQ0FBckIsQ0FKYyxDQU1kO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7OztJQUNBLElBQUlFLGtCQUFrQixHQUFHLE1BQXpCO0lBQ0EsSUFBSUMsaUJBQWlCLEdBQUcsTUFBeEI7SUFDQUMsZ0JBQUEsR0FBbUIsTUFBbkI7SUFDQSxJQUFJRSxzQkFBc0IsR0FBRyxNQUE3QjtJQUNBLElBQUlDLG1CQUFtQixHQUFHLE1BQTFCO0lBQ0EsSUFBSUMsbUJBQW1CLEdBQUcsTUFBMUI7SUFDQSxJQUFJQyxrQkFBa0IsR0FBRyxNQUF6QjtJQUNBLElBQUlDLHNCQUFzQixHQUFHLE1BQTdCO0lBQ0EsSUFBSUMsbUJBQW1CLEdBQUcsTUFBMUI7SUFDQSxJQUFJQyx3QkFBd0IsR0FBRyxNQUEvQjtJQUNBLElBQUlDLGVBQWUsR0FBRyxNQUF0QjtJQUNBLElBQUlDLGVBQWUsR0FBRyxNQUF0QjtJQUNBLElBQUlDLGdCQUFnQixHQUFHLE1BQXZCO0lBQ0EsSUFBSUMsdUJBQXVCLEdBQUcsTUFBOUI7SUFDQSxJQUFJQyxzQkFBc0IsR0FBRyxNQUE3QjtJQUNBLElBQUlDLGdCQUFnQixHQUFHLE1BQXZCO0lBQ0EsSUFBSUMsb0JBQW9CLEdBQUcsTUFBM0I7SUFDQSxJQUFJQyw2QkFBNkIsR0FBRyxNQUFwQztJQUNBLElBQUlDLG9CQUFvQixHQUFHLE1BQTNCO0lBQ0EsSUFBSUMsd0JBQXdCLEdBQUcsTUFBL0I7O0lBRUEsSUFBSSxPQUFPQyxNQUFQ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Q0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcz8yZmMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFIHx8IHR5cGVbMF0gPT09IFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50KSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuLy8gZXZlbiB3aXRoIHRoZSBwcm9kIHRyYW5zZm9ybS4gVGhpcyBtZWFucyB0aGF0IGpzeERFViBpcyBwdXJlbHlcbi8vIG9wdC1pbiBiZWhhdmlvciBmb3IgYmV0dGVyIG1lc3NhZ2VzIGJ1dCB0aGF0IHdlIHdvbid0IHN0b3Bcbi8vIGdpdmluZyB5b3Ugd2FybmluZ3MgaWYgeW91IHVzZSBwcm9kdWN0aW9uIGFwaXMuXG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljKHR5cGUsIHByb3BzLCBrZXkpIHtcbiAge1xuICAgIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25EeW5hbWljKHR5cGUsIHByb3BzLCBrZXkpIHtcbiAge1xuICAgIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBmYWxzZSk7XG4gIH1cbn1cblxudmFyIGpzeCA9ICBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWMgOyAvLyB3ZSBtYXkgd2FudCB0byBzcGVjaWFsIGNhc2UganN4cyBpbnRlcm5hbGx5IHRvIHRha2UgYWR2YW50YWdlIG9mIHN0YXRpYyBjaGlsZHJlbi5cbi8vIGZvciBub3cgd2UgY2FuIHNoaXAgaWRlbnRpY2FsIHByb2QgZnVuY3Rpb25zXG5cbnZhciBqc3hzID0gIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljIDtcblxuZXhwb3J0cy5qc3ggPSBqc3g7XG5leHBvcnRzLmpzeHMgPSBqc3hzO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIlJlYWN0IiwicmVxdWlyZSIsIl9hc3NpZ24iLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsImV4cG9ydHMiLCJGcmFnbWVudCIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfQkxPQ0tfVFlQRSIsIlJFQUNUX1NFUlZFUl9CTE9DS19UWVBFIiwiUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSIsIlJFQUNUX1NDT1BFX1RZUEUiLCJSRUFDVF9PUEFRVUVfSURfVFlQRSIsIlJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJzeW1ib2xGb3IiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiUmVhY3RTaGFyZWRJbnRlcm5hbHMiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsImVycm9yIiwiZm9ybWF0IiwiX2xlbjIiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5MiIsInByaW50V2FybmluZyIsImxldmVsIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSIsInN0YWNrIiwiZ2V0U3RhY2tBZGRlbmR1bSIsImNvbmNhdCIsImFyZ3NXaXRoRm9ybWF0IiwibWFwIiwiaXRlbSIsInVuc2hpZnQiLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImFwcGx5IiwiY2FsbCIsImNvbnNvbGUiLCJlbmFibGVTY29wZUFQSSIsImlzVmFsaWRFbGVtZW50VHlwZSIsInR5cGUiLCIkJHR5cGVvZiIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJmdW5jdGlvbk5hbWUiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsImdldENvbXBvbmVudE5hbWUiLCJ0YWciLCJjb250ZXh0IiwicHJvdmlkZXIiLCJfY29udGV4dCIsInJlbmRlciIsIl9yZW5kZXIiLCJsYXp5Q29tcG9uZW50IiwicGF5bG9hZCIsIl9wYXlsb2FkIiwiaW5pdCIsIl9pbml0IiwieCIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwicHJldkluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImRpc2FibGVkTG9nIiwiX19yZWFjdERpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJsb2ciLCJpbmZvIiwid2FybiIsImdyb3VwIiwiZ3JvdXBDb2xsYXBzZWQiLCJncm91cEVuZCIsInByb3BzIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsInZhbHVlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsInByZWZpeCIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwic291cmNlIiwib3duZXJGbiIsInVuZGVmaW5lZCIsIkVycm9yIiwibWF0Y2giLCJ0cmltIiwicmVlbnRyeSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJQb3NzaWJseVdlYWtNYXAiLCJXZWFrTWFwIiwiTWFwIiwiZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSIsImZuIiwiY29uc3RydWN0IiwiZnJhbWUiLCJnZXQiLCJjb250cm9sIiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJzYW1wbGUiLCJzYW1wbGVMaW5lcyIsInNwbGl0IiwiY29udHJvbExpbmVzIiwicyIsImMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJlbGVtZW50Iiwib3duZXIiLCJfb3duZXIiLCJfc291cmNlIiwic2V0RXh0cmFTdGFja0ZyYW1lIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImNvbXBvbmVudE5hbWUiLCJoYXMiLCJiaW5kIiwiaGFzT3duUHJvcGVydHkiLCJ0eXBlU3BlY05hbWUiLCJlcnJvciQxIiwiZXJyIiwiZXgiLCJtZXNzYWdlIiwiUmVhY3RDdXJyZW50T3duZXIiLCJSRVNFUlZFRF9QUk9QUyIsImtleSIsInJlZiIsIl9fc2VsZiIsIl9fc291cmNlIiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biIsImRpZFdhcm5BYm91dFN0cmluZ1JlZnMiLCJoYXNWYWxpZFJlZiIsImNvbmZpZyIsImdldHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlzUmVhY3RXYXJuaW5nIiwiaGFzVmFsaWRLZXkiLCJ3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQiLCJzZWxmIiwic3RhdGVOb2RlIiwiZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdLZXkiLCJkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ1JlZiIsIlJlYWN0RWxlbWVudCIsIl9zdG9yZSIsImZyZWV6ZSIsImpzeERFViIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSZWFjdEN1cnJlbnRPd25lciQxIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMSIsInByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duIiwiaXNWYWxpZEVsZW1lbnQiLCJvYmplY3QiLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnRUeXBlIiwicGFyZW50TmFtZSIsInZhbGlkYXRlRXhwbGljaXRLZXkiLCJ2YWxpZGF0ZWQiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lciIsInZhbGlkYXRlQ2hpbGRLZXlzIiwibm9kZSIsImlzQXJyYXkiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyIsImpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyIsImpzeCIsImpzeHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUlBLEtBQUosRUFBMkMsRUFBM0MsTUFFTztFQUNMRyx1SkFBQTtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/NTc3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-runtime.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSUEsS0FBSixFQUEyQyxFQUEzQyxNQUVPO0VBQ0xHLCtJQUFBO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzPzM0ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-runtime.js\n"));

/***/ }),

/***/ "./node_modules/recoil/es/index.js":
/*!*****************************************!*\
  !*** ./node_modules/recoil/es/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultValue\": function() { return /* binding */ Recoil_index_1; },\n/* harmony export */   \"RecoilLoadable\": function() { return /* binding */ Recoil_index_3; },\n/* harmony export */   \"RecoilRoot\": function() { return /* binding */ Recoil_index_4; },\n/* harmony export */   \"atom\": function() { return /* binding */ Recoil_index_7; },\n/* harmony export */   \"atomFamily\": function() { return /* binding */ Recoil_index_9; },\n/* harmony export */   \"constSelector\": function() { return /* binding */ Recoil_index_11; },\n/* harmony export */   \"errorSelector\": function() { return /* binding */ Recoil_index_12; },\n/* harmony export */   \"isRecoilValue\": function() { return /* binding */ Recoil_index_2; },\n/* harmony export */   \"noWait\": function() { return /* binding */ Recoil_index_14; },\n/* harmony export */   \"readOnlySelector\": function() { return /* binding */ Recoil_index_13; },\n/* harmony export */   \"retentionZone\": function() { return /* binding */ Recoil_index_37; },\n/* harmony export */   \"selector\": function() { return /* binding */ Recoil_index_8; },\n/* harmony export */   \"selectorFamily\": function() { return /* binding */ Recoil_index_10; },\n/* harmony export */   \"snapshot_UNSTABLE\": function() { return /* binding */ Recoil_index_35; },\n/* harmony export */   \"useGetRecoilValueInfo_UNSTABLE\": function() { return /* binding */ Recoil_index_25; },\n/* harmony export */   \"useGotoRecoilSnapshot\": function() { return /* binding */ Recoil_index_32; },\n/* harmony export */   \"useRecoilBridgeAcrossReactRoots_UNSTABLE\": function() { return /* binding */ Recoil_index_6; },\n/* harmony export */   \"useRecoilCallback\": function() { return /* binding */ Recoil_index_30; },\n/* harmony export */   \"useRecoilRefresher_UNSTABLE\": function() { return /* binding */ Recoil_index_26; },\n/* harmony export */   \"useRecoilSnapshot\": function() { return /* binding */ Recoil_index_33; },\n/* harmony export */   \"useRecoilState\": function() { return /* binding */ Recoil_index_21; },\n/* harmony export */   \"useRecoilStateLoadable\": function() { return /* binding */ Recoil_index_22; },\n/* harmony export */   \"useRecoilState_TRANSITION_SUPPORT_UNSTABLE\": function() { return /* binding */ Recoil_index_29; },\n/* harmony export */   \"useRecoilStoreID\": function() { return /* binding */ Recoil_index_5; },\n/* harmony export */   \"useRecoilTransactionObserver_UNSTABLE\": function() { return /* binding */ Recoil_index_34; },\n/* harmony export */   \"useRecoilTransaction_UNSTABLE\": function() { return /* binding */ Recoil_index_31; },\n/* harmony export */   \"useRecoilValue\": function() { return /* binding */ Recoil_index_19; },\n/* harmony export */   \"useRecoilValueLoadable\": function() { return /* binding */ Recoil_index_20; },\n/* harmony export */   \"useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE\": function() { return /* binding */ Recoil_index_27; },\n/* harmony export */   \"useRecoilValue_TRANSITION_SUPPORT_UNSTABLE\": function() { return /* binding */ Recoil_index_28; },\n/* harmony export */   \"useResetRecoilState\": function() { return /* binding */ Recoil_index_24; },\n/* harmony export */   \"useRetain\": function() { return /* binding */ Recoil_index_36; },\n/* harmony export */   \"useSetRecoilState\": function() { return /* binding */ Recoil_index_23; },\n/* harmony export */   \"waitForAll\": function() { return /* binding */ Recoil_index_17; },\n/* harmony export */   \"waitForAllSettled\": function() { return /* binding */ Recoil_index_18; },\n/* harmony export */   \"waitForAny\": function() { return /* binding */ Recoil_index_16; },\n/* harmony export */   \"waitForNone\": function() { return /* binding */ Recoil_index_15; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction err(message) {\n  const error = new Error(message); // In V8, Error objects keep the closure scope chain alive until the\n  // err.stack property is accessed.\n\n  if (error.stack === undefined) {\n    // IE sets the stack only if error is thrown\n    try {\n      throw error;\n    } catch (_) {} // eslint-disable-line fb-www/no-unused-catch-bindings, no-empty\n\n  }\n\n  return error;\n}\n\nvar err_1 = err; // @oss-only\n\nvar Recoil_err = err_1;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n// Split declaration and implementation to allow this function to pretend to\n// check for actual instance of Promise instead of something with a `then`\n// method.\n// eslint-disable-next-line no-redeclare\n\nfunction isPromise(p) {\n  return !!p && typeof p.then === 'function';\n}\n\nvar Recoil_isPromise = isPromise;\n\nfunction nullthrows(x, message) {\n  if (x != null) {\n    return x;\n  }\n\n  throw Recoil_err(message !== null && message !== void 0 ? message : 'Got unexpected null or undefined');\n}\n\nvar Recoil_nullthrows = nullthrows;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass BaseLoadable {\n  getValue() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  toPromise() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  valueMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  valueOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected value, but in \"${this.state}\" state`);\n  }\n\n  promiseMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  promiseOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected promise, but in \"${this.state}\" state`);\n  }\n\n  errorMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  errorOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected error, but in \"${this.state}\" state`);\n  }\n\n  is(other) {\n    // $FlowFixMe[prop-missing]\n    return other.state === this.state && other.contents === this.contents;\n  }\n\n  map(_map) {\n    throw Recoil_err('BaseLoadable');\n  }\n\n}\n\nclass ValueLoadable extends BaseLoadable {\n  constructor(value) {\n    super();\n\n    _defineProperty(this, \"state\", 'hasValue');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = value;\n  }\n\n  getValue() {\n    return this.contents;\n  }\n\n  toPromise() {\n    return Promise.resolve(this.contents);\n  }\n\n  valueMaybe() {\n    return this.contents;\n  }\n\n  valueOrThrow() {\n    return this.contents;\n  }\n\n  promiseMaybe() {\n    return undefined;\n  }\n\n  errorMaybe() {\n    return undefined;\n  }\n\n  map(map) {\n    try {\n      const next = map(this.contents);\n      return Recoil_isPromise(next) ? loadableWithPromise(next) : isLoadable(next) ? next : loadableWithValue(next);\n    } catch (e) {\n      return Recoil_isPromise(e) ? // If we \"suspended\", then try again.\n      // errors and subsequent retries will be handled in 'loading' case\n      // $FlowFixMe[prop-missing]\n      loadableWithPromise(e.next(() => this.map(map))) : loadableWithError(e);\n    }\n  }\n\n}\n\nclass ErrorLoadable extends BaseLoadable {\n  constructor(error) {\n    super();\n\n    _defineProperty(this, \"state\", 'hasError');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = error;\n  }\n\n  getValue() {\n    throw this.contents;\n  }\n\n  toPromise() {\n    return Promise.reject(this.contents);\n  }\n\n  valueMaybe() {\n    return undefined;\n  }\n\n  promiseMaybe() {\n    return undefined;\n  }\n\n  errorMaybe() {\n    return this.contents;\n  }\n\n  errorOrThrow() {\n    return this.contents;\n  }\n\n  map(_map) {\n    // $FlowIssue[incompatible-return]\n    return this;\n  }\n\n}\n\nclass LoadingLoadable extends BaseLoadable {\n  constructor(promise) {\n    super();\n\n    _defineProperty(this, \"state\", 'loading');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = promise;\n  }\n\n  getValue() {\n    throw this.contents;\n  }\n\n  toPromise() {\n    return this.contents;\n  }\n\n  valueMaybe() {\n    return undefined;\n  }\n\n  promiseMaybe() {\n    return this.contents;\n  }\n\n  promiseOrThrow() {\n    return this.contents;\n  }\n\n  errorMaybe() {\n    return undefined;\n  }\n\n  map(map) {\n    return loadableWithPromise(this.contents.then(value => {\n      const next = map(value);\n\n      if (isLoadable(next)) {\n        const nextLoadable = next;\n\n        switch (nextLoadable.state) {\n          case 'hasValue':\n            return nextLoadable.contents;\n\n          case 'hasError':\n            throw nextLoadable.contents;\n\n          case 'loading':\n            return nextLoadable.contents;\n        }\n      } // $FlowIssue[incompatible-return]\n\n\n      return next;\n    }).catch(e => {\n      if (Recoil_isPromise(e)) {\n        // we were \"suspended,\" try again\n        return e.then(() => this.map(map).contents);\n      }\n\n      throw e;\n    }));\n  }\n\n}\n\nfunction loadableWithValue(value) {\n  return Object.freeze(new ValueLoadable(value));\n}\n\nfunction loadableWithError(error) {\n  return Object.freeze(new ErrorLoadable(error));\n}\n\nfunction loadableWithPromise(promise) {\n  return Object.freeze(new LoadingLoadable(promise));\n}\n\nfunction loadableLoading() {\n  return Object.freeze(new LoadingLoadable(new Promise(() => {})));\n}\n\nfunction loadableAllArray(inputs) {\n  return inputs.every(i => i.state === 'hasValue') ? loadableWithValue(inputs.map(i => i.contents)) : inputs.some(i => i.state === 'hasError') ? loadableWithError(Recoil_nullthrows(inputs.find(i => i.state === 'hasError'), 'Invalid loadable passed to loadableAll').contents) : loadableWithPromise(Promise.all(inputs.map(i => i.contents)));\n}\n\nfunction loadableAll(inputs) {\n  const unwrapedInputs = Array.isArray(inputs) ? inputs : Object.getOwnPropertyNames(inputs).map(key => inputs[key]);\n  const normalizedInputs = unwrapedInputs.map(x => isLoadable(x) ? x : Recoil_isPromise(x) ? loadableWithPromise(x) : loadableWithValue(x));\n  const output = loadableAllArray(normalizedInputs);\n  return Array.isArray(inputs) ? // $FlowIssue[incompatible-return]\n  output : // Object.getOwnPropertyNames() has consistent key ordering with ES6\n  // $FlowIssue[incompatible-call]\n  output.map(outputs => Object.getOwnPropertyNames(inputs).reduce((out, key, idx) => ({ ...out,\n    [key]: outputs[idx]\n  }), {}));\n}\n\nfunction isLoadable(x) {\n  return x instanceof BaseLoadable;\n}\n\nconst LoadableStaticInterface = {\n  of: value => Recoil_isPromise(value) ? loadableWithPromise(value) : isLoadable(value) ? value : loadableWithValue(value),\n  error: error => loadableWithError(error),\n  // $FlowIssue[incompatible-return]\n  loading: () => loadableLoading(),\n  // $FlowIssue[unclear-type]\n  all: loadableAll,\n  isLoadable\n};\nvar Recoil_Loadable = {\n  loadableWithValue,\n  loadableWithError,\n  loadableWithPromise,\n  loadableLoading,\n  loadableAll,\n  isLoadable,\n  RecoilLoadable: LoadableStaticInterface\n};\nvar Recoil_Loadable_1 = Recoil_Loadable.loadableWithValue;\nvar Recoil_Loadable_2 = Recoil_Loadable.loadableWithError;\nvar Recoil_Loadable_3 = Recoil_Loadable.loadableWithPromise;\nvar Recoil_Loadable_4 = Recoil_Loadable.loadableLoading;\nvar Recoil_Loadable_5 = Recoil_Loadable.loadableAll;\nvar Recoil_Loadable_6 = Recoil_Loadable.isLoadable;\nvar Recoil_Loadable_7 = Recoil_Loadable.RecoilLoadable;\nvar Recoil_Loadable$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  loadableWithValue: Recoil_Loadable_1,\n  loadableWithError: Recoil_Loadable_2,\n  loadableWithPromise: Recoil_Loadable_3,\n  loadableLoading: Recoil_Loadable_4,\n  loadableAll: Recoil_Loadable_5,\n  isLoadable: Recoil_Loadable_6,\n  RecoilLoadable: Recoil_Loadable_7\n});\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nconst gks = new Map().set('recoil_hamt_2020', true).set('recoil_sync_external_store', true).set('recoil_suppress_rerender_in_callback', true).set('recoil_memory_managament_2020', true);\n\nfunction Recoil_gkx_OSS(gk) {\n  var _gks$get;\n\n  return (_gks$get = gks.get(gk)) !== null && _gks$get !== void 0 ? _gks$get : false;\n}\n\nRecoil_gkx_OSS.setPass = gk => {\n  gks.set(gk, true);\n};\n\nRecoil_gkx_OSS.setFail = gk => {\n  gks.set(gk, false);\n};\n\nRecoil_gkx_OSS.clear = () => {\n  gks.clear();\n};\n\nvar Recoil_gkx = Recoil_gkx_OSS; // @oss-only\n\nvar _createMutableSource, _useMutableSource, _useSyncExternalStore;\n\nconst createMutableSource = // flowlint-next-line unclear-type:off\n(_createMutableSource = (react__WEBPACK_IMPORTED_MODULE_0___default().createMutableSource)) !== null && _createMutableSource !== void 0 ? _createMutableSource : (react__WEBPACK_IMPORTED_MODULE_0___default().unstable_createMutableSource);\nconst useMutableSource = // flowlint-next-line unclear-type:off\n(_useMutableSource = (react__WEBPACK_IMPORTED_MODULE_0___default().useMutableSource)) !== null && _useMutableSource !== void 0 ? _useMutableSource : (react__WEBPACK_IMPORTED_MODULE_0___default().unstable_useMutableSource); // https://github.com/reactwg/react-18/discussions/86\n\nconst useSyncExternalStore = // flowlint-next-line unclear-type:off\n(_useSyncExternalStore = (react__WEBPACK_IMPORTED_MODULE_0___default().useSyncExternalStore)) !== null && _useSyncExternalStore !== void 0 ? _useSyncExternalStore : // flowlint-next-line unclear-type:off\n(react__WEBPACK_IMPORTED_MODULE_0___default().unstable_useSyncExternalStore);\n/**\n * mode: The React API and approach to use for syncing state with React\n * early: Re-renders from Recoil updates occur:\n *    1) earlier\n *    2) in sync with React updates in the same batch\n *    3) before transaction observers instead of after.\n * concurrent: Is the current mode compatible with Concurrent Mode and useTransition()\n */\n\nfunction reactMode() {\n  // NOTE: This mode is currently broken with some Suspense cases\n  // see Recoil_selector-test.js\n  if (Recoil_gkx('recoil_transition_support')) {\n    return {\n      mode: 'TRANSITION_SUPPORT',\n      early: true,\n      concurrent: true\n    };\n  }\n\n  if (Recoil_gkx('recoil_sync_external_store') && useSyncExternalStore != null) {\n    return {\n      mode: 'SYNC_EXTERNAL_STORE',\n      early: true,\n      concurrent: false\n    };\n  }\n\n  if (Recoil_gkx('recoil_mutable_source') && useMutableSource != null && typeof window !== 'undefined' && !window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE) {\n    return Recoil_gkx('recoil_suppress_rerender_in_callback') ? {\n      mode: 'MUTABLE_SOURCE',\n      early: true,\n      concurrent: true\n    } : {\n      mode: 'MUTABLE_SOURCE',\n      early: false,\n      concurrent: false\n    };\n  }\n\n  return Recoil_gkx('recoil_suppress_rerender_in_callback') ? {\n    mode: 'LEGACY',\n    early: true,\n    concurrent: false\n  } : {\n    mode: 'LEGACY',\n    early: false,\n    concurrent: false\n  };\n} // TODO Need to figure out if there is a standard/open-source equivalent to see if hot module replacement is happening:\n\n\nfunction isFastRefreshEnabled() {\n  // @fb-only: const {isAcceptingUpdate} = require('__debug');\n  // @fb-only: return typeof isAcceptingUpdate === 'function' && isAcceptingUpdate();\n  return false; // @oss-only\n}\n\nvar Recoil_ReactMode = {\n  createMutableSource,\n  useMutableSource,\n  useSyncExternalStore,\n  reactMode,\n  isFastRefreshEnabled\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n// eslint-disable-next-line no-unused-vars\n\nclass AbstractRecoilValue {\n  constructor(newKey) {\n    _defineProperty(this, \"key\", void 0);\n\n    this.key = newKey;\n  }\n\n  toJSON() {\n    return {\n      key: this.key\n    };\n  }\n\n}\n\nclass RecoilState extends AbstractRecoilValue {}\n\nclass RecoilValueReadOnly extends AbstractRecoilValue {}\n\nfunction isRecoilValue(x) {\n  return x instanceof RecoilState || x instanceof RecoilValueReadOnly;\n}\n\nvar Recoil_RecoilValue = {\n  AbstractRecoilValue,\n  RecoilState,\n  RecoilValueReadOnly,\n  isRecoilValue\n};\nvar Recoil_RecoilValue_1 = Recoil_RecoilValue.AbstractRecoilValue;\nvar Recoil_RecoilValue_2 = Recoil_RecoilValue.RecoilState;\nvar Recoil_RecoilValue_3 = Recoil_RecoilValue.RecoilValueReadOnly;\nvar Recoil_RecoilValue_4 = Recoil_RecoilValue.isRecoilValue;\nvar Recoil_RecoilValue$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AbstractRecoilValue: Recoil_RecoilValue_1,\n  RecoilState: Recoil_RecoilValue_2,\n  RecoilValueReadOnly: Recoil_RecoilValue_3,\n  isRecoilValue: Recoil_RecoilValue_4\n});\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction sprintf(format, ...args) {\n  let index = 0;\n  return format.replace(/%s/g, () => String(args[index++]));\n}\n\nvar sprintf_1 = sprintf;\n\nfunction expectationViolation(format, ...args) {\n  if (true) {\n    const message = sprintf_1.call(null, format, ...args);\n    const error = new Error(message);\n    error.name = 'Expectation Violation';\n    console.error(error);\n  }\n}\n\nvar expectationViolation_1 = expectationViolation; // @oss-only\n\nvar Recoil_expectationViolation = expectationViolation_1;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Creates a new iterable whose output is generated by passing the input\n * iterable's values through the mapper function.\n */\n\nfunction mapIterable(iterable, callback) {\n  // Use generator to create iterable/iterator\n  return function* () {\n    let index = 0;\n\n    for (const value of iterable) {\n      yield callback(value, index++);\n    }\n  }();\n}\n\nvar Recoil_mapIterable = mapIterable;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction recoverableViolation(message, _projectName, {\n  error\n} = {}) {\n  if (true) {\n    console.error(message, error);\n  }\n\n  return null;\n}\n\nvar recoverableViolation_1 = recoverableViolation; // @oss-only\n\nvar Recoil_recoverableViolation = recoverableViolation_1;\nconst {\n  isFastRefreshEnabled: isFastRefreshEnabled$1\n} = Recoil_ReactMode;\n\nclass DefaultValue {}\n\nconst DEFAULT_VALUE = new DefaultValue(); // flowlint-next-line unclear-type:off\n\nconst nodes = new Map(); // flowlint-next-line unclear-type:off\n\nconst recoilValues = new Map();\n/* eslint-disable no-redeclare */\n\nfunction recoilValuesForKeys(keys) {\n  return Recoil_mapIterable(keys, key => Recoil_nullthrows(recoilValues.get(key)));\n}\n\nfunction registerNode(node) {\n  if (nodes.has(node.key)) {\n    const message = `Duplicate atom key \"${node.key}\". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;\n\n    if (true) {\n      // TODO Figure this out for open-source\n      if (!isFastRefreshEnabled$1()) {\n        Recoil_expectationViolation(message, 'recoil');\n      }\n    } else {}\n  }\n\n  nodes.set(node.key, node);\n  const recoilValue = node.set == null ? new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key) : new Recoil_RecoilValue$1.RecoilState(node.key);\n  recoilValues.set(node.key, recoilValue);\n  return recoilValue;\n}\n/* eslint-enable no-redeclare */\n\n\nclass NodeMissingError extends Error {} // flowlint-next-line unclear-type:off\n\n\nfunction getNode(key) {\n  const node = nodes.get(key);\n\n  if (node == null) {\n    throw new NodeMissingError(`Missing definition for RecoilValue: \"${key}\"\"`);\n  }\n\n  return node;\n} // flowlint-next-line unclear-type:off\n\n\nfunction getNodeMaybe(key) {\n  return nodes.get(key);\n}\n\nconst configDeletionHandlers = new Map();\n\nfunction deleteNodeConfigIfPossible(key) {\n  var _node$shouldDeleteCon;\n\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const node = nodes.get(key);\n\n  if (node !== null && node !== void 0 && (_node$shouldDeleteCon = node.shouldDeleteConfigOnRelease) !== null && _node$shouldDeleteCon !== void 0 && _node$shouldDeleteCon.call(node)) {\n    var _getConfigDeletionHan;\n\n    nodes.delete(key);\n    (_getConfigDeletionHan = getConfigDeletionHandler(key)) === null || _getConfigDeletionHan === void 0 ? void 0 : _getConfigDeletionHan();\n    configDeletionHandlers.delete(key);\n  }\n}\n\nfunction setConfigDeletionHandler(key, fn) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  if (fn === undefined) {\n    configDeletionHandlers.delete(key);\n  } else {\n    configDeletionHandlers.set(key, fn);\n  }\n}\n\nfunction getConfigDeletionHandler(key) {\n  return configDeletionHandlers.get(key);\n}\n\nvar Recoil_Node = {\n  nodes,\n  recoilValues,\n  registerNode,\n  getNode,\n  getNodeMaybe,\n  deleteNodeConfigIfPossible,\n  setConfigDeletionHandler,\n  getConfigDeletionHandler,\n  recoilValuesForKeys,\n  NodeMissingError,\n  DefaultValue,\n  DEFAULT_VALUE\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction enqueueExecution(s, f) {\n  f();\n}\n\nvar Recoil_Queue = {\n  enqueueExecution\n};\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar hamt_1 = createCommonjsModule(function (module) {\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n  /**\n      @fileOverview Hash Array Mapped Trie.\n  \n      Code based on: https://github.com/exclipy/pdata\n  */\n\n\n  var hamt = {}; // export\n\n  /* Configuration\n   ******************************************************************************/\n\n  var SIZE = 5;\n  var BUCKET_SIZE = Math.pow(2, SIZE);\n  var MASK = BUCKET_SIZE - 1;\n  var MAX_INDEX_NODE = BUCKET_SIZE / 2;\n  var MIN_ARRAY_NODE = BUCKET_SIZE / 4;\n  /*\n   ******************************************************************************/\n\n  var nothing = {};\n\n  var constant = function constant(x) {\n    return function () {\n      return x;\n    };\n  };\n  /**\n      Get 32 bit hash of string.\n  \n      Based on:\n      http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n  */\n\n\n  var hash = hamt.hash = function (str) {\n    var type = typeof str === 'undefined' ? 'undefined' : _typeof(str);\n    if (type === 'number') return str;\n    if (type !== 'string') str += '';\n    var hash = 0;\n\n    for (var i = 0, len = str.length; i < len; ++i) {\n      var c = str.charCodeAt(i);\n      hash = (hash << 5) - hash + c | 0;\n    }\n\n    return hash;\n  };\n  /* Bit Ops\n   ******************************************************************************/\n\n  /**\n      Hamming weight.\n  \n      Taken from: http://jsperf.com/hamming-weight\n  */\n\n\n  var popcount = function popcount(x) {\n    x -= x >> 1 & 0x55555555;\n    x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n    x = x + (x >> 4) & 0x0f0f0f0f;\n    x += x >> 8;\n    x += x >> 16;\n    return x & 0x7f;\n  };\n\n  var hashFragment = function hashFragment(shift, h) {\n    return h >>> shift & MASK;\n  };\n\n  var toBitmap = function toBitmap(x) {\n    return 1 << x;\n  };\n\n  var fromBitmap = function fromBitmap(bitmap, bit) {\n    return popcount(bitmap & bit - 1);\n  };\n  /* Array Ops\n   ******************************************************************************/\n\n  /**\n      Set a value in an array.\n  \n      @param mutate Should the input array be mutated?\n      @param at Index to change.\n      @param v New value\n      @param arr Array.\n  */\n\n\n  var arrayUpdate = function arrayUpdate(mutate, at, v, arr) {\n    var out = arr;\n\n    if (!mutate) {\n      var len = arr.length;\n      out = new Array(len);\n\n      for (var i = 0; i < len; ++i) {\n        out[i] = arr[i];\n      }\n    }\n\n    out[at] = v;\n    return out;\n  };\n  /**\n      Remove a value from an array.\n  \n      @param mutate Should the input array be mutated?\n      @param at Index to remove.\n      @param arr Array.\n  */\n\n\n  var arraySpliceOut = function arraySpliceOut(mutate, at, arr) {\n    var newLen = arr.length - 1;\n    var i = 0;\n    var g = 0;\n    var out = arr;\n\n    if (mutate) {\n      i = g = at;\n    } else {\n      out = new Array(newLen);\n\n      while (i < at) {\n        out[g++] = arr[i++];\n      }\n    }\n\n    ++i;\n\n    while (i <= newLen) {\n      out[g++] = arr[i++];\n    }\n\n    if (mutate) {\n      out.length = newLen;\n    }\n\n    return out;\n  };\n  /**\n      Insert a value into an array.\n  \n      @param mutate Should the input array be mutated?\n      @param at Index to insert at.\n      @param v Value to insert,\n      @param arr Array.\n  */\n\n\n  var arraySpliceIn = function arraySpliceIn(mutate, at, v, arr) {\n    var len = arr.length;\n\n    if (mutate) {\n      var _i = len;\n\n      while (_i >= at) {\n        arr[_i--] = arr[_i];\n      }\n\n      arr[at] = v;\n      return arr;\n    }\n\n    var i = 0,\n        g = 0;\n    var out = new Array(len + 1);\n\n    while (i < at) {\n      out[g++] = arr[i++];\n    }\n\n    out[at] = v;\n\n    while (i < len) {\n      out[++g] = arr[i++];\n    }\n\n    return out;\n  };\n  /* Node Structures\n   ******************************************************************************/\n\n\n  var LEAF = 1;\n  var COLLISION = 2;\n  var INDEX = 3;\n  var ARRAY = 4;\n  /**\n      Empty node.\n  */\n\n  var empty = {\n    __hamt_isEmpty: true\n  };\n\n  var isEmptyNode = function isEmptyNode(x) {\n    return x === empty || x && x.__hamt_isEmpty;\n  };\n  /**\n      Leaf holding a value.\n  \n      @member edit Edit of the node.\n      @member hash Hash of key.\n      @member key Key.\n      @member value Value stored.\n  */\n\n\n  var Leaf = function Leaf(edit, hash, key, value) {\n    return {\n      type: LEAF,\n      edit: edit,\n      hash: hash,\n      key: key,\n      value: value,\n      _modify: Leaf__modify\n    };\n  };\n  /**\n      Leaf holding multiple values with the same hash but different keys.\n  \n      @member edit Edit of the node.\n      @member hash Hash of key.\n      @member children Array of collision children node.\n  */\n\n\n  var Collision = function Collision(edit, hash, children) {\n    return {\n      type: COLLISION,\n      edit: edit,\n      hash: hash,\n      children: children,\n      _modify: Collision__modify\n    };\n  };\n  /**\n      Internal node with a sparse set of children.\n  \n      Uses a bitmap and array to pack children.\n  \n    @member edit Edit of the node.\n      @member mask Bitmap that encode the positions of children in the array.\n      @member children Array of child nodes.\n  */\n\n\n  var IndexedNode = function IndexedNode(edit, mask, children) {\n    return {\n      type: INDEX,\n      edit: edit,\n      mask: mask,\n      children: children,\n      _modify: IndexedNode__modify\n    };\n  };\n  /**\n      Internal node with many children.\n  \n      @member edit Edit of the node.\n      @member size Number of children.\n      @member children Array of child nodes.\n  */\n\n\n  var ArrayNode = function ArrayNode(edit, size, children) {\n    return {\n      type: ARRAY,\n      edit: edit,\n      size: size,\n      children: children,\n      _modify: ArrayNode__modify\n    };\n  };\n  /**\n      Is `node` a leaf node?\n  */\n\n\n  var isLeaf = function isLeaf(node) {\n    return node === empty || node.type === LEAF || node.type === COLLISION;\n  };\n  /* Internal node operations.\n   ******************************************************************************/\n\n  /**\n      Expand an indexed node into an array node.\n  \n    @param edit Current edit.\n      @param frag Index of added child.\n      @param child Added child.\n      @param mask Index node mask before child added.\n      @param subNodes Index node children before child added.\n  */\n\n\n  var expand = function expand(edit, frag, child, bitmap, subNodes) {\n    var arr = [];\n    var bit = bitmap;\n    var count = 0;\n\n    for (var i = 0; bit; ++i) {\n      if (bit & 1) arr[i] = subNodes[count++];\n      bit >>>= 1;\n    }\n\n    arr[frag] = child;\n    return ArrayNode(edit, count + 1, arr);\n  };\n  /**\n      Collapse an array node into a indexed node.\n  \n    @param edit Current edit.\n      @param count Number of elements in new array.\n      @param removed Index of removed element.\n      @param elements Array node children before remove.\n  */\n\n\n  var pack = function pack(edit, count, removed, elements) {\n    var children = new Array(count - 1);\n    var g = 0;\n    var bitmap = 0;\n\n    for (var i = 0, len = elements.length; i < len; ++i) {\n      if (i !== removed) {\n        var elem = elements[i];\n\n        if (elem && !isEmptyNode(elem)) {\n          children[g++] = elem;\n          bitmap |= 1 << i;\n        }\n      }\n    }\n\n    return IndexedNode(edit, bitmap, children);\n  };\n  /**\n      Merge two leaf nodes.\n  \n      @param shift Current shift.\n      @param h1 Node 1 hash.\n      @param n1 Node 1.\n      @param h2 Node 2 hash.\n      @param n2 Node 2.\n  */\n\n\n  var mergeLeaves = function mergeLeaves(edit, shift, h1, n1, h2, n2) {\n    if (h1 === h2) return Collision(edit, h1, [n2, n1]);\n    var subH1 = hashFragment(shift, h1);\n    var subH2 = hashFragment(shift, h2);\n    return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [mergeLeaves(edit, shift + SIZE, h1, n1, h2, n2)] : subH1 < subH2 ? [n1, n2] : [n2, n1]);\n  };\n  /**\n      Update an entry in a collision list.\n  \n      @param mutate Should mutation be used?\n      @param edit Current edit.\n      @param keyEq Key compare function.\n      @param hash Hash of collision.\n      @param list Collision list.\n      @param f Update function.\n      @param k Key to update.\n      @param size Size ref.\n  */\n\n\n  var updateCollisionList = function updateCollisionList(mutate, edit, keyEq, h, list, f, k, size) {\n    var len = list.length;\n\n    for (var i = 0; i < len; ++i) {\n      var child = list[i];\n\n      if (keyEq(k, child.key)) {\n        var value = child.value;\n\n        var _newValue = f(value);\n\n        if (_newValue === value) return list;\n\n        if (_newValue === nothing) {\n          --size.value;\n          return arraySpliceOut(mutate, i, list);\n        }\n\n        return arrayUpdate(mutate, i, Leaf(edit, h, k, _newValue), list);\n      }\n    }\n\n    var newValue = f();\n    if (newValue === nothing) return list;\n    ++size.value;\n    return arrayUpdate(mutate, len, Leaf(edit, h, k, newValue), list);\n  };\n\n  var canEditNode = function canEditNode(edit, node) {\n    return edit === node.edit;\n  };\n  /* Editing\n   ******************************************************************************/\n\n\n  var Leaf__modify = function Leaf__modify(edit, keyEq, shift, f, h, k, size) {\n    if (keyEq(k, this.key)) {\n      var _v = f(this.value);\n\n      if (_v === this.value) return this;else if (_v === nothing) {\n        --size.value;\n        return empty;\n      }\n\n      if (canEditNode(edit, this)) {\n        this.value = _v;\n        return this;\n      }\n\n      return Leaf(edit, h, k, _v);\n    }\n\n    var v = f();\n    if (v === nothing) return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n  };\n\n  var Collision__modify = function Collision__modify(edit, keyEq, shift, f, h, k, size) {\n    if (h === this.hash) {\n      var canEdit = canEditNode(edit, this);\n      var list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f, k, size);\n      if (list === this.children) return this;\n      return list.length > 1 ? Collision(edit, this.hash, list) : list[0]; // collapse single element collision list\n    }\n\n    var v = f();\n    if (v === nothing) return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n  };\n\n  var IndexedNode__modify = function IndexedNode__modify(edit, keyEq, shift, f, h, k, size) {\n    var mask = this.mask;\n    var children = this.children;\n    var frag = hashFragment(shift, h);\n    var bit = toBitmap(frag);\n    var indx = fromBitmap(mask, bit);\n    var exists = mask & bit;\n    var current = exists ? children[indx] : empty;\n\n    var child = current._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n\n    if (current === child) return this;\n    var canEdit = canEditNode(edit, this);\n    var bitmap = mask;\n    var newChildren = void 0;\n\n    if (exists && isEmptyNode(child)) {\n      // remove\n      bitmap &= ~bit;\n      if (!bitmap) return empty;\n      if (children.length <= 2 && isLeaf(children[indx ^ 1])) return children[indx ^ 1]; // collapse\n\n      newChildren = arraySpliceOut(canEdit, indx, children);\n    } else if (!exists && !isEmptyNode(child)) {\n      // add\n      if (children.length >= MAX_INDEX_NODE) return expand(edit, frag, child, mask, children);\n      bitmap |= bit;\n      newChildren = arraySpliceIn(canEdit, indx, child, children);\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, indx, child, children);\n    }\n\n    if (canEdit) {\n      this.mask = bitmap;\n      this.children = newChildren;\n      return this;\n    }\n\n    return IndexedNode(edit, bitmap, newChildren);\n  };\n\n  var ArrayNode__modify = function ArrayNode__modify(edit, keyEq, shift, f, h, k, size) {\n    var count = this.size;\n    var children = this.children;\n    var frag = hashFragment(shift, h);\n    var child = children[frag];\n\n    var newChild = (child || empty)._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n\n    if (child === newChild) return this;\n    var canEdit = canEditNode(edit, this);\n    var newChildren = void 0;\n\n    if (isEmptyNode(child) && !isEmptyNode(newChild)) {\n      // add\n      ++count;\n      newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {\n      // remove\n      --count;\n      if (count <= MIN_ARRAY_NODE) return pack(edit, count, frag, children);\n      newChildren = arrayUpdate(canEdit, frag, empty, children);\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    }\n\n    if (canEdit) {\n      this.size = count;\n      this.children = newChildren;\n      return this;\n    }\n\n    return ArrayNode(edit, count, newChildren);\n  };\n\n  empty._modify = function (edit, keyEq, shift, f, h, k, size) {\n    var v = f();\n    if (v === nothing) return empty;\n    ++size.value;\n    return Leaf(edit, h, k, v);\n  };\n  /*\n   ******************************************************************************/\n\n\n  function Map(editable, edit, config, root, size) {\n    this._editable = editable;\n    this._edit = edit;\n    this._config = config;\n    this._root = root;\n    this._size = size;\n  }\n\n  Map.prototype.setTree = function (newRoot, newSize) {\n    if (this._editable) {\n      this._root = newRoot;\n      this._size = newSize;\n      return this;\n    }\n\n    return newRoot === this._root ? this : new Map(this._editable, this._edit, this._config, newRoot, newSize);\n  };\n  /* Queries\n   ******************************************************************************/\n\n  /**\n      Lookup the value for `key` in `map` using a custom `hash`.\n  \n      Returns the value or `alt` if none.\n  */\n\n\n  var tryGetHash = hamt.tryGetHash = function (alt, hash, key, map) {\n    var node = map._root;\n    var shift = 0;\n    var keyEq = map._config.keyEq;\n\n    while (true) {\n      switch (node.type) {\n        case LEAF:\n          {\n            return keyEq(key, node.key) ? node.value : alt;\n          }\n\n        case COLLISION:\n          {\n            if (hash === node.hash) {\n              var children = node.children;\n\n              for (var i = 0, len = children.length; i < len; ++i) {\n                var child = children[i];\n                if (keyEq(key, child.key)) return child.value;\n              }\n            }\n\n            return alt;\n          }\n\n        case INDEX:\n          {\n            var frag = hashFragment(shift, hash);\n            var bit = toBitmap(frag);\n\n            if (node.mask & bit) {\n              node = node.children[fromBitmap(node.mask, bit)];\n              shift += SIZE;\n              break;\n            }\n\n            return alt;\n          }\n\n        case ARRAY:\n          {\n            node = node.children[hashFragment(shift, hash)];\n\n            if (node) {\n              shift += SIZE;\n              break;\n            }\n\n            return alt;\n          }\n\n        default:\n          return alt;\n      }\n    }\n  };\n\n  Map.prototype.tryGetHash = function (alt, hash, key) {\n    return tryGetHash(alt, hash, key, this);\n  };\n  /**\n      Lookup the value for `key` in `map` using internal hash function.\n  \n      @see `tryGetHash`\n  */\n\n\n  var tryGet = hamt.tryGet = function (alt, key, map) {\n    return tryGetHash(alt, map._config.hash(key), key, map);\n  };\n\n  Map.prototype.tryGet = function (alt, key) {\n    return tryGet(alt, key, this);\n  };\n  /**\n      Lookup the value for `key` in `map` using a custom `hash`.\n  \n      Returns the value or `undefined` if none.\n  */\n\n\n  var getHash = hamt.getHash = function (hash, key, map) {\n    return tryGetHash(undefined, hash, key, map);\n  };\n\n  Map.prototype.getHash = function (hash, key) {\n    return getHash(hash, key, this);\n  };\n  /**\n      Lookup the value for `key` in `map` using internal hash function.\n  \n      @see `get`\n  */\n\n\n  var get = hamt.get = function (key, map) {\n    return tryGetHash(undefined, map._config.hash(key), key, map);\n  };\n\n  Map.prototype.get = function (key, alt) {\n    return tryGet(alt, key, this);\n  };\n  /**\n      Does an entry exist for `key` in `map`? Uses custom `hash`.\n  */\n\n\n  var hasHash = hamt.has = function (hash, key, map) {\n    return tryGetHash(nothing, hash, key, map) !== nothing;\n  };\n\n  Map.prototype.hasHash = function (hash, key) {\n    return hasHash(hash, key, this);\n  };\n  /**\n      Does an entry exist for `key` in `map`? Uses internal hash function.\n  */\n\n\n  var has = hamt.has = function (key, map) {\n    return hasHash(map._config.hash(key), key, map);\n  };\n\n  Map.prototype.has = function (key) {\n    return has(key, this);\n  };\n\n  var defKeyCompare = function defKeyCompare(x, y) {\n    return x === y;\n  };\n  /**\n      Create an empty map.\n  \n      @param config Configuration.\n  */\n\n\n  hamt.make = function (config) {\n    return new Map(0, 0, {\n      keyEq: config && config.keyEq || defKeyCompare,\n      hash: config && config.hash || hash\n    }, empty, 0);\n  };\n  /**\n      Empty map.\n  */\n\n\n  hamt.empty = hamt.make();\n  /**\n      Does `map` contain any elements?\n  */\n\n  var isEmpty = hamt.isEmpty = function (map) {\n    return map && !!isEmptyNode(map._root);\n  };\n\n  Map.prototype.isEmpty = function () {\n    return isEmpty(this);\n  };\n  /* Updates\n   ******************************************************************************/\n\n  /**\n      Alter the value stored for `key` in `map` using function `f` using\n      custom hash.\n  \n      `f` is invoked with the current value for `k` if it exists,\n      or no arguments if no such value exists. `modify` will always either\n      update or insert a value into the map.\n  \n      Returns a map with the modified value. Does not alter `map`.\n  */\n\n\n  var modifyHash = hamt.modifyHash = function (f, hash, key, map) {\n    var size = {\n      value: map._size\n    };\n\n    var newRoot = map._root._modify(map._editable ? map._edit : NaN, map._config.keyEq, 0, f, hash, key, size);\n\n    return map.setTree(newRoot, size.value);\n  };\n\n  Map.prototype.modifyHash = function (hash, key, f) {\n    return modifyHash(f, hash, key, this);\n  };\n  /**\n      Alter the value stored for `key` in `map` using function `f` using\n      internal hash function.\n  \n      @see `modifyHash`\n  */\n\n\n  var modify = hamt.modify = function (f, key, map) {\n    return modifyHash(f, map._config.hash(key), key, map);\n  };\n\n  Map.prototype.modify = function (key, f) {\n    return modify(f, key, this);\n  };\n  /**\n      Store `value` for `key` in `map` using custom `hash`.\n  \n      Returns a map with the modified value. Does not alter `map`.\n  */\n\n\n  var setHash = hamt.setHash = function (hash, key, value, map) {\n    return modifyHash(constant(value), hash, key, map);\n  };\n\n  Map.prototype.setHash = function (hash, key, value) {\n    return setHash(hash, key, value, this);\n  };\n  /**\n      Store `value` for `key` in `map` using internal hash function.\n  \n      @see `setHash`\n  */\n\n\n  var set = hamt.set = function (key, value, map) {\n    return setHash(map._config.hash(key), key, value, map);\n  };\n\n  Map.prototype.set = function (key, value) {\n    return set(key, value, this);\n  };\n  /**\n      Remove the entry for `key` in `map`.\n  \n      Returns a map with the value removed. Does not alter `map`.\n  */\n\n\n  var del = constant(nothing);\n\n  var removeHash = hamt.removeHash = function (hash, key, map) {\n    return modifyHash(del, hash, key, map);\n  };\n\n  Map.prototype.removeHash = Map.prototype.deleteHash = function (hash, key) {\n    return removeHash(hash, key, this);\n  };\n  /**\n      Remove the entry for `key` in `map` using internal hash function.\n  \n      @see `removeHash`\n  */\n\n\n  var remove = hamt.remove = function (key, map) {\n    return removeHash(map._config.hash(key), key, map);\n  };\n\n  Map.prototype.remove = Map.prototype.delete = function (key) {\n    return remove(key, this);\n  };\n  /* Mutation\n   ******************************************************************************/\n\n  /**\n      Mark `map` as mutable.\n   */\n\n\n  var beginMutation = hamt.beginMutation = function (map) {\n    return new Map(map._editable + 1, map._edit + 1, map._config, map._root, map._size);\n  };\n\n  Map.prototype.beginMutation = function () {\n    return beginMutation(this);\n  };\n  /**\n      Mark `map` as immutable.\n   */\n\n\n  var endMutation = hamt.endMutation = function (map) {\n    map._editable = map._editable && map._editable - 1;\n    return map;\n  };\n\n  Map.prototype.endMutation = function () {\n    return endMutation(this);\n  };\n  /**\n      Mutate `map` within the context of `f`.\n      @param f\n      @param map HAMT\n  */\n\n\n  var mutate = hamt.mutate = function (f, map) {\n    var transient = beginMutation(map);\n    f(transient);\n    return endMutation(transient);\n  };\n\n  Map.prototype.mutate = function (f) {\n    return mutate(f, this);\n  };\n  /* Traversal\n   ******************************************************************************/\n\n  /**\n      Apply a continuation.\n  */\n\n\n  var appk = function appk(k) {\n    return k && lazyVisitChildren(k[0], k[1], k[2], k[3], k[4]);\n  };\n  /**\n      Recursively visit all values stored in an array of nodes lazily.\n  */\n\n\n  var lazyVisitChildren = function lazyVisitChildren(len, children, i, f, k) {\n    while (i < len) {\n      var child = children[i++];\n      if (child && !isEmptyNode(child)) return lazyVisit(child, f, [len, children, i, f, k]);\n    }\n\n    return appk(k);\n  };\n  /**\n      Recursively visit all values stored in `node` lazily.\n  */\n\n\n  var lazyVisit = function lazyVisit(node, f, k) {\n    switch (node.type) {\n      case LEAF:\n        return {\n          value: f(node),\n          rest: k\n        };\n\n      case COLLISION:\n      case ARRAY:\n      case INDEX:\n        var children = node.children;\n        return lazyVisitChildren(children.length, children, 0, f, k);\n\n      default:\n        return appk(k);\n    }\n  };\n\n  var DONE = {\n    done: true\n  };\n  /**\n      Javascript iterator over a map.\n  */\n\n  function MapIterator(v) {\n    this.v = v;\n  }\n\n  MapIterator.prototype.next = function () {\n    if (!this.v) return DONE;\n    var v0 = this.v;\n    this.v = appk(v0.rest);\n    return v0;\n  };\n\n  MapIterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n  /**\n      Lazily visit each value in map with function `f`.\n  */\n\n\n  var visit = function visit(map, f) {\n    return new MapIterator(lazyVisit(map._root, f));\n  };\n  /**\n      Get a Javascsript iterator of `map`.\n  \n      Iterates over `[key, value]` arrays.\n  */\n\n\n  var buildPairs = function buildPairs(x) {\n    return [x.key, x.value];\n  };\n\n  var entries = hamt.entries = function (map) {\n    return visit(map, buildPairs);\n  };\n\n  Map.prototype.entries = Map.prototype[Symbol.iterator] = function () {\n    return entries(this);\n  };\n  /**\n      Get array of all keys in `map`.\n  \n      Order is not guaranteed.\n  */\n\n\n  var buildKeys = function buildKeys(x) {\n    return x.key;\n  };\n\n  var keys = hamt.keys = function (map) {\n    return visit(map, buildKeys);\n  };\n\n  Map.prototype.keys = function () {\n    return keys(this);\n  };\n  /**\n      Get array of all values in `map`.\n  \n      Order is not guaranteed, duplicates are preserved.\n  */\n\n\n  var buildValues = function buildValues(x) {\n    return x.value;\n  };\n\n  var values = hamt.values = Map.prototype.values = function (map) {\n    return visit(map, buildValues);\n  };\n\n  Map.prototype.values = function () {\n    return values(this);\n  };\n  /* Fold\n   ******************************************************************************/\n\n  /**\n      Visit every entry in the map, aggregating data.\n  \n      Order of nodes is not guaranteed.\n  \n      @param f Function mapping accumulated value, value, and key to new value.\n      @param z Starting value.\n      @param m HAMT\n  */\n\n\n  var fold = hamt.fold = function (f, z, m) {\n    var root = m._root;\n    if (root.type === LEAF) return f(z, root.value, root.key);\n    var toVisit = [root.children];\n    var children = void 0;\n\n    while (children = toVisit.pop()) {\n      for (var i = 0, len = children.length; i < len;) {\n        var child = children[i++];\n\n        if (child && child.type) {\n          if (child.type === LEAF) z = f(z, child.value, child.key);else toVisit.push(child.children);\n        }\n      }\n    }\n\n    return z;\n  };\n\n  Map.prototype.fold = function (f, z) {\n    return fold(f, z, this);\n  };\n  /**\n      Visit every entry in the map, aggregating data.\n  \n      Order of nodes is not guaranteed.\n  \n      @param f Function invoked with value and key\n      @param map HAMT\n  */\n\n\n  var forEach = hamt.forEach = function (f, map) {\n    return fold(function (_, value, key) {\n      return f(value, key, map);\n    }, null, map);\n  };\n\n  Map.prototype.forEach = function (f) {\n    return forEach(f, this);\n  };\n  /* Aggregate\n   ******************************************************************************/\n\n  /**\n      Get the number of entries in `map`.\n  */\n\n\n  var count = hamt.count = function (map) {\n    return map._size;\n  };\n\n  Map.prototype.count = function () {\n    return count(this);\n  };\n\n  Object.defineProperty(Map.prototype, 'size', {\n    get: Map.prototype.count\n  });\n  /* Export\n   ******************************************************************************/\n\n  if (module.exports) {\n    module.exports = hamt;\n  } else {\n    undefined.hamt = hamt;\n  }\n});\n\nclass BuiltInMap {\n  constructor(existing) {\n    _defineProperty(this, \"_map\", void 0);\n\n    this._map = new Map(existing === null || existing === void 0 ? void 0 : existing.entries());\n  }\n\n  keys() {\n    return this._map.keys();\n  }\n\n  entries() {\n    return this._map.entries();\n  }\n\n  get(k) {\n    return this._map.get(k);\n  }\n\n  has(k) {\n    return this._map.has(k);\n  }\n\n  set(k, v) {\n    this._map.set(k, v);\n\n    return this;\n  }\n\n  delete(k) {\n    this._map.delete(k);\n\n    return this;\n  }\n\n  clone() {\n    return persistentMap(this);\n  }\n\n  toMap() {\n    return new Map(this._map);\n  }\n\n}\n\nclass HashArrayMappedTrieMap {\n  // Because hamt.empty is not a function there is no way to introduce type\n  // parameters on it, so empty is typed as HAMTPlusMap<string, mixed>.\n  // $FlowIssue\n  constructor(existing) {\n    _defineProperty(this, \"_hamt\", hamt_1.empty.beginMutation());\n\n    if (existing instanceof HashArrayMappedTrieMap) {\n      const h = existing._hamt.endMutation();\n\n      existing._hamt = h.beginMutation();\n      this._hamt = h.beginMutation();\n    } else if (existing) {\n      for (const [k, v] of existing.entries()) {\n        this._hamt.set(k, v);\n      }\n    }\n  }\n\n  keys() {\n    return this._hamt.keys();\n  }\n\n  entries() {\n    return this._hamt.entries();\n  }\n\n  get(k) {\n    return this._hamt.get(k);\n  }\n\n  has(k) {\n    return this._hamt.has(k);\n  }\n\n  set(k, v) {\n    this._hamt.set(k, v);\n\n    return this;\n  }\n\n  delete(k) {\n    this._hamt.delete(k);\n\n    return this;\n  }\n\n  clone() {\n    return persistentMap(this);\n  }\n\n  toMap() {\n    return new Map(this._hamt);\n  }\n\n}\n\nfunction persistentMap(existing) {\n  if (Recoil_gkx('recoil_hamt_2020')) {\n    return new HashArrayMappedTrieMap(existing);\n  } else {\n    return new BuiltInMap(existing);\n  }\n}\n\nvar Recoil_PersistentMap = {\n  persistentMap\n};\nvar Recoil_PersistentMap_1 = Recoil_PersistentMap.persistentMap;\nvar Recoil_PersistentMap$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  persistentMap: Recoil_PersistentMap_1\n});\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Returns a set containing all of the values from the first set that are not\n * present in any of the subsequent sets.\n *\n * Note: this is written procedurally (i.e., without filterSet) for performant\n * use in tight loops.\n */\n\nfunction differenceSets(set, ...setsWithValuesToRemove) {\n  const ret = new Set();\n\n  FIRST: for (const value of set) {\n    for (const otherSet of setsWithValuesToRemove) {\n      if (otherSet.has(value)) {\n        continue FIRST;\n      }\n    }\n\n    ret.add(value);\n  }\n\n  return ret;\n}\n\nvar Recoil_differenceSets = differenceSets;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Returns a new Map object with the same keys as the original, but with the\n * values replaced with the output of the given callback function.\n */\n\nfunction mapMap(map, callback) {\n  const result = new Map();\n  map.forEach((value, key) => {\n    result.set(key, callback(value, key));\n  });\n  return result;\n}\n\nvar Recoil_mapMap = mapMap;\n\nfunction makeGraph() {\n  return {\n    nodeDeps: new Map(),\n    nodeToNodeSubscriptions: new Map()\n  };\n}\n\nfunction cloneGraph(graph) {\n  return {\n    nodeDeps: Recoil_mapMap(graph.nodeDeps, s => new Set(s)),\n    nodeToNodeSubscriptions: Recoil_mapMap(graph.nodeToNodeSubscriptions, s => new Set(s))\n  };\n} // Note that this overwrites the deps of existing nodes, rather than unioning\n// the new deps with the old deps.\n\n\nfunction mergeDepsIntoGraph(key, newDeps, graph, // If olderGraph is given then we will not overwrite changes made to the given\n// graph compared with olderGraph:\nolderGraph) {\n  const {\n    nodeDeps,\n    nodeToNodeSubscriptions\n  } = graph;\n  const oldDeps = nodeDeps.get(key);\n\n  if (oldDeps && olderGraph && oldDeps !== olderGraph.nodeDeps.get(key)) {\n    return;\n  } // Update nodeDeps:\n\n\n  nodeDeps.set(key, newDeps); // Add new deps to nodeToNodeSubscriptions:\n\n  const addedDeps = oldDeps == null ? newDeps : Recoil_differenceSets(newDeps, oldDeps);\n\n  for (const dep of addedDeps) {\n    if (!nodeToNodeSubscriptions.has(dep)) {\n      nodeToNodeSubscriptions.set(dep, new Set());\n    }\n\n    const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));\n    existing.add(key);\n  } // Remove removed deps from nodeToNodeSubscriptions:\n\n\n  if (oldDeps) {\n    const removedDeps = Recoil_differenceSets(oldDeps, newDeps);\n\n    for (const dep of removedDeps) {\n      if (!nodeToNodeSubscriptions.has(dep)) {\n        return;\n      }\n\n      const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));\n      existing.delete(key);\n\n      if (existing.size === 0) {\n        nodeToNodeSubscriptions.delete(dep);\n      }\n    }\n  }\n}\n\nfunction saveDepsToStore(key, deps, store, version) {\n  var _storeState$nextTree, _storeState$previousT, _storeState$previousT2, _storeState$previousT3;\n\n  const storeState = store.getState();\n\n  if (!(version === storeState.currentTree.version || version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {\n    Recoil_recoverableViolation('Tried to save dependencies to a discarded tree');\n  } // Merge the dependencies discovered into the store's dependency map\n  // for the version that was read:\n\n\n  const graph = store.getGraph(version);\n  mergeDepsIntoGraph(key, deps, graph); // If this version is not the latest version, also write these dependencies\n  // into later versions if they don't already have their own:\n\n  if (version === ((_storeState$previousT2 = storeState.previousTree) === null || _storeState$previousT2 === void 0 ? void 0 : _storeState$previousT2.version)) {\n    const currentGraph = store.getGraph(storeState.currentTree.version);\n    mergeDepsIntoGraph(key, deps, currentGraph, graph);\n  }\n\n  if (version === ((_storeState$previousT3 = storeState.previousTree) === null || _storeState$previousT3 === void 0 ? void 0 : _storeState$previousT3.version) || version === storeState.currentTree.version) {\n    var _storeState$nextTree2;\n\n    const nextVersion = (_storeState$nextTree2 = storeState.nextTree) === null || _storeState$nextTree2 === void 0 ? void 0 : _storeState$nextTree2.version;\n\n    if (nextVersion !== undefined) {\n      const nextGraph = store.getGraph(nextVersion);\n      mergeDepsIntoGraph(key, deps, nextGraph, graph);\n    }\n  }\n}\n\nvar Recoil_Graph = {\n  cloneGraph,\n  graph: makeGraph,\n  saveDepsToStore\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nlet nextTreeStateVersion = 0;\n\nconst getNextTreeStateVersion = () => nextTreeStateVersion++;\n\nlet nextStoreID = 0;\n\nconst getNextStoreID = () => nextStoreID++;\n\nlet nextComponentID = 0;\n\nconst getNextComponentID = () => nextComponentID++;\n\nvar Recoil_Keys = {\n  getNextTreeStateVersion,\n  getNextStoreID,\n  getNextComponentID\n};\nconst {\n  persistentMap: persistentMap$1\n} = Recoil_PersistentMap$1;\nconst {\n  graph\n} = Recoil_Graph;\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$1\n} = Recoil_Keys;\n\nfunction makeEmptyTreeState() {\n  const version = getNextTreeStateVersion$1();\n  return {\n    version,\n    stateID: version,\n    transactionMetadata: {},\n    dirtyAtoms: new Set(),\n    atomValues: persistentMap$1(),\n    nonvalidatedAtoms: persistentMap$1()\n  };\n}\n\nfunction makeEmptyStoreState() {\n  const currentTree = makeEmptyTreeState();\n  return {\n    currentTree,\n    nextTree: null,\n    previousTree: null,\n    commitDepth: 0,\n    knownAtoms: new Set(),\n    knownSelectors: new Set(),\n    transactionSubscriptions: new Map(),\n    nodeTransactionSubscriptions: new Map(),\n    nodeToComponentSubscriptions: new Map(),\n    queuedComponentCallbacks_DEPRECATED: [],\n    suspendedComponentResolvers: new Set(),\n    graphsByVersion: new Map().set(currentTree.version, graph()),\n    retention: {\n      referenceCounts: new Map(),\n      nodesRetainedByZone: new Map(),\n      retainablesToCheckForRelease: new Set()\n    },\n    nodeCleanupFunctions: new Map()\n  };\n}\n\nvar Recoil_State = {\n  makeEmptyTreeState,\n  makeEmptyStoreState,\n  getNextTreeStateVersion: getNextTreeStateVersion$1\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nclass RetentionZone {}\n\nfunction retentionZone() {\n  return new RetentionZone();\n}\n\nvar Recoil_RetentionZone = {\n  RetentionZone,\n  retentionZone\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Utilities for working with built-in Maps and Sets without mutating them.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction setByAddingToSet(set, v) {\n  const next = new Set(set);\n  next.add(v);\n  return next;\n}\n\nfunction setByDeletingFromSet(set, v) {\n  const next = new Set(set);\n  next.delete(v);\n  return next;\n}\n\nfunction mapBySettingInMap(map, k, v) {\n  const next = new Map(map);\n  next.set(k, v);\n  return next;\n}\n\nfunction mapByUpdatingInMap(map, k, updater) {\n  const next = new Map(map);\n  next.set(k, updater(next.get(k)));\n  return next;\n}\n\nfunction mapByDeletingFromMap(map, k) {\n  const next = new Map(map);\n  next.delete(k);\n  return next;\n}\n\nfunction mapByDeletingMultipleFromMap(map, ks) {\n  const next = new Map(map);\n  ks.forEach(k => next.delete(k));\n  return next;\n}\n\nvar Recoil_CopyOnWrite = {\n  setByAddingToSet,\n  setByDeletingFromSet,\n  mapBySettingInMap,\n  mapByUpdatingInMap,\n  mapByDeletingFromMap,\n  mapByDeletingMultipleFromMap\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Creates a new iterable whose output is generated by passing the input\n * iterable's values through the filter function.\n */\n\nfunction* filterIterable(iterable, predicate) {\n  // Use generator to create iterable/iterator\n  let index = 0;\n\n  for (const value of iterable) {\n    if (predicate(value, index++)) {\n      yield value;\n    }\n  }\n}\n\nvar Recoil_filterIterable = filterIterable;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Return a proxy object based on the provided base and factories objects.\n * The proxy will include all properties of the base object as-is.\n * The factories object contains callbacks to obtain the values of the properies\n * for its keys.\n *\n * This is useful for providing users an object where some properties may be\n * lazily computed only on first access.\n */\n// $FlowIssue[unclear-type]\n\nfunction lazyProxy(base, factories) {\n  const proxy = new Proxy(base, {\n    // Compute and cache lazy property if not already done.\n    get: (target, prop) => {\n      if (!(prop in target) && prop in factories) {\n        target[prop] = factories[prop]();\n      }\n\n      return target[prop];\n    },\n    // This method allows user to iterate keys as normal\n    ownKeys: target => {\n      return Object.keys(target);\n    }\n  }); // $FlowIssue[incompatible-return]\n\n  return proxy;\n}\n\nvar Recoil_lazyProxy = lazyProxy;\nconst {\n  getNode: getNode$1,\n  getNodeMaybe: getNodeMaybe$1,\n  recoilValuesForKeys: recoilValuesForKeys$1\n} = Recoil_Node;\nconst {\n  RetentionZone: RetentionZone$1\n} = Recoil_RetentionZone;\nconst {\n  setByAddingToSet: setByAddingToSet$1\n} = Recoil_CopyOnWrite; // flowlint-next-line unclear-type:off\n\nconst emptySet = Object.freeze(new Set());\n\nclass ReadOnlyRecoilValueError extends Error {}\n\nfunction initializeRetentionForNode(store, nodeKey, retainedBy) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return () => undefined;\n  }\n\n  const {\n    nodesRetainedByZone\n  } = store.getState().retention;\n\n  function addToZone(zone) {\n    let set = nodesRetainedByZone.get(zone);\n\n    if (!set) {\n      nodesRetainedByZone.set(zone, set = new Set());\n    }\n\n    set.add(nodeKey);\n  }\n\n  if (retainedBy instanceof RetentionZone$1) {\n    addToZone(retainedBy);\n  } else if (Array.isArray(retainedBy)) {\n    for (const zone of retainedBy) {\n      addToZone(zone);\n    }\n  }\n\n  return () => {\n    if (!Recoil_gkx('recoil_memory_managament_2020')) {\n      return;\n    }\n\n    const {\n      retention\n    } = store.getState();\n\n    function deleteFromZone(zone) {\n      const set = retention.nodesRetainedByZone.get(zone);\n      set === null || set === void 0 ? void 0 : set.delete(nodeKey);\n\n      if (set && set.size === 0) {\n        retention.nodesRetainedByZone.delete(zone);\n      }\n    }\n\n    if (retainedBy instanceof RetentionZone$1) {\n      deleteFromZone(retainedBy);\n    } else if (Array.isArray(retainedBy)) {\n      for (const zone of retainedBy) {\n        deleteFromZone(zone);\n      }\n    }\n  };\n}\n\nfunction initializeNodeIfNewToStore(store, treeState, key, trigger) {\n  const storeState = store.getState();\n\n  if (storeState.nodeCleanupFunctions.has(key)) {\n    return;\n  }\n\n  const node = getNode$1(key);\n  const retentionCleanup = initializeRetentionForNode(store, key, node.retainedBy);\n  const nodeCleanup = node.init(store, treeState, trigger);\n  storeState.nodeCleanupFunctions.set(key, () => {\n    nodeCleanup();\n    retentionCleanup();\n  });\n}\n\nfunction initializeNode(store, key, trigger) {\n  initializeNodeIfNewToStore(store, store.getState().currentTree, key, trigger);\n}\n\nfunction cleanUpNode(store, key) {\n  var _state$nodeCleanupFun;\n\n  const state = store.getState();\n  (_state$nodeCleanupFun = state.nodeCleanupFunctions.get(key)) === null || _state$nodeCleanupFun === void 0 ? void 0 : _state$nodeCleanupFun();\n  state.nodeCleanupFunctions.delete(key);\n} // Get the current value loadable of a node and update the state.\n// Update dependencies and subscriptions for selectors.\n// Update saved value validation for atoms.\n\n\nfunction getNodeLoadable(store, state, key) {\n  initializeNodeIfNewToStore(store, state, key, 'get');\n  return getNode$1(key).get(store, state);\n} // Peek at the current value loadable for a node without any evaluation or state change\n\n\nfunction peekNodeLoadable(store, state, key) {\n  return getNode$1(key).peek(store, state);\n} // Write value directly to state bypassing the Node interface as the node\n// definitions may not have been loaded yet when processing the initial snapshot.\n\n\nfunction setUnvalidatedAtomValue_DEPRECATED(state, key, newValue) {\n  var _node$invalidate;\n\n  const node = getNodeMaybe$1(key);\n  node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);\n  return { ...state,\n    atomValues: state.atomValues.clone().delete(key),\n    nonvalidatedAtoms: state.nonvalidatedAtoms.clone().set(key, newValue),\n    dirtyAtoms: setByAddingToSet$1(state.dirtyAtoms, key)\n  };\n} // Return the discovered dependencies and values to be written by setting\n// a node value. (Multiple values may be written due to selectors getting to\n// set upstreams; deps may be discovered because of reads in updater functions.)\n\n\nfunction setNodeValue(store, state, key, newValue) {\n  const node = getNode$1(key);\n\n  if (node.set == null) {\n    throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${key}`);\n  }\n\n  const set = node.set; // so flow doesn't lose the above refinement.\n\n  initializeNodeIfNewToStore(store, state, key, 'set');\n  return set(store, state, newValue);\n}\n\nfunction peekNodeInfo(store, state, key) {\n  const storeState = store.getState();\n  const graph = store.getGraph(state.version);\n  const type = getNode$1(key).nodeType;\n  return Recoil_lazyProxy({\n    type\n  }, {\n    loadable: () => peekNodeLoadable(store, state, key),\n    isActive: () => storeState.knownAtoms.has(key) || storeState.knownSelectors.has(key),\n    isSet: () => type === 'selector' ? false : state.atomValues.has(key),\n    isModified: () => state.dirtyAtoms.has(key),\n    // Report current dependencies.  If the node hasn't been evaluated, then\n    // dependencies may be missing based on the current state.\n    deps: () => {\n      var _graph$nodeDeps$get;\n\n      return recoilValuesForKeys$1((_graph$nodeDeps$get = graph.nodeDeps.get(key)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : []);\n    },\n    // Reports all \"current\" subscribers.  Evaluating other nodes or\n    // previous in-progress async evaluations may introduce new subscribers.\n    subscribers: () => {\n      var _storeState$nodeToCom, _storeState$nodeToCom2;\n\n      return {\n        nodes: recoilValuesForKeys$1(Recoil_filterIterable(getDownstreamNodes(store, state, new Set([key])), nodeKey => nodeKey !== key)),\n        components: Recoil_mapIterable((_storeState$nodeToCom = (_storeState$nodeToCom2 = storeState.nodeToComponentSubscriptions.get(key)) === null || _storeState$nodeToCom2 === void 0 ? void 0 : _storeState$nodeToCom2.values()) !== null && _storeState$nodeToCom !== void 0 ? _storeState$nodeToCom : [], ([name]) => ({\n          name\n        }))\n      };\n    }\n  });\n} // Find all of the recursively dependent nodes\n\n\nfunction getDownstreamNodes(store, state, keys) {\n  const visitedNodes = new Set();\n  const visitingNodes = Array.from(keys);\n  const graph = store.getGraph(state.version);\n\n  for (let key = visitingNodes.pop(); key; key = visitingNodes.pop()) {\n    var _graph$nodeToNodeSubs;\n\n    visitedNodes.add(key);\n    const subscribedNodes = (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(key)) !== null && _graph$nodeToNodeSubs !== void 0 ? _graph$nodeToNodeSubs : emptySet;\n\n    for (const downstreamNode of subscribedNodes) {\n      if (!visitedNodes.has(downstreamNode)) {\n        visitingNodes.push(downstreamNode);\n      }\n    }\n  }\n\n  return visitedNodes;\n}\n\nvar Recoil_FunctionalCore = {\n  getNodeLoadable,\n  peekNodeLoadable,\n  setNodeValue,\n  initializeNode,\n  cleanUpNode,\n  setUnvalidatedAtomValue_DEPRECATED,\n  peekNodeInfo,\n  getDownstreamNodes\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nlet _invalidateMemoizedSnapshot = null;\n\nfunction setInvalidateMemoizedSnapshot(invalidate) {\n  _invalidateMemoizedSnapshot = invalidate;\n}\n\nfunction invalidateMemoizedSnapshot() {\n  var _invalidateMemoizedSn;\n\n  (_invalidateMemoizedSn = _invalidateMemoizedSnapshot) === null || _invalidateMemoizedSn === void 0 ? void 0 : _invalidateMemoizedSn();\n}\n\nvar Recoil_SnapshotCache = {\n  setInvalidateMemoizedSnapshot,\n  invalidateMemoizedSnapshot\n};\nconst {\n  getDownstreamNodes: getDownstreamNodes$1,\n  getNodeLoadable: getNodeLoadable$1,\n  setNodeValue: setNodeValue$1\n} = Recoil_FunctionalCore;\nconst {\n  getNextComponentID: getNextComponentID$1\n} = Recoil_Keys;\nconst {\n  getNode: getNode$2,\n  getNodeMaybe: getNodeMaybe$2\n} = Recoil_Node;\nconst {\n  DefaultValue: DefaultValue$1\n} = Recoil_Node;\nconst {\n  reactMode: reactMode$1\n} = Recoil_ReactMode;\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$1,\n  RecoilState: RecoilState$1,\n  RecoilValueReadOnly: RecoilValueReadOnly$1,\n  isRecoilValue: isRecoilValue$1\n} = Recoil_RecoilValue$1;\nconst {\n  invalidateMemoizedSnapshot: invalidateMemoizedSnapshot$1\n} = Recoil_SnapshotCache;\n\nfunction getRecoilValueAsLoadable(store, {\n  key\n}, treeState = store.getState().currentTree) {\n  var _storeState$nextTree, _storeState$previousT; // Reading from an older tree can cause bugs because the dependencies that we\n  // discover during the read are lost.\n\n\n  const storeState = store.getState();\n\n  if (!(treeState.version === storeState.currentTree.version || treeState.version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || treeState.version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {\n    Recoil_recoverableViolation('Tried to read from a discarded tree');\n  }\n\n  const loadable = getNodeLoadable$1(store, treeState, key);\n\n  if (loadable.state === 'loading') {\n    loadable.contents.catch(() => {\n      /**\n       * HACK: intercept thrown error here to prevent an uncaught promise exception. Ideally this would happen closer to selector\n       * execution (perhaps introducing a new ERROR class to be resolved by async selectors that are in an error state)\n       */\n      return;\n    });\n  }\n\n  return loadable;\n}\n\nfunction applyAtomValueWrites(atomValues, writes) {\n  const result = atomValues.clone();\n  writes.forEach((v, k) => {\n    if (v.state === 'hasValue' && v.contents instanceof DefaultValue$1) {\n      result.delete(k);\n    } else {\n      result.set(k, v);\n    }\n  });\n  return result;\n}\n\nfunction valueFromValueOrUpdater(store, state, {\n  key\n}, valueOrUpdater) {\n  if (typeof valueOrUpdater === 'function') {\n    // Updater form: pass in the current value. Throw if the current value\n    // is unavailable (namely when updating an async selector that's\n    // pending or errored):\n    const current = getNodeLoadable$1(store, state, key);\n\n    if (current.state === 'loading') {\n      const msg = `Tried to set atom or selector \"${key}\" using an updater function while the current state is pending, this is not currently supported.`;\n      Recoil_recoverableViolation(msg);\n      throw Recoil_err(msg);\n    } else if (current.state === 'hasError') {\n      throw current.contents;\n    } // T itself may be a function, so our refinement is not sufficient:\n\n\n    return valueOrUpdater(current.contents); // flowlint-line unclear-type:off\n  } else {\n    return valueOrUpdater;\n  }\n}\n\nfunction applyAction(store, state, action) {\n  if (action.type === 'set') {\n    const {\n      recoilValue,\n      valueOrUpdater\n    } = action;\n    const newValue = valueFromValueOrUpdater(store, state, recoilValue, valueOrUpdater);\n    const writes = setNodeValue$1(store, state, recoilValue.key, newValue);\n\n    for (const [key, loadable] of writes.entries()) {\n      writeLoadableToTreeState(state, key, loadable);\n    }\n  } else if (action.type === 'setLoadable') {\n    const {\n      recoilValue: {\n        key\n      },\n      loadable\n    } = action;\n    writeLoadableToTreeState(state, key, loadable);\n  } else if (action.type === 'markModified') {\n    const {\n      recoilValue: {\n        key\n      }\n    } = action;\n    state.dirtyAtoms.add(key);\n  } else if (action.type === 'setUnvalidated') {\n    var _node$invalidate; // Write value directly to state bypassing the Node interface as the node\n    // definitions may not have been loaded yet when processing the initial snapshot.\n\n\n    const {\n      recoilValue: {\n        key\n      },\n      unvalidatedValue\n    } = action;\n    const node = getNodeMaybe$2(key);\n    node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);\n    state.atomValues.delete(key);\n    state.nonvalidatedAtoms.set(key, unvalidatedValue);\n    state.dirtyAtoms.add(key);\n  } else {\n    Recoil_recoverableViolation(`Unknown action ${action.type}`);\n  }\n}\n\nfunction writeLoadableToTreeState(state, key, loadable) {\n  if (loadable.state === 'hasValue' && loadable.contents instanceof DefaultValue$1) {\n    state.atomValues.delete(key);\n  } else {\n    state.atomValues.set(key, loadable);\n  }\n\n  state.dirtyAtoms.add(key);\n  state.nonvalidatedAtoms.delete(key);\n}\n\nfunction applyActionsToStore(store, actions) {\n  store.replaceState(state => {\n    const newState = copyTreeState(state);\n\n    for (const action of actions) {\n      applyAction(store, newState, action);\n    }\n\n    invalidateDownstreams(store, newState);\n    invalidateMemoizedSnapshot$1();\n    return newState;\n  });\n}\n\nfunction queueOrPerformStateUpdate(store, action) {\n  if (batchStack.length) {\n    const actionsByStore = batchStack[batchStack.length - 1];\n    let actions = actionsByStore.get(store);\n\n    if (!actions) {\n      actionsByStore.set(store, actions = []);\n    }\n\n    actions.push(action);\n  } else {\n    applyActionsToStore(store, [action]);\n  }\n}\n\nconst batchStack = [];\n\nfunction batchStart() {\n  const actionsByStore = new Map();\n  batchStack.push(actionsByStore);\n  return () => {\n    for (const [store, actions] of actionsByStore) {\n      applyActionsToStore(store, actions);\n    }\n\n    const popped = batchStack.pop();\n\n    if (popped !== actionsByStore) {\n      Recoil_recoverableViolation('Incorrect order of batch popping');\n    }\n  };\n}\n\nfunction copyTreeState(state) {\n  return { ...state,\n    atomValues: state.atomValues.clone(),\n    nonvalidatedAtoms: state.nonvalidatedAtoms.clone(),\n    dirtyAtoms: new Set(state.dirtyAtoms)\n  };\n}\n\nfunction invalidateDownstreams(store, state) {\n  // Inform any nodes that were changed or downstream of changes so that they\n  // can clear out any caches as needed due to the update:\n  const downstreams = getDownstreamNodes$1(store, state, state.dirtyAtoms);\n\n  for (const key of downstreams) {\n    var _getNodeMaybe, _getNodeMaybe$invalid;\n\n    (_getNodeMaybe = getNodeMaybe$2(key)) === null || _getNodeMaybe === void 0 ? void 0 : (_getNodeMaybe$invalid = _getNodeMaybe.invalidate) === null || _getNodeMaybe$invalid === void 0 ? void 0 : _getNodeMaybe$invalid.call(_getNodeMaybe, state);\n  }\n}\n\nfunction setRecoilValue(store, recoilValue, valueOrUpdater) {\n  queueOrPerformStateUpdate(store, {\n    type: 'set',\n    recoilValue,\n    valueOrUpdater\n  });\n}\n\nfunction setRecoilValueLoadable(store, recoilValue, loadable) {\n  if (loadable instanceof DefaultValue$1) {\n    return setRecoilValue(store, recoilValue, loadable);\n  }\n\n  queueOrPerformStateUpdate(store, {\n    type: 'setLoadable',\n    recoilValue,\n    loadable: loadable\n  });\n}\n\nfunction markRecoilValueModified(store, recoilValue) {\n  queueOrPerformStateUpdate(store, {\n    type: 'markModified',\n    recoilValue\n  });\n}\n\nfunction setUnvalidatedRecoilValue(store, recoilValue, unvalidatedValue) {\n  queueOrPerformStateUpdate(store, {\n    type: 'setUnvalidated',\n    recoilValue,\n    unvalidatedValue\n  });\n}\n\nfunction subscribeToRecoilValue(store, {\n  key\n}, callback, componentDebugName = null) {\n  const subID = getNextComponentID$1();\n  const storeState = store.getState();\n\n  if (!storeState.nodeToComponentSubscriptions.has(key)) {\n    storeState.nodeToComponentSubscriptions.set(key, new Map());\n  }\n\n  Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID, [componentDebugName !== null && componentDebugName !== void 0 ? componentDebugName : '<not captured>', callback]); // Handle the case that, during the same tick that we are subscribing, an atom\n  // has been updated by some effect handler. Otherwise we will miss the update.\n\n  const mode = reactMode$1();\n\n  if (mode.early && (mode.mode === 'LEGACY' || mode.mode === 'MUTABLE_SOURCE')) {\n    const nextTree = store.getState().nextTree;\n\n    if (nextTree && nextTree.dirtyAtoms.has(key)) {\n      callback(nextTree);\n    }\n  }\n\n  return {\n    release: () => {\n      const releaseStoreState = store.getState();\n      const subs = releaseStoreState.nodeToComponentSubscriptions.get(key);\n\n      if (subs === undefined || !subs.has(subID)) {\n        Recoil_recoverableViolation(`Subscription missing at release time for atom ${key}. This is a bug in Recoil.`);\n        return;\n      }\n\n      subs.delete(subID);\n\n      if (subs.size === 0) {\n        releaseStoreState.nodeToComponentSubscriptions.delete(key);\n      }\n    }\n  };\n}\n\nfunction refreshRecoilValue(store, recoilValue) {\n  var _node$clearCache;\n\n  const {\n    currentTree\n  } = store.getState();\n  const node = getNode$2(recoilValue.key);\n  (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, currentTree);\n}\n\nvar Recoil_RecoilValueInterface = {\n  RecoilValueReadOnly: RecoilValueReadOnly$1,\n  AbstractRecoilValue: AbstractRecoilValue$1,\n  RecoilState: RecoilState$1,\n  getRecoilValueAsLoadable,\n  setRecoilValue,\n  setRecoilValueLoadable,\n  markRecoilValueModified,\n  setUnvalidatedRecoilValue,\n  subscribeToRecoilValue,\n  isRecoilValue: isRecoilValue$1,\n  applyAtomValueWrites,\n  // TODO Remove export when deprecating initialStoreState_DEPRECATED in RecoilRoot\n  batchStart,\n  writeLoadableToTreeState,\n  invalidateDownstreams,\n  copyTreeState,\n  refreshRecoilValue\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * The someSet() method tests whether some elements in the given Set pass the\n * test implemented by the provided function.\n */\n\nfunction someSet(set, callback, context) {\n  const iterator = set.entries();\n  let current = iterator.next();\n\n  while (!current.done) {\n    const entry = current.value;\n\n    if (callback.call(context, entry[1], entry[0], set)) {\n      return true;\n    }\n\n    current = iterator.next();\n  }\n\n  return false;\n}\n\nvar Recoil_someSet = someSet;\nconst {\n  cleanUpNode: cleanUpNode$1\n} = Recoil_FunctionalCore;\nconst {\n  deleteNodeConfigIfPossible: deleteNodeConfigIfPossible$1,\n  getNode: getNode$3\n} = Recoil_Node;\nconst {\n  RetentionZone: RetentionZone$2\n} = Recoil_RetentionZone; // Components that aren't mounted after suspending for this long will be assumed\n// to be discarded and their resources released.\n\nconst SUSPENSE_TIMEOUT_MS = 120000;\nconst emptySet$1 = new Set();\n\nfunction releaseRetainablesNowOnCurrentTree(store, retainables) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree;\n\n  if (storeState.nextTree) {\n    Recoil_recoverableViolation('releaseNodesNowOnCurrentTree should only be called at the end of a batch');\n    return; // leak memory rather than erase something that's about to be used.\n  }\n\n  const nodes = new Set();\n\n  for (const r of retainables) {\n    if (r instanceof RetentionZone$2) {\n      for (const n of nodesRetainedByZone(storeState, r)) {\n        nodes.add(n);\n      }\n    } else {\n      nodes.add(r);\n    }\n  }\n\n  const releasableNodes = findReleasableNodes(store, nodes);\n\n  for (const node of releasableNodes) {\n    releaseNode(store, treeState, node);\n  }\n}\n\nfunction findReleasableNodes(store, searchFromNodes) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree;\n  const graph = store.getGraph(treeState.version);\n  const releasableNodes = new Set(); // mutated to collect answer\n\n  const nonReleasableNodes = new Set();\n  findReleasableNodesInner(searchFromNodes);\n  return releasableNodes;\n\n  function findReleasableNodesInner(searchFromNodes) {\n    const releasableNodesFoundThisIteration = new Set();\n    const downstreams = getDownstreamNodesInTopologicalOrder(store, treeState, searchFromNodes, releasableNodes, // don't descend into these\n    nonReleasableNodes // don't descend into these\n    ); // Find which of the downstream nodes are releasable and which are not:\n\n    for (const node of downstreams) {\n      var _storeState$retention; // Not releasable if configured to be retained forever:\n\n\n      if (getNode$3(node).retainedBy === 'recoilRoot') {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if retained directly by a component:\n\n\n      if (((_storeState$retention = storeState.retention.referenceCounts.get(node)) !== null && _storeState$retention !== void 0 ? _storeState$retention : 0) > 0) {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if retained by a zone:\n\n\n      if (zonesThatCouldRetainNode(node).some(z => storeState.retention.referenceCounts.get(z))) {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if it has a non-releasable child (which will already be in\n      // nonReleasableNodes because we are going in topological order):\n\n\n      const nodeChildren = graph.nodeToNodeSubscriptions.get(node);\n\n      if (nodeChildren && Recoil_someSet(nodeChildren, child => nonReleasableNodes.has(child))) {\n        nonReleasableNodes.add(node);\n        continue;\n      }\n\n      releasableNodes.add(node);\n      releasableNodesFoundThisIteration.add(node);\n    } // If we found any releasable nodes, we need to walk UP from those nodes to\n    // find whether their parents can now be released as well:\n\n\n    const parents = new Set();\n\n    for (const node of releasableNodesFoundThisIteration) {\n      for (const parent of (_graph$nodeDeps$get = graph.nodeDeps.get(node)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : emptySet$1) {\n        var _graph$nodeDeps$get;\n\n        if (!releasableNodes.has(parent)) {\n          parents.add(parent);\n        }\n      }\n    }\n\n    if (parents.size) {\n      findReleasableNodesInner(parents);\n    }\n  }\n} // Children before parents\n\n\nfunction getDownstreamNodesInTopologicalOrder(store, treeState, nodes, // Mutable set is destroyed in place\ndoNotDescendInto1, doNotDescendInto2) {\n  const graph = store.getGraph(treeState.version);\n  const answer = [];\n  const visited = new Set();\n\n  while (nodes.size > 0) {\n    visit(Recoil_nullthrows(nodes.values().next().value));\n  }\n\n  return answer;\n\n  function visit(node) {\n    if (doNotDescendInto1.has(node) || doNotDescendInto2.has(node)) {\n      nodes.delete(node);\n      return;\n    }\n\n    if (visited.has(node)) {\n      return;\n    }\n\n    const children = graph.nodeToNodeSubscriptions.get(node);\n\n    if (children) {\n      for (const child of children) {\n        visit(child);\n      }\n    }\n\n    visited.add(node);\n    nodes.delete(node);\n    answer.push(node);\n  }\n}\n\nfunction releaseNode(store, treeState, node) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  } // Atom effects, in-closure caches, etc.:\n\n\n  cleanUpNode$1(store, node); // Delete from store state:\n\n  const storeState = store.getState();\n  storeState.knownAtoms.delete(node);\n  storeState.knownSelectors.delete(node);\n  storeState.nodeTransactionSubscriptions.delete(node);\n  storeState.retention.referenceCounts.delete(node);\n  const zones = zonesThatCouldRetainNode(node);\n\n  for (const zone of zones) {\n    var _storeState$retention2;\n\n    (_storeState$retention2 = storeState.retention.nodesRetainedByZone.get(zone)) === null || _storeState$retention2 === void 0 ? void 0 : _storeState$retention2.delete(node);\n  } // Note that we DO NOT delete from nodeToComponentSubscriptions because this\n  // already happens when the last component that was retaining the node unmounts,\n  // and this could happen either before or after that.\n  // Delete from TreeState and dep graph:\n\n\n  treeState.atomValues.delete(node);\n  treeState.dirtyAtoms.delete(node);\n  treeState.nonvalidatedAtoms.delete(node);\n  const graph = storeState.graphsByVersion.get(treeState.version);\n\n  if (graph) {\n    const deps = graph.nodeDeps.get(node);\n\n    if (deps !== undefined) {\n      graph.nodeDeps.delete(node);\n\n      for (const dep of deps) {\n        var _graph$nodeToNodeSubs;\n\n        (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(dep)) === null || _graph$nodeToNodeSubs === void 0 ? void 0 : _graph$nodeToNodeSubs.delete(node);\n      }\n    } // No need to delete sub's deps as there should be no subs at this point.\n    // But an invariant would require deleting nodes in topological order.\n\n\n    graph.nodeToNodeSubscriptions.delete(node);\n  } // Node config (for family members only as their configs can be recreated, and\n  // only if they are not retained within any other Stores):\n\n\n  deleteNodeConfigIfPossible$1(node);\n}\n\nfunction nodesRetainedByZone(storeState, zone) {\n  var _storeState$retention3;\n\n  return (_storeState$retention3 = storeState.retention.nodesRetainedByZone.get(zone)) !== null && _storeState$retention3 !== void 0 ? _storeState$retention3 : emptySet$1;\n}\n\nfunction zonesThatCouldRetainNode(node) {\n  const retainedBy = getNode$3(node).retainedBy;\n\n  if (retainedBy === undefined || retainedBy === 'components' || retainedBy === 'recoilRoot') {\n    return [];\n  } else if (retainedBy instanceof RetentionZone$2) {\n    return [retainedBy];\n  } else {\n    return retainedBy; // it's an array of zones\n  }\n}\n\nfunction scheduleOrPerformPossibleReleaseOfRetainable(store, retainable) {\n  const state = store.getState();\n\n  if (state.nextTree) {\n    state.retention.retainablesToCheckForRelease.add(retainable);\n  } else {\n    releaseRetainablesNowOnCurrentTree(store, new Set([retainable]));\n  }\n}\n\nfunction updateRetainCount(store, retainable, delta) {\n  var _map$get;\n\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const map = store.getState().retention.referenceCounts;\n  const newCount = ((_map$get = map.get(retainable)) !== null && _map$get !== void 0 ? _map$get : 0) + delta;\n\n  if (newCount === 0) {\n    updateRetainCountToZero(store, retainable);\n  } else {\n    map.set(retainable, newCount);\n  }\n}\n\nfunction updateRetainCountToZero(store, retainable) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const map = store.getState().retention.referenceCounts;\n  map.delete(retainable);\n  scheduleOrPerformPossibleReleaseOfRetainable(store, retainable);\n}\n\nfunction releaseScheduledRetainablesNow(store) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const state = store.getState();\n  releaseRetainablesNowOnCurrentTree(store, state.retention.retainablesToCheckForRelease);\n  state.retention.retainablesToCheckForRelease.clear();\n}\n\nfunction retainedByOptionWithDefault(r) {\n  // The default will change from 'recoilRoot' to 'components' in the future.\n  return r === undefined ? 'recoilRoot' : r;\n}\n\nvar Recoil_Retention = {\n  SUSPENSE_TIMEOUT_MS,\n  updateRetainCount,\n  updateRetainCountToZero,\n  releaseScheduledRetainablesNow,\n  retainedByOptionWithDefault\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is to export esstiential functions from react-dom\n * for our web build\n *\n * \n * @format\n * @oncall recoil\n */\n\nconst {\n  unstable_batchedUpdates\n} = (react_dom__WEBPACK_IMPORTED_MODULE_1___default());\nvar ReactBatchedUpdates = {\n  unstable_batchedUpdates\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is to export esstiential functions from react-dom\n * for our web build\n *\n * \n * @format\n * @oncall recoil\n */\n// @fb-only: const {unstable_batchedUpdates} = require('ReactDOMComet');\n// prettier-ignore\n\nconst {\n  unstable_batchedUpdates: unstable_batchedUpdates$1\n} = ReactBatchedUpdates; // @oss-only\n\nvar Recoil_ReactBatchedUpdates = {\n  unstable_batchedUpdates: unstable_batchedUpdates$1\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nconst {\n  batchStart: batchStart$1\n} = Recoil_RecoilValueInterface;\nconst {\n  unstable_batchedUpdates: unstable_batchedUpdates$2\n} = Recoil_ReactBatchedUpdates;\nlet batcher = unstable_batchedUpdates$2; // flowlint-next-line unclear-type:off\n\n/**\n * Sets the provided batcher function as the batcher function used by Recoil.\n *\n * Set the batcher to a custom batcher for your renderer,\n * if you use a renderer other than React DOM or React Native.\n */\n\nconst setBatcher = newBatcher => {\n  batcher = newBatcher;\n};\n/**\n * Returns the current batcher function.\n */\n\n\nconst getBatcher = () => batcher;\n/**\n * Calls the current batcher function and passes the\n * provided callback function.\n */\n\n\nconst batchUpdates = callback => {\n  batcher(() => {\n    let batchEnd = () => undefined;\n\n    try {\n      batchEnd = batchStart$1();\n      callback();\n    } finally {\n      batchEnd();\n    }\n  });\n};\n\nvar Recoil_Batching = {\n  getBatcher,\n  setBatcher,\n  batchUpdates\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Combines multiple Iterables into a single Iterable.\n * Traverses the input Iterables in the order provided and maintains the order\n * of their elements.\n *\n * Example:\n * ```\n * const r = Array.from(concatIterables(['a', 'b'], ['c'], ['d', 'e', 'f']));\n * r == ['a', 'b', 'c', 'd', 'e', 'f'];\n * ```\n */\n\nfunction* concatIterables(iters) {\n  for (const iter of iters) {\n    for (const val of iter) {\n      yield val;\n    }\n  }\n}\n\nvar Recoil_concatIterables = concatIterables;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/* eslint-disable fb-www/typeof-undefined */\n\nconst isSSR = // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709\ntypeof Window === 'undefined' || typeof window === 'undefined';\n/* eslint-enable fb-www/typeof-undefined */\n\nconst isWindow = value => !isSSR && ( // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709\nvalue === window || value instanceof Window);\n\nconst isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative'; // eslint-disable-line fb-www/typeof-undefined\n\nvar Recoil_Environment = {\n  isSSR,\n  isReactNative,\n  isWindow\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Caches a function's results based on the key returned by the passed\n * hashFunction.\n */\n\nfunction memoizeWithArgsHash(fn, hashFunction) {\n  let cache;\n\n  const memoizedFn = (...args) => {\n    if (!cache) {\n      cache = {};\n    }\n\n    const key = hashFunction(...args);\n\n    if (!Object.hasOwnProperty.call(cache, key)) {\n      cache[key] = fn(...args);\n    }\n\n    return cache[key];\n  };\n\n  return memoizedFn;\n}\n/**\n * Caches a function's results based on a comparison of the arguments.\n * Only caches the last return of the function.\n * Defaults to reference equality\n */\n\n\nfunction memoizeOneWithArgsHash(fn, hashFunction) {\n  let lastKey;\n  let lastResult; // breaking cache when arguments change\n\n  const memoizedFn = (...args) => {\n    const key = hashFunction(...args);\n\n    if (lastKey === key) {\n      return lastResult;\n    }\n\n    lastKey = key;\n    lastResult = fn(...args);\n    return lastResult;\n  };\n\n  return memoizedFn;\n}\n/**\n * Caches a function's results based on a comparison of the arguments.\n * Only caches the last return of the function.\n * Defaults to reference equality\n */\n\n\nfunction memoizeOneWithArgsHashAndInvalidation(fn, hashFunction) {\n  let lastKey;\n  let lastResult; // breaking cache when arguments change\n\n  const memoizedFn = (...args) => {\n    const key = hashFunction(...args);\n\n    if (lastKey === key) {\n      return lastResult;\n    }\n\n    lastKey = key;\n    lastResult = fn(...args);\n    return lastResult;\n  };\n\n  const invalidate = () => {\n    lastKey = null;\n  };\n\n  return [memoizedFn, invalidate];\n}\n\nvar Recoil_Memoize = {\n  memoizeWithArgsHash,\n  memoizeOneWithArgsHash,\n  memoizeOneWithArgsHashAndInvalidation\n};\nconst {\n  batchUpdates: batchUpdates$1\n} = Recoil_Batching;\nconst {\n  initializeNode: initializeNode$1,\n  peekNodeInfo: peekNodeInfo$1\n} = Recoil_FunctionalCore;\nconst {\n  graph: graph$1\n} = Recoil_Graph;\nconst {\n  getNextStoreID: getNextStoreID$1\n} = Recoil_Keys;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$1,\n  recoilValues: recoilValues$1,\n  recoilValuesForKeys: recoilValuesForKeys$2\n} = Recoil_Node;\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$2,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$1,\n  setRecoilValue: setRecoilValue$1,\n  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$1\n} = Recoil_RecoilValueInterface;\nconst {\n  updateRetainCount: updateRetainCount$1\n} = Recoil_Retention;\nconst {\n  setInvalidateMemoizedSnapshot: setInvalidateMemoizedSnapshot$1\n} = Recoil_SnapshotCache;\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$2,\n  makeEmptyStoreState: makeEmptyStoreState$1\n} = Recoil_State;\nconst {\n  isSSR: isSSR$1\n} = Recoil_Environment;\nconst {\n  memoizeOneWithArgsHashAndInvalidation: memoizeOneWithArgsHashAndInvalidation$1\n} = Recoil_Memoize; // Opaque at this surface because it's part of the public API from here.\n\nconst retainWarning = `\nRecoil Snapshots only last for the duration of the callback they are provided to. To keep a Snapshot longer, do this:\n\n  const release = snapshot.retain();\n  try {\n    await doSomethingWithSnapshot(snapshot);\n  } finally {\n    release();\n  }\n\nThis is currently a DEV-only warning but will become a thrown exception in the next release of Recoil.\n`; // A \"Snapshot\" is \"read-only\" and captures a specific set of values of atoms.\n// However, the data-flow-graph and selector values may evolve as selector\n// evaluation functions are executed and async selectors resolve.\n\nclass Snapshot {\n  // eslint-disable-next-line fb-www/no-uninitialized-properties\n  constructor(storeState, parentStoreID) {\n    _defineProperty(this, \"_store\", void 0);\n\n    _defineProperty(this, \"_refCount\", 1);\n\n    _defineProperty(this, \"getLoadable\", recoilValue => {\n      this.checkRefCount_INTERNAL();\n      return getRecoilValueAsLoadable$1(this._store, recoilValue);\n    });\n\n    _defineProperty(this, \"getPromise\", recoilValue => {\n      this.checkRefCount_INTERNAL();\n      return this.getLoadable(recoilValue).toPromise();\n    });\n\n    _defineProperty(this, \"getNodes_UNSTABLE\", opt => {\n      this.checkRefCount_INTERNAL(); // TODO Deal with modified selectors\n\n      if ((opt === null || opt === void 0 ? void 0 : opt.isModified) === true) {\n        if ((opt === null || opt === void 0 ? void 0 : opt.isInitialized) === false) {\n          return [];\n        }\n\n        const state = this._store.getState().currentTree;\n\n        return recoilValuesForKeys$2(state.dirtyAtoms);\n      }\n\n      const knownAtoms = this._store.getState().knownAtoms;\n\n      const knownSelectors = this._store.getState().knownSelectors;\n\n      return (opt === null || opt === void 0 ? void 0 : opt.isInitialized) == null ? recoilValues$1.values() : opt.isInitialized === true ? recoilValuesForKeys$2(Recoil_concatIterables([knownAtoms, knownSelectors])) : Recoil_filterIterable(recoilValues$1.values(), ({\n        key\n      }) => !knownAtoms.has(key) && !knownSelectors.has(key));\n    });\n\n    _defineProperty(this, \"getInfo_UNSTABLE\", ({\n      key\n    }) => {\n      this.checkRefCount_INTERNAL();\n      return peekNodeInfo$1(this._store, this._store.getState().currentTree, key);\n    });\n\n    _defineProperty(this, \"map\", mapper => {\n      this.checkRefCount_INTERNAL();\n      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);\n      mapper(mutableSnapshot); // if removing batchUpdates from `set` add it here\n\n      return mutableSnapshot;\n    });\n\n    _defineProperty(this, \"asyncMap\", async mapper => {\n      this.checkRefCount_INTERNAL();\n      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);\n      mutableSnapshot.retain(); // Retain new snapshot during async mapper\n\n      await mapper(mutableSnapshot); // Continue to retain the new snapshot for the user, but auto-release it\n      // after the next tick, the same as a new synchronous snapshot.\n\n      mutableSnapshot.autoRelease_INTERNAL();\n      return mutableSnapshot;\n    });\n\n    this._store = {\n      storeID: getNextStoreID$1(),\n      parentStoreID,\n      getState: () => storeState,\n      replaceState: replacer => {\n        // no batching, so nextTree is never active\n        storeState.currentTree = replacer(storeState.currentTree);\n      },\n      getGraph: version => {\n        const graphs = storeState.graphsByVersion;\n\n        if (graphs.has(version)) {\n          return Recoil_nullthrows(graphs.get(version));\n        }\n\n        const newGraph = graph$1();\n        graphs.set(version, newGraph);\n        return newGraph;\n      },\n      subscribeToTransactions: () => ({\n        release: () => {}\n      }),\n      addTransactionMetadata: () => {\n        throw Recoil_err('Cannot subscribe to Snapshots');\n      }\n    }; // Initialize any nodes that are live in the parent store (primarily so that\n    // this snapshot gets counted towards the node's live stores count).\n    // TODO Optimize this when cloning snapshots for callbacks\n\n    for (const nodeKey of this._store.getState().knownAtoms) {\n      initializeNode$1(this._store, nodeKey, 'get');\n      updateRetainCount$1(this._store, nodeKey, 1);\n    }\n\n    this.autoRelease_INTERNAL();\n  }\n\n  retain() {\n    if (this._refCount <= 0) {\n      if (true) {\n        throw Recoil_err('Snapshot has already been released.');\n      } else {}\n    }\n\n    this._refCount++;\n    let released = false;\n    return () => {\n      if (!released) {\n        released = true;\n\n        this._release();\n      }\n    };\n  }\n  /**\n   * Release the snapshot on the next tick.  This means the snapshot is retained\n   * during the execution of the current function using it.\n   */\n\n\n  autoRelease_INTERNAL() {\n    if (!isSSR$1) {\n      // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936\n      window.setTimeout(() => this._release(), 10);\n    }\n  }\n\n  _release() {\n    this._refCount--;\n\n    if (this._refCount === 0) {\n      this._store.getState().nodeCleanupFunctions.forEach(cleanup => cleanup());\n\n      this._store.getState().nodeCleanupFunctions.clear();\n\n      if (!Recoil_gkx('recoil_memory_managament_2020')) {\n        return;\n      } // Temporarily nerfing this to allow us to find broken call sites without\n      // actually breaking anybody yet.\n      // for (const k of this._store.getState().knownAtoms) {\n      //   updateRetainCountToZero(this._store, k);\n      // }\n\n    } else if (this._refCount < 0) {\n      if (true) {\n        Recoil_recoverableViolation('Snapshot released an extra time.');\n      }\n    }\n  }\n\n  isRetained() {\n    return this._refCount > 0;\n  }\n\n  checkRefCount_INTERNAL() {\n    if (Recoil_gkx('recoil_memory_managament_2020') && this._refCount <= 0) {\n      if (true) {\n        Recoil_recoverableViolation(retainWarning);\n      } // What we will ship later:\n      // throw err(retainWarning);\n\n    }\n  }\n\n  getStore_INTERNAL() {\n    this.checkRefCount_INTERNAL();\n    return this._store;\n  }\n\n  getID() {\n    this.checkRefCount_INTERNAL();\n    return this._store.getState().currentTree.stateID;\n  }\n\n  getStoreID() {\n    this.checkRefCount_INTERNAL();\n    return this._store.storeID;\n  } // We want to allow the methods to be destructured and used as accessors\n\n  /* eslint-disable fb-www/extra-arrow-initializer */\n\n  /* eslint-enable fb-www/extra-arrow-initializer */\n\n\n}\n\nfunction cloneStoreState(store, treeState, bumpVersion = false) {\n  const storeState = store.getState();\n  const version = bumpVersion ? getNextTreeStateVersion$2() : treeState.version;\n  return {\n    // Always clone the TreeState to isolate stores from accidental mutations.\n    // For example, reading a selector from a cloned snapshot shouldn't cache\n    // in the original treestate which may cause the original to skip\n    // initialization of upstream atoms.\n    currentTree: {\n      // TODO snapshots shouldn't really have versions because a new version number\n      // is always assigned when the snapshot is gone to.\n      version: bumpVersion ? version : treeState.version,\n      stateID: bumpVersion ? version : treeState.stateID,\n      transactionMetadata: { ...treeState.transactionMetadata\n      },\n      dirtyAtoms: new Set(treeState.dirtyAtoms),\n      atomValues: treeState.atomValues.clone(),\n      nonvalidatedAtoms: treeState.nonvalidatedAtoms.clone()\n    },\n    commitDepth: 0,\n    nextTree: null,\n    previousTree: null,\n    knownAtoms: new Set(storeState.knownAtoms),\n    // FIXME here's a copy\n    knownSelectors: new Set(storeState.knownSelectors),\n    // FIXME here's a copy\n    transactionSubscriptions: new Map(),\n    nodeTransactionSubscriptions: new Map(),\n    nodeToComponentSubscriptions: new Map(),\n    queuedComponentCallbacks_DEPRECATED: [],\n    suspendedComponentResolvers: new Set(),\n    graphsByVersion: new Map().set(version, store.getGraph(treeState.version)),\n    retention: {\n      referenceCounts: new Map(),\n      nodesRetainedByZone: new Map(),\n      retainablesToCheckForRelease: new Set()\n    },\n    // FIXME here's a copy\n    // Create blank cleanup handlers for atoms so snapshots don't re-run\n    // atom effects.\n    nodeCleanupFunctions: new Map(Recoil_mapIterable(storeState.nodeCleanupFunctions.entries(), ([key]) => [key, () => {}]))\n  };\n} // Factory to build a fresh snapshot\n\n\nfunction freshSnapshot(initializeState) {\n  const snapshot = new Snapshot(makeEmptyStoreState$1());\n  return initializeState != null ? snapshot.map(initializeState) : snapshot;\n} // Factory to clone a snapshot state\n\n\nconst [memoizedCloneSnapshot, invalidateMemoizedSnapshot$2] = memoizeOneWithArgsHashAndInvalidation$1((store, version) => {\n  var _storeState$nextTree;\n\n  const storeState = store.getState();\n  const treeState = version === 'latest' ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : Recoil_nullthrows(storeState.previousTree);\n  return new Snapshot(cloneStoreState(store, treeState), store.storeID);\n}, (store, version) => {\n  var _store$getState$nextT, _store$getState$previ;\n\n  return String(version) + String(store.storeID) + String((_store$getState$nextT = store.getState().nextTree) === null || _store$getState$nextT === void 0 ? void 0 : _store$getState$nextT.version) + String(store.getState().currentTree.version) + String((_store$getState$previ = store.getState().previousTree) === null || _store$getState$previ === void 0 ? void 0 : _store$getState$previ.version);\n}); // Avoid circular dependencies\n\nsetInvalidateMemoizedSnapshot$1(invalidateMemoizedSnapshot$2);\n\nfunction cloneSnapshot(store, version = 'latest') {\n  const snapshot = memoizedCloneSnapshot(store, version);\n\n  if (!snapshot.isRetained()) {\n    invalidateMemoizedSnapshot$2();\n    return memoizedCloneSnapshot(store, version);\n  }\n\n  return snapshot;\n}\n\nclass MutableSnapshot extends Snapshot {\n  constructor(snapshot, batch) {\n    super(cloneStoreState(snapshot.getStore_INTERNAL(), snapshot.getStore_INTERNAL().getState().currentTree, true), snapshot.getStoreID());\n\n    _defineProperty(this, \"_batch\", void 0);\n\n    _defineProperty(this, \"set\", (recoilState, newValueOrUpdater) => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // This batchUpdates ensures this `set` is applied immediately and you can\n      // read the written value after calling `set`. I would like to remove this\n      // behavior and only batch in `Snapshot.map`, but this would be a breaking\n      // change potentially.\n\n      this._batch(() => {\n        updateRetainCount$1(store, recoilState.key, 1);\n        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, newValueOrUpdater);\n      });\n    });\n\n    _defineProperty(this, \"reset\", recoilState => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.\n\n      this._batch(() => {\n        updateRetainCount$1(store, recoilState.key, 1);\n        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, DEFAULT_VALUE$1);\n      });\n    });\n\n    _defineProperty(this, \"setUnvalidatedAtomValues_DEPRECATED\", values => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.\n\n      batchUpdates$1(() => {\n        for (const [k, v] of values.entries()) {\n          updateRetainCount$1(store, k, 1);\n          setUnvalidatedRecoilValue$1(store, new AbstractRecoilValue$2(k), v);\n        }\n      });\n    });\n\n    this._batch = batch;\n  }\n\n}\n\nvar Recoil_Snapshot = {\n  Snapshot,\n  MutableSnapshot,\n  freshSnapshot,\n  cloneSnapshot\n};\nvar Recoil_Snapshot_1 = Recoil_Snapshot.Snapshot;\nvar Recoil_Snapshot_2 = Recoil_Snapshot.MutableSnapshot;\nvar Recoil_Snapshot_3 = Recoil_Snapshot.freshSnapshot;\nvar Recoil_Snapshot_4 = Recoil_Snapshot.cloneSnapshot;\nvar Recoil_Snapshot$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Snapshot: Recoil_Snapshot_1,\n  MutableSnapshot: Recoil_Snapshot_2,\n  freshSnapshot: Recoil_Snapshot_3,\n  cloneSnapshot: Recoil_Snapshot_4\n});\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction unionSets(...sets) {\n  const result = new Set();\n\n  for (const set of sets) {\n    for (const value of set) {\n      result.add(value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_unionSets = unionSets;\nconst {\n  useRef\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n/**\n * The same as `useRef()` except that if a function is specified then it will\n * call that function to get the value to initialize the reference with.\n * This is similar to how `useState()` behaves when given a function.  It allows\n * the user to avoid generating the initial value for subsequent renders.\n * The tradeoff is that to set the reference to a function itself you need to\n * nest it: useRefInitOnce(() => () => {...});\n */\n\nfunction useRefInitOnce(initialValue) {\n  // $FlowExpectedError[incompatible-call]\n  const ref = useRef(initialValue);\n\n  if (ref.current === initialValue && typeof initialValue === 'function') {\n    // $FlowExpectedError[incompatible-use]\n    ref.current = initialValue();\n  }\n\n  return ref;\n}\n\nvar Recoil_useRefInitOnce = useRefInitOnce; // @fb-only: const RecoilusagelogEvent = require('RecoilusagelogEvent');\n// @fb-only: const RecoilUsageLogFalcoEvent = require('RecoilUsageLogFalcoEvent');\n// @fb-only: const URI = require('URI');\n\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$3,\n  makeEmptyStoreState: makeEmptyStoreState$2\n} = Recoil_State;\nconst {\n  cleanUpNode: cleanUpNode$2,\n  getDownstreamNodes: getDownstreamNodes$2,\n  initializeNode: initializeNode$2,\n  setNodeValue: setNodeValue$2,\n  setUnvalidatedAtomValue_DEPRECATED: setUnvalidatedAtomValue_DEPRECATED$1\n} = Recoil_FunctionalCore;\nconst {\n  graph: graph$2\n} = Recoil_Graph;\nconst {\n  cloneGraph: cloneGraph$1\n} = Recoil_Graph;\nconst {\n  getNextStoreID: getNextStoreID$2\n} = Recoil_Keys;\nconst {\n  createMutableSource: createMutableSource$1,\n  reactMode: reactMode$2\n} = Recoil_ReactMode;\nconst {\n  applyAtomValueWrites: applyAtomValueWrites$1\n} = Recoil_RecoilValueInterface;\nconst {\n  releaseScheduledRetainablesNow: releaseScheduledRetainablesNow$1\n} = Recoil_Retention;\nconst {\n  freshSnapshot: freshSnapshot$1\n} = Recoil_Snapshot$1;\nconst {\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef: useRef$1,\n  useState\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction notInAContext() {\n  throw Recoil_err('This component must be used inside a <RecoilRoot> component.');\n}\n\nconst defaultStore = Object.freeze({\n  storeID: getNextStoreID$2(),\n  getState: notInAContext,\n  replaceState: notInAContext,\n  getGraph: notInAContext,\n  subscribeToTransactions: notInAContext,\n  addTransactionMetadata: notInAContext\n});\nlet stateReplacerIsBeingExecuted = false;\n\nfunction startNextTreeIfNeeded(store) {\n  if (stateReplacerIsBeingExecuted) {\n    throw Recoil_err('An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.');\n  }\n\n  const storeState = store.getState();\n\n  if (storeState.nextTree === null) {\n    if (Recoil_gkx('recoil_memory_managament_2020') && Recoil_gkx('recoil_release_on_cascading_update_killswitch_2021')) {\n      // If this is a cascading update (that is, rendering due to one state change\n      // invokes a second state change), we won't have cleaned up retainables yet\n      // because this normally happens after notifying components. Do it before\n      // proceeding with the cascading update so that it remains predictable:\n      if (storeState.commitDepth > 0) {\n        releaseScheduledRetainablesNow$1(store);\n      }\n    }\n\n    const version = storeState.currentTree.version;\n    const nextVersion = getNextTreeStateVersion$3();\n    storeState.nextTree = { ...storeState.currentTree,\n      version: nextVersion,\n      stateID: nextVersion,\n      dirtyAtoms: new Set(),\n      transactionMetadata: {}\n    };\n    storeState.graphsByVersion.set(nextVersion, cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))));\n  }\n}\n\nconst AppContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext({\n  current: defaultStore\n});\n\nconst useStoreRef = () => useContext(AppContext); // $FlowExpectedError[incompatible-call]\n\n\nconst MutableSourceContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\n\nfunction useRecoilMutableSource() {\n  const mutableSource = useContext(MutableSourceContext);\n\n  if (mutableSource == null) {\n    Recoil_expectationViolation('Attempted to use a Recoil hook outside of a <RecoilRoot>. ' + '<RecoilRoot> must be an ancestor of any component that uses ' + 'Recoil hooks.');\n  }\n\n  return mutableSource;\n}\n\nfunction notifyComponents(store, storeState, treeState) {\n  const dependentNodes = getDownstreamNodes$2(store, treeState, treeState.dirtyAtoms);\n\n  for (const key of dependentNodes) {\n    const comps = storeState.nodeToComponentSubscriptions.get(key);\n\n    if (comps) {\n      for (const [_subID, [_debugName, callback]] of comps) {\n        callback(treeState);\n      }\n    }\n  }\n}\n\nfunction sendEndOfBatchNotifications(store) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree; // Inform transaction subscribers of the transaction:\n\n  const dirtyAtoms = treeState.dirtyAtoms;\n\n  if (dirtyAtoms.size) {\n    // Execute Node-specific subscribers before global subscribers\n    for (const [key, subscriptions] of storeState.nodeTransactionSubscriptions) {\n      if (dirtyAtoms.has(key)) {\n        for (const [_, subscription] of subscriptions) {\n          subscription(store);\n        }\n      }\n    }\n\n    for (const [_, subscription] of storeState.transactionSubscriptions) {\n      subscription(store);\n    }\n\n    if (!reactMode$2().early || storeState.suspendedComponentResolvers.size > 0) {\n      // Notifying components is needed to wake from suspense, even when using\n      // early rendering.\n      notifyComponents(store, storeState, treeState); // Wake all suspended components so the right one(s) can try to re-render.\n      // We need to wake up components not just when some asynchronous selector\n      // resolved, but also when changing synchronous values because this may cause\n      // a selector to change from asynchronous to synchronous, in which case there\n      // would be no follow-up asynchronous resolution to wake us up.\n      // TODO OPTIMIZATION Only wake up related downstream components\n\n      storeState.suspendedComponentResolvers.forEach(cb => cb());\n      storeState.suspendedComponentResolvers.clear();\n    }\n  } // Special behavior ONLY invoked by useInterface.\n  // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.\n\n\n  storeState.queuedComponentCallbacks_DEPRECATED.forEach(cb => cb(treeState));\n  storeState.queuedComponentCallbacks_DEPRECATED.splice(0, storeState.queuedComponentCallbacks_DEPRECATED.length);\n}\n\nfunction endBatch(store) {\n  const storeState = store.getState();\n  storeState.commitDepth++;\n\n  try {\n    const {\n      nextTree\n    } = storeState; // Ignore commits that are not because of Recoil transactions -- namely,\n    // because something above RecoilRoot re-rendered:\n\n    if (nextTree == null) {\n      return;\n    } // nextTree is now committed -- note that copying and reset occurs when\n    // a transaction begins, in startNextTreeIfNeeded:\n\n\n    storeState.previousTree = storeState.currentTree;\n    storeState.currentTree = nextTree;\n    storeState.nextTree = null;\n    sendEndOfBatchNotifications(store);\n\n    if (storeState.previousTree != null) {\n      storeState.graphsByVersion.delete(storeState.previousTree.version);\n    } else {\n      Recoil_recoverableViolation('Ended batch with no previous state, which is unexpected', 'recoil');\n    }\n\n    storeState.previousTree = null;\n\n    if (Recoil_gkx('recoil_memory_managament_2020')) {\n      // Only release retainables if there were no writes during the end of the\n      // batch.  This avoids releasing something we might be about to use.\n      if (nextTree == null) {\n        releaseScheduledRetainablesNow$1(store);\n      }\n    }\n  } finally {\n    storeState.commitDepth--;\n  }\n}\n/*\n * The purpose of the Batcher is to observe when React batches end so that\n * Recoil state changes can be batched. Whenever Recoil state changes, we call\n * setState on the batcher. Then we wait for that change to be committed, which\n * signifies the end of the batch. That's when we respond to the Recoil change.\n */\n\n\nfunction Batcher({\n  setNotifyBatcherOfChange\n}) {\n  const storeRef = useStoreRef();\n  const [, setState] = useState([]);\n  setNotifyBatcherOfChange(() => setState({}));\n  useEffect(() => {\n    setNotifyBatcherOfChange(() => setState({})); // If an asynchronous selector resolves after the Batcher is unmounted,\n    // notifyBatcherOfChange will still be called. An error gets thrown whenever\n    // setState is called after a component is already unmounted, so this sets\n    // notifyBatcherOfChange to be a no-op.\n\n    return () => {\n      setNotifyBatcherOfChange(() => {});\n    };\n  }, [setNotifyBatcherOfChange]);\n  useEffect(() => {\n    // enqueueExecution runs this function immediately; it is only used to\n    // manipulate the order of useEffects during tests, since React seems to\n    // call useEffect in an unpredictable order sometimes.\n    Recoil_Queue.enqueueExecution('Batcher', () => {\n      endBatch(storeRef.current);\n    });\n  });\n  return null;\n}\n\nif (true) {\n  if (typeof window !== 'undefined' && !window.$recoilDebugStates) {\n    window.$recoilDebugStates = [];\n  }\n} // When removing this deprecated function, remove stateBySettingRecoilValue\n// which will no longer be needed.\n\n\nfunction initialStoreState_DEPRECATED(store, initializeState) {\n  const initial = makeEmptyStoreState$2();\n  initializeState({\n    set: (atom, value) => {\n      const state = initial.currentTree;\n      const writes = setNodeValue$2(store, state, atom.key, value);\n      const writtenNodes = new Set(writes.keys());\n      const nonvalidatedAtoms = state.nonvalidatedAtoms.clone();\n\n      for (const n of writtenNodes) {\n        nonvalidatedAtoms.delete(n);\n      }\n\n      initial.currentTree = { ...state,\n        dirtyAtoms: Recoil_unionSets(state.dirtyAtoms, writtenNodes),\n        atomValues: applyAtomValueWrites$1(state.atomValues, writes),\n        // NB: PLEASE un-export applyAtomValueWrites when deleting this code\n        nonvalidatedAtoms\n      };\n    },\n    setUnvalidatedAtomValues: atomValues => {\n      // FIXME replace this with a mutative loop\n      atomValues.forEach((v, k) => {\n        initial.currentTree = setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree, k, v);\n      });\n    }\n  });\n  return initial;\n} // Initialize state snapshot for <RecoilRoot> for the initializeState prop.\n// Atom effect initialization takes precedence over this prop.\n// Any atom effects will be run before initialization, but then cleaned up,\n// they are then re-run when used as part of rendering.  These semantics are\n// compatible with React StrictMode where effects may be re-run multiple times\n// but state initialization only happens once the first time.\n\n\nfunction initialStoreState(initializeState) {\n  // Initialize a snapshot and get its store\n  const snapshot = freshSnapshot$1(initializeState);\n  const storeState = snapshot.getStore_INTERNAL().getState(); // Counteract the snapshot auto-release\n\n  snapshot.retain(); // Cleanup any effects run during initialization and clear the handlers so\n  // they will re-initialize if used during rendering.  This allows atom effect\n  // initialization to take precedence over initializeState and be compatible\n  // with StrictMode semantics.\n\n  storeState.nodeCleanupFunctions.forEach(cleanup => cleanup());\n  storeState.nodeCleanupFunctions.clear();\n  return storeState;\n}\n\nlet nextID = 0;\n\nfunction RecoilRoot_INTERNAL({\n  initializeState_DEPRECATED,\n  initializeState,\n  store_INTERNAL: storeProp,\n  // For use with React \"context bridging\"\n  children\n}) {\n  // prettier-ignore\n  // @fb-only: useEffect(() => {\n  // @fb-only: if (gkx('recoil_usage_logging')) {\n  // @fb-only: try {\n  // @fb-only: RecoilUsageLogFalcoEvent.log(() => ({\n  // @fb-only: type: RecoilusagelogEvent.RECOIL_ROOT_MOUNTED,\n  // @fb-only: path: URI.getRequestURI().getPath(),\n  // @fb-only: }));\n  // @fb-only: } catch {\n  // @fb-only: recoverableViolation(\n  // @fb-only: 'Error when logging Recoil Usage event',\n  // @fb-only: 'recoil',\n  // @fb-only: );\n  // @fb-only: }\n  // @fb-only: }\n  // @fb-only: }, []);\n  let storeStateRef; // eslint-disable-line prefer-const\n\n  const getGraph = version => {\n    const graphs = storeStateRef.current.graphsByVersion;\n\n    if (graphs.has(version)) {\n      return Recoil_nullthrows(graphs.get(version));\n    }\n\n    const newGraph = graph$2();\n    graphs.set(version, newGraph);\n    return newGraph;\n  };\n\n  const subscribeToTransactions = (callback, key) => {\n    if (key == null) {\n      // Global transaction subscriptions\n      const {\n        transactionSubscriptions\n      } = storeRef.current.getState();\n      const id = nextID++;\n      transactionSubscriptions.set(id, callback);\n      return {\n        release: () => {\n          transactionSubscriptions.delete(id);\n        }\n      };\n    } else {\n      // Node-specific transaction subscriptions:\n      const {\n        nodeTransactionSubscriptions\n      } = storeRef.current.getState();\n\n      if (!nodeTransactionSubscriptions.has(key)) {\n        nodeTransactionSubscriptions.set(key, new Map());\n      }\n\n      const id = nextID++;\n      Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id, callback);\n      return {\n        release: () => {\n          const subs = nodeTransactionSubscriptions.get(key);\n\n          if (subs) {\n            subs.delete(id);\n\n            if (subs.size === 0) {\n              nodeTransactionSubscriptions.delete(key);\n            }\n          }\n        }\n      };\n    }\n  };\n\n  const addTransactionMetadata = metadata => {\n    startNextTreeIfNeeded(storeRef.current);\n\n    for (const k of Object.keys(metadata)) {\n      Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k] = metadata[k];\n    }\n  };\n\n  const replaceState = replacer => {\n    startNextTreeIfNeeded(storeRef.current); // Use replacer to get the next state:\n\n    const nextTree = Recoil_nullthrows(storeStateRef.current.nextTree);\n    let replaced;\n\n    try {\n      stateReplacerIsBeingExecuted = true;\n      replaced = replacer(nextTree);\n    } finally {\n      stateReplacerIsBeingExecuted = false;\n    }\n\n    if (replaced === nextTree) {\n      return;\n    }\n\n    if (true) {\n      if (typeof window !== 'undefined') {\n        window.$recoilDebugStates.push(replaced); // TODO this shouldn't happen here because it's not batched\n      }\n    } // Save changes to nextTree and schedule a React update:\n\n\n    storeStateRef.current.nextTree = replaced;\n\n    if (reactMode$2().early) {\n      notifyComponents(storeRef.current, storeStateRef.current, replaced);\n    }\n\n    Recoil_nullthrows(notifyBatcherOfChange.current)();\n  };\n\n  const notifyBatcherOfChange = useRef$1(null);\n  const setNotifyBatcherOfChange = useCallback(x => {\n    notifyBatcherOfChange.current = x;\n  }, [notifyBatcherOfChange]);\n  const storeRef = Recoil_useRefInitOnce(() => storeProp !== null && storeProp !== void 0 ? storeProp : {\n    storeID: getNextStoreID$2(),\n    getState: () => storeStateRef.current,\n    replaceState,\n    getGraph,\n    subscribeToTransactions,\n    addTransactionMetadata\n  });\n\n  if (storeProp != null) {\n    storeRef.current = storeProp;\n  }\n\n  storeStateRef = Recoil_useRefInitOnce(() => initializeState_DEPRECATED != null ? initialStoreState_DEPRECATED(storeRef.current, initializeState_DEPRECATED) : initializeState != null ? initialStoreState(initializeState) : makeEmptyStoreState$2());\n  const mutableSource = useMemo(() => createMutableSource$1 === null || createMutableSource$1 === void 0 ? void 0 : createMutableSource$1(storeStateRef, () => storeStateRef.current.currentTree.version), [storeStateRef]); // Cleanup when the <RecoilRoot> is unmounted\n\n  useEffect(() => {\n    // React is free to call effect cleanup handlers and effects at will, the\n    // deps array is only an optimization.  For example, React strict mode\n    // will execute each effect twice for testing.  Therefore, we need symmetry\n    // to re-initialize all known atoms after they were cleaned up.\n    const store = storeRef.current;\n\n    for (const atomKey of new Set(store.getState().knownAtoms)) {\n      initializeNode$2(store, atomKey, 'get');\n    }\n\n    return () => {\n      for (const atomKey of store.getState().knownAtoms) {\n        cleanUpNode$2(store, atomKey);\n      }\n    };\n  }, [storeRef]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AppContext.Provider, {\n    value: storeRef\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MutableSourceContext.Provider, {\n    value: mutableSource\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Batcher, {\n    setNotifyBatcherOfChange: setNotifyBatcherOfChange\n  }), children));\n}\n\nfunction RecoilRoot(props) {\n  const {\n    override,\n    ...propsExceptOverride\n  } = props;\n  const ancestorStoreRef = useStoreRef();\n\n  if (override === false && ancestorStoreRef.current !== defaultStore) {\n    // If ancestorStoreRef.current !== defaultStore, it means that this\n    // RecoilRoot is not nested within another.\n    return props.children;\n  }\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RecoilRoot_INTERNAL, propsExceptOverride);\n}\n\nfunction useRecoilStoreID() {\n  return useStoreRef().current.storeID;\n}\n\nvar Recoil_RecoilRoot = {\n  RecoilRoot,\n  useStoreRef,\n  useRecoilMutableSource,\n  useRecoilStoreID,\n  notifyComponents_FOR_TESTING: notifyComponents,\n  sendEndOfBatchNotifications_FOR_TESTING: sendEndOfBatchNotifications\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction shallowArrayEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar Recoil_shallowArrayEqual = shallowArrayEqual;\nconst {\n  useEffect: useEffect$1,\n  useRef: useRef$2\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction usePrevious(value) {\n  const ref = useRef$2();\n  useEffect$1(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\nvar Recoil_usePrevious = usePrevious;\nconst {\n  useStoreRef: useStoreRef$1\n} = Recoil_RecoilRoot;\nconst {\n  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$1\n} = Recoil_Retention;\nconst {\n  updateRetainCount: updateRetainCount$2\n} = Recoil_Retention;\nconst {\n  RetentionZone: RetentionZone$3\n} = Recoil_RetentionZone;\nconst {\n  useEffect: useEffect$2,\n  useRef: useRef$3\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\nconst {\n  isSSR: isSSR$2\n} = Recoil_Environment; // I don't see a way to avoid the any type here because we want to accept readable\n// and writable values with any type parameter, but normally with writable ones\n// RecoilState<SomeT> is not a subtype of RecoilState<mixed>.\n// flowlint-line unclear-type:off\n\nfunction useRetain(toRetain) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  } // eslint-disable-next-line fb-www/react-hooks\n\n\n  return useRetain_ACTUAL(toRetain);\n}\n\nfunction useRetain_ACTUAL(toRetain) {\n  const array = Array.isArray(toRetain) ? toRetain : [toRetain];\n  const retainables = array.map(a => a instanceof RetentionZone$3 ? a : a.key);\n  const storeRef = useStoreRef$1();\n  useEffect$2(() => {\n    if (!Recoil_gkx('recoil_memory_managament_2020')) {\n      return;\n    }\n\n    const store = storeRef.current;\n\n    if (timeoutID.current && !isSSR$2) {\n      // Already performed a temporary retain on render, simply cancel the release\n      // of that temporary retain.\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n    } else {\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, 1);\n      }\n    }\n\n    return () => {\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }; // eslint-disable-next-line fb-www/react-hooks-deps\n  }, [storeRef, ...retainables]); // We want to retain if the component suspends. This is terrible but the Suspense\n  // API affords us no better option. If we suspend and never commit after some\n  // seconds, then release. The 'actual' retain/release in the effect above\n  // cancels this.\n\n  const timeoutID = useRef$3();\n  const previousRetainables = Recoil_usePrevious(retainables);\n\n  if (!isSSR$2 && (previousRetainables === undefined || !Recoil_shallowArrayEqual(previousRetainables, retainables))) {\n    const store = storeRef.current;\n\n    for (const r of retainables) {\n      updateRetainCount$2(store, r, 1);\n    }\n\n    if (previousRetainables) {\n      for (const r of previousRetainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }\n\n    if (timeoutID.current) {\n      window.clearTimeout(timeoutID.current);\n    }\n\n    timeoutID.current = window.setTimeout(() => {\n      timeoutID.current = null;\n\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }, SUSPENSE_TIMEOUT_MS$1);\n  }\n}\n\nvar Recoil_useRetain = useRetain;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * THIS CODE HAS BEEN COMMENTED OUT INTENTIONALLY\n *\n * This technique of getting the component name is imperfect, since it both only\n * works in a non-minified code base, and more importantly introduces performance\n * problems since it relies in throwing errors which is an expensive operation.\n *\n * At some point we may want to reevaluate this technique hence why we have commented\n * this code out, rather than delete it all together.\n */\n// const {useRef} = require('react');\n// const gkx = require('recoil-shared/util/Recoil_gkx');\n// const stackTraceParser = require('recoil-shared/util/Recoil_stackTraceParser');\n\nfunction useComponentName() {\n  // const nameRef = useRef();\n  // if (__DEV__) {\n  //   if (gkx('recoil_infer_component_names')) {\n  //     if (nameRef.current === undefined) {\n  //       // There is no blessed way to determine the calling React component from\n  //       // within a hook. This hack uses the fact that hooks must start with 'use'\n  //       // and that hooks are either called by React Components or other hooks. It\n  //       // follows therefore, that to find the calling component, you simply need\n  //       // to look down the stack and find the first function which doesn't start\n  //       // with 'use'. We are only enabling this in dev for now, since once the\n  //       // codebase is minified, the naming assumptions no longer hold true.\n  //       // eslint-disable-next-line fb-www/no-new-error\n  //       const frames = stackTraceParser(new Error().stack);\n  //       for (const {methodName} of frames) {\n  //         // I observed cases where the frame was of the form 'Object.useXXX'\n  //         // hence why I'm searching for hooks following a word boundary\n  //         if (!methodName.match(/\\buse[^\\b]+$/)) {\n  //           return (nameRef.current = methodName);\n  //         }\n  //       }\n  //       nameRef.current = null;\n  //     }\n  //     return nameRef.current ?? '<unable to determine component name>';\n  //   }\n  // }\n  // @fb-only: return \"<component name only available when both in dev mode and when passing GK 'recoil_infer_component_names'>\";\n  return '<component name not available>'; // @oss-only\n}\n\nvar Recoil_useComponentName = useComponentName;\nconst {\n  batchUpdates: batchUpdates$2\n} = Recoil_Batching;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$2\n} = Recoil_Node;\nconst {\n  reactMode: reactMode$3,\n  useMutableSource: useMutableSource$1,\n  useSyncExternalStore: useSyncExternalStore$1\n} = Recoil_ReactMode;\nconst {\n  useRecoilMutableSource: useRecoilMutableSource$1,\n  useStoreRef: useStoreRef$2\n} = Recoil_RecoilRoot;\nconst {\n  isRecoilValue: isRecoilValue$2\n} = Recoil_RecoilValue$1;\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$3,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$2,\n  setRecoilValue: setRecoilValue$2,\n  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$2,\n  subscribeToRecoilValue: subscribeToRecoilValue$1\n} = Recoil_RecoilValueInterface;\nconst {\n  useCallback: useCallback$1,\n  useEffect: useEffect$3,\n  useMemo: useMemo$1,\n  useRef: useRef$4,\n  useState: useState$1\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\nconst {\n  setByAddingToSet: setByAddingToSet$2\n} = Recoil_CopyOnWrite;\n\nfunction handleLoadable(loadable, recoilValue, storeRef) {\n  // We can't just throw the promise we are waiting on to Suspense.  If the\n  // upstream dependencies change it may produce a state in which the component\n  // can render, but it would still be suspended on a Promise that may never resolve.\n  if (loadable.state === 'hasValue') {\n    return loadable.contents;\n  } else if (loadable.state === 'loading') {\n    const promise = new Promise(resolve => {\n      storeRef.current.getState().suspendedComponentResolvers.add(resolve);\n    }); // $FlowExpectedError Flow(prop-missing) for integrating with tools that inspect thrown promises @fb-only\n    // @fb-only: promise.displayName = `Recoil State: ${recoilValue.key}`;\n\n    throw promise;\n  } else if (loadable.state === 'hasError') {\n    throw loadable.contents;\n  } else {\n    throw Recoil_err(`Invalid value of loadable atom \"${recoilValue.key}\"`);\n  }\n}\n\nfunction validateRecoilValue(recoilValue, hookName) {\n  if (!isRecoilValue$2(recoilValue)) {\n    throw Recoil_err(`Invalid argument to ${hookName}: expected an atom or selector but got ${String(recoilValue)}`);\n  }\n}\n/**\n * Various things are broken with useRecoilInterface, particularly concurrent\n * mode, React strict mode, and memory management. They will not be fixed.\n * */\n\n\nfunction useRecoilInterface_DEPRECATED() {\n  const componentName = Recoil_useComponentName();\n  const storeRef = useStoreRef$2();\n  const [, forceUpdate] = useState$1([]);\n  const recoilValuesUsed = useRef$4(new Set());\n  recoilValuesUsed.current = new Set(); // Track the RecoilValues used just during this render\n\n  const previousSubscriptions = useRef$4(new Set());\n  const subscriptions = useRef$4(new Map());\n  const unsubscribeFrom = useCallback$1(key => {\n    const sub = subscriptions.current.get(key);\n\n    if (sub) {\n      sub.release();\n      subscriptions.current.delete(key);\n    }\n  }, [subscriptions]);\n  const updateState = useCallback$1((_state, key) => {\n    if (subscriptions.current.has(key)) {\n      forceUpdate([]);\n    }\n  }, []); // Effect to add/remove subscriptions as nodes are used\n\n  useEffect$3(() => {\n    const store = storeRef.current;\n    Recoil_differenceSets(recoilValuesUsed.current, previousSubscriptions.current).forEach(key => {\n      if (subscriptions.current.has(key)) {\n        Recoil_expectationViolation(`Double subscription to RecoilValue \"${key}\"`);\n        return;\n      }\n\n      const sub = subscribeToRecoilValue$1(store, new AbstractRecoilValue$3(key), state => updateState(state, key), componentName);\n      subscriptions.current.set(key, sub);\n      /**\n       * Since we're subscribing in an effect we need to update to the latest\n       * value of the atom since it may have changed since we rendered. We can\n       * go ahead and do that now, unless we're in the middle of a batch --\n       * in which case we should do it at the end of the batch, due to the\n       * following edge case: Suppose an atom is updated in another useEffect\n       * of this same component. Then the following sequence of events occur:\n       * 1. Atom is updated and subs fired (but we may not be subscribed\n       *    yet depending on order of effects, so we miss this) Updated value\n       *    is now in nextTree, but not currentTree.\n       * 2. This effect happens. We subscribe and update.\n       * 3. From the update we re-render and read currentTree, with old value.\n       * 4. Batcher's effect sets currentTree to nextTree.\n       * In this sequence we miss the update. To avoid that, add the update\n       * to queuedComponentCallback if a batch is in progress.\n       */\n      // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.\n\n      const state = store.getState();\n\n      if (state.nextTree) {\n        store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {\n          updateState(store.getState(), key);\n        });\n      } else {\n        updateState(store.getState(), key);\n      }\n    });\n    Recoil_differenceSets(previousSubscriptions.current, recoilValuesUsed.current).forEach(key => {\n      unsubscribeFrom(key);\n    });\n    previousSubscriptions.current = recoilValuesUsed.current;\n  }); // Effect to unsubscribe from all when unmounting\n\n  useEffect$3(() => {\n    const currentSubscriptions = subscriptions.current; // Restore subscriptions that were cleared due to StrictMode running this effect twice\n\n    Recoil_differenceSets(recoilValuesUsed.current, new Set(currentSubscriptions.keys())).forEach(key => {\n      const sub = subscribeToRecoilValue$1(storeRef.current, new AbstractRecoilValue$3(key), state => updateState(state, key), componentName);\n      currentSubscriptions.set(key, sub);\n    });\n    return () => currentSubscriptions.forEach((_, key) => unsubscribeFrom(key));\n  }, [componentName, storeRef, unsubscribeFrom, updateState]);\n  return useMemo$1(() => {\n    // eslint-disable-next-line no-shadow\n    function useSetRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useSetRecoilState');\n      }\n\n      return newValueOrUpdater => {\n        setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);\n      };\n    } // eslint-disable-next-line no-shadow\n\n\n    function useResetRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useResetRecoilState');\n      }\n\n      return () => setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilValueLoadable(recoilValue) {\n      var _storeState$nextTree;\n\n      if (true) {\n        validateRecoilValue(recoilValue, 'useRecoilValueLoadable');\n      }\n\n      if (!recoilValuesUsed.current.has(recoilValue.key)) {\n        recoilValuesUsed.current = setByAddingToSet$2(recoilValuesUsed.current, recoilValue.key);\n      } // TODO Restore optimization to memoize lookup\n\n\n      const storeState = storeRef.current.getState();\n      return getRecoilValueAsLoadable$2(storeRef.current, recoilValue, reactMode$3().early ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : storeState.currentTree);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilValue(recoilValue) {\n      if (true) {\n        validateRecoilValue(recoilValue, 'useRecoilValue');\n      }\n\n      const loadable = useRecoilValueLoadable(recoilValue);\n      return handleLoadable(loadable, recoilValue, storeRef);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useRecoilState');\n      }\n\n      return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilStateLoadable(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useRecoilStateLoadable');\n      }\n\n      return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];\n    }\n\n    return {\n      getRecoilValue: useRecoilValue,\n      getRecoilValueLoadable: useRecoilValueLoadable,\n      getRecoilState: useRecoilState,\n      getRecoilStateLoadable: useRecoilStateLoadable,\n      getSetRecoilState: useSetRecoilState,\n      getResetRecoilState: useResetRecoilState\n    };\n  }, [recoilValuesUsed, storeRef]);\n}\n\nconst recoilComponentGetRecoilValueCount_FOR_TESTING = {\n  current: 0\n};\n\nfunction useRecoilValueLoadable_SYNC_EXTERNAL_STORE(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const componentName = Recoil_useComponentName();\n  const getSnapshot = useCallback$1(() => {\n    var _storeState$nextTree2;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree2 = storeState.nextTree) !== null && _storeState$nextTree2 !== void 0 ? _storeState$nextTree2 : storeState.currentTree : storeState.currentTree;\n    const loadable = getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n    return {\n      loadable,\n      key: recoilValue.key\n    };\n  }, [storeRef, recoilValue]); // Memoize the state to avoid unnecessary rerenders\n\n  const memoizePreviousSnapshot = useCallback$1(getState => {\n    let prevState;\n    return () => {\n      var _prevState, _prevState2;\n\n      const nextState = getState();\n\n      if ((_prevState = prevState) !== null && _prevState !== void 0 && _prevState.loadable.is(nextState.loadable) && ((_prevState2 = prevState) === null || _prevState2 === void 0 ? void 0 : _prevState2.key) === nextState.key) {\n        return prevState;\n      }\n\n      prevState = nextState;\n      return nextState;\n    };\n  }, []);\n  const getMemoizedSnapshot = useMemo$1(() => memoizePreviousSnapshot(getSnapshot), [getSnapshot, memoizePreviousSnapshot]);\n  const subscribe = useCallback$1(notify => {\n    const store = storeRef.current;\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, notify, componentName);\n    return subscription.release;\n  }, [storeRef, recoilValue, componentName]);\n  return useSyncExternalStore$1(subscribe, getMemoizedSnapshot, // getSnapshot()\n  getMemoizedSnapshot // getServerSnapshot() for SSR support\n  ).loadable;\n}\n\nfunction useRecoilValueLoadable_MUTABLE_SOURCE(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree3;\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree3 = storeState.nextTree) !== null && _storeState$nextTree3 !== void 0 ? _storeState$nextTree3 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const getLoadableWithTesting = useCallback$1(() => {\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    return getLoadable();\n  }, [getLoadable]);\n  const componentName = Recoil_useComponentName();\n  const subscribe = useCallback$1((_storeState, notify) => {\n    const store = storeRef.current;\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, () => {\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return notify();\n      } // Only re-render if the value has changed.\n      // This will evaluate the atom/selector now as well as when the\n      // component renders, but that may help with prefetching.\n\n\n      const newLoadable = getLoadable();\n\n      if (!prevLoadableRef.current.is(newLoadable)) {\n        notify();\n      } // If the component is suspended then the effect setting prevLoadableRef\n      // will not run.  So, set the previous value here when its subscription\n      // is fired to wake it up.  We can't just rely on this, though, because\n      // this only executes when an atom/selector is dirty and the atom/selector\n      // passed to the hook can dynamically change.\n\n\n      prevLoadableRef.current = newLoadable;\n    }, componentName);\n    return subscription.release;\n  }, [storeRef, recoilValue, componentName, getLoadable]);\n  const source = useRecoilMutableSource$1();\n\n  if (source == null) {\n    throw Recoil_err('Recoil hooks must be used in components contained within a <RecoilRoot> component.');\n  }\n\n  const loadable = useMutableSource$1(source, getLoadableWithTesting, subscribe);\n  const prevLoadableRef = useRef$4(loadable);\n  useEffect$3(() => {\n    prevLoadableRef.current = loadable;\n  });\n  return loadable;\n}\n\nfunction useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const componentName = Recoil_useComponentName(); // Accessors to get the current state\n\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree4;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree4 = storeState.nextTree) !== null && _storeState$nextTree4 !== void 0 ? _storeState$nextTree4 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const getState = useCallback$1(() => ({\n    loadable: getLoadable(),\n    key: recoilValue.key\n  }), [getLoadable, recoilValue.key]); // Memoize state snapshots\n\n  const updateState = useCallback$1(prevState => {\n    const nextState = getState();\n    return prevState.loadable.is(nextState.loadable) && prevState.key === nextState.key ? prevState : nextState;\n  }, [getState]); // Subscribe to Recoil state changes\n\n  useEffect$3(() => {\n    const subscription = subscribeToRecoilValue$1(storeRef.current, recoilValue, _state => {\n      setState(updateState);\n    }, componentName); // Update state in case we are using a different key\n\n    setState(updateState);\n    return subscription.release;\n  }, [componentName, recoilValue, storeRef, updateState]); // Get the current state\n\n  const [state, setState] = useState$1(getState); // If we changed keys, then return the state for the new key.\n  // This is important in case the old key would cause the component to suspend.\n  // We don't have to set the new state here since the subscribing effect above\n  // will do that.\n\n  return state.key !== recoilValue.key ? getState().loadable : state.loadable;\n}\n\nfunction useRecoilValueLoadable_LEGACY(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const [, forceUpdate] = useState$1([]);\n  const componentName = Recoil_useComponentName();\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree5;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree5 = storeState.nextTree) !== null && _storeState$nextTree5 !== void 0 ? _storeState$nextTree5 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const loadable = getLoadable();\n  const prevLoadableRef = useRef$4(loadable);\n  useEffect$3(() => {\n    prevLoadableRef.current = loadable;\n  });\n  useEffect$3(() => {\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, _state => {\n      var _prevLoadableRef$curr;\n\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return forceUpdate([]);\n      }\n\n      const newLoadable = getLoadable();\n\n      if (!((_prevLoadableRef$curr = prevLoadableRef.current) !== null && _prevLoadableRef$curr !== void 0 && _prevLoadableRef$curr.is(newLoadable))) {\n        forceUpdate(newLoadable);\n      }\n\n      prevLoadableRef.current = newLoadable;\n    }, componentName);\n    /**\n     * Since we're subscribing in an effect we need to update to the latest\n     * value of the atom since it may have changed since we rendered. We can\n     * go ahead and do that now, unless we're in the middle of a batch --\n     * in which case we should do it at the end of the batch, due to the\n     * following edge case: Suppose an atom is updated in another useEffect\n     * of this same component. Then the following sequence of events occur:\n     * 1. Atom is updated and subs fired (but we may not be subscribed\n     *    yet depending on order of effects, so we miss this) Updated value\n     *    is now in nextTree, but not currentTree.\n     * 2. This effect happens. We subscribe and update.\n     * 3. From the update we re-render and read currentTree, with old value.\n     * 4. Batcher's effect sets currentTree to nextTree.\n     * In this sequence we miss the update. To avoid that, add the update\n     * to queuedComponentCallback if a batch is in progress.\n     */\n\n    if (storeState.nextTree) {\n      store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {\n        prevLoadableRef.current = null;\n        forceUpdate([]);\n      });\n    } else {\n      var _prevLoadableRef$curr2;\n\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return forceUpdate([]);\n      }\n\n      const newLoadable = getLoadable();\n\n      if (!((_prevLoadableRef$curr2 = prevLoadableRef.current) !== null && _prevLoadableRef$curr2 !== void 0 && _prevLoadableRef$curr2.is(newLoadable))) {\n        forceUpdate(newLoadable);\n      }\n\n      prevLoadableRef.current = newLoadable;\n    }\n\n    return subscription.release;\n  }, [componentName, getLoadable, recoilValue, storeRef]);\n  return loadable;\n}\n/**\n  Like useRecoilValue(), but either returns the value if available or\n  just undefined if not available for any reason, such as pending or error.\n*/\n\n\nfunction useRecoilValueLoadable(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValueLoadable');\n  }\n\n  if (Recoil_gkx('recoil_memory_managament_2020')) {\n    // eslint-disable-next-line fb-www/react-hooks\n    Recoil_useRetain(recoilValue);\n  }\n\n  return {\n    TRANSITION_SUPPORT: useRecoilValueLoadable_TRANSITION_SUPPORT,\n    SYNC_EXTERNAL_STORE: useRecoilValueLoadable_SYNC_EXTERNAL_STORE,\n    MUTABLE_SOURCE: useRecoilValueLoadable_MUTABLE_SOURCE,\n    LEGACY: useRecoilValueLoadable_LEGACY\n  }[reactMode$3().mode](recoilValue);\n}\n/**\n  Returns the value represented by the RecoilValue.\n  If the value is pending, it will throw a Promise to suspend the component,\n  if the value is an error it will throw it for the nearest React error boundary.\n  This will also subscribe the component for any updates in the value.\n  */\n\n\nfunction useRecoilValue(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValue');\n  }\n\n  const storeRef = useStoreRef$2();\n  const loadable = useRecoilValueLoadable(recoilValue);\n  return handleLoadable(loadable, recoilValue, storeRef);\n}\n/**\n  Returns a function that allows the value of a RecoilState to be updated, but does\n  not subscribe the component to changes to that RecoilState.\n*/\n\n\nfunction useSetRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useSetRecoilState');\n  }\n\n  const storeRef = useStoreRef$2();\n  return useCallback$1(newValueOrUpdater => {\n    setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);\n  }, [storeRef, recoilState]);\n}\n/**\n  Returns a function that will reset the value of a RecoilState to its default\n*/\n\n\nfunction useResetRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useResetRecoilState');\n  }\n\n  const storeRef = useStoreRef$2();\n  return useCallback$1(() => {\n    setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n  }, [storeRef, recoilState]);\n}\n/**\n  Equivalent to useState(). Allows the value of the RecoilState to be read and written.\n  Subsequent updates to the RecoilState will cause the component to re-render. If the\n  RecoilState is pending, this will suspend the component and initiate the\n  retrieval of the value. If evaluating the RecoilState resulted in an error, this will\n  throw the error so that the nearest React error boundary can catch it.\n*/\n\n\nfunction useRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilState');\n  }\n\n  return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];\n}\n/**\n  Like useRecoilState(), but does not cause Suspense or React error handling. Returns\n  an object that indicates whether the RecoilState is available, pending, or\n  unavailable due to an error.\n*/\n\n\nfunction useRecoilStateLoadable(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilStateLoadable');\n  }\n\n  return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];\n}\n\nfunction useSetUnvalidatedAtomValues() {\n  const storeRef = useStoreRef$2();\n  return (values, transactionMetadata = {}) => {\n    batchUpdates$2(() => {\n      storeRef.current.addTransactionMetadata(transactionMetadata);\n      values.forEach((value, key) => setUnvalidatedRecoilValue$2(storeRef.current, new AbstractRecoilValue$3(key), value));\n    });\n  };\n}\n/**\n * Experimental variants of hooks with support for useTransition()\n */\n\n\nfunction useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE');\n\n    if (!reactMode$3().early) {\n      Recoil_recoverableViolation('Attepmt to use a hook with UNSTABLE_TRANSITION_SUPPORT in a rendering mode incompatible with concurrent rendering.  Try enabling the recoil_sync_external_store or recoil_transition_support GKs.');\n    }\n  }\n\n  if (Recoil_gkx('recoil_memory_managament_2020')) {\n    // eslint-disable-next-line fb-www/react-hooks\n    Recoil_useRetain(recoilValue);\n  }\n\n  return useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue);\n}\n\nfunction useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValue_TRANSITION_SUPPORT_UNSTABLE');\n  }\n\n  const storeRef = useStoreRef$2();\n  const loadable = useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue);\n  return handleLoadable(loadable, recoilValue, storeRef);\n}\n\nfunction useRecoilState_TRANSITION_SUPPORT_UNSTABLE(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilState_TRANSITION_SUPPORT_UNSTABLE');\n  }\n\n  return [useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilState), useSetRecoilState(recoilState)];\n}\n\nvar Recoil_Hooks = {\n  recoilComponentGetRecoilValueCount_FOR_TESTING,\n  useRecoilInterface: useRecoilInterface_DEPRECATED,\n  useRecoilState,\n  useRecoilStateLoadable,\n  useRecoilValue,\n  useRecoilValueLoadable,\n  useResetRecoilState,\n  useSetRecoilState,\n  useSetUnvalidatedAtomValues,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Returns a map containing all of the keys + values from the original map where\n * the given callback returned true.\n */\n\nfunction filterMap(map, callback) {\n  const result = new Map();\n\n  for (const [key, value] of map) {\n    if (callback(value, key)) {\n      result.set(key, value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_filterMap = filterMap;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Returns a set containing all of the values from the original set where\n * the given callback returned true.\n */\n\nfunction filterSet(set, callback) {\n  const result = new Set();\n\n  for (const value of set) {\n    if (callback(value)) {\n      result.add(value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_filterSet = filterSet;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction mergeMaps(...maps) {\n  const result = new Map();\n\n  for (let i = 0; i < maps.length; i++) {\n    const iterator = maps[i].keys();\n    let nextKey;\n\n    while (!(nextKey = iterator.next()).done) {\n      // $FlowIssue[incompatible-call] - map/iterator knows nothing about flow types\n      result.set(nextKey.value, maps[i].get(nextKey.value));\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_mergeMaps = mergeMaps;\nconst {\n  batchUpdates: batchUpdates$3\n} = Recoil_Batching;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$3,\n  getNode: getNode$4,\n  nodes: nodes$1\n} = Recoil_Node;\nconst {\n  useStoreRef: useStoreRef$3\n} = Recoil_RecoilRoot;\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$4,\n  setRecoilValueLoadable: setRecoilValueLoadable$1\n} = Recoil_RecoilValueInterface;\nconst {\n  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$2\n} = Recoil_Retention;\nconst {\n  cloneSnapshot: cloneSnapshot$1\n} = Recoil_Snapshot$1;\nconst {\n  useCallback: useCallback$2,\n  useEffect: useEffect$4,\n  useRef: useRef$5,\n  useState: useState$2\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\nconst {\n  isSSR: isSSR$3\n} = Recoil_Environment;\n\nfunction useTransactionSubscription(callback) {\n  const storeRef = useStoreRef$3();\n  useEffect$4(() => {\n    const sub = storeRef.current.subscribeToTransactions(callback);\n    return sub.release;\n  }, [callback, storeRef]);\n}\n\nfunction externallyVisibleAtomValuesInState(state) {\n  const atomValues = state.atomValues.toMap();\n  const persistedAtomContentsValues = Recoil_mapMap(Recoil_filterMap(atomValues, (v, k) => {\n    const node = getNode$4(k);\n    const persistence = node.persistence_UNSTABLE;\n    return persistence != null && persistence.type !== 'none' && v.state === 'hasValue';\n  }), v => v.contents); // Merge in nonvalidated atoms; we may not have defs for them but they will\n  // all have persistence on or they wouldn't be there in the first place.\n\n  return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(), persistedAtomContentsValues);\n}\n/**\n  Calls the given callback after any atoms have been modified and the consequent\n  component re-renders have been committed. This is intended for persisting\n  the values of the atoms to storage. The stored values can then be restored\n  using the useSetUnvalidatedAtomValues hook.\n\n  The callback receives the following info:\n\n  atomValues: The current value of every atom that is both persistable (persistence\n              type not set to 'none') and whose value is available (not in an\n              error or loading state).\n\n  previousAtomValues: The value of every persistable and available atom before\n               the transaction began.\n\n  atomInfo: A map containing the persistence settings for each atom. Every key\n            that exists in atomValues will also exist in atomInfo.\n\n  modifiedAtoms: The set of atoms that were written to during the transaction.\n\n  transactionMetadata: Arbitrary information that was added via the\n          useSetUnvalidatedAtomValues hook. Useful for ignoring the useSetUnvalidatedAtomValues\n          transaction, to avoid loops.\n*/\n\n\nfunction useTransactionObservation_DEPRECATED(callback) {\n  useTransactionSubscription(useCallback$2(store => {\n    let previousTree = store.getState().previousTree;\n    const currentTree = store.getState().currentTree;\n\n    if (!previousTree) {\n      Recoil_recoverableViolation('Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil');\n      previousTree = store.getState().currentTree; // attempt to trundle on\n    }\n\n    const atomValues = externallyVisibleAtomValuesInState(currentTree);\n    const previousAtomValues = externallyVisibleAtomValuesInState(previousTree);\n    const atomInfo = Recoil_mapMap(nodes$1, node => {\n      var _node$persistence_UNS, _node$persistence_UNS2, _node$persistence_UNS3, _node$persistence_UNS4;\n\n      return {\n        persistence_UNSTABLE: {\n          type: (_node$persistence_UNS = (_node$persistence_UNS2 = node.persistence_UNSTABLE) === null || _node$persistence_UNS2 === void 0 ? void 0 : _node$persistence_UNS2.type) !== null && _node$persistence_UNS !== void 0 ? _node$persistence_UNS : 'none',\n          backButton: (_node$persistence_UNS3 = (_node$persistence_UNS4 = node.persistence_UNSTABLE) === null || _node$persistence_UNS4 === void 0 ? void 0 : _node$persistence_UNS4.backButton) !== null && _node$persistence_UNS3 !== void 0 ? _node$persistence_UNS3 : false\n        }\n      };\n    }); // Filter on existance in atomValues so that externally-visible rules\n    // are also applied to modified atoms (specifically exclude selectors):\n\n    const modifiedAtoms = Recoil_filterSet(currentTree.dirtyAtoms, k => atomValues.has(k) || previousAtomValues.has(k));\n    callback({\n      atomValues,\n      previousAtomValues,\n      atomInfo,\n      modifiedAtoms,\n      transactionMetadata: { ...currentTree.transactionMetadata\n      }\n    });\n  }, [callback]));\n}\n\nfunction useRecoilTransactionObserver(callback) {\n  useTransactionSubscription(useCallback$2(store => {\n    const snapshot = cloneSnapshot$1(store, 'latest');\n    const previousSnapshot = cloneSnapshot$1(store, 'previous');\n    callback({\n      snapshot,\n      previousSnapshot\n    });\n  }, [callback]));\n} // Return a snapshot of the current state and subscribe to all state changes\n\n\nfunction useRecoilSnapshot() {\n  const storeRef = useStoreRef$3();\n  const [snapshot, setSnapshot] = useState$2(() => cloneSnapshot$1(storeRef.current));\n  const previousSnapshot = Recoil_usePrevious(snapshot);\n  const timeoutID = useRef$5();\n  const releaseRef = useRef$5();\n  useTransactionSubscription(useCallback$2(store => setSnapshot(cloneSnapshot$1(store)), [])); // Retain snapshot for duration component is mounted\n\n  useEffect$4(() => {\n    const release = snapshot.retain(); // Release the retain from the rendering call\n\n    if (timeoutID.current && !isSSR$3) {\n      var _releaseRef$current;\n\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n      (_releaseRef$current = releaseRef.current) === null || _releaseRef$current === void 0 ? void 0 : _releaseRef$current.call(releaseRef);\n      releaseRef.current = null;\n    }\n\n    return () => {\n      // Defer the release.  If \"Fast Refresh\"\" is used then the component may\n      // re-render with the same state.  The previous cleanup will then run and\n      // then the new effect will run. We don't want the snapshot to be released\n      // by that cleanup before the new effect has a chance to retain it again.\n      // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936\n      window.setTimeout(release, 10);\n    };\n  }, [snapshot]); // Retain snapshot until above effect is run.\n  // Release after a threshold in case component is suspended.\n\n  if (previousSnapshot !== snapshot && !isSSR$3) {\n    // Release the previous snapshot\n    if (timeoutID.current) {\n      var _releaseRef$current2;\n\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n      (_releaseRef$current2 = releaseRef.current) === null || _releaseRef$current2 === void 0 ? void 0 : _releaseRef$current2.call(releaseRef);\n      releaseRef.current = null;\n    }\n\n    releaseRef.current = snapshot.retain();\n    timeoutID.current = window.setTimeout(() => {\n      var _releaseRef$current3;\n\n      timeoutID.current = null;\n      (_releaseRef$current3 = releaseRef.current) === null || _releaseRef$current3 === void 0 ? void 0 : _releaseRef$current3.call(releaseRef);\n      releaseRef.current = null;\n    }, SUSPENSE_TIMEOUT_MS$2);\n  }\n\n  return snapshot;\n}\n\nfunction gotoSnapshot(store, snapshot) {\n  var _storeState$nextTree;\n\n  const storeState = store.getState();\n  const prev = (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree;\n  const next = snapshot.getStore_INTERNAL().getState().currentTree;\n  batchUpdates$3(() => {\n    const keysToUpdate = new Set();\n\n    for (const keys of [prev.atomValues.keys(), next.atomValues.keys()]) {\n      for (const key of keys) {\n        var _prev$atomValues$get, _next$atomValues$get;\n\n        if (((_prev$atomValues$get = prev.atomValues.get(key)) === null || _prev$atomValues$get === void 0 ? void 0 : _prev$atomValues$get.contents) !== ((_next$atomValues$get = next.atomValues.get(key)) === null || _next$atomValues$get === void 0 ? void 0 : _next$atomValues$get.contents) && getNode$4(key).shouldRestoreFromSnapshots) {\n          keysToUpdate.add(key);\n        }\n      }\n    }\n\n    keysToUpdate.forEach(key => {\n      setRecoilValueLoadable$1(store, new AbstractRecoilValue$4(key), next.atomValues.has(key) ? Recoil_nullthrows(next.atomValues.get(key)) : DEFAULT_VALUE$3);\n    });\n    store.replaceState(state => ({ ...state,\n      stateID: snapshot.getID()\n    }));\n  });\n}\n\nfunction useGotoRecoilSnapshot() {\n  const storeRef = useStoreRef$3();\n  return useCallback$2(snapshot => gotoSnapshot(storeRef.current, snapshot), [storeRef]);\n}\n\nvar Recoil_SnapshotHooks = {\n  useRecoilSnapshot,\n  gotoSnapshot,\n  useGotoRecoilSnapshot,\n  useRecoilTransactionObserver,\n  useTransactionObservation_DEPRECATED,\n  useTransactionSubscription_DEPRECATED: useTransactionSubscription\n};\nconst {\n  peekNodeInfo: peekNodeInfo$2\n} = Recoil_FunctionalCore;\nconst {\n  useStoreRef: useStoreRef$4\n} = Recoil_RecoilRoot;\n\nfunction useGetRecoilValueInfo() {\n  const storeRef = useStoreRef$4();\n  return ({\n    key\n  }) => peekNodeInfo$2(storeRef.current, storeRef.current.getState().currentTree, key);\n}\n\nvar Recoil_useGetRecoilValueInfo = useGetRecoilValueInfo;\nconst {\n  reactMode: reactMode$4\n} = Recoil_ReactMode;\nconst {\n  RecoilRoot: RecoilRoot$1,\n  useStoreRef: useStoreRef$5\n} = Recoil_RecoilRoot;\nconst {\n  useMemo: useMemo$2\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction useRecoilBridgeAcrossReactRoots() {\n  // The test fails when using useMutableSource(), but only if act() is used\n  // for the nested root.  So, this may only be a testing environment issue.\n  if (reactMode$4().mode === 'MUTABLE_SOURCE') {\n    // eslint-disable-next-line fb-www/no-console\n    console.warn('Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.');\n  }\n\n  const store = useStoreRef$5().current;\n  return useMemo$2(() => {\n    // eslint-disable-next-line no-shadow\n    function RecoilBridge({\n      children\n    }) {\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RecoilRoot$1, {\n        store_INTERNAL: store\n      }, children);\n    }\n\n    return RecoilBridge;\n  }, [store]);\n}\n\nvar Recoil_useRecoilBridgeAcrossReactRoots = useRecoilBridgeAcrossReactRoots;\nconst {\n  loadableWithValue: loadableWithValue$1\n} = Recoil_Loadable$1;\nconst {\n  initializeNode: initializeNode$3\n} = Recoil_FunctionalCore;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$4,\n  getNode: getNode$5\n} = Recoil_Node;\nconst {\n  copyTreeState: copyTreeState$1,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$3,\n  invalidateDownstreams: invalidateDownstreams$1,\n  writeLoadableToTreeState: writeLoadableToTreeState$1\n} = Recoil_RecoilValueInterface;\n\nfunction isAtom(recoilValue) {\n  return getNode$5(recoilValue.key).nodeType === 'atom';\n}\n\nclass TransactionInterfaceImpl {\n  constructor(store, treeState) {\n    _defineProperty(this, \"_store\", void 0);\n\n    _defineProperty(this, \"_treeState\", void 0);\n\n    _defineProperty(this, \"_changes\", void 0);\n\n    _defineProperty(this, \"get\", recoilValue => {\n      if (this._changes.has(recoilValue.key)) {\n        // $FlowIssue[incompatible-return]\n        return this._changes.get(recoilValue.key);\n      }\n\n      if (!isAtom(recoilValue)) {\n        throw Recoil_err('Reading selectors within atomicUpdate is not supported');\n      }\n\n      const loadable = getRecoilValueAsLoadable$3(this._store, recoilValue, this._treeState);\n\n      if (loadable.state === 'hasValue') {\n        return loadable.contents;\n      } else if (loadable.state === 'hasError') {\n        throw loadable.contents;\n      } else {\n        throw Recoil_err(`Expected Recoil atom ${recoilValue.key} to have a value, but it is in a loading state.`);\n      }\n    });\n\n    _defineProperty(this, \"set\", (recoilState, valueOrUpdater) => {\n      if (!isAtom(recoilState)) {\n        throw Recoil_err('Setting selectors within atomicUpdate is not supported');\n      }\n\n      if (typeof valueOrUpdater === 'function') {\n        const current = this.get(recoilState);\n\n        this._changes.set(recoilState.key, valueOrUpdater(current)); // flowlint-line unclear-type:off\n\n      } else {\n        // Initialize atom and run effects if not initialized yet\n        initializeNode$3(this._store, recoilState.key, 'set');\n\n        this._changes.set(recoilState.key, valueOrUpdater);\n      }\n    });\n\n    _defineProperty(this, \"reset\", recoilState => {\n      this.set(recoilState, DEFAULT_VALUE$4);\n    });\n\n    this._store = store;\n    this._treeState = treeState;\n    this._changes = new Map();\n  } // Allow destructing\n  // eslint-disable-next-line fb-www/extra-arrow-initializer\n\n\n  newTreeState_INTERNAL() {\n    if (this._changes.size === 0) {\n      return this._treeState;\n    }\n\n    const newState = copyTreeState$1(this._treeState);\n\n    for (const [k, v] of this._changes) {\n      writeLoadableToTreeState$1(newState, k, loadableWithValue$1(v));\n    }\n\n    invalidateDownstreams$1(this._store, newState);\n    return newState;\n  }\n\n}\n\nfunction atomicUpdater(store) {\n  return fn => {\n    store.replaceState(treeState => {\n      const changeset = new TransactionInterfaceImpl(store, treeState);\n      fn(changeset);\n      return changeset.newTreeState_INTERNAL();\n    });\n  };\n}\n\nvar Recoil_AtomicUpdates = {\n  atomicUpdater\n};\nvar Recoil_AtomicUpdates_1 = Recoil_AtomicUpdates.atomicUpdater;\nvar Recoil_AtomicUpdates$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  atomicUpdater: Recoil_AtomicUpdates_1\n});\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nvar invariant_1 = invariant; // @oss-only\n\nvar Recoil_invariant = invariant_1;\nconst {\n  atomicUpdater: atomicUpdater$1\n} = Recoil_AtomicUpdates$1;\nconst {\n  batchUpdates: batchUpdates$4\n} = Recoil_Batching;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$5\n} = Recoil_Node;\nconst {\n  useStoreRef: useStoreRef$6\n} = Recoil_RecoilRoot;\nconst {\n  refreshRecoilValue: refreshRecoilValue$1,\n  setRecoilValue: setRecoilValue$3\n} = Recoil_RecoilValueInterface;\nconst {\n  cloneSnapshot: cloneSnapshot$2\n} = Recoil_Snapshot$1;\nconst {\n  gotoSnapshot: gotoSnapshot$1\n} = Recoil_SnapshotHooks;\nconst {\n  useCallback: useCallback$3\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nclass Sentinel {}\n\nconst SENTINEL = new Sentinel();\n\nfunction recoilCallback(store, fn, args, extraInterface) {\n  let ret = SENTINEL;\n  let releaseSnapshot;\n  batchUpdates$4(() => {\n    const errMsg = 'useRecoilCallback() expects a function that returns a function: ' + 'it accepts a function of the type (RecoilInterface) => (Args) => ReturnType ' + 'and returns a callback function (Args) => ReturnType, where RecoilInterface is ' + 'an object {snapshot, set, ...} and Args and ReturnType are the argument and return ' + 'types of the callback you want to create.  Please see the docs ' + 'at recoiljs.org for details.';\n\n    if (typeof fn !== 'function') {\n      throw Recoil_err(errMsg);\n    } // Clone the snapshot lazily to avoid overhead if the callback does not use it.\n    // Note that this means the snapshot may represent later state from when\n    // the callback was called if it first accesses the snapshot asynchronously.\n\n\n    const callbackInterface = Recoil_lazyProxy({ ...(extraInterface !== null && extraInterface !== void 0 ? extraInterface : {}),\n      // flowlint-line unclear-type:off\n      set: (node, newValue) => setRecoilValue$3(store, node, newValue),\n      reset: node => setRecoilValue$3(store, node, DEFAULT_VALUE$5),\n      refresh: node => refreshRecoilValue$1(store, node),\n      gotoSnapshot: snapshot => gotoSnapshot$1(store, snapshot),\n      transact_UNSTABLE: transaction => atomicUpdater$1(store)(transaction)\n    }, {\n      snapshot: () => {\n        const snapshot = cloneSnapshot$2(store);\n        releaseSnapshot = snapshot.retain();\n        return snapshot;\n      }\n    });\n    const callback = fn(callbackInterface);\n\n    if (typeof callback !== 'function') {\n      throw Recoil_err(errMsg);\n    }\n\n    ret = callback(...args);\n  });\n  !!(ret instanceof Sentinel) ?  true ? Recoil_invariant(false, 'batchUpdates should return immediately') : 0 : void 0;\n\n  if (Recoil_isPromise(ret)) {\n    ret.finally(() => {\n      var _releaseSnapshot;\n\n      (_releaseSnapshot = releaseSnapshot) === null || _releaseSnapshot === void 0 ? void 0 : _releaseSnapshot();\n    });\n  } else {\n    var _releaseSnapshot2;\n\n    (_releaseSnapshot2 = releaseSnapshot) === null || _releaseSnapshot2 === void 0 ? void 0 : _releaseSnapshot2();\n  } // $FlowFixMe[incompatible-cast]\n\n\n  return ret;\n}\n\nfunction useRecoilCallback(fn, deps) {\n  const storeRef = useStoreRef$6();\n  return useCallback$3( // $FlowIssue[incompatible-call]\n  (...args) => {\n    return recoilCallback(storeRef.current, fn, args);\n  }, deps != null ? [...deps, storeRef] : undefined // eslint-disable-line fb-www/react-hooks-deps\n  );\n}\n\nvar Recoil_useRecoilCallback = {\n  recoilCallback,\n  useRecoilCallback\n};\nconst {\n  useStoreRef: useStoreRef$7\n} = Recoil_RecoilRoot;\nconst {\n  refreshRecoilValue: refreshRecoilValue$2\n} = Recoil_RecoilValueInterface;\nconst {\n  useCallback: useCallback$4\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction useRecoilRefresher(recoilValue) {\n  const storeRef = useStoreRef$7();\n  return useCallback$4(() => {\n    const store = storeRef.current;\n    refreshRecoilValue$2(store, recoilValue);\n  }, [recoilValue, storeRef]);\n}\n\nvar Recoil_useRecoilRefresher = useRecoilRefresher;\nconst {\n  atomicUpdater: atomicUpdater$2\n} = Recoil_AtomicUpdates$1;\nconst {\n  useStoreRef: useStoreRef$8\n} = Recoil_RecoilRoot;\nconst {\n  useMemo: useMemo$3\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction useRecoilTransaction(fn, deps) {\n  const storeRef = useStoreRef$8();\n  return useMemo$3(() => (...args) => {\n    const atomicUpdate = atomicUpdater$2(storeRef.current);\n    atomicUpdate(transactionInterface => {\n      fn(transactionInterface)(...args);\n    });\n  }, deps != null ? [...deps, storeRef] : undefined // eslint-disable-line fb-www/react-hooks-deps\n  );\n}\n\nvar Recoil_useRecoilTransaction = useRecoilTransaction;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nclass WrappedValue {\n  constructor(value) {\n    _defineProperty(this, \"value\", void 0);\n\n    this.value = value;\n  }\n\n}\n\nvar Recoil_Wrapper = {\n  WrappedValue\n};\nvar Recoil_Wrapper_1 = Recoil_Wrapper.WrappedValue;\nvar Recoil_Wrapper$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  WrappedValue: Recoil_Wrapper_1\n});\nconst {\n  isFastRefreshEnabled: isFastRefreshEnabled$2\n} = Recoil_ReactMode;\n\nclass ChangedPathError extends Error {}\n\nclass TreeCache {\n  // $FlowIssue[unclear-type]\n  constructor(options) {\n    var _options$onHit, _options$onSet, _options$mapNodeValue;\n\n    _defineProperty(this, \"_name\", void 0);\n\n    _defineProperty(this, \"_numLeafs\", void 0);\n\n    _defineProperty(this, \"_root\", void 0);\n\n    _defineProperty(this, \"_onHit\", void 0);\n\n    _defineProperty(this, \"_onSet\", void 0);\n\n    _defineProperty(this, \"_mapNodeValue\", void 0);\n\n    this._name = options === null || options === void 0 ? void 0 : options.name;\n    this._numLeafs = 0;\n    this._root = null;\n    this._onHit = (_options$onHit = options === null || options === void 0 ? void 0 : options.onHit) !== null && _options$onHit !== void 0 ? _options$onHit : () => {};\n    this._onSet = (_options$onSet = options === null || options === void 0 ? void 0 : options.onSet) !== null && _options$onSet !== void 0 ? _options$onSet : () => {};\n    this._mapNodeValue = (_options$mapNodeValue = options === null || options === void 0 ? void 0 : options.mapNodeValue) !== null && _options$mapNodeValue !== void 0 ? _options$mapNodeValue : val => val;\n  }\n\n  size() {\n    return this._numLeafs;\n  } // $FlowIssue[unclear-type]\n\n\n  root() {\n    return this._root;\n  }\n\n  get(getNodeValue, handlers) {\n    var _this$getLeafNode;\n\n    return (_this$getLeafNode = this.getLeafNode(getNodeValue, handlers)) === null || _this$getLeafNode === void 0 ? void 0 : _this$getLeafNode.value;\n  }\n\n  getLeafNode(getNodeValue, handlers) {\n    if (this._root == null) {\n      return undefined;\n    } // Iterate down the tree based on the current node values until we hit a leaf\n    // $FlowIssue[unclear-type]\n\n\n    let node = this._root;\n\n    while (node) {\n      handlers === null || handlers === void 0 ? void 0 : handlers.onNodeVisit(node);\n\n      if (node.type === 'leaf') {\n        this._onHit(node);\n\n        return node;\n      }\n\n      const nodeValue = this._mapNodeValue(getNodeValue(node.nodeKey));\n\n      node = node.branches.get(nodeValue);\n    }\n\n    return undefined;\n  }\n\n  set(route, value, handlers) {\n    const addLeaf = () => {\n      var _node2, _node3, _this$_root2, _handlers$onNodeVisit2; // First, setup the branch nodes for the route:\n      // Iterate down the tree to find or add branch nodes following the route\n\n\n      let node;\n      let branchKey;\n\n      for (const [nodeKey, nodeValue] of route) {\n        var _node, _handlers$onNodeVisit, _this$_root; // If the previous root was a leaf, while we not have a get(), it means\n        // the selector has inconsistent values or implementation changed.\n\n\n        const root = this._root;\n\n        if ((root === null || root === void 0 ? void 0 : root.type) === 'leaf') {\n          throw this.invalidCacheError();\n        } // node now refers to the next node down in the tree\n\n\n        const parent = node; // $FlowFixMe[prop-missing]\n        // $FlowFixMe[incompatible-type]\n\n        node = parent ? parent.branches.get(branchKey) : root; // $FlowFixMe[prop-missing]\n        // $FlowFixMe[incompatible-type]\n\n        node = (_node = node) !== null && _node !== void 0 ? _node : {\n          type: 'branch',\n          nodeKey,\n          parent,\n          branches: new Map(),\n          branchKey\n        }; // If we found an existing node, confirm it has a consistent value\n\n        if (node.type !== 'branch' || node.nodeKey !== nodeKey) {\n          throw this.invalidCacheError();\n        } // Add the branch node to the tree\n\n\n        parent === null || parent === void 0 ? void 0 : parent.branches.set(branchKey, node);\n        handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit = handlers.onNodeVisit) === null || _handlers$onNodeVisit === void 0 ? void 0 : _handlers$onNodeVisit.call(handlers, node); // Prepare for next iteration and install root if it is new.\n\n        branchKey = this._mapNodeValue(nodeValue);\n        this._root = (_this$_root = this._root) !== null && _this$_root !== void 0 ? _this$_root : node;\n      } // Second, setup the leaf node:\n      // If there is an existing leaf for this route confirm it is consistent\n\n\n      const oldLeaf = node ? (_node2 = node) === null || _node2 === void 0 ? void 0 : _node2.branches.get(branchKey) : this._root;\n\n      if (oldLeaf != null && (oldLeaf.type !== 'leaf' || oldLeaf.branchKey !== branchKey)) {\n        throw this.invalidCacheError();\n      } // Create a new or replacement leaf.\n\n\n      const leafNode = {\n        type: 'leaf',\n        value,\n        parent: node,\n        branchKey\n      }; // Install the leaf and call handlers\n\n      (_node3 = node) === null || _node3 === void 0 ? void 0 : _node3.branches.set(branchKey, leafNode);\n      this._root = (_this$_root2 = this._root) !== null && _this$_root2 !== void 0 ? _this$_root2 : leafNode;\n      this._numLeafs++;\n\n      this._onSet(leafNode);\n\n      handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit2 = handlers.onNodeVisit) === null || _handlers$onNodeVisit2 === void 0 ? void 0 : _handlers$onNodeVisit2.call(handlers, leafNode);\n    };\n\n    try {\n      addLeaf();\n    } catch (error) {\n      // If the cache was stale or observed inconsistent values, such as with\n      // Fast Refresh, then clear it and rebuild with the new values.\n      if (error instanceof ChangedPathError) {\n        this.clear();\n        addLeaf();\n      } else {\n        throw error;\n      }\n    }\n  } // Returns true if leaf was actually deleted from the tree\n\n\n  delete(leaf) {\n    const root = this.root();\n\n    if (!root) {\n      return false;\n    }\n\n    if (leaf === root) {\n      this._root = null;\n      this._numLeafs = 0;\n      return true;\n    } // Iterate up from the leaf deleteing it from it's parent's branches.\n\n\n    let node = leaf.parent;\n    let branchKey = leaf.branchKey;\n\n    while (node) {\n      var _node4;\n\n      node.branches.delete(branchKey); // Stop iterating if we hit the root.\n\n      if (node === root) {\n        if (node.branches.size === 0) {\n          this._root = null;\n          this._numLeafs = 0;\n        } else {\n          this._numLeafs--;\n        }\n\n        return true;\n      } // Stop iterating if there are other branches since we don't need to\n      // remove any more nodes.\n\n\n      if (node.branches.size > 0) {\n        break;\n      } // Iterate up to our parent\n\n\n      branchKey = (_node4 = node) === null || _node4 === void 0 ? void 0 : _node4.branchKey;\n      node = node.parent;\n    } // Confirm that the leaf we are deleting is actually attached to our tree\n\n\n    for (; node !== root; node = node.parent) {\n      if (node == null) {\n        return false;\n      }\n    }\n\n    this._numLeafs--;\n    return true;\n  }\n\n  clear() {\n    this._numLeafs = 0;\n    this._root = null;\n  }\n\n  invalidCacheError() {\n    const CHANGED_PATH_ERROR_MESSAGE = isFastRefreshEnabled$2() ? 'Possible Fast Refresh module reload detected.  ' + 'This may also be caused by an selector returning inconsistent values. ' + 'Resetting cache.' : 'Invalid cache values.  This happens when selectors do not return ' + 'consistent values for the same input dependency values.  That may also ' + 'be caused when using Fast Refresh to change a selector implementation.  ' + 'Resetting cache.';\n    Recoil_recoverableViolation(CHANGED_PATH_ERROR_MESSAGE + (this._name != null ? ` - ${this._name}` : ''));\n    throw new ChangedPathError();\n  }\n\n}\n\nvar Recoil_TreeCache = {\n  TreeCache\n};\nvar Recoil_TreeCache_1 = Recoil_TreeCache.TreeCache;\nvar Recoil_TreeCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  TreeCache: Recoil_TreeCache_1\n});\n\nclass LRUCache {\n  constructor(options) {\n    var _options$mapKey;\n\n    _defineProperty(this, \"_maxSize\", void 0);\n\n    _defineProperty(this, \"_size\", void 0);\n\n    _defineProperty(this, \"_head\", void 0);\n\n    _defineProperty(this, \"_tail\", void 0);\n\n    _defineProperty(this, \"_map\", void 0);\n\n    _defineProperty(this, \"_keyMapper\", void 0);\n\n    this._maxSize = options.maxSize;\n    this._size = 0;\n    this._head = null;\n    this._tail = null;\n    this._map = new Map();\n    this._keyMapper = (_options$mapKey = options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : v => v;\n  }\n\n  head() {\n    return this._head;\n  }\n\n  tail() {\n    return this._tail;\n  }\n\n  size() {\n    return this._size;\n  }\n\n  maxSize() {\n    return this._maxSize;\n  }\n\n  has(key) {\n    return this._map.has(this._keyMapper(key));\n  }\n\n  get(key) {\n    const mappedKey = this._keyMapper(key);\n\n    const node = this._map.get(mappedKey);\n\n    if (!node) {\n      return undefined;\n    }\n\n    this.set(key, node.value);\n    return node.value;\n  }\n\n  set(key, val) {\n    const mappedKey = this._keyMapper(key);\n\n    const existingNode = this._map.get(mappedKey);\n\n    if (existingNode) {\n      this.delete(key);\n    }\n\n    const head = this.head();\n    const node = {\n      key,\n      right: head,\n      left: null,\n      value: val\n    };\n\n    if (head) {\n      head.left = node;\n    } else {\n      this._tail = node;\n    }\n\n    this._map.set(mappedKey, node);\n\n    this._head = node;\n    this._size++;\n\n    this._maybeDeleteLRU();\n  }\n\n  _maybeDeleteLRU() {\n    if (this.size() > this.maxSize()) {\n      this.deleteLru();\n    }\n  }\n\n  deleteLru() {\n    const tail = this.tail();\n\n    if (tail) {\n      this.delete(tail.key);\n    }\n  }\n\n  delete(key) {\n    const mappedKey = this._keyMapper(key);\n\n    if (!this._size || !this._map.has(mappedKey)) {\n      return;\n    }\n\n    const node = Recoil_nullthrows(this._map.get(mappedKey));\n    const right = node.right;\n    const left = node.left;\n\n    if (right) {\n      right.left = node.left;\n    }\n\n    if (left) {\n      left.right = node.right;\n    }\n\n    if (node === this.head()) {\n      this._head = right;\n    }\n\n    if (node === this.tail()) {\n      this._tail = left;\n    }\n\n    this._map.delete(mappedKey);\n\n    this._size--;\n  }\n\n  clear() {\n    this._size = 0;\n    this._head = null;\n    this._tail = null;\n    this._map = new Map();\n  }\n\n}\n\nvar Recoil_LRUCache = {\n  LRUCache\n};\nvar Recoil_LRUCache_1 = Recoil_LRUCache.LRUCache;\nvar Recoil_LRUCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  LRUCache: Recoil_LRUCache_1\n});\nconst {\n  LRUCache: LRUCache$1\n} = Recoil_LRUCache$1;\nconst {\n  TreeCache: TreeCache$1\n} = Recoil_TreeCache$1;\n\nfunction treeCacheLRU({\n  name,\n  maxSize,\n  mapNodeValue = v => v\n}) {\n  const lruCache = new LRUCache$1({\n    maxSize\n  });\n  const cache = new TreeCache$1({\n    name,\n    mapNodeValue,\n    onHit: node => {\n      lruCache.set(node, true);\n    },\n    onSet: node => {\n      const lruNode = lruCache.tail();\n      lruCache.set(node, true);\n\n      if (lruNode && cache.size() > maxSize) {\n        cache.delete(lruNode.key);\n      }\n    }\n  });\n  return cache;\n}\n\nvar Recoil_treeCacheLRU = treeCacheLRU;\nconst TIME_WARNING_THRESHOLD_MS = 15;\n\nfunction stringify(x, opt, key) {\n  // A optimization to avoid the more expensive JSON.stringify() for simple strings\n  // This may lose protection for u2028 and u2029, though.\n  if (typeof x === 'string' && !x.includes('\"') && !x.includes('\\\\')) {\n    return `\"${x}\"`;\n  } // Handle primitive types\n\n\n  switch (typeof x) {\n    case 'undefined':\n      return '';\n    // JSON.stringify(undefined) returns undefined, but we always want to return a string\n\n    case 'boolean':\n      return x ? 'true' : 'false';\n\n    case 'number':\n    case 'symbol':\n      // case 'bigint': // BigInt is not supported in www\n      return String(x);\n\n    case 'string':\n      // Add surrounding quotes and escape internal quotes\n      return JSON.stringify(x);\n\n    case 'function':\n      if ((opt === null || opt === void 0 ? void 0 : opt.allowFunctions) !== true) {\n        throw Recoil_err('Attempt to serialize function in a Recoil cache key');\n      }\n\n      return `__FUNCTION(${x.name})__`;\n  }\n\n  if (x === null) {\n    return 'null';\n  } // Fallback case for unknown types\n\n\n  if (typeof x !== 'object') {\n    var _JSON$stringify;\n\n    return (_JSON$stringify = JSON.stringify(x)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : '';\n  } // Deal with all promises as equivalent for now.\n\n\n  if (Recoil_isPromise(x)) {\n    return '__PROMISE__';\n  } // Arrays handle recursive stringification\n\n\n  if (Array.isArray(x)) {\n    return `[${x.map((v, i) => stringify(v, opt, i.toString()))}]`;\n  } // If an object defines a toJSON() method, then use that to override the\n  // serialization.  This matches the behavior of JSON.stringify().\n  // Pass the key for compatibility.\n  // Immutable.js collections define this method to allow us to serialize them.\n\n\n  if (typeof x.toJSON === 'function') {\n    // flowlint-next-line unclear-type: off\n    return stringify(x.toJSON(key), opt, key);\n  } // For built-in Maps, sort the keys in a stable order instead of the\n  // default insertion order.  Support non-string keys.\n\n\n  if (x instanceof Map) {\n    const obj = {};\n\n    for (const [k, v] of x) {\n      // Stringify will escape any nested quotes\n      obj[typeof k === 'string' ? k : stringify(k, opt)] = v;\n    }\n\n    return stringify(obj, opt, key);\n  } // For built-in Sets, sort the keys in a stable order instead of the\n  // default insertion order.\n\n\n  if (x instanceof Set) {\n    return stringify(Array.from(x).sort((a, b) => stringify(a, opt).localeCompare(stringify(b, opt))), opt, key);\n  } // Anything else that is iterable serialize as an Array.\n\n\n  if (Symbol !== undefined && x[Symbol.iterator] != null && typeof x[Symbol.iterator] === 'function') {\n    // flowlint-next-line unclear-type: off\n    return stringify(Array.from(x), opt, key);\n  } // For all other Objects, sort the keys in a stable order.\n\n\n  return `{${Object.keys(x).filter(k => x[k] !== undefined).sort() // stringify the key to add quotes and escape any nested slashes or quotes.\n  .map(k => `${stringify(k, opt)}:${stringify(x[k], opt, k)}`).join(',')}}`;\n} // Utility similar to JSON.stringify() except:\n// * Serialize built-in Sets as an Array\n// * Serialize built-in Maps as an Object.  Supports non-string keys.\n// * Serialize other iterables as arrays\n// * Sort the keys of Objects and Maps to have a stable order based on string conversion.\n//    This overrides their default insertion order.\n// * Still uses toJSON() of any object to override serialization\n// * Support Symbols (though don't guarantee uniqueness)\n// * We could support BigInt, but Flow doesn't seem to like it.\n// See Recoil_stableStringify-test.js for examples\n\n\nfunction stableStringify(x, opt = {\n  allowFunctions: false\n}) {\n  if (true) {\n    if (typeof window !== 'undefined') {\n      const startTime = window.performance ? window.performance.now() : 0;\n      const str = stringify(x, opt);\n      const endTime = window.performance ? window.performance.now() : 0;\n\n      if (endTime - startTime > TIME_WARNING_THRESHOLD_MS) {\n        /* eslint-disable fb-www/no-console */\n        console.groupCollapsed(`Recoil: Spent ${endTime - startTime}ms computing a cache key`);\n        console.warn(x, str);\n        console.groupEnd();\n        /* eslint-enable fb-www/no-console */\n      }\n\n      return str;\n    }\n  }\n\n  return stringify(x, opt);\n}\n\nvar Recoil_stableStringify = stableStringify;\nconst {\n  TreeCache: TreeCache$2\n} = Recoil_TreeCache$1;\nconst defaultPolicy = {\n  equality: 'reference',\n  eviction: 'keep-all',\n  maxSize: Infinity\n};\n\nfunction treeCacheFromPolicy({\n  equality = defaultPolicy.equality,\n  eviction = defaultPolicy.eviction,\n  maxSize = defaultPolicy.maxSize\n} = defaultPolicy, name) {\n  const valueMapper = getValueMapper(equality);\n  return getTreeCache(eviction, maxSize, valueMapper, name);\n}\n\nfunction getValueMapper(equality) {\n  switch (equality) {\n    case 'reference':\n      return val => val;\n\n    case 'value':\n      return val => Recoil_stableStringify(val);\n  }\n\n  throw Recoil_err(`Unrecognized equality policy ${equality}`);\n}\n\nfunction getTreeCache(eviction, maxSize, mapNodeValue, name) {\n  switch (eviction) {\n    case 'keep-all':\n      return new TreeCache$2({\n        name,\n        mapNodeValue\n      });\n\n    case 'lru':\n      return Recoil_treeCacheLRU({\n        name,\n        maxSize: Recoil_nullthrows(maxSize),\n        mapNodeValue\n      });\n\n    case 'most-recent':\n      return Recoil_treeCacheLRU({\n        name,\n        maxSize: 1,\n        mapNodeValue\n      });\n  }\n\n  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);\n}\n\nvar Recoil_treeCacheFromPolicy = treeCacheFromPolicy;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction isNode(object) {\n  var _ownerDocument, _doc$defaultView;\n\n  if (typeof window === 'undefined') {\n    return false;\n  }\n\n  const doc = object != null ? (_ownerDocument = object.ownerDocument) !== null && _ownerDocument !== void 0 ? _ownerDocument : object : document;\n  const defaultView = (_doc$defaultView = doc.defaultView) !== null && _doc$defaultView !== void 0 ? _doc$defaultView : window;\n  return !!(object != null && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));\n}\n\nvar Recoil_isNode = isNode;\nconst {\n  isReactNative: isReactNative$1,\n  isWindow: isWindow$1\n} = Recoil_Environment;\n\nfunction shouldNotBeFrozen(value) {\n  // Primitives and functions:\n  if (value === null || typeof value !== 'object') {\n    return true;\n  } // React elements:\n\n\n  switch (typeof value.$$typeof) {\n    case 'symbol':\n      return true;\n\n    case 'number':\n      return true;\n  } // Immutable structures:\n\n\n  if (value['@@__IMMUTABLE_ITERABLE__@@'] != null || value['@@__IMMUTABLE_KEYED__@@'] != null || value['@@__IMMUTABLE_INDEXED__@@'] != null || value['@@__IMMUTABLE_ORDERED__@@'] != null || value['@@__IMMUTABLE_RECORD__@@'] != null) {\n    return true;\n  } // DOM nodes:\n\n\n  if (Recoil_isNode(value)) {\n    return true;\n  }\n\n  if (Recoil_isPromise(value)) {\n    return true;\n  }\n\n  if (value instanceof Error) {\n    return true;\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return true;\n  } // Some environments, just as Jest, don't work with the instanceof check\n\n\n  if (!isReactNative$1 && isWindow$1(value)) {\n    return true;\n  }\n\n  return false;\n} // Recursively freeze a value to enforce it is read-only.\n// This may also have minimal performance improvements for enumerating\n// objects (based on browser implementations, of course)\n\n\nfunction deepFreezeValue(value) {\n  if (typeof value !== 'object' || shouldNotBeFrozen(value)) {\n    return;\n  }\n\n  Object.freeze(value); // Make all properties read-only\n\n  for (const key in value) {\n    // $FlowIssue[method-unbinding] added when improving typing for this parameters\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      const prop = value[key]; // Prevent infinite recurssion for circular references.\n\n      if (typeof prop === 'object' && prop != null && !Object.isFrozen(prop)) {\n        deepFreezeValue(prop);\n      }\n    }\n  }\n\n  Object.seal(value); // This also makes existing properties non-configurable.\n}\n\nvar Recoil_deepFreezeValue = deepFreezeValue;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is a stub for some integration into FB internal stuff\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction startPerfBlock(_id) {\n  return () => null;\n}\n\nvar Recoil_PerformanceTimings = {\n  startPerfBlock\n};\nconst {\n  isLoadable: isLoadable$1,\n  loadableWithError: loadableWithError$1,\n  loadableWithPromise: loadableWithPromise$1,\n  loadableWithValue: loadableWithValue$2\n} = Recoil_Loadable$1;\nconst {\n  WrappedValue: WrappedValue$1\n} = Recoil_Wrapper$1;\nconst {\n  getNodeLoadable: getNodeLoadable$2,\n  peekNodeLoadable: peekNodeLoadable$1,\n  setNodeValue: setNodeValue$3\n} = Recoil_FunctionalCore;\nconst {\n  saveDepsToStore: saveDepsToStore$1\n} = Recoil_Graph;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$6,\n  getConfigDeletionHandler: getConfigDeletionHandler$1,\n  getNode: getNode$6,\n  registerNode: registerNode$1\n} = Recoil_Node;\nconst {\n  isRecoilValue: isRecoilValue$3\n} = Recoil_RecoilValue$1;\nconst {\n  markRecoilValueModified: markRecoilValueModified$1\n} = Recoil_RecoilValueInterface;\nconst {\n  retainedByOptionWithDefault: retainedByOptionWithDefault$1\n} = Recoil_Retention;\nconst {\n  recoilCallback: recoilCallback$1\n} = Recoil_useRecoilCallback;\nconst {\n  startPerfBlock: startPerfBlock$1\n} = Recoil_PerformanceTimings;\n\nclass Canceled {}\n\nconst CANCELED = new Canceled();\n/**\n * An ExecutionID is an arbitrary ID that lets us distinguish executions from\n * each other. This is necessary as we need a way of solving this problem:\n * \"given 3 async executions, only update state for the 'latest' execution when\n * it finishes running regardless of when the other 2 finish\". ExecutionIDs\n * provide a convenient way of identifying executions so that we can track and\n * manage them over time.\n */\n\nconst dependencyStack = []; // for detecting circular dependencies.\n\nconst waitingStores = new Map();\n\nconst getNewExecutionID = (() => {\n  let executionID = 0;\n  return () => executionID++;\n})();\n/* eslint-disable no-redeclare */\n\n\nfunction selector(options) {\n  let recoilValue = null;\n  const {\n    key,\n    get,\n    cachePolicy_UNSTABLE: cachePolicy\n  } = options;\n  const set = options.set != null ? options.set : undefined; // flow\n\n  if (true) {\n    if (typeof key !== 'string') {\n      throw Recoil_err('A key option with a unique string value must be provided when creating a selector.');\n    }\n\n    if (typeof get !== 'function') {\n      throw Recoil_err('Selectors must specify a get callback option to get the selector value.');\n    }\n  } // This is every discovered dependency across all executions\n\n\n  const discoveredDependencyNodeKeys = new Set();\n  const cache = Recoil_treeCacheFromPolicy(cachePolicy !== null && cachePolicy !== void 0 ? cachePolicy : {\n    equality: 'reference',\n    eviction: 'keep-all'\n  }, key);\n  const retainedBy = retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE);\n  const executionInfoMap = new Map();\n  let liveStoresCount = 0;\n\n  function selectorIsLive() {\n    return !Recoil_gkx('recoil_memory_managament_2020') || liveStoresCount > 0;\n  }\n\n  function selectorInit(store) {\n    store.getState().knownSelectors.add(key);\n    liveStoresCount++;\n    return () => {\n      liveStoresCount--;\n    };\n  }\n\n  function selectorShouldDeleteConfigOnRelease() {\n    return getConfigDeletionHandler$1(key) !== undefined && !selectorIsLive();\n  }\n\n  function resolveAsync(store, state, executionID, loadable, depValues) {\n    setCache(state, loadable, depValues);\n    notifyStoresOfResolvedAsync(store, executionID);\n  }\n\n  function notifyStoresOfResolvedAsync(store, executionID) {\n    if (isLatestExecution(store, executionID)) {\n      clearExecutionInfo(store);\n    }\n\n    notifyWaitingStores(executionID, true);\n  }\n  /**\n   * Notify stores to pull the selector again if a new async dep was discovered.\n   * 1) Async selector adds a new dep but doesn't resolve yet.\n   *    Note that deps for an async selector are based on the state when the\n   *    evaluation started, in order to provide a consistent picture of state.\n   * 2) But, new value of dep based on the current state might cause the selector\n   *    to resolve or resolve differently.\n   * 3) Therefore, this notification will pull the selector based on the current\n   *    state for the components\n   */\n\n\n  function notifyStoresOfNewAsyncDep(store, executionID) {\n    if (isLatestExecution(store, executionID)) {\n      const executionInfo = Recoil_nullthrows(getExecutionInfo(store));\n      executionInfo.stateVersions.clear();\n      notifyWaitingStores(executionID, false);\n    }\n  }\n\n  function notifyWaitingStores(executionID, clearWaitlist) {\n    const stores = waitingStores.get(executionID);\n\n    if (stores != null) {\n      for (const waitingStore of stores) {\n        markRecoilValueModified$1(waitingStore, Recoil_nullthrows(recoilValue));\n      }\n\n      if (clearWaitlist) {\n        waitingStores.delete(executionID);\n      }\n    }\n  }\n\n  function markStoreWaitingForResolvedAsync(store, executionID) {\n    let stores = waitingStores.get(executionID);\n\n    if (stores == null) {\n      waitingStores.set(executionID, stores = new Set());\n    }\n\n    stores.add(store);\n  }\n  /**\n   * This function attaches a then() and a catch() to a promise that was\n   * returned from a selector's get() (either explicitly or implicitly by\n   * running a function that uses the \"async\" keyword). If a selector's get()\n   * returns a promise, we have two possibilities:\n   *\n   * 1. The promise will resolve, in which case it will have completely finished\n   *    executing without any remaining pending dependencies. No more retries\n   *    are needed and we can proceed with updating the cache and notifying\n   *    subscribers (if it is the latest execution, otherwise only the cache\n   *    will be updated and subscriptions will not be fired). This is the case\n   *    handled by the attached then() handler.\n   *\n   * 2. The promise will throw because it either has an error or it came across\n   *    an async dependency that has not yet resolved, in which case we will\n   *    call wrapDepdencyPromise(), whose responsibility is to handle dependency\n   *    promises. This case is handled by the attached catch() handler.\n   *\n   * Both branches will eventually resolve to the final result of the selector\n   * (or an error if a real error occurred).\n   *\n   * The execution will run to completion even if it is stale, and its value\n   * will be cached. But stale executions will not update global state or update\n   * executionInfo as that is the responsibility of the 'latest' execution.\n   *\n   * Note this function should not be passed a promise that was thrown--AKA a\n   * dependency promise. Dependency promises should be passed to\n   * wrapPendingDependencyPromise()).\n   */\n\n\n  function wrapResultPromise(store, promise, state, depValues, executionID, loadingDepsState) {\n    return promise.then(value => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      const loadable = loadableWithValue$2(value);\n      resolveAsync(store, state, executionID, loadable, depValues);\n      return value;\n    }).catch(errorOrPromise => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      if (Recoil_isPromise(errorOrPromise)) {\n        return wrapPendingDependencyPromise(store, errorOrPromise, state, depValues, executionID, loadingDepsState);\n      }\n\n      const loadable = loadableWithError$1(errorOrPromise);\n      resolveAsync(store, state, executionID, loadable, depValues);\n      throw errorOrPromise;\n    });\n  }\n  /**\n   * This function attaches a then() and a catch() to a promise that was\n   * thrown from a selector's get(). If a selector's get() throws a promise,\n   * we have two possibilities:\n   *\n   * 1. The promise will resolve, meaning one of our selector's dependencies is\n   *    now available and we should \"retry\" our get() by running it again. This\n   *    is the case handled by the attached then() handler.\n   *\n   * 2. The promise will throw because something went wrong with the dependency\n   *    promise (in other words a real error occurred). This case is handled by\n   *    the attached catch() handler. If the dependency promise throws, it is\n   *    _always_ a real error and not another dependency promise (any dependency\n   *    promises would have been handled upstream).\n   *\n   * The then() branch will eventually resolve to the final result of the\n   * selector (or an error if a real error occurs), and the catch() will always\n   * resolve to an error because the dependency promise is a promise that was\n   * wrapped upstream, meaning it will only resolve to its real value or to a\n   * real error.\n   *\n   * The execution will run to completion even if it is stale, and its value\n   * will be cached. But stale executions will not update global state or update\n   * executionInfo as that is the responsibility of the 'latest' execution.\n   *\n   * Note this function should not be passed a promise that was returned from\n   * get(). The intention is that this function is only passed promises that\n   * were thrown due to a pending dependency. Promises returned by get() should\n   * be passed to wrapResultPromise() instead.\n   */\n\n\n  function wrapPendingDependencyPromise(store, promise, state, existingDeps, executionID, loadingDepsState) {\n    return promise.then(resolvedDep => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      } // Check if we are handling a pending Recoil dependency or if the user\n      // threw their own Promise to \"suspend\" a selector evaluation.  We need\n      // to check that the loadingDepPromise actually matches the promise that\n      // we caught in case the selector happened to catch the promise we threw\n      // for a pending Recoil dependency from `getRecoilValue()` and threw\n      // their own promise instead.\n\n\n      if (loadingDepsState.loadingDepKey != null && loadingDepsState.loadingDepPromise === promise) {\n        /**\n         * Note for async atoms, this means we are changing the atom's value\n         * in the store for the given version. This should be alright because\n         * the version of state is now stale and a new version will have\n         * already been triggered by the atom being resolved (see this logic\n         * in Recoil_atom.js)\n         */\n        state.atomValues.set(loadingDepsState.loadingDepKey, loadableWithValue$2(resolvedDep));\n      } else {\n        /**\n         * If resolvedDepKey is not defined, the promise was a user-thrown\n         * promise. User-thrown promises are an advanced feature and they\n         * should be avoided in almost all cases. Using `loadable.map()` inside\n         * of selectors for loading loadables and then throwing that mapped\n         * loadable's promise is an example of a user-thrown promise.\n         *\n         * When we hit a user-thrown promise, we have to bail out of an optimization\n         * where we bypass calculating selector cache keys for selectors that\n         * have been previously seen for a given state (these selectors are saved in\n         * state.atomValues) to avoid stale state as we have no way of knowing\n         * what state changes happened (if any) in result to the promise resolving.\n         *\n         * Ideally we would only bail out selectors that are in the chain of\n         * dependencies for this selector, but there's currently no way to get\n         * a full list of a selector's downstream nodes because the state that\n         * is executing may be a discarded tree (so store.getGraph(state.version)\n         * will be empty), and the full dep tree may not be in the selector\n         * caches in the case where the selector's cache was cleared. To solve\n         * for this we would have to keep track of all running selector\n         * executions and their downstream deps. Because this only covers edge\n         * cases, that complexity might not be justifyable.\n         */\n        store.getState().knownSelectors.forEach(nodeKey => {\n          state.atomValues.delete(nodeKey);\n        });\n      }\n      /**\n       * Optimization: Now that the dependency has resolved, let's try hitting\n       * the cache in case the dep resolved to a value we have previously seen.\n       *\n       * TODO:\n       * Note this optimization is not perfect because it only prevents re-executions\n       * _after_ the point where an async dependency is found. Any code leading\n       * up to the async dependency may have run unnecessarily. The ideal case\n       * would be to wait for the async dependency to resolve first, check the\n       * cache, and prevent _any_ execution of the selector if the resulting\n       * value of the dependency leads to a path that is found in the cache.\n       * The ideal case is more difficult to implement as it would require that\n       * we capture and wait for the the async dependency right after checking\n       * the cache. The current approach takes advantage of the fact that running\n       * the selector already has a code path that lets us exit early when\n       * an async dep resolves.\n       */\n\n\n      const cachedLoadable = getLoadableFromCacheAndUpdateDeps(store, state);\n\n      if (cachedLoadable && cachedLoadable.state !== 'loading') {\n        /**\n         * This has to notify stores of a resolved async, even if there is no\n         * current pending execution for the following case:\n         * 1) A component renders with this pending loadable.\n         * 2) The upstream dependency resolves.\n         * 3) While processing some other selector it reads this one, such as\n         *    while traversing its dependencies.  At this point it gets the\n         *    new resolved value synchronously and clears the current\n         *    execution ID.  The component wasn't getting the value itself,\n         *    though, so it still has the pending loadable.\n         * 4) When this code executes the current execution id was cleared\n         *    and it wouldn't notify the component of the new value.\n         *\n         * I think this is only an issue with \"early\" rendering since the\n         * components got their value using the in-progress execution.\n         * We don't have a unit test for this case yet.  I'm not sure it is\n         * necessary with recoil_transition_support mode.\n         */\n        if (isLatestExecution(store, executionID) || getExecutionInfo(store) == null) {\n          notifyStoresOfResolvedAsync(store, executionID);\n        }\n\n        if (cachedLoadable.state === 'hasValue') {\n          return cachedLoadable.contents;\n        } else {\n          throw cachedLoadable.contents;\n        }\n      }\n      /**\n       * If this execution is stale, let's check to see if there is some in\n       * progress execution with a matching state. If we find a match, then\n       * we can take the value from that in-progress execution. Note this may\n       * sound like an edge case, but may be very common in cases where a\n       * loading dependency resolves from loading to having a value (thus\n       * possibly triggering a re-render), and React re-renders before the\n       * chained .then() functions run, thus starting a new execution as the\n       * dep has changed value. Without this check we will run the selector\n       * twice (once in the new execution and once again in this .then(), so\n       * this check is necessary to keep unnecessary re-executions to a\n       * minimum).\n       *\n       * Also note this code does not check across all executions that may be\n       * running. It only optimizes for the _latest_ execution per store as\n       * we currently do not maintain a list of all currently running executions.\n       * This means in some cases we may run selectors more than strictly\n       * necessary when there are multiple executions running for the same\n       * selector. This may be a valid tradeoff as checking for dep changes\n       * across all in-progress executions may take longer than just\n       * re-running the selector. This will be app-dependent, and maybe in the\n       * future we can make the behavior configurable. An ideal fix may be\n       * to extend the tree cache to support caching loading states.\n       */\n\n\n      if (!isLatestExecution(store, executionID)) {\n        const executionInfo = getInProgressExecutionInfo(store, state);\n\n        if (executionInfo != null) {\n          /**\n           * Returning promise here without wrapping as the wrapper logic was\n           * already done upstream when this promise was generated.\n           */\n          return executionInfo.loadingLoadable.contents;\n        }\n      } // Retry the selector evaluation now that the dependency has resolved\n\n\n      const [loadable, depValues] = evaluateSelectorGetter(store, state, executionID);\n\n      if (loadable.state !== 'loading') {\n        resolveAsync(store, state, executionID, loadable, depValues);\n      }\n\n      if (loadable.state === 'hasError') {\n        throw loadable.contents;\n      }\n\n      return loadable.contents;\n    }).catch(error => {\n      // The selector was released since the request began; ignore the response.\n      if (error instanceof Canceled) {\n        throw CANCELED;\n      }\n\n      if (!selectorIsLive()) {\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      const loadable = loadableWithError$1(error);\n      resolveAsync(store, state, executionID, loadable, existingDeps);\n      throw error;\n    });\n  }\n\n  function updateDeps(store, state, deps, executionID) {\n    var _store$getState, _store$getState$curre, _store$getState2, _store$getState2$next;\n\n    if (isLatestExecution(store, executionID) || state.version === ((_store$getState = store.getState()) === null || _store$getState === void 0 ? void 0 : (_store$getState$curre = _store$getState.currentTree) === null || _store$getState$curre === void 0 ? void 0 : _store$getState$curre.version) || state.version === ((_store$getState2 = store.getState()) === null || _store$getState2 === void 0 ? void 0 : (_store$getState2$next = _store$getState2.nextTree) === null || _store$getState2$next === void 0 ? void 0 : _store$getState2$next.version)) {\n      var _store$getState$nextT, _store$getState3, _store$getState3$next;\n\n      saveDepsToStore$1(key, deps, store, (_store$getState$nextT = (_store$getState3 = store.getState()) === null || _store$getState3 === void 0 ? void 0 : (_store$getState3$next = _store$getState3.nextTree) === null || _store$getState3$next === void 0 ? void 0 : _store$getState3$next.version) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree.version);\n    }\n\n    for (const nodeKey of deps) {\n      discoveredDependencyNodeKeys.add(nodeKey);\n    }\n  }\n\n  function evaluateSelectorGetter(store, state, executionID) {\n    const endPerfBlock = startPerfBlock$1(key); // TODO T63965866: use execution ID here\n\n    let duringSynchronousExecution = true;\n    let duringAsynchronousExecution = true;\n\n    const finishEvaluation = () => {\n      endPerfBlock();\n      duringAsynchronousExecution = false;\n    };\n\n    let result;\n    let resultIsError = false;\n    let loadable;\n    const loadingDepsState = {\n      loadingDepKey: null,\n      loadingDepPromise: null\n    };\n    /**\n     * Starting a fresh set of deps that we'll be using to update state. We're\n     * starting a new set versus adding it in existing state deps because\n     * the version of state that we update deps for may be a more recent version\n     * than the version the selector was called with. This is because the latest\n     * execution will update the deps of the current/latest version of state\n     * (This is safe to do because the fact that the selector is the latest\n     * execution means the deps we discover below are our best guess at the\n     * deps for the current/latest state in the store)\n     */\n\n    const depValues = new Map();\n\n    function getRecoilValue({\n      key: depKey\n    }) {\n      const depLoadable = getNodeLoadable$2(store, state, depKey);\n      depValues.set(depKey, depLoadable); // We need to update asynchronous dependencies as we go so the selector\n      // knows if it has to restart evaluation if one of them is updated before\n      // the asynchronous selector completely resolves.\n\n      if (!duringSynchronousExecution) {\n        updateDeps(store, state, new Set(depValues.keys()), executionID);\n        notifyStoresOfNewAsyncDep(store, executionID);\n      }\n\n      switch (depLoadable.state) {\n        case 'hasValue':\n          return depLoadable.contents;\n\n        case 'hasError':\n          throw depLoadable.contents;\n\n        case 'loading':\n          loadingDepsState.loadingDepKey = depKey;\n          loadingDepsState.loadingDepPromise = depLoadable.contents;\n          throw depLoadable.contents;\n      }\n\n      throw Recoil_err('Invalid Loadable state');\n    }\n\n    const getCallback = fn => {\n      return (...args) => {\n        if (duringAsynchronousExecution) {\n          throw Recoil_err('Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.');\n        }\n\n        !(recoilValue != null) ?  true ? Recoil_invariant(false, 'Recoil Value can never be null') : 0 : void 0;\n        return recoilCallback$1(store, fn, args, {\n          node: recoilValue\n        } // flowlint-line unclear-type:off\n        );\n      };\n    };\n\n    try {\n      result = get({\n        get: getRecoilValue,\n        getCallback\n      });\n      result = isRecoilValue$3(result) ? getRecoilValue(result) : result;\n\n      if (isLoadable$1(result)) {\n        if (result.state === 'hasError') {\n          resultIsError = true;\n        }\n\n        result = result.contents;\n      }\n\n      if (Recoil_isPromise(result)) {\n        result = wrapResultPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);\n      } else {\n        finishEvaluation();\n      }\n\n      result = result instanceof WrappedValue$1 ? result.value : result;\n    } catch (errorOrDepPromise) {\n      result = errorOrDepPromise;\n\n      if (Recoil_isPromise(result)) {\n        result = wrapPendingDependencyPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);\n      } else {\n        resultIsError = true;\n        finishEvaluation();\n      }\n    }\n\n    if (resultIsError) {\n      loadable = loadableWithError$1(result);\n    } else if (Recoil_isPromise(result)) {\n      loadable = loadableWithPromise$1(result);\n    } else {\n      loadable = loadableWithValue$2(result);\n    }\n\n    duringSynchronousExecution = false;\n    updateExecutionInfoDepValues(store, executionID, depValues);\n    updateDeps(store, state, new Set(depValues.keys()), executionID);\n    return [loadable, depValues];\n  }\n\n  function getLoadableFromCacheAndUpdateDeps(store, state) {\n    // First, look up in the state cache\n    // If it's here, then the deps in the store should already be valid.\n    let cachedLoadable = state.atomValues.get(key);\n\n    if (cachedLoadable != null) {\n      return cachedLoadable;\n    } // Second, look up in the selector cache and update the deps in the store\n\n\n    const depsAfterCacheLookup = new Set();\n\n    try {\n      cachedLoadable = cache.get(nodeKey => {\n        !(typeof nodeKey === 'string') ?  true ? Recoil_invariant(false, 'Cache nodeKey is type string') : 0 : void 0;\n        return getNodeLoadable$2(store, state, nodeKey).contents;\n      }, {\n        onNodeVisit: node => {\n          if (node.type === 'branch' && node.nodeKey !== key) {\n            depsAfterCacheLookup.add(node.nodeKey);\n          }\n        }\n      });\n    } catch (error) {\n      throw Recoil_err(`Problem with cache lookup for selector \"${key}\": ${error.message}`);\n    }\n\n    if (cachedLoadable) {\n      var _getExecutionInfo; // Cache the results in the state to allow for cheaper lookup than\n      // iterating the tree cache of dependencies.\n\n\n      state.atomValues.set(key, cachedLoadable);\n      /**\n       * Ensure store contains correct dependencies if we hit the cache so that\n       * the store deps and cache are in sync for a given state. This is important\n       * because store deps are normally updated when new executions are created,\n       * but cache hits don't trigger new executions but they still _may_ signify\n       * a change in deps in the store if the store deps for this state are empty\n       * or stale.\n       */\n\n      updateDeps(store, state, depsAfterCacheLookup, (_getExecutionInfo = getExecutionInfo(store)) === null || _getExecutionInfo === void 0 ? void 0 : _getExecutionInfo.executionID);\n    }\n\n    return cachedLoadable;\n  }\n  /**\n   * Given a tree state, this function returns a Loadable of the current state.\n   *\n   * The selector's get() function will only be re-evaluated if _both_ of the\n   * following statements are true:\n   *\n   * 1. The current dep values from the given state produced a cache key that\n   *    was not found in the cache.\n   * 2. There is no currently running async execution OR there is an\n   *    async execution that is running, but after comparing the dep values in\n   *    the given state with the dep values that the execution has discovered so\n   *    far we find that at least one dep value has changed, in which case we\n   *    start a new execution (the previously running execution will continue to\n   *    run to completion, but only the new execution will be deemed the\n   *    'latest' execution, meaning it will be the only execution that will\n   *    update global state when it is finished. Any non-latest executions will\n   *    run to completion and update the selector cache but not global state).\n   */\n\n\n  function getSelectorLoadableAndUpdateDeps(store, state) {\n    // First, see if our current state is cached\n    const cachedVal = getLoadableFromCacheAndUpdateDeps(store, state);\n\n    if (cachedVal != null) {\n      clearExecutionInfo(store);\n      return cachedVal;\n    } // Second, check if there is already an ongoing execution based on the current state\n\n\n    const inProgressExecutionInfo = getInProgressExecutionInfo(store, state);\n\n    if (inProgressExecutionInfo != null) {\n      var _inProgressExecutionI;\n\n      if (((_inProgressExecutionI = inProgressExecutionInfo.loadingLoadable) === null || _inProgressExecutionI === void 0 ? void 0 : _inProgressExecutionI.state) === 'loading') {\n        markStoreWaitingForResolvedAsync(store, inProgressExecutionInfo.executionID);\n      } // FIXME: check after the fact to see if we made the right choice by waiting\n\n\n      return inProgressExecutionInfo.loadingLoadable;\n    } // Third, start a new evaluation of the selector\n\n\n    const newExecutionID = getNewExecutionID();\n    const [loadable, newDepValues] = evaluateSelectorGetter(store, state, newExecutionID);\n    /**\n     * Conditionally updates the cache with a given loadable.\n     *\n     * We only cache loadables that are not loading because our cache keys are\n     * based on dep values, which are in an unfinished state for loadables that\n     * have a 'loading' state (new deps may be discovered while the selector\n     * runs its async code). We never want to cache partial dependencies b/c it\n     * could lead to errors, such as prematurely returning the result based on a\n     * partial list of deps-- we need the full list of deps to ensure that we\n     * are returning the correct result from cache.\n     */\n\n    if (loadable.state === 'loading') {\n      setExecutionInfo(store, newExecutionID, loadable, newDepValues, state);\n      markStoreWaitingForResolvedAsync(store, newExecutionID);\n    } else {\n      clearExecutionInfo(store);\n      setCache(state, loadable, newDepValues);\n    }\n\n    return loadable;\n  }\n  /**\n   * Searches execution info across all stores to see if there is an in-progress\n   * execution whose dependency values match the values of the requesting store.\n   */\n\n\n  function getInProgressExecutionInfo(store, state) {\n    // Sort the pending executions so that our current store is checked first.\n    const pendingExecutions = Recoil_concatIterables([executionInfoMap.has(store) ? [Recoil_nullthrows(executionInfoMap.get(store))] : [], Recoil_mapIterable(Recoil_filterIterable(executionInfoMap, ([s]) => s !== store), ([, execInfo]) => execInfo)]);\n\n    function anyDepChanged(execDepValues) {\n      for (const [depKey, execLoadable] of execDepValues) {\n        if (!getNodeLoadable$2(store, state, depKey).is(execLoadable)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    for (const execInfo of pendingExecutions) {\n      if ( // If this execution was already checked to be valid with this version\n      // of state, then let's use it!\n      execInfo.stateVersions.get(state.version) || // If the deps for the execution match our current state, then it's valid\n      !anyDepChanged(execInfo.depValuesDiscoveredSoFarDuringAsyncWork)) {\n        execInfo.stateVersions.set(state.version, true);\n        return execInfo;\n      } else {\n        execInfo.stateVersions.set(state.version, false);\n      }\n    }\n\n    return undefined;\n  }\n\n  function getExecutionInfo(store) {\n    return executionInfoMap.get(store);\n  }\n  /**\n   * This function will update the selector's execution info when the selector\n   * has either finished running an execution or has started a new execution. If\n   * the given loadable is in a 'loading' state, the intention is that a new\n   * execution has started. Otherwise, the intention is that an execution has\n   * just finished.\n   */\n\n\n  function setExecutionInfo(store, newExecutionID, loadable, depValues, state) {\n    executionInfoMap.set(store, {\n      depValuesDiscoveredSoFarDuringAsyncWork: depValues,\n      executionID: newExecutionID,\n      loadingLoadable: loadable,\n      stateVersions: new Map([[state.version, true]])\n    });\n  }\n\n  function updateExecutionInfoDepValues(store, executionID, depValues) {\n    // We only need to bother updating the deps for the latest execution because\n    // that's all getInProgressExecutionInfo() will be looking for.\n    if (isLatestExecution(store, executionID)) {\n      const executionInfo = getExecutionInfo(store);\n\n      if (executionInfo != null) {\n        executionInfo.depValuesDiscoveredSoFarDuringAsyncWork = depValues;\n      }\n    }\n  }\n\n  function clearExecutionInfo(store) {\n    executionInfoMap.delete(store);\n  }\n\n  function isLatestExecution(store, executionID) {\n    var _getExecutionInfo2;\n\n    return executionID === ((_getExecutionInfo2 = getExecutionInfo(store)) === null || _getExecutionInfo2 === void 0 ? void 0 : _getExecutionInfo2.executionID);\n  }\n  /**\n   * FIXME: dep keys should take into account the state of the loadable to\n   * prevent the edge case where a loadable with an error and a loadable with\n   * an error as a value are treated as the same thing incorrectly. For example\n   * these two should be treated differently:\n   *\n   * selector({key: '', get: () => new Error('hi')});\n   * selector({key: '', get () => {throw new Error('hi')}});\n   *\n   * With current implementation they are treated the same\n   */\n\n\n  function depValuesToDepRoute(depValues) {\n    return Array.from(depValues.entries()).map(([depKey, valLoadable]) => [depKey, valLoadable.contents]);\n  }\n\n  function setCache(state, loadable, depValues) {\n    if (true) {\n      if (loadable.state !== 'loading' && Boolean(options.dangerouslyAllowMutability) === false) {\n        Recoil_deepFreezeValue(loadable.contents);\n      }\n    }\n\n    state.atomValues.set(key, loadable);\n\n    try {\n      cache.set(depValuesToDepRoute(depValues), loadable);\n    } catch (error) {\n      throw Recoil_err(`Problem with setting cache for selector \"${key}\": ${error.message}`);\n    }\n  }\n\n  function detectCircularDependencies(fn) {\n    if (dependencyStack.includes(key)) {\n      const message = `Recoil selector has circular dependencies: ${dependencyStack.slice(dependencyStack.indexOf(key)).join(' \\u2192 ')}`;\n      return loadableWithError$1(Recoil_err(message));\n    }\n\n    dependencyStack.push(key);\n\n    try {\n      return fn();\n    } finally {\n      dependencyStack.pop();\n    }\n  }\n\n  function selectorPeek(store, state) {\n    const cachedLoadable = state.atomValues.get(key);\n\n    if (cachedLoadable != null) {\n      return cachedLoadable;\n    }\n\n    return cache.get(nodeKey => {\n      var _peekNodeLoadable;\n\n      !(typeof nodeKey === 'string') ?  true ? Recoil_invariant(false, 'Cache nodeKey is type string') : 0 : void 0;\n      return (_peekNodeLoadable = peekNodeLoadable$1(store, state, nodeKey)) === null || _peekNodeLoadable === void 0 ? void 0 : _peekNodeLoadable.contents;\n    });\n  }\n\n  function selectorGet(store, state) {\n    return detectCircularDependencies(() => getSelectorLoadableAndUpdateDeps(store, state));\n  }\n\n  function invalidateSelector(state) {\n    state.atomValues.delete(key);\n  }\n\n  function clearSelectorCache(store, treeState) {\n    !(recoilValue != null) ?  true ? Recoil_invariant(false, 'Recoil Value can never be null') : 0 : void 0;\n\n    for (const nodeKey of discoveredDependencyNodeKeys) {\n      var _node$clearCache;\n\n      const node = getNode$6(nodeKey);\n      (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, treeState);\n    }\n\n    discoveredDependencyNodeKeys.clear();\n    invalidateSelector(treeState);\n    cache.clear();\n    markRecoilValueModified$1(store, recoilValue);\n  }\n\n  if (set != null) {\n    /**\n     * ES5 strict mode prohibits defining non-top-level function declarations,\n     * so don't use function declaration syntax here\n     */\n    const selectorSet = (store, state, newValue) => {\n      let syncSelectorSetFinished = false;\n      const writes = new Map();\n\n      function getRecoilValue({\n        key: depKey\n      }) {\n        if (syncSelectorSetFinished) {\n          throw Recoil_err('Recoil: Async selector sets are not currently supported.');\n        }\n\n        const loadable = getNodeLoadable$2(store, state, depKey);\n\n        if (loadable.state === 'hasValue') {\n          return loadable.contents;\n        } else if (loadable.state === 'loading') {\n          const msg = `Getting value of asynchronous atom or selector \"${depKey}\" in a pending state while setting selector \"${key}\" is not yet supported.`;\n          Recoil_recoverableViolation(msg);\n          throw Recoil_err(msg);\n        } else {\n          throw loadable.contents;\n        }\n      }\n\n      function setRecoilState(recoilState, valueOrUpdater) {\n        if (syncSelectorSetFinished) {\n          const msg = 'Recoil: Async selector sets are not currently supported.';\n          Recoil_recoverableViolation(msg);\n          throw Recoil_err(msg);\n        }\n\n        const setValue = typeof valueOrUpdater === 'function' ? // cast to any because we can't restrict type S from being a function itself without losing support for opaque types\n        // flowlint-next-line unclear-type:off\n        valueOrUpdater(getRecoilValue(recoilState)) : valueOrUpdater;\n        const upstreamWrites = setNodeValue$3(store, state, recoilState.key, setValue);\n        upstreamWrites.forEach((v, k) => writes.set(k, v));\n      }\n\n      function resetRecoilState(recoilState) {\n        setRecoilState(recoilState, DEFAULT_VALUE$6);\n      }\n\n      const ret = set({\n        set: setRecoilState,\n        get: getRecoilValue,\n        reset: resetRecoilState\n      }, newValue); // set should be a void method, but if the user makes it `async`, then it\n      // will return a Promise, which we don't currently support.\n\n      if (ret !== undefined) {\n        throw Recoil_isPromise(ret) ? Recoil_err('Recoil: Async selector sets are not currently supported.') : Recoil_err('Recoil: selector set should be a void function.');\n      }\n\n      syncSelectorSetFinished = true;\n      return writes;\n    };\n\n    return recoilValue = registerNode$1({\n      key,\n      nodeType: 'selector',\n      peek: selectorPeek,\n      get: selectorGet,\n      set: selectorSet,\n      init: selectorInit,\n      invalidate: invalidateSelector,\n      clearCache: clearSelectorCache,\n      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,\n      dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n      shouldRestoreFromSnapshots: false,\n      retainedBy\n    });\n  } else {\n    return recoilValue = registerNode$1({\n      key,\n      nodeType: 'selector',\n      peek: selectorPeek,\n      get: selectorGet,\n      init: selectorInit,\n      invalidate: invalidateSelector,\n      clearCache: clearSelectorCache,\n      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,\n      dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n      shouldRestoreFromSnapshots: false,\n      retainedBy\n    });\n  }\n}\n/* eslint-enable no-redeclare */\n// $FlowIssue[incompatible-use]\n\n\nselector.value = value => new WrappedValue$1(value);\n\nvar Recoil_selector = selector; // @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';\n// @fb-only: const {scopedAtom} = require('Recoil_ScopedAtom');\n\nconst {\n  isLoadable: isLoadable$2,\n  loadableWithError: loadableWithError$2,\n  loadableWithPromise: loadableWithPromise$2,\n  loadableWithValue: loadableWithValue$3\n} = Recoil_Loadable$1;\nconst {\n  WrappedValue: WrappedValue$2\n} = Recoil_Wrapper$1;\nconst {\n  peekNodeInfo: peekNodeInfo$3\n} = Recoil_FunctionalCore;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$7,\n  DefaultValue: DefaultValue$2,\n  getConfigDeletionHandler: getConfigDeletionHandler$2,\n  registerNode: registerNode$2,\n  setConfigDeletionHandler: setConfigDeletionHandler$1\n} = Recoil_Node;\nconst {\n  isRecoilValue: isRecoilValue$4\n} = Recoil_RecoilValue$1;\nconst {\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$4,\n  markRecoilValueModified: markRecoilValueModified$2,\n  setRecoilValue: setRecoilValue$4,\n  setRecoilValueLoadable: setRecoilValueLoadable$2\n} = Recoil_RecoilValueInterface;\nconst {\n  retainedByOptionWithDefault: retainedByOptionWithDefault$2\n} = Recoil_Retention;\n\nconst unwrap = x => x instanceof WrappedValue$2 ? x.value : x;\n\nfunction baseAtom(options) {\n  const {\n    key,\n    persistence_UNSTABLE: persistence\n  } = options;\n  const retainedBy = retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE);\n  let liveStoresCount = 0;\n\n  function unwrapPromise(promise) {\n    return loadableWithPromise$2(promise.then(value => {\n      defaultLoadable = loadableWithValue$3(value);\n      return value;\n    }).catch(error => {\n      defaultLoadable = loadableWithError$2(error);\n      throw error;\n    }));\n  }\n\n  let defaultLoadable = Recoil_isPromise(options.default) ? unwrapPromise(options.default) : isLoadable$2(options.default) ? options.default.state === 'loading' ? unwrapPromise(options.default.contents) : options.default : loadableWithValue$3(unwrap(options.default));\n  maybeFreezeValueOrPromise(defaultLoadable.contents);\n  let cachedAnswerForUnvalidatedValue = undefined; // Cleanup handlers for this atom\n  // Rely on stable reference equality of the store to use it as a key per <RecoilRoot>\n\n  const cleanupEffectsByStore = new Map();\n\n  function maybeFreezeValueOrPromise(valueOrPromise) {\n    if (true) {\n      if (options.dangerouslyAllowMutability !== true) {\n        if (Recoil_isPromise(valueOrPromise)) {\n          return valueOrPromise.then(value => {\n            Recoil_deepFreezeValue(value);\n            return value;\n          });\n        } else {\n          Recoil_deepFreezeValue(valueOrPromise);\n          return valueOrPromise;\n        }\n      }\n    }\n\n    return valueOrPromise;\n  }\n\n  function wrapPendingPromise(store, promise) {\n    const wrappedPromise = promise.then(value => {\n      var _store$getState$nextT, _state$atomValues$get;\n\n      const state = (_store$getState$nextT = store.getState().nextTree) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree;\n\n      if (((_state$atomValues$get = state.atomValues.get(key)) === null || _state$atomValues$get === void 0 ? void 0 : _state$atomValues$get.contents) === wrappedPromise) {\n        setRecoilValue$4(store, node, value);\n      }\n\n      return value;\n    }).catch(error => {\n      var _store$getState$nextT2, _state$atomValues$get2;\n\n      const state = (_store$getState$nextT2 = store.getState().nextTree) !== null && _store$getState$nextT2 !== void 0 ? _store$getState$nextT2 : store.getState().currentTree;\n\n      if (((_state$atomValues$get2 = state.atomValues.get(key)) === null || _state$atomValues$get2 === void 0 ? void 0 : _state$atomValues$get2.contents) === wrappedPromise) {\n        setRecoilValueLoadable$2(store, node, loadableWithError$2(error));\n      }\n\n      throw error;\n    });\n    return wrappedPromise;\n  }\n\n  function initAtom(store, initState, trigger) {\n    var _options$effects;\n\n    liveStoresCount++;\n\n    const cleanupAtom = () => {\n      var _cleanupEffectsByStor;\n\n      liveStoresCount--;\n      (_cleanupEffectsByStor = cleanupEffectsByStore.get(store)) === null || _cleanupEffectsByStor === void 0 ? void 0 : _cleanupEffectsByStor.forEach(cleanup => cleanup());\n      cleanupEffectsByStore.delete(store);\n    };\n\n    store.getState().knownAtoms.add(key); // Setup async defaults to notify subscribers when they resolve\n\n    if (defaultLoadable.state === 'loading') {\n      const notifyDefaultSubscribers = () => {\n        var _store$getState$nextT3;\n\n        const state = (_store$getState$nextT3 = store.getState().nextTree) !== null && _store$getState$nextT3 !== void 0 ? _store$getState$nextT3 : store.getState().currentTree;\n\n        if (!state.atomValues.has(key)) {\n          markRecoilValueModified$2(store, node);\n        }\n      };\n\n      defaultLoadable.contents.finally(notifyDefaultSubscribers);\n    } ///////////////////\n    // Run Atom Effects\n    ///////////////////\n\n\n    const effects = (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE;\n\n    if (effects != null) {\n      // This state is scoped by Store, since this is in the initAtom() closure\n      let initValue = DEFAULT_VALUE$7;\n      let isDuringInit = true;\n      let isInitError = false;\n      let pendingSetSelf = null;\n\n      function getLoadable(recoilValue) {\n        // Normally we can just get the current value of another atom.\n        // But for our own value we need to check if there is a pending\n        // initialized value or get the fallback default value.\n        if (isDuringInit && recoilValue.key === key) {\n          // Cast T to S\n          const retValue = initValue; // flowlint-line unclear-type:off\n\n          return retValue instanceof DefaultValue$2 ? peekAtom(store, initState) // flowlint-line unclear-type:off\n          : Recoil_isPromise(retValue) ? loadableWithPromise$2(retValue.then(v => v instanceof DefaultValue$2 ? // Cast T to S\n          defaultLoadable.toPromise() // flowlint-line unclear-type:off\n          : v)) : loadableWithValue$3(retValue);\n        }\n\n        return getRecoilValueAsLoadable$4(store, recoilValue);\n      }\n\n      function getPromise(recoilValue) {\n        return getLoadable(recoilValue).toPromise();\n      }\n\n      function getInfo_UNSTABLE(recoilValue) {\n        var _store$getState$nextT4;\n\n        const info = peekNodeInfo$3(store, (_store$getState$nextT4 = store.getState().nextTree) !== null && _store$getState$nextT4 !== void 0 ? _store$getState$nextT4 : store.getState().currentTree, recoilValue.key);\n        return isDuringInit && recoilValue.key === key && !(initValue instanceof DefaultValue$2) ? { ...info,\n          isSet: true,\n          loadable: getLoadable(recoilValue)\n        } : info;\n      }\n\n      const setSelf = effect => valueOrUpdater => {\n        if (isDuringInit) {\n          const currentLoadable = getLoadable(node);\n          const currentValue = currentLoadable.state === 'hasValue' ? currentLoadable.contents : DEFAULT_VALUE$7;\n          initValue = typeof valueOrUpdater === 'function' ? // cast to any because we can't restrict T from being a function without losing support for opaque types\n          valueOrUpdater(currentValue) // flowlint-line unclear-type:off\n          : valueOrUpdater;\n\n          if (Recoil_isPromise(initValue)) {\n            initValue = initValue.then(value => {\n              // Avoid calling onSet() when setSelf() initializes with a Promise\n              pendingSetSelf = {\n                effect,\n                value\n              };\n              return value;\n            });\n          }\n        } else {\n          if (Recoil_isPromise(valueOrUpdater)) {\n            throw Recoil_err('Setting atoms to async values is not implemented.');\n          }\n\n          if (typeof valueOrUpdater !== 'function') {\n            pendingSetSelf = {\n              effect,\n              value: unwrap(valueOrUpdater)\n            };\n          }\n\n          setRecoilValue$4(store, node, typeof valueOrUpdater === 'function' ? currentValue => {\n            const newValue = unwrap( // cast to any because we can't restrict T from being a function without losing support for opaque types\n            valueOrUpdater(currentValue) // flowlint-line unclear-type:off\n            );\n            pendingSetSelf = {\n              effect,\n              value: newValue\n            };\n            return newValue;\n          } : unwrap(valueOrUpdater));\n        }\n      };\n\n      const resetSelf = effect => () => setSelf(effect)(DEFAULT_VALUE$7);\n\n      const onSet = effect => handler => {\n        var _cleanupEffectsByStor2;\n\n        const {\n          release\n        } = store.subscribeToTransactions(currentStore => {\n          var _currentTree$atomValu; // eslint-disable-next-line prefer-const\n\n\n          let {\n            currentTree,\n            previousTree\n          } = currentStore.getState();\n\n          if (!previousTree) {\n            Recoil_recoverableViolation('Transaction subscribers notified without a next tree being present -- this is a bug in Recoil');\n            previousTree = currentTree; // attempt to trundle on\n          }\n\n          const newLoadable = (_currentTree$atomValu = currentTree.atomValues.get(key)) !== null && _currentTree$atomValu !== void 0 ? _currentTree$atomValu : defaultLoadable;\n\n          if (newLoadable.state === 'hasValue') {\n            var _previousTree$atomVal, _pendingSetSelf, _pendingSetSelf2, _pendingSetSelf3;\n\n            const newValue = newLoadable.contents;\n            const oldLoadable = (_previousTree$atomVal = previousTree.atomValues.get(key)) !== null && _previousTree$atomVal !== void 0 ? _previousTree$atomVal : defaultLoadable;\n            const oldValue = oldLoadable.state === 'hasValue' ? oldLoadable.contents : DEFAULT_VALUE$7; // TODO This isn't actually valid, use as a placeholder for now.\n            // Ignore atom value changes that were set via setSelf() in the same effect.\n            // We will still properly call the handler if there was a subsequent\n            // set from something other than an atom effect which was batched\n            // with the `setSelf()` call.  However, we may incorrectly ignore\n            // the handler if the subsequent batched call happens to set the\n            // atom to the exact same value as the `setSelf()`.   But, in that\n            // case, it was kind of a noop, so the semantics are debatable..\n\n            if (((_pendingSetSelf = pendingSetSelf) === null || _pendingSetSelf === void 0 ? void 0 : _pendingSetSelf.effect) !== effect || ((_pendingSetSelf2 = pendingSetSelf) === null || _pendingSetSelf2 === void 0 ? void 0 : _pendingSetSelf2.value) !== newValue) {\n              handler(newValue, oldValue, !currentTree.atomValues.has(key));\n            } else if (((_pendingSetSelf3 = pendingSetSelf) === null || _pendingSetSelf3 === void 0 ? void 0 : _pendingSetSelf3.effect) === effect) {\n              pendingSetSelf = null;\n            }\n          }\n        }, key);\n        cleanupEffectsByStore.set(store, [...((_cleanupEffectsByStor2 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor2 !== void 0 ? _cleanupEffectsByStor2 : []), release]);\n      };\n\n      for (const effect of effects) {\n        try {\n          const cleanup = effect({\n            node,\n            storeID: store.storeID,\n            parentStoreID_UNSTABLE: store.parentStoreID,\n            trigger,\n            setSelf: setSelf(effect),\n            resetSelf: resetSelf(effect),\n            onSet: onSet(effect),\n            getPromise,\n            getLoadable,\n            getInfo_UNSTABLE\n          });\n\n          if (cleanup != null) {\n            var _cleanupEffectsByStor3;\n\n            cleanupEffectsByStore.set(store, [...((_cleanupEffectsByStor3 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor3 !== void 0 ? _cleanupEffectsByStor3 : []), cleanup]);\n          }\n        } catch (error) {\n          initValue = error;\n          isInitError = true;\n        }\n      }\n\n      isDuringInit = false; // Mutate initial state in place since we know there are no other subscribers\n      // since we are the ones initializing on first use.\n\n      if (!(initValue instanceof DefaultValue$2)) {\n        var _store$getState$nextT5;\n\n        const initLoadable = isInitError ? loadableWithError$2(initValue) : Recoil_isPromise(initValue) ? loadableWithPromise$2(wrapPendingPromise(store, initValue)) : loadableWithValue$3(unwrap(initValue));\n        maybeFreezeValueOrPromise(initLoadable.contents);\n        initState.atomValues.set(key, initLoadable); // If there is a pending transaction, then also mutate the next state tree.\n        // This could happen if the atom was first initialized in an action that\n        // also updated some other atom's state.\n\n        (_store$getState$nextT5 = store.getState().nextTree) === null || _store$getState$nextT5 === void 0 ? void 0 : _store$getState$nextT5.atomValues.set(key, initLoadable);\n      }\n    }\n\n    return cleanupAtom;\n  }\n\n  function peekAtom(_store, state) {\n    var _ref, _state$atomValues$get3;\n\n    return (_ref = (_state$atomValues$get3 = state.atomValues.get(key)) !== null && _state$atomValues$get3 !== void 0 ? _state$atomValues$get3 : cachedAnswerForUnvalidatedValue) !== null && _ref !== void 0 ? _ref : defaultLoadable;\n  }\n\n  function getAtom(_store, state) {\n    if (state.atomValues.has(key)) {\n      // Atom value is stored in state:\n      return Recoil_nullthrows(state.atomValues.get(key));\n    } else if (state.nonvalidatedAtoms.has(key)) {\n      // Atom value is stored but needs validation before use.\n      // We might have already validated it and have a cached validated value:\n      if (cachedAnswerForUnvalidatedValue != null) {\n        return cachedAnswerForUnvalidatedValue;\n      }\n\n      if (persistence == null) {\n        Recoil_expectationViolation(`Tried to restore a persisted value for atom ${key} but it has no persistence settings.`);\n        return defaultLoadable;\n      }\n\n      const nonvalidatedValue = state.nonvalidatedAtoms.get(key);\n      const validatorResult = persistence.validator(nonvalidatedValue, DEFAULT_VALUE$7);\n      const validatedValueLoadable = validatorResult instanceof DefaultValue$2 ? defaultLoadable : loadableWithValue$3(validatorResult);\n      cachedAnswerForUnvalidatedValue = validatedValueLoadable;\n      return cachedAnswerForUnvalidatedValue;\n    } else {\n      return defaultLoadable;\n    }\n  }\n\n  function invalidateAtom() {\n    cachedAnswerForUnvalidatedValue = undefined;\n  }\n\n  function setAtom(_store, state, newValue) {\n    // Bail out if we're being set to the existing value, or if we're being\n    // reset but have no stored value (validated or unvalidated) to reset from:\n    if (state.atomValues.has(key)) {\n      const existing = Recoil_nullthrows(state.atomValues.get(key));\n\n      if (existing.state === 'hasValue' && newValue === existing.contents) {\n        return new Map();\n      }\n    } else if (!state.nonvalidatedAtoms.has(key) && newValue instanceof DefaultValue$2) {\n      return new Map();\n    }\n\n    maybeFreezeValueOrPromise(newValue);\n    cachedAnswerForUnvalidatedValue = undefined; // can be released now if it was previously in use\n\n    return new Map().set(key, loadableWithValue$3(newValue));\n  }\n\n  function shouldDeleteConfigOnReleaseAtom() {\n    return getConfigDeletionHandler$2(key) !== undefined && liveStoresCount <= 0;\n  }\n\n  const node = registerNode$2({\n    key,\n    nodeType: 'atom',\n    peek: peekAtom,\n    get: getAtom,\n    set: setAtom,\n    init: initAtom,\n    invalidate: invalidateAtom,\n    shouldDeleteConfigOnRelease: shouldDeleteConfigOnReleaseAtom,\n    dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n    persistence_UNSTABLE: options.persistence_UNSTABLE ? {\n      type: options.persistence_UNSTABLE.type,\n      backButton: options.persistence_UNSTABLE.backButton\n    } : undefined,\n    shouldRestoreFromSnapshots: true,\n    retainedBy\n  });\n  return node;\n} // prettier-ignore\n\n\nfunction atom(options) {\n  if (true) {\n    if (typeof options.key !== 'string') {\n      throw Recoil_err('A key option with a unique string value must be provided when creating an atom.');\n    }\n  }\n\n  const { // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n    ...restOptions\n  } = options;\n  const optionsDefault = 'default' in options ? // $FlowIssue[prop-missing] No way to refine in Flow that property is not defined\n  // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined\n  options.default : new Promise(() => {});\n\n  if (isRecoilValue$4(optionsDefault) // Continue to use atomWithFallback for promise defaults for scoped atoms\n  // for now, since scoped atoms don't support async defaults\n  // @fb-only: || (isPromise(optionsDefault) && scopeRules_APPEND_ONLY_READ_THE_DOCS)\n  // @fb-only: || (isLoadable(optionsDefault) && scopeRules_APPEND_ONLY_READ_THE_DOCS)\n  ) {\n    return atomWithFallback({ ...restOptions,\n      default: optionsDefault // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n\n    }); // @fb-only: } else if (scopeRules_APPEND_ONLY_READ_THE_DOCS\n    // @fb-only: && !isPromise(optionsDefault)\n    // @fb-only: && !isLoadable(optionsDefault)\n    // @fb-only: ) {\n    // @fb-only: return scopedAtom<T>({\n    // @fb-only: ...restOptions,\n    // @fb-only: default: unwrap<T>(optionsDefault),\n    // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n    // @fb-only: });\n  } else {\n    return baseAtom({ ...restOptions,\n      default: optionsDefault\n    });\n  }\n}\n\nfunction atomWithFallback(options) {\n  const base = atom({ ...options,\n    default: DEFAULT_VALUE$7,\n    persistence_UNSTABLE: options.persistence_UNSTABLE === undefined ? undefined : { ...options.persistence_UNSTABLE,\n      validator: storedValue => storedValue instanceof DefaultValue$2 ? storedValue : Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue, DEFAULT_VALUE$7)\n    },\n    // TODO Hack for now.\n    effects: options.effects,\n    // flowlint-line unclear-type: off\n    effects_UNSTABLE: options.effects_UNSTABLE // flowlint-line unclear-type: off\n\n  });\n  const sel = Recoil_selector({\n    key: `${options.key}__withFallback`,\n    get: ({\n      get\n    }) => {\n      const baseValue = get(base);\n      return baseValue instanceof DefaultValue$2 ? options.default : baseValue;\n    },\n    set: ({\n      set\n    }, newValue) => set(base, newValue),\n    // This selector does not need to cache as it is a wrapper selector\n    // and the selector within the wrapper selector will have a cache\n    // option by default\n    cachePolicy_UNSTABLE: {\n      eviction: 'most-recent'\n    },\n    dangerouslyAllowMutability: options.dangerouslyAllowMutability\n  });\n  setConfigDeletionHandler$1(sel.key, getConfigDeletionHandler$2(options.key));\n  return sel;\n}\n\natom.value = value => new WrappedValue$2(value);\n\nvar Recoil_atom = atom;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nclass MapCache {\n  constructor(options) {\n    var _options$mapKey;\n\n    _defineProperty(this, \"_map\", void 0);\n\n    _defineProperty(this, \"_keyMapper\", void 0);\n\n    this._map = new Map();\n    this._keyMapper = (_options$mapKey = options === null || options === void 0 ? void 0 : options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : v => v;\n  }\n\n  size() {\n    return this._map.size;\n  }\n\n  has(key) {\n    return this._map.has(this._keyMapper(key));\n  }\n\n  get(key) {\n    return this._map.get(this._keyMapper(key));\n  }\n\n  set(key, val) {\n    this._map.set(this._keyMapper(key), val);\n  }\n\n  delete(key) {\n    this._map.delete(this._keyMapper(key));\n  }\n\n  clear() {\n    this._map.clear();\n  }\n\n}\n\nvar Recoil_MapCache = {\n  MapCache\n};\nvar Recoil_MapCache_1 = Recoil_MapCache.MapCache;\nvar Recoil_MapCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MapCache: Recoil_MapCache_1\n});\nconst {\n  LRUCache: LRUCache$2\n} = Recoil_LRUCache$1;\nconst {\n  MapCache: MapCache$1\n} = Recoil_MapCache$1;\nconst defaultPolicy$1 = {\n  equality: 'reference',\n  eviction: 'none',\n  maxSize: Infinity\n};\n\nfunction cacheFromPolicy({\n  equality = defaultPolicy$1.equality,\n  eviction = defaultPolicy$1.eviction,\n  maxSize = defaultPolicy$1.maxSize\n} = defaultPolicy$1) {\n  const valueMapper = getValueMapper$1(equality);\n  const cache = getCache(eviction, maxSize, valueMapper);\n  return cache;\n}\n\nfunction getValueMapper$1(equality) {\n  switch (equality) {\n    case 'reference':\n      return val => val;\n\n    case 'value':\n      return val => Recoil_stableStringify(val);\n  }\n\n  throw Recoil_err(`Unrecognized equality policy ${equality}`);\n}\n\nfunction getCache(eviction, maxSize, mapKey) {\n  switch (eviction) {\n    case 'keep-all':\n      return new MapCache$1({\n        mapKey\n      });\n\n    case 'lru':\n      return new LRUCache$2({\n        mapKey,\n        maxSize: Recoil_nullthrows(maxSize)\n      });\n\n    case 'most-recent':\n      return new LRUCache$2({\n        mapKey,\n        maxSize: 1\n      });\n  }\n\n  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);\n}\n\nvar Recoil_cacheFromPolicy = cacheFromPolicy; // @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';\n\nconst {\n  setConfigDeletionHandler: setConfigDeletionHandler$2\n} = Recoil_Node; // Process scopeRules to handle any entries which are functions taking parameters\n// prettier-ignore\n// @fb-only: function mapScopeRules<P>(\n// @fb-only: scopeRules?: ParameterizedScopeRules<P>,\n// @fb-only: param: P,\n// @fb-only: ): ScopeRules | void {\n// @fb-only: return scopeRules?.map(rule =>\n// @fb-only: Array.isArray(rule)\n// @fb-only: ? rule.map(entry => (typeof entry === 'function' ? entry(param) : entry))\n// @fb-only: : rule,\n// @fb-only: );\n// @fb-only: }\n\n/*\nA function which returns an atom based on the input parameter.\n\nEach unique parameter returns a unique atom. E.g.,\n\n  const f = atomFamily(...);\n  f({a: 1}) => an atom\n  f({a: 2}) => a different atom\n\nThis allows components to persist local, private state using atoms.  Each\ninstance of the component may have a different key, which it uses as the\nparameter for a family of atoms; in this way, each component will have\nits own atom not shared by other instances.  These state keys may be composed\ninto children's state keys as well.\n*/\n\nfunction atomFamily(options) {\n  var _options$cachePolicyF, _options$cachePolicyF2;\n\n  const atomCache = Recoil_cacheFromPolicy({\n    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : 'value',\n    eviction: 'keep-all'\n  }); // Simple atomFamily implementation to cache individual atoms based\n  // on the parameter value equality.\n\n  return params => {\n    var _stableStringify, _options$effects;\n\n    const cachedAtom = atomCache.get(params);\n\n    if (cachedAtom != null) {\n      return cachedAtom;\n    }\n\n    const {\n      cachePolicyForParams_UNSTABLE,\n      ...atomOptions\n    } = options;\n    const optionsDefault = 'default' in options ? // $FlowIssue[prop-missing] No way to refine in Flow that property is not defined\n    // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined\n    options.default : new Promise(() => {});\n    const newAtom = Recoil_atom({ ...atomOptions,\n      key: `${options.key}__${(_stableStringify = Recoil_stableStringify(params)) !== null && _stableStringify !== void 0 ? _stableStringify : 'void'}`,\n      default: typeof optionsDefault === 'function' ? // The default was parameterized\n      // Flow doesn't know that T isn't a function, so we need to case to any\n      // $FlowIssue[incompatible-use]\n      optionsDefault(params) : // Default may be a static value, promise, or RecoilValue\n      optionsDefault,\n      retainedBy_UNSTABLE: typeof options.retainedBy_UNSTABLE === 'function' ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE,\n      effects: typeof options.effects === 'function' ? options.effects(params) : typeof options.effects_UNSTABLE === 'function' ? options.effects_UNSTABLE(params) : (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE // prettier-ignore\n      // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS: mapScopeRules(\n      // @fb-only: options.scopeRules_APPEND_ONLY_READ_THE_DOCS,\n      // @fb-only: params,\n      // @fb-only: ),\n\n    });\n    atomCache.set(params, newAtom);\n    setConfigDeletionHandler$2(newAtom.key, () => {\n      atomCache.delete(params);\n    });\n    return newAtom;\n  };\n}\n\nvar Recoil_atomFamily = atomFamily;\nconst {\n  setConfigDeletionHandler: setConfigDeletionHandler$3\n} = Recoil_Node; // Keep in mind the parameter needs to be serializable as a cahche key\n// using Recoil_stableStringify\n// Add a unique index to each selector in case the cache implementation allows\n// duplicate keys based on equivalent stringified parameters\n\nlet nextIndex = 0;\n/* eslint-disable no-redeclare */\n// Return a function that returns members of a family of selectors of the same type\n// E.g.,\n//\n// const s = selectorFamily(...);\n// s({a: 1}) => a selector\n// s({a: 2}) => a different selector\n//\n// By default, the selectors are distinguished by distinct values of the\n// parameter based on value equality, not reference equality.  This allows using\n// object literals or other equivalent objects at callsites to not create\n// duplicate cache entries.  This behavior may be overridden with the\n// cacheImplementationForParams option.\n\nfunction selectorFamily(options) {\n  var _options$cachePolicyF, _options$cachePolicyF2;\n\n  const selectorCache = Recoil_cacheFromPolicy({\n    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : 'value',\n    eviction: 'keep-all'\n  });\n  return params => {\n    var _stableStringify; // Throw an error with selector key so that it is clear which\n    // selector is causing an error\n\n\n    let cachedSelector;\n\n    try {\n      cachedSelector = selectorCache.get(params);\n    } catch (error) {\n      throw Recoil_err(`Problem with cache lookup for selector ${options.key}: ${error.message}`);\n    }\n\n    if (cachedSelector != null) {\n      return cachedSelector;\n    }\n\n    const myKey = `${options.key}__selectorFamily/${(_stableStringify = Recoil_stableStringify(params, {\n      // It is possible to use functions in parameters if the user uses\n      // a cache with reference equality thanks to the incrementing index.\n      allowFunctions: true\n    })) !== null && _stableStringify !== void 0 ? _stableStringify : 'void'}/${nextIndex++}`; // Append index in case values serialize to the same key string\n\n    const myGet = callbacks => options.get(params)(callbacks);\n\n    const myCachePolicy = options.cachePolicy_UNSTABLE;\n    const retainedBy = typeof options.retainedBy_UNSTABLE === 'function' ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE;\n    let newSelector;\n\n    if (options.set != null) {\n      const set = options.set;\n\n      const mySet = (callbacks, newValue) => set(params)(callbacks, newValue);\n\n      newSelector = Recoil_selector({\n        key: myKey,\n        get: myGet,\n        set: mySet,\n        cachePolicy_UNSTABLE: myCachePolicy,\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n        retainedBy_UNSTABLE: retainedBy\n      });\n    } else {\n      newSelector = Recoil_selector({\n        key: myKey,\n        get: myGet,\n        cachePolicy_UNSTABLE: myCachePolicy,\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n        retainedBy_UNSTABLE: retainedBy\n      });\n    }\n\n    selectorCache.set(params, newSelector);\n    setConfigDeletionHandler$3(newSelector.key, () => {\n      selectorCache.delete(params);\n    });\n    return newSelector;\n  };\n}\n/* eslint-enable no-redeclare */\n\n\nvar Recoil_selectorFamily = selectorFamily; // flowlint-next-line unclear-type:off\n\nconst constantSelector = Recoil_selectorFamily({\n  key: '__constant',\n  get: constant => () => constant,\n  cachePolicyForParams_UNSTABLE: {\n    equality: 'reference'\n  }\n}); // Function that returns a selector which always produces the\n// same constant value.  It may be called multiple times with the\n// same value, based on reference equality, and will provide the\n// same selector.\n\nfunction constSelector(constant) {\n  return constantSelector(constant);\n}\n\nvar Recoil_constSelector = constSelector; // flowlint-next-line unclear-type:off\n\nconst throwingSelector = Recoil_selectorFamily({\n  key: '__error',\n  get: message => () => {\n    throw Recoil_err(message);\n  },\n  // TODO Why?\n  cachePolicyForParams_UNSTABLE: {\n    equality: 'reference'\n  }\n}); // Function that returns a selector which always throws an error\n// with the provided message.\n\nfunction errorSelector(message) {\n  return throwingSelector(message);\n}\n\nvar Recoil_errorSelector = errorSelector;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Wraps another recoil value and prevents writing to it.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction readOnlySelector(atom) {\n  // flowlint-next-line unclear-type: off\n  return atom;\n}\n\nvar Recoil_readOnlySelector = readOnlySelector;\nconst {\n  loadableWithError: loadableWithError$3,\n  loadableWithPromise: loadableWithPromise$3,\n  loadableWithValue: loadableWithValue$4\n} = Recoil_Loadable$1; /////////////////\n//  TRUTH TABLE\n/////////////////\n// Dependencies        waitForNone         waitForAny        waitForAll       waitForAllSettled\n//  [loading, loading]  [Promise, Promise]  Promise           Promise         Promise\n//  [value, loading]    [value, Promise]    [value, Promise]  Promise         Promise\n//  [value, value]      [value, value]      [value, value]    [value, value]  [value, value]\n//\n//  [error, loading]    [Error, Promise]    [Error, Promise]  Error           Promise\n//  [error, error]      [Error, Error]      [Error, Error]    Error           [error, error]\n//  [value, error]      [value, Error]      [value, Error]    Error           [value, error]\n// Issue parallel requests for all dependencies and return the current\n// status if they have results, have some error, or are still pending.\n\nfunction concurrentRequests(getRecoilValue, deps) {\n  const results = Array(deps.length).fill(undefined);\n  const exceptions = Array(deps.length).fill(undefined);\n\n  for (const [i, dep] of deps.entries()) {\n    try {\n      results[i] = getRecoilValue(dep);\n    } catch (e) {\n      // exceptions can either be Promises of pending results or real errors\n      exceptions[i] = e;\n    }\n  }\n\n  return [results, exceptions];\n}\n\nfunction isError(exp) {\n  return exp != null && !Recoil_isPromise(exp);\n}\n\nfunction unwrapDependencies(dependencies) {\n  return Array.isArray(dependencies) ? dependencies : Object.getOwnPropertyNames(dependencies).map(key => dependencies[key]);\n}\n\nfunction wrapResults(dependencies,\n/* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n * LTI update could not be added via codemod */\nresults) {\n  return Array.isArray(dependencies) ? results : // Object.getOwnPropertyNames() has consistent key ordering with ES6\n  Object.getOwnPropertyNames(dependencies).reduce((out, key, idx) => ({ ...out,\n    [key]: results[idx]\n  }), {});\n}\n\nfunction wrapLoadables(dependencies, results, exceptions) {\n  const output = exceptions.map((exception, idx) => exception == null ? loadableWithValue$4(results[idx]) : Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));\n  return wrapResults(dependencies, output);\n}\n\nfunction combineAsyncResultsWithSyncResults(syncResults, asyncResults) {\n  return asyncResults.map((result, idx) =>\n  /**\n   * it's important we use === undefined as opposed to == null, because the\n   * resolved value of the async promise could be `null`, in which case we\n   * don't want to use syncResults[idx], which would be undefined. If async\n   * promise resolves to `undefined`, that's ok because `syncResults[idx]`\n   * will also be `undefined`. That's a little hacky, but it works.\n   */\n  result === undefined ? syncResults[idx] : result);\n} // Selector that requests all dependencies in parallel and immediately returns\n// current results without waiting.\n\n\nconst waitForNone = Recoil_selectorFamily({\n  key: '__waitForNone',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // Always return the current status of the results; never block.\n\n    return wrapLoadables(dependencies, results, exceptions);\n  },\n  dangerouslyAllowMutability: true\n}); // Selector that requests all dependencies in parallel and waits for at least\n// one to be available before returning results.  It will only error if all\n// dependencies have errors.\n\nconst waitForAny = Recoil_selectorFamily({\n  key: '__waitForAny',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If any results are available, value or error, return the current status\n\n    if (exceptions.some(exp => !Recoil_isPromise(exp))) {\n      return wrapLoadables(dependencies, results, exceptions);\n    } // Otherwise, return a promise that will resolve when the next result is\n    // available, whichever one happens to be next.  But, if all pending\n    // dependencies end up with errors, then reject the promise.\n\n\n    return new Promise(resolve => {\n      for (const [i, exp] of exceptions.entries()) {\n        if (Recoil_isPromise(exp)) {\n          exp.then(result => {\n            results[i] = result;\n            exceptions[i] = undefined;\n            resolve(wrapLoadables(dependencies, results, exceptions));\n          }).catch(error => {\n            exceptions[i] = error;\n            resolve(wrapLoadables(dependencies, results, exceptions));\n          });\n        }\n      }\n    });\n  },\n  dangerouslyAllowMutability: true\n}); // Selector that requests all dependencies in parallel and waits for all to be\n// available before returning a value.  It will error if any dependencies error.\n\nconst waitForAll = Recoil_selectorFamily({\n  key: '__waitForAll',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results\n\n    if (exceptions.every(exp => exp == null)) {\n      return wrapResults(dependencies, results);\n    } // If we have any errors, throw the first error\n\n\n    const error = exceptions.find(isError);\n\n    if (error != null) {\n      throw error;\n    } // Otherwise, return a promise that will resolve when all results are available\n\n\n    return Promise.all(exceptions).then(exceptionResults => wrapResults(dependencies, combineAsyncResultsWithSyncResults(results, exceptionResults)));\n  },\n  dangerouslyAllowMutability: true\n});\nconst waitForAllSettled = Recoil_selectorFamily({\n  key: '__waitForAllSettled',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results\n\n    if (exceptions.every(exp => !Recoil_isPromise(exp))) {\n      return wrapLoadables(dependencies, results, exceptions);\n    } // Wait for all results to settle\n\n\n    return Promise.all(exceptions.map((exp, i) => Recoil_isPromise(exp) ? exp.then(result => {\n      results[i] = result;\n      exceptions[i] = undefined;\n    }).catch(error => {\n      results[i] = undefined;\n      exceptions[i] = error;\n    }) : null)) // Then wrap them as loadables\n    .then(() => wrapLoadables(dependencies, results, exceptions));\n  },\n  dangerouslyAllowMutability: true\n});\nconst noWait = Recoil_selectorFamily({\n  key: '__noWait',\n  get: dependency => ({\n    get\n  }) => {\n    try {\n      return Recoil_selector.value(loadableWithValue$4(get(dependency)));\n    } catch (exception) {\n      return Recoil_selector.value(Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));\n    }\n  },\n  dangerouslyAllowMutability: true\n});\nvar Recoil_WaitFor = {\n  waitForNone,\n  waitForAny,\n  waitForAll,\n  waitForAllSettled,\n  noWait\n};\nconst {\n  RecoilLoadable\n} = Recoil_Loadable$1;\nconst {\n  DefaultValue: DefaultValue$3\n} = Recoil_Node;\nconst {\n  RecoilRoot: RecoilRoot$2,\n  useRecoilStoreID: useRecoilStoreID$1\n} = Recoil_RecoilRoot;\nconst {\n  isRecoilValue: isRecoilValue$5\n} = Recoil_RecoilValue$1;\nconst {\n  retentionZone: retentionZone$1\n} = Recoil_RetentionZone;\nconst {\n  freshSnapshot: freshSnapshot$2\n} = Recoil_Snapshot$1;\nconst {\n  useRecoilState: useRecoilState$1,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilStateLoadable: useRecoilStateLoadable$1,\n  useRecoilValue: useRecoilValue$1,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilValueLoadable: useRecoilValueLoadable$1,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,\n  useResetRecoilState: useResetRecoilState$1,\n  useSetRecoilState: useSetRecoilState$1\n} = Recoil_Hooks;\nconst {\n  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,\n  useRecoilSnapshot: useRecoilSnapshot$1,\n  useRecoilTransactionObserver: useRecoilTransactionObserver$1\n} = Recoil_SnapshotHooks;\nconst {\n  useRecoilCallback: useRecoilCallback$1\n} = Recoil_useRecoilCallback;\nconst {\n  noWait: noWait$1,\n  waitForAll: waitForAll$1,\n  waitForAllSettled: waitForAllSettled$1,\n  waitForAny: waitForAny$1,\n  waitForNone: waitForNone$1\n} = Recoil_WaitFor;\nvar Recoil_index = {\n  // Types\n  DefaultValue: DefaultValue$3,\n  isRecoilValue: isRecoilValue$5,\n  RecoilLoadable,\n  // Recoil Root\n  RecoilRoot: RecoilRoot$2,\n  useRecoilStoreID: useRecoilStoreID$1,\n  useRecoilBridgeAcrossReactRoots_UNSTABLE: Recoil_useRecoilBridgeAcrossReactRoots,\n  // Atoms/Selectors\n  atom: Recoil_atom,\n  selector: Recoil_selector,\n  // Convenience Atoms/Selectors\n  atomFamily: Recoil_atomFamily,\n  selectorFamily: Recoil_selectorFamily,\n  constSelector: Recoil_constSelector,\n  errorSelector: Recoil_errorSelector,\n  readOnlySelector: Recoil_readOnlySelector,\n  // Concurrency Helpers for Atoms/Selectors\n  noWait: noWait$1,\n  waitForNone: waitForNone$1,\n  waitForAny: waitForAny$1,\n  waitForAll: waitForAll$1,\n  waitForAllSettled: waitForAllSettled$1,\n  // Hooks for Atoms/Selectors\n  useRecoilValue: useRecoilValue$1,\n  useRecoilValueLoadable: useRecoilValueLoadable$1,\n  useRecoilState: useRecoilState$1,\n  useRecoilStateLoadable: useRecoilStateLoadable$1,\n  useSetRecoilState: useSetRecoilState$1,\n  useResetRecoilState: useResetRecoilState$1,\n  useGetRecoilValueInfo_UNSTABLE: Recoil_useGetRecoilValueInfo,\n  useRecoilRefresher_UNSTABLE: Recoil_useRecoilRefresher,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,\n  // Hooks for complex operations\n  useRecoilCallback: useRecoilCallback$1,\n  useRecoilTransaction_UNSTABLE: Recoil_useRecoilTransaction,\n  // Snapshots\n  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,\n  useRecoilSnapshot: useRecoilSnapshot$1,\n  useRecoilTransactionObserver_UNSTABLE: useRecoilTransactionObserver$1,\n  snapshot_UNSTABLE: freshSnapshot$2,\n  // Memory Management\n  useRetain: Recoil_useRetain,\n  retentionZone: retentionZone$1\n};\nvar Recoil_index_1 = Recoil_index.DefaultValue;\nvar Recoil_index_2 = Recoil_index.isRecoilValue;\nvar Recoil_index_3 = Recoil_index.RecoilLoadable;\nvar Recoil_index_4 = Recoil_index.RecoilRoot;\nvar Recoil_index_5 = Recoil_index.useRecoilStoreID;\nvar Recoil_index_6 = Recoil_index.useRecoilBridgeAcrossReactRoots_UNSTABLE;\nvar Recoil_index_7 = Recoil_index.atom;\nvar Recoil_index_8 = Recoil_index.selector;\nvar Recoil_index_9 = Recoil_index.atomFamily;\nvar Recoil_index_10 = Recoil_index.selectorFamily;\nvar Recoil_index_11 = Recoil_index.constSelector;\nvar Recoil_index_12 = Recoil_index.errorSelector;\nvar Recoil_index_13 = Recoil_index.readOnlySelector;\nvar Recoil_index_14 = Recoil_index.noWait;\nvar Recoil_index_15 = Recoil_index.waitForNone;\nvar Recoil_index_16 = Recoil_index.waitForAny;\nvar Recoil_index_17 = Recoil_index.waitForAll;\nvar Recoil_index_18 = Recoil_index.waitForAllSettled;\nvar Recoil_index_19 = Recoil_index.useRecoilValue;\nvar Recoil_index_20 = Recoil_index.useRecoilValueLoadable;\nvar Recoil_index_21 = Recoil_index.useRecoilState;\nvar Recoil_index_22 = Recoil_index.useRecoilStateLoadable;\nvar Recoil_index_23 = Recoil_index.useSetRecoilState;\nvar Recoil_index_24 = Recoil_index.useResetRecoilState;\nvar Recoil_index_25 = Recoil_index.useGetRecoilValueInfo_UNSTABLE;\nvar Recoil_index_26 = Recoil_index.useRecoilRefresher_UNSTABLE;\nvar Recoil_index_27 = Recoil_index.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_28 = Recoil_index.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_29 = Recoil_index.useRecoilState_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_30 = Recoil_index.useRecoilCallback;\nvar Recoil_index_31 = Recoil_index.useRecoilTransaction_UNSTABLE;\nvar Recoil_index_32 = Recoil_index.useGotoRecoilSnapshot;\nvar Recoil_index_33 = Recoil_index.useRecoilSnapshot;\nvar Recoil_index_34 = Recoil_index.useRecoilTransactionObserver_UNSTABLE;\nvar Recoil_index_35 = Recoil_index.snapshot_UNSTABLE;\nvar Recoil_index_36 = Recoil_index.useRetain;\nvar Recoil_index_37 = Recoil_index.retentionZone;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Recoil_index);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM3aEIsMENBQW5DO0FBQ0EsSUFBSWlrQixlQUFlLEdBQUdwQyxZQUFZLENBQUM3YSxpQkFBbkM7QUFDQSxJQUFJa2QsZUFBZSxHQUFHckMsWUFBWSxDQUFDSSw2QkFBbkM7QUFDQSxJQUFJa0MsZUFBZSxHQUFHdEMsWUFBWSxDQUFDeGUscUJBQW5DO0FBQ0EsSUFBSStnQixlQUFlLEdBQUd2QyxZQUFZLENBQUNwZixpQkFBbkM7QUFDQSxJQUFJNGhCLGVBQWUsR0FBR3hDLFlBQVksQ0FBQ0sscUNBQW5DO0FBQ0EsSUFBSW9DLGVBQWUsR0FBR3pDLFlBQVksQ0FBQ00saUJBQW5DO0FBQ0EsSUFBSW9DLGVBQWUsR0FBRzFDLFlBQVksQ0FBQ2xuQixTQUFuQztBQUNBLElBQUk2cEIsZUFBZSxHQUFHM0MsWUFBWSxDQUFDcitCLGFBQW5DO0FBRUEsK0RBQWVxK0IsWUFBZiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVjb2lsL2VzL2luZGV4LmpzPzNhNjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCByZWFjdERvbSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBlcnIobWVzc2FnZSkge1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTsgLy8gSW4gVjgsIEVycm9yIG9iamVjdHMga2VlcCB0aGUgY2xvc3VyZSBzY29wZSBjaGFpbiBhbGl2ZSB1bnRpbCB0aGVcbiAgLy8gZXJyLnN0YWNrIHByb3BlcnR5IGlzIGFjY2Vzc2VkLlxuXG4gIGlmIChlcnJvci5zdGFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gSUUgc2V0cyB0aGUgc3RhY2sgb25seSBpZiBlcnJvciBpcyB0aHJvd25cbiAgICB0cnkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBjYXRjaCAoXykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBmYi13d3cvbm8tdW51c2VkLWNhdGNoLWJpbmRpbmdzLCBuby1lbXB0eVxuXG4gIH1cblxuICByZXR1cm4gZXJyb3I7XG59XG5cbnZhciBlcnJfMSA9IGVycjtcblxuLy8gQG9zcy1vbmx5XG5cblxudmFyIFJlY29pbF9lcnIgPSBlcnJfMTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuLy8gU3BsaXQgZGVjbGFyYXRpb24gYW5kIGltcGxlbWVudGF0aW9uIHRvIGFsbG93IHRoaXMgZnVuY3Rpb24gdG8gcHJldGVuZCB0b1xuLy8gY2hlY2sgZm9yIGFjdHVhbCBpbnN0YW5jZSBvZiBQcm9taXNlIGluc3RlYWQgb2Ygc29tZXRoaW5nIHdpdGggYSBgdGhlbmBcbi8vIG1ldGhvZC5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmZ1bmN0aW9uIGlzUHJvbWlzZShwKSB7XG4gIHJldHVybiAhIXAgJiYgdHlwZW9mIHAudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIFJlY29pbF9pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIG51bGx0aHJvd3MoeCwgbWVzc2FnZSkge1xuICBpZiAoeCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cblxuICB0aHJvdyBSZWNvaWxfZXJyKG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICdHb3QgdW5leHBlY3RlZCBudWxsIG9yIHVuZGVmaW5lZCcpO1xufVxuXG52YXIgUmVjb2lsX251bGx0aHJvd3MgPSBudWxsdGhyb3dzO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuY2xhc3MgQmFzZUxvYWRhYmxlIHtcbiAgZ2V0VmFsdWUoKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XG4gIH1cblxuICB0b1Byb21pc2UoKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XG4gIH1cblxuICB2YWx1ZU1heWJlKCkge1xuICAgIHRocm93IFJlY29pbF9lcnIoJ0Jhc2VMb2FkYWJsZScpO1xuICB9XG5cbiAgdmFsdWVPclRocm93KCkge1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHRocm93IFJlY29pbF9lcnIoYExvYWRhYmxlIGV4cGVjdGVkIHZhbHVlLCBidXQgaW4gXCIke3RoaXMuc3RhdGV9XCIgc3RhdGVgKTtcbiAgfVxuXG4gIHByb21pc2VNYXliZSgpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcbiAgfVxuXG4gIHByb21pc2VPclRocm93KCkge1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHRocm93IFJlY29pbF9lcnIoYExvYWRhYmxlIGV4cGVjdGVkIHByb21pc2UsIGJ1dCBpbiBcIiR7dGhpcy5zdGF0ZX1cIiBzdGF0ZWApO1xuICB9XG5cbiAgZXJyb3JNYXliZSgpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcbiAgfVxuXG4gIGVycm9yT3JUaHJvdygpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICB0aHJvdyBSZWNvaWxfZXJyKGBMb2FkYWJsZSBleHBlY3RlZCBlcnJvciwgYnV0IGluIFwiJHt0aGlzLnN0YXRlfVwiIHN0YXRlYCk7XG4gIH1cblxuICBpcyhvdGhlcikge1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHJldHVybiBvdGhlci5zdGF0ZSA9PT0gdGhpcy5zdGF0ZSAmJiBvdGhlci5jb250ZW50cyA9PT0gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIG1hcChfbWFwKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XG4gIH1cblxufVxuXG5jbGFzcyBWYWx1ZUxvYWRhYmxlIGV4dGVuZHMgQmFzZUxvYWRhYmxlIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwgJ2hhc1ZhbHVlJyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZW50c1wiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5jb250ZW50cyA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICB0b1Byb21pc2UoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmNvbnRlbnRzKTtcbiAgfVxuXG4gIHZhbHVlTWF5YmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICB2YWx1ZU9yVGhyb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICBwcm9taXNlTWF5YmUoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGVycm9yTWF5YmUoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIG1hcChtYXApIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV4dCA9IG1hcCh0aGlzLmNvbnRlbnRzKTtcbiAgICAgIHJldHVybiBSZWNvaWxfaXNQcm9taXNlKG5leHQpID8gbG9hZGFibGVXaXRoUHJvbWlzZShuZXh0KSA6IGlzTG9hZGFibGUobmV4dCkgPyBuZXh0IDogbG9hZGFibGVXaXRoVmFsdWUobmV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFJlY29pbF9pc1Byb21pc2UoZSkgPyAvLyBJZiB3ZSBcInN1c3BlbmRlZFwiLCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICAgIC8vIGVycm9ycyBhbmQgc3Vic2VxdWVudCByZXRyaWVzIHdpbGwgYmUgaGFuZGxlZCBpbiAnbG9hZGluZycgY2FzZVxuICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBsb2FkYWJsZVdpdGhQcm9taXNlKGUubmV4dCgoKSA9PiB0aGlzLm1hcChtYXApKSkgOiBsb2FkYWJsZVdpdGhFcnJvcihlKTtcbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBFcnJvckxvYWRhYmxlIGV4dGVuZHMgQmFzZUxvYWRhYmxlIHtcbiAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwgJ2hhc0Vycm9yJyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZW50c1wiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5jb250ZW50cyA9IGVycm9yO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgdGhyb3cgdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIHRvUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5jb250ZW50cyk7XG4gIH1cblxuICB2YWx1ZU1heWJlKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBwcm9taXNlTWF5YmUoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGVycm9yTWF5YmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICBlcnJvck9yVGhyb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICBtYXAoX21hcCkge1xuICAgIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5cbmNsYXNzIExvYWRpbmdMb2FkYWJsZSBleHRlbmRzIEJhc2VMb2FkYWJsZSB7XG4gIGNvbnN0cnVjdG9yKHByb21pc2UpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwgJ2xvYWRpbmcnKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRlbnRzXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmNvbnRlbnRzID0gcHJvbWlzZTtcbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIHRocm93IHRoaXMuY29udGVudHM7XG4gIH1cblxuICB0b1Byb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICB2YWx1ZU1heWJlKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBwcm9taXNlTWF5YmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICBwcm9taXNlT3JUaHJvdygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIGVycm9yTWF5YmUoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIG1hcChtYXApIHtcbiAgICByZXR1cm4gbG9hZGFibGVXaXRoUHJvbWlzZSh0aGlzLmNvbnRlbnRzLnRoZW4odmFsdWUgPT4ge1xuICAgICAgY29uc3QgbmV4dCA9IG1hcCh2YWx1ZSk7XG5cbiAgICAgIGlmIChpc0xvYWRhYmxlKG5leHQpKSB7XG4gICAgICAgIGNvbnN0IG5leHRMb2FkYWJsZSA9IG5leHQ7XG5cbiAgICAgICAgc3dpdGNoIChuZXh0TG9hZGFibGUuc3RhdGUpIHtcbiAgICAgICAgICBjYXNlICdoYXNWYWx1ZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV4dExvYWRhYmxlLmNvbnRlbnRzO1xuXG4gICAgICAgICAgY2FzZSAnaGFzRXJyb3InOlxuICAgICAgICAgICAgdGhyb3cgbmV4dExvYWRhYmxlLmNvbnRlbnRzO1xuXG4gICAgICAgICAgY2FzZSAnbG9hZGluZyc6XG4gICAgICAgICAgICByZXR1cm4gbmV4dExvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICB9IC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuXG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKGUpKSB7XG4gICAgICAgIC8vIHdlIHdlcmUgXCJzdXNwZW5kZWQsXCIgdHJ5IGFnYWluXG4gICAgICAgIHJldHVybiBlLnRoZW4oKCkgPT4gdGhpcy5tYXAobWFwKS5jb250ZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGU7XG4gICAgfSkpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gbG9hZGFibGVXaXRoVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobmV3IFZhbHVlTG9hZGFibGUodmFsdWUpKTtcbn1cblxuZnVuY3Rpb24gbG9hZGFibGVXaXRoRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobmV3IEVycm9yTG9hZGFibGUoZXJyb3IpKTtcbn1cblxuZnVuY3Rpb24gbG9hZGFibGVXaXRoUHJvbWlzZShwcm9taXNlKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG5ldyBMb2FkaW5nTG9hZGFibGUocHJvbWlzZSkpO1xufVxuXG5mdW5jdGlvbiBsb2FkYWJsZUxvYWRpbmcoKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG5ldyBMb2FkaW5nTG9hZGFibGUobmV3IFByb21pc2UoKCkgPT4ge30pKSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRhYmxlQWxsQXJyYXkoaW5wdXRzKSB7XG4gIHJldHVybiBpbnB1dHMuZXZlcnkoaSA9PiBpLnN0YXRlID09PSAnaGFzVmFsdWUnKSA/IGxvYWRhYmxlV2l0aFZhbHVlKGlucHV0cy5tYXAoaSA9PiBpLmNvbnRlbnRzKSkgOiBpbnB1dHMuc29tZShpID0+IGkuc3RhdGUgPT09ICdoYXNFcnJvcicpID8gbG9hZGFibGVXaXRoRXJyb3IoUmVjb2lsX251bGx0aHJvd3MoaW5wdXRzLmZpbmQoaSA9PiBpLnN0YXRlID09PSAnaGFzRXJyb3InKSwgJ0ludmFsaWQgbG9hZGFibGUgcGFzc2VkIHRvIGxvYWRhYmxlQWxsJykuY29udGVudHMpIDogbG9hZGFibGVXaXRoUHJvbWlzZShQcm9taXNlLmFsbChpbnB1dHMubWFwKGkgPT4gaS5jb250ZW50cykpKTtcbn1cblxuZnVuY3Rpb24gbG9hZGFibGVBbGwoaW5wdXRzKSB7XG4gIGNvbnN0IHVud3JhcGVkSW5wdXRzID0gQXJyYXkuaXNBcnJheShpbnB1dHMpID8gaW5wdXRzIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5wdXRzKS5tYXAoa2V5ID0+IGlucHV0c1trZXldKTtcbiAgY29uc3Qgbm9ybWFsaXplZElucHV0cyA9IHVud3JhcGVkSW5wdXRzLm1hcCh4ID0+IGlzTG9hZGFibGUoeCkgPyB4IDogUmVjb2lsX2lzUHJvbWlzZSh4KSA/IGxvYWRhYmxlV2l0aFByb21pc2UoeCkgOiBsb2FkYWJsZVdpdGhWYWx1ZSh4KSk7XG4gIGNvbnN0IG91dHB1dCA9IGxvYWRhYmxlQWxsQXJyYXkobm9ybWFsaXplZElucHV0cyk7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0cykgPyAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gIG91dHB1dCA6IC8vIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCkgaGFzIGNvbnNpc3RlbnQga2V5IG9yZGVyaW5nIHdpdGggRVM2XG4gIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLWNhbGxdXG4gIG91dHB1dC5tYXAob3V0cHV0cyA9PiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbnB1dHMpLnJlZHVjZSgob3V0LCBrZXksIGlkeCkgPT4gKHsgLi4ub3V0LFxuICAgIFtrZXldOiBvdXRwdXRzW2lkeF1cbiAgfSksIHt9KSk7XG59XG5cbmZ1bmN0aW9uIGlzTG9hZGFibGUoeCkge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIEJhc2VMb2FkYWJsZTtcbn1cblxuY29uc3QgTG9hZGFibGVTdGF0aWNJbnRlcmZhY2UgPSB7XG4gIG9mOiB2YWx1ZSA9PiBSZWNvaWxfaXNQcm9taXNlKHZhbHVlKSA/IGxvYWRhYmxlV2l0aFByb21pc2UodmFsdWUpIDogaXNMb2FkYWJsZSh2YWx1ZSkgPyB2YWx1ZSA6IGxvYWRhYmxlV2l0aFZhbHVlKHZhbHVlKSxcbiAgZXJyb3I6IGVycm9yID0+IGxvYWRhYmxlV2l0aEVycm9yKGVycm9yKSxcbiAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICBsb2FkaW5nOiAoKSA9PiBsb2FkYWJsZUxvYWRpbmcoKSxcbiAgLy8gJEZsb3dJc3N1ZVt1bmNsZWFyLXR5cGVdXG4gIGFsbDogbG9hZGFibGVBbGwsXG4gIGlzTG9hZGFibGVcbn07XG52YXIgUmVjb2lsX0xvYWRhYmxlID0ge1xuICBsb2FkYWJsZVdpdGhWYWx1ZSxcbiAgbG9hZGFibGVXaXRoRXJyb3IsXG4gIGxvYWRhYmxlV2l0aFByb21pc2UsXG4gIGxvYWRhYmxlTG9hZGluZyxcbiAgbG9hZGFibGVBbGwsXG4gIGlzTG9hZGFibGUsXG4gIFJlY29pbExvYWRhYmxlOiBMb2FkYWJsZVN0YXRpY0ludGVyZmFjZVxufTtcblxudmFyIFJlY29pbF9Mb2FkYWJsZV8xID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlV2l0aFZhbHVlO1xudmFyIFJlY29pbF9Mb2FkYWJsZV8yID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlV2l0aEVycm9yO1xudmFyIFJlY29pbF9Mb2FkYWJsZV8zID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlV2l0aFByb21pc2U7XG52YXIgUmVjb2lsX0xvYWRhYmxlXzQgPSBSZWNvaWxfTG9hZGFibGUubG9hZGFibGVMb2FkaW5nO1xudmFyIFJlY29pbF9Mb2FkYWJsZV81ID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlQWxsO1xudmFyIFJlY29pbF9Mb2FkYWJsZV82ID0gUmVjb2lsX0xvYWRhYmxlLmlzTG9hZGFibGU7XG52YXIgUmVjb2lsX0xvYWRhYmxlXzcgPSBSZWNvaWxfTG9hZGFibGUuUmVjb2lsTG9hZGFibGU7XG5cbnZhciBSZWNvaWxfTG9hZGFibGUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBsb2FkYWJsZVdpdGhWYWx1ZTogUmVjb2lsX0xvYWRhYmxlXzEsXG4gIGxvYWRhYmxlV2l0aEVycm9yOiBSZWNvaWxfTG9hZGFibGVfMixcbiAgbG9hZGFibGVXaXRoUHJvbWlzZTogUmVjb2lsX0xvYWRhYmxlXzMsXG4gIGxvYWRhYmxlTG9hZGluZzogUmVjb2lsX0xvYWRhYmxlXzQsXG4gIGxvYWRhYmxlQWxsOiBSZWNvaWxfTG9hZGFibGVfNSxcbiAgaXNMb2FkYWJsZTogUmVjb2lsX0xvYWRhYmxlXzYsXG4gIFJlY29pbExvYWRhYmxlOiBSZWNvaWxfTG9hZGFibGVfN1xufSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmNvbnN0IGdrcyA9IG5ldyBNYXAoKS5zZXQoJ3JlY29pbF9oYW10XzIwMjAnLCB0cnVlKS5zZXQoJ3JlY29pbF9zeW5jX2V4dGVybmFsX3N0b3JlJywgdHJ1ZSkuc2V0KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snLCB0cnVlKS5zZXQoJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJywgdHJ1ZSk7XG5cbmZ1bmN0aW9uIFJlY29pbF9na3hfT1NTKGdrKSB7XG4gIHZhciBfZ2tzJGdldDtcblxuICByZXR1cm4gKF9na3MkZ2V0ID0gZ2tzLmdldChnaykpICE9PSBudWxsICYmIF9na3MkZ2V0ICE9PSB2b2lkIDAgPyBfZ2tzJGdldCA6IGZhbHNlO1xufVxuXG5SZWNvaWxfZ2t4X09TUy5zZXRQYXNzID0gZ2sgPT4ge1xuICBna3Muc2V0KGdrLCB0cnVlKTtcbn07XG5cblJlY29pbF9na3hfT1NTLnNldEZhaWwgPSBnayA9PiB7XG4gIGdrcy5zZXQoZ2ssIGZhbHNlKTtcbn07XG5cblJlY29pbF9na3hfT1NTLmNsZWFyID0gKCkgPT4ge1xuICBna3MuY2xlYXIoKTtcbn07XG5cbnZhciBSZWNvaWxfZ2t4ID0gUmVjb2lsX2dreF9PU1M7IC8vIEBvc3Mtb25seVxuXG52YXIgX2NyZWF0ZU11dGFibGVTb3VyY2UsIF91c2VNdXRhYmxlU291cmNlLCBfdXNlU3luY0V4dGVybmFsU3RvcmU7XG5cblxuXG5cblxuY29uc3QgY3JlYXRlTXV0YWJsZVNvdXJjZSA9IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4oX2NyZWF0ZU11dGFibGVTb3VyY2UgPSByZWFjdC5jcmVhdGVNdXRhYmxlU291cmNlKSAhPT0gbnVsbCAmJiBfY3JlYXRlTXV0YWJsZVNvdXJjZSAhPT0gdm9pZCAwID8gX2NyZWF0ZU11dGFibGVTb3VyY2UgOiByZWFjdC51bnN0YWJsZV9jcmVhdGVNdXRhYmxlU291cmNlO1xuY29uc3QgdXNlTXV0YWJsZVNvdXJjZSA9IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4oX3VzZU11dGFibGVTb3VyY2UgPSByZWFjdC51c2VNdXRhYmxlU291cmNlKSAhPT0gbnVsbCAmJiBfdXNlTXV0YWJsZVNvdXJjZSAhPT0gdm9pZCAwID8gX3VzZU11dGFibGVTb3VyY2UgOiByZWFjdC51bnN0YWJsZV91c2VNdXRhYmxlU291cmNlOyAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVhY3R3Zy9yZWFjdC0xOC9kaXNjdXNzaW9ucy84NlxuXG5jb25zdCB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4oX3VzZVN5bmNFeHRlcm5hbFN0b3JlID0gcmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUpICE9PSBudWxsICYmIF91c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPT0gdm9pZCAwID8gX3VzZVN5bmNFeHRlcm5hbFN0b3JlIDogLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbnJlYWN0LnVuc3RhYmxlX3VzZVN5bmNFeHRlcm5hbFN0b3JlO1xuXG4vKipcbiAqIG1vZGU6IFRoZSBSZWFjdCBBUEkgYW5kIGFwcHJvYWNoIHRvIHVzZSBmb3Igc3luY2luZyBzdGF0ZSB3aXRoIFJlYWN0XG4gKiBlYXJseTogUmUtcmVuZGVycyBmcm9tIFJlY29pbCB1cGRhdGVzIG9jY3VyOlxuICogICAgMSkgZWFybGllclxuICogICAgMikgaW4gc3luYyB3aXRoIFJlYWN0IHVwZGF0ZXMgaW4gdGhlIHNhbWUgYmF0Y2hcbiAqICAgIDMpIGJlZm9yZSB0cmFuc2FjdGlvbiBvYnNlcnZlcnMgaW5zdGVhZCBvZiBhZnRlci5cbiAqIGNvbmN1cnJlbnQ6IElzIHRoZSBjdXJyZW50IG1vZGUgY29tcGF0aWJsZSB3aXRoIENvbmN1cnJlbnQgTW9kZSBhbmQgdXNlVHJhbnNpdGlvbigpXG4gKi9cbmZ1bmN0aW9uIHJlYWN0TW9kZSgpIHtcbiAgLy8gTk9URTogVGhpcyBtb2RlIGlzIGN1cnJlbnRseSBicm9rZW4gd2l0aCBzb21lIFN1c3BlbnNlIGNhc2VzXG4gIC8vIHNlZSBSZWNvaWxfc2VsZWN0b3ItdGVzdC5qc1xuICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX3RyYW5zaXRpb25fc3VwcG9ydCcpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGU6ICdUUkFOU0lUSU9OX1NVUFBPUlQnLFxuICAgICAgZWFybHk6IHRydWUsXG4gICAgICBjb25jdXJyZW50OiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfc3luY19leHRlcm5hbF9zdG9yZScpICYmIHVzZVN5bmNFeHRlcm5hbFN0b3JlICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kZTogJ1NZTkNfRVhURVJOQUxfU1RPUkUnLFxuICAgICAgZWFybHk6IHRydWUsXG4gICAgICBjb25jdXJyZW50OiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX211dGFibGVfc291cmNlJykgJiYgdXNlTXV0YWJsZVNvdXJjZSAhPSBudWxsICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuJGRpc2FibGVSZWNvaWxWYWx1ZU11dGFibGVTb3VyY2VfVEVNUF9IQUNLX0RPX05PVF9VU0UpIHtcbiAgICByZXR1cm4gUmVjb2lsX2dreCgncmVjb2lsX3N1cHByZXNzX3JlcmVuZGVyX2luX2NhbGxiYWNrJykgPyB7XG4gICAgICBtb2RlOiAnTVVUQUJMRV9TT1VSQ0UnLFxuICAgICAgZWFybHk6IHRydWUsXG4gICAgICBjb25jdXJyZW50OiB0cnVlXG4gICAgfSA6IHtcbiAgICAgIG1vZGU6ICdNVVRBQkxFX1NPVVJDRScsXG4gICAgICBlYXJseTogZmFsc2UsXG4gICAgICBjb25jdXJyZW50OiBmYWxzZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gUmVjb2lsX2dreCgncmVjb2lsX3N1cHByZXNzX3JlcmVuZGVyX2luX2NhbGxiYWNrJykgPyB7XG4gICAgbW9kZTogJ0xFR0FDWScsXG4gICAgZWFybHk6IHRydWUsXG4gICAgY29uY3VycmVudDogZmFsc2VcbiAgfSA6IHtcbiAgICBtb2RlOiAnTEVHQUNZJyxcbiAgICBlYXJseTogZmFsc2UsXG4gICAgY29uY3VycmVudDogZmFsc2VcbiAgfTtcbn0gLy8gVE9ETyBOZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhlcmUgaXMgYSBzdGFuZGFyZC9vcGVuLXNvdXJjZSBlcXVpdmFsZW50IHRvIHNlZSBpZiBob3QgbW9kdWxlIHJlcGxhY2VtZW50IGlzIGhhcHBlbmluZzpcblxuXG5mdW5jdGlvbiBpc0Zhc3RSZWZyZXNoRW5hYmxlZCgpIHtcbiAgLy8gQGZiLW9ubHk6IGNvbnN0IHtpc0FjY2VwdGluZ1VwZGF0ZX0gPSByZXF1aXJlKCdfX2RlYnVnJyk7XG4gIC8vIEBmYi1vbmx5OiByZXR1cm4gdHlwZW9mIGlzQWNjZXB0aW5nVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGlzQWNjZXB0aW5nVXBkYXRlKCk7XG4gIHJldHVybiBmYWxzZTsgLy8gQG9zcy1vbmx5XG59XG5cbnZhciBSZWNvaWxfUmVhY3RNb2RlID0ge1xuICBjcmVhdGVNdXRhYmxlU291cmNlLFxuICB1c2VNdXRhYmxlU291cmNlLFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZSxcbiAgcmVhY3RNb2RlLFxuICBpc0Zhc3RSZWZyZXNoRW5hYmxlZFxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5jbGFzcyBBYnN0cmFjdFJlY29pbFZhbHVlIHtcbiAgY29uc3RydWN0b3IobmV3S2V5KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5XCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmtleSA9IG5ld0tleTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiB0aGlzLmtleVxuICAgIH07XG4gIH1cblxufVxuXG5jbGFzcyBSZWNvaWxTdGF0ZSBleHRlbmRzIEFic3RyYWN0UmVjb2lsVmFsdWUge31cblxuY2xhc3MgUmVjb2lsVmFsdWVSZWFkT25seSBleHRlbmRzIEFic3RyYWN0UmVjb2lsVmFsdWUge31cblxuZnVuY3Rpb24gaXNSZWNvaWxWYWx1ZSh4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVjb2lsU3RhdGUgfHwgeCBpbnN0YW5jZW9mIFJlY29pbFZhbHVlUmVhZE9ubHk7XG59XG5cbnZhciBSZWNvaWxfUmVjb2lsVmFsdWUgPSB7XG4gIEFic3RyYWN0UmVjb2lsVmFsdWUsXG4gIFJlY29pbFN0YXRlLFxuICBSZWNvaWxWYWx1ZVJlYWRPbmx5LFxuICBpc1JlY29pbFZhbHVlXG59O1xuXG52YXIgUmVjb2lsX1JlY29pbFZhbHVlXzEgPSBSZWNvaWxfUmVjb2lsVmFsdWUuQWJzdHJhY3RSZWNvaWxWYWx1ZTtcbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVfMiA9IFJlY29pbF9SZWNvaWxWYWx1ZS5SZWNvaWxTdGF0ZTtcbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVfMyA9IFJlY29pbF9SZWNvaWxWYWx1ZS5SZWNvaWxWYWx1ZVJlYWRPbmx5O1xudmFyIFJlY29pbF9SZWNvaWxWYWx1ZV80ID0gUmVjb2lsX1JlY29pbFZhbHVlLmlzUmVjb2lsVmFsdWU7XG5cbnZhciBSZWNvaWxfUmVjb2lsVmFsdWUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBBYnN0cmFjdFJlY29pbFZhbHVlOiBSZWNvaWxfUmVjb2lsVmFsdWVfMSxcbiAgUmVjb2lsU3RhdGU6IFJlY29pbF9SZWNvaWxWYWx1ZV8yLFxuICBSZWNvaWxWYWx1ZVJlYWRPbmx5OiBSZWNvaWxfUmVjb2lsVmFsdWVfMyxcbiAgaXNSZWNvaWxWYWx1ZTogUmVjb2lsX1JlY29pbFZhbHVlXzRcbn0pO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBzcHJpbnRmKGZvcm1hdCwgLi4uYXJncykge1xuICBsZXQgaW5kZXggPSAwO1xuICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoLyVzL2csICgpID0+IFN0cmluZyhhcmdzW2luZGV4KytdKSk7XG59XG5cbnZhciBzcHJpbnRmXzEgPSBzcHJpbnRmO1xuXG5mdW5jdGlvbiBleHBlY3RhdGlvblZpb2xhdGlvbihmb3JtYXQsIC4uLmFyZ3MpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBzcHJpbnRmXzEuY2FsbChudWxsLCBmb3JtYXQsIC4uLmFyZ3MpO1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGVycm9yLm5hbWUgPSAnRXhwZWN0YXRpb24gVmlvbGF0aW9uJztcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgfVxufVxuXG52YXIgZXhwZWN0YXRpb25WaW9sYXRpb25fMSA9IGV4cGVjdGF0aW9uVmlvbGF0aW9uO1xuXG4vLyBAb3NzLW9ubHlcblxuXG52YXIgUmVjb2lsX2V4cGVjdGF0aW9uVmlvbGF0aW9uID0gZXhwZWN0YXRpb25WaW9sYXRpb25fMTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpdGVyYWJsZSB3aG9zZSBvdXRwdXQgaXMgZ2VuZXJhdGVkIGJ5IHBhc3NpbmcgdGhlIGlucHV0XG4gKiBpdGVyYWJsZSdzIHZhbHVlcyB0aHJvdWdoIHRoZSBtYXBwZXIgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gbWFwSXRlcmFibGUoaXRlcmFibGUsIGNhbGxiYWNrKSB7XG4gIC8vIFVzZSBnZW5lcmF0b3IgdG8gY3JlYXRlIGl0ZXJhYmxlL2l0ZXJhdG9yXG4gIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgIGxldCBpbmRleCA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhYmxlKSB7XG4gICAgICB5aWVsZCBjYWxsYmFjayh2YWx1ZSwgaW5kZXgrKyk7XG4gICAgfVxuICB9KCk7XG59XG5cbnZhciBSZWNvaWxfbWFwSXRlcmFibGUgPSBtYXBJdGVyYWJsZTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gcmVjb3ZlcmFibGVWaW9sYXRpb24obWVzc2FnZSwgX3Byb2plY3ROYW1lLCB7XG4gIGVycm9yXG59ID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgZXJyb3IpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciByZWNvdmVyYWJsZVZpb2xhdGlvbl8xID0gcmVjb3ZlcmFibGVWaW9sYXRpb247XG5cbi8vIEBvc3Mtb25seVxuXG5cbnZhciBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24gPSByZWNvdmVyYWJsZVZpb2xhdGlvbl8xO1xuXG5jb25zdCB7XG4gIGlzRmFzdFJlZnJlc2hFbmFibGVkOiBpc0Zhc3RSZWZyZXNoRW5hYmxlZCQxXG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgRGVmYXVsdFZhbHVlIHt9XG5cbmNvbnN0IERFRkFVTFRfVkFMVUUgPSBuZXcgRGVmYXVsdFZhbHVlKCk7XG4vLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuY29uc3Qgbm9kZXMgPSBuZXcgTWFwKCk7IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cbmNvbnN0IHJlY29pbFZhbHVlcyA9IG5ldyBNYXAoKTtcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuXG5mdW5jdGlvbiByZWNvaWxWYWx1ZXNGb3JLZXlzKGtleXMpIHtcbiAgcmV0dXJuIFJlY29pbF9tYXBJdGVyYWJsZShrZXlzLCBrZXkgPT4gUmVjb2lsX251bGx0aHJvd3MocmVjb2lsVmFsdWVzLmdldChrZXkpKSk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTm9kZShub2RlKSB7XG4gIGlmIChub2Rlcy5oYXMobm9kZS5rZXkpKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBEdXBsaWNhdGUgYXRvbSBrZXkgXCIke25vZGUua2V5fVwiLiBUaGlzIGlzIGEgRkFUQUwgRVJST1IgaW5cbiAgICAgIHByb2R1Y3Rpb24uIEJ1dCBpdCBpcyBzYWZlIHRvIGlnbm9yZSB0aGlzIHdhcm5pbmcgaWYgaXQgb2NjdXJyZWQgYmVjYXVzZSBvZlxuICAgICAgaG90IG1vZHVsZSByZXBsYWNlbWVudC5gO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgLy8gVE9ETyBGaWd1cmUgdGhpcyBvdXQgZm9yIG9wZW4tc291cmNlXG4gICAgICBpZiAoIWlzRmFzdFJlZnJlc2hFbmFibGVkJDEoKSkge1xuICAgICAgICBSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24obWVzc2FnZSwgJ3JlY29pbCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAZmItb25seTogcmVjb3ZlcmFibGVWaW9sYXRpb24obWVzc2FnZSwgJ3JlY29pbCcpO1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpOyAvLyBAb3NzLW9ubHlcbiAgICB9XG4gIH1cblxuICBub2Rlcy5zZXQobm9kZS5rZXksIG5vZGUpO1xuICBjb25zdCByZWNvaWxWYWx1ZSA9IG5vZGUuc2V0ID09IG51bGwgPyBuZXcgUmVjb2lsX1JlY29pbFZhbHVlJDEuUmVjb2lsVmFsdWVSZWFkT25seShub2RlLmtleSkgOiBuZXcgUmVjb2lsX1JlY29pbFZhbHVlJDEuUmVjb2lsU3RhdGUobm9kZS5rZXkpO1xuICByZWNvaWxWYWx1ZXMuc2V0KG5vZGUua2V5LCByZWNvaWxWYWx1ZSk7XG4gIHJldHVybiByZWNvaWxWYWx1ZTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tcmVkZWNsYXJlICovXG5cblxuY2xhc3MgTm9kZU1pc3NpbmdFcnJvciBleHRlbmRzIEVycm9yIHt9IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cblxuZnVuY3Rpb24gZ2V0Tm9kZShrZXkpIHtcbiAgY29uc3Qgbm9kZSA9IG5vZGVzLmdldChrZXkpO1xuXG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTm9kZU1pc3NpbmdFcnJvcihgTWlzc2luZyBkZWZpbml0aW9uIGZvciBSZWNvaWxWYWx1ZTogXCIke2tleX1cIlwiYCk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0gLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcblxuXG5mdW5jdGlvbiBnZXROb2RlTWF5YmUoa2V5KSB7XG4gIHJldHVybiBub2Rlcy5nZXQoa2V5KTtcbn1cblxuY29uc3QgY29uZmlnRGVsZXRpb25IYW5kbGVycyA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGUoa2V5KSB7XG4gIHZhciBfbm9kZSRzaG91bGREZWxldGVDb247XG5cbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgbm9kZSA9IG5vZGVzLmdldChrZXkpO1xuXG4gIGlmIChub2RlICE9PSBudWxsICYmIG5vZGUgIT09IHZvaWQgMCAmJiAoX25vZGUkc2hvdWxkRGVsZXRlQ29uID0gbm9kZS5zaG91bGREZWxldGVDb25maWdPblJlbGVhc2UpICE9PSBudWxsICYmIF9ub2RlJHNob3VsZERlbGV0ZUNvbiAhPT0gdm9pZCAwICYmIF9ub2RlJHNob3VsZERlbGV0ZUNvbi5jYWxsKG5vZGUpKSB7XG4gICAgdmFyIF9nZXRDb25maWdEZWxldGlvbkhhbjtcblxuICAgIG5vZGVzLmRlbGV0ZShrZXkpO1xuICAgIChfZ2V0Q29uZmlnRGVsZXRpb25IYW4gPSBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIoa2V5KSkgPT09IG51bGwgfHwgX2dldENvbmZpZ0RlbGV0aW9uSGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0Q29uZmlnRGVsZXRpb25IYW4oKTtcbiAgICBjb25maWdEZWxldGlvbkhhbmRsZXJzLmRlbGV0ZShrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlcihrZXksIGZuKSB7XG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChmbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uZmlnRGVsZXRpb25IYW5kbGVycy5kZWxldGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWdEZWxldGlvbkhhbmRsZXJzLnNldChrZXksIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIoa2V5KSB7XG4gIHJldHVybiBjb25maWdEZWxldGlvbkhhbmRsZXJzLmdldChrZXkpO1xufVxuXG52YXIgUmVjb2lsX05vZGUgPSB7XG4gIG5vZGVzLFxuICByZWNvaWxWYWx1ZXMsXG4gIHJlZ2lzdGVyTm9kZSxcbiAgZ2V0Tm9kZSxcbiAgZ2V0Tm9kZU1heWJlLFxuICBkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZSxcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyLFxuICBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIsXG4gIHJlY29pbFZhbHVlc0ZvcktleXMsXG4gIE5vZGVNaXNzaW5nRXJyb3IsXG4gIERlZmF1bHRWYWx1ZSxcbiAgREVGQVVMVF9WQUxVRVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gZW5xdWV1ZUV4ZWN1dGlvbihzLCBmKSB7XG4gIGYoKTtcbn1cblxudmFyIFJlY29pbF9RdWV1ZSA9IHtcbiAgZW5xdWV1ZUV4ZWN1dGlvblxufTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciBoYW10XzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuLyoqXG4gICAgQGZpbGVPdmVydmlldyBIYXNoIEFycmF5IE1hcHBlZCBUcmllLlxuXG4gICAgQ29kZSBiYXNlZCBvbjogaHR0cHM6Ly9naXRodWIuY29tL2V4Y2xpcHkvcGRhdGFcbiovXG5cblxudmFyIGhhbXQgPSB7fTsgLy8gZXhwb3J0XG5cbi8qIENvbmZpZ3VyYXRpb25cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBTSVpFID0gNTtcbnZhciBCVUNLRVRfU0laRSA9IE1hdGgucG93KDIsIFNJWkUpO1xudmFyIE1BU0sgPSBCVUNLRVRfU0laRSAtIDE7XG52YXIgTUFYX0lOREVYX05PREUgPSBCVUNLRVRfU0laRSAvIDI7XG52YXIgTUlOX0FSUkFZX05PREUgPSBCVUNLRVRfU0laRSAvIDQ7XG4vKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIG5vdGhpbmcgPSB7fTtcblxudmFyIGNvbnN0YW50ID0gZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufTtcbi8qKlxuICAgIEdldCAzMiBiaXQgaGFzaCBvZiBzdHJpbmcuXG5cbiAgICBCYXNlZCBvbjpcbiAgICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc2MTY0NjEvZ2VuZXJhdGUtYS1oYXNoLWZyb20tc3RyaW5nLWluLWphdmFzY3JpcHQtanF1ZXJ5XG4qL1xuXG5cbnZhciBoYXNoID0gaGFtdC5oYXNoID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN0cik7XG4gIGlmICh0eXBlID09PSAnbnVtYmVyJykgcmV0dXJuIHN0cjtcbiAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSBzdHIgKz0gJyc7XG4gIHZhciBoYXNoID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgYyB8IDA7XG4gIH1cblxuICByZXR1cm4gaGFzaDtcbn07XG4vKiBCaXQgT3BzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBIYW1taW5nIHdlaWdodC5cblxuICAgIFRha2VuIGZyb206IGh0dHA6Ly9qc3BlcmYuY29tL2hhbW1pbmctd2VpZ2h0XG4qL1xuXG5cbnZhciBwb3Bjb3VudCA9IGZ1bmN0aW9uIHBvcGNvdW50KHgpIHtcbiAgeCAtPSB4ID4+IDEgJiAweDU1NTU1NTU1O1xuICB4ID0gKHggJiAweDMzMzMzMzMzKSArICh4ID4+IDIgJiAweDMzMzMzMzMzKTtcbiAgeCA9IHggKyAoeCA+PiA0KSAmIDB4MGYwZjBmMGY7XG4gIHggKz0geCA+PiA4O1xuICB4ICs9IHggPj4gMTY7XG4gIHJldHVybiB4ICYgMHg3Zjtcbn07XG5cbnZhciBoYXNoRnJhZ21lbnQgPSBmdW5jdGlvbiBoYXNoRnJhZ21lbnQoc2hpZnQsIGgpIHtcbiAgcmV0dXJuIGggPj4+IHNoaWZ0ICYgTUFTSztcbn07XG5cbnZhciB0b0JpdG1hcCA9IGZ1bmN0aW9uIHRvQml0bWFwKHgpIHtcbiAgcmV0dXJuIDEgPDwgeDtcbn07XG5cbnZhciBmcm9tQml0bWFwID0gZnVuY3Rpb24gZnJvbUJpdG1hcChiaXRtYXAsIGJpdCkge1xuICByZXR1cm4gcG9wY291bnQoYml0bWFwICYgYml0IC0gMSk7XG59O1xuLyogQXJyYXkgT3BzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBTZXQgYSB2YWx1ZSBpbiBhbiBhcnJheS5cblxuICAgIEBwYXJhbSBtdXRhdGUgU2hvdWxkIHRoZSBpbnB1dCBhcnJheSBiZSBtdXRhdGVkP1xuICAgIEBwYXJhbSBhdCBJbmRleCB0byBjaGFuZ2UuXG4gICAgQHBhcmFtIHYgTmV3IHZhbHVlXG4gICAgQHBhcmFtIGFyciBBcnJheS5cbiovXG5cblxudmFyIGFycmF5VXBkYXRlID0gZnVuY3Rpb24gYXJyYXlVcGRhdGUobXV0YXRlLCBhdCwgdiwgYXJyKSB7XG4gIHZhciBvdXQgPSBhcnI7XG5cbiAgaWYgKCFtdXRhdGUpIHtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBvdXQgPSBuZXcgQXJyYXkobGVuKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIG91dFtpXSA9IGFycltpXTtcbiAgICB9XG4gIH1cblxuICBvdXRbYXRdID0gdjtcbiAgcmV0dXJuIG91dDtcbn07XG4vKipcbiAgICBSZW1vdmUgYSB2YWx1ZSBmcm9tIGFuIGFycmF5LlxuXG4gICAgQHBhcmFtIG11dGF0ZSBTaG91bGQgdGhlIGlucHV0IGFycmF5IGJlIG11dGF0ZWQ/XG4gICAgQHBhcmFtIGF0IEluZGV4IHRvIHJlbW92ZS5cbiAgICBAcGFyYW0gYXJyIEFycmF5LlxuKi9cblxuXG52YXIgYXJyYXlTcGxpY2VPdXQgPSBmdW5jdGlvbiBhcnJheVNwbGljZU91dChtdXRhdGUsIGF0LCBhcnIpIHtcbiAgdmFyIG5ld0xlbiA9IGFyci5sZW5ndGggLSAxO1xuICB2YXIgaSA9IDA7XG4gIHZhciBnID0gMDtcbiAgdmFyIG91dCA9IGFycjtcblxuICBpZiAobXV0YXRlKSB7XG4gICAgaSA9IGcgPSBhdDtcbiAgfSBlbHNlIHtcbiAgICBvdXQgPSBuZXcgQXJyYXkobmV3TGVuKTtcblxuICAgIHdoaWxlIChpIDwgYXQpIHtcbiAgICAgIG91dFtnKytdID0gYXJyW2krK107XG4gICAgfVxuICB9XG5cbiAgKytpO1xuXG4gIHdoaWxlIChpIDw9IG5ld0xlbikge1xuICAgIG91dFtnKytdID0gYXJyW2krK107XG4gIH1cblxuICBpZiAobXV0YXRlKSB7XG4gICAgb3V0Lmxlbmd0aCA9IG5ld0xlbjtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuLyoqXG4gICAgSW5zZXJ0IGEgdmFsdWUgaW50byBhbiBhcnJheS5cblxuICAgIEBwYXJhbSBtdXRhdGUgU2hvdWxkIHRoZSBpbnB1dCBhcnJheSBiZSBtdXRhdGVkP1xuICAgIEBwYXJhbSBhdCBJbmRleCB0byBpbnNlcnQgYXQuXG4gICAgQHBhcmFtIHYgVmFsdWUgdG8gaW5zZXJ0LFxuICAgIEBwYXJhbSBhcnIgQXJyYXkuXG4qL1xuXG5cbnZhciBhcnJheVNwbGljZUluID0gZnVuY3Rpb24gYXJyYXlTcGxpY2VJbihtdXRhdGUsIGF0LCB2LCBhcnIpIHtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgaWYgKG11dGF0ZSkge1xuICAgIHZhciBfaSA9IGxlbjtcblxuICAgIHdoaWxlIChfaSA+PSBhdCkge1xuICAgICAgYXJyW19pLS1dID0gYXJyW19pXTtcbiAgICB9XG5cbiAgICBhcnJbYXRdID0gdjtcbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgdmFyIGkgPSAwLFxuICAgICAgZyA9IDA7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXkobGVuICsgMSk7XG5cbiAgd2hpbGUgKGkgPCBhdCkge1xuICAgIG91dFtnKytdID0gYXJyW2krK107XG4gIH1cblxuICBvdXRbYXRdID0gdjtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIG91dFsrK2ddID0gYXJyW2krK107XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcbi8qIE5vZGUgU3RydWN0dXJlc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG52YXIgTEVBRiA9IDE7XG52YXIgQ09MTElTSU9OID0gMjtcbnZhciBJTkRFWCA9IDM7XG52YXIgQVJSQVkgPSA0O1xuLyoqXG4gICAgRW1wdHkgbm9kZS5cbiovXG5cbnZhciBlbXB0eSA9IHtcbiAgX19oYW10X2lzRW1wdHk6IHRydWVcbn07XG5cbnZhciBpc0VtcHR5Tm9kZSA9IGZ1bmN0aW9uIGlzRW1wdHlOb2RlKHgpIHtcbiAgcmV0dXJuIHggPT09IGVtcHR5IHx8IHggJiYgeC5fX2hhbXRfaXNFbXB0eTtcbn07XG4vKipcbiAgICBMZWFmIGhvbGRpbmcgYSB2YWx1ZS5cblxuICAgIEBtZW1iZXIgZWRpdCBFZGl0IG9mIHRoZSBub2RlLlxuICAgIEBtZW1iZXIgaGFzaCBIYXNoIG9mIGtleS5cbiAgICBAbWVtYmVyIGtleSBLZXkuXG4gICAgQG1lbWJlciB2YWx1ZSBWYWx1ZSBzdG9yZWQuXG4qL1xuXG5cbnZhciBMZWFmID0gZnVuY3Rpb24gTGVhZihlZGl0LCBoYXNoLCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogTEVBRixcbiAgICBlZGl0OiBlZGl0LFxuICAgIGhhc2g6IGhhc2gsXG4gICAga2V5OiBrZXksXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIF9tb2RpZnk6IExlYWZfX21vZGlmeVxuICB9O1xufTtcbi8qKlxuICAgIExlYWYgaG9sZGluZyBtdWx0aXBsZSB2YWx1ZXMgd2l0aCB0aGUgc2FtZSBoYXNoIGJ1dCBkaWZmZXJlbnQga2V5cy5cblxuICAgIEBtZW1iZXIgZWRpdCBFZGl0IG9mIHRoZSBub2RlLlxuICAgIEBtZW1iZXIgaGFzaCBIYXNoIG9mIGtleS5cbiAgICBAbWVtYmVyIGNoaWxkcmVuIEFycmF5IG9mIGNvbGxpc2lvbiBjaGlsZHJlbiBub2RlLlxuKi9cblxuXG52YXIgQ29sbGlzaW9uID0gZnVuY3Rpb24gQ29sbGlzaW9uKGVkaXQsIGhhc2gsIGNoaWxkcmVuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQ09MTElTSU9OLFxuICAgIGVkaXQ6IGVkaXQsXG4gICAgaGFzaDogaGFzaCxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgX21vZGlmeTogQ29sbGlzaW9uX19tb2RpZnlcbiAgfTtcbn07XG4vKipcbiAgICBJbnRlcm5hbCBub2RlIHdpdGggYSBzcGFyc2Ugc2V0IG9mIGNoaWxkcmVuLlxuXG4gICAgVXNlcyBhIGJpdG1hcCBhbmQgYXJyYXkgdG8gcGFjayBjaGlsZHJlbi5cblxuICBAbWVtYmVyIGVkaXQgRWRpdCBvZiB0aGUgbm9kZS5cbiAgICBAbWVtYmVyIG1hc2sgQml0bWFwIHRoYXQgZW5jb2RlIHRoZSBwb3NpdGlvbnMgb2YgY2hpbGRyZW4gaW4gdGhlIGFycmF5LlxuICAgIEBtZW1iZXIgY2hpbGRyZW4gQXJyYXkgb2YgY2hpbGQgbm9kZXMuXG4qL1xuXG5cbnZhciBJbmRleGVkTm9kZSA9IGZ1bmN0aW9uIEluZGV4ZWROb2RlKGVkaXQsIG1hc2ssIGNoaWxkcmVuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogSU5ERVgsXG4gICAgZWRpdDogZWRpdCxcbiAgICBtYXNrOiBtYXNrLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBfbW9kaWZ5OiBJbmRleGVkTm9kZV9fbW9kaWZ5XG4gIH07XG59O1xuLyoqXG4gICAgSW50ZXJuYWwgbm9kZSB3aXRoIG1hbnkgY2hpbGRyZW4uXG5cbiAgICBAbWVtYmVyIGVkaXQgRWRpdCBvZiB0aGUgbm9kZS5cbiAgICBAbWVtYmVyIHNpemUgTnVtYmVyIG9mIGNoaWxkcmVuLlxuICAgIEBtZW1iZXIgY2hpbGRyZW4gQXJyYXkgb2YgY2hpbGQgbm9kZXMuXG4qL1xuXG5cbnZhciBBcnJheU5vZGUgPSBmdW5jdGlvbiBBcnJheU5vZGUoZWRpdCwgc2l6ZSwgY2hpbGRyZW4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBUlJBWSxcbiAgICBlZGl0OiBlZGl0LFxuICAgIHNpemU6IHNpemUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIF9tb2RpZnk6IEFycmF5Tm9kZV9fbW9kaWZ5XG4gIH07XG59O1xuLyoqXG4gICAgSXMgYG5vZGVgIGEgbGVhZiBub2RlP1xuKi9cblxuXG52YXIgaXNMZWFmID0gZnVuY3Rpb24gaXNMZWFmKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgPT09IGVtcHR5IHx8IG5vZGUudHlwZSA9PT0gTEVBRiB8fCBub2RlLnR5cGUgPT09IENPTExJU0lPTjtcbn07XG4vKiBJbnRlcm5hbCBub2RlIG9wZXJhdGlvbnMuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBFeHBhbmQgYW4gaW5kZXhlZCBub2RlIGludG8gYW4gYXJyYXkgbm9kZS5cblxuICBAcGFyYW0gZWRpdCBDdXJyZW50IGVkaXQuXG4gICAgQHBhcmFtIGZyYWcgSW5kZXggb2YgYWRkZWQgY2hpbGQuXG4gICAgQHBhcmFtIGNoaWxkIEFkZGVkIGNoaWxkLlxuICAgIEBwYXJhbSBtYXNrIEluZGV4IG5vZGUgbWFzayBiZWZvcmUgY2hpbGQgYWRkZWQuXG4gICAgQHBhcmFtIHN1Yk5vZGVzIEluZGV4IG5vZGUgY2hpbGRyZW4gYmVmb3JlIGNoaWxkIGFkZGVkLlxuKi9cblxuXG52YXIgZXhwYW5kID0gZnVuY3Rpb24gZXhwYW5kKGVkaXQsIGZyYWcsIGNoaWxkLCBiaXRtYXAsIHN1Yk5vZGVzKSB7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGJpdCA9IGJpdG1hcDtcbiAgdmFyIGNvdW50ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgYml0OyArK2kpIHtcbiAgICBpZiAoYml0ICYgMSkgYXJyW2ldID0gc3ViTm9kZXNbY291bnQrK107XG4gICAgYml0ID4+Pj0gMTtcbiAgfVxuXG4gIGFycltmcmFnXSA9IGNoaWxkO1xuICByZXR1cm4gQXJyYXlOb2RlKGVkaXQsIGNvdW50ICsgMSwgYXJyKTtcbn07XG4vKipcbiAgICBDb2xsYXBzZSBhbiBhcnJheSBub2RlIGludG8gYSBpbmRleGVkIG5vZGUuXG5cbiAgQHBhcmFtIGVkaXQgQ3VycmVudCBlZGl0LlxuICAgIEBwYXJhbSBjb3VudCBOdW1iZXIgb2YgZWxlbWVudHMgaW4gbmV3IGFycmF5LlxuICAgIEBwYXJhbSByZW1vdmVkIEluZGV4IG9mIHJlbW92ZWQgZWxlbWVudC5cbiAgICBAcGFyYW0gZWxlbWVudHMgQXJyYXkgbm9kZSBjaGlsZHJlbiBiZWZvcmUgcmVtb3ZlLlxuKi9cblxuXG52YXIgcGFjayA9IGZ1bmN0aW9uIHBhY2soZWRpdCwgY291bnQsIHJlbW92ZWQsIGVsZW1lbnRzKSB7XG4gIHZhciBjaGlsZHJlbiA9IG5ldyBBcnJheShjb3VudCAtIDEpO1xuICB2YXIgZyA9IDA7XG4gIHZhciBiaXRtYXAgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChpICE9PSByZW1vdmVkKSB7XG4gICAgICB2YXIgZWxlbSA9IGVsZW1lbnRzW2ldO1xuXG4gICAgICBpZiAoZWxlbSAmJiAhaXNFbXB0eU5vZGUoZWxlbSkpIHtcbiAgICAgICAgY2hpbGRyZW5bZysrXSA9IGVsZW07XG4gICAgICAgIGJpdG1hcCB8PSAxIDw8IGk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEluZGV4ZWROb2RlKGVkaXQsIGJpdG1hcCwgY2hpbGRyZW4pO1xufTtcbi8qKlxuICAgIE1lcmdlIHR3byBsZWFmIG5vZGVzLlxuXG4gICAgQHBhcmFtIHNoaWZ0IEN1cnJlbnQgc2hpZnQuXG4gICAgQHBhcmFtIGgxIE5vZGUgMSBoYXNoLlxuICAgIEBwYXJhbSBuMSBOb2RlIDEuXG4gICAgQHBhcmFtIGgyIE5vZGUgMiBoYXNoLlxuICAgIEBwYXJhbSBuMiBOb2RlIDIuXG4qL1xuXG5cbnZhciBtZXJnZUxlYXZlcyA9IGZ1bmN0aW9uIG1lcmdlTGVhdmVzKGVkaXQsIHNoaWZ0LCBoMSwgbjEsIGgyLCBuMikge1xuICBpZiAoaDEgPT09IGgyKSByZXR1cm4gQ29sbGlzaW9uKGVkaXQsIGgxLCBbbjIsIG4xXSk7XG4gIHZhciBzdWJIMSA9IGhhc2hGcmFnbWVudChzaGlmdCwgaDEpO1xuICB2YXIgc3ViSDIgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGgyKTtcbiAgcmV0dXJuIEluZGV4ZWROb2RlKGVkaXQsIHRvQml0bWFwKHN1YkgxKSB8IHRvQml0bWFwKHN1YkgyKSwgc3ViSDEgPT09IHN1YkgyID8gW21lcmdlTGVhdmVzKGVkaXQsIHNoaWZ0ICsgU0laRSwgaDEsIG4xLCBoMiwgbjIpXSA6IHN1YkgxIDwgc3ViSDIgPyBbbjEsIG4yXSA6IFtuMiwgbjFdKTtcbn07XG4vKipcbiAgICBVcGRhdGUgYW4gZW50cnkgaW4gYSBjb2xsaXNpb24gbGlzdC5cblxuICAgIEBwYXJhbSBtdXRhdGUgU2hvdWxkIG11dGF0aW9uIGJlIHVzZWQ/XG4gICAgQHBhcmFtIGVkaXQgQ3VycmVudCBlZGl0LlxuICAgIEBwYXJhbSBrZXlFcSBLZXkgY29tcGFyZSBmdW5jdGlvbi5cbiAgICBAcGFyYW0gaGFzaCBIYXNoIG9mIGNvbGxpc2lvbi5cbiAgICBAcGFyYW0gbGlzdCBDb2xsaXNpb24gbGlzdC5cbiAgICBAcGFyYW0gZiBVcGRhdGUgZnVuY3Rpb24uXG4gICAgQHBhcmFtIGsgS2V5IHRvIHVwZGF0ZS5cbiAgICBAcGFyYW0gc2l6ZSBTaXplIHJlZi5cbiovXG5cblxudmFyIHVwZGF0ZUNvbGxpc2lvbkxpc3QgPSBmdW5jdGlvbiB1cGRhdGVDb2xsaXNpb25MaXN0KG11dGF0ZSwgZWRpdCwga2V5RXEsIGgsIGxpc3QsIGYsIGssIHNpemUpIHtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgY2hpbGQgPSBsaXN0W2ldO1xuXG4gICAgaWYgKGtleUVxKGssIGNoaWxkLmtleSkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGNoaWxkLnZhbHVlO1xuXG4gICAgICB2YXIgX25ld1ZhbHVlID0gZih2YWx1ZSk7XG5cbiAgICAgIGlmIChfbmV3VmFsdWUgPT09IHZhbHVlKSByZXR1cm4gbGlzdDtcblxuICAgICAgaWYgKF9uZXdWYWx1ZSA9PT0gbm90aGluZykge1xuICAgICAgICAtLXNpemUudmFsdWU7XG4gICAgICAgIHJldHVybiBhcnJheVNwbGljZU91dChtdXRhdGUsIGksIGxpc3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyYXlVcGRhdGUobXV0YXRlLCBpLCBMZWFmKGVkaXQsIGgsIGssIF9uZXdWYWx1ZSksIGxpc3QpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdWYWx1ZSA9IGYoKTtcbiAgaWYgKG5ld1ZhbHVlID09PSBub3RoaW5nKSByZXR1cm4gbGlzdDtcbiAgKytzaXplLnZhbHVlO1xuICByZXR1cm4gYXJyYXlVcGRhdGUobXV0YXRlLCBsZW4sIExlYWYoZWRpdCwgaCwgaywgbmV3VmFsdWUpLCBsaXN0KTtcbn07XG5cbnZhciBjYW5FZGl0Tm9kZSA9IGZ1bmN0aW9uIGNhbkVkaXROb2RlKGVkaXQsIG5vZGUpIHtcbiAgcmV0dXJuIGVkaXQgPT09IG5vZGUuZWRpdDtcbn07XG4vKiBFZGl0aW5nXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbnZhciBMZWFmX19tb2RpZnkgPSBmdW5jdGlvbiBMZWFmX19tb2RpZnkoZWRpdCwga2V5RXEsIHNoaWZ0LCBmLCBoLCBrLCBzaXplKSB7XG4gIGlmIChrZXlFcShrLCB0aGlzLmtleSkpIHtcbiAgICB2YXIgX3YgPSBmKHRoaXMudmFsdWUpO1xuXG4gICAgaWYgKF92ID09PSB0aGlzLnZhbHVlKSByZXR1cm4gdGhpcztlbHNlIGlmIChfdiA9PT0gbm90aGluZykge1xuICAgICAgLS1zaXplLnZhbHVlO1xuICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH1cblxuICAgIGlmIChjYW5FZGl0Tm9kZShlZGl0LCB0aGlzKSkge1xuICAgICAgdGhpcy52YWx1ZSA9IF92O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIExlYWYoZWRpdCwgaCwgaywgX3YpO1xuICB9XG5cbiAgdmFyIHYgPSBmKCk7XG4gIGlmICh2ID09PSBub3RoaW5nKSByZXR1cm4gdGhpcztcbiAgKytzaXplLnZhbHVlO1xuICByZXR1cm4gbWVyZ2VMZWF2ZXMoZWRpdCwgc2hpZnQsIHRoaXMuaGFzaCwgdGhpcywgaCwgTGVhZihlZGl0LCBoLCBrLCB2KSk7XG59O1xuXG52YXIgQ29sbGlzaW9uX19tb2RpZnkgPSBmdW5jdGlvbiBDb2xsaXNpb25fX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQsIGYsIGgsIGssIHNpemUpIHtcbiAgaWYgKGggPT09IHRoaXMuaGFzaCkge1xuICAgIHZhciBjYW5FZGl0ID0gY2FuRWRpdE5vZGUoZWRpdCwgdGhpcyk7XG4gICAgdmFyIGxpc3QgPSB1cGRhdGVDb2xsaXNpb25MaXN0KGNhbkVkaXQsIGVkaXQsIGtleUVxLCB0aGlzLmhhc2gsIHRoaXMuY2hpbGRyZW4sIGYsIGssIHNpemUpO1xuICAgIGlmIChsaXN0ID09PSB0aGlzLmNoaWxkcmVuKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gbGlzdC5sZW5ndGggPiAxID8gQ29sbGlzaW9uKGVkaXQsIHRoaXMuaGFzaCwgbGlzdCkgOiBsaXN0WzBdOyAvLyBjb2xsYXBzZSBzaW5nbGUgZWxlbWVudCBjb2xsaXNpb24gbGlzdFxuICB9XG5cbiAgdmFyIHYgPSBmKCk7XG4gIGlmICh2ID09PSBub3RoaW5nKSByZXR1cm4gdGhpcztcbiAgKytzaXplLnZhbHVlO1xuICByZXR1cm4gbWVyZ2VMZWF2ZXMoZWRpdCwgc2hpZnQsIHRoaXMuaGFzaCwgdGhpcywgaCwgTGVhZihlZGl0LCBoLCBrLCB2KSk7XG59O1xuXG52YXIgSW5kZXhlZE5vZGVfX21vZGlmeSA9IGZ1bmN0aW9uIEluZGV4ZWROb2RlX19tb2RpZnkoZWRpdCwga2V5RXEsIHNoaWZ0LCBmLCBoLCBrLCBzaXplKSB7XG4gIHZhciBtYXNrID0gdGhpcy5tYXNrO1xuICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICB2YXIgZnJhZyA9IGhhc2hGcmFnbWVudChzaGlmdCwgaCk7XG4gIHZhciBiaXQgPSB0b0JpdG1hcChmcmFnKTtcbiAgdmFyIGluZHggPSBmcm9tQml0bWFwKG1hc2ssIGJpdCk7XG4gIHZhciBleGlzdHMgPSBtYXNrICYgYml0O1xuICB2YXIgY3VycmVudCA9IGV4aXN0cyA/IGNoaWxkcmVuW2luZHhdIDogZW1wdHk7XG5cbiAgdmFyIGNoaWxkID0gY3VycmVudC5fbW9kaWZ5KGVkaXQsIGtleUVxLCBzaGlmdCArIFNJWkUsIGYsIGgsIGssIHNpemUpO1xuXG4gIGlmIChjdXJyZW50ID09PSBjaGlsZCkgcmV0dXJuIHRoaXM7XG4gIHZhciBjYW5FZGl0ID0gY2FuRWRpdE5vZGUoZWRpdCwgdGhpcyk7XG4gIHZhciBiaXRtYXAgPSBtYXNrO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSB2b2lkIDA7XG5cbiAgaWYgKGV4aXN0cyAmJiBpc0VtcHR5Tm9kZShjaGlsZCkpIHtcbiAgICAvLyByZW1vdmVcbiAgICBiaXRtYXAgJj0gfmJpdDtcbiAgICBpZiAoIWJpdG1hcCkgcmV0dXJuIGVtcHR5O1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPD0gMiAmJiBpc0xlYWYoY2hpbGRyZW5baW5keCBeIDFdKSkgcmV0dXJuIGNoaWxkcmVuW2luZHggXiAxXTsgLy8gY29sbGFwc2VcblxuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlTcGxpY2VPdXQoY2FuRWRpdCwgaW5keCwgY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKCFleGlzdHMgJiYgIWlzRW1wdHlOb2RlKGNoaWxkKSkge1xuICAgIC8vIGFkZFxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPj0gTUFYX0lOREVYX05PREUpIHJldHVybiBleHBhbmQoZWRpdCwgZnJhZywgY2hpbGQsIG1hc2ssIGNoaWxkcmVuKTtcbiAgICBiaXRtYXAgfD0gYml0O1xuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlTcGxpY2VJbihjYW5FZGl0LCBpbmR4LCBjaGlsZCwgY2hpbGRyZW4pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1vZGlmeVxuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlVcGRhdGUoY2FuRWRpdCwgaW5keCwgY2hpbGQsIGNoaWxkcmVuKTtcbiAgfVxuXG4gIGlmIChjYW5FZGl0KSB7XG4gICAgdGhpcy5tYXNrID0gYml0bWFwO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldHVybiBJbmRleGVkTm9kZShlZGl0LCBiaXRtYXAsIG5ld0NoaWxkcmVuKTtcbn07XG5cbnZhciBBcnJheU5vZGVfX21vZGlmeSA9IGZ1bmN0aW9uIEFycmF5Tm9kZV9fbW9kaWZ5KGVkaXQsIGtleUVxLCBzaGlmdCwgZiwgaCwgaywgc2l6ZSkge1xuICB2YXIgY291bnQgPSB0aGlzLnNpemU7XG4gIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gIHZhciBmcmFnID0gaGFzaEZyYWdtZW50KHNoaWZ0LCBoKTtcbiAgdmFyIGNoaWxkID0gY2hpbGRyZW5bZnJhZ107XG5cbiAgdmFyIG5ld0NoaWxkID0gKGNoaWxkIHx8IGVtcHR5KS5fbW9kaWZ5KGVkaXQsIGtleUVxLCBzaGlmdCArIFNJWkUsIGYsIGgsIGssIHNpemUpO1xuXG4gIGlmIChjaGlsZCA9PT0gbmV3Q2hpbGQpIHJldHVybiB0aGlzO1xuICB2YXIgY2FuRWRpdCA9IGNhbkVkaXROb2RlKGVkaXQsIHRoaXMpO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSB2b2lkIDA7XG5cbiAgaWYgKGlzRW1wdHlOb2RlKGNoaWxkKSAmJiAhaXNFbXB0eU5vZGUobmV3Q2hpbGQpKSB7XG4gICAgLy8gYWRkXG4gICAgKytjb3VudDtcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5VXBkYXRlKGNhbkVkaXQsIGZyYWcsIG5ld0NoaWxkLCBjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAoIWlzRW1wdHlOb2RlKGNoaWxkKSAmJiBpc0VtcHR5Tm9kZShuZXdDaGlsZCkpIHtcbiAgICAvLyByZW1vdmVcbiAgICAtLWNvdW50O1xuICAgIGlmIChjb3VudCA8PSBNSU5fQVJSQVlfTk9ERSkgcmV0dXJuIHBhY2soZWRpdCwgY291bnQsIGZyYWcsIGNoaWxkcmVuKTtcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5VXBkYXRlKGNhbkVkaXQsIGZyYWcsIGVtcHR5LCBjaGlsZHJlbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gbW9kaWZ5XG4gICAgbmV3Q2hpbGRyZW4gPSBhcnJheVVwZGF0ZShjYW5FZGl0LCBmcmFnLCBuZXdDaGlsZCwgY2hpbGRyZW4pO1xuICB9XG5cbiAgaWYgKGNhbkVkaXQpIHtcbiAgICB0aGlzLnNpemUgPSBjb3VudDtcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gQXJyYXlOb2RlKGVkaXQsIGNvdW50LCBuZXdDaGlsZHJlbik7XG59O1xuXG5lbXB0eS5fbW9kaWZ5ID0gZnVuY3Rpb24gKGVkaXQsIGtleUVxLCBzaGlmdCwgZiwgaCwgaywgc2l6ZSkge1xuICB2YXIgdiA9IGYoKTtcbiAgaWYgKHYgPT09IG5vdGhpbmcpIHJldHVybiBlbXB0eTtcbiAgKytzaXplLnZhbHVlO1xuICByZXR1cm4gTGVhZihlZGl0LCBoLCBrLCB2KTtcbn07XG4vKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5mdW5jdGlvbiBNYXAoZWRpdGFibGUsIGVkaXQsIGNvbmZpZywgcm9vdCwgc2l6ZSkge1xuICB0aGlzLl9lZGl0YWJsZSA9IGVkaXRhYmxlO1xuICB0aGlzLl9lZGl0ID0gZWRpdDtcbiAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICB0aGlzLl9yb290ID0gcm9vdDtcbiAgdGhpcy5fc2l6ZSA9IHNpemU7XG59XG5cbk1hcC5wcm90b3R5cGUuc2V0VHJlZSA9IGZ1bmN0aW9uIChuZXdSb290LCBuZXdTaXplKSB7XG4gIGlmICh0aGlzLl9lZGl0YWJsZSkge1xuICAgIHRoaXMuX3Jvb3QgPSBuZXdSb290O1xuICAgIHRoaXMuX3NpemUgPSBuZXdTaXplO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIG5ld1Jvb3QgPT09IHRoaXMuX3Jvb3QgPyB0aGlzIDogbmV3IE1hcCh0aGlzLl9lZGl0YWJsZSwgdGhpcy5fZWRpdCwgdGhpcy5fY29uZmlnLCBuZXdSb290LCBuZXdTaXplKTtcbn07XG4vKiBRdWVyaWVzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBMb29rdXAgdGhlIHZhbHVlIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBhIGN1c3RvbSBgaGFzaGAuXG5cbiAgICBSZXR1cm5zIHRoZSB2YWx1ZSBvciBgYWx0YCBpZiBub25lLlxuKi9cblxuXG52YXIgdHJ5R2V0SGFzaCA9IGhhbXQudHJ5R2V0SGFzaCA9IGZ1bmN0aW9uIChhbHQsIGhhc2gsIGtleSwgbWFwKSB7XG4gIHZhciBub2RlID0gbWFwLl9yb290O1xuICB2YXIgc2hpZnQgPSAwO1xuICB2YXIga2V5RXEgPSBtYXAuX2NvbmZpZy5rZXlFcTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIExFQUY6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4ga2V5RXEoa2V5LCBub2RlLmtleSkgPyBub2RlLnZhbHVlIDogYWx0O1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ09MTElTSU9OOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGhhc2ggPT09IG5vZGUuaGFzaCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICBpZiAoa2V5RXEoa2V5LCBjaGlsZC5rZXkpKSByZXR1cm4gY2hpbGQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFsdDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIElOREVYOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGZyYWcgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGhhc2gpO1xuICAgICAgICAgIHZhciBiaXQgPSB0b0JpdG1hcChmcmFnKTtcblxuICAgICAgICAgIGlmIChub2RlLm1hc2sgJiBiaXQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW2Zyb21CaXRtYXAobm9kZS5tYXNrLCBiaXQpXTtcbiAgICAgICAgICAgIHNoaWZ0ICs9IFNJWkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYWx0O1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQVJSQVk6XG4gICAgICAgIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlbltoYXNoRnJhZ21lbnQoc2hpZnQsIGhhc2gpXTtcblxuICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBzaGlmdCArPSBTSVpFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFsdDtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYWx0O1xuICAgIH1cbiAgfVxufTtcblxuTWFwLnByb3RvdHlwZS50cnlHZXRIYXNoID0gZnVuY3Rpb24gKGFsdCwgaGFzaCwga2V5KSB7XG4gIHJldHVybiB0cnlHZXRIYXNoKGFsdCwgaGFzaCwga2V5LCB0aGlzKTtcbn07XG4vKipcbiAgICBMb29rdXAgdGhlIHZhbHVlIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxuXG4gICAgQHNlZSBgdHJ5R2V0SGFzaGBcbiovXG5cblxudmFyIHRyeUdldCA9IGhhbXQudHJ5R2V0ID0gZnVuY3Rpb24gKGFsdCwga2V5LCBtYXApIHtcbiAgcmV0dXJuIHRyeUdldEhhc2goYWx0LCBtYXAuX2NvbmZpZy5oYXNoKGtleSksIGtleSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUudHJ5R2V0ID0gZnVuY3Rpb24gKGFsdCwga2V5KSB7XG4gIHJldHVybiB0cnlHZXQoYWx0LCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIExvb2t1cCB0aGUgdmFsdWUgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGEgY3VzdG9tIGBoYXNoYC5cblxuICAgIFJldHVybnMgdGhlIHZhbHVlIG9yIGB1bmRlZmluZWRgIGlmIG5vbmUuXG4qL1xuXG5cbnZhciBnZXRIYXNoID0gaGFtdC5nZXRIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgbWFwKSB7XG4gIHJldHVybiB0cnlHZXRIYXNoKHVuZGVmaW5lZCwgaGFzaCwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5nZXRIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSkge1xuICByZXR1cm4gZ2V0SGFzaChoYXNoLCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIExvb2t1cCB0aGUgdmFsdWUgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGludGVybmFsIGhhc2ggZnVuY3Rpb24uXG5cbiAgICBAc2VlIGBnZXRgXG4qL1xuXG5cbnZhciBnZXQgPSBoYW10LmdldCA9IGZ1bmN0aW9uIChrZXksIG1hcCkge1xuICByZXR1cm4gdHJ5R2V0SGFzaCh1bmRlZmluZWQsIG1hcC5fY29uZmlnLmhhc2goa2V5KSwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5LCBhbHQpIHtcbiAgcmV0dXJuIHRyeUdldChhbHQsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgRG9lcyBhbiBlbnRyeSBleGlzdCBmb3IgYGtleWAgaW4gYG1hcGA/IFVzZXMgY3VzdG9tIGBoYXNoYC5cbiovXG5cblxudmFyIGhhc0hhc2ggPSBoYW10LmhhcyA9IGZ1bmN0aW9uIChoYXNoLCBrZXksIG1hcCkge1xuICByZXR1cm4gdHJ5R2V0SGFzaChub3RoaW5nLCBoYXNoLCBrZXksIG1hcCkgIT09IG5vdGhpbmc7XG59O1xuXG5NYXAucHJvdG90eXBlLmhhc0hhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5KSB7XG4gIHJldHVybiBoYXNIYXNoKGhhc2gsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgRG9lcyBhbiBlbnRyeSBleGlzdCBmb3IgYGtleWAgaW4gYG1hcGA/IFVzZXMgaW50ZXJuYWwgaGFzaCBmdW5jdGlvbi5cbiovXG5cblxudmFyIGhhcyA9IGhhbXQuaGFzID0gZnVuY3Rpb24gKGtleSwgbWFwKSB7XG4gIHJldHVybiBoYXNIYXNoKG1hcC5fY29uZmlnLmhhc2goa2V5KSwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBoYXMoa2V5LCB0aGlzKTtcbn07XG5cbnZhciBkZWZLZXlDb21wYXJlID0gZnVuY3Rpb24gZGVmS2V5Q29tcGFyZSh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5O1xufTtcbi8qKlxuICAgIENyZWF0ZSBhbiBlbXB0eSBtYXAuXG5cbiAgICBAcGFyYW0gY29uZmlnIENvbmZpZ3VyYXRpb24uXG4qL1xuXG5cbmhhbXQubWFrZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBNYXAoMCwgMCwge1xuICAgIGtleUVxOiBjb25maWcgJiYgY29uZmlnLmtleUVxIHx8IGRlZktleUNvbXBhcmUsXG4gICAgaGFzaDogY29uZmlnICYmIGNvbmZpZy5oYXNoIHx8IGhhc2hcbiAgfSwgZW1wdHksIDApO1xufTtcbi8qKlxuICAgIEVtcHR5IG1hcC5cbiovXG5cblxuaGFtdC5lbXB0eSA9IGhhbXQubWFrZSgpO1xuLyoqXG4gICAgRG9lcyBgbWFwYCBjb250YWluIGFueSBlbGVtZW50cz9cbiovXG5cbnZhciBpc0VtcHR5ID0gaGFtdC5pc0VtcHR5ID0gZnVuY3Rpb24gKG1hcCkge1xuICByZXR1cm4gbWFwICYmICEhaXNFbXB0eU5vZGUobWFwLl9yb290KTtcbn07XG5cbk1hcC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRW1wdHkodGhpcyk7XG59O1xuLyogVXBkYXRlc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgQWx0ZXIgdGhlIHZhbHVlIHN0b3JlZCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgZnVuY3Rpb24gYGZgIHVzaW5nXG4gICAgY3VzdG9tIGhhc2guXG5cbiAgICBgZmAgaXMgaW52b2tlZCB3aXRoIHRoZSBjdXJyZW50IHZhbHVlIGZvciBga2AgaWYgaXQgZXhpc3RzLFxuICAgIG9yIG5vIGFyZ3VtZW50cyBpZiBubyBzdWNoIHZhbHVlIGV4aXN0cy4gYG1vZGlmeWAgd2lsbCBhbHdheXMgZWl0aGVyXG4gICAgdXBkYXRlIG9yIGluc2VydCBhIHZhbHVlIGludG8gdGhlIG1hcC5cblxuICAgIFJldHVybnMgYSBtYXAgd2l0aCB0aGUgbW9kaWZpZWQgdmFsdWUuIERvZXMgbm90IGFsdGVyIGBtYXBgLlxuKi9cblxuXG52YXIgbW9kaWZ5SGFzaCA9IGhhbXQubW9kaWZ5SGFzaCA9IGZ1bmN0aW9uIChmLCBoYXNoLCBrZXksIG1hcCkge1xuICB2YXIgc2l6ZSA9IHtcbiAgICB2YWx1ZTogbWFwLl9zaXplXG4gIH07XG5cbiAgdmFyIG5ld1Jvb3QgPSBtYXAuX3Jvb3QuX21vZGlmeShtYXAuX2VkaXRhYmxlID8gbWFwLl9lZGl0IDogTmFOLCBtYXAuX2NvbmZpZy5rZXlFcSwgMCwgZiwgaGFzaCwga2V5LCBzaXplKTtcblxuICByZXR1cm4gbWFwLnNldFRyZWUobmV3Um9vdCwgc2l6ZS52YWx1ZSk7XG59O1xuXG5NYXAucHJvdG90eXBlLm1vZGlmeUhhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5LCBmKSB7XG4gIHJldHVybiBtb2RpZnlIYXNoKGYsIGhhc2gsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgQWx0ZXIgdGhlIHZhbHVlIHN0b3JlZCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgZnVuY3Rpb24gYGZgIHVzaW5nXG4gICAgaW50ZXJuYWwgaGFzaCBmdW5jdGlvbi5cblxuICAgIEBzZWUgYG1vZGlmeUhhc2hgXG4qL1xuXG5cbnZhciBtb2RpZnkgPSBoYW10Lm1vZGlmeSA9IGZ1bmN0aW9uIChmLCBrZXksIG1hcCkge1xuICByZXR1cm4gbW9kaWZ5SGFzaChmLCBtYXAuX2NvbmZpZy5oYXNoKGtleSksIGtleSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUubW9kaWZ5ID0gZnVuY3Rpb24gKGtleSwgZikge1xuICByZXR1cm4gbW9kaWZ5KGYsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgU3RvcmUgYHZhbHVlYCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgY3VzdG9tIGBoYXNoYC5cblxuICAgIFJldHVybnMgYSBtYXAgd2l0aCB0aGUgbW9kaWZpZWQgdmFsdWUuIERvZXMgbm90IGFsdGVyIGBtYXBgLlxuKi9cblxuXG52YXIgc2V0SGFzaCA9IGhhbXQuc2V0SGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXksIHZhbHVlLCBtYXApIHtcbiAgcmV0dXJuIG1vZGlmeUhhc2goY29uc3RhbnQodmFsdWUpLCBoYXNoLCBrZXksIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLnNldEhhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc2V0SGFzaChoYXNoLCBrZXksIHZhbHVlLCB0aGlzKTtcbn07XG4vKipcbiAgICBTdG9yZSBgdmFsdWVgIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxuXG4gICAgQHNlZSBgc2V0SGFzaGBcbiovXG5cblxudmFyIHNldCA9IGhhbXQuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG1hcCkge1xuICByZXR1cm4gc2V0SGFzaChtYXAuX2NvbmZpZy5oYXNoKGtleSksIGtleSwgdmFsdWUsIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzZXQoa2V5LCB2YWx1ZSwgdGhpcyk7XG59O1xuLyoqXG4gICAgUmVtb3ZlIHRoZSBlbnRyeSBmb3IgYGtleWAgaW4gYG1hcGAuXG5cbiAgICBSZXR1cm5zIGEgbWFwIHdpdGggdGhlIHZhbHVlIHJlbW92ZWQuIERvZXMgbm90IGFsdGVyIGBtYXBgLlxuKi9cblxuXG52YXIgZGVsID0gY29uc3RhbnQobm90aGluZyk7XG5cbnZhciByZW1vdmVIYXNoID0gaGFtdC5yZW1vdmVIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgbWFwKSB7XG4gIHJldHVybiBtb2RpZnlIYXNoKGRlbCwgaGFzaCwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5yZW1vdmVIYXNoID0gTWFwLnByb3RvdHlwZS5kZWxldGVIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSkge1xuICByZXR1cm4gcmVtb3ZlSGFzaChoYXNoLCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIFJlbW92ZSB0aGUgZW50cnkgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGludGVybmFsIGhhc2ggZnVuY3Rpb24uXG5cbiAgICBAc2VlIGByZW1vdmVIYXNoYFxuKi9cblxuXG52YXIgcmVtb3ZlID0gaGFtdC5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5LCBtYXApIHtcbiAgcmV0dXJuIHJlbW92ZUhhc2gobWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLnJlbW92ZSA9IE1hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gcmVtb3ZlKGtleSwgdGhpcyk7XG59O1xuLyogTXV0YXRpb25cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICAgIE1hcmsgYG1hcGAgYXMgbXV0YWJsZS5cbiAqL1xuXG5cbnZhciBiZWdpbk11dGF0aW9uID0gaGFtdC5iZWdpbk11dGF0aW9uID0gZnVuY3Rpb24gKG1hcCkge1xuICByZXR1cm4gbmV3IE1hcChtYXAuX2VkaXRhYmxlICsgMSwgbWFwLl9lZGl0ICsgMSwgbWFwLl9jb25maWcsIG1hcC5fcm9vdCwgbWFwLl9zaXplKTtcbn07XG5cbk1hcC5wcm90b3R5cGUuYmVnaW5NdXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGJlZ2luTXV0YXRpb24odGhpcyk7XG59O1xuLyoqXG4gICAgTWFyayBgbWFwYCBhcyBpbW11dGFibGUuXG4gKi9cblxuXG52YXIgZW5kTXV0YXRpb24gPSBoYW10LmVuZE11dGF0aW9uID0gZnVuY3Rpb24gKG1hcCkge1xuICBtYXAuX2VkaXRhYmxlID0gbWFwLl9lZGl0YWJsZSAmJiBtYXAuX2VkaXRhYmxlIC0gMTtcbiAgcmV0dXJuIG1hcDtcbn07XG5cbk1hcC5wcm90b3R5cGUuZW5kTXV0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBlbmRNdXRhdGlvbih0aGlzKTtcbn07XG4vKipcbiAgICBNdXRhdGUgYG1hcGAgd2l0aGluIHRoZSBjb250ZXh0IG9mIGBmYC5cbiAgICBAcGFyYW0gZlxuICAgIEBwYXJhbSBtYXAgSEFNVFxuKi9cblxuXG52YXIgbXV0YXRlID0gaGFtdC5tdXRhdGUgPSBmdW5jdGlvbiAoZiwgbWFwKSB7XG4gIHZhciB0cmFuc2llbnQgPSBiZWdpbk11dGF0aW9uKG1hcCk7XG4gIGYodHJhbnNpZW50KTtcbiAgcmV0dXJuIGVuZE11dGF0aW9uKHRyYW5zaWVudCk7XG59O1xuXG5NYXAucHJvdG90eXBlLm11dGF0ZSA9IGZ1bmN0aW9uIChmKSB7XG4gIHJldHVybiBtdXRhdGUoZiwgdGhpcyk7XG59O1xuLyogVHJhdmVyc2FsXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBBcHBseSBhIGNvbnRpbnVhdGlvbi5cbiovXG5cblxudmFyIGFwcGsgPSBmdW5jdGlvbiBhcHBrKGspIHtcbiAgcmV0dXJuIGsgJiYgbGF6eVZpc2l0Q2hpbGRyZW4oa1swXSwga1sxXSwga1syXSwga1szXSwga1s0XSk7XG59O1xuLyoqXG4gICAgUmVjdXJzaXZlbHkgdmlzaXQgYWxsIHZhbHVlcyBzdG9yZWQgaW4gYW4gYXJyYXkgb2Ygbm9kZXMgbGF6aWx5LlxuKi9cblxuXG52YXIgbGF6eVZpc2l0Q2hpbGRyZW4gPSBmdW5jdGlvbiBsYXp5VmlzaXRDaGlsZHJlbihsZW4sIGNoaWxkcmVuLCBpLCBmLCBrKSB7XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baSsrXTtcbiAgICBpZiAoY2hpbGQgJiYgIWlzRW1wdHlOb2RlKGNoaWxkKSkgcmV0dXJuIGxhenlWaXNpdChjaGlsZCwgZiwgW2xlbiwgY2hpbGRyZW4sIGksIGYsIGtdKTtcbiAgfVxuXG4gIHJldHVybiBhcHBrKGspO1xufTtcbi8qKlxuICAgIFJlY3Vyc2l2ZWx5IHZpc2l0IGFsbCB2YWx1ZXMgc3RvcmVkIGluIGBub2RlYCBsYXppbHkuXG4qL1xuXG5cbnZhciBsYXp5VmlzaXQgPSBmdW5jdGlvbiBsYXp5VmlzaXQobm9kZSwgZiwgaykge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgTEVBRjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBmKG5vZGUpLFxuICAgICAgICByZXN0OiBrXG4gICAgICB9O1xuXG4gICAgY2FzZSBDT0xMSVNJT046XG4gICAgY2FzZSBBUlJBWTpcbiAgICBjYXNlIElOREVYOlxuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIHJldHVybiBsYXp5VmlzaXRDaGlsZHJlbihjaGlsZHJlbi5sZW5ndGgsIGNoaWxkcmVuLCAwLCBmLCBrKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXBwayhrKTtcbiAgfVxufTtcblxudmFyIERPTkUgPSB7XG4gIGRvbmU6IHRydWVcbn07XG4vKipcbiAgICBKYXZhc2NyaXB0IGl0ZXJhdG9yIG92ZXIgYSBtYXAuXG4qL1xuXG5mdW5jdGlvbiBNYXBJdGVyYXRvcih2KSB7XG4gIHRoaXMudiA9IHY7XG59XG5cbk1hcEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudikgcmV0dXJuIERPTkU7XG4gIHZhciB2MCA9IHRoaXMudjtcbiAgdGhpcy52ID0gYXBwayh2MC5yZXN0KTtcbiAgcmV0dXJuIHYwO1xufTtcblxuTWFwSXRlcmF0b3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICAgIExhemlseSB2aXNpdCBlYWNoIHZhbHVlIGluIG1hcCB3aXRoIGZ1bmN0aW9uIGBmYC5cbiovXG5cblxudmFyIHZpc2l0ID0gZnVuY3Rpb24gdmlzaXQobWFwLCBmKSB7XG4gIHJldHVybiBuZXcgTWFwSXRlcmF0b3IobGF6eVZpc2l0KG1hcC5fcm9vdCwgZikpO1xufTtcbi8qKlxuICAgIEdldCBhIEphdmFzY3NyaXB0IGl0ZXJhdG9yIG9mIGBtYXBgLlxuXG4gICAgSXRlcmF0ZXMgb3ZlciBgW2tleSwgdmFsdWVdYCBhcnJheXMuXG4qL1xuXG5cbnZhciBidWlsZFBhaXJzID0gZnVuY3Rpb24gYnVpbGRQYWlycyh4KSB7XG4gIHJldHVybiBbeC5rZXksIHgudmFsdWVdO1xufTtcblxudmFyIGVudHJpZXMgPSBoYW10LmVudHJpZXMgPSBmdW5jdGlvbiAobWFwKSB7XG4gIHJldHVybiB2aXNpdChtYXAsIGJ1aWxkUGFpcnMpO1xufTtcblxuTWFwLnByb3RvdHlwZS5lbnRyaWVzID0gTWFwLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZW50cmllcyh0aGlzKTtcbn07XG4vKipcbiAgICBHZXQgYXJyYXkgb2YgYWxsIGtleXMgaW4gYG1hcGAuXG5cbiAgICBPcmRlciBpcyBub3QgZ3VhcmFudGVlZC5cbiovXG5cblxudmFyIGJ1aWxkS2V5cyA9IGZ1bmN0aW9uIGJ1aWxkS2V5cyh4KSB7XG4gIHJldHVybiB4LmtleTtcbn07XG5cbnZhciBrZXlzID0gaGFtdC5rZXlzID0gZnVuY3Rpb24gKG1hcCkge1xuICByZXR1cm4gdmlzaXQobWFwLCBidWlsZEtleXMpO1xufTtcblxuTWFwLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ga2V5cyh0aGlzKTtcbn07XG4vKipcbiAgICBHZXQgYXJyYXkgb2YgYWxsIHZhbHVlcyBpbiBgbWFwYC5cblxuICAgIE9yZGVyIGlzIG5vdCBndWFyYW50ZWVkLCBkdXBsaWNhdGVzIGFyZSBwcmVzZXJ2ZWQuXG4qL1xuXG5cbnZhciBidWlsZFZhbHVlcyA9IGZ1bmN0aW9uIGJ1aWxkVmFsdWVzKHgpIHtcbiAgcmV0dXJuIHgudmFsdWU7XG59O1xuXG52YXIgdmFsdWVzID0gaGFtdC52YWx1ZXMgPSBNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uIChtYXApIHtcbiAgcmV0dXJuIHZpc2l0KG1hcCwgYnVpbGRWYWx1ZXMpO1xufTtcblxuTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB2YWx1ZXModGhpcyk7XG59O1xuLyogRm9sZFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgVmlzaXQgZXZlcnkgZW50cnkgaW4gdGhlIG1hcCwgYWdncmVnYXRpbmcgZGF0YS5cblxuICAgIE9yZGVyIG9mIG5vZGVzIGlzIG5vdCBndWFyYW50ZWVkLlxuXG4gICAgQHBhcmFtIGYgRnVuY3Rpb24gbWFwcGluZyBhY2N1bXVsYXRlZCB2YWx1ZSwgdmFsdWUsIGFuZCBrZXkgdG8gbmV3IHZhbHVlLlxuICAgIEBwYXJhbSB6IFN0YXJ0aW5nIHZhbHVlLlxuICAgIEBwYXJhbSBtIEhBTVRcbiovXG5cblxudmFyIGZvbGQgPSBoYW10LmZvbGQgPSBmdW5jdGlvbiAoZiwgeiwgbSkge1xuICB2YXIgcm9vdCA9IG0uX3Jvb3Q7XG4gIGlmIChyb290LnR5cGUgPT09IExFQUYpIHJldHVybiBmKHosIHJvb3QudmFsdWUsIHJvb3Qua2V5KTtcbiAgdmFyIHRvVmlzaXQgPSBbcm9vdC5jaGlsZHJlbl07XG4gIHZhciBjaGlsZHJlbiA9IHZvaWQgMDtcblxuICB3aGlsZSAoY2hpbGRyZW4gPSB0b1Zpc2l0LnBvcCgpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2krK107XG5cbiAgICAgIGlmIChjaGlsZCAmJiBjaGlsZC50eXBlKSB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBMRUFGKSB6ID0gZih6LCBjaGlsZC52YWx1ZSwgY2hpbGQua2V5KTtlbHNlIHRvVmlzaXQucHVzaChjaGlsZC5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHo7XG59O1xuXG5NYXAucHJvdG90eXBlLmZvbGQgPSBmdW5jdGlvbiAoZiwgeikge1xuICByZXR1cm4gZm9sZChmLCB6LCB0aGlzKTtcbn07XG4vKipcbiAgICBWaXNpdCBldmVyeSBlbnRyeSBpbiB0aGUgbWFwLCBhZ2dyZWdhdGluZyBkYXRhLlxuXG4gICAgT3JkZXIgb2Ygbm9kZXMgaXMgbm90IGd1YXJhbnRlZWQuXG5cbiAgICBAcGFyYW0gZiBGdW5jdGlvbiBpbnZva2VkIHdpdGggdmFsdWUgYW5kIGtleVxuICAgIEBwYXJhbSBtYXAgSEFNVFxuKi9cblxuXG52YXIgZm9yRWFjaCA9IGhhbXQuZm9yRWFjaCA9IGZ1bmN0aW9uIChmLCBtYXApIHtcbiAgcmV0dXJuIGZvbGQoZnVuY3Rpb24gKF8sIHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gZih2YWx1ZSwga2V5LCBtYXApO1xuICB9LCBudWxsLCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGYpIHtcbiAgcmV0dXJuIGZvckVhY2goZiwgdGhpcyk7XG59O1xuLyogQWdncmVnYXRlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBHZXQgdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIGBtYXBgLlxuKi9cblxuXG52YXIgY291bnQgPSBoYW10LmNvdW50ID0gZnVuY3Rpb24gKG1hcCkge1xuICByZXR1cm4gbWFwLl9zaXplO1xufTtcblxuTWFwLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNvdW50KHRoaXMpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcC5wcm90b3R5cGUsICdzaXplJywge1xuICBnZXQ6IE1hcC5wcm90b3R5cGUuY291bnRcbn0pO1xuLyogRXhwb3J0XG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5pZiAoIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaGFtdDtcbn0gZWxzZSB7XG4gIHVuZGVmaW5lZC5oYW10ID0gaGFtdDtcbn1cbn0pO1xuXG5jbGFzcyBCdWlsdEluTWFwIHtcbiAgY29uc3RydWN0b3IoZXhpc3RpbmcpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWFwXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKGV4aXN0aW5nID09PSBudWxsIHx8IGV4aXN0aW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGlzdGluZy5lbnRyaWVzKCkpO1xuICB9XG5cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcbiAgfVxuXG4gIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5lbnRyaWVzKCk7XG4gIH1cblxuICBnZXQoaykge1xuICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0KGspO1xuICB9XG5cbiAgaGFzKGspIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyhrKTtcbiAgfVxuXG4gIHNldChrLCB2KSB7XG4gICAgdGhpcy5fbWFwLnNldChrLCB2KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGVsZXRlKGspIHtcbiAgICB0aGlzLl9tYXAuZGVsZXRlKGspO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gcGVyc2lzdGVudE1hcCh0aGlzKTtcbiAgfVxuXG4gIHRvTWFwKCkge1xuICAgIHJldHVybiBuZXcgTWFwKHRoaXMuX21hcCk7XG4gIH1cblxufVxuXG5jbGFzcyBIYXNoQXJyYXlNYXBwZWRUcmllTWFwIHtcbiAgLy8gQmVjYXVzZSBoYW10LmVtcHR5IGlzIG5vdCBhIGZ1bmN0aW9uIHRoZXJlIGlzIG5vIHdheSB0byBpbnRyb2R1Y2UgdHlwZVxuICAvLyBwYXJhbWV0ZXJzIG9uIGl0LCBzbyBlbXB0eSBpcyB0eXBlZCBhcyBIQU1UUGx1c01hcDxzdHJpbmcsIG1peGVkPi5cbiAgLy8gJEZsb3dJc3N1ZVxuICBjb25zdHJ1Y3RvcihleGlzdGluZykge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9oYW10XCIsIGhhbXRfMS5lbXB0eS5iZWdpbk11dGF0aW9uKCkpO1xuXG4gICAgaWYgKGV4aXN0aW5nIGluc3RhbmNlb2YgSGFzaEFycmF5TWFwcGVkVHJpZU1hcCkge1xuICAgICAgY29uc3QgaCA9IGV4aXN0aW5nLl9oYW10LmVuZE11dGF0aW9uKCk7XG5cbiAgICAgIGV4aXN0aW5nLl9oYW10ID0gaC5iZWdpbk11dGF0aW9uKCk7XG4gICAgICB0aGlzLl9oYW10ID0gaC5iZWdpbk11dGF0aW9uKCk7XG4gICAgfSBlbHNlIGlmIChleGlzdGluZykge1xuICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgZXhpc3RpbmcuZW50cmllcygpKSB7XG4gICAgICAgIHRoaXMuX2hhbXQuc2V0KGssIHYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhbXQua2V5cygpO1xuICB9XG5cbiAgZW50cmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5faGFtdC5lbnRyaWVzKCk7XG4gIH1cblxuICBnZXQoaykge1xuICAgIHJldHVybiB0aGlzLl9oYW10LmdldChrKTtcbiAgfVxuXG4gIGhhcyhrKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhbXQuaGFzKGspO1xuICB9XG5cbiAgc2V0KGssIHYpIHtcbiAgICB0aGlzLl9oYW10LnNldChrLCB2KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGVsZXRlKGspIHtcbiAgICB0aGlzLl9oYW10LmRlbGV0ZShrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIHBlcnNpc3RlbnRNYXAodGhpcyk7XG4gIH1cblxuICB0b01hcCgpIHtcbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzLl9oYW10KTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHBlcnNpc3RlbnRNYXAoZXhpc3RpbmcpIHtcbiAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9oYW10XzIwMjAnKSkge1xuICAgIHJldHVybiBuZXcgSGFzaEFycmF5TWFwcGVkVHJpZU1hcChleGlzdGluZyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBCdWlsdEluTWFwKGV4aXN0aW5nKTtcbiAgfVxufVxuXG52YXIgUmVjb2lsX1BlcnNpc3RlbnRNYXAgPSB7XG4gIHBlcnNpc3RlbnRNYXBcbn07XG5cbnZhciBSZWNvaWxfUGVyc2lzdGVudE1hcF8xID0gUmVjb2lsX1BlcnNpc3RlbnRNYXAucGVyc2lzdGVudE1hcDtcblxudmFyIFJlY29pbF9QZXJzaXN0ZW50TWFwJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgcGVyc2lzdGVudE1hcDogUmVjb2lsX1BlcnNpc3RlbnRNYXBfMVxufSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIFJldHVybnMgYSBzZXQgY29udGFpbmluZyBhbGwgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBmaXJzdCBzZXQgdGhhdCBhcmUgbm90XG4gKiBwcmVzZW50IGluIGFueSBvZiB0aGUgc3Vic2VxdWVudCBzZXRzLlxuICpcbiAqIE5vdGU6IHRoaXMgaXMgd3JpdHRlbiBwcm9jZWR1cmFsbHkgKGkuZS4sIHdpdGhvdXQgZmlsdGVyU2V0KSBmb3IgcGVyZm9ybWFudFxuICogdXNlIGluIHRpZ2h0IGxvb3BzLlxuICovXG5cbmZ1bmN0aW9uIGRpZmZlcmVuY2VTZXRzKHNldCwgLi4uc2V0c1dpdGhWYWx1ZXNUb1JlbW92ZSkge1xuICBjb25zdCByZXQgPSBuZXcgU2V0KCk7XG5cbiAgRklSU1Q6IGZvciAoY29uc3QgdmFsdWUgb2Ygc2V0KSB7XG4gICAgZm9yIChjb25zdCBvdGhlclNldCBvZiBzZXRzV2l0aFZhbHVlc1RvUmVtb3ZlKSB7XG4gICAgICBpZiAob3RoZXJTZXQuaGFzKHZhbHVlKSkge1xuICAgICAgICBjb250aW51ZSBGSVJTVDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXQuYWRkKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbnZhciBSZWNvaWxfZGlmZmVyZW5jZVNldHMgPSBkaWZmZXJlbmNlU2V0cztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIG5ldyBNYXAgb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyB0aGUgb3JpZ2luYWwsIGJ1dCB3aXRoIHRoZVxuICogdmFsdWVzIHJlcGxhY2VkIHdpdGggdGhlIG91dHB1dCBvZiB0aGUgZ2l2ZW4gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gbWFwTWFwKG1hcCwgY2FsbGJhY2spIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICBtYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIHJlc3VsdC5zZXQoa2V5LCBjYWxsYmFjayh2YWx1ZSwga2V5KSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVjb2lsX21hcE1hcCA9IG1hcE1hcDtcblxuZnVuY3Rpb24gbWFrZUdyYXBoKCkge1xuICByZXR1cm4ge1xuICAgIG5vZGVEZXBzOiBuZXcgTWFwKCksXG4gICAgbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBjbG9uZUdyYXBoKGdyYXBoKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZURlcHM6IFJlY29pbF9tYXBNYXAoZ3JhcGgubm9kZURlcHMsIHMgPT4gbmV3IFNldChzKSksXG4gICAgbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnM6IFJlY29pbF9tYXBNYXAoZ3JhcGgubm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMsIHMgPT4gbmV3IFNldChzKSlcbiAgfTtcbn0gLy8gTm90ZSB0aGF0IHRoaXMgb3ZlcndyaXRlcyB0aGUgZGVwcyBvZiBleGlzdGluZyBub2RlcywgcmF0aGVyIHRoYW4gdW5pb25pbmdcbi8vIHRoZSBuZXcgZGVwcyB3aXRoIHRoZSBvbGQgZGVwcy5cblxuXG5mdW5jdGlvbiBtZXJnZURlcHNJbnRvR3JhcGgoa2V5LCBuZXdEZXBzLCBncmFwaCwgLy8gSWYgb2xkZXJHcmFwaCBpcyBnaXZlbiB0aGVuIHdlIHdpbGwgbm90IG92ZXJ3cml0ZSBjaGFuZ2VzIG1hZGUgdG8gdGhlIGdpdmVuXG4vLyBncmFwaCBjb21wYXJlZCB3aXRoIG9sZGVyR3JhcGg6XG5vbGRlckdyYXBoKSB7XG4gIGNvbnN0IHtcbiAgICBub2RlRGVwcyxcbiAgICBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uc1xuICB9ID0gZ3JhcGg7XG4gIGNvbnN0IG9sZERlcHMgPSBub2RlRGVwcy5nZXQoa2V5KTtcblxuICBpZiAob2xkRGVwcyAmJiBvbGRlckdyYXBoICYmIG9sZERlcHMgIT09IG9sZGVyR3JhcGgubm9kZURlcHMuZ2V0KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVXBkYXRlIG5vZGVEZXBzOlxuXG5cbiAgbm9kZURlcHMuc2V0KGtleSwgbmV3RGVwcyk7IC8vIEFkZCBuZXcgZGVwcyB0byBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uczpcblxuICBjb25zdCBhZGRlZERlcHMgPSBvbGREZXBzID09IG51bGwgPyBuZXdEZXBzIDogUmVjb2lsX2RpZmZlcmVuY2VTZXRzKG5ld0RlcHMsIG9sZERlcHMpO1xuXG4gIGZvciAoY29uc3QgZGVwIG9mIGFkZGVkRGVwcykge1xuICAgIGlmICghbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuaGFzKGRlcCkpIHtcbiAgICAgIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zLnNldChkZXAsIG5ldyBTZXQoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmcgPSBSZWNvaWxfbnVsbHRocm93cyhub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQoZGVwKSk7XG4gICAgZXhpc3RpbmcuYWRkKGtleSk7XG4gIH0gLy8gUmVtb3ZlIHJlbW92ZWQgZGVwcyBmcm9tIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zOlxuXG5cbiAgaWYgKG9sZERlcHMpIHtcbiAgICBjb25zdCByZW1vdmVkRGVwcyA9IFJlY29pbF9kaWZmZXJlbmNlU2V0cyhvbGREZXBzLCBuZXdEZXBzKTtcblxuICAgIGZvciAoY29uc3QgZGVwIG9mIHJlbW92ZWREZXBzKSB7XG4gICAgICBpZiAoIW5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmhhcyhkZXApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXhpc3RpbmcgPSBSZWNvaWxfbnVsbHRocm93cyhub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQoZGVwKSk7XG4gICAgICBleGlzdGluZy5kZWxldGUoa2V5KTtcblxuICAgICAgaWYgKGV4aXN0aW5nLnNpemUgPT09IDApIHtcbiAgICAgICAgbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGRlcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhdmVEZXBzVG9TdG9yZShrZXksIGRlcHMsIHN0b3JlLCB2ZXJzaW9uKSB7XG4gIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZSwgX3N0b3JlU3RhdGUkcHJldmlvdXNULCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QyLCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QzO1xuXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gIGlmICghKHZlcnNpb24gPT09IHN0b3JlU3RhdGUuY3VycmVudFRyZWUudmVyc2lvbiB8fCB2ZXJzaW9uID09PSAoKF9zdG9yZVN0YXRlJG5leHRUcmVlID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkbmV4dFRyZWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJG5leHRUcmVlLnZlcnNpb24pIHx8IHZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUID0gc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJHByZXZpb3VzVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNULnZlcnNpb24pKSkge1xuICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignVHJpZWQgdG8gc2F2ZSBkZXBlbmRlbmNpZXMgdG8gYSBkaXNjYXJkZWQgdHJlZScpO1xuICB9IC8vIE1lcmdlIHRoZSBkZXBlbmRlbmNpZXMgZGlzY292ZXJlZCBpbnRvIHRoZSBzdG9yZSdzIGRlcGVuZGVuY3kgbWFwXG4gIC8vIGZvciB0aGUgdmVyc2lvbiB0aGF0IHdhcyByZWFkOlxuXG5cbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaCh2ZXJzaW9uKTtcbiAgbWVyZ2VEZXBzSW50b0dyYXBoKGtleSwgZGVwcywgZ3JhcGgpOyAvLyBJZiB0aGlzIHZlcnNpb24gaXMgbm90IHRoZSBsYXRlc3QgdmVyc2lvbiwgYWxzbyB3cml0ZSB0aGVzZSBkZXBlbmRlbmNpZXNcbiAgLy8gaW50byBsYXRlciB2ZXJzaW9ucyBpZiB0aGV5IGRvbid0IGFscmVhZHkgaGF2ZSB0aGVpciBvd246XG5cbiAgaWYgKHZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUMiA9IHN0b3JlU3RhdGUucHJldmlvdXNUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRwcmV2aW91c1QyLnZlcnNpb24pKSB7XG4gICAgY29uc3QgY3VycmVudEdyYXBoID0gc3RvcmUuZ2V0R3JhcGgoc3RvcmVTdGF0ZS5jdXJyZW50VHJlZS52ZXJzaW9uKTtcbiAgICBtZXJnZURlcHNJbnRvR3JhcGgoa2V5LCBkZXBzLCBjdXJyZW50R3JhcGgsIGdyYXBoKTtcbiAgfVxuXG4gIGlmICh2ZXJzaW9uID09PSAoKF9zdG9yZVN0YXRlJHByZXZpb3VzVDMgPSBzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkcHJldmlvdXNUMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNUMy52ZXJzaW9uKSB8fCB2ZXJzaW9uID09PSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlLnZlcnNpb24pIHtcbiAgICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWUyO1xuXG4gICAgY29uc3QgbmV4dFZlcnNpb24gPSAoX3N0b3JlU3RhdGUkbmV4dFRyZWUyID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkbmV4dFRyZWUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRuZXh0VHJlZTIudmVyc2lvbjtcblxuICAgIGlmIChuZXh0VmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBuZXh0R3JhcGggPSBzdG9yZS5nZXRHcmFwaChuZXh0VmVyc2lvbik7XG4gICAgICBtZXJnZURlcHNJbnRvR3JhcGgoa2V5LCBkZXBzLCBuZXh0R3JhcGgsIGdyYXBoKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlY29pbF9HcmFwaCA9IHtcbiAgY2xvbmVHcmFwaCxcbiAgZ3JhcGg6IG1ha2VHcmFwaCxcbiAgc2F2ZURlcHNUb1N0b3JlXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5sZXQgbmV4dFRyZWVTdGF0ZVZlcnNpb24gPSAwO1xuXG5jb25zdCBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiA9ICgpID0+IG5leHRUcmVlU3RhdGVWZXJzaW9uKys7XG5cbmxldCBuZXh0U3RvcmVJRCA9IDA7XG5cbmNvbnN0IGdldE5leHRTdG9yZUlEID0gKCkgPT4gbmV4dFN0b3JlSUQrKztcblxubGV0IG5leHRDb21wb25lbnRJRCA9IDA7XG5cbmNvbnN0IGdldE5leHRDb21wb25lbnRJRCA9ICgpID0+IG5leHRDb21wb25lbnRJRCsrO1xuXG52YXIgUmVjb2lsX0tleXMgPSB7XG4gIGdldE5leHRUcmVlU3RhdGVWZXJzaW9uLFxuICBnZXROZXh0U3RvcmVJRCxcbiAgZ2V0TmV4dENvbXBvbmVudElEXG59O1xuXG5jb25zdCB7XG4gIHBlcnNpc3RlbnRNYXA6IHBlcnNpc3RlbnRNYXAkMVxufSA9IFJlY29pbF9QZXJzaXN0ZW50TWFwJDE7XG5cbmNvbnN0IHtcbiAgZ3JhcGhcbn0gPSBSZWNvaWxfR3JhcGg7XG5cbmNvbnN0IHtcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb246IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDFcbn0gPSBSZWNvaWxfS2V5cztcblxuZnVuY3Rpb24gbWFrZUVtcHR5VHJlZVN0YXRlKCkge1xuICBjb25zdCB2ZXJzaW9uID0gZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMSgpO1xuICByZXR1cm4ge1xuICAgIHZlcnNpb24sXG4gICAgc3RhdGVJRDogdmVyc2lvbixcbiAgICB0cmFuc2FjdGlvbk1ldGFkYXRhOiB7fSxcbiAgICBkaXJ0eUF0b21zOiBuZXcgU2V0KCksXG4gICAgYXRvbVZhbHVlczogcGVyc2lzdGVudE1hcCQxKCksXG4gICAgbm9udmFsaWRhdGVkQXRvbXM6IHBlcnNpc3RlbnRNYXAkMSgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VFbXB0eVN0b3JlU3RhdGUoKSB7XG4gIGNvbnN0IGN1cnJlbnRUcmVlID0gbWFrZUVtcHR5VHJlZVN0YXRlKCk7XG4gIHJldHVybiB7XG4gICAgY3VycmVudFRyZWUsXG4gICAgbmV4dFRyZWU6IG51bGwsXG4gICAgcHJldmlvdXNUcmVlOiBudWxsLFxuICAgIGNvbW1pdERlcHRoOiAwLFxuICAgIGtub3duQXRvbXM6IG5ldyBTZXQoKSxcbiAgICBrbm93blNlbGVjdG9yczogbmV3IFNldCgpLFxuICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxuICAgIG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKSxcbiAgICBub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXG4gICAgcXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQ6IFtdLFxuICAgIHN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVyczogbmV3IFNldCgpLFxuICAgIGdyYXBoc0J5VmVyc2lvbjogbmV3IE1hcCgpLnNldChjdXJyZW50VHJlZS52ZXJzaW9uLCBncmFwaCgpKSxcbiAgICByZXRlbnRpb246IHtcbiAgICAgIHJlZmVyZW5jZUNvdW50czogbmV3IE1hcCgpLFxuICAgICAgbm9kZXNSZXRhaW5lZEJ5Wm9uZTogbmV3IE1hcCgpLFxuICAgICAgcmV0YWluYWJsZXNUb0NoZWNrRm9yUmVsZWFzZTogbmV3IFNldCgpXG4gICAgfSxcbiAgICBub2RlQ2xlYW51cEZ1bmN0aW9uczogbmV3IE1hcCgpXG4gIH07XG59XG5cbnZhciBSZWNvaWxfU3RhdGUgPSB7XG4gIG1ha2VFbXB0eVRyZWVTdGF0ZSxcbiAgbWFrZUVtcHR5U3RvcmVTdGF0ZSxcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb246IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDFcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmNsYXNzIFJldGVudGlvblpvbmUge31cblxuZnVuY3Rpb24gcmV0ZW50aW9uWm9uZSgpIHtcbiAgcmV0dXJuIG5ldyBSZXRlbnRpb25ab25lKCk7XG59XG5cbnZhciBSZWNvaWxfUmV0ZW50aW9uWm9uZSA9IHtcbiAgUmV0ZW50aW9uWm9uZSxcbiAgcmV0ZW50aW9uWm9uZVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBVdGlsaXRpZXMgZm9yIHdvcmtpbmcgd2l0aCBidWlsdC1pbiBNYXBzIGFuZCBTZXRzIHdpdGhvdXQgbXV0YXRpbmcgdGhlbS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gc2V0QnlBZGRpbmdUb1NldChzZXQsIHYpIHtcbiAgY29uc3QgbmV4dCA9IG5ldyBTZXQoc2V0KTtcbiAgbmV4dC5hZGQodik7XG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRCeURlbGV0aW5nRnJvbVNldChzZXQsIHYpIHtcbiAgY29uc3QgbmV4dCA9IG5ldyBTZXQoc2V0KTtcbiAgbmV4dC5kZWxldGUodik7XG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiBtYXBCeVNldHRpbmdJbk1hcChtYXAsIGssIHYpIHtcbiAgY29uc3QgbmV4dCA9IG5ldyBNYXAobWFwKTtcbiAgbmV4dC5zZXQoaywgdik7XG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiBtYXBCeVVwZGF0aW5nSW5NYXAobWFwLCBrLCB1cGRhdGVyKSB7XG4gIGNvbnN0IG5leHQgPSBuZXcgTWFwKG1hcCk7XG4gIG5leHQuc2V0KGssIHVwZGF0ZXIobmV4dC5nZXQoaykpKTtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIG1hcEJ5RGVsZXRpbmdGcm9tTWFwKG1hcCwgaykge1xuICBjb25zdCBuZXh0ID0gbmV3IE1hcChtYXApO1xuICBuZXh0LmRlbGV0ZShrKTtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIG1hcEJ5RGVsZXRpbmdNdWx0aXBsZUZyb21NYXAobWFwLCBrcykge1xuICBjb25zdCBuZXh0ID0gbmV3IE1hcChtYXApO1xuICBrcy5mb3JFYWNoKGsgPT4gbmV4dC5kZWxldGUoaykpO1xuICByZXR1cm4gbmV4dDtcbn1cblxudmFyIFJlY29pbF9Db3B5T25Xcml0ZSA9IHtcbiAgc2V0QnlBZGRpbmdUb1NldCxcbiAgc2V0QnlEZWxldGluZ0Zyb21TZXQsXG4gIG1hcEJ5U2V0dGluZ0luTWFwLFxuICBtYXBCeVVwZGF0aW5nSW5NYXAsXG4gIG1hcEJ5RGVsZXRpbmdGcm9tTWFwLFxuICBtYXBCeURlbGV0aW5nTXVsdGlwbGVGcm9tTWFwXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGl0ZXJhYmxlIHdob3NlIG91dHB1dCBpcyBnZW5lcmF0ZWQgYnkgcGFzc2luZyB0aGUgaW5wdXRcbiAqIGl0ZXJhYmxlJ3MgdmFsdWVzIHRocm91Z2ggdGhlIGZpbHRlciBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiogZmlsdGVySXRlcmFibGUoaXRlcmFibGUsIHByZWRpY2F0ZSkge1xuICAvLyBVc2UgZ2VuZXJhdG9yIHRvIGNyZWF0ZSBpdGVyYWJsZS9pdGVyYXRvclxuICBsZXQgaW5kZXggPSAwO1xuXG4gIGZvciAoY29uc3QgdmFsdWUgb2YgaXRlcmFibGUpIHtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCsrKSkge1xuICAgICAgeWllbGQgdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWNvaWxfZmlsdGVySXRlcmFibGUgPSBmaWx0ZXJJdGVyYWJsZTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogUmV0dXJuIGEgcHJveHkgb2JqZWN0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBiYXNlIGFuZCBmYWN0b3JpZXMgb2JqZWN0cy5cbiAqIFRoZSBwcm94eSB3aWxsIGluY2x1ZGUgYWxsIHByb3BlcnRpZXMgb2YgdGhlIGJhc2Ugb2JqZWN0IGFzLWlzLlxuICogVGhlIGZhY3RvcmllcyBvYmplY3QgY29udGFpbnMgY2FsbGJhY2tzIHRvIG9idGFpbiB0aGUgdmFsdWVzIG9mIHRoZSBwcm9wZXJpZXNcbiAqIGZvciBpdHMga2V5cy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgcHJvdmlkaW5nIHVzZXJzIGFuIG9iamVjdCB3aGVyZSBzb21lIHByb3BlcnRpZXMgbWF5IGJlXG4gKiBsYXppbHkgY29tcHV0ZWQgb25seSBvbiBmaXJzdCBhY2Nlc3MuXG4gKi9cbi8vICRGbG93SXNzdWVbdW5jbGVhci10eXBlXVxuXG5mdW5jdGlvbiBsYXp5UHJveHkoYmFzZSwgZmFjdG9yaWVzKSB7XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KGJhc2UsIHtcbiAgICAvLyBDb21wdXRlIGFuZCBjYWNoZSBsYXp5IHByb3BlcnR5IGlmIG5vdCBhbHJlYWR5IGRvbmUuXG4gICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICBpZiAoIShwcm9wIGluIHRhcmdldCkgJiYgcHJvcCBpbiBmYWN0b3JpZXMpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gZmFjdG9yaWVzW3Byb3BdKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgfSxcbiAgICAvLyBUaGlzIG1ldGhvZCBhbGxvd3MgdXNlciB0byBpdGVyYXRlIGtleXMgYXMgbm9ybWFsXG4gICAgb3duS2V5czogdGFyZ2V0ID0+IHtcblxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCk7XG4gICAgfVxuICB9KTsgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gIHJldHVybiBwcm94eTtcbn1cblxudmFyIFJlY29pbF9sYXp5UHJveHkgPSBsYXp5UHJveHk7XG5cbmNvbnN0IHtcbiAgZ2V0Tm9kZTogZ2V0Tm9kZSQxLFxuICBnZXROb2RlTWF5YmU6IGdldE5vZGVNYXliZSQxLFxuICByZWNvaWxWYWx1ZXNGb3JLZXlzOiByZWNvaWxWYWx1ZXNGb3JLZXlzJDFcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBSZXRlbnRpb25ab25lOiBSZXRlbnRpb25ab25lJDFcbn0gPSBSZWNvaWxfUmV0ZW50aW9uWm9uZTtcblxuY29uc3Qge1xuICBzZXRCeUFkZGluZ1RvU2V0OiBzZXRCeUFkZGluZ1RvU2V0JDFcbn0gPSBSZWNvaWxfQ29weU9uV3JpdGU7XG5cblxuXG5cblxuXG5cbiAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG5cbmNvbnN0IGVtcHR5U2V0ID0gT2JqZWN0LmZyZWV6ZShuZXcgU2V0KCkpO1xuXG5jbGFzcyBSZWFkT25seVJlY29pbFZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUmV0ZW50aW9uRm9yTm9kZShzdG9yZSwgbm9kZUtleSwgcmV0YWluZWRCeSkge1xuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIG5vZGVzUmV0YWluZWRCeVpvbmVcbiAgfSA9IHN0b3JlLmdldFN0YXRlKCkucmV0ZW50aW9uO1xuXG4gIGZ1bmN0aW9uIGFkZFRvWm9uZSh6b25lKSB7XG4gICAgbGV0IHNldCA9IG5vZGVzUmV0YWluZWRCeVpvbmUuZ2V0KHpvbmUpO1xuXG4gICAgaWYgKCFzZXQpIHtcbiAgICAgIG5vZGVzUmV0YWluZWRCeVpvbmUuc2V0KHpvbmUsIHNldCA9IG5ldyBTZXQoKSk7XG4gICAgfVxuXG4gICAgc2V0LmFkZChub2RlS2V5KTtcbiAgfVxuXG4gIGlmIChyZXRhaW5lZEJ5IGluc3RhbmNlb2YgUmV0ZW50aW9uWm9uZSQxKSB7XG4gICAgYWRkVG9ab25lKHJldGFpbmVkQnkpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmV0YWluZWRCeSkpIHtcbiAgICBmb3IgKGNvbnN0IHpvbmUgb2YgcmV0YWluZWRCeSkge1xuICAgICAgYWRkVG9ab25lKHpvbmUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgcmV0ZW50aW9uXG4gICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICBmdW5jdGlvbiBkZWxldGVGcm9tWm9uZSh6b25lKSB7XG4gICAgICBjb25zdCBzZXQgPSByZXRlbnRpb24ubm9kZXNSZXRhaW5lZEJ5Wm9uZS5nZXQoem9uZSk7XG4gICAgICBzZXQgPT09IG51bGwgfHwgc2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXQuZGVsZXRlKG5vZGVLZXkpO1xuXG4gICAgICBpZiAoc2V0ICYmIHNldC5zaXplID09PSAwKSB7XG4gICAgICAgIHJldGVudGlvbi5ub2Rlc1JldGFpbmVkQnlab25lLmRlbGV0ZSh6b25lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmV0YWluZWRCeSBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMSkge1xuICAgICAgZGVsZXRlRnJvbVpvbmUocmV0YWluZWRCeSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldGFpbmVkQnkpKSB7XG4gICAgICBmb3IgKGNvbnN0IHpvbmUgb2YgcmV0YWluZWRCeSkge1xuICAgICAgICBkZWxldGVGcm9tWm9uZSh6b25lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlKHN0b3JlLCB0cmVlU3RhdGUsIGtleSwgdHJpZ2dlcikge1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICBpZiAoc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5oYXMoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG5vZGUgPSBnZXROb2RlJDEoa2V5KTtcbiAgY29uc3QgcmV0ZW50aW9uQ2xlYW51cCA9IGluaXRpYWxpemVSZXRlbnRpb25Gb3JOb2RlKHN0b3JlLCBrZXksIG5vZGUucmV0YWluZWRCeSk7XG4gIGNvbnN0IG5vZGVDbGVhbnVwID0gbm9kZS5pbml0KHN0b3JlLCB0cmVlU3RhdGUsIHRyaWdnZXIpO1xuICBzdG9yZVN0YXRlLm5vZGVDbGVhbnVwRnVuY3Rpb25zLnNldChrZXksICgpID0+IHtcbiAgICBub2RlQ2xlYW51cCgpO1xuICAgIHJldGVudGlvbkNsZWFudXAoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVOb2RlKHN0b3JlLCBrZXksIHRyaWdnZXIpIHtcbiAgaW5pdGlhbGl6ZU5vZGVJZk5ld1RvU3RvcmUoc3RvcmUsIHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUsIGtleSwgdHJpZ2dlcik7XG59XG5cbmZ1bmN0aW9uIGNsZWFuVXBOb2RlKHN0b3JlLCBrZXkpIHtcbiAgdmFyIF9zdGF0ZSRub2RlQ2xlYW51cEZ1bjtcblxuICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIChfc3RhdGUkbm9kZUNsZWFudXBGdW4gPSBzdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5nZXQoa2V5KSkgPT09IG51bGwgfHwgX3N0YXRlJG5vZGVDbGVhbnVwRnVuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGUkbm9kZUNsZWFudXBGdW4oKTtcbiAgc3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuZGVsZXRlKGtleSk7XG59IC8vIEdldCB0aGUgY3VycmVudCB2YWx1ZSBsb2FkYWJsZSBvZiBhIG5vZGUgYW5kIHVwZGF0ZSB0aGUgc3RhdGUuXG4vLyBVcGRhdGUgZGVwZW5kZW5jaWVzIGFuZCBzdWJzY3JpcHRpb25zIGZvciBzZWxlY3RvcnMuXG4vLyBVcGRhdGUgc2F2ZWQgdmFsdWUgdmFsaWRhdGlvbiBmb3IgYXRvbXMuXG5cblxuZnVuY3Rpb24gZ2V0Tm9kZUxvYWRhYmxlKHN0b3JlLCBzdGF0ZSwga2V5KSB7XG4gIGluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlKHN0b3JlLCBzdGF0ZSwga2V5LCAnZ2V0Jyk7XG4gIHJldHVybiBnZXROb2RlJDEoa2V5KS5nZXQoc3RvcmUsIHN0YXRlKTtcbn0gLy8gUGVlayBhdCB0aGUgY3VycmVudCB2YWx1ZSBsb2FkYWJsZSBmb3IgYSBub2RlIHdpdGhvdXQgYW55IGV2YWx1YXRpb24gb3Igc3RhdGUgY2hhbmdlXG5cblxuZnVuY3Rpb24gcGVla05vZGVMb2FkYWJsZShzdG9yZSwgc3RhdGUsIGtleSkge1xuICByZXR1cm4gZ2V0Tm9kZSQxKGtleSkucGVlayhzdG9yZSwgc3RhdGUpO1xufSAvLyBXcml0ZSB2YWx1ZSBkaXJlY3RseSB0byBzdGF0ZSBieXBhc3NpbmcgdGhlIE5vZGUgaW50ZXJmYWNlIGFzIHRoZSBub2RlXG4vLyBkZWZpbml0aW9ucyBtYXkgbm90IGhhdmUgYmVlbiBsb2FkZWQgeWV0IHdoZW4gcHJvY2Vzc2luZyB0aGUgaW5pdGlhbCBzbmFwc2hvdC5cblxuXG5mdW5jdGlvbiBzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVEKHN0YXRlLCBrZXksIG5ld1ZhbHVlKSB7XG4gIHZhciBfbm9kZSRpbnZhbGlkYXRlO1xuXG4gIGNvbnN0IG5vZGUgPSBnZXROb2RlTWF5YmUkMShrZXkpO1xuICBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbm9kZSRpbnZhbGlkYXRlID0gbm9kZS5pbnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfbm9kZSRpbnZhbGlkYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRpbnZhbGlkYXRlLmNhbGwobm9kZSwgc3RhdGUpO1xuICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICBhdG9tVmFsdWVzOiBzdGF0ZS5hdG9tVmFsdWVzLmNsb25lKCkuZGVsZXRlKGtleSksXG4gICAgbm9udmFsaWRhdGVkQXRvbXM6IHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmNsb25lKCkuc2V0KGtleSwgbmV3VmFsdWUpLFxuICAgIGRpcnR5QXRvbXM6IHNldEJ5QWRkaW5nVG9TZXQkMShzdGF0ZS5kaXJ0eUF0b21zLCBrZXkpXG4gIH07XG59IC8vIFJldHVybiB0aGUgZGlzY292ZXJlZCBkZXBlbmRlbmNpZXMgYW5kIHZhbHVlcyB0byBiZSB3cml0dGVuIGJ5IHNldHRpbmdcbi8vIGEgbm9kZSB2YWx1ZS4gKE11bHRpcGxlIHZhbHVlcyBtYXkgYmUgd3JpdHRlbiBkdWUgdG8gc2VsZWN0b3JzIGdldHRpbmcgdG9cbi8vIHNldCB1cHN0cmVhbXM7IGRlcHMgbWF5IGJlIGRpc2NvdmVyZWQgYmVjYXVzZSBvZiByZWFkcyBpbiB1cGRhdGVyIGZ1bmN0aW9ucy4pXG5cblxuZnVuY3Rpb24gc2V0Tm9kZVZhbHVlKHN0b3JlLCBzdGF0ZSwga2V5LCBuZXdWYWx1ZSkge1xuICBjb25zdCBub2RlID0gZ2V0Tm9kZSQxKGtleSk7XG5cbiAgaWYgKG5vZGUuc2V0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgUmVhZE9ubHlSZWNvaWxWYWx1ZUVycm9yKGBBdHRlbXB0IHRvIHNldCByZWFkLW9ubHkgUmVjb2lsVmFsdWU6ICR7a2V5fWApO1xuICB9XG5cbiAgY29uc3Qgc2V0ID0gbm9kZS5zZXQ7IC8vIHNvIGZsb3cgZG9lc24ndCBsb3NlIHRoZSBhYm92ZSByZWZpbmVtZW50LlxuXG4gIGluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlKHN0b3JlLCBzdGF0ZSwga2V5LCAnc2V0Jyk7XG4gIHJldHVybiBzZXQoc3RvcmUsIHN0YXRlLCBuZXdWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHBlZWtOb2RlSW5mbyhzdG9yZSwgc3RhdGUsIGtleSkge1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaChzdGF0ZS52ZXJzaW9uKTtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGUkMShrZXkpLm5vZGVUeXBlO1xuICByZXR1cm4gUmVjb2lsX2xhenlQcm94eSh7XG4gICAgdHlwZVxuICB9LCB7XG4gICAgbG9hZGFibGU6ICgpID0+IHBlZWtOb2RlTG9hZGFibGUoc3RvcmUsIHN0YXRlLCBrZXkpLFxuICAgIGlzQWN0aXZlOiAoKSA9PiBzdG9yZVN0YXRlLmtub3duQXRvbXMuaGFzKGtleSkgfHwgc3RvcmVTdGF0ZS5rbm93blNlbGVjdG9ycy5oYXMoa2V5KSxcbiAgICBpc1NldDogKCkgPT4gdHlwZSA9PT0gJ3NlbGVjdG9yJyA/IGZhbHNlIDogc3RhdGUuYXRvbVZhbHVlcy5oYXMoa2V5KSxcbiAgICBpc01vZGlmaWVkOiAoKSA9PiBzdGF0ZS5kaXJ0eUF0b21zLmhhcyhrZXkpLFxuICAgIC8vIFJlcG9ydCBjdXJyZW50IGRlcGVuZGVuY2llcy4gIElmIHRoZSBub2RlIGhhc24ndCBiZWVuIGV2YWx1YXRlZCwgdGhlblxuICAgIC8vIGRlcGVuZGVuY2llcyBtYXkgYmUgbWlzc2luZyBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICBkZXBzOiAoKSA9PiB7XG4gICAgICB2YXIgX2dyYXBoJG5vZGVEZXBzJGdldDtcblxuICAgICAgcmV0dXJuIHJlY29pbFZhbHVlc0ZvcktleXMkMSgoX2dyYXBoJG5vZGVEZXBzJGdldCA9IGdyYXBoLm5vZGVEZXBzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfZ3JhcGgkbm9kZURlcHMkZ2V0ICE9PSB2b2lkIDAgPyBfZ3JhcGgkbm9kZURlcHMkZ2V0IDogW10pO1xuICAgIH0sXG4gICAgLy8gUmVwb3J0cyBhbGwgXCJjdXJyZW50XCIgc3Vic2NyaWJlcnMuICBFdmFsdWF0aW5nIG90aGVyIG5vZGVzIG9yXG4gICAgLy8gcHJldmlvdXMgaW4tcHJvZ3Jlc3MgYXN5bmMgZXZhbHVhdGlvbnMgbWF5IGludHJvZHVjZSBuZXcgc3Vic2NyaWJlcnMuXG4gICAgc3Vic2NyaWJlcnM6ICgpID0+IHtcbiAgICAgIHZhciBfc3RvcmVTdGF0ZSRub2RlVG9Db20sIF9zdG9yZVN0YXRlJG5vZGVUb0NvbTI7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVzOiByZWNvaWxWYWx1ZXNGb3JLZXlzJDEoUmVjb2lsX2ZpbHRlckl0ZXJhYmxlKGdldERvd25zdHJlYW1Ob2RlcyhzdG9yZSwgc3RhdGUsIG5ldyBTZXQoW2tleV0pKSwgbm9kZUtleSA9PiBub2RlS2V5ICE9PSBrZXkpKSxcbiAgICAgICAgY29tcG9uZW50czogUmVjb2lsX21hcEl0ZXJhYmxlKChfc3RvcmVTdGF0ZSRub2RlVG9Db20gPSAoX3N0b3JlU3RhdGUkbm9kZVRvQ29tMiA9IHN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5nZXQoa2V5KSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkbm9kZVRvQ29tMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkbm9kZVRvQ29tMi52YWx1ZXMoKSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbm9kZVRvQ29tICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRub2RlVG9Db20gOiBbXSwgKFtuYW1lXSkgPT4gKHtcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH0pKVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufSAvLyBGaW5kIGFsbCBvZiB0aGUgcmVjdXJzaXZlbHkgZGVwZW5kZW50IG5vZGVzXG5cblxuZnVuY3Rpb24gZ2V0RG93bnN0cmVhbU5vZGVzKHN0b3JlLCBzdGF0ZSwga2V5cykge1xuICBjb25zdCB2aXNpdGVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IHZpc2l0aW5nTm9kZXMgPSBBcnJheS5mcm9tKGtleXMpO1xuICBjb25zdCBncmFwaCA9IHN0b3JlLmdldEdyYXBoKHN0YXRlLnZlcnNpb24pO1xuXG4gIGZvciAobGV0IGtleSA9IHZpc2l0aW5nTm9kZXMucG9wKCk7IGtleTsga2V5ID0gdmlzaXRpbmdOb2Rlcy5wb3AoKSkge1xuICAgIHZhciBfZ3JhcGgkbm9kZVRvTm9kZVN1YnM7XG5cbiAgICB2aXNpdGVkTm9kZXMuYWRkKGtleSk7XG4gICAgY29uc3Qgc3Vic2NyaWJlZE5vZGVzID0gKF9ncmFwaCRub2RlVG9Ob2RlU3VicyA9IGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgIT09IHZvaWQgMCA/IF9ncmFwaCRub2RlVG9Ob2RlU3VicyA6IGVtcHR5U2V0O1xuXG4gICAgZm9yIChjb25zdCBkb3duc3RyZWFtTm9kZSBvZiBzdWJzY3JpYmVkTm9kZXMpIHtcbiAgICAgIGlmICghdmlzaXRlZE5vZGVzLmhhcyhkb3duc3RyZWFtTm9kZSkpIHtcbiAgICAgICAgdmlzaXRpbmdOb2Rlcy5wdXNoKGRvd25zdHJlYW1Ob2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmlzaXRlZE5vZGVzO1xufVxuXG52YXIgUmVjb2lsX0Z1bmN0aW9uYWxDb3JlID0ge1xuICBnZXROb2RlTG9hZGFibGUsXG4gIHBlZWtOb2RlTG9hZGFibGUsXG4gIHNldE5vZGVWYWx1ZSxcbiAgaW5pdGlhbGl6ZU5vZGUsXG4gIGNsZWFuVXBOb2RlLFxuICBzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVELFxuICBwZWVrTm9kZUluZm8sXG4gIGdldERvd25zdHJlYW1Ob2Rlc1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxubGV0IF9pbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCA9IG51bGw7XG5cbmZ1bmN0aW9uIHNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90KGludmFsaWRhdGUpIHtcbiAgX2ludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90ID0gaW52YWxpZGF0ZTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QoKSB7XG4gIHZhciBfaW52YWxpZGF0ZU1lbW9pemVkU247XG5cbiAgKF9pbnZhbGlkYXRlTWVtb2l6ZWRTbiA9IF9pbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCkgPT09IG51bGwgfHwgX2ludmFsaWRhdGVNZW1vaXplZFNuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW52YWxpZGF0ZU1lbW9pemVkU24oKTtcbn1cblxudmFyIFJlY29pbF9TbmFwc2hvdENhY2hlID0ge1xuICBzZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCxcbiAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3Rcbn07XG5cbmNvbnN0IHtcbiAgZ2V0RG93bnN0cmVhbU5vZGVzOiBnZXREb3duc3RyZWFtTm9kZXMkMSxcbiAgZ2V0Tm9kZUxvYWRhYmxlOiBnZXROb2RlTG9hZGFibGUkMSxcbiAgc2V0Tm9kZVZhbHVlOiBzZXROb2RlVmFsdWUkMVxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICBnZXROZXh0Q29tcG9uZW50SUQ6IGdldE5leHRDb21wb25lbnRJRCQxXG59ID0gUmVjb2lsX0tleXM7XG5cbmNvbnN0IHtcbiAgZ2V0Tm9kZTogZ2V0Tm9kZSQyLFxuICBnZXROb2RlTWF5YmU6IGdldE5vZGVNYXliZSQyXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgRGVmYXVsdFZhbHVlOiBEZWZhdWx0VmFsdWUkMVxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDFcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xuXG5jb25zdCB7XG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkMSxcbiAgUmVjb2lsU3RhdGU6IFJlY29pbFN0YXRlJDEsXG4gIFJlY29pbFZhbHVlUmVhZE9ubHk6IFJlY29pbFZhbHVlUmVhZE9ubHkkMSxcbiAgaXNSZWNvaWxWYWx1ZTogaXNSZWNvaWxWYWx1ZSQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlJDE7XG5cbmNvbnN0IHtcbiAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3Q6IGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDFcbn0gPSBSZWNvaWxfU25hcHNob3RDYWNoZTtcblxuXG5cblxuXG5cblxuZnVuY3Rpb24gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlKHN0b3JlLCB7XG4gIGtleVxufSwgdHJlZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSkge1xuICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWUsIF9zdG9yZVN0YXRlJHByZXZpb3VzVDtcblxuICAvLyBSZWFkaW5nIGZyb20gYW4gb2xkZXIgdHJlZSBjYW4gY2F1c2UgYnVncyBiZWNhdXNlIHRoZSBkZXBlbmRlbmNpZXMgdGhhdCB3ZVxuICAvLyBkaXNjb3ZlciBkdXJpbmcgdGhlIHJlYWQgYXJlIGxvc3QuXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gIGlmICghKHRyZWVTdGF0ZS52ZXJzaW9uID09PSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlLnZlcnNpb24gfHwgdHJlZVN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkbmV4dFRyZWUudmVyc2lvbikgfHwgdHJlZVN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUID0gc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJHByZXZpb3VzVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNULnZlcnNpb24pKSkge1xuICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignVHJpZWQgdG8gcmVhZCBmcm9tIGEgZGlzY2FyZGVkIHRyZWUnKTtcbiAgfVxuXG4gIGNvbnN0IGxvYWRhYmxlID0gZ2V0Tm9kZUxvYWRhYmxlJDEoc3RvcmUsIHRyZWVTdGF0ZSwga2V5KTtcblxuICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgIGxvYWRhYmxlLmNvbnRlbnRzLmNhdGNoKCgpID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogSEFDSzogaW50ZXJjZXB0IHRocm93biBlcnJvciBoZXJlIHRvIHByZXZlbnQgYW4gdW5jYXVnaHQgcHJvbWlzZSBleGNlcHRpb24uIElkZWFsbHkgdGhpcyB3b3VsZCBoYXBwZW4gY2xvc2VyIHRvIHNlbGVjdG9yXG4gICAgICAgKiBleGVjdXRpb24gKHBlcmhhcHMgaW50cm9kdWNpbmcgYSBuZXcgRVJST1IgY2xhc3MgdG8gYmUgcmVzb2x2ZWQgYnkgYXN5bmMgc2VsZWN0b3JzIHRoYXQgYXJlIGluIGFuIGVycm9yIHN0YXRlKVxuICAgICAgICovXG4gICAgICByZXR1cm47XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbG9hZGFibGU7XG59XG5cbmZ1bmN0aW9uIGFwcGx5QXRvbVZhbHVlV3JpdGVzKGF0b21WYWx1ZXMsIHdyaXRlcykge1xuICBjb25zdCByZXN1bHQgPSBhdG9tVmFsdWVzLmNsb25lKCk7XG4gIHdyaXRlcy5mb3JFYWNoKCh2LCBrKSA9PiB7XG4gICAgaWYgKHYuc3RhdGUgPT09ICdoYXNWYWx1ZScgJiYgdi5jb250ZW50cyBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQxKSB7XG4gICAgICByZXN1bHQuZGVsZXRlKGspO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuc2V0KGssIHYpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHZhbHVlRnJvbVZhbHVlT3JVcGRhdGVyKHN0b3JlLCBzdGF0ZSwge1xuICBrZXlcbn0sIHZhbHVlT3JVcGRhdGVyKSB7XG4gIGlmICh0eXBlb2YgdmFsdWVPclVwZGF0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVcGRhdGVyIGZvcm06IHBhc3MgaW4gdGhlIGN1cnJlbnQgdmFsdWUuIFRocm93IGlmIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgLy8gaXMgdW5hdmFpbGFibGUgKG5hbWVseSB3aGVuIHVwZGF0aW5nIGFuIGFzeW5jIHNlbGVjdG9yIHRoYXQnc1xuICAgIC8vIHBlbmRpbmcgb3IgZXJyb3JlZCk6XG4gICAgY29uc3QgY3VycmVudCA9IGdldE5vZGVMb2FkYWJsZSQxKHN0b3JlLCBzdGF0ZSwga2V5KTtcblxuICAgIGlmIChjdXJyZW50LnN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGBUcmllZCB0byBzZXQgYXRvbSBvciBzZWxlY3RvciBcIiR7a2V5fVwiIHVzaW5nIGFuIHVwZGF0ZXIgZnVuY3Rpb24gd2hpbGUgdGhlIGN1cnJlbnQgc3RhdGUgaXMgcGVuZGluZywgdGhpcyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZC5gO1xuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKG1zZyk7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKG1zZyk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50LnN0YXRlID09PSAnaGFzRXJyb3InKSB7XG4gICAgICB0aHJvdyBjdXJyZW50LmNvbnRlbnRzO1xuICAgIH0gLy8gVCBpdHNlbGYgbWF5IGJlIGEgZnVuY3Rpb24sIHNvIG91ciByZWZpbmVtZW50IGlzIG5vdCBzdWZmaWNpZW50OlxuXG5cbiAgICByZXR1cm4gdmFsdWVPclVwZGF0ZXIoY3VycmVudC5jb250ZW50cyk7IC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZU9yVXBkYXRlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseUFjdGlvbihzdG9yZSwgc3RhdGUsIGFjdGlvbikge1xuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdzZXQnKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVjb2lsVmFsdWUsXG4gICAgICB2YWx1ZU9yVXBkYXRlclxuICAgIH0gPSBhY3Rpb247XG4gICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZUZyb21WYWx1ZU9yVXBkYXRlcihzdG9yZSwgc3RhdGUsIHJlY29pbFZhbHVlLCB2YWx1ZU9yVXBkYXRlcik7XG4gICAgY29uc3Qgd3JpdGVzID0gc2V0Tm9kZVZhbHVlJDEoc3RvcmUsIHN0YXRlLCByZWNvaWxWYWx1ZS5rZXksIG5ld1ZhbHVlKTtcblxuICAgIGZvciAoY29uc3QgW2tleSwgbG9hZGFibGVdIG9mIHdyaXRlcy5lbnRyaWVzKCkpIHtcbiAgICAgIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZShzdGF0ZSwga2V5LCBsb2FkYWJsZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFjdGlvbi50eXBlID09PSAnc2V0TG9hZGFibGUnKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVjb2lsVmFsdWU6IHtcbiAgICAgICAga2V5XG4gICAgICB9LFxuICAgICAgbG9hZGFibGVcbiAgICB9ID0gYWN0aW9uO1xuICAgIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZShzdGF0ZSwga2V5LCBsb2FkYWJsZSk7XG4gIH0gZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09ICdtYXJrTW9kaWZpZWQnKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVjb2lsVmFsdWU6IHtcbiAgICAgICAga2V5XG4gICAgICB9XG4gICAgfSA9IGFjdGlvbjtcbiAgICBzdGF0ZS5kaXJ0eUF0b21zLmFkZChrZXkpO1xuICB9IGVsc2UgaWYgKGFjdGlvbi50eXBlID09PSAnc2V0VW52YWxpZGF0ZWQnKSB7XG4gICAgdmFyIF9ub2RlJGludmFsaWRhdGU7XG5cbiAgICAvLyBXcml0ZSB2YWx1ZSBkaXJlY3RseSB0byBzdGF0ZSBieXBhc3NpbmcgdGhlIE5vZGUgaW50ZXJmYWNlIGFzIHRoZSBub2RlXG4gICAgLy8gZGVmaW5pdGlvbnMgbWF5IG5vdCBoYXZlIGJlZW4gbG9hZGVkIHlldCB3aGVuIHByb2Nlc3NpbmcgdGhlIGluaXRpYWwgc25hcHNob3QuXG4gICAgY29uc3Qge1xuICAgICAgcmVjb2lsVmFsdWU6IHtcbiAgICAgICAga2V5XG4gICAgICB9LFxuICAgICAgdW52YWxpZGF0ZWRWYWx1ZVxuICAgIH0gPSBhY3Rpb247XG4gICAgY29uc3Qgbm9kZSA9IGdldE5vZGVNYXliZSQyKGtleSk7XG4gICAgbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX25vZGUkaW52YWxpZGF0ZSA9IG5vZGUuaW52YWxpZGF0ZSkgPT09IG51bGwgfHwgX25vZGUkaW52YWxpZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkaW52YWxpZGF0ZS5jYWxsKG5vZGUsIHN0YXRlKTtcbiAgICBzdGF0ZS5hdG9tVmFsdWVzLmRlbGV0ZShrZXkpO1xuICAgIHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLnNldChrZXksIHVudmFsaWRhdGVkVmFsdWUpO1xuICAgIHN0YXRlLmRpcnR5QXRvbXMuYWRkKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKGBVbmtub3duIGFjdGlvbiAke2FjdGlvbi50eXBlfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZShzdGF0ZSwga2V5LCBsb2FkYWJsZSkge1xuICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScgJiYgbG9hZGFibGUuY29udGVudHMgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMSkge1xuICAgIHN0YXRlLmF0b21WYWx1ZXMuZGVsZXRlKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuYXRvbVZhbHVlcy5zZXQoa2V5LCBsb2FkYWJsZSk7XG4gIH1cblxuICBzdGF0ZS5kaXJ0eUF0b21zLmFkZChrZXkpO1xuICBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5kZWxldGUoa2V5KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlBY3Rpb25zVG9TdG9yZShzdG9yZSwgYWN0aW9ucykge1xuICBzdG9yZS5yZXBsYWNlU3RhdGUoc3RhdGUgPT4ge1xuICAgIGNvbnN0IG5ld1N0YXRlID0gY29weVRyZWVTdGF0ZShzdGF0ZSk7XG5cbiAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBhY3Rpb25zKSB7XG4gICAgICBhcHBseUFjdGlvbihzdG9yZSwgbmV3U3RhdGUsIGFjdGlvbik7XG4gICAgfVxuXG4gICAgaW52YWxpZGF0ZURvd25zdHJlYW1zKHN0b3JlLCBuZXdTdGF0ZSk7XG4gICAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMSgpO1xuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlT3JQZXJmb3JtU3RhdGVVcGRhdGUoc3RvcmUsIGFjdGlvbikge1xuICBpZiAoYmF0Y2hTdGFjay5sZW5ndGgpIHtcbiAgICBjb25zdCBhY3Rpb25zQnlTdG9yZSA9IGJhdGNoU3RhY2tbYmF0Y2hTdGFjay5sZW5ndGggLSAxXTtcbiAgICBsZXQgYWN0aW9ucyA9IGFjdGlvbnNCeVN0b3JlLmdldChzdG9yZSk7XG5cbiAgICBpZiAoIWFjdGlvbnMpIHtcbiAgICAgIGFjdGlvbnNCeVN0b3JlLnNldChzdG9yZSwgYWN0aW9ucyA9IFtdKTtcbiAgICB9XG5cbiAgICBhY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBhcHBseUFjdGlvbnNUb1N0b3JlKHN0b3JlLCBbYWN0aW9uXSk7XG4gIH1cbn1cblxuY29uc3QgYmF0Y2hTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBiYXRjaFN0YXJ0KCkge1xuICBjb25zdCBhY3Rpb25zQnlTdG9yZSA9IG5ldyBNYXAoKTtcbiAgYmF0Y2hTdGFjay5wdXNoKGFjdGlvbnNCeVN0b3JlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtzdG9yZSwgYWN0aW9uc10gb2YgYWN0aW9uc0J5U3RvcmUpIHtcbiAgICAgIGFwcGx5QWN0aW9uc1RvU3RvcmUoc3RvcmUsIGFjdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IHBvcHBlZCA9IGJhdGNoU3RhY2sucG9wKCk7XG5cbiAgICBpZiAocG9wcGVkICE9PSBhY3Rpb25zQnlTdG9yZSkge1xuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdJbmNvcnJlY3Qgb3JkZXIgb2YgYmF0Y2ggcG9wcGluZycpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29weVRyZWVTdGF0ZShzdGF0ZSkge1xuICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICBhdG9tVmFsdWVzOiBzdGF0ZS5hdG9tVmFsdWVzLmNsb25lKCksXG4gICAgbm9udmFsaWRhdGVkQXRvbXM6IHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmNsb25lKCksXG4gICAgZGlydHlBdG9tczogbmV3IFNldChzdGF0ZS5kaXJ0eUF0b21zKVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlRG93bnN0cmVhbXMoc3RvcmUsIHN0YXRlKSB7XG4gIC8vIEluZm9ybSBhbnkgbm9kZXMgdGhhdCB3ZXJlIGNoYW5nZWQgb3IgZG93bnN0cmVhbSBvZiBjaGFuZ2VzIHNvIHRoYXQgdGhleVxuICAvLyBjYW4gY2xlYXIgb3V0IGFueSBjYWNoZXMgYXMgbmVlZGVkIGR1ZSB0byB0aGUgdXBkYXRlOlxuICBjb25zdCBkb3duc3RyZWFtcyA9IGdldERvd25zdHJlYW1Ob2RlcyQxKHN0b3JlLCBzdGF0ZSwgc3RhdGUuZGlydHlBdG9tcyk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgZG93bnN0cmVhbXMpIHtcbiAgICB2YXIgX2dldE5vZGVNYXliZSwgX2dldE5vZGVNYXliZSRpbnZhbGlkO1xuXG4gICAgKF9nZXROb2RlTWF5YmUgPSBnZXROb2RlTWF5YmUkMihrZXkpKSA9PT0gbnVsbCB8fCBfZ2V0Tm9kZU1heWJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2dldE5vZGVNYXliZSRpbnZhbGlkID0gX2dldE5vZGVNYXliZS5pbnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfZ2V0Tm9kZU1heWJlJGludmFsaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXROb2RlTWF5YmUkaW52YWxpZC5jYWxsKF9nZXROb2RlTWF5YmUsIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRSZWNvaWxWYWx1ZShzdG9yZSwgcmVjb2lsVmFsdWUsIHZhbHVlT3JVcGRhdGVyKSB7XG4gIHF1ZXVlT3JQZXJmb3JtU3RhdGVVcGRhdGUoc3RvcmUsIHtcbiAgICB0eXBlOiAnc2V0JyxcbiAgICByZWNvaWxWYWx1ZSxcbiAgICB2YWx1ZU9yVXBkYXRlclxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0UmVjb2lsVmFsdWVMb2FkYWJsZShzdG9yZSwgcmVjb2lsVmFsdWUsIGxvYWRhYmxlKSB7XG4gIGlmIChsb2FkYWJsZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQxKSB7XG4gICAgcmV0dXJuIHNldFJlY29pbFZhbHVlKHN0b3JlLCByZWNvaWxWYWx1ZSwgbG9hZGFibGUpO1xuICB9XG5cbiAgcXVldWVPclBlcmZvcm1TdGF0ZVVwZGF0ZShzdG9yZSwge1xuICAgIHR5cGU6ICdzZXRMb2FkYWJsZScsXG4gICAgcmVjb2lsVmFsdWUsXG4gICAgbG9hZGFibGU6IGxvYWRhYmxlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZChzdG9yZSwgcmVjb2lsVmFsdWUpIHtcbiAgcXVldWVPclBlcmZvcm1TdGF0ZVVwZGF0ZShzdG9yZSwge1xuICAgIHR5cGU6ICdtYXJrTW9kaWZpZWQnLFxuICAgIHJlY29pbFZhbHVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlKHN0b3JlLCByZWNvaWxWYWx1ZSwgdW52YWxpZGF0ZWRWYWx1ZSkge1xuICBxdWV1ZU9yUGVyZm9ybVN0YXRlVXBkYXRlKHN0b3JlLCB7XG4gICAgdHlwZTogJ3NldFVudmFsaWRhdGVkJyxcbiAgICByZWNvaWxWYWx1ZSxcbiAgICB1bnZhbGlkYXRlZFZhbHVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmVUb1JlY29pbFZhbHVlKHN0b3JlLCB7XG4gIGtleVxufSwgY2FsbGJhY2ssIGNvbXBvbmVudERlYnVnTmFtZSA9IG51bGwpIHtcbiAgY29uc3Qgc3ViSUQgPSBnZXROZXh0Q29tcG9uZW50SUQkMSgpO1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICBpZiAoIXN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5oYXMoa2V5KSkge1xuICAgIHN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5zZXQoa2V5LCBuZXcgTWFwKCkpO1xuICB9XG5cbiAgUmVjb2lsX251bGx0aHJvd3Moc3RvcmVTdGF0ZS5ub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zLmdldChrZXkpKS5zZXQoc3ViSUQsIFtjb21wb25lbnREZWJ1Z05hbWUgIT09IG51bGwgJiYgY29tcG9uZW50RGVidWdOYW1lICE9PSB2b2lkIDAgPyBjb21wb25lbnREZWJ1Z05hbWUgOiAnPG5vdCBjYXB0dXJlZD4nLCBjYWxsYmFja10pOyAvLyBIYW5kbGUgdGhlIGNhc2UgdGhhdCwgZHVyaW5nIHRoZSBzYW1lIHRpY2sgdGhhdCB3ZSBhcmUgc3Vic2NyaWJpbmcsIGFuIGF0b21cbiAgLy8gaGFzIGJlZW4gdXBkYXRlZCBieSBzb21lIGVmZmVjdCBoYW5kbGVyLiBPdGhlcndpc2Ugd2Ugd2lsbCBtaXNzIHRoZSB1cGRhdGUuXG5cbiAgY29uc3QgbW9kZSA9IHJlYWN0TW9kZSQxKCk7XG5cbiAgaWYgKG1vZGUuZWFybHkgJiYgKG1vZGUubW9kZSA9PT0gJ0xFR0FDWScgfHwgbW9kZS5tb2RlID09PSAnTVVUQUJMRV9TT1VSQ0UnKSkge1xuICAgIGNvbnN0IG5leHRUcmVlID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZTtcblxuICAgIGlmIChuZXh0VHJlZSAmJiBuZXh0VHJlZS5kaXJ0eUF0b21zLmhhcyhrZXkpKSB7XG4gICAgICBjYWxsYmFjayhuZXh0VHJlZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZWxlYXNlOiAoKSA9PiB7XG4gICAgICBjb25zdCByZWxlYXNlU3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBjb25zdCBzdWJzID0gcmVsZWFzZVN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5nZXQoa2V5KTtcblxuICAgICAgaWYgKHN1YnMgPT09IHVuZGVmaW5lZCB8fCAhc3Vicy5oYXMoc3ViSUQpKSB7XG4gICAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbihgU3Vic2NyaXB0aW9uIG1pc3NpbmcgYXQgcmVsZWFzZSB0aW1lIGZvciBhdG9tICR7a2V5fS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWNvaWwuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3Vicy5kZWxldGUoc3ViSUQpO1xuXG4gICAgICBpZiAoc3Vicy5zaXplID09PSAwKSB7XG4gICAgICAgIHJlbGVhc2VTdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiByZWZyZXNoUmVjb2lsVmFsdWUoc3RvcmUsIHJlY29pbFZhbHVlKSB7XG4gIHZhciBfbm9kZSRjbGVhckNhY2hlO1xuXG4gIGNvbnN0IHtcbiAgICBjdXJyZW50VHJlZVxuICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3Qgbm9kZSA9IGdldE5vZGUkMihyZWNvaWxWYWx1ZS5rZXkpO1xuICAoX25vZGUkY2xlYXJDYWNoZSA9IG5vZGUuY2xlYXJDYWNoZSkgPT09IG51bGwgfHwgX25vZGUkY2xlYXJDYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkY2xlYXJDYWNoZS5jYWxsKG5vZGUsIHN0b3JlLCBjdXJyZW50VHJlZSk7XG59XG5cbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2UgPSB7XG4gIFJlY29pbFZhbHVlUmVhZE9ubHk6IFJlY29pbFZhbHVlUmVhZE9ubHkkMSxcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZTogQWJzdHJhY3RSZWNvaWxWYWx1ZSQxLFxuICBSZWNvaWxTdGF0ZTogUmVjb2lsU3RhdGUkMSxcbiAgZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlLFxuICBzZXRSZWNvaWxWYWx1ZSxcbiAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSxcbiAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQsXG4gIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUsXG4gIHN1YnNjcmliZVRvUmVjb2lsVmFsdWUsXG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkMSxcbiAgYXBwbHlBdG9tVmFsdWVXcml0ZXMsXG4gIC8vIFRPRE8gUmVtb3ZlIGV4cG9ydCB3aGVuIGRlcHJlY2F0aW5nIGluaXRpYWxTdG9yZVN0YXRlX0RFUFJFQ0FURUQgaW4gUmVjb2lsUm9vdFxuICBiYXRjaFN0YXJ0LFxuICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUsXG4gIGludmFsaWRhdGVEb3duc3RyZWFtcyxcbiAgY29weVRyZWVTdGF0ZSxcbiAgcmVmcmVzaFJlY29pbFZhbHVlXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBUaGUgc29tZVNldCgpIG1ldGhvZCB0ZXN0cyB3aGV0aGVyIHNvbWUgZWxlbWVudHMgaW4gdGhlIGdpdmVuIFNldCBwYXNzIHRoZVxuICogdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gc29tZVNldChzZXQsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGNvbnN0IGl0ZXJhdG9yID0gc2V0LmVudHJpZXMoKTtcbiAgbGV0IGN1cnJlbnQgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgd2hpbGUgKCFjdXJyZW50LmRvbmUpIHtcbiAgICBjb25zdCBlbnRyeSA9IGN1cnJlbnQudmFsdWU7XG5cbiAgICBpZiAoY2FsbGJhY2suY2FsbChjb250ZXh0LCBlbnRyeVsxXSwgZW50cnlbMF0sIHNldCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGN1cnJlbnQgPSBpdGVyYXRvci5uZXh0KCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBSZWNvaWxfc29tZVNldCA9IHNvbWVTZXQ7XG5cbmNvbnN0IHtcbiAgY2xlYW5VcE5vZGU6IGNsZWFuVXBOb2RlJDFcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGU6IGRlbGV0ZU5vZGVDb25maWdJZlBvc3NpYmxlJDEsXG4gIGdldE5vZGU6IGdldE5vZGUkM1xufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIFJldGVudGlvblpvbmU6IFJldGVudGlvblpvbmUkMlxufSA9IFJlY29pbF9SZXRlbnRpb25ab25lO1xuXG5cblxuXG5cblxuXG4gLy8gQ29tcG9uZW50cyB0aGF0IGFyZW4ndCBtb3VudGVkIGFmdGVyIHN1c3BlbmRpbmcgZm9yIHRoaXMgbG9uZyB3aWxsIGJlIGFzc3VtZWRcbi8vIHRvIGJlIGRpc2NhcmRlZCBhbmQgdGhlaXIgcmVzb3VyY2VzIHJlbGVhc2VkLlxuXG5cbmNvbnN0IFNVU1BFTlNFX1RJTUVPVVRfTVMgPSAxMjAwMDA7XG5jb25zdCBlbXB0eVNldCQxID0gbmV3IFNldCgpO1xuXG5mdW5jdGlvbiByZWxlYXNlUmV0YWluYWJsZXNOb3dPbkN1cnJlbnRUcmVlKHN0b3JlLCByZXRhaW5hYmxlcykge1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3QgdHJlZVN0YXRlID0gc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcblxuICBpZiAoc3RvcmVTdGF0ZS5uZXh0VHJlZSkge1xuICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbigncmVsZWFzZU5vZGVzTm93T25DdXJyZW50VHJlZSBzaG91bGQgb25seSBiZSBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhIGJhdGNoJyk7XG4gICAgcmV0dXJuOyAvLyBsZWFrIG1lbW9yeSByYXRoZXIgdGhhbiBlcmFzZSBzb21ldGhpbmcgdGhhdCdzIGFib3V0IHRvIGJlIHVzZWQuXG4gIH1cblxuICBjb25zdCBub2RlcyA9IG5ldyBTZXQoKTtcblxuICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcbiAgICBpZiAociBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMikge1xuICAgICAgZm9yIChjb25zdCBuIG9mIG5vZGVzUmV0YWluZWRCeVpvbmUoc3RvcmVTdGF0ZSwgcikpIHtcbiAgICAgICAgbm9kZXMuYWRkKG4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2Rlcy5hZGQocik7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVsZWFzYWJsZU5vZGVzID0gZmluZFJlbGVhc2FibGVOb2RlcyhzdG9yZSwgbm9kZXMpO1xuXG4gIGZvciAoY29uc3Qgbm9kZSBvZiByZWxlYXNhYmxlTm9kZXMpIHtcbiAgICByZWxlYXNlTm9kZShzdG9yZSwgdHJlZVN0YXRlLCBub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUmVsZWFzYWJsZU5vZGVzKHN0b3JlLCBzZWFyY2hGcm9tTm9kZXMpIHtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IHRyZWVTdGF0ZSA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG4gIGNvbnN0IGdyYXBoID0gc3RvcmUuZ2V0R3JhcGgodHJlZVN0YXRlLnZlcnNpb24pO1xuICBjb25zdCByZWxlYXNhYmxlTm9kZXMgPSBuZXcgU2V0KCk7IC8vIG11dGF0ZWQgdG8gY29sbGVjdCBhbnN3ZXJcblxuICBjb25zdCBub25SZWxlYXNhYmxlTm9kZXMgPSBuZXcgU2V0KCk7XG4gIGZpbmRSZWxlYXNhYmxlTm9kZXNJbm5lcihzZWFyY2hGcm9tTm9kZXMpO1xuICByZXR1cm4gcmVsZWFzYWJsZU5vZGVzO1xuXG4gIGZ1bmN0aW9uIGZpbmRSZWxlYXNhYmxlTm9kZXNJbm5lcihzZWFyY2hGcm9tTm9kZXMpIHtcbiAgICBjb25zdCByZWxlYXNhYmxlTm9kZXNGb3VuZFRoaXNJdGVyYXRpb24gPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgZG93bnN0cmVhbXMgPSBnZXREb3duc3RyZWFtTm9kZXNJblRvcG9sb2dpY2FsT3JkZXIoc3RvcmUsIHRyZWVTdGF0ZSwgc2VhcmNoRnJvbU5vZGVzLCByZWxlYXNhYmxlTm9kZXMsIC8vIGRvbid0IGRlc2NlbmQgaW50byB0aGVzZVxuICAgIG5vblJlbGVhc2FibGVOb2RlcyAvLyBkb24ndCBkZXNjZW5kIGludG8gdGhlc2VcbiAgICApOyAvLyBGaW5kIHdoaWNoIG9mIHRoZSBkb3duc3RyZWFtIG5vZGVzIGFyZSByZWxlYXNhYmxlIGFuZCB3aGljaCBhcmUgbm90OlxuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIGRvd25zdHJlYW1zKSB7XG4gICAgICB2YXIgX3N0b3JlU3RhdGUkcmV0ZW50aW9uO1xuXG4gICAgICAvLyBOb3QgcmVsZWFzYWJsZSBpZiBjb25maWd1cmVkIHRvIGJlIHJldGFpbmVkIGZvcmV2ZXI6XG4gICAgICBpZiAoZ2V0Tm9kZSQzKG5vZGUpLnJldGFpbmVkQnkgPT09ICdyZWNvaWxSb290Jykge1xuICAgICAgICBub25SZWxlYXNhYmxlTm9kZXMuYWRkKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gTm90IHJlbGVhc2FibGUgaWYgcmV0YWluZWQgZGlyZWN0bHkgYnkgYSBjb21wb25lbnQ6XG5cblxuICAgICAgaWYgKCgoX3N0b3JlU3RhdGUkcmV0ZW50aW9uID0gc3RvcmVTdGF0ZS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzLmdldChub2RlKSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkcmV0ZW50aW9uICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRyZXRlbnRpb24gOiAwKSA+IDApIHtcbiAgICAgICAgbm9uUmVsZWFzYWJsZU5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIE5vdCByZWxlYXNhYmxlIGlmIHJldGFpbmVkIGJ5IGEgem9uZTpcblxuXG4gICAgICBpZiAoem9uZXNUaGF0Q291bGRSZXRhaW5Ob2RlKG5vZGUpLnNvbWUoeiA9PiBzdG9yZVN0YXRlLnJldGVudGlvbi5yZWZlcmVuY2VDb3VudHMuZ2V0KHopKSkge1xuICAgICAgICBub25SZWxlYXNhYmxlTm9kZXMuYWRkKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gTm90IHJlbGVhc2FibGUgaWYgaXQgaGFzIGEgbm9uLXJlbGVhc2FibGUgY2hpbGQgKHdoaWNoIHdpbGwgYWxyZWFkeSBiZSBpblxuICAgICAgLy8gbm9uUmVsZWFzYWJsZU5vZGVzIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIGluIHRvcG9sb2dpY2FsIG9yZGVyKTpcblxuXG4gICAgICBjb25zdCBub2RlQ2hpbGRyZW4gPSBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQobm9kZSk7XG5cbiAgICAgIGlmIChub2RlQ2hpbGRyZW4gJiYgUmVjb2lsX3NvbWVTZXQobm9kZUNoaWxkcmVuLCBjaGlsZCA9PiBub25SZWxlYXNhYmxlTm9kZXMuaGFzKGNoaWxkKSkpIHtcbiAgICAgICAgbm9uUmVsZWFzYWJsZU5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJlbGVhc2FibGVOb2Rlcy5hZGQobm9kZSk7XG4gICAgICByZWxlYXNhYmxlTm9kZXNGb3VuZFRoaXNJdGVyYXRpb24uYWRkKG5vZGUpO1xuICAgIH0gLy8gSWYgd2UgZm91bmQgYW55IHJlbGVhc2FibGUgbm9kZXMsIHdlIG5lZWQgdG8gd2FsayBVUCBmcm9tIHRob3NlIG5vZGVzIHRvXG4gICAgLy8gZmluZCB3aGV0aGVyIHRoZWlyIHBhcmVudHMgY2FuIG5vdyBiZSByZWxlYXNlZCBhcyB3ZWxsOlxuXG5cbiAgICBjb25zdCBwYXJlbnRzID0gbmV3IFNldCgpO1xuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIHJlbGVhc2FibGVOb2Rlc0ZvdW5kVGhpc0l0ZXJhdGlvbikge1xuICAgICAgZm9yIChjb25zdCBwYXJlbnQgb2YgKF9ncmFwaCRub2RlRGVwcyRnZXQgPSBncmFwaC5ub2RlRGVwcy5nZXQobm9kZSkpICE9PSBudWxsICYmIF9ncmFwaCRub2RlRGVwcyRnZXQgIT09IHZvaWQgMCA/IF9ncmFwaCRub2RlRGVwcyRnZXQgOiBlbXB0eVNldCQxKSB7XG4gICAgICAgIHZhciBfZ3JhcGgkbm9kZURlcHMkZ2V0O1xuXG4gICAgICAgIGlmICghcmVsZWFzYWJsZU5vZGVzLmhhcyhwYXJlbnQpKSB7XG4gICAgICAgICAgcGFyZW50cy5hZGQocGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJlbnRzLnNpemUpIHtcbiAgICAgIGZpbmRSZWxlYXNhYmxlTm9kZXNJbm5lcihwYXJlbnRzKTtcbiAgICB9XG4gIH1cbn0gLy8gQ2hpbGRyZW4gYmVmb3JlIHBhcmVudHNcblxuXG5mdW5jdGlvbiBnZXREb3duc3RyZWFtTm9kZXNJblRvcG9sb2dpY2FsT3JkZXIoc3RvcmUsIHRyZWVTdGF0ZSwgbm9kZXMsIC8vIE11dGFibGUgc2V0IGlzIGRlc3Ryb3llZCBpbiBwbGFjZVxuZG9Ob3REZXNjZW5kSW50bzEsIGRvTm90RGVzY2VuZEludG8yKSB7XG4gIGNvbnN0IGdyYXBoID0gc3RvcmUuZ2V0R3JhcGgodHJlZVN0YXRlLnZlcnNpb24pO1xuICBjb25zdCBhbnN3ZXIgPSBbXTtcbiAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcblxuICB3aGlsZSAobm9kZXMuc2l6ZSA+IDApIHtcbiAgICB2aXNpdChSZWNvaWxfbnVsbHRocm93cyhub2Rlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWUpKTtcbiAgfVxuXG4gIHJldHVybiBhbnN3ZXI7XG5cbiAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xuICAgIGlmIChkb05vdERlc2NlbmRJbnRvMS5oYXMobm9kZSkgfHwgZG9Ob3REZXNjZW5kSW50bzIuaGFzKG5vZGUpKSB7XG4gICAgICBub2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZpc2l0ZWQuaGFzKG5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQobm9kZSk7XG5cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgdmlzaXQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgIG5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICBhbnN3ZXIucHVzaChub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWxlYXNlTm9kZShzdG9yZSwgdHJlZVN0YXRlLCBub2RlKSB7XG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBBdG9tIGVmZmVjdHMsIGluLWNsb3N1cmUgY2FjaGVzLCBldGMuOlxuXG5cbiAgY2xlYW5VcE5vZGUkMShzdG9yZSwgbm9kZSk7IC8vIERlbGV0ZSBmcm9tIHN0b3JlIHN0YXRlOlxuXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBzdG9yZVN0YXRlLmtub3duQXRvbXMuZGVsZXRlKG5vZGUpO1xuICBzdG9yZVN0YXRlLmtub3duU2VsZWN0b3JzLmRlbGV0ZShub2RlKTtcbiAgc3RvcmVTdGF0ZS5ub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLmRlbGV0ZShub2RlKTtcbiAgc3RvcmVTdGF0ZS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzLmRlbGV0ZShub2RlKTtcbiAgY29uc3Qgem9uZXMgPSB6b25lc1RoYXRDb3VsZFJldGFpbk5vZGUobm9kZSk7XG5cbiAgZm9yIChjb25zdCB6b25lIG9mIHpvbmVzKSB7XG4gICAgdmFyIF9zdG9yZVN0YXRlJHJldGVudGlvbjI7XG5cbiAgICAoX3N0b3JlU3RhdGUkcmV0ZW50aW9uMiA9IHN0b3JlU3RhdGUucmV0ZW50aW9uLm5vZGVzUmV0YWluZWRCeVpvbmUuZ2V0KHpvbmUpKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRyZXRlbnRpb24yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRyZXRlbnRpb24yLmRlbGV0ZShub2RlKTtcbiAgfSAvLyBOb3RlIHRoYXQgd2UgRE8gTk9UIGRlbGV0ZSBmcm9tIG5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMgYmVjYXVzZSB0aGlzXG4gIC8vIGFscmVhZHkgaGFwcGVucyB3aGVuIHRoZSBsYXN0IGNvbXBvbmVudCB0aGF0IHdhcyByZXRhaW5pbmcgdGhlIG5vZGUgdW5tb3VudHMsXG4gIC8vIGFuZCB0aGlzIGNvdWxkIGhhcHBlbiBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoYXQuXG4gIC8vIERlbGV0ZSBmcm9tIFRyZWVTdGF0ZSBhbmQgZGVwIGdyYXBoOlxuXG5cbiAgdHJlZVN0YXRlLmF0b21WYWx1ZXMuZGVsZXRlKG5vZGUpO1xuICB0cmVlU3RhdGUuZGlydHlBdG9tcy5kZWxldGUobm9kZSk7XG4gIHRyZWVTdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5kZWxldGUobm9kZSk7XG4gIGNvbnN0IGdyYXBoID0gc3RvcmVTdGF0ZS5ncmFwaHNCeVZlcnNpb24uZ2V0KHRyZWVTdGF0ZS52ZXJzaW9uKTtcblxuICBpZiAoZ3JhcGgpIHtcbiAgICBjb25zdCBkZXBzID0gZ3JhcGgubm9kZURlcHMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKGRlcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZ3JhcGgubm9kZURlcHMuZGVsZXRlKG5vZGUpO1xuXG4gICAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XG4gICAgICAgIHZhciBfZ3JhcGgkbm9kZVRvTm9kZVN1YnM7XG5cbiAgICAgICAgKF9ncmFwaCRub2RlVG9Ob2RlU3VicyA9IGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChkZXApKSA9PT0gbnVsbCB8fCBfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ncmFwaCRub2RlVG9Ob2RlU3Vicy5kZWxldGUobm9kZSk7XG4gICAgICB9XG4gICAgfSAvLyBObyBuZWVkIHRvIGRlbGV0ZSBzdWIncyBkZXBzIGFzIHRoZXJlIHNob3VsZCBiZSBubyBzdWJzIGF0IHRoaXMgcG9pbnQuXG4gICAgLy8gQnV0IGFuIGludmFyaWFudCB3b3VsZCByZXF1aXJlIGRlbGV0aW5nIG5vZGVzIGluIHRvcG9sb2dpY2FsIG9yZGVyLlxuXG5cbiAgICBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5kZWxldGUobm9kZSk7XG4gIH0gLy8gTm9kZSBjb25maWcgKGZvciBmYW1pbHkgbWVtYmVycyBvbmx5IGFzIHRoZWlyIGNvbmZpZ3MgY2FuIGJlIHJlY3JlYXRlZCwgYW5kXG4gIC8vIG9ubHkgaWYgdGhleSBhcmUgbm90IHJldGFpbmVkIHdpdGhpbiBhbnkgb3RoZXIgU3RvcmVzKTpcblxuXG4gIGRlbGV0ZU5vZGVDb25maWdJZlBvc3NpYmxlJDEobm9kZSk7XG59XG5cbmZ1bmN0aW9uIG5vZGVzUmV0YWluZWRCeVpvbmUoc3RvcmVTdGF0ZSwgem9uZSkge1xuICB2YXIgX3N0b3JlU3RhdGUkcmV0ZW50aW9uMztcblxuICByZXR1cm4gKF9zdG9yZVN0YXRlJHJldGVudGlvbjMgPSBzdG9yZVN0YXRlLnJldGVudGlvbi5ub2Rlc1JldGFpbmVkQnlab25lLmdldCh6b25lKSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkcmV0ZW50aW9uMyAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkcmV0ZW50aW9uMyA6IGVtcHR5U2V0JDE7XG59XG5cbmZ1bmN0aW9uIHpvbmVzVGhhdENvdWxkUmV0YWluTm9kZShub2RlKSB7XG4gIGNvbnN0IHJldGFpbmVkQnkgPSBnZXROb2RlJDMobm9kZSkucmV0YWluZWRCeTtcblxuICBpZiAocmV0YWluZWRCeSA9PT0gdW5kZWZpbmVkIHx8IHJldGFpbmVkQnkgPT09ICdjb21wb25lbnRzJyB8fCByZXRhaW5lZEJ5ID09PSAncmVjb2lsUm9vdCcpIHtcbiAgICByZXR1cm4gW107XG4gIH0gZWxzZSBpZiAocmV0YWluZWRCeSBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMikge1xuICAgIHJldHVybiBbcmV0YWluZWRCeV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJldGFpbmVkQnk7IC8vIGl0J3MgYW4gYXJyYXkgb2Ygem9uZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZU9yUGVyZm9ybVBvc3NpYmxlUmVsZWFzZU9mUmV0YWluYWJsZShzdG9yZSwgcmV0YWluYWJsZSkge1xuICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgaWYgKHN0YXRlLm5leHRUcmVlKSB7XG4gICAgc3RhdGUucmV0ZW50aW9uLnJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2UuYWRkKHJldGFpbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHJlbGVhc2VSZXRhaW5hYmxlc05vd09uQ3VycmVudFRyZWUoc3RvcmUsIG5ldyBTZXQoW3JldGFpbmFibGVdKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUmV0YWluQ291bnQoc3RvcmUsIHJldGFpbmFibGUsIGRlbHRhKSB7XG4gIHZhciBfbWFwJGdldDtcblxuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBtYXAgPSBzdG9yZS5nZXRTdGF0ZSgpLnJldGVudGlvbi5yZWZlcmVuY2VDb3VudHM7XG4gIGNvbnN0IG5ld0NvdW50ID0gKChfbWFwJGdldCA9IG1hcC5nZXQocmV0YWluYWJsZSkpICE9PSBudWxsICYmIF9tYXAkZ2V0ICE9PSB2b2lkIDAgPyBfbWFwJGdldCA6IDApICsgZGVsdGE7XG5cbiAgaWYgKG5ld0NvdW50ID09PSAwKSB7XG4gICAgdXBkYXRlUmV0YWluQ291bnRUb1plcm8oc3RvcmUsIHJldGFpbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIG1hcC5zZXQocmV0YWluYWJsZSwgbmV3Q291bnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJldGFpbkNvdW50VG9aZXJvKHN0b3JlLCByZXRhaW5hYmxlKSB7XG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG1hcCA9IHN0b3JlLmdldFN0YXRlKCkucmV0ZW50aW9uLnJlZmVyZW5jZUNvdW50cztcbiAgbWFwLmRlbGV0ZShyZXRhaW5hYmxlKTtcbiAgc2NoZWR1bGVPclBlcmZvcm1Qb3NzaWJsZVJlbGVhc2VPZlJldGFpbmFibGUoc3RvcmUsIHJldGFpbmFibGUpO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3coc3RvcmUpIHtcbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICByZWxlYXNlUmV0YWluYWJsZXNOb3dPbkN1cnJlbnRUcmVlKHN0b3JlLCBzdGF0ZS5yZXRlbnRpb24ucmV0YWluYWJsZXNUb0NoZWNrRm9yUmVsZWFzZSk7XG4gIHN0YXRlLnJldGVudGlvbi5yZXRhaW5hYmxlc1RvQ2hlY2tGb3JSZWxlYXNlLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdChyKSB7XG4gIC8vIFRoZSBkZWZhdWx0IHdpbGwgY2hhbmdlIGZyb20gJ3JlY29pbFJvb3QnIHRvICdjb21wb25lbnRzJyBpbiB0aGUgZnV0dXJlLlxuICByZXR1cm4gciA9PT0gdW5kZWZpbmVkID8gJ3JlY29pbFJvb3QnIDogcjtcbn1cblxudmFyIFJlY29pbF9SZXRlbnRpb24gPSB7XG4gIFNVU1BFTlNFX1RJTUVPVVRfTVMsXG4gIHVwZGF0ZVJldGFpbkNvdW50LFxuICB1cGRhdGVSZXRhaW5Db3VudFRvWmVybyxcbiAgcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93LFxuICByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHRcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogVGhpcyBpcyB0byBleHBvcnQgZXNzdGllbnRpYWwgZnVuY3Rpb25zIGZyb20gcmVhY3QtZG9tXG4gKiBmb3Igb3VyIHdlYiBidWlsZFxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuY29uc3Qge1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlc1xufSA9IHJlYWN0RG9tO1xuXG52YXIgUmVhY3RCYXRjaGVkVXBkYXRlcyA9IHtcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXNcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogVGhpcyBpcyB0byBleHBvcnQgZXNzdGllbnRpYWwgZnVuY3Rpb25zIGZyb20gcmVhY3QtZG9tXG4gKiBmb3Igb3VyIHdlYiBidWlsZFxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLy8gQGZiLW9ubHk6IGNvbnN0IHt1bnN0YWJsZV9iYXRjaGVkVXBkYXRlc30gPSByZXF1aXJlKCdSZWFjdERPTUNvbWV0Jyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHtcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDFcbn0gPSBSZWFjdEJhdGNoZWRVcGRhdGVzOyAvLyBAb3NzLW9ubHlcblxuXG52YXIgUmVjb2lsX1JlYWN0QmF0Y2hlZFVwZGF0ZXMgPSB7XG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQxXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuY29uc3Qge1xuICBiYXRjaFN0YXJ0OiBiYXRjaFN0YXJ0JDFcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XG5cbmNvbnN0IHtcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDJcbn0gPSBSZWNvaWxfUmVhY3RCYXRjaGVkVXBkYXRlcztcblxubGV0IGJhdGNoZXIgPSB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQyOyAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG4vKipcbiAqIFNldHMgdGhlIHByb3ZpZGVkIGJhdGNoZXIgZnVuY3Rpb24gYXMgdGhlIGJhdGNoZXIgZnVuY3Rpb24gdXNlZCBieSBSZWNvaWwuXG4gKlxuICogU2V0IHRoZSBiYXRjaGVyIHRvIGEgY3VzdG9tIGJhdGNoZXIgZm9yIHlvdXIgcmVuZGVyZXIsXG4gKiBpZiB5b3UgdXNlIGEgcmVuZGVyZXIgb3RoZXIgdGhhbiBSZWFjdCBET00gb3IgUmVhY3QgTmF0aXZlLlxuICovXG5jb25zdCBzZXRCYXRjaGVyID0gbmV3QmF0Y2hlciA9PiB7XG4gIGJhdGNoZXIgPSBuZXdCYXRjaGVyO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBiYXRjaGVyIGZ1bmN0aW9uLlxuICovXG5cblxuY29uc3QgZ2V0QmF0Y2hlciA9ICgpID0+IGJhdGNoZXI7XG4vKipcbiAqIENhbGxzIHRoZSBjdXJyZW50IGJhdGNoZXIgZnVuY3Rpb24gYW5kIHBhc3NlcyB0aGVcbiAqIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5cblxuY29uc3QgYmF0Y2hVcGRhdGVzID0gY2FsbGJhY2sgPT4ge1xuICBiYXRjaGVyKCgpID0+IHtcbiAgICBsZXQgYmF0Y2hFbmQgPSAoKSA9PiB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgYmF0Y2hFbmQgPSBiYXRjaFN0YXJ0JDEoKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGJhdGNoRW5kKCk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBSZWNvaWxfQmF0Y2hpbmcgPSB7XG4gIGdldEJhdGNoZXIsXG4gIHNldEJhdGNoZXIsXG4gIGJhdGNoVXBkYXRlc1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogQ29tYmluZXMgbXVsdGlwbGUgSXRlcmFibGVzIGludG8gYSBzaW5nbGUgSXRlcmFibGUuXG4gKiBUcmF2ZXJzZXMgdGhlIGlucHV0IEl0ZXJhYmxlcyBpbiB0aGUgb3JkZXIgcHJvdmlkZWQgYW5kIG1haW50YWlucyB0aGUgb3JkZXJcbiAqIG9mIHRoZWlyIGVsZW1lbnRzLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBcbiAqIGNvbnN0IHIgPSBBcnJheS5mcm9tKGNvbmNhdEl0ZXJhYmxlcyhbJ2EnLCAnYiddLCBbJ2MnXSwgWydkJywgJ2UnLCAnZiddKSk7XG4gKiByID09IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnXTtcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uKiBjb25jYXRJdGVyYWJsZXMoaXRlcnMpIHtcbiAgZm9yIChjb25zdCBpdGVyIG9mIGl0ZXJzKSB7XG4gICAgZm9yIChjb25zdCB2YWwgb2YgaXRlcikge1xuICAgICAgeWllbGQgdmFsO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVjb2lsX2NvbmNhdEl0ZXJhYmxlcyA9IGNvbmNhdEl0ZXJhYmxlcztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbmNvbnN0IGlzU1NSID0gLy8gJEZsb3dGaXhNZShzaXRlPXJlY29pbCkgV2luZG93IGRvZXMgbm90IGhhdmUgYSBGbG93VHlwZSBkZWZpbml0aW9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy82NzA5XG50eXBlb2YgV2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbi8qIGVzbGludC1lbmFibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuY29uc3QgaXNXaW5kb3cgPSB2YWx1ZSA9PiAhaXNTU1IgJiYgKCAvLyAkRmxvd0ZpeE1lKHNpdGU9cmVjb2lsKSBXaW5kb3cgZG9lcyBub3QgaGF2ZSBhIEZsb3dUeXBlIGRlZmluaXRpb24gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzY3MDlcbnZhbHVlID09PSB3aW5kb3cgfHwgdmFsdWUgaW5zdGFuY2VvZiBXaW5kb3cpO1xuXG5jb25zdCBpc1JlYWN0TmF0aXZlID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZSc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZmItd3d3L3R5cGVvZi11bmRlZmluZWRcblxudmFyIFJlY29pbF9FbnZpcm9ubWVudCA9IHtcbiAgaXNTU1IsXG4gIGlzUmVhY3ROYXRpdmUsXG4gIGlzV2luZG93XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBDYWNoZXMgYSBmdW5jdGlvbidzIHJlc3VsdHMgYmFzZWQgb24gdGhlIGtleSByZXR1cm5lZCBieSB0aGUgcGFzc2VkXG4gKiBoYXNoRnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZVdpdGhBcmdzSGFzaChmbiwgaGFzaEZ1bmN0aW9uKSB7XG4gIGxldCBjYWNoZTtcblxuICBjb25zdCBtZW1vaXplZEZuID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoIWNhY2hlKSB7XG4gICAgICBjYWNoZSA9IHt9O1xuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IGhhc2hGdW5jdGlvbiguLi5hcmdzKTtcblxuICAgIGlmICghT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGtleSkpIHtcbiAgICAgIGNhY2hlW2tleV0gPSBmbiguLi5hcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVba2V5XTtcbiAgfTtcblxuICByZXR1cm4gbWVtb2l6ZWRGbjtcbn1cbi8qKlxuICogQ2FjaGVzIGEgZnVuY3Rpb24ncyByZXN1bHRzIGJhc2VkIG9uIGEgY29tcGFyaXNvbiBvZiB0aGUgYXJndW1lbnRzLlxuICogT25seSBjYWNoZXMgdGhlIGxhc3QgcmV0dXJuIG9mIHRoZSBmdW5jdGlvbi5cbiAqIERlZmF1bHRzIHRvIHJlZmVyZW5jZSBlcXVhbGl0eVxuICovXG5cblxuZnVuY3Rpb24gbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaChmbiwgaGFzaEZ1bmN0aW9uKSB7XG4gIGxldCBsYXN0S2V5O1xuICBsZXQgbGFzdFJlc3VsdDsgLy8gYnJlYWtpbmcgY2FjaGUgd2hlbiBhcmd1bWVudHMgY2hhbmdlXG5cbiAgY29uc3QgbWVtb2l6ZWRGbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaGFzaEZ1bmN0aW9uKC4uLmFyZ3MpO1xuXG4gICAgaWYgKGxhc3RLZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfVxuXG4gICAgbGFzdEtleSA9IGtleTtcbiAgICBsYXN0UmVzdWx0ID0gZm4oLi4uYXJncyk7XG4gICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIG1lbW9pemVkRm47XG59XG4vKipcbiAqIENhY2hlcyBhIGZ1bmN0aW9uJ3MgcmVzdWx0cyBiYXNlZCBvbiBhIGNvbXBhcmlzb24gb2YgdGhlIGFyZ3VtZW50cy5cbiAqIE9ubHkgY2FjaGVzIHRoZSBsYXN0IHJldHVybiBvZiB0aGUgZnVuY3Rpb24uXG4gKiBEZWZhdWx0cyB0byByZWZlcmVuY2UgZXF1YWxpdHlcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb24oZm4sIGhhc2hGdW5jdGlvbikge1xuICBsZXQgbGFzdEtleTtcbiAgbGV0IGxhc3RSZXN1bHQ7IC8vIGJyZWFraW5nIGNhY2hlIHdoZW4gYXJndW1lbnRzIGNoYW5nZVxuXG4gIGNvbnN0IG1lbW9pemVkRm4gPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGhhc2hGdW5jdGlvbiguLi5hcmdzKTtcblxuICAgIGlmIChsYXN0S2V5ID09PSBrZXkpIHtcbiAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgIH1cblxuICAgIGxhc3RLZXkgPSBrZXk7XG4gICAgbGFzdFJlc3VsdCA9IGZuKC4uLmFyZ3MpO1xuICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICB9O1xuXG4gIGNvbnN0IGludmFsaWRhdGUgPSAoKSA9PiB7XG4gICAgbGFzdEtleSA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFttZW1vaXplZEZuLCBpbnZhbGlkYXRlXTtcbn1cblxudmFyIFJlY29pbF9NZW1vaXplID0ge1xuICBtZW1vaXplV2l0aEFyZ3NIYXNoLFxuICBtZW1vaXplT25lV2l0aEFyZ3NIYXNoLFxuICBtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uXG59O1xuXG5jb25zdCB7XG4gIGJhdGNoVXBkYXRlczogYmF0Y2hVcGRhdGVzJDFcbn0gPSBSZWNvaWxfQmF0Y2hpbmc7XG5cbmNvbnN0IHtcbiAgaW5pdGlhbGl6ZU5vZGU6IGluaXRpYWxpemVOb2RlJDEsXG4gIHBlZWtOb2RlSW5mbzogcGVla05vZGVJbmZvJDFcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgZ3JhcGg6IGdyYXBoJDFcbn0gPSBSZWNvaWxfR3JhcGg7XG5cbmNvbnN0IHtcbiAgZ2V0TmV4dFN0b3JlSUQ6IGdldE5leHRTdG9yZUlEJDFcbn0gPSBSZWNvaWxfS2V5cztcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDEsXG4gIHJlY29pbFZhbHVlczogcmVjb2lsVmFsdWVzJDEsXG4gIHJlY29pbFZhbHVlc0ZvcktleXM6IHJlY29pbFZhbHVlc0ZvcktleXMkMlxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkMixcbiAgZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlOiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMSxcbiAgc2V0UmVjb2lsVmFsdWU6IHNldFJlY29pbFZhbHVlJDEsXG4gIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWU6IHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuY29uc3Qge1xuICB1cGRhdGVSZXRhaW5Db3VudDogdXBkYXRlUmV0YWluQ291bnQkMVxufSA9IFJlY29pbF9SZXRlbnRpb247XG5cbmNvbnN0IHtcbiAgc2V0SW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3Q6IHNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDFcbn0gPSBSZWNvaWxfU25hcHNob3RDYWNoZTtcblxuY29uc3Qge1xuICBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbjogZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMixcbiAgbWFrZUVtcHR5U3RvcmVTdGF0ZTogbWFrZUVtcHR5U3RvcmVTdGF0ZSQxXG59ID0gUmVjb2lsX1N0YXRlO1xuXG5cblxuY29uc3Qge1xuICBpc1NTUjogaXNTU1IkMVxufSA9IFJlY29pbF9FbnZpcm9ubWVudDtcblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IHtcbiAgbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaEFuZEludmFsaWRhdGlvbjogbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaEFuZEludmFsaWRhdGlvbiQxXG59ID0gUmVjb2lsX01lbW9pemU7XG5cblxuXG4gLy8gT3BhcXVlIGF0IHRoaXMgc3VyZmFjZSBiZWNhdXNlIGl0J3MgcGFydCBvZiB0aGUgcHVibGljIEFQSSBmcm9tIGhlcmUuXG5cblxuY29uc3QgcmV0YWluV2FybmluZyA9IGBcblJlY29pbCBTbmFwc2hvdHMgb25seSBsYXN0IGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGNhbGxiYWNrIHRoZXkgYXJlIHByb3ZpZGVkIHRvLiBUbyBrZWVwIGEgU25hcHNob3QgbG9uZ2VyLCBkbyB0aGlzOlxuXG4gIGNvbnN0IHJlbGVhc2UgPSBzbmFwc2hvdC5yZXRhaW4oKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBkb1NvbWV0aGluZ1dpdGhTbmFwc2hvdChzbmFwc2hvdCk7XG4gIH0gZmluYWxseSB7XG4gICAgcmVsZWFzZSgpO1xuICB9XG5cblRoaXMgaXMgY3VycmVudGx5IGEgREVWLW9ubHkgd2FybmluZyBidXQgd2lsbCBiZWNvbWUgYSB0aHJvd24gZXhjZXB0aW9uIGluIHRoZSBuZXh0IHJlbGVhc2Ugb2YgUmVjb2lsLlxuYDsgLy8gQSBcIlNuYXBzaG90XCIgaXMgXCJyZWFkLW9ubHlcIiBhbmQgY2FwdHVyZXMgYSBzcGVjaWZpYyBzZXQgb2YgdmFsdWVzIG9mIGF0b21zLlxuLy8gSG93ZXZlciwgdGhlIGRhdGEtZmxvdy1ncmFwaCBhbmQgc2VsZWN0b3IgdmFsdWVzIG1heSBldm9sdmUgYXMgc2VsZWN0b3Jcbi8vIGV2YWx1YXRpb24gZnVuY3Rpb25zIGFyZSBleGVjdXRlZCBhbmQgYXN5bmMgc2VsZWN0b3JzIHJlc29sdmUuXG5cbmNsYXNzIFNuYXBzaG90IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9uby11bmluaXRpYWxpemVkLXByb3BlcnRpZXNcbiAgY29uc3RydWN0b3Ioc3RvcmVTdGF0ZSwgcGFyZW50U3RvcmVJRCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdG9yZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3JlZkNvdW50XCIsIDEpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0TG9hZGFibGVcIiwgcmVjb2lsVmFsdWUgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICByZXR1cm4gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDEodGhpcy5fc3RvcmUsIHJlY29pbFZhbHVlKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFByb21pc2VcIiwgcmVjb2lsVmFsdWUgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRMb2FkYWJsZShyZWNvaWxWYWx1ZSkudG9Qcm9taXNlKCk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXROb2Rlc19VTlNUQUJMRVwiLCBvcHQgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7IC8vIFRPRE8gRGVhbCB3aXRoIG1vZGlmaWVkIHNlbGVjdG9yc1xuXG4gICAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5pc01vZGlmaWVkKSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5pc0luaXRpYWxpemVkKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XG5cbiAgICAgICAgcmV0dXJuIHJlY29pbFZhbHVlc0ZvcktleXMkMihzdGF0ZS5kaXJ0eUF0b21zKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga25vd25BdG9tcyA9IHRoaXMuX3N0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcztcblxuICAgICAgY29uc3Qga25vd25TZWxlY3RvcnMgPSB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmtub3duU2VsZWN0b3JzO1xuXG4gICAgICByZXR1cm4gKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5pc0luaXRpYWxpemVkKSA9PSBudWxsID8gcmVjb2lsVmFsdWVzJDEudmFsdWVzKCkgOiBvcHQuaXNJbml0aWFsaXplZCA9PT0gdHJ1ZSA/IHJlY29pbFZhbHVlc0ZvcktleXMkMihSZWNvaWxfY29uY2F0SXRlcmFibGVzKFtrbm93bkF0b21zLCBrbm93blNlbGVjdG9yc10pKSA6IFJlY29pbF9maWx0ZXJJdGVyYWJsZShyZWNvaWxWYWx1ZXMkMS52YWx1ZXMoKSwgKHtcbiAgICAgICAga2V5XG4gICAgICB9KSA9PiAha25vd25BdG9tcy5oYXMoa2V5KSAmJiAha25vd25TZWxlY3RvcnMuaGFzKGtleSkpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0SW5mb19VTlNUQUJMRVwiLCAoe1xuICAgICAga2V5XG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICByZXR1cm4gcGVla05vZGVJbmZvJDEodGhpcy5fc3RvcmUsIHRoaXMuX3N0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUsIGtleSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXBcIiwgbWFwcGVyID0+IHtcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xuICAgICAgY29uc3QgbXV0YWJsZVNuYXBzaG90ID0gbmV3IE11dGFibGVTbmFwc2hvdCh0aGlzLCBiYXRjaFVwZGF0ZXMkMSk7XG4gICAgICBtYXBwZXIobXV0YWJsZVNuYXBzaG90KTsgLy8gaWYgcmVtb3ZpbmcgYmF0Y2hVcGRhdGVzIGZyb20gYHNldGAgYWRkIGl0IGhlcmVcblxuICAgICAgcmV0dXJuIG11dGFibGVTbmFwc2hvdDtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFzeW5jTWFwXCIsIGFzeW5jIG1hcHBlciA9PiB7XG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICAgIGNvbnN0IG11dGFibGVTbmFwc2hvdCA9IG5ldyBNdXRhYmxlU25hcHNob3QodGhpcywgYmF0Y2hVcGRhdGVzJDEpO1xuICAgICAgbXV0YWJsZVNuYXBzaG90LnJldGFpbigpOyAvLyBSZXRhaW4gbmV3IHNuYXBzaG90IGR1cmluZyBhc3luYyBtYXBwZXJcblxuICAgICAgYXdhaXQgbWFwcGVyKG11dGFibGVTbmFwc2hvdCk7IC8vIENvbnRpbnVlIHRvIHJldGFpbiB0aGUgbmV3IHNuYXBzaG90IGZvciB0aGUgdXNlciwgYnV0IGF1dG8tcmVsZWFzZSBpdFxuICAgICAgLy8gYWZ0ZXIgdGhlIG5leHQgdGljaywgdGhlIHNhbWUgYXMgYSBuZXcgc3luY2hyb25vdXMgc25hcHNob3QuXG5cbiAgICAgIG11dGFibGVTbmFwc2hvdC5hdXRvUmVsZWFzZV9JTlRFUk5BTCgpO1xuICAgICAgcmV0dXJuIG11dGFibGVTbmFwc2hvdDtcbiAgICB9KTtcblxuICAgIHRoaXMuX3N0b3JlID0ge1xuICAgICAgc3RvcmVJRDogZ2V0TmV4dFN0b3JlSUQkMSgpLFxuICAgICAgcGFyZW50U3RvcmVJRCxcbiAgICAgIGdldFN0YXRlOiAoKSA9PiBzdG9yZVN0YXRlLFxuICAgICAgcmVwbGFjZVN0YXRlOiByZXBsYWNlciA9PiB7XG4gICAgICAgIC8vIG5vIGJhdGNoaW5nLCBzbyBuZXh0VHJlZSBpcyBuZXZlciBhY3RpdmVcbiAgICAgICAgc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA9IHJlcGxhY2VyKHN0b3JlU3RhdGUuY3VycmVudFRyZWUpO1xuICAgICAgfSxcbiAgICAgIGdldEdyYXBoOiB2ZXJzaW9uID0+IHtcbiAgICAgICAgY29uc3QgZ3JhcGhzID0gc3RvcmVTdGF0ZS5ncmFwaHNCeVZlcnNpb247XG5cbiAgICAgICAgaWYgKGdyYXBocy5oYXModmVyc2lvbikpIHtcbiAgICAgICAgICByZXR1cm4gUmVjb2lsX251bGx0aHJvd3MoZ3JhcGhzLmdldCh2ZXJzaW9uKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdHcmFwaCA9IGdyYXBoJDEoKTtcbiAgICAgICAgZ3JhcGhzLnNldCh2ZXJzaW9uLCBuZXdHcmFwaCk7XG4gICAgICAgIHJldHVybiBuZXdHcmFwaDtcbiAgICAgIH0sXG4gICAgICBzdWJzY3JpYmVUb1RyYW5zYWN0aW9uczogKCkgPT4gKHtcbiAgICAgICAgcmVsZWFzZTogKCkgPT4ge31cbiAgICAgIH0pLFxuICAgICAgYWRkVHJhbnNhY3Rpb25NZXRhZGF0YTogKCkgPT4ge1xuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdDYW5ub3Qgc3Vic2NyaWJlIHRvIFNuYXBzaG90cycpO1xuICAgICAgfVxuICAgIH07IC8vIEluaXRpYWxpemUgYW55IG5vZGVzIHRoYXQgYXJlIGxpdmUgaW4gdGhlIHBhcmVudCBzdG9yZSAocHJpbWFyaWx5IHNvIHRoYXRcbiAgICAvLyB0aGlzIHNuYXBzaG90IGdldHMgY291bnRlZCB0b3dhcmRzIHRoZSBub2RlJ3MgbGl2ZSBzdG9yZXMgY291bnQpLlxuICAgIC8vIFRPRE8gT3B0aW1pemUgdGhpcyB3aGVuIGNsb25pbmcgc25hcHNob3RzIGZvciBjYWxsYmFja3NcblxuICAgIGZvciAoY29uc3Qgbm9kZUtleSBvZiB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMpIHtcbiAgICAgIGluaXRpYWxpemVOb2RlJDEodGhpcy5fc3RvcmUsIG5vZGVLZXksICdnZXQnKTtcbiAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDEodGhpcy5fc3RvcmUsIG5vZGVLZXksIDEpO1xuICAgIH1cblxuICAgIHRoaXMuYXV0b1JlbGVhc2VfSU5URVJOQUwoKTtcbiAgfVxuXG4gIHJldGFpbigpIHtcbiAgICBpZiAodGhpcy5fcmVmQ291bnQgPD0gMCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdTbmFwc2hvdCBoYXMgYWxyZWFkeSBiZWVuIHJlbGVhc2VkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdBdHRlbXB0IHRvIHJldGFpbigpIFNuYXBzaG90IHRoYXQgd2FzIGFscmVhZHkgcmVsZWFzZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcmVmQ291bnQrKztcbiAgICBsZXQgcmVsZWFzZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFyZWxlYXNlZCkge1xuICAgICAgICByZWxlYXNlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fcmVsZWFzZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlbGVhc2UgdGhlIHNuYXBzaG90IG9uIHRoZSBuZXh0IHRpY2suICBUaGlzIG1lYW5zIHRoZSBzbmFwc2hvdCBpcyByZXRhaW5lZFxuICAgKiBkdXJpbmcgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgY3VycmVudCBmdW5jdGlvbiB1c2luZyBpdC5cbiAgICovXG5cblxuICBhdXRvUmVsZWFzZV9JTlRFUk5BTCgpIHtcbiAgICBpZiAoIWlzU1NSJDEpIHtcbiAgICAgIC8vIFVzZSB0aW1lb3V0IG9mIDEwIHRvIHdvcmthcm91bmQgRmlyZWZveCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rZXhwZXJpbWVudGFsL1JlY29pbC9pc3N1ZXMvMTkzNlxuICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGhpcy5fcmVsZWFzZSgpLCAxMCk7XG4gICAgfVxuICB9XG5cbiAgX3JlbGVhc2UoKSB7XG4gICAgdGhpcy5fcmVmQ291bnQtLTtcblxuICAgIGlmICh0aGlzLl9yZWZDb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcblxuICAgICAgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5jbGVhcigpO1xuXG4gICAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBUZW1wb3JhcmlseSBuZXJmaW5nIHRoaXMgdG8gYWxsb3cgdXMgdG8gZmluZCBicm9rZW4gY2FsbCBzaXRlcyB3aXRob3V0XG4gICAgICAvLyBhY3R1YWxseSBicmVha2luZyBhbnlib2R5IHlldC5cbiAgICAgIC8vIGZvciAoY29uc3QgayBvZiB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMpIHtcbiAgICAgIC8vICAgdXBkYXRlUmV0YWluQ291bnRUb1plcm8odGhpcy5fc3RvcmUsIGspO1xuICAgICAgLy8gfVxuXG4gICAgfSBlbHNlIGlmICh0aGlzLl9yZWZDb3VudCA8IDApIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdTbmFwc2hvdCByZWxlYXNlZCBhbiBleHRyYSB0aW1lLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzUmV0YWluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZkNvdW50ID4gMDtcbiAgfVxuXG4gIGNoZWNrUmVmQ291bnRfSU5URVJOQUwoKSB7XG4gICAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykgJiYgdGhpcy5fcmVmQ291bnQgPD0gMCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24ocmV0YWluV2FybmluZyk7XG4gICAgICB9IC8vIFdoYXQgd2Ugd2lsbCBzaGlwIGxhdGVyOlxuICAgICAgLy8gdGhyb3cgZXJyKHJldGFpbldhcm5pbmcpO1xuXG4gICAgfVxuICB9XG5cbiAgZ2V0U3RvcmVfSU5URVJOQUwoKSB7XG4gICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlO1xuICB9XG5cbiAgZ2V0SUQoKSB7XG4gICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUuc3RhdGVJRDtcbiAgfVxuXG4gIGdldFN0b3JlSUQoKSB7XG4gICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLnN0b3JlSUQ7XG4gIH0gLy8gV2Ugd2FudCB0byBhbGxvdyB0aGUgbWV0aG9kcyB0byBiZSBkZXN0cnVjdHVyZWQgYW5kIHVzZWQgYXMgYWNjZXNzb3JzXG5cbiAgLyogZXNsaW50LWRpc2FibGUgZmItd3d3L2V4dHJhLWFycm93LWluaXRpYWxpemVyICovXG5cbiAgLyogZXNsaW50LWVuYWJsZSBmYi13d3cvZXh0cmEtYXJyb3ctaW5pdGlhbGl6ZXIgKi9cblxuXG59XG5cbmZ1bmN0aW9uIGNsb25lU3RvcmVTdGF0ZShzdG9yZSwgdHJlZVN0YXRlLCBidW1wVmVyc2lvbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBjb25zdCB2ZXJzaW9uID0gYnVtcFZlcnNpb24gPyBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQyKCkgOiB0cmVlU3RhdGUudmVyc2lvbjtcbiAgcmV0dXJuIHtcbiAgICAvLyBBbHdheXMgY2xvbmUgdGhlIFRyZWVTdGF0ZSB0byBpc29sYXRlIHN0b3JlcyBmcm9tIGFjY2lkZW50YWwgbXV0YXRpb25zLlxuICAgIC8vIEZvciBleGFtcGxlLCByZWFkaW5nIGEgc2VsZWN0b3IgZnJvbSBhIGNsb25lZCBzbmFwc2hvdCBzaG91bGRuJ3QgY2FjaGVcbiAgICAvLyBpbiB0aGUgb3JpZ2luYWwgdHJlZXN0YXRlIHdoaWNoIG1heSBjYXVzZSB0aGUgb3JpZ2luYWwgdG8gc2tpcFxuICAgIC8vIGluaXRpYWxpemF0aW9uIG9mIHVwc3RyZWFtIGF0b21zLlxuICAgIGN1cnJlbnRUcmVlOiB7XG4gICAgICAvLyBUT0RPIHNuYXBzaG90cyBzaG91bGRuJ3QgcmVhbGx5IGhhdmUgdmVyc2lvbnMgYmVjYXVzZSBhIG5ldyB2ZXJzaW9uIG51bWJlclxuICAgICAgLy8gaXMgYWx3YXlzIGFzc2lnbmVkIHdoZW4gdGhlIHNuYXBzaG90IGlzIGdvbmUgdG8uXG4gICAgICB2ZXJzaW9uOiBidW1wVmVyc2lvbiA/IHZlcnNpb24gOiB0cmVlU3RhdGUudmVyc2lvbixcbiAgICAgIHN0YXRlSUQ6IGJ1bXBWZXJzaW9uID8gdmVyc2lvbiA6IHRyZWVTdGF0ZS5zdGF0ZUlELFxuICAgICAgdHJhbnNhY3Rpb25NZXRhZGF0YTogeyAuLi50cmVlU3RhdGUudHJhbnNhY3Rpb25NZXRhZGF0YVxuICAgICAgfSxcbiAgICAgIGRpcnR5QXRvbXM6IG5ldyBTZXQodHJlZVN0YXRlLmRpcnR5QXRvbXMpLFxuICAgICAgYXRvbVZhbHVlczogdHJlZVN0YXRlLmF0b21WYWx1ZXMuY2xvbmUoKSxcbiAgICAgIG5vbnZhbGlkYXRlZEF0b21zOiB0cmVlU3RhdGUubm9udmFsaWRhdGVkQXRvbXMuY2xvbmUoKVxuICAgIH0sXG4gICAgY29tbWl0RGVwdGg6IDAsXG4gICAgbmV4dFRyZWU6IG51bGwsXG4gICAgcHJldmlvdXNUcmVlOiBudWxsLFxuICAgIGtub3duQXRvbXM6IG5ldyBTZXQoc3RvcmVTdGF0ZS5rbm93bkF0b21zKSxcbiAgICAvLyBGSVhNRSBoZXJlJ3MgYSBjb3B5XG4gICAga25vd25TZWxlY3RvcnM6IG5ldyBTZXQoc3RvcmVTdGF0ZS5rbm93blNlbGVjdG9ycyksXG4gICAgLy8gRklYTUUgaGVyZSdzIGEgY29weVxuICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxuICAgIG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKSxcbiAgICBub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXG4gICAgcXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQ6IFtdLFxuICAgIHN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVyczogbmV3IFNldCgpLFxuICAgIGdyYXBoc0J5VmVyc2lvbjogbmV3IE1hcCgpLnNldCh2ZXJzaW9uLCBzdG9yZS5nZXRHcmFwaCh0cmVlU3RhdGUudmVyc2lvbikpLFxuICAgIHJldGVudGlvbjoge1xuICAgICAgcmVmZXJlbmNlQ291bnRzOiBuZXcgTWFwKCksXG4gICAgICBub2Rlc1JldGFpbmVkQnlab25lOiBuZXcgTWFwKCksXG4gICAgICByZXRhaW5hYmxlc1RvQ2hlY2tGb3JSZWxlYXNlOiBuZXcgU2V0KClcbiAgICB9LFxuICAgIC8vIEZJWE1FIGhlcmUncyBhIGNvcHlcbiAgICAvLyBDcmVhdGUgYmxhbmsgY2xlYW51cCBoYW5kbGVycyBmb3IgYXRvbXMgc28gc25hcHNob3RzIGRvbid0IHJlLXJ1blxuICAgIC8vIGF0b20gZWZmZWN0cy5cbiAgICBub2RlQ2xlYW51cEZ1bmN0aW9uczogbmV3IE1hcChSZWNvaWxfbWFwSXRlcmFibGUoc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5lbnRyaWVzKCksIChba2V5XSkgPT4gW2tleSwgKCkgPT4ge31dKSlcbiAgfTtcbn0gLy8gRmFjdG9yeSB0byBidWlsZCBhIGZyZXNoIHNuYXBzaG90XG5cblxuZnVuY3Rpb24gZnJlc2hTbmFwc2hvdChpbml0aWFsaXplU3RhdGUpIHtcbiAgY29uc3Qgc25hcHNob3QgPSBuZXcgU25hcHNob3QobWFrZUVtcHR5U3RvcmVTdGF0ZSQxKCkpO1xuICByZXR1cm4gaW5pdGlhbGl6ZVN0YXRlICE9IG51bGwgPyBzbmFwc2hvdC5tYXAoaW5pdGlhbGl6ZVN0YXRlKSA6IHNuYXBzaG90O1xufSAvLyBGYWN0b3J5IHRvIGNsb25lIGEgc25hcHNob3Qgc3RhdGVcblxuXG5jb25zdCBbbWVtb2l6ZWRDbG9uZVNuYXBzaG90LCBpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQyXSA9IG1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb24kMSgoc3RvcmUsIHZlcnNpb24pID0+IHtcbiAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlO1xuXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBjb25zdCB0cmVlU3RhdGUgPSB2ZXJzaW9uID09PSAnbGF0ZXN0JyA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBSZWNvaWxfbnVsbHRocm93cyhzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSk7XG4gIHJldHVybiBuZXcgU25hcHNob3QoY2xvbmVTdG9yZVN0YXRlKHN0b3JlLCB0cmVlU3RhdGUpLCBzdG9yZS5zdG9yZUlEKTtcbn0sIChzdG9yZSwgdmVyc2lvbikgPT4ge1xuICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRULCBfc3RvcmUkZ2V0U3RhdGUkcHJldmk7XG5cbiAgcmV0dXJuIFN0cmluZyh2ZXJzaW9uKSArIFN0cmluZyhzdG9yZS5zdG9yZUlEKSArIFN0cmluZygoX3N0b3JlJGdldFN0YXRlJG5leHRUID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlJG5leHRUID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQudmVyc2lvbikgKyBTdHJpbmcoc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZS52ZXJzaW9uKSArIFN0cmluZygoX3N0b3JlJGdldFN0YXRlJHByZXZpID0gc3RvcmUuZ2V0U3RhdGUoKS5wcmV2aW91c1RyZWUpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZSRwcmV2aSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlJGdldFN0YXRlJHByZXZpLnZlcnNpb24pO1xufSk7IC8vIEF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuXG5zZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQxKGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDIpO1xuXG5mdW5jdGlvbiBjbG9uZVNuYXBzaG90KHN0b3JlLCB2ZXJzaW9uID0gJ2xhdGVzdCcpIHtcbiAgY29uc3Qgc25hcHNob3QgPSBtZW1vaXplZENsb25lU25hcHNob3Qoc3RvcmUsIHZlcnNpb24pO1xuXG4gIGlmICghc25hcHNob3QuaXNSZXRhaW5lZCgpKSB7XG4gICAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMigpO1xuICAgIHJldHVybiBtZW1vaXplZENsb25lU25hcHNob3Qoc3RvcmUsIHZlcnNpb24pO1xuICB9XG5cbiAgcmV0dXJuIHNuYXBzaG90O1xufVxuXG5jbGFzcyBNdXRhYmxlU25hcHNob3QgZXh0ZW5kcyBTbmFwc2hvdCB7XG4gIGNvbnN0cnVjdG9yKHNuYXBzaG90LCBiYXRjaCkge1xuICAgIHN1cGVyKGNsb25lU3RvcmVTdGF0ZShzbmFwc2hvdC5nZXRTdG9yZV9JTlRFUk5BTCgpLCBzbmFwc2hvdC5nZXRTdG9yZV9JTlRFUk5BTCgpLmdldFN0YXRlKCkuY3VycmVudFRyZWUsIHRydWUpLCBzbmFwc2hvdC5nZXRTdG9yZUlEKCkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2JhdGNoXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRcIiwgKHJlY29pbFN0YXRlLCBuZXdWYWx1ZU9yVXBkYXRlcikgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRoaXMuZ2V0U3RvcmVfSU5URVJOQUwoKTsgLy8gVGhpcyBiYXRjaFVwZGF0ZXMgZW5zdXJlcyB0aGlzIGBzZXRgIGlzIGFwcGxpZWQgaW1tZWRpYXRlbHkgYW5kIHlvdSBjYW5cbiAgICAgIC8vIHJlYWQgdGhlIHdyaXR0ZW4gdmFsdWUgYWZ0ZXIgY2FsbGluZyBgc2V0YC4gSSB3b3VsZCBsaWtlIHRvIHJlbW92ZSB0aGlzXG4gICAgICAvLyBiZWhhdmlvciBhbmQgb25seSBiYXRjaCBpbiBgU25hcHNob3QubWFwYCwgYnV0IHRoaXMgd291bGQgYmUgYSBicmVha2luZ1xuICAgICAgLy8gY2hhbmdlIHBvdGVudGlhbGx5LlxuXG4gICAgICB0aGlzLl9iYXRjaCgoKSA9PiB7XG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDEoc3RvcmUsIHJlY29pbFN0YXRlLmtleSwgMSk7XG4gICAgICAgIHNldFJlY29pbFZhbHVlJDEodGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpLCByZWNvaWxTdGF0ZSwgbmV3VmFsdWVPclVwZGF0ZXIpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNldFwiLCByZWNvaWxTdGF0ZSA9PiB7XG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpOyAvLyBTZWUgbm90ZSBhdCBgc2V0YCBhYm91dCBiYXRjaGVkIHVwZGF0ZXMuXG5cbiAgICAgIHRoaXMuX2JhdGNoKCgpID0+IHtcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMShzdG9yZSwgcmVjb2lsU3RhdGUua2V5LCAxKTtcbiAgICAgICAgc2V0UmVjb2lsVmFsdWUkMSh0aGlzLmdldFN0b3JlX0lOVEVSTkFMKCksIHJlY29pbFN0YXRlLCBERUZBVUxUX1ZBTFVFJDEpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXNfREVQUkVDQVRFRFwiLCB2YWx1ZXMgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRoaXMuZ2V0U3RvcmVfSU5URVJOQUwoKTsgLy8gU2VlIG5vdGUgYXQgYHNldGAgYWJvdXQgYmF0Y2hlZCB1cGRhdGVzLlxuXG4gICAgICBiYXRjaFVwZGF0ZXMkMSgoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHZhbHVlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICB1cGRhdGVSZXRhaW5Db3VudCQxKHN0b3JlLCBrLCAxKTtcbiAgICAgICAgICBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlJDEoc3RvcmUsIG5ldyBBYnN0cmFjdFJlY29pbFZhbHVlJDIoayksIHYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2JhdGNoID0gYmF0Y2g7XG4gIH1cblxufVxuXG52YXIgUmVjb2lsX1NuYXBzaG90ID0ge1xuICBTbmFwc2hvdCxcbiAgTXV0YWJsZVNuYXBzaG90LFxuICBmcmVzaFNuYXBzaG90LFxuICBjbG9uZVNuYXBzaG90XG59O1xuXG52YXIgUmVjb2lsX1NuYXBzaG90XzEgPSBSZWNvaWxfU25hcHNob3QuU25hcHNob3Q7XG52YXIgUmVjb2lsX1NuYXBzaG90XzIgPSBSZWNvaWxfU25hcHNob3QuTXV0YWJsZVNuYXBzaG90O1xudmFyIFJlY29pbF9TbmFwc2hvdF8zID0gUmVjb2lsX1NuYXBzaG90LmZyZXNoU25hcHNob3Q7XG52YXIgUmVjb2lsX1NuYXBzaG90XzQgPSBSZWNvaWxfU25hcHNob3QuY2xvbmVTbmFwc2hvdDtcblxudmFyIFJlY29pbF9TbmFwc2hvdCQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFNuYXBzaG90OiBSZWNvaWxfU25hcHNob3RfMSxcbiAgTXV0YWJsZVNuYXBzaG90OiBSZWNvaWxfU25hcHNob3RfMixcbiAgZnJlc2hTbmFwc2hvdDogUmVjb2lsX1NuYXBzaG90XzMsXG4gIGNsb25lU25hcHNob3Q6IFJlY29pbF9TbmFwc2hvdF80XG59KTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gdW5pb25TZXRzKC4uLnNldHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuXG4gIGZvciAoY29uc3Qgc2V0IG9mIHNldHMpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHNldCkge1xuICAgICAgcmVzdWx0LmFkZCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlY29pbF91bmlvblNldHMgPSB1bmlvblNldHM7XG5cbmNvbnN0IHtcbiAgdXNlUmVmXG59ID0gcmVhY3Q7XG4vKipcbiAqIFRoZSBzYW1lIGFzIGB1c2VSZWYoKWAgZXhjZXB0IHRoYXQgaWYgYSBmdW5jdGlvbiBpcyBzcGVjaWZpZWQgdGhlbiBpdCB3aWxsXG4gKiBjYWxsIHRoYXQgZnVuY3Rpb24gdG8gZ2V0IHRoZSB2YWx1ZSB0byBpbml0aWFsaXplIHRoZSByZWZlcmVuY2Ugd2l0aC5cbiAqIFRoaXMgaXMgc2ltaWxhciB0byBob3cgYHVzZVN0YXRlKClgIGJlaGF2ZXMgd2hlbiBnaXZlbiBhIGZ1bmN0aW9uLiAgSXQgYWxsb3dzXG4gKiB0aGUgdXNlciB0byBhdm9pZCBnZW5lcmF0aW5nIHRoZSBpbml0aWFsIHZhbHVlIGZvciBzdWJzZXF1ZW50IHJlbmRlcnMuXG4gKiBUaGUgdHJhZGVvZmYgaXMgdGhhdCB0byBzZXQgdGhlIHJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIGl0c2VsZiB5b3UgbmVlZCB0b1xuICogbmVzdCBpdDogdXNlUmVmSW5pdE9uY2UoKCkgPT4gKCkgPT4gey4uLn0pO1xuICovXG5cblxuZnVuY3Rpb24gdXNlUmVmSW5pdE9uY2UoaW5pdGlhbFZhbHVlKSB7XG4gIC8vICRGbG93RXhwZWN0ZWRFcnJvcltpbmNvbXBhdGlibGUtY2FsbF1cbiAgY29uc3QgcmVmID0gdXNlUmVmKGluaXRpYWxWYWx1ZSk7XG5cbiAgaWYgKHJlZi5jdXJyZW50ID09PSBpbml0aWFsVmFsdWUgJiYgdHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICRGbG93RXhwZWN0ZWRFcnJvcltpbmNvbXBhdGlibGUtdXNlXVxuICAgIHJlZi5jdXJyZW50ID0gaW5pdGlhbFZhbHVlKCk7XG4gIH1cblxuICByZXR1cm4gcmVmO1xufVxuXG52YXIgUmVjb2lsX3VzZVJlZkluaXRPbmNlID0gdXNlUmVmSW5pdE9uY2U7XG5cbi8vIEBmYi1vbmx5OiBjb25zdCBSZWNvaWx1c2FnZWxvZ0V2ZW50ID0gcmVxdWlyZSgnUmVjb2lsdXNhZ2Vsb2dFdmVudCcpO1xuLy8gQGZiLW9ubHk6IGNvbnN0IFJlY29pbFVzYWdlTG9nRmFsY29FdmVudCA9IHJlcXVpcmUoJ1JlY29pbFVzYWdlTG9nRmFsY29FdmVudCcpO1xuLy8gQGZiLW9ubHk6IGNvbnN0IFVSSSA9IHJlcXVpcmUoJ1VSSScpO1xuXG5cbmNvbnN0IHtcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb246IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDMsXG4gIG1ha2VFbXB0eVN0b3JlU3RhdGU6IG1ha2VFbXB0eVN0b3JlU3RhdGUkMlxufSA9IFJlY29pbF9TdGF0ZTtcblxuY29uc3Qge1xuICBjbGVhblVwTm9kZTogY2xlYW5VcE5vZGUkMixcbiAgZ2V0RG93bnN0cmVhbU5vZGVzOiBnZXREb3duc3RyZWFtTm9kZXMkMixcbiAgaW5pdGlhbGl6ZU5vZGU6IGluaXRpYWxpemVOb2RlJDIsXG4gIHNldE5vZGVWYWx1ZTogc2V0Tm9kZVZhbHVlJDIsXG4gIHNldFVudmFsaWRhdGVkQXRvbVZhbHVlX0RFUFJFQ0FURUQ6IHNldFVudmFsaWRhdGVkQXRvbVZhbHVlX0RFUFJFQ0FURUQkMVxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICBncmFwaDogZ3JhcGgkMlxufSA9IFJlY29pbF9HcmFwaDtcblxuY29uc3Qge1xuICBjbG9uZUdyYXBoOiBjbG9uZUdyYXBoJDFcbn0gPSBSZWNvaWxfR3JhcGg7XG5cbmNvbnN0IHtcbiAgZ2V0TmV4dFN0b3JlSUQ6IGdldE5leHRTdG9yZUlEJDJcbn0gPSBSZWNvaWxfS2V5cztcblxuY29uc3Qge1xuICBjcmVhdGVNdXRhYmxlU291cmNlOiBjcmVhdGVNdXRhYmxlU291cmNlJDEsXG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDJcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xuXG5jb25zdCB7XG4gIGFwcGx5QXRvbVZhbHVlV3JpdGVzOiBhcHBseUF0b21WYWx1ZVdyaXRlcyQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIHJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdzogcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93JDFcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5jb25zdCB7XG4gIGZyZXNoU25hcHNob3Q6IGZyZXNoU25hcHNob3QkMVxufSA9IFJlY29pbF9TbmFwc2hvdCQxO1xuXG5cblxuY29uc3Qge1xuICB1c2VDYWxsYmFjayxcbiAgdXNlQ29udGV4dCxcbiAgdXNlRWZmZWN0LFxuICB1c2VNZW1vLFxuICB1c2VSZWY6IHVzZVJlZiQxLFxuICB1c2VTdGF0ZVxufSA9IHJlYWN0O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gbm90SW5BQ29udGV4dCgpIHtcbiAgdGhyb3cgUmVjb2lsX2VycignVGhpcyBjb21wb25lbnQgbXVzdCBiZSB1c2VkIGluc2lkZSBhIDxSZWNvaWxSb290PiBjb21wb25lbnQuJyk7XG59XG5cbmNvbnN0IGRlZmF1bHRTdG9yZSA9IE9iamVjdC5mcmVlemUoe1xuICBzdG9yZUlEOiBnZXROZXh0U3RvcmVJRCQyKCksXG4gIGdldFN0YXRlOiBub3RJbkFDb250ZXh0LFxuICByZXBsYWNlU3RhdGU6IG5vdEluQUNvbnRleHQsXG4gIGdldEdyYXBoOiBub3RJbkFDb250ZXh0LFxuICBzdWJzY3JpYmVUb1RyYW5zYWN0aW9uczogbm90SW5BQ29udGV4dCxcbiAgYWRkVHJhbnNhY3Rpb25NZXRhZGF0YTogbm90SW5BQ29udGV4dFxufSk7XG5sZXQgc3RhdGVSZXBsYWNlcklzQmVpbmdFeGVjdXRlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzdGFydE5leHRUcmVlSWZOZWVkZWQoc3RvcmUpIHtcbiAgaWYgKHN0YXRlUmVwbGFjZXJJc0JlaW5nRXhlY3V0ZWQpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdBbiBhdG9tIHVwZGF0ZSB3YXMgdHJpZ2dlcmVkIHdpdGhpbiB0aGUgZXhlY3V0aW9uIG9mIGEgc3RhdGUgdXBkYXRlciBmdW5jdGlvbi4gU3RhdGUgdXBkYXRlciBmdW5jdGlvbnMgcHJvdmlkZWQgdG8gUmVjb2lsIG11c3QgYmUgcHVyZSBmdW5jdGlvbnMuJyk7XG4gIH1cblxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICBpZiAoc3RvcmVTdGF0ZS5uZXh0VHJlZSA9PT0gbnVsbCkge1xuICAgIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpICYmIFJlY29pbF9na3goJ3JlY29pbF9yZWxlYXNlX29uX2Nhc2NhZGluZ191cGRhdGVfa2lsbHN3aXRjaF8yMDIxJykpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjYXNjYWRpbmcgdXBkYXRlICh0aGF0IGlzLCByZW5kZXJpbmcgZHVlIHRvIG9uZSBzdGF0ZSBjaGFuZ2VcbiAgICAgIC8vIGludm9rZXMgYSBzZWNvbmQgc3RhdGUgY2hhbmdlKSwgd2Ugd29uJ3QgaGF2ZSBjbGVhbmVkIHVwIHJldGFpbmFibGVzIHlldFxuICAgICAgLy8gYmVjYXVzZSB0aGlzIG5vcm1hbGx5IGhhcHBlbnMgYWZ0ZXIgbm90aWZ5aW5nIGNvbXBvbmVudHMuIERvIGl0IGJlZm9yZVxuICAgICAgLy8gcHJvY2VlZGluZyB3aXRoIHRoZSBjYXNjYWRpbmcgdXBkYXRlIHNvIHRoYXQgaXQgcmVtYWlucyBwcmVkaWN0YWJsZTpcbiAgICAgIGlmIChzdG9yZVN0YXRlLmNvbW1pdERlcHRoID4gMCkge1xuICAgICAgICByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3ckMShzdG9yZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdmVyc2lvbiA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWUudmVyc2lvbjtcbiAgICBjb25zdCBuZXh0VmVyc2lvbiA9IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDMoKTtcbiAgICBzdG9yZVN0YXRlLm5leHRUcmVlID0geyAuLi5zdG9yZVN0YXRlLmN1cnJlbnRUcmVlLFxuICAgICAgdmVyc2lvbjogbmV4dFZlcnNpb24sXG4gICAgICBzdGF0ZUlEOiBuZXh0VmVyc2lvbixcbiAgICAgIGRpcnR5QXRvbXM6IG5ldyBTZXQoKSxcbiAgICAgIHRyYW5zYWN0aW9uTWV0YWRhdGE6IHt9XG4gICAgfTtcbiAgICBzdG9yZVN0YXRlLmdyYXBoc0J5VmVyc2lvbi5zZXQobmV4dFZlcnNpb24sIGNsb25lR3JhcGgkMShSZWNvaWxfbnVsbHRocm93cyhzdG9yZVN0YXRlLmdyYXBoc0J5VmVyc2lvbi5nZXQodmVyc2lvbikpKSk7XG4gIH1cbn1cblxuY29uc3QgQXBwQ29udGV4dCA9IHJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBjdXJyZW50OiBkZWZhdWx0U3RvcmVcbn0pO1xuXG5jb25zdCB1c2VTdG9yZVJlZiA9ICgpID0+IHVzZUNvbnRleHQoQXBwQ29udGV4dCk7IC8vICRGbG93RXhwZWN0ZWRFcnJvcltpbmNvbXBhdGlibGUtY2FsbF1cblxuXG5jb25zdCBNdXRhYmxlU291cmNlQ29udGV4dCA9IHJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmZ1bmN0aW9uIHVzZVJlY29pbE11dGFibGVTb3VyY2UoKSB7XG4gIGNvbnN0IG11dGFibGVTb3VyY2UgPSB1c2VDb250ZXh0KE11dGFibGVTb3VyY2VDb250ZXh0KTtcblxuICBpZiAobXV0YWJsZVNvdXJjZSA9PSBudWxsKSB7XG4gICAgUmVjb2lsX2V4cGVjdGF0aW9uVmlvbGF0aW9uKCdBdHRlbXB0ZWQgdG8gdXNlIGEgUmVjb2lsIGhvb2sgb3V0c2lkZSBvZiBhIDxSZWNvaWxSb290Pi4gJyArICc8UmVjb2lsUm9vdD4gbXVzdCBiZSBhbiBhbmNlc3RvciBvZiBhbnkgY29tcG9uZW50IHRoYXQgdXNlcyAnICsgJ1JlY29pbCBob29rcy4nKTtcbiAgfVxuXG4gIHJldHVybiBtdXRhYmxlU291cmNlO1xufVxuXG5mdW5jdGlvbiBub3RpZnlDb21wb25lbnRzKHN0b3JlLCBzdG9yZVN0YXRlLCB0cmVlU3RhdGUpIHtcbiAgY29uc3QgZGVwZW5kZW50Tm9kZXMgPSBnZXREb3duc3RyZWFtTm9kZXMkMihzdG9yZSwgdHJlZVN0YXRlLCB0cmVlU3RhdGUuZGlydHlBdG9tcyk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgZGVwZW5kZW50Tm9kZXMpIHtcbiAgICBjb25zdCBjb21wcyA9IHN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5nZXQoa2V5KTtcblxuICAgIGlmIChjb21wcykge1xuICAgICAgZm9yIChjb25zdCBbX3N1YklELCBbX2RlYnVnTmFtZSwgY2FsbGJhY2tdXSBvZiBjb21wcykge1xuICAgICAgICBjYWxsYmFjayh0cmVlU3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnMoc3RvcmUpIHtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IHRyZWVTdGF0ZSA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7IC8vIEluZm9ybSB0cmFuc2FjdGlvbiBzdWJzY3JpYmVycyBvZiB0aGUgdHJhbnNhY3Rpb246XG5cbiAgY29uc3QgZGlydHlBdG9tcyA9IHRyZWVTdGF0ZS5kaXJ0eUF0b21zO1xuXG4gIGlmIChkaXJ0eUF0b21zLnNpemUpIHtcbiAgICAvLyBFeGVjdXRlIE5vZGUtc3BlY2lmaWMgc3Vic2NyaWJlcnMgYmVmb3JlIGdsb2JhbCBzdWJzY3JpYmVyc1xuICAgIGZvciAoY29uc3QgW2tleSwgc3Vic2NyaXB0aW9uc10gb2Ygc3RvcmVTdGF0ZS5ub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zKSB7XG4gICAgICBpZiAoZGlydHlBdG9tcy5oYXMoa2V5KSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtfLCBzdWJzY3JpcHRpb25dIG9mIHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb24oc3RvcmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbXywgc3Vic2NyaXB0aW9uXSBvZiBzdG9yZVN0YXRlLnRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucykge1xuICAgICAgc3Vic2NyaXB0aW9uKHN0b3JlKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlYWN0TW9kZSQyKCkuZWFybHkgfHwgc3RvcmVTdGF0ZS5zdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMuc2l6ZSA+IDApIHtcbiAgICAgIC8vIE5vdGlmeWluZyBjb21wb25lbnRzIGlzIG5lZWRlZCB0byB3YWtlIGZyb20gc3VzcGVuc2UsIGV2ZW4gd2hlbiB1c2luZ1xuICAgICAgLy8gZWFybHkgcmVuZGVyaW5nLlxuICAgICAgbm90aWZ5Q29tcG9uZW50cyhzdG9yZSwgc3RvcmVTdGF0ZSwgdHJlZVN0YXRlKTsgLy8gV2FrZSBhbGwgc3VzcGVuZGVkIGNvbXBvbmVudHMgc28gdGhlIHJpZ2h0IG9uZShzKSBjYW4gdHJ5IHRvIHJlLXJlbmRlci5cbiAgICAgIC8vIFdlIG5lZWQgdG8gd2FrZSB1cCBjb21wb25lbnRzIG5vdCBqdXN0IHdoZW4gc29tZSBhc3luY2hyb25vdXMgc2VsZWN0b3JcbiAgICAgIC8vIHJlc29sdmVkLCBidXQgYWxzbyB3aGVuIGNoYW5naW5nIHN5bmNocm9ub3VzIHZhbHVlcyBiZWNhdXNlIHRoaXMgbWF5IGNhdXNlXG4gICAgICAvLyBhIHNlbGVjdG9yIHRvIGNoYW5nZSBmcm9tIGFzeW5jaHJvbm91cyB0byBzeW5jaHJvbm91cywgaW4gd2hpY2ggY2FzZSB0aGVyZVxuICAgICAgLy8gd291bGQgYmUgbm8gZm9sbG93LXVwIGFzeW5jaHJvbm91cyByZXNvbHV0aW9uIHRvIHdha2UgdXMgdXAuXG4gICAgICAvLyBUT0RPIE9QVElNSVpBVElPTiBPbmx5IHdha2UgdXAgcmVsYXRlZCBkb3duc3RyZWFtIGNvbXBvbmVudHNcblxuICAgICAgc3RvcmVTdGF0ZS5zdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMuZm9yRWFjaChjYiA9PiBjYigpKTtcbiAgICAgIHN0b3JlU3RhdGUuc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzLmNsZWFyKCk7XG4gICAgfVxuICB9IC8vIFNwZWNpYWwgYmVoYXZpb3IgT05MWSBpbnZva2VkIGJ5IHVzZUludGVyZmFjZS5cbiAgLy8gRklYTUUgZGVsZXRlIHF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVEIHdoZW4gZGVsZXRpbmcgdXNlSW50ZXJmYWNlLlxuXG5cbiAgc3RvcmVTdGF0ZS5xdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRC5mb3JFYWNoKGNiID0+IGNiKHRyZWVTdGF0ZSkpO1xuICBzdG9yZVN0YXRlLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELnNwbGljZSgwLCBzdG9yZVN0YXRlLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGVuZEJhdGNoKHN0b3JlKSB7XG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBzdG9yZVN0YXRlLmNvbW1pdERlcHRoKys7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7XG4gICAgICBuZXh0VHJlZVxuICAgIH0gPSBzdG9yZVN0YXRlOyAvLyBJZ25vcmUgY29tbWl0cyB0aGF0IGFyZSBub3QgYmVjYXVzZSBvZiBSZWNvaWwgdHJhbnNhY3Rpb25zIC0tIG5hbWVseSxcbiAgICAvLyBiZWNhdXNlIHNvbWV0aGluZyBhYm92ZSBSZWNvaWxSb290IHJlLXJlbmRlcmVkOlxuXG4gICAgaWYgKG5leHRUcmVlID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG5leHRUcmVlIGlzIG5vdyBjb21taXR0ZWQgLS0gbm90ZSB0aGF0IGNvcHlpbmcgYW5kIHJlc2V0IG9jY3VycyB3aGVuXG4gICAgLy8gYSB0cmFuc2FjdGlvbiBiZWdpbnMsIGluIHN0YXJ0TmV4dFRyZWVJZk5lZWRlZDpcblxuXG4gICAgc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUgPSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICAgIHN0b3JlU3RhdGUuY3VycmVudFRyZWUgPSBuZXh0VHJlZTtcbiAgICBzdG9yZVN0YXRlLm5leHRUcmVlID0gbnVsbDtcbiAgICBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnMoc3RvcmUpO1xuXG4gICAgaWYgKHN0b3JlU3RhdGUucHJldmlvdXNUcmVlICE9IG51bGwpIHtcbiAgICAgIHN0b3JlU3RhdGUuZ3JhcGhzQnlWZXJzaW9uLmRlbGV0ZShzdG9yZVN0YXRlLnByZXZpb3VzVHJlZS52ZXJzaW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdFbmRlZCBiYXRjaCB3aXRoIG5vIHByZXZpb3VzIHN0YXRlLCB3aGljaCBpcyB1bmV4cGVjdGVkJywgJ3JlY29pbCcpO1xuICAgIH1cblxuICAgIHN0b3JlU3RhdGUucHJldmlvdXNUcmVlID0gbnVsbDtcblxuICAgIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgICAvLyBPbmx5IHJlbGVhc2UgcmV0YWluYWJsZXMgaWYgdGhlcmUgd2VyZSBubyB3cml0ZXMgZHVyaW5nIHRoZSBlbmQgb2YgdGhlXG4gICAgICAvLyBiYXRjaC4gIFRoaXMgYXZvaWRzIHJlbGVhc2luZyBzb21ldGhpbmcgd2UgbWlnaHQgYmUgYWJvdXQgdG8gdXNlLlxuICAgICAgaWYgKG5leHRUcmVlID09IG51bGwpIHtcbiAgICAgICAgcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93JDEoc3RvcmUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBzdG9yZVN0YXRlLmNvbW1pdERlcHRoLS07XG4gIH1cbn1cbi8qXG4gKiBUaGUgcHVycG9zZSBvZiB0aGUgQmF0Y2hlciBpcyB0byBvYnNlcnZlIHdoZW4gUmVhY3QgYmF0Y2hlcyBlbmQgc28gdGhhdFxuICogUmVjb2lsIHN0YXRlIGNoYW5nZXMgY2FuIGJlIGJhdGNoZWQuIFdoZW5ldmVyIFJlY29pbCBzdGF0ZSBjaGFuZ2VzLCB3ZSBjYWxsXG4gKiBzZXRTdGF0ZSBvbiB0aGUgYmF0Y2hlci4gVGhlbiB3ZSB3YWl0IGZvciB0aGF0IGNoYW5nZSB0byBiZSBjb21taXR0ZWQsIHdoaWNoXG4gKiBzaWduaWZpZXMgdGhlIGVuZCBvZiB0aGUgYmF0Y2guIFRoYXQncyB3aGVuIHdlIHJlc3BvbmQgdG8gdGhlIFJlY29pbCBjaGFuZ2UuXG4gKi9cblxuXG5mdW5jdGlvbiBCYXRjaGVyKHtcbiAgc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlXG59KSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYoKTtcbiAgY29uc3QgWywgc2V0U3RhdGVdID0gdXNlU3RhdGUoW10pO1xuICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2UoKCkgPT4gc2V0U3RhdGUoe30pKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2UoKCkgPT4gc2V0U3RhdGUoe30pKTsgLy8gSWYgYW4gYXN5bmNocm9ub3VzIHNlbGVjdG9yIHJlc29sdmVzIGFmdGVyIHRoZSBCYXRjaGVyIGlzIHVubW91bnRlZCxcbiAgICAvLyBub3RpZnlCYXRjaGVyT2ZDaGFuZ2Ugd2lsbCBzdGlsbCBiZSBjYWxsZWQuIEFuIGVycm9yIGdldHMgdGhyb3duIHdoZW5ldmVyXG4gICAgLy8gc2V0U3RhdGUgaXMgY2FsbGVkIGFmdGVyIGEgY29tcG9uZW50IGlzIGFscmVhZHkgdW5tb3VudGVkLCBzbyB0aGlzIHNldHNcbiAgICAvLyBub3RpZnlCYXRjaGVyT2ZDaGFuZ2UgdG8gYmUgYSBuby1vcC5cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2UoKCkgPT4ge30pO1xuICAgIH07XG4gIH0sIFtzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2VdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBlbnF1ZXVlRXhlY3V0aW9uIHJ1bnMgdGhpcyBmdW5jdGlvbiBpbW1lZGlhdGVseTsgaXQgaXMgb25seSB1c2VkIHRvXG4gICAgLy8gbWFuaXB1bGF0ZSB0aGUgb3JkZXIgb2YgdXNlRWZmZWN0cyBkdXJpbmcgdGVzdHMsIHNpbmNlIFJlYWN0IHNlZW1zIHRvXG4gICAgLy8gY2FsbCB1c2VFZmZlY3QgaW4gYW4gdW5wcmVkaWN0YWJsZSBvcmRlciBzb21ldGltZXMuXG4gICAgUmVjb2lsX1F1ZXVlLmVucXVldWVFeGVjdXRpb24oJ0JhdGNoZXInLCAoKSA9PiB7XG4gICAgICBlbmRCYXRjaChzdG9yZVJlZi5jdXJyZW50KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LiRyZWNvaWxEZWJ1Z1N0YXRlcykge1xuICAgIHdpbmRvdy4kcmVjb2lsRGVidWdTdGF0ZXMgPSBbXTtcbiAgfVxufSAvLyBXaGVuIHJlbW92aW5nIHRoaXMgZGVwcmVjYXRlZCBmdW5jdGlvbiwgcmVtb3ZlIHN0YXRlQnlTZXR0aW5nUmVjb2lsVmFsdWVcbi8vIHdoaWNoIHdpbGwgbm8gbG9uZ2VyIGJlIG5lZWRlZC5cblxuXG5mdW5jdGlvbiBpbml0aWFsU3RvcmVTdGF0ZV9ERVBSRUNBVEVEKHN0b3JlLCBpbml0aWFsaXplU3RhdGUpIHtcbiAgY29uc3QgaW5pdGlhbCA9IG1ha2VFbXB0eVN0b3JlU3RhdGUkMigpO1xuICBpbml0aWFsaXplU3RhdGUoe1xuICAgIHNldDogKGF0b20sIHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGluaXRpYWwuY3VycmVudFRyZWU7XG4gICAgICBjb25zdCB3cml0ZXMgPSBzZXROb2RlVmFsdWUkMihzdG9yZSwgc3RhdGUsIGF0b20ua2V5LCB2YWx1ZSk7XG4gICAgICBjb25zdCB3cml0dGVuTm9kZXMgPSBuZXcgU2V0KHdyaXRlcy5rZXlzKCkpO1xuICAgICAgY29uc3Qgbm9udmFsaWRhdGVkQXRvbXMgPSBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5jbG9uZSgpO1xuXG4gICAgICBmb3IgKGNvbnN0IG4gb2Ygd3JpdHRlbk5vZGVzKSB7XG4gICAgICAgIG5vbnZhbGlkYXRlZEF0b21zLmRlbGV0ZShuKTtcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbC5jdXJyZW50VHJlZSA9IHsgLi4uc3RhdGUsXG4gICAgICAgIGRpcnR5QXRvbXM6IFJlY29pbF91bmlvblNldHMoc3RhdGUuZGlydHlBdG9tcywgd3JpdHRlbk5vZGVzKSxcbiAgICAgICAgYXRvbVZhbHVlczogYXBwbHlBdG9tVmFsdWVXcml0ZXMkMShzdGF0ZS5hdG9tVmFsdWVzLCB3cml0ZXMpLFxuICAgICAgICAvLyBOQjogUExFQVNFIHVuLWV4cG9ydCBhcHBseUF0b21WYWx1ZVdyaXRlcyB3aGVuIGRlbGV0aW5nIHRoaXMgY29kZVxuICAgICAgICBub252YWxpZGF0ZWRBdG9tc1xuICAgICAgfTtcbiAgICB9LFxuICAgIHNldFVudmFsaWRhdGVkQXRvbVZhbHVlczogYXRvbVZhbHVlcyA9PiB7XG4gICAgICAvLyBGSVhNRSByZXBsYWNlIHRoaXMgd2l0aCBhIG11dGF0aXZlIGxvb3BcbiAgICAgIGF0b21WYWx1ZXMuZm9yRWFjaCgodiwgaykgPT4ge1xuICAgICAgICBpbml0aWFsLmN1cnJlbnRUcmVlID0gc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCQxKGluaXRpYWwuY3VycmVudFRyZWUsIGssIHYpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGluaXRpYWw7XG59IC8vIEluaXRpYWxpemUgc3RhdGUgc25hcHNob3QgZm9yIDxSZWNvaWxSb290PiBmb3IgdGhlIGluaXRpYWxpemVTdGF0ZSBwcm9wLlxuLy8gQXRvbSBlZmZlY3QgaW5pdGlhbGl6YXRpb24gdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgcHJvcC5cbi8vIEFueSBhdG9tIGVmZmVjdHMgd2lsbCBiZSBydW4gYmVmb3JlIGluaXRpYWxpemF0aW9uLCBidXQgdGhlbiBjbGVhbmVkIHVwLFxuLy8gdGhleSBhcmUgdGhlbiByZS1ydW4gd2hlbiB1c2VkIGFzIHBhcnQgb2YgcmVuZGVyaW5nLiAgVGhlc2Ugc2VtYW50aWNzIGFyZVxuLy8gY29tcGF0aWJsZSB3aXRoIFJlYWN0IFN0cmljdE1vZGUgd2hlcmUgZWZmZWN0cyBtYXkgYmUgcmUtcnVuIG11bHRpcGxlIHRpbWVzXG4vLyBidXQgc3RhdGUgaW5pdGlhbGl6YXRpb24gb25seSBoYXBwZW5zIG9uY2UgdGhlIGZpcnN0IHRpbWUuXG5cblxuZnVuY3Rpb24gaW5pdGlhbFN0b3JlU3RhdGUoaW5pdGlhbGl6ZVN0YXRlKSB7XG4gIC8vIEluaXRpYWxpemUgYSBzbmFwc2hvdCBhbmQgZ2V0IGl0cyBzdG9yZVxuICBjb25zdCBzbmFwc2hvdCA9IGZyZXNoU25hcHNob3QkMShpbml0aWFsaXplU3RhdGUpO1xuICBjb25zdCBzdG9yZVN0YXRlID0gc25hcHNob3QuZ2V0U3RvcmVfSU5URVJOQUwoKS5nZXRTdGF0ZSgpOyAvLyBDb3VudGVyYWN0IHRoZSBzbmFwc2hvdCBhdXRvLXJlbGVhc2VcblxuICBzbmFwc2hvdC5yZXRhaW4oKTsgLy8gQ2xlYW51cCBhbnkgZWZmZWN0cyBydW4gZHVyaW5nIGluaXRpYWxpemF0aW9uIGFuZCBjbGVhciB0aGUgaGFuZGxlcnMgc29cbiAgLy8gdGhleSB3aWxsIHJlLWluaXRpYWxpemUgaWYgdXNlZCBkdXJpbmcgcmVuZGVyaW5nLiAgVGhpcyBhbGxvd3MgYXRvbSBlZmZlY3RcbiAgLy8gaW5pdGlhbGl6YXRpb24gdG8gdGFrZSBwcmVjZWRlbmNlIG92ZXIgaW5pdGlhbGl6ZVN0YXRlIGFuZCBiZSBjb21wYXRpYmxlXG4gIC8vIHdpdGggU3RyaWN0TW9kZSBzZW1hbnRpY3MuXG5cbiAgc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcbiAgc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5jbGVhcigpO1xuICByZXR1cm4gc3RvcmVTdGF0ZTtcbn1cblxubGV0IG5leHRJRCA9IDA7XG5cbmZ1bmN0aW9uIFJlY29pbFJvb3RfSU5URVJOQUwoe1xuICBpbml0aWFsaXplU3RhdGVfREVQUkVDQVRFRCxcbiAgaW5pdGlhbGl6ZVN0YXRlLFxuICBzdG9yZV9JTlRFUk5BTDogc3RvcmVQcm9wLFxuICAvLyBGb3IgdXNlIHdpdGggUmVhY3QgXCJjb250ZXh0IGJyaWRnaW5nXCJcbiAgY2hpbGRyZW5cbn0pIHtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIC8vIEBmYi1vbmx5OiB1c2VFZmZlY3QoKCkgPT4ge1xuICAvLyBAZmItb25seTogaWYgKGdreCgncmVjb2lsX3VzYWdlX2xvZ2dpbmcnKSkge1xuICAvLyBAZmItb25seTogdHJ5IHtcbiAgLy8gQGZiLW9ubHk6IFJlY29pbFVzYWdlTG9nRmFsY29FdmVudC5sb2coKCkgPT4gKHtcbiAgLy8gQGZiLW9ubHk6IHR5cGU6IFJlY29pbHVzYWdlbG9nRXZlbnQuUkVDT0lMX1JPT1RfTU9VTlRFRCxcbiAgLy8gQGZiLW9ubHk6IHBhdGg6IFVSSS5nZXRSZXF1ZXN0VVJJKCkuZ2V0UGF0aCgpLFxuICAvLyBAZmItb25seTogfSkpO1xuICAvLyBAZmItb25seTogfSBjYXRjaCB7XG4gIC8vIEBmYi1vbmx5OiByZWNvdmVyYWJsZVZpb2xhdGlvbihcbiAgLy8gQGZiLW9ubHk6ICdFcnJvciB3aGVuIGxvZ2dpbmcgUmVjb2lsIFVzYWdlIGV2ZW50JyxcbiAgLy8gQGZiLW9ubHk6ICdyZWNvaWwnLFxuICAvLyBAZmItb25seTogKTtcbiAgLy8gQGZiLW9ubHk6IH1cbiAgLy8gQGZiLW9ubHk6IH1cbiAgLy8gQGZiLW9ubHk6IH0sIFtdKTtcbiAgbGV0IHN0b3JlU3RhdGVSZWY7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWNvbnN0XG5cbiAgY29uc3QgZ2V0R3JhcGggPSB2ZXJzaW9uID0+IHtcbiAgICBjb25zdCBncmFwaHMgPSBzdG9yZVN0YXRlUmVmLmN1cnJlbnQuZ3JhcGhzQnlWZXJzaW9uO1xuXG4gICAgaWYgKGdyYXBocy5oYXModmVyc2lvbikpIHtcbiAgICAgIHJldHVybiBSZWNvaWxfbnVsbHRocm93cyhncmFwaHMuZ2V0KHZlcnNpb24pKTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdHcmFwaCA9IGdyYXBoJDIoKTtcbiAgICBncmFwaHMuc2V0KHZlcnNpb24sIG5ld0dyYXBoKTtcbiAgICByZXR1cm4gbmV3R3JhcGg7XG4gIH07XG5cbiAgY29uc3Qgc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnMgPSAoY2FsbGJhY2ssIGtleSkgPT4ge1xuICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgLy8gR2xvYmFsIHRyYW5zYWN0aW9uIHN1YnNjcmlwdGlvbnNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zXG4gICAgICB9ID0gc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3QgaWQgPSBuZXh0SUQrKztcbiAgICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5zZXQoaWQsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbGVhc2U6ICgpID0+IHtcbiAgICAgICAgICB0cmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9kZS1zcGVjaWZpYyB0cmFuc2FjdGlvbiBzdWJzY3JpcHRpb25zOlxuICAgICAgY29uc3Qge1xuICAgICAgICBub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zXG4gICAgICB9ID0gc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpO1xuXG4gICAgICBpZiAoIW5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuaGFzKGtleSkpIHtcbiAgICAgICAgbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5zZXQoa2V5LCBuZXcgTWFwKCkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpZCA9IG5leHRJRCsrO1xuICAgICAgUmVjb2lsX251bGx0aHJvd3Mobm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5nZXQoa2V5KSkuc2V0KGlkLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWxlYXNlOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3VicyA9IG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuZ2V0KGtleSk7XG5cbiAgICAgICAgICBpZiAoc3Vicykge1xuICAgICAgICAgICAgc3Vicy5kZWxldGUoaWQpO1xuXG4gICAgICAgICAgICBpZiAoc3Vicy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgIG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBhZGRUcmFuc2FjdGlvbk1ldGFkYXRhID0gbWV0YWRhdGEgPT4ge1xuICAgIHN0YXJ0TmV4dFRyZWVJZk5lZWRlZChzdG9yZVJlZi5jdXJyZW50KTtcblxuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhtZXRhZGF0YSkpIHtcbiAgICAgIFJlY29pbF9udWxsdGhyb3dzKHN0b3JlUmVmLmN1cnJlbnQuZ2V0U3RhdGUoKS5uZXh0VHJlZSkudHJhbnNhY3Rpb25NZXRhZGF0YVtrXSA9IG1ldGFkYXRhW2tdO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByZXBsYWNlU3RhdGUgPSByZXBsYWNlciA9PiB7XG4gICAgc3RhcnROZXh0VHJlZUlmTmVlZGVkKHN0b3JlUmVmLmN1cnJlbnQpOyAvLyBVc2UgcmVwbGFjZXIgdG8gZ2V0IHRoZSBuZXh0IHN0YXRlOlxuXG4gICAgY29uc3QgbmV4dFRyZWUgPSBSZWNvaWxfbnVsbHRocm93cyhzdG9yZVN0YXRlUmVmLmN1cnJlbnQubmV4dFRyZWUpO1xuICAgIGxldCByZXBsYWNlZDtcblxuICAgIHRyeSB7XG4gICAgICBzdGF0ZVJlcGxhY2VySXNCZWluZ0V4ZWN1dGVkID0gdHJ1ZTtcbiAgICAgIHJlcGxhY2VkID0gcmVwbGFjZXIobmV4dFRyZWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzdGF0ZVJlcGxhY2VySXNCZWluZ0V4ZWN1dGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2VkID09PSBuZXh0VHJlZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3aW5kb3cuJHJlY29pbERlYnVnU3RhdGVzLnB1c2gocmVwbGFjZWQpOyAvLyBUT0RPIHRoaXMgc2hvdWxkbid0IGhhcHBlbiBoZXJlIGJlY2F1c2UgaXQncyBub3QgYmF0Y2hlZFxuICAgICAgfVxuICAgIH0gLy8gU2F2ZSBjaGFuZ2VzIHRvIG5leHRUcmVlIGFuZCBzY2hlZHVsZSBhIFJlYWN0IHVwZGF0ZTpcblxuXG4gICAgc3RvcmVTdGF0ZVJlZi5jdXJyZW50Lm5leHRUcmVlID0gcmVwbGFjZWQ7XG5cbiAgICBpZiAocmVhY3RNb2RlJDIoKS5lYXJseSkge1xuICAgICAgbm90aWZ5Q29tcG9uZW50cyhzdG9yZVJlZi5jdXJyZW50LCBzdG9yZVN0YXRlUmVmLmN1cnJlbnQsIHJlcGxhY2VkKTtcbiAgICB9XG5cbiAgICBSZWNvaWxfbnVsbHRocm93cyhub3RpZnlCYXRjaGVyT2ZDaGFuZ2UuY3VycmVudCkoKTtcbiAgfTtcblxuICBjb25zdCBub3RpZnlCYXRjaGVyT2ZDaGFuZ2UgPSB1c2VSZWYkMShudWxsKTtcbiAgY29uc3Qgc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlID0gdXNlQ2FsbGJhY2soeCA9PiB7XG4gICAgbm90aWZ5QmF0Y2hlck9mQ2hhbmdlLmN1cnJlbnQgPSB4O1xuICB9LCBbbm90aWZ5QmF0Y2hlck9mQ2hhbmdlXSk7XG4gIGNvbnN0IHN0b3JlUmVmID0gUmVjb2lsX3VzZVJlZkluaXRPbmNlKCgpID0+IHN0b3JlUHJvcCAhPT0gbnVsbCAmJiBzdG9yZVByb3AgIT09IHZvaWQgMCA/IHN0b3JlUHJvcCA6IHtcbiAgICBzdG9yZUlEOiBnZXROZXh0U3RvcmVJRCQyKCksXG4gICAgZ2V0U3RhdGU6ICgpID0+IHN0b3JlU3RhdGVSZWYuY3VycmVudCxcbiAgICByZXBsYWNlU3RhdGUsXG4gICAgZ2V0R3JhcGgsXG4gICAgc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnMsXG4gICAgYWRkVHJhbnNhY3Rpb25NZXRhZGF0YVxuICB9KTtcblxuICBpZiAoc3RvcmVQcm9wICE9IG51bGwpIHtcbiAgICBzdG9yZVJlZi5jdXJyZW50ID0gc3RvcmVQcm9wO1xuICB9XG5cbiAgc3RvcmVTdGF0ZVJlZiA9IFJlY29pbF91c2VSZWZJbml0T25jZSgoKSA9PiBpbml0aWFsaXplU3RhdGVfREVQUkVDQVRFRCAhPSBudWxsID8gaW5pdGlhbFN0b3JlU3RhdGVfREVQUkVDQVRFRChzdG9yZVJlZi5jdXJyZW50LCBpbml0aWFsaXplU3RhdGVfREVQUkVDQVRFRCkgOiBpbml0aWFsaXplU3RhdGUgIT0gbnVsbCA/IGluaXRpYWxTdG9yZVN0YXRlKGluaXRpYWxpemVTdGF0ZSkgOiBtYWtlRW1wdHlTdG9yZVN0YXRlJDIoKSk7XG4gIGNvbnN0IG11dGFibGVTb3VyY2UgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZU11dGFibGVTb3VyY2UkMSA9PT0gbnVsbCB8fCBjcmVhdGVNdXRhYmxlU291cmNlJDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWF0ZU11dGFibGVTb3VyY2UkMShzdG9yZVN0YXRlUmVmLCAoKSA9PiBzdG9yZVN0YXRlUmVmLmN1cnJlbnQuY3VycmVudFRyZWUudmVyc2lvbiksIFtzdG9yZVN0YXRlUmVmXSk7IC8vIENsZWFudXAgd2hlbiB0aGUgPFJlY29pbFJvb3Q+IGlzIHVubW91bnRlZFxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gUmVhY3QgaXMgZnJlZSB0byBjYWxsIGVmZmVjdCBjbGVhbnVwIGhhbmRsZXJzIGFuZCBlZmZlY3RzIGF0IHdpbGwsIHRoZVxuICAgIC8vIGRlcHMgYXJyYXkgaXMgb25seSBhbiBvcHRpbWl6YXRpb24uICBGb3IgZXhhbXBsZSwgUmVhY3Qgc3RyaWN0IG1vZGVcbiAgICAvLyB3aWxsIGV4ZWN1dGUgZWFjaCBlZmZlY3QgdHdpY2UgZm9yIHRlc3RpbmcuICBUaGVyZWZvcmUsIHdlIG5lZWQgc3ltbWV0cnlcbiAgICAvLyB0byByZS1pbml0aWFsaXplIGFsbCBrbm93biBhdG9tcyBhZnRlciB0aGV5IHdlcmUgY2xlYW5lZCB1cC5cbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG5cbiAgICBmb3IgKGNvbnN0IGF0b21LZXkgb2YgbmV3IFNldChzdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMpKSB7XG4gICAgICBpbml0aWFsaXplTm9kZSQyKHN0b3JlLCBhdG9tS2V5LCAnZ2V0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgYXRvbUtleSBvZiBzdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMpIHtcbiAgICAgICAgY2xlYW5VcE5vZGUkMihzdG9yZSwgYXRvbUtleSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3N0b3JlUmVmXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChBcHBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHN0b3JlUmVmXG4gIH0sIC8qI19fUFVSRV9fKi9yZWFjdC5jcmVhdGVFbGVtZW50KE11dGFibGVTb3VyY2VDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IG11dGFibGVTb3VyY2VcbiAgfSwgLyojX19QVVJFX18qL3JlYWN0LmNyZWF0ZUVsZW1lbnQoQmF0Y2hlciwge1xuICAgIHNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZTogc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlXG4gIH0pLCBjaGlsZHJlbikpO1xufVxuXG5mdW5jdGlvbiBSZWNvaWxSb290KHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBvdmVycmlkZSxcbiAgICAuLi5wcm9wc0V4Y2VwdE92ZXJyaWRlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgYW5jZXN0b3JTdG9yZVJlZiA9IHVzZVN0b3JlUmVmKCk7XG5cbiAgaWYgKG92ZXJyaWRlID09PSBmYWxzZSAmJiBhbmNlc3RvclN0b3JlUmVmLmN1cnJlbnQgIT09IGRlZmF1bHRTdG9yZSkge1xuICAgIC8vIElmIGFuY2VzdG9yU3RvcmVSZWYuY3VycmVudCAhPT0gZGVmYXVsdFN0b3JlLCBpdCBtZWFucyB0aGF0IHRoaXNcbiAgICAvLyBSZWNvaWxSb290IGlzIG5vdCBuZXN0ZWQgd2l0aGluIGFub3RoZXIuXG4gICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9yZWFjdC5jcmVhdGVFbGVtZW50KFJlY29pbFJvb3RfSU5URVJOQUwsIHByb3BzRXhjZXB0T3ZlcnJpZGUpO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxTdG9yZUlEKCkge1xuICByZXR1cm4gdXNlU3RvcmVSZWYoKS5jdXJyZW50LnN0b3JlSUQ7XG59XG5cbnZhciBSZWNvaWxfUmVjb2lsUm9vdCA9IHtcbiAgUmVjb2lsUm9vdCxcbiAgdXNlU3RvcmVSZWYsXG4gIHVzZVJlY29pbE11dGFibGVTb3VyY2UsXG4gIHVzZVJlY29pbFN0b3JlSUQsXG4gIG5vdGlmeUNvbXBvbmVudHNfRk9SX1RFU1RJTkc6IG5vdGlmeUNvbXBvbmVudHMsXG4gIHNlbmRFbmRPZkJhdGNoTm90aWZpY2F0aW9uc19GT1JfVEVTVElORzogc2VuZEVuZE9mQmF0Y2hOb3RpZmljYXRpb25zXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBzaGFsbG93QXJyYXlFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBSZWNvaWxfc2hhbGxvd0FycmF5RXF1YWwgPSBzaGFsbG93QXJyYXlFcXVhbDtcblxuY29uc3Qge1xuICB1c2VFZmZlY3Q6IHVzZUVmZmVjdCQxLFxuICB1c2VSZWY6IHVzZVJlZiQyXG59ID0gcmVhY3Q7XG5cbmZ1bmN0aW9uIHVzZVByZXZpb3VzKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZiQyKCk7XG4gIHVzZUVmZmVjdCQxKCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuXG52YXIgUmVjb2lsX3VzZVByZXZpb3VzID0gdXNlUHJldmlvdXM7XG5cbmNvbnN0IHtcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDFcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuY29uc3Qge1xuICBTVVNQRU5TRV9USU1FT1VUX01TOiBTVVNQRU5TRV9USU1FT1VUX01TJDFcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5jb25zdCB7XG4gIHVwZGF0ZVJldGFpbkNvdW50OiB1cGRhdGVSZXRhaW5Db3VudCQyXG59ID0gUmVjb2lsX1JldGVudGlvbjtcblxuY29uc3Qge1xuICBSZXRlbnRpb25ab25lOiBSZXRlbnRpb25ab25lJDNcbn0gPSBSZWNvaWxfUmV0ZW50aW9uWm9uZTtcblxuY29uc3Qge1xuICB1c2VFZmZlY3Q6IHVzZUVmZmVjdCQyLFxuICB1c2VSZWY6IHVzZVJlZiQzXG59ID0gcmVhY3Q7XG5cbmNvbnN0IHtcbiAgaXNTU1I6IGlzU1NSJDJcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XG5cblxuXG5cblxuIC8vIEkgZG9uJ3Qgc2VlIGEgd2F5IHRvIGF2b2lkIHRoZSBhbnkgdHlwZSBoZXJlIGJlY2F1c2Ugd2Ugd2FudCB0byBhY2NlcHQgcmVhZGFibGVcbi8vIGFuZCB3cml0YWJsZSB2YWx1ZXMgd2l0aCBhbnkgdHlwZSBwYXJhbWV0ZXIsIGJ1dCBub3JtYWxseSB3aXRoIHdyaXRhYmxlIG9uZXNcbi8vIFJlY29pbFN0YXRlPFNvbWVUPiBpcyBub3QgYSBzdWJ0eXBlIG9mIFJlY29pbFN0YXRlPG1peGVkPi5cblxuXG4vLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbmZ1bmN0aW9uIHVzZVJldGFpbih0b1JldGFpbikge1xuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9yZWFjdC1ob29rc1xuXG5cbiAgcmV0dXJuIHVzZVJldGFpbl9BQ1RVQUwodG9SZXRhaW4pO1xufVxuXG5mdW5jdGlvbiB1c2VSZXRhaW5fQUNUVUFMKHRvUmV0YWluKSB7XG4gIGNvbnN0IGFycmF5ID0gQXJyYXkuaXNBcnJheSh0b1JldGFpbikgPyB0b1JldGFpbiA6IFt0b1JldGFpbl07XG4gIGNvbnN0IHJldGFpbmFibGVzID0gYXJyYXkubWFwKGEgPT4gYSBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMyA/IGEgOiBhLmtleSk7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMSgpO1xuICB1c2VFZmZlY3QkMigoKSA9PiB7XG4gICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuXG4gICAgaWYgKHRpbWVvdXRJRC5jdXJyZW50ICYmICFpc1NTUiQyKSB7XG4gICAgICAvLyBBbHJlYWR5IHBlcmZvcm1lZCBhIHRlbXBvcmFyeSByZXRhaW4gb24gcmVuZGVyLCBzaW1wbHkgY2FuY2VsIHRoZSByZWxlYXNlXG4gICAgICAvLyBvZiB0aGF0IHRlbXBvcmFyeSByZXRhaW4uXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcbiAgICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCByIG9mIHJldGFpbmFibGVzKSB7XG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMihzdG9yZSwgciwgLTEpO1xuICAgICAgfVxuICAgIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvcmVhY3QtaG9va3MtZGVwc1xuICB9LCBbc3RvcmVSZWYsIC4uLnJldGFpbmFibGVzXSk7IC8vIFdlIHdhbnQgdG8gcmV0YWluIGlmIHRoZSBjb21wb25lbnQgc3VzcGVuZHMuIFRoaXMgaXMgdGVycmlibGUgYnV0IHRoZSBTdXNwZW5zZVxuICAvLyBBUEkgYWZmb3JkcyB1cyBubyBiZXR0ZXIgb3B0aW9uLiBJZiB3ZSBzdXNwZW5kIGFuZCBuZXZlciBjb21taXQgYWZ0ZXIgc29tZVxuICAvLyBzZWNvbmRzLCB0aGVuIHJlbGVhc2UuIFRoZSAnYWN0dWFsJyByZXRhaW4vcmVsZWFzZSBpbiB0aGUgZWZmZWN0IGFib3ZlXG4gIC8vIGNhbmNlbHMgdGhpcy5cblxuICBjb25zdCB0aW1lb3V0SUQgPSB1c2VSZWYkMygpO1xuICBjb25zdCBwcmV2aW91c1JldGFpbmFibGVzID0gUmVjb2lsX3VzZVByZXZpb3VzKHJldGFpbmFibGVzKTtcblxuICBpZiAoIWlzU1NSJDIgJiYgKHByZXZpb3VzUmV0YWluYWJsZXMgPT09IHVuZGVmaW5lZCB8fCAhUmVjb2lsX3NoYWxsb3dBcnJheUVxdWFsKHByZXZpb3VzUmV0YWluYWJsZXMsIHJldGFpbmFibGVzKSkpIHtcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG5cbiAgICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcbiAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIDEpO1xuICAgIH1cblxuICAgIGlmIChwcmV2aW91c1JldGFpbmFibGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IHIgb2YgcHJldmlvdXNSZXRhaW5hYmxlcykge1xuICAgICAgICB1cGRhdGVSZXRhaW5Db3VudCQyKHN0b3JlLCByLCAtMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRpbWVvdXRJRC5jdXJyZW50KSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcbiAgICB9XG5cbiAgICB0aW1lb3V0SUQuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgZm9yIChjb25zdCByIG9mIHJldGFpbmFibGVzKSB7XG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIC0xKTtcbiAgICAgIH1cbiAgICB9LCBTVVNQRU5TRV9USU1FT1VUX01TJDEpO1xuICB9XG59XG5cbnZhciBSZWNvaWxfdXNlUmV0YWluID0gdXNlUmV0YWluO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBUSElTIENPREUgSEFTIEJFRU4gQ09NTUVOVEVEIE9VVCBJTlRFTlRJT05BTExZXG4gKlxuICogVGhpcyB0ZWNobmlxdWUgb2YgZ2V0dGluZyB0aGUgY29tcG9uZW50IG5hbWUgaXMgaW1wZXJmZWN0LCBzaW5jZSBpdCBib3RoIG9ubHlcbiAqIHdvcmtzIGluIGEgbm9uLW1pbmlmaWVkIGNvZGUgYmFzZSwgYW5kIG1vcmUgaW1wb3J0YW50bHkgaW50cm9kdWNlcyBwZXJmb3JtYW5jZVxuICogcHJvYmxlbXMgc2luY2UgaXQgcmVsaWVzIGluIHRocm93aW5nIGVycm9ycyB3aGljaCBpcyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uLlxuICpcbiAqIEF0IHNvbWUgcG9pbnQgd2UgbWF5IHdhbnQgdG8gcmVldmFsdWF0ZSB0aGlzIHRlY2huaXF1ZSBoZW5jZSB3aHkgd2UgaGF2ZSBjb21tZW50ZWRcbiAqIHRoaXMgY29kZSBvdXQsIHJhdGhlciB0aGFuIGRlbGV0ZSBpdCBhbGwgdG9nZXRoZXIuXG4gKi9cbi8vIGNvbnN0IHt1c2VSZWZ9ID0gcmVxdWlyZSgncmVhY3QnKTtcbi8vIGNvbnN0IGdreCA9IHJlcXVpcmUoJ3JlY29pbC1zaGFyZWQvdXRpbC9SZWNvaWxfZ2t4Jyk7XG4vLyBjb25zdCBzdGFja1RyYWNlUGFyc2VyID0gcmVxdWlyZSgncmVjb2lsLXNoYXJlZC91dGlsL1JlY29pbF9zdGFja1RyYWNlUGFyc2VyJyk7XG5cbmZ1bmN0aW9uIHVzZUNvbXBvbmVudE5hbWUoKSB7XG4gIC8vIGNvbnN0IG5hbWVSZWYgPSB1c2VSZWYoKTtcbiAgLy8gaWYgKF9fREVWX18pIHtcbiAgLy8gICBpZiAoZ2t4KCdyZWNvaWxfaW5mZXJfY29tcG9uZW50X25hbWVzJykpIHtcbiAgLy8gICAgIGlmIChuYW1lUmVmLmN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAvLyAgICAgICAvLyBUaGVyZSBpcyBubyBibGVzc2VkIHdheSB0byBkZXRlcm1pbmUgdGhlIGNhbGxpbmcgUmVhY3QgY29tcG9uZW50IGZyb21cbiAgLy8gICAgICAgLy8gd2l0aGluIGEgaG9vay4gVGhpcyBoYWNrIHVzZXMgdGhlIGZhY3QgdGhhdCBob29rcyBtdXN0IHN0YXJ0IHdpdGggJ3VzZSdcbiAgLy8gICAgICAgLy8gYW5kIHRoYXQgaG9va3MgYXJlIGVpdGhlciBjYWxsZWQgYnkgUmVhY3QgQ29tcG9uZW50cyBvciBvdGhlciBob29rcy4gSXRcbiAgLy8gICAgICAgLy8gZm9sbG93cyB0aGVyZWZvcmUsIHRoYXQgdG8gZmluZCB0aGUgY2FsbGluZyBjb21wb25lbnQsIHlvdSBzaW1wbHkgbmVlZFxuICAvLyAgICAgICAvLyB0byBsb29rIGRvd24gdGhlIHN0YWNrIGFuZCBmaW5kIHRoZSBmaXJzdCBmdW5jdGlvbiB3aGljaCBkb2Vzbid0IHN0YXJ0XG4gIC8vICAgICAgIC8vIHdpdGggJ3VzZScuIFdlIGFyZSBvbmx5IGVuYWJsaW5nIHRoaXMgaW4gZGV2IGZvciBub3csIHNpbmNlIG9uY2UgdGhlXG4gIC8vICAgICAgIC8vIGNvZGViYXNlIGlzIG1pbmlmaWVkLCB0aGUgbmFtaW5nIGFzc3VtcHRpb25zIG5vIGxvbmdlciBob2xkIHRydWUuXG4gIC8vICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvbm8tbmV3LWVycm9yXG4gIC8vICAgICAgIGNvbnN0IGZyYW1lcyA9IHN0YWNrVHJhY2VQYXJzZXIobmV3IEVycm9yKCkuc3RhY2spO1xuICAvLyAgICAgICBmb3IgKGNvbnN0IHttZXRob2ROYW1lfSBvZiBmcmFtZXMpIHtcbiAgLy8gICAgICAgICAvLyBJIG9ic2VydmVkIGNhc2VzIHdoZXJlIHRoZSBmcmFtZSB3YXMgb2YgdGhlIGZvcm0gJ09iamVjdC51c2VYWFgnXG4gIC8vICAgICAgICAgLy8gaGVuY2Ugd2h5IEknbSBzZWFyY2hpbmcgZm9yIGhvb2tzIGZvbGxvd2luZyBhIHdvcmQgYm91bmRhcnlcbiAgLy8gICAgICAgICBpZiAoIW1ldGhvZE5hbWUubWF0Y2goL1xcYnVzZVteXFxiXSskLykpIHtcbiAgLy8gICAgICAgICAgIHJldHVybiAobmFtZVJlZi5jdXJyZW50ID0gbWV0aG9kTmFtZSk7XG4gIC8vICAgICAgICAgfVxuICAvLyAgICAgICB9XG4gIC8vICAgICAgIG5hbWVSZWYuY3VycmVudCA9IG51bGw7XG4gIC8vICAgICB9XG4gIC8vICAgICByZXR1cm4gbmFtZVJlZi5jdXJyZW50ID8/ICc8dW5hYmxlIHRvIGRldGVybWluZSBjb21wb25lbnQgbmFtZT4nO1xuICAvLyAgIH1cbiAgLy8gfVxuICAvLyBAZmItb25seTogcmV0dXJuIFwiPGNvbXBvbmVudCBuYW1lIG9ubHkgYXZhaWxhYmxlIHdoZW4gYm90aCBpbiBkZXYgbW9kZSBhbmQgd2hlbiBwYXNzaW5nIEdLICdyZWNvaWxfaW5mZXJfY29tcG9uZW50X25hbWVzJz5cIjtcbiAgcmV0dXJuICc8Y29tcG9uZW50IG5hbWUgbm90IGF2YWlsYWJsZT4nOyAvLyBAb3NzLW9ubHlcbn1cblxudmFyIFJlY29pbF91c2VDb21wb25lbnROYW1lID0gdXNlQ29tcG9uZW50TmFtZTtcblxuY29uc3Qge1xuICBiYXRjaFVwZGF0ZXM6IGJhdGNoVXBkYXRlcyQyXG59ID0gUmVjb2lsX0JhdGNoaW5nO1xuXG5jb25zdCB7XG4gIERFRkFVTFRfVkFMVUU6IERFRkFVTFRfVkFMVUUkMlxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDMsXG4gIHVzZU11dGFibGVTb3VyY2U6IHVzZU11dGFibGVTb3VyY2UkMSxcbiAgdXNlU3luY0V4dGVybmFsU3RvcmU6IHVzZVN5bmNFeHRlcm5hbFN0b3JlJDFcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xuXG5jb25zdCB7XG4gIHVzZVJlY29pbE11dGFibGVTb3VyY2U6IHVzZVJlY29pbE11dGFibGVTb3VyY2UkMSxcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDJcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuY29uc3Qge1xuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWUkMTtcblxuY29uc3Qge1xuICBBYnN0cmFjdFJlY29pbFZhbHVlOiBBYnN0cmFjdFJlY29pbFZhbHVlJDMsXG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZTogZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIsXG4gIHNldFJlY29pbFZhbHVlOiBzZXRSZWNvaWxWYWx1ZSQyLFxuICBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlOiBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlJDIsXG4gIHN1YnNjcmliZVRvUmVjb2lsVmFsdWU6IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuXG5cbmNvbnN0IHtcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrJDEsXG4gIHVzZUVmZmVjdDogdXNlRWZmZWN0JDMsXG4gIHVzZU1lbW86IHVzZU1lbW8kMSxcbiAgdXNlUmVmOiB1c2VSZWYkNCxcbiAgdXNlU3RhdGU6IHVzZVN0YXRlJDFcbn0gPSByZWFjdDtcblxuY29uc3Qge1xuICBzZXRCeUFkZGluZ1RvU2V0OiBzZXRCeUFkZGluZ1RvU2V0JDJcbn0gPSBSZWNvaWxfQ29weU9uV3JpdGU7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGhhbmRsZUxvYWRhYmxlKGxvYWRhYmxlLCByZWNvaWxWYWx1ZSwgc3RvcmVSZWYpIHtcbiAgLy8gV2UgY2FuJ3QganVzdCB0aHJvdyB0aGUgcHJvbWlzZSB3ZSBhcmUgd2FpdGluZyBvbiB0byBTdXNwZW5zZS4gIElmIHRoZVxuICAvLyB1cHN0cmVhbSBkZXBlbmRlbmNpZXMgY2hhbmdlIGl0IG1heSBwcm9kdWNlIGEgc3RhdGUgaW4gd2hpY2ggdGhlIGNvbXBvbmVudFxuICAvLyBjYW4gcmVuZGVyLCBidXQgaXQgd291bGQgc3RpbGwgYmUgc3VzcGVuZGVkIG9uIGEgUHJvbWlzZSB0aGF0IG1heSBuZXZlciByZXNvbHZlLlxuICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScpIHtcbiAgICByZXR1cm4gbG9hZGFibGUuY29udGVudHM7XG4gIH0gZWxzZSBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHN0b3JlUmVmLmN1cnJlbnQuZ2V0U3RhdGUoKS5zdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMuYWRkKHJlc29sdmUpO1xuICAgIH0pOyAvLyAkRmxvd0V4cGVjdGVkRXJyb3IgRmxvdyhwcm9wLW1pc3NpbmcpIGZvciBpbnRlZ3JhdGluZyB3aXRoIHRvb2xzIHRoYXQgaW5zcGVjdCB0aHJvd24gcHJvbWlzZXMgQGZiLW9ubHlcbiAgICAvLyBAZmItb25seTogcHJvbWlzZS5kaXNwbGF5TmFtZSA9IGBSZWNvaWwgU3RhdGU6ICR7cmVjb2lsVmFsdWUua2V5fWA7XG5cbiAgICB0aHJvdyBwcm9taXNlO1xuICB9IGVsc2UgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzRXJyb3InKSB7XG4gICAgdGhyb3cgbG9hZGFibGUuY29udGVudHM7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycihgSW52YWxpZCB2YWx1ZSBvZiBsb2FkYWJsZSBhdG9tIFwiJHtyZWNvaWxWYWx1ZS5rZXl9XCJgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlLCBob29rTmFtZSkge1xuICBpZiAoIWlzUmVjb2lsVmFsdWUkMihyZWNvaWxWYWx1ZSkpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKGBJbnZhbGlkIGFyZ3VtZW50IHRvICR7aG9va05hbWV9OiBleHBlY3RlZCBhbiBhdG9tIG9yIHNlbGVjdG9yIGJ1dCBnb3QgJHtTdHJpbmcocmVjb2lsVmFsdWUpfWApO1xuICB9XG59XG5cbi8qKlxuICogVmFyaW91cyB0aGluZ3MgYXJlIGJyb2tlbiB3aXRoIHVzZVJlY29pbEludGVyZmFjZSwgcGFydGljdWxhcmx5IGNvbmN1cnJlbnRcbiAqIG1vZGUsIFJlYWN0IHN0cmljdCBtb2RlLCBhbmQgbWVtb3J5IG1hbmFnZW1lbnQuIFRoZXkgd2lsbCBub3QgYmUgZml4ZWQuXG4gKiAqL1xuZnVuY3Rpb24gdXNlUmVjb2lsSW50ZXJmYWNlX0RFUFJFQ0FURUQoKSB7XG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBSZWNvaWxfdXNlQ29tcG9uZW50TmFtZSgpO1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgY29uc3QgWywgZm9yY2VVcGRhdGVdID0gdXNlU3RhdGUkMShbXSk7XG4gIGNvbnN0IHJlY29pbFZhbHVlc1VzZWQgPSB1c2VSZWYkNChuZXcgU2V0KCkpO1xuICByZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQgPSBuZXcgU2V0KCk7IC8vIFRyYWNrIHRoZSBSZWNvaWxWYWx1ZXMgdXNlZCBqdXN0IGR1cmluZyB0aGlzIHJlbmRlclxuXG4gIGNvbnN0IHByZXZpb3VzU3Vic2NyaXB0aW9ucyA9IHVzZVJlZiQ0KG5ldyBTZXQoKSk7XG4gIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB1c2VSZWYkNChuZXcgTWFwKCkpO1xuICBjb25zdCB1bnN1YnNjcmliZUZyb20gPSB1c2VDYWxsYmFjayQxKGtleSA9PiB7XG4gICAgY29uc3Qgc3ViID0gc3Vic2NyaXB0aW9ucy5jdXJyZW50LmdldChrZXkpO1xuXG4gICAgaWYgKHN1Yikge1xuICAgICAgc3ViLnJlbGVhc2UoKTtcbiAgICAgIHN1YnNjcmlwdGlvbnMuY3VycmVudC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH0sIFtzdWJzY3JpcHRpb25zXSk7XG4gIGNvbnN0IHVwZGF0ZVN0YXRlID0gdXNlQ2FsbGJhY2skMSgoX3N0YXRlLCBrZXkpID0+IHtcbiAgICBpZiAoc3Vic2NyaXB0aW9ucy5jdXJyZW50LmhhcyhrZXkpKSB7XG4gICAgICBmb3JjZVVwZGF0ZShbXSk7XG4gICAgfVxuICB9LCBbXSk7IC8vIEVmZmVjdCB0byBhZGQvcmVtb3ZlIHN1YnNjcmlwdGlvbnMgYXMgbm9kZXMgYXJlIHVzZWRcblxuICB1c2VFZmZlY3QkMygoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIFJlY29pbF9kaWZmZXJlbmNlU2V0cyhyZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQsIHByZXZpb3VzU3Vic2NyaXB0aW9ucy5jdXJyZW50KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9ucy5jdXJyZW50LmhhcyhrZXkpKSB7XG4gICAgICAgIFJlY29pbF9leHBlY3RhdGlvblZpb2xhdGlvbihgRG91YmxlIHN1YnNjcmlwdGlvbiB0byBSZWNvaWxWYWx1ZSBcIiR7a2V5fVwiYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3ViID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlLCBuZXcgQWJzdHJhY3RSZWNvaWxWYWx1ZSQzKGtleSksIHN0YXRlID0+IHVwZGF0ZVN0YXRlKHN0YXRlLCBrZXkpLCBjb21wb25lbnROYW1lKTtcbiAgICAgIHN1YnNjcmlwdGlvbnMuY3VycmVudC5zZXQoa2V5LCBzdWIpO1xuICAgICAgLyoqXG4gICAgICAgKiBTaW5jZSB3ZSdyZSBzdWJzY3JpYmluZyBpbiBhbiBlZmZlY3Qgd2UgbmVlZCB0byB1cGRhdGUgdG8gdGhlIGxhdGVzdFxuICAgICAgICogdmFsdWUgb2YgdGhlIGF0b20gc2luY2UgaXQgbWF5IGhhdmUgY2hhbmdlZCBzaW5jZSB3ZSByZW5kZXJlZC4gV2UgY2FuXG4gICAgICAgKiBnbyBhaGVhZCBhbmQgZG8gdGhhdCBub3csIHVubGVzcyB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgYmF0Y2ggLS1cbiAgICAgICAqIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGRvIGl0IGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLCBkdWUgdG8gdGhlXG4gICAgICAgKiBmb2xsb3dpbmcgZWRnZSBjYXNlOiBTdXBwb3NlIGFuIGF0b20gaXMgdXBkYXRlZCBpbiBhbm90aGVyIHVzZUVmZmVjdFxuICAgICAgICogb2YgdGhpcyBzYW1lIGNvbXBvbmVudC4gVGhlbiB0aGUgZm9sbG93aW5nIHNlcXVlbmNlIG9mIGV2ZW50cyBvY2N1cjpcbiAgICAgICAqIDEuIEF0b20gaXMgdXBkYXRlZCBhbmQgc3VicyBmaXJlZCAoYnV0IHdlIG1heSBub3QgYmUgc3Vic2NyaWJlZFxuICAgICAgICogICAgeWV0IGRlcGVuZGluZyBvbiBvcmRlciBvZiBlZmZlY3RzLCBzbyB3ZSBtaXNzIHRoaXMpIFVwZGF0ZWQgdmFsdWVcbiAgICAgICAqICAgIGlzIG5vdyBpbiBuZXh0VHJlZSwgYnV0IG5vdCBjdXJyZW50VHJlZS5cbiAgICAgICAqIDIuIFRoaXMgZWZmZWN0IGhhcHBlbnMuIFdlIHN1YnNjcmliZSBhbmQgdXBkYXRlLlxuICAgICAgICogMy4gRnJvbSB0aGUgdXBkYXRlIHdlIHJlLXJlbmRlciBhbmQgcmVhZCBjdXJyZW50VHJlZSwgd2l0aCBvbGQgdmFsdWUuXG4gICAgICAgKiA0LiBCYXRjaGVyJ3MgZWZmZWN0IHNldHMgY3VycmVudFRyZWUgdG8gbmV4dFRyZWUuXG4gICAgICAgKiBJbiB0aGlzIHNlcXVlbmNlIHdlIG1pc3MgdGhlIHVwZGF0ZS4gVG8gYXZvaWQgdGhhdCwgYWRkIHRoZSB1cGRhdGVcbiAgICAgICAqIHRvIHF1ZXVlZENvbXBvbmVudENhbGxiYWNrIGlmIGEgYmF0Y2ggaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICAgKi9cbiAgICAgIC8vIEZJWE1FIGRlbGV0ZSBxdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRCB3aGVuIGRlbGV0aW5nIHVzZUludGVyZmFjZS5cblxuICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICBpZiAoc3RhdGUubmV4dFRyZWUpIHtcbiAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5xdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRC5wdXNoKCgpID0+IHtcbiAgICAgICAgICB1cGRhdGVTdGF0ZShzdG9yZS5nZXRTdGF0ZSgpLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHN0b3JlLmdldFN0YXRlKCksIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgUmVjb2lsX2RpZmZlcmVuY2VTZXRzKHByZXZpb3VzU3Vic2NyaXB0aW9ucy5jdXJyZW50LCByZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHVuc3Vic2NyaWJlRnJvbShrZXkpO1xuICAgIH0pO1xuICAgIHByZXZpb3VzU3Vic2NyaXB0aW9ucy5jdXJyZW50ID0gcmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50O1xuICB9KTsgLy8gRWZmZWN0IHRvIHVuc3Vic2NyaWJlIGZyb20gYWxsIHdoZW4gdW5tb3VudGluZ1xuXG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50U3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnMuY3VycmVudDsgLy8gUmVzdG9yZSBzdWJzY3JpcHRpb25zIHRoYXQgd2VyZSBjbGVhcmVkIGR1ZSB0byBTdHJpY3RNb2RlIHJ1bm5pbmcgdGhpcyBlZmZlY3QgdHdpY2VcblxuICAgIFJlY29pbF9kaWZmZXJlbmNlU2V0cyhyZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQsIG5ldyBTZXQoY3VycmVudFN1YnNjcmlwdGlvbnMua2V5cygpKSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3Qgc3ViID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlUmVmLmN1cnJlbnQsIG5ldyBBYnN0cmFjdFJlY29pbFZhbHVlJDMoa2V5KSwgc3RhdGUgPT4gdXBkYXRlU3RhdGUoc3RhdGUsIGtleSksIGNvbXBvbmVudE5hbWUpO1xuICAgICAgY3VycmVudFN1YnNjcmlwdGlvbnMuc2V0KGtleSwgc3ViKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gY3VycmVudFN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoXywga2V5KSA9PiB1bnN1YnNjcmliZUZyb20oa2V5KSk7XG4gIH0sIFtjb21wb25lbnROYW1lLCBzdG9yZVJlZiwgdW5zdWJzY3JpYmVGcm9tLCB1cGRhdGVTdGF0ZV0pO1xuICByZXR1cm4gdXNlTWVtbyQxKCgpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG4gICAgZnVuY3Rpb24gdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVNldFJlY29pbFN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdWYWx1ZU9yVXBkYXRlciA9PiB7XG4gICAgICAgIHNldFJlY29pbFZhbHVlJDIoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsU3RhdGUsIG5ld1ZhbHVlT3JVcGRhdGVyKTtcbiAgICAgIH07XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG5cblxuICAgIGZ1bmN0aW9uIHVzZVJlc2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlc2V0UmVjb2lsU3RhdGUnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgpID0+IHNldFJlY29pbFZhbHVlJDIoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsU3RhdGUsIERFRkFVTFRfVkFMVUUkMik7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG5cblxuICAgIGZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGUocmVjb2lsVmFsdWUpIHtcbiAgICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlLCAndXNlUmVjb2lsVmFsdWVMb2FkYWJsZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlY29pbFZhbHVlc1VzZWQuY3VycmVudC5oYXMocmVjb2lsVmFsdWUua2V5KSkge1xuICAgICAgICByZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQgPSBzZXRCeUFkZGluZ1RvU2V0JDIocmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50LCByZWNvaWxWYWx1ZS5rZXkpO1xuICAgICAgfSAvLyBUT0RPIFJlc3RvcmUgb3B0aW1pemF0aW9uIHRvIG1lbW9pemUgbG9va3VwXG5cblxuICAgICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlUmVmLmN1cnJlbnQuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMihzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxWYWx1ZSwgcmVhY3RNb2RlJDMoKS5lYXJseSA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcblxuXG4gICAgZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSwgJ3VzZVJlY29pbFZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvYWRhYmxlID0gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZShyZWNvaWxWYWx1ZSk7XG4gICAgICByZXR1cm4gaGFuZGxlTG9hZGFibGUobG9hZGFibGUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZik7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG5cblxuICAgIGZ1bmN0aW9uIHVzZVJlY29pbFN0YXRlKHJlY29pbFN0YXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZWNvaWxTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3VzZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcblxuXG4gICAgZnVuY3Rpb24gdXNlUmVjb2lsU3RhdGVMb2FkYWJsZShyZWNvaWxTdGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlUmVjb2lsU3RhdGVMb2FkYWJsZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3VzZVJlY29pbFZhbHVlTG9hZGFibGUocmVjb2lsU3RhdGUpLCB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSldO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBnZXRSZWNvaWxWYWx1ZTogdXNlUmVjb2lsVmFsdWUsXG4gICAgICBnZXRSZWNvaWxWYWx1ZUxvYWRhYmxlOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlLFxuICAgICAgZ2V0UmVjb2lsU3RhdGU6IHVzZVJlY29pbFN0YXRlLFxuICAgICAgZ2V0UmVjb2lsU3RhdGVMb2FkYWJsZTogdXNlUmVjb2lsU3RhdGVMb2FkYWJsZSxcbiAgICAgIGdldFNldFJlY29pbFN0YXRlOiB1c2VTZXRSZWNvaWxTdGF0ZSxcbiAgICAgIGdldFJlc2V0UmVjb2lsU3RhdGU6IHVzZVJlc2V0UmVjb2lsU3RhdGVcbiAgICB9O1xuICB9LCBbcmVjb2lsVmFsdWVzVXNlZCwgc3RvcmVSZWZdKTtcbn1cblxuY29uc3QgcmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORyA9IHtcbiAgY3VycmVudDogMFxufTtcblxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9TWU5DX0VYVEVSTkFMX1NUT1JFKHJlY29pbFZhbHVlKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICBjb25zdCBjb21wb25lbnROYW1lID0gUmVjb2lsX3VzZUNvbXBvbmVudE5hbWUoKTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSB1c2VDYWxsYmFjayQxKCgpID0+IHtcbiAgICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWUyO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORy5jdXJyZW50Kys7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHRyZWVTdGF0ZSA9IHJlYWN0TW9kZSQzKCkuZWFybHkgPyAoX3N0b3JlU3RhdGUkbmV4dFRyZWUyID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWUyICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZTIgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcbiAgICBjb25zdCBsb2FkYWJsZSA9IGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyKHN0b3JlLCByZWNvaWxWYWx1ZSwgdHJlZVN0YXRlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9hZGFibGUsXG4gICAgICBrZXk6IHJlY29pbFZhbHVlLmtleVxuICAgIH07XG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsVmFsdWVdKTsgLy8gTWVtb2l6ZSB0aGUgc3RhdGUgdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmVyZW5kZXJzXG5cbiAgY29uc3QgbWVtb2l6ZVByZXZpb3VzU25hcHNob3QgPSB1c2VDYWxsYmFjayQxKGdldFN0YXRlID0+IHtcbiAgICBsZXQgcHJldlN0YXRlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB2YXIgX3ByZXZTdGF0ZSwgX3ByZXZTdGF0ZTI7XG5cbiAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IGdldFN0YXRlKCk7XG5cbiAgICAgIGlmICgoX3ByZXZTdGF0ZSA9IHByZXZTdGF0ZSkgIT09IG51bGwgJiYgX3ByZXZTdGF0ZSAhPT0gdm9pZCAwICYmIF9wcmV2U3RhdGUubG9hZGFibGUuaXMobmV4dFN0YXRlLmxvYWRhYmxlKSAmJiAoKF9wcmV2U3RhdGUyID0gcHJldlN0YXRlKSA9PT0gbnVsbCB8fCBfcHJldlN0YXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ByZXZTdGF0ZTIua2V5KSA9PT0gbmV4dFN0YXRlLmtleSkge1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgfVxuXG4gICAgICBwcmV2U3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICByZXR1cm4gbmV4dFN0YXRlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgZ2V0TWVtb2l6ZWRTbmFwc2hvdCA9IHVzZU1lbW8kMSgoKSA9PiBtZW1vaXplUHJldmlvdXNTbmFwc2hvdChnZXRTbmFwc2hvdCksIFtnZXRTbmFwc2hvdCwgbWVtb2l6ZVByZXZpb3VzU25hcHNob3RdKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gdXNlQ2FsbGJhY2skMShub3RpZnkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmUsIHJlY29pbFZhbHVlLCBub3RpZnksIGNvbXBvbmVudE5hbWUpO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucmVsZWFzZTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZSwgY29tcG9uZW50TmFtZV0pO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUkMShzdWJzY3JpYmUsIGdldE1lbW9pemVkU25hcHNob3QsIC8vIGdldFNuYXBzaG90KClcbiAgZ2V0TWVtb2l6ZWRTbmFwc2hvdCAvLyBnZXRTZXJ2ZXJTbmFwc2hvdCgpIGZvciBTU1Igc3VwcG9ydFxuICApLmxvYWRhYmxlO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX01VVEFCTEVfU09VUkNFKHJlY29pbFZhbHVlKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICBjb25zdCBnZXRMb2FkYWJsZSA9IHVzZUNhbGxiYWNrJDEoKCkgPT4ge1xuICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTM7XG5cbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgdHJlZVN0YXRlID0gcmVhY3RNb2RlJDMoKS5lYXJseSA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZTMgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZTMgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJG5leHRUcmVlMyA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMihzdG9yZSwgcmVjb2lsVmFsdWUsIHRyZWVTdGF0ZSk7XG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsVmFsdWVdKTtcbiAgY29uc3QgZ2V0TG9hZGFibGVXaXRoVGVzdGluZyA9IHVzZUNhbGxiYWNrJDEoKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkcuY3VycmVudCsrO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRMb2FkYWJsZSgpO1xuICB9LCBbZ2V0TG9hZGFibGVdKTtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHVzZUNhbGxiYWNrJDEoKF9zdG9yZVN0YXRlLCBub3RpZnkpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlLCByZWNvaWxWYWx1ZSwgKCkgPT4ge1xuICAgICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snKSkge1xuICAgICAgICByZXR1cm4gbm90aWZ5KCk7XG4gICAgICB9IC8vIE9ubHkgcmUtcmVuZGVyIGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZC5cbiAgICAgIC8vIFRoaXMgd2lsbCBldmFsdWF0ZSB0aGUgYXRvbS9zZWxlY3RvciBub3cgYXMgd2VsbCBhcyB3aGVuIHRoZVxuICAgICAgLy8gY29tcG9uZW50IHJlbmRlcnMsIGJ1dCB0aGF0IG1heSBoZWxwIHdpdGggcHJlZmV0Y2hpbmcuXG5cblxuICAgICAgY29uc3QgbmV3TG9hZGFibGUgPSBnZXRMb2FkYWJsZSgpO1xuXG4gICAgICBpZiAoIXByZXZMb2FkYWJsZVJlZi5jdXJyZW50LmlzKG5ld0xvYWRhYmxlKSkge1xuICAgICAgICBub3RpZnkoKTtcbiAgICAgIH0gLy8gSWYgdGhlIGNvbXBvbmVudCBpcyBzdXNwZW5kZWQgdGhlbiB0aGUgZWZmZWN0IHNldHRpbmcgcHJldkxvYWRhYmxlUmVmXG4gICAgICAvLyB3aWxsIG5vdCBydW4uICBTbywgc2V0IHRoZSBwcmV2aW91cyB2YWx1ZSBoZXJlIHdoZW4gaXRzIHN1YnNjcmlwdGlvblxuICAgICAgLy8gaXMgZmlyZWQgdG8gd2FrZSBpdCB1cC4gIFdlIGNhbid0IGp1c3QgcmVseSBvbiB0aGlzLCB0aG91Z2gsIGJlY2F1c2VcbiAgICAgIC8vIHRoaXMgb25seSBleGVjdXRlcyB3aGVuIGFuIGF0b20vc2VsZWN0b3IgaXMgZGlydHkgYW5kIHRoZSBhdG9tL3NlbGVjdG9yXG4gICAgICAvLyBwYXNzZWQgdG8gdGhlIGhvb2sgY2FuIGR5bmFtaWNhbGx5IGNoYW5nZS5cblxuXG4gICAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IG5ld0xvYWRhYmxlO1xuICAgIH0sIGNvbXBvbmVudE5hbWUpO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucmVsZWFzZTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZSwgY29tcG9uZW50TmFtZSwgZ2V0TG9hZGFibGVdKTtcbiAgY29uc3Qgc291cmNlID0gdXNlUmVjb2lsTXV0YWJsZVNvdXJjZSQxKCk7XG5cbiAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignUmVjb2lsIGhvb2tzIG11c3QgYmUgdXNlZCBpbiBjb21wb25lbnRzIGNvbnRhaW5lZCB3aXRoaW4gYSA8UmVjb2lsUm9vdD4gY29tcG9uZW50LicpO1xuICB9XG5cbiAgY29uc3QgbG9hZGFibGUgPSB1c2VNdXRhYmxlU291cmNlJDEoc291cmNlLCBnZXRMb2FkYWJsZVdpdGhUZXN0aW5nLCBzdWJzY3JpYmUpO1xuICBjb25zdCBwcmV2TG9hZGFibGVSZWYgPSB1c2VSZWYkNChsb2FkYWJsZSk7XG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcbiAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IGxvYWRhYmxlO1xuICB9KTtcbiAgcmV0dXJuIGxvYWRhYmxlO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVChyZWNvaWxWYWx1ZSkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7IC8vIEFjY2Vzc29ycyB0byBnZXQgdGhlIGN1cnJlbnQgc3RhdGVcblxuICBjb25zdCBnZXRMb2FkYWJsZSA9IHVzZUNhbGxiYWNrJDEoKCkgPT4ge1xuICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTQ7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HLmN1cnJlbnQrKztcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgdHJlZVN0YXRlID0gcmVhY3RNb2RlJDMoKS5lYXJseSA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZTQgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZTQgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJG5leHRUcmVlNCA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMihzdG9yZSwgcmVjb2lsVmFsdWUsIHRyZWVTdGF0ZSk7XG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsVmFsdWVdKTtcbiAgY29uc3QgZ2V0U3RhdGUgPSB1c2VDYWxsYmFjayQxKCgpID0+ICh7XG4gICAgbG9hZGFibGU6IGdldExvYWRhYmxlKCksXG4gICAga2V5OiByZWNvaWxWYWx1ZS5rZXlcbiAgfSksIFtnZXRMb2FkYWJsZSwgcmVjb2lsVmFsdWUua2V5XSk7IC8vIE1lbW9pemUgc3RhdGUgc25hcHNob3RzXG5cbiAgY29uc3QgdXBkYXRlU3RhdGUgPSB1c2VDYWxsYmFjayQxKHByZXZTdGF0ZSA9PiB7XG4gICAgY29uc3QgbmV4dFN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4gcHJldlN0YXRlLmxvYWRhYmxlLmlzKG5leHRTdGF0ZS5sb2FkYWJsZSkgJiYgcHJldlN0YXRlLmtleSA9PT0gbmV4dFN0YXRlLmtleSA/IHByZXZTdGF0ZSA6IG5leHRTdGF0ZTtcbiAgfSwgW2dldFN0YXRlXSk7IC8vIFN1YnNjcmliZSB0byBSZWNvaWwgc3RhdGUgY2hhbmdlc1xuXG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsVmFsdWUsIF9zdGF0ZSA9PiB7XG4gICAgICBzZXRTdGF0ZSh1cGRhdGVTdGF0ZSk7XG4gICAgfSwgY29tcG9uZW50TmFtZSk7IC8vIFVwZGF0ZSBzdGF0ZSBpbiBjYXNlIHdlIGFyZSB1c2luZyBhIGRpZmZlcmVudCBrZXlcblxuICAgIHNldFN0YXRlKHVwZGF0ZVN0YXRlKTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uLnJlbGVhc2U7XG4gIH0sIFtjb21wb25lbnROYW1lLCByZWNvaWxWYWx1ZSwgc3RvcmVSZWYsIHVwZGF0ZVN0YXRlXSk7IC8vIEdldCB0aGUgY3VycmVudCBzdGF0ZVxuXG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUkMShnZXRTdGF0ZSk7IC8vIElmIHdlIGNoYW5nZWQga2V5cywgdGhlbiByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgbmV3IGtleS5cbiAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgaW4gY2FzZSB0aGUgb2xkIGtleSB3b3VsZCBjYXVzZSB0aGUgY29tcG9uZW50IHRvIHN1c3BlbmQuXG4gIC8vIFdlIGRvbid0IGhhdmUgdG8gc2V0IHRoZSBuZXcgc3RhdGUgaGVyZSBzaW5jZSB0aGUgc3Vic2NyaWJpbmcgZWZmZWN0IGFib3ZlXG4gIC8vIHdpbGwgZG8gdGhhdC5cblxuICByZXR1cm4gc3RhdGUua2V5ICE9PSByZWNvaWxWYWx1ZS5rZXkgPyBnZXRTdGF0ZSgpLmxvYWRhYmxlIDogc3RhdGUubG9hZGFibGU7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfTEVHQUNZKHJlY29pbFZhbHVlKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICBjb25zdCBbLCBmb3JjZVVwZGF0ZV0gPSB1c2VTdGF0ZSQxKFtdKTtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7XG4gIGNvbnN0IGdldExvYWRhYmxlID0gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XG4gICAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlNTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkcuY3VycmVudCsrO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0cmVlU3RhdGUgPSByZWFjdE1vZGUkMygpLmVhcmx5ID8gKF9zdG9yZVN0YXRlJG5leHRUcmVlNSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlNSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWU1IDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG4gICAgcmV0dXJuIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyKHN0b3JlLCByZWNvaWxWYWx1ZSwgdHJlZVN0YXRlKTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZV0pO1xuICBjb25zdCBsb2FkYWJsZSA9IGdldExvYWRhYmxlKCk7XG4gIGNvbnN0IHByZXZMb2FkYWJsZVJlZiA9IHVzZVJlZiQ0KGxvYWRhYmxlKTtcbiAgdXNlRWZmZWN0JDMoKCkgPT4ge1xuICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbG9hZGFibGU7XG4gIH0pO1xuICB1c2VFZmZlY3QkMygoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMShzdG9yZSwgcmVjb2lsVmFsdWUsIF9zdGF0ZSA9PiB7XG4gICAgICB2YXIgX3ByZXZMb2FkYWJsZVJlZiRjdXJyO1xuXG4gICAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycpKSB7XG4gICAgICAgIHJldHVybiBmb3JjZVVwZGF0ZShbXSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0xvYWRhYmxlID0gZ2V0TG9hZGFibGUoKTtcblxuICAgICAgaWYgKCEoKF9wcmV2TG9hZGFibGVSZWYkY3VyciA9IHByZXZMb2FkYWJsZVJlZi5jdXJyZW50KSAhPT0gbnVsbCAmJiBfcHJldkxvYWRhYmxlUmVmJGN1cnIgIT09IHZvaWQgMCAmJiBfcHJldkxvYWRhYmxlUmVmJGN1cnIuaXMobmV3TG9hZGFibGUpKSkge1xuICAgICAgICBmb3JjZVVwZGF0ZShuZXdMb2FkYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbmV3TG9hZGFibGU7XG4gICAgfSwgY29tcG9uZW50TmFtZSk7XG4gICAgLyoqXG4gICAgICogU2luY2Ugd2UncmUgc3Vic2NyaWJpbmcgaW4gYW4gZWZmZWN0IHdlIG5lZWQgdG8gdXBkYXRlIHRvIHRoZSBsYXRlc3RcbiAgICAgKiB2YWx1ZSBvZiB0aGUgYXRvbSBzaW5jZSBpdCBtYXkgaGF2ZSBjaGFuZ2VkIHNpbmNlIHdlIHJlbmRlcmVkLiBXZSBjYW5cbiAgICAgKiBnbyBhaGVhZCBhbmQgZG8gdGhhdCBub3csIHVubGVzcyB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgYmF0Y2ggLS1cbiAgICAgKiBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBkbyBpdCBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaCwgZHVlIHRvIHRoZVxuICAgICAqIGZvbGxvd2luZyBlZGdlIGNhc2U6IFN1cHBvc2UgYW4gYXRvbSBpcyB1cGRhdGVkIGluIGFub3RoZXIgdXNlRWZmZWN0XG4gICAgICogb2YgdGhpcyBzYW1lIGNvbXBvbmVudC4gVGhlbiB0aGUgZm9sbG93aW5nIHNlcXVlbmNlIG9mIGV2ZW50cyBvY2N1cjpcbiAgICAgKiAxLiBBdG9tIGlzIHVwZGF0ZWQgYW5kIHN1YnMgZmlyZWQgKGJ1dCB3ZSBtYXkgbm90IGJlIHN1YnNjcmliZWRcbiAgICAgKiAgICB5ZXQgZGVwZW5kaW5nIG9uIG9yZGVyIG9mIGVmZmVjdHMsIHNvIHdlIG1pc3MgdGhpcykgVXBkYXRlZCB2YWx1ZVxuICAgICAqICAgIGlzIG5vdyBpbiBuZXh0VHJlZSwgYnV0IG5vdCBjdXJyZW50VHJlZS5cbiAgICAgKiAyLiBUaGlzIGVmZmVjdCBoYXBwZW5zLiBXZSBzdWJzY3JpYmUgYW5kIHVwZGF0ZS5cbiAgICAgKiAzLiBGcm9tIHRoZSB1cGRhdGUgd2UgcmUtcmVuZGVyIGFuZCByZWFkIGN1cnJlbnRUcmVlLCB3aXRoIG9sZCB2YWx1ZS5cbiAgICAgKiA0LiBCYXRjaGVyJ3MgZWZmZWN0IHNldHMgY3VycmVudFRyZWUgdG8gbmV4dFRyZWUuXG4gICAgICogSW4gdGhpcyBzZXF1ZW5jZSB3ZSBtaXNzIHRoZSB1cGRhdGUuIFRvIGF2b2lkIHRoYXQsIGFkZCB0aGUgdXBkYXRlXG4gICAgICogdG8gcXVldWVkQ29tcG9uZW50Q2FsbGJhY2sgaWYgYSBiYXRjaCBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKi9cblxuICAgIGlmIChzdG9yZVN0YXRlLm5leHRUcmVlKSB7XG4gICAgICBzdG9yZS5nZXRTdGF0ZSgpLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELnB1c2goKCkgPT4ge1xuICAgICAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGZvcmNlVXBkYXRlKFtdKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3ByZXZMb2FkYWJsZVJlZiRjdXJyMjtcblxuICAgICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snKSkge1xuICAgICAgICByZXR1cm4gZm9yY2VVcGRhdGUoW10pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdMb2FkYWJsZSA9IGdldExvYWRhYmxlKCk7XG5cbiAgICAgIGlmICghKChfcHJldkxvYWRhYmxlUmVmJGN1cnIyID0gcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQpICE9PSBudWxsICYmIF9wcmV2TG9hZGFibGVSZWYkY3VycjIgIT09IHZvaWQgMCAmJiBfcHJldkxvYWRhYmxlUmVmJGN1cnIyLmlzKG5ld0xvYWRhYmxlKSkpIHtcbiAgICAgICAgZm9yY2VVcGRhdGUobmV3TG9hZGFibGUpO1xuICAgICAgfVxuXG4gICAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IG5ld0xvYWRhYmxlO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucmVsZWFzZTtcbiAgfSwgW2NvbXBvbmVudE5hbWUsIGdldExvYWRhYmxlLCByZWNvaWxWYWx1ZSwgc3RvcmVSZWZdKTtcbiAgcmV0dXJuIGxvYWRhYmxlO1xufVxuLyoqXG4gIExpa2UgdXNlUmVjb2lsVmFsdWUoKSwgYnV0IGVpdGhlciByZXR1cm5zIHRoZSB2YWx1ZSBpZiBhdmFpbGFibGUgb3JcbiAganVzdCB1bmRlZmluZWQgaWYgbm90IGF2YWlsYWJsZSBmb3IgYW55IHJlYXNvbiwgc3VjaCBhcyBwZW5kaW5nIG9yIGVycm9yLlxuKi9cblxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlLCAndXNlUmVjb2lsVmFsdWVMb2FkYWJsZScpO1xuICB9XG5cbiAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L3JlYWN0LWhvb2tzXG4gICAgUmVjb2lsX3VzZVJldGFpbihyZWNvaWxWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIFRSQU5TSVRJT05fU1VQUE9SVDogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlQsXG4gICAgU1lOQ19FWFRFUk5BTF9TVE9SRTogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9TWU5DX0VYVEVSTkFMX1NUT1JFLFxuICAgIE1VVEFCTEVfU09VUkNFOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX01VVEFCTEVfU09VUkNFLFxuICAgIExFR0FDWTogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9MRUdBQ1lcbiAgfVtyZWFjdE1vZGUkMygpLm1vZGVdKHJlY29pbFZhbHVlKTtcbn1cbi8qKlxuICBSZXR1cm5zIHRoZSB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgUmVjb2lsVmFsdWUuXG4gIElmIHRoZSB2YWx1ZSBpcyBwZW5kaW5nLCBpdCB3aWxsIHRocm93IGEgUHJvbWlzZSB0byBzdXNwZW5kIHRoZSBjb21wb25lbnQsXG4gIGlmIHRoZSB2YWx1ZSBpcyBhbiBlcnJvciBpdCB3aWxsIHRocm93IGl0IGZvciB0aGUgbmVhcmVzdCBSZWFjdCBlcnJvciBib3VuZGFyeS5cbiAgVGhpcyB3aWxsIGFsc28gc3Vic2NyaWJlIHRoZSBjb21wb25lbnQgZm9yIGFueSB1cGRhdGVzIGluIHRoZSB2YWx1ZS5cbiAgKi9cblxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSwgJ3VzZVJlY29pbFZhbHVlJyk7XG4gIH1cblxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgY29uc3QgbG9hZGFibGUgPSB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFZhbHVlKTtcbiAgcmV0dXJuIGhhbmRsZUxvYWRhYmxlKGxvYWRhYmxlLCByZWNvaWxWYWx1ZSwgc3RvcmVSZWYpO1xufVxuLyoqXG4gIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFsbG93cyB0aGUgdmFsdWUgb2YgYSBSZWNvaWxTdGF0ZSB0byBiZSB1cGRhdGVkLCBidXQgZG9lc1xuICBub3Qgc3Vic2NyaWJlIHRoZSBjb21wb25lbnQgdG8gY2hhbmdlcyB0byB0aGF0IFJlY29pbFN0YXRlLlxuKi9cblxuXG5mdW5jdGlvbiB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVNldFJlY29pbFN0YXRlJyk7XG4gIH1cblxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDEobmV3VmFsdWVPclVwZGF0ZXIgPT4ge1xuICAgIHNldFJlY29pbFZhbHVlJDIoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsU3RhdGUsIG5ld1ZhbHVlT3JVcGRhdGVyKTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxTdGF0ZV0pO1xufVxuLyoqXG4gIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVzZXQgdGhlIHZhbHVlIG9mIGEgUmVjb2lsU3RhdGUgdG8gaXRzIGRlZmF1bHRcbiovXG5cblxuZnVuY3Rpb24gdXNlUmVzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlc2V0UmVjb2lsU3RhdGUnKTtcbiAgfVxuXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XG4gICAgc2V0UmVjb2lsVmFsdWUkMihzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxTdGF0ZSwgREVGQVVMVF9WQUxVRSQyKTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxTdGF0ZV0pO1xufVxuLyoqXG4gIEVxdWl2YWxlbnQgdG8gdXNlU3RhdGUoKS4gQWxsb3dzIHRoZSB2YWx1ZSBvZiB0aGUgUmVjb2lsU3RhdGUgdG8gYmUgcmVhZCBhbmQgd3JpdHRlbi5cbiAgU3Vic2VxdWVudCB1cGRhdGVzIHRvIHRoZSBSZWNvaWxTdGF0ZSB3aWxsIGNhdXNlIHRoZSBjb21wb25lbnQgdG8gcmUtcmVuZGVyLiBJZiB0aGVcbiAgUmVjb2lsU3RhdGUgaXMgcGVuZGluZywgdGhpcyB3aWxsIHN1c3BlbmQgdGhlIGNvbXBvbmVudCBhbmQgaW5pdGlhdGUgdGhlXG4gIHJldHJpZXZhbCBvZiB0aGUgdmFsdWUuIElmIGV2YWx1YXRpbmcgdGhlIFJlY29pbFN0YXRlIHJlc3VsdGVkIGluIGFuIGVycm9yLCB0aGlzIHdpbGxcbiAgdGhyb3cgdGhlIGVycm9yIHNvIHRoYXQgdGhlIG5lYXJlc3QgUmVhY3QgZXJyb3IgYm91bmRhcnkgY2FuIGNhdGNoIGl0LlxuKi9cblxuXG5mdW5jdGlvbiB1c2VSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlY29pbFN0YXRlJyk7XG4gIH1cblxuICByZXR1cm4gW3VzZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcbn1cbi8qKlxuICBMaWtlIHVzZVJlY29pbFN0YXRlKCksIGJ1dCBkb2VzIG5vdCBjYXVzZSBTdXNwZW5zZSBvciBSZWFjdCBlcnJvciBoYW5kbGluZy4gUmV0dXJuc1xuICBhbiBvYmplY3QgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgUmVjb2lsU3RhdGUgaXMgYXZhaWxhYmxlLCBwZW5kaW5nLCBvclxuICB1bmF2YWlsYWJsZSBkdWUgdG8gYW4gZXJyb3IuXG4qL1xuXG5cbmZ1bmN0aW9uIHVzZVJlY29pbFN0YXRlTG9hZGFibGUocmVjb2lsU3RhdGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlJyk7XG4gIH1cblxuICByZXR1cm4gW3VzZVJlY29pbFZhbHVlTG9hZGFibGUocmVjb2lsU3RhdGUpLCB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSldO1xufVxuXG5mdW5jdGlvbiB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMoKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICByZXR1cm4gKHZhbHVlcywgdHJhbnNhY3Rpb25NZXRhZGF0YSA9IHt9KSA9PiB7XG4gICAgYmF0Y2hVcGRhdGVzJDIoKCkgPT4ge1xuICAgICAgc3RvcmVSZWYuY3VycmVudC5hZGRUcmFuc2FjdGlvbk1ldGFkYXRhKHRyYW5zYWN0aW9uTWV0YWRhdGEpO1xuICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMihzdG9yZVJlZi5jdXJyZW50LCBuZXcgQWJzdHJhY3RSZWNvaWxWYWx1ZSQzKGtleSksIHZhbHVlKSk7XG4gICAgfSk7XG4gIH07XG59XG4vKipcbiAqIEV4cGVyaW1lbnRhbCB2YXJpYW50cyBvZiBob29rcyB3aXRoIHN1cHBvcnQgZm9yIHVzZVRyYW5zaXRpb24oKVxuICovXG5cblxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsVmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRScpO1xuXG4gICAgaWYgKCFyZWFjdE1vZGUkMygpLmVhcmx5KSB7XG4gICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ0F0dGVwbXQgdG8gdXNlIGEgaG9vayB3aXRoIFVOU1RBQkxFX1RSQU5TSVRJT05fU1VQUE9SVCBpbiBhIHJlbmRlcmluZyBtb2RlIGluY29tcGF0aWJsZSB3aXRoIGNvbmN1cnJlbnQgcmVuZGVyaW5nLiAgVHJ5IGVuYWJsaW5nIHRoZSByZWNvaWxfc3luY19leHRlcm5hbF9zdG9yZSBvciByZWNvaWxfdHJhbnNpdGlvbl9zdXBwb3J0IEdLcy4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvcmVhY3QtaG9va3NcbiAgICBSZWNvaWxfdXNlUmV0YWluKHJlY29pbFZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVChyZWNvaWxWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRShyZWNvaWxWYWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSwgJ3VzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRScpO1xuICB9XG5cbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XG4gIGNvbnN0IGxvYWRhYmxlID0gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsVmFsdWUpO1xuICByZXR1cm4gaGFuZGxlTG9hZGFibGUobG9hZGFibGUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZik7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRShyZWNvaWxTdGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRScpO1xuICB9XG5cbiAgcmV0dXJuIFt1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsU3RhdGUpLCB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSldO1xufVxuXG52YXIgUmVjb2lsX0hvb2tzID0ge1xuICByZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HLFxuICB1c2VSZWNvaWxJbnRlcmZhY2U6IHVzZVJlY29pbEludGVyZmFjZV9ERVBSRUNBVEVELFxuICB1c2VSZWNvaWxTdGF0ZSxcbiAgdXNlUmVjb2lsU3RhdGVMb2FkYWJsZSxcbiAgdXNlUmVjb2lsVmFsdWUsXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGUsXG4gIHVzZVJlc2V0UmVjb2lsU3RhdGUsXG4gIHVzZVNldFJlY29pbFN0YXRlLFxuICB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMsXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFLFxuICB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUsXG4gIHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIG1hcCBjb250YWluaW5nIGFsbCBvZiB0aGUga2V5cyArIHZhbHVlcyBmcm9tIHRoZSBvcmlnaW5hbCBtYXAgd2hlcmVcbiAqIHRoZSBnaXZlbiBjYWxsYmFjayByZXR1cm5lZCB0cnVlLlxuICovXG5cbmZ1bmN0aW9uIGZpbHRlck1hcChtYXAsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcblxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXApIHtcbiAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSkpIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlY29pbF9maWx0ZXJNYXAgPSBmaWx0ZXJNYXA7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIFJldHVybnMgYSBzZXQgY29udGFpbmluZyBhbGwgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBvcmlnaW5hbCBzZXQgd2hlcmVcbiAqIHRoZSBnaXZlbiBjYWxsYmFjayByZXR1cm5lZCB0cnVlLlxuICovXG5cbmZ1bmN0aW9uIGZpbHRlclNldChzZXQsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcblxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHNldCkge1xuICAgIGlmIChjYWxsYmFjayh2YWx1ZSkpIHtcbiAgICAgIHJlc3VsdC5hZGQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBSZWNvaWxfZmlsdGVyU2V0ID0gZmlsdGVyU2V0O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBtZXJnZU1hcHMoLi4ubWFwcykge1xuICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBtYXBzW2ldLmtleXMoKTtcbiAgICBsZXQgbmV4dEtleTtcblxuICAgIHdoaWxlICghKG5leHRLZXkgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLWNhbGxdIC0gbWFwL2l0ZXJhdG9yIGtub3dzIG5vdGhpbmcgYWJvdXQgZmxvdyB0eXBlc1xuICAgICAgcmVzdWx0LnNldChuZXh0S2V5LnZhbHVlLCBtYXBzW2ldLmdldChuZXh0S2V5LnZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlY29pbF9tZXJnZU1hcHMgPSBtZXJnZU1hcHM7XG5cbmNvbnN0IHtcbiAgYmF0Y2hVcGRhdGVzOiBiYXRjaFVwZGF0ZXMkM1xufSA9IFJlY29pbF9CYXRjaGluZztcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDMsXG4gIGdldE5vZGU6IGdldE5vZGUkNCxcbiAgbm9kZXM6IG5vZGVzJDFcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkM1xufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkNCxcbiAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZTogc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIFNVU1BFTlNFX1RJTUVPVVRfTVM6IFNVU1BFTlNFX1RJTUVPVVRfTVMkMlxufSA9IFJlY29pbF9SZXRlbnRpb247XG5cbmNvbnN0IHtcbiAgY2xvbmVTbmFwc2hvdDogY2xvbmVTbmFwc2hvdCQxXG59ID0gUmVjb2lsX1NuYXBzaG90JDE7XG5cbmNvbnN0IHtcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrJDIsXG4gIHVzZUVmZmVjdDogdXNlRWZmZWN0JDQsXG4gIHVzZVJlZjogdXNlUmVmJDUsXG4gIHVzZVN0YXRlOiB1c2VTdGF0ZSQyXG59ID0gcmVhY3Q7XG5cbmNvbnN0IHtcbiAgaXNTU1I6IGlzU1NSJDNcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiB1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvbihjYWxsYmFjaykge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDMoKTtcbiAgdXNlRWZmZWN0JDQoKCkgPT4ge1xuICAgIGNvbnN0IHN1YiA9IHN0b3JlUmVmLmN1cnJlbnQuc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnMoY2FsbGJhY2spO1xuICAgIHJldHVybiBzdWIucmVsZWFzZTtcbiAgfSwgW2NhbGxiYWNrLCBzdG9yZVJlZl0pO1xufVxuXG5mdW5jdGlvbiBleHRlcm5hbGx5VmlzaWJsZUF0b21WYWx1ZXNJblN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IGF0b21WYWx1ZXMgPSBzdGF0ZS5hdG9tVmFsdWVzLnRvTWFwKCk7XG4gIGNvbnN0IHBlcnNpc3RlZEF0b21Db250ZW50c1ZhbHVlcyA9IFJlY29pbF9tYXBNYXAoUmVjb2lsX2ZpbHRlck1hcChhdG9tVmFsdWVzLCAodiwgaykgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBnZXROb2RlJDQoayk7XG4gICAgY29uc3QgcGVyc2lzdGVuY2UgPSBub2RlLnBlcnNpc3RlbmNlX1VOU1RBQkxFO1xuICAgIHJldHVybiBwZXJzaXN0ZW5jZSAhPSBudWxsICYmIHBlcnNpc3RlbmNlLnR5cGUgIT09ICdub25lJyAmJiB2LnN0YXRlID09PSAnaGFzVmFsdWUnO1xuICB9KSwgdiA9PiB2LmNvbnRlbnRzKTsgLy8gTWVyZ2UgaW4gbm9udmFsaWRhdGVkIGF0b21zOyB3ZSBtYXkgbm90IGhhdmUgZGVmcyBmb3IgdGhlbSBidXQgdGhleSB3aWxsXG4gIC8vIGFsbCBoYXZlIHBlcnNpc3RlbmNlIG9uIG9yIHRoZXkgd291bGRuJ3QgYmUgdGhlcmUgaW4gdGhlIGZpcnN0IHBsYWNlLlxuXG4gIHJldHVybiBSZWNvaWxfbWVyZ2VNYXBzKHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLnRvTWFwKCksIHBlcnNpc3RlZEF0b21Db250ZW50c1ZhbHVlcyk7XG59XG5cbi8qKlxuICBDYWxscyB0aGUgZ2l2ZW4gY2FsbGJhY2sgYWZ0ZXIgYW55IGF0b21zIGhhdmUgYmVlbiBtb2RpZmllZCBhbmQgdGhlIGNvbnNlcXVlbnRcbiAgY29tcG9uZW50IHJlLXJlbmRlcnMgaGF2ZSBiZWVuIGNvbW1pdHRlZC4gVGhpcyBpcyBpbnRlbmRlZCBmb3IgcGVyc2lzdGluZ1xuICB0aGUgdmFsdWVzIG9mIHRoZSBhdG9tcyB0byBzdG9yYWdlLiBUaGUgc3RvcmVkIHZhbHVlcyBjYW4gdGhlbiBiZSByZXN0b3JlZFxuICB1c2luZyB0aGUgdXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzIGhvb2suXG5cbiAgVGhlIGNhbGxiYWNrIHJlY2VpdmVzIHRoZSBmb2xsb3dpbmcgaW5mbzpcblxuICBhdG9tVmFsdWVzOiBUaGUgY3VycmVudCB2YWx1ZSBvZiBldmVyeSBhdG9tIHRoYXQgaXMgYm90aCBwZXJzaXN0YWJsZSAocGVyc2lzdGVuY2VcbiAgICAgICAgICAgICAgdHlwZSBub3Qgc2V0IHRvICdub25lJykgYW5kIHdob3NlIHZhbHVlIGlzIGF2YWlsYWJsZSAobm90IGluIGFuXG4gICAgICAgICAgICAgIGVycm9yIG9yIGxvYWRpbmcgc3RhdGUpLlxuXG4gIHByZXZpb3VzQXRvbVZhbHVlczogVGhlIHZhbHVlIG9mIGV2ZXJ5IHBlcnNpc3RhYmxlIGFuZCBhdmFpbGFibGUgYXRvbSBiZWZvcmVcbiAgICAgICAgICAgICAgIHRoZSB0cmFuc2FjdGlvbiBiZWdhbi5cblxuICBhdG9tSW5mbzogQSBtYXAgY29udGFpbmluZyB0aGUgcGVyc2lzdGVuY2Ugc2V0dGluZ3MgZm9yIGVhY2ggYXRvbS4gRXZlcnkga2V5XG4gICAgICAgICAgICB0aGF0IGV4aXN0cyBpbiBhdG9tVmFsdWVzIHdpbGwgYWxzbyBleGlzdCBpbiBhdG9tSW5mby5cblxuICBtb2RpZmllZEF0b21zOiBUaGUgc2V0IG9mIGF0b21zIHRoYXQgd2VyZSB3cml0dGVuIHRvIGR1cmluZyB0aGUgdHJhbnNhY3Rpb24uXG5cbiAgdHJhbnNhY3Rpb25NZXRhZGF0YTogQXJiaXRyYXJ5IGluZm9ybWF0aW9uIHRoYXQgd2FzIGFkZGVkIHZpYSB0aGVcbiAgICAgICAgICB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMgaG9vay4gVXNlZnVsIGZvciBpZ25vcmluZyB0aGUgdXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzXG4gICAgICAgICAgdHJhbnNhY3Rpb24sIHRvIGF2b2lkIGxvb3BzLlxuKi9cbmZ1bmN0aW9uIHVzZVRyYW5zYWN0aW9uT2JzZXJ2YXRpb25fREVQUkVDQVRFRChjYWxsYmFjaykge1xuICB1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvbih1c2VDYWxsYmFjayQyKHN0b3JlID0+IHtcbiAgICBsZXQgcHJldmlvdXNUcmVlID0gc3RvcmUuZ2V0U3RhdGUoKS5wcmV2aW91c1RyZWU7XG4gICAgY29uc3QgY3VycmVudFRyZWUgPSBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xuXG4gICAgaWYgKCFwcmV2aW91c1RyZWUpIHtcbiAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignVHJhbnNhY3Rpb24gc3Vic2NyaWJlcnMgbm90aWZpZWQgd2l0aG91dCBhIHByZXZpb3VzIHRyZWUgYmVpbmcgcHJlc2VudCAtLSB0aGlzIGlzIGEgYnVnIGluIFJlY29pbCcpO1xuICAgICAgcHJldmlvdXNUcmVlID0gc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZTsgLy8gYXR0ZW1wdCB0byB0cnVuZGxlIG9uXG4gICAgfVxuXG4gICAgY29uc3QgYXRvbVZhbHVlcyA9IGV4dGVybmFsbHlWaXNpYmxlQXRvbVZhbHVlc0luU3RhdGUoY3VycmVudFRyZWUpO1xuICAgIGNvbnN0IHByZXZpb3VzQXRvbVZhbHVlcyA9IGV4dGVybmFsbHlWaXNpYmxlQXRvbVZhbHVlc0luU3RhdGUocHJldmlvdXNUcmVlKTtcbiAgICBjb25zdCBhdG9tSW5mbyA9IFJlY29pbF9tYXBNYXAobm9kZXMkMSwgbm9kZSA9PiB7XG4gICAgICB2YXIgX25vZGUkcGVyc2lzdGVuY2VfVU5TLCBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMyLCBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMzLCBfbm9kZSRwZXJzaXN0ZW5jZV9VTlM0O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwZXJzaXN0ZW5jZV9VTlNUQUJMRToge1xuICAgICAgICAgIHR5cGU6IChfbm9kZSRwZXJzaXN0ZW5jZV9VTlMgPSAoX25vZGUkcGVyc2lzdGVuY2VfVU5TMiA9IG5vZGUucGVyc2lzdGVuY2VfVU5TVEFCTEUpID09PSBudWxsIHx8IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzIudHlwZSkgIT09IG51bGwgJiYgX25vZGUkcGVyc2lzdGVuY2VfVU5TICE9PSB2b2lkIDAgPyBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMgOiAnbm9uZScsXG4gICAgICAgICAgYmFja0J1dHRvbjogKF9ub2RlJHBlcnNpc3RlbmNlX1VOUzMgPSAoX25vZGUkcGVyc2lzdGVuY2VfVU5TNCA9IG5vZGUucGVyc2lzdGVuY2VfVU5TVEFCTEUpID09PSBudWxsIHx8IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzQuYmFja0J1dHRvbikgIT09IG51bGwgJiYgX25vZGUkcGVyc2lzdGVuY2VfVU5TMyAhPT0gdm9pZCAwID8gX25vZGUkcGVyc2lzdGVuY2VfVU5TMyA6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7IC8vIEZpbHRlciBvbiBleGlzdGFuY2UgaW4gYXRvbVZhbHVlcyBzbyB0aGF0IGV4dGVybmFsbHktdmlzaWJsZSBydWxlc1xuICAgIC8vIGFyZSBhbHNvIGFwcGxpZWQgdG8gbW9kaWZpZWQgYXRvbXMgKHNwZWNpZmljYWxseSBleGNsdWRlIHNlbGVjdG9ycyk6XG5cbiAgICBjb25zdCBtb2RpZmllZEF0b21zID0gUmVjb2lsX2ZpbHRlclNldChjdXJyZW50VHJlZS5kaXJ0eUF0b21zLCBrID0+IGF0b21WYWx1ZXMuaGFzKGspIHx8IHByZXZpb3VzQXRvbVZhbHVlcy5oYXMoaykpO1xuICAgIGNhbGxiYWNrKHtcbiAgICAgIGF0b21WYWx1ZXMsXG4gICAgICBwcmV2aW91c0F0b21WYWx1ZXMsXG4gICAgICBhdG9tSW5mbyxcbiAgICAgIG1vZGlmaWVkQXRvbXMsXG4gICAgICB0cmFuc2FjdGlvbk1ldGFkYXRhOiB7IC4uLmN1cnJlbnRUcmVlLnRyYW5zYWN0aW9uTWV0YWRhdGFcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW2NhbGxiYWNrXSkpO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gIHVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uKHVzZUNhbGxiYWNrJDIoc3RvcmUgPT4ge1xuICAgIGNvbnN0IHNuYXBzaG90ID0gY2xvbmVTbmFwc2hvdCQxKHN0b3JlLCAnbGF0ZXN0Jyk7XG4gICAgY29uc3QgcHJldmlvdXNTbmFwc2hvdCA9IGNsb25lU25hcHNob3QkMShzdG9yZSwgJ3ByZXZpb3VzJyk7XG4gICAgY2FsbGJhY2soe1xuICAgICAgc25hcHNob3QsXG4gICAgICBwcmV2aW91c1NuYXBzaG90XG4gICAgfSk7XG4gIH0sIFtjYWxsYmFja10pKTtcbn0gLy8gUmV0dXJuIGEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHN1YnNjcmliZSB0byBhbGwgc3RhdGUgY2hhbmdlc1xuXG5cbmZ1bmN0aW9uIHVzZVJlY29pbFNuYXBzaG90KCkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDMoKTtcbiAgY29uc3QgW3NuYXBzaG90LCBzZXRTbmFwc2hvdF0gPSB1c2VTdGF0ZSQyKCgpID0+IGNsb25lU25hcHNob3QkMShzdG9yZVJlZi5jdXJyZW50KSk7XG4gIGNvbnN0IHByZXZpb3VzU25hcHNob3QgPSBSZWNvaWxfdXNlUHJldmlvdXMoc25hcHNob3QpO1xuICBjb25zdCB0aW1lb3V0SUQgPSB1c2VSZWYkNSgpO1xuICBjb25zdCByZWxlYXNlUmVmID0gdXNlUmVmJDUoKTtcbiAgdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb24odXNlQ2FsbGJhY2skMihzdG9yZSA9PiBzZXRTbmFwc2hvdChjbG9uZVNuYXBzaG90JDEoc3RvcmUpKSwgW10pKTsgLy8gUmV0YWluIHNuYXBzaG90IGZvciBkdXJhdGlvbiBjb21wb25lbnQgaXMgbW91bnRlZFxuXG4gIHVzZUVmZmVjdCQ0KCgpID0+IHtcbiAgICBjb25zdCByZWxlYXNlID0gc25hcHNob3QucmV0YWluKCk7IC8vIFJlbGVhc2UgdGhlIHJldGFpbiBmcm9tIHRoZSByZW5kZXJpbmcgY2FsbFxuXG4gICAgaWYgKHRpbWVvdXRJRC5jdXJyZW50ICYmICFpc1NTUiQzKSB7XG4gICAgICB2YXIgX3JlbGVhc2VSZWYkY3VycmVudDtcblxuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0SUQuY3VycmVudCk7XG4gICAgICB0aW1lb3V0SUQuY3VycmVudCA9IG51bGw7XG4gICAgICAoX3JlbGVhc2VSZWYkY3VycmVudCA9IHJlbGVhc2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX3JlbGVhc2VSZWYkY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbGVhc2VSZWYkY3VycmVudC5jYWxsKHJlbGVhc2VSZWYpO1xuICAgICAgcmVsZWFzZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gRGVmZXIgdGhlIHJlbGVhc2UuICBJZiBcIkZhc3QgUmVmcmVzaFwiXCIgaXMgdXNlZCB0aGVuIHRoZSBjb21wb25lbnQgbWF5XG4gICAgICAvLyByZS1yZW5kZXIgd2l0aCB0aGUgc2FtZSBzdGF0ZS4gIFRoZSBwcmV2aW91cyBjbGVhbnVwIHdpbGwgdGhlbiBydW4gYW5kXG4gICAgICAvLyB0aGVuIHRoZSBuZXcgZWZmZWN0IHdpbGwgcnVuLiBXZSBkb24ndCB3YW50IHRoZSBzbmFwc2hvdCB0byBiZSByZWxlYXNlZFxuICAgICAgLy8gYnkgdGhhdCBjbGVhbnVwIGJlZm9yZSB0aGUgbmV3IGVmZmVjdCBoYXMgYSBjaGFuY2UgdG8gcmV0YWluIGl0IGFnYWluLlxuICAgICAgLy8gVXNlIHRpbWVvdXQgb2YgMTAgdG8gd29ya2Fyb3VuZCBGaXJlZm94IGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tleHBlcmltZW50YWwvUmVjb2lsL2lzc3Vlcy8xOTM2XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChyZWxlYXNlLCAxMCk7XG4gICAgfTtcbiAgfSwgW3NuYXBzaG90XSk7IC8vIFJldGFpbiBzbmFwc2hvdCB1bnRpbCBhYm92ZSBlZmZlY3QgaXMgcnVuLlxuICAvLyBSZWxlYXNlIGFmdGVyIGEgdGhyZXNob2xkIGluIGNhc2UgY29tcG9uZW50IGlzIHN1c3BlbmRlZC5cblxuICBpZiAocHJldmlvdXNTbmFwc2hvdCAhPT0gc25hcHNob3QgJiYgIWlzU1NSJDMpIHtcbiAgICAvLyBSZWxlYXNlIHRoZSBwcmV2aW91cyBzbmFwc2hvdFxuICAgIGlmICh0aW1lb3V0SUQuY3VycmVudCkge1xuICAgICAgdmFyIF9yZWxlYXNlUmVmJGN1cnJlbnQyO1xuXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcbiAgICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gbnVsbDtcbiAgICAgIChfcmVsZWFzZVJlZiRjdXJyZW50MiA9IHJlbGVhc2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX3JlbGVhc2VSZWYkY3VycmVudDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZWxlYXNlUmVmJGN1cnJlbnQyLmNhbGwocmVsZWFzZVJlZik7XG4gICAgICByZWxlYXNlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cblxuICAgIHJlbGVhc2VSZWYuY3VycmVudCA9IHNuYXBzaG90LnJldGFpbigpO1xuICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdmFyIF9yZWxlYXNlUmVmJGN1cnJlbnQzO1xuXG4gICAgICB0aW1lb3V0SUQuY3VycmVudCA9IG51bGw7XG4gICAgICAoX3JlbGVhc2VSZWYkY3VycmVudDMgPSByZWxlYXNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9yZWxlYXNlUmVmJGN1cnJlbnQzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsZWFzZVJlZiRjdXJyZW50My5jYWxsKHJlbGVhc2VSZWYpO1xuICAgICAgcmVsZWFzZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9LCBTVVNQRU5TRV9USU1FT1VUX01TJDIpO1xuICB9XG5cbiAgcmV0dXJuIHNuYXBzaG90O1xufVxuXG5mdW5jdGlvbiBnb3RvU25hcHNob3Qoc3RvcmUsIHNuYXBzaG90KSB7XG4gIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTtcblxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3QgcHJldiA9IChfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG4gIGNvbnN0IG5leHQgPSBzbmFwc2hvdC5nZXRTdG9yZV9JTlRFUk5BTCgpLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XG4gIGJhdGNoVXBkYXRlcyQzKCgpID0+IHtcbiAgICBjb25zdCBrZXlzVG9VcGRhdGUgPSBuZXcgU2V0KCk7XG5cbiAgICBmb3IgKGNvbnN0IGtleXMgb2YgW3ByZXYuYXRvbVZhbHVlcy5rZXlzKCksIG5leHQuYXRvbVZhbHVlcy5rZXlzKCldKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIHZhciBfcHJldiRhdG9tVmFsdWVzJGdldCwgX25leHQkYXRvbVZhbHVlcyRnZXQ7XG5cbiAgICAgICAgaWYgKCgoX3ByZXYkYXRvbVZhbHVlcyRnZXQgPSBwcmV2LmF0b21WYWx1ZXMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9wcmV2JGF0b21WYWx1ZXMkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHJldiRhdG9tVmFsdWVzJGdldC5jb250ZW50cykgIT09ICgoX25leHQkYXRvbVZhbHVlcyRnZXQgPSBuZXh0LmF0b21WYWx1ZXMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9uZXh0JGF0b21WYWx1ZXMkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbmV4dCRhdG9tVmFsdWVzJGdldC5jb250ZW50cykgJiYgZ2V0Tm9kZSQ0KGtleSkuc2hvdWxkUmVzdG9yZUZyb21TbmFwc2hvdHMpIHtcbiAgICAgICAgICBrZXlzVG9VcGRhdGUuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBrZXlzVG9VcGRhdGUuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQxKHN0b3JlLCBuZXcgQWJzdHJhY3RSZWNvaWxWYWx1ZSQ0KGtleSksIG5leHQuYXRvbVZhbHVlcy5oYXMoa2V5KSA/IFJlY29pbF9udWxsdGhyb3dzKG5leHQuYXRvbVZhbHVlcy5nZXQoa2V5KSkgOiBERUZBVUxUX1ZBTFVFJDMpO1xuICAgIH0pO1xuICAgIHN0b3JlLnJlcGxhY2VTdGF0ZShzdGF0ZSA9PiAoeyAuLi5zdGF0ZSxcbiAgICAgIHN0YXRlSUQ6IHNuYXBzaG90LmdldElEKClcbiAgICB9KSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VHb3RvUmVjb2lsU25hcHNob3QoKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMygpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2skMihzbmFwc2hvdCA9PiBnb3RvU25hcHNob3Qoc3RvcmVSZWYuY3VycmVudCwgc25hcHNob3QpLCBbc3RvcmVSZWZdKTtcbn1cblxudmFyIFJlY29pbF9TbmFwc2hvdEhvb2tzID0ge1xuICB1c2VSZWNvaWxTbmFwc2hvdCxcbiAgZ290b1NuYXBzaG90LFxuICB1c2VHb3RvUmVjb2lsU25hcHNob3QsXG4gIHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXIsXG4gIHVzZVRyYW5zYWN0aW9uT2JzZXJ2YXRpb25fREVQUkVDQVRFRCxcbiAgdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25fREVQUkVDQVRFRDogdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25cbn07XG5cbmNvbnN0IHtcbiAgcGVla05vZGVJbmZvOiBwZWVrTm9kZUluZm8kMlxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkNFxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5mdW5jdGlvbiB1c2VHZXRSZWNvaWxWYWx1ZUluZm8oKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkNCgpO1xuICByZXR1cm4gKHtcbiAgICBrZXlcbiAgfSkgPT4gcGVla05vZGVJbmZvJDIoc3RvcmVSZWYuY3VycmVudCwgc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLCBrZXkpO1xufVxuXG52YXIgUmVjb2lsX3VzZUdldFJlY29pbFZhbHVlSW5mbyA9IHVzZUdldFJlY29pbFZhbHVlSW5mbztcblxuY29uc3Qge1xuICByZWFjdE1vZGU6IHJlYWN0TW9kZSQ0XG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcblxuY29uc3Qge1xuICBSZWNvaWxSb290OiBSZWNvaWxSb290JDEsXG4gIHVzZVN0b3JlUmVmOiB1c2VTdG9yZVJlZiQ1XG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XG5cblxuXG5jb25zdCB7XG4gIHVzZU1lbW86IHVzZU1lbW8kMlxufSA9IHJlYWN0O1xuXG5mdW5jdGlvbiB1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzKCkge1xuICAvLyBUaGUgdGVzdCBmYWlscyB3aGVuIHVzaW5nIHVzZU11dGFibGVTb3VyY2UoKSwgYnV0IG9ubHkgaWYgYWN0KCkgaXMgdXNlZFxuICAvLyBmb3IgdGhlIG5lc3RlZCByb290LiAgU28sIHRoaXMgbWF5IG9ubHkgYmUgYSB0ZXN0aW5nIGVudmlyb25tZW50IGlzc3VlLlxuICBpZiAocmVhY3RNb2RlJDQoKS5tb2RlID09PSAnTVVUQUJMRV9TT1VSQ0UnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9uby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBUaGVyZSBhcmUga25vd24gaXNzdWVzIHVzaW5nIHVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHMoKSBpbiByZWNvaWxfbXV0YWJsZV9zb3VyY2UgcmVuZGVyaW5nIG1vZGUuICBQbGVhc2UgY29uc2lkZXIgdXBncmFkaW5nIHRvIHJlY29pbF9zeW5jX2V4dGVybmFsX3N0b3JlIG1vZGUuJyk7XG4gIH1cblxuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlUmVmJDUoKS5jdXJyZW50O1xuICByZXR1cm4gdXNlTWVtbyQyKCgpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG4gICAgZnVuY3Rpb24gUmVjb2lsQnJpZGdlKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9yZWFjdC5jcmVhdGVFbGVtZW50KFJlY29pbFJvb3QkMSwge1xuICAgICAgICBzdG9yZV9JTlRFUk5BTDogc3RvcmVcbiAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVjb2lsQnJpZGdlO1xuICB9LCBbc3RvcmVdKTtcbn1cblxudmFyIFJlY29pbF91c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzID0gdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cztcblxuY29uc3Qge1xuICBsb2FkYWJsZVdpdGhWYWx1ZTogbG9hZGFibGVXaXRoVmFsdWUkMVxufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xuXG5jb25zdCB7XG4gIGluaXRpYWxpemVOb2RlOiBpbml0aWFsaXplTm9kZSQzXG59ID0gUmVjb2lsX0Z1bmN0aW9uYWxDb3JlO1xuXG5jb25zdCB7XG4gIERFRkFVTFRfVkFMVUU6IERFRkFVTFRfVkFMVUUkNCxcbiAgZ2V0Tm9kZTogZ2V0Tm9kZSQ1XG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgY29weVRyZWVTdGF0ZTogY29weVRyZWVTdGF0ZSQxLFxuICBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGU6IGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQzLFxuICBpbnZhbGlkYXRlRG93bnN0cmVhbXM6IGludmFsaWRhdGVEb3duc3RyZWFtcyQxLFxuICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGU6IHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZSQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5cblxuZnVuY3Rpb24gaXNBdG9tKHJlY29pbFZhbHVlKSB7XG4gIHJldHVybiBnZXROb2RlJDUocmVjb2lsVmFsdWUua2V5KS5ub2RlVHlwZSA9PT0gJ2F0b20nO1xufVxuXG5jbGFzcyBUcmFuc2FjdGlvbkludGVyZmFjZUltcGwge1xuICBjb25zdHJ1Y3RvcihzdG9yZSwgdHJlZVN0YXRlKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N0b3JlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdHJlZVN0YXRlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2hhbmdlc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0XCIsIHJlY29pbFZhbHVlID0+IHtcbiAgICAgIGlmICh0aGlzLl9jaGFuZ2VzLmhhcyhyZWNvaWxWYWx1ZS5rZXkpKSB7XG4gICAgICAgIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZXMuZ2V0KHJlY29pbFZhbHVlLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNBdG9tKHJlY29pbFZhbHVlKSkge1xuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdSZWFkaW5nIHNlbGVjdG9ycyB3aXRoaW4gYXRvbWljVXBkYXRlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9hZGFibGUgPSBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMyh0aGlzLl9zdG9yZSwgcmVjb2lsVmFsdWUsIHRoaXMuX3RyZWVTdGF0ZSk7XG5cbiAgICAgIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJykge1xuICAgICAgICByZXR1cm4gbG9hZGFibGUuY29udGVudHM7XG4gICAgICB9IGVsc2UgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzRXJyb3InKSB7XG4gICAgICAgIHRocm93IGxvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgUmVjb2lsX2VycihgRXhwZWN0ZWQgUmVjb2lsIGF0b20gJHtyZWNvaWxWYWx1ZS5rZXl9IHRvIGhhdmUgYSB2YWx1ZSwgYnV0IGl0IGlzIGluIGEgbG9hZGluZyBzdGF0ZS5gKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldFwiLCAocmVjb2lsU3RhdGUsIHZhbHVlT3JVcGRhdGVyKSA9PiB7XG4gICAgICBpZiAoIWlzQXRvbShyZWNvaWxTdGF0ZSkpIHtcbiAgICAgICAgdGhyb3cgUmVjb2lsX2VycignU2V0dGluZyBzZWxlY3RvcnMgd2l0aGluIGF0b21pY1VwZGF0ZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWVPclVwZGF0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuZ2V0KHJlY29pbFN0YXRlKTtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VzLnNldChyZWNvaWxTdGF0ZS5rZXksIHZhbHVlT3JVcGRhdGVyKGN1cnJlbnQpKTsgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgYXRvbSBhbmQgcnVuIGVmZmVjdHMgaWYgbm90IGluaXRpYWxpemVkIHlldFxuICAgICAgICBpbml0aWFsaXplTm9kZSQzKHRoaXMuX3N0b3JlLCByZWNvaWxTdGF0ZS5rZXksICdzZXQnKTtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VzLnNldChyZWNvaWxTdGF0ZS5rZXksIHZhbHVlT3JVcGRhdGVyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc2V0XCIsIHJlY29pbFN0YXRlID0+IHtcbiAgICAgIHRoaXMuc2V0KHJlY29pbFN0YXRlLCBERUZBVUxUX1ZBTFVFJDQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLl90cmVlU3RhdGUgPSB0cmVlU3RhdGU7XG4gICAgdGhpcy5fY2hhbmdlcyA9IG5ldyBNYXAoKTtcbiAgfSAvLyBBbGxvdyBkZXN0cnVjdGluZ1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L2V4dHJhLWFycm93LWluaXRpYWxpemVyXG5cblxuICBuZXdUcmVlU3RhdGVfSU5URVJOQUwoKSB7XG4gICAgaWYgKHRoaXMuX2NoYW5nZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyZWVTdGF0ZTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdTdGF0ZSA9IGNvcHlUcmVlU3RhdGUkMSh0aGlzLl90cmVlU3RhdGUpO1xuXG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgdGhpcy5fY2hhbmdlcykge1xuICAgICAgd3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlJDEobmV3U3RhdGUsIGssIGxvYWRhYmxlV2l0aFZhbHVlJDEodikpO1xuICAgIH1cblxuICAgIGludmFsaWRhdGVEb3duc3RyZWFtcyQxKHRoaXMuX3N0b3JlLCBuZXdTdGF0ZSk7XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gYXRvbWljVXBkYXRlcihzdG9yZSkge1xuICByZXR1cm4gZm4gPT4ge1xuICAgIHN0b3JlLnJlcGxhY2VTdGF0ZSh0cmVlU3RhdGUgPT4ge1xuICAgICAgY29uc3QgY2hhbmdlc2V0ID0gbmV3IFRyYW5zYWN0aW9uSW50ZXJmYWNlSW1wbChzdG9yZSwgdHJlZVN0YXRlKTtcbiAgICAgIGZuKGNoYW5nZXNldCk7XG4gICAgICByZXR1cm4gY2hhbmdlc2V0Lm5ld1RyZWVTdGF0ZV9JTlRFUk5BTCgpO1xuICAgIH0pO1xuICB9O1xufVxuXG52YXIgUmVjb2lsX0F0b21pY1VwZGF0ZXMgPSB7XG4gIGF0b21pY1VwZGF0ZXJcbn07XG5cbnZhciBSZWNvaWxfQXRvbWljVXBkYXRlc18xID0gUmVjb2lsX0F0b21pY1VwZGF0ZXMuYXRvbWljVXBkYXRlcjtcblxudmFyIFJlY29pbF9BdG9taWNVcGRhdGVzJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYXRvbWljVXBkYXRlcjogUmVjb2lsX0F0b21pY1VwZGF0ZXNfMVxufSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxudmFyIGludmFyaWFudF8xID0gaW52YXJpYW50O1xuXG4vLyBAb3NzLW9ubHlcblxuXG52YXIgUmVjb2lsX2ludmFyaWFudCA9IGludmFyaWFudF8xO1xuXG5jb25zdCB7XG4gIGF0b21pY1VwZGF0ZXI6IGF0b21pY1VwZGF0ZXIkMVxufSA9IFJlY29pbF9BdG9taWNVcGRhdGVzJDE7XG5cbmNvbnN0IHtcbiAgYmF0Y2hVcGRhdGVzOiBiYXRjaFVwZGF0ZXMkNFxufSA9IFJlY29pbF9CYXRjaGluZztcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDVcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkNlxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIHJlZnJlc2hSZWNvaWxWYWx1ZTogcmVmcmVzaFJlY29pbFZhbHVlJDEsXG4gIHNldFJlY29pbFZhbHVlOiBzZXRSZWNvaWxWYWx1ZSQzXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIGNsb25lU25hcHNob3Q6IGNsb25lU25hcHNob3QkMlxufSA9IFJlY29pbF9TbmFwc2hvdCQxO1xuXG5jb25zdCB7XG4gIGdvdG9TbmFwc2hvdDogZ290b1NuYXBzaG90JDFcbn0gPSBSZWNvaWxfU25hcHNob3RIb29rcztcblxuY29uc3Qge1xuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2skM1xufSA9IHJlYWN0O1xuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgU2VudGluZWwge31cblxuY29uc3QgU0VOVElORUwgPSBuZXcgU2VudGluZWwoKTtcblxuZnVuY3Rpb24gcmVjb2lsQ2FsbGJhY2soc3RvcmUsIGZuLCBhcmdzLCBleHRyYUludGVyZmFjZSkge1xuICBsZXQgcmV0ID0gU0VOVElORUw7XG4gIGxldCByZWxlYXNlU25hcHNob3Q7XG4gIGJhdGNoVXBkYXRlcyQ0KCgpID0+IHtcbiAgICBjb25zdCBlcnJNc2cgPSAndXNlUmVjb2lsQ2FsbGJhY2soKSBleHBlY3RzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb246ICcgKyAnaXQgYWNjZXB0cyBhIGZ1bmN0aW9uIG9mIHRoZSB0eXBlIChSZWNvaWxJbnRlcmZhY2UpID0+IChBcmdzKSA9PiBSZXR1cm5UeXBlICcgKyAnYW5kIHJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbiAoQXJncykgPT4gUmV0dXJuVHlwZSwgd2hlcmUgUmVjb2lsSW50ZXJmYWNlIGlzICcgKyAnYW4gb2JqZWN0IHtzbmFwc2hvdCwgc2V0LCAuLi59IGFuZCBBcmdzIGFuZCBSZXR1cm5UeXBlIGFyZSB0aGUgYXJndW1lbnQgYW5kIHJldHVybiAnICsgJ3R5cGVzIG9mIHRoZSBjYWxsYmFjayB5b3Ugd2FudCB0byBjcmVhdGUuICBQbGVhc2Ugc2VlIHRoZSBkb2NzICcgKyAnYXQgcmVjb2lsanMub3JnIGZvciBkZXRhaWxzLic7XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKGVyck1zZyk7XG4gICAgfSAvLyBDbG9uZSB0aGUgc25hcHNob3QgbGF6aWx5IHRvIGF2b2lkIG92ZXJoZWFkIGlmIHRoZSBjYWxsYmFjayBkb2VzIG5vdCB1c2UgaXQuXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgbWVhbnMgdGhlIHNuYXBzaG90IG1heSByZXByZXNlbnQgbGF0ZXIgc3RhdGUgZnJvbSB3aGVuXG4gICAgLy8gdGhlIGNhbGxiYWNrIHdhcyBjYWxsZWQgaWYgaXQgZmlyc3QgYWNjZXNzZXMgdGhlIHNuYXBzaG90IGFzeW5jaHJvbm91c2x5LlxuXG5cbiAgICBjb25zdCBjYWxsYmFja0ludGVyZmFjZSA9IFJlY29pbF9sYXp5UHJveHkoeyAuLi4oZXh0cmFJbnRlcmZhY2UgIT09IG51bGwgJiYgZXh0cmFJbnRlcmZhY2UgIT09IHZvaWQgMCA/IGV4dHJhSW50ZXJmYWNlIDoge30pLFxuICAgICAgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gICAgICBzZXQ6IChub2RlLCBuZXdWYWx1ZSkgPT4gc2V0UmVjb2lsVmFsdWUkMyhzdG9yZSwgbm9kZSwgbmV3VmFsdWUpLFxuICAgICAgcmVzZXQ6IG5vZGUgPT4gc2V0UmVjb2lsVmFsdWUkMyhzdG9yZSwgbm9kZSwgREVGQVVMVF9WQUxVRSQ1KSxcbiAgICAgIHJlZnJlc2g6IG5vZGUgPT4gcmVmcmVzaFJlY29pbFZhbHVlJDEoc3RvcmUsIG5vZGUpLFxuICAgICAgZ290b1NuYXBzaG90OiBzbmFwc2hvdCA9PiBnb3RvU25hcHNob3QkMShzdG9yZSwgc25hcHNob3QpLFxuICAgICAgdHJhbnNhY3RfVU5TVEFCTEU6IHRyYW5zYWN0aW9uID0+IGF0b21pY1VwZGF0ZXIkMShzdG9yZSkodHJhbnNhY3Rpb24pXG4gICAgfSwge1xuICAgICAgc25hcHNob3Q6ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSBjbG9uZVNuYXBzaG90JDIoc3RvcmUpO1xuICAgICAgICByZWxlYXNlU25hcHNob3QgPSBzbmFwc2hvdC5yZXRhaW4oKTtcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gZm4oY2FsbGJhY2tJbnRlcmZhY2UpO1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycihlcnJNc2cpO1xuICAgIH1cblxuICAgIHJldCA9IGNhbGxiYWNrKC4uLmFyZ3MpO1xuICB9KTtcbiAgISEocmV0IGluc3RhbmNlb2YgU2VudGluZWwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ2JhdGNoVXBkYXRlcyBzaG91bGQgcmV0dXJuIGltbWVkaWF0ZWx5JykgOiBSZWNvaWxfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICBpZiAoUmVjb2lsX2lzUHJvbWlzZShyZXQpKSB7XG4gICAgcmV0LmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdmFyIF9yZWxlYXNlU25hcHNob3Q7XG5cbiAgICAgIChfcmVsZWFzZVNuYXBzaG90ID0gcmVsZWFzZVNuYXBzaG90KSA9PT0gbnVsbCB8fCBfcmVsZWFzZVNuYXBzaG90ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsZWFzZVNuYXBzaG90KCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9yZWxlYXNlU25hcHNob3QyO1xuXG4gICAgKF9yZWxlYXNlU25hcHNob3QyID0gcmVsZWFzZVNuYXBzaG90KSA9PT0gbnVsbCB8fCBfcmVsZWFzZVNuYXBzaG90MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbGVhc2VTbmFwc2hvdDIoKTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYXN0XVxuXG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gdXNlUmVjb2lsQ2FsbGJhY2soZm4sIGRlcHMpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQ2KCk7XG4gIHJldHVybiB1c2VDYWxsYmFjayQzKCAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1jYWxsXVxuICAoLi4uYXJncykgPT4ge1xuICAgIHJldHVybiByZWNvaWxDYWxsYmFjayhzdG9yZVJlZi5jdXJyZW50LCBmbiwgYXJncyk7XG4gIH0sIGRlcHMgIT0gbnVsbCA/IFsuLi5kZXBzLCBzdG9yZVJlZl0gOiB1bmRlZmluZWQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmYi13d3cvcmVhY3QtaG9va3MtZGVwc1xuICApO1xufVxuXG52YXIgUmVjb2lsX3VzZVJlY29pbENhbGxiYWNrID0ge1xuICByZWNvaWxDYWxsYmFjayxcbiAgdXNlUmVjb2lsQ2FsbGJhY2tcbn07XG5cbmNvbnN0IHtcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDdcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuY29uc3Qge1xuICByZWZyZXNoUmVjb2lsVmFsdWU6IHJlZnJlc2hSZWNvaWxWYWx1ZSQyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIHVzZUNhbGxiYWNrOiB1c2VDYWxsYmFjayQ0XG59ID0gcmVhY3Q7XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFJlZnJlc2hlcihyZWNvaWxWYWx1ZSkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDcoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDQoKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICByZWZyZXNoUmVjb2lsVmFsdWUkMihzdG9yZSwgcmVjb2lsVmFsdWUpO1xuICB9LCBbcmVjb2lsVmFsdWUsIHN0b3JlUmVmXSk7XG59XG5cbnZhciBSZWNvaWxfdXNlUmVjb2lsUmVmcmVzaGVyID0gdXNlUmVjb2lsUmVmcmVzaGVyO1xuXG5jb25zdCB7XG4gIGF0b21pY1VwZGF0ZXI6IGF0b21pY1VwZGF0ZXIkMlxufSA9IFJlY29pbF9BdG9taWNVcGRhdGVzJDE7XG5cbmNvbnN0IHtcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDhcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuY29uc3Qge1xuICB1c2VNZW1vOiB1c2VNZW1vJDNcbn0gPSByZWFjdDtcblxuZnVuY3Rpb24gdXNlUmVjb2lsVHJhbnNhY3Rpb24oZm4sIGRlcHMpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQ4KCk7XG4gIHJldHVybiB1c2VNZW1vJDMoKCkgPT4gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBhdG9taWNVcGRhdGUgPSBhdG9taWNVcGRhdGVyJDIoc3RvcmVSZWYuY3VycmVudCk7XG4gICAgYXRvbWljVXBkYXRlKHRyYW5zYWN0aW9uSW50ZXJmYWNlID0+IHtcbiAgICAgIGZuKHRyYW5zYWN0aW9uSW50ZXJmYWNlKSguLi5hcmdzKTtcbiAgICB9KTtcbiAgfSwgZGVwcyAhPSBudWxsID8gWy4uLmRlcHMsIHN0b3JlUmVmXSA6IHVuZGVmaW5lZCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZiLXd3dy9yZWFjdC1ob29rcy1kZXBzXG4gICk7XG59XG5cbnZhciBSZWNvaWxfdXNlUmVjb2lsVHJhbnNhY3Rpb24gPSB1c2VSZWNvaWxUcmFuc2FjdGlvbjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuY2xhc3MgV3JhcHBlZFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbn1cblxudmFyIFJlY29pbF9XcmFwcGVyID0ge1xuICBXcmFwcGVkVmFsdWVcbn07XG5cbnZhciBSZWNvaWxfV3JhcHBlcl8xID0gUmVjb2lsX1dyYXBwZXIuV3JhcHBlZFZhbHVlO1xuXG52YXIgUmVjb2lsX1dyYXBwZXIkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBXcmFwcGVkVmFsdWU6IFJlY29pbF9XcmFwcGVyXzFcbn0pO1xuXG5jb25zdCB7XG4gIGlzRmFzdFJlZnJlc2hFbmFibGVkOiBpc0Zhc3RSZWZyZXNoRW5hYmxlZCQyXG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcblxuXG5cbmNsYXNzIENoYW5nZWRQYXRoRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5jbGFzcyBUcmVlQ2FjaGUge1xuICAvLyAkRmxvd0lzc3VlW3VuY2xlYXItdHlwZV1cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyRvbkhpdCwgX29wdGlvbnMkb25TZXQsIF9vcHRpb25zJG1hcE5vZGVWYWx1ZTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9uYW1lXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbnVtTGVhZnNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yb290XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfb25IaXRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9vblNldFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX21hcE5vZGVWYWx1ZVwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5fbmFtZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lO1xuICAgIHRoaXMuX251bUxlYWZzID0gMDtcbiAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB0aGlzLl9vbkhpdCA9IChfb3B0aW9ucyRvbkhpdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbkhpdCkgIT09IG51bGwgJiYgX29wdGlvbnMkb25IaXQgIT09IHZvaWQgMCA/IF9vcHRpb25zJG9uSGl0IDogKCkgPT4ge307XG4gICAgdGhpcy5fb25TZXQgPSAoX29wdGlvbnMkb25TZXQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25TZXQpICE9PSBudWxsICYmIF9vcHRpb25zJG9uU2V0ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRvblNldCA6ICgpID0+IHt9O1xuICAgIHRoaXMuX21hcE5vZGVWYWx1ZSA9IChfb3B0aW9ucyRtYXBOb2RlVmFsdWUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWFwTm9kZVZhbHVlKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRtYXBOb2RlVmFsdWUgIT09IHZvaWQgMCA/IF9vcHRpb25zJG1hcE5vZGVWYWx1ZSA6IHZhbCA9PiB2YWw7XG4gIH1cblxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9udW1MZWFmcztcbiAgfSAvLyAkRmxvd0lzc3VlW3VuY2xlYXItdHlwZV1cblxuXG4gIHJvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG4gIH1cblxuICBnZXQoZ2V0Tm9kZVZhbHVlLCBoYW5kbGVycykge1xuICAgIHZhciBfdGhpcyRnZXRMZWFmTm9kZTtcblxuICAgIHJldHVybiAoX3RoaXMkZ2V0TGVhZk5vZGUgPSB0aGlzLmdldExlYWZOb2RlKGdldE5vZGVWYWx1ZSwgaGFuZGxlcnMpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRMZWFmTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0TGVhZk5vZGUudmFsdWU7XG4gIH1cblxuICBnZXRMZWFmTm9kZShnZXROb2RlVmFsdWUsIGhhbmRsZXJzKSB7XG4gICAgaWYgKHRoaXMuX3Jvb3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IC8vIEl0ZXJhdGUgZG93biB0aGUgdHJlZSBiYXNlZCBvbiB0aGUgY3VycmVudCBub2RlIHZhbHVlcyB1bnRpbCB3ZSBoaXQgYSBsZWFmXG4gICAgLy8gJEZsb3dJc3N1ZVt1bmNsZWFyLXR5cGVdXG5cblxuICAgIGxldCBub2RlID0gdGhpcy5fcm9vdDtcblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBoYW5kbGVycyA9PT0gbnVsbCB8fCBoYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGFuZGxlcnMub25Ob2RlVmlzaXQobm9kZSk7XG5cbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdsZWFmJykge1xuICAgICAgICB0aGlzLl9vbkhpdChub2RlKTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZVZhbHVlID0gdGhpcy5fbWFwTm9kZVZhbHVlKGdldE5vZGVWYWx1ZShub2RlLm5vZGVLZXkpKTtcblxuICAgICAgbm9kZSA9IG5vZGUuYnJhbmNoZXMuZ2V0KG5vZGVWYWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHNldChyb3V0ZSwgdmFsdWUsIGhhbmRsZXJzKSB7XG4gICAgY29uc3QgYWRkTGVhZiA9ICgpID0+IHtcbiAgICAgIHZhciBfbm9kZTIsIF9ub2RlMywgX3RoaXMkX3Jvb3QyLCBfaGFuZGxlcnMkb25Ob2RlVmlzaXQyO1xuXG4gICAgICAvLyBGaXJzdCwgc2V0dXAgdGhlIGJyYW5jaCBub2RlcyBmb3IgdGhlIHJvdXRlOlxuICAgICAgLy8gSXRlcmF0ZSBkb3duIHRoZSB0cmVlIHRvIGZpbmQgb3IgYWRkIGJyYW5jaCBub2RlcyBmb2xsb3dpbmcgdGhlIHJvdXRlXG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGxldCBicmFuY2hLZXk7XG5cbiAgICAgIGZvciAoY29uc3QgW25vZGVLZXksIG5vZGVWYWx1ZV0gb2Ygcm91dGUpIHtcbiAgICAgICAgdmFyIF9ub2RlLCBfaGFuZGxlcnMkb25Ob2RlVmlzaXQsIF90aGlzJF9yb290O1xuXG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyByb290IHdhcyBhIGxlYWYsIHdoaWxlIHdlIG5vdCBoYXZlIGEgZ2V0KCksIGl0IG1lYW5zXG4gICAgICAgIC8vIHRoZSBzZWxlY3RvciBoYXMgaW5jb25zaXN0ZW50IHZhbHVlcyBvciBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkLlxuICAgICAgICBjb25zdCByb290ID0gdGhpcy5fcm9vdDtcblxuICAgICAgICBpZiAoKHJvb3QgPT09IG51bGwgfHwgcm9vdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm9vdC50eXBlKSA9PT0gJ2xlYWYnKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5pbnZhbGlkQ2FjaGVFcnJvcigpO1xuICAgICAgICB9IC8vIG5vZGUgbm93IHJlZmVycyB0byB0aGUgbmV4dCBub2RlIGRvd24gaW4gdGhlIHRyZWVcblxuXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGU7IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXVxuXG4gICAgICAgIG5vZGUgPSBwYXJlbnQgPyBwYXJlbnQuYnJhbmNoZXMuZ2V0KGJyYW5jaEtleSkgOiByb290OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV1cblxuICAgICAgICBub2RlID0gKF9ub2RlID0gbm9kZSkgIT09IG51bGwgJiYgX25vZGUgIT09IHZvaWQgMCA/IF9ub2RlIDoge1xuICAgICAgICAgIHR5cGU6ICdicmFuY2gnLFxuICAgICAgICAgIG5vZGVLZXksXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIGJyYW5jaGVzOiBuZXcgTWFwKCksXG4gICAgICAgICAgYnJhbmNoS2V5XG4gICAgICAgIH07IC8vIElmIHdlIGZvdW5kIGFuIGV4aXN0aW5nIG5vZGUsIGNvbmZpcm0gaXQgaGFzIGEgY29uc2lzdGVudCB2YWx1ZVxuXG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09ICdicmFuY2gnIHx8IG5vZGUubm9kZUtleSAhPT0gbm9kZUtleSkge1xuICAgICAgICAgIHRocm93IHRoaXMuaW52YWxpZENhY2hlRXJyb3IoKTtcbiAgICAgICAgfSAvLyBBZGQgdGhlIGJyYW5jaCBub2RlIHRvIHRoZSB0cmVlXG5cblxuICAgICAgICBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuYnJhbmNoZXMuc2V0KGJyYW5jaEtleSwgbm9kZSk7XG4gICAgICAgIGhhbmRsZXJzID09PSBudWxsIHx8IGhhbmRsZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2hhbmRsZXJzJG9uTm9kZVZpc2l0ID0gaGFuZGxlcnMub25Ob2RlVmlzaXQpID09PSBudWxsIHx8IF9oYW5kbGVycyRvbk5vZGVWaXNpdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2hhbmRsZXJzJG9uTm9kZVZpc2l0LmNhbGwoaGFuZGxlcnMsIG5vZGUpOyAvLyBQcmVwYXJlIGZvciBuZXh0IGl0ZXJhdGlvbiBhbmQgaW5zdGFsbCByb290IGlmIGl0IGlzIG5ldy5cblxuICAgICAgICBicmFuY2hLZXkgPSB0aGlzLl9tYXBOb2RlVmFsdWUobm9kZVZhbHVlKTtcbiAgICAgICAgdGhpcy5fcm9vdCA9IChfdGhpcyRfcm9vdCA9IHRoaXMuX3Jvb3QpICE9PSBudWxsICYmIF90aGlzJF9yb290ICE9PSB2b2lkIDAgPyBfdGhpcyRfcm9vdCA6IG5vZGU7XG4gICAgICB9IC8vIFNlY29uZCwgc2V0dXAgdGhlIGxlYWYgbm9kZTpcbiAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGxlYWYgZm9yIHRoaXMgcm91dGUgY29uZmlybSBpdCBpcyBjb25zaXN0ZW50XG5cblxuICAgICAgY29uc3Qgb2xkTGVhZiA9IG5vZGUgPyAoX25vZGUyID0gbm9kZSkgPT09IG51bGwgfHwgX25vZGUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZTIuYnJhbmNoZXMuZ2V0KGJyYW5jaEtleSkgOiB0aGlzLl9yb290O1xuXG4gICAgICBpZiAob2xkTGVhZiAhPSBudWxsICYmIChvbGRMZWFmLnR5cGUgIT09ICdsZWFmJyB8fCBvbGRMZWFmLmJyYW5jaEtleSAhPT0gYnJhbmNoS2V5KSkge1xuICAgICAgICB0aHJvdyB0aGlzLmludmFsaWRDYWNoZUVycm9yKCk7XG4gICAgICB9IC8vIENyZWF0ZSBhIG5ldyBvciByZXBsYWNlbWVudCBsZWFmLlxuXG5cbiAgICAgIGNvbnN0IGxlYWZOb2RlID0ge1xuICAgICAgICB0eXBlOiAnbGVhZicsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBwYXJlbnQ6IG5vZGUsXG4gICAgICAgIGJyYW5jaEtleVxuICAgICAgfTsgLy8gSW5zdGFsbCB0aGUgbGVhZiBhbmQgY2FsbCBoYW5kbGVyc1xuXG4gICAgICAoX25vZGUzID0gbm9kZSkgPT09IG51bGwgfHwgX25vZGUzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZTMuYnJhbmNoZXMuc2V0KGJyYW5jaEtleSwgbGVhZk5vZGUpO1xuICAgICAgdGhpcy5fcm9vdCA9IChfdGhpcyRfcm9vdDIgPSB0aGlzLl9yb290KSAhPT0gbnVsbCAmJiBfdGhpcyRfcm9vdDIgIT09IHZvaWQgMCA/IF90aGlzJF9yb290MiA6IGxlYWZOb2RlO1xuICAgICAgdGhpcy5fbnVtTGVhZnMrKztcblxuICAgICAgdGhpcy5fb25TZXQobGVhZk5vZGUpO1xuXG4gICAgICBoYW5kbGVycyA9PT0gbnVsbCB8fCBoYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9oYW5kbGVycyRvbk5vZGVWaXNpdDIgPSBoYW5kbGVycy5vbk5vZGVWaXNpdCkgPT09IG51bGwgfHwgX2hhbmRsZXJzJG9uTm9kZVZpc2l0MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2hhbmRsZXJzJG9uTm9kZVZpc2l0Mi5jYWxsKGhhbmRsZXJzLCBsZWFmTm9kZSk7XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBhZGRMZWFmKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIHRoZSBjYWNoZSB3YXMgc3RhbGUgb3Igb2JzZXJ2ZWQgaW5jb25zaXN0ZW50IHZhbHVlcywgc3VjaCBhcyB3aXRoXG4gICAgICAvLyBGYXN0IFJlZnJlc2gsIHRoZW4gY2xlYXIgaXQgYW5kIHJlYnVpbGQgd2l0aCB0aGUgbmV3IHZhbHVlcy5cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENoYW5nZWRQYXRoRXJyb3IpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICBhZGRMZWFmKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUmV0dXJucyB0cnVlIGlmIGxlYWYgd2FzIGFjdHVhbGx5IGRlbGV0ZWQgZnJvbSB0aGUgdHJlZVxuXG5cbiAgZGVsZXRlKGxlYWYpIHtcbiAgICBjb25zdCByb290ID0gdGhpcy5yb290KCk7XG5cbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobGVhZiA9PT0gcm9vdCkge1xuICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgICB0aGlzLl9udW1MZWFmcyA9IDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIEl0ZXJhdGUgdXAgZnJvbSB0aGUgbGVhZiBkZWxldGVpbmcgaXQgZnJvbSBpdCdzIHBhcmVudCdzIGJyYW5jaGVzLlxuXG5cbiAgICBsZXQgbm9kZSA9IGxlYWYucGFyZW50O1xuICAgIGxldCBicmFuY2hLZXkgPSBsZWFmLmJyYW5jaEtleTtcblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICB2YXIgX25vZGU0O1xuXG4gICAgICBub2RlLmJyYW5jaGVzLmRlbGV0ZShicmFuY2hLZXkpOyAvLyBTdG9wIGl0ZXJhdGluZyBpZiB3ZSBoaXQgdGhlIHJvb3QuXG5cbiAgICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICAgIGlmIChub2RlLmJyYW5jaGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9udW1MZWFmcyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbnVtTGVhZnMtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBTdG9wIGl0ZXJhdGluZyBpZiB0aGVyZSBhcmUgb3RoZXIgYnJhbmNoZXMgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgLy8gcmVtb3ZlIGFueSBtb3JlIG5vZGVzLlxuXG5cbiAgICAgIGlmIChub2RlLmJyYW5jaGVzLnNpemUgPiAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBJdGVyYXRlIHVwIHRvIG91ciBwYXJlbnRcblxuXG4gICAgICBicmFuY2hLZXkgPSAoX25vZGU0ID0gbm9kZSkgPT09IG51bGwgfHwgX25vZGU0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZTQuYnJhbmNoS2V5O1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH0gLy8gQ29uZmlybSB0aGF0IHRoZSBsZWFmIHdlIGFyZSBkZWxldGluZyBpcyBhY3R1YWxseSBhdHRhY2hlZCB0byBvdXIgdHJlZVxuXG5cbiAgICBmb3IgKDsgbm9kZSAhPT0gcm9vdDsgbm9kZSA9IG5vZGUucGFyZW50KSB7XG4gICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9udW1MZWFmcy0tO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fbnVtTGVhZnMgPSAwO1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICB9XG5cbiAgaW52YWxpZENhY2hlRXJyb3IoKSB7XG4gICAgY29uc3QgQ0hBTkdFRF9QQVRIX0VSUk9SX01FU1NBR0UgPSBpc0Zhc3RSZWZyZXNoRW5hYmxlZCQyKCkgPyAnUG9zc2libGUgRmFzdCBSZWZyZXNoIG1vZHVsZSByZWxvYWQgZGV0ZWN0ZWQuICAnICsgJ1RoaXMgbWF5IGFsc28gYmUgY2F1c2VkIGJ5IGFuIHNlbGVjdG9yIHJldHVybmluZyBpbmNvbnNpc3RlbnQgdmFsdWVzLiAnICsgJ1Jlc2V0dGluZyBjYWNoZS4nIDogJ0ludmFsaWQgY2FjaGUgdmFsdWVzLiAgVGhpcyBoYXBwZW5zIHdoZW4gc2VsZWN0b3JzIGRvIG5vdCByZXR1cm4gJyArICdjb25zaXN0ZW50IHZhbHVlcyBmb3IgdGhlIHNhbWUgaW5wdXQgZGVwZW5kZW5jeSB2YWx1ZXMuICBUaGF0IG1heSBhbHNvICcgKyAnYmUgY2F1c2VkIHdoZW4gdXNpbmcgRmFzdCBSZWZyZXNoIHRvIGNoYW5nZSBhIHNlbGVjdG9yIGltcGxlbWVudGF0aW9uLiAgJyArICdSZXNldHRpbmcgY2FjaGUuJztcbiAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oQ0hBTkdFRF9QQVRIX0VSUk9SX01FU1NBR0UgKyAodGhpcy5fbmFtZSAhPSBudWxsID8gYCAtICR7dGhpcy5fbmFtZX1gIDogJycpKTtcbiAgICB0aHJvdyBuZXcgQ2hhbmdlZFBhdGhFcnJvcigpO1xuICB9XG5cbn1cblxudmFyIFJlY29pbF9UcmVlQ2FjaGUgPSB7XG4gIFRyZWVDYWNoZVxufTtcblxudmFyIFJlY29pbF9UcmVlQ2FjaGVfMSA9IFJlY29pbF9UcmVlQ2FjaGUuVHJlZUNhY2hlO1xuXG52YXIgUmVjb2lsX1RyZWVDYWNoZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFRyZWVDYWNoZTogUmVjb2lsX1RyZWVDYWNoZV8xXG59KTtcblxuY2xhc3MgTFJVQ2FjaGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zJG1hcEtleTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tYXhTaXplXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2l6ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2hlYWRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90YWlsXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWFwXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfa2V5TWFwcGVyXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLl9tYXhTaXplID0gb3B0aW9ucy5tYXhTaXplO1xuICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgIHRoaXMuX3RhaWwgPSBudWxsO1xuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9rZXlNYXBwZXIgPSAoX29wdGlvbnMkbWFwS2V5ID0gb3B0aW9ucy5tYXBLZXkpICE9PSBudWxsICYmIF9vcHRpb25zJG1hcEtleSAhPT0gdm9pZCAwID8gX29wdGlvbnMkbWFwS2V5IDogdiA9PiB2O1xuICB9XG5cbiAgaGVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZDtcbiAgfVxuXG4gIHRhaWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhaWw7XG4gIH1cblxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplO1xuICB9XG5cbiAgbWF4U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4U2l6ZTtcbiAgfVxuXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyh0aGlzLl9rZXlNYXBwZXIoa2V5KSk7XG4gIH1cblxuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgbWFwcGVkS2V5ID0gdGhpcy5fa2V5TWFwcGVyKGtleSk7XG5cbiAgICBjb25zdCBub2RlID0gdGhpcy5fbWFwLmdldChtYXBwZWRLZXkpO1xuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMuc2V0KGtleSwgbm9kZS52YWx1ZSk7XG4gICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gIH1cblxuICBzZXQoa2V5LCB2YWwpIHtcbiAgICBjb25zdCBtYXBwZWRLZXkgPSB0aGlzLl9rZXlNYXBwZXIoa2V5KTtcblxuICAgIGNvbnN0IGV4aXN0aW5nTm9kZSA9IHRoaXMuX21hcC5nZXQobWFwcGVkS2V5KTtcblxuICAgIGlmIChleGlzdGluZ05vZGUpIHtcbiAgICAgIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGVhZCA9IHRoaXMuaGVhZCgpO1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICBrZXksXG4gICAgICByaWdodDogaGVhZCxcbiAgICAgIGxlZnQ6IG51bGwsXG4gICAgICB2YWx1ZTogdmFsXG4gICAgfTtcblxuICAgIGlmIChoZWFkKSB7XG4gICAgICBoZWFkLmxlZnQgPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90YWlsID0gbm9kZTtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXAuc2V0KG1hcHBlZEtleSwgbm9kZSk7XG5cbiAgICB0aGlzLl9oZWFkID0gbm9kZTtcbiAgICB0aGlzLl9zaXplKys7XG5cbiAgICB0aGlzLl9tYXliZURlbGV0ZUxSVSgpO1xuICB9XG5cbiAgX21heWJlRGVsZXRlTFJVKCkge1xuICAgIGlmICh0aGlzLnNpemUoKSA+IHRoaXMubWF4U2l6ZSgpKSB7XG4gICAgICB0aGlzLmRlbGV0ZUxydSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlbGV0ZUxydSgpIHtcbiAgICBjb25zdCB0YWlsID0gdGhpcy50YWlsKCk7XG5cbiAgICBpZiAodGFpbCkge1xuICAgICAgdGhpcy5kZWxldGUodGFpbC5rZXkpO1xuICAgIH1cbiAgfVxuXG4gIGRlbGV0ZShrZXkpIHtcbiAgICBjb25zdCBtYXBwZWRLZXkgPSB0aGlzLl9rZXlNYXBwZXIoa2V5KTtcblxuICAgIGlmICghdGhpcy5fc2l6ZSB8fCAhdGhpcy5fbWFwLmhhcyhtYXBwZWRLZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZSA9IFJlY29pbF9udWxsdGhyb3dzKHRoaXMuX21hcC5nZXQobWFwcGVkS2V5KSk7XG4gICAgY29uc3QgcmlnaHQgPSBub2RlLnJpZ2h0O1xuICAgIGNvbnN0IGxlZnQgPSBub2RlLmxlZnQ7XG5cbiAgICBpZiAocmlnaHQpIHtcbiAgICAgIHJpZ2h0LmxlZnQgPSBub2RlLmxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKGxlZnQpIHtcbiAgICAgIGxlZnQucmlnaHQgPSBub2RlLnJpZ2h0O1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSB0aGlzLmhlYWQoKSkge1xuICAgICAgdGhpcy5faGVhZCA9IHJpZ2h0O1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSB0aGlzLnRhaWwoKSkge1xuICAgICAgdGhpcy5fdGFpbCA9IGxlZnQ7XG4gICAgfVxuXG4gICAgdGhpcy5fbWFwLmRlbGV0ZShtYXBwZWRLZXkpO1xuXG4gICAgdGhpcy5fc2l6ZS0tO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICB9XG5cbn1cblxudmFyIFJlY29pbF9MUlVDYWNoZSA9IHtcbiAgTFJVQ2FjaGVcbn07XG5cbnZhciBSZWNvaWxfTFJVQ2FjaGVfMSA9IFJlY29pbF9MUlVDYWNoZS5MUlVDYWNoZTtcblxudmFyIFJlY29pbF9MUlVDYWNoZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIExSVUNhY2hlOiBSZWNvaWxfTFJVQ2FjaGVfMVxufSk7XG5cbmNvbnN0IHtcbiAgTFJVQ2FjaGU6IExSVUNhY2hlJDFcbn0gPSBSZWNvaWxfTFJVQ2FjaGUkMTtcblxuY29uc3Qge1xuICBUcmVlQ2FjaGU6IFRyZWVDYWNoZSQxXG59ID0gUmVjb2lsX1RyZWVDYWNoZSQxO1xuXG5mdW5jdGlvbiB0cmVlQ2FjaGVMUlUoe1xuICBuYW1lLFxuICBtYXhTaXplLFxuICBtYXBOb2RlVmFsdWUgPSB2ID0+IHZcbn0pIHtcbiAgY29uc3QgbHJ1Q2FjaGUgPSBuZXcgTFJVQ2FjaGUkMSh7XG4gICAgbWF4U2l6ZVxuICB9KTtcbiAgY29uc3QgY2FjaGUgPSBuZXcgVHJlZUNhY2hlJDEoe1xuICAgIG5hbWUsXG4gICAgbWFwTm9kZVZhbHVlLFxuICAgIG9uSGl0OiBub2RlID0+IHtcbiAgICAgIGxydUNhY2hlLnNldChub2RlLCB0cnVlKTtcbiAgICB9LFxuICAgIG9uU2V0OiBub2RlID0+IHtcbiAgICAgIGNvbnN0IGxydU5vZGUgPSBscnVDYWNoZS50YWlsKCk7XG4gICAgICBscnVDYWNoZS5zZXQobm9kZSwgdHJ1ZSk7XG5cbiAgICAgIGlmIChscnVOb2RlICYmIGNhY2hlLnNpemUoKSA+IG1heFNpemUpIHtcbiAgICAgICAgY2FjaGUuZGVsZXRlKGxydU5vZGUua2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2FjaGU7XG59XG5cbnZhciBSZWNvaWxfdHJlZUNhY2hlTFJVID0gdHJlZUNhY2hlTFJVO1xuXG5jb25zdCBUSU1FX1dBUk5JTkdfVEhSRVNIT0xEX01TID0gMTU7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeSh4LCBvcHQsIGtleSkge1xuICAvLyBBIG9wdGltaXphdGlvbiB0byBhdm9pZCB0aGUgbW9yZSBleHBlbnNpdmUgSlNPTi5zdHJpbmdpZnkoKSBmb3Igc2ltcGxlIHN0cmluZ3NcbiAgLy8gVGhpcyBtYXkgbG9zZSBwcm90ZWN0aW9uIGZvciB1MjAyOCBhbmQgdTIwMjksIHRob3VnaC5cbiAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJyAmJiAheC5pbmNsdWRlcygnXCInKSAmJiAheC5pbmNsdWRlcygnXFxcXCcpKSB7XG4gICAgcmV0dXJuIGBcIiR7eH1cImA7XG4gIH0gLy8gSGFuZGxlIHByaW1pdGl2ZSB0eXBlc1xuXG5cbiAgc3dpdGNoICh0eXBlb2YgeCkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gJyc7XG4gICAgLy8gSlNPTi5zdHJpbmdpZnkodW5kZWZpbmVkKSByZXR1cm5zIHVuZGVmaW5lZCwgYnV0IHdlIGFsd2F5cyB3YW50IHRvIHJldHVybiBhIHN0cmluZ1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4geCA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBjYXNlICdiaWdpbnQnOiAvLyBCaWdJbnQgaXMgbm90IHN1cHBvcnRlZCBpbiB3d3dcbiAgICAgIHJldHVybiBTdHJpbmcoeCk7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgLy8gQWRkIHN1cnJvdW5kaW5nIHF1b3RlcyBhbmQgZXNjYXBlIGludGVybmFsIHF1b3Rlc1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHgpO1xuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgaWYgKChvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuYWxsb3dGdW5jdGlvbnMpICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IFJlY29pbF9lcnIoJ0F0dGVtcHQgdG8gc2VyaWFsaXplIGZ1bmN0aW9uIGluIGEgUmVjb2lsIGNhY2hlIGtleScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYF9fRlVOQ1RJT04oJHt4Lm5hbWV9KV9fYDtcbiAgfVxuXG4gIGlmICh4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfSAvLyBGYWxsYmFjayBjYXNlIGZvciB1bmtub3duIHR5cGVzXG5cblxuICBpZiAodHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgdmFyIF9KU09OJHN0cmluZ2lmeTtcblxuICAgIHJldHVybiAoX0pTT04kc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnkoeCkpICE9PSBudWxsICYmIF9KU09OJHN0cmluZ2lmeSAhPT0gdm9pZCAwID8gX0pTT04kc3RyaW5naWZ5IDogJyc7XG4gIH0gLy8gRGVhbCB3aXRoIGFsbCBwcm9taXNlcyBhcyBlcXVpdmFsZW50IGZvciBub3cuXG5cblxuICBpZiAoUmVjb2lsX2lzUHJvbWlzZSh4KSkge1xuICAgIHJldHVybiAnX19QUk9NSVNFX18nO1xuICB9IC8vIEFycmF5cyBoYW5kbGUgcmVjdXJzaXZlIHN0cmluZ2lmaWNhdGlvblxuXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICByZXR1cm4gYFske3gubWFwKCh2LCBpKSA9PiBzdHJpbmdpZnkodiwgb3B0LCBpLnRvU3RyaW5nKCkpKX1dYDtcbiAgfSAvLyBJZiBhbiBvYmplY3QgZGVmaW5lcyBhIHRvSlNPTigpIG1ldGhvZCwgdGhlbiB1c2UgdGhhdCB0byBvdmVycmlkZSB0aGVcbiAgLy8gc2VyaWFsaXphdGlvbi4gIFRoaXMgbWF0Y2hlcyB0aGUgYmVoYXZpb3Igb2YgSlNPTi5zdHJpbmdpZnkoKS5cbiAgLy8gUGFzcyB0aGUga2V5IGZvciBjb21wYXRpYmlsaXR5LlxuICAvLyBJbW11dGFibGUuanMgY29sbGVjdGlvbnMgZGVmaW5lIHRoaXMgbWV0aG9kIHRvIGFsbG93IHVzIHRvIHNlcmlhbGl6ZSB0aGVtLlxuXG5cbiAgaWYgKHR5cGVvZiB4LnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxuICAgIHJldHVybiBzdHJpbmdpZnkoeC50b0pTT04oa2V5KSwgb3B0LCBrZXkpO1xuICB9IC8vIEZvciBidWlsdC1pbiBNYXBzLCBzb3J0IHRoZSBrZXlzIGluIGEgc3RhYmxlIG9yZGVyIGluc3RlYWQgb2YgdGhlXG4gIC8vIGRlZmF1bHQgaW5zZXJ0aW9uIG9yZGVyLiAgU3VwcG9ydCBub24tc3RyaW5nIGtleXMuXG5cblxuICBpZiAoeCBpbnN0YW5jZW9mIE1hcCkge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgeCkge1xuICAgICAgLy8gU3RyaW5naWZ5IHdpbGwgZXNjYXBlIGFueSBuZXN0ZWQgcXVvdGVzXG4gICAgICBvYmpbdHlwZW9mIGsgPT09ICdzdHJpbmcnID8gayA6IHN0cmluZ2lmeShrLCBvcHQpXSA9IHY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ2lmeShvYmosIG9wdCwga2V5KTtcbiAgfSAvLyBGb3IgYnVpbHQtaW4gU2V0cywgc29ydCB0aGUga2V5cyBpbiBhIHN0YWJsZSBvcmRlciBpbnN0ZWFkIG9mIHRoZVxuICAvLyBkZWZhdWx0IGluc2VydGlvbiBvcmRlci5cblxuXG4gIGlmICh4IGluc3RhbmNlb2YgU2V0KSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShBcnJheS5mcm9tKHgpLnNvcnQoKGEsIGIpID0+IHN0cmluZ2lmeShhLCBvcHQpLmxvY2FsZUNvbXBhcmUoc3RyaW5naWZ5KGIsIG9wdCkpKSwgb3B0LCBrZXkpO1xuICB9IC8vIEFueXRoaW5nIGVsc2UgdGhhdCBpcyBpdGVyYWJsZSBzZXJpYWxpemUgYXMgYW4gQXJyYXkuXG5cblxuICBpZiAoU3ltYm9sICE9PSB1bmRlZmluZWQgJiYgeFtTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgJiYgdHlwZW9mIHhbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxuICAgIHJldHVybiBzdHJpbmdpZnkoQXJyYXkuZnJvbSh4KSwgb3B0LCBrZXkpO1xuICB9IC8vIEZvciBhbGwgb3RoZXIgT2JqZWN0cywgc29ydCB0aGUga2V5cyBpbiBhIHN0YWJsZSBvcmRlci5cblxuXG4gIHJldHVybiBgeyR7T2JqZWN0LmtleXMoeCkuZmlsdGVyKGsgPT4geFtrXSAhPT0gdW5kZWZpbmVkKS5zb3J0KCkgLy8gc3RyaW5naWZ5IHRoZSBrZXkgdG8gYWRkIHF1b3RlcyBhbmQgZXNjYXBlIGFueSBuZXN0ZWQgc2xhc2hlcyBvciBxdW90ZXMuXG4gIC5tYXAoayA9PiBgJHtzdHJpbmdpZnkoaywgb3B0KX06JHtzdHJpbmdpZnkoeFtrXSwgb3B0LCBrKX1gKS5qb2luKCcsJyl9fWA7XG59IC8vIFV0aWxpdHkgc2ltaWxhciB0byBKU09OLnN0cmluZ2lmeSgpIGV4Y2VwdDpcbi8vICogU2VyaWFsaXplIGJ1aWx0LWluIFNldHMgYXMgYW4gQXJyYXlcbi8vICogU2VyaWFsaXplIGJ1aWx0LWluIE1hcHMgYXMgYW4gT2JqZWN0LiAgU3VwcG9ydHMgbm9uLXN0cmluZyBrZXlzLlxuLy8gKiBTZXJpYWxpemUgb3RoZXIgaXRlcmFibGVzIGFzIGFycmF5c1xuLy8gKiBTb3J0IHRoZSBrZXlzIG9mIE9iamVjdHMgYW5kIE1hcHMgdG8gaGF2ZSBhIHN0YWJsZSBvcmRlciBiYXNlZCBvbiBzdHJpbmcgY29udmVyc2lvbi5cbi8vICAgIFRoaXMgb3ZlcnJpZGVzIHRoZWlyIGRlZmF1bHQgaW5zZXJ0aW9uIG9yZGVyLlxuLy8gKiBTdGlsbCB1c2VzIHRvSlNPTigpIG9mIGFueSBvYmplY3QgdG8gb3ZlcnJpZGUgc2VyaWFsaXphdGlvblxuLy8gKiBTdXBwb3J0IFN5bWJvbHMgKHRob3VnaCBkb24ndCBndWFyYW50ZWUgdW5pcXVlbmVzcylcbi8vICogV2UgY291bGQgc3VwcG9ydCBCaWdJbnQsIGJ1dCBGbG93IGRvZXNuJ3Qgc2VlbSB0byBsaWtlIGl0LlxuLy8gU2VlIFJlY29pbF9zdGFibGVTdHJpbmdpZnktdGVzdC5qcyBmb3IgZXhhbXBsZXNcblxuXG5mdW5jdGlvbiBzdGFibGVTdHJpbmdpZnkoeCwgb3B0ID0ge1xuICBhbGxvd0Z1bmN0aW9uczogZmFsc2Vcbn0pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIDogMDtcbiAgICAgIGNvbnN0IHN0ciA9IHN0cmluZ2lmeSh4LCBvcHQpO1xuICAgICAgY29uc3QgZW5kVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6IDA7XG5cbiAgICAgIGlmIChlbmRUaW1lIC0gc3RhcnRUaW1lID4gVElNRV9XQVJOSU5HX1RIUkVTSE9MRF9NUykge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvbm8tY29uc29sZSAqL1xuICAgICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKGBSZWNvaWw6IFNwZW50ICR7ZW5kVGltZSAtIHN0YXJ0VGltZX1tcyBjb21wdXRpbmcgYSBjYWNoZSBrZXlgKTtcbiAgICAgICAgY29uc29sZS53YXJuKHgsIHN0cik7XG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBmYi13d3cvbm8tY29uc29sZSAqL1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnkoeCwgb3B0KTtcbn1cblxudmFyIFJlY29pbF9zdGFibGVTdHJpbmdpZnkgPSBzdGFibGVTdHJpbmdpZnk7XG5cbmNvbnN0IHtcbiAgVHJlZUNhY2hlOiBUcmVlQ2FjaGUkMlxufSA9IFJlY29pbF9UcmVlQ2FjaGUkMTtcblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IGRlZmF1bHRQb2xpY3kgPSB7XG4gIGVxdWFsaXR5OiAncmVmZXJlbmNlJyxcbiAgZXZpY3Rpb246ICdrZWVwLWFsbCcsXG4gIG1heFNpemU6IEluZmluaXR5XG59O1xuXG5mdW5jdGlvbiB0cmVlQ2FjaGVGcm9tUG9saWN5KHtcbiAgZXF1YWxpdHkgPSBkZWZhdWx0UG9saWN5LmVxdWFsaXR5LFxuICBldmljdGlvbiA9IGRlZmF1bHRQb2xpY3kuZXZpY3Rpb24sXG4gIG1heFNpemUgPSBkZWZhdWx0UG9saWN5Lm1heFNpemVcbn0gPSBkZWZhdWx0UG9saWN5LCBuYW1lKSB7XG4gIGNvbnN0IHZhbHVlTWFwcGVyID0gZ2V0VmFsdWVNYXBwZXIoZXF1YWxpdHkpO1xuICByZXR1cm4gZ2V0VHJlZUNhY2hlKGV2aWN0aW9uLCBtYXhTaXplLCB2YWx1ZU1hcHBlciwgbmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlTWFwcGVyKGVxdWFsaXR5KSB7XG4gIHN3aXRjaCAoZXF1YWxpdHkpIHtcbiAgICBjYXNlICdyZWZlcmVuY2UnOlxuICAgICAgcmV0dXJuIHZhbCA9PiB2YWw7XG5cbiAgICBjYXNlICd2YWx1ZSc6XG4gICAgICByZXR1cm4gdmFsID0+IFJlY29pbF9zdGFibGVTdHJpbmdpZnkodmFsKTtcbiAgfVxuXG4gIHRocm93IFJlY29pbF9lcnIoYFVucmVjb2duaXplZCBlcXVhbGl0eSBwb2xpY3kgJHtlcXVhbGl0eX1gKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJlZUNhY2hlKGV2aWN0aW9uLCBtYXhTaXplLCBtYXBOb2RlVmFsdWUsIG5hbWUpIHtcbiAgc3dpdGNoIChldmljdGlvbikge1xuICAgIGNhc2UgJ2tlZXAtYWxsJzpcbiAgICAgIHJldHVybiBuZXcgVHJlZUNhY2hlJDIoe1xuICAgICAgICBuYW1lLFxuICAgICAgICBtYXBOb2RlVmFsdWVcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnbHJ1JzpcbiAgICAgIHJldHVybiBSZWNvaWxfdHJlZUNhY2hlTFJVKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgbWF4U2l6ZTogUmVjb2lsX251bGx0aHJvd3MobWF4U2l6ZSksXG4gICAgICAgIG1hcE5vZGVWYWx1ZVxuICAgICAgfSk7XG5cbiAgICBjYXNlICdtb3N0LXJlY2VudCc6XG4gICAgICByZXR1cm4gUmVjb2lsX3RyZWVDYWNoZUxSVSh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIG1heFNpemU6IDEsXG4gICAgICAgIG1hcE5vZGVWYWx1ZVxuICAgICAgfSk7XG4gIH1cblxuICB0aHJvdyBSZWNvaWxfZXJyKGBVbnJlY29nbml6ZWQgZXZpY3Rpb24gcG9saWN5ICR7ZXZpY3Rpb259YCk7XG59XG5cbnZhciBSZWNvaWxfdHJlZUNhY2hlRnJvbVBvbGljeSA9IHRyZWVDYWNoZUZyb21Qb2xpY3k7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIGlzTm9kZShvYmplY3QpIHtcbiAgdmFyIF9vd25lckRvY3VtZW50LCBfZG9jJGRlZmF1bHRWaWV3O1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGRvYyA9IG9iamVjdCAhPSBudWxsID8gKF9vd25lckRvY3VtZW50ID0gb2JqZWN0Lm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9vd25lckRvY3VtZW50ICE9PSB2b2lkIDAgPyBfb3duZXJEb2N1bWVudCA6IG9iamVjdCA6IGRvY3VtZW50O1xuICBjb25zdCBkZWZhdWx0VmlldyA9IChfZG9jJGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3KSAhPT0gbnVsbCAmJiBfZG9jJGRlZmF1bHRWaWV3ICE9PSB2b2lkIDAgPyBfZG9jJGRlZmF1bHRWaWV3IDogd2luZG93O1xuICByZXR1cm4gISEob2JqZWN0ICE9IG51bGwgJiYgKHR5cGVvZiBkZWZhdWx0Vmlldy5Ob2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgZGVmYXVsdFZpZXcuTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbnZhciBSZWNvaWxfaXNOb2RlID0gaXNOb2RlO1xuXG5jb25zdCB7XG4gIGlzUmVhY3ROYXRpdmU6IGlzUmVhY3ROYXRpdmUkMSxcbiAgaXNXaW5kb3c6IGlzV2luZG93JDFcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XG5cblxuXG5cblxuZnVuY3Rpb24gc2hvdWxkTm90QmVGcm96ZW4odmFsdWUpIHtcbiAgLy8gUHJpbWl0aXZlcyBhbmQgZnVuY3Rpb25zOlxuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIFJlYWN0IGVsZW1lbnRzOlxuXG5cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUuJCR0eXBlb2YpIHtcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSW1tdXRhYmxlIHN0cnVjdHVyZXM6XG5cblxuICBpZiAodmFsdWVbJ0BAX19JTU1VVEFCTEVfSVRFUkFCTEVfX0BAJ10gIT0gbnVsbCB8fCB2YWx1ZVsnQEBfX0lNTVVUQUJMRV9LRVlFRF9fQEAnXSAhPSBudWxsIHx8IHZhbHVlWydAQF9fSU1NVVRBQkxFX0lOREVYRURfX0BAJ10gIT0gbnVsbCB8fCB2YWx1ZVsnQEBfX0lNTVVUQUJMRV9PUkRFUkVEX19AQCddICE9IG51bGwgfHwgdmFsdWVbJ0BAX19JTU1VVEFCTEVfUkVDT1JEX19AQCddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBET00gbm9kZXM6XG5cblxuICBpZiAoUmVjb2lsX2lzTm9kZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChSZWNvaWxfaXNQcm9taXNlKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gU29tZSBlbnZpcm9ubWVudHMsIGp1c3QgYXMgSmVzdCwgZG9uJ3Qgd29yayB3aXRoIHRoZSBpbnN0YW5jZW9mIGNoZWNrXG5cblxuICBpZiAoIWlzUmVhY3ROYXRpdmUkMSAmJiBpc1dpbmRvdyQxKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBSZWN1cnNpdmVseSBmcmVlemUgYSB2YWx1ZSB0byBlbmZvcmNlIGl0IGlzIHJlYWQtb25seS5cbi8vIFRoaXMgbWF5IGFsc28gaGF2ZSBtaW5pbWFsIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50cyBmb3IgZW51bWVyYXRpbmdcbi8vIG9iamVjdHMgKGJhc2VkIG9uIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zLCBvZiBjb3Vyc2UpXG5cblxuZnVuY3Rpb24gZGVlcEZyZWV6ZVZhbHVlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHNob3VsZE5vdEJlRnJvemVuKHZhbHVlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIE9iamVjdC5mcmVlemUodmFsdWUpOyAvLyBNYWtlIGFsbCBwcm9wZXJ0aWVzIHJlYWQtb25seVxuXG4gIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgLy8gJEZsb3dJc3N1ZVttZXRob2QtdW5iaW5kaW5nXSBhZGRlZCB3aGVuIGltcHJvdmluZyB0eXBpbmcgZm9yIHRoaXMgcGFyYW1ldGVyc1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIGNvbnN0IHByb3AgPSB2YWx1ZVtrZXldOyAvLyBQcmV2ZW50IGluZmluaXRlIHJlY3Vyc3Npb24gZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ29iamVjdCcgJiYgcHJvcCAhPSBudWxsICYmICFPYmplY3QuaXNGcm96ZW4ocHJvcCkpIHtcbiAgICAgICAgZGVlcEZyZWV6ZVZhbHVlKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5zZWFsKHZhbHVlKTsgLy8gVGhpcyBhbHNvIG1ha2VzIGV4aXN0aW5nIHByb3BlcnRpZXMgbm9uLWNvbmZpZ3VyYWJsZS5cbn1cblxudmFyIFJlY29pbF9kZWVwRnJlZXplVmFsdWUgPSBkZWVwRnJlZXplVmFsdWU7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogVGhpcyBpcyBhIHN0dWIgZm9yIHNvbWUgaW50ZWdyYXRpb24gaW50byBGQiBpbnRlcm5hbCBzdHVmZlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuZnVuY3Rpb24gc3RhcnRQZXJmQmxvY2soX2lkKSB7XG4gIHJldHVybiAoKSA9PiBudWxsO1xufVxuXG52YXIgUmVjb2lsX1BlcmZvcm1hbmNlVGltaW5ncyA9IHtcbiAgc3RhcnRQZXJmQmxvY2tcbn07XG5cbmNvbnN0IHtcbiAgaXNMb2FkYWJsZTogaXNMb2FkYWJsZSQxLFxuICBsb2FkYWJsZVdpdGhFcnJvcjogbG9hZGFibGVXaXRoRXJyb3IkMSxcbiAgbG9hZGFibGVXaXRoUHJvbWlzZTogbG9hZGFibGVXaXRoUHJvbWlzZSQxLFxuICBsb2FkYWJsZVdpdGhWYWx1ZTogbG9hZGFibGVXaXRoVmFsdWUkMlxufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xuXG5jb25zdCB7XG4gIFdyYXBwZWRWYWx1ZTogV3JhcHBlZFZhbHVlJDFcbn0gPSBSZWNvaWxfV3JhcHBlciQxO1xuXG5cblxuY29uc3Qge1xuICBnZXROb2RlTG9hZGFibGU6IGdldE5vZGVMb2FkYWJsZSQyLFxuICBwZWVrTm9kZUxvYWRhYmxlOiBwZWVrTm9kZUxvYWRhYmxlJDEsXG4gIHNldE5vZGVWYWx1ZTogc2V0Tm9kZVZhbHVlJDNcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgc2F2ZURlcHNUb1N0b3JlOiBzYXZlRGVwc1RvU3RvcmUkMVxufSA9IFJlY29pbF9HcmFwaDtcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDYsXG4gIGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlcjogZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDEsXG4gIGdldE5vZGU6IGdldE5vZGUkNixcbiAgcmVnaXN0ZXJOb2RlOiByZWdpc3Rlck5vZGUkMVxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkM1xufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xuXG5jb25zdCB7XG4gIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkOiBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdDogcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0JDFcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5jb25zdCB7XG4gIHJlY29pbENhbGxiYWNrOiByZWNvaWxDYWxsYmFjayQxXG59ID0gUmVjb2lsX3VzZVJlY29pbENhbGxiYWNrO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCB7XG4gIHN0YXJ0UGVyZkJsb2NrOiBzdGFydFBlcmZCbG9jayQxXG59ID0gUmVjb2lsX1BlcmZvcm1hbmNlVGltaW5ncztcblxuXG5cbmNsYXNzIENhbmNlbGVkIHt9XG5cbmNvbnN0IENBTkNFTEVEID0gbmV3IENhbmNlbGVkKCk7XG4vKipcbiAqIEFuIEV4ZWN1dGlvbklEIGlzIGFuIGFyYml0cmFyeSBJRCB0aGF0IGxldHMgdXMgZGlzdGluZ3Vpc2ggZXhlY3V0aW9ucyBmcm9tXG4gKiBlYWNoIG90aGVyLiBUaGlzIGlzIG5lY2Vzc2FyeSBhcyB3ZSBuZWVkIGEgd2F5IG9mIHNvbHZpbmcgdGhpcyBwcm9ibGVtOlxuICogXCJnaXZlbiAzIGFzeW5jIGV4ZWN1dGlvbnMsIG9ubHkgdXBkYXRlIHN0YXRlIGZvciB0aGUgJ2xhdGVzdCcgZXhlY3V0aW9uIHdoZW5cbiAqIGl0IGZpbmlzaGVzIHJ1bm5pbmcgcmVnYXJkbGVzcyBvZiB3aGVuIHRoZSBvdGhlciAyIGZpbmlzaFwiLiBFeGVjdXRpb25JRHNcbiAqIHByb3ZpZGUgYSBjb252ZW5pZW50IHdheSBvZiBpZGVudGlmeWluZyBleGVjdXRpb25zIHNvIHRoYXQgd2UgY2FuIHRyYWNrIGFuZFxuICogbWFuYWdlIHRoZW0gb3ZlciB0aW1lLlxuICovXG5cbmNvbnN0IGRlcGVuZGVuY3lTdGFjayA9IFtdOyAvLyBmb3IgZGV0ZWN0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cblxuY29uc3Qgd2FpdGluZ1N0b3JlcyA9IG5ldyBNYXAoKTtcblxuY29uc3QgZ2V0TmV3RXhlY3V0aW9uSUQgPSAoKCkgPT4ge1xuICBsZXQgZXhlY3V0aW9uSUQgPSAwO1xuICByZXR1cm4gKCkgPT4gZXhlY3V0aW9uSUQrKztcbn0pKCk7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZWRlY2xhcmUgKi9cblxuXG5mdW5jdGlvbiBzZWxlY3RvcihvcHRpb25zKSB7XG4gIGxldCByZWNvaWxWYWx1ZSA9IG51bGw7XG4gIGNvbnN0IHtcbiAgICBrZXksXG4gICAgZ2V0LFxuICAgIGNhY2hlUG9saWN5X1VOU1RBQkxFOiBjYWNoZVBvbGljeVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc2V0ID0gb3B0aW9ucy5zZXQgIT0gbnVsbCA/IG9wdGlvbnMuc2V0IDogdW5kZWZpbmVkOyAvLyBmbG93XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycignQSBrZXkgb3B0aW9uIHdpdGggYSB1bmlxdWUgc3RyaW5nIHZhbHVlIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBjcmVhdGluZyBhIHNlbGVjdG9yLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKCdTZWxlY3RvcnMgbXVzdCBzcGVjaWZ5IGEgZ2V0IGNhbGxiYWNrIG9wdGlvbiB0byBnZXQgdGhlIHNlbGVjdG9yIHZhbHVlLicpO1xuICAgIH1cbiAgfSAvLyBUaGlzIGlzIGV2ZXJ5IGRpc2NvdmVyZWQgZGVwZW5kZW5jeSBhY3Jvc3MgYWxsIGV4ZWN1dGlvbnNcblxuXG4gIGNvbnN0IGRpc2NvdmVyZWREZXBlbmRlbmN5Tm9kZUtleXMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGNhY2hlID0gUmVjb2lsX3RyZWVDYWNoZUZyb21Qb2xpY3koY2FjaGVQb2xpY3kgIT09IG51bGwgJiYgY2FjaGVQb2xpY3kgIT09IHZvaWQgMCA/IGNhY2hlUG9saWN5IDoge1xuICAgIGVxdWFsaXR5OiAncmVmZXJlbmNlJyxcbiAgICBldmljdGlvbjogJ2tlZXAtYWxsJ1xuICB9LCBrZXkpO1xuICBjb25zdCByZXRhaW5lZEJ5ID0gcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0JDEob3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFKTtcbiAgY29uc3QgZXhlY3V0aW9uSW5mb01hcCA9IG5ldyBNYXAoKTtcbiAgbGV0IGxpdmVTdG9yZXNDb3VudCA9IDA7XG5cbiAgZnVuY3Rpb24gc2VsZWN0b3JJc0xpdmUoKSB7XG4gICAgcmV0dXJuICFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpIHx8IGxpdmVTdG9yZXNDb3VudCA+IDA7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RvckluaXQoc3RvcmUpIHtcbiAgICBzdG9yZS5nZXRTdGF0ZSgpLmtub3duU2VsZWN0b3JzLmFkZChrZXkpO1xuICAgIGxpdmVTdG9yZXNDb3VudCsrO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXZlU3RvcmVzQ291bnQtLTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0b3JTaG91bGREZWxldGVDb25maWdPblJlbGVhc2UoKSB7XG4gICAgcmV0dXJuIGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQxKGtleSkgIT09IHVuZGVmaW5lZCAmJiAhc2VsZWN0b3JJc0xpdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVBc3luYyhzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklELCBsb2FkYWJsZSwgZGVwVmFsdWVzKSB7XG4gICAgc2V0Q2FjaGUoc3RhdGUsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpO1xuICAgIG5vdGlmeVN0b3Jlc09mUmVzb2x2ZWRBc3luYyhzdG9yZSwgZXhlY3V0aW9uSUQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5U3RvcmVzT2ZSZXNvbHZlZEFzeW5jKHN0b3JlLCBleGVjdXRpb25JRCkge1xuICAgIGlmIChpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpKSB7XG4gICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xuICAgIH1cblxuICAgIG5vdGlmeVdhaXRpbmdTdG9yZXMoZXhlY3V0aW9uSUQsIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBOb3RpZnkgc3RvcmVzIHRvIHB1bGwgdGhlIHNlbGVjdG9yIGFnYWluIGlmIGEgbmV3IGFzeW5jIGRlcCB3YXMgZGlzY292ZXJlZC5cbiAgICogMSkgQXN5bmMgc2VsZWN0b3IgYWRkcyBhIG5ldyBkZXAgYnV0IGRvZXNuJ3QgcmVzb2x2ZSB5ZXQuXG4gICAqICAgIE5vdGUgdGhhdCBkZXBzIGZvciBhbiBhc3luYyBzZWxlY3RvciBhcmUgYmFzZWQgb24gdGhlIHN0YXRlIHdoZW4gdGhlXG4gICAqICAgIGV2YWx1YXRpb24gc3RhcnRlZCwgaW4gb3JkZXIgdG8gcHJvdmlkZSBhIGNvbnNpc3RlbnQgcGljdHVyZSBvZiBzdGF0ZS5cbiAgICogMikgQnV0LCBuZXcgdmFsdWUgb2YgZGVwIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIG1pZ2h0IGNhdXNlIHRoZSBzZWxlY3RvclxuICAgKiAgICB0byByZXNvbHZlIG9yIHJlc29sdmUgZGlmZmVyZW50bHkuXG4gICAqIDMpIFRoZXJlZm9yZSwgdGhpcyBub3RpZmljYXRpb24gd2lsbCBwdWxsIHRoZSBzZWxlY3RvciBiYXNlZCBvbiB0aGUgY3VycmVudFxuICAgKiAgICBzdGF0ZSBmb3IgdGhlIGNvbXBvbmVudHNcbiAgICovXG5cblxuICBmdW5jdGlvbiBub3RpZnlTdG9yZXNPZk5ld0FzeW5jRGVwKHN0b3JlLCBleGVjdXRpb25JRCkge1xuICAgIGlmIChpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpKSB7XG4gICAgICBjb25zdCBleGVjdXRpb25JbmZvID0gUmVjb2lsX251bGx0aHJvd3MoZ2V0RXhlY3V0aW9uSW5mbyhzdG9yZSkpO1xuICAgICAgZXhlY3V0aW9uSW5mby5zdGF0ZVZlcnNpb25zLmNsZWFyKCk7XG4gICAgICBub3RpZnlXYWl0aW5nU3RvcmVzKGV4ZWN1dGlvbklELCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5V2FpdGluZ1N0b3JlcyhleGVjdXRpb25JRCwgY2xlYXJXYWl0bGlzdCkge1xuICAgIGNvbnN0IHN0b3JlcyA9IHdhaXRpbmdTdG9yZXMuZ2V0KGV4ZWN1dGlvbklEKTtcblxuICAgIGlmIChzdG9yZXMgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCB3YWl0aW5nU3RvcmUgb2Ygc3RvcmVzKSB7XG4gICAgICAgIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDEod2FpdGluZ1N0b3JlLCBSZWNvaWxfbnVsbHRocm93cyhyZWNvaWxWYWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xlYXJXYWl0bGlzdCkge1xuICAgICAgICB3YWl0aW5nU3RvcmVzLmRlbGV0ZShleGVjdXRpb25JRCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1N0b3JlV2FpdGluZ0ZvclJlc29sdmVkQXN5bmMoc3RvcmUsIGV4ZWN1dGlvbklEKSB7XG4gICAgbGV0IHN0b3JlcyA9IHdhaXRpbmdTdG9yZXMuZ2V0KGV4ZWN1dGlvbklEKTtcblxuICAgIGlmIChzdG9yZXMgPT0gbnVsbCkge1xuICAgICAgd2FpdGluZ1N0b3Jlcy5zZXQoZXhlY3V0aW9uSUQsIHN0b3JlcyA9IG5ldyBTZXQoKSk7XG4gICAgfVxuXG4gICAgc3RvcmVzLmFkZChzdG9yZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYXR0YWNoZXMgYSB0aGVuKCkgYW5kIGEgY2F0Y2goKSB0byBhIHByb21pc2UgdGhhdCB3YXNcbiAgICogcmV0dXJuZWQgZnJvbSBhIHNlbGVjdG9yJ3MgZ2V0KCkgKGVpdGhlciBleHBsaWNpdGx5IG9yIGltcGxpY2l0bHkgYnlcbiAgICogcnVubmluZyBhIGZ1bmN0aW9uIHRoYXQgdXNlcyB0aGUgXCJhc3luY1wiIGtleXdvcmQpLiBJZiBhIHNlbGVjdG9yJ3MgZ2V0KClcbiAgICogcmV0dXJucyBhIHByb21pc2UsIHdlIGhhdmUgdHdvIHBvc3NpYmlsaXRpZXM6XG4gICAqXG4gICAqIDEuIFRoZSBwcm9taXNlIHdpbGwgcmVzb2x2ZSwgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGhhdmUgY29tcGxldGVseSBmaW5pc2hlZFxuICAgKiAgICBleGVjdXRpbmcgd2l0aG91dCBhbnkgcmVtYWluaW5nIHBlbmRpbmcgZGVwZW5kZW5jaWVzLiBObyBtb3JlIHJldHJpZXNcbiAgICogICAgYXJlIG5lZWRlZCBhbmQgd2UgY2FuIHByb2NlZWQgd2l0aCB1cGRhdGluZyB0aGUgY2FjaGUgYW5kIG5vdGlmeWluZ1xuICAgKiAgICBzdWJzY3JpYmVycyAoaWYgaXQgaXMgdGhlIGxhdGVzdCBleGVjdXRpb24sIG90aGVyd2lzZSBvbmx5IHRoZSBjYWNoZVxuICAgKiAgICB3aWxsIGJlIHVwZGF0ZWQgYW5kIHN1YnNjcmlwdGlvbnMgd2lsbCBub3QgYmUgZmlyZWQpLiBUaGlzIGlzIHRoZSBjYXNlXG4gICAqICAgIGhhbmRsZWQgYnkgdGhlIGF0dGFjaGVkIHRoZW4oKSBoYW5kbGVyLlxuICAgKlxuICAgKiAyLiBUaGUgcHJvbWlzZSB3aWxsIHRocm93IGJlY2F1c2UgaXQgZWl0aGVyIGhhcyBhbiBlcnJvciBvciBpdCBjYW1lIGFjcm9zc1xuICAgKiAgICBhbiBhc3luYyBkZXBlbmRlbmN5IHRoYXQgaGFzIG5vdCB5ZXQgcmVzb2x2ZWQsIGluIHdoaWNoIGNhc2Ugd2Ugd2lsbFxuICAgKiAgICBjYWxsIHdyYXBEZXBkZW5jeVByb21pc2UoKSwgd2hvc2UgcmVzcG9uc2liaWxpdHkgaXMgdG8gaGFuZGxlIGRlcGVuZGVuY3lcbiAgICogICAgcHJvbWlzZXMuIFRoaXMgY2FzZSBpcyBoYW5kbGVkIGJ5IHRoZSBhdHRhY2hlZCBjYXRjaCgpIGhhbmRsZXIuXG4gICAqXG4gICAqIEJvdGggYnJhbmNoZXMgd2lsbCBldmVudHVhbGx5IHJlc29sdmUgdG8gdGhlIGZpbmFsIHJlc3VsdCBvZiB0aGUgc2VsZWN0b3JcbiAgICogKG9yIGFuIGVycm9yIGlmIGEgcmVhbCBlcnJvciBvY2N1cnJlZCkuXG4gICAqXG4gICAqIFRoZSBleGVjdXRpb24gd2lsbCBydW4gdG8gY29tcGxldGlvbiBldmVuIGlmIGl0IGlzIHN0YWxlLCBhbmQgaXRzIHZhbHVlXG4gICAqIHdpbGwgYmUgY2FjaGVkLiBCdXQgc3RhbGUgZXhlY3V0aW9ucyB3aWxsIG5vdCB1cGRhdGUgZ2xvYmFsIHN0YXRlIG9yIHVwZGF0ZVxuICAgKiBleGVjdXRpb25JbmZvIGFzIHRoYXQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSAnbGF0ZXN0JyBleGVjdXRpb24uXG4gICAqXG4gICAqIE5vdGUgdGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIHBhc3NlZCBhIHByb21pc2UgdGhhdCB3YXMgdGhyb3duLS1BS0EgYVxuICAgKiBkZXBlbmRlbmN5IHByb21pc2UuIERlcGVuZGVuY3kgcHJvbWlzZXMgc2hvdWxkIGJlIHBhc3NlZCB0b1xuICAgKiB3cmFwUGVuZGluZ0RlcGVuZGVuY3lQcm9taXNlKCkpLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHdyYXBSZXN1bHRQcm9taXNlKHN0b3JlLCBwcm9taXNlLCBzdGF0ZSwgZGVwVmFsdWVzLCBleGVjdXRpb25JRCwgbG9hZGluZ0RlcHNTdGF0ZSkge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgaWYgKCFzZWxlY3RvcklzTGl2ZSgpKSB7XG4gICAgICAgIC8vIFRoZSBzZWxlY3RvciB3YXMgcmVsZWFzZWQgc2luY2UgdGhlIHJlcXVlc3QgYmVnYW47IGlnbm9yZSB0aGUgcmVzcG9uc2UuXG4gICAgICAgIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSk7XG4gICAgICAgIHRocm93IENBTkNFTEVEO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2FkYWJsZSA9IGxvYWRhYmxlV2l0aFZhbHVlJDIodmFsdWUpO1xuICAgICAgcmVzb2x2ZUFzeW5jKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pLmNhdGNoKGVycm9yT3JQcm9taXNlID0+IHtcbiAgICAgIGlmICghc2VsZWN0b3JJc0xpdmUoKSkge1xuICAgICAgICAvLyBUaGUgc2VsZWN0b3Igd2FzIHJlbGVhc2VkIHNpbmNlIHRoZSByZXF1ZXN0IGJlZ2FuOyBpZ25vcmUgdGhlIHJlc3BvbnNlLlxuICAgICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xuICAgICAgICB0aHJvdyBDQU5DRUxFRDtcbiAgICAgIH1cblxuICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UoZXJyb3JPclByb21pc2UpKSB7XG4gICAgICAgIHJldHVybiB3cmFwUGVuZGluZ0RlcGVuZGVuY3lQcm9taXNlKHN0b3JlLCBlcnJvck9yUHJvbWlzZSwgc3RhdGUsIGRlcFZhbHVlcywgZXhlY3V0aW9uSUQsIGxvYWRpbmdEZXBzU3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2FkYWJsZSA9IGxvYWRhYmxlV2l0aEVycm9yJDEoZXJyb3JPclByb21pc2UpO1xuICAgICAgcmVzb2x2ZUFzeW5jKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpO1xuICAgICAgdGhyb3cgZXJyb3JPclByb21pc2U7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYXR0YWNoZXMgYSB0aGVuKCkgYW5kIGEgY2F0Y2goKSB0byBhIHByb21pc2UgdGhhdCB3YXNcbiAgICogdGhyb3duIGZyb20gYSBzZWxlY3RvcidzIGdldCgpLiBJZiBhIHNlbGVjdG9yJ3MgZ2V0KCkgdGhyb3dzIGEgcHJvbWlzZSxcbiAgICogd2UgaGF2ZSB0d28gcG9zc2liaWxpdGllczpcbiAgICpcbiAgICogMS4gVGhlIHByb21pc2Ugd2lsbCByZXNvbHZlLCBtZWFuaW5nIG9uZSBvZiBvdXIgc2VsZWN0b3IncyBkZXBlbmRlbmNpZXMgaXNcbiAgICogICAgbm93IGF2YWlsYWJsZSBhbmQgd2Ugc2hvdWxkIFwicmV0cnlcIiBvdXIgZ2V0KCkgYnkgcnVubmluZyBpdCBhZ2Fpbi4gVGhpc1xuICAgKiAgICBpcyB0aGUgY2FzZSBoYW5kbGVkIGJ5IHRoZSBhdHRhY2hlZCB0aGVuKCkgaGFuZGxlci5cbiAgICpcbiAgICogMi4gVGhlIHByb21pc2Ugd2lsbCB0aHJvdyBiZWNhdXNlIHNvbWV0aGluZyB3ZW50IHdyb25nIHdpdGggdGhlIGRlcGVuZGVuY3lcbiAgICogICAgcHJvbWlzZSAoaW4gb3RoZXIgd29yZHMgYSByZWFsIGVycm9yIG9jY3VycmVkKS4gVGhpcyBjYXNlIGlzIGhhbmRsZWQgYnlcbiAgICogICAgdGhlIGF0dGFjaGVkIGNhdGNoKCkgaGFuZGxlci4gSWYgdGhlIGRlcGVuZGVuY3kgcHJvbWlzZSB0aHJvd3MsIGl0IGlzXG4gICAqICAgIF9hbHdheXNfIGEgcmVhbCBlcnJvciBhbmQgbm90IGFub3RoZXIgZGVwZW5kZW5jeSBwcm9taXNlIChhbnkgZGVwZW5kZW5jeVxuICAgKiAgICBwcm9taXNlcyB3b3VsZCBoYXZlIGJlZW4gaGFuZGxlZCB1cHN0cmVhbSkuXG4gICAqXG4gICAqIFRoZSB0aGVuKCkgYnJhbmNoIHdpbGwgZXZlbnR1YWxseSByZXNvbHZlIHRvIHRoZSBmaW5hbCByZXN1bHQgb2YgdGhlXG4gICAqIHNlbGVjdG9yIChvciBhbiBlcnJvciBpZiBhIHJlYWwgZXJyb3Igb2NjdXJzKSwgYW5kIHRoZSBjYXRjaCgpIHdpbGwgYWx3YXlzXG4gICAqIHJlc29sdmUgdG8gYW4gZXJyb3IgYmVjYXVzZSB0aGUgZGVwZW5kZW5jeSBwcm9taXNlIGlzIGEgcHJvbWlzZSB0aGF0IHdhc1xuICAgKiB3cmFwcGVkIHVwc3RyZWFtLCBtZWFuaW5nIGl0IHdpbGwgb25seSByZXNvbHZlIHRvIGl0cyByZWFsIHZhbHVlIG9yIHRvIGFcbiAgICogcmVhbCBlcnJvci5cbiAgICpcbiAgICogVGhlIGV4ZWN1dGlvbiB3aWxsIHJ1biB0byBjb21wbGV0aW9uIGV2ZW4gaWYgaXQgaXMgc3RhbGUsIGFuZCBpdHMgdmFsdWVcbiAgICogd2lsbCBiZSBjYWNoZWQuIEJ1dCBzdGFsZSBleGVjdXRpb25zIHdpbGwgbm90IHVwZGF0ZSBnbG9iYWwgc3RhdGUgb3IgdXBkYXRlXG4gICAqIGV4ZWN1dGlvbkluZm8gYXMgdGhhdCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlICdsYXRlc3QnIGV4ZWN1dGlvbi5cbiAgICpcbiAgICogTm90ZSB0aGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgcGFzc2VkIGEgcHJvbWlzZSB0aGF0IHdhcyByZXR1cm5lZCBmcm9tXG4gICAqIGdldCgpLiBUaGUgaW50ZW50aW9uIGlzIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IHBhc3NlZCBwcm9taXNlcyB0aGF0XG4gICAqIHdlcmUgdGhyb3duIGR1ZSB0byBhIHBlbmRpbmcgZGVwZW5kZW5jeS4gUHJvbWlzZXMgcmV0dXJuZWQgYnkgZ2V0KCkgc2hvdWxkXG4gICAqIGJlIHBhc3NlZCB0byB3cmFwUmVzdWx0UHJvbWlzZSgpIGluc3RlYWQuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gd3JhcFBlbmRpbmdEZXBlbmRlbmN5UHJvbWlzZShzdG9yZSwgcHJvbWlzZSwgc3RhdGUsIGV4aXN0aW5nRGVwcywgZXhlY3V0aW9uSUQsIGxvYWRpbmdEZXBzU3RhdGUpIHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKHJlc29sdmVkRGVwID0+IHtcbiAgICAgIGlmICghc2VsZWN0b3JJc0xpdmUoKSkge1xuICAgICAgICAvLyBUaGUgc2VsZWN0b3Igd2FzIHJlbGVhc2VkIHNpbmNlIHRoZSByZXF1ZXN0IGJlZ2FuOyBpZ25vcmUgdGhlIHJlc3BvbnNlLlxuICAgICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xuICAgICAgICB0aHJvdyBDQU5DRUxFRDtcbiAgICAgIH0gLy8gQ2hlY2sgaWYgd2UgYXJlIGhhbmRsaW5nIGEgcGVuZGluZyBSZWNvaWwgZGVwZW5kZW5jeSBvciBpZiB0aGUgdXNlclxuICAgICAgLy8gdGhyZXcgdGhlaXIgb3duIFByb21pc2UgdG8gXCJzdXNwZW5kXCIgYSBzZWxlY3RvciBldmFsdWF0aW9uLiAgV2UgbmVlZFxuICAgICAgLy8gdG8gY2hlY2sgdGhhdCB0aGUgbG9hZGluZ0RlcFByb21pc2UgYWN0dWFsbHkgbWF0Y2hlcyB0aGUgcHJvbWlzZSB0aGF0XG4gICAgICAvLyB3ZSBjYXVnaHQgaW4gY2FzZSB0aGUgc2VsZWN0b3IgaGFwcGVuZWQgdG8gY2F0Y2ggdGhlIHByb21pc2Ugd2UgdGhyZXdcbiAgICAgIC8vIGZvciBhIHBlbmRpbmcgUmVjb2lsIGRlcGVuZGVuY3kgZnJvbSBgZ2V0UmVjb2lsVmFsdWUoKWAgYW5kIHRocmV3XG4gICAgICAvLyB0aGVpciBvd24gcHJvbWlzZSBpbnN0ZWFkLlxuXG5cbiAgICAgIGlmIChsb2FkaW5nRGVwc1N0YXRlLmxvYWRpbmdEZXBLZXkgIT0gbnVsbCAmJiBsb2FkaW5nRGVwc1N0YXRlLmxvYWRpbmdEZXBQcm9taXNlID09PSBwcm9taXNlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3RlIGZvciBhc3luYyBhdG9tcywgdGhpcyBtZWFucyB3ZSBhcmUgY2hhbmdpbmcgdGhlIGF0b20ncyB2YWx1ZVxuICAgICAgICAgKiBpbiB0aGUgc3RvcmUgZm9yIHRoZSBnaXZlbiB2ZXJzaW9uLiBUaGlzIHNob3VsZCBiZSBhbHJpZ2h0IGJlY2F1c2VcbiAgICAgICAgICogdGhlIHZlcnNpb24gb2Ygc3RhdGUgaXMgbm93IHN0YWxlIGFuZCBhIG5ldyB2ZXJzaW9uIHdpbGwgaGF2ZVxuICAgICAgICAgKiBhbHJlYWR5IGJlZW4gdHJpZ2dlcmVkIGJ5IHRoZSBhdG9tIGJlaW5nIHJlc29sdmVkIChzZWUgdGhpcyBsb2dpY1xuICAgICAgICAgKiBpbiBSZWNvaWxfYXRvbS5qcylcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRlLmF0b21WYWx1ZXMuc2V0KGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcEtleSwgbG9hZGFibGVXaXRoVmFsdWUkMihyZXNvbHZlZERlcCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHJlc29sdmVkRGVwS2V5IGlzIG5vdCBkZWZpbmVkLCB0aGUgcHJvbWlzZSB3YXMgYSB1c2VyLXRocm93blxuICAgICAgICAgKiBwcm9taXNlLiBVc2VyLXRocm93biBwcm9taXNlcyBhcmUgYW4gYWR2YW5jZWQgZmVhdHVyZSBhbmQgdGhleVxuICAgICAgICAgKiBzaG91bGQgYmUgYXZvaWRlZCBpbiBhbG1vc3QgYWxsIGNhc2VzLiBVc2luZyBgbG9hZGFibGUubWFwKClgIGluc2lkZVxuICAgICAgICAgKiBvZiBzZWxlY3RvcnMgZm9yIGxvYWRpbmcgbG9hZGFibGVzIGFuZCB0aGVuIHRocm93aW5nIHRoYXQgbWFwcGVkXG4gICAgICAgICAqIGxvYWRhYmxlJ3MgcHJvbWlzZSBpcyBhbiBleGFtcGxlIG9mIGEgdXNlci10aHJvd24gcHJvbWlzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiB3ZSBoaXQgYSB1c2VyLXRocm93biBwcm9taXNlLCB3ZSBoYXZlIHRvIGJhaWwgb3V0IG9mIGFuIG9wdGltaXphdGlvblxuICAgICAgICAgKiB3aGVyZSB3ZSBieXBhc3MgY2FsY3VsYXRpbmcgc2VsZWN0b3IgY2FjaGUga2V5cyBmb3Igc2VsZWN0b3JzIHRoYXRcbiAgICAgICAgICogaGF2ZSBiZWVuIHByZXZpb3VzbHkgc2VlbiBmb3IgYSBnaXZlbiBzdGF0ZSAodGhlc2Ugc2VsZWN0b3JzIGFyZSBzYXZlZCBpblxuICAgICAgICAgKiBzdGF0ZS5hdG9tVmFsdWVzKSB0byBhdm9pZCBzdGFsZSBzdGF0ZSBhcyB3ZSBoYXZlIG5vIHdheSBvZiBrbm93aW5nXG4gICAgICAgICAqIHdoYXQgc3RhdGUgY2hhbmdlcyBoYXBwZW5lZCAoaWYgYW55KSBpbiByZXN1bHQgdG8gdGhlIHByb21pc2UgcmVzb2x2aW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZGVhbGx5IHdlIHdvdWxkIG9ubHkgYmFpbCBvdXQgc2VsZWN0b3JzIHRoYXQgYXJlIGluIHRoZSBjaGFpbiBvZlxuICAgICAgICAgKiBkZXBlbmRlbmNpZXMgZm9yIHRoaXMgc2VsZWN0b3IsIGJ1dCB0aGVyZSdzIGN1cnJlbnRseSBubyB3YXkgdG8gZ2V0XG4gICAgICAgICAqIGEgZnVsbCBsaXN0IG9mIGEgc2VsZWN0b3IncyBkb3duc3RyZWFtIG5vZGVzIGJlY2F1c2UgdGhlIHN0YXRlIHRoYXRcbiAgICAgICAgICogaXMgZXhlY3V0aW5nIG1heSBiZSBhIGRpc2NhcmRlZCB0cmVlIChzbyBzdG9yZS5nZXRHcmFwaChzdGF0ZS52ZXJzaW9uKVxuICAgICAgICAgKiB3aWxsIGJlIGVtcHR5KSwgYW5kIHRoZSBmdWxsIGRlcCB0cmVlIG1heSBub3QgYmUgaW4gdGhlIHNlbGVjdG9yXG4gICAgICAgICAqIGNhY2hlcyBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgc2VsZWN0b3IncyBjYWNoZSB3YXMgY2xlYXJlZC4gVG8gc29sdmVcbiAgICAgICAgICogZm9yIHRoaXMgd2Ugd291bGQgaGF2ZSB0byBrZWVwIHRyYWNrIG9mIGFsbCBydW5uaW5nIHNlbGVjdG9yXG4gICAgICAgICAqIGV4ZWN1dGlvbnMgYW5kIHRoZWlyIGRvd25zdHJlYW0gZGVwcy4gQmVjYXVzZSB0aGlzIG9ubHkgY292ZXJzIGVkZ2VcbiAgICAgICAgICogY2FzZXMsIHRoYXQgY29tcGxleGl0eSBtaWdodCBub3QgYmUganVzdGlmeWFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLmtub3duU2VsZWN0b3JzLmZvckVhY2gobm9kZUtleSA9PiB7XG4gICAgICAgICAgc3RhdGUuYXRvbVZhbHVlcy5kZWxldGUobm9kZUtleSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBPcHRpbWl6YXRpb246IE5vdyB0aGF0IHRoZSBkZXBlbmRlbmN5IGhhcyByZXNvbHZlZCwgbGV0J3MgdHJ5IGhpdHRpbmdcbiAgICAgICAqIHRoZSBjYWNoZSBpbiBjYXNlIHRoZSBkZXAgcmVzb2x2ZWQgdG8gYSB2YWx1ZSB3ZSBoYXZlIHByZXZpb3VzbHkgc2Vlbi5cbiAgICAgICAqXG4gICAgICAgKiBUT0RPOlxuICAgICAgICogTm90ZSB0aGlzIG9wdGltaXphdGlvbiBpcyBub3QgcGVyZmVjdCBiZWNhdXNlIGl0IG9ubHkgcHJldmVudHMgcmUtZXhlY3V0aW9uc1xuICAgICAgICogX2FmdGVyXyB0aGUgcG9pbnQgd2hlcmUgYW4gYXN5bmMgZGVwZW5kZW5jeSBpcyBmb3VuZC4gQW55IGNvZGUgbGVhZGluZ1xuICAgICAgICogdXAgdG8gdGhlIGFzeW5jIGRlcGVuZGVuY3kgbWF5IGhhdmUgcnVuIHVubmVjZXNzYXJpbHkuIFRoZSBpZGVhbCBjYXNlXG4gICAgICAgKiB3b3VsZCBiZSB0byB3YWl0IGZvciB0aGUgYXN5bmMgZGVwZW5kZW5jeSB0byByZXNvbHZlIGZpcnN0LCBjaGVjayB0aGVcbiAgICAgICAqIGNhY2hlLCBhbmQgcHJldmVudCBfYW55XyBleGVjdXRpb24gb2YgdGhlIHNlbGVjdG9yIGlmIHRoZSByZXN1bHRpbmdcbiAgICAgICAqIHZhbHVlIG9mIHRoZSBkZXBlbmRlbmN5IGxlYWRzIHRvIGEgcGF0aCB0aGF0IGlzIGZvdW5kIGluIHRoZSBjYWNoZS5cbiAgICAgICAqIFRoZSBpZGVhbCBjYXNlIGlzIG1vcmUgZGlmZmljdWx0IHRvIGltcGxlbWVudCBhcyBpdCB3b3VsZCByZXF1aXJlIHRoYXRcbiAgICAgICAqIHdlIGNhcHR1cmUgYW5kIHdhaXQgZm9yIHRoZSB0aGUgYXN5bmMgZGVwZW5kZW5jeSByaWdodCBhZnRlciBjaGVja2luZ1xuICAgICAgICogdGhlIGNhY2hlLiBUaGUgY3VycmVudCBhcHByb2FjaCB0YWtlcyBhZHZhbnRhZ2Ugb2YgdGhlIGZhY3QgdGhhdCBydW5uaW5nXG4gICAgICAgKiB0aGUgc2VsZWN0b3IgYWxyZWFkeSBoYXMgYSBjb2RlIHBhdGggdGhhdCBsZXRzIHVzIGV4aXQgZWFybHkgd2hlblxuICAgICAgICogYW4gYXN5bmMgZGVwIHJlc29sdmVzLlxuICAgICAgICovXG5cblxuICAgICAgY29uc3QgY2FjaGVkTG9hZGFibGUgPSBnZXRMb2FkYWJsZUZyb21DYWNoZUFuZFVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlKTtcblxuICAgICAgaWYgKGNhY2hlZExvYWRhYmxlICYmIGNhY2hlZExvYWRhYmxlLnN0YXRlICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaGFzIHRvIG5vdGlmeSBzdG9yZXMgb2YgYSByZXNvbHZlZCBhc3luYywgZXZlbiBpZiB0aGVyZSBpcyBub1xuICAgICAgICAgKiBjdXJyZW50IHBlbmRpbmcgZXhlY3V0aW9uIGZvciB0aGUgZm9sbG93aW5nIGNhc2U6XG4gICAgICAgICAqIDEpIEEgY29tcG9uZW50IHJlbmRlcnMgd2l0aCB0aGlzIHBlbmRpbmcgbG9hZGFibGUuXG4gICAgICAgICAqIDIpIFRoZSB1cHN0cmVhbSBkZXBlbmRlbmN5IHJlc29sdmVzLlxuICAgICAgICAgKiAzKSBXaGlsZSBwcm9jZXNzaW5nIHNvbWUgb3RoZXIgc2VsZWN0b3IgaXQgcmVhZHMgdGhpcyBvbmUsIHN1Y2ggYXNcbiAgICAgICAgICogICAgd2hpbGUgdHJhdmVyc2luZyBpdHMgZGVwZW5kZW5jaWVzLiAgQXQgdGhpcyBwb2ludCBpdCBnZXRzIHRoZVxuICAgICAgICAgKiAgICBuZXcgcmVzb2x2ZWQgdmFsdWUgc3luY2hyb25vdXNseSBhbmQgY2xlYXJzIHRoZSBjdXJyZW50XG4gICAgICAgICAqICAgIGV4ZWN1dGlvbiBJRC4gIFRoZSBjb21wb25lbnQgd2Fzbid0IGdldHRpbmcgdGhlIHZhbHVlIGl0c2VsZixcbiAgICAgICAgICogICAgdGhvdWdoLCBzbyBpdCBzdGlsbCBoYXMgdGhlIHBlbmRpbmcgbG9hZGFibGUuXG4gICAgICAgICAqIDQpIFdoZW4gdGhpcyBjb2RlIGV4ZWN1dGVzIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBpZCB3YXMgY2xlYXJlZFxuICAgICAgICAgKiAgICBhbmQgaXQgd291bGRuJ3Qgbm90aWZ5IHRoZSBjb21wb25lbnQgb2YgdGhlIG5ldyB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSSB0aGluayB0aGlzIGlzIG9ubHkgYW4gaXNzdWUgd2l0aCBcImVhcmx5XCIgcmVuZGVyaW5nIHNpbmNlIHRoZVxuICAgICAgICAgKiBjb21wb25lbnRzIGdvdCB0aGVpciB2YWx1ZSB1c2luZyB0aGUgaW4tcHJvZ3Jlc3MgZXhlY3V0aW9uLlxuICAgICAgICAgKiBXZSBkb24ndCBoYXZlIGEgdW5pdCB0ZXN0IGZvciB0aGlzIGNhc2UgeWV0LiAgSSdtIG5vdCBzdXJlIGl0IGlzXG4gICAgICAgICAqIG5lY2Vzc2FyeSB3aXRoIHJlY29pbF90cmFuc2l0aW9uX3N1cHBvcnQgbW9kZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpIHx8IGdldEV4ZWN1dGlvbkluZm8oc3RvcmUpID09IG51bGwpIHtcbiAgICAgICAgICBub3RpZnlTdG9yZXNPZlJlc29sdmVkQXN5bmMoc3RvcmUsIGV4ZWN1dGlvbklEKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYWNoZWRMb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJykge1xuICAgICAgICAgIHJldHVybiBjYWNoZWRMb2FkYWJsZS5jb250ZW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBjYWNoZWRMb2FkYWJsZS5jb250ZW50cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGlzIGV4ZWN1dGlvbiBpcyBzdGFsZSwgbGV0J3MgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIHNvbWUgaW5cbiAgICAgICAqIHByb2dyZXNzIGV4ZWN1dGlvbiB3aXRoIGEgbWF0Y2hpbmcgc3RhdGUuIElmIHdlIGZpbmQgYSBtYXRjaCwgdGhlblxuICAgICAgICogd2UgY2FuIHRha2UgdGhlIHZhbHVlIGZyb20gdGhhdCBpbi1wcm9ncmVzcyBleGVjdXRpb24uIE5vdGUgdGhpcyBtYXlcbiAgICAgICAqIHNvdW5kIGxpa2UgYW4gZWRnZSBjYXNlLCBidXQgbWF5IGJlIHZlcnkgY29tbW9uIGluIGNhc2VzIHdoZXJlIGFcbiAgICAgICAqIGxvYWRpbmcgZGVwZW5kZW5jeSByZXNvbHZlcyBmcm9tIGxvYWRpbmcgdG8gaGF2aW5nIGEgdmFsdWUgKHRodXNcbiAgICAgICAqIHBvc3NpYmx5IHRyaWdnZXJpbmcgYSByZS1yZW5kZXIpLCBhbmQgUmVhY3QgcmUtcmVuZGVycyBiZWZvcmUgdGhlXG4gICAgICAgKiBjaGFpbmVkIC50aGVuKCkgZnVuY3Rpb25zIHJ1biwgdGh1cyBzdGFydGluZyBhIG5ldyBleGVjdXRpb24gYXMgdGhlXG4gICAgICAgKiBkZXAgaGFzIGNoYW5nZWQgdmFsdWUuIFdpdGhvdXQgdGhpcyBjaGVjayB3ZSB3aWxsIHJ1biB0aGUgc2VsZWN0b3JcbiAgICAgICAqIHR3aWNlIChvbmNlIGluIHRoZSBuZXcgZXhlY3V0aW9uIGFuZCBvbmNlIGFnYWluIGluIHRoaXMgLnRoZW4oKSwgc29cbiAgICAgICAqIHRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGtlZXAgdW5uZWNlc3NhcnkgcmUtZXhlY3V0aW9ucyB0byBhXG4gICAgICAgKiBtaW5pbXVtKS5cbiAgICAgICAqXG4gICAgICAgKiBBbHNvIG5vdGUgdGhpcyBjb2RlIGRvZXMgbm90IGNoZWNrIGFjcm9zcyBhbGwgZXhlY3V0aW9ucyB0aGF0IG1heSBiZVxuICAgICAgICogcnVubmluZy4gSXQgb25seSBvcHRpbWl6ZXMgZm9yIHRoZSBfbGF0ZXN0XyBleGVjdXRpb24gcGVyIHN0b3JlIGFzXG4gICAgICAgKiB3ZSBjdXJyZW50bHkgZG8gbm90IG1haW50YWluIGEgbGlzdCBvZiBhbGwgY3VycmVudGx5IHJ1bm5pbmcgZXhlY3V0aW9ucy5cbiAgICAgICAqIFRoaXMgbWVhbnMgaW4gc29tZSBjYXNlcyB3ZSBtYXkgcnVuIHNlbGVjdG9ycyBtb3JlIHRoYW4gc3RyaWN0bHlcbiAgICAgICAqIG5lY2Vzc2FyeSB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBleGVjdXRpb25zIHJ1bm5pbmcgZm9yIHRoZSBzYW1lXG4gICAgICAgKiBzZWxlY3Rvci4gVGhpcyBtYXkgYmUgYSB2YWxpZCB0cmFkZW9mZiBhcyBjaGVja2luZyBmb3IgZGVwIGNoYW5nZXNcbiAgICAgICAqIGFjcm9zcyBhbGwgaW4tcHJvZ3Jlc3MgZXhlY3V0aW9ucyBtYXkgdGFrZSBsb25nZXIgdGhhbiBqdXN0XG4gICAgICAgKiByZS1ydW5uaW5nIHRoZSBzZWxlY3Rvci4gVGhpcyB3aWxsIGJlIGFwcC1kZXBlbmRlbnQsIGFuZCBtYXliZSBpbiB0aGVcbiAgICAgICAqIGZ1dHVyZSB3ZSBjYW4gbWFrZSB0aGUgYmVoYXZpb3IgY29uZmlndXJhYmxlLiBBbiBpZGVhbCBmaXggbWF5IGJlXG4gICAgICAgKiB0byBleHRlbmQgdGhlIHRyZWUgY2FjaGUgdG8gc3VwcG9ydCBjYWNoaW5nIGxvYWRpbmcgc3RhdGVzLlxuICAgICAgICovXG5cblxuICAgICAgaWYgKCFpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpKSB7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvbkluZm8gPSBnZXRJblByb2dyZXNzRXhlY3V0aW9uSW5mbyhzdG9yZSwgc3RhdGUpO1xuXG4gICAgICAgIGlmIChleGVjdXRpb25JbmZvICE9IG51bGwpIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBSZXR1cm5pbmcgcHJvbWlzZSBoZXJlIHdpdGhvdXQgd3JhcHBpbmcgYXMgdGhlIHdyYXBwZXIgbG9naWMgd2FzXG4gICAgICAgICAgICogYWxyZWFkeSBkb25lIHVwc3RyZWFtIHdoZW4gdGhpcyBwcm9taXNlIHdhcyBnZW5lcmF0ZWQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgcmV0dXJuIGV4ZWN1dGlvbkluZm8ubG9hZGluZ0xvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJldHJ5IHRoZSBzZWxlY3RvciBldmFsdWF0aW9uIG5vdyB0aGF0IHRoZSBkZXBlbmRlbmN5IGhhcyByZXNvbHZlZFxuXG5cbiAgICAgIGNvbnN0IFtsb2FkYWJsZSwgZGVwVmFsdWVzXSA9IGV2YWx1YXRlU2VsZWN0b3JHZXR0ZXIoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCk7XG5cbiAgICAgIGlmIChsb2FkYWJsZS5zdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIHJlc29sdmVBc3luYyhzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklELCBsb2FkYWJsZSwgZGVwVmFsdWVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzRXJyb3InKSB7XG4gICAgICAgIHRocm93IGxvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9hZGFibGUuY29udGVudHM7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgLy8gVGhlIHNlbGVjdG9yIHdhcyByZWxlYXNlZCBzaW5jZSB0aGUgcmVxdWVzdCBiZWdhbjsgaWdub3JlIHRoZSByZXNwb25zZS5cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENhbmNlbGVkKSB7XG4gICAgICAgIHRocm93IENBTkNFTEVEO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGVjdG9ySXNMaXZlKCkpIHtcbiAgICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcbiAgICAgICAgdGhyb3cgQ0FOQ0VMRUQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvYWRhYmxlID0gbG9hZGFibGVXaXRoRXJyb3IkMShlcnJvcik7XG4gICAgICByZXNvbHZlQXN5bmMoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCwgbG9hZGFibGUsIGV4aXN0aW5nRGVwcyk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlLCBkZXBzLCBleGVjdXRpb25JRCkge1xuICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUsIF9zdG9yZSRnZXRTdGF0ZSRjdXJyZSwgX3N0b3JlJGdldFN0YXRlMiwgX3N0b3JlJGdldFN0YXRlMiRuZXh0O1xuXG4gICAgaWYgKGlzTGF0ZXN0RXhlY3V0aW9uKHN0b3JlLCBleGVjdXRpb25JRCkgfHwgc3RhdGUudmVyc2lvbiA9PT0gKChfc3RvcmUkZ2V0U3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc3RvcmUkZ2V0U3RhdGUkY3VycmUgPSBfc3RvcmUkZ2V0U3RhdGUuY3VycmVudFRyZWUpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZSRjdXJyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlJGdldFN0YXRlJGN1cnJlLnZlcnNpb24pIHx8IHN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlJGdldFN0YXRlMiA9IHN0b3JlLmdldFN0YXRlKCkpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc3RvcmUkZ2V0U3RhdGUyJG5leHQgPSBfc3RvcmUkZ2V0U3RhdGUyLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUyJG5leHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZSRnZXRTdGF0ZTIkbmV4dC52ZXJzaW9uKSkge1xuICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCwgX3N0b3JlJGdldFN0YXRlMywgX3N0b3JlJGdldFN0YXRlMyRuZXh0O1xuXG4gICAgICBzYXZlRGVwc1RvU3RvcmUkMShrZXksIGRlcHMsIHN0b3JlLCAoX3N0b3JlJGdldFN0YXRlJG5leHRUID0gKF9zdG9yZSRnZXRTdGF0ZTMgPSBzdG9yZS5nZXRTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3N0b3JlJGdldFN0YXRlMyRuZXh0ID0gX3N0b3JlJGdldFN0YXRlMy5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlMyRuZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUzJG5leHQudmVyc2lvbikgIT09IG51bGwgJiYgX3N0b3JlJGdldFN0YXRlJG5leHRUICE9PSB2b2lkIDAgPyBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgOiBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLnZlcnNpb24pO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qgbm9kZUtleSBvZiBkZXBzKSB7XG4gICAgICBkaXNjb3ZlcmVkRGVwZW5kZW5jeU5vZGVLZXlzLmFkZChub2RlS2V5KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBldmFsdWF0ZVNlbGVjdG9yR2V0dGVyKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQpIHtcbiAgICBjb25zdCBlbmRQZXJmQmxvY2sgPSBzdGFydFBlcmZCbG9jayQxKGtleSk7IC8vIFRPRE8gVDYzOTY1ODY2OiB1c2UgZXhlY3V0aW9uIElEIGhlcmVcblxuICAgIGxldCBkdXJpbmdTeW5jaHJvbm91c0V4ZWN1dGlvbiA9IHRydWU7XG4gICAgbGV0IGR1cmluZ0FzeW5jaHJvbm91c0V4ZWN1dGlvbiA9IHRydWU7XG5cbiAgICBjb25zdCBmaW5pc2hFdmFsdWF0aW9uID0gKCkgPT4ge1xuICAgICAgZW5kUGVyZkJsb2NrKCk7XG4gICAgICBkdXJpbmdBc3luY2hyb25vdXNFeGVjdXRpb24gPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgcmVzdWx0SXNFcnJvciA9IGZhbHNlO1xuICAgIGxldCBsb2FkYWJsZTtcbiAgICBjb25zdCBsb2FkaW5nRGVwc1N0YXRlID0ge1xuICAgICAgbG9hZGluZ0RlcEtleTogbnVsbCxcbiAgICAgIGxvYWRpbmdEZXBQcm9taXNlOiBudWxsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydGluZyBhIGZyZXNoIHNldCBvZiBkZXBzIHRoYXQgd2UnbGwgYmUgdXNpbmcgdG8gdXBkYXRlIHN0YXRlLiBXZSdyZVxuICAgICAqIHN0YXJ0aW5nIGEgbmV3IHNldCB2ZXJzdXMgYWRkaW5nIGl0IGluIGV4aXN0aW5nIHN0YXRlIGRlcHMgYmVjYXVzZVxuICAgICAqIHRoZSB2ZXJzaW9uIG9mIHN0YXRlIHRoYXQgd2UgdXBkYXRlIGRlcHMgZm9yIG1heSBiZSBhIG1vcmUgcmVjZW50IHZlcnNpb25cbiAgICAgKiB0aGFuIHRoZSB2ZXJzaW9uIHRoZSBzZWxlY3RvciB3YXMgY2FsbGVkIHdpdGguIFRoaXMgaXMgYmVjYXVzZSB0aGUgbGF0ZXN0XG4gICAgICogZXhlY3V0aW9uIHdpbGwgdXBkYXRlIHRoZSBkZXBzIG9mIHRoZSBjdXJyZW50L2xhdGVzdCB2ZXJzaW9uIG9mIHN0YXRlXG4gICAgICogKFRoaXMgaXMgc2FmZSB0byBkbyBiZWNhdXNlIHRoZSBmYWN0IHRoYXQgdGhlIHNlbGVjdG9yIGlzIHRoZSBsYXRlc3RcbiAgICAgKiBleGVjdXRpb24gbWVhbnMgdGhlIGRlcHMgd2UgZGlzY292ZXIgYmVsb3cgYXJlIG91ciBiZXN0IGd1ZXNzIGF0IHRoZVxuICAgICAqIGRlcHMgZm9yIHRoZSBjdXJyZW50L2xhdGVzdCBzdGF0ZSBpbiB0aGUgc3RvcmUpXG4gICAgICovXG5cbiAgICBjb25zdCBkZXBWYWx1ZXMgPSBuZXcgTWFwKCk7XG5cbiAgICBmdW5jdGlvbiBnZXRSZWNvaWxWYWx1ZSh7XG4gICAgICBrZXk6IGRlcEtleVxuICAgIH0pIHtcbiAgICAgIGNvbnN0IGRlcExvYWRhYmxlID0gZ2V0Tm9kZUxvYWRhYmxlJDIoc3RvcmUsIHN0YXRlLCBkZXBLZXkpO1xuICAgICAgZGVwVmFsdWVzLnNldChkZXBLZXksIGRlcExvYWRhYmxlKTsgLy8gV2UgbmVlZCB0byB1cGRhdGUgYXN5bmNocm9ub3VzIGRlcGVuZGVuY2llcyBhcyB3ZSBnbyBzbyB0aGUgc2VsZWN0b3JcbiAgICAgIC8vIGtub3dzIGlmIGl0IGhhcyB0byByZXN0YXJ0IGV2YWx1YXRpb24gaWYgb25lIG9mIHRoZW0gaXMgdXBkYXRlZCBiZWZvcmVcbiAgICAgIC8vIHRoZSBhc3luY2hyb25vdXMgc2VsZWN0b3IgY29tcGxldGVseSByZXNvbHZlcy5cblxuICAgICAgaWYgKCFkdXJpbmdTeW5jaHJvbm91c0V4ZWN1dGlvbikge1xuICAgICAgICB1cGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSwgbmV3IFNldChkZXBWYWx1ZXMua2V5cygpKSwgZXhlY3V0aW9uSUQpO1xuICAgICAgICBub3RpZnlTdG9yZXNPZk5ld0FzeW5jRGVwKHN0b3JlLCBleGVjdXRpb25JRCk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZGVwTG9hZGFibGUuc3RhdGUpIHtcbiAgICAgICAgY2FzZSAnaGFzVmFsdWUnOlxuICAgICAgICAgIHJldHVybiBkZXBMb2FkYWJsZS5jb250ZW50cztcblxuICAgICAgICBjYXNlICdoYXNFcnJvcic6XG4gICAgICAgICAgdGhyb3cgZGVwTG9hZGFibGUuY29udGVudHM7XG5cbiAgICAgICAgY2FzZSAnbG9hZGluZyc6XG4gICAgICAgICAgbG9hZGluZ0RlcHNTdGF0ZS5sb2FkaW5nRGVwS2V5ID0gZGVwS2V5O1xuICAgICAgICAgIGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcFByb21pc2UgPSBkZXBMb2FkYWJsZS5jb250ZW50cztcbiAgICAgICAgICB0aHJvdyBkZXBMb2FkYWJsZS5jb250ZW50cztcbiAgICAgIH1cblxuICAgICAgdGhyb3cgUmVjb2lsX2VycignSW52YWxpZCBMb2FkYWJsZSBzdGF0ZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGdldENhbGxiYWNrID0gZm4gPT4ge1xuICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChkdXJpbmdBc3luY2hyb25vdXNFeGVjdXRpb24pIHtcbiAgICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdDYWxsYmFja3MgZnJvbSBnZXRDYWxsYmFjaygpIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBhc3luY2hyb25vdXNseSBhZnRlciB0aGUgc2VsZWN0b3IgaXMgZXZhbHV0YXRlZC4gIEl0IGNhbiBiZSB1c2VkIGZvciBzZWxlY3RvcnMgdG8gcmV0dXJuIG9iamVjdHMgd2l0aCBjYWxsYmFja3MgdGhhdCBjYW4gd29yayB3aXRoIFJlY29pbCBzdGF0ZSB3aXRob3V0IGEgc3Vic2NyaXB0aW9uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgIShyZWNvaWxWYWx1ZSAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UsICdSZWNvaWwgVmFsdWUgY2FuIG5ldmVyIGJlIG51bGwnKSA6IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgICByZXR1cm4gcmVjb2lsQ2FsbGJhY2skMShzdG9yZSwgZm4sIGFyZ3MsIHtcbiAgICAgICAgICBub2RlOiByZWNvaWxWYWx1ZVxuICAgICAgICB9IC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGdldCh7XG4gICAgICAgIGdldDogZ2V0UmVjb2lsVmFsdWUsXG4gICAgICAgIGdldENhbGxiYWNrXG4gICAgICB9KTtcbiAgICAgIHJlc3VsdCA9IGlzUmVjb2lsVmFsdWUkMyhyZXN1bHQpID8gZ2V0UmVjb2lsVmFsdWUocmVzdWx0KSA6IHJlc3VsdDtcblxuICAgICAgaWYgKGlzTG9hZGFibGUkMShyZXN1bHQpKSB7XG4gICAgICAgIGlmIChyZXN1bHQuc3RhdGUgPT09ICdoYXNFcnJvcicpIHtcbiAgICAgICAgICByZXN1bHRJc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb250ZW50cztcbiAgICAgIH1cblxuICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQgPSB3cmFwUmVzdWx0UHJvbWlzZShzdG9yZSwgcmVzdWx0LCBzdGF0ZSwgZGVwVmFsdWVzLCBleGVjdXRpb25JRCwgbG9hZGluZ0RlcHNTdGF0ZSkuZmluYWxseShmaW5pc2hFdmFsdWF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmlzaEV2YWx1YXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gcmVzdWx0IGluc3RhbmNlb2YgV3JhcHBlZFZhbHVlJDEgPyByZXN1bHQudmFsdWUgOiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3JPckRlcFByb21pc2UpIHtcbiAgICAgIHJlc3VsdCA9IGVycm9yT3JEZXBQcm9taXNlO1xuXG4gICAgICBpZiAoUmVjb2lsX2lzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdCA9IHdyYXBQZW5kaW5nRGVwZW5kZW5jeVByb21pc2Uoc3RvcmUsIHJlc3VsdCwgc3RhdGUsIGRlcFZhbHVlcywgZXhlY3V0aW9uSUQsIGxvYWRpbmdEZXBzU3RhdGUpLmZpbmFsbHkoZmluaXNoRXZhbHVhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRJc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgZmluaXNoRXZhbHVhdGlvbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXN1bHRJc0Vycm9yKSB7XG4gICAgICBsb2FkYWJsZSA9IGxvYWRhYmxlV2l0aEVycm9yJDEocmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKFJlY29pbF9pc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgbG9hZGFibGUgPSBsb2FkYWJsZVdpdGhQcm9taXNlJDEocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZGFibGUgPSBsb2FkYWJsZVdpdGhWYWx1ZSQyKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgZHVyaW5nU3luY2hyb25vdXNFeGVjdXRpb24gPSBmYWxzZTtcbiAgICB1cGRhdGVFeGVjdXRpb25JbmZvRGVwVmFsdWVzKHN0b3JlLCBleGVjdXRpb25JRCwgZGVwVmFsdWVzKTtcbiAgICB1cGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSwgbmV3IFNldChkZXBWYWx1ZXMua2V5cygpKSwgZXhlY3V0aW9uSUQpO1xuICAgIHJldHVybiBbbG9hZGFibGUsIGRlcFZhbHVlc107XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMb2FkYWJsZUZyb21DYWNoZUFuZFVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlKSB7XG4gICAgLy8gRmlyc3QsIGxvb2sgdXAgaW4gdGhlIHN0YXRlIGNhY2hlXG4gICAgLy8gSWYgaXQncyBoZXJlLCB0aGVuIHRoZSBkZXBzIGluIHRoZSBzdG9yZSBzaG91bGQgYWxyZWFkeSBiZSB2YWxpZC5cbiAgICBsZXQgY2FjaGVkTG9hZGFibGUgPSBzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpO1xuXG4gICAgaWYgKGNhY2hlZExvYWRhYmxlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZWRMb2FkYWJsZTtcbiAgICB9IC8vIFNlY29uZCwgbG9vayB1cCBpbiB0aGUgc2VsZWN0b3IgY2FjaGUgYW5kIHVwZGF0ZSB0aGUgZGVwcyBpbiB0aGUgc3RvcmVcblxuXG4gICAgY29uc3QgZGVwc0FmdGVyQ2FjaGVMb29rdXAgPSBuZXcgU2V0KCk7XG5cbiAgICB0cnkge1xuICAgICAgY2FjaGVkTG9hZGFibGUgPSBjYWNoZS5nZXQobm9kZUtleSA9PiB7XG4gICAgICAgICEodHlwZW9mIG5vZGVLZXkgPT09ICdzdHJpbmcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UsICdDYWNoZSBub2RlS2V5IGlzIHR5cGUgc3RyaW5nJykgOiBSZWNvaWxfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIGdldE5vZGVMb2FkYWJsZSQyKHN0b3JlLCBzdGF0ZSwgbm9kZUtleSkuY29udGVudHM7XG4gICAgICB9LCB7XG4gICAgICAgIG9uTm9kZVZpc2l0OiBub2RlID0+IHtcbiAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnYnJhbmNoJyAmJiBub2RlLm5vZGVLZXkgIT09IGtleSkge1xuICAgICAgICAgICAgZGVwc0FmdGVyQ2FjaGVMb29rdXAuYWRkKG5vZGUubm9kZUtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycihgUHJvYmxlbSB3aXRoIGNhY2hlIGxvb2t1cCBmb3Igc2VsZWN0b3IgXCIke2tleX1cIjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cblxuICAgIGlmIChjYWNoZWRMb2FkYWJsZSkge1xuICAgICAgdmFyIF9nZXRFeGVjdXRpb25JbmZvO1xuXG4gICAgICAvLyBDYWNoZSB0aGUgcmVzdWx0cyBpbiB0aGUgc3RhdGUgdG8gYWxsb3cgZm9yIGNoZWFwZXIgbG9va3VwIHRoYW5cbiAgICAgIC8vIGl0ZXJhdGluZyB0aGUgdHJlZSBjYWNoZSBvZiBkZXBlbmRlbmNpZXMuXG4gICAgICBzdGF0ZS5hdG9tVmFsdWVzLnNldChrZXksIGNhY2hlZExvYWRhYmxlKTtcbiAgICAgIC8qKlxuICAgICAgICogRW5zdXJlIHN0b3JlIGNvbnRhaW5zIGNvcnJlY3QgZGVwZW5kZW5jaWVzIGlmIHdlIGhpdCB0aGUgY2FjaGUgc28gdGhhdFxuICAgICAgICogdGhlIHN0b3JlIGRlcHMgYW5kIGNhY2hlIGFyZSBpbiBzeW5jIGZvciBhIGdpdmVuIHN0YXRlLiBUaGlzIGlzIGltcG9ydGFudFxuICAgICAgICogYmVjYXVzZSBzdG9yZSBkZXBzIGFyZSBub3JtYWxseSB1cGRhdGVkIHdoZW4gbmV3IGV4ZWN1dGlvbnMgYXJlIGNyZWF0ZWQsXG4gICAgICAgKiBidXQgY2FjaGUgaGl0cyBkb24ndCB0cmlnZ2VyIG5ldyBleGVjdXRpb25zIGJ1dCB0aGV5IHN0aWxsIF9tYXlfIHNpZ25pZnlcbiAgICAgICAqIGEgY2hhbmdlIGluIGRlcHMgaW4gdGhlIHN0b3JlIGlmIHRoZSBzdG9yZSBkZXBzIGZvciB0aGlzIHN0YXRlIGFyZSBlbXB0eVxuICAgICAgICogb3Igc3RhbGUuXG4gICAgICAgKi9cblxuICAgICAgdXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUsIGRlcHNBZnRlckNhY2hlTG9va3VwLCAoX2dldEV4ZWN1dGlvbkluZm8gPSBnZXRFeGVjdXRpb25JbmZvKHN0b3JlKSkgPT09IG51bGwgfHwgX2dldEV4ZWN1dGlvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRFeGVjdXRpb25JbmZvLmV4ZWN1dGlvbklEKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVkTG9hZGFibGU7XG4gIH1cbiAgLyoqXG4gICAqIEdpdmVuIGEgdHJlZSBzdGF0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgTG9hZGFibGUgb2YgdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqXG4gICAqIFRoZSBzZWxlY3RvcidzIGdldCgpIGZ1bmN0aW9uIHdpbGwgb25seSBiZSByZS1ldmFsdWF0ZWQgaWYgX2JvdGhfIG9mIHRoZVxuICAgKiBmb2xsb3dpbmcgc3RhdGVtZW50cyBhcmUgdHJ1ZTpcbiAgICpcbiAgICogMS4gVGhlIGN1cnJlbnQgZGVwIHZhbHVlcyBmcm9tIHRoZSBnaXZlbiBzdGF0ZSBwcm9kdWNlZCBhIGNhY2hlIGtleSB0aGF0XG4gICAqICAgIHdhcyBub3QgZm91bmQgaW4gdGhlIGNhY2hlLlxuICAgKiAyLiBUaGVyZSBpcyBubyBjdXJyZW50bHkgcnVubmluZyBhc3luYyBleGVjdXRpb24gT1IgdGhlcmUgaXMgYW5cbiAgICogICAgYXN5bmMgZXhlY3V0aW9uIHRoYXQgaXMgcnVubmluZywgYnV0IGFmdGVyIGNvbXBhcmluZyB0aGUgZGVwIHZhbHVlcyBpblxuICAgKiAgICB0aGUgZ2l2ZW4gc3RhdGUgd2l0aCB0aGUgZGVwIHZhbHVlcyB0aGF0IHRoZSBleGVjdXRpb24gaGFzIGRpc2NvdmVyZWQgc29cbiAgICogICAgZmFyIHdlIGZpbmQgdGhhdCBhdCBsZWFzdCBvbmUgZGVwIHZhbHVlIGhhcyBjaGFuZ2VkLCBpbiB3aGljaCBjYXNlIHdlXG4gICAqICAgIHN0YXJ0IGEgbmV3IGV4ZWN1dGlvbiAodGhlIHByZXZpb3VzbHkgcnVubmluZyBleGVjdXRpb24gd2lsbCBjb250aW51ZSB0b1xuICAgKiAgICBydW4gdG8gY29tcGxldGlvbiwgYnV0IG9ubHkgdGhlIG5ldyBleGVjdXRpb24gd2lsbCBiZSBkZWVtZWQgdGhlXG4gICAqICAgICdsYXRlc3QnIGV4ZWN1dGlvbiwgbWVhbmluZyBpdCB3aWxsIGJlIHRoZSBvbmx5IGV4ZWN1dGlvbiB0aGF0IHdpbGxcbiAgICogICAgdXBkYXRlIGdsb2JhbCBzdGF0ZSB3aGVuIGl0IGlzIGZpbmlzaGVkLiBBbnkgbm9uLWxhdGVzdCBleGVjdXRpb25zIHdpbGxcbiAgICogICAgcnVuIHRvIGNvbXBsZXRpb24gYW5kIHVwZGF0ZSB0aGUgc2VsZWN0b3IgY2FjaGUgYnV0IG5vdCBnbG9iYWwgc3RhdGUpLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9yTG9hZGFibGVBbmRVcGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSkge1xuICAgIC8vIEZpcnN0LCBzZWUgaWYgb3VyIGN1cnJlbnQgc3RhdGUgaXMgY2FjaGVkXG4gICAgY29uc3QgY2FjaGVkVmFsID0gZ2V0TG9hZGFibGVGcm9tQ2FjaGVBbmRVcGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSk7XG5cbiAgICBpZiAoY2FjaGVkVmFsICE9IG51bGwpIHtcbiAgICAgIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSk7XG4gICAgICByZXR1cm4gY2FjaGVkVmFsO1xuICAgIH0gLy8gU2Vjb25kLCBjaGVjayBpZiB0aGVyZSBpcyBhbHJlYWR5IGFuIG9uZ29pbmcgZXhlY3V0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlXG5cblxuICAgIGNvbnN0IGluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvID0gZ2V0SW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8oc3RvcmUsIHN0YXRlKTtcblxuICAgIGlmIChpblByb2dyZXNzRXhlY3V0aW9uSW5mbyAhPSBudWxsKSB7XG4gICAgICB2YXIgX2luUHJvZ3Jlc3NFeGVjdXRpb25JO1xuXG4gICAgICBpZiAoKChfaW5Qcm9ncmVzc0V4ZWN1dGlvbkkgPSBpblByb2dyZXNzRXhlY3V0aW9uSW5mby5sb2FkaW5nTG9hZGFibGUpID09PSBudWxsIHx8IF9pblByb2dyZXNzRXhlY3V0aW9uSSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2luUHJvZ3Jlc3NFeGVjdXRpb25JLnN0YXRlKSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIG1hcmtTdG9yZVdhaXRpbmdGb3JSZXNvbHZlZEFzeW5jKHN0b3JlLCBpblByb2dyZXNzRXhlY3V0aW9uSW5mby5leGVjdXRpb25JRCk7XG4gICAgICB9IC8vIEZJWE1FOiBjaGVjayBhZnRlciB0aGUgZmFjdCB0byBzZWUgaWYgd2UgbWFkZSB0aGUgcmlnaHQgY2hvaWNlIGJ5IHdhaXRpbmdcblxuXG4gICAgICByZXR1cm4gaW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8ubG9hZGluZ0xvYWRhYmxlO1xuICAgIH0gLy8gVGhpcmQsIHN0YXJ0IGEgbmV3IGV2YWx1YXRpb24gb2YgdGhlIHNlbGVjdG9yXG5cblxuICAgIGNvbnN0IG5ld0V4ZWN1dGlvbklEID0gZ2V0TmV3RXhlY3V0aW9uSUQoKTtcbiAgICBjb25zdCBbbG9hZGFibGUsIG5ld0RlcFZhbHVlc10gPSBldmFsdWF0ZVNlbGVjdG9yR2V0dGVyKHN0b3JlLCBzdGF0ZSwgbmV3RXhlY3V0aW9uSUQpO1xuICAgIC8qKlxuICAgICAqIENvbmRpdGlvbmFsbHkgdXBkYXRlcyB0aGUgY2FjaGUgd2l0aCBhIGdpdmVuIGxvYWRhYmxlLlxuICAgICAqXG4gICAgICogV2Ugb25seSBjYWNoZSBsb2FkYWJsZXMgdGhhdCBhcmUgbm90IGxvYWRpbmcgYmVjYXVzZSBvdXIgY2FjaGUga2V5cyBhcmVcbiAgICAgKiBiYXNlZCBvbiBkZXAgdmFsdWVzLCB3aGljaCBhcmUgaW4gYW4gdW5maW5pc2hlZCBzdGF0ZSBmb3IgbG9hZGFibGVzIHRoYXRcbiAgICAgKiBoYXZlIGEgJ2xvYWRpbmcnIHN0YXRlIChuZXcgZGVwcyBtYXkgYmUgZGlzY292ZXJlZCB3aGlsZSB0aGUgc2VsZWN0b3JcbiAgICAgKiBydW5zIGl0cyBhc3luYyBjb2RlKS4gV2UgbmV2ZXIgd2FudCB0byBjYWNoZSBwYXJ0aWFsIGRlcGVuZGVuY2llcyBiL2MgaXRcbiAgICAgKiBjb3VsZCBsZWFkIHRvIGVycm9ycywgc3VjaCBhcyBwcmVtYXR1cmVseSByZXR1cm5pbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiBhXG4gICAgICogcGFydGlhbCBsaXN0IG9mIGRlcHMtLSB3ZSBuZWVkIHRoZSBmdWxsIGxpc3Qgb2YgZGVwcyB0byBlbnN1cmUgdGhhdCB3ZVxuICAgICAqIGFyZSByZXR1cm5pbmcgdGhlIGNvcnJlY3QgcmVzdWx0IGZyb20gY2FjaGUuXG4gICAgICovXG5cbiAgICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgc2V0RXhlY3V0aW9uSW5mbyhzdG9yZSwgbmV3RXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBuZXdEZXBWYWx1ZXMsIHN0YXRlKTtcbiAgICAgIG1hcmtTdG9yZVdhaXRpbmdGb3JSZXNvbHZlZEFzeW5jKHN0b3JlLCBuZXdFeGVjdXRpb25JRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSk7XG4gICAgICBzZXRDYWNoZShzdGF0ZSwgbG9hZGFibGUsIG5ld0RlcFZhbHVlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvYWRhYmxlO1xuICB9XG4gIC8qKlxuICAgKiBTZWFyY2hlcyBleGVjdXRpb24gaW5mbyBhY3Jvc3MgYWxsIHN0b3JlcyB0byBzZWUgaWYgdGhlcmUgaXMgYW4gaW4tcHJvZ3Jlc3NcbiAgICogZXhlY3V0aW9uIHdob3NlIGRlcGVuZGVuY3kgdmFsdWVzIG1hdGNoIHRoZSB2YWx1ZXMgb2YgdGhlIHJlcXVlc3Rpbmcgc3RvcmUuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0SW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8oc3RvcmUsIHN0YXRlKSB7XG4gICAgLy8gU29ydCB0aGUgcGVuZGluZyBleGVjdXRpb25zIHNvIHRoYXQgb3VyIGN1cnJlbnQgc3RvcmUgaXMgY2hlY2tlZCBmaXJzdC5cbiAgICBjb25zdCBwZW5kaW5nRXhlY3V0aW9ucyA9IFJlY29pbF9jb25jYXRJdGVyYWJsZXMoW2V4ZWN1dGlvbkluZm9NYXAuaGFzKHN0b3JlKSA/IFtSZWNvaWxfbnVsbHRocm93cyhleGVjdXRpb25JbmZvTWFwLmdldChzdG9yZSkpXSA6IFtdLCBSZWNvaWxfbWFwSXRlcmFibGUoUmVjb2lsX2ZpbHRlckl0ZXJhYmxlKGV4ZWN1dGlvbkluZm9NYXAsIChbc10pID0+IHMgIT09IHN0b3JlKSwgKFssIGV4ZWNJbmZvXSkgPT4gZXhlY0luZm8pXSk7XG5cbiAgICBmdW5jdGlvbiBhbnlEZXBDaGFuZ2VkKGV4ZWNEZXBWYWx1ZXMpIHtcbiAgICAgIGZvciAoY29uc3QgW2RlcEtleSwgZXhlY0xvYWRhYmxlXSBvZiBleGVjRGVwVmFsdWVzKSB7XG4gICAgICAgIGlmICghZ2V0Tm9kZUxvYWRhYmxlJDIoc3RvcmUsIHN0YXRlLCBkZXBLZXkpLmlzKGV4ZWNMb2FkYWJsZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBleGVjSW5mbyBvZiBwZW5kaW5nRXhlY3V0aW9ucykge1xuICAgICAgaWYgKCAvLyBJZiB0aGlzIGV4ZWN1dGlvbiB3YXMgYWxyZWFkeSBjaGVja2VkIHRvIGJlIHZhbGlkIHdpdGggdGhpcyB2ZXJzaW9uXG4gICAgICAvLyBvZiBzdGF0ZSwgdGhlbiBsZXQncyB1c2UgaXQhXG4gICAgICBleGVjSW5mby5zdGF0ZVZlcnNpb25zLmdldChzdGF0ZS52ZXJzaW9uKSB8fCAvLyBJZiB0aGUgZGVwcyBmb3IgdGhlIGV4ZWN1dGlvbiBtYXRjaCBvdXIgY3VycmVudCBzdGF0ZSwgdGhlbiBpdCdzIHZhbGlkXG4gICAgICAhYW55RGVwQ2hhbmdlZChleGVjSW5mby5kZXBWYWx1ZXNEaXNjb3ZlcmVkU29GYXJEdXJpbmdBc3luY1dvcmspKSB7XG4gICAgICAgIGV4ZWNJbmZvLnN0YXRlVmVyc2lvbnMuc2V0KHN0YXRlLnZlcnNpb24sIHRydWUpO1xuICAgICAgICByZXR1cm4gZXhlY0luZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGVjSW5mby5zdGF0ZVZlcnNpb25zLnNldChzdGF0ZS52ZXJzaW9uLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEV4ZWN1dGlvbkluZm8oc3RvcmUpIHtcbiAgICByZXR1cm4gZXhlY3V0aW9uSW5mb01hcC5nZXQoc3RvcmUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdXBkYXRlIHRoZSBzZWxlY3RvcidzIGV4ZWN1dGlvbiBpbmZvIHdoZW4gdGhlIHNlbGVjdG9yXG4gICAqIGhhcyBlaXRoZXIgZmluaXNoZWQgcnVubmluZyBhbiBleGVjdXRpb24gb3IgaGFzIHN0YXJ0ZWQgYSBuZXcgZXhlY3V0aW9uLiBJZlxuICAgKiB0aGUgZ2l2ZW4gbG9hZGFibGUgaXMgaW4gYSAnbG9hZGluZycgc3RhdGUsIHRoZSBpbnRlbnRpb24gaXMgdGhhdCBhIG5ld1xuICAgKiBleGVjdXRpb24gaGFzIHN0YXJ0ZWQuIE90aGVyd2lzZSwgdGhlIGludGVudGlvbiBpcyB0aGF0IGFuIGV4ZWN1dGlvbiBoYXNcbiAgICoganVzdCBmaW5pc2hlZC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBzZXRFeGVjdXRpb25JbmZvKHN0b3JlLCBuZXdFeGVjdXRpb25JRCwgbG9hZGFibGUsIGRlcFZhbHVlcywgc3RhdGUpIHtcbiAgICBleGVjdXRpb25JbmZvTWFwLnNldChzdG9yZSwge1xuICAgICAgZGVwVmFsdWVzRGlzY292ZXJlZFNvRmFyRHVyaW5nQXN5bmNXb3JrOiBkZXBWYWx1ZXMsXG4gICAgICBleGVjdXRpb25JRDogbmV3RXhlY3V0aW9uSUQsXG4gICAgICBsb2FkaW5nTG9hZGFibGU6IGxvYWRhYmxlLFxuICAgICAgc3RhdGVWZXJzaW9uczogbmV3IE1hcChbW3N0YXRlLnZlcnNpb24sIHRydWVdXSlcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUV4ZWN1dGlvbkluZm9EZXBWYWx1ZXMoc3RvcmUsIGV4ZWN1dGlvbklELCBkZXBWYWx1ZXMpIHtcbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gYm90aGVyIHVwZGF0aW5nIHRoZSBkZXBzIGZvciB0aGUgbGF0ZXN0IGV4ZWN1dGlvbiBiZWNhdXNlXG4gICAgLy8gdGhhdCdzIGFsbCBnZXRJblByb2dyZXNzRXhlY3V0aW9uSW5mbygpIHdpbGwgYmUgbG9va2luZyBmb3IuXG4gICAgaWYgKGlzTGF0ZXN0RXhlY3V0aW9uKHN0b3JlLCBleGVjdXRpb25JRCkpIHtcbiAgICAgIGNvbnN0IGV4ZWN1dGlvbkluZm8gPSBnZXRFeGVjdXRpb25JbmZvKHN0b3JlKTtcblxuICAgICAgaWYgKGV4ZWN1dGlvbkluZm8gIT0gbnVsbCkge1xuICAgICAgICBleGVjdXRpb25JbmZvLmRlcFZhbHVlc0Rpc2NvdmVyZWRTb0ZhckR1cmluZ0FzeW5jV29yayA9IGRlcFZhbHVlcztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpIHtcbiAgICBleGVjdXRpb25JbmZvTWFwLmRlbGV0ZShzdG9yZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpIHtcbiAgICB2YXIgX2dldEV4ZWN1dGlvbkluZm8yO1xuXG4gICAgcmV0dXJuIGV4ZWN1dGlvbklEID09PSAoKF9nZXRFeGVjdXRpb25JbmZvMiA9IGdldEV4ZWN1dGlvbkluZm8oc3RvcmUpKSA9PT0gbnVsbCB8fCBfZ2V0RXhlY3V0aW9uSW5mbzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRFeGVjdXRpb25JbmZvMi5leGVjdXRpb25JRCk7XG4gIH1cbiAgLyoqXG4gICAqIEZJWE1FOiBkZXAga2V5cyBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgdGhlIHN0YXRlIG9mIHRoZSBsb2FkYWJsZSB0b1xuICAgKiBwcmV2ZW50IHRoZSBlZGdlIGNhc2Ugd2hlcmUgYSBsb2FkYWJsZSB3aXRoIGFuIGVycm9yIGFuZCBhIGxvYWRhYmxlIHdpdGhcbiAgICogYW4gZXJyb3IgYXMgYSB2YWx1ZSBhcmUgdHJlYXRlZCBhcyB0aGUgc2FtZSB0aGluZyBpbmNvcnJlY3RseS4gRm9yIGV4YW1wbGVcbiAgICogdGhlc2UgdHdvIHNob3VsZCBiZSB0cmVhdGVkIGRpZmZlcmVudGx5OlxuICAgKlxuICAgKiBzZWxlY3Rvcih7a2V5OiAnJywgZ2V0OiAoKSA9PiBuZXcgRXJyb3IoJ2hpJyl9KTtcbiAgICogc2VsZWN0b3Ioe2tleTogJycsIGdldCAoKSA9PiB7dGhyb3cgbmV3IEVycm9yKCdoaScpfX0pO1xuICAgKlxuICAgKiBXaXRoIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gdGhleSBhcmUgdHJlYXRlZCB0aGUgc2FtZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGRlcFZhbHVlc1RvRGVwUm91dGUoZGVwVmFsdWVzKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZGVwVmFsdWVzLmVudHJpZXMoKSkubWFwKChbZGVwS2V5LCB2YWxMb2FkYWJsZV0pID0+IFtkZXBLZXksIHZhbExvYWRhYmxlLmNvbnRlbnRzXSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDYWNoZShzdGF0ZSwgbG9hZGFibGUsIGRlcFZhbHVlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmIChsb2FkYWJsZS5zdGF0ZSAhPT0gJ2xvYWRpbmcnICYmIEJvb2xlYW4ob3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSkgPT09IGZhbHNlKSB7XG4gICAgICAgIFJlY29pbF9kZWVwRnJlZXplVmFsdWUobG9hZGFibGUuY29udGVudHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLmF0b21WYWx1ZXMuc2V0KGtleSwgbG9hZGFibGUpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNhY2hlLnNldChkZXBWYWx1ZXNUb0RlcFJvdXRlKGRlcFZhbHVlcyksIGxvYWRhYmxlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycihgUHJvYmxlbSB3aXRoIHNldHRpbmcgY2FjaGUgZm9yIHNlbGVjdG9yIFwiJHtrZXl9XCI6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRlY3RDaXJjdWxhckRlcGVuZGVuY2llcyhmbikge1xuICAgIGlmIChkZXBlbmRlbmN5U3RhY2suaW5jbHVkZXMoa2V5KSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBSZWNvaWwgc2VsZWN0b3IgaGFzIGNpcmN1bGFyIGRlcGVuZGVuY2llczogJHtkZXBlbmRlbmN5U3RhY2suc2xpY2UoZGVwZW5kZW5jeVN0YWNrLmluZGV4T2Yoa2V5KSkuam9pbignIFxcdTIxOTIgJyl9YDtcbiAgICAgIHJldHVybiBsb2FkYWJsZVdpdGhFcnJvciQxKFJlY29pbF9lcnIobWVzc2FnZSkpO1xuICAgIH1cblxuICAgIGRlcGVuZGVuY3lTdGFjay5wdXNoKGtleSk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRlcGVuZGVuY3lTdGFjay5wb3AoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RvclBlZWsoc3RvcmUsIHN0YXRlKSB7XG4gICAgY29uc3QgY2FjaGVkTG9hZGFibGUgPSBzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpO1xuXG4gICAgaWYgKGNhY2hlZExvYWRhYmxlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZWRMb2FkYWJsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGUuZ2V0KG5vZGVLZXkgPT4ge1xuICAgICAgdmFyIF9wZWVrTm9kZUxvYWRhYmxlO1xuXG4gICAgICAhKHR5cGVvZiBub2RlS2V5ID09PSAnc3RyaW5nJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBSZWNvaWxfaW52YXJpYW50KGZhbHNlLCAnQ2FjaGUgbm9kZUtleSBpcyB0eXBlIHN0cmluZycpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gKF9wZWVrTm9kZUxvYWRhYmxlID0gcGVla05vZGVMb2FkYWJsZSQxKHN0b3JlLCBzdGF0ZSwgbm9kZUtleSkpID09PSBudWxsIHx8IF9wZWVrTm9kZUxvYWRhYmxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVla05vZGVMb2FkYWJsZS5jb250ZW50cztcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdG9yR2V0KHN0b3JlLCBzdGF0ZSkge1xuICAgIHJldHVybiBkZXRlY3RDaXJjdWxhckRlcGVuZGVuY2llcygoKSA9PiBnZXRTZWxlY3RvckxvYWRhYmxlQW5kVXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRhdGVTZWxlY3RvcihzdGF0ZSkge1xuICAgIHN0YXRlLmF0b21WYWx1ZXMuZGVsZXRlKGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhclNlbGVjdG9yQ2FjaGUoc3RvcmUsIHRyZWVTdGF0ZSkge1xuICAgICEocmVjb2lsVmFsdWUgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBSZWNvaWxfaW52YXJpYW50KGZhbHNlLCAnUmVjb2lsIFZhbHVlIGNhbiBuZXZlciBiZSBudWxsJykgOiBSZWNvaWxfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGZvciAoY29uc3Qgbm9kZUtleSBvZiBkaXNjb3ZlcmVkRGVwZW5kZW5jeU5vZGVLZXlzKSB7XG4gICAgICB2YXIgX25vZGUkY2xlYXJDYWNoZTtcblxuICAgICAgY29uc3Qgbm9kZSA9IGdldE5vZGUkNihub2RlS2V5KTtcbiAgICAgIChfbm9kZSRjbGVhckNhY2hlID0gbm9kZS5jbGVhckNhY2hlKSA9PT0gbnVsbCB8fCBfbm9kZSRjbGVhckNhY2hlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRjbGVhckNhY2hlLmNhbGwobm9kZSwgc3RvcmUsIHRyZWVTdGF0ZSk7XG4gICAgfVxuXG4gICAgZGlzY292ZXJlZERlcGVuZGVuY3lOb2RlS2V5cy5jbGVhcigpO1xuICAgIGludmFsaWRhdGVTZWxlY3Rvcih0cmVlU3RhdGUpO1xuICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQkMShzdG9yZSwgcmVjb2lsVmFsdWUpO1xuICB9XG5cbiAgaWYgKHNldCAhPSBudWxsKSB7XG4gICAgLyoqXG4gICAgICogRVM1IHN0cmljdCBtb2RlIHByb2hpYml0cyBkZWZpbmluZyBub24tdG9wLWxldmVsIGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyxcbiAgICAgKiBzbyBkb24ndCB1c2UgZnVuY3Rpb24gZGVjbGFyYXRpb24gc3ludGF4IGhlcmVcbiAgICAgKi9cbiAgICBjb25zdCBzZWxlY3RvclNldCA9IChzdG9yZSwgc3RhdGUsIG5ld1ZhbHVlKSA9PiB7XG4gICAgICBsZXQgc3luY1NlbGVjdG9yU2V0RmluaXNoZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHdyaXRlcyA9IG5ldyBNYXAoKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0UmVjb2lsVmFsdWUoe1xuICAgICAgICBrZXk6IGRlcEtleVxuICAgICAgfSkge1xuICAgICAgICBpZiAoc3luY1NlbGVjdG9yU2V0RmluaXNoZWQpIHtcbiAgICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdSZWNvaWw6IEFzeW5jIHNlbGVjdG9yIHNldHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9hZGFibGUgPSBnZXROb2RlTG9hZGFibGUkMihzdG9yZSwgc3RhdGUsIGRlcEtleSk7XG5cbiAgICAgICAgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnKSB7XG4gICAgICAgICAgcmV0dXJuIGxvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICB9IGVsc2UgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBgR2V0dGluZyB2YWx1ZSBvZiBhc3luY2hyb25vdXMgYXRvbSBvciBzZWxlY3RvciBcIiR7ZGVwS2V5fVwiIGluIGEgcGVuZGluZyBzdGF0ZSB3aGlsZSBzZXR0aW5nIHNlbGVjdG9yIFwiJHtrZXl9XCIgaXMgbm90IHlldCBzdXBwb3J0ZWQuYDtcbiAgICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24obXNnKTtcbiAgICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKG1zZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbG9hZGFibGUuY29udGVudHM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUsIHZhbHVlT3JVcGRhdGVyKSB7XG4gICAgICAgIGlmIChzeW5jU2VsZWN0b3JTZXRGaW5pc2hlZCkge1xuICAgICAgICAgIGNvbnN0IG1zZyA9ICdSZWNvaWw6IEFzeW5jIHNlbGVjdG9yIHNldHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLic7XG4gICAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKG1zZyk7XG4gICAgICAgICAgdGhyb3cgUmVjb2lsX2Vycihtc2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2V0VmFsdWUgPSB0eXBlb2YgdmFsdWVPclVwZGF0ZXIgPT09ICdmdW5jdGlvbicgPyAvLyBjYXN0IHRvIGFueSBiZWNhdXNlIHdlIGNhbid0IHJlc3RyaWN0IHR5cGUgUyBmcm9tIGJlaW5nIGEgZnVuY3Rpb24gaXRzZWxmIHdpdGhvdXQgbG9zaW5nIHN1cHBvcnQgZm9yIG9wYXF1ZSB0eXBlc1xuICAgICAgICAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgICB2YWx1ZU9yVXBkYXRlcihnZXRSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSkpIDogdmFsdWVPclVwZGF0ZXI7XG4gICAgICAgIGNvbnN0IHVwc3RyZWFtV3JpdGVzID0gc2V0Tm9kZVZhbHVlJDMoc3RvcmUsIHN0YXRlLCByZWNvaWxTdGF0ZS5rZXksIHNldFZhbHVlKTtcbiAgICAgICAgdXBzdHJlYW1Xcml0ZXMuZm9yRWFjaCgodiwgaykgPT4gd3JpdGVzLnNldChrLCB2KSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlc2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgICAgICAgc2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUsIERFRkFVTFRfVkFMVUUkNik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJldCA9IHNldCh7XG4gICAgICAgIHNldDogc2V0UmVjb2lsU3RhdGUsXG4gICAgICAgIGdldDogZ2V0UmVjb2lsVmFsdWUsXG4gICAgICAgIHJlc2V0OiByZXNldFJlY29pbFN0YXRlXG4gICAgICB9LCBuZXdWYWx1ZSk7IC8vIHNldCBzaG91bGQgYmUgYSB2b2lkIG1ldGhvZCwgYnV0IGlmIHRoZSB1c2VyIG1ha2VzIGl0IGBhc3luY2AsIHRoZW4gaXRcbiAgICAgIC8vIHdpbGwgcmV0dXJuIGEgUHJvbWlzZSwgd2hpY2ggd2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQuXG5cbiAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBSZWNvaWxfaXNQcm9taXNlKHJldCkgPyBSZWNvaWxfZXJyKCdSZWNvaWw6IEFzeW5jIHNlbGVjdG9yIHNldHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLicpIDogUmVjb2lsX2VycignUmVjb2lsOiBzZWxlY3RvciBzZXQgc2hvdWxkIGJlIGEgdm9pZCBmdW5jdGlvbi4nKTtcbiAgICAgIH1cblxuICAgICAgc3luY1NlbGVjdG9yU2V0RmluaXNoZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHdyaXRlcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlY29pbFZhbHVlID0gcmVnaXN0ZXJOb2RlJDEoe1xuICAgICAga2V5LFxuICAgICAgbm9kZVR5cGU6ICdzZWxlY3RvcicsXG4gICAgICBwZWVrOiBzZWxlY3RvclBlZWssXG4gICAgICBnZXQ6IHNlbGVjdG9yR2V0LFxuICAgICAgc2V0OiBzZWxlY3RvclNldCxcbiAgICAgIGluaXQ6IHNlbGVjdG9ySW5pdCxcbiAgICAgIGludmFsaWRhdGU6IGludmFsaWRhdGVTZWxlY3RvcixcbiAgICAgIGNsZWFyQ2FjaGU6IGNsZWFyU2VsZWN0b3JDYWNoZSxcbiAgICAgIHNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZTogc2VsZWN0b3JTaG91bGREZWxldGVDb25maWdPblJlbGVhc2UsXG4gICAgICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSxcbiAgICAgIHNob3VsZFJlc3RvcmVGcm9tU25hcHNob3RzOiBmYWxzZSxcbiAgICAgIHJldGFpbmVkQnlcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVjb2lsVmFsdWUgPSByZWdpc3Rlck5vZGUkMSh7XG4gICAgICBrZXksXG4gICAgICBub2RlVHlwZTogJ3NlbGVjdG9yJyxcbiAgICAgIHBlZWs6IHNlbGVjdG9yUGVlayxcbiAgICAgIGdldDogc2VsZWN0b3JHZXQsXG4gICAgICBpbml0OiBzZWxlY3RvckluaXQsXG4gICAgICBpbnZhbGlkYXRlOiBpbnZhbGlkYXRlU2VsZWN0b3IsXG4gICAgICBjbGVhckNhY2hlOiBjbGVhclNlbGVjdG9yQ2FjaGUsXG4gICAgICBzaG91bGREZWxldGVDb25maWdPblJlbGVhc2U6IHNlbGVjdG9yU2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlLFxuICAgICAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHksXG4gICAgICBzaG91bGRSZXN0b3JlRnJvbVNuYXBzaG90czogZmFsc2UsXG4gICAgICByZXRhaW5lZEJ5XG4gICAgfSk7XG4gIH1cbn1cbi8qIGVzbGludC1lbmFibGUgbm8tcmVkZWNsYXJlICovXG4vLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS11c2VdXG5cblxuc2VsZWN0b3IudmFsdWUgPSB2YWx1ZSA9PiBuZXcgV3JhcHBlZFZhbHVlJDEodmFsdWUpO1xuXG52YXIgUmVjb2lsX3NlbGVjdG9yID0gc2VsZWN0b3I7XG5cbi8vIEBmYi1vbmx5OiBpbXBvcnQgdHlwZSB7U2NvcGVSdWxlc30gZnJvbSAnUmVjb2lsX1Njb3BlZEF0b20nO1xuLy8gQGZiLW9ubHk6IGNvbnN0IHtzY29wZWRBdG9tfSA9IHJlcXVpcmUoJ1JlY29pbF9TY29wZWRBdG9tJyk7XG5jb25zdCB7XG4gIGlzTG9hZGFibGU6IGlzTG9hZGFibGUkMixcbiAgbG9hZGFibGVXaXRoRXJyb3I6IGxvYWRhYmxlV2l0aEVycm9yJDIsXG4gIGxvYWRhYmxlV2l0aFByb21pc2U6IGxvYWRhYmxlV2l0aFByb21pc2UkMixcbiAgbG9hZGFibGVXaXRoVmFsdWU6IGxvYWRhYmxlV2l0aFZhbHVlJDNcbn0gPSBSZWNvaWxfTG9hZGFibGUkMTtcblxuY29uc3Qge1xuICBXcmFwcGVkVmFsdWU6IFdyYXBwZWRWYWx1ZSQyXG59ID0gUmVjb2lsX1dyYXBwZXIkMTtcblxuY29uc3Qge1xuICBwZWVrTm9kZUluZm86IHBlZWtOb2RlSW5mbyQzXG59ID0gUmVjb2lsX0Z1bmN0aW9uYWxDb3JlO1xuXG5jb25zdCB7XG4gIERFRkFVTFRfVkFMVUU6IERFRkFVTFRfVkFMVUUkNyxcbiAgRGVmYXVsdFZhbHVlOiBEZWZhdWx0VmFsdWUkMixcbiAgZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyOiBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMixcbiAgcmVnaXN0ZXJOb2RlOiByZWdpc3Rlck5vZGUkMixcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyOiBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMVxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkNFxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xuXG5jb25zdCB7XG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZTogZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDQsXG4gIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkOiBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQyLFxuICBzZXRSZWNvaWxWYWx1ZTogc2V0UmVjb2lsVmFsdWUkNCxcbiAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZTogc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdDogcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0JDJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgdW53cmFwID0geCA9PiB4IGluc3RhbmNlb2YgV3JhcHBlZFZhbHVlJDIgPyB4LnZhbHVlIDogeDtcblxuZnVuY3Rpb24gYmFzZUF0b20ob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAga2V5LFxuICAgIHBlcnNpc3RlbmNlX1VOU1RBQkxFOiBwZXJzaXN0ZW5jZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmV0YWluZWRCeSA9IHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCQyKG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSk7XG4gIGxldCBsaXZlU3RvcmVzQ291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIHVud3JhcFByb21pc2UocHJvbWlzZSkge1xuICAgIHJldHVybiBsb2FkYWJsZVdpdGhQcm9taXNlJDIocHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgIGRlZmF1bHRMb2FkYWJsZSA9IGxvYWRhYmxlV2l0aFZhbHVlJDModmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIGRlZmF1bHRMb2FkYWJsZSA9IGxvYWRhYmxlV2l0aEVycm9yJDIoZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSkpO1xuICB9XG5cbiAgbGV0IGRlZmF1bHRMb2FkYWJsZSA9IFJlY29pbF9pc1Byb21pc2Uob3B0aW9ucy5kZWZhdWx0KSA/IHVud3JhcFByb21pc2Uob3B0aW9ucy5kZWZhdWx0KSA6IGlzTG9hZGFibGUkMihvcHRpb25zLmRlZmF1bHQpID8gb3B0aW9ucy5kZWZhdWx0LnN0YXRlID09PSAnbG9hZGluZycgPyB1bndyYXBQcm9taXNlKG9wdGlvbnMuZGVmYXVsdC5jb250ZW50cykgOiBvcHRpb25zLmRlZmF1bHQgOiBsb2FkYWJsZVdpdGhWYWx1ZSQzKHVud3JhcChvcHRpb25zLmRlZmF1bHQpKTtcbiAgbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZShkZWZhdWx0TG9hZGFibGUuY29udGVudHMpO1xuICBsZXQgY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSA9IHVuZGVmaW5lZDsgLy8gQ2xlYW51cCBoYW5kbGVycyBmb3IgdGhpcyBhdG9tXG4gIC8vIFJlbHkgb24gc3RhYmxlIHJlZmVyZW5jZSBlcXVhbGl0eSBvZiB0aGUgc3RvcmUgdG8gdXNlIGl0IGFzIGEga2V5IHBlciA8UmVjb2lsUm9vdD5cblxuICBjb25zdCBjbGVhbnVwRWZmZWN0c0J5U3RvcmUgPSBuZXcgTWFwKCk7XG5cbiAgZnVuY3Rpb24gbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZSh2YWx1ZU9yUHJvbWlzZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmIChvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5ICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKHZhbHVlT3JQcm9taXNlKSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZU9yUHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIFJlY29pbF9kZWVwRnJlZXplVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFJlY29pbF9kZWVwRnJlZXplVmFsdWUodmFsdWVPclByb21pc2UpO1xuICAgICAgICAgIHJldHVybiB2YWx1ZU9yUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZU9yUHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBQZW5kaW5nUHJvbWlzZShzdG9yZSwgcHJvbWlzZSkge1xuICAgIGNvbnN0IHdyYXBwZWRQcm9taXNlID0gcHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQsIF9zdGF0ZSRhdG9tVmFsdWVzJGdldDtcblxuICAgICAgY29uc3Qgc3RhdGUgPSAoX3N0b3JlJGdldFN0YXRlJG5leHRUID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlJGdldFN0YXRlJG5leHRUICE9PSB2b2lkIDAgPyBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgOiBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xuXG4gICAgICBpZiAoKChfc3RhdGUkYXRvbVZhbHVlcyRnZXQgPSBzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZSRhdG9tVmFsdWVzJGdldC5jb250ZW50cykgPT09IHdyYXBwZWRQcm9taXNlKSB7XG4gICAgICAgIHNldFJlY29pbFZhbHVlJDQoc3RvcmUsIG5vZGUsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQyLCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQyO1xuXG4gICAgICBjb25zdCBzdGF0ZSA9IChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQyID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlJGdldFN0YXRlJG5leHRUMiAhPT0gdm9pZCAwID8gX3N0b3JlJGdldFN0YXRlJG5leHRUMiA6IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XG5cbiAgICAgIGlmICgoKF9zdGF0ZSRhdG9tVmFsdWVzJGdldDIgPSBzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGUkYXRvbVZhbHVlcyRnZXQyLmNvbnRlbnRzKSA9PT0gd3JhcHBlZFByb21pc2UpIHtcbiAgICAgICAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQyKHN0b3JlLCBub2RlLCBsb2FkYWJsZVdpdGhFcnJvciQyKGVycm9yKSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIHJldHVybiB3cmFwcGVkUHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRBdG9tKHN0b3JlLCBpbml0U3RhdGUsIHRyaWdnZXIpIHtcbiAgICB2YXIgX29wdGlvbnMkZWZmZWN0cztcblxuICAgIGxpdmVTdG9yZXNDb3VudCsrO1xuXG4gICAgY29uc3QgY2xlYW51cEF0b20gPSAoKSA9PiB7XG4gICAgICB2YXIgX2NsZWFudXBFZmZlY3RzQnlTdG9yO1xuXG4gICAgICBsaXZlU3RvcmVzQ291bnQtLTtcbiAgICAgIChfY2xlYW51cEVmZmVjdHNCeVN0b3IgPSBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuZ2V0KHN0b3JlKSkgPT09IG51bGwgfHwgX2NsZWFudXBFZmZlY3RzQnlTdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY2xlYW51cEVmZmVjdHNCeVN0b3IuZm9yRWFjaChjbGVhbnVwID0+IGNsZWFudXAoKSk7XG4gICAgICBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuZGVsZXRlKHN0b3JlKTtcbiAgICB9O1xuXG4gICAgc3RvcmUuZ2V0U3RhdGUoKS5rbm93bkF0b21zLmFkZChrZXkpOyAvLyBTZXR1cCBhc3luYyBkZWZhdWx0cyB0byBub3RpZnkgc3Vic2NyaWJlcnMgd2hlbiB0aGV5IHJlc29sdmVcblxuICAgIGlmIChkZWZhdWx0TG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgY29uc3Qgbm90aWZ5RGVmYXVsdFN1YnNjcmliZXJzID0gKCkgPT4ge1xuICAgICAgICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRUMztcblxuICAgICAgICBjb25zdCBzdGF0ZSA9IChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQzID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlJGdldFN0YXRlJG5leHRUMyAhPT0gdm9pZCAwID8gX3N0b3JlJGdldFN0YXRlJG5leHRUMyA6IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5hdG9tVmFsdWVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQkMihzdG9yZSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGRlZmF1bHRMb2FkYWJsZS5jb250ZW50cy5maW5hbGx5KG5vdGlmeURlZmF1bHRTdWJzY3JpYmVycyk7XG4gICAgfSAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gUnVuIEF0b20gRWZmZWN0c1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4gICAgY29uc3QgZWZmZWN0cyA9IChfb3B0aW9ucyRlZmZlY3RzID0gb3B0aW9ucy5lZmZlY3RzKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRlZmZlY3RzICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRlZmZlY3RzIDogb3B0aW9ucy5lZmZlY3RzX1VOU1RBQkxFO1xuXG4gICAgaWYgKGVmZmVjdHMgIT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBzdGF0ZSBpcyBzY29wZWQgYnkgU3RvcmUsIHNpbmNlIHRoaXMgaXMgaW4gdGhlIGluaXRBdG9tKCkgY2xvc3VyZVxuICAgICAgbGV0IGluaXRWYWx1ZSA9IERFRkFVTFRfVkFMVUUkNztcbiAgICAgIGxldCBpc0R1cmluZ0luaXQgPSB0cnVlO1xuICAgICAgbGV0IGlzSW5pdEVycm9yID0gZmFsc2U7XG4gICAgICBsZXQgcGVuZGluZ1NldFNlbGYgPSBudWxsO1xuXG4gICAgICBmdW5jdGlvbiBnZXRMb2FkYWJsZShyZWNvaWxWYWx1ZSkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSBjYW4ganVzdCBnZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYW5vdGhlciBhdG9tLlxuICAgICAgICAvLyBCdXQgZm9yIG91ciBvd24gdmFsdWUgd2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBhIHBlbmRpbmdcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQgdmFsdWUgb3IgZ2V0IHRoZSBmYWxsYmFjayBkZWZhdWx0IHZhbHVlLlxuICAgICAgICBpZiAoaXNEdXJpbmdJbml0ICYmIHJlY29pbFZhbHVlLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgLy8gQ2FzdCBUIHRvIFNcbiAgICAgICAgICBjb25zdCByZXRWYWx1ZSA9IGluaXRWYWx1ZTsgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cbiAgICAgICAgICByZXR1cm4gcmV0VmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IHBlZWtBdG9tKHN0b3JlLCBpbml0U3RhdGUpIC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgICAgIDogUmVjb2lsX2lzUHJvbWlzZShyZXRWYWx1ZSkgPyBsb2FkYWJsZVdpdGhQcm9taXNlJDIocmV0VmFsdWUudGhlbih2ID0+IHYgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IC8vIENhc3QgVCB0byBTXG4gICAgICAgICAgZGVmYXVsdExvYWRhYmxlLnRvUHJvbWlzZSgpIC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgICAgIDogdikpIDogbG9hZGFibGVXaXRoVmFsdWUkMyhyZXRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDQoc3RvcmUsIHJlY29pbFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UHJvbWlzZShyZWNvaWxWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZ2V0TG9hZGFibGUocmVjb2lsVmFsdWUpLnRvUHJvbWlzZSgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRJbmZvX1VOU1RBQkxFKHJlY29pbFZhbHVlKSB7XG4gICAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ0O1xuXG4gICAgICAgIGNvbnN0IGluZm8gPSBwZWVrTm9kZUluZm8kMyhzdG9yZSwgKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDQgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ0ICE9PSB2b2lkIDAgPyBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ0IDogc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSwgcmVjb2lsVmFsdWUua2V5KTtcbiAgICAgICAgcmV0dXJuIGlzRHVyaW5nSW5pdCAmJiByZWNvaWxWYWx1ZS5rZXkgPT09IGtleSAmJiAhKGluaXRWYWx1ZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyKSA/IHsgLi4uaW5mbyxcbiAgICAgICAgICBpc1NldDogdHJ1ZSxcbiAgICAgICAgICBsb2FkYWJsZTogZ2V0TG9hZGFibGUocmVjb2lsVmFsdWUpXG4gICAgICAgIH0gOiBpbmZvO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXRTZWxmID0gZWZmZWN0ID0+IHZhbHVlT3JVcGRhdGVyID0+IHtcbiAgICAgICAgaWYgKGlzRHVyaW5nSW5pdCkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRMb2FkYWJsZSA9IGdldExvYWRhYmxlKG5vZGUpO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRMb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJyA/IGN1cnJlbnRMb2FkYWJsZS5jb250ZW50cyA6IERFRkFVTFRfVkFMVUUkNztcbiAgICAgICAgICBpbml0VmFsdWUgPSB0eXBlb2YgdmFsdWVPclVwZGF0ZXIgPT09ICdmdW5jdGlvbicgPyAvLyBjYXN0IHRvIGFueSBiZWNhdXNlIHdlIGNhbid0IHJlc3RyaWN0IFQgZnJvbSBiZWluZyBhIGZ1bmN0aW9uIHdpdGhvdXQgbG9zaW5nIHN1cHBvcnQgZm9yIG9wYXF1ZSB0eXBlc1xuICAgICAgICAgIHZhbHVlT3JVcGRhdGVyKGN1cnJlbnRWYWx1ZSkgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gICAgICAgICAgOiB2YWx1ZU9yVXBkYXRlcjtcblxuICAgICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKGluaXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGluaXRWYWx1ZSA9IGluaXRWYWx1ZS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgLy8gQXZvaWQgY2FsbGluZyBvblNldCgpIHdoZW4gc2V0U2VsZigpIGluaXRpYWxpemVzIHdpdGggYSBQcm9taXNlXG4gICAgICAgICAgICAgIHBlbmRpbmdTZXRTZWxmID0ge1xuICAgICAgICAgICAgICAgIGVmZmVjdCxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UodmFsdWVPclVwZGF0ZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdTZXR0aW5nIGF0b21zIHRvIGFzeW5jIHZhbHVlcyBpcyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZU9yVXBkYXRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcGVuZGluZ1NldFNlbGYgPSB7XG4gICAgICAgICAgICAgIGVmZmVjdCxcbiAgICAgICAgICAgICAgdmFsdWU6IHVud3JhcCh2YWx1ZU9yVXBkYXRlcilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0UmVjb2lsVmFsdWUkNChzdG9yZSwgbm9kZSwgdHlwZW9mIHZhbHVlT3JVcGRhdGVyID09PSAnZnVuY3Rpb24nID8gY3VycmVudFZhbHVlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdW53cmFwKCAvLyBjYXN0IHRvIGFueSBiZWNhdXNlIHdlIGNhbid0IHJlc3RyaWN0IFQgZnJvbSBiZWluZyBhIGZ1bmN0aW9uIHdpdGhvdXQgbG9zaW5nIHN1cHBvcnQgZm9yIG9wYXF1ZSB0eXBlc1xuICAgICAgICAgICAgdmFsdWVPclVwZGF0ZXIoY3VycmVudFZhbHVlKSAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwZW5kaW5nU2V0U2VsZiA9IHtcbiAgICAgICAgICAgICAgZWZmZWN0LFxuICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgICAgICAgfSA6IHVud3JhcCh2YWx1ZU9yVXBkYXRlcikpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXNldFNlbGYgPSBlZmZlY3QgPT4gKCkgPT4gc2V0U2VsZihlZmZlY3QpKERFRkFVTFRfVkFMVUUkNyk7XG5cbiAgICAgIGNvbnN0IG9uU2V0ID0gZWZmZWN0ID0+IGhhbmRsZXIgPT4ge1xuICAgICAgICB2YXIgX2NsZWFudXBFZmZlY3RzQnlTdG9yMjtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVsZWFzZVxuICAgICAgICB9ID0gc3RvcmUuc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnMoY3VycmVudFN0b3JlID0+IHtcbiAgICAgICAgICB2YXIgX2N1cnJlbnRUcmVlJGF0b21WYWx1O1xuXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBjdXJyZW50VHJlZSxcbiAgICAgICAgICAgIHByZXZpb3VzVHJlZVxuICAgICAgICAgIH0gPSBjdXJyZW50U3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgICAgIGlmICghcHJldmlvdXNUcmVlKSB7XG4gICAgICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ1RyYW5zYWN0aW9uIHN1YnNjcmliZXJzIG5vdGlmaWVkIHdpdGhvdXQgYSBuZXh0IHRyZWUgYmVpbmcgcHJlc2VudCAtLSB0aGlzIGlzIGEgYnVnIGluIFJlY29pbCcpO1xuICAgICAgICAgICAgcHJldmlvdXNUcmVlID0gY3VycmVudFRyZWU7IC8vIGF0dGVtcHQgdG8gdHJ1bmRsZSBvblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG5ld0xvYWRhYmxlID0gKF9jdXJyZW50VHJlZSRhdG9tVmFsdSA9IGN1cnJlbnRUcmVlLmF0b21WYWx1ZXMuZ2V0KGtleSkpICE9PSBudWxsICYmIF9jdXJyZW50VHJlZSRhdG9tVmFsdSAhPT0gdm9pZCAwID8gX2N1cnJlbnRUcmVlJGF0b21WYWx1IDogZGVmYXVsdExvYWRhYmxlO1xuXG4gICAgICAgICAgaWYgKG5ld0xvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnKSB7XG4gICAgICAgICAgICB2YXIgX3ByZXZpb3VzVHJlZSRhdG9tVmFsLCBfcGVuZGluZ1NldFNlbGYsIF9wZW5kaW5nU2V0U2VsZjIsIF9wZW5kaW5nU2V0U2VsZjM7XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gbmV3TG9hZGFibGUuY29udGVudHM7XG4gICAgICAgICAgICBjb25zdCBvbGRMb2FkYWJsZSA9IChfcHJldmlvdXNUcmVlJGF0b21WYWwgPSBwcmV2aW91c1RyZWUuYXRvbVZhbHVlcy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX3ByZXZpb3VzVHJlZSRhdG9tVmFsICE9PSB2b2lkIDAgPyBfcHJldmlvdXNUcmVlJGF0b21WYWwgOiBkZWZhdWx0TG9hZGFibGU7XG4gICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IG9sZExvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnID8gb2xkTG9hZGFibGUuY29udGVudHMgOiBERUZBVUxUX1ZBTFVFJDc7IC8vIFRPRE8gVGhpcyBpc24ndCBhY3R1YWxseSB2YWxpZCwgdXNlIGFzIGEgcGxhY2Vob2xkZXIgZm9yIG5vdy5cbiAgICAgICAgICAgIC8vIElnbm9yZSBhdG9tIHZhbHVlIGNoYW5nZXMgdGhhdCB3ZXJlIHNldCB2aWEgc2V0U2VsZigpIGluIHRoZSBzYW1lIGVmZmVjdC5cbiAgICAgICAgICAgIC8vIFdlIHdpbGwgc3RpbGwgcHJvcGVybHkgY2FsbCB0aGUgaGFuZGxlciBpZiB0aGVyZSB3YXMgYSBzdWJzZXF1ZW50XG4gICAgICAgICAgICAvLyBzZXQgZnJvbSBzb21ldGhpbmcgb3RoZXIgdGhhbiBhbiBhdG9tIGVmZmVjdCB3aGljaCB3YXMgYmF0Y2hlZFxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgYHNldFNlbGYoKWAgY2FsbC4gIEhvd2V2ZXIsIHdlIG1heSBpbmNvcnJlY3RseSBpZ25vcmVcbiAgICAgICAgICAgIC8vIHRoZSBoYW5kbGVyIGlmIHRoZSBzdWJzZXF1ZW50IGJhdGNoZWQgY2FsbCBoYXBwZW5zIHRvIHNldCB0aGVcbiAgICAgICAgICAgIC8vIGF0b20gdG8gdGhlIGV4YWN0IHNhbWUgdmFsdWUgYXMgdGhlIGBzZXRTZWxmKClgLiAgIEJ1dCwgaW4gdGhhdFxuICAgICAgICAgICAgLy8gY2FzZSwgaXQgd2FzIGtpbmQgb2YgYSBub29wLCBzbyB0aGUgc2VtYW50aWNzIGFyZSBkZWJhdGFibGUuLlxuXG4gICAgICAgICAgICBpZiAoKChfcGVuZGluZ1NldFNlbGYgPSBwZW5kaW5nU2V0U2VsZikgPT09IG51bGwgfHwgX3BlbmRpbmdTZXRTZWxmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ1NldFNlbGYuZWZmZWN0KSAhPT0gZWZmZWN0IHx8ICgoX3BlbmRpbmdTZXRTZWxmMiA9IHBlbmRpbmdTZXRTZWxmKSA9PT0gbnVsbCB8fCBfcGVuZGluZ1NldFNlbGYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ1NldFNlbGYyLnZhbHVlKSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgaGFuZGxlcihuZXdWYWx1ZSwgb2xkVmFsdWUsICFjdXJyZW50VHJlZS5hdG9tVmFsdWVzLmhhcyhrZXkpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChfcGVuZGluZ1NldFNlbGYzID0gcGVuZGluZ1NldFNlbGYpID09PSBudWxsIHx8IF9wZW5kaW5nU2V0U2VsZjMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wZW5kaW5nU2V0U2VsZjMuZWZmZWN0KSA9PT0gZWZmZWN0KSB7XG4gICAgICAgICAgICAgIHBlbmRpbmdTZXRTZWxmID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIGtleSk7XG4gICAgICAgIGNsZWFudXBFZmZlY3RzQnlTdG9yZS5zZXQoc3RvcmUsIFsuLi4oKF9jbGVhbnVwRWZmZWN0c0J5U3RvcjIgPSBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuZ2V0KHN0b3JlKSkgIT09IG51bGwgJiYgX2NsZWFudXBFZmZlY3RzQnlTdG9yMiAhPT0gdm9pZCAwID8gX2NsZWFudXBFZmZlY3RzQnlTdG9yMiA6IFtdKSwgcmVsZWFzZV0pO1xuICAgICAgfTtcblxuICAgICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBlZmZlY3Qoe1xuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHN0b3JlSUQ6IHN0b3JlLnN0b3JlSUQsXG4gICAgICAgICAgICBwYXJlbnRTdG9yZUlEX1VOU1RBQkxFOiBzdG9yZS5wYXJlbnRTdG9yZUlELFxuICAgICAgICAgICAgdHJpZ2dlcixcbiAgICAgICAgICAgIHNldFNlbGY6IHNldFNlbGYoZWZmZWN0KSxcbiAgICAgICAgICAgIHJlc2V0U2VsZjogcmVzZXRTZWxmKGVmZmVjdCksXG4gICAgICAgICAgICBvblNldDogb25TZXQoZWZmZWN0KSxcbiAgICAgICAgICAgIGdldFByb21pc2UsXG4gICAgICAgICAgICBnZXRMb2FkYWJsZSxcbiAgICAgICAgICAgIGdldEluZm9fVU5TVEFCTEVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChjbGVhbnVwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfY2xlYW51cEVmZmVjdHNCeVN0b3IzO1xuXG4gICAgICAgICAgICBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuc2V0KHN0b3JlLCBbLi4uKChfY2xlYW51cEVmZmVjdHNCeVN0b3IzID0gY2xlYW51cEVmZmVjdHNCeVN0b3JlLmdldChzdG9yZSkpICE9PSBudWxsICYmIF9jbGVhbnVwRWZmZWN0c0J5U3RvcjMgIT09IHZvaWQgMCA/IF9jbGVhbnVwRWZmZWN0c0J5U3RvcjMgOiBbXSksIGNsZWFudXBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaW5pdFZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgaXNJbml0RXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlzRHVyaW5nSW5pdCA9IGZhbHNlOyAvLyBNdXRhdGUgaW5pdGlhbCBzdGF0ZSBpbiBwbGFjZSBzaW5jZSB3ZSBrbm93IHRoZXJlIGFyZSBubyBvdGhlciBzdWJzY3JpYmVyc1xuICAgICAgLy8gc2luY2Ugd2UgYXJlIHRoZSBvbmVzIGluaXRpYWxpemluZyBvbiBmaXJzdCB1c2UuXG5cbiAgICAgIGlmICghKGluaXRWYWx1ZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyKSkge1xuICAgICAgICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRUNTtcblxuICAgICAgICBjb25zdCBpbml0TG9hZGFibGUgPSBpc0luaXRFcnJvciA/IGxvYWRhYmxlV2l0aEVycm9yJDIoaW5pdFZhbHVlKSA6IFJlY29pbF9pc1Byb21pc2UoaW5pdFZhbHVlKSA/IGxvYWRhYmxlV2l0aFByb21pc2UkMih3cmFwUGVuZGluZ1Byb21pc2Uoc3RvcmUsIGluaXRWYWx1ZSkpIDogbG9hZGFibGVXaXRoVmFsdWUkMyh1bndyYXAoaW5pdFZhbHVlKSk7XG4gICAgICAgIG1heWJlRnJlZXplVmFsdWVPclByb21pc2UoaW5pdExvYWRhYmxlLmNvbnRlbnRzKTtcbiAgICAgICAgaW5pdFN0YXRlLmF0b21WYWx1ZXMuc2V0KGtleSwgaW5pdExvYWRhYmxlKTsgLy8gSWYgdGhlcmUgaXMgYSBwZW5kaW5nIHRyYW5zYWN0aW9uLCB0aGVuIGFsc28gbXV0YXRlIHRoZSBuZXh0IHN0YXRlIHRyZWUuXG4gICAgICAgIC8vIFRoaXMgY291bGQgaGFwcGVuIGlmIHRoZSBhdG9tIHdhcyBmaXJzdCBpbml0aWFsaXplZCBpbiBhbiBhY3Rpb24gdGhhdFxuICAgICAgICAvLyBhbHNvIHVwZGF0ZWQgc29tZSBvdGhlciBhdG9tJ3Mgc3RhdGUuXG5cbiAgICAgICAgKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1LmF0b21WYWx1ZXMuc2V0KGtleSwgaW5pdExvYWRhYmxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xlYW51cEF0b207XG4gIH1cblxuICBmdW5jdGlvbiBwZWVrQXRvbShfc3RvcmUsIHN0YXRlKSB7XG4gICAgdmFyIF9yZWYsIF9zdGF0ZSRhdG9tVmFsdWVzJGdldDM7XG5cbiAgICByZXR1cm4gKF9yZWYgPSAoX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MyA9IHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSkpICE9PSBudWxsICYmIF9zdGF0ZSRhdG9tVmFsdWVzJGdldDMgIT09IHZvaWQgMCA/IF9zdGF0ZSRhdG9tVmFsdWVzJGdldDMgOiBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogZGVmYXVsdExvYWRhYmxlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QXRvbShfc3RvcmUsIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmF0b21WYWx1ZXMuaGFzKGtleSkpIHtcbiAgICAgIC8vIEF0b20gdmFsdWUgaXMgc3RvcmVkIGluIHN0YXRlOlxuICAgICAgcmV0dXJuIFJlY29pbF9udWxsdGhyb3dzKHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSkpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuaGFzKGtleSkpIHtcbiAgICAgIC8vIEF0b20gdmFsdWUgaXMgc3RvcmVkIGJ1dCBuZWVkcyB2YWxpZGF0aW9uIGJlZm9yZSB1c2UuXG4gICAgICAvLyBXZSBtaWdodCBoYXZlIGFscmVhZHkgdmFsaWRhdGVkIGl0IGFuZCBoYXZlIGEgY2FjaGVkIHZhbGlkYXRlZCB2YWx1ZTpcbiAgICAgIGlmIChjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwZXJzaXN0ZW5jZSA9PSBudWxsKSB7XG4gICAgICAgIFJlY29pbF9leHBlY3RhdGlvblZpb2xhdGlvbihgVHJpZWQgdG8gcmVzdG9yZSBhIHBlcnNpc3RlZCB2YWx1ZSBmb3IgYXRvbSAke2tleX0gYnV0IGl0IGhhcyBubyBwZXJzaXN0ZW5jZSBzZXR0aW5ncy5gKTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2FkYWJsZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9udmFsaWRhdGVkVmFsdWUgPSBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5nZXQoa2V5KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRvclJlc3VsdCA9IHBlcnNpc3RlbmNlLnZhbGlkYXRvcihub252YWxpZGF0ZWRWYWx1ZSwgREVGQVVMVF9WQUxVRSQ3KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFZhbHVlTG9hZGFibGUgPSB2YWxpZGF0b3JSZXN1bHQgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IGRlZmF1bHRMb2FkYWJsZSA6IGxvYWRhYmxlV2l0aFZhbHVlJDModmFsaWRhdG9yUmVzdWx0KTtcbiAgICAgIGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWUgPSB2YWxpZGF0ZWRWYWx1ZUxvYWRhYmxlO1xuICAgICAgcmV0dXJuIGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZWZhdWx0TG9hZGFibGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZUF0b20oKSB7XG4gICAgY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEF0b20oX3N0b3JlLCBzdGF0ZSwgbmV3VmFsdWUpIHtcbiAgICAvLyBCYWlsIG91dCBpZiB3ZSdyZSBiZWluZyBzZXQgdG8gdGhlIGV4aXN0aW5nIHZhbHVlLCBvciBpZiB3ZSdyZSBiZWluZ1xuICAgIC8vIHJlc2V0IGJ1dCBoYXZlIG5vIHN0b3JlZCB2YWx1ZSAodmFsaWRhdGVkIG9yIHVudmFsaWRhdGVkKSB0byByZXNldCBmcm9tOlxuICAgIGlmIChzdGF0ZS5hdG9tVmFsdWVzLmhhcyhrZXkpKSB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IFJlY29pbF9udWxsdGhyb3dzKHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSkpO1xuXG4gICAgICBpZiAoZXhpc3Rpbmcuc3RhdGUgPT09ICdoYXNWYWx1ZScgJiYgbmV3VmFsdWUgPT09IGV4aXN0aW5nLmNvbnRlbnRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuaGFzKGtleSkgJiYgbmV3VmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMikge1xuICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBtYXliZUZyZWV6ZVZhbHVlT3JQcm9taXNlKG5ld1ZhbHVlKTtcbiAgICBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlID0gdW5kZWZpbmVkOyAvLyBjYW4gYmUgcmVsZWFzZWQgbm93IGlmIGl0IHdhcyBwcmV2aW91c2x5IGluIHVzZVxuXG4gICAgcmV0dXJuIG5ldyBNYXAoKS5zZXQoa2V5LCBsb2FkYWJsZVdpdGhWYWx1ZSQzKG5ld1ZhbHVlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGREZWxldGVDb25maWdPblJlbGVhc2VBdG9tKCkge1xuICAgIHJldHVybiBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMihrZXkpICE9PSB1bmRlZmluZWQgJiYgbGl2ZVN0b3Jlc0NvdW50IDw9IDA7XG4gIH1cblxuICBjb25zdCBub2RlID0gcmVnaXN0ZXJOb2RlJDIoe1xuICAgIGtleSxcbiAgICBub2RlVHlwZTogJ2F0b20nLFxuICAgIHBlZWs6IHBlZWtBdG9tLFxuICAgIGdldDogZ2V0QXRvbSxcbiAgICBzZXQ6IHNldEF0b20sXG4gICAgaW5pdDogaW5pdEF0b20sXG4gICAgaW52YWxpZGF0ZTogaW52YWxpZGF0ZUF0b20sXG4gICAgc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlOiBzaG91bGREZWxldGVDb25maWdPblJlbGVhc2VBdG9tLFxuICAgIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiBvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5LFxuICAgIHBlcnNpc3RlbmNlX1VOU1RBQkxFOiBvcHRpb25zLnBlcnNpc3RlbmNlX1VOU1RBQkxFID8ge1xuICAgICAgdHlwZTogb3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRS50eXBlLFxuICAgICAgYmFja0J1dHRvbjogb3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRS5iYWNrQnV0dG9uXG4gICAgfSA6IHVuZGVmaW5lZCxcbiAgICBzaG91bGRSZXN0b3JlRnJvbVNuYXBzaG90czogdHJ1ZSxcbiAgICByZXRhaW5lZEJ5XG4gIH0pO1xuICByZXR1cm4gbm9kZTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxuZnVuY3Rpb24gYXRvbShvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMua2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycignQSBrZXkgb3B0aW9uIHdpdGggYSB1bmlxdWUgc3RyaW5nIHZhbHVlIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBjcmVhdGluZyBhbiBhdG9tLicpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHsgLy8gQGZiLW9ubHk6IHNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUyxcbiAgICAuLi5yZXN0T3B0aW9uc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgb3B0aW9uc0RlZmF1bHQgPSAnZGVmYXVsdCcgaW4gb3B0aW9ucyA/IC8vICRGbG93SXNzdWVbcHJvcC1taXNzaW5nXSBObyB3YXkgdG8gcmVmaW5lIGluIEZsb3cgdGhhdCBwcm9wZXJ0eSBpcyBub3QgZGVmaW5lZFxuICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS10eXBlXSBObyB3YXkgdG8gcmVmaW5lIGluIEZsb3cgdGhhdCBwcm9wZXJ0eSBpcyBub3QgZGVmaW5lZFxuICBvcHRpb25zLmRlZmF1bHQgOiBuZXcgUHJvbWlzZSgoKSA9PiB7fSk7XG5cbiAgaWYgKGlzUmVjb2lsVmFsdWUkNChvcHRpb25zRGVmYXVsdCkgLy8gQ29udGludWUgdG8gdXNlIGF0b21XaXRoRmFsbGJhY2sgZm9yIHByb21pc2UgZGVmYXVsdHMgZm9yIHNjb3BlZCBhdG9tc1xuICAvLyBmb3Igbm93LCBzaW5jZSBzY29wZWQgYXRvbXMgZG9uJ3Qgc3VwcG9ydCBhc3luYyBkZWZhdWx0c1xuICAvLyBAZmItb25seTogfHwgKGlzUHJvbWlzZShvcHRpb25zRGVmYXVsdCkgJiYgc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTKVxuICAvLyBAZmItb25seTogfHwgKGlzTG9hZGFibGUob3B0aW9uc0RlZmF1bHQpICYmIHNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUylcbiAgKSB7XG4gICAgcmV0dXJuIGF0b21XaXRoRmFsbGJhY2soeyAuLi5yZXN0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHQ6IG9wdGlvbnNEZWZhdWx0IC8vIEBmYi1vbmx5OiBzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1MsXG5cbiAgICB9KTsgLy8gQGZiLW9ubHk6IH0gZWxzZSBpZiAoc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTXG4gICAgLy8gQGZiLW9ubHk6ICYmICFpc1Byb21pc2Uob3B0aW9uc0RlZmF1bHQpXG4gICAgLy8gQGZiLW9ubHk6ICYmICFpc0xvYWRhYmxlKG9wdGlvbnNEZWZhdWx0KVxuICAgIC8vIEBmYi1vbmx5OiApIHtcbiAgICAvLyBAZmItb25seTogcmV0dXJuIHNjb3BlZEF0b208VD4oe1xuICAgIC8vIEBmYi1vbmx5OiAuLi5yZXN0T3B0aW9ucyxcbiAgICAvLyBAZmItb25seTogZGVmYXVsdDogdW53cmFwPFQ+KG9wdGlvbnNEZWZhdWx0KSxcbiAgICAvLyBAZmItb25seTogc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTLFxuICAgIC8vIEBmYi1vbmx5OiB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZUF0b20oeyAuLi5yZXN0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHQ6IG9wdGlvbnNEZWZhdWx0XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXRvbVdpdGhGYWxsYmFjayhvcHRpb25zKSB7XG4gIGNvbnN0IGJhc2UgPSBhdG9tKHsgLi4ub3B0aW9ucyxcbiAgICBkZWZhdWx0OiBERUZBVUxUX1ZBTFVFJDcsXG4gICAgcGVyc2lzdGVuY2VfVU5TVEFCTEU6IG9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHsgLi4ub3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRSxcbiAgICAgIHZhbGlkYXRvcjogc3RvcmVkVmFsdWUgPT4gc3RvcmVkVmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IHN0b3JlZFZhbHVlIDogUmVjb2lsX251bGx0aHJvd3Mob3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRSkudmFsaWRhdG9yKHN0b3JlZFZhbHVlLCBERUZBVUxUX1ZBTFVFJDcpXG4gICAgfSxcbiAgICAvLyBUT0RPIEhhY2sgZm9yIG5vdy5cbiAgICBlZmZlY3RzOiBvcHRpb25zLmVmZmVjdHMsXG4gICAgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxuICAgIGVmZmVjdHNfVU5TVEFCTEU6IG9wdGlvbnMuZWZmZWN0c19VTlNUQUJMRSAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTogb2ZmXG5cbiAgfSk7XG4gIGNvbnN0IHNlbCA9IFJlY29pbF9zZWxlY3Rvcih7XG4gICAga2V5OiBgJHtvcHRpb25zLmtleX1fX3dpdGhGYWxsYmFja2AsXG4gICAgZ2V0OiAoe1xuICAgICAgZ2V0XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgYmFzZVZhbHVlID0gZ2V0KGJhc2UpO1xuICAgICAgcmV0dXJuIGJhc2VWYWx1ZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyID8gb3B0aW9ucy5kZWZhdWx0IDogYmFzZVZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiAoe1xuICAgICAgc2V0XG4gICAgfSwgbmV3VmFsdWUpID0+IHNldChiYXNlLCBuZXdWYWx1ZSksXG4gICAgLy8gVGhpcyBzZWxlY3RvciBkb2VzIG5vdCBuZWVkIHRvIGNhY2hlIGFzIGl0IGlzIGEgd3JhcHBlciBzZWxlY3RvclxuICAgIC8vIGFuZCB0aGUgc2VsZWN0b3Igd2l0aGluIHRoZSB3cmFwcGVyIHNlbGVjdG9yIHdpbGwgaGF2ZSBhIGNhY2hlXG4gICAgLy8gb3B0aW9uIGJ5IGRlZmF1bHRcbiAgICBjYWNoZVBvbGljeV9VTlNUQUJMRToge1xuICAgICAgZXZpY3Rpb246ICdtb3N0LXJlY2VudCdcbiAgICB9LFxuICAgIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiBvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5XG4gIH0pO1xuICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMShzZWwua2V5LCBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMihvcHRpb25zLmtleSkpO1xuICByZXR1cm4gc2VsO1xufVxuXG5hdG9tLnZhbHVlID0gdmFsdWUgPT4gbmV3IFdyYXBwZWRWYWx1ZSQyKHZhbHVlKTtcblxudmFyIFJlY29pbF9hdG9tID0gYXRvbTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuY2xhc3MgTWFwQ2FjaGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zJG1hcEtleTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tYXBcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9rZXlNYXBwZXJcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9rZXlNYXBwZXIgPSAoX29wdGlvbnMkbWFwS2V5ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1hcEtleSkgIT09IG51bGwgJiYgX29wdGlvbnMkbWFwS2V5ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRtYXBLZXkgOiB2ID0+IHY7XG4gIH1cblxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuc2l6ZTtcbiAgfVxuXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyh0aGlzLl9rZXlNYXBwZXIoa2V5KSk7XG4gIH1cblxuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5nZXQodGhpcy5fa2V5TWFwcGVyKGtleSkpO1xuICB9XG5cbiAgc2V0KGtleSwgdmFsKSB7XG4gICAgdGhpcy5fbWFwLnNldCh0aGlzLl9rZXlNYXBwZXIoa2V5KSwgdmFsKTtcbiAgfVxuXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9tYXAuZGVsZXRlKHRoaXMuX2tleU1hcHBlcihrZXkpKTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICB9XG5cbn1cblxudmFyIFJlY29pbF9NYXBDYWNoZSA9IHtcbiAgTWFwQ2FjaGVcbn07XG5cbnZhciBSZWNvaWxfTWFwQ2FjaGVfMSA9IFJlY29pbF9NYXBDYWNoZS5NYXBDYWNoZTtcblxudmFyIFJlY29pbF9NYXBDYWNoZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIE1hcENhY2hlOiBSZWNvaWxfTWFwQ2FjaGVfMVxufSk7XG5cbmNvbnN0IHtcbiAgTFJVQ2FjaGU6IExSVUNhY2hlJDJcbn0gPSBSZWNvaWxfTFJVQ2FjaGUkMTtcblxuY29uc3Qge1xuICBNYXBDYWNoZTogTWFwQ2FjaGUkMVxufSA9IFJlY29pbF9NYXBDYWNoZSQxO1xuXG5cblxuXG5cblxuXG5jb25zdCBkZWZhdWx0UG9saWN5JDEgPSB7XG4gIGVxdWFsaXR5OiAncmVmZXJlbmNlJyxcbiAgZXZpY3Rpb246ICdub25lJyxcbiAgbWF4U2l6ZTogSW5maW5pdHlcbn07XG5cbmZ1bmN0aW9uIGNhY2hlRnJvbVBvbGljeSh7XG4gIGVxdWFsaXR5ID0gZGVmYXVsdFBvbGljeSQxLmVxdWFsaXR5LFxuICBldmljdGlvbiA9IGRlZmF1bHRQb2xpY3kkMS5ldmljdGlvbixcbiAgbWF4U2l6ZSA9IGRlZmF1bHRQb2xpY3kkMS5tYXhTaXplXG59ID0gZGVmYXVsdFBvbGljeSQxKSB7XG4gIGNvbnN0IHZhbHVlTWFwcGVyID0gZ2V0VmFsdWVNYXBwZXIkMShlcXVhbGl0eSk7XG4gIGNvbnN0IGNhY2hlID0gZ2V0Q2FjaGUoZXZpY3Rpb24sIG1heFNpemUsIHZhbHVlTWFwcGVyKTtcbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZU1hcHBlciQxKGVxdWFsaXR5KSB7XG4gIHN3aXRjaCAoZXF1YWxpdHkpIHtcbiAgICBjYXNlICdyZWZlcmVuY2UnOlxuICAgICAgcmV0dXJuIHZhbCA9PiB2YWw7XG5cbiAgICBjYXNlICd2YWx1ZSc6XG4gICAgICByZXR1cm4gdmFsID0+IFJlY29pbF9zdGFibGVTdHJpbmdpZnkodmFsKTtcbiAgfVxuXG4gIHRocm93IFJlY29pbF9lcnIoYFVucmVjb2duaXplZCBlcXVhbGl0eSBwb2xpY3kgJHtlcXVhbGl0eX1gKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FjaGUoZXZpY3Rpb24sIG1heFNpemUsIG1hcEtleSkge1xuICBzd2l0Y2ggKGV2aWN0aW9uKSB7XG4gICAgY2FzZSAna2VlcC1hbGwnOlxuICAgICAgcmV0dXJuIG5ldyBNYXBDYWNoZSQxKHtcbiAgICAgICAgbWFwS2V5XG4gICAgICB9KTtcblxuICAgIGNhc2UgJ2xydSc6XG4gICAgICByZXR1cm4gbmV3IExSVUNhY2hlJDIoe1xuICAgICAgICBtYXBLZXksXG4gICAgICAgIG1heFNpemU6IFJlY29pbF9udWxsdGhyb3dzKG1heFNpemUpXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ21vc3QtcmVjZW50JzpcbiAgICAgIHJldHVybiBuZXcgTFJVQ2FjaGUkMih7XG4gICAgICAgIG1hcEtleSxcbiAgICAgICAgbWF4U2l6ZTogMVxuICAgICAgfSk7XG4gIH1cblxuICB0aHJvdyBSZWNvaWxfZXJyKGBVbnJlY29nbml6ZWQgZXZpY3Rpb24gcG9saWN5ICR7ZXZpY3Rpb259YCk7XG59XG5cbnZhciBSZWNvaWxfY2FjaGVGcm9tUG9saWN5ID0gY2FjaGVGcm9tUG9saWN5O1xuXG4vLyBAZmItb25seTogaW1wb3J0IHR5cGUge1Njb3BlUnVsZXN9IGZyb20gJ1JlY29pbF9TY29wZWRBdG9tJztcblxuXG5jb25zdCB7XG4gIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlcjogc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDJcbn0gPSBSZWNvaWxfTm9kZTtcblxuXG5cblxuXG4vLyBQcm9jZXNzIHNjb3BlUnVsZXMgdG8gaGFuZGxlIGFueSBlbnRyaWVzIHdoaWNoIGFyZSBmdW5jdGlvbnMgdGFraW5nIHBhcmFtZXRlcnNcbi8vIHByZXR0aWVyLWlnbm9yZVxuLy8gQGZiLW9ubHk6IGZ1bmN0aW9uIG1hcFNjb3BlUnVsZXM8UD4oXG4vLyBAZmItb25seTogc2NvcGVSdWxlcz86IFBhcmFtZXRlcml6ZWRTY29wZVJ1bGVzPFA+LFxuLy8gQGZiLW9ubHk6IHBhcmFtOiBQLFxuLy8gQGZiLW9ubHk6ICk6IFNjb3BlUnVsZXMgfCB2b2lkIHtcbi8vIEBmYi1vbmx5OiByZXR1cm4gc2NvcGVSdWxlcz8ubWFwKHJ1bGUgPT5cbi8vIEBmYi1vbmx5OiBBcnJheS5pc0FycmF5KHJ1bGUpXG4vLyBAZmItb25seTogPyBydWxlLm1hcChlbnRyeSA9PiAodHlwZW9mIGVudHJ5ID09PSAnZnVuY3Rpb24nID8gZW50cnkocGFyYW0pIDogZW50cnkpKVxuLy8gQGZiLW9ubHk6IDogcnVsZSxcbi8vIEBmYi1vbmx5OiApO1xuLy8gQGZiLW9ubHk6IH1cblxuLypcbkEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBhdG9tIGJhc2VkIG9uIHRoZSBpbnB1dCBwYXJhbWV0ZXIuXG5cbkVhY2ggdW5pcXVlIHBhcmFtZXRlciByZXR1cm5zIGEgdW5pcXVlIGF0b20uIEUuZy4sXG5cbiAgY29uc3QgZiA9IGF0b21GYW1pbHkoLi4uKTtcbiAgZih7YTogMX0pID0+IGFuIGF0b21cbiAgZih7YTogMn0pID0+IGEgZGlmZmVyZW50IGF0b21cblxuVGhpcyBhbGxvd3MgY29tcG9uZW50cyB0byBwZXJzaXN0IGxvY2FsLCBwcml2YXRlIHN0YXRlIHVzaW5nIGF0b21zLiAgRWFjaFxuaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCBtYXkgaGF2ZSBhIGRpZmZlcmVudCBrZXksIHdoaWNoIGl0IHVzZXMgYXMgdGhlXG5wYXJhbWV0ZXIgZm9yIGEgZmFtaWx5IG9mIGF0b21zOyBpbiB0aGlzIHdheSwgZWFjaCBjb21wb25lbnQgd2lsbCBoYXZlXG5pdHMgb3duIGF0b20gbm90IHNoYXJlZCBieSBvdGhlciBpbnN0YW5jZXMuICBUaGVzZSBzdGF0ZSBrZXlzIG1heSBiZSBjb21wb3NlZFxuaW50byBjaGlsZHJlbidzIHN0YXRlIGtleXMgYXMgd2VsbC5cbiovXG5mdW5jdGlvbiBhdG9tRmFtaWx5KG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGNhY2hlUG9saWN5RiwgX29wdGlvbnMkY2FjaGVQb2xpY3lGMjtcblxuICBjb25zdCBhdG9tQ2FjaGUgPSBSZWNvaWxfY2FjaGVGcm9tUG9saWN5KHtcbiAgICBlcXVhbGl0eTogKF9vcHRpb25zJGNhY2hlUG9saWN5RiA9IChfb3B0aW9ucyRjYWNoZVBvbGljeUYyID0gb3B0aW9ucy5jYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRSkgPT09IG51bGwgfHwgX29wdGlvbnMkY2FjaGVQb2xpY3lGMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkY2FjaGVQb2xpY3lGMi5lcXVhbGl0eSkgIT09IG51bGwgJiYgX29wdGlvbnMkY2FjaGVQb2xpY3lGICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRjYWNoZVBvbGljeUYgOiAndmFsdWUnLFxuICAgIGV2aWN0aW9uOiAna2VlcC1hbGwnXG4gIH0pOyAvLyBTaW1wbGUgYXRvbUZhbWlseSBpbXBsZW1lbnRhdGlvbiB0byBjYWNoZSBpbmRpdmlkdWFsIGF0b21zIGJhc2VkXG4gIC8vIG9uIHRoZSBwYXJhbWV0ZXIgdmFsdWUgZXF1YWxpdHkuXG5cbiAgcmV0dXJuIHBhcmFtcyA9PiB7XG4gICAgdmFyIF9zdGFibGVTdHJpbmdpZnksIF9vcHRpb25zJGVmZmVjdHM7XG5cbiAgICBjb25zdCBjYWNoZWRBdG9tID0gYXRvbUNhY2hlLmdldChwYXJhbXMpO1xuXG4gICAgaWYgKGNhY2hlZEF0b20gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZEF0b207XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgY2FjaGVQb2xpY3lGb3JQYXJhbXNfVU5TVEFCTEUsXG4gICAgICAuLi5hdG9tT3B0aW9uc1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG9wdGlvbnNEZWZhdWx0ID0gJ2RlZmF1bHQnIGluIG9wdGlvbnMgPyAvLyAkRmxvd0lzc3VlW3Byb3AtbWlzc2luZ10gTm8gd2F5IHRvIHJlZmluZSBpbiBGbG93IHRoYXQgcHJvcGVydHkgaXMgbm90IGRlZmluZWRcbiAgICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS10eXBlXSBObyB3YXkgdG8gcmVmaW5lIGluIEZsb3cgdGhhdCBwcm9wZXJ0eSBpcyBub3QgZGVmaW5lZFxuICAgIG9wdGlvbnMuZGVmYXVsdCA6IG5ldyBQcm9taXNlKCgpID0+IHt9KTtcbiAgICBjb25zdCBuZXdBdG9tID0gUmVjb2lsX2F0b20oeyAuLi5hdG9tT3B0aW9ucyxcbiAgICAgIGtleTogYCR7b3B0aW9ucy5rZXl9X18keyhfc3RhYmxlU3RyaW5naWZ5ID0gUmVjb2lsX3N0YWJsZVN0cmluZ2lmeShwYXJhbXMpKSAhPT0gbnVsbCAmJiBfc3RhYmxlU3RyaW5naWZ5ICE9PSB2b2lkIDAgPyBfc3RhYmxlU3RyaW5naWZ5IDogJ3ZvaWQnfWAsXG4gICAgICBkZWZhdWx0OiB0eXBlb2Ygb3B0aW9uc0RlZmF1bHQgPT09ICdmdW5jdGlvbicgPyAvLyBUaGUgZGVmYXVsdCB3YXMgcGFyYW1ldGVyaXplZFxuICAgICAgLy8gRmxvdyBkb2Vzbid0IGtub3cgdGhhdCBUIGlzbid0IGEgZnVuY3Rpb24sIHNvIHdlIG5lZWQgdG8gY2FzZSB0byBhbnlcbiAgICAgIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXVzZV1cbiAgICAgIG9wdGlvbnNEZWZhdWx0KHBhcmFtcykgOiAvLyBEZWZhdWx0IG1heSBiZSBhIHN0YXRpYyB2YWx1ZSwgcHJvbWlzZSwgb3IgUmVjb2lsVmFsdWVcbiAgICAgIG9wdGlvbnNEZWZhdWx0LFxuICAgICAgcmV0YWluZWRCeV9VTlNUQUJMRTogdHlwZW9mIG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRShwYXJhbXMpIDogb3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFLFxuICAgICAgZWZmZWN0czogdHlwZW9mIG9wdGlvbnMuZWZmZWN0cyA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZWZmZWN0cyhwYXJhbXMpIDogdHlwZW9mIG9wdGlvbnMuZWZmZWN0c19VTlNUQUJMRSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZWZmZWN0c19VTlNUQUJMRShwYXJhbXMpIDogKF9vcHRpb25zJGVmZmVjdHMgPSBvcHRpb25zLmVmZmVjdHMpICE9PSBudWxsICYmIF9vcHRpb25zJGVmZmVjdHMgIT09IHZvaWQgMCA/IF9vcHRpb25zJGVmZmVjdHMgOiBvcHRpb25zLmVmZmVjdHNfVU5TVEFCTEUgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAvLyBAZmItb25seTogc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTOiBtYXBTY29wZVJ1bGVzKFxuICAgICAgLy8gQGZiLW9ubHk6IG9wdGlvbnMuc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTLFxuICAgICAgLy8gQGZiLW9ubHk6IHBhcmFtcyxcbiAgICAgIC8vIEBmYi1vbmx5OiApLFxuXG4gICAgfSk7XG4gICAgYXRvbUNhY2hlLnNldChwYXJhbXMsIG5ld0F0b20pO1xuICAgIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQyKG5ld0F0b20ua2V5LCAoKSA9PiB7XG4gICAgICBhdG9tQ2FjaGUuZGVsZXRlKHBhcmFtcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0F0b207XG4gIH07XG59XG5cbnZhciBSZWNvaWxfYXRvbUZhbWlseSA9IGF0b21GYW1pbHk7XG5cbmNvbnN0IHtcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyOiBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkM1xufSA9IFJlY29pbF9Ob2RlO1xuXG5cblxuXG5cbiAvLyBLZWVwIGluIG1pbmQgdGhlIHBhcmFtZXRlciBuZWVkcyB0byBiZSBzZXJpYWxpemFibGUgYXMgYSBjYWhjaGUga2V5XG4vLyB1c2luZyBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5XG5cblxuLy8gQWRkIGEgdW5pcXVlIGluZGV4IHRvIGVhY2ggc2VsZWN0b3IgaW4gY2FzZSB0aGUgY2FjaGUgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4vLyBkdXBsaWNhdGUga2V5cyBiYXNlZCBvbiBlcXVpdmFsZW50IHN0cmluZ2lmaWVkIHBhcmFtZXRlcnNcbmxldCBuZXh0SW5kZXggPSAwO1xuLyogZXNsaW50LWRpc2FibGUgbm8tcmVkZWNsYXJlICovXG5cbi8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBtZW1iZXJzIG9mIGEgZmFtaWx5IG9mIHNlbGVjdG9ycyBvZiB0aGUgc2FtZSB0eXBlXG4vLyBFLmcuLFxuLy9cbi8vIGNvbnN0IHMgPSBzZWxlY3RvckZhbWlseSguLi4pO1xuLy8gcyh7YTogMX0pID0+IGEgc2VsZWN0b3Jcbi8vIHMoe2E6IDJ9KSA9PiBhIGRpZmZlcmVudCBzZWxlY3RvclxuLy9cbi8vIEJ5IGRlZmF1bHQsIHRoZSBzZWxlY3RvcnMgYXJlIGRpc3Rpbmd1aXNoZWQgYnkgZGlzdGluY3QgdmFsdWVzIG9mIHRoZVxuLy8gcGFyYW1ldGVyIGJhc2VkIG9uIHZhbHVlIGVxdWFsaXR5LCBub3QgcmVmZXJlbmNlIGVxdWFsaXR5LiAgVGhpcyBhbGxvd3MgdXNpbmdcbi8vIG9iamVjdCBsaXRlcmFscyBvciBvdGhlciBlcXVpdmFsZW50IG9iamVjdHMgYXQgY2FsbHNpdGVzIHRvIG5vdCBjcmVhdGVcbi8vIGR1cGxpY2F0ZSBjYWNoZSBlbnRyaWVzLiAgVGhpcyBiZWhhdmlvciBtYXkgYmUgb3ZlcnJpZGRlbiB3aXRoIHRoZVxuLy8gY2FjaGVJbXBsZW1lbnRhdGlvbkZvclBhcmFtcyBvcHRpb24uXG5mdW5jdGlvbiBzZWxlY3RvckZhbWlseShvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRjYWNoZVBvbGljeUYsIF9vcHRpb25zJGNhY2hlUG9saWN5RjI7XG5cbiAgY29uc3Qgc2VsZWN0b3JDYWNoZSA9IFJlY29pbF9jYWNoZUZyb21Qb2xpY3koe1xuICAgIGVxdWFsaXR5OiAoX29wdGlvbnMkY2FjaGVQb2xpY3lGID0gKF9vcHRpb25zJGNhY2hlUG9saWN5RjIgPSBvcHRpb25zLmNhY2hlUG9saWN5Rm9yUGFyYW1zX1VOU1RBQkxFKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRjYWNoZVBvbGljeUYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRjYWNoZVBvbGljeUYyLmVxdWFsaXR5KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRjYWNoZVBvbGljeUYgIT09IHZvaWQgMCA/IF9vcHRpb25zJGNhY2hlUG9saWN5RiA6ICd2YWx1ZScsXG4gICAgZXZpY3Rpb246ICdrZWVwLWFsbCdcbiAgfSk7XG4gIHJldHVybiBwYXJhbXMgPT4ge1xuICAgIHZhciBfc3RhYmxlU3RyaW5naWZ5O1xuXG4gICAgLy8gVGhyb3cgYW4gZXJyb3Igd2l0aCBzZWxlY3RvciBrZXkgc28gdGhhdCBpdCBpcyBjbGVhciB3aGljaFxuICAgIC8vIHNlbGVjdG9yIGlzIGNhdXNpbmcgYW4gZXJyb3JcbiAgICBsZXQgY2FjaGVkU2VsZWN0b3I7XG5cbiAgICB0cnkge1xuICAgICAgY2FjaGVkU2VsZWN0b3IgPSBzZWxlY3RvckNhY2hlLmdldChwYXJhbXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKGBQcm9ibGVtIHdpdGggY2FjaGUgbG9va3VwIGZvciBzZWxlY3RvciAke29wdGlvbnMua2V5fTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cblxuICAgIGlmIChjYWNoZWRTZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkU2VsZWN0b3I7XG4gICAgfVxuXG4gICAgY29uc3QgbXlLZXkgPSBgJHtvcHRpb25zLmtleX1fX3NlbGVjdG9yRmFtaWx5LyR7KF9zdGFibGVTdHJpbmdpZnkgPSBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5KHBhcmFtcywge1xuICAgICAgLy8gSXQgaXMgcG9zc2libGUgdG8gdXNlIGZ1bmN0aW9ucyBpbiBwYXJhbWV0ZXJzIGlmIHRoZSB1c2VyIHVzZXNcbiAgICAgIC8vIGEgY2FjaGUgd2l0aCByZWZlcmVuY2UgZXF1YWxpdHkgdGhhbmtzIHRvIHRoZSBpbmNyZW1lbnRpbmcgaW5kZXguXG4gICAgICBhbGxvd0Z1bmN0aW9uczogdHJ1ZVxuICAgIH0pKSAhPT0gbnVsbCAmJiBfc3RhYmxlU3RyaW5naWZ5ICE9PSB2b2lkIDAgPyBfc3RhYmxlU3RyaW5naWZ5IDogJ3ZvaWQnfS8ke25leHRJbmRleCsrfWA7IC8vIEFwcGVuZCBpbmRleCBpbiBjYXNlIHZhbHVlcyBzZXJpYWxpemUgdG8gdGhlIHNhbWUga2V5IHN0cmluZ1xuXG4gICAgY29uc3QgbXlHZXQgPSBjYWxsYmFja3MgPT4gb3B0aW9ucy5nZXQocGFyYW1zKShjYWxsYmFja3MpO1xuXG4gICAgY29uc3QgbXlDYWNoZVBvbGljeSA9IG9wdGlvbnMuY2FjaGVQb2xpY3lfVU5TVEFCTEU7XG4gICAgY29uc3QgcmV0YWluZWRCeSA9IHR5cGVvZiBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUocGFyYW1zKSA6IG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRTtcbiAgICBsZXQgbmV3U2VsZWN0b3I7XG5cbiAgICBpZiAob3B0aW9ucy5zZXQgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2V0ID0gb3B0aW9ucy5zZXQ7XG5cbiAgICAgIGNvbnN0IG15U2V0ID0gKGNhbGxiYWNrcywgbmV3VmFsdWUpID0+IHNldChwYXJhbXMpKGNhbGxiYWNrcywgbmV3VmFsdWUpO1xuXG4gICAgICBuZXdTZWxlY3RvciA9IFJlY29pbF9zZWxlY3Rvcih7XG4gICAgICAgIGtleTogbXlLZXksXG4gICAgICAgIGdldDogbXlHZXQsXG4gICAgICAgIHNldDogbXlTZXQsXG4gICAgICAgIGNhY2hlUG9saWN5X1VOU1RBQkxFOiBteUNhY2hlUG9saWN5LFxuICAgICAgICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSxcbiAgICAgICAgcmV0YWluZWRCeV9VTlNUQUJMRTogcmV0YWluZWRCeVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1NlbGVjdG9yID0gUmVjb2lsX3NlbGVjdG9yKHtcbiAgICAgICAga2V5OiBteUtleSxcbiAgICAgICAgZ2V0OiBteUdldCxcbiAgICAgICAgY2FjaGVQb2xpY3lfVU5TVEFCTEU6IG15Q2FjaGVQb2xpY3ksXG4gICAgICAgIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiBvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5LFxuICAgICAgICByZXRhaW5lZEJ5X1VOU1RBQkxFOiByZXRhaW5lZEJ5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzZWxlY3RvckNhY2hlLnNldChwYXJhbXMsIG5ld1NlbGVjdG9yKTtcbiAgICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMyhuZXdTZWxlY3Rvci5rZXksICgpID0+IHtcbiAgICAgIHNlbGVjdG9yQ2FjaGUuZGVsZXRlKHBhcmFtcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld1NlbGVjdG9yO1xuICB9O1xufVxuLyogZXNsaW50LWVuYWJsZSBuby1yZWRlY2xhcmUgKi9cblxuXG52YXIgUmVjb2lsX3NlbGVjdG9yRmFtaWx5ID0gc2VsZWN0b3JGYW1pbHk7XG5cbi8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cblxuY29uc3QgY29uc3RhbnRTZWxlY3RvciA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XG4gIGtleTogJ19fY29uc3RhbnQnLFxuICBnZXQ6IGNvbnN0YW50ID0+ICgpID0+IGNvbnN0YW50LFxuICBjYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRToge1xuICAgIGVxdWFsaXR5OiAncmVmZXJlbmNlJ1xuICB9XG59KTsgLy8gRnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2VsZWN0b3Igd2hpY2ggYWx3YXlzIHByb2R1Y2VzIHRoZVxuLy8gc2FtZSBjb25zdGFudCB2YWx1ZS4gIEl0IG1heSBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aCB0aGVcbi8vIHNhbWUgdmFsdWUsIGJhc2VkIG9uIHJlZmVyZW5jZSBlcXVhbGl0eSwgYW5kIHdpbGwgcHJvdmlkZSB0aGVcbi8vIHNhbWUgc2VsZWN0b3IuXG5cbmZ1bmN0aW9uIGNvbnN0U2VsZWN0b3IoY29uc3RhbnQpIHtcbiAgcmV0dXJuIGNvbnN0YW50U2VsZWN0b3IoY29uc3RhbnQpO1xufVxuXG52YXIgUmVjb2lsX2NvbnN0U2VsZWN0b3IgPSBjb25zdFNlbGVjdG9yO1xuXG4vLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG5cbmNvbnN0IHRocm93aW5nU2VsZWN0b3IgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xuICBrZXk6ICdfX2Vycm9yJyxcbiAgZ2V0OiBtZXNzYWdlID0+ICgpID0+IHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKG1lc3NhZ2UpO1xuICB9LFxuICAvLyBUT0RPIFdoeT9cbiAgY2FjaGVQb2xpY3lGb3JQYXJhbXNfVU5TVEFCTEU6IHtcbiAgICBlcXVhbGl0eTogJ3JlZmVyZW5jZSdcbiAgfVxufSk7IC8vIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNlbGVjdG9yIHdoaWNoIGFsd2F5cyB0aHJvd3MgYW4gZXJyb3Jcbi8vIHdpdGggdGhlIHByb3ZpZGVkIG1lc3NhZ2UuXG5cbmZ1bmN0aW9uIGVycm9yU2VsZWN0b3IobWVzc2FnZSkge1xuICByZXR1cm4gdGhyb3dpbmdTZWxlY3RvcihtZXNzYWdlKTtcbn1cblxudmFyIFJlY29pbF9lcnJvclNlbGVjdG9yID0gZXJyb3JTZWxlY3RvcjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBXcmFwcyBhbm90aGVyIHJlY29pbCB2YWx1ZSBhbmQgcHJldmVudHMgd3JpdGluZyB0byBpdC5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gcmVhZE9ubHlTZWxlY3RvcihhdG9tKSB7XG4gIC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxuICByZXR1cm4gYXRvbTtcbn1cblxudmFyIFJlY29pbF9yZWFkT25seVNlbGVjdG9yID0gcmVhZE9ubHlTZWxlY3RvcjtcblxuY29uc3Qge1xuICBsb2FkYWJsZVdpdGhFcnJvcjogbG9hZGFibGVXaXRoRXJyb3IkMyxcbiAgbG9hZGFibGVXaXRoUHJvbWlzZTogbG9hZGFibGVXaXRoUHJvbWlzZSQzLFxuICBsb2FkYWJsZVdpdGhWYWx1ZTogbG9hZGFibGVXaXRoVmFsdWUkNFxufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xuXG5cblxuXG5cbiAvLy8vLy8vLy8vLy8vLy8vL1xuLy8gIFRSVVRIIFRBQkxFXG4vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRGVwZW5kZW5jaWVzICAgICAgICB3YWl0Rm9yTm9uZSAgICAgICAgIHdhaXRGb3JBbnkgICAgICAgIHdhaXRGb3JBbGwgICAgICAgd2FpdEZvckFsbFNldHRsZWRcbi8vICBbbG9hZGluZywgbG9hZGluZ10gIFtQcm9taXNlLCBQcm9taXNlXSAgUHJvbWlzZSAgICAgICAgICAgUHJvbWlzZSAgICAgICAgIFByb21pc2Vcbi8vICBbdmFsdWUsIGxvYWRpbmddICAgIFt2YWx1ZSwgUHJvbWlzZV0gICAgW3ZhbHVlLCBQcm9taXNlXSAgUHJvbWlzZSAgICAgICAgIFByb21pc2Vcbi8vICBbdmFsdWUsIHZhbHVlXSAgICAgIFt2YWx1ZSwgdmFsdWVdICAgICAgW3ZhbHVlLCB2YWx1ZV0gICAgW3ZhbHVlLCB2YWx1ZV0gIFt2YWx1ZSwgdmFsdWVdXG4vL1xuLy8gIFtlcnJvciwgbG9hZGluZ10gICAgW0Vycm9yLCBQcm9taXNlXSAgICBbRXJyb3IsIFByb21pc2VdICBFcnJvciAgICAgICAgICAgUHJvbWlzZVxuLy8gIFtlcnJvciwgZXJyb3JdICAgICAgW0Vycm9yLCBFcnJvcl0gICAgICBbRXJyb3IsIEVycm9yXSAgICBFcnJvciAgICAgICAgICAgW2Vycm9yLCBlcnJvcl1cbi8vICBbdmFsdWUsIGVycm9yXSAgICAgIFt2YWx1ZSwgRXJyb3JdICAgICAgW3ZhbHVlLCBFcnJvcl0gICAgRXJyb3IgICAgICAgICAgIFt2YWx1ZSwgZXJyb3JdXG4vLyBJc3N1ZSBwYXJhbGxlbCByZXF1ZXN0cyBmb3IgYWxsIGRlcGVuZGVuY2llcyBhbmQgcmV0dXJuIHRoZSBjdXJyZW50XG4vLyBzdGF0dXMgaWYgdGhleSBoYXZlIHJlc3VsdHMsIGhhdmUgc29tZSBlcnJvciwgb3IgYXJlIHN0aWxsIHBlbmRpbmcuXG5cblxuZnVuY3Rpb24gY29uY3VycmVudFJlcXVlc3RzKGdldFJlY29pbFZhbHVlLCBkZXBzKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBBcnJheShkZXBzLmxlbmd0aCkuZmlsbCh1bmRlZmluZWQpO1xuICBjb25zdCBleGNlcHRpb25zID0gQXJyYXkoZGVwcy5sZW5ndGgpLmZpbGwodW5kZWZpbmVkKTtcblxuICBmb3IgKGNvbnN0IFtpLCBkZXBdIG9mIGRlcHMuZW50cmllcygpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdHNbaV0gPSBnZXRSZWNvaWxWYWx1ZShkZXApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGV4Y2VwdGlvbnMgY2FuIGVpdGhlciBiZSBQcm9taXNlcyBvZiBwZW5kaW5nIHJlc3VsdHMgb3IgcmVhbCBlcnJvcnNcbiAgICAgIGV4Y2VwdGlvbnNbaV0gPSBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbcmVzdWx0cywgZXhjZXB0aW9uc107XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZXhwKSB7XG4gIHJldHVybiBleHAgIT0gbnVsbCAmJiAhUmVjb2lsX2lzUHJvbWlzZShleHApO1xufVxuXG5mdW5jdGlvbiB1bndyYXBEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRlcGVuZGVuY2llcykgPyBkZXBlbmRlbmNpZXMgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZXBlbmRlbmNpZXMpLm1hcChrZXkgPT4gZGVwZW5kZW5jaWVzW2tleV0pO1xufVxuXG5mdW5jdGlvbiB3cmFwUmVzdWx0cyhkZXBlbmRlbmNpZXMsXG4vKiAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdIFRoZSB0eXBlIGFubm90YXRpb24ocykgcmVxdWlyZWQgYnkgRmxvdydzXG4gKiBMVEkgdXBkYXRlIGNvdWxkIG5vdCBiZSBhZGRlZCB2aWEgY29kZW1vZCAqL1xucmVzdWx0cykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkZXBlbmRlbmNpZXMpID8gcmVzdWx0cyA6IC8vIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCkgaGFzIGNvbnNpc3RlbnQga2V5IG9yZGVyaW5nIHdpdGggRVM2XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRlcGVuZGVuY2llcykucmVkdWNlKChvdXQsIGtleSwgaWR4KSA9PiAoeyAuLi5vdXQsXG4gICAgW2tleV06IHJlc3VsdHNbaWR4XVxuICB9KSwge30pO1xufVxuXG5mdW5jdGlvbiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucykge1xuICBjb25zdCBvdXRwdXQgPSBleGNlcHRpb25zLm1hcCgoZXhjZXB0aW9uLCBpZHgpID0+IGV4Y2VwdGlvbiA9PSBudWxsID8gbG9hZGFibGVXaXRoVmFsdWUkNChyZXN1bHRzW2lkeF0pIDogUmVjb2lsX2lzUHJvbWlzZShleGNlcHRpb24pID8gbG9hZGFibGVXaXRoUHJvbWlzZSQzKGV4Y2VwdGlvbikgOiBsb2FkYWJsZVdpdGhFcnJvciQzKGV4Y2VwdGlvbikpO1xuICByZXR1cm4gd3JhcFJlc3VsdHMoZGVwZW5kZW5jaWVzLCBvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lQXN5bmNSZXN1bHRzV2l0aFN5bmNSZXN1bHRzKHN5bmNSZXN1bHRzLCBhc3luY1Jlc3VsdHMpIHtcbiAgcmV0dXJuIGFzeW5jUmVzdWx0cy5tYXAoKHJlc3VsdCwgaWR4KSA9PlxuICAvKipcbiAgICogaXQncyBpbXBvcnRhbnQgd2UgdXNlID09PSB1bmRlZmluZWQgYXMgb3Bwb3NlZCB0byA9PSBudWxsLCBiZWNhdXNlIHRoZVxuICAgKiByZXNvbHZlZCB2YWx1ZSBvZiB0aGUgYXN5bmMgcHJvbWlzZSBjb3VsZCBiZSBgbnVsbGAsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICogZG9uJ3Qgd2FudCB0byB1c2Ugc3luY1Jlc3VsdHNbaWR4XSwgd2hpY2ggd291bGQgYmUgdW5kZWZpbmVkLiBJZiBhc3luY1xuICAgKiBwcm9taXNlIHJlc29sdmVzIHRvIGB1bmRlZmluZWRgLCB0aGF0J3Mgb2sgYmVjYXVzZSBgc3luY1Jlc3VsdHNbaWR4XWBcbiAgICogd2lsbCBhbHNvIGJlIGB1bmRlZmluZWRgLiBUaGF0J3MgYSBsaXR0bGUgaGFja3ksIGJ1dCBpdCB3b3Jrcy5cbiAgICovXG4gIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gc3luY1Jlc3VsdHNbaWR4XSA6IHJlc3VsdCk7XG59IC8vIFNlbGVjdG9yIHRoYXQgcmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbCBhbmQgaW1tZWRpYXRlbHkgcmV0dXJuc1xuLy8gY3VycmVudCByZXN1bHRzIHdpdGhvdXQgd2FpdGluZy5cblxuXG5jb25zdCB3YWl0Rm9yTm9uZSA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XG4gIGtleTogJ19fd2FpdEZvck5vbmUnLFxuICBnZXQ6IGRlcGVuZGVuY2llcyA9PiAoe1xuICAgIGdldFxuICB9KSA9PiB7XG4gICAgLy8gSXNzdWUgcmVxdWVzdHMgZm9yIGFsbCBkZXBlbmRlbmNpZXMgaW4gcGFyYWxsZWwuXG4gICAgY29uc3QgZGVwcyA9IHVud3JhcERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpO1xuICAgIGNvbnN0IFtyZXN1bHRzLCBleGNlcHRpb25zXSA9IGNvbmN1cnJlbnRSZXF1ZXN0cyhnZXQsIGRlcHMpOyAvLyBBbHdheXMgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgcmVzdWx0czsgbmV2ZXIgYmxvY2suXG5cbiAgICByZXR1cm4gd3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpO1xuICB9LFxuICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogdHJ1ZVxufSk7IC8vIFNlbGVjdG9yIHRoYXQgcmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbCBhbmQgd2FpdHMgZm9yIGF0IGxlYXN0XG4vLyBvbmUgdG8gYmUgYXZhaWxhYmxlIGJlZm9yZSByZXR1cm5pbmcgcmVzdWx0cy4gIEl0IHdpbGwgb25seSBlcnJvciBpZiBhbGxcbi8vIGRlcGVuZGVuY2llcyBoYXZlIGVycm9ycy5cblxuY29uc3Qgd2FpdEZvckFueSA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XG4gIGtleTogJ19fd2FpdEZvckFueScsXG4gIGdldDogZGVwZW5kZW5jaWVzID0+ICh7XG4gICAgZ2V0XG4gIH0pID0+IHtcbiAgICAvLyBJc3N1ZSByZXF1ZXN0cyBmb3IgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbC5cbiAgICAvLyBFeGNlcHRpb25zIGNhbiBlaXRoZXIgYmUgUHJvbWlzZXMgb2YgcGVuZGluZyByZXN1bHRzIG9yIHJlYWwgZXJyb3JzXG4gICAgY29uc3QgZGVwcyA9IHVud3JhcERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpO1xuICAgIGNvbnN0IFtyZXN1bHRzLCBleGNlcHRpb25zXSA9IGNvbmN1cnJlbnRSZXF1ZXN0cyhnZXQsIGRlcHMpOyAvLyBJZiBhbnkgcmVzdWx0cyBhcmUgYXZhaWxhYmxlLCB2YWx1ZSBvciBlcnJvciwgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXR1c1xuXG4gICAgaWYgKGV4Y2VwdGlvbnMuc29tZShleHAgPT4gIVJlY29pbF9pc1Byb21pc2UoZXhwKSkpIHtcbiAgICAgIHJldHVybiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucyk7XG4gICAgfSAvLyBPdGhlcndpc2UsIHJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiB0aGUgbmV4dCByZXN1bHQgaXNcbiAgICAvLyBhdmFpbGFibGUsIHdoaWNoZXZlciBvbmUgaGFwcGVucyB0byBiZSBuZXh0LiAgQnV0LCBpZiBhbGwgcGVuZGluZ1xuICAgIC8vIGRlcGVuZGVuY2llcyBlbmQgdXAgd2l0aCBlcnJvcnMsIHRoZW4gcmVqZWN0IHRoZSBwcm9taXNlLlxuXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IFtpLCBleHBdIG9mIGV4Y2VwdGlvbnMuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKGV4cCkpIHtcbiAgICAgICAgICBleHAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGV4Y2VwdGlvbnNbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXNvbHZlKHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKSk7XG4gICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgZXhjZXB0aW9uc1tpXSA9IGVycm9yO1xuICAgICAgICAgICAgcmVzb2x2ZSh3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucykpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiB0cnVlXG59KTsgLy8gU2VsZWN0b3IgdGhhdCByZXF1ZXN0cyBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsIGFuZCB3YWl0cyBmb3IgYWxsIHRvIGJlXG4vLyBhdmFpbGFibGUgYmVmb3JlIHJldHVybmluZyBhIHZhbHVlLiAgSXQgd2lsbCBlcnJvciBpZiBhbnkgZGVwZW5kZW5jaWVzIGVycm9yLlxuXG5jb25zdCB3YWl0Rm9yQWxsID0gUmVjb2lsX3NlbGVjdG9yRmFtaWx5KHtcbiAga2V5OiAnX193YWl0Rm9yQWxsJyxcbiAgZ2V0OiBkZXBlbmRlbmNpZXMgPT4gKHtcbiAgICBnZXRcbiAgfSkgPT4ge1xuICAgIC8vIElzc3VlIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsLlxuICAgIC8vIEV4Y2VwdGlvbnMgY2FuIGVpdGhlciBiZSBQcm9taXNlcyBvZiBwZW5kaW5nIHJlc3VsdHMgb3IgcmVhbCBlcnJvcnNcbiAgICBjb25zdCBkZXBzID0gdW53cmFwRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgW3Jlc3VsdHMsIGV4Y2VwdGlvbnNdID0gY29uY3VycmVudFJlcXVlc3RzKGdldCwgZGVwcyk7IC8vIElmIGFsbCByZXN1bHRzIGFyZSBhdmFpbGFibGUsIHJldHVybiB0aGUgcmVzdWx0c1xuXG4gICAgaWYgKGV4Y2VwdGlvbnMuZXZlcnkoZXhwID0+IGV4cCA9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIHdyYXBSZXN1bHRzKGRlcGVuZGVuY2llcywgcmVzdWx0cyk7XG4gICAgfSAvLyBJZiB3ZSBoYXZlIGFueSBlcnJvcnMsIHRocm93IHRoZSBmaXJzdCBlcnJvclxuXG5cbiAgICBjb25zdCBlcnJvciA9IGV4Y2VwdGlvbnMuZmluZChpc0Vycm9yKTtcblxuICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IC8vIE90aGVyd2lzZSwgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIGFsbCByZXN1bHRzIGFyZSBhdmFpbGFibGVcblxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGV4Y2VwdGlvbnMpLnRoZW4oZXhjZXB0aW9uUmVzdWx0cyA9PiB3cmFwUmVzdWx0cyhkZXBlbmRlbmNpZXMsIGNvbWJpbmVBc3luY1Jlc3VsdHNXaXRoU3luY1Jlc3VsdHMocmVzdWx0cywgZXhjZXB0aW9uUmVzdWx0cykpKTtcbiAgfSxcbiAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IHRydWVcbn0pO1xuY29uc3Qgd2FpdEZvckFsbFNldHRsZWQgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xuICBrZXk6ICdfX3dhaXRGb3JBbGxTZXR0bGVkJyxcbiAgZ2V0OiBkZXBlbmRlbmNpZXMgPT4gKHtcbiAgICBnZXRcbiAgfSkgPT4ge1xuICAgIC8vIElzc3VlIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsLlxuICAgIC8vIEV4Y2VwdGlvbnMgY2FuIGVpdGhlciBiZSBQcm9taXNlcyBvZiBwZW5kaW5nIHJlc3VsdHMgb3IgcmVhbCBlcnJvcnNcbiAgICBjb25zdCBkZXBzID0gdW53cmFwRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgW3Jlc3VsdHMsIGV4Y2VwdGlvbnNdID0gY29uY3VycmVudFJlcXVlc3RzKGdldCwgZGVwcyk7IC8vIElmIGFsbCByZXN1bHRzIGFyZSBhdmFpbGFibGUsIHJldHVybiB0aGUgcmVzdWx0c1xuXG4gICAgaWYgKGV4Y2VwdGlvbnMuZXZlcnkoZXhwID0+ICFSZWNvaWxfaXNQcm9taXNlKGV4cCkpKSB7XG4gICAgICByZXR1cm4gd3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpO1xuICAgIH0gLy8gV2FpdCBmb3IgYWxsIHJlc3VsdHMgdG8gc2V0dGxlXG5cblxuICAgIHJldHVybiBQcm9taXNlLmFsbChleGNlcHRpb25zLm1hcCgoZXhwLCBpKSA9PiBSZWNvaWxfaXNQcm9taXNlKGV4cCkgPyBleHAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgcmVzdWx0c1tpXSA9IHJlc3VsdDtcbiAgICAgIGV4Y2VwdGlvbnNbaV0gPSB1bmRlZmluZWQ7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgcmVzdWx0c1tpXSA9IHVuZGVmaW5lZDtcbiAgICAgIGV4Y2VwdGlvbnNbaV0gPSBlcnJvcjtcbiAgICB9KSA6IG51bGwpKSAvLyBUaGVuIHdyYXAgdGhlbSBhcyBsb2FkYWJsZXNcbiAgICAudGhlbigoKSA9PiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucykpO1xuICB9LFxuICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogdHJ1ZVxufSk7XG5jb25zdCBub1dhaXQgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xuICBrZXk6ICdfX25vV2FpdCcsXG4gIGdldDogZGVwZW5kZW5jeSA9PiAoe1xuICAgIGdldFxuICB9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBSZWNvaWxfc2VsZWN0b3IudmFsdWUobG9hZGFibGVXaXRoVmFsdWUkNChnZXQoZGVwZW5kZW5jeSkpKTtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgIHJldHVybiBSZWNvaWxfc2VsZWN0b3IudmFsdWUoUmVjb2lsX2lzUHJvbWlzZShleGNlcHRpb24pID8gbG9hZGFibGVXaXRoUHJvbWlzZSQzKGV4Y2VwdGlvbikgOiBsb2FkYWJsZVdpdGhFcnJvciQzKGV4Y2VwdGlvbikpO1xuICAgIH1cbiAgfSxcbiAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IHRydWVcbn0pO1xudmFyIFJlY29pbF9XYWl0Rm9yID0ge1xuICB3YWl0Rm9yTm9uZSxcbiAgd2FpdEZvckFueSxcbiAgd2FpdEZvckFsbCxcbiAgd2FpdEZvckFsbFNldHRsZWQsXG4gIG5vV2FpdFxufTtcblxuY29uc3Qge1xuICBSZWNvaWxMb2FkYWJsZVxufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xuXG5jb25zdCB7XG4gIERlZmF1bHRWYWx1ZTogRGVmYXVsdFZhbHVlJDNcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBSZWNvaWxSb290OiBSZWNvaWxSb290JDIsXG4gIHVzZVJlY29pbFN0b3JlSUQ6IHVzZVJlY29pbFN0b3JlSUQkMVxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkNVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xuXG5jb25zdCB7XG4gIHJldGVudGlvblpvbmU6IHJldGVudGlvblpvbmUkMVxufSA9IFJlY29pbF9SZXRlbnRpb25ab25lO1xuXG5jb25zdCB7XG4gIGZyZXNoU25hcHNob3Q6IGZyZXNoU25hcHNob3QkMlxufSA9IFJlY29pbF9TbmFwc2hvdCQxO1xuXG5jb25zdCB7XG4gIHVzZVJlY29pbFN0YXRlOiB1c2VSZWNvaWxTdGF0ZSQxLFxuICB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlOiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlJDEsXG4gIHVzZVJlY29pbFZhbHVlOiB1c2VSZWNvaWxWYWx1ZSQxLFxuICB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlJDEsXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICB1c2VSZXNldFJlY29pbFN0YXRlOiB1c2VSZXNldFJlY29pbFN0YXRlJDEsXG4gIHVzZVNldFJlY29pbFN0YXRlOiB1c2VTZXRSZWNvaWxTdGF0ZSQxXG59ID0gUmVjb2lsX0hvb2tzO1xuXG5jb25zdCB7XG4gIHVzZUdvdG9SZWNvaWxTbmFwc2hvdDogdXNlR290b1JlY29pbFNuYXBzaG90JDEsXG4gIHVzZVJlY29pbFNuYXBzaG90OiB1c2VSZWNvaWxTbmFwc2hvdCQxLFxuICB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyOiB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyJDFcbn0gPSBSZWNvaWxfU25hcHNob3RIb29rcztcblxuXG5cblxuXG5jb25zdCB7XG4gIHVzZVJlY29pbENhbGxiYWNrOiB1c2VSZWNvaWxDYWxsYmFjayQxXG59ID0gUmVjb2lsX3VzZVJlY29pbENhbGxiYWNrO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3Qge1xuICBub1dhaXQ6IG5vV2FpdCQxLFxuICB3YWl0Rm9yQWxsOiB3YWl0Rm9yQWxsJDEsXG4gIHdhaXRGb3JBbGxTZXR0bGVkOiB3YWl0Rm9yQWxsU2V0dGxlZCQxLFxuICB3YWl0Rm9yQW55OiB3YWl0Rm9yQW55JDEsXG4gIHdhaXRGb3JOb25lOiB3YWl0Rm9yTm9uZSQxXG59ID0gUmVjb2lsX1dhaXRGb3I7XG5cbnZhciBSZWNvaWxfaW5kZXggPSB7XG4gIC8vIFR5cGVzXG4gIERlZmF1bHRWYWx1ZTogRGVmYXVsdFZhbHVlJDMsXG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkNSxcbiAgUmVjb2lsTG9hZGFibGUsXG4gIC8vIFJlY29pbCBSb290XG4gIFJlY29pbFJvb3Q6IFJlY29pbFJvb3QkMixcbiAgdXNlUmVjb2lsU3RvcmVJRDogdXNlUmVjb2lsU3RvcmVJRCQxLFxuICB1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzX1VOU1RBQkxFOiBSZWNvaWxfdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cyxcbiAgLy8gQXRvbXMvU2VsZWN0b3JzXG4gIGF0b206IFJlY29pbF9hdG9tLFxuICBzZWxlY3RvcjogUmVjb2lsX3NlbGVjdG9yLFxuICAvLyBDb252ZW5pZW5jZSBBdG9tcy9TZWxlY3RvcnNcbiAgYXRvbUZhbWlseTogUmVjb2lsX2F0b21GYW1pbHksXG4gIHNlbGVjdG9yRmFtaWx5OiBSZWNvaWxfc2VsZWN0b3JGYW1pbHksXG4gIGNvbnN0U2VsZWN0b3I6IFJlY29pbF9jb25zdFNlbGVjdG9yLFxuICBlcnJvclNlbGVjdG9yOiBSZWNvaWxfZXJyb3JTZWxlY3RvcixcbiAgcmVhZE9ubHlTZWxlY3RvcjogUmVjb2lsX3JlYWRPbmx5U2VsZWN0b3IsXG4gIC8vIENvbmN1cnJlbmN5IEhlbHBlcnMgZm9yIEF0b21zL1NlbGVjdG9yc1xuICBub1dhaXQ6IG5vV2FpdCQxLFxuICB3YWl0Rm9yTm9uZTogd2FpdEZvck5vbmUkMSxcbiAgd2FpdEZvckFueTogd2FpdEZvckFueSQxLFxuICB3YWl0Rm9yQWxsOiB3YWl0Rm9yQWxsJDEsXG4gIHdhaXRGb3JBbGxTZXR0bGVkOiB3YWl0Rm9yQWxsU2V0dGxlZCQxLFxuICAvLyBIb29rcyBmb3IgQXRvbXMvU2VsZWN0b3JzXG4gIHVzZVJlY29pbFZhbHVlOiB1c2VSZWNvaWxWYWx1ZSQxLFxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlJDEsXG4gIHVzZVJlY29pbFN0YXRlOiB1c2VSZWNvaWxTdGF0ZSQxLFxuICB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlOiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlJDEsXG4gIHVzZVNldFJlY29pbFN0YXRlOiB1c2VTZXRSZWNvaWxTdGF0ZSQxLFxuICB1c2VSZXNldFJlY29pbFN0YXRlOiB1c2VSZXNldFJlY29pbFN0YXRlJDEsXG4gIHVzZUdldFJlY29pbFZhbHVlSW5mb19VTlNUQUJMRTogUmVjb2lsX3VzZUdldFJlY29pbFZhbHVlSW5mbyxcbiAgdXNlUmVjb2lsUmVmcmVzaGVyX1VOU1RBQkxFOiBSZWNvaWxfdXNlUmVjb2lsUmVmcmVzaGVyLFxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSxcbiAgdXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFOiB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSxcbiAgdXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFOiB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSxcbiAgLy8gSG9va3MgZm9yIGNvbXBsZXggb3BlcmF0aW9uc1xuICB1c2VSZWNvaWxDYWxsYmFjazogdXNlUmVjb2lsQ2FsbGJhY2skMSxcbiAgdXNlUmVjb2lsVHJhbnNhY3Rpb25fVU5TVEFCTEU6IFJlY29pbF91c2VSZWNvaWxUcmFuc2FjdGlvbixcbiAgLy8gU25hcHNob3RzXG4gIHVzZUdvdG9SZWNvaWxTbmFwc2hvdDogdXNlR290b1JlY29pbFNuYXBzaG90JDEsXG4gIHVzZVJlY29pbFNuYXBzaG90OiB1c2VSZWNvaWxTbmFwc2hvdCQxLFxuICB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyX1VOU1RBQkxFOiB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyJDEsXG4gIHNuYXBzaG90X1VOU1RBQkxFOiBmcmVzaFNuYXBzaG90JDIsXG4gIC8vIE1lbW9yeSBNYW5hZ2VtZW50XG4gIHVzZVJldGFpbjogUmVjb2lsX3VzZVJldGFpbixcbiAgcmV0ZW50aW9uWm9uZTogcmV0ZW50aW9uWm9uZSQxXG59O1xudmFyIFJlY29pbF9pbmRleF8xID0gUmVjb2lsX2luZGV4LkRlZmF1bHRWYWx1ZTtcbnZhciBSZWNvaWxfaW5kZXhfMiA9IFJlY29pbF9pbmRleC5pc1JlY29pbFZhbHVlO1xudmFyIFJlY29pbF9pbmRleF8zID0gUmVjb2lsX2luZGV4LlJlY29pbExvYWRhYmxlO1xudmFyIFJlY29pbF9pbmRleF80ID0gUmVjb2lsX2luZGV4LlJlY29pbFJvb3Q7XG52YXIgUmVjb2lsX2luZGV4XzUgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU3RvcmVJRDtcbnZhciBSZWNvaWxfaW5kZXhfNiA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF83ID0gUmVjb2lsX2luZGV4LmF0b207XG52YXIgUmVjb2lsX2luZGV4XzggPSBSZWNvaWxfaW5kZXguc2VsZWN0b3I7XG52YXIgUmVjb2lsX2luZGV4XzkgPSBSZWNvaWxfaW5kZXguYXRvbUZhbWlseTtcbnZhciBSZWNvaWxfaW5kZXhfMTAgPSBSZWNvaWxfaW5kZXguc2VsZWN0b3JGYW1pbHk7XG52YXIgUmVjb2lsX2luZGV4XzExID0gUmVjb2lsX2luZGV4LmNvbnN0U2VsZWN0b3I7XG52YXIgUmVjb2lsX2luZGV4XzEyID0gUmVjb2lsX2luZGV4LmVycm9yU2VsZWN0b3I7XG52YXIgUmVjb2lsX2luZGV4XzEzID0gUmVjb2lsX2luZGV4LnJlYWRPbmx5U2VsZWN0b3I7XG52YXIgUmVjb2lsX2luZGV4XzE0ID0gUmVjb2lsX2luZGV4Lm5vV2FpdDtcbnZhciBSZWNvaWxfaW5kZXhfMTUgPSBSZWNvaWxfaW5kZXgud2FpdEZvck5vbmU7XG52YXIgUmVjb2lsX2luZGV4XzE2ID0gUmVjb2lsX2luZGV4LndhaXRGb3JBbnk7XG52YXIgUmVjb2lsX2luZGV4XzE3ID0gUmVjb2lsX2luZGV4LndhaXRGb3JBbGw7XG52YXIgUmVjb2lsX2luZGV4XzE4ID0gUmVjb2lsX2luZGV4LndhaXRGb3JBbGxTZXR0bGVkO1xudmFyIFJlY29pbF9pbmRleF8xOSA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxWYWx1ZTtcbnZhciBSZWNvaWxfaW5kZXhfMjAgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVmFsdWVMb2FkYWJsZTtcbnZhciBSZWNvaWxfaW5kZXhfMjEgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU3RhdGU7XG52YXIgUmVjb2lsX2luZGV4XzIyID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFN0YXRlTG9hZGFibGU7XG52YXIgUmVjb2lsX2luZGV4XzIzID0gUmVjb2lsX2luZGV4LnVzZVNldFJlY29pbFN0YXRlO1xudmFyIFJlY29pbF9pbmRleF8yNCA9IFJlY29pbF9pbmRleC51c2VSZXNldFJlY29pbFN0YXRlO1xudmFyIFJlY29pbF9pbmRleF8yNSA9IFJlY29pbF9pbmRleC51c2VHZXRSZWNvaWxWYWx1ZUluZm9fVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzI2ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFJlZnJlc2hlcl9VTlNUQUJMRTtcbnZhciBSZWNvaWxfaW5kZXhfMjcgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzI4ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTtcbnZhciBSZWNvaWxfaW5kZXhfMjkgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF8zMCA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxDYWxsYmFjaztcbnZhciBSZWNvaWxfaW5kZXhfMzEgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVHJhbnNhY3Rpb25fVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzMyID0gUmVjb2lsX2luZGV4LnVzZUdvdG9SZWNvaWxTbmFwc2hvdDtcbnZhciBSZWNvaWxfaW5kZXhfMzMgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU25hcHNob3Q7XG52YXIgUmVjb2lsX2luZGV4XzM0ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXJfVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzM1ID0gUmVjb2lsX2luZGV4LnNuYXBzaG90X1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF8zNiA9IFJlY29pbF9pbmRleC51c2VSZXRhaW47XG52YXIgUmVjb2lsX2luZGV4XzM3ID0gUmVjb2lsX2luZGV4LnJldGVudGlvblpvbmU7XG5cbmV4cG9ydCBkZWZhdWx0IFJlY29pbF9pbmRleDtcbmV4cG9ydCB7IFJlY29pbF9pbmRleF8xIGFzIERlZmF1bHRWYWx1ZSwgUmVjb2lsX2luZGV4XzMgYXMgUmVjb2lsTG9hZGFibGUsIFJlY29pbF9pbmRleF80IGFzIFJlY29pbFJvb3QsIFJlY29pbF9pbmRleF83IGFzIGF0b20sIFJlY29pbF9pbmRleF85IGFzIGF0b21GYW1pbHksIFJlY29pbF9pbmRleF8xMSBhcyBjb25zdFNlbGVjdG9yLCBSZWNvaWxfaW5kZXhfMTIgYXMgZXJyb3JTZWxlY3RvciwgUmVjb2lsX2luZGV4XzIgYXMgaXNSZWNvaWxWYWx1ZSwgUmVjb2lsX2luZGV4XzE0IGFzIG5vV2FpdCwgUmVjb2lsX2luZGV4XzEzIGFzIHJlYWRPbmx5U2VsZWN0b3IsIFJlY29pbF9pbmRleF8zNyBhcyByZXRlbnRpb25ab25lLCBSZWNvaWxfaW5kZXhfOCBhcyBzZWxlY3RvciwgUmVjb2lsX2luZGV4XzEwIGFzIHNlbGVjdG9yRmFtaWx5LCBSZWNvaWxfaW5kZXhfMzUgYXMgc25hcHNob3RfVU5TVEFCTEUsIFJlY29pbF9pbmRleF8yNSBhcyB1c2VHZXRSZWNvaWxWYWx1ZUluZm9fVU5TVEFCTEUsIFJlY29pbF9pbmRleF8zMiBhcyB1c2VHb3RvUmVjb2lsU25hcHNob3QsIFJlY29pbF9pbmRleF82IGFzIHVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHNfVU5TVEFCTEUsIFJlY29pbF9pbmRleF8zMCBhcyB1c2VSZWNvaWxDYWxsYmFjaywgUmVjb2lsX2luZGV4XzI2IGFzIHVzZVJlY29pbFJlZnJlc2hlcl9VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzMzIGFzIHVzZVJlY29pbFNuYXBzaG90LCBSZWNvaWxfaW5kZXhfMjEgYXMgdXNlUmVjb2lsU3RhdGUsIFJlY29pbF9pbmRleF8yMiBhcyB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlLCBSZWNvaWxfaW5kZXhfMjkgYXMgdXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFLCBSZWNvaWxfaW5kZXhfNSBhcyB1c2VSZWNvaWxTdG9yZUlELCBSZWNvaWxfaW5kZXhfMzQgYXMgdXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlcl9VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzMxIGFzIHVzZVJlY29pbFRyYW5zYWN0aW9uX1VOU1RBQkxFLCBSZWNvaWxfaW5kZXhfMTkgYXMgdXNlUmVjb2lsVmFsdWUsIFJlY29pbF9pbmRleF8yMCBhcyB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlLCBSZWNvaWxfaW5kZXhfMjcgYXMgdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUsIFJlY29pbF9pbmRleF8yOCBhcyB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUsIFJlY29pbF9pbmRleF8yNCBhcyB1c2VSZXNldFJlY29pbFN0YXRlLCBSZWNvaWxfaW5kZXhfMzYgYXMgdXNlUmV0YWluLCBSZWNvaWxfaW5kZXhfMjMgYXMgdXNlU2V0UmVjb2lsU3RhdGUsIFJlY29pbF9pbmRleF8xNyBhcyB3YWl0Rm9yQWxsLCBSZWNvaWxfaW5kZXhfMTggYXMgd2FpdEZvckFsbFNldHRsZWQsIFJlY29pbF9pbmRleF8xNiBhcyB3YWl0Rm9yQW55LCBSZWNvaWxfaW5kZXhfMTUgYXMgd2FpdEZvck5vbmUgfTtcbiJdLCJuYW1lcyI6WyJyZWFjdCIsInJlYWN0RG9tIiwiZXJyIiwibWVzc2FnZSIsImVycm9yIiwiRXJyb3IiLCJzdGFjayIsInVuZGVmaW5lZCIsIl8iLCJlcnJfMSIsIlJlY29pbF9lcnIiLCJpc1Byb21pc2UiLCJwIiwidGhlbiIsIlJlY29pbF9pc1Byb21pc2UiLCJudWxsdGhyb3dzIiwieCIsIlJlY29pbF9udWxsdGhyb3dzIiwiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIkJhc2VMb2FkYWJsZSIsImdldFZhbHVlIiwidG9Qcm9taXNlIiwidmFsdWVNYXliZSIsInZhbHVlT3JUaHJvdyIsInN0YXRlIiwicHJvbWlzZU1heWJlIiwicHJvbWlzZU9yVGhyb3ciLCJlcnJvck1heWJlIiwiZXJyb3JPclRocm93IiwiaXMiLCJvdGhlciIsImNvbnRlbnRzIiwibWFwIiwiX21hcCIsIlZhbHVlTG9hZGFibGUiLCJjb25zdHJ1Y3RvciIsIlByb21pc2UiLCJyZXNvbHZlIiwibmV4dCIsImxvYWRhYmxlV2l0aFByb21pc2UiLCJpc0xvYWRhYmxlIiwibG9hZGFibGVXaXRoVmFsdWUiLCJlIiwibG9hZGFibGVXaXRoRXJyb3IiLCJFcnJvckxvYWRhYmxlIiwicmVqZWN0IiwiTG9hZGluZ0xvYWRhYmxlIiwicHJvbWlzZSIsIm5leHRMb2FkYWJsZSIsImNhdGNoIiwiZnJlZXplIiwibG9hZGFibGVMb2FkaW5nIiwibG9hZGFibGVBbGxBcnJheSIsImlucHV0cyIsImV2ZXJ5IiwiaSIsInNvbWUiLCJmaW5kIiwiYWxsIiwibG9hZGFibGVBbGwiLCJ1bndyYXBlZElucHV0cyIsIkFycmF5IiwiaXNBcnJheSIsImdldE93blByb3BlcnR5TmFtZXMiLCJub3JtYWxpemVkSW5wdXRzIiwib3V0cHV0Iiwib3V0cHV0cyIsInJlZHVjZSIsIm91dCIsImlkeCIsIkxvYWRhYmxlU3RhdGljSW50ZXJmYWNlIiwib2YiLCJsb2FkaW5nIiwiUmVjb2lsX0xvYWRhYmxlIiwiUmVjb2lsTG9hZGFibGUiLCJSZWNvaWxfTG9hZGFibGVfMSIsIlJlY29pbF9Mb2FkYWJsZV8yIiwiUmVjb2lsX0xvYWRhYmxlXzMiLCJSZWNvaWxfTG9hZGFibGVfNCIsIlJlY29pbF9Mb2FkYWJsZV81IiwiUmVjb2lsX0xvYWRhYmxlXzYiLCJSZWNvaWxfTG9hZGFibGVfNyIsIlJlY29pbF9Mb2FkYWJsZSQxIiwiX19wcm90b19fIiwiZ2tzIiwiTWFwIiwic2V0IiwiUmVjb2lsX2dreF9PU1MiLCJnayIsIl9na3MkZ2V0IiwiZ2V0Iiwic2V0UGFzcyIsInNldEZhaWwiLCJjbGVhciIsIlJlY29pbF9na3giLCJfY3JlYXRlTXV0YWJsZVNvdXJjZSIsIl91c2VNdXRhYmxlU291cmNlIiwiX3VzZVN5bmNFeHRlcm5hbFN0b3JlIiwiY3JlYXRlTXV0YWJsZVNvdXJjZSIsInVuc3RhYmxlX2NyZWF0ZU11dGFibGVTb3VyY2UiLCJ1c2VNdXRhYmxlU291cmNlIiwidW5zdGFibGVfdXNlTXV0YWJsZVNvdXJjZSIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwidW5zdGFibGVfdXNlU3luY0V4dGVybmFsU3RvcmUiLCJyZWFjdE1vZGUiLCJtb2RlIiwiZWFybHkiLCJjb25jdXJyZW50Iiwid2luZG93IiwiJGRpc2FibGVSZWNvaWxWYWx1ZU11dGFibGVTb3VyY2VfVEVNUF9IQUNLX0RPX05PVF9VU0UiLCJpc0Zhc3RSZWZyZXNoRW5hYmxlZCIsIlJlY29pbF9SZWFjdE1vZGUiLCJBYnN0cmFjdFJlY29pbFZhbHVlIiwibmV3S2V5IiwidG9KU09OIiwiUmVjb2lsU3RhdGUiLCJSZWNvaWxWYWx1ZVJlYWRPbmx5IiwiaXNSZWNvaWxWYWx1ZSIsIlJlY29pbF9SZWNvaWxWYWx1ZSIsIlJlY29pbF9SZWNvaWxWYWx1ZV8xIiwiUmVjb2lsX1JlY29pbFZhbHVlXzIiLCJSZWNvaWxfUmVjb2lsVmFsdWVfMyIsIlJlY29pbF9SZWNvaWxWYWx1ZV80IiwiUmVjb2lsX1JlY29pbFZhbHVlJDEiLCJzcHJpbnRmIiwiZm9ybWF0IiwiYXJncyIsImluZGV4IiwicmVwbGFjZSIsIlN0cmluZyIsInNwcmludGZfMSIsImV4cGVjdGF0aW9uVmlvbGF0aW9uIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY2FsbCIsIm5hbWUiLCJjb25zb2xlIiwiZXhwZWN0YXRpb25WaW9sYXRpb25fMSIsIlJlY29pbF9leHBlY3RhdGlvblZpb2xhdGlvbiIsIm1hcEl0ZXJhYmxlIiwiaXRlcmFibGUiLCJjYWxsYmFjayIsIlJlY29pbF9tYXBJdGVyYWJsZSIsInJlY292ZXJhYmxlVmlvbGF0aW9uIiwiX3Byb2plY3ROYW1lIiwicmVjb3ZlcmFibGVWaW9sYXRpb25fMSIsIlJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbiIsImlzRmFzdFJlZnJlc2hFbmFibGVkJDEiLCJEZWZhdWx0VmFsdWUiLCJERUZBVUxUX1ZBTFVFIiwibm9kZXMiLCJyZWNvaWxWYWx1ZXMiLCJyZWNvaWxWYWx1ZXNGb3JLZXlzIiwia2V5cyIsInJlZ2lzdGVyTm9kZSIsIm5vZGUiLCJoYXMiLCJ3YXJuIiwicmVjb2lsVmFsdWUiLCJOb2RlTWlzc2luZ0Vycm9yIiwiZ2V0Tm9kZSIsImdldE5vZGVNYXliZSIsImNvbmZpZ0RlbGV0aW9uSGFuZGxlcnMiLCJkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZSIsIl9ub2RlJHNob3VsZERlbGV0ZUNvbiIsInNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZSIsIl9nZXRDb25maWdEZWxldGlvbkhhbiIsImRlbGV0ZSIsImdldENvbmZpZ0RlbGV0aW9uSGFuZGxlciIsInNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciIsImZuIiwiUmVjb2lsX05vZGUiLCJlbnF1ZXVlRXhlY3V0aW9uIiwicyIsImYiLCJSZWNvaWxfUXVldWUiLCJjcmVhdGVDb21tb25qc01vZHVsZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJoYW10XzEiLCJfdHlwZW9mIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJoYW10IiwiU0laRSIsIkJVQ0tFVF9TSVpFIiwiTWF0aCIsInBvdyIsIk1BU0siLCJNQVhfSU5ERVhfTk9ERSIsIk1JTl9BUlJBWV9OT0RFIiwibm90aGluZyIsImNvbnN0YW50IiwiaGFzaCIsInN0ciIsInR5cGUiLCJsZW4iLCJsZW5ndGgiLCJjIiwiY2hhckNvZGVBdCIsInBvcGNvdW50IiwiaGFzaEZyYWdtZW50Iiwic2hpZnQiLCJoIiwidG9CaXRtYXAiLCJmcm9tQml0bWFwIiwiYml0bWFwIiwiYml0IiwiYXJyYXlVcGRhdGUiLCJtdXRhdGUiLCJhdCIsInYiLCJhcnIiLCJhcnJheVNwbGljZU91dCIsIm5ld0xlbiIsImciLCJhcnJheVNwbGljZUluIiwiX2kiLCJMRUFGIiwiQ09MTElTSU9OIiwiSU5ERVgiLCJBUlJBWSIsImVtcHR5IiwiX19oYW10X2lzRW1wdHkiLCJpc0VtcHR5Tm9kZSIsIkxlYWYiLCJlZGl0IiwiX21vZGlmeSIsIkxlYWZfX21vZGlmeSIsIkNvbGxpc2lvbiIsImNoaWxkcmVuIiwiQ29sbGlzaW9uX19tb2RpZnkiLCJJbmRleGVkTm9kZSIsIm1hc2siLCJJbmRleGVkTm9kZV9fbW9kaWZ5IiwiQXJyYXlOb2RlIiwic2l6ZSIsIkFycmF5Tm9kZV9fbW9kaWZ5IiwiaXNMZWFmIiwiZXhwYW5kIiwiZnJhZyIsImNoaWxkIiwic3ViTm9kZXMiLCJjb3VudCIsInBhY2siLCJyZW1vdmVkIiwiZWxlbWVudHMiLCJlbGVtIiwibWVyZ2VMZWF2ZXMiLCJoMSIsIm4xIiwiaDIiLCJuMiIsInN1YkgxIiwic3ViSDIiLCJ1cGRhdGVDb2xsaXNpb25MaXN0Iiwia2V5RXEiLCJsaXN0IiwiayIsIl9uZXdWYWx1ZSIsIm5ld1ZhbHVlIiwiY2FuRWRpdE5vZGUiLCJfdiIsImNhbkVkaXQiLCJpbmR4IiwiZXhpc3RzIiwiY3VycmVudCIsIm5ld0NoaWxkcmVuIiwibmV3Q2hpbGQiLCJlZGl0YWJsZSIsImNvbmZpZyIsInJvb3QiLCJfZWRpdGFibGUiLCJfZWRpdCIsIl9jb25maWciLCJfcm9vdCIsIl9zaXplIiwic2V0VHJlZSIsIm5ld1Jvb3QiLCJuZXdTaXplIiwidHJ5R2V0SGFzaCIsImFsdCIsInRyeUdldCIsImdldEhhc2giLCJoYXNIYXNoIiwiZGVmS2V5Q29tcGFyZSIsInkiLCJtYWtlIiwiaXNFbXB0eSIsIm1vZGlmeUhhc2giLCJOYU4iLCJtb2RpZnkiLCJzZXRIYXNoIiwiZGVsIiwicmVtb3ZlSGFzaCIsImRlbGV0ZUhhc2giLCJyZW1vdmUiLCJiZWdpbk11dGF0aW9uIiwiZW5kTXV0YXRpb24iLCJ0cmFuc2llbnQiLCJhcHBrIiwibGF6eVZpc2l0Q2hpbGRyZW4iLCJsYXp5VmlzaXQiLCJyZXN0IiwiRE9ORSIsImRvbmUiLCJNYXBJdGVyYXRvciIsInYwIiwidmlzaXQiLCJidWlsZFBhaXJzIiwiZW50cmllcyIsImJ1aWxkS2V5cyIsImJ1aWxkVmFsdWVzIiwidmFsdWVzIiwiZm9sZCIsInoiLCJtIiwidG9WaXNpdCIsInBvcCIsInB1c2giLCJmb3JFYWNoIiwiQnVpbHRJbk1hcCIsImV4aXN0aW5nIiwiY2xvbmUiLCJwZXJzaXN0ZW50TWFwIiwidG9NYXAiLCJIYXNoQXJyYXlNYXBwZWRUcmllTWFwIiwiX2hhbXQiLCJSZWNvaWxfUGVyc2lzdGVudE1hcCIsIlJlY29pbF9QZXJzaXN0ZW50TWFwXzEiLCJSZWNvaWxfUGVyc2lzdGVudE1hcCQxIiwiZGlmZmVyZW5jZVNldHMiLCJzZXRzV2l0aFZhbHVlc1RvUmVtb3ZlIiwicmV0IiwiU2V0IiwiRklSU1QiLCJvdGhlclNldCIsImFkZCIsIlJlY29pbF9kaWZmZXJlbmNlU2V0cyIsIm1hcE1hcCIsInJlc3VsdCIsIlJlY29pbF9tYXBNYXAiLCJtYWtlR3JhcGgiLCJub2RlRGVwcyIsIm5vZGVUb05vZGVTdWJzY3JpcHRpb25zIiwiY2xvbmVHcmFwaCIsImdyYXBoIiwibWVyZ2VEZXBzSW50b0dyYXBoIiwibmV3RGVwcyIsIm9sZGVyR3JhcGgiLCJvbGREZXBzIiwiYWRkZWREZXBzIiwiZGVwIiwicmVtb3ZlZERlcHMiLCJzYXZlRGVwc1RvU3RvcmUiLCJkZXBzIiwic3RvcmUiLCJ2ZXJzaW9uIiwiX3N0b3JlU3RhdGUkbmV4dFRyZWUiLCJfc3RvcmVTdGF0ZSRwcmV2aW91c1QiLCJfc3RvcmVTdGF0ZSRwcmV2aW91c1QyIiwiX3N0b3JlU3RhdGUkcHJldmlvdXNUMyIsInN0b3JlU3RhdGUiLCJnZXRTdGF0ZSIsImN1cnJlbnRUcmVlIiwibmV4dFRyZWUiLCJwcmV2aW91c1RyZWUiLCJnZXRHcmFwaCIsImN1cnJlbnRHcmFwaCIsIl9zdG9yZVN0YXRlJG5leHRUcmVlMiIsIm5leHRWZXJzaW9uIiwibmV4dEdyYXBoIiwiUmVjb2lsX0dyYXBoIiwibmV4dFRyZWVTdGF0ZVZlcnNpb24iLCJnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiIsIm5leHRTdG9yZUlEIiwiZ2V0TmV4dFN0b3JlSUQiLCJuZXh0Q29tcG9uZW50SUQiLCJnZXROZXh0Q29tcG9uZW50SUQiLCJSZWNvaWxfS2V5cyIsInBlcnNpc3RlbnRNYXAkMSIsImdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDEiLCJtYWtlRW1wdHlUcmVlU3RhdGUiLCJzdGF0ZUlEIiwidHJhbnNhY3Rpb25NZXRhZGF0YSIsImRpcnR5QXRvbXMiLCJhdG9tVmFsdWVzIiwibm9udmFsaWRhdGVkQXRvbXMiLCJtYWtlRW1wdHlTdG9yZVN0YXRlIiwiY29tbWl0RGVwdGgiLCJrbm93bkF0b21zIiwia25vd25TZWxlY3RvcnMiLCJ0cmFuc2FjdGlvblN1YnNjcmlwdGlvbnMiLCJub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zIiwibm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucyIsInF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVEIiwic3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzIiwiZ3JhcGhzQnlWZXJzaW9uIiwicmV0ZW50aW9uIiwicmVmZXJlbmNlQ291bnRzIiwibm9kZXNSZXRhaW5lZEJ5Wm9uZSIsInJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2UiLCJub2RlQ2xlYW51cEZ1bmN0aW9ucyIsIlJlY29pbF9TdGF0ZSIsIlJldGVudGlvblpvbmUiLCJyZXRlbnRpb25ab25lIiwiUmVjb2lsX1JldGVudGlvblpvbmUiLCJzZXRCeUFkZGluZ1RvU2V0Iiwic2V0QnlEZWxldGluZ0Zyb21TZXQiLCJtYXBCeVNldHRpbmdJbk1hcCIsIm1hcEJ5VXBkYXRpbmdJbk1hcCIsInVwZGF0ZXIiLCJtYXBCeURlbGV0aW5nRnJvbU1hcCIsIm1hcEJ5RGVsZXRpbmdNdWx0aXBsZUZyb21NYXAiLCJrcyIsIlJlY29pbF9Db3B5T25Xcml0ZSIsImZpbHRlckl0ZXJhYmxlIiwicHJlZGljYXRlIiwiUmVjb2lsX2ZpbHRlckl0ZXJhYmxlIiwibGF6eVByb3h5IiwiYmFzZSIsImZhY3RvcmllcyIsInByb3h5IiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwib3duS2V5cyIsIlJlY29pbF9sYXp5UHJveHkiLCJnZXROb2RlJDEiLCJnZXROb2RlTWF5YmUkMSIsInJlY29pbFZhbHVlc0ZvcktleXMkMSIsIlJldGVudGlvblpvbmUkMSIsInNldEJ5QWRkaW5nVG9TZXQkMSIsImVtcHR5U2V0IiwiUmVhZE9ubHlSZWNvaWxWYWx1ZUVycm9yIiwiaW5pdGlhbGl6ZVJldGVudGlvbkZvck5vZGUiLCJub2RlS2V5IiwicmV0YWluZWRCeSIsImFkZFRvWm9uZSIsInpvbmUiLCJkZWxldGVGcm9tWm9uZSIsImluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlIiwidHJlZVN0YXRlIiwidHJpZ2dlciIsInJldGVudGlvbkNsZWFudXAiLCJub2RlQ2xlYW51cCIsImluaXQiLCJpbml0aWFsaXplTm9kZSIsImNsZWFuVXBOb2RlIiwiX3N0YXRlJG5vZGVDbGVhbnVwRnVuIiwiZ2V0Tm9kZUxvYWRhYmxlIiwicGVla05vZGVMb2FkYWJsZSIsInBlZWsiLCJzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVEIiwiX25vZGUkaW52YWxpZGF0ZSIsImludmFsaWRhdGUiLCJzZXROb2RlVmFsdWUiLCJwZWVrTm9kZUluZm8iLCJub2RlVHlwZSIsImxvYWRhYmxlIiwiaXNBY3RpdmUiLCJpc1NldCIsImlzTW9kaWZpZWQiLCJfZ3JhcGgkbm9kZURlcHMkZ2V0Iiwic3Vic2NyaWJlcnMiLCJfc3RvcmVTdGF0ZSRub2RlVG9Db20iLCJfc3RvcmVTdGF0ZSRub2RlVG9Db20yIiwiZ2V0RG93bnN0cmVhbU5vZGVzIiwiY29tcG9uZW50cyIsInZpc2l0ZWROb2RlcyIsInZpc2l0aW5nTm9kZXMiLCJmcm9tIiwiX2dyYXBoJG5vZGVUb05vZGVTdWJzIiwic3Vic2NyaWJlZE5vZGVzIiwiZG93bnN0cmVhbU5vZGUiLCJSZWNvaWxfRnVuY3Rpb25hbENvcmUiLCJfaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QiLCJzZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCIsImludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90IiwiX2ludmFsaWRhdGVNZW1vaXplZFNuIiwiUmVjb2lsX1NuYXBzaG90Q2FjaGUiLCJnZXREb3duc3RyZWFtTm9kZXMkMSIsImdldE5vZGVMb2FkYWJsZSQxIiwic2V0Tm9kZVZhbHVlJDEiLCJnZXROZXh0Q29tcG9uZW50SUQkMSIsImdldE5vZGUkMiIsImdldE5vZGVNYXliZSQyIiwiRGVmYXVsdFZhbHVlJDEiLCJyZWFjdE1vZGUkMSIsIkFic3RyYWN0UmVjb2lsVmFsdWUkMSIsIlJlY29pbFN0YXRlJDEiLCJSZWNvaWxWYWx1ZVJlYWRPbmx5JDEiLCJpc1JlY29pbFZhbHVlJDEiLCJpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQxIiwiZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlIiwiYXBwbHlBdG9tVmFsdWVXcml0ZXMiLCJ3cml0ZXMiLCJ2YWx1ZUZyb21WYWx1ZU9yVXBkYXRlciIsInZhbHVlT3JVcGRhdGVyIiwibXNnIiwiYXBwbHlBY3Rpb24iLCJhY3Rpb24iLCJ3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUiLCJ1bnZhbGlkYXRlZFZhbHVlIiwiYXBwbHlBY3Rpb25zVG9TdG9yZSIsImFjdGlvbnMiLCJyZXBsYWNlU3RhdGUiLCJuZXdTdGF0ZSIsImNvcHlUcmVlU3RhdGUiLCJpbnZhbGlkYXRlRG93bnN0cmVhbXMiLCJxdWV1ZU9yUGVyZm9ybVN0YXRlVXBkYXRlIiwiYmF0Y2hTdGFjayIsImFjdGlvbnNCeVN0b3JlIiwiYmF0Y2hTdGFydCIsInBvcHBlZCIsImRvd25zdHJlYW1zIiwiX2dldE5vZGVNYXliZSIsIl9nZXROb2RlTWF5YmUkaW52YWxpZCIsInNldFJlY29pbFZhbHVlIiwic2V0UmVjb2lsVmFsdWVMb2FkYWJsZSIsIm1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkIiwic2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZSIsInN1YnNjcmliZVRvUmVjb2lsVmFsdWUiLCJjb21wb25lbnREZWJ1Z05hbWUiLCJzdWJJRCIsInJlbGVhc2UiLCJyZWxlYXNlU3RvcmVTdGF0ZSIsInN1YnMiLCJyZWZyZXNoUmVjb2lsVmFsdWUiLCJfbm9kZSRjbGVhckNhY2hlIiwiY2xlYXJDYWNoZSIsIlJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZSIsInNvbWVTZXQiLCJjb250ZXh0IiwiZW50cnkiLCJSZWNvaWxfc29tZVNldCIsImNsZWFuVXBOb2RlJDEiLCJkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZSQxIiwiZ2V0Tm9kZSQzIiwiUmV0ZW50aW9uWm9uZSQyIiwiU1VTUEVOU0VfVElNRU9VVF9NUyIsImVtcHR5U2V0JDEiLCJyZWxlYXNlUmV0YWluYWJsZXNOb3dPbkN1cnJlbnRUcmVlIiwicmV0YWluYWJsZXMiLCJyIiwibiIsInJlbGVhc2FibGVOb2RlcyIsImZpbmRSZWxlYXNhYmxlTm9kZXMiLCJyZWxlYXNlTm9kZSIsInNlYXJjaEZyb21Ob2RlcyIsIm5vblJlbGVhc2FibGVOb2RlcyIsImZpbmRSZWxlYXNhYmxlTm9kZXNJbm5lciIsInJlbGVhc2FibGVOb2Rlc0ZvdW5kVGhpc0l0ZXJhdGlvbiIsImdldERvd25zdHJlYW1Ob2Rlc0luVG9wb2xvZ2ljYWxPcmRlciIsIl9zdG9yZVN0YXRlJHJldGVudGlvbiIsInpvbmVzVGhhdENvdWxkUmV0YWluTm9kZSIsIm5vZGVDaGlsZHJlbiIsInBhcmVudHMiLCJwYXJlbnQiLCJkb05vdERlc2NlbmRJbnRvMSIsImRvTm90RGVzY2VuZEludG8yIiwiYW5zd2VyIiwidmlzaXRlZCIsInpvbmVzIiwiX3N0b3JlU3RhdGUkcmV0ZW50aW9uMiIsIl9zdG9yZVN0YXRlJHJldGVudGlvbjMiLCJzY2hlZHVsZU9yUGVyZm9ybVBvc3NpYmxlUmVsZWFzZU9mUmV0YWluYWJsZSIsInJldGFpbmFibGUiLCJ1cGRhdGVSZXRhaW5Db3VudCIsImRlbHRhIiwiX21hcCRnZXQiLCJuZXdDb3VudCIsInVwZGF0ZVJldGFpbkNvdW50VG9aZXJvIiwicmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93IiwicmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0IiwiUmVjb2lsX1JldGVudGlvbiIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwiUmVhY3RCYXRjaGVkVXBkYXRlcyIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDEiLCJSZWNvaWxfUmVhY3RCYXRjaGVkVXBkYXRlcyIsImJhdGNoU3RhcnQkMSIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDIiLCJiYXRjaGVyIiwic2V0QmF0Y2hlciIsIm5ld0JhdGNoZXIiLCJnZXRCYXRjaGVyIiwiYmF0Y2hVcGRhdGVzIiwiYmF0Y2hFbmQiLCJSZWNvaWxfQmF0Y2hpbmciLCJjb25jYXRJdGVyYWJsZXMiLCJpdGVycyIsIml0ZXIiLCJ2YWwiLCJSZWNvaWxfY29uY2F0SXRlcmFibGVzIiwiaXNTU1IiLCJXaW5kb3ciLCJpc1dpbmRvdyIsImlzUmVhY3ROYXRpdmUiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0IiwiUmVjb2lsX0Vudmlyb25tZW50IiwibWVtb2l6ZVdpdGhBcmdzSGFzaCIsImhhc2hGdW5jdGlvbiIsImNhY2hlIiwibWVtb2l6ZWRGbiIsImhhc093blByb3BlcnR5IiwibWVtb2l6ZU9uZVdpdGhBcmdzSGFzaCIsImxhc3RLZXkiLCJsYXN0UmVzdWx0IiwibWVtb2l6ZU9uZVdpdGhBcmdzSGFzaEFuZEludmFsaWRhdGlvbiIsIlJlY29pbF9NZW1vaXplIiwiYmF0Y2hVcGRhdGVzJDEiLCJpbml0aWFsaXplTm9kZSQxIiwicGVla05vZGVJbmZvJDEiLCJncmFwaCQxIiwiZ2V0TmV4dFN0b3JlSUQkMSIsIkRFRkFVTFRfVkFMVUUkMSIsInJlY29pbFZhbHVlcyQxIiwicmVjb2lsVmFsdWVzRm9yS2V5cyQyIiwiQWJzdHJhY3RSZWNvaWxWYWx1ZSQyIiwiZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDEiLCJzZXRSZWNvaWxWYWx1ZSQxIiwic2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZSQxIiwidXBkYXRlUmV0YWluQ291bnQkMSIsInNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDEiLCJnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQyIiwibWFrZUVtcHR5U3RvcmVTdGF0ZSQxIiwiaXNTU1IkMSIsIm1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb24kMSIsInJldGFpbldhcm5pbmciLCJTbmFwc2hvdCIsInBhcmVudFN0b3JlSUQiLCJjaGVja1JlZkNvdW50X0lOVEVSTkFMIiwiX3N0b3JlIiwiZ2V0TG9hZGFibGUiLCJvcHQiLCJpc0luaXRpYWxpemVkIiwibWFwcGVyIiwibXV0YWJsZVNuYXBzaG90IiwiTXV0YWJsZVNuYXBzaG90IiwicmV0YWluIiwiYXV0b1JlbGVhc2VfSU5URVJOQUwiLCJzdG9yZUlEIiwicmVwbGFjZXIiLCJncmFwaHMiLCJuZXdHcmFwaCIsInN1YnNjcmliZVRvVHJhbnNhY3Rpb25zIiwiYWRkVHJhbnNhY3Rpb25NZXRhZGF0YSIsIl9yZWZDb3VudCIsInJlbGVhc2VkIiwiX3JlbGVhc2UiLCJzZXRUaW1lb3V0IiwiY2xlYW51cCIsImlzUmV0YWluZWQiLCJnZXRTdG9yZV9JTlRFUk5BTCIsImdldElEIiwiZ2V0U3RvcmVJRCIsImNsb25lU3RvcmVTdGF0ZSIsImJ1bXBWZXJzaW9uIiwiZnJlc2hTbmFwc2hvdCIsImluaXRpYWxpemVTdGF0ZSIsInNuYXBzaG90IiwibWVtb2l6ZWRDbG9uZVNuYXBzaG90IiwiaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMiIsIl9zdG9yZSRnZXRTdGF0ZSRuZXh0VCIsIl9zdG9yZSRnZXRTdGF0ZSRwcmV2aSIsImNsb25lU25hcHNob3QiLCJiYXRjaCIsInJlY29pbFN0YXRlIiwibmV3VmFsdWVPclVwZGF0ZXIiLCJfYmF0Y2giLCJSZWNvaWxfU25hcHNob3QiLCJSZWNvaWxfU25hcHNob3RfMSIsIlJlY29pbF9TbmFwc2hvdF8yIiwiUmVjb2lsX1NuYXBzaG90XzMiLCJSZWNvaWxfU25hcHNob3RfNCIsIlJlY29pbF9TbmFwc2hvdCQxIiwidW5pb25TZXRzIiwic2V0cyIsIlJlY29pbF91bmlvblNldHMiLCJ1c2VSZWYiLCJ1c2VSZWZJbml0T25jZSIsImluaXRpYWxWYWx1ZSIsInJlZiIsIlJlY29pbF91c2VSZWZJbml0T25jZSIsImdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDMiLCJtYWtlRW1wdHlTdG9yZVN0YXRlJDIiLCJjbGVhblVwTm9kZSQyIiwiZ2V0RG93bnN0cmVhbU5vZGVzJDIiLCJpbml0aWFsaXplTm9kZSQyIiwic2V0Tm9kZVZhbHVlJDIiLCJzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVEJDEiLCJncmFwaCQyIiwiY2xvbmVHcmFwaCQxIiwiZ2V0TmV4dFN0b3JlSUQkMiIsImNyZWF0ZU11dGFibGVTb3VyY2UkMSIsInJlYWN0TW9kZSQyIiwiYXBwbHlBdG9tVmFsdWVXcml0ZXMkMSIsInJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdyQxIiwiZnJlc2hTbmFwc2hvdCQxIiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiQxIiwidXNlU3RhdGUiLCJub3RJbkFDb250ZXh0IiwiZGVmYXVsdFN0b3JlIiwic3RhdGVSZXBsYWNlcklzQmVpbmdFeGVjdXRlZCIsInN0YXJ0TmV4dFRyZWVJZk5lZWRlZCIsIkFwcENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlU3RvcmVSZWYiLCJNdXRhYmxlU291cmNlQ29udGV4dCIsInVzZVJlY29pbE11dGFibGVTb3VyY2UiLCJtdXRhYmxlU291cmNlIiwibm90aWZ5Q29tcG9uZW50cyIsImRlcGVuZGVudE5vZGVzIiwiY29tcHMiLCJfc3ViSUQiLCJfZGVidWdOYW1lIiwic2VuZEVuZE9mQmF0Y2hOb3RpZmljYXRpb25zIiwic3Vic2NyaXB0aW9ucyIsInN1YnNjcmlwdGlvbiIsImNiIiwic3BsaWNlIiwiZW5kQmF0Y2giLCJCYXRjaGVyIiwic2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlIiwic3RvcmVSZWYiLCJzZXRTdGF0ZSIsIiRyZWNvaWxEZWJ1Z1N0YXRlcyIsImluaXRpYWxTdG9yZVN0YXRlX0RFUFJFQ0FURUQiLCJpbml0aWFsIiwiYXRvbSIsIndyaXR0ZW5Ob2RlcyIsInNldFVudmFsaWRhdGVkQXRvbVZhbHVlcyIsImluaXRpYWxTdG9yZVN0YXRlIiwibmV4dElEIiwiUmVjb2lsUm9vdF9JTlRFUk5BTCIsImluaXRpYWxpemVTdGF0ZV9ERVBSRUNBVEVEIiwic3RvcmVfSU5URVJOQUwiLCJzdG9yZVByb3AiLCJzdG9yZVN0YXRlUmVmIiwiaWQiLCJtZXRhZGF0YSIsInJlcGxhY2VkIiwibm90aWZ5QmF0Y2hlck9mQ2hhbmdlIiwiYXRvbUtleSIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsIlJlY29pbFJvb3QiLCJwcm9wcyIsIm92ZXJyaWRlIiwicHJvcHNFeGNlcHRPdmVycmlkZSIsImFuY2VzdG9yU3RvcmVSZWYiLCJ1c2VSZWNvaWxTdG9yZUlEIiwiUmVjb2lsX1JlY29pbFJvb3QiLCJub3RpZnlDb21wb25lbnRzX0ZPUl9URVNUSU5HIiwic2VuZEVuZE9mQmF0Y2hOb3RpZmljYXRpb25zX0ZPUl9URVNUSU5HIiwic2hhbGxvd0FycmF5RXF1YWwiLCJhIiwiYiIsImwiLCJSZWNvaWxfc2hhbGxvd0FycmF5RXF1YWwiLCJ1c2VFZmZlY3QkMSIsInVzZVJlZiQyIiwidXNlUHJldmlvdXMiLCJSZWNvaWxfdXNlUHJldmlvdXMiLCJ1c2VTdG9yZVJlZiQxIiwiU1VTUEVOU0VfVElNRU9VVF9NUyQxIiwidXBkYXRlUmV0YWluQ291bnQkMiIsIlJldGVudGlvblpvbmUkMyIsInVzZUVmZmVjdCQyIiwidXNlUmVmJDMiLCJpc1NTUiQyIiwidXNlUmV0YWluIiwidG9SZXRhaW4iLCJ1c2VSZXRhaW5fQUNUVUFMIiwiYXJyYXkiLCJ0aW1lb3V0SUQiLCJjbGVhclRpbWVvdXQiLCJwcmV2aW91c1JldGFpbmFibGVzIiwiUmVjb2lsX3VzZVJldGFpbiIsInVzZUNvbXBvbmVudE5hbWUiLCJSZWNvaWxfdXNlQ29tcG9uZW50TmFtZSIsImJhdGNoVXBkYXRlcyQyIiwiREVGQVVMVF9WQUxVRSQyIiwicmVhY3RNb2RlJDMiLCJ1c2VNdXRhYmxlU291cmNlJDEiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxIiwidXNlUmVjb2lsTXV0YWJsZVNvdXJjZSQxIiwidXNlU3RvcmVSZWYkMiIsImlzUmVjb2lsVmFsdWUkMiIsIkFic3RyYWN0UmVjb2lsVmFsdWUkMyIsImdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyIiwic2V0UmVjb2lsVmFsdWUkMiIsInNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMiIsInN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMSIsInVzZUNhbGxiYWNrJDEiLCJ1c2VFZmZlY3QkMyIsInVzZU1lbW8kMSIsInVzZVJlZiQ0IiwidXNlU3RhdGUkMSIsInNldEJ5QWRkaW5nVG9TZXQkMiIsImhhbmRsZUxvYWRhYmxlIiwidmFsaWRhdGVSZWNvaWxWYWx1ZSIsImhvb2tOYW1lIiwidXNlUmVjb2lsSW50ZXJmYWNlX0RFUFJFQ0FURUQiLCJjb21wb25lbnROYW1lIiwiZm9yY2VVcGRhdGUiLCJyZWNvaWxWYWx1ZXNVc2VkIiwicHJldmlvdXNTdWJzY3JpcHRpb25zIiwidW5zdWJzY3JpYmVGcm9tIiwic3ViIiwidXBkYXRlU3RhdGUiLCJfc3RhdGUiLCJjdXJyZW50U3Vic2NyaXB0aW9ucyIsInVzZVNldFJlY29pbFN0YXRlIiwidXNlUmVzZXRSZWNvaWxTdGF0ZSIsInVzZVJlY29pbFZhbHVlTG9hZGFibGUiLCJ1c2VSZWNvaWxWYWx1ZSIsInVzZVJlY29pbFN0YXRlIiwidXNlUmVjb2lsU3RhdGVMb2FkYWJsZSIsImdldFJlY29pbFZhbHVlIiwiZ2V0UmVjb2lsVmFsdWVMb2FkYWJsZSIsImdldFJlY29pbFN0YXRlIiwiZ2V0UmVjb2lsU3RhdGVMb2FkYWJsZSIsImdldFNldFJlY29pbFN0YXRlIiwiZ2V0UmVzZXRSZWNvaWxTdGF0ZSIsInJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkciLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1NZTkNfRVhURVJOQUxfU1RPUkUiLCJnZXRTbmFwc2hvdCIsIm1lbW9pemVQcmV2aW91c1NuYXBzaG90IiwicHJldlN0YXRlIiwiX3ByZXZTdGF0ZSIsIl9wcmV2U3RhdGUyIiwibmV4dFN0YXRlIiwiZ2V0TWVtb2l6ZWRTbmFwc2hvdCIsInN1YnNjcmliZSIsIm5vdGlmeSIsInVzZVJlY29pbFZhbHVlTG9hZGFibGVfTVVUQUJMRV9TT1VSQ0UiLCJfc3RvcmVTdGF0ZSRuZXh0VHJlZTMiLCJnZXRMb2FkYWJsZVdpdGhUZXN0aW5nIiwiX3N0b3JlU3RhdGUiLCJuZXdMb2FkYWJsZSIsInByZXZMb2FkYWJsZVJlZiIsInNvdXJjZSIsInVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUIiwiX3N0b3JlU3RhdGUkbmV4dFRyZWU0IiwidXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9MRUdBQ1kiLCJfc3RvcmVTdGF0ZSRuZXh0VHJlZTUiLCJfcHJldkxvYWRhYmxlUmVmJGN1cnIiLCJfcHJldkxvYWRhYmxlUmVmJGN1cnIyIiwiVFJBTlNJVElPTl9TVVBQT1JUIiwiU1lOQ19FWFRFUk5BTF9TVE9SRSIsIk1VVEFCTEVfU09VUkNFIiwiTEVHQUNZIiwidXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzIiwidXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUiLCJ1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUiLCJ1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUiLCJSZWNvaWxfSG9va3MiLCJ1c2VSZWNvaWxJbnRlcmZhY2UiLCJmaWx0ZXJNYXAiLCJSZWNvaWxfZmlsdGVyTWFwIiwiZmlsdGVyU2V0IiwiUmVjb2lsX2ZpbHRlclNldCIsIm1lcmdlTWFwcyIsIm1hcHMiLCJuZXh0S2V5IiwiUmVjb2lsX21lcmdlTWFwcyIsImJhdGNoVXBkYXRlcyQzIiwiREVGQVVMVF9WQUxVRSQzIiwiZ2V0Tm9kZSQ0Iiwibm9kZXMkMSIsInVzZVN0b3JlUmVmJDMiLCJBYnN0cmFjdFJlY29pbFZhbHVlJDQiLCJzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlJDEiLCJTVVNQRU5TRV9USU1FT1VUX01TJDIiLCJjbG9uZVNuYXBzaG90JDEiLCJ1c2VDYWxsYmFjayQyIiwidXNlRWZmZWN0JDQiLCJ1c2VSZWYkNSIsInVzZVN0YXRlJDIiLCJpc1NTUiQzIiwidXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb24iLCJleHRlcm5hbGx5VmlzaWJsZUF0b21WYWx1ZXNJblN0YXRlIiwicGVyc2lzdGVkQXRvbUNvbnRlbnRzVmFsdWVzIiwicGVyc2lzdGVuY2UiLCJwZXJzaXN0ZW5jZV9VTlNUQUJMRSIsInVzZVRyYW5zYWN0aW9uT2JzZXJ2YXRpb25fREVQUkVDQVRFRCIsInByZXZpb3VzQXRvbVZhbHVlcyIsImF0b21JbmZvIiwiX25vZGUkcGVyc2lzdGVuY2VfVU5TIiwiX25vZGUkcGVyc2lzdGVuY2VfVU5TMiIsIl9ub2RlJHBlcnNpc3RlbmNlX1VOUzMiLCJfbm9kZSRwZXJzaXN0ZW5jZV9VTlM0IiwiYmFja0J1dHRvbiIsIm1vZGlmaWVkQXRvbXMiLCJ1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyIiwicHJldmlvdXNTbmFwc2hvdCIsInVzZVJlY29pbFNuYXBzaG90Iiwic2V0U25hcHNob3QiLCJyZWxlYXNlUmVmIiwiX3JlbGVhc2VSZWYkY3VycmVudCIsIl9yZWxlYXNlUmVmJGN1cnJlbnQyIiwiX3JlbGVhc2VSZWYkY3VycmVudDMiLCJnb3RvU25hcHNob3QiLCJwcmV2Iiwia2V5c1RvVXBkYXRlIiwiX3ByZXYkYXRvbVZhbHVlcyRnZXQiLCJfbmV4dCRhdG9tVmFsdWVzJGdldCIsInNob3VsZFJlc3RvcmVGcm9tU25hcHNob3RzIiwidXNlR290b1JlY29pbFNuYXBzaG90IiwiUmVjb2lsX1NuYXBzaG90SG9va3MiLCJ1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvbl9ERVBSRUNBVEVEIiwicGVla05vZGVJbmZvJDIiLCJ1c2VTdG9yZVJlZiQ0IiwidXNlR2V0UmVjb2lsVmFsdWVJbmZvIiwiUmVjb2lsX3VzZUdldFJlY29pbFZhbHVlSW5mbyIsInJlYWN0TW9kZSQ0IiwiUmVjb2lsUm9vdCQxIiwidXNlU3RvcmVSZWYkNSIsInVzZU1lbW8kMiIsInVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHMiLCJSZWNvaWxCcmlkZ2UiLCJSZWNvaWxfdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cyIsImxvYWRhYmxlV2l0aFZhbHVlJDEiLCJpbml0aWFsaXplTm9kZSQzIiwiREVGQVVMVF9WQUxVRSQ0IiwiZ2V0Tm9kZSQ1IiwiY29weVRyZWVTdGF0ZSQxIiwiZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDMiLCJpbnZhbGlkYXRlRG93bnN0cmVhbXMkMSIsIndyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZSQxIiwiaXNBdG9tIiwiVHJhbnNhY3Rpb25JbnRlcmZhY2VJbXBsIiwiX2NoYW5nZXMiLCJfdHJlZVN0YXRlIiwibmV3VHJlZVN0YXRlX0lOVEVSTkFMIiwiYXRvbWljVXBkYXRlciIsImNoYW5nZXNldCIsIlJlY29pbF9BdG9taWNVcGRhdGVzIiwiUmVjb2lsX0F0b21pY1VwZGF0ZXNfMSIsIlJlY29pbF9BdG9taWNVcGRhdGVzJDEiLCJpbnZhcmlhbnQiLCJjb25kaXRpb24iLCJpbnZhcmlhbnRfMSIsIlJlY29pbF9pbnZhcmlhbnQiLCJhdG9taWNVcGRhdGVyJDEiLCJiYXRjaFVwZGF0ZXMkNCIsIkRFRkFVTFRfVkFMVUUkNSIsInVzZVN0b3JlUmVmJDYiLCJyZWZyZXNoUmVjb2lsVmFsdWUkMSIsInNldFJlY29pbFZhbHVlJDMiLCJjbG9uZVNuYXBzaG90JDIiLCJnb3RvU25hcHNob3QkMSIsInVzZUNhbGxiYWNrJDMiLCJTZW50aW5lbCIsIlNFTlRJTkVMIiwicmVjb2lsQ2FsbGJhY2siLCJleHRyYUludGVyZmFjZSIsInJlbGVhc2VTbmFwc2hvdCIsImVyck1zZyIsImNhbGxiYWNrSW50ZXJmYWNlIiwicmVzZXQiLCJyZWZyZXNoIiwidHJhbnNhY3RfVU5TVEFCTEUiLCJ0cmFuc2FjdGlvbiIsImZpbmFsbHkiLCJfcmVsZWFzZVNuYXBzaG90IiwiX3JlbGVhc2VTbmFwc2hvdDIiLCJ1c2VSZWNvaWxDYWxsYmFjayIsIlJlY29pbF91c2VSZWNvaWxDYWxsYmFjayIsInVzZVN0b3JlUmVmJDciLCJyZWZyZXNoUmVjb2lsVmFsdWUkMiIsInVzZUNhbGxiYWNrJDQiLCJ1c2VSZWNvaWxSZWZyZXNoZXIiLCJSZWNvaWxfdXNlUmVjb2lsUmVmcmVzaGVyIiwiYXRvbWljVXBkYXRlciQyIiwidXNlU3RvcmVSZWYkOCIsInVzZU1lbW8kMyIsInVzZVJlY29pbFRyYW5zYWN0aW9uIiwiYXRvbWljVXBkYXRlIiwidHJhbnNhY3Rpb25JbnRlcmZhY2UiLCJSZWNvaWxfdXNlUmVjb2lsVHJhbnNhY3Rpb24iLCJXcmFwcGVkVmFsdWUiLCJSZWNvaWxfV3JhcHBlciIsIlJlY29pbF9XcmFwcGVyXzEiLCJSZWNvaWxfV3JhcHBlciQxIiwiaXNGYXN0UmVmcmVzaEVuYWJsZWQkMiIsIkNoYW5nZWRQYXRoRXJyb3IiLCJUcmVlQ2FjaGUiLCJvcHRpb25zIiwiX29wdGlvbnMkb25IaXQiLCJfb3B0aW9ucyRvblNldCIsIl9vcHRpb25zJG1hcE5vZGVWYWx1ZSIsIl9uYW1lIiwiX251bUxlYWZzIiwiX29uSGl0Iiwib25IaXQiLCJfb25TZXQiLCJvblNldCIsIl9tYXBOb2RlVmFsdWUiLCJtYXBOb2RlVmFsdWUiLCJnZXROb2RlVmFsdWUiLCJoYW5kbGVycyIsIl90aGlzJGdldExlYWZOb2RlIiwiZ2V0TGVhZk5vZGUiLCJvbk5vZGVWaXNpdCIsIm5vZGVWYWx1ZSIsImJyYW5jaGVzIiwicm91dGUiLCJhZGRMZWFmIiwiX25vZGUyIiwiX25vZGUzIiwiX3RoaXMkX3Jvb3QyIiwiX2hhbmRsZXJzJG9uTm9kZVZpc2l0MiIsImJyYW5jaEtleSIsIl9ub2RlIiwiX2hhbmRsZXJzJG9uTm9kZVZpc2l0IiwiX3RoaXMkX3Jvb3QiLCJpbnZhbGlkQ2FjaGVFcnJvciIsIm9sZExlYWYiLCJsZWFmTm9kZSIsImxlYWYiLCJfbm9kZTQiLCJDSEFOR0VEX1BBVEhfRVJST1JfTUVTU0FHRSIsIlJlY29pbF9UcmVlQ2FjaGUiLCJSZWNvaWxfVHJlZUNhY2hlXzEiLCJSZWNvaWxfVHJlZUNhY2hlJDEiLCJMUlVDYWNoZSIsIl9vcHRpb25zJG1hcEtleSIsIl9tYXhTaXplIiwibWF4U2l6ZSIsIl9oZWFkIiwiX3RhaWwiLCJfa2V5TWFwcGVyIiwibWFwS2V5IiwiaGVhZCIsInRhaWwiLCJtYXBwZWRLZXkiLCJleGlzdGluZ05vZGUiLCJyaWdodCIsImxlZnQiLCJfbWF5YmVEZWxldGVMUlUiLCJkZWxldGVMcnUiLCJSZWNvaWxfTFJVQ2FjaGUiLCJSZWNvaWxfTFJVQ2FjaGVfMSIsIlJlY29pbF9MUlVDYWNoZSQxIiwiTFJVQ2FjaGUkMSIsIlRyZWVDYWNoZSQxIiwidHJlZUNhY2hlTFJVIiwibHJ1Q2FjaGUiLCJscnVOb2RlIiwiUmVjb2lsX3RyZWVDYWNoZUxSVSIsIlRJTUVfV0FSTklOR19USFJFU0hPTERfTVMiLCJzdHJpbmdpZnkiLCJpbmNsdWRlcyIsIkpTT04iLCJhbGxvd0Z1bmN0aW9ucyIsIl9KU09OJHN0cmluZ2lmeSIsInRvU3RyaW5nIiwic29ydCIsImxvY2FsZUNvbXBhcmUiLCJmaWx0ZXIiLCJqb2luIiwic3RhYmxlU3RyaW5naWZ5Iiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJlbmRUaW1lIiwiZ3JvdXBDb2xsYXBzZWQiLCJncm91cEVuZCIsIlJlY29pbF9zdGFibGVTdHJpbmdpZnkiLCJUcmVlQ2FjaGUkMiIsImRlZmF1bHRQb2xpY3kiLCJlcXVhbGl0eSIsImV2aWN0aW9uIiwiSW5maW5pdHkiLCJ0cmVlQ2FjaGVGcm9tUG9saWN5IiwidmFsdWVNYXBwZXIiLCJnZXRWYWx1ZU1hcHBlciIsImdldFRyZWVDYWNoZSIsIlJlY29pbF90cmVlQ2FjaGVGcm9tUG9saWN5IiwiaXNOb2RlIiwib2JqZWN0IiwiX293bmVyRG9jdW1lbnQiLCJfZG9jJGRlZmF1bHRWaWV3IiwiZG9jIiwib3duZXJEb2N1bWVudCIsImRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJOb2RlIiwibm9kZU5hbWUiLCJSZWNvaWxfaXNOb2RlIiwiaXNSZWFjdE5hdGl2ZSQxIiwiaXNXaW5kb3ckMSIsInNob3VsZE5vdEJlRnJvemVuIiwiJCR0eXBlb2YiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImRlZXBGcmVlemVWYWx1ZSIsImlzRnJvemVuIiwic2VhbCIsIlJlY29pbF9kZWVwRnJlZXplVmFsdWUiLCJzdGFydFBlcmZCbG9jayIsIl9pZCIsIlJlY29pbF9QZXJmb3JtYW5jZVRpbWluZ3MiLCJpc0xvYWRhYmxlJDEiLCJsb2FkYWJsZVdpdGhFcnJvciQxIiwibG9hZGFibGVXaXRoUHJvbWlzZSQxIiwibG9hZGFibGVXaXRoVmFsdWUkMiIsIldyYXBwZWRWYWx1ZSQxIiwiZ2V0Tm9kZUxvYWRhYmxlJDIiLCJwZWVrTm9kZUxvYWRhYmxlJDEiLCJzZXROb2RlVmFsdWUkMyIsInNhdmVEZXBzVG9TdG9yZSQxIiwiREVGQVVMVF9WQUxVRSQ2IiwiZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDEiLCJnZXROb2RlJDYiLCJyZWdpc3Rlck5vZGUkMSIsImlzUmVjb2lsVmFsdWUkMyIsIm1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDEiLCJyZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQkMSIsInJlY29pbENhbGxiYWNrJDEiLCJzdGFydFBlcmZCbG9jayQxIiwiQ2FuY2VsZWQiLCJDQU5DRUxFRCIsImRlcGVuZGVuY3lTdGFjayIsIndhaXRpbmdTdG9yZXMiLCJnZXROZXdFeGVjdXRpb25JRCIsImV4ZWN1dGlvbklEIiwic2VsZWN0b3IiLCJjYWNoZVBvbGljeV9VTlNUQUJMRSIsImNhY2hlUG9saWN5IiwiZGlzY292ZXJlZERlcGVuZGVuY3lOb2RlS2V5cyIsInJldGFpbmVkQnlfVU5TVEFCTEUiLCJleGVjdXRpb25JbmZvTWFwIiwibGl2ZVN0b3Jlc0NvdW50Iiwic2VsZWN0b3JJc0xpdmUiLCJzZWxlY3RvckluaXQiLCJzZWxlY3RvclNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZSIsInJlc29sdmVBc3luYyIsImRlcFZhbHVlcyIsInNldENhY2hlIiwibm90aWZ5U3RvcmVzT2ZSZXNvbHZlZEFzeW5jIiwiaXNMYXRlc3RFeGVjdXRpb24iLCJjbGVhckV4ZWN1dGlvbkluZm8iLCJub3RpZnlXYWl0aW5nU3RvcmVzIiwibm90aWZ5U3RvcmVzT2ZOZXdBc3luY0RlcCIsImV4ZWN1dGlvbkluZm8iLCJnZXRFeGVjdXRpb25JbmZvIiwic3RhdGVWZXJzaW9ucyIsImNsZWFyV2FpdGxpc3QiLCJzdG9yZXMiLCJ3YWl0aW5nU3RvcmUiLCJtYXJrU3RvcmVXYWl0aW5nRm9yUmVzb2x2ZWRBc3luYyIsIndyYXBSZXN1bHRQcm9taXNlIiwibG9hZGluZ0RlcHNTdGF0ZSIsImVycm9yT3JQcm9taXNlIiwid3JhcFBlbmRpbmdEZXBlbmRlbmN5UHJvbWlzZSIsImV4aXN0aW5nRGVwcyIsInJlc29sdmVkRGVwIiwibG9hZGluZ0RlcEtleSIsImxvYWRpbmdEZXBQcm9taXNlIiwiY2FjaGVkTG9hZGFibGUiLCJnZXRMb2FkYWJsZUZyb21DYWNoZUFuZFVwZGF0ZURlcHMiLCJnZXRJblByb2dyZXNzRXhlY3V0aW9uSW5mbyIsImxvYWRpbmdMb2FkYWJsZSIsImV2YWx1YXRlU2VsZWN0b3JHZXR0ZXIiLCJ1cGRhdGVEZXBzIiwiX3N0b3JlJGdldFN0YXRlIiwiX3N0b3JlJGdldFN0YXRlJGN1cnJlIiwiX3N0b3JlJGdldFN0YXRlMiIsIl9zdG9yZSRnZXRTdGF0ZTIkbmV4dCIsIl9zdG9yZSRnZXRTdGF0ZTMiLCJfc3RvcmUkZ2V0U3RhdGUzJG5leHQiLCJlbmRQZXJmQmxvY2siLCJkdXJpbmdTeW5jaHJvbm91c0V4ZWN1dGlvbiIsImR1cmluZ0FzeW5jaHJvbm91c0V4ZWN1dGlvbiIsImZpbmlzaEV2YWx1YXRpb24iLCJyZXN1bHRJc0Vycm9yIiwiZGVwS2V5IiwiZGVwTG9hZGFibGUiLCJnZXRDYWxsYmFjayIsImVycm9yT3JEZXBQcm9taXNlIiwidXBkYXRlRXhlY3V0aW9uSW5mb0RlcFZhbHVlcyIsImRlcHNBZnRlckNhY2hlTG9va3VwIiwiX2dldEV4ZWN1dGlvbkluZm8iLCJnZXRTZWxlY3RvckxvYWRhYmxlQW5kVXBkYXRlRGVwcyIsImNhY2hlZFZhbCIsImluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvIiwiX2luUHJvZ3Jlc3NFeGVjdXRpb25JIiwibmV3RXhlY3V0aW9uSUQiLCJuZXdEZXBWYWx1ZXMiLCJzZXRFeGVjdXRpb25JbmZvIiwicGVuZGluZ0V4ZWN1dGlvbnMiLCJleGVjSW5mbyIsImFueURlcENoYW5nZWQiLCJleGVjRGVwVmFsdWVzIiwiZXhlY0xvYWRhYmxlIiwiZGVwVmFsdWVzRGlzY292ZXJlZFNvRmFyRHVyaW5nQXN5bmNXb3JrIiwiX2dldEV4ZWN1dGlvbkluZm8yIiwiZGVwVmFsdWVzVG9EZXBSb3V0ZSIsInZhbExvYWRhYmxlIiwiQm9vbGVhbiIsImRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5IiwiZGV0ZWN0Q2lyY3VsYXJEZXBlbmRlbmNpZXMiLCJzbGljZSIsImluZGV4T2YiLCJzZWxlY3RvclBlZWsiLCJfcGVla05vZGVMb2FkYWJsZSIsInNlbGVjdG9yR2V0IiwiaW52YWxpZGF0ZVNlbGVjdG9yIiwiY2xlYXJTZWxlY3RvckNhY2hlIiwic2VsZWN0b3JTZXQiLCJzeW5jU2VsZWN0b3JTZXRGaW5pc2hlZCIsInNldFJlY29pbFN0YXRlIiwic2V0VmFsdWUiLCJ1cHN0cmVhbVdyaXRlcyIsInJlc2V0UmVjb2lsU3RhdGUiLCJSZWNvaWxfc2VsZWN0b3IiLCJpc0xvYWRhYmxlJDIiLCJsb2FkYWJsZVdpdGhFcnJvciQyIiwibG9hZGFibGVXaXRoUHJvbWlzZSQyIiwibG9hZGFibGVXaXRoVmFsdWUkMyIsIldyYXBwZWRWYWx1ZSQyIiwicGVla05vZGVJbmZvJDMiLCJERUZBVUxUX1ZBTFVFJDciLCJEZWZhdWx0VmFsdWUkMiIsImdldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQyIiwicmVnaXN0ZXJOb2RlJDIiLCJzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMSIsImlzUmVjb2lsVmFsdWUkNCIsImdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQ0IiwibWFya1JlY29pbFZhbHVlTW9kaWZpZWQkMiIsInNldFJlY29pbFZhbHVlJDQiLCJzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlJDIiLCJyZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQkMiIsInVud3JhcCIsImJhc2VBdG9tIiwidW53cmFwUHJvbWlzZSIsImRlZmF1bHRMb2FkYWJsZSIsImRlZmF1bHQiLCJtYXliZUZyZWV6ZVZhbHVlT3JQcm9taXNlIiwiY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSIsImNsZWFudXBFZmZlY3RzQnlTdG9yZSIsInZhbHVlT3JQcm9taXNlIiwid3JhcFBlbmRpbmdQcm9taXNlIiwid3JhcHBlZFByb21pc2UiLCJfc3RhdGUkYXRvbVZhbHVlcyRnZXQiLCJfc3RvcmUkZ2V0U3RhdGUkbmV4dFQyIiwiX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MiIsImluaXRBdG9tIiwiaW5pdFN0YXRlIiwiX29wdGlvbnMkZWZmZWN0cyIsImNsZWFudXBBdG9tIiwiX2NsZWFudXBFZmZlY3RzQnlTdG9yIiwibm90aWZ5RGVmYXVsdFN1YnNjcmliZXJzIiwiX3N0b3JlJGdldFN0YXRlJG5leHRUMyIsImVmZmVjdHMiLCJlZmZlY3RzX1VOU1RBQkxFIiwiaW5pdFZhbHVlIiwiaXNEdXJpbmdJbml0IiwiaXNJbml0RXJyb3IiLCJwZW5kaW5nU2V0U2VsZiIsInJldFZhbHVlIiwicGVla0F0b20iLCJnZXRQcm9taXNlIiwiZ2V0SW5mb19VTlNUQUJMRSIsIl9zdG9yZSRnZXRTdGF0ZSRuZXh0VDQiLCJpbmZvIiwic2V0U2VsZiIsImVmZmVjdCIsImN1cnJlbnRMb2FkYWJsZSIsImN1cnJlbnRWYWx1ZSIsInJlc2V0U2VsZiIsImhhbmRsZXIiLCJfY2xlYW51cEVmZmVjdHNCeVN0b3IyIiwiY3VycmVudFN0b3JlIiwiX2N1cnJlbnRUcmVlJGF0b21WYWx1IiwiX3ByZXZpb3VzVHJlZSRhdG9tVmFsIiwiX3BlbmRpbmdTZXRTZWxmIiwiX3BlbmRpbmdTZXRTZWxmMiIsIl9wZW5kaW5nU2V0U2VsZjMiLCJvbGRMb2FkYWJsZSIsIm9sZFZhbHVlIiwicGFyZW50U3RvcmVJRF9VTlNUQUJMRSIsIl9jbGVhbnVwRWZmZWN0c0J5U3RvcjMiLCJfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1IiwiaW5pdExvYWRhYmxlIiwiX3JlZiIsIl9zdGF0ZSRhdG9tVmFsdWVzJGdldDMiLCJnZXRBdG9tIiwibm9udmFsaWRhdGVkVmFsdWUiLCJ2YWxpZGF0b3JSZXN1bHQiLCJ2YWxpZGF0b3IiLCJ2YWxpZGF0ZWRWYWx1ZUxvYWRhYmxlIiwiaW52YWxpZGF0ZUF0b20iLCJzZXRBdG9tIiwic2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlQXRvbSIsInJlc3RPcHRpb25zIiwib3B0aW9uc0RlZmF1bHQiLCJhdG9tV2l0aEZhbGxiYWNrIiwic3RvcmVkVmFsdWUiLCJzZWwiLCJiYXNlVmFsdWUiLCJSZWNvaWxfYXRvbSIsIk1hcENhY2hlIiwiUmVjb2lsX01hcENhY2hlIiwiUmVjb2lsX01hcENhY2hlXzEiLCJSZWNvaWxfTWFwQ2FjaGUkMSIsIkxSVUNhY2hlJDIiLCJNYXBDYWNoZSQxIiwiZGVmYXVsdFBvbGljeSQxIiwiY2FjaGVGcm9tUG9saWN5IiwiZ2V0VmFsdWVNYXBwZXIkMSIsImdldENhY2hlIiwiUmVjb2lsX2NhY2hlRnJvbVBvbGljeSIsInNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQyIiwiYXRvbUZhbWlseSIsIl9vcHRpb25zJGNhY2hlUG9saWN5RiIsIl9vcHRpb25zJGNhY2hlUG9saWN5RjIiLCJhdG9tQ2FjaGUiLCJjYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRSIsInBhcmFtcyIsIl9zdGFibGVTdHJpbmdpZnkiLCJjYWNoZWRBdG9tIiwiYXRvbU9wdGlvbnMiLCJuZXdBdG9tIiwiUmVjb2lsX2F0b21GYW1pbHkiLCJzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMyIsIm5leHRJbmRleCIsInNlbGVjdG9yRmFtaWx5Iiwic2VsZWN0b3JDYWNoZSIsImNhY2hlZFNlbGVjdG9yIiwibXlLZXkiLCJteUdldCIsImNhbGxiYWNrcyIsIm15Q2FjaGVQb2xpY3kiLCJuZXdTZWxlY3RvciIsIm15U2V0IiwiUmVjb2lsX3NlbGVjdG9yRmFtaWx5IiwiY29uc3RhbnRTZWxlY3RvciIsImNvbnN0U2VsZWN0b3IiLCJSZWNvaWxfY29uc3RTZWxlY3RvciIsInRocm93aW5nU2VsZWN0b3IiLCJlcnJvclNlbGVjdG9yIiwiUmVjb2lsX2Vycm9yU2VsZWN0b3IiLCJyZWFkT25seVNlbGVjdG9yIiwiUmVjb2lsX3JlYWRPbmx5U2VsZWN0b3IiLCJsb2FkYWJsZVdpdGhFcnJvciQzIiwibG9hZGFibGVXaXRoUHJvbWlzZSQzIiwibG9hZGFibGVXaXRoVmFsdWUkNCIsImNvbmN1cnJlbnRSZXF1ZXN0cyIsInJlc3VsdHMiLCJmaWxsIiwiZXhjZXB0aW9ucyIsImlzRXJyb3IiLCJleHAiLCJ1bndyYXBEZXBlbmRlbmNpZXMiLCJkZXBlbmRlbmNpZXMiLCJ3cmFwUmVzdWx0cyIsIndyYXBMb2FkYWJsZXMiLCJleGNlcHRpb24iLCJjb21iaW5lQXN5bmNSZXN1bHRzV2l0aFN5bmNSZXN1bHRzIiwic3luY1Jlc3VsdHMiLCJhc3luY1Jlc3VsdHMiLCJ3YWl0Rm9yTm9uZSIsIndhaXRGb3JBbnkiLCJ3YWl0Rm9yQWxsIiwiZXhjZXB0aW9uUmVzdWx0cyIsIndhaXRGb3JBbGxTZXR0bGVkIiwibm9XYWl0IiwiZGVwZW5kZW5jeSIsIlJlY29pbF9XYWl0Rm9yIiwiRGVmYXVsdFZhbHVlJDMiLCJSZWNvaWxSb290JDIiLCJ1c2VSZWNvaWxTdG9yZUlEJDEiLCJpc1JlY29pbFZhbHVlJDUiLCJyZXRlbnRpb25ab25lJDEiLCJmcmVzaFNuYXBzaG90JDIiLCJ1c2VSZWNvaWxTdGF0ZSQxIiwidXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEiLCJ1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlJDEiLCJ1c2VSZWNvaWxWYWx1ZSQxIiwidXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEiLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlJDEiLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxIiwidXNlUmVzZXRSZWNvaWxTdGF0ZSQxIiwidXNlU2V0UmVjb2lsU3RhdGUkMSIsInVzZUdvdG9SZWNvaWxTbmFwc2hvdCQxIiwidXNlUmVjb2lsU25hcHNob3QkMSIsInVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXIkMSIsInVzZVJlY29pbENhbGxiYWNrJDEiLCJub1dhaXQkMSIsIndhaXRGb3JBbGwkMSIsIndhaXRGb3JBbGxTZXR0bGVkJDEiLCJ3YWl0Rm9yQW55JDEiLCJ3YWl0Rm9yTm9uZSQxIiwiUmVjb2lsX2luZGV4IiwidXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290c19VTlNUQUJMRSIsInVzZUdldFJlY29pbFZhbHVlSW5mb19VTlNUQUJMRSIsInVzZVJlY29pbFJlZnJlc2hlcl9VTlNUQUJMRSIsInVzZVJlY29pbFRyYW5zYWN0aW9uX1VOU1RBQkxFIiwidXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlcl9VTlNUQUJMRSIsInNuYXBzaG90X1VOU1RBQkxFIiwiUmVjb2lsX2luZGV4XzEiLCJSZWNvaWxfaW5kZXhfMiIsIlJlY29pbF9pbmRleF8zIiwiUmVjb2lsX2luZGV4XzQiLCJSZWNvaWxfaW5kZXhfNSIsIlJlY29pbF9pbmRleF82IiwiUmVjb2lsX2luZGV4XzciLCJSZWNvaWxfaW5kZXhfOCIsIlJlY29pbF9pbmRleF85IiwiUmVjb2lsX2luZGV4XzEwIiwiUmVjb2lsX2luZGV4XzExIiwiUmVjb2lsX2luZGV4XzEyIiwiUmVjb2lsX2luZGV4XzEzIiwiUmVjb2lsX2luZGV4XzE0IiwiUmVjb2lsX2luZGV4XzE1IiwiUmVjb2lsX2luZGV4XzE2IiwiUmVjb2lsX2luZGV4XzE3IiwiUmVjb2lsX2luZGV4XzE4IiwiUmVjb2lsX2luZGV4XzE5IiwiUmVjb2lsX2luZGV4XzIwIiwiUmVjb2lsX2luZGV4XzIxIiwiUmVjb2lsX2luZGV4XzIyIiwiUmVjb2lsX2luZGV4XzIzIiwiUmVjb2lsX2luZGV4XzI0IiwiUmVjb2lsX2luZGV4XzI1IiwiUmVjb2lsX2luZGV4XzI2IiwiUmVjb2lsX2luZGV4XzI3IiwiUmVjb2lsX2luZGV4XzI4IiwiUmVjb2lsX2luZGV4XzI5IiwiUmVjb2lsX2luZGV4XzMwIiwiUmVjb2lsX2luZGV4XzMxIiwiUmVjb2lsX2luZGV4XzMyIiwiUmVjb2lsX2luZGV4XzMzIiwiUmVjb2lsX2luZGV4XzM0IiwiUmVjb2lsX2luZGV4XzM1IiwiUmVjb2lsX2luZGV4XzM2IiwiUmVjb2lsX2luZGV4XzM3Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recoil/es/index.js\n"));

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar runtime = function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function (obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n    return generator;\n  }\n\n  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n\n  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n\n\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"); // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n    // do is to check its .name property.\n    (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n  };\n\n  exports.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  }; // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n\n\n  exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n\n        if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function (value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function (err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function (unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function (error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = // If enqueue has been called before, then we want to wait until\n      // all previous Promises have been resolved before calling invoke,\n      // so that results are always delivered in the correct order. If\n      // enqueue has not been called before, then it is important to\n      // call invoke immediately, without waiting on a callback to fire,\n      // so that the async generator function has the opportunity to do\n      // any necessary setup in a predictable way. This predictability\n      // is why the Promise constructor synchronously invokes its\n      // executor callback, and why async functions synchronously\n      // execute code before the first await. Since we implement simple\n      // async functions in terms of async generators, it is especially\n      // important to get this right, even though it requires care.\n      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n      // invocations of the iterator.\n      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    } // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n\n\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n\n  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n    : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        } // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n        var record = tryCatch(innerFn, self, context);\n\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted; // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  } // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (!info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n      context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    } // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n\n\n    context.delegate = null;\n    return ContinueSentinel;\n  } // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n\n\n  defineIteratorMethods(Gp);\n  define(Gp, toStringTagSymbol, \"Generator\"); // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n  define(Gp, iteratorSymbol, function () {\n    return this;\n  });\n  define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    keys.reverse(); // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      } // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n\n\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n          return next;\n        };\n\n        return next.next = next;\n      }\n    } // Return an iterator with no values.\n\n\n    return {\n      next: doneResult\n    };\n  }\n\n  exports.values = values;\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n    reset: function (skipTempReset) {\n      this.prev = 0;\n      this.next = 0; // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n      this.method = \"next\";\n      this.arg = undefined;\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n    stop: function () {\n      this.done = true;\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n    dispatchException: function (exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n    abrupt: function (type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n    complete: function (record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" || record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n    finish: function (finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n    \"catch\": function (tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      } // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function (iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  }; // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n\n  return exports;\n}( // If this script is executing as a CommonJS module, use module.exports\n// as the regeneratorRuntime namespace. Otherwise create a new empty\n// object. Either way, the resulting object will be used to initialize\n// the regeneratorRuntime variable at the top of this file.\n true ? module.exports : 0);\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLElBQUlBLE9BQU8sR0FBSSxVQUFVQyxPQUFWLEVBQW1CO0VBQ2hDOztFQUVBLElBQUlDLEVBQUUsR0FBR0MsTUFBTSxDQUFDQyxTQUFoQjtFQUNBLElBQUlDLE1BQU0sR0FBR0gsRUFBRSxDQUFDSSxjQUFoQjtFQUNBLElBQUlDLFNBQUosQ0FMZ0MsQ0FLakI7O0VBQ2YsSUFBSUMsT0FBTyxHQUFHLE9BQU9DLE1BQVAsS0FBa0IsVUFBbEIsR0FBK0JBLE1BQS9CLEdBQXdDLEVBQXREO0VBQ0EsSUFBSUMsY0FBYyxHQUFHRixPQUFPLENBQUNHLFFBQVIsSUFBb0IsWUFBekM7RUFDQSxJQUFJQyxtQkFBbUIsR0FBR0osT0FBTyxDQUFDSyxhQUFSLElBQXlCLGlCQUFuRDtFQUNBLElBQUlDLGlCQUFpQixHQUFHTixPQUFPLENBQUNPLFdBQVIsSUFBdUIsZUFBL0M7O0VBRUEsU0FBU0MsTUFBVCxDQUFnQkMsR0FBaEIsRUFBcUJDLEdBQXJCLEVBQTBCQyxLQUExQixFQUFpQztJQUMvQmhCLE1BQU0sQ0FBQ2lCLGNBQVAsQ0FBc0JILEdBQXRCLEVBQTJCQyxHQUEzQixFQUFnQztNQUM5QkMsS0FBSyxFQUFFQSxLQUR1QjtNQUU5QkUsVUFBVSxFQUFFLElBRmtCO01BRzlCQyxZQUFZLEVBQUUsSUFIZ0I7TUFJOUJDLFFBQVEsRUFBRTtJQUpvQixDQUFoQztJQU1BLE9BQU9OLEdBQUcsQ0FBQ0MsR0FBRCxDQUFWO0VBQ0Q7O0VBQ0QsSUFBSTtJQUNGO0lBQ0FGLE1BQU0sQ0FBQyxFQUFELEVBQUssRUFBTCxDQUFOO0VBQ0QsQ0FIRCxDQUdFLE9BQU9RLEdBQVAsRUFBWTtJQUNaUixNQUFNLEdBQUcsVUFBU0MsR0FBVCxFQUFjQyxHQUFkLEVBQW1CQyxLQUFuQixFQUEwQjtNQUNqQyxPQUFPRixHQUFH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SSxPQUFwQyxHQUE4QyxDQXJ0QmpDLENBQWY7O0FBd3RCQSxJQUFJO0VBQ0Y4SSxrQkFBa0IsR0FBRy9JLE9BQXJCO0FBQ0QsQ0FGRCxDQUVFLE9BQU9nSixvQkFBUCxFQUE2QjtFQUM3QjtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksT0FBT0MsVUFBUCxLQUFzQixRQUExQixFQUFvQztJQUNsQ0EsVUFBVSxDQUFDRixrQkFBWCxHQUFnQy9JLE9BQWhDO0VBQ0QsQ0FGRCxNQUVPO0lBQ0xrSixRQUFRLENBQUMsR0FBRCxFQUFNLHdCQUFOLENBQVIsQ0FBd0NsSixPQUF4QztFQUNEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcz9jNTZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgZGVmaW5lKEdwLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgLy8gd2UgY2FuIGV4cGxpY2l0bHkgYWNjZXNzIGdsb2JhbFRoaXMuIEluIG9sZGVyIGVuZ2luZXMgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGVsc2Uge1xuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiZXhwb3J0cyIsIk9wIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCJ1bmRlZmluZWQiLCIkU3ltYm9sIiwiU3ltYm9sIiwiaXRlcmF0b3JTeW1ib2wiLCJpdGVyYXRvciIsImFzeW5jSXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwidG9TdHJpbmdUYWdTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImRlZmluZSIsIm9iaiIsImtleSIsInZhbHVlIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJlcnIiLCJ3cmFwIiwiaW5uZXJGbiIsIm91dGVyRm4iLCJzZWxmIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsImNyZWF0ZSIsImNvbnRleHQiLCJDb250ZXh0IiwiX2ludm9rZSIsIm1ha2VJbnZva2VNZXRob2QiLCJ0cnlDYXRjaCIsImZuIiwiYXJnIiwidHlwZSIsImNhbGwiLCJHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0IiwiR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCIsIkdlblN0YXRlRXhlY3V0aW5nIiwiR2VuU3RhdGVDb21wbGV0ZWQiLCJDb250aW51ZVNlbnRpbmVsIiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwidmFsdWVzIiwiR3AiLCJkaXNwbGF5TmFtZSIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsImZvckVhY2giLCJtZXRob2QiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwiZ2VuRnVuIiwiY3RvciIsImNvbnN0cnVjdG9yIiwibmFtZSIsIm1hcmsiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImF3cmFwIiwiX19hd2FpdCIsIkFzeW5jSXRlcmF0b3IiLCJQcm9taXNlSW1wbCIsImludm9rZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWNvcmQiLCJyZXN1bHQiLCJ0aGVuIiwidW53cmFwcGVkIiwiZXJyb3IiLCJwcmV2aW91c1Byb21pc2UiLCJlbnF1ZXVlIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJhc3luYyIsIlByb21pc2UiLCJpdGVyIiwibmV4dCIsImRvbmUiLCJzdGF0ZSIsIkVycm9yIiwiZG9uZVJlc3VsdCIsImRlbGVnYXRlIiwiZGVsZWdhdGVSZXN1bHQiLCJtYXliZUludm9rZURlbGVnYXRlIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJhYnJ1cHQiLCJUeXBlRXJyb3IiLCJpbmZvIiwicmVzdWx0TmFtZSIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJsb2NzIiwiZW50cnkiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJwdXNoIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsImtleXMiLCJvYmplY3QiLCJyZXZlcnNlIiwibGVuZ3RoIiwicG9wIiwiaXRlcmFibGUiLCJpdGVyYXRvck1ldGhvZCIsImlzTmFOIiwiaSIsInNraXBUZW1wUmVzZXQiLCJwcmV2IiwiY2hhckF0Iiwic2xpY2UiLCJzdG9wIiwicm9vdEVudHJ5Iiwicm9vdFJlY29yZCIsInJ2YWwiLCJleGNlcHRpb24iLCJoYW5kbGUiLCJsb2MiLCJjYXVnaHQiLCJoYXNDYXRjaCIsImhhc0ZpbmFsbHkiLCJmaW5hbGx5RW50cnkiLCJjb21wbGV0ZSIsImZpbmlzaCIsInRocm93biIsImRlbGVnYXRlWWllbGQiLCJtb2R1bGUiLCJyZWdlbmVyYXRvclJ1bnRpbWUiLCJhY2NpZGVudGFsU3RyaWN0TW9kZSIsImdsb2JhbFRoaXMiLCJGdW5jdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css":
/*!********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css ***!
  \********************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*\\n! tailwindcss v3.0.24 | MIT License | https://tailwindcss.com\\n*//*\\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\\n*/\\n\\n*,\\n::before,\\n::after {\\n  box-sizing: border-box; /* 1 */\\n  border-width: 0; /* 2 */\\n  border-style: solid; /* 2 */\\n  border-color: #e5e7eb; /* 2 */\\n}\\n\\n::before,\\n::after {\\n  --tw-content: '';\\n}\\n\\n/*\\n1. Use a consistent sensible line-height in all browsers.\\n2. Prevent adjustments of font size after orientation changes in iOS.\\n3. Use a more readable tab size.\\n4. Use the user's configured `sans` font-family by default.\\n*/\\n\\nhtml {\\n  line-height: 1.5; /* 1 */\\n  -webkit-text-size-adjust: 100%; /* 2 */\\n  -moz-tab-size: 4; /* 3 */\\n  -o-tab-size: 4;\\n     tab-size: 4; /* 3 */\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\"; /* 4 */\\n}\\n\\n/*\\n1. Remove the margin in all browsers.\\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\\n*/\\n\\nbody {\\n  margin: 0; /* 1 */\\n  line-height: inherit; /* 2 */\\n}\\n\\n/*\\n1. Add the correct height in Firefox.\\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\\n3. Ensure horizontal rules are visible by default.\\n*/\\n\\nhr {\\n  height: 0; /* 1 */\\n  color: inherit; /* 2 */\\n  border-top-width: 1px; /* 3 */\\n}\\n\\n/*\\nAdd the correct text decoration in Chrome, Edge, and Safari.\\n*/\\n\\nabbr:where([title]) {\\n  -webkit-text-decoration: underline dotted;\\n          text-decoration: underline dotted;\\n}\\n\\n/*\\nRemove the default font size and weight for headings.\\n*/\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  font-size: inherit;\\n  font-weight: inherit;\\n}\\n\\n/*\\nReset links to optimize for opt-in styling instead of opt-out.\\n*/\\n\\na {\\n  color: inherit;\\n  text-decoration: inherit;\\n}\\n\\n/*\\nAdd the correct font weight in Edge and Safari.\\n*/\\n\\nb,\\nstrong {\\n  font-weight: bolder;\\n}\\n\\n/*\\n1. Use the user's configured `mono` font family by default.\\n2. Correct the odd `em` font sizing in all browsers.\\n*/\\n\\ncode,\\nkbd,\\nsamp,\\npre {\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace; /* 1 */\\n  font-size: 1em; /* 2 */\\n}\\n\\n/*\\nAdd the correct font size in all browsers.\\n*/\\n\\nsmall {\\n  font-size: 80%;\\n}\\n\\n/*\\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\\n*/\\n\\nsub,\\nsup {\\n  font-size: 75%;\\n  line-height: 0;\\n  position: relative;\\n  vertical-align: baseline;\\n}\\n\\nsub {\\n  bottom: -0.25em;\\n}\\n\\nsup {\\n  top: -0.5em;\\n}\\n\\n/*\\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\\n3. Remove gaps between table borders by default.\\n*/\\n\\ntable {\\n  text-indent: 0; /* 1 */\\n  border-color: inherit; /* 2 */\\n  border-collapse: collapse; /* 3 */\\n}\\n\\n/*\\n1. Change the font styles in all browsers.\\n2. Remove the margin in Firefox and Safari.\\n3. Remove default padding in all browsers.\\n*/\\n\\nbutton,\\ninput,\\noptgroup,\\nselect,\\ntextarea {\\n  font-family: inherit; /* 1 */\\n  font-size: 100%; /* 1 */\\n  line-height: inherit; /* 1 */\\n  color: inherit; /* 1 */\\n  margin: 0; /* 2 */\\n  padding: 0; /* 3 */\\n}\\n\\n/*\\nRemove the inheritance of text transform in Edge and Firefox.\\n*/\\n\\nbutton,\\nselect {\\n  text-transform: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Remove default button styles.\\n*/\\n\\nbutton,\\n[type='button'],\\n[type='reset'],\\n[type='submit'] {\\n  -webkit-appearance: button; /* 1 */\\n  background-color: transparent; /* 2 */\\n  background-image: none; /* 2 */\\n}\\n\\n/*\\nUse the modern Firefox focus style for all focusable elements.\\n*/\\n\\n:-moz-focusring {\\n  outline: auto;\\n}\\n\\n/*\\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\\n*/\\n\\n:-moz-ui-invalid {\\n  box-shadow: none;\\n}\\n\\n/*\\nAdd the correct vertical alignment in Chrome and Firefox.\\n*/\\n\\nprogress {\\n  vertical-align: baseline;\\n}\\n\\n/*\\nCorrect the cursor style of increment and decrement buttons in Safari.\\n*/\\n\\n::-webkit-inner-spin-button,\\n::-webkit-outer-spin-button {\\n  height: auto;\\n}\\n\\n/*\\n1. Correct the odd appearance in Chrome and Safari.\\n2. Correct the outline style in Safari.\\n*/\\n\\n[type='search'] {\\n  -webkit-appearance: textfield; /* 1 */\\n  outline-offset: -2px; /* 2 */\\n}\\n\\n/*\\nRemove the inner padding in Chrome and Safari on macOS.\\n*/\\n\\n::-webkit-search-decoration {\\n  -webkit-appearance: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Change font properties to `inherit` in Safari.\\n*/\\n\\n::-webkit-file-upload-button {\\n  -webkit-appearance: button; /* 1 */\\n  font: inherit; /* 2 */\\n}\\n\\n/*\\nAdd the correct display in Chrome and Safari.\\n*/\\n\\nsummary {\\n  display: list-item;\\n}\\n\\n/*\\nRemoves the default spacing and border for appropriate elements.\\n*/\\n\\nblockquote,\\ndl,\\ndd,\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\nhr,\\nfigure,\\np,\\npre {\\n  margin: 0;\\n}\\n\\nfieldset {\\n  margin: 0;\\n  padding: 0;\\n}\\n\\nlegend {\\n  padding: 0;\\n}\\n\\nol,\\nul,\\nmenu {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n/*\\nPrevent resizing textareas horizontally by default.\\n*/\\n\\ntextarea {\\n  resize: vertical;\\n}\\n\\n/*\\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\\n2. Set the default placeholder color to the user's configured gray 400 color.\\n*/\\n\\ninput::-moz-placeholder, textarea::-moz-placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\ninput::placeholder,\\ntextarea::placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\n/*\\nSet the default cursor for buttons.\\n*/\\n\\nbutton,\\n[role=\\\"button\\\"] {\\n  cursor: pointer;\\n}\\n\\n/*\\nMake sure disabled buttons don't get the pointer cursor.\\n*/\\n:disabled {\\n  cursor: default;\\n}\\n\\n/*\\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\\n   This can trigger a poorly considered lint error in some tools but is included by design.\\n*/\\n\\nimg,\\nsvg,\\nvideo,\\ncanvas,\\naudio,\\niframe,\\nembed,\\nobject {\\n  display: block; /* 1 */\\n  vertical-align: middle; /* 2 */\\n}\\n\\n/*\\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\\n*/\\n\\nimg,\\nvideo {\\n  max-width: 100%;\\n  height: auto;\\n}\\n\\n/*\\nEnsure the default browser behavior of the `hidden` attribute.\\n*/\\n\\n[hidden] {\\n  display: none;\\n}\\n\\n*, ::before, ::after {\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\n.pointer-events-none {\\n  pointer-events: none;\\n}\\n.fixed {\\n  position: fixed;\\n}\\n.absolute {\\n  position: absolute;\\n}\\n.relative {\\n  position: relative;\\n}\\n.-top-3 {\\n  top: -0.75rem;\\n}\\n.-top-5 {\\n  top: -1.25rem;\\n}\\n.-top-16 {\\n  top: -4rem;\\n}\\n.bottom-\\\\[16\\\\.2rem\\\\] {\\n  bottom: 16.2rem;\\n}\\n.right-0 {\\n  right: 0px;\\n}\\n.right-24 {\\n  right: 6rem;\\n}\\n.left-1\\\\/2 {\\n  left: 50%;\\n}\\n.right-1\\\\/2 {\\n  right: 50%;\\n}\\n.bottom-36 {\\n  bottom: 9rem;\\n}\\n.top-\\\\[85\\\\%\\\\] {\\n  top: 85%;\\n}\\n.bottom-\\\\[17\\\\.2rem\\\\] {\\n  bottom: 17.2rem;\\n}\\n.bottom-0 {\\n  bottom: 0px;\\n}\\n.top-0 {\\n  top: 0px;\\n}\\n.right-9 {\\n  right: 2.25rem;\\n}\\n.left-0 {\\n  left: 0px;\\n}\\n.z-10 {\\n  z-index: 10;\\n}\\n.z-20 {\\n  z-index: 20;\\n}\\n.col-span-2 {\\n  grid-column: span 2 / span 2;\\n}\\n.col-span-3 {\\n  grid-column: span 3 / span 3;\\n}\\n.col-span-12 {\\n  grid-column: span 12 / span 12;\\n}\\n.col-span-10 {\\n  grid-column: span 10 / span 10;\\n}\\n.col-span-4 {\\n  grid-column: span 4 / span 4;\\n}\\n.col-span-6 {\\n  grid-column: span 6 / span 6;\\n}\\n.col-span-7 {\\n  grid-column: span 7 / span 7;\\n}\\n.row-span-3 {\\n  grid-row: span 3 / span 3;\\n}\\n.my-2 {\\n  margin-top: 0.5rem;\\n  margin-bottom: 0.5rem;\\n}\\n.mx-auto {\\n  margin-left: auto;\\n  margin-right: auto;\\n}\\n.mx-3 {\\n  margin-left: 0.75rem;\\n  margin-right: 0.75rem;\\n}\\n.mx-5 {\\n  margin-left: 1.25rem;\\n  margin-right: 1.25rem;\\n}\\n.mx-1 {\\n  margin-left: 0.25rem;\\n  margin-right: 0.25rem;\\n}\\n.my-1 {\\n  margin-top: 0.25rem;\\n  margin-bottom: 0.25rem;\\n}\\n.mx-2 {\\n  margin-left: 0.5rem;\\n  margin-right: 0.5rem;\\n}\\n.my-7 {\\n  margin-top: 1.75rem;\\n  margin-bottom: 1.75rem;\\n}\\n.mx-\\\\[0\\\\.35rem\\\\] {\\n  margin-left: 0.35rem;\\n  margin-right: 0.35rem;\\n}\\n.my-3 {\\n  margin-top: 0.75rem;\\n  margin-bottom: 0.75rem;\\n}\\n.mx-10 {\\n  margin-left: 2.5rem;\\n  margin-right: 2.5rem;\\n}\\n.mx-8 {\\n  margin-left: 2rem;\\n  margin-right: 2rem;\\n}\\n.my-12 {\\n  margin-top: 3rem;\\n  margin-bottom: 3rem;\\n}\\n.mt-16 {\\n  margin-top: 4rem;\\n}\\n.mt-12 {\\n  margin-top: 3rem;\\n}\\n.mt-8 {\\n  margin-top: 2rem;\\n}\\n.mt-2 {\\n  margin-top: 0.5rem;\\n}\\n.mr-5 {\\n  margin-right: 1.25rem;\\n}\\n.mt-5 {\\n  margin-top: 1.25rem;\\n}\\n.-mt-14 {\\n  margin-top: -3.5rem;\\n}\\n.-mb-5 {\\n  margin-bottom: -1.25rem;\\n}\\n.mb-5 {\\n  margin-bottom: 1.25rem;\\n}\\n.mt-3 {\\n  margin-top: 0.75rem;\\n}\\n.mt-10 {\\n  margin-top: 2.5rem;\\n}\\n.mt-7 {\\n  margin-top: 1.75rem;\\n}\\n.mb-10 {\\n  margin-bottom: 2.5rem;\\n}\\n.mt-1 {\\n  margin-top: 0.25rem;\\n}\\n.mt-4 {\\n  margin-top: 1rem;\\n}\\n.ml-1 {\\n  margin-left: 0.25rem;\\n}\\n.mb-7 {\\n  margin-bottom: 1.75rem;\\n}\\n.mb-2 {\\n  margin-bottom: 0.5rem;\\n}\\n.mr-16 {\\n  margin-right: 4rem;\\n}\\n.ml-5 {\\n  margin-left: 1.25rem;\\n}\\n.mt-\\\\[15px\\\\] {\\n  margin-top: 15px;\\n}\\n.mt-\\\\[0\\\\.8px\\\\] {\\n  margin-top: 0.8px;\\n}\\n.mt-6 {\\n  margin-top: 1.5rem;\\n}\\n.mb-4 {\\n  margin-bottom: 1rem;\\n}\\n.-mb-1 {\\n  margin-bottom: -0.25rem;\\n}\\n.-ml-\\\\[100\\\\%\\\\] {\\n  margin-left: -100%;\\n}\\n.-ml-\\\\[0\\\\%\\\\] {\\n  margin-left: -0%;\\n}\\n.-ml-\\\\[200\\\\%\\\\] {\\n  margin-left: -200%;\\n}\\n.-ml-\\\\[300\\\\%\\\\] {\\n  margin-left: -300%;\\n}\\n.-ml-\\\\[50vw\\\\] {\\n  margin-left: -50vw;\\n}\\n.-mr-\\\\[50vw\\\\] {\\n  margin-right: -50vw;\\n}\\n.mr-\\\\[0\\\\.35rem\\\\] {\\n  margin-right: 0.35rem;\\n}\\n.ml-3 {\\n  margin-left: 0.75rem;\\n}\\n.mr-3 {\\n  margin-right: 0.75rem;\\n}\\n.mb-1 {\\n  margin-bottom: 0.25rem;\\n}\\n.mb-8 {\\n  margin-bottom: 2rem;\\n}\\n.block {\\n  display: block;\\n}\\n.inline-block {\\n  display: inline-block;\\n}\\n.flex {\\n  display: flex;\\n}\\n.inline-flex {\\n  display: inline-flex;\\n}\\n.table {\\n  display: table;\\n}\\n.grid {\\n  display: grid;\\n}\\n.hidden {\\n  display: none;\\n}\\n.aspect-square {\\n  aspect-ratio: 1 / 1;\\n}\\n.h-5 {\\n  height: 1.25rem;\\n}\\n.h-24 {\\n  height: 6rem;\\n}\\n.h-72 {\\n  height: 18rem;\\n}\\n.h-fit {\\n  height: -webkit-fit-content;\\n  height: -moz-fit-content;\\n  height: fit-content;\\n}\\n.h-\\\\[330px\\\\] {\\n  height: 330px;\\n}\\n.h-12 {\\n  height: 3rem;\\n}\\n.h-max {\\n  height: -webkit-max-content;\\n  height: -moz-max-content;\\n  height: max-content;\\n}\\n.h-\\\\[190\\\\] {\\n  height: 190;\\n}\\n.h-\\\\[467px\\\\] {\\n  height: 467px;\\n}\\n.h-6 {\\n  height: 1.5rem;\\n}\\n.h-full {\\n  height: 100%;\\n}\\n.h-\\\\[30px\\\\] {\\n  height: 30px;\\n}\\n.h-56 {\\n  height: 14rem;\\n}\\n.h-\\\\[45vh\\\\] {\\n  height: 45vh;\\n}\\n.h-\\\\[250px\\\\] {\\n  height: 250px;\\n}\\n.h-4 {\\n  height: 1rem;\\n}\\n.h-\\\\[166px\\\\] {\\n  height: 166px;\\n}\\n.h-\\\\[199\\\\.69px\\\\] {\\n  height: 199.69px;\\n}\\n.h-\\\\[60px\\\\] {\\n  height: 60px;\\n}\\n.h-48 {\\n  height: 12rem;\\n}\\n.max-h-fit {\\n  max-height: -webkit-fit-content;\\n  max-height: -moz-fit-content;\\n  max-height: fit-content;\\n}\\n.max-h-\\\\[250px\\\\] {\\n  max-height: 250px;\\n}\\n.max-h-\\\\[24px\\\\] {\\n  max-height: 24px;\\n}\\n.min-h-screen {\\n  min-height: 100vh;\\n}\\n.min-h-\\\\[100vh\\\\] {\\n  min-height: 100vh;\\n}\\n.min-h-\\\\[330px\\\\] {\\n  min-height: 330px;\\n}\\n.min-h-\\\\[213px\\\\] {\\n  min-height: 213px;\\n}\\n.w-full {\\n  width: 100%;\\n}\\n.w-5 {\\n  width: 1.25rem;\\n}\\n.w-3\\\\/4 {\\n  width: 75%;\\n}\\n.w-24 {\\n  width: 6rem;\\n}\\n.w-8 {\\n  width: 2rem;\\n}\\n.w-\\\\[90vw\\\\] {\\n  width: 90vw;\\n}\\n.w-12 {\\n  width: 3rem;\\n}\\n.w-\\\\[48\\\\%\\\\] {\\n  width: 48%;\\n}\\n.w-fit {\\n  width: -webkit-fit-content;\\n  width: -moz-fit-content;\\n  width: fit-content;\\n}\\n.w-2\\\\/3 {\\n  width: 66.666667%;\\n}\\n.w-\\\\[144px\\\\] {\\n  width: 144px;\\n}\\n.w-80 {\\n  width: 20rem;\\n}\\n.w-\\\\[100vw\\\\] {\\n  width: 100vw;\\n}\\n.w-6 {\\n  width: 1.5rem;\\n}\\n.w-\\\\[30px\\\\] {\\n  width: 30px;\\n}\\n.w-\\\\[300\\\\%\\\\] {\\n  width: 300%;\\n}\\n.w-\\\\[100\\\\%\\\\] {\\n  width: 100%;\\n}\\n.w-4 {\\n  width: 1rem;\\n}\\n.w-\\\\[108px\\\\] {\\n  width: 108px;\\n}\\n.w-\\\\[142px\\\\] {\\n  width: 142px;\\n}\\n.w-\\\\[4\\\\.2rem\\\\] {\\n  width: 4.2rem;\\n}\\n.w-20 {\\n  width: 5rem;\\n}\\n.w-2\\\\/4 {\\n  width: 50%;\\n}\\n.min-w-\\\\[300px\\\\] {\\n  min-width: 300px;\\n}\\n.min-w-\\\\[50px\\\\] {\\n  min-width: 50px;\\n}\\n.min-w-\\\\[78px\\\\] {\\n  min-width: 78px;\\n}\\n.min-w-\\\\[108px\\\\] {\\n  min-width: 108px;\\n}\\n.min-w-\\\\[26px\\\\] {\\n  min-width: 26px;\\n}\\n.max-w-\\\\[1200px\\\\] {\\n  max-width: 1200px;\\n}\\n.max-w-\\\\[1500px\\\\] {\\n  max-width: 1500px;\\n}\\n.max-w-\\\\[1300px\\\\] {\\n  max-width: 1300px;\\n}\\n.max-w-\\\\[1100px\\\\] {\\n  max-width: 1100px;\\n}\\n.max-w-\\\\[581px\\\\] {\\n  max-width: 581px;\\n}\\n.-translate-x-1\\\\/2 {\\n  --tw-translate-x: -50%;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n.cursor-pointer {\\n  cursor: pointer;\\n}\\n.select-none {\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n          user-select: none;\\n}\\n.appearance-none {\\n  -webkit-appearance: none;\\n     -moz-appearance: none;\\n          appearance: none;\\n}\\n.grid-cols-2 {\\n  grid-template-columns: repeat(2, minmax(0, 1fr));\\n}\\n.grid-cols-1 {\\n  grid-template-columns: repeat(1, minmax(0, 1fr));\\n}\\n.grid-cols-4 {\\n  grid-template-columns: repeat(4, minmax(0, 1fr));\\n}\\n.grid-cols-12 {\\n  grid-template-columns: repeat(12, minmax(0, 1fr));\\n}\\n.grid-cols-10 {\\n  grid-template-columns: repeat(10, minmax(0, 1fr));\\n}\\n.flex-col {\\n  flex-direction: column;\\n}\\n.flex-wrap {\\n  flex-wrap: wrap;\\n}\\n.place-content-between {\\n  place-content: space-between;\\n}\\n.items-end {\\n  align-items: flex-end;\\n}\\n.items-center {\\n  align-items: center;\\n}\\n.justify-end {\\n  justify-content: flex-end;\\n}\\n.justify-center {\\n  justify-content: center;\\n}\\n.justify-between {\\n  justify-content: space-between;\\n}\\n.gap-3 {\\n  gap: 0.75rem;\\n}\\n.gap-10 {\\n  gap: 2.5rem;\\n}\\n.gap-4 {\\n  gap: 1rem;\\n}\\n.space-y-4 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-y-reverse: 0;\\n  margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));\\n  margin-bottom: calc(1rem * var(--tw-space-y-reverse));\\n}\\n.space-x-3 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(0.75rem * var(--tw-space-x-reverse));\\n  margin-left: calc(0.75rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\n.space-x-2 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(0.5rem * var(--tw-space-x-reverse));\\n  margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\n.space-x-5 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(1.25rem * var(--tw-space-x-reverse));\\n  margin-left: calc(1.25rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\n.space-x-8 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(2rem * var(--tw-space-x-reverse));\\n  margin-left: calc(2rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\n.divide-solid > :not([hidden]) ~ :not([hidden]) {\\n  border-style: solid;\\n}\\n.overflow-hidden {\\n  overflow: hidden;\\n}\\n.overflow-x-auto {\\n  overflow-x: auto;\\n}\\n.whitespace-nowrap {\\n  white-space: nowrap;\\n}\\n.whitespace-pre-wrap {\\n  white-space: pre-wrap;\\n}\\n.rounded-md {\\n  border-radius: 0.375rem;\\n}\\n.rounded-3xl {\\n  border-radius: 1.5rem;\\n}\\n.rounded-xl {\\n  border-radius: 0.75rem;\\n}\\n.rounded-full {\\n  border-radius: 9999px;\\n}\\n.rounded-lg {\\n  border-radius: 0.5rem;\\n}\\n.rounded {\\n  border-radius: 0.25rem;\\n}\\n.rounded-l-md {\\n  border-top-left-radius: 0.375rem;\\n  border-bottom-left-radius: 0.375rem;\\n}\\n.rounded-l-none {\\n  border-top-left-radius: 0px;\\n  border-bottom-left-radius: 0px;\\n}\\n.border {\\n  border-width: 1px;\\n}\\n.border-\\\\[0\\\\.5px\\\\] {\\n  border-width: 0.5px;\\n}\\n.border-2 {\\n  border-width: 2px;\\n}\\n.border-\\\\[1px\\\\] {\\n  border-width: 1px;\\n}\\n.border-4 {\\n  border-width: 4px;\\n}\\n.border-b {\\n  border-bottom-width: 1px;\\n}\\n.border-b-2 {\\n  border-bottom-width: 2px;\\n}\\n.border-t {\\n  border-top-width: 1px;\\n}\\n.border-b-\\\\[1px\\\\] {\\n  border-bottom-width: 1px;\\n}\\n.border-t-2 {\\n  border-top-width: 2px;\\n}\\n.border-t-\\\\[1px\\\\] {\\n  border-top-width: 1px;\\n}\\n.border-r-0 {\\n  border-right-width: 0px;\\n}\\n.border-solid {\\n  border-style: solid;\\n}\\n.border-dashed {\\n  border-style: dashed;\\n}\\n.border-blue-400 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(96 165 250 / var(--tw-border-opacity));\\n}\\n.border-transparent {\\n  border-color: transparent;\\n}\\n.border-gray-300 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(209 213 219 / var(--tw-border-opacity));\\n}\\n.border-\\\\[\\\\#BBBBBB\\\\] {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(187 187 187 / var(--tw-border-opacity));\\n}\\n.border-\\\\[\\\\#e2e2e2\\\\] {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(226 226 226 / var(--tw-border-opacity));\\n}\\n.border-blue-800 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(30 64 175 / var(--tw-border-opacity));\\n}\\n.bg-white {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\\n}\\n.bg-slate-400 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(148 163 184 / var(--tw-bg-opacity));\\n}\\n.bg-blue-500 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(59 130 246 / var(--tw-bg-opacity));\\n}\\n.bg-zinc-300 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(212 212 216 / var(--tw-bg-opacity));\\n}\\n.bg-zinc-400 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(161 161 170 / var(--tw-bg-opacity));\\n}\\n.bg-yellow-500 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(234 179 8 / var(--tw-bg-opacity));\\n}\\n.bg-indigo-500 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(99 102 241 / var(--tw-bg-opacity));\\n}\\n.bg-teal-500 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(20 184 166 / var(--tw-bg-opacity));\\n}\\n.bg-blue-200 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(191 219 254 / var(--tw-bg-opacity));\\n}\\n.bg-\\\\[\\\\#3D414D\\\\] {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(61 65 77 / var(--tw-bg-opacity));\\n}\\n.bg-gray-200 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(229 231 235 / var(--tw-bg-opacity));\\n}\\n.bg-black {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(0 0 0 / var(--tw-bg-opacity));\\n}\\n.bg-red-200 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(254 202 202 / var(--tw-bg-opacity));\\n}\\n.bg-slate-300 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(203 213 225 / var(--tw-bg-opacity));\\n}\\n.bg-slate-100 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(241 245 249 / var(--tw-bg-opacity));\\n}\\n.bg-gray-50 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(249 250 251 / var(--tw-bg-opacity));\\n}\\n.object-cover {\\n  -o-object-fit: cover;\\n     object-fit: cover;\\n}\\n.p-6 {\\n  padding: 1.5rem;\\n}\\n.p-3 {\\n  padding: 0.75rem;\\n}\\n.p-2 {\\n  padding: 0.5rem;\\n}\\n.p-\\\\[0\\\\.12rem\\\\] {\\n  padding: 0.12rem;\\n}\\n.p-1 {\\n  padding: 0.25rem;\\n}\\n.p-\\\\[0\\\\.2rem\\\\] {\\n  padding: 0.2rem;\\n}\\n.p-0 {\\n  padding: 0px;\\n}\\n.px-4 {\\n  padding-left: 1rem;\\n  padding-right: 1rem;\\n}\\n.px-2 {\\n  padding-left: 0.5rem;\\n  padding-right: 0.5rem;\\n}\\n.py-2 {\\n  padding-top: 0.5rem;\\n  padding-bottom: 0.5rem;\\n}\\n.py-4 {\\n  padding-top: 1rem;\\n  padding-bottom: 1rem;\\n}\\n.py-20 {\\n  padding-top: 5rem;\\n  padding-bottom: 5rem;\\n}\\n.px-20 {\\n  padding-left: 5rem;\\n  padding-right: 5rem;\\n}\\n.px-8 {\\n  padding-left: 2rem;\\n  padding-right: 2rem;\\n}\\n.py-3 {\\n  padding-top: 0.75rem;\\n  padding-bottom: 0.75rem;\\n}\\n.px-3 {\\n  padding-left: 0.75rem;\\n  padding-right: 0.75rem;\\n}\\n.px-1 {\\n  padding-left: 0.25rem;\\n  padding-right: 0.25rem;\\n}\\n.py-\\\\[5px\\\\] {\\n  padding-top: 5px;\\n  padding-bottom: 5px;\\n}\\n.py-5 {\\n  padding-top: 1.25rem;\\n  padding-bottom: 1.25rem;\\n}\\n.px-10 {\\n  padding-left: 2.5rem;\\n  padding-right: 2.5rem;\\n}\\n.py-1 {\\n  padding-top: 0.25rem;\\n  padding-bottom: 0.25rem;\\n}\\n.pb-4 {\\n  padding-bottom: 1rem;\\n}\\n.pt-2 {\\n  padding-top: 0.5rem;\\n}\\n.pb-14 {\\n  padding-bottom: 3.5rem;\\n}\\n.pb-\\\\[60px\\\\] {\\n  padding-bottom: 60px;\\n}\\n.pb-3 {\\n  padding-bottom: 0.75rem;\\n}\\n.pt-1 {\\n  padding-top: 0.25rem;\\n}\\n.pt-3 {\\n  padding-top: 0.75rem;\\n}\\n.pb-1 {\\n  padding-bottom: 0.25rem;\\n}\\n.pb-2 {\\n  padding-bottom: 0.5rem;\\n}\\n.pl-6 {\\n  padding-left: 1.5rem;\\n}\\n.pl-3 {\\n  padding-left: 0.75rem;\\n}\\n.pl-7 {\\n  padding-left: 1.75rem;\\n}\\n.pr-3 {\\n  padding-right: 0.75rem;\\n}\\n.text-center {\\n  text-align: center;\\n}\\n.font-sans {\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\";\\n}\\n.text-3xl {\\n  font-size: 1.875rem;\\n  line-height: 2.25rem;\\n}\\n.text-sm {\\n  font-size: 0.875rem;\\n  line-height: 1.25rem;\\n}\\n.text-xl {\\n  font-size: 1.25rem;\\n  line-height: 1.75rem;\\n}\\n.text-2xl {\\n  font-size: 1.5rem;\\n  line-height: 2rem;\\n}\\n.text-xs {\\n  font-size: 0.75rem;\\n  line-height: 1rem;\\n}\\n.text-lg {\\n  font-size: 1.125rem;\\n  line-height: 1.75rem;\\n}\\n.text-base {\\n  font-size: 1rem;\\n  line-height: 1.5rem;\\n}\\n.font-bold {\\n  font-weight: 700;\\n}\\n.font-medium {\\n  font-weight: 500;\\n}\\n.font-semibold {\\n  font-weight: 600;\\n}\\n.uppercase {\\n  text-transform: uppercase;\\n}\\n.leading-7 {\\n  line-height: 1.75rem;\\n}\\n.leading-\\\\[1\\\\.8rem\\\\] {\\n  line-height: 1.8rem;\\n}\\n.text-gray-500 {\\n  --tw-text-opacity: 1;\\n  color: rgb(107 114 128 / var(--tw-text-opacity));\\n}\\n.text-blue-300 {\\n  --tw-text-opacity: 1;\\n  color: rgb(147 197 253 / var(--tw-text-opacity));\\n}\\n.text-white {\\n  --tw-text-opacity: 1;\\n  color: rgb(255 255 255 / var(--tw-text-opacity));\\n}\\n.text-gray-600 {\\n  --tw-text-opacity: 1;\\n  color: rgb(75 85 99 / var(--tw-text-opacity));\\n}\\n.text-\\\\[\\\\#666676\\\\] {\\n  --tw-text-opacity: 1;\\n  color: rgb(102 102 118 / var(--tw-text-opacity));\\n}\\n.text-gray-400 {\\n  --tw-text-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-text-opacity));\\n}\\n.text-red-400 {\\n  --tw-text-opacity: 1;\\n  color: rgb(248 113 113 / var(--tw-text-opacity));\\n}\\n.text-blue-500 {\\n  --tw-text-opacity: 1;\\n  color: rgb(59 130 246 / var(--tw-text-opacity));\\n}\\n.text-blue-400 {\\n  --tw-text-opacity: 1;\\n  color: rgb(96 165 250 / var(--tw-text-opacity));\\n}\\n.text-gray-700 {\\n  --tw-text-opacity: 1;\\n  color: rgb(55 65 81 / var(--tw-text-opacity));\\n}\\n.text-black {\\n  --tw-text-opacity: 1;\\n  color: rgb(0 0 0 / var(--tw-text-opacity));\\n}\\n.placeholder-gray-400::-moz-placeholder {\\n  --tw-placeholder-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-placeholder-opacity));\\n}\\n.placeholder-gray-400::placeholder {\\n  --tw-placeholder-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-placeholder-opacity));\\n}\\n.opacity-60 {\\n  opacity: 0.6;\\n}\\n.shadow-sm {\\n  --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);\\n  --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\n.shadow-xl {\\n  --tw-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);\\n  --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\n.ring-2 {\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\n}\\n.ring-yellow-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(234 179 8 / var(--tw-ring-opacity));\\n}\\n.ring-indigo-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(99 102 241 / var(--tw-ring-opacity));\\n}\\n.ring-teal-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(20 184 166 / var(--tw-ring-opacity));\\n}\\n.ring-gray-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(107 114 128 / var(--tw-ring-opacity));\\n}\\n.ring-black {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(0 0 0 / var(--tw-ring-opacity));\\n}\\n.ring-red-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(239 68 68 / var(--tw-ring-opacity));\\n}\\n.ring-blue-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(59 130 246 / var(--tw-ring-opacity));\\n}\\n.ring-offset-2 {\\n  --tw-ring-offset-width: 2px;\\n}\\n.ring-offset-1 {\\n  --tw-ring-offset-width: 1px;\\n}\\n.filter {\\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n}\\n.transition {\\n  transition-property: color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\n.transition-all {\\n  transition-property: all;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\n.duration-\\\\[0ms\\\\] {\\n  transition-duration: 0ms;\\n}\\n.duration-1000 {\\n  transition-duration: 1000ms;\\n}\\n.last\\\\:border-b-0:last-child {\\n  border-bottom-width: 0px;\\n}\\n.odd\\\\:bg-blue-50:nth-child(odd) {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(239 246 255 / var(--tw-bg-opacity));\\n}\\n.hover\\\\:cursor-pointer:hover {\\n  cursor: pointer;\\n}\\n.hover\\\\:border-blue-500:hover {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(59 130 246 / var(--tw-border-opacity));\\n}\\n.hover\\\\:border-gray-400:hover {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(156 163 175 / var(--tw-border-opacity));\\n}\\n.hover\\\\:border-gray-300:hover {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(209 213 219 / var(--tw-border-opacity));\\n}\\n.hover\\\\:bg-gray-50:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(249 250 251 / var(--tw-bg-opacity));\\n}\\n.hover\\\\:bg-teal-500:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(20 184 166 / var(--tw-bg-opacity));\\n}\\n.hover\\\\:bg-gray-200:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(229 231 235 / var(--tw-bg-opacity));\\n}\\n.hover\\\\:bg-gray-100:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(243 244 246 / var(--tw-bg-opacity));\\n}\\n.hover\\\\:bg-white:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\\n}\\n.hover\\\\:text-gray-400:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-text-opacity));\\n}\\n.hover\\\\:text-black:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(0 0 0 / var(--tw-text-opacity));\\n}\\n.hover\\\\:text-blue-500:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(59 130 246 / var(--tw-text-opacity));\\n}\\n.hover\\\\:text-red-500:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(239 68 68 / var(--tw-text-opacity));\\n}\\n.hover\\\\:text-gray-500:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(107 114 128 / var(--tw-text-opacity));\\n}\\n.hover\\\\:text-blue-400:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(96 165 250 / var(--tw-text-opacity));\\n}\\n.hover\\\\:underline:hover {\\n  -webkit-text-decoration-line: underline;\\n          text-decoration-line: underline;\\n}\\n.focus\\\\:border-blue-400:focus {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(96 165 250 / var(--tw-border-opacity));\\n}\\n.focus\\\\:border-orange-500:focus {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(249 115 22 / var(--tw-border-opacity));\\n}\\n.focus\\\\:bg-red-500:focus {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(239 68 68 / var(--tw-bg-opacity));\\n}\\n.focus\\\\:outline-none:focus {\\n  outline: 2px solid transparent;\\n  outline-offset: 2px;\\n}\\n.focus\\\\:ring-2:focus {\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\n}\\n.focus\\\\:ring-blue-500:focus {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(59 130 246 / var(--tw-ring-opacity));\\n}\\n.focus\\\\:ring-blue-400:focus {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(96 165 250 / var(--tw-ring-opacity));\\n}\\n.focus\\\\:ring-orange-500:focus {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(249 115 22 / var(--tw-ring-opacity));\\n}\\n.focus\\\\:ring-offset-2:focus {\\n  --tw-ring-offset-width: 2px;\\n}\\n.active\\\\:bg-yellow-500:active {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(234 179 8 / var(--tw-bg-opacity));\\n}\\n.peer:checked ~ .peer-checked\\\\:bg-blue-600 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(37 99 235 / var(--tw-bg-opacity));\\n}\\n.peer:checked ~ .peer-checked\\\\:text-white {\\n  --tw-text-opacity: 1;\\n  color: rgb(255 255 255 / var(--tw-text-opacity));\\n}\\n@media (min-width: 640px) {\\n\\n  .sm\\\\:col-span-10 {\\n    grid-column: span 10 / span 10;\\n  }\\n\\n  .sm\\\\:mt-7 {\\n    margin-top: 1.75rem;\\n  }\\n\\n  .sm\\\\:grid {\\n    display: grid;\\n  }\\n\\n  .sm\\\\:max-w-\\\\[380px\\\\] {\\n    max-width: 380px;\\n  }\\n\\n  .sm\\\\:grid-cols-5 {\\n    grid-template-columns: repeat(5, minmax(0, 1fr));\\n  }\\n\\n  .sm\\\\:grid-cols-1 {\\n    grid-template-columns: repeat(1, minmax(0, 1fr));\\n  }\\n\\n  .sm\\\\:grid-cols-3 {\\n    grid-template-columns: repeat(3, minmax(0, 1fr));\\n  }\\n\\n  .sm\\\\:grid-cols-10 {\\n    grid-template-columns: repeat(10, minmax(0, 1fr));\\n  }\\n\\n  .sm\\\\:pl-5 {\\n    padding-left: 1.25rem;\\n  }\\n}\\n@media (min-width: 768px) {\\n\\n  .md\\\\:grid-cols-5 {\\n    grid-template-columns: repeat(5, minmax(0, 1fr));\\n  }\\n\\n  .md\\\\:grid-cols-4 {\\n    grid-template-columns: repeat(4, minmax(0, 1fr));\\n  }\\n\\n  .md\\\\:grid-cols-3 {\\n    grid-template-columns: repeat(3, minmax(0, 1fr));\\n  }\\n\\n  .md\\\\:grid-cols-2 {\\n    grid-template-columns: repeat(2, minmax(0, 1fr));\\n  }\\n}\\n@media (min-width: 1024px) {\\n\\n  .lg\\\\:col-span-1 {\\n    grid-column: span 1 / span 1;\\n  }\\n\\n  .lg\\\\:col-span-10 {\\n    grid-column: span 10 / span 10;\\n  }\\n\\n  .lg\\\\:col-span-5 {\\n    grid-column: span 5 / span 5;\\n  }\\n\\n  .lg\\\\:grid-cols-8 {\\n    grid-template-columns: repeat(8, minmax(0, 1fr));\\n  }\\n\\n  .lg\\\\:grid-cols-6 {\\n    grid-template-columns: repeat(6, minmax(0, 1fr));\\n  }\\n\\n  .lg\\\\:grid-cols-4 {\\n    grid-template-columns: repeat(4, minmax(0, 1fr));\\n  }\\n\\n  .lg\\\\:grid-rows-5 {\\n    grid-template-rows: repeat(5, minmax(0, 1fr));\\n  }\\n\\n  .lg\\\\:px-5 {\\n    padding-left: 1.25rem;\\n    padding-right: 1.25rem;\\n  }\\n\\n  .lg\\\\:px-0 {\\n    padding-left: 0px;\\n    padding-right: 0px;\\n  }\\n}\\n@media (min-width: 1280px) {\\n\\n  .xl\\\\:grid-cols-5 {\\n    grid-template-columns: repeat(5, minmax(0, 1fr));\\n  }\\n\\n  .xl\\\\:grid-cols-3 {\\n    grid-template-columns: repeat(3, minmax(0, 1fr));\\n  }\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://styles/globals.css\",\"<no source>\"],\"names\":[],\"mappings\":\"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B;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,2BAAmB;EAAnB,wBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,2BAAmB;EAAnB,wBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,+BAAmB;EAAnB,4BAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,0BAAmB;EAA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;EDAA;CCAA;ADAA;EAAA,4GCAA;EDAA,0GCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;;EAAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;CAAA;ADAA;;EAAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;CAAA;ADAA;;EAAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA,sBCAA;IDAA;GCAA;;EDAA;IAAA,kBCAA;IDAA;GCAA;CAAA;ADAA;;EAAA;IAAA;GCAA;;EDAA;IAAA;GCAA;CAAA\",\"sourcesContent\":[\"@tailwind base;\\n@tailwind components;\\n@tailwind utilities;\\n\",null],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls4XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOF0udXNlWzJdIS4vc3R5bGVzL2dsb2JhbHMuY3NzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ3dIO0FBQ3hILDhCQUE4QixrSEFBMkI7QUFDekQ7QUFDQSwyWEFBMlgsNEJBQTRCLDRCQUE0QixnQ0FBZ0Msa0NBQWtDLFVBQVUsd0JBQXdCLHFCQUFxQixHQUFHLHFQQUFxUCxzQkFBc0IsMkNBQTJDLDZCQUE2QiwwQkFBMEIsb0JBQW9CLHVQQUF1UCxVQUFVLGdLQUFnSyxlQUFlLGlDQUFpQyxVQUFVLDJOQUEyTixlQUFlLDJCQUEyQixrQ0FBa0MsVUFBVSxpR0FBaUcsOENBQThDLDhDQUE4QyxHQUFHLGtHQUFrRyx1QkFBdUIseUJBQXlCLEdBQUcsaUZBQWlGLG1CQUFtQiw2QkFBNkIsR0FBRywyRUFBMkUsd0JBQXdCLEdBQUcsMEpBQTBKLHlIQUF5SCwyQkFBMkIsVUFBVSxpRUFBaUUsbUJBQW1CLEdBQUcsMkdBQTJHLG1CQUFtQixtQkFBbUIsdUJBQXVCLDZCQUE2QixHQUFHLFNBQVMsb0JBQW9CLEdBQUcsU0FBUyxnQkFBZ0IsR0FBRyxnYkFBZ2Isb0JBQW9CLGtDQUFrQyxzQ0FBc0MsVUFBVSxrTUFBa00sMEJBQTBCLDRCQUE0QixpQ0FBaUMsMkJBQTJCLHNCQUFzQix1QkFBdUIsVUFBVSw4RkFBOEYseUJBQXlCLEdBQUcsbUxBQW1MLGdDQUFnQywwQ0FBMEMsbUNBQW1DLFVBQVUsK0ZBQStGLGtCQUFrQixHQUFHLCtNQUErTSxxQkFBcUIsR0FBRyxtRkFBbUYsNkJBQTZCLEdB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LHlCQUF5Qix1REFBdUQsS0FBSyxHQUFHLFNBQVMsa0dBQWtHLFlBQVksTUFBTSxPQUFPLHFCQUFxQixvQkFBb0IscUJBQXFCLHFCQUFxQixNQUFNLE1BQU0sV0FBVyxNQUFNLFNBQVMsTUFBTSxLQUFLLHFCQUFxQixxQkFBcUIscUJBQXFCLFVBQVUsb0JBQW9CLHFCQUFxQixNQUFNLE9BQU8sTUFBTSxLQUFLLG9CQUFvQixxQkFBcUIsTUFBTSxRQUFRLE1BQU0sS0FBSyxvQkFBb0Isb0JBQW9CLHFCQUFxQixNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsV0FBVyxNQUFNLE1BQU0sTUFBTSxVQUFVLFdBQVcsV0FBVyxNQUFNLE1BQU0sTUFBTSxLQUFLLFVBQVUsV0FBVyxNQUFNLE1BQU0sTUFBTSxNQUFNLFdBQVcsTUFBTSxPQUFPLE1BQU0sUUFBUSxxQkFBcUIsb0JBQW9CLE1BQU0sTUFBTSxNQUFNLEtBQUssVUFBVSxNQUFNLE1BQU0sTUFBTSxNQUFNLFVBQVUsVUFBVSxXQUFXLFdBQVcsTUFBTSxLQUFLLFVBQVUsTUFBTSxLQUFLLFVBQVUsTUFBTSxRQUFRLE1BQU0sS0FBSyxvQkFBb0IscUJBQXFCLHFCQUFxQixNQUFNLFFBQVEsTUFBTSxTQUFTLHFCQUFxQixvQkFBb0IscUJBQXFCLG9CQUFvQixvQkFBb0Isb0JBQW9CLE1BQU0sTUFBTSxNQUFNLE1BQU0sV0FBVyxNQUFNLE9BQU8sTUFBTSxRQUFRLHFCQUFxQixxQkFBcUIscUJBQXFCLE1BQU0sTUFBTSxNQUFNLEtBQUssVUFBVSxNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLE1BQU0sVUFBVSxNQUFNLE9BQU8sTUFBTSxLQUFLLHFCQUFxQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sT0FBTyxNQUFNLEtBQUsscUJBQXFCLG9CQUFvQixNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0saUJBQWlCLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxNQUFNLEtBQUssVUFBVSxNQUFNLE9BQU8sV0FBVyxVQUFVLFVBQVUsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sT0FBTyxNQUFNLEtBQUssb0JBQW9CLG9CQUFvQixNQUFNLE1BQU0sb0JBQW9CLG9CQUFvQixNQUFNLE1BQU0sTUFBTSxNQUFNLFVBQVUsTUFBTSxNQUFNLEtBQUssS0FBSyxVQUFVLE1BQU0sUUFBUSxNQUFNLFlBQVksb0JBQW9CLHFCQUFxQixNQUFNLE1BQU0sTUFBTSxNQUFNLFVBQVUsVUFBVSxNQUFNLE1BQU0sTUFBTSxLQUFLLFVBQVUsTUFBTSxLQUFLLFdBQVcsV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sV0FBVyxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLGFBQWEsYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssV0FBVyxLQUFLLE1BQU0sS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLEtBQUssd0NBQXdDLHVCQUF1QixzQkFBc0IsMEJBQTBCO0FBQzdtMUM7QUFDQSwrREFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zdHlsZXMvZ2xvYmFscy5jc3M/NGJhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLypcXG4hIHRhaWx3aW5kY3NzIHYzLjAuMjQgfCBNSVQgTGljZW5zZSB8IGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tXFxuKi8vKlxcbjEuIFByZXZlbnQgcGFkZGluZyBhbmQgYm9yZGVyIGZyb20gYWZmZWN0aW5nIGVsZW1lbnQgd2lkdGguIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzQpXFxuMi4gQWxsb3cgYWRkaW5nIGEgYm9yZGVyIHRvIGFuIGVsZW1lbnQgYnkganVzdCBhZGRpbmcgYSBib3JkZXItd2lkdGguIChodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRjc3MvdGFpbHdpbmRjc3MvcHVsbC8xMTYpXFxuKi9cXG5cXG4qLFxcbjo6YmVmb3JlLFxcbjo6YWZ0ZXIge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgLyogMSAqL1xcbiAgYm9yZGVyLXdpZHRoOiAwOyAvKiAyICovXFxuICBib3JkZXItc3R5bGU6IHNvbGlkOyAvKiAyICovXFxuICBib3JkZXItY29sb3I6ICNlNWU3ZWI7IC8qIDIgKi9cXG59XFxuXFxuOjpiZWZvcmUsXFxuOjphZnRlciB7XFxuICAtLXR3LWNvbnRlbnQ6ICcnO1xcbn1cXG5cXG4vKlxcbjEuIFVzZSBhIGNvbnNpc3RlbnQgc2Vuc2libGUgbGluZS1oZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxcbjIuIFByZXZlbnQgYWRqdXN0bWVudHMgb2YgZm9udCBzaXplIGFmdGVyIG9yaWVudGF0aW9uIGNoYW5nZXMgaW4gaU9TLlxcbjMuIFVzZSBhIG1vcmUgcmVhZGFibGUgdGFiIHNpemUuXFxuNC4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgc2Fuc2AgZm9udC1mYW1pbHkgYnkgZGVmYXVsdC5cXG4qL1xcblxcbmh0bWwge1xcbiAgbGluZS1oZWlnaHQ6IDEuNTsgLyogMSAqL1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlOyAvKiAyICovXFxuICAtbW96LXRhYi1zaXplOiA0OyAvKiAzICovXFxuICAtby10YWItc2l6ZTogNDtcXG4gICAgIHRhYi1zaXplOiA0OyAvKiAzICovXFxuICBmb250LWZhbWlseTogdWktc2Fucy1zZXJpZiwgc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFxcXCJTZWdvZSBVSVxcXCIsIFJvYm90bywgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgQXJpYWwsIFxcXCJOb3RvIFNhbnNcXFwiLCBzYW5zLXNlcmlmLCBcXFwiQXBwbGUgQ29sb3IgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgU3ltYm9sXFxcIiwgXFxcIk5vdG8gQ29sb3IgRW1vamlcXFwiOyAvKiA0ICovXFxufVxcblxcbi8qXFxuMS4gUmVtb3ZlIHRoZSBtYXJnaW4gaW4gYWxsIGJyb3dzZXJzLlxcbjIuIEluaGVyaXQgbGluZS1oZWlnaHQgZnJvbSBgaHRtbGAgc28gdXNlcnMgY2FuIHNldCB0aGVtIGFzIGEgY2xhc3MgZGlyZWN0bHkgb24gdGhlIGBodG1sYCBlbGVtZW50LlxcbiovXFxuXFxuYm9keSB7XFxuICBtYXJnaW46IDA7IC8qIDEgKi9cXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyAvKiAyICovXFxufVxcblxcbi8qXFxuMS4gQWRkIHRoZSBjb3JyZWN0IGhlaWdodCBpbiBGaXJlZm94LlxcbjIuIENvcnJlY3QgdGhlIGluaGVyaXRhbmNlIG9mIGJvcmRlciBjb2xvciBpbiBGaXJlZm94LiAoaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTkwNjU1KVxcbjMuIEVuc3VyZSBob3Jpem9udGFsIHJ1bGVzIGFyZSB2aXNpYmxlIGJ5IGRlZmF1bHQuXFxuKi9cXG5cXG5ociB7XFxuICBoZWlnaHQ6IDA7IC8qIDEgKi9cXG4gIGNvbG9yOiBpbmhlcml0OyAvKiAyICovXFxuICBib3JkZXItdG9wLXdpZHRoOiAxcHg7IC8qIDMgKi9cXG59XFxuXFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgdGV4dCBkZWNvcmF0aW9uIGluIENocm9tZSwgRWRnZSwgYW5kIFNhZmFyaS5cXG4qL1xcblxcbmFiYnI6d2hlcmUoW3RpdGxlXSkge1xcbiAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG59XFxuXFxuLypcXG5SZW1vdmUgdGhlIGRlZmF1bHQgZm9udCBzaXplIGFuZCB3ZWlnaHQgZm9yIGhlYWRpbmdzLlxcbiovXFxuXFxuaDEsXFxuaDIsXFxuaDMsXFxuaDQsXFxuaDUsXFxuaDYge1xcbiAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7XFxufVxcblxcbi8qXFxuUmVzZXQgbGlua3MgdG8gb3B0aW1pemUgZm9yIG9wdC1pbiBzdHlsaW5nIGluc3RlYWQgb2Ygb3B0LW91dC5cXG4qL1xcblxcbmEge1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICB0ZXh0LWRlY29yYXRpb246IGluaGVyaXQ7XFxufVxcblxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IGZvbnQgd2VpZ2h0IGluIEVkZ2UgYW5kIFNhZmFyaS5cXG4qL1xcblxcbmIsXFxuc3Ryb25nIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxufVxcblxcbi8qXFxuMS4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgbW9ub2AgZm9udCBmYW1pbHkgYnkgZGVmYXVsdC5cXG4yLiBDb3JyZWN0IHRoZSBvZGQgYGVtYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXFxuKi9cXG5cXG5jb2RlLFxcbmtiZCxcXG5zYW1wLFxcbnByZSB7XFxuICBmb250LWZhbWlseTogdWktbW9ub3NwYWNlLCBTRk1vbm8tUmVndWxhciwgTWVubG8sIE1vbmFjbywgQ29uc29sYXMsIFxcXCJMaWJlcmF0aW9uIE1vbm9cXFwiLCBcXFwiQ291cmllciBOZXdcXFwiLCBtb25vc3BhY2U7IC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMWVtOyAvKiAyICovXFxufVxcblxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXFxuKi9cXG5cXG5zbWFsbCB7XFxuICBmb250LXNpemU6IDgwJTtcXG59XFxuXFxuLypcXG5QcmV2ZW50IGBzdWJgIGFuZCBgc3VwYCBlbGVtZW50cyBmcm9tIGFmZmVjdGluZyB0aGUgbGluZSBoZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuc3ViLFxcbnN1cCB7XFxuICBmb250LXNpemU6IDc1JTtcXG4gIGxpbmUtaGVpZ2h0OiAwO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG5cXG5zdWIge1xcbiAgYm90dG9tOiAtMC4yNWVtO1xcbn1cXG5cXG5zdXAge1xcbiAgdG9wOiAtMC41ZW07XFxufVxcblxcbi8qXFxuMS4gUmVtb3ZlIHRleHQgaW5kZW50YXRpb24gZnJvbSB0YWJsZSBjb250ZW50cyBpbiBDaHJvbWUgYW5kIFNhZmFyaS4gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk5OTA4OCwgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIwMTI5NylcXG4yLiBDb3JyZWN0IHRhYmxlIGJvcmRlciBjb2xvciBpbmhlcml0YW5jZSBpbiBhbGwgQ2hyb21lIGFuZCBTYWZhcmkuIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05MzU3MjksIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xOTUwMTYpXFxuMy4gUmVtb3ZlIGdhcHMgYmV0d2VlbiB0YWJsZSBib3JkZXJzIGJ5IGRlZmF1bHQuXFxuKi9cXG5cXG50YWJsZSB7XFxuICB0ZXh0LWluZGVudDogMDsgLyogMSAqL1xcbiAgYm9yZGVyLWNvbG9yOiBpbmhlcml0OyAvKiAyICovXFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlOyAvKiAzICovXFxufVxcblxcbi8qXFxuMS4gQ2hhbmdlIHRoZSBmb250IHN0eWxlcyBpbiBhbGwgYnJvd3NlcnMuXFxuMi4gUmVtb3ZlIHRoZSBtYXJnaW4gaW4gRmlyZWZveCBhbmQgU2FmYXJpLlxcbjMuIFJlbW92ZSBkZWZhdWx0IHBhZGRpbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuYnV0dG9uLFxcbmlucHV0LFxcbm9wdGdyb3VwLFxcbnNlbGVjdCxcXG50ZXh0YXJlYSB7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDsgLyogMSAqL1xcbiAgZm9udC1zaXplOiAxMDAlOyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgLyogMSAqL1xcbiAgY29sb3I6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIG1hcmdpbjogMDsgLyogMiAqL1xcbiAgcGFkZGluZzogMDsgLyogMyAqL1xcbn1cXG5cXG4vKlxcblJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRWRnZSBhbmQgRmlyZWZveC5cXG4qL1xcblxcbmJ1dHRvbixcXG5zZWxlY3Qge1xcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxufVxcblxcbi8qXFxuMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4yLiBSZW1vdmUgZGVmYXVsdCBidXR0b24gc3R5bGVzLlxcbiovXFxuXFxuYnV0dG9uLFxcblt0eXBlPSdidXR0b24nXSxcXG5bdHlwZT0ncmVzZXQnXSxcXG5bdHlwZT0nc3VibWl0J10ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247IC8qIDEgKi9cXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyAvKiAyICovXFxuICBiYWNrZ3JvdW5kLWltYWdlOiBub25lOyAvKiAyICovXFxufVxcblxcbi8qXFxuVXNlIHRoZSBtb2Rlcm4gRmlyZWZveCBmb2N1cyBzdHlsZSBmb3IgYWxsIGZvY3VzYWJsZSBlbGVtZW50cy5cXG4qL1xcblxcbjotbW96LWZvY3VzcmluZyB7XFxuICBvdXRsaW5lOiBhdXRvO1xcbn1cXG5cXG4vKlxcblJlbW92ZSB0aGUgYWRkaXRpb25hbCBgOmludmFsaWRgIHN0eWxlcyBpbiBGaXJlZm94LiAoaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvZ2Vja28tZGV2L2Jsb2IvMmY5ZWFjZDlkM2Q5OTVjOTM3YjQyNTFhNTU1N2Q5NWQ0OTRjOWJlMS9sYXlvdXQvc3R5bGUvcmVzL2Zvcm1zLmNzcyNMNzI4LUw3MzcpXFxuKi9cXG5cXG46LW1vei11aS1pbnZhbGlkIHtcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxufVxcblxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IHZlcnRpY2FsIGFsaWdubWVudCBpbiBDaHJvbWUgYW5kIEZpcmVmb3guXFxuKi9cXG5cXG5wcm9ncmVzcyB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxufVxcblxcbi8qXFxuQ29ycmVjdCB0aGUgY3Vyc29yIHN0eWxlIG9mIGluY3JlbWVudCBhbmQgZGVjcmVtZW50IGJ1dHRvbnMgaW4gU2FmYXJpLlxcbiovXFxuXFxuOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxcbjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XFxuICBoZWlnaHQ6IGF1dG87XFxufVxcblxcbi8qXFxuMS4gQ29ycmVjdCB0aGUgb2RkIGFwcGVhcmFuY2UgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXFxuMi4gQ29ycmVjdCB0aGUgb3V0bGluZSBzdHlsZSBpbiBTYWZhcmkuXFxuKi9cXG5cXG5bdHlwZT0nc2VhcmNoJ10ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7IC8qIDEgKi9cXG4gIG91dGxpbmUtb2Zmc2V0OiAtMnB4OyAvKiAyICovXFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBpbm5lciBwYWRkaW5nIGluIENocm9tZSBhbmQgU2FmYXJpIG9uIG1hY09TLlxcbiovXFxuXFxuOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG59XFxuXFxuLypcXG4xLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxcbjIuIENoYW5nZSBmb250IHByb3BlcnRpZXMgdG8gYGluaGVyaXRgIGluIFNhZmFyaS5cXG4qL1xcblxcbjo6LXdlYmtpdC1maWxlLXVwbG9hZC1idXR0b24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247IC8qIDEgKi9cXG4gIGZvbnQ6IGluaGVyaXQ7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBDaHJvbWUgYW5kIFNhZmFyaS5cXG4qL1xcblxcbnN1bW1hcnkge1xcbiAgZGlzcGxheTogbGlzdC1pdGVtO1xcbn1cXG5cXG4vKlxcblJlbW92ZXMgdGhlIGRlZmF1bHQgc3BhY2luZyBhbmQgYm9yZGVyIGZvciBhcHByb3ByaWF0ZSBlbGVtZW50cy5cXG4qL1xcblxcbmJsb2NrcXVvdGUsXFxuZGwsXFxuZGQsXFxuaDEsXFxuaDIsXFxuaDMsXFxuaDQsXFxuaDUsXFxuaDYsXFxuaHIsXFxuZmlndXJlLFxcbnAsXFxucHJlIHtcXG4gIG1hcmdpbjogMDtcXG59XFxuXFxuZmllbGRzZXQge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxubGVnZW5kIHtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbm9sLFxcbnVsLFxcbm1lbnUge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbi8qXFxuUHJldmVudCByZXNpemluZyB0ZXh0YXJlYXMgaG9yaXpvbnRhbGx5IGJ5IGRlZmF1bHQuXFxuKi9cXG5cXG50ZXh0YXJlYSB7XFxuICByZXNpemU6IHZlcnRpY2FsO1xcbn1cXG5cXG4vKlxcbjEuIFJlc2V0IHRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIG9wYWNpdHkgaW4gRmlyZWZveC4gKGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MvaXNzdWVzLzMzMDApXFxuMi4gU2V0IHRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIGNvbG9yIHRvIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBncmF5IDQwMCBjb2xvci5cXG4qL1xcblxcbmlucHV0OjotbW96LXBsYWNlaG9sZGVyLCB0ZXh0YXJlYTo6LW1vei1wbGFjZWhvbGRlciB7XFxuICBvcGFjaXR5OiAxOyAvKiAxICovXFxuICBjb2xvcjogIzljYTNhZjsgLyogMiAqL1xcbn1cXG5cXG5pbnB1dDo6cGxhY2Vob2xkZXIsXFxudGV4dGFyZWE6OnBsYWNlaG9sZGVyIHtcXG4gIG9wYWNpdHk6IDE7IC8qIDEgKi9cXG4gIGNvbG9yOiAjOWNhM2FmOyAvKiAyICovXFxufVxcblxcbi8qXFxuU2V0IHRoZSBkZWZhdWx0IGN1cnNvciBmb3IgYnV0dG9ucy5cXG4qL1xcblxcbmJ1dHRvbixcXG5bcm9sZT1cXFwiYnV0dG9uXFxcIl0ge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4vKlxcbk1ha2Ugc3VyZSBkaXNhYmxlZCBidXR0b25zIGRvbid0IGdldCB0aGUgcG9pbnRlciBjdXJzb3IuXFxuKi9cXG46ZGlzYWJsZWQge1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG5cXG4vKlxcbjEuIE1ha2UgcmVwbGFjZWQgZWxlbWVudHMgYGRpc3BsYXk6IGJsb2NrYCBieSBkZWZhdWx0LiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy8xNClcXG4yLiBBZGQgYHZlcnRpY2FsLWFsaWduOiBtaWRkbGVgIHRvIGFsaWduIHJlcGxhY2VkIGVsZW1lbnRzIG1vcmUgc2Vuc2libHkgYnkgZGVmYXVsdC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9qZW5zaW1tb25zL2Nzc3JlbWVkeS9pc3N1ZXMvMTQjaXNzdWVjb21tZW50LTYzNDkzNDIxMClcXG4gICBUaGlzIGNhbiB0cmlnZ2VyIGEgcG9vcmx5IGNvbnNpZGVyZWQgbGludCBlcnJvciBpbiBzb21lIHRvb2xzIGJ1dCBpcyBpbmNsdWRlZCBieSBkZXNpZ24uXFxuKi9cXG5cXG5pbWcsXFxuc3ZnLFxcbnZpZGVvLFxcbmNhbnZhcyxcXG5hdWRpbyxcXG5pZnJhbWUsXFxuZW1iZWQsXFxub2JqZWN0IHtcXG4gIGRpc3BsYXk6IGJsb2NrOyAvKiAxICovXFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyAvKiAyICovXFxufVxcblxcbi8qXFxuQ29uc3RyYWluIGltYWdlcyBhbmQgdmlkZW9zIHRvIHRoZSBwYXJlbnQgd2lkdGggYW5kIHByZXNlcnZlIHRoZWlyIGludHJpbnNpYyBhc3BlY3QgcmF0aW8uIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzE0KVxcbiovXFxuXFxuaW1nLFxcbnZpZGVvIHtcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuLypcXG5FbnN1cmUgdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciBvZiB0aGUgYGhpZGRlbmAgYXR0cmlidXRlLlxcbiovXFxuXFxuW2hpZGRlbl0ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuKiwgOjpiZWZvcmUsIDo6YWZ0ZXIge1xcbiAgLS10dy10cmFuc2xhdGUteDogMDtcXG4gIC0tdHctdHJhbnNsYXRlLXk6IDA7XFxuICAtLXR3LXJvdGF0ZTogMDtcXG4gIC0tdHctc2tldy14OiAwO1xcbiAgLS10dy1za2V3LXk6IDA7XFxuICAtLXR3LXNjYWxlLXg6IDE7XFxuICAtLXR3LXNjYWxlLXk6IDE7XFxuICAtLXR3LXBhbi14OiAgO1xcbiAgLS10dy1wYW4teTogIDtcXG4gIC0tdHctcGluY2gtem9vbTogIDtcXG4gIC0tdHctc2Nyb2xsLXNuYXAtc3RyaWN0bmVzczogcHJveGltaXR5O1xcbiAgLS10dy1vcmRpbmFsOiAgO1xcbiAgLS10dy1zbGFzaGVkLXplcm86ICA7XFxuICAtLXR3LW51bWVyaWMtZmlndXJlOiAgO1xcbiAgLS10dy1udW1lcmljLXNwYWNpbmc6ICA7XFxuICAtLXR3LW51bWVyaWMtZnJhY3Rpb246ICA7XFxuICAtLXR3LXJpbmctaW5zZXQ6ICA7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAwcHg7XFxuICAtLXR3LXJpbmctb2Zmc2V0LWNvbG9yOiAjZmZmO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIDAuNSk7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1yaW5nLXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMCAjMDAwMDtcXG4gIC0tdHctYmx1cjogIDtcXG4gIC0tdHctYnJpZ2h0bmVzczogIDtcXG4gIC0tdHctY29udHJhc3Q6ICA7XFxuICAtLXR3LWdyYXlzY2FsZTogIDtcXG4gIC0tdHctaHVlLXJvdGF0ZTogIDtcXG4gIC0tdHctaW52ZXJ0OiAgO1xcbiAgLS10dy1zYXR1cmF0ZTogIDtcXG4gIC0tdHctc2VwaWE6ICA7XFxuICAtLXR3LWRyb3Atc2hhZG93OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1ibHVyOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1jb250cmFzdDogIDtcXG4gIC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1odWUtcm90YXRlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1pbnZlcnQ6ICA7XFxuICAtLXR3LWJhY2tkcm9wLW9wYWNpdHk6ICA7XFxuICAtLXR3LWJhY2tkcm9wLXNhdHVyYXRlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1zZXBpYTogIDtcXG59XFxuLnBvaW50ZXItZXZlbnRzLW5vbmUge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcbi5maXhlZCB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxufVxcbi5hYnNvbHV0ZSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcbi5yZWxhdGl2ZSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi4tdG9wLTMge1xcbiAgdG9wOiAtMC43NXJlbTtcXG59XFxuLi10b3AtNSB7XFxuICB0b3A6IC0xLjI1cmVtO1xcbn1cXG4uLXRvcC0xNiB7XFxuICB0b3A6IC00cmVtO1xcbn1cXG4uYm90dG9tLVxcXFxbMTZcXFxcLjJyZW1cXFxcXSB7XFxuICBib3R0b206IDE2LjJyZW07XFxufVxcbi5yaWdodC0wIHtcXG4gIHJpZ2h0OiAwcHg7XFxufVxcbi5yaWdodC0yNCB7XFxuICByaWdodDogNnJlbTtcXG59XFxuLmxlZnQtMVxcXFwvMiB7XFxuICBsZWZ0OiA1MCU7XFxufVxcbi5yaWdodC0xXFxcXC8yIHtcXG4gIHJpZ2h0OiA1MCU7XFxufVxcbi5ib3R0b20tMzYge1xcbiAgYm90dG9tOiA5cmVtO1xcbn1cXG4udG9wLVxcXFxbODVcXFxcJVxcXFxdIHtcXG4gIHRvcDogODUlO1xcbn1cXG4uYm90dG9tLVxcXFxbMTdcXFxcLjJyZW1cXFxcXSB7XFxuICBib3R0b206IDE3LjJyZW07XFxufVxcbi5ib3R0b20tMCB7XFxuICBib3R0b206IDBweDtcXG59XFxuLnRvcC0wIHtcXG4gIHRvcDogMHB4O1xcbn1cXG4ucmlnaHQtOSB7XFxuICByaWdodDogMi4yNXJlbTtcXG59XFxuLmxlZnQtMCB7XFxuICBsZWZ0OiAwcHg7XFxufVxcbi56LTEwIHtcXG4gIHotaW5kZXg6IDEwO1xcbn1cXG4uei0yMCB7XFxuICB6LWluZGV4OiAyMDtcXG59XFxuLmNvbC1zcGFuLTIge1xcbiAgZ3JpZC1jb2x1bW46IHNwYW4gMiAvIHNwYW4gMjtcXG59XFxuLmNvbC1zcGFuLTMge1xcbiAgZ3JpZC1jb2x1bW46IHNwYW4gMyAvIHNwYW4gMztcXG59XFxuLmNvbC1zcGFuLTEyIHtcXG4gIGdyaWQtY29sdW1uOiBzcGFuIDEyIC8gc3BhbiAxMjtcXG59XFxuLmNvbC1zcGFuLTEwIHtcXG4gIGdyaWQtY29sdW1uOiBzcGFuIDEwIC8gc3BhbiAxMDtcXG59XFxuLmNvbC1zcGFuLTQge1xcbiAgZ3JpZC1jb2x1bW46IHNwYW4gNCAvIHNwYW4gNDtcXG59XFxuLmNvbC1zcGFuLTYge1xcbiAgZ3JpZC1jb2x1bW46IHNwYW4gNiAvIHNwYW4gNjtcXG59XFxuLmNvbC1zcGFuLTcge1xcbiAgZ3JpZC1jb2x1bW46IHNwYW4gNyAvIHNwYW4gNztcXG59XFxuLnJvdy1zcGFuLTMge1xcbiAgZ3JpZC1yb3c6IHNwYW4gMyAvIHNwYW4gMztcXG59XFxuLm15LTIge1xcbiAgbWFyZ2luLXRvcDogMC41cmVtO1xcbiAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbn1cXG4ubXgtYXV0byB7XFxuICBtYXJnaW4tbGVmdDogYXV0bztcXG4gIG1hcmdpbi1yaWdodDogYXV0bztcXG59XFxuLm14LTMge1xcbiAgbWFyZ2luLWxlZnQ6IDAuNzVyZW07XFxuICBtYXJnaW4tcmlnaHQ6IDAuNzVyZW07XFxufVxcbi5teC01IHtcXG4gIG1hcmdpbi1sZWZ0OiAxLjI1cmVtO1xcbiAgbWFyZ2luLXJpZ2h0OiAxLjI1cmVtO1xcbn1cXG4ubXgtMSB7XFxuICBtYXJnaW4tbGVmdDogMC4yNXJlbTtcXG4gIG1hcmdpbi1yaWdodDogMC4yNXJlbTtcXG59XFxuLm15LTEge1xcbiAgbWFyZ2luLXRvcDogMC4yNXJlbTtcXG4gIG1hcmdpbi1ib3R0b206IDAuMjVyZW07XFxufVxcbi5teC0yIHtcXG4gIG1hcmdpbi1sZWZ0OiAwLjVyZW07XFxuICBtYXJnaW4tcmlnaHQ6IDAuNXJlbTtcXG59XFxuLm15LTcge1xcbiAgbWFyZ2luLXRvcDogMS43NXJlbTtcXG4gIG1hcmdpbi1ib3R0b206IDEuNzVyZW07XFxufVxcbi5teC1cXFxcWzBcXFxcLjM1cmVtXFxcXF0ge1xcbiAgbWFyZ2luLWxlZnQ6IDAuMzVyZW07XFxuICBtYXJnaW4tcmlnaHQ6IDAuMzVyZW07XFxufVxcbi5teS0zIHtcXG4gIG1hcmdpbi10b3A6IDAuNzVyZW07XFxuICBtYXJnaW4tYm90dG9tOiAwLjc1cmVtO1xcbn1cXG4ubXgtMTAge1xcbiAgbWFyZ2luLWxlZnQ6IDIuNXJlbTtcXG4gIG1hcmdpbi1yaWdodDogMi41cmVtO1xcbn1cXG4ubXgtOCB7XFxuICBtYXJnaW4tbGVmdDogMnJlbTtcXG4gIG1hcmdpbi1yaWdodDogMnJlbTtcXG59XFxuLm15LTEyIHtcXG4gIG1hcmdpbi10b3A6IDNyZW07XFxuICBtYXJnaW4tYm90dG9tOiAzcmVtO1xcbn1cXG4ubXQtMTYge1xcbiAgbWFyZ2luLXRvcDogNHJlbTtcXG59XFxuLm10LTEyIHtcXG4gIG1hcmdpbi10b3A6IDNyZW07XFxufVxcbi5tdC04IHtcXG4gIG1hcmdpbi10b3A6IDJyZW07XFxufVxcbi5tdC0yIHtcXG4gIG1hcmdpbi10b3A6IDAuNXJlbTtcXG59XFxuLm1yLTUge1xcbiAgbWFyZ2luLXJpZ2h0OiAxLjI1cmVtO1xcbn1cXG4ubXQtNSB7XFxuICBtYXJnaW4tdG9wOiAxLjI1cmVtO1xcbn1cXG4uLW10LTE0IHtcXG4gIG1hcmdpbi10b3A6IC0zLjVyZW07XFxufVxcbi4tbWItNSB7XFxuICBtYXJnaW4tYm90dG9tOiAtMS4yNXJlbTtcXG59XFxuLm1iLTUge1xcbiAgbWFyZ2luLWJvdHRvbTogMS4yNXJlbTtcXG59XFxuLm10LTMge1xcbiAgbWFyZ2luLXRvcDogMC43NXJlbTtcXG59XFxuLm10LTEwIHtcXG4gIG1hcmdpbi10b3A6IDIuNXJlbTtcXG59XFxuLm10LTcge1xcbiAgbWFyZ2luLXRvcDogMS43NXJlbTtcXG59XFxuLm1iLTEwIHtcXG4gIG1hcmdpbi1ib3R0b206IDIuNXJlbTtcXG59XFxuLm10LTEge1xcbiAgbWFyZ2luLXRvcDogMC4yNXJlbTtcXG59XFxuLm10LTQge1xcbiAgbWFyZ2luLXRvcDogMXJlbTtcXG59XFxuLm1sLTEge1xcbiAgbWFyZ2luLWxlZnQ6IDAuMjVyZW07XFxufVxcbi5tYi03IHtcXG4gIG1hcmdpbi1ib3R0b206IDEuNzVyZW07XFxufVxcbi5tYi0yIHtcXG4gIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG59XFxuLm1yLTE2IHtcXG4gIG1hcmdpbi1yaWdodDogNHJlbTtcXG59XFxuLm1sLTUge1xcbiAgbWFyZ2luLWxlZnQ6IDEuMjVyZW07XFxufVxcbi5tdC1cXFxcWzE1cHhcXFxcXSB7XFxuICBtYXJnaW4tdG9wOiAxNXB4O1xcbn1cXG4ubXQtXFxcXFswXFxcXC44cHhcXFxcXSB7XFxuICBtYXJnaW4tdG9wOiAwLjhweDtcXG59XFxuLm10LTYge1xcbiAgbWFyZ2luLXRvcDogMS41cmVtO1xcbn1cXG4ubWItNCB7XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbn1cXG4uLW1iLTEge1xcbiAgbWFyZ2luLWJvdHRvbTogLTAuMjVyZW07XFxufVxcbi4tbWwtXFxcXFsxMDBcXFxcJVxcXFxdIHtcXG4gIG1hcmdpbi1sZWZ0OiAtMTAwJTtcXG59XFxuLi1tbC1cXFxcWzBcXFxcJVxcXFxdIHtcXG4gIG1hcmdpbi1sZWZ0OiAtMCU7XFxufVxcbi4tbWwtXFxcXFsyMDBcXFxcJVxcXFxdIHtcXG4gIG1hcmdpbi1sZWZ0OiAtMjAwJTtcXG59XFxuLi1tbC1cXFxcWzMwMFxcXFwlXFxcXF0ge1xcbiAgbWFyZ2luLWxlZnQ6IC0zMDAlO1xcbn1cXG4uLW1sLVxcXFxbNTB2d1xcXFxdIHtcXG4gIG1hcmdpbi1sZWZ0OiAtNTB2dztcXG59XFxuLi1tci1cXFxcWzUwdndcXFxcXSB7XFxuICBtYXJnaW4tcmlnaHQ6IC01MHZ3O1xcbn1cXG4ubXItXFxcXFswXFxcXC4zNXJlbVxcXFxdIHtcXG4gIG1hcmdpbi1yaWdodDogMC4zNXJlbTtcXG59XFxuLm1sLTMge1xcbiAgbWFyZ2luLWxlZnQ6IDAuNzVyZW07XFxufVxcbi5tci0zIHtcXG4gIG1hcmdpbi1yaWdodDogMC43NXJlbTtcXG59XFxuLm1iLTEge1xcbiAgbWFyZ2luLWJvdHRvbTogMC4yNXJlbTtcXG59XFxuLm1iLTgge1xcbiAgbWFyZ2luLWJvdHRvbTogMnJlbTtcXG59XFxuLmJsb2NrIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4uaW5saW5lLWJsb2NrIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuLmZsZXgge1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuLmlubGluZS1mbGV4IHtcXG4gIGRpc3BsYXk6IGlubGluZS1mbGV4O1xcbn1cXG4udGFibGUge1xcbiAgZGlzcGxheTogdGFibGU7XFxufVxcbi5ncmlkIHtcXG4gIGRpc3BsYXk6IGdyaWQ7XFxufVxcbi5oaWRkZW4ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLmFzcGVjdC1zcXVhcmUge1xcbiAgYXNwZWN0LXJhdGlvOiAxIC8gMTtcXG59XFxuLmgtNSB7XFxuICBoZWlnaHQ6IDEuMjVyZW07XFxufVxcbi5oLTI0IHtcXG4gIGhlaWdodDogNnJlbTtcXG59XFxuLmgtNzIge1xcbiAgaGVpZ2h0OiAxOHJlbTtcXG59XFxuLmgtZml0IHtcXG4gIGhlaWdodDogLXdlYmtpdC1maXQtY29udGVudDtcXG4gIGhlaWdodDogLW1vei1maXQtY29udGVudDtcXG4gIGhlaWdodDogZml0LWNvbnRlbnQ7XFxufVxcbi5oLVxcXFxbMzMwcHhcXFxcXSB7XFxuICBoZWlnaHQ6IDMzMHB4O1xcbn1cXG4uaC0xMiB7XFxuICBoZWlnaHQ6IDNyZW07XFxufVxcbi5oLW1heCB7XFxuICBoZWlnaHQ6IC13ZWJraXQtbWF4LWNvbnRlbnQ7XFxuICBoZWlnaHQ6IC1tb3otbWF4LWNvbnRlbnQ7XFxuICBoZWlnaHQ6IG1heC1jb250ZW50O1xcbn1cXG4uaC1cXFxcWzE5MFxcXFxdIHtcXG4gIGhlaWdodDogMTkwO1xcbn1cXG4uaC1cXFxcWzQ2N3B4XFxcXF0ge1xcbiAgaGVpZ2h0OiA0NjdweDtcXG59XFxuLmgtNiB7XFxuICBoZWlnaHQ6IDEuNXJlbTtcXG59XFxuLmgtZnVsbCB7XFxuICBoZWlnaHQ6IDEwMCU7XFxufVxcbi5oLVxcXFxbMzBweFxcXFxdIHtcXG4gIGhlaWdodDogMzBweDtcXG59XFxuLmgtNTYge1xcbiAgaGVpZ2h0OiAxNHJlbTtcXG59XFxuLmgtXFxcXFs0NXZoXFxcXF0ge1xcbiAgaGVpZ2h0OiA0NXZoO1xcbn1cXG4uaC1cXFxcWzI1MHB4XFxcXF0ge1xcbiAgaGVpZ2h0OiAyNTBweDtcXG59XFxuLmgtNCB7XFxuICBoZWlnaHQ6IDFyZW07XFxufVxcbi5oLVxcXFxbMTY2cHhcXFxcXSB7XFxuICBoZWlnaHQ6IDE2NnB4O1xcbn1cXG4uaC1cXFxcWzE5OVxcXFwuNjlweFxcXFxdIHtcXG4gIGhlaWdodDogMTk5LjY5cHg7XFxufVxcbi5oLVxcXFxbNjBweFxcXFxdIHtcXG4gIGhlaWdodDogNjBweDtcXG59XFxuLmgtNDgge1xcbiAgaGVpZ2h0OiAxMnJlbTtcXG59XFxuLm1heC1oLWZpdCB7XFxuICBtYXgtaGVpZ2h0OiAtd2Via2l0LWZpdC1jb250ZW50O1xcbiAgbWF4LWhlaWdodDogLW1vei1maXQtY29udGVudDtcXG4gIG1heC1oZWlnaHQ6IGZpdC1jb250ZW50O1xcbn1cXG4ubWF4LWgtXFxcXFsyNTBweFxcXFxdIHtcXG4gIG1heC1oZWlnaHQ6IDI1MHB4O1xcbn1cXG4ubWF4LWgtXFxcXFsyNHB4XFxcXF0ge1xcbiAgbWF4LWhlaWdodDogMjRweDtcXG59XFxuLm1pbi1oLXNjcmVlbiB7XFxuICBtaW4taGVpZ2h0OiAxMDB2aDtcXG59XFxuLm1pbi1oLVxcXFxbMTAwdmhcXFxcXSB7XFxuICBtaW4taGVpZ2h0OiAxMDB2aDtcXG59XFxuLm1pbi1oLVxcXFxbMzMwcHhcXFxcXSB7XFxuICBtaW4taGVpZ2h0OiAzMzBweDtcXG59XFxuLm1pbi1oLVxcXFxbMjEzcHhcXFxcXSB7XFxuICBtaW4taGVpZ2h0OiAyMTNweDtcXG59XFxuLnctZnVsbCB7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuLnctNSB7XFxuICB3aWR0aDogMS4yNXJlbTtcXG59XFxuLnctM1xcXFwvNCB7XFxuICB3aWR0aDogNzUlO1xcbn1cXG4udy0yNCB7XFxuICB3aWR0aDogNnJlbTtcXG59XFxuLnctOCB7XFxuICB3aWR0aDogMnJlbTtcXG59XFxuLnctXFxcXFs5MHZ3XFxcXF0ge1xcbiAgd2lkdGg6IDkwdnc7XFxufVxcbi53LTEyIHtcXG4gIHdpZHRoOiAzcmVtO1xcbn1cXG4udy1cXFxcWzQ4XFxcXCVcXFxcXSB7XFxuICB3aWR0aDogNDglO1xcbn1cXG4udy1maXQge1xcbiAgd2lkdGg6IC13ZWJraXQtZml0LWNvbnRlbnQ7XFxuICB3aWR0aDogLW1vei1maXQtY29udGVudDtcXG4gIHdpZHRoOiBmaXQtY29udGVudDtcXG59XFxuLnctMlxcXFwvMyB7XFxuICB3aWR0aDogNjYuNjY2NjY3JTtcXG59XFxuLnctXFxcXFsxNDRweFxcXFxdIHtcXG4gIHdpZHRoOiAxNDRweDtcXG59XFxuLnctODAge1xcbiAgd2lkdGg6IDIwcmVtO1xcbn1cXG4udy1cXFxcWzEwMHZ3XFxcXF0ge1xcbiAgd2lkdGg6IDEwMHZ3O1xcbn1cXG4udy02IHtcXG4gIHdpZHRoOiAxLjVyZW07XFxufVxcbi53LVxcXFxbMzBweFxcXFxdIHtcXG4gIHdpZHRoOiAzMHB4O1xcbn1cXG4udy1cXFxcWzMwMFxcXFwlXFxcXF0ge1xcbiAgd2lkdGg6IDMwMCU7XFxufVxcbi53LVxcXFxbMTAwXFxcXCVcXFxcXSB7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuLnctNCB7XFxuICB3aWR0aDogMXJlbTtcXG59XFxuLnctXFxcXFsxMDhweFxcXFxdIHtcXG4gIHdpZHRoOiAxMDhweDtcXG59XFxuLnctXFxcXFsxNDJweFxcXFxdIHtcXG4gIHdpZHRoOiAxNDJweDtcXG59XFxuLnctXFxcXFs0XFxcXC4ycmVtXFxcXF0ge1xcbiAgd2lkdGg6IDQuMnJlbTtcXG59XFxuLnctMjAge1xcbiAgd2lkdGg6IDVyZW07XFxufVxcbi53LTJcXFxcLzQge1xcbiAgd2lkdGg6IDUwJTtcXG59XFxuLm1pbi13LVxcXFxbMzAwcHhcXFxcXSB7XFxuICBtaW4td2lkdGg6IDMwMHB4O1xcbn1cXG4ubWluLXctXFxcXFs1MHB4XFxcXF0ge1xcbiAgbWluLXdpZHRoOiA1MHB4O1xcbn1cXG4ubWluLXctXFxcXFs3OHB4XFxcXF0ge1xcbiAgbWluLXdpZHRoOiA3OHB4O1xcbn1cXG4ubWluLXctXFxcXFsxMDhweFxcXFxdIHtcXG4gIG1pbi13aWR0aDogMTA4cHg7XFxufVxcbi5taW4tdy1cXFxcWzI2cHhcXFxcXSB7XFxuICBtaW4td2lkdGg6IDI2cHg7XFxufVxcbi5tYXgtdy1cXFxcWzEyMDBweFxcXFxdIHtcXG4gIG1heC13aWR0aDogMTIwMHB4O1xcbn1cXG4ubWF4LXctXFxcXFsxNTAwcHhcXFxcXSB7XFxuICBtYXgtd2lkdGg6IDE1MDBweDtcXG59XFxuLm1heC13LVxcXFxbMTMwMHB4XFxcXF0ge1xcbiAgbWF4LXdpZHRoOiAxMzAwcHg7XFxufVxcbi5tYXgtdy1cXFxcWzExMDBweFxcXFxdIHtcXG4gIG1heC13aWR0aDogMTEwMHB4O1xcbn1cXG4ubWF4LXctXFxcXFs1ODFweFxcXFxdIHtcXG4gIG1heC13aWR0aDogNTgxcHg7XFxufVxcbi4tdHJhbnNsYXRlLXgtMVxcXFwvMiB7XFxuICAtLXR3LXRyYW5zbGF0ZS14OiAtNTAlO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUodmFyKC0tdHctdHJhbnNsYXRlLXgpLCB2YXIoLS10dy10cmFuc2xhdGUteSkpIHJvdGF0ZSh2YXIoLS10dy1yb3RhdGUpKSBza2V3WCh2YXIoLS10dy1za2V3LXgpKSBza2V3WSh2YXIoLS10dy1za2V3LXkpKSBzY2FsZVgodmFyKC0tdHctc2NhbGUteCkpIHNjYWxlWSh2YXIoLS10dy1zY2FsZS15KSk7XFxufVxcbi5jdXJzb3ItcG9pbnRlciB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5zZWxlY3Qtbm9uZSB7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcbi5hcHBlYXJhbmNlLW5vbmUge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgICAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xcbiAgICAgICAgICBhcHBlYXJhbmNlOiBub25lO1xcbn1cXG4uZ3JpZC1jb2xzLTIge1xcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMiwgbWlubWF4KDAsIDFmcikpO1xcbn1cXG4uZ3JpZC1jb2xzLTEge1xcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMSwgbWlubWF4KDAsIDFmcikpO1xcbn1cXG4uZ3JpZC1jb2xzLTQge1xcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoNCwgbWlubWF4KDAsIDFmcikpO1xcbn1cXG4uZ3JpZC1jb2xzLTEyIHtcXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDEyLCBtaW5tYXgoMCwgMWZyKSk7XFxufVxcbi5ncmlkLWNvbHMtMTAge1xcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMTAsIG1pbm1heCgwLCAxZnIpKTtcXG59XFxuLmZsZXgtY29sIHtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcbi5mbGV4LXdyYXAge1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbn1cXG4ucGxhY2UtY29udGVudC1iZXR3ZWVuIHtcXG4gIHBsYWNlLWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxufVxcbi5pdGVtcy1lbmQge1xcbiAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xcbn1cXG4uaXRlbXMtY2VudGVyIHtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5qdXN0aWZ5LWVuZCB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xcbn1cXG4uanVzdGlmeS1jZW50ZXIge1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcbi5qdXN0aWZ5LWJldHdlZW4ge1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbn1cXG4uZ2FwLTMge1xcbiAgZ2FwOiAwLjc1cmVtO1xcbn1cXG4uZ2FwLTEwIHtcXG4gIGdhcDogMi41cmVtO1xcbn1cXG4uZ2FwLTQge1xcbiAgZ2FwOiAxcmVtO1xcbn1cXG4uc3BhY2UteS00ID4gOm5vdChbaGlkZGVuXSkgfiA6bm90KFtoaWRkZW5dKSB7XFxuICAtLXR3LXNwYWNlLXktcmV2ZXJzZTogMDtcXG4gIG1hcmdpbi10b3A6IGNhbGMoMXJlbSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpKTtcXG4gIG1hcmdpbi1ib3R0b206IGNhbGMoMXJlbSAqIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpO1xcbn1cXG4uc3BhY2UteC0zID4gOm5vdChbaGlkZGVuXSkgfiA6bm90KFtoaWRkZW5dKSB7XFxuICAtLXR3LXNwYWNlLXgtcmV2ZXJzZTogMDtcXG4gIG1hcmdpbi1yaWdodDogY2FsYygwLjc1cmVtICogdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSk7XFxuICBtYXJnaW4tbGVmdDogY2FsYygwLjc1cmVtICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSkpO1xcbn1cXG4uc3BhY2UteC0yID4gOm5vdChbaGlkZGVuXSkgfiA6bm90KFtoaWRkZW5dKSB7XFxuICAtLXR3LXNwYWNlLXgtcmV2ZXJzZTogMDtcXG4gIG1hcmdpbi1yaWdodDogY2FsYygwLjVyZW0gKiB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKTtcXG4gIG1hcmdpbi1sZWZ0OiBjYWxjKDAuNXJlbSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXgtcmV2ZXJzZSkpKTtcXG59XFxuLnNwYWNlLXgtNSA+IDpub3QoW2hpZGRlbl0pIH4gOm5vdChbaGlkZGVuXSkge1xcbiAgLS10dy1zcGFjZS14LXJldmVyc2U6IDA7XFxuICBtYXJnaW4tcmlnaHQ6IGNhbGMoMS4yNXJlbSAqIHZhcigtLXR3LXNwYWNlLXgtcmV2ZXJzZSkpO1xcbiAgbWFyZ2luLWxlZnQ6IGNhbGMoMS4yNXJlbSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXgtcmV2ZXJzZSkpKTtcXG59XFxuLnNwYWNlLXgtOCA+IDpub3QoW2hpZGRlbl0pIH4gOm5vdChbaGlkZGVuXSkge1xcbiAgLS10dy1zcGFjZS14LXJldmVyc2U6IDA7XFxuICBtYXJnaW4tcmlnaHQ6IGNhbGMoMnJlbSAqIHZhcigtLXR3LXNwYWNlLXgtcmV2ZXJzZSkpO1xcbiAgbWFyZ2luLWxlZnQ6IGNhbGMoMnJlbSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXgtcmV2ZXJzZSkpKTtcXG59XFxuLmRpdmlkZS1zb2xpZCA+IDpub3QoW2hpZGRlbl0pIH4gOm5vdChbaGlkZGVuXSkge1xcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG59XFxuLm92ZXJmbG93LWhpZGRlbiB7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG4ub3ZlcmZsb3cteC1hdXRvIHtcXG4gIG92ZXJmbG93LXg6IGF1dG87XFxufVxcbi53aGl0ZXNwYWNlLW5vd3JhcCB7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG4ud2hpdGVzcGFjZS1wcmUtd3JhcCB7XFxuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxufVxcbi5yb3VuZGVkLW1kIHtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMzc1cmVtO1xcbn1cXG4ucm91bmRlZC0zeGwge1xcbiAgYm9yZGVyLXJhZGl1czogMS41cmVtO1xcbn1cXG4ucm91bmRlZC14bCB7XFxuICBib3JkZXItcmFkaXVzOiAwLjc1cmVtO1xcbn1cXG4ucm91bmRlZC1mdWxsIHtcXG4gIGJvcmRlci1yYWRpdXM6IDk5OTlweDtcXG59XFxuLnJvdW5kZWQtbGcge1xcbiAgYm9yZGVyLXJhZGl1czogMC41cmVtO1xcbn1cXG4ucm91bmRlZCB7XFxuICBib3JkZXItcmFkaXVzOiAwLjI1cmVtO1xcbn1cXG4ucm91bmRlZC1sLW1kIHtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDAuMzc1cmVtO1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMC4zNzVyZW07XFxufVxcbi5yb3VuZGVkLWwtbm9uZSB7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwcHg7XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwcHg7XFxufVxcbi5ib3JkZXIge1xcbiAgYm9yZGVyLXdpZHRoOiAxcHg7XFxufVxcbi5ib3JkZXItXFxcXFswXFxcXC41cHhcXFxcXSB7XFxuICBib3JkZXItd2lkdGg6IDAuNXB4O1xcbn1cXG4uYm9yZGVyLTIge1xcbiAgYm9yZGVyLXdpZHRoOiAycHg7XFxufVxcbi5ib3JkZXItXFxcXFsxcHhcXFxcXSB7XFxuICBib3JkZXItd2lkdGg6IDFweDtcXG59XFxuLmJvcmRlci00IHtcXG4gIGJvcmRlci13aWR0aDogNHB4O1xcbn1cXG4uYm9yZGVyLWIge1xcbiAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4O1xcbn1cXG4uYm9yZGVyLWItMiB7XFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAycHg7XFxufVxcbi5ib3JkZXItdCB7XFxuICBib3JkZXItdG9wLXdpZHRoOiAxcHg7XFxufVxcbi5ib3JkZXItYi1cXFxcWzFweFxcXFxdIHtcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDtcXG59XFxuLmJvcmRlci10LTIge1xcbiAgYm9yZGVyLXRvcC13aWR0aDogMnB4O1xcbn1cXG4uYm9yZGVyLXQtXFxcXFsxcHhcXFxcXSB7XFxuICBib3JkZXItdG9wLXdpZHRoOiAxcHg7XFxufVxcbi5ib3JkZXItci0wIHtcXG4gIGJvcmRlci1yaWdodC13aWR0aDogMHB4O1xcbn1cXG4uYm9yZGVyLXNvbGlkIHtcXG4gIGJvcmRlci1zdHlsZTogc29saWQ7XFxufVxcbi5ib3JkZXItZGFzaGVkIHtcXG4gIGJvcmRlci1zdHlsZTogZGFzaGVkO1xcbn1cXG4uYm9yZGVyLWJsdWUtNDAwIHtcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICBib3JkZXItY29sb3I6IHJnYig5NiAxNjUgMjUwIC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxuLmJvcmRlci10cmFuc3BhcmVudCB7XFxuICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG4uYm9yZGVyLWdyYXktMzAwIHtcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICBib3JkZXItY29sb3I6IHJnYigyMDkgMjEzIDIxOSAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxufVxcbi5ib3JkZXItXFxcXFtcXFxcI0JCQkJCQlxcXFxdIHtcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICBib3JkZXItY29sb3I6IHJnYigxODcgMTg3IDE4NyAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxufVxcbi5ib3JkZXItXFxcXFtcXFxcI2UyZTJlMlxcXFxdIHtcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICBib3JkZXItY29sb3I6IHJnYigyMjYgMjI2IDIyNiAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxufVxcbi5ib3JkZXItYmx1ZS04MDAge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDMwIDY0IDE3NSAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxufVxcbi5iZy13aGl0ZSB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjU1IDI1NSAyNTUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy1zbGF0ZS00MDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDE0OCAxNjMgMTg0IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4uYmctYmx1ZS01MDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDU5IDEzMCAyNDYgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy16aW5jLTMwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjEyIDIxMiAyMTYgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy16aW5jLTQwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMTYxIDE2MSAxNzAgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy15ZWxsb3ctNTAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMzQgMTc5IDggLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy1pbmRpZ28tNTAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYig5OSAxMDIgMjQxIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4uYmctdGVhbC01MDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIwIDE4NCAxNjYgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy1ibHVlLTIwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMTkxIDIxOSAyNTQgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy1cXFxcW1xcXFwjM0Q0MTREXFxcXF0ge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDYxIDY1IDc3IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4uYmctZ3JheS0yMDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIyOSAyMzEgMjM1IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4uYmctYmxhY2sge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDAgMCAwIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4uYmctcmVkLTIwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjU0IDIwMiAyMDIgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy1zbGF0ZS0zMDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIwMyAyMTMgMjI1IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4uYmctc2xhdGUtMTAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNDEgMjQ1IDI0OSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuLmJnLWdyYXktNTAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI0OSAyNTAgMjUxIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4ub2JqZWN0LWNvdmVyIHtcXG4gIC1vLW9iamVjdC1maXQ6IGNvdmVyO1xcbiAgICAgb2JqZWN0LWZpdDogY292ZXI7XFxufVxcbi5wLTYge1xcbiAgcGFkZGluZzogMS41cmVtO1xcbn1cXG4ucC0zIHtcXG4gIHBhZGRpbmc6IDAuNzVyZW07XFxufVxcbi5wLTIge1xcbiAgcGFkZGluZzogMC41cmVtO1xcbn1cXG4ucC1cXFxcWzBcXFxcLjEycmVtXFxcXF0ge1xcbiAgcGFkZGluZzogMC4xMnJlbTtcXG59XFxuLnAtMSB7XFxuICBwYWRkaW5nOiAwLjI1cmVtO1xcbn1cXG4ucC1cXFxcWzBcXFxcLjJyZW1cXFxcXSB7XFxuICBwYWRkaW5nOiAwLjJyZW07XFxufVxcbi5wLTAge1xcbiAgcGFkZGluZzogMHB4O1xcbn1cXG4ucHgtNCB7XFxuICBwYWRkaW5nLWxlZnQ6IDFyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAxcmVtO1xcbn1cXG4ucHgtMiB7XFxuICBwYWRkaW5nLWxlZnQ6IDAuNXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDAuNXJlbTtcXG59XFxuLnB5LTIge1xcbiAgcGFkZGluZy10b3A6IDAuNXJlbTtcXG4gIHBhZGRpbmctYm90dG9tOiAwLjVyZW07XFxufVxcbi5weS00IHtcXG4gIHBhZGRpbmctdG9wOiAxcmVtO1xcbiAgcGFkZGluZy1ib3R0b206IDFyZW07XFxufVxcbi5weS0yMCB7XFxuICBwYWRkaW5nLXRvcDogNXJlbTtcXG4gIHBhZGRpbmctYm90dG9tOiA1cmVtO1xcbn1cXG4ucHgtMjAge1xcbiAgcGFkZGluZy1sZWZ0OiA1cmVtO1xcbiAgcGFkZGluZy1yaWdodDogNXJlbTtcXG59XFxuLnB4LTgge1xcbiAgcGFkZGluZy1sZWZ0OiAycmVtO1xcbiAgcGFkZGluZy1yaWdodDogMnJlbTtcXG59XFxuLnB5LTMge1xcbiAgcGFkZGluZy10b3A6IDAuNzVyZW07XFxuICBwYWRkaW5nLWJvdHRvbTogMC43NXJlbTtcXG59XFxuLnB4LTMge1xcbiAgcGFkZGluZy1sZWZ0OiAwLjc1cmVtO1xcbiAgcGFkZGluZy1yaWdodDogMC43NXJlbTtcXG59XFxuLnB4LTEge1xcbiAgcGFkZGluZy1sZWZ0OiAwLjI1cmVtO1xcbiAgcGFkZGluZy1yaWdodDogMC4yNXJlbTtcXG59XFxuLnB5LVxcXFxbNXB4XFxcXF0ge1xcbiAgcGFkZGluZy10b3A6IDVweDtcXG4gIHBhZGRpbmctYm90dG9tOiA1cHg7XFxufVxcbi5weS01IHtcXG4gIHBhZGRpbmctdG9wOiAxLjI1cmVtO1xcbiAgcGFkZGluZy1ib3R0b206IDEuMjVyZW07XFxufVxcbi5weC0xMCB7XFxuICBwYWRkaW5nLWxlZnQ6IDIuNXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDIuNXJlbTtcXG59XFxuLnB5LTEge1xcbiAgcGFkZGluZy10b3A6IDAuMjVyZW07XFxuICBwYWRkaW5nLWJvdHRvbTogMC4yNXJlbTtcXG59XFxuLnBiLTQge1xcbiAgcGFkZGluZy1ib3R0b206IDFyZW07XFxufVxcbi5wdC0yIHtcXG4gIHBhZGRpbmctdG9wOiAwLjVyZW07XFxufVxcbi5wYi0xNCB7XFxuICBwYWRkaW5nLWJvdHRvbTogMy41cmVtO1xcbn1cXG4ucGItXFxcXFs2MHB4XFxcXF0ge1xcbiAgcGFkZGluZy1ib3R0b206IDYwcHg7XFxufVxcbi5wYi0zIHtcXG4gIHBhZGRpbmctYm90dG9tOiAwLjc1cmVtO1xcbn1cXG4ucHQtMSB7XFxuICBwYWRkaW5nLXRvcDogMC4yNXJlbTtcXG59XFxuLnB0LTMge1xcbiAgcGFkZGluZy10b3A6IDAuNzVyZW07XFxufVxcbi5wYi0xIHtcXG4gIHBhZGRpbmctYm90dG9tOiAwLjI1cmVtO1xcbn1cXG4ucGItMiB7XFxuICBwYWRkaW5nLWJvdHRvbTogMC41cmVtO1xcbn1cXG4ucGwtNiB7XFxuICBwYWRkaW5nLWxlZnQ6IDEuNXJlbTtcXG59XFxuLnBsLTMge1xcbiAgcGFkZGluZy1sZWZ0OiAwLjc1cmVtO1xcbn1cXG4ucGwtNyB7XFxuICBwYWRkaW5nLWxlZnQ6IDEuNzVyZW07XFxufVxcbi5wci0zIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDAuNzVyZW07XFxufVxcbi50ZXh0LWNlbnRlciB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcbi5mb250LXNhbnMge1xcbiAgZm9udC1mYW1pbHk6IHVpLXNhbnMtc2VyaWYsIHN5c3RlbS11aSwgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcXFwiU2Vnb2UgVUlcXFwiLCBSb2JvdG8sIFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsIEFyaWFsLCBcXFwiTm90byBTYW5zXFxcIiwgc2Fucy1zZXJpZiwgXFxcIkFwcGxlIENvbG9yIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIFN5bWJvbFxcXCIsIFxcXCJOb3RvIENvbG9yIEVtb2ppXFxcIjtcXG59XFxuLnRleHQtM3hsIHtcXG4gIGZvbnQtc2l6ZTogMS44NzVyZW07XFxuICBsaW5lLWhlaWdodDogMi4yNXJlbTtcXG59XFxuLnRleHQtc20ge1xcbiAgZm9udC1zaXplOiAwLjg3NXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjI1cmVtO1xcbn1cXG4udGV4dC14bCB7XFxuICBmb250LXNpemU6IDEuMjVyZW07XFxuICBsaW5lLWhlaWdodDogMS43NXJlbTtcXG59XFxuLnRleHQtMnhsIHtcXG4gIGZvbnQtc2l6ZTogMS41cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDJyZW07XFxufVxcbi50ZXh0LXhzIHtcXG4gIGZvbnQtc2l6ZTogMC43NXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxcmVtO1xcbn1cXG4udGV4dC1sZyB7XFxuICBmb250LXNpemU6IDEuMTI1cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuNzVyZW07XFxufVxcbi50ZXh0LWJhc2Uge1xcbiAgZm9udC1zaXplOiAxcmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuNXJlbTtcXG59XFxuLmZvbnQtYm9sZCB7XFxuICBmb250LXdlaWdodDogNzAwO1xcbn1cXG4uZm9udC1tZWRpdW0ge1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG59XFxuLmZvbnQtc2VtaWJvbGQge1xcbiAgZm9udC13ZWlnaHQ6IDYwMDtcXG59XFxuLnVwcGVyY2FzZSB7XFxuICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcbn1cXG4ubGVhZGluZy03IHtcXG4gIGxpbmUtaGVpZ2h0OiAxLjc1cmVtO1xcbn1cXG4ubGVhZGluZy1cXFxcWzFcXFxcLjhyZW1cXFxcXSB7XFxuICBsaW5lLWhlaWdodDogMS44cmVtO1xcbn1cXG4udGV4dC1ncmF5LTUwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMTA3IDExNCAxMjggLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtYmx1ZS0zMDAge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDE0NyAxOTcgMjUzIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi50ZXh0LXdoaXRlIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigyNTUgMjU1IDI1NSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXG4udGV4dC1ncmF5LTYwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoNzUgODUgOTkgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtXFxcXFtcXFxcIzY2NjY3NlxcXFxdIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigxMDIgMTAyIDExOCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXG4udGV4dC1ncmF5LTQwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMTU2IDE2MyAxNzUgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtcmVkLTQwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMjQ4IDExMyAxMTMgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtYmx1ZS01MDAge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDU5IDEzMCAyNDYgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtYmx1ZS00MDAge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDk2IDE2NSAyNTAgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtZ3JheS03MDAge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDU1IDY1IDgxIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi50ZXh0LWJsYWNrIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigwIDAgMCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXG4ucGxhY2Vob2xkZXItZ3JheS00MDA6Oi1tb3otcGxhY2Vob2xkZXIge1xcbiAgLS10dy1wbGFjZWhvbGRlci1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigxNTYgMTYzIDE3NSAvIHZhcigtLXR3LXBsYWNlaG9sZGVyLW9wYWNpdHkpKTtcXG59XFxuLnBsYWNlaG9sZGVyLWdyYXktNDAwOjpwbGFjZWhvbGRlciB7XFxuICAtLXR3LXBsYWNlaG9sZGVyLW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDE1NiAxNjMgMTc1IC8gdmFyKC0tdHctcGxhY2Vob2xkZXItb3BhY2l0eSkpO1xcbn1cXG4ub3BhY2l0eS02MCB7XFxuICBvcGFjaXR5OiAwLjY7XFxufVxcbi5zaGFkb3ctc20ge1xcbiAgLS10dy1zaGFkb3c6IDAgMXB4IDJweCAwIHJnYigwIDAgMCAvIDAuMDUpO1xcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAxcHggMnB4IDAgdmFyKC0tdHctc2hhZG93LWNvbG9yKTtcXG4gIGJveC1zaGFkb3c6IHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctcmluZy1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXNoYWRvdyk7XFxufVxcbi5zaGFkb3cteGwge1xcbiAgLS10dy1zaGFkb3c6IDAgMjBweCAyNXB4IC01cHggcmdiKDAgMCAwIC8gMC4xKSwgMCA4cHggMTBweCAtNnB4IHJnYigwIDAgMCAvIDAuMSk7XFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDIwcHggMjVweCAtNXB4IHZhcigtLXR3LXNoYWRvdy1jb2xvciksIDAgOHB4IDEwcHggLTZweCB2YXIoLS10dy1zaGFkb3ctY29sb3IpO1xcbiAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1yaW5nLXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctc2hhZG93KTtcXG59XFxuLnJpbmctMiB7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogdmFyKC0tdHctcmluZy1pbnNldCkgMCAwIDAgdmFyKC0tdHctcmluZy1vZmZzZXQtd2lkdGgpIHZhcigtLXR3LXJpbmctb2Zmc2V0LWNvbG9yKTtcXG4gIC0tdHctcmluZy1zaGFkb3c6IHZhcigtLXR3LXJpbmctaW5zZXQpIDAgMCAwIGNhbGMoMnB4ICsgdmFyKC0tdHctcmluZy1vZmZzZXQtd2lkdGgpKSB2YXIoLS10dy1yaW5nLWNvbG9yKTtcXG4gIGJveC1zaGFkb3c6IHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksIHZhcigtLXR3LXJpbmctc2hhZG93KSwgdmFyKC0tdHctc2hhZG93LCAwIDAgIzAwMDApO1xcbn1cXG4ucmluZy15ZWxsb3ctNTAwIHtcXG4gIC0tdHctcmluZy1vcGFjaXR5OiAxO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoMjM0IDE3OSA4IC8gdmFyKC0tdHctcmluZy1vcGFjaXR5KSk7XFxufVxcbi5yaW5nLWluZGlnby01MDAge1xcbiAgLS10dy1yaW5nLW9wYWNpdHk6IDE7XFxuICAtLXR3LXJpbmctY29sb3I6IHJnYig5OSAxMDIgMjQxIC8gdmFyKC0tdHctcmluZy1vcGFjaXR5KSk7XFxufVxcbi5yaW5nLXRlYWwtNTAwIHtcXG4gIC0tdHctcmluZy1vcGFjaXR5OiAxO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoMjAgMTg0IDE2NiAvIHZhcigtLXR3LXJpbmctb3BhY2l0eSkpO1xcbn1cXG4ucmluZy1ncmF5LTUwMCB7XFxuICAtLXR3LXJpbmctb3BhY2l0eTogMTtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDEwNyAxMTQgMTI4IC8gdmFyKC0tdHctcmluZy1vcGFjaXR5KSk7XFxufVxcbi5yaW5nLWJsYWNrIHtcXG4gIC0tdHctcmluZy1vcGFjaXR5OiAxO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoMCAwIDAgLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXG59XFxuLnJpbmctcmVkLTUwMCB7XFxuICAtLXR3LXJpbmctb3BhY2l0eTogMTtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDIzOSA2OCA2OCAvIHZhcigtLXR3LXJpbmctb3BhY2l0eSkpO1xcbn1cXG4ucmluZy1ibHVlLTUwMCB7XFxuICAtLXR3LXJpbmctb3BhY2l0eTogMTtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDU5IDEzMCAyNDYgLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXG59XFxuLnJpbmctb2Zmc2V0LTIge1xcbiAgLS10dy1yaW5nLW9mZnNldC13aWR0aDogMnB4O1xcbn1cXG4ucmluZy1vZmZzZXQtMSB7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAxcHg7XFxufVxcbi5maWx0ZXIge1xcbiAgZmlsdGVyOiB2YXIoLS10dy1ibHVyKSB2YXIoLS10dy1icmlnaHRuZXNzKSB2YXIoLS10dy1jb250cmFzdCkgdmFyKC0tdHctZ3JheXNjYWxlKSB2YXIoLS10dy1odWUtcm90YXRlKSB2YXIoLS10dy1pbnZlcnQpIHZhcigtLXR3LXNhdHVyYXRlKSB2YXIoLS10dy1zZXBpYSkgdmFyKC0tdHctZHJvcC1zaGFkb3cpO1xcbn1cXG4udHJhbnNpdGlvbiB7XFxuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBjb2xvciwgYmFja2dyb3VuZC1jb2xvciwgYm9yZGVyLWNvbG9yLCBmaWxsLCBzdHJva2UsIG9wYWNpdHksIGJveC1zaGFkb3csIHRyYW5zZm9ybSwgZmlsdGVyLCAtd2Via2l0LXRleHQtZGVjb3JhdGlvbi1jb2xvciwgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI7XFxuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBjb2xvciwgYmFja2dyb3VuZC1jb2xvciwgYm9yZGVyLWNvbG9yLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIGZpbGwsIHN0cm9rZSwgb3BhY2l0eSwgYm94LXNoYWRvdywgdHJhbnNmb3JtLCBmaWx0ZXIsIGJhY2tkcm9wLWZpbHRlcjtcXG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IGNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXItY29sb3IsIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgZmlsbCwgc3Ryb2tlLCBvcGFjaXR5LCBib3gtc2hhZG93LCB0cmFuc2Zvcm0sIGZpbHRlciwgYmFja2Ryb3AtZmlsdGVyLCAtd2Via2l0LXRleHQtZGVjb3JhdGlvbi1jb2xvciwgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI7XFxuICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtcXG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDE1MG1zO1xcbn1cXG4udHJhbnNpdGlvbi1hbGwge1xcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogYWxsO1xcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XFxuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcXG59XFxuLmR1cmF0aW9uLVxcXFxbMG1zXFxcXF0ge1xcbiAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMG1zO1xcbn1cXG4uZHVyYXRpb24tMTAwMCB7XFxuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxMDAwbXM7XFxufVxcbi5sYXN0XFxcXDpib3JkZXItYi0wOmxhc3QtY2hpbGQge1xcbiAgYm9yZGVyLWJvdHRvbS13aWR0aDogMHB4O1xcbn1cXG4ub2RkXFxcXDpiZy1ibHVlLTUwOm50aC1jaGlsZChvZGQpIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMzkgMjQ2IDI1NSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuLmhvdmVyXFxcXDpjdXJzb3ItcG9pbnRlcjpob3ZlciB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5ob3ZlclxcXFw6Ym9yZGVyLWJsdWUtNTAwOmhvdmVyIHtcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICBib3JkZXItY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxuLmhvdmVyXFxcXDpib3JkZXItZ3JheS00MDA6aG92ZXIge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDE1NiAxNjMgMTc1IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxuLmhvdmVyXFxcXDpib3JkZXItZ3JheS0zMDA6aG92ZXIge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDIwOSAyMTMgMjE5IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxuLmhvdmVyXFxcXDpiZy1ncmF5LTUwOmhvdmVyIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNDkgMjUwIDI1MSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuLmhvdmVyXFxcXDpiZy10ZWFsLTUwMDpob3ZlciB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjAgMTg0IDE2NiAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuLmhvdmVyXFxcXDpiZy1ncmF5LTIwMDpob3ZlciB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjI5IDIzMSAyMzUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5ob3ZlclxcXFw6YmctZ3JheS0xMDA6aG92ZXIge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI0MyAyNDQgMjQ2IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4uaG92ZXJcXFxcOmJnLXdoaXRlOmhvdmVyIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNTUgMjU1IDI1NSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuLmhvdmVyXFxcXDp0ZXh0LWdyYXktNDAwOmhvdmVyIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigxNTYgMTYzIDE3NSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXG4uaG92ZXJcXFxcOnRleHQtYmxhY2s6aG92ZXIge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDAgMCAwIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi5ob3ZlclxcXFw6dGV4dC1ibHVlLTUwMDpob3ZlciB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXG4uaG92ZXJcXFxcOnRleHQtcmVkLTUwMDpob3ZlciB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMjM5IDY4IDY4IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi5ob3ZlclxcXFw6dGV4dC1ncmF5LTUwMDpob3ZlciB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMTA3IDExNCAxMjggLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLmhvdmVyXFxcXDp0ZXh0LWJsdWUtNDAwOmhvdmVyIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYig5NiAxNjUgMjUwIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi5ob3ZlclxcXFw6dW5kZXJsaW5lOmhvdmVyIHtcXG4gIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uLWxpbmU6IHVuZGVybGluZTtcXG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uLWxpbmU6IHVuZGVybGluZTtcXG59XFxuLmZvY3VzXFxcXDpib3JkZXItYmx1ZS00MDA6Zm9jdXMge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDk2IDE2NSAyNTAgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXG4uZm9jdXNcXFxcOmJvcmRlci1vcmFuZ2UtNTAwOmZvY3VzIHtcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICBib3JkZXItY29sb3I6IHJnYigyNDkgMTE1IDIyIC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxuLmZvY3VzXFxcXDpiZy1yZWQtNTAwOmZvY3VzIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMzkgNjggNjggLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5mb2N1c1xcXFw6b3V0bGluZS1ub25lOmZvY3VzIHtcXG4gIG91dGxpbmU6IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIG91dGxpbmUtb2Zmc2V0OiAycHg7XFxufVxcbi5mb2N1c1xcXFw6cmluZy0yOmZvY3VzIHtcXG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiB2YXIoLS10dy1yaW5nLWluc2V0KSAwIDAgMCB2YXIoLS10dy1yaW5nLW9mZnNldC13aWR0aCkgdmFyKC0tdHctcmluZy1vZmZzZXQtY29sb3IpO1xcbiAgLS10dy1yaW5nLXNoYWRvdzogdmFyKC0tdHctcmluZy1pbnNldCkgMCAwIDAgY2FsYygycHggKyB2YXIoLS10dy1yaW5nLW9mZnNldC13aWR0aCkpIHZhcigtLXR3LXJpbmctY29sb3IpO1xcbiAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93KSwgdmFyKC0tdHctcmluZy1zaGFkb3cpLCB2YXIoLS10dy1zaGFkb3csIDAgMCAjMDAwMCk7XFxufVxcbi5mb2N1c1xcXFw6cmluZy1ibHVlLTUwMDpmb2N1cyB7XFxuICAtLXR3LXJpbmctb3BhY2l0eTogMTtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDU5IDEzMCAyNDYgLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXG59XFxuLmZvY3VzXFxcXDpyaW5nLWJsdWUtNDAwOmZvY3VzIHtcXG4gIC0tdHctcmluZy1vcGFjaXR5OiAxO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoOTYgMTY1IDI1MCAvIHZhcigtLXR3LXJpbmctb3BhY2l0eSkpO1xcbn1cXG4uZm9jdXNcXFxcOnJpbmctb3JhbmdlLTUwMDpmb2N1cyB7XFxuICAtLXR3LXJpbmctb3BhY2l0eTogMTtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDI0OSAxMTUgMjIgLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXG59XFxuLmZvY3VzXFxcXDpyaW5nLW9mZnNldC0yOmZvY3VzIHtcXG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDJweDtcXG59XFxuLmFjdGl2ZVxcXFw6YmcteWVsbG93LTUwMDphY3RpdmUge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIzNCAxNzkgOCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuLnBlZXI6Y2hlY2tlZCB+IC5wZWVyLWNoZWNrZWRcXFxcOmJnLWJsdWUtNjAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigzNyA5OSAyMzUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5wZWVyOmNoZWNrZWQgfiAucGVlci1jaGVja2VkXFxcXDp0ZXh0LXdoaXRlIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigyNTUgMjU1IDI1NSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXG5AbWVkaWEgKG1pbi13aWR0aDogNjQwcHgpIHtcXG5cXG4gIC5zbVxcXFw6Y29sLXNwYW4tMTAge1xcbiAgICBncmlkLWNvbHVtbjogc3BhbiAxMCAvIHNwYW4gMTA7XFxuICB9XFxuXFxuICAuc21cXFxcOm10LTcge1xcbiAgICBtYXJnaW4tdG9wOiAxLjc1cmVtO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpncmlkIHtcXG4gICAgZGlzcGxheTogZ3JpZDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWF4LXctXFxcXFszODBweFxcXFxdIHtcXG4gICAgbWF4LXdpZHRoOiAzODBweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Z3JpZC1jb2xzLTUge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg1LCBtaW5tYXgoMCwgMWZyKSk7XFxuICB9XFxuXFxuICAuc21cXFxcOmdyaWQtY29scy0xIHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMSwgbWlubWF4KDAsIDFmcikpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpncmlkLWNvbHMtMyB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDMsIG1pbm1heCgwLCAxZnIpKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Z3JpZC1jb2xzLTEwIHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMTAsIG1pbm1heCgwLCAxZnIpKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGwtNSB7XFxuICAgIHBhZGRpbmctbGVmdDogMS4yNXJlbTtcXG4gIH1cXG59XFxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuXFxuICAubWRcXFxcOmdyaWQtY29scy01IHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoNSwgbWlubWF4KDAsIDFmcikpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpncmlkLWNvbHMtNCB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDQsIG1pbm1heCgwLCAxZnIpKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Z3JpZC1jb2xzLTMge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgzLCBtaW5tYXgoMCwgMWZyKSk7XFxuICB9XFxuXFxuICAubWRcXFxcOmdyaWQtY29scy0yIHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMiwgbWlubWF4KDAsIDFmcikpO1xcbiAgfVxcbn1cXG5AbWVkaWEgKG1pbi13aWR0aDogMTAyNHB4KSB7XFxuXFxuICAubGdcXFxcOmNvbC1zcGFuLTEge1xcbiAgICBncmlkLWNvbHVtbjogc3BhbiAxIC8gc3BhbiAxO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpjb2wtc3Bhbi0xMCB7XFxuICAgIGdyaWQtY29sdW1uOiBzcGFuIDEwIC8gc3BhbiAxMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Y29sLXNwYW4tNSB7XFxuICAgIGdyaWQtY29sdW1uOiBzcGFuIDUgLyBzcGFuIDU7XFxuICB9XFxuXFxuICAubGdcXFxcOmdyaWQtY29scy04IHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoOCwgbWlubWF4KDAsIDFmcikpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpncmlkLWNvbHMtNiB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDYsIG1pbm1heCgwLCAxZnIpKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Z3JpZC1jb2xzLTQge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg0LCBtaW5tYXgoMCwgMWZyKSk7XFxuICB9XFxuXFxuICAubGdcXFxcOmdyaWQtcm93cy01IHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiByZXBlYXQoNSwgbWlubWF4KDAsIDFmcikpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpweC01IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxLjI1cmVtO1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxLjI1cmVtO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpweC0wIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAwcHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDBweDtcXG4gIH1cXG59XFxuQG1lZGlhIChtaW4td2lkdGg6IDEyODBweCkge1xcblxcbiAgLnhsXFxcXDpncmlkLWNvbHMtNSB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDUsIG1pbm1heCgwLCAxZnIpKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Z3JpZC1jb2xzLTMge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgzLCBtaW5tYXgoMCwgMWZyKSk7XFxuICB9XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zdHlsZXMvZ2xvYmFscy5jc3NcIixcIjxubyBzb3Vy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bkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxnQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsMkJBQW1CO0VBQW5CLHdCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSwyQkFBbUI7RUFBbkIsd0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSwrQkFBbUI7RUFBbkIsNEJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLDBCQUFtQjtFQUFuQix1QkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHlCQUFtQjtLQUFuQixzQkFBbUI7VUFBbkI7QUFBbUI7QUFBbkI7RUFBQSx3QkFBbUI7S0FBbkIscUJBQW1CO1VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkIsNERBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CLHVEQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQixzREFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkIsdURBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CLG9EQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxnQ0FBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSwyQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7S0FBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG1CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGlCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGlCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHFCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHFCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGdCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLG1CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG1CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGlCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG1CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGVBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsMkJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsMkJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSwwQ0FBbUI7RUFBbkIsdURBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsZ0ZBQW1CO0VBQW5CLG9HQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDJHQUFtQjtFQUFuQix5R0FBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSx3S0FBbUI7RUFBbkIsd0pBQW1CO0VBQW5CLGdOQUFtQjtFQUFuQix3REFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSx3QkFBbUI7RUFBbkIsd0RBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUZuQjtFQUFBO0NDQUE7QURBQTtFQUFBLG1CQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUE7Q0NBQTtBREFBO0VBQUEsdUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSx1QkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHVCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEsbUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxtQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLG1CQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEsbUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxtQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHFCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEscUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxxQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHFCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEscUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxxQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHdDQ0FBO1VEQUE7Q0NBQTtBREFBO0VBQUEsdUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSx1QkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLG1CQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEsK0JDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSw0R0NBQTtFREFBLDBHQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEscUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxxQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHFCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUE7Q0NBQTtBREFBO0VBQUEsbUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxtQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHFCQ0FBO0VEQUE7Q0NBQTtBREFBOztFQUFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBO0NBQUE7QURBQTs7RUFBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7Q0FBQTtBREFBOztFQUFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBLHNCQ0FBO0lEQUE7R0NBQTs7RURBQTtJQUFBLGtCQ0FBO0lEQUE7R0NBQTtDQUFBO0FEQUE7O0VBQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTtDQUFBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIkB0YWlsd2luZCBiYXNlO1xcbkB0YWlsd2luZCBjb21wb25lbnRzO1xcbkB0YWlsd2luZCB1dGlsaXRpZXM7XFxuXCIsbnVsbF0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app! ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"./pages/_app.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1wcml2YXRlLW5leHQtcGFnZXMlMkZfYXBwJnBhZ2U9JTJGX2FwcCEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxpREFBeUI7QUFDaEQ7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzY3ODIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHBcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL19hcHBcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!\n"));

/***/ }),

/***/ "./public/fdb_logo.png":
/*!*****************************!*\
  !*** ./public/fdb_logo.png ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/fdb_logo.a5ea18a4.png\",\"height\":143,\"width\":173,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ffdb_logo.a5ea18a4.png&w=8&q=70\"});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wdWJsaWMvZmRiX2xvZ28ucG5nLmpzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHVLQUF1SyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvZmRiX2xvZ28ucG5nPzZlMjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1wic3JjXCI6XCIvX25leHQvc3RhdGljL21lZGlhL2ZkYl9sb2dvLmE1ZWExOGE0LnBuZ1wiLFwiaGVpZ2h0XCI6MTQzLFwid2lkdGhcIjoxNzMsXCJibHVyRGF0YVVSTFwiOlwiL19uZXh0L2ltYWdlP3VybD0lMkZfbmV4dCUyRnN0YXRpYyUyRm1lZGlhJTJGZmRiX2xvZ28uYTVlYTE4YTQucG5nJnc9OCZxPTcwXCJ9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./public/fdb_logo.png\n"));

/***/ }),

/***/ "./styles/globals.css":
/*!****************************!*\
  !*** ./styles/globals.css ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvZ2xvYmFscy5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLG9OQUF3RztBQUMxSCwwQkFBMEIsbUJBQU8sQ0FBQyx1ZUFBK087O0FBRWpSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLHVlQUErTztBQUNyUDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHVlQUErTzs7QUFFelE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxVQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3R5bGVzL2dsb2JhbHMuY3NzP2M5ODMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzhdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOF0udXNlWzJdIS4vZ2xvYmFscy5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNfX25leHRfY3NzX19ET19OT1RfVVNFX19cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls4XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzhdLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls4XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzhdLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nconst isOldIE = function isOldIE() {\n    let memo;\n    return function memorize() {\n        if (typeof memo === \"undefined\") {\n            // Test for IE <= 9 as proposed by Browserhacks\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n            // Tests for existence of standard globals is to allow style-loader\n            // to operate correctly into non-standard environments\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\n            memo = Boolean(window && document && document.all && !window.atob);\n        }\n        return memo;\n    };\n}();\nconst getTarget = function getTarget() {\n    const memo = {};\n    return function memorize(target) {\n        if (typeof memo[target] === \"undefined\") {\n            let styleTarget = document.querySelector(target);\n            // Special case to return head of iframe instead of iframe itself\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n                try {\n                    // This will throw an exception if access to iframe is blocked\n                    // due to cross-origin restrictions\n                    styleTarget = styleTarget.contentDocument.head;\n                } catch (e) {\n                    // istanbul ignore next\n                    styleTarget = null;\n                }\n            }\n            memo[target] = styleTarget;\n        }\n        return memo[target];\n    };\n}();\nconst stylesInDom = [];\nfunction getIndexByIdentifier(identifier) {\n    let result = -1;\n    for(let i = 0; i < stylesInDom.length; i++){\n        if (stylesInDom[i].identifier === identifier) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\nfunction modulesToDom(list, options) {\n    const idCountMap = {};\n    const identifiers = [];\n    for(let i = 0; i < list.length; i++){\n        const item = list[i];\n        const id = options.base ? item[0] + options.base : item[0];\n        const count = idCountMap[id] || 0;\n        const identifier = id + \" \" + count.toString();\n        idCountMap[id] = count + 1;\n        const index = getIndexByIdentifier(identifier);\n        const obj = {\n            css: item[1],\n            media: item[2],\n            sourceMap: item[3]\n        };\n        if (index !== -1) {\n            stylesInDom[index].references++;\n            stylesInDom[index].updater(obj);\n        } else {\n            stylesInDom.push({\n                identifier: identifier,\n                updater: addStyle(obj, options),\n                references: 1\n            });\n        }\n        identifiers.push(identifier);\n    }\n    return identifiers;\n}\nfunction insertStyleElement(options) {\n    const style = document.createElement(\"style\");\n    const attributes = options.attributes || {};\n    if (typeof attributes.nonce === \"undefined\") {\n        const nonce = // eslint-disable-next-line no-undef\n         true ? __webpack_require__.nc : 0;\n        if (nonce) {\n            attributes.nonce = nonce;\n        }\n    }\n    Object.keys(attributes).forEach(function(key) {\n        style.setAttribute(key, attributes[key]);\n    });\n    if (typeof options.insert === \"function\") {\n        options.insert(style);\n    } else {\n        const target = getTarget(options.insert || \"head\");\n        if (!target) {\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        }\n        target.appendChild(style);\n    }\n    return style;\n}\nfunction removeStyleElement(style) {\n    // istanbul ignore if\n    if (style.parentNode === null) {\n        return false;\n    }\n    style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */ const replaceText = function replaceText() {\n    const textStore = [];\n    return function replace(index, replacement) {\n        textStore[index] = replacement;\n        return textStore.filter(Boolean).join(\"\\n\");\n    };\n}();\nfunction applyToSingletonTag(style, index, remove, obj) {\n    const css = remove ? \"\" : obj.media ? \"@media \" + obj.media + \" {\" + obj.css + \"}\" : obj.css;\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = replaceText(index, css);\n    } else {\n        const cssNode = document.createTextNode(css);\n        const childNodes = style.childNodes;\n        if (childNodes[index]) {\n            style.removeChild(childNodes[index]);\n        }\n        if (childNodes.length) {\n            style.insertBefore(cssNode, childNodes[index]);\n        } else {\n            style.appendChild(cssNode);\n        }\n    }\n}\nfunction applyToTag(style, options, obj) {\n    let css = obj.css;\n    const media = obj.media;\n    const sourceMap = obj.sourceMap;\n    if (media) {\n        style.setAttribute(\"media\", media);\n    } else {\n        style.removeAttribute(\"media\");\n    }\n    if (sourceMap && typeof btoa !== \"undefined\") {\n        css += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n    }\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        while(style.firstChild){\n            style.removeChild(style.firstChild);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n}\nlet singleton = null;\nlet singletonCounter = 0;\nfunction addStyle(obj, options) {\n    let style;\n    let update;\n    let remove;\n    if (options.singleton) {\n        const styleIndex = singletonCounter++;\n        style = singleton || (singleton = insertStyleElement(options));\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n    } else {\n        style = insertStyleElement(options);\n        update = applyToTag.bind(null, style, options);\n        remove = function() {\n            removeStyleElement(style);\n        };\n    }\n    update(obj);\n    return function updateStyle(newObj) {\n        if (newObj) {\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n                return;\n            }\n            update(obj = newObj);\n        } else {\n            remove();\n        }\n    };\n}\nmodule.exports = function(list, options) {\n    options = options || {};\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n    // tags it will allow on a page\n    if (!options.singleton && typeof options.singleton !== \"boolean\") {\n        options.singleton = isOldIE();\n    }\n    list = list || [];\n    let lastIdentifiers = modulesToDom(list, options);\n    return function update(newList) {\n        newList = newList || [];\n        if (Object.prototype.toString.call(newList) !== \"[object Array]\") {\n            return;\n        }\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            stylesInDom[index].references--;\n        }\n        const newLastIdentifiers = modulesToDom(newList, options);\n        for(let i1 = 0; i1 < lastIdentifiers.length; i1++){\n            const identifier = lastIdentifiers[i1];\n            const index = getIndexByIdentifier(identifier);\n            if (stylesInDom[index].references === 0) {\n                stylesInDom[index].updater();\n                stylesInDom.splice(index, 1);\n            }\n        }\n        lastIdentifiers = newLastIdentifiers;\n    };\n};\n\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUVBQXFFLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yNmVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gICAgbGV0IG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgICAgICBpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAgICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAgICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG59KCk7XG5jb25zdCBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gICAgY29uc3QgbWVtbyA9IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG4gICAgICAgICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICAgIH07XG59KCk7XG5jb25zdCBzdHlsZXNJbkRvbSA9IFtdO1xuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICAgIGxldCByZXN1bHQgPSAtMTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGlkQ291bnRNYXAgPSB7fTtcbiAgICBjb25zdCBpZGVudGlmaWVycyA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgIGNvbnN0IGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgICAgIGNvbnN0IGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGlkICsgXCIgXCIgKyBjb3VudC50b1N0cmluZygpO1xuICAgICAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3Qgb2JqID0ge1xuICAgICAgICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICAgICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBub25jZSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQob3B0aW9ucy5pbnNlcnQgfHwgXCJoZWFkXCIpO1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG59XG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovIGNvbnN0IHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gICAgY29uc3QgdGV4dFN0b3JlID0gW107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKTtcbiAgICB9O1xufSgpO1xuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gICAgY29uc3QgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiICsgb2JqLm1lZGlhICsgXCIge1wiICsgb2JqLmNzcyArIFwifVwiIDogb2JqLmNzcztcbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG4gICAgICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gICAgbGV0IGNzcyA9IG9iai5jc3M7XG4gICAgY29uc3QgbWVkaWEgPSBvYmoubWVkaWE7XG4gICAgY29uc3Qgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpO1xuICAgIH1cbiAgICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcbiAgICB9XG4gICAgLy8gRm9yIG9sZCBJRVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpe1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgfVxufVxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5sZXQgc2luZ2xldG9uQ291bnRlciA9IDA7XG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgICBsZXQgc3R5bGU7XG4gICAgbGV0IHVwZGF0ZTtcbiAgICBsZXQgcmVtb3ZlO1xuICAgIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgICAgICBjb25zdCBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgICAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgICAgIHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlKG9iaik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgICAgICBpZiAobmV3T2JqKSB7XG4gICAgICAgICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG4gICAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICAgIH1cbiAgICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgICBsZXQgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgICAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuICAgICAgICBmb3IobGV0IGkxID0gMDsgaTEgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpMSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaTFdO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIGlmIChzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKCk7XG4gICAgICAgICAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gICAgfTtcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n"));

/***/ }),

/***/ "./components/Footer.tsx":
/*!*******************************!*\
  !*** ./components/Footer.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Footer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction Footer() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"footer\", {\n        className: \" mt-10 px-10 text-center absolute bottom-0 h-[60px] w-full \",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: \"Copyright \\xa9 Sagan Jung 2022. All rights reserved.\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Footer.tsx\",\n                lineNumber: 4,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: \"contact - mk44879@gmail.com\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Footer.tsx\",\n                lineNumber: 5,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Footer.tsx\",\n        lineNumber: 3,\n        columnNumber: 5\n    }, this);\n};\n_c = Footer;\nvar _c;\n$RefreshReg$(_c, \"Footer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0Zvb3Rlci50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFBZSxTQUFTQSxNQUFNLEdBQUc7SUFDL0IscUJBQ0UsOERBQUNDLFFBQU07UUFBQ0MsU0FBUyxFQUFDLDZEQUE2RDs7MEJBQzdFLDhEQUFDQyxHQUFDOzBCQUFDLHNEQUFpRDs7Ozs7b0JBQUk7MEJBQ3hELDhEQUFDQSxHQUFDOzBCQUFDLDZCQUEyQjs7Ozs7b0JBQUk7Ozs7OztZQUMzQixDQUNUO0NBQ0g7QUFQdUJILEtBQUFBLE1BQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Gb290ZXIudHN4P2E3OWYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRm9vdGVyKCkge1xyXG4gIHJldHVybiAoXHJcbiAgICA8Zm9vdGVyIGNsYXNzTmFtZT1cIiBtdC0xMCBweC0xMCB0ZXh0LWNlbnRlciBhYnNvbHV0ZSBib3R0b20tMCBoLVs2MHB4XSB3LWZ1bGwgXCI+XHJcbiAgICAgIDxwPkNvcHlyaWdodCDCqSBTYWdhbiBKdW5nIDIwMjIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuPC9wPlxyXG4gICAgICA8cD5jb250YWN0IC0gbWs0NDg3OUBnbWFpbC5jb208L3A+XHJcbiAgICA8L2Zvb3Rlcj5cclxuICApO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJGb290ZXIiLCJmb290ZXIiLCJjbGFzc05hbWUiLCJwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Footer.tsx\n"));

/***/ }),

/***/ "./components/Gnb.tsx":
/*!****************************!*\
  !*** ./components/Gnb.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Gnb; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next-auth/react */ \"./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _libs_client_useUser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/client/useUser */ \"./libs/client/useUser.tsx\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _public_fdb_logo_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../public/fdb_logo.png */ \"./public/fdb_logo.png\");\n\n\n\n\n\n\nvar _s = $RefreshSig$();\nfunction Gnb() {\n    _s();\n    var ref = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_2__.useSession)(), nextSession = ref.data;\n    var ref1 = (0,_libs_client_useUser__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(), user = ref1.user, isLoading = ref1.isLoading;\n    // const { data: CredentailSession } = useSWR(\"/api/users/me\");\n    // console.log(user);\n    // console.log(nextSession);\n    // useEffect(() => {\n    //   if (data && !data.ok) {\n    //     router.replace(\"/enter\");\n    //   }\n    // }, [data, router]);\n    // console.log(data);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n        className: \"flex bg-blue-200 fixed top-0 w-full py-2 z-20\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n            className: \"flex w-full justify-between items-center\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                    className: \"flex uppercase font-bold \",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \" ml-3 mr-3 cursor-pointer\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                className: \" \",\n                                href: \"/\",\n                                passHref: true,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    className: \" flex items-center \",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_4___default()), {\n                                        className: \" rounded-xl border-blue-800 border-4 border-solid\",\n                                        src: _public_fdb_logo_png__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n                                        width: 26,\n                                        height: 26\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                                        lineNumber: 29,\n                                        columnNumber: 17\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 28,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 27,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 26,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"mr-3\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                href: \"/fictions/all/all/all/1/all\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    children: \"\\uC791\\uD488\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 40,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 39,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 38,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"mr-3\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                href: \"/authors/1\",\n                                passHref: true,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    children: \"\\uC791\\uAC00\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 45,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 44,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 43,\n                            columnNumber: 11\n                        }, this),\n                        user ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"mr-3\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                href: \"/fictions/create\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    children: \"Create\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 54,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 53,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 52,\n                            columnNumber: 13\n                        }, this) : null\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                    lineNumber: 25,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                    className: \" flex font-bold items-center\",\n                    children: [\n                        user ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"mr-3\",\n                            children: \"Admin\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 60,\n                            columnNumber: 19\n                        }, this) : null,\n                        nextSession ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \" mr-3 p-0 flex items-center cursor-pointer min-w-[26px]\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                className: \" rounded-full\",\n                                href: \"/profile\",\n                                passHref: true,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    className: \" flex items-center\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_4___default()), {\n                                        className: \" rounded-full\",\n                                        src: nextSession.user.image || \"\",\n                                        width: 26,\n                                        height: 26\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                                        lineNumber: 65,\n                                        columnNumber: 19\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                                    lineNumber: 64,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 63,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 62,\n                            columnNumber: 13\n                        }, this) : null,\n                        nextSession ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            className: \" mr-5 font-bold\",\n                            onClick: function() {\n                                return (0,next_auth_react__WEBPACK_IMPORTED_MODULE_2__.signOut)();\n                            },\n                            children: \"Sign out\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 76,\n                            columnNumber: 13\n                        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                            href: \"/enter\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                className: \" mr-5 hover:cursor-pointer\",\n                                children: \"Enter\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                                lineNumber: 81,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                            lineNumber: 80,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n                    lineNumber: 59,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n            lineNumber: 24,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Gnb.tsx\",\n        lineNumber: 23,\n        columnNumber: 5\n    }, this);\n};\n_s(Gnb, \"hok5D1BpjBZA3UVuT/spEw5bbE0=\", false, function() {\n    return [\n        next_auth_react__WEBPACK_IMPORTED_MODULE_2__.useSession,\n        _libs_client_useUser__WEBPACK_IMPORTED_MODULE_3__[\"default\"]\n    ];\n});\n_c = Gnb;\nvar _c;\n$RefreshReg$(_c, \"Gnb\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ozs7d0NBQ1A7Ozs7O29DQUNDOzs7OztnQ0FDSixHQUNILElBQUk7d0JBQ1BiLFdBQVcsaUJBQ1YsOERBQUNlLFFBQU07NEJBQUNYLFNBQVMsRUFBQyxpQkFBaUI7NEJBQUNZLE9BQU8sRUFBRTt1Q0FBTXRCLHdEQUFPLEVBQUU7NkJBQUE7c0NBQUUsVUFFOUQ7Ozs7O2dDQUFTLGlCQUVULDhEQUFDRixrREFBSTs0QkFBQ2dCLElBQUksRUFBQyxRQUFRO3NDQUNqQiw0RUFBQ0QsSUFBRTtnQ0FBQ0gsU0FBUyxFQUFDLDRCQUE0QjswQ0FBQyxPQUFLOzs7OztvQ0FBSzs7Ozs7Z0NBQ2hEOzs7Ozs7d0JBRU47Ozs7OztnQkFDRDs7Ozs7WUFDQyxDQUNUO0NBQ0g7R0E5RXVCTixHQUFHOztRQUNLTCx1REFBVTtRQUNaRSw0REFBTzs7O0FBRmJHLEtBQUFBLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9HbmIudHN4PzVjOGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiO1xyXG5pbXBvcnQgeyB1c2VTZXNzaW9uLCBzaWduSW4sIHNpZ25PdXQgfSBmcm9tIFwibmV4dC1hdXRoL3JlYWN0XCI7XHJcbmltcG9ydCB1c2VVc2VyIGZyb20gXCJAbGlicy9jbGllbnQvdXNlVXNlclwiO1xyXG5pbXBvcnQgdXNlU1dSIGZyb20gXCJzd3JcIjtcclxuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCByb3V0ZXIgZnJvbSBcIm5leHQvcm91dGVyXCI7XHJcbmltcG9ydCBJbWFnZSBmcm9tIFwibmV4dC9pbWFnZVwiO1xyXG5pbXBvcnQgbG9nbyBmcm9tIFwiLi4vcHVibGljL2ZkYl9sb2dvLnBuZ1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gR25iKCkge1xyXG4gIGNvbnN0IHsgZGF0YTogbmV4dFNlc3Npb24gfSA9IHVzZVNlc3Npb24oKTtcclxuICBjb25zdCB7IHVzZXIsIGlzTG9hZGluZyB9ID0gdXNlVXNlcigpO1xyXG4gIC8vIGNvbnN0IHsgZGF0YTogQ3JlZGVudGFpbFNlc3Npb24gfSA9IHVzZVNXUihcIi9hcGkvdXNlcnMvbWVcIik7XHJcbiAgLy8gY29uc29sZS5sb2codXNlcik7XHJcbiAgLy8gY29uc29sZS5sb2cobmV4dFNlc3Npb24pO1xyXG4gIC8vIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgLy8gICBpZiAoZGF0YSAmJiAhZGF0YS5vaykge1xyXG4gIC8vICAgICByb3V0ZXIucmVwbGFjZShcIi9lbnRlclwiKTtcclxuICAvLyAgIH1cclxuICAvLyB9LCBbZGF0YSwgcm91dGVyXSk7XHJcbiAgLy8gY29uc29sZS5sb2coZGF0YSk7XHJcbiAgcmV0dXJuIChcclxuICAgIDxoZWFkZXIgY2xhc3NOYW1lPVwiZmxleCBiZy1ibHVlLTIwMCBmaXhlZCB0b3AtMCB3LWZ1bGwgcHktMiB6LTIwXCI+XHJcbiAgICAgIDxuYXYgY2xhc3NOYW1lPVwiZmxleCB3LWZ1bGwganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlclwiPlxyXG4gICAgICAgIDx1bCBjbGFzc05hbWU9XCJmbGV4IHVwcGVyY2FzZSBmb250LWJvbGQgXCI+XHJcbiAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwiIG1sLTMgbXItMyBjdXJzb3ItcG9pbnRlclwiPlxyXG4gICAgICAgICAgICA8TGluayBjbGFzc05hbWU9XCIgXCIgaHJlZj1cIi9cIiBwYXNzSHJlZj5cclxuICAgICAgICAgICAgICA8YSBjbGFzc05hbWU9XCIgZmxleCBpdGVtcy1jZW50ZXIgXCI+XHJcbiAgICAgICAgICAgICAgICA8SW1hZ2VcclxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiIHJvdW5kZWQteGwgYm9yZGVyLWJsdWUtODAwIGJvcmRlci00IGJvcmRlci1zb2xpZFwiXHJcbiAgICAgICAgICAgICAgICAgIHNyYz17bG9nb31cclxuICAgICAgICAgICAgICAgICAgd2lkdGg9ezI2fVxyXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ9ezI2fVxyXG4gICAgICAgICAgICAgICAgPjwvSW1hZ2U+XHJcbiAgICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm1yLTNcIj5cclxuICAgICAgICAgICAgPExpbmsgaHJlZj1cIi9maWN0aW9ucy9hbGwvYWxsL2FsbC8xL2FsbFwiPlxyXG4gICAgICAgICAgICAgIDxhPuyeke2SiDwvYT5cclxuICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgPC9saT5cclxuICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJtci0zXCI+XHJcbiAgICAgICAgICAgIDxMaW5rIGhyZWY9XCIvYXV0aG9ycy8xXCIgcGFzc0hyZWY+XHJcbiAgICAgICAgICAgICAgPGE+7J6R6rCAPC9hPlxyXG4gICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgey8qIDxMaW5rIGhyZWY9XCIvcmFua2luZ1wiPlxyXG4gICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibXItM1wiPlJhbmtpbmc8L2xpPlxyXG4gICAgICAgICAgPC9MaW5rPiAqL31cclxuICAgICAgICAgIHt1c2VyID8gKFxyXG4gICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibXItM1wiPlxyXG4gICAgICAgICAgICAgIDxMaW5rIGhyZWY9XCIvZmljdGlvbnMvY3JlYXRlXCI+XHJcbiAgICAgICAgICAgICAgICA8YT5DcmVhdGU8L2E+XHJcbiAgICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgKSA6IG51bGx9XHJcbiAgICAgICAgPC91bD5cclxuICAgICAgICA8dWwgY2xhc3NOYW1lPVwiIGZsZXggZm9udC1ib2xkIGl0ZW1zLWNlbnRlclwiPlxyXG4gICAgICAgICAge3VzZXIgPyA8bGkgY2xhc3NOYW1lPVwibXItM1wiPkFkbWluPC9saT4gOiBudWxsfVxyXG4gICAgICAgICAge25leHRTZXNzaW9uID8gKFxyXG4gICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwiIG1yLTMgcC0wIGZsZXggaXRlbXMtY2VudGVyIGN1cnNvci1wb2ludGVyIG1pbi13LVsyNnB4XVwiPlxyXG4gICAgICAgICAgICAgIDxMaW5rIGNsYXNzTmFtZT1cIiByb3VuZGVkLWZ1bGxcIiBocmVmPVwiL3Byb2ZpbGVcIiBwYXNzSHJlZj5cclxuICAgICAgICAgICAgICAgIDxhIGNsYXNzTmFtZT1cIiBmbGV4IGl0ZW1zLWNlbnRlclwiPlxyXG4gICAgICAgICAgICAgICAgICA8SW1hZ2VcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCIgcm91bmRlZC1mdWxsXCJcclxuICAgICAgICAgICAgICAgICAgICBzcmM9e25leHRTZXNzaW9uLnVzZXIhLmltYWdlIHx8IFwiXCJ9XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg9ezI2fVxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodD17MjZ9XHJcbiAgICAgICAgICAgICAgICAgID48L0ltYWdlPlxyXG4gICAgICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICkgOiBudWxsfVxyXG4gICAgICAgICAge25leHRTZXNzaW9uID8gKFxyXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cIiBtci01IGZvbnQtYm9sZFwiIG9uQ2xpY2s9eygpID0+IHNpZ25PdXQoKX0+XHJcbiAgICAgICAgICAgICAgU2lnbiBvdXRcclxuICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICApIDogKFxyXG4gICAgICAgICAgICA8TGluayBocmVmPVwiL2VudGVyXCI+XHJcbiAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIiBtci01IGhvdmVyOmN1cnNvci1wb2ludGVyXCI+RW50ZXI8L2xpPlxyXG4gICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICApfVxyXG4gICAgICAgIDwvdWw+XHJcbiAgICAgIDwvbmF2PlxyXG4gICAgPC9oZWFkZXI+XHJcbiAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsiTGluayIsInVzZVNlc3Npb24iLCJzaWduT3V0IiwidXNlVXNlciIsIkltYWdlIiwibG9nbyIsIkduYiIsImRhdGEiLCJuZXh0U2Vzc2lvbiIsInVzZXIiLCJpc0xvYWRpbmciLCJoZWFkZXIiLCJjbGFzc05hbWUiLCJuYXYiLCJ1bCIsImxpIiwiaHJlZiIsInBhc3NIcmVmIiwiYSIsInNyYyIsIndpZHRoIiwiaGVpZ2h0IiwiaW1hZ2UiLCJidXR0b24iLCJvbkNsaWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Gnb.tsx\n"));

/***/ }),

/***/ "./components/Top.tsx":
/*!****************************!*\
  !*** ./components/Top.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Top; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Gnb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Gnb */ \"./components/Gnb.tsx\");\n\n\nfunction Top() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Gnb__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\components\\\\Top.tsx\",\n        lineNumber: 4,\n        columnNumber: 10\n    }, this);\n};\n_c = Top;\nvar _c;\n$RefreshReg$(_c, \"Top\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1RvcC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQXdCO0FBRVQsU0FBU0MsR0FBRyxHQUFHO0lBQzVCLHFCQUFPLDhEQUFDRCw0Q0FBRzs7OztZQUFHLENBQUM7Q0FDaEI7QUFGdUJDLEtBQUFBLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Ub3AudHN4PzFmNWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEduYiBmcm9tIFwiLi9HbmJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRvcCgpIHtcclxuICByZXR1cm4gPEduYiAvPjtcclxufVxyXG4iXSwibmFtZXMiOlsiR25iIiwiVG9wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Top.tsx\n"));

/***/ }),

/***/ "./libs/client/useUser.tsx":
/*!*********************************!*\
  !*** ./libs/client/useUser.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ useUser; }\n/* harmony export */ });\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! swr */ \"./node_modules/swr/dist/index.mjs\");\n\n\n\nvar _s = $RefreshSig$();\nfunction useUser() {\n    _s();\n    var ref = (0,swr__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"/api/users/me\"), data = ref.data, error = ref.error;\n    // const { data: session } = useSession();\n    var router = (0,next_router__WEBPACK_IMPORTED_MODULE_0__.useRouter)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (data && !data.ok) {\n        // router.replace(\"/enter\");\n        }\n    }, [\n        data,\n        router\n    ]);\n    //   return router.replace(\"/enter\");\n    return {\n        user: data === null || data === void 0 ? void 0 : data.profile,\n        isLoading: !data && !error\n    };\n};\n_s(useUser, \"4W9O7/pgHSLAxPizl2rA7NDDAiw=\", false, function() {\n    return [\n        swr__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n        next_router__WEBPACK_IMPORTED_MODULE_0__.useRouter\n    ];\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL2NsaWVudC91c2VVc2VyLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBd0M7QUFDTjtBQUNUOztBQUVWLFNBQVNHLE9BQU8sR0FBRzs7SUFDaEMsSUFBd0JELEdBQXVCLEdBQXZCQSwrQ0FBTSxDQUFDLGVBQWUsQ0FBQyxFQUF2Q0UsSUFBSSxHQUFZRixHQUF1QixDQUF2Q0UsSUFBSSxFQUFFQyxLQUFLLEdBQUtILEdBQXVCLENBQWpDRyxLQUFLO0lBQ25CLDBDQUEwQztJQUMxQyxJQUFNQyxNQUFNLEdBQUdOLHNEQUFTLEVBQUU7SUFDMUJDLGdEQUFTLENBQUMsV0FBTTtRQUNkLElBQUlHLElBQUksSUFBSSxDQUFDQSxJQUFJLENBQUNHLEVBQUUsRUFBRTtRQUNwQiw0QkFBNEI7U0FDN0I7S0FDRixFQUFFO1FBQUNILElBQUk7UUFBRUUsTUFBTTtLQUFDLENBQUMsQ0FBQztJQUVuQixxQ0FBcUM7SUFFckMsT0FBTztRQUFFRSxJQUFJLEVBQUVKLElBQUksYUFBSkEsSUFBSSxXQUFTLEdBQWJBLEtBQUFBLENBQWEsR0FBYkEsSUFBSSxDQUFFSyxPQUFPO1FBQUVDLFNBQVMsRUFBRSxDQUFDTixJQUFJLElBQUksQ0FBQ0MsS0FBSztLQUFFLENBQUM7Q0FDNUQ7R0FidUJGLE9BQU87O1FBQ0xELDJDQUFNO1FBRWZGLGtEQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYnMvY2xpZW50L3VzZVVzZXIudHN4P2M2N2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvcm91dGVyXCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgdXNlU1dSIGZyb20gXCJzd3JcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZVVzZXIoKSB7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gdXNlU1dSKFwiL2FwaS91c2Vycy9tZVwiKTtcclxuICAvLyBjb25zdCB7IGRhdGE6IHNlc3Npb24gfSA9IHVzZVNlc3Npb24oKTtcclxuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGRhdGEgJiYgIWRhdGEub2spIHtcclxuICAgICAgLy8gcm91dGVyLnJlcGxhY2UoXCIvZW50ZXJcIik7XHJcbiAgICB9XHJcbiAgfSwgW2RhdGEsIHJvdXRlcl0pO1xyXG5cclxuICAvLyAgIHJldHVybiByb3V0ZXIucmVwbGFjZShcIi9lbnRlclwiKTtcclxuXHJcbiAgcmV0dXJuIHsgdXNlcjogZGF0YT8ucHJvZmlsZSwgaXNMb2FkaW5nOiAhZGF0YSAmJiAhZXJyb3IgfTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlUm91dGVyIiwidXNlRWZmZWN0IiwidXNlU1dSIiwidXNlVXNlciIsImRhdGEiLCJlcnJvciIsInJvdXRlciIsIm9rIiwidXNlciIsInByb2ZpbGUiLCJpc0xvYWRpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./libs/client/useUser.tsx\n"));

/***/ }),

/***/ "./pages/_app.tsx":
/*!************************!*\
  !*** ./pages/_app.tsx ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @swc/helpers/src/_object_spread.mjs */ \"./node_modules/@swc/helpers/src/_object_spread.mjs\");\n/* harmony import */ var _swc_helpers_src_object_without_properties_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/src/_object_without_properties.mjs */ \"./node_modules/@swc/helpers/src/_object_without_properties.mjs\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../styles/globals.css */ \"./styles/globals.css\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_styles_globals_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Top__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @components/Top */ \"./components/Top.tsx\");\n/* harmony import */ var _components_Footer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @components/Footer */ \"./components/Footer.tsx\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next-auth/react */ \"./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! swr */ \"./node_modules/swr/dist/index.mjs\");\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! recoil */ \"./node_modules/recoil/es/index.js\");\n\n\n\n\n\n\n\n\n\nfunction MyApp(_param) {\n    var Component = _param.Component, session = _param.pageProps.session, pageProps = (0,_swc_helpers_src_object_without_properties_mjs__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(_param.pageProps, [\n        \"session\"\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_auth_react__WEBPACK_IMPORTED_MODULE_4__.SessionProvider, {\n        session: session,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(swr__WEBPACK_IMPORTED_MODULE_5__.SWRConfig, {\n            value: {\n                fetcher: function(url) {\n                    return fetch(url).then(function(response) {\n                        return response.json();\n                    });\n                }\n            },\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(recoil__WEBPACK_IMPORTED_MODULE_6__.RecoilRoot, {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \" min-w-[300px] max-h-fit flex flex-col items-center min-h-[100vh] relative\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Top__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\pages\\\\_app.tsx\",\n                            lineNumber: 26,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                            className: \" mt-10 mx-3 flex-column items-center pb-[60px]\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, (0,_swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_8__[\"default\"])({}, pageProps), void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\pages\\\\_app.tsx\",\n                                lineNumber: 28,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\pages\\\\_app.tsx\",\n                            lineNumber: 27,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Footer__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\pages\\\\_app.tsx\",\n                            lineNumber: 30,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\pages\\\\_app.tsx\",\n                    lineNumber: 25,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\pages\\\\_app.tsx\",\n                lineNumber: 24,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\pages\\\\_app.tsx\",\n            lineNumber: 18,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fictiondbs_carrot_ver\\\\pages\\\\_app.tsx\",\n        lineNumber: 17,\n        columnNumber: 5\n    }, this);\n}\n_c = MyApp;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MyApp);\nvar _c;\n$RefreshReg$(_c, \"MyApp\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9fYXBwLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7OztBQUErQjtBQUVHO0FBQ007QUFDVTtBQUNsQjtBQU9oQjtBQUVoQixTQUFTSyxLQUFLLENBQUMsTUFBNkQsRUFBRTtRQUE3REMsU0FBUyxHQUFYLE1BQTZELENBQTNEQSxTQUFTLEVBQUVDLE9BQW9CLEdBQWpDLE1BQTZELENBQWhEQSxTQUFTLENBQUlDLE9BQU8sRUFBS0QsU0FBUyw4RkFBL0MsTUFBNkQsQ0FBaERBLFNBQVM7UUFBSUMsU0FBTzs7SUFDOUMscUJBQ0UsOERBQUNOLDREQUFlO1FBQUNNLE9BQU8sRUFBRUEsT0FBTztrQkFDL0IsNEVBQUNMLDBDQUFTO1lBQ1JNLEtBQUssRUFBRTtnQkFDTEMsT0FBTyxFQUFFLFNBQUNDLEdBQVc7MkJBQ25CQyxLQUFLLENBQUNELEdBQUcsQ0FBQyxDQUFDRSxJQUFJLENBQUMsU0FBQ0MsUUFBUTsrQkFBS0EsUUFBUSxDQUFDQyxJQUFJLEVBQUU7cUJBQUEsQ0FBQztpQkFBQTthQUNqRDtzQkFFRCw0RUFBQ1gsOENBQVU7MEJBQ1QsNEVBQUNZLEtBQUc7b0JBQUNDLFNBQVMsRUFBQyw0RUFBNkU7O3NDQUMxRiw4REFBQ2pCLHVEQUFHOzs7O2dDQUFHO3NDQUNQLDhEQUFDa0IsU0FBTzs0QkFBQ0QsU0FBUyxFQUFDLGdEQUFnRDtzQ0FDakUsNEVBQUNYLFNBQVMscUZBQUtDLFNBQVM7Ozs7b0NBQUk7Ozs7O2dDQUNwQjtzQ0FDViw4REFBQ04sMERBQU07Ozs7Z0NBQUc7Ozs7Ozt3QkFDTjs7Ozs7b0JBQ0s7Ozs7O2dCQUNIOzs7OztZQUNJLENBQ2xCO0NBQ0g7QUFyQlFJLEtBQUFBLEtBQUs7QUF1QmQsK0RBQWVBLEtBQUssRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9fYXBwLnRzeD8yZmJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBcIi4uL3N0eWxlcy9nbG9iYWxzLmNzc1wiO1xuaW1wb3J0IHR5cGUgeyBBcHBQcm9wcyB9IGZyb20gXCJuZXh0L2FwcFwiO1xuaW1wb3J0IFRvcCBmcm9tIFwiQGNvbXBvbmVudHMvVG9wXCI7XG5pbXBvcnQgRm9vdGVyIGZyb20gXCJAY29tcG9uZW50cy9Gb290ZXJcIjtcbmltcG9ydCB7IFNlc3Npb25Qcm92aWRlciB9IGZyb20gXCJuZXh0LWF1dGgvcmVhY3RcIjtcbmltcG9ydCB7IFNXUkNvbmZpZyB9IGZyb20gXCJzd3JcIjtcbmltcG9ydCB7XG4gIFJlY29pbFJvb3QsXG4gIGF0b20sXG4gIHNlbGVjdG9yLFxuICB1c2VSZWNvaWxTdGF0ZSxcbiAgdXNlUmVjb2lsVmFsdWUsXG59IGZyb20gXCJyZWNvaWxcIjtcblxuZnVuY3Rpb24gTXlBcHAoeyBDb21wb25lbnQsIHBhZ2VQcm9wczogeyBzZXNzaW9uLCAuLi5wYWdlUHJvcHMgfSB9OiBBcHBQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxTZXNzaW9uUHJvdmlkZXIgc2Vzc2lvbj17c2Vzc2lvbn0+XG4gICAgICA8U1dSQ29uZmlnXG4gICAgICAgIHZhbHVlPXt7XG4gICAgICAgICAgZmV0Y2hlcjogKHVybDogc3RyaW5nKSA9PlxuICAgICAgICAgICAgZmV0Y2godXJsKS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKSxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgPFJlY29pbFJvb3Q+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCIgbWluLXctWzMwMHB4XSAgbWF4LWgtZml0IGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIG1pbi1oLVsxMDB2aF0gcmVsYXRpdmVcIj5cbiAgICAgICAgICAgIDxUb3AgLz5cbiAgICAgICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cIiBtdC0xMCBteC0zIGZsZXgtY29sdW1uIGl0ZW1zLWNlbnRlciBwYi1bNjBweF1cIj5cbiAgICAgICAgICAgICAgPENvbXBvbmVudCB7Li4ucGFnZVByb3BzfSAvPlxuICAgICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICAgICAgPEZvb3RlciAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L1JlY29pbFJvb3Q+XG4gICAgICA8L1NXUkNvbmZpZz5cbiAgICA8L1Nlc3Npb25Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTXlBcHA7XG4iXSwibmFtZXMiOlsiVG9wIiwiRm9vdGVyIiwiU2Vzc2lvblByb3ZpZGVyIiwiU1dSQ29uZmlnIiwiUmVjb2lsUm9vdCIsIk15QXBwIiwiQ29tcG9uZW50IiwicGFnZVByb3BzIiwic2Vzc2lvbiIsInZhbHVlIiwiZmV0Y2hlciIsInVybCIsImZldGNoIiwidGhlbiIsInJlc3BvbnNlIiwianNvbiIsImRpdiIsImNsYXNzTmFtZSIsInNlY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/_app.tsx\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_define_property.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_define_property.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _defineProperty; }\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fZGVmaW5lX3Byb3BlcnR5Lm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWUsU0FBU0EsZUFBVCxDQUF5QkMsR0FBekIsRUFBOEJDLEdBQTlCLEVBQW1DQyxLQUFuQyxFQUEwQztFQUN2RCxJQUFJRCxHQUFHLElBQUlELEdBQVgsRUFBZ0I7SUFDZEcsTUFBTSxDQUFDQyxjQUFQLENBQXNCSixHQUF0QixFQUEyQkMsR0FBM0IsRUFBZ0M7TUFDOUJDLEtBQUssRUFBRUEsS0FEdUI7TUFFOUJHLFVBQVUsRUFBRSxJQUZrQjtNQUc5QkMsWUFBWSxFQUFFLElBSGdCO01BSTlCQyxRQUFRLEVBQUU7SUFKb0IsQ0FBaEM7RUFNRCxDQVBELE1BT087SUFDTFAsR0FBRyxDQUFDQyxHQUFELENBQUgsR0FBV0MsS0FBWDtFQUNEOztFQUVELE9BQU9GLEdBQVA7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fZGVmaW5lX3Byb3BlcnR5Lm1qcz9iNTEyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuIl0sIm5hbWVzIjpbIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_define_property.mjs\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_object_spread.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_object_spread.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectSpread; }\n/* harmony export */ });\n/* harmony import */ var _define_property_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_define_property.mjs */ \"./node_modules/@swc/helpers/src/_define_property.mjs\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      (0,_define_property_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]);\n    });\n  }\n\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fb2JqZWN0X3NwcmVhZC5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUVlLFNBQVNDLGFBQVQsQ0FBdUJDLE1BQXZCLEVBQStCO0VBQzVDLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0MsU0FBUyxDQUFDQyxNQUE5QixFQUFzQ0YsQ0FBQyxFQUF2QyxFQUEyQztJQUN6QyxJQUFJRyxNQUFNLEdBQUdGLFNBQVMsQ0FBQ0QsQ0FBRCxDQUFULElBQWdCLElBQWhCLEdBQXVCQyxTQUFTLENBQUNELENBQUQsQ0FBaEMsR0FBc0MsRUFBbkQ7SUFDQSxJQUFJSSxPQUFPLEdBQUdDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZSCxNQUFaLENBQWQ7O0lBRUEsSUFBSSxPQUFPRSxNQUFNLENBQUNFLHFCQUFkLEtBQXdDLFVBQTVDLEVBQXdEO01BQ3RESCxPQUFPLEdBQUdBLE9BQU8sQ0FBQ0ksTUFBUixDQUFlSCxNQUFNLENBQUNFLHFCQUFQLENBQTZCSixNQUE3QixFQUFxQ00sTUFBckMsQ0FBNEMsVUFBVUMsR0FBVixFQUFlO1FBQ2xGLE9BQU9MLE1BQU0sQ0FBQ00sd0JBQVAsQ0FBZ0NSLE1BQWhDLEVBQXdDTyxHQUF4QyxFQUE2Q0UsVUFBcEQ7TUFDRCxDQUZ3QixDQUFmLENBQVY7SUFHRDs7SUFFRFIsT0FBTyxDQUFDUyxPQUFSLENBQWdCLFVBQVVDLEdBQVYsRUFBZTtNQUM3QmpCLGdFQUFjLENBQUNFLE1BQUQsRUFBU2UsR0FBVCxFQUFjWCxNQUFNLENBQUNXLEdBQUQsQ0FBcEIsQ0FBZDtJQUNELENBRkQ7RUFHRDs7RUFFRCxPQUFPZixNQUFQO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9zcmMvX29iamVjdF9zcHJlYWQubWpzPzdkNDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gJy4vX2RlZmluZV9wcm9wZXJ0eS5tanMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59Il0sIm5hbWVzIjpbImRlZmluZVByb3BlcnR5IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJvd25LZXlzIiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImNvbmNhdCIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJmb3JFYWNoIiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_object_spread.mjs\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_object_without_properties.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_object_without_properties.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectWithoutProperties; }\n/* harmony export */ });\n/* harmony import */ var _object_without_properties_loose_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_object_without_properties_loose.mjs */ \"./node_modules/@swc/helpers/src/_object_without_properties_loose.mjs\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = (0,_object_without_properties_loose_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcy5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUVlLFNBQVNDLHdCQUFULENBQWtDQyxNQUFsQyxFQUEwQ0MsUUFBMUMsRUFBb0Q7RUFDakUsSUFBSUQsTUFBTSxJQUFJLElBQWQsRUFBb0IsT0FBTyxFQUFQO0VBQ3BCLElBQUlFLE1BQU0sR0FBR0osZ0ZBQTRCLENBQUNFLE1BQUQsRUFBU0MsUUFBVCxDQUF6QztFQUNBLElBQUlFLEdBQUosRUFBU0MsQ0FBVDs7RUFFQSxJQUFJQyxNQUFNLENBQUNDLHFCQUFYLEVBQWtDO0lBQ2hDLElBQUlDLGdCQUFnQixHQUFHRixNQUFNLENBQUNDLHFCQUFQLENBQTZCTixNQUE3QixDQUF2Qjs7SUFFQSxLQUFLSSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdHLGdCQUFnQixDQUFDQyxNQUFqQyxFQUF5Q0osQ0FBQyxFQUExQyxFQUE4QztNQUM1Q0QsR0FBRyxHQUFHSSxnQkFBZ0IsQ0FBQ0gsQ0FBRCxDQUF0QjtNQUNBLElBQUlILFFBQVEsQ0FBQ1EsT0FBVCxDQUFpQk4sR0FBakIsS0FBeUIsQ0FBN0IsRUFBZ0M7TUFDaEMsSUFBSSxDQUFDRSxNQUFNLENBQUNLLFNBQVAsQ0FBaUJDLG9CQUFqQixDQUFzQ0MsSUFBdEMsQ0FBMkNaLE1BQTNDLEVBQW1ERyxHQUFuRCxDQUFMLEVBQThEO01BQzlERCxNQUFNLENBQUNDLEdBQUQsQ0FBTixHQUFjSCxNQUFNLENBQUNHLEdBQUQsQ0FBcEI7SUFDRDtFQUNGOztFQUVELE9BQU9ELE1BQVA7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcy5tanM/ZDk2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tICcuL19vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlLm1qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0iXSwibmFtZXMiOlsib2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZSIsImV4Y2x1ZGVkIiwidGFyZ2V0Iiwia2V5IiwiaSIsIk9iamVjdCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJsZW5ndGgiLCJpbmRleE9mIiwicHJvdG90eXBlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJjYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_object_without_properties.mjs\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_object_without_properties_loose.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_object_without_properties_loose.mjs ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectWithoutPropertiesLoose; }\n/* harmony export */ });\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZS5tanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlLFNBQVNBLDZCQUFULENBQXVDQyxNQUF2QyxFQUErQ0MsUUFBL0MsRUFBeUQ7RUFDdEUsSUFBSUQsTUFBTSxJQUFJLElBQWQsRUFBb0IsT0FBTyxFQUFQO0VBQ3BCLElBQUlFLE1BQU0sR0FBRyxFQUFiO0VBQ0EsSUFBSUMsVUFBVSxHQUFHQyxNQUFNLENBQUNDLElBQVAsQ0FBWUwsTUFBWixDQUFqQjtFQUNBLElBQUlNLEdBQUosRUFBU0MsQ0FBVDs7RUFFQSxLQUFLQSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdKLFVBQVUsQ0FBQ0ssTUFBM0IsRUFBbUNELENBQUMsRUFBcEMsRUFBd0M7SUFDdENELEdBQUcsR0FBR0gsVUFBVSxDQUFDSSxDQUFELENBQWhCO0lBQ0EsSUFBSU4sUUFBUSxDQUFDUSxPQUFULENBQWlCSCxHQUFqQixLQUF5QixDQUE3QixFQUFnQztJQUNoQ0osTUFBTSxDQUFDSSxHQUFELENBQU4sR0FBY04sTUFBTSxDQUFDTSxHQUFELENBQXBCO0VBQ0Q7O0VBRUQsT0FBT0osTUFBUDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvc3JjL19vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlLm1qcz8yMGI3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuIl0sIm5hbWVzIjpbIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlIiwiZXhjbHVkZWQiLCJ0YXJnZXQiLCJzb3VyY2VLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImtleSIsImkiLCJsZW5ndGgiLCJpbmRleE9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_object_without_properties_loose.mjs\n"));

/***/ }),

/***/ "./node_modules/swr/dist/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/swr/dist/index.mjs ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SWRConfig\": function() { return /* binding */ SWRConfig; },\n/* harmony export */   \"default\": function() { return /* binding */ useSWR; },\n/* harmony export */   \"mutate\": function() { return /* binding */ mutate; },\n/* harmony export */   \"unstable_serialize\": function() { return /* binding */ unstable_serialize; },\n/* harmony export */   \"useSWRConfig\": function() { return /* binding */ useSWRConfig; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nvar noop = function () {}; // Using noop() as the undefined value as undefined can possibly be replaced\n// by something else.  Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\n\n\nvar UNDEFINED =\n/*#__NOINLINE__*/\nnoop();\nvar OBJECT = Object;\n\nvar isUndefined = function (v) {\n  return v === UNDEFINED;\n};\n\nvar isFunction = function (v) {\n  return typeof v == 'function';\n};\n\nvar mergeObjects = function (a, b) {\n  return OBJECT.assign({}, a, b);\n};\n\nvar STR_UNDEFINED = 'undefined'; // NOTE: Use function to guarantee it's re-evaluated between jsdom and node runtime for tests.\n\nvar hasWindow = function () {\n  return typeof window != STR_UNDEFINED;\n};\n\nvar hasDocument = function () {\n  return typeof document != STR_UNDEFINED;\n};\n\nvar hasRequestAnimationFrame = function () {\n  return hasWindow() && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\n}; // use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\n\n\nvar table = new WeakMap(); // counter of the key\n\nvar counter = 0; // A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsible.\n\nvar stableHash = function (arg) {\n  var type = typeof arg;\n  var constructor = arg && arg.constructor;\n  var isDate = constructor == Date;\n  var result;\n  var index;\n\n  if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n    // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n    // If it's already hashed, directly return the result.\n    result = table.get(arg);\n    if (result) return result; // Store the hash first for circular reference detection before entering the\n    // recursive `stableHash` calls.\n    // For other objects like set and map, we use this id directly as the hash.\n\n    result = ++counter + '~';\n    table.set(arg, result);\n\n    if (constructor == Array) {\n      // Array.\n      result = '@';\n\n      for (index = 0; index < arg.length; index++) {\n        result += stableHash(arg[index]) + ',';\n      }\n\n      table.set(arg, result);\n    }\n\n    if (constructor == OBJECT) {\n      // Object, sort keys.\n      result = '#';\n      var keys = OBJECT.keys(arg).sort();\n\n      while (!isUndefined(index = keys.pop())) {\n        if (!isUndefined(arg[index])) {\n          result += index + ':' + stableHash(arg[index]) + ',';\n        }\n      }\n\n      table.set(arg, result);\n    }\n  } else {\n    result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n  }\n\n  return result;\n};\n/**\n * Due to bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a work around, we always assume it's online on first load, and change\n * the status upon `online` or `offline` events.\n */\n\n\nvar online = true;\n\nvar isOnline = function () {\n  return online;\n};\n\nvar hasWin = hasWindow();\nvar hasDoc = hasDocument(); // For node and React Native, `add/removeEventListener` doesn't exist on window.\n\nvar onWindowEvent = hasWin && window.addEventListener ? window.addEventListener.bind(window) : noop;\nvar onDocumentEvent = hasDoc ? document.addEventListener.bind(document) : noop;\nvar offWindowEvent = hasWin && window.removeEventListener ? window.removeEventListener.bind(window) : noop;\nvar offDocumentEvent = hasDoc ? document.removeEventListener.bind(document) : noop;\n\nvar isVisible = function () {\n  var visibilityState = hasDoc && document.visibilityState;\n  return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\n\nvar initFocus = function (callback) {\n  // focus revalidate\n  onDocumentEvent('visibilitychange', callback);\n  onWindowEvent('focus', callback);\n  return function () {\n    offDocumentEvent('visibilitychange', callback);\n    offWindowEvent('focus', callback);\n  };\n};\n\nvar initReconnect = function (callback) {\n  // revalidate on reconnected\n  var onOnline = function () {\n    online = true;\n    callback();\n  }; // nothing to revalidate, just update the status\n\n\n  var onOffline = function () {\n    online = false;\n  };\n\n  onWindowEvent('online', onOnline);\n  onWindowEvent('offline', onOffline);\n  return function () {\n    offWindowEvent('online', onOnline);\n    offWindowEvent('offline', onOffline);\n  };\n};\n\nvar preset = {\n  isOnline: isOnline,\n  isVisible: isVisible\n};\nvar defaultConfigOptions = {\n  initFocus: initFocus,\n  initReconnect: initReconnect\n};\nvar IS_SERVER = !hasWindow() || 'Deno' in window; // Polyfill requestAnimationFrame\n\nvar rAF = function (f) {\n  return hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);\n}; // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\n\n\nvar useIsomorphicLayoutEffect = IS_SERVER ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect; // This assignment is to extend the Navigator type to use effectiveType.\n\nvar navigatorConnection = typeof navigator !== 'undefined' && navigator.connection; // Adjust the config based on slow connection status (<= 70Kbps).\n\nvar slowConnection = !IS_SERVER && navigatorConnection && (['slow-2g', '2g'].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\n\nvar serialize = function (key) {\n  if (isFunction(key)) {\n    try {\n      key = key();\n    } catch (err) {\n      // dependencies not ready\n      key = '';\n    }\n  }\n\n  var args = [].concat(key); // If key is not falsy, or not an empty array, hash it.\n\n  key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n  var infoKey = key ? '$swr$' + key : '';\n  return [key, args, infoKey];\n}; // Global state used to deduplicate requests and store listeners\n\n\nvar SWRGlobalState = new WeakMap();\nvar FOCUS_EVENT = 0;\nvar RECONNECT_EVENT = 1;\nvar MUTATE_EVENT = 2;\n\nvar broadcastState = function (cache, key, data, error, isValidating, revalidate, broadcast) {\n  if (broadcast === void 0) {\n    broadcast = true;\n  }\n\n  var _a = SWRGlobalState.get(cache),\n      EVENT_REVALIDATORS = _a[0],\n      STATE_UPDATERS = _a[1],\n      FETCH = _a[3];\n\n  var revalidators = EVENT_REVALIDATORS[key];\n  var updaters = STATE_UPDATERS[key]; // Cache was populated, update states of all hooks.\n\n  if (broadcast && updaters) {\n    for (var i = 0; i < updaters.length; ++i) {\n      updaters[i](data, error, isValidating);\n    }\n  } // If we also need to revalidate, only do it for the first hook.\n\n\n  if (revalidate) {\n    // Invalidate the key by deleting the concurrent request markers so new\n    // requests will not be deduped.\n    delete FETCH[key];\n\n    if (revalidators && revalidators[0]) {\n      return revalidators[0](MUTATE_EVENT).then(function () {\n        return cache.get(key);\n      });\n    }\n  }\n\n  return cache.get(key);\n}; // Global timestamp.\n\n\nvar __timestamp = 0;\n\nvar getTimestamp = function () {\n  return ++__timestamp;\n};\n\nvar internalMutate = function () {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  return __awaiter(void 0, void 0, void 0, function () {\n    var cache, _key, _data, _opts, options, populateCache, revalidate, rollbackOnError, customOptimisticData, _a, key, keyInfo, _b, MUTATION, data, error, beforeMutationTs, hasCustomOptimisticData, rollbackData, optimisticData, res;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          cache = args[0], _key = args[1], _data = args[2], _opts = args[3];\n          options = typeof _opts === 'boolean' ? {\n            revalidate: _opts\n          } : _opts || {};\n          populateCache = isUndefined(options.populateCache) ? true : options.populateCache;\n          revalidate = options.revalidate !== false;\n          rollbackOnError = options.rollbackOnError !== false;\n          customOptimisticData = options.optimisticData;\n          _a = serialize(_key), key = _a[0], keyInfo = _a[2];\n          if (!key) return [2\n          /*return*/\n          ];\n          _b = SWRGlobalState.get(cache), MUTATION = _b[2]; // If there is no new data provided, revalidate the key with current state.\n\n          if (args.length < 3) {\n            // Revalidate and broadcast state.\n            return [2\n            /*return*/\n            , broadcastState(cache, key, cache.get(key), UNDEFINED, UNDEFINED, revalidate, true)];\n          }\n\n          data = _data;\n          beforeMutationTs = getTimestamp();\n          MUTATION[key] = [beforeMutationTs, 0];\n          hasCustomOptimisticData = !isUndefined(customOptimisticData);\n          rollbackData = cache.get(key); // Do optimistic data update.\n\n          if (hasCustomOptimisticData) {\n            optimisticData = isFunction(customOptimisticData) ? customOptimisticData(rollbackData) : customOptimisticData;\n            cache.set(key, optimisticData);\n            broadcastState(cache, key, optimisticData);\n          }\n\n          if (isFunction(data)) {\n            // `data` is a function, call it passing current cache value.\n            try {\n              data = data(cache.get(key));\n            } catch (err) {\n              // If it throws an error synchronously, we shouldn't update the cache.\n              error = err;\n            }\n          }\n\n          if (!(data && isFunction(data.then))) return [3\n          /*break*/\n          , 2];\n          return [4\n          /*yield*/\n          , data.catch(function (err) {\n            error = err;\n          }) // Check if other mutations have occurred since we've started this mutation.\n          // If there's a race we don't update cache or broadcast the change,\n          // just return the data.\n          ];\n\n        case 1:\n          // This means that the mutation is async, we need to check timestamps to\n          // avoid race conditions.\n          data = _c.sent(); // Check if other mutations have occurred since we've started this mutation.\n          // If there's a race we don't update cache or broadcast the change,\n          // just return the data.\n\n          if (beforeMutationTs !== MUTATION[key][0]) {\n            if (error) throw error;\n            return [2\n            /*return*/\n            , data];\n          } else if (error && hasCustomOptimisticData && rollbackOnError) {\n            // Rollback. Always populate the cache in this case but without\n            // transforming the data.\n            populateCache = true;\n            data = rollbackData;\n            cache.set(key, rollbackData);\n          }\n\n          _c.label = 2;\n\n        case 2:\n          // If we should write back the cache after request.\n          if (populateCache) {\n            if (!error) {\n              // Transform the result into data.\n              if (isFunction(populateCache)) {\n                data = populateCache(data, rollbackData);\n              } // Only update cached data if there's no error. Data can be `undefined` here.\n\n\n              cache.set(key, data);\n            } // Always update or reset the error.\n\n\n            cache.set(keyInfo, mergeObjects(cache.get(keyInfo), {\n              error: error\n            }));\n          } // Reset the timestamp to mark the mutation has ended.\n\n\n          MUTATION[key][1] = getTimestamp();\n          return [4\n          /*yield*/\n          , broadcastState(cache, key, data, error, UNDEFINED, revalidate, !!populateCache) // Throw error or return data\n          ];\n\n        case 3:\n          res = _c.sent(); // Throw error or return data\n\n          if (error) throw error;\n          return [2\n          /*return*/\n          , populateCache ? res : data];\n      }\n    });\n  });\n};\n\nvar revalidateAllKeys = function (revalidators, type) {\n  for (var key in revalidators) {\n    if (revalidators[key][0]) revalidators[key][0](type);\n  }\n};\n\nvar initCache = function (provider, options) {\n  // The global state for a specific provider will be used to deduplicate\n  // requests and store listeners. As well as a mutate function that bound to\n  // the cache.\n  // Provider's global state might be already initialized. Let's try to get the\n  // global state associated with the provider first.\n  if (!SWRGlobalState.has(provider)) {\n    var opts = mergeObjects(defaultConfigOptions, options); // If there's no global state bound to the provider, create a new one with the\n    // new mutate function.\n\n    var EVENT_REVALIDATORS = {};\n    var mutate = internalMutate.bind(UNDEFINED, provider);\n    var unmount = noop; // Update the state if it's new, or the provider has been extended.\n\n    SWRGlobalState.set(provider, [EVENT_REVALIDATORS, {}, {}, {}, mutate]); // This is a new provider, we need to initialize it and setup DOM events\n    // listeners for `focus` and `reconnect` actions.\n\n    if (!IS_SERVER) {\n      // When listening to the native events for auto revalidations,\n      // we intentionally put a delay (setTimeout) here to make sure they are\n      // fired after immediate JavaScript executions, which can possibly be\n      // React's state updates.\n      // This avoids some unnecessary revalidations such as\n      // https://github.com/vercel/swr/issues/1680.\n      var releaseFocus_1 = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n      var releaseReconnect_1 = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n\n      unmount = function () {\n        releaseFocus_1 && releaseFocus_1();\n        releaseReconnect_1 && releaseReconnect_1(); // When un-mounting, we need to remove the cache provider from the state\n        // storage too because it's a side-effect. Otherwise when re-mounting we\n        // will not re-register those event listeners.\n\n        SWRGlobalState.delete(provider);\n      };\n    } // We might want to inject an extra layer on top of `provider` in the future,\n    // such as key serialization, auto GC, etc.\n    // For now, it's just a `Map` interface without any modifications.\n\n\n    return [provider, mutate, unmount];\n  }\n\n  return [provider, SWRGlobalState.get(provider)[4]];\n}; // error retry\n\n\nvar onErrorRetry = function (_, __, config, revalidate, opts) {\n  var maxRetryCount = config.errorRetryCount;\n  var currentRetryCount = opts.retryCount; // Exponential backoff\n\n  var timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n\n  if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n    return;\n  }\n\n  setTimeout(revalidate, timeout, opts);\n}; // Default cache provider\n\n\nvar _a = initCache(new Map()),\n    cache = _a[0],\n    mutate = _a[1]; // Default config\n\n\nvar defaultConfig = mergeObjects({\n  // events\n  onLoadingSlow: noop,\n  onSuccess: noop,\n  onError: noop,\n  onErrorRetry: onErrorRetry,\n  onDiscarded: noop,\n  // switches\n  revalidateOnFocus: true,\n  revalidateOnReconnect: true,\n  revalidateIfStale: true,\n  shouldRetryOnError: true,\n  // timeouts\n  errorRetryInterval: slowConnection ? 10000 : 5000,\n  focusThrottleInterval: 5 * 1000,\n  dedupingInterval: 2 * 1000,\n  loadingTimeout: slowConnection ? 5000 : 3000,\n  // providers\n  compare: function (currentData, newData) {\n    return stableHash(currentData) == stableHash(newData);\n  },\n  isPaused: function () {\n    return false;\n  },\n  cache: cache,\n  mutate: mutate,\n  fallback: {}\n}, // use web preset by default\npreset);\n\nvar mergeConfigs = function (a, b) {\n  // Need to create a new object to avoid mutating the original here.\n  var v = mergeObjects(a, b); // If two configs are provided, merge their `use` and `fallback` options.\n\n  if (b) {\n    var u1 = a.use,\n        f1 = a.fallback;\n    var u2 = b.use,\n        f2 = b.fallback;\n\n    if (u1 && u2) {\n      v.use = u1.concat(u2);\n    }\n\n    if (f1 && f2) {\n      v.fallback = mergeObjects(f1, f2);\n    }\n  }\n\n  return v;\n};\n\nvar SWRConfigContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\n\nvar SWRConfig$1 = function (props) {\n  var value = props.value; // Extend parent context values and middleware.\n\n  var extendedConfig = mergeConfigs((0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext), value); // Should not use the inherited provider.\n\n  var provider = value && value.provider; // Use a lazy initialized state to create the cache on first access.\n\n  var cacheContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function () {\n    return provider ? initCache(provider(extendedConfig.cache || cache), value) : UNDEFINED;\n  })[0]; // Override the cache if a new provider is given.\n\n  if (cacheContext) {\n    extendedConfig.cache = cacheContext[0];\n    extendedConfig.mutate = cacheContext[1];\n  } // Unsubscribe events.\n\n\n  useIsomorphicLayoutEffect(function () {\n    return cacheContext ? cacheContext[2] : UNDEFINED;\n  }, []);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SWRConfigContext.Provider, mergeObjects(props, {\n    value: extendedConfig\n  }));\n};\n/**\n * An implementation of state with dependency-tracking.\n */\n\n\nvar useStateWithDeps = function (state, unmountedRef) {\n  var rerender = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({})[1];\n  var stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state); // If a state property (data, error or isValidating) is accessed by the render\n  // function, we mark the property as a dependency so if it is updated again\n  // in the future, we trigger a rerender.\n  // This is also known as dependency-tracking.\n\n  var stateDependenciesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    data: false,\n    error: false,\n    isValidating: false\n  });\n  /**\n   * @param payload To change stateRef, pass the values explicitly to setState:\n   * @example\n   * ```js\n   * setState({\n   *   isValidating: false\n   *   data: newData // set data to newData\n   *   error: undefined // set error to undefined\n   * })\n   *\n   * setState({\n   *   isValidating: false\n   *   data: undefined // set data to undefined\n   *   error: err // set error to err\n   * })\n   * ```\n   */\n\n  var setState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (payload) {\n    var shouldRerender = false;\n    var currentState = stateRef.current;\n\n    for (var _ in payload) {\n      var k = _; // If the property has changed, update the state and mark rerender as\n      // needed.\n\n      if (currentState[k] !== payload[k]) {\n        currentState[k] = payload[k]; // If the property is accessed by the component, a rerender should be\n        // triggered.\n\n        if (stateDependenciesRef.current[k]) {\n          shouldRerender = true;\n        }\n      }\n    }\n\n    if (shouldRerender && !unmountedRef.current) {\n      rerender({});\n    }\n  }, // config.suspense isn't allowed to change during the lifecycle\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []); // Always update the state reference.\n\n  useIsomorphicLayoutEffect(function () {\n    stateRef.current = state;\n  });\n  return [stateRef, stateDependenciesRef.current, setState];\n};\n\nvar normalize = function (args) {\n  return isFunction(args[1]) ? [args[0], args[1], args[2] || {}] : [args[0], null, (args[1] === null ? args[2] : args[1]) || {}];\n};\n\nvar useSWRConfig = function () {\n  return mergeObjects(defaultConfig, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext));\n}; // It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\n\n\nvar withArgs = function (hook) {\n  return function useSWRArgs() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    } // Get the default and inherited configuration.\n\n\n    var fallbackConfig = useSWRConfig(); // Normalize arguments.\n\n    var _a = normalize(args),\n        key = _a[0],\n        fn = _a[1],\n        _config = _a[2]; // Merge configurations.\n\n\n    var config = mergeConfigs(fallbackConfig, _config); // Apply middleware\n\n    var next = hook;\n    var use = config.use;\n\n    if (use) {\n      for (var i = use.length; i-- > 0;) {\n        next = use[i](next);\n      }\n    }\n\n    return next(key, fn || config.fetcher, config);\n  };\n}; // Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\n\n\nvar subscribeCallback = function (key, callbacks, callback) {\n  var keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n  keyedRevalidators.push(callback);\n  return function () {\n    var index = keyedRevalidators.indexOf(callback);\n\n    if (index >= 0) {\n      // O(1): faster than splice\n      keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n      keyedRevalidators.pop();\n    }\n  };\n};\n\nvar WITH_DEDUPE = {\n  dedupe: true\n};\n\nvar useSWRHandler = function (_key, fetcher, config) {\n  var cache = config.cache,\n      compare = config.compare,\n      fallbackData = config.fallbackData,\n      suspense = config.suspense,\n      revalidateOnMount = config.revalidateOnMount,\n      refreshInterval = config.refreshInterval,\n      refreshWhenHidden = config.refreshWhenHidden,\n      refreshWhenOffline = config.refreshWhenOffline;\n\n  var _a = SWRGlobalState.get(cache),\n      EVENT_REVALIDATORS = _a[0],\n      STATE_UPDATERS = _a[1],\n      MUTATION = _a[2],\n      FETCH = _a[3]; // `key` is the identifier of the SWR `data` state, `keyInfo` holds extra\n  // states such as `error` and `isValidating` inside,\n  // all of them are derived from `_key`.\n  // `fnArgs` is an array of arguments parsed from the key, which will be passed\n  // to the fetcher.\n\n\n  var _b = serialize(_key),\n      key = _b[0],\n      fnArgs = _b[1],\n      keyInfo = _b[2]; // If it's the initial render of this hook.\n\n\n  var initialMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false); // If the hook is unmounted already. This will be used to prevent some effects\n  // to be called after unmounting.\n\n  var unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false); // Refs to keep the key and config.\n\n  var keyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(key);\n  var fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fetcher);\n  var configRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(config);\n\n  var getConfig = function () {\n    return configRef.current;\n  };\n\n  var isActive = function () {\n    return getConfig().isVisible() && getConfig().isOnline();\n  };\n\n  var patchFetchInfo = function (info) {\n    return cache.set(keyInfo, mergeObjects(cache.get(keyInfo), info));\n  }; // Get the current state that SWR should return.\n\n\n  var cached = cache.get(key);\n  var fallback = isUndefined(fallbackData) ? config.fallback[key] : fallbackData;\n  var data = isUndefined(cached) ? fallback : cached;\n  var info = cache.get(keyInfo) || {};\n  var error = info.error;\n  var isInitialMount = !initialMountedRef.current; // - Suspense mode and there's stale data for the initial render.\n  // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.\n  // - `revalidateIfStale` is enabled but `data` is not defined.\n\n  var shouldRevalidate = function () {\n    // If `revalidateOnMount` is set, we take the value directly.\n    if (isInitialMount && !isUndefined(revalidateOnMount)) return revalidateOnMount; // If it's paused, we skip revalidation.\n\n    if (getConfig().isPaused()) return false; // Under suspense mode, it will always fetch on render if there is no\n    // stale data so no need to revalidate immediately on mount again.\n    // If data exists, only revalidate if `revalidateIfStale` is true.\n\n    if (suspense) return isUndefined(data) ? false : config.revalidateIfStale; // If there is no stale data, we need to revalidate on mount;\n    // If `revalidateIfStale` is set to true, we will always revalidate.\n\n    return isUndefined(data) || config.revalidateIfStale;\n  }; // Resolve the current validating state.\n\n\n  var resolveValidating = function () {\n    if (!key || !fetcher) return false;\n    if (info.isValidating) return true; // If it's not mounted yet and it should revalidate on mount, revalidate.\n\n    return isInitialMount && shouldRevalidate();\n  };\n\n  var isValidating = resolveValidating();\n\n  var _c = useStateWithDeps({\n    data: data,\n    error: error,\n    isValidating: isValidating\n  }, unmountedRef),\n      stateRef = _c[0],\n      stateDependencies = _c[1],\n      setState = _c[2]; // The revalidation function is a carefully crafted wrapper of the original\n  // `fetcher`, to correctly handle the many edge cases.\n\n\n  var revalidate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (revalidateOpts) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var currentFetcher, newData, startAt, loading, opts, shouldStartNewRequest, isCurrentKeyMounted, cleanupState, newState, finishRequestAndUpdateState, mutationInfo, err_1;\n\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            currentFetcher = fetcherRef.current;\n\n            if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {\n              return [2\n              /*return*/\n              , false];\n            }\n\n            loading = true;\n            opts = revalidateOpts || {};\n            shouldStartNewRequest = !FETCH[key] || !opts.dedupe;\n\n            isCurrentKeyMounted = function () {\n              return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;\n            };\n\n            cleanupState = function () {\n              // Check if it's still the same request before deleting.\n              var requestInfo = FETCH[key];\n\n              if (requestInfo && requestInfo[1] === startAt) {\n                delete FETCH[key];\n              }\n            };\n\n            newState = {\n              isValidating: false\n            };\n\n            finishRequestAndUpdateState = function () {\n              patchFetchInfo({\n                isValidating: false\n              }); // We can only set state if it's safe (still mounted with the same key).\n\n              if (isCurrentKeyMounted()) {\n                setState(newState);\n              }\n            }; // Start fetching. Change the `isValidating` state, update the cache.\n\n\n            patchFetchInfo({\n              isValidating: true\n            });\n            setState({\n              isValidating: true\n            });\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n\n            if (shouldStartNewRequest) {\n              // Tell all other hooks to change the `isValidating` state.\n              broadcastState(cache, key, stateRef.current.data, stateRef.current.error, true); // If no cache being rendered currently (it shows a blank page),\n              // we trigger the loading slow event.\n\n              if (config.loadingTimeout && !cache.get(key)) {\n                setTimeout(function () {\n                  if (loading && isCurrentKeyMounted()) {\n                    getConfig().onLoadingSlow(key, config);\n                  }\n                }, config.loadingTimeout);\n              } // Start the request and save the timestamp.\n\n\n              FETCH[key] = [currentFetcher.apply(void 0, fnArgs), getTimestamp()];\n            }\n\n            _a = FETCH[key], newData = _a[0], startAt = _a[1];\n            return [4\n            /*yield*/\n            , newData];\n\n          case 2:\n            newData = _b.sent();\n\n            if (shouldStartNewRequest) {\n              // If the request isn't interrupted, clean it up after the\n              // deduplication interval.\n              setTimeout(cleanupState, config.dedupingInterval);\n            } // If there're other ongoing request(s), started after the current one,\n            // we need to ignore the current one to avoid possible race conditions:\n            //   req1------------------>res1        (current one)\n            //        req2---------------->res2\n            // the request that fired later will always be kept.\n            // The timestamp maybe be `undefined` or a number\n\n\n            if (!FETCH[key] || FETCH[key][1] !== startAt) {\n              if (shouldStartNewRequest) {\n                if (isCurrentKeyMounted()) {\n                  getConfig().onDiscarded(key);\n                }\n              }\n\n              return [2\n              /*return*/\n              , false];\n            } // Clear error.\n\n\n            patchFetchInfo({\n              error: UNDEFINED\n            });\n            newState.error = UNDEFINED;\n            mutationInfo = MUTATION[key];\n\n            if (!isUndefined(mutationInfo) && ( // case 1\n            startAt <= mutationInfo[0] || // case 2\n            startAt <= mutationInfo[1] || // case 3\n            mutationInfo[1] === 0)) {\n              finishRequestAndUpdateState();\n\n              if (shouldStartNewRequest) {\n                if (isCurrentKeyMounted()) {\n                  getConfig().onDiscarded(key);\n                }\n              }\n\n              return [2\n              /*return*/\n              , false];\n            } // Deep compare with latest state to avoid extra re-renders.\n            // For local state, compare and assign.\n\n\n            if (!compare(stateRef.current.data, newData)) {\n              newState.data = newData;\n            } else {\n              // data and newData are deeply equal\n              // it should be safe to broadcast the stale data\n              newState.data = stateRef.current.data; // At the end of this function, `brocastState` invokes the `onStateUpdate` function,\n              // which takes care of avoiding the re-render\n            } // For global state, it's possible that the key has changed.\n            // https://github.com/vercel/swr/pull/1058\n\n\n            if (!compare(cache.get(key), newData)) {\n              cache.set(key, newData);\n            } // Trigger the successful callback if it's the original request.\n\n\n            if (shouldStartNewRequest) {\n              if (isCurrentKeyMounted()) {\n                getConfig().onSuccess(newData, key, config);\n              }\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            err_1 = _b.sent();\n            cleanupState(); // Not paused, we continue handling the error. Otherwise discard it.\n\n            if (!getConfig().isPaused()) {\n              // Get a new error, don't use deep comparison for errors.\n              patchFetchInfo({\n                error: err_1\n              });\n              newState.error = err_1; // Error event and retry logic. Only for the actual request, not\n              // deduped ones.\n\n              if (shouldStartNewRequest && isCurrentKeyMounted()) {\n                getConfig().onError(err_1, key, config);\n\n                if (typeof config.shouldRetryOnError === 'boolean' && config.shouldRetryOnError || isFunction(config.shouldRetryOnError) && config.shouldRetryOnError(err_1)) {\n                  // When retrying, dedupe is always enabled\n                  if (isActive()) {\n                    // If it's active, stop. It will auto revalidate when refocusing\n                    // or reconnecting.\n                    getConfig().onErrorRetry(err_1, key, config, revalidate, {\n                      retryCount: (opts.retryCount || 0) + 1,\n                      dedupe: true\n                    });\n                  }\n                }\n              }\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            // Mark loading as stopped.\n            loading = false; // Update the current hook's state.\n\n            finishRequestAndUpdateState(); // Here is the source of the request, need to tell all other hooks to\n            // update their states.\n\n            if (isCurrentKeyMounted() && shouldStartNewRequest) {\n              broadcastState(cache, key, newState.data, newState.error, false);\n            }\n\n            return [2\n            /*return*/\n            , true];\n        }\n      });\n    });\n  }, // `setState` is immutable, and `eventsCallback`, `fnArgs`, `keyInfo`,\n  // and `keyValidating` are depending on `key`, so we can exclude them from\n  // the deps array.\n  //\n  // FIXME:\n  // `fn` and `config` might be changed during the lifecycle,\n  // but they might be changed every render like this.\n  // `useSWR('key', () => fetch('/api/'), { suspense: true })`\n  // So we omit the values from the deps array\n  // even though it might cause unexpected behaviors.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [key]); // Similar to the global mutate, but bound to the current cache and key.\n  // `cache` isn't allowed to change during the lifecycle.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  var boundMutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)( // By using `bind` we don't need to modify the size of the rest arguments.\n  // Due to https://github.com/microsoft/TypeScript/issues/37181, we have to\n  // cast it to any for now.\n  internalMutate.bind(UNDEFINED, cache, function () {\n    return keyRef.current;\n  }), // eslint-disable-next-line react-hooks/exhaustive-deps\n  []); // Always update fetcher and config refs.\n\n  useIsomorphicLayoutEffect(function () {\n    fetcherRef.current = fetcher;\n    configRef.current = config;\n  }); // After mounted or key changed.\n\n  useIsomorphicLayoutEffect(function () {\n    if (!key) return;\n    var keyChanged = key !== keyRef.current;\n    var softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE); // Expose state updater to global event listeners. So we can update hook's\n    // internal state from the outside.\n\n    var onStateUpdate = function (updatedData, updatedError, updatedIsValidating) {\n      setState(mergeObjects({\n        error: updatedError,\n        isValidating: updatedIsValidating\n      }, // Since `setState` only shallowly compares states, we do a deep\n      // comparison here.\n      compare(stateRef.current.data, updatedData) ? UNDEFINED : {\n        data: updatedData\n      }));\n    }; // Expose revalidators to global event listeners. So we can trigger\n    // revalidation from the outside.\n\n\n    var nextFocusRevalidatedAt = 0;\n\n    var onRevalidate = function (type) {\n      if (type == FOCUS_EVENT) {\n        var now = Date.now();\n\n        if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {\n          nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;\n          softRevalidate();\n        }\n      } else if (type == RECONNECT_EVENT) {\n        if (getConfig().revalidateOnReconnect && isActive()) {\n          softRevalidate();\n        }\n      } else if (type == MUTATE_EVENT) {\n        return revalidate();\n      }\n\n      return;\n    };\n\n    var unsubUpdate = subscribeCallback(key, STATE_UPDATERS, onStateUpdate);\n    var unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate); // Mark the component as mounted and update corresponding refs.\n\n    unmountedRef.current = false;\n    keyRef.current = key;\n    initialMountedRef.current = true; // When `key` updates, reset the state to the initial value\n    // and trigger a rerender if necessary.\n\n    if (keyChanged) {\n      setState({\n        data: data,\n        error: error,\n        isValidating: isValidating\n      });\n    } // Trigger a revalidation.\n\n\n    if (shouldRevalidate()) {\n      if (isUndefined(data) || IS_SERVER) {\n        // Revalidate immediately.\n        softRevalidate();\n      } else {\n        // Delay the revalidate if we have data to return so we won't block\n        // rendering.\n        rAF(softRevalidate);\n      }\n    }\n\n    return function () {\n      // Mark it as unmounted.\n      unmountedRef.current = true;\n      unsubUpdate();\n      unsubEvents();\n    };\n  }, [key, revalidate]); // Polling\n\n  useIsomorphicLayoutEffect(function () {\n    var timer;\n\n    function next() {\n      // Use the passed interval\n      // ...or invoke the function with the updated data to get the interval\n      var interval = isFunction(refreshInterval) ? refreshInterval(data) : refreshInterval; // We only start next interval if `refreshInterval` is not 0, and:\n      // - `force` is true, which is the start of polling\n      // - or `timer` is not 0, which means the effect wasn't canceled\n\n      if (interval && timer !== -1) {\n        timer = setTimeout(execute, interval);\n      }\n    }\n\n    function execute() {\n      // Check if it's OK to execute:\n      // Only revalidate when the page is visible, online and not errored.\n      if (!stateRef.current.error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {\n        revalidate(WITH_DEDUPE).then(next);\n      } else {\n        // Schedule next interval to check again.\n        next();\n      }\n    }\n\n    next();\n    return function () {\n      if (timer) {\n        clearTimeout(timer);\n        timer = -1;\n      }\n    };\n  }, [refreshInterval, refreshWhenHidden, refreshWhenOffline, revalidate]); // Display debug info in React DevTools.\n\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(data); // In Suspense mode, we can't return the empty `data` state.\n  // If there is `error`, the `error` needs to be thrown to the error boundary.\n  // If there is no `error`, the `revalidation` promise needs to be thrown to\n  // the suspense boundary.\n\n  if (suspense && isUndefined(data) && key) {\n    // Always update fetcher and config refs even with the Suspense mode.\n    fetcherRef.current = fetcher;\n    configRef.current = config;\n    unmountedRef.current = false;\n    throw isUndefined(error) ? revalidate(WITH_DEDUPE) : error;\n  }\n\n  return {\n    mutate: boundMutate,\n\n    get data() {\n      stateDependencies.data = true;\n      return data;\n    },\n\n    get error() {\n      stateDependencies.error = true;\n      return error;\n    },\n\n    get isValidating() {\n      stateDependencies.isValidating = true;\n      return isValidating;\n    }\n\n  };\n};\n\nvar SWRConfig = OBJECT.defineProperty(SWRConfig$1, 'default', {\n  value: defaultConfig\n});\n\nvar unstable_serialize = function (key) {\n  return serialize(key)[0];\n};\n\nvar useSWR = withArgs(useSWRHandler); // useSWR\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBMEM7SUFDdEM7SUFDQXNJLFVBQVUsQ0FBQzNCLE9BQVgsR0FBcUJVLE9BQXJCO0lBQ0FrQixTQUFTLENBQUM1QixPQUFWLEdBQW9CakQsTUFBcEI7SUFDQXlDLFlBQVksQ0FBQ1EsT0FBYixHQUF1QixLQUF2QjtJQUNBLE1BQU0zSyxXQUFXLENBQUM2RSxLQUFELENBQVgsR0FBcUJFLFVBQVUsQ0FBQzJHLFdBQUQsQ0FBL0IsR0FBK0M3RyxLQUFyRDtFQUNIOztFQUNELE9BQU87SUFDSHNDLE1BQU0sRUFBRTBHLFdBREw7O0lBRUgsSUFBSWpKLElBQUosR0FBVztNQUNQb0ksaUJBQWlCLENBQUNwSSxJQUFsQixHQUF5QixJQUF6QjtNQUNBLE9BQU9BLElBQVA7SUFDSCxDQUxFOztJQU1ILElBQUlDLEtBQUosR0FBWTtNQUNSbUksaUJBQWlCLENBQUNuSSxLQUFsQixHQUEwQixJQUExQjtNQUNBLE9BQU9BLEtBQVA7SUFDSCxDQVRFOztJQVVILElBQUlDLFlBQUosR0FBbUI7TUFDZmtJLGlCQUFpQixDQUFDbEksWUFBbEIsR0FBaUMsSUFBakM7TUFDQSxPQUFPQSxZQUFQO0lBQ0g7O0VBYkUsQ0FBUDtBQWVILENBeFpEOztBQXlaQSxJQUFJK0osU0FBUyxHQUFHL08sTUFBTSxDQUFDZ1AsY0FBUCxDQUFzQmxGLFdBQXRCLEVBQW1DLFNBQW5DLEVBQThDO0VBQzFEbk0sS0FBSyxFQUFFMks7QUFEbUQsQ0FBOUMsQ0FBaEI7O0FBR0EsSUFBSTJHLGtCQUFrQixHQUFHLFVBQVUvSyxHQUFWLEVBQWU7RUFBRSxPQUFPRCxTQUFTLENBQUNDLEdBQUQsQ0FBVCxDQUFlLENBQWYsQ0FBUDtBQUEyQixDQUFyRTs7QUFDQSxJQUFJZ0wsTUFBTSxHQUFHakUsUUFBUSxDQUFDYSxhQUFELENBQXJCLEVBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N3ci9kaXN0L2luZGV4Lm1qcz82MmUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgY3JlYXRlRWxlbWVudCwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlRGVidWdWYWx1ZSB9IGZyb20gJ3JlYWN0JztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuLy8gVXNpbmcgbm9vcCgpIGFzIHRoZSB1bmRlZmluZWQgdmFsdWUgYXMgdW5kZWZpbmVkIGNhbiBwb3NzaWJseSBiZSByZXBsYWNlZFxuLy8gYnkgc29tZXRoaW5nIGVsc2UuICBQcmV0dGllciBpZ25vcmUgYW5kIGV4dHJhIHBhcmVudGhlc2VzIGFyZSBuZWNlc3NhcnkgaGVyZVxuLy8gdG8gZW5zdXJlIHRoYXQgdHNjIGRvZXNuJ3QgcmVtb3ZlIHRoZSBfX05PSU5MSU5FX18gY29tbWVudC5cbi8vIHByZXR0aWVyLWlnbm9yZVxudmFyIFVOREVGSU5FRCA9ICggLyojX19OT0lOTElORV9fKi9ub29wKCkpO1xudmFyIE9CSkVDVCA9IE9iamVjdDtcbnZhciBpc1VuZGVmaW5lZCA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ID09PSBVTkRFRklORUQ7IH07XG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0eXBlb2YgdiA9PSAnZnVuY3Rpb24nOyB9O1xudmFyIG1lcmdlT2JqZWN0cyA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBPQkpFQ1QuYXNzaWduKHt9LCBhLCBiKTsgfTtcbnZhciBTVFJfVU5ERUZJTkVEID0gJ3VuZGVmaW5lZCc7XG4vLyBOT1RFOiBVc2UgZnVuY3Rpb24gdG8gZ3VhcmFudGVlIGl0J3MgcmUtZXZhbHVhdGVkIGJldHdlZW4ganNkb20gYW5kIG5vZGUgcnVudGltZSBmb3IgdGVzdHMuXG52YXIgaGFzV2luZG93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPSBTVFJfVU5ERUZJTkVEOyB9O1xudmFyIGhhc0RvY3VtZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9IFNUUl9VTkRFRklORUQ7IH07XG52YXIgaGFzUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBoYXNXaW5kb3coKSAmJiB0eXBlb2Ygd2luZG93WydyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXSAhPSBTVFJfVU5ERUZJTkVEO1xufTtcblxuLy8gdXNlIFdlYWtNYXAgdG8gc3RvcmUgdGhlIG9iamVjdC0+a2V5IG1hcHBpbmdcbi8vIHNvIHRoZSBvYmplY3RzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbi8vIFdlYWtNYXAgdXNlcyBhIGhhc2h0YWJsZSB1bmRlciB0aGUgaG9vZCwgc28gdGhlIGxvb2t1cFxuLy8gY29tcGxleGl0eSBpcyBhbG1vc3QgTygxKS5cbnZhciB0YWJsZSA9IG5ldyBXZWFrTWFwKCk7XG4vLyBjb3VudGVyIG9mIHRoZSBrZXlcbnZhciBjb3VudGVyID0gMDtcbi8vIEEgc3RhYmxlIGhhc2ggaW1wbGVtZW50YXRpb24gdGhhdCBzdXBwb3J0czpcbi8vIC0gRmFzdCBhbmQgZW5zdXJlcyB1bmlxdWUgaGFzaCBwcm9wZXJ0aWVzXG4vLyAtIEhhbmRsZXMgdW5zZXJpYWxpemFibGUgdmFsdWVzXG4vLyAtIEhhbmRsZXMgb2JqZWN0IGtleSBvcmRlcmluZ1xuLy8gLSBHZW5lcmF0ZXMgc2hvcnQgcmVzdWx0c1xuLy9cbi8vIFRoaXMgaXMgbm90IGEgc2VyaWFsaXphdGlvbiBmdW5jdGlvbiwgYW5kIHRoZSByZXN1bHQgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmVcbi8vIHBhcnNpYmxlLlxudmFyIHN0YWJsZUhhc2ggPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGFyZyAmJiBhcmcuY29uc3RydWN0b3I7XG4gICAgdmFyIGlzRGF0ZSA9IGNvbnN0cnVjdG9yID09IERhdGU7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgaW5kZXg7XG4gICAgaWYgKE9CSkVDVChhcmcpID09PSBhcmcgJiYgIWlzRGF0ZSAmJiBjb25zdHJ1Y3RvciAhPSBSZWdFeHApIHtcbiAgICAgICAgLy8gT2JqZWN0L2Z1bmN0aW9uLCBub3QgbnVsbC9kYXRlL3JlZ2V4cC4gVXNlIFdlYWtNYXAgdG8gc3RvcmUgdGhlIGlkIGZpcnN0LlxuICAgICAgICAvLyBJZiBpdCdzIGFscmVhZHkgaGFzaGVkLCBkaXJlY3RseSByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgICAgcmVzdWx0ID0gdGFibGUuZ2V0KGFyZyk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAvLyBTdG9yZSB0aGUgaGFzaCBmaXJzdCBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGlvbiBiZWZvcmUgZW50ZXJpbmcgdGhlXG4gICAgICAgIC8vIHJlY3Vyc2l2ZSBgc3RhYmxlSGFzaGAgY2FsbHMuXG4gICAgICAgIC8vIEZvciBvdGhlciBvYmplY3RzIGxpa2Ugc2V0IGFuZCBtYXAsIHdlIHVzZSB0aGlzIGlkIGRpcmVjdGx5IGFzIHRoZSBoYXNoLlxuICAgICAgICByZXN1bHQgPSArK2NvdW50ZXIgKyAnfic7XG4gICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PSBBcnJheSkge1xuICAgICAgICAgICAgLy8gQXJyYXkuXG4gICAgICAgICAgICByZXN1bHQgPSAnQCc7XG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBhcmcubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0YWJsZUhhc2goYXJnW2luZGV4XSkgKyAnLCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PSBPQkpFQ1QpIHtcbiAgICAgICAgICAgIC8vIE9iamVjdCwgc29ydCBrZXlzLlxuICAgICAgICAgICAgcmVzdWx0ID0gJyMnO1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPQkpFQ1Qua2V5cyhhcmcpLnNvcnQoKTtcbiAgICAgICAgICAgIHdoaWxlICghaXNVbmRlZmluZWQoKGluZGV4ID0ga2V5cy5wb3AoKSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChhcmdbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gaW5kZXggKyAnOicgKyBzdGFibGVIYXNoKGFyZ1tpbmRleF0pICsgJywnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGlzRGF0ZVxuICAgICAgICAgICAgPyBhcmcudG9KU09OKClcbiAgICAgICAgICAgIDogdHlwZSA9PSAnc3ltYm9sJ1xuICAgICAgICAgICAgICAgID8gYXJnLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICA6IHR5cGUgPT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeShhcmcpXG4gICAgICAgICAgICAgICAgICAgIDogJycgKyBhcmc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIER1ZSB0byBidWcgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Njc4MDc1LFxuICogaXQncyBub3QgcmVsaWFibGUgdG8gZGV0ZWN0IGlmIHRoZSBicm93c2VyIGlzIGN1cnJlbnRseSBvbmxpbmUgb3Igb2ZmbGluZVxuICogYmFzZWQgb24gYG5hdmlnYXRvci5vbkxpbmVgLlxuICogQXMgYSB3b3JrIGFyb3VuZCwgd2UgYWx3YXlzIGFzc3VtZSBpdCdzIG9ubGluZSBvbiBmaXJzdCBsb2FkLCBhbmQgY2hhbmdlXG4gKiB0aGUgc3RhdHVzIHVwb24gYG9ubGluZWAgb3IgYG9mZmxpbmVgIGV2ZW50cy5cbiAqL1xudmFyIG9ubGluZSA9IHRydWU7XG52YXIgaXNPbmxpbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvbmxpbmU7IH07XG52YXIgaGFzV2luID0gaGFzV2luZG93KCk7XG52YXIgaGFzRG9jID0gaGFzRG9jdW1lbnQoKTtcbi8vIEZvciBub2RlIGFuZCBSZWFjdCBOYXRpdmUsIGBhZGQvcmVtb3ZlRXZlbnRMaXN0ZW5lcmAgZG9lc24ndCBleGlzdCBvbiB3aW5kb3cuXG52YXIgb25XaW5kb3dFdmVudCA9IGhhc1dpbiAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgID8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIuYmluZCh3aW5kb3cpXG4gICAgOiBub29wO1xudmFyIG9uRG9jdW1lbnRFdmVudCA9IGhhc0RvYyA/IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIuYmluZChkb2N1bWVudCkgOiBub29wO1xudmFyIG9mZldpbmRvd0V2ZW50ID0gaGFzV2luICYmIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyXG4gICAgPyB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKHdpbmRvdylcbiAgICA6IG5vb3A7XG52YXIgb2ZmRG9jdW1lbnRFdmVudCA9IGhhc0RvY1xuICAgID8gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKGRvY3VtZW50KVxuICAgIDogbm9vcDtcbnZhciBpc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZpc2liaWxpdHlTdGF0ZSA9IGhhc0RvYyAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGU7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHZpc2liaWxpdHlTdGF0ZSkgfHwgdmlzaWJpbGl0eVN0YXRlICE9PSAnaGlkZGVuJztcbn07XG52YXIgaW5pdEZvY3VzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgLy8gZm9jdXMgcmV2YWxpZGF0ZVxuICAgIG9uRG9jdW1lbnRFdmVudCgndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKTtcbiAgICBvbldpbmRvd0V2ZW50KCdmb2N1cycsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBvZmZEb2N1bWVudEV2ZW50KCd2aXNpYmlsaXR5Y2hhbmdlJywgY2FsbGJhY2spO1xuICAgICAgICBvZmZXaW5kb3dFdmVudCgnZm9jdXMnLCBjYWxsYmFjayk7XG4gICAgfTtcbn07XG52YXIgaW5pdFJlY29ubmVjdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIHJldmFsaWRhdGUgb24gcmVjb25uZWN0ZWRcbiAgICB2YXIgb25PbmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9ubGluZSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgICAvLyBub3RoaW5nIHRvIHJldmFsaWRhdGUsIGp1c3QgdXBkYXRlIHRoZSBzdGF0dXNcbiAgICB2YXIgb25PZmZsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbmxpbmUgPSBmYWxzZTtcbiAgICB9O1xuICAgIG9uV2luZG93RXZlbnQoJ29ubGluZScsIG9uT25saW5lKTtcbiAgICBvbldpbmRvd0V2ZW50KCdvZmZsaW5lJywgb25PZmZsaW5lKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBvZmZXaW5kb3dFdmVudCgnb25saW5lJywgb25PbmxpbmUpO1xuICAgICAgICBvZmZXaW5kb3dFdmVudCgnb2ZmbGluZScsIG9uT2ZmbGluZSk7XG4gICAgfTtcbn07XG52YXIgcHJlc2V0ID0ge1xuICAgIGlzT25saW5lOiBpc09ubGluZSxcbiAgICBpc1Zpc2libGU6IGlzVmlzaWJsZVxufTtcbnZhciBkZWZhdWx0Q29uZmlnT3B0aW9ucyA9IHtcbiAgICBpbml0Rm9jdXM6IGluaXRGb2N1cyxcbiAgICBpbml0UmVjb25uZWN0OiBpbml0UmVjb25uZWN0XG59O1xuXG52YXIgSVNfU0VSVkVSID0gIWhhc1dpbmRvdygpIHx8ICdEZW5vJyBpbiB3aW5kb3c7XG4vLyBQb2x5ZmlsbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbnZhciByQUYgPSBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBoYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSA/IHdpbmRvd1sncmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10oZikgOiBzZXRUaW1lb3V0KGYsIDEpO1xufTtcbi8vIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXG4vLyBUbyBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxuLy8gdXNlTGF5b3V0RWZmZWN0IGluIHRoZSBicm93c2VyLlxudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBJU19TRVJWRVIgPyB1c2VFZmZlY3QgOiB1c2VMYXlvdXRFZmZlY3Q7XG4vLyBUaGlzIGFzc2lnbm1lbnQgaXMgdG8gZXh0ZW5kIHRoZSBOYXZpZ2F0b3IgdHlwZSB0byB1c2UgZWZmZWN0aXZlVHlwZS5cbnZhciBuYXZpZ2F0b3JDb25uZWN0aW9uID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBuYXZpZ2F0b3IuY29ubmVjdGlvbjtcbi8vIEFkanVzdCB0aGUgY29uZmlnIGJhc2VkIG9uIHNsb3cgY29ubmVjdGlvbiBzdGF0dXMgKDw9IDcwS2JwcykuXG52YXIgc2xvd0Nvbm5lY3Rpb24gPSAhSVNfU0VSVkVSICYmXG4gICAgbmF2aWdhdG9yQ29ubmVjdGlvbiAmJlxuICAgIChbJ3Nsb3ctMmcnLCAnMmcnXS5pbmNsdWRlcyhuYXZpZ2F0b3JDb25uZWN0aW9uLmVmZmVjdGl2ZVR5cGUpIHx8XG4gICAgICAgIG5hdmlnYXRvckNvbm5lY3Rpb24uc2F2ZURhdGEpO1xuXG52YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChpc0Z1bmN0aW9uKGtleSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGtleSA9IGtleSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGRlcGVuZGVuY2llcyBub3QgcmVhZHlcbiAgICAgICAgICAgIGtleSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBhcmdzID0gW10uY29uY2F0KGtleSk7XG4gICAgLy8gSWYga2V5IGlzIG5vdCBmYWxzeSwgb3Igbm90IGFuIGVtcHR5IGFycmF5LCBoYXNoIGl0LlxuICAgIGtleSA9XG4gICAgICAgIHR5cGVvZiBrZXkgPT0gJ3N0cmluZydcbiAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICA6IChBcnJheS5pc0FycmF5KGtleSkgPyBrZXkubGVuZ3RoIDoga2V5KVxuICAgICAgICAgICAgICAgID8gc3RhYmxlSGFzaChrZXkpXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICB2YXIgaW5mb0tleSA9IGtleSA/ICckc3dyJCcgKyBrZXkgOiAnJztcbiAgICByZXR1cm4gW2tleSwgYXJncywgaW5mb0tleV07XG59O1xuXG4vLyBHbG9iYWwgc3RhdGUgdXNlZCB0byBkZWR1cGxpY2F0ZSByZXF1ZXN0cyBhbmQgc3RvcmUgbGlzdGVuZXJzXG52YXIgU1dSR2xvYmFsU3RhdGUgPSBuZXcgV2Vha01hcCgpO1xuXG52YXIgRk9DVVNfRVZFTlQgPSAwO1xudmFyIFJFQ09OTkVDVF9FVkVOVCA9IDE7XG52YXIgTVVUQVRFX0VWRU5UID0gMjtcblxudmFyIGJyb2FkY2FzdFN0YXRlID0gZnVuY3Rpb24gKGNhY2hlLCBrZXksIGRhdGEsIGVycm9yLCBpc1ZhbGlkYXRpbmcsIHJldmFsaWRhdGUsIGJyb2FkY2FzdCkge1xuICAgIGlmIChicm9hZGNhc3QgPT09IHZvaWQgMCkgeyBicm9hZGNhc3QgPSB0cnVlOyB9XG4gICAgdmFyIF9hID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKSwgRVZFTlRfUkVWQUxJREFUT1JTID0gX2FbMF0sIFNUQVRFX1VQREFURVJTID0gX2FbMV0sIEZFVENIID0gX2FbM107XG4gICAgdmFyIHJldmFsaWRhdG9ycyA9IEVWRU5UX1JFVkFMSURBVE9SU1trZXldO1xuICAgIHZhciB1cGRhdGVycyA9IFNUQVRFX1VQREFURVJTW2tleV07XG4gICAgLy8gQ2FjaGUgd2FzIHBvcHVsYXRlZCwgdXBkYXRlIHN0YXRlcyBvZiBhbGwgaG9va3MuXG4gICAgaWYgKGJyb2FkY2FzdCAmJiB1cGRhdGVycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB1cGRhdGVyc1tpXShkYXRhLCBlcnJvciwgaXNWYWxpZGF0aW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB3ZSBhbHNvIG5lZWQgdG8gcmV2YWxpZGF0ZSwgb25seSBkbyBpdCBmb3IgdGhlIGZpcnN0IGhvb2suXG4gICAgaWYgKHJldmFsaWRhdGUpIHtcbiAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUga2V5IGJ5IGRlbGV0aW5nIHRoZSBjb25jdXJyZW50IHJlcXVlc3QgbWFya2VycyBzbyBuZXdcbiAgICAgICAgLy8gcmVxdWVzdHMgd2lsbCBub3QgYmUgZGVkdXBlZC5cbiAgICAgICAgZGVsZXRlIEZFVENIW2tleV07XG4gICAgICAgIGlmIChyZXZhbGlkYXRvcnMgJiYgcmV2YWxpZGF0b3JzWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0b3JzWzBdKE1VVEFURV9FVkVOVCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xufTtcblxuLy8gR2xvYmFsIHRpbWVzdGFtcC5cbnZhciBfX3RpbWVzdGFtcCA9IDA7XG52YXIgZ2V0VGltZXN0YW1wID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKytfX3RpbWVzdGFtcDsgfTtcblxudmFyIGludGVybmFsTXV0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhY2hlLCBfa2V5LCBfZGF0YSwgX29wdHMsIG9wdGlvbnMsIHBvcHVsYXRlQ2FjaGUsIHJldmFsaWRhdGUsIHJvbGxiYWNrT25FcnJvciwgY3VzdG9tT3B0aW1pc3RpY0RhdGEsIF9hLCBrZXksIGtleUluZm8sIF9iLCBNVVRBVElPTiwgZGF0YSwgZXJyb3IsIGJlZm9yZU11dGF0aW9uVHMsIGhhc0N1c3RvbU9wdGltaXN0aWNEYXRhLCByb2xsYmFja0RhdGEsIG9wdGltaXN0aWNEYXRhLCByZXM7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlID0gYXJnc1swXSwgX2tleSA9IGFyZ3NbMV0sIF9kYXRhID0gYXJnc1syXSwgX29wdHMgPSBhcmdzWzNdO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIF9vcHRzID09PSAnYm9vbGVhbicgPyB7IHJldmFsaWRhdGU6IF9vcHRzIH0gOiBfb3B0cyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcG9wdWxhdGVDYWNoZSA9IGlzVW5kZWZpbmVkKG9wdGlvbnMucG9wdWxhdGVDYWNoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcHRpb25zLnBvcHVsYXRlQ2FjaGU7XG4gICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGUgPSBvcHRpb25zLnJldmFsaWRhdGUgIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByb2xsYmFja09uRXJyb3IgPSBvcHRpb25zLnJvbGxiYWNrT25FcnJvciAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbU9wdGltaXN0aWNEYXRhID0gb3B0aW9ucy5vcHRpbWlzdGljRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBzZXJpYWxpemUoX2tleSksIGtleSA9IF9hWzBdLCBrZXlJbmZvID0gX2FbMl07XG4gICAgICAgICAgICAgICAgICAgIGlmICgha2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICBfYiA9IFNXUkdsb2JhbFN0YXRlLmdldChjYWNoZSksIE1VVEFUSU9OID0gX2JbMl07XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG5ldyBkYXRhIHByb3ZpZGVkLCByZXZhbGlkYXRlIHRoZSBrZXkgd2l0aCBjdXJyZW50IHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZhbGlkYXRlIGFuZCBicm9hZGNhc3Qgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgY2FjaGUuZ2V0KGtleSksIFVOREVGSU5FRCwgVU5ERUZJTkVELCByZXZhbGlkYXRlLCB0cnVlKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9kYXRhO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVNdXRhdGlvblRzID0gZ2V0VGltZXN0YW1wKCk7XG4gICAgICAgICAgICAgICAgICAgIE1VVEFUSU9OW2tleV0gPSBbYmVmb3JlTXV0YXRpb25UcywgMF07XG4gICAgICAgICAgICAgICAgICAgIGhhc0N1c3RvbU9wdGltaXN0aWNEYXRhID0gIWlzVW5kZWZpbmVkKGN1c3RvbU9wdGltaXN0aWNEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcm9sbGJhY2tEYXRhID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG9wdGltaXN0aWMgZGF0YSB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNDdXN0b21PcHRpbWlzdGljRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpY0RhdGEgPSBpc0Z1bmN0aW9uKGN1c3RvbU9wdGltaXN0aWNEYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY3VzdG9tT3B0aW1pc3RpY0RhdGEocm9sbGJhY2tEYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VzdG9tT3B0aW1pc3RpY0RhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCBvcHRpbWlzdGljRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBvcHRpbWlzdGljRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBkYXRhYCBpcyBhIGZ1bmN0aW9uLCBjYWxsIGl0IHBhc3NpbmcgY3VycmVudCBjYWNoZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEoY2FjaGUuZ2V0KGtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IHRocm93cyBhbiBlcnJvciBzeW5jaHJvbm91c2x5LCB3ZSBzaG91bGRuJ3QgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShkYXRhICYmIGlzRnVuY3Rpb24oZGF0YS50aGVuKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBkYXRhLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBvdGhlciBtdXRhdGlvbnMgaGF2ZSBvY2N1cnJlZCBzaW5jZSB3ZSd2ZSBzdGFydGVkIHRoaXMgbXV0YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcmFjZSB3ZSBkb24ndCB1cGRhdGUgY2FjaGUgb3IgYnJvYWRjYXN0IHRoZSBjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHJldHVybiB0aGUgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgbXV0YXRpb24gaXMgYXN5bmMsIHdlIG5lZWQgdG8gY2hlY2sgdGltZXN0YW1wcyB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBhdm9pZCByYWNlIGNvbmRpdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG90aGVyIG11dGF0aW9ucyBoYXZlIG9jY3VycmVkIHNpbmNlIHdlJ3ZlIHN0YXJ0ZWQgdGhpcyBtdXRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHJhY2Ugd2UgZG9uJ3QgdXBkYXRlIGNhY2hlIG9yIGJyb2FkY2FzdCB0aGUgY2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHJldHVybiB0aGUgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZU11dGF0aW9uVHMgIT09IE1VVEFUSU9OW2tleV1bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBoYXNDdXN0b21PcHRpbWlzdGljRGF0YSAmJiByb2xsYmFja09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvbGxiYWNrLiBBbHdheXMgcG9wdWxhdGUgdGhlIGNhY2hlIGluIHRoaXMgY2FzZSBidXQgd2l0aG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtaW5nIHRoZSBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9wdWxhdGVDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcm9sbGJhY2tEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgcm9sbGJhY2tEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBzaG91bGQgd3JpdGUgYmFjayB0aGUgY2FjaGUgYWZ0ZXIgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcHVsYXRlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIHJlc3VsdCBpbnRvIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocG9wdWxhdGVDYWNoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBvcHVsYXRlQ2FjaGUoZGF0YSwgcm9sbGJhY2tEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgY2FjaGVkIGRhdGEgaWYgdGhlcmUncyBubyBlcnJvci4gRGF0YSBjYW4gYmUgYHVuZGVmaW5lZGAgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyB1cGRhdGUgb3IgcmVzZXQgdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleUluZm8sIG1lcmdlT2JqZWN0cyhjYWNoZS5nZXQoa2V5SW5mbyksIHsgZXJyb3I6IGVycm9yIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdGltZXN0YW1wIHRvIG1hcmsgdGhlIG11dGF0aW9uIGhhcyBlbmRlZC5cbiAgICAgICAgICAgICAgICAgICAgTVVUQVRJT05ba2V5XVsxXSA9IGdldFRpbWVzdGFtcCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBkYXRhLCBlcnJvciwgVU5ERUZJTkVELCByZXZhbGlkYXRlLCAhIXBvcHVsYXRlQ2FjaGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBlcnJvciBvciByZXR1cm4gZGF0YVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBlcnJvciBvciByZXR1cm4gZGF0YVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHBvcHVsYXRlQ2FjaGUgPyByZXMgOiBkYXRhXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG52YXIgcmV2YWxpZGF0ZUFsbEtleXMgPSBmdW5jdGlvbiAocmV2YWxpZGF0b3JzLCB0eXBlKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHJldmFsaWRhdG9ycykge1xuICAgICAgICBpZiAocmV2YWxpZGF0b3JzW2tleV1bMF0pXG4gICAgICAgICAgICByZXZhbGlkYXRvcnNba2V5XVswXSh0eXBlKTtcbiAgICB9XG59O1xudmFyIGluaXRDYWNoZSA9IGZ1bmN0aW9uIChwcm92aWRlciwgb3B0aW9ucykge1xuICAgIC8vIFRoZSBnbG9iYWwgc3RhdGUgZm9yIGEgc3BlY2lmaWMgcHJvdmlkZXIgd2lsbCBiZSB1c2VkIHRvIGRlZHVwbGljYXRlXG4gICAgLy8gcmVxdWVzdHMgYW5kIHN0b3JlIGxpc3RlbmVycy4gQXMgd2VsbCBhcyBhIG11dGF0ZSBmdW5jdGlvbiB0aGF0IGJvdW5kIHRvXG4gICAgLy8gdGhlIGNhY2hlLlxuICAgIC8vIFByb3ZpZGVyJ3MgZ2xvYmFsIHN0YXRlIG1pZ2h0IGJlIGFscmVhZHkgaW5pdGlhbGl6ZWQuIExldCdzIHRyeSB0byBnZXQgdGhlXG4gICAgLy8gZ2xvYmFsIHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZXIgZmlyc3QuXG4gICAgaWYgKCFTV1JHbG9iYWxTdGF0ZS5oYXMocHJvdmlkZXIpKSB7XG4gICAgICAgIHZhciBvcHRzID0gbWVyZ2VPYmplY3RzKGRlZmF1bHRDb25maWdPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBnbG9iYWwgc3RhdGUgYm91bmQgdG8gdGhlIHByb3ZpZGVyLCBjcmVhdGUgYSBuZXcgb25lIHdpdGggdGhlXG4gICAgICAgIC8vIG5ldyBtdXRhdGUgZnVuY3Rpb24uXG4gICAgICAgIHZhciBFVkVOVF9SRVZBTElEQVRPUlMgPSB7fTtcbiAgICAgICAgdmFyIG11dGF0ZSA9IGludGVybmFsTXV0YXRlLmJpbmQoVU5ERUZJTkVELCBwcm92aWRlcik7XG4gICAgICAgIHZhciB1bm1vdW50ID0gbm9vcDtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzdGF0ZSBpZiBpdCdzIG5ldywgb3IgdGhlIHByb3ZpZGVyIGhhcyBiZWVuIGV4dGVuZGVkLlxuICAgICAgICBTV1JHbG9iYWxTdGF0ZS5zZXQocHJvdmlkZXIsIFtFVkVOVF9SRVZBTElEQVRPUlMsIHt9LCB7fSwge30sIG11dGF0ZV0pO1xuICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IHByb3ZpZGVyLCB3ZSBuZWVkIHRvIGluaXRpYWxpemUgaXQgYW5kIHNldHVwIERPTSBldmVudHNcbiAgICAgICAgLy8gbGlzdGVuZXJzIGZvciBgZm9jdXNgIGFuZCBgcmVjb25uZWN0YCBhY3Rpb25zLlxuICAgICAgICBpZiAoIUlTX1NFUlZFUikge1xuICAgICAgICAgICAgLy8gV2hlbiBsaXN0ZW5pbmcgdG8gdGhlIG5hdGl2ZSBldmVudHMgZm9yIGF1dG8gcmV2YWxpZGF0aW9ucyxcbiAgICAgICAgICAgIC8vIHdlIGludGVudGlvbmFsbHkgcHV0IGEgZGVsYXkgKHNldFRpbWVvdXQpIGhlcmUgdG8gbWFrZSBzdXJlIHRoZXkgYXJlXG4gICAgICAgICAgICAvLyBmaXJlZCBhZnRlciBpbW1lZGlhdGUgSmF2YVNjcmlwdCBleGVjdXRpb25zLCB3aGljaCBjYW4gcG9zc2libHkgYmVcbiAgICAgICAgICAgIC8vIFJlYWN0J3Mgc3RhdGUgdXBkYXRlcy5cbiAgICAgICAgICAgIC8vIFRoaXMgYXZvaWRzIHNvbWUgdW5uZWNlc3NhcnkgcmV2YWxpZGF0aW9ucyBzdWNoIGFzXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL3N3ci9pc3N1ZXMvMTY4MC5cbiAgICAgICAgICAgIHZhciByZWxlYXNlRm9jdXNfMSA9IG9wdHMuaW5pdEZvY3VzKHNldFRpbWVvdXQuYmluZChVTkRFRklORUQsIHJldmFsaWRhdGVBbGxLZXlzLmJpbmQoVU5ERUZJTkVELCBFVkVOVF9SRVZBTElEQVRPUlMsIEZPQ1VTX0VWRU5UKSkpO1xuICAgICAgICAgICAgdmFyIHJlbGVhc2VSZWNvbm5lY3RfMSA9IG9wdHMuaW5pdFJlY29ubmVjdChzZXRUaW1lb3V0LmJpbmQoVU5ERUZJTkVELCByZXZhbGlkYXRlQWxsS2V5cy5iaW5kKFVOREVGSU5FRCwgRVZFTlRfUkVWQUxJREFUT1JTLCBSRUNPTk5FQ1RfRVZFTlQpKSk7XG4gICAgICAgICAgICB1bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VGb2N1c18xICYmIHJlbGVhc2VGb2N1c18xKCk7XG4gICAgICAgICAgICAgICAgcmVsZWFzZVJlY29ubmVjdF8xICYmIHJlbGVhc2VSZWNvbm5lY3RfMSgpO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdW4tbW91bnRpbmcsIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBjYWNoZSBwcm92aWRlciBmcm9tIHRoZSBzdGF0ZVxuICAgICAgICAgICAgICAgIC8vIHN0b3JhZ2UgdG9vIGJlY2F1c2UgaXQncyBhIHNpZGUtZWZmZWN0LiBPdGhlcndpc2Ugd2hlbiByZS1tb3VudGluZyB3ZVxuICAgICAgICAgICAgICAgIC8vIHdpbGwgbm90IHJlLXJlZ2lzdGVyIHRob3NlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAgICAgICAgICBTV1JHbG9iYWxTdGF0ZS5kZWxldGUocHJvdmlkZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBtaWdodCB3YW50IHRvIGluamVjdCBhbiBleHRyYSBsYXllciBvbiB0b3Agb2YgYHByb3ZpZGVyYCBpbiB0aGUgZnV0dXJlLFxuICAgICAgICAvLyBzdWNoIGFzIGtleSBzZXJpYWxpemF0aW9uLCBhdXRvIEdDLCBldGMuXG4gICAgICAgIC8vIEZvciBub3csIGl0J3MganVzdCBhIGBNYXBgIGludGVyZmFjZSB3aXRob3V0IGFueSBtb2RpZmljYXRpb25zLlxuICAgICAgICByZXR1cm4gW3Byb3ZpZGVyLCBtdXRhdGUsIHVubW91bnRdO1xuICAgIH1cbiAgICByZXR1cm4gW3Byb3ZpZGVyLCBTV1JHbG9iYWxTdGF0ZS5nZXQocHJvdmlkZXIpWzRdXTtcbn07XG5cbi8vIGVycm9yIHJldHJ5XG52YXIgb25FcnJvclJldHJ5ID0gZnVuY3Rpb24gKF8sIF9fLCBjb25maWcsIHJldmFsaWRhdGUsIG9wdHMpIHtcbiAgICB2YXIgbWF4UmV0cnlDb3VudCA9IGNvbmZpZy5lcnJvclJldHJ5Q291bnQ7XG4gICAgdmFyIGN1cnJlbnRSZXRyeUNvdW50ID0gb3B0cy5yZXRyeUNvdW50O1xuICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICB2YXIgdGltZW91dCA9IH5+KChNYXRoLnJhbmRvbSgpICsgMC41KSAqXG4gICAgICAgICgxIDw8IChjdXJyZW50UmV0cnlDb3VudCA8IDggPyBjdXJyZW50UmV0cnlDb3VudCA6IDgpKSkgKiBjb25maWcuZXJyb3JSZXRyeUludGVydmFsO1xuICAgIGlmICghaXNVbmRlZmluZWQobWF4UmV0cnlDb3VudCkgJiYgY3VycmVudFJldHJ5Q291bnQgPiBtYXhSZXRyeUNvdW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0VGltZW91dChyZXZhbGlkYXRlLCB0aW1lb3V0LCBvcHRzKTtcbn07XG4vLyBEZWZhdWx0IGNhY2hlIHByb3ZpZGVyXG52YXIgX2EgPSBpbml0Q2FjaGUobmV3IE1hcCgpKSwgY2FjaGUgPSBfYVswXSwgbXV0YXRlID0gX2FbMV07XG4vLyBEZWZhdWx0IGNvbmZpZ1xudmFyIGRlZmF1bHRDb25maWcgPSBtZXJnZU9iamVjdHMoe1xuICAgIC8vIGV2ZW50c1xuICAgIG9uTG9hZGluZ1Nsb3c6IG5vb3AsXG4gICAgb25TdWNjZXNzOiBub29wLFxuICAgIG9uRXJyb3I6IG5vb3AsXG4gICAgb25FcnJvclJldHJ5OiBvbkVycm9yUmV0cnksXG4gICAgb25EaXNjYXJkZWQ6IG5vb3AsXG4gICAgLy8gc3dpdGNoZXNcbiAgICByZXZhbGlkYXRlT25Gb2N1czogdHJ1ZSxcbiAgICByZXZhbGlkYXRlT25SZWNvbm5lY3Q6IHRydWUsXG4gICAgcmV2YWxpZGF0ZUlmU3RhbGU6IHRydWUsXG4gICAgc2hvdWxkUmV0cnlPbkVycm9yOiB0cnVlLFxuICAgIC8vIHRpbWVvdXRzXG4gICAgZXJyb3JSZXRyeUludGVydmFsOiBzbG93Q29ubmVjdGlvbiA/IDEwMDAwIDogNTAwMCxcbiAgICBmb2N1c1Rocm90dGxlSW50ZXJ2YWw6IDUgKiAxMDAwLFxuICAgIGRlZHVwaW5nSW50ZXJ2YWw6IDIgKiAxMDAwLFxuICAgIGxvYWRpbmdUaW1lb3V0OiBzbG93Q29ubmVjdGlvbiA/IDUwMDAgOiAzMDAwLFxuICAgIC8vIHByb3ZpZGVyc1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICAgICAgICByZXR1cm4gc3RhYmxlSGFzaChjdXJyZW50RGF0YSkgPT0gc3RhYmxlSGFzaChuZXdEYXRhKTtcbiAgICB9LFxuICAgIGlzUGF1c2VkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICBjYWNoZTogY2FjaGUsXG4gICAgbXV0YXRlOiBtdXRhdGUsXG4gICAgZmFsbGJhY2s6IHt9XG59LCBcbi8vIHVzZSB3ZWIgcHJlc2V0IGJ5IGRlZmF1bHRcbnByZXNldCk7XG5cbnZhciBtZXJnZUNvbmZpZ3MgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIE5lZWQgdG8gY3JlYXRlIGEgbmV3IG9iamVjdCB0byBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgaGVyZS5cbiAgICB2YXIgdiA9IG1lcmdlT2JqZWN0cyhhLCBiKTtcbiAgICAvLyBJZiB0d28gY29uZmlncyBhcmUgcHJvdmlkZWQsIG1lcmdlIHRoZWlyIGB1c2VgIGFuZCBgZmFsbGJhY2tgIG9wdGlvbnMuXG4gICAgaWYgKGIpIHtcbiAgICAgICAgdmFyIHUxID0gYS51c2UsIGYxID0gYS5mYWxsYmFjaztcbiAgICAgICAgdmFyIHUyID0gYi51c2UsIGYyID0gYi5mYWxsYmFjaztcbiAgICAgICAgaWYgKHUxICYmIHUyKSB7XG4gICAgICAgICAgICB2LnVzZSA9IHUxLmNvbmNhdCh1Mik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYxICYmIGYyKSB7XG4gICAgICAgICAgICB2LmZhbGxiYWNrID0gbWVyZ2VPYmplY3RzKGYxLCBmMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuXG52YXIgU1dSQ29uZmlnQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xudmFyIFNXUkNvbmZpZyQxID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgLy8gRXh0ZW5kIHBhcmVudCBjb250ZXh0IHZhbHVlcyBhbmQgbWlkZGxld2FyZS5cbiAgICB2YXIgZXh0ZW5kZWRDb25maWcgPSBtZXJnZUNvbmZpZ3ModXNlQ29udGV4dChTV1JDb25maWdDb250ZXh0KSwgdmFsdWUpO1xuICAgIC8vIFNob3VsZCBub3QgdXNlIHRoZSBpbmhlcml0ZWQgcHJvdmlkZXIuXG4gICAgdmFyIHByb3ZpZGVyID0gdmFsdWUgJiYgdmFsdWUucHJvdmlkZXI7XG4gICAgLy8gVXNlIGEgbGF6eSBpbml0aWFsaXplZCBzdGF0ZSB0byBjcmVhdGUgdGhlIGNhY2hlIG9uIGZpcnN0IGFjY2Vzcy5cbiAgICB2YXIgY2FjaGVDb250ZXh0ID0gdXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvdmlkZXJcbiAgICAgICAgICAgID8gaW5pdENhY2hlKHByb3ZpZGVyKGV4dGVuZGVkQ29uZmlnLmNhY2hlIHx8IGNhY2hlKSwgdmFsdWUpXG4gICAgICAgICAgICA6IFVOREVGSU5FRDtcbiAgICB9KVswXTtcbiAgICAvLyBPdmVycmlkZSB0aGUgY2FjaGUgaWYgYSBuZXcgcHJvdmlkZXIgaXMgZ2l2ZW4uXG4gICAgaWYgKGNhY2hlQ29udGV4dCkge1xuICAgICAgICBleHRlbmRlZENvbmZpZy5jYWNoZSA9IGNhY2hlQ29udGV4dFswXTtcbiAgICAgICAgZXh0ZW5kZWRDb25maWcubXV0YXRlID0gY2FjaGVDb250ZXh0WzFdO1xuICAgIH1cbiAgICAvLyBVbnN1YnNjcmliZSBldmVudHMuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiAoY2FjaGVDb250ZXh0ID8gY2FjaGVDb250ZXh0WzJdIDogVU5ERUZJTkVEKTsgfSwgW10pO1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFNXUkNvbmZpZ0NvbnRleHQuUHJvdmlkZXIsIG1lcmdlT2JqZWN0cyhwcm9wcywge1xuICAgICAgICB2YWx1ZTogZXh0ZW5kZWRDb25maWdcbiAgICB9KSk7XG59O1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHN0YXRlIHdpdGggZGVwZW5kZW5jeS10cmFja2luZy5cbiAqL1xudmFyIHVzZVN0YXRlV2l0aERlcHMgPSBmdW5jdGlvbiAoc3RhdGUsIHVubW91bnRlZFJlZikge1xuICAgIHZhciByZXJlbmRlciA9IHVzZVN0YXRlKHt9KVsxXTtcbiAgICB2YXIgc3RhdGVSZWYgPSB1c2VSZWYoc3RhdGUpO1xuICAgIC8vIElmIGEgc3RhdGUgcHJvcGVydHkgKGRhdGEsIGVycm9yIG9yIGlzVmFsaWRhdGluZykgaXMgYWNjZXNzZWQgYnkgdGhlIHJlbmRlclxuICAgIC8vIGZ1bmN0aW9uLCB3ZSBtYXJrIHRoZSBwcm9wZXJ0eSBhcyBhIGRlcGVuZGVuY3kgc28gaWYgaXQgaXMgdXBkYXRlZCBhZ2FpblxuICAgIC8vIGluIHRoZSBmdXR1cmUsIHdlIHRyaWdnZXIgYSByZXJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGFsc28ga25vd24gYXMgZGVwZW5kZW5jeS10cmFja2luZy5cbiAgICB2YXIgc3RhdGVEZXBlbmRlbmNpZXNSZWYgPSB1c2VSZWYoe1xuICAgICAgICBkYXRhOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBheWxvYWQgVG8gY2hhbmdlIHN0YXRlUmVmLCBwYXNzIHRoZSB2YWx1ZXMgZXhwbGljaXRseSB0byBzZXRTdGF0ZTpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogc2V0U3RhdGUoe1xuICAgICAqICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxuICAgICAqICAgZGF0YTogbmV3RGF0YSAvLyBzZXQgZGF0YSB0byBuZXdEYXRhXG4gICAgICogICBlcnJvcjogdW5kZWZpbmVkIC8vIHNldCBlcnJvciB0byB1bmRlZmluZWRcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogc2V0U3RhdGUoe1xuICAgICAqICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxuICAgICAqICAgZGF0YTogdW5kZWZpbmVkIC8vIHNldCBkYXRhIHRvIHVuZGVmaW5lZFxuICAgICAqICAgZXJyb3I6IGVyciAvLyBzZXQgZXJyb3IgdG8gZXJyXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB2YXIgc2V0U3RhdGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgc2hvdWxkUmVyZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICAgIGZvciAodmFyIF8gaW4gcGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIGsgPSBfO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGhhcyBjaGFuZ2VkLCB1cGRhdGUgdGhlIHN0YXRlIGFuZCBtYXJrIHJlcmVuZGVyIGFzXG4gICAgICAgICAgICAvLyBuZWVkZWQuXG4gICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlW2tdICE9PSBwYXlsb2FkW2tdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFN0YXRlW2tdID0gcGF5bG9hZFtrXTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQgYnkgdGhlIGNvbXBvbmVudCwgYSByZXJlbmRlciBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyZWQuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlRGVwZW5kZW5jaWVzUmVmLmN1cnJlbnRba10pIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVyZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUmVyZW5kZXIgJiYgIXVubW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXJlbmRlcih7fSk7XG4gICAgICAgIH1cbiAgICB9LCBcbiAgICAvLyBjb25maWcuc3VzcGVuc2UgaXNuJ3QgYWxsb3dlZCB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZlY3ljbGVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW10pO1xuICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIHN0YXRlIHJlZmVyZW5jZS5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RhdGVSZWYuY3VycmVudCA9IHN0YXRlO1xuICAgIH0pO1xuICAgIHJldHVybiBbc3RhdGVSZWYsIHN0YXRlRGVwZW5kZW5jaWVzUmVmLmN1cnJlbnQsIHNldFN0YXRlXTtcbn07XG5cbnZhciBub3JtYWxpemUgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGFyZ3NbMV0pXG4gICAgICAgID8gW2FyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0gfHwge31dXG4gICAgICAgIDogW2FyZ3NbMF0sIG51bGwsIChhcmdzWzFdID09PSBudWxsID8gYXJnc1syXSA6IGFyZ3NbMV0pIHx8IHt9XTtcbn07XG5cbnZhciB1c2VTV1JDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0cyhkZWZhdWx0Q29uZmlnLCB1c2VDb250ZXh0KFNXUkNvbmZpZ0NvbnRleHQpKTtcbn07XG5cbi8vIEl0J3MgdHJpY2t5IHRvIHBhc3MgZ2VuZXJpYyB0eXBlcyBhcyBwYXJhbWV0ZXJzLCBzbyB3ZSBqdXN0IGRpcmVjdGx5IG92ZXJyaWRlXG4vLyB0aGUgdHlwZXMgaGVyZS5cbnZhciB3aXRoQXJncyA9IGZ1bmN0aW9uIChob29rKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVzZVNXUkFyZ3MoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBkZWZhdWx0IGFuZCBpbmhlcml0ZWQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgdmFyIGZhbGxiYWNrQ29uZmlnID0gdXNlU1dSQ29uZmlnKCk7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBhcmd1bWVudHMuXG4gICAgICAgIHZhciBfYSA9IG5vcm1hbGl6ZShhcmdzKSwga2V5ID0gX2FbMF0sIGZuID0gX2FbMV0sIF9jb25maWcgPSBfYVsyXTtcbiAgICAgICAgLy8gTWVyZ2UgY29uZmlndXJhdGlvbnMuXG4gICAgICAgIHZhciBjb25maWcgPSBtZXJnZUNvbmZpZ3MoZmFsbGJhY2tDb25maWcsIF9jb25maWcpO1xuICAgICAgICAvLyBBcHBseSBtaWRkbGV3YXJlXG4gICAgICAgIHZhciBuZXh0ID0gaG9vaztcbiAgICAgICAgdmFyIHVzZSA9IGNvbmZpZy51c2U7XG4gICAgICAgIGlmICh1c2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB1c2UubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgICAgICAgICAgIG5leHQgPSB1c2VbaV0obmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQoa2V5LCBmbiB8fCBjb25maWcuZmV0Y2hlciwgY29uZmlnKTtcbiAgICB9O1xufTtcblxuLy8gQWRkIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYSBsaXN0IG9mIGtleWVkIGNhbGxiYWNrIGZ1bmN0aW9ucyBhbmQgcmV0dXJuXG4vLyB0aGUgdW5zdWJzY3JpYmUgZnVuY3Rpb24uXG52YXIgc3Vic2NyaWJlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoa2V5LCBjYWxsYmFja3MsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGtleWVkUmV2YWxpZGF0b3JzID0gY2FsbGJhY2tzW2tleV0gfHwgKGNhbGxiYWNrc1trZXldID0gW10pO1xuICAgIGtleWVkUmV2YWxpZGF0b3JzLnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGtleWVkUmV2YWxpZGF0b3JzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgLy8gTygxKTogZmFzdGVyIHRoYW4gc3BsaWNlXG4gICAgICAgICAgICBrZXllZFJldmFsaWRhdG9yc1tpbmRleF0gPSBrZXllZFJldmFsaWRhdG9yc1trZXllZFJldmFsaWRhdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGtleWVkUmV2YWxpZGF0b3JzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbnZhciBXSVRIX0RFRFVQRSA9IHsgZGVkdXBlOiB0cnVlIH07XG52YXIgdXNlU1dSSGFuZGxlciA9IGZ1bmN0aW9uIChfa2V5LCBmZXRjaGVyLCBjb25maWcpIHtcbiAgICB2YXIgY2FjaGUgPSBjb25maWcuY2FjaGUsIGNvbXBhcmUgPSBjb25maWcuY29tcGFyZSwgZmFsbGJhY2tEYXRhID0gY29uZmlnLmZhbGxiYWNrRGF0YSwgc3VzcGVuc2UgPSBjb25maWcuc3VzcGVuc2UsIHJldmFsaWRhdGVPbk1vdW50ID0gY29uZmlnLnJldmFsaWRhdGVPbk1vdW50LCByZWZyZXNoSW50ZXJ2YWwgPSBjb25maWcucmVmcmVzaEludGVydmFsLCByZWZyZXNoV2hlbkhpZGRlbiA9IGNvbmZpZy5yZWZyZXNoV2hlbkhpZGRlbiwgcmVmcmVzaFdoZW5PZmZsaW5lID0gY29uZmlnLnJlZnJlc2hXaGVuT2ZmbGluZTtcbiAgICB2YXIgX2EgPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpLCBFVkVOVF9SRVZBTElEQVRPUlMgPSBfYVswXSwgU1RBVEVfVVBEQVRFUlMgPSBfYVsxXSwgTVVUQVRJT04gPSBfYVsyXSwgRkVUQ0ggPSBfYVszXTtcbiAgICAvLyBga2V5YCBpcyB0aGUgaWRlbnRpZmllciBvZiB0aGUgU1dSIGBkYXRhYCBzdGF0ZSwgYGtleUluZm9gIGhvbGRzIGV4dHJhXG4gICAgLy8gc3RhdGVzIHN1Y2ggYXMgYGVycm9yYCBhbmQgYGlzVmFsaWRhdGluZ2AgaW5zaWRlLFxuICAgIC8vIGFsbCBvZiB0aGVtIGFyZSBkZXJpdmVkIGZyb20gYF9rZXlgLlxuICAgIC8vIGBmbkFyZ3NgIGlzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBwYXJzZWQgZnJvbSB0aGUga2V5LCB3aGljaCB3aWxsIGJlIHBhc3NlZFxuICAgIC8vIHRvIHRoZSBmZXRjaGVyLlxuICAgIHZhciBfYiA9IHNlcmlhbGl6ZShfa2V5KSwga2V5ID0gX2JbMF0sIGZuQXJncyA9IF9iWzFdLCBrZXlJbmZvID0gX2JbMl07XG4gICAgLy8gSWYgaXQncyB0aGUgaW5pdGlhbCByZW5kZXIgb2YgdGhpcyBob29rLlxuICAgIHZhciBpbml0aWFsTW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gSWYgdGhlIGhvb2sgaXMgdW5tb3VudGVkIGFscmVhZHkuIFRoaXMgd2lsbCBiZSB1c2VkIHRvIHByZXZlbnQgc29tZSBlZmZlY3RzXG4gICAgLy8gdG8gYmUgY2FsbGVkIGFmdGVyIHVubW91bnRpbmcuXG4gICAgdmFyIHVubW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gUmVmcyB0byBrZWVwIHRoZSBrZXkgYW5kIGNvbmZpZy5cbiAgICB2YXIga2V5UmVmID0gdXNlUmVmKGtleSk7XG4gICAgdmFyIGZldGNoZXJSZWYgPSB1c2VSZWYoZmV0Y2hlcik7XG4gICAgdmFyIGNvbmZpZ1JlZiA9IHVzZVJlZihjb25maWcpO1xuICAgIHZhciBnZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWdSZWYuY3VycmVudDsgfTtcbiAgICB2YXIgaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRDb25maWcoKS5pc1Zpc2libGUoKSAmJiBnZXRDb25maWcoKS5pc09ubGluZSgpOyB9O1xuICAgIHZhciBwYXRjaEZldGNoSW5mbyA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5zZXQoa2V5SW5mbywgbWVyZ2VPYmplY3RzKGNhY2hlLmdldChrZXlJbmZvKSwgaW5mbykpO1xuICAgIH07XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0YXRlIHRoYXQgU1dSIHNob3VsZCByZXR1cm4uXG4gICAgdmFyIGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgIHZhciBmYWxsYmFjayA9IGlzVW5kZWZpbmVkKGZhbGxiYWNrRGF0YSlcbiAgICAgICAgPyBjb25maWcuZmFsbGJhY2tba2V5XVxuICAgICAgICA6IGZhbGxiYWNrRGF0YTtcbiAgICB2YXIgZGF0YSA9IGlzVW5kZWZpbmVkKGNhY2hlZCkgPyBmYWxsYmFjayA6IGNhY2hlZDtcbiAgICB2YXIgaW5mbyA9IGNhY2hlLmdldChrZXlJbmZvKSB8fCB7fTtcbiAgICB2YXIgZXJyb3IgPSBpbmZvLmVycm9yO1xuICAgIHZhciBpc0luaXRpYWxNb3VudCA9ICFpbml0aWFsTW91bnRlZFJlZi5jdXJyZW50O1xuICAgIC8vIC0gU3VzcGVuc2UgbW9kZSBhbmQgdGhlcmUncyBzdGFsZSBkYXRhIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgLy8gLSBOb3Qgc3VzcGVuc2UgbW9kZSBhbmQgdGhlcmUgaXMgbm8gZmFsbGJhY2sgZGF0YSBhbmQgYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBlbmFibGVkLlxuICAgIC8vIC0gYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBlbmFibGVkIGJ1dCBgZGF0YWAgaXMgbm90IGRlZmluZWQuXG4gICAgdmFyIHNob3VsZFJldmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElmIGByZXZhbGlkYXRlT25Nb3VudGAgaXMgc2V0LCB3ZSB0YWtlIHRoZSB2YWx1ZSBkaXJlY3RseS5cbiAgICAgICAgaWYgKGlzSW5pdGlhbE1vdW50ICYmICFpc1VuZGVmaW5lZChyZXZhbGlkYXRlT25Nb3VudCkpXG4gICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0ZU9uTW91bnQ7XG4gICAgICAgIC8vIElmIGl0J3MgcGF1c2VkLCB3ZSBza2lwIHJldmFsaWRhdGlvbi5cbiAgICAgICAgaWYgKGdldENvbmZpZygpLmlzUGF1c2VkKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFVuZGVyIHN1c3BlbnNlIG1vZGUsIGl0IHdpbGwgYWx3YXlzIGZldGNoIG9uIHJlbmRlciBpZiB0aGVyZSBpcyBub1xuICAgICAgICAvLyBzdGFsZSBkYXRhIHNvIG5vIG5lZWQgdG8gcmV2YWxpZGF0ZSBpbW1lZGlhdGVseSBvbiBtb3VudCBhZ2Fpbi5cbiAgICAgICAgLy8gSWYgZGF0YSBleGlzdHMsIG9ubHkgcmV2YWxpZGF0ZSBpZiBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIHRydWUuXG4gICAgICAgIGlmIChzdXNwZW5zZSlcbiAgICAgICAgICAgIHJldHVybiBpc1VuZGVmaW5lZChkYXRhKSA/IGZhbHNlIDogY29uZmlnLnJldmFsaWRhdGVJZlN0YWxlO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBzdGFsZSBkYXRhLCB3ZSBuZWVkIHRvIHJldmFsaWRhdGUgb24gbW91bnQ7XG4gICAgICAgIC8vIElmIGByZXZhbGlkYXRlSWZTdGFsZWAgaXMgc2V0IHRvIHRydWUsIHdlIHdpbGwgYWx3YXlzIHJldmFsaWRhdGUuXG4gICAgICAgIHJldHVybiBpc1VuZGVmaW5lZChkYXRhKSB8fCBjb25maWcucmV2YWxpZGF0ZUlmU3RhbGU7XG4gICAgfTtcbiAgICAvLyBSZXNvbHZlIHRoZSBjdXJyZW50IHZhbGlkYXRpbmcgc3RhdGUuXG4gICAgdmFyIHJlc29sdmVWYWxpZGF0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWtleSB8fCAhZmV0Y2hlcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGluZm8uaXNWYWxpZGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIElmIGl0J3Mgbm90IG1vdW50ZWQgeWV0IGFuZCBpdCBzaG91bGQgcmV2YWxpZGF0ZSBvbiBtb3VudCwgcmV2YWxpZGF0ZS5cbiAgICAgICAgcmV0dXJuIGlzSW5pdGlhbE1vdW50ICYmIHNob3VsZFJldmFsaWRhdGUoKTtcbiAgICB9O1xuICAgIHZhciBpc1ZhbGlkYXRpbmcgPSByZXNvbHZlVmFsaWRhdGluZygpO1xuICAgIHZhciBfYyA9IHVzZVN0YXRlV2l0aERlcHMoe1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIGlzVmFsaWRhdGluZzogaXNWYWxpZGF0aW5nXG4gICAgfSwgdW5tb3VudGVkUmVmKSwgc3RhdGVSZWYgPSBfY1swXSwgc3RhdGVEZXBlbmRlbmNpZXMgPSBfY1sxXSwgc2V0U3RhdGUgPSBfY1syXTtcbiAgICAvLyBUaGUgcmV2YWxpZGF0aW9uIGZ1bmN0aW9uIGlzIGEgY2FyZWZ1bGx5IGNyYWZ0ZWQgd3JhcHBlciBvZiB0aGUgb3JpZ2luYWxcbiAgICAvLyBgZmV0Y2hlcmAsIHRvIGNvcnJlY3RseSBoYW5kbGUgdGhlIG1hbnkgZWRnZSBjYXNlcy5cbiAgICB2YXIgcmV2YWxpZGF0ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChyZXZhbGlkYXRlT3B0cykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRGZXRjaGVyLCBuZXdEYXRhLCBzdGFydEF0LCBsb2FkaW5nLCBvcHRzLCBzaG91bGRTdGFydE5ld1JlcXVlc3QsIGlzQ3VycmVudEtleU1vdW50ZWQsIGNsZWFudXBTdGF0ZSwgbmV3U3RhdGUsIGZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSwgbXV0YXRpb25JbmZvLCBlcnJfMTtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RmV0Y2hlciA9IGZldGNoZXJSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFjdXJyZW50RmV0Y2hlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMgPSByZXZhbGlkYXRlT3B0cyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RhcnROZXdSZXF1ZXN0ID0gIUZFVENIW2tleV0gfHwgIW9wdHMuZGVkdXBlO1xuICAgICAgICAgICAgICAgICAgICBpc0N1cnJlbnRLZXlNb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF1bm1vdW50ZWRSZWYuY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9PT0ga2V5UmVmLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsTW91bnRlZFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIHN0aWxsIHRoZSBzYW1lIHJlcXVlc3QgYmVmb3JlIGRlbGV0aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RJbmZvID0gRkVUQ0hba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0SW5mbyAmJiByZXF1ZXN0SW5mb1sxXSA9PT0gc3RhcnRBdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBGRVRDSFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHsgaXNWYWxpZGF0aW5nOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaEZldGNoSW5mbyh7IGlzVmFsaWRhdGluZzogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gb25seSBzZXQgc3RhdGUgaWYgaXQncyBzYWZlIChzdGlsbCBtb3VudGVkIHdpdGggdGhlIHNhbWUga2V5KS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRLZXlNb3VudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGZldGNoaW5nLiBDaGFuZ2UgdGhlIGBpc1ZhbGlkYXRpbmdgIHN0YXRlLCB1cGRhdGUgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBwYXRjaEZldGNoSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXRlKHsgaXNWYWxpZGF0aW5nOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUZWxsIGFsbCBvdGhlciBob29rcyB0byBjaGFuZ2UgdGhlIGBpc1ZhbGlkYXRpbmdgIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgc3RhdGVSZWYuY3VycmVudC5kYXRhLCBzdGF0ZVJlZi5jdXJyZW50LmVycm9yLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIGNhY2hlIGJlaW5nIHJlbmRlcmVkIGN1cnJlbnRseSAoaXQgc2hvd3MgYSBibGFuayBwYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHRyaWdnZXIgdGhlIGxvYWRpbmcgc2xvdyBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubG9hZGluZ1RpbWVvdXQgJiYgIWNhY2hlLmdldChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2FkaW5nICYmIGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25Mb2FkaW5nU2xvdyhrZXksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjb25maWcubG9hZGluZ1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHJlcXVlc3QgYW5kIHNhdmUgdGhlIHRpbWVzdGFtcC5cbiAgICAgICAgICAgICAgICAgICAgICAgIEZFVENIW2tleV0gPSBbY3VycmVudEZldGNoZXIuYXBwbHkodm9pZCAwLCBmbkFyZ3MpLCBnZXRUaW1lc3RhbXAoKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2EgPSBGRVRDSFtrZXldLCBuZXdEYXRhID0gX2FbMF0sIHN0YXJ0QXQgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbmV3RGF0YV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCBpc24ndCBpbnRlcnJ1cHRlZCwgY2xlYW4gaXQgdXAgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWR1cGxpY2F0aW9uIGludGVydmFsLlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjbGVhbnVwU3RhdGUsIGNvbmZpZy5kZWR1cGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdyZSBvdGhlciBvbmdvaW5nIHJlcXVlc3QocyksIHN0YXJ0ZWQgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lLFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGlnbm9yZSB0aGUgY3VycmVudCBvbmUgdG8gYXZvaWQgcG9zc2libGUgcmFjZSBjb25kaXRpb25zOlxuICAgICAgICAgICAgICAgICAgICAvLyAgIHJlcTEtLS0tLS0tLS0tLS0tLS0tLS0+cmVzMSAgICAgICAgKGN1cnJlbnQgb25lKVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgcmVxMi0tLS0tLS0tLS0tLS0tLS0+cmVzMlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCB0aGF0IGZpcmVkIGxhdGVyIHdpbGwgYWx3YXlzIGJlIGtlcHQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0aW1lc3RhbXAgbWF5YmUgYmUgYHVuZGVmaW5lZGAgb3IgYSBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFGRVRDSFtrZXldIHx8IEZFVENIW2tleV1bMV0gIT09IHN0YXJ0QXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRGlzY2FyZGVkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGZXRjaEluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFVOREVGSU5FRFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUuZXJyb3IgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSW5mbyA9IE1VVEFUSU9OW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQobXV0YXRpb25JbmZvKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhcnRBdCA8PSBtdXRhdGlvbkluZm9bMF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEF0IDw9IG11dGF0aW9uSW5mb1sxXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSW5mb1sxXSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRLZXlNb3VudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25EaXNjYXJkZWQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIERlZXAgY29tcGFyZSB3aXRoIGxhdGVzdCBzdGF0ZSB0byBhdm9pZCBleHRyYSByZS1yZW5kZXJzLlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgbG9jYWwgc3RhdGUsIGNvbXBhcmUgYW5kIGFzc2lnbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKHN0YXRlUmVmLmN1cnJlbnQuZGF0YSwgbmV3RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmRhdGEgPSBuZXdEYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBhbmQgbmV3RGF0YSBhcmUgZGVlcGx5IGVxdWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgc2FmZSB0byBicm9hZGNhc3QgdGhlIHN0YWxlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmRhdGEgPSBzdGF0ZVJlZi5jdXJyZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdCB0aGUgZW5kIG9mIHRoaXMgZnVuY3Rpb24sIGBicm9jYXN0U3RhdGVgIGludm9rZXMgdGhlIGBvblN0YXRlVXBkYXRlYCBmdW5jdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHRha2VzIGNhcmUgb2YgYXZvaWRpbmcgdGhlIHJlLXJlbmRlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBnbG9iYWwgc3RhdGUsIGl0J3MgcG9zc2libGUgdGhhdCB0aGUga2V5IGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL3N3ci9wdWxsLzEwNThcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKGNhY2hlLmdldChrZXkpLCBuZXdEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgbmV3RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciB0aGUgc3VjY2Vzc2Z1bCBjYWxsYmFjayBpZiBpdCdzIHRoZSBvcmlnaW5hbCByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25TdWNjZXNzKG5ld0RhdGEsIGtleSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGVycl8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IHBhdXNlZCwgd2UgY29udGludWUgaGFuZGxpbmcgdGhlIGVycm9yLiBPdGhlcndpc2UgZGlzY2FyZCBpdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFnZXRDb25maWcoKS5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBuZXcgZXJyb3IsIGRvbid0IHVzZSBkZWVwIGNvbXBhcmlzb24gZm9yIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoRmV0Y2hJbmZvKHsgZXJyb3I6IGVycl8xIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUuZXJyb3IgPSBlcnJfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9yIGV2ZW50IGFuZCByZXRyeSBsb2dpYy4gT25seSBmb3IgdGhlIGFjdHVhbCByZXF1ZXN0LCBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZHVwZWQgb25lcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QgJiYgaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25FcnJvcihlcnJfMSwga2V5LCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGNvbmZpZy5zaG91bGRSZXRyeU9uRXJyb3IgPT09ICdib29sZWFuJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc2hvdWxkUmV0cnlPbkVycm9yKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNGdW5jdGlvbihjb25maWcuc2hvdWxkUmV0cnlPbkVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnNob3VsZFJldHJ5T25FcnJvcihlcnJfMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gcmV0cnlpbmcsIGRlZHVwZSBpcyBhbHdheXMgZW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhY3RpdmUsIHN0b3AuIEl0IHdpbGwgYXV0byByZXZhbGlkYXRlIHdoZW4gcmVmb2N1c2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgcmVjb25uZWN0aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25FcnJvclJldHJ5KGVycl8xLCBrZXksIGNvbmZpZywgcmV2YWxpZGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5Q291bnQ6IChvcHRzLnJldHJ5Q291bnQgfHwgMCkgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZHVwZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAvLyBNYXJrIGxvYWRpbmcgYXMgc3RvcHBlZC5cbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgaG9vaydzIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGVyZSBpcyB0aGUgc291cmNlIG9mIHRoZSByZXF1ZXN0LCBuZWVkIHRvIHRlbGwgYWxsIG90aGVyIGhvb2tzIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGVpciBzdGF0ZXMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRLZXlNb3VudGVkKCkgJiYgc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBuZXdTdGF0ZS5kYXRhLCBuZXdTdGF0ZS5lcnJvciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0cnVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7IH0sIFxuICAgIC8vIGBzZXRTdGF0ZWAgaXMgaW1tdXRhYmxlLCBhbmQgYGV2ZW50c0NhbGxiYWNrYCwgYGZuQXJnc2AsIGBrZXlJbmZvYCxcbiAgICAvLyBhbmQgYGtleVZhbGlkYXRpbmdgIGFyZSBkZXBlbmRpbmcgb24gYGtleWAsIHNvIHdlIGNhbiBleGNsdWRlIHRoZW0gZnJvbVxuICAgIC8vIHRoZSBkZXBzIGFycmF5LlxuICAgIC8vXG4gICAgLy8gRklYTUU6XG4gICAgLy8gYGZuYCBhbmQgYGNvbmZpZ2AgbWlnaHQgYmUgY2hhbmdlZCBkdXJpbmcgdGhlIGxpZmVjeWNsZSxcbiAgICAvLyBidXQgdGhleSBtaWdodCBiZSBjaGFuZ2VkIGV2ZXJ5IHJlbmRlciBsaWtlIHRoaXMuXG4gICAgLy8gYHVzZVNXUigna2V5JywgKCkgPT4gZmV0Y2goJy9hcGkvJyksIHsgc3VzcGVuc2U6IHRydWUgfSlgXG4gICAgLy8gU28gd2Ugb21pdCB0aGUgdmFsdWVzIGZyb20gdGhlIGRlcHMgYXJyYXlcbiAgICAvLyBldmVuIHRob3VnaCBpdCBtaWdodCBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9ycy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW2tleV0pO1xuICAgIC8vIFNpbWlsYXIgdG8gdGhlIGdsb2JhbCBtdXRhdGUsIGJ1dCBib3VuZCB0byB0aGUgY3VycmVudCBjYWNoZSBhbmQga2V5LlxuICAgIC8vIGBjYWNoZWAgaXNuJ3QgYWxsb3dlZCB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZlY3ljbGUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIHZhciBib3VuZE11dGF0ZSA9IHVzZUNhbGxiYWNrKFxuICAgIC8vIEJ5IHVzaW5nIGBiaW5kYCB3ZSBkb24ndCBuZWVkIHRvIG1vZGlmeSB0aGUgc2l6ZSBvZiB0aGUgcmVzdCBhcmd1bWVudHMuXG4gICAgLy8gRHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzcxODEsIHdlIGhhdmUgdG9cbiAgICAvLyBjYXN0IGl0IHRvIGFueSBmb3Igbm93LlxuICAgIGludGVybmFsTXV0YXRlLmJpbmQoVU5ERUZJTkVELCBjYWNoZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4ga2V5UmVmLmN1cnJlbnQ7IH0pLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW10pO1xuICAgIC8vIEFsd2F5cyB1cGRhdGUgZmV0Y2hlciBhbmQgY29uZmlnIHJlZnMuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZldGNoZXJSZWYuY3VycmVudCA9IGZldGNoZXI7XG4gICAgICAgIGNvbmZpZ1JlZi5jdXJyZW50ID0gY29uZmlnO1xuICAgIH0pO1xuICAgIC8vIEFmdGVyIG1vdW50ZWQgb3Iga2V5IGNoYW5nZWQuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgha2V5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIga2V5Q2hhbmdlZCA9IGtleSAhPT0ga2V5UmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBzb2Z0UmV2YWxpZGF0ZSA9IHJldmFsaWRhdGUuYmluZChVTkRFRklORUQsIFdJVEhfREVEVVBFKTtcbiAgICAgICAgLy8gRXhwb3NlIHN0YXRlIHVwZGF0ZXIgdG8gZ2xvYmFsIGV2ZW50IGxpc3RlbmVycy4gU28gd2UgY2FuIHVwZGF0ZSBob29rJ3NcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGUgZnJvbSB0aGUgb3V0c2lkZS5cbiAgICAgICAgdmFyIG9uU3RhdGVVcGRhdGUgPSBmdW5jdGlvbiAodXBkYXRlZERhdGEsIHVwZGF0ZWRFcnJvciwgdXBkYXRlZElzVmFsaWRhdGluZykge1xuICAgICAgICAgICAgc2V0U3RhdGUobWVyZ2VPYmplY3RzKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogdXBkYXRlZEVycm9yLFxuICAgICAgICAgICAgICAgIGlzVmFsaWRhdGluZzogdXBkYXRlZElzVmFsaWRhdGluZ1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvLyBTaW5jZSBgc2V0U3RhdGVgIG9ubHkgc2hhbGxvd2x5IGNvbXBhcmVzIHN0YXRlcywgd2UgZG8gYSBkZWVwXG4gICAgICAgICAgICAvLyBjb21wYXJpc29uIGhlcmUuXG4gICAgICAgICAgICBjb21wYXJlKHN0YXRlUmVmLmN1cnJlbnQuZGF0YSwgdXBkYXRlZERhdGEpXG4gICAgICAgICAgICAgICAgPyBVTkRFRklORURcbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdXBkYXRlZERhdGFcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEV4cG9zZSByZXZhbGlkYXRvcnMgdG8gZ2xvYmFsIGV2ZW50IGxpc3RlbmVycy4gU28gd2UgY2FuIHRyaWdnZXJcbiAgICAgICAgLy8gcmV2YWxpZGF0aW9uIGZyb20gdGhlIG91dHNpZGUuXG4gICAgICAgIHZhciBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ID0gMDtcbiAgICAgICAgdmFyIG9uUmV2YWxpZGF0ZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBGT0NVU19FVkVOVCkge1xuICAgICAgICAgICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGlmIChnZXRDb25maWcoKS5yZXZhbGlkYXRlT25Gb2N1cyAmJlxuICAgICAgICAgICAgICAgICAgICBub3cgPiBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ICYmXG4gICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEZvY3VzUmV2YWxpZGF0ZWRBdCA9IG5vdyArIGdldENvbmZpZygpLmZvY3VzVGhyb3R0bGVJbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFJFQ09OTkVDVF9FVkVOVCkge1xuICAgICAgICAgICAgICAgIGlmIChnZXRDb25maWcoKS5yZXZhbGlkYXRlT25SZWNvbm5lY3QgJiYgaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICBzb2Z0UmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gTVVUQVRFX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHVuc3ViVXBkYXRlID0gc3Vic2NyaWJlQ2FsbGJhY2soa2V5LCBTVEFURV9VUERBVEVSUywgb25TdGF0ZVVwZGF0ZSk7XG4gICAgICAgIHZhciB1bnN1YkV2ZW50cyA9IHN1YnNjcmliZUNhbGxiYWNrKGtleSwgRVZFTlRfUkVWQUxJREFUT1JTLCBvblJldmFsaWRhdGUpO1xuICAgICAgICAvLyBNYXJrIHRoZSBjb21wb25lbnQgYXMgbW91bnRlZCBhbmQgdXBkYXRlIGNvcnJlc3BvbmRpbmcgcmVmcy5cbiAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAga2V5UmVmLmN1cnJlbnQgPSBrZXk7XG4gICAgICAgIGluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAvLyBXaGVuIGBrZXlgIHVwZGF0ZXMsIHJlc2V0IHRoZSBzdGF0ZSB0byB0aGUgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAvLyBhbmQgdHJpZ2dlciBhIHJlcmVuZGVyIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgaWYgKGtleUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IGlzVmFsaWRhdGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJpZ2dlciBhIHJldmFsaWRhdGlvbi5cbiAgICAgICAgaWYgKHNob3VsZFJldmFsaWRhdGUoKSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGRhdGEpIHx8IElTX1NFUlZFUikge1xuICAgICAgICAgICAgICAgIC8vIFJldmFsaWRhdGUgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERlbGF5IHRoZSByZXZhbGlkYXRlIGlmIHdlIGhhdmUgZGF0YSB0byByZXR1cm4gc28gd2Ugd29uJ3QgYmxvY2tcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJpbmcuXG4gICAgICAgICAgICAgICAgckFGKHNvZnRSZXZhbGlkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gTWFyayBpdCBhcyB1bm1vdW50ZWQuXG4gICAgICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICB1bnN1YlVwZGF0ZSgpO1xuICAgICAgICAgICAgdW5zdWJFdmVudHMoKTtcbiAgICAgICAgfTtcbiAgICB9LCBba2V5LCByZXZhbGlkYXRlXSk7XG4gICAgLy8gUG9sbGluZ1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGltZXI7XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIHBhc3NlZCBpbnRlcnZhbFxuICAgICAgICAgICAgLy8gLi4ub3IgaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSB1cGRhdGVkIGRhdGEgdG8gZ2V0IHRoZSBpbnRlcnZhbFxuICAgICAgICAgICAgdmFyIGludGVydmFsID0gaXNGdW5jdGlvbihyZWZyZXNoSW50ZXJ2YWwpXG4gICAgICAgICAgICAgICAgPyByZWZyZXNoSW50ZXJ2YWwoZGF0YSlcbiAgICAgICAgICAgICAgICA6IHJlZnJlc2hJbnRlcnZhbDtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgc3RhcnQgbmV4dCBpbnRlcnZhbCBpZiBgcmVmcmVzaEludGVydmFsYCBpcyBub3QgMCwgYW5kOlxuICAgICAgICAgICAgLy8gLSBgZm9yY2VgIGlzIHRydWUsIHdoaWNoIGlzIHRoZSBzdGFydCBvZiBwb2xsaW5nXG4gICAgICAgICAgICAvLyAtIG9yIGB0aW1lcmAgaXMgbm90IDAsIHdoaWNoIG1lYW5zIHRoZSBlZmZlY3Qgd2Fzbid0IGNhbmNlbGVkXG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgJiYgdGltZXIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWN1dGUsIGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBPSyB0byBleGVjdXRlOlxuICAgICAgICAgICAgLy8gT25seSByZXZhbGlkYXRlIHdoZW4gdGhlIHBhZ2UgaXMgdmlzaWJsZSwgb25saW5lIGFuZCBub3QgZXJyb3JlZC5cbiAgICAgICAgICAgIGlmICghc3RhdGVSZWYuY3VycmVudC5lcnJvciAmJlxuICAgICAgICAgICAgICAgIChyZWZyZXNoV2hlbkhpZGRlbiB8fCBnZXRDb25maWcoKS5pc1Zpc2libGUoKSkgJiZcbiAgICAgICAgICAgICAgICAocmVmcmVzaFdoZW5PZmZsaW5lIHx8IGdldENvbmZpZygpLmlzT25saW5lKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZShXSVRIX0RFRFVQRSkudGhlbihuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIG5leHQgaW50ZXJ2YWwgdG8gY2hlY2sgYWdhaW4uXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgdGltZXIgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbcmVmcmVzaEludGVydmFsLCByZWZyZXNoV2hlbkhpZGRlbiwgcmVmcmVzaFdoZW5PZmZsaW5lLCByZXZhbGlkYXRlXSk7XG4gICAgLy8gRGlzcGxheSBkZWJ1ZyBpbmZvIGluIFJlYWN0IERldlRvb2xzLlxuICAgIHVzZURlYnVnVmFsdWUoZGF0YSk7XG4gICAgLy8gSW4gU3VzcGVuc2UgbW9kZSwgd2UgY2FuJ3QgcmV0dXJuIHRoZSBlbXB0eSBgZGF0YWAgc3RhdGUuXG4gICAgLy8gSWYgdGhlcmUgaXMgYGVycm9yYCwgdGhlIGBlcnJvcmAgbmVlZHMgdG8gYmUgdGhyb3duIHRvIHRoZSBlcnJvciBib3VuZGFyeS5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBgZXJyb3JgLCB0aGUgYHJldmFsaWRhdGlvbmAgcHJvbWlzZSBuZWVkcyB0byBiZSB0aHJvd24gdG9cbiAgICAvLyB0aGUgc3VzcGVuc2UgYm91bmRhcnkuXG4gICAgaWYgKHN1c3BlbnNlICYmIGlzVW5kZWZpbmVkKGRhdGEpICYmIGtleSkge1xuICAgICAgICAvLyBBbHdheXMgdXBkYXRlIGZldGNoZXIgYW5kIGNvbmZpZyByZWZzIGV2ZW4gd2l0aCB0aGUgU3VzcGVuc2UgbW9kZS5cbiAgICAgICAgZmV0Y2hlclJlZi5jdXJyZW50ID0gZmV0Y2hlcjtcbiAgICAgICAgY29uZmlnUmVmLmN1cnJlbnQgPSBjb25maWc7XG4gICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIHRocm93IGlzVW5kZWZpbmVkKGVycm9yKSA/IHJldmFsaWRhdGUoV0lUSF9ERURVUEUpIDogZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG11dGF0ZTogYm91bmRNdXRhdGUsXG4gICAgICAgIGdldCBkYXRhKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuZGF0YSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNWYWxpZGF0aW5nKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuaXNWYWxpZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkYXRpbmc7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbnZhciBTV1JDb25maWcgPSBPQkpFQ1QuZGVmaW5lUHJvcGVydHkoU1dSQ29uZmlnJDEsICdkZWZhdWx0Jywge1xuICAgIHZhbHVlOiBkZWZhdWx0Q29uZmlnXG59KTtcbnZhciB1bnN0YWJsZV9zZXJpYWxpemUgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBzZXJpYWxpemUoa2V5KVswXTsgfTtcbnZhciB1c2VTV1IgPSB3aXRoQXJncyh1c2VTV1JIYW5kbGVyKTtcblxuLy8gdXNlU1dSXG5cbmV4cG9ydCB7IFNXUkNvbmZpZywgdXNlU1dSIGFzIGRlZmF1bHQsIG11dGF0ZSwgdW5zdGFibGVfc2VyaWFsaXplLCB1c2VTV1JDb25maWcgfTtcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwiY3JlYXRlRWxlbWVudCIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwidXNlRGVidWdWYWx1ZSIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9fZ2VuZXJhdG9yIiwiYm9keSIsIl8iLCJsYWJlbCIsInNlbnQiLCJ0IiwidHJ5cyIsIm9wcyIsImYiLCJ5IiwiZyIsInZlcmIiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm4iLCJ2Iiwib3AiLCJUeXBlRXJyb3IiLCJjYWxsIiwicG9wIiwibGVuZ3RoIiwicHVzaCIsIm5vb3AiLCJVTkRFRklORUQiLCJPQkpFQ1QiLCJPYmplY3QiLCJpc1VuZGVmaW5lZCIsImlzRnVuY3Rpb24iLCJtZXJnZU9iamVjdHMiLCJhIiwiYiIsImFzc2lnbiIsIlNUUl9VTkRFRklORUQiLCJoYXNXaW5kb3ciLCJ3aW5kb3ciLCJoYXNEb2N1bWVudCIsImRvY3VtZW50IiwiaGFzUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidGFibGUiLCJXZWFrTWFwIiwiY291bnRlciIsInN0YWJsZUhhc2giLCJhcmciLCJ0eXBlIiwiY29uc3RydWN0b3IiLCJpc0RhdGUiLCJEYXRlIiwiaW5kZXgiLCJSZWdFeHAiLCJnZXQiLCJzZXQiLCJBcnJheSIsImtleXMiLCJzb3J0IiwidG9KU09OIiwidG9TdHJpbmciLCJKU09OIiwic3RyaW5naWZ5Iiwib25saW5lIiwiaXNPbmxpbmUiLCJoYXNXaW4iLCJoYXNEb2MiLCJvbldpbmRvd0V2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImJpbmQiLCJvbkRvY3VtZW50RXZlbnQiLCJvZmZXaW5kb3dFdmVudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvZmZEb2N1bWVudEV2ZW50IiwiaXNWaXNpYmxlIiwidmlzaWJpbGl0eVN0YXRlIiwiaW5pdEZvY3VzIiwiY2FsbGJhY2siLCJpbml0UmVjb25uZWN0Iiwib25PbmxpbmUiLCJvbk9mZmxpbmUiLCJwcmVzZXQiLCJkZWZhdWx0Q29uZmlnT3B0aW9ucyIsIklTX1NFUlZFUiIsInJBRiIsInNldFRpbWVvdXQiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwibmF2aWdhdG9yQ29ubmVjdGlvbiIsIm5hdmlnYXRvciIsImNvbm5lY3Rpb24iLCJzbG93Q29ubmVjdGlvbiIsImluY2x1ZGVzIiwiZWZmZWN0aXZlVHlwZSIsInNhdmVEYXRhIiwic2VyaWFsaXplIiwia2V5IiwiZXJyIiwiYXJncyIsImNvbmNhdCIsImlzQXJyYXkiLCJpbmZvS2V5IiwiU1dSR2xvYmFsU3RhdGUiLCJGT0NVU19FVkVOVCIsIlJFQ09OTkVDVF9FVkVOVCIsIk1VVEFURV9FVkVOVCIsImJyb2FkY2FzdFN0YXRlIiwiY2FjaGUiLCJkYXRhIiwiZXJyb3IiLCJpc1ZhbGlkYXRpbmciLCJyZXZhbGlkYXRlIiwiYnJvYWRjYXN0IiwiX2EiLCJFVkVOVF9SRVZBTElEQVRPUlMiLCJTVEFURV9VUERBVEVSUyIsIkZFVENIIiwicmV2YWxpZGF0b3JzIiwidXBkYXRlcnMiLCJpIiwiX190aW1lc3RhbXAiLCJnZXRUaW1lc3RhbXAiLCJpbnRlcm5hbE11dGF0ZSIsIl9pIiwiYXJndW1lbnRzIiwiX2tleSIsIl9kYXRhIiwiX29wdHMiLCJvcHRpb25zIiwicG9wdWxhdGVDYWNoZSIsInJvbGxiYWNrT25FcnJvciIsImN1c3RvbU9wdGltaXN0aWNEYXRhIiwia2V5SW5mbyIsIl9iIiwiTVVUQVRJT04iLCJiZWZvcmVNdXRhdGlvblRzIiwiaGFzQ3VzdG9tT3B0aW1pc3RpY0RhdGEiLCJyb2xsYmFja0RhdGEiLCJvcHRpbWlzdGljRGF0YSIsInJlcyIsIl9jIiwiY2F0Y2giLCJyZXZhbGlkYXRlQWxsS2V5cyIsImluaXRDYWNoZSIsInByb3ZpZGVyIiwiaGFzIiwib3B0cyIsIm11dGF0ZSIsInVubW91bnQiLCJyZWxlYXNlRm9jdXNfMSIsInJlbGVhc2VSZWNvbm5lY3RfMSIsImRlbGV0ZSIsIm9uRXJyb3JSZXRyeSIsIl9fIiwiY29uZmlnIiwibWF4UmV0cnlDb3VudCIsImVycm9yUmV0cnlDb3VudCIsImN1cnJlbnRSZXRyeUNvdW50IiwicmV0cnlDb3VudCIsInRpbWVvdXQiLCJNYXRoIiwicmFuZG9tIiwiZXJyb3JSZXRyeUludGVydmFsIiwiTWFwIiwiZGVmYXVsdENvbmZpZyIsIm9uTG9hZGluZ1Nsb3ciLCJvblN1Y2Nlc3MiLCJvbkVycm9yIiwib25EaXNjYXJkZWQiLCJyZXZhbGlkYXRlT25Gb2N1cyIsInJldmFsaWRhdGVPblJlY29ubmVjdCIsInJldmFsaWRhdGVJZlN0YWxlIiwic2hvdWxkUmV0cnlPbkVycm9yIiwiZm9jdXNUaHJvdHRsZUludGVydmFsIiwiZGVkdXBpbmdJbnRlcnZhbCIsImxvYWRpbmdUaW1lb3V0IiwiY29tcGFyZSIsImN1cnJlbnREYXRhIiwibmV3RGF0YSIsImlzUGF1c2VkIiwiZmFsbGJhY2siLCJtZXJnZUNvbmZpZ3MiLCJ1MSIsInVzZSIsImYxIiwidTIiLCJmMiIsIlNXUkNvbmZpZ0NvbnRleHQiLCJTV1JDb25maWckMSIsInByb3BzIiwiZXh0ZW5kZWRDb25maWciLCJjYWNoZUNvbnRleHQiLCJQcm92aWRlciIsInVzZVN0YXRlV2l0aERlcHMiLCJzdGF0ZSIsInVubW91bnRlZFJlZiIsInJlcmVuZGVyIiwic3RhdGVSZWYiLCJzdGF0ZURlcGVuZGVuY2llc1JlZiIsInNldFN0YXRlIiwicGF5bG9hZCIsInNob3VsZFJlcmVuZGVyIiwiY3VycmVudFN0YXRlIiwiY3VycmVudCIsImsiLCJub3JtYWxpemUiLCJ1c2VTV1JDb25maWciLCJ3aXRoQXJncyIsImhvb2siLCJ1c2VTV1JBcmdzIiwiZmFsbGJhY2tDb25maWciLCJmbiIsIl9jb25maWciLCJmZXRjaGVyIiwic3Vic2NyaWJlQ2FsbGJhY2siLCJjYWxsYmFja3MiLCJrZXllZFJldmFsaWRhdG9ycyIsImluZGV4T2YiLCJXSVRIX0RFRFVQRSIsImRlZHVwZSIsInVzZVNXUkhhbmRsZXIiLCJmYWxsYmFja0RhdGEiLCJzdXNwZW5zZSIsInJldmFsaWRhdGVPbk1vdW50IiwicmVmcmVzaEludGVydmFsIiwicmVmcmVzaFdoZW5IaWRkZW4iLCJyZWZyZXNoV2hlbk9mZmxpbmUiLCJmbkFyZ3MiLCJpbml0aWFsTW91bnRlZFJlZiIsImtleVJlZiIsImZldGNoZXJSZWYiLCJjb25maWdSZWYiLCJnZXRDb25maWciLCJpc0FjdGl2ZSIsInBhdGNoRmV0Y2hJbmZvIiwiaW5mbyIsImNhY2hlZCIsImlzSW5pdGlhbE1vdW50Iiwic2hvdWxkUmV2YWxpZGF0ZSIsInJlc29sdmVWYWxpZGF0aW5nIiwic3RhdGVEZXBlbmRlbmNpZXMiLCJyZXZhbGlkYXRlT3B0cyIsImN1cnJlbnRGZXRjaGVyIiwic3RhcnRBdCIsImxvYWRpbmciLCJzaG91bGRTdGFydE5ld1JlcXVlc3QiLCJpc0N1cnJlbnRLZXlNb3VudGVkIiwiY2xlYW51cFN0YXRlIiwibmV3U3RhdGUiLCJmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUiLCJtdXRhdGlvbkluZm8iLCJlcnJfMSIsInJlcXVlc3RJbmZvIiwiYm91bmRNdXRhdGUiLCJrZXlDaGFuZ2VkIiwic29mdFJldmFsaWRhdGUiLCJvblN0YXRlVXBkYXRlIiwidXBkYXRlZERhdGEiLCJ1cGRhdGVkRXJyb3IiLCJ1cGRhdGVkSXNWYWxpZGF0aW5nIiwibmV4dEZvY3VzUmV2YWxpZGF0ZWRBdCIsIm9uUmV2YWxpZGF0ZSIsIm5vdyIsInVuc3ViVXBkYXRlIiwidW5zdWJFdmVudHMiLCJ0aW1lciIsImludGVydmFsIiwiZXhlY3V0ZSIsImNsZWFyVGltZW91dCIsIlNXUkNvbmZpZyIsImRlZmluZVByb3BlcnR5IiwidW5zdGFibGVfc2VyaWFsaXplIiwidXNlU1dSIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/swr/dist/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!"), __webpack_exec__("./node_modules/next/dist/client/router.js"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);