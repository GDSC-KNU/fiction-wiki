/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "./node_modules/@swc/helpers/lib/_define_property.js":
/*!***********************************************************!*\
  !*** ./node_modules/@swc/helpers/lib/_define_property.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = _defineProperty;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2xpYi9fZGVmaW5lX3Byb3BlcnR5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCxrQkFBQSxHQUFrQkcsZUFBbEI7O0FBQ0EsU0FBU0EsZUFBVCxDQUF5QkMsR0FBekIsRUFBOEJDLEdBQTlCLEVBQW1DSixLQUFuQyxFQUEwQztFQUN0QyxJQUFJSSxHQUFHLElBQUlELEdBQVgsRUFBZ0I7SUFDWk4sTUFBTSxDQUFDQyxjQUFQLENBQXNCSyxHQUF0QixFQUEyQkMsR0FBM0IsRUFBZ0M7TUFDNUJKLEtBQUssRUFBRUEsS0FEcUI7TUFFNUJLLFVBQVUsRUFBRSxJQUZnQjtNQUc1QkMsWUFBWSxFQUFFLElBSGM7TUFJNUJDLFFBQVEsRUFBRTtJQUprQixDQUFoQztFQU1ILENBUEQsTUFPTztJQUNISixHQUFHLENBQUNDLEdBQUQsQ0FBSCxHQUFXSixLQUFYO0VBQ0g7O0VBQ0QsT0FBT0csR0FBUDtBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvbGliL19kZWZpbmVfcHJvcGVydHkuanM/NzY0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZpbmVQcm9wZXJ0eTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/lib/_define_property.js\n"));

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength;\nexports.toByteArray = toByteArray;\nexports.fromByteArray = fromByteArray;\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n} // Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction getLens(b64) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');\n  } // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n  var validLen = b64.indexOf('=');\n  if (validLen === -1) validLen = len;\n  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n  return [validLen, placeHoldersLen];\n} // base64 is 4/3 + up to two characters of the original data\n\n\nfunction byteLength(b64) {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\n\nfunction _byteLength(b64, validLen, placeHoldersLen) {\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\n\nfunction toByteArray(b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars\n\n  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n  var i;\n\n  for (i = 0; i < len; i += 4) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = tmp >> 16 & 0xFF;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  return arr;\n}\n\nfunction tripletToBase64(num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\n\nfunction encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n    output.push(tripletToBase64(tmp));\n  }\n\n  return output.join('');\n}\n\nfunction fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n  // go through the array every three bytes, we'll deal with trailing stuff later\n\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');\n  }\n\n  return parts.join('');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBUixHQUFhLElBQWQsQ0FETixHQUVBLElBSEY7RUFLRCxDQVBELE1BT08sSUFBSVksVUFBVSxLQUFLLENBQW5CLEVBQXNCO0lBQzNCWixHQUFHLEdBQUcsQ0FBQ00sS0FBSyxDQUFDakIsR0FBRyxHQUFHLENBQVAsQ0FBTCxJQUFrQixDQUFuQixJQUF3QmlCLEtBQUssQ0FBQ2pCLEdBQUcsR0FBRyxDQUFQLENBQW5DO0lBQ0F3QixLQUFLLENBQUNILElBQU4sQ0FDRTVCLE1BQU0sQ0FBQ2tCLEdBQUcsSUFBSSxFQUFSLENBQU4sR0FDQWxCLE1BQU0sQ0FBRWtCLEdBQUcsSUFBSSxDQUFSLEdBQWEsSUFBZCxDQUROLEdBRUFsQixNQUFNLENBQUVrQixHQUFHLElBQUksQ0FBUixHQUFhLElBQWQsQ0FGTixHQUdBLEdBSkY7RUFNRDs7RUFFRCxPQUFPYSxLQUFLLENBQUNGLElBQU4sQ0FBVyxFQUFYLENBQVA7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzPzM3NzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsImJ5dGVMZW5ndGgiLCJ0b0J5dGVBcnJheSIsImZyb21CeXRlQXJyYXkiLCJsb29rdXAiLCJyZXZMb29rdXAiLCJBcnIiLCJVaW50OEFycmF5IiwiQXJyYXkiLCJjb2RlIiwiaSIsImxlbiIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJnZXRMZW5zIiwiYjY0IiwiRXJyb3IiLCJ2YWxpZExlbiIsImluZGV4T2YiLCJwbGFjZUhvbGRlcnNMZW4iLCJsZW5zIiwiX2J5dGVMZW5ndGgiLCJ0bXAiLCJhcnIiLCJjdXJCeXRlIiwidHJpcGxldFRvQmFzZTY0IiwibnVtIiwiZW5jb2RlQ2h1bmsiLCJ1aW50OCIsInN0YXJ0IiwiZW5kIiwib3V0cHV0IiwicHVzaCIsImpvaW4iLCJleHRyYUJ5dGVzIiwicGFydHMiLCJtYXhDaHVua0xlbmd0aCIsImxlbjIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n/* eslint-disable no-proto */\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\");\n\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\");\n\nconst customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation\n? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n: null;\nexports.Buffer = Buffer;\nexports.SlowBuffer = SlowBuffer;\nexports.INSPECT_MAX_BYTES = 50;\nconst K_MAX_LENGTH = 0x7fffffff;\nexports.kMaxLength = K_MAX_LENGTH;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\n\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {\n  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');\n}\n\nfunction typedArraySupport() {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1);\n    const proto = {\n      foo: function () {\n        return 42;\n      }\n    };\n    Object.setPrototypeOf(proto, Uint8Array.prototype);\n    Object.setPrototypeOf(arr, proto);\n    return arr.foo() === 42;\n  } catch (e) {\n    return false;\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined;\n    return this.buffer;\n  }\n});\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined;\n    return this.byteOffset;\n  }\n});\n\nfunction createBuffer(length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n  } // Return an augmented `Uint8Array` instance\n\n\n  const buf = new Uint8Array(length);\n  Object.setPrototypeOf(buf, Buffer.prototype);\n  return buf;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\n\nfunction Buffer(arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError('The \"string\" argument must be of type string. Received type number');\n    }\n\n    return allocUnsafe(arg);\n  }\n\n  return from(arg, encodingOrOffset, length);\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n\nfunction from(value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset);\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value);\n  }\n\n  if (value == null) {\n    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);\n  }\n\n  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n    return fromArrayBuffer(value, encodingOrOffset, length);\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length);\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n  }\n\n  const valueOf = value.valueOf && value.valueOf();\n\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length);\n  }\n\n  const b = fromObject(value);\n  if (b) return b;\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);\n  }\n\n  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\n\n\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length);\n}; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\n\n\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\nObject.setPrototypeOf(Buffer, Uint8Array);\n\nfunction assertSize(size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number');\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n  }\n}\n\nfunction alloc(size, fill, encoding) {\n  assertSize(size);\n\n  if (size <= 0) {\n    return createBuffer(size);\n  }\n\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n  }\n\n  return createBuffer(size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\n\n\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding);\n};\n\nfunction allocUnsafe(size) {\n  assertSize(size);\n  return createBuffer(size < 0 ? 0 : checked(size) | 0);\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\n\n\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\n\n\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size);\n};\n\nfunction fromString(string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding);\n  }\n\n  const length = byteLength(string, encoding) | 0;\n  let buf = createBuffer(length);\n  const actual = buf.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual);\n  }\n\n  return buf;\n}\n\nfunction fromArrayLike(array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0;\n  const buf = createBuffer(length);\n\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255;\n  }\n\n  return buf;\n}\n\nfunction fromArrayView(arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView);\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n  }\n\n  return fromArrayLike(arrayView);\n}\n\nfunction fromArrayBuffer(array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds');\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds');\n  }\n\n  let buf;\n\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array);\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset);\n  } else {\n    buf = new Uint8Array(array, byteOffset, length);\n  } // Return an augmented `Uint8Array` instance\n\n\n  Object.setPrototypeOf(buf, Buffer.prototype);\n  return buf;\n}\n\nfunction fromObject(obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0;\n    const buf = createBuffer(len);\n\n    if (buf.length === 0) {\n      return buf;\n    }\n\n    obj.copy(buf, 0, 0, len);\n    return buf;\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0);\n    }\n\n    return fromArrayLike(obj);\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data);\n  }\n}\n\nfunction checked(length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n  }\n\n  return length | 0;\n}\n\nfunction SlowBuffer(length) {\n  if (+length != length) {\n    // eslint-disable-line eqeqeq\n    length = 0;\n  }\n\n  return Buffer.alloc(+length);\n}\n\nBuffer.isBuffer = function isBuffer(b) {\n  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false\n};\n\nBuffer.compare = function compare(a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n  }\n\n  if (a === b) return 0;\n  let x = a.length;\n  let y = b.length;\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true;\n\n    default:\n      return false;\n  }\n};\n\nBuffer.concat = function concat(list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers');\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0);\n  }\n\n  let i;\n\n  if (length === undefined) {\n    length = 0;\n\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length);\n  let pos = 0;\n\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i];\n\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);\n        buf.copy(buffer, pos);\n      } else {\n        Uint8Array.prototype.set.call(buffer, buf, pos);\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    } else {\n      buf.copy(buffer, pos);\n    }\n\n    pos += buf.length;\n  }\n\n  return buffer;\n};\n\nfunction byteLength(string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length;\n  }\n\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength;\n  }\n\n  if (typeof string !== 'string') {\n    throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);\n  }\n\n  const len = string.length;\n  const mustMatch = arguments.length > 2 && arguments[2] === true;\n  if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion\n\n  let loweredCase = false;\n\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len;\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length;\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2;\n\n      case 'hex':\n        return len >>> 1;\n\n      case 'base64':\n        return base64ToBytes(string).length;\n\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8\n        }\n\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\nBuffer.byteLength = byteLength;\n\nfunction slowToString(encoding, start, end) {\n  let loweredCase = false; // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\n  if (start === undefined || start < 0) {\n    start = 0;\n  } // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n\n\n  if (start > this.length) {\n    return '';\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return '';\n  } // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n\n\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return '';\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end);\n\n      case 'ascii':\n        return asciiSlice(this, start, end);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end);\n\n      case 'base64':\n        return base64Slice(this, start, end);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n} // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\n\n\nBuffer.prototype._isBuffer = true;\n\nfunction swap(b, n, m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  const len = this.length;\n\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits');\n  }\n\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n\n  return this;\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  const len = this.length;\n\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits');\n  }\n\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n\n  return this;\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  const len = this.length;\n\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits');\n  }\n\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n\n  return this;\n};\n\nBuffer.prototype.toString = function toString() {\n  const length = this.length;\n  if (length === 0) return '';\n  if (arguments.length === 0) return utf8Slice(this, 0, length);\n  return slowToString.apply(this, arguments);\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\nBuffer.prototype.equals = function equals(b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n  if (this === b) return true;\n  return Buffer.compare(this, b) === 0;\n};\n\nBuffer.prototype.inspect = function inspect() {\n  let str = '';\n  const max = exports.INSPECT_MAX_BYTES;\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n  if (this.length > max) str += ' ... ';\n  return '<Buffer ' + str + '>';\n};\n\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;\n}\n\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength);\n  }\n\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index');\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0;\n  }\n\n  if (thisStart >= thisEnd) {\n    return -1;\n  }\n\n  if (start >= end) {\n    return 1;\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n  if (this === target) return 0;\n  let x = thisEnd - thisStart;\n  let y = end - start;\n  const len = Math.min(x, y);\n  const thisCopy = this.slice(thisStart, thisEnd);\n  const targetCopy = target.slice(start, end);\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\n\n\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1; // Normalize byteOffset\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n\n  byteOffset = +byteOffset; // Coerce to Number.\n\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : buffer.length - 1;\n  } // Normalize byteOffset: negative offsets start from the end of the buffer\n\n\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1;else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;else return -1;\n  } // Normalize val\n\n\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  } // Finally, search either indexOf (if dir is true) or lastIndexOf\n\n\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1;\n    }\n\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n      }\n    }\n\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n  }\n\n  throw new TypeError('val must be string, number or Buffer');\n}\n\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1;\n  let arrLength = arr.length;\n  let valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n\n    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1;\n      }\n\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read(buf, i) {\n    if (indexSize === 1) {\n      return buf[i];\n    } else {\n      return buf.readUInt16BE(i * indexSize);\n    }\n  }\n\n  let i;\n\n  if (dir) {\n    let foundIndex = -1;\n\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true;\n\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break;\n        }\n      }\n\n      if (found) return i;\n    }\n  }\n\n  return -1;\n}\n\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\n\nfunction hexWrite(buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  const remaining = buf.length - offset;\n\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  const strLen = string.length;\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n\n  let i;\n\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (numberIsNaN(parsed)) return i;\n    buf[offset + i] = parsed;\n  }\n\n  return i;\n}\n\nfunction utf8Write(buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nfunction asciiWrite(buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\n\nfunction base64Write(buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\n\nfunction ucs2Write(buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0; // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0; // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0;\n\n    if (isFinite(length)) {\n      length = length >>> 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n  } else {\n    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n  }\n\n  const remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds');\n  }\n\n  if (!encoding) encoding = 'utf8';\n  let loweredCase = false;\n\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length);\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length);\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  };\n};\n\nfunction base64Slice(buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf);\n  } else {\n    return base64.fromByteArray(buf.slice(start, end));\n  }\n}\n\nfunction utf8Slice(buf, start, end) {\n  end = Math.min(buf.length, end);\n  const res = [];\n  let i = start;\n\n  while (i < end) {\n    const firstByte = buf[i];\n    let codePoint = null;\n    let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n\n          break;\n\n        case 2:\n          secondByte = buf[i + 1];\n\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n          break;\n\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n          break;\n\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res);\n} // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\n\n\nconst MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray(codePoints) {\n  const len = codePoints.length;\n\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n  } // Decode in chunks to avoid \"call stack size exceeded\".\n\n\n  let res = '';\n  let i = 0;\n\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n\n  return res;\n}\n\nfunction asciiSlice(buf, start, end) {\n  let ret = '';\n  end = Math.min(buf.length, end);\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n\n  return ret;\n}\n\nfunction latin1Slice(buf, start, end) {\n  let ret = '';\n  end = Math.min(buf.length, end);\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n\n  return ret;\n}\n\nfunction hexSlice(buf, start, end) {\n  const len = buf.length;\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n  let out = '';\n\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]];\n  }\n\n  return out;\n}\n\nfunction utf16leSlice(buf, start, end) {\n  const bytes = buf.slice(start, end);\n  let res = ''; // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n\n  return res;\n}\n\nBuffer.prototype.slice = function slice(start, end) {\n  const len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n  const newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance\n\n  Object.setPrototypeOf(newBuf, Buffer.prototype);\n  return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\n\n\nfunction checkOffset(offset, ext, length) {\n  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n}\n\nBuffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n  let val = this[offset];\n  let mul = 1;\n  let i = 0;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  let val = this[offset + --byteLength];\n  let mul = 1;\n\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset];\n};\n\nBuffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | this[offset + 1] << 8;\n};\n\nBuffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] << 8 | this[offset + 1];\n};\n\nBuffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\n\nBuffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n  offset = offset >>> 0;\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8);\n  }\n\n  const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n  const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n  return BigInt(lo) + (BigInt(hi) << BigInt(32));\n});\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n  offset = offset >>> 0;\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8);\n  }\n\n  const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n  const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n});\n\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n  let val = this[offset];\n  let mul = 1;\n  let i = 0;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  mul *= 0x80;\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n  return val;\n};\n\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n  let i = byteLength;\n  let mul = 1;\n  let val = this[offset + --i];\n\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n\n  mul *= 0x80;\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n  return val;\n};\n\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return this[offset];\n  return (0xff - this[offset] + 1) * -1;\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  const val = this[offset] | this[offset + 1] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  const val = this[offset + 1] | this[offset] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n  offset = offset >>> 0;\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8);\n  }\n\n  const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24); // Overflow\n\n  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n});\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n  offset = offset >>> 0;\n  validateNumber(offset, 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8);\n  }\n\n  const val = (first << 24) + // Overflow\n  this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n});\n\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, true, 23, 4);\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, false, 23, 4);\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, true, 52, 8);\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, false, 52, 8);\n};\n\nfunction checkInt(buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n}\n\nBuffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  let mul = 1;\n  let i = 0;\n  this[offset] = value & 0xFF;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  let i = byteLength - 1;\n  let mul = 1;\n  this[offset + i] = value & 0xFF;\n\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nBuffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  this[offset] = value & 0xff;\n  this[offset + 1] = value >>> 8;\n  return offset + 2;\n};\n\nBuffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  this[offset] = value >>> 8;\n  this[offset + 1] = value & 0xff;\n  return offset + 2;\n};\n\nBuffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  this[offset + 3] = value >>> 24;\n  this[offset + 2] = value >>> 16;\n  this[offset + 1] = value >>> 8;\n  this[offset] = value & 0xff;\n  return offset + 4;\n};\n\nBuffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  this[offset] = value >>> 24;\n  this[offset + 1] = value >>> 16;\n  this[offset + 2] = value >>> 8;\n  this[offset + 3] = value & 0xff;\n  return offset + 4;\n};\n\nfunction wrtBigUInt64LE(buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7);\n  let lo = Number(value & BigInt(0xffffffff));\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  return offset;\n}\n\nfunction wrtBigUInt64BE(buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7);\n  let lo = Number(value & BigInt(0xffffffff));\n  buf[offset + 7] = lo;\n  lo = lo >> 8;\n  buf[offset + 6] = lo;\n  lo = lo >> 8;\n  buf[offset + 5] = lo;\n  lo = lo >> 8;\n  buf[offset + 4] = lo;\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n  buf[offset + 3] = hi;\n  hi = hi >> 8;\n  buf[offset + 2] = hi;\n  hi = hi >> 8;\n  buf[offset + 1] = hi;\n  hi = hi >> 8;\n  buf[offset] = hi;\n  return offset + 8;\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));\n});\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));\n});\n\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n\n  if (!noAssert) {\n    const limit = Math.pow(2, 8 * byteLength - 1);\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  let i = 0;\n  let mul = 1;\n  let sub = 0;\n  this[offset] = value & 0xFF;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n\n  if (!noAssert) {\n    const limit = Math.pow(2, 8 * byteLength - 1);\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  let i = byteLength - 1;\n  let mul = 1;\n  let sub = 0;\n  this[offset + i] = value & 0xFF;\n\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  this[offset] = value & 0xff;\n  this[offset + 1] = value >>> 8;\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  this[offset] = value >>> 8;\n  this[offset + 1] = value & 0xff;\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  this[offset] = value & 0xff;\n  this[offset + 1] = value >>> 8;\n  this[offset + 2] = value >>> 16;\n  this[offset + 3] = value >>> 24;\n  return offset + 4;\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  this[offset] = value >>> 24;\n  this[offset + 1] = value >>> 16;\n  this[offset + 2] = value >>> 8;\n  this[offset + 3] = value & 0xff;\n  return offset + 4;\n};\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));\n});\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));\n});\n\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n  if (offset < 0) throw new RangeError('Index out of range');\n}\n\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  ieee754.write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4;\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert);\n};\n\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  ieee754.write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8;\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert);\n}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n  if (end === start) return 0;\n  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds');\n  }\n\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');\n  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?\n\n  if (end > this.length) end = this.length;\n\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  const len = end - start;\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end);\n  } else {\n    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n  }\n\n  return len;\n}; // Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\n\n\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string');\n    }\n\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding);\n    }\n\n    if (val.length === 1) {\n      const code = val.charCodeAt(0);\n\n      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code;\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  } else if (typeof val === 'boolean') {\n    val = Number(val);\n  } // Invalid ranges are not set to a default, so can range check early.\n\n\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index');\n  }\n\n  if (end <= start) {\n    return this;\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n  if (!val) val = 0;\n  let i;\n\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);\n    const len = bytes.length;\n\n    if (len === 0) {\n      throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n    }\n\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this;\n}; // CUSTOM ERRORS\n// =============\n// Simplified versions from Node, changed for Buffer-only usage\n\n\nconst errors = {};\n\nfunction E(sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor() {\n      super();\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      }); // Add the error code to the name to include it in the stack trace.\n\n      this.name = `${this.name} [${sym}]`; // Access the stack to generate the error message including the error code\n      // from the name.\n\n      this.stack; // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n\n      delete this.name;\n    }\n\n    get code() {\n      return sym;\n    }\n\n    set code(value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      });\n    }\n\n    toString() {\n      return `${this.name} [${sym}]: ${this.message}`;\n    }\n\n  };\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {\n  if (name) {\n    return `${name} is outside of buffer bounds`;\n  }\n\n  return 'Attempt to access memory outside buffer bounds';\n}, RangeError);\nE('ERR_INVALID_ARG_TYPE', function (name, actual) {\n  return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n}, TypeError);\nE('ERR_OUT_OF_RANGE', function (str, range, input) {\n  let msg = `The value of \"${str}\" is out of range.`;\n  let received = input;\n\n  if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n    received = addNumericalSeparator(String(input));\n  } else if (typeof input === 'bigint') {\n    received = String(input);\n\n    if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n      received = addNumericalSeparator(received);\n    }\n\n    received += 'n';\n  }\n\n  msg += ` It must be ${range}. Received ${received}`;\n  return msg;\n}, RangeError);\n\nfunction addNumericalSeparator(val) {\n  let res = '';\n  let i = val.length;\n  const start = val[0] === '-' ? 1 : 0;\n\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`;\n  }\n\n  return `${val.slice(0, i)}${res}`;\n} // CHECK FUNCTIONS\n// ===============\n\n\nfunction checkBounds(buf, offset, byteLength) {\n  validateNumber(offset, 'offset');\n\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1));\n  }\n}\n\nfunction checkIntBI(value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : '';\n    let range;\n\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`;\n    }\n\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value);\n  }\n\n  checkBounds(buf, offset, byteLength);\n}\n\nfunction validateNumber(value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);\n  }\n}\n\nfunction boundsError(value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type);\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);\n} // HELPER FUNCTIONS\n// ================\n\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\nfunction base64clean(str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]; // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\n  str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''\n\n  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n\n  return str;\n}\n\nfunction utf8ToBytes(string, units) {\n  units = units || Infinity;\n  let codePoint;\n  const length = string.length;\n  let leadSurrogate = null;\n  const bytes = [];\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i); // is surrogate component\n\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } // valid lead\n\n\n        leadSurrogate = codePoint;\n        continue;\n      } // 2 leads in a row\n\n\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue;\n      } // valid surrogate pair\n\n\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null; // encode utf8\n\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break;\n      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break;\n      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break;\n      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n\n  return bytes;\n}\n\nfunction asciiToBytes(str) {\n  const byteArray = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n\n  return byteArray;\n}\n\nfunction utf16leToBytes(str, units) {\n  let c, hi, lo;\n  const byteArray = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break;\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return base64.toByteArray(base64clean(str));\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  let i;\n\n  for (i = 0; i < length; ++i) {\n    if (i + offset >= dst.length || i >= src.length) break;\n    dst[i + offset] = src[i];\n  }\n\n  return i;\n} // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\n\n\nfunction isInstance(obj, type) {\n  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n}\n\nfunction numberIsNaN(obj) {\n  // For IE11 support\n  return obj !== obj; // eslint-disable-line no-self-compare\n} // Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\n\n\nconst hexSliceLookupTable = function () {\n  const alphabet = '0123456789abcdef';\n  const table = new Array(256);\n\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16;\n\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j];\n    }\n  }\n\n  return table;\n}(); // Return not function with Error if BigInt not supported\n\n\nfunction defineBigIntMethod(fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;\n}\n\nfunction BufferBigIntNotDefined() {\n  throw new Error('BigInt not supported');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsRUFBcEIsRUFBd0IsRUFBRUEsQ0FBMUIsRUFBNkI7SUFDM0IsTUFBTTBPLEdBQUcsR0FBRzFPLENBQUMsR0FBRyxFQUFoQjs7SUFDQSxLQUFLLElBQUl3RSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEVBQXBCLEVBQXdCLEVBQUVBLENBQTFCLEVBQTZCO01BQzNCaUssS0FBSyxDQUFDQyxHQUFHLEdBQUdsSyxDQUFQLENBQUwsR0FBaUJnSyxRQUFRLENBQUN4TyxDQUFELENBQVIsR0FBY3dPLFFBQVEsQ0FBQ2hLLENBQUQsQ0FBdkM7SUFDRDtFQUNGOztFQUNELE9BQU9pSyxLQUFQO0FBQ0QsQ0FWMkIsRUFBNUIsQyxDQVlBOzs7QUFDQSxTQUFTdkcsa0JBQVQsQ0FBNkJ5RyxFQUE3QixFQUFpQztFQUMvQixPQUFPLE9BQU9sRyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDbUcsc0JBQWhDLEdBQXlERCxFQUFoRTtBQUNEOztBQUVELFNBQVNDLHNCQUFULEdBQW1DO0VBQ2pDLE1BQU0sSUFBSW5KLEtBQUosQ0FBVSxzQkFBVixDQUFOO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcz85MDFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG5jb25zdCBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5jb25zdCBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuY29uc3QgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGNvbnN0IGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgbGV0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgbGV0IGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICBjb25zdCBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICBsZXQgeCA9IGEubGVuZ3RoXG4gIGxldCB5ID0gYi5sZW5ndGhcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIGxldCBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgbGV0IHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGNvbnN0IG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2VyY2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIGNvbnN0IGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIGxldCBzdHIgPSAnJ1xuICBjb25zdCBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICBsZXQgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgbGV0IHkgPSBlbmQgLSBzdGFydFxuICBjb25zdCBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICBsZXQgaW5kZXhTaXplID0gMVxuICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICBsZXQgaVxuICBpZiAoZGlyKSB7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICBjb25zdCByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIGNvbnN0IHJlcyA9IFtdXG5cbiAgbGV0IGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIGxldCBjb2RlUG9pbnQgPSBudWxsXG4gICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5jb25zdCBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgbGV0IG91dCA9ICcnXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgbGV0IHJlcyA9ICcnXG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICBsZXQgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGxvID0gZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNFxuXG4gIGNvbnN0IGhpID0gdGhpc1srK29mZnNldF0gK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIGxhc3QgKiAyICoqIDI0XG5cbiAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgY29uc3QgbG8gPSB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3RcblxuICByZXR1cm4gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoXG4gIGxldCBtdWwgPSAxXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICtcbiAgICB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICtcbiAgICB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArXG4gICAgKGxhc3QgPDwgMjQpIC8vIE92ZXJmbG93XG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gKGZpcnN0IDw8IDI0KSArIC8vIE92ZXJmbG93XG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQodGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRMRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICByZXR1cm4gb2Zmc2V0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyA3XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNl0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDVdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA0XSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgM10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDJdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAxXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0XSA9IGhpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gMFxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICBsZXQgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBDVVNUT00gRVJST1JTXG4vLyA9PT09PT09PT09PT09XG5cbi8vIFNpbXBsaWZpZWQgdmVyc2lvbnMgZnJvbSBOb2RlLCBjaGFuZ2VkIGZvciBCdWZmZXItb25seSB1c2FnZVxuY29uc3QgZXJyb3JzID0ge31cbmZ1bmN0aW9uIEUgKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkge1xuICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske3N5bX1dYFxuICAgICAgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgICAgIC8vIGZyb20gdGhlIG5hbWUuXG4gICAgICB0aGlzLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgICAvLyBSZXNldCB0aGUgbmFtZSB0byB0aGUgYWN0dWFsIG5hbWUuXG4gICAgICBkZWxldGUgdGhpcy5uYW1lXG4gICAgfVxuXG4gICAgZ2V0IGNvZGUgKCkge1xuICAgICAgcmV0dXJuIHN5bVxuICAgIH1cblxuICAgIHNldCBjb2RlICh2YWx1ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2RlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgIH1cbiAgfVxufVxuXG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLFxuICBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gYCR7bmFtZX0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYFxuICAgIH1cblxuICAgIHJldHVybiAnQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcydcbiAgfSwgUmFuZ2VFcnJvcilcbkUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcbiAgZnVuY3Rpb24gKG5hbWUsIGFjdHVhbCkge1xuICAgIHJldHVybiBgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWBcbiAgfSwgVHlwZUVycm9yKVxuRSgnRVJSX09VVF9PRl9SQU5HRScsXG4gIGZ1bmN0aW9uIChzdHIsIHJhbmdlLCBpbnB1dCkge1xuICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLmBcbiAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dFxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7XG4gICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpXG4gICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7XG4gICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKVxuICAgICAgfVxuICAgICAgcmVjZWl2ZWQgKz0gJ24nXG4gICAgfVxuICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YFxuICAgIHJldHVybiBtc2dcbiAgfSwgUmFuZ2VFcnJvcilcblxuZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yICh2YWwpIHtcbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gdmFsLmxlbmd0aFxuICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gJy0nID8gMSA6IDBcbiAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHtcbiAgICByZXMgPSBgXyR7dmFsLnNsaWNlKGkgLSAzLCBpKX0ke3Jlc31gXG4gIH1cbiAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gXG59XG5cbi8vIENIRUNLIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRzIChidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBpZiAoYnVmW29mZnNldF0gPT09IHVuZGVmaW5lZCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoICsgMSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRCSSAodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHtcbiAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gJ2JpZ2ludCcgPyAnbicgOiAnJ1xuICAgIGxldCByYW5nZVxuICAgIGlmIChieXRlTGVuZ3RoID4gMykge1xuICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkge1xuICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4fSR7bn1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogYCArXG4gICAgICAgICAgICAgICAgYCR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn1gXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlID0gYD49ICR7bWlufSR7bn0gYW5kIDw9ICR7bWF4fSR7bn1gXG4gICAgfVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSgndmFsdWUnLCByYW5nZSwgdmFsdWUpXG4gIH1cbiAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyICh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0Vycm9yICh2YWx1ZSwgbGVuZ3RoLCB0eXBlKSB7XG4gIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcbiAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSlcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JywgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuXG4gIGlmIChsZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKVxuICB9XG5cbiAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUpXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuY29uc3QgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIGxldCBjb2RlUG9pbnRcbiAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgY29uc3QgYnl0ZXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIGxldCBjLCBoaSwgbG9cbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxuY29uc3QgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgY29uc3QgaTE2ID0gaSAqIDE2XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG5cbi8vIFJldHVybiBub3QgZnVuY3Rpb24gd2l0aCBFcnJvciBpZiBCaWdJbnQgbm90IHN1cHBvcnRlZFxuZnVuY3Rpb24gZGVmaW5lQmlnSW50TWV0aG9kIChmbikge1xuICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXJCaWdJbnROb3REZWZpbmVkIDogZm5cbn1cblxuZnVuY3Rpb24gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQmlnSW50IG5vdCBzdXBwb3J0ZWQnKVxufVxuIl0sIm5hbWVzIjpbImJhc2U2NCIsInJlcXVpcmUiLCJpZWVlNzU0IiwiY3VzdG9tSW5zcGVjdFN5bWJvbCIsIlN5bWJvbCIsImV4cG9ydHMiLCJCdWZmZXIiLCJTbG93QnVmZmVyIiwiSU5TUEVDVF9NQVhfQllURVMiLCJLX01BWF9MRU5HVEgiLCJrTWF4TGVuZ3RoIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsInR5cGVkQXJyYXlTdXBwb3J0IiwiY29uc29sZSIsImVycm9yIiwiYXJyIiwiVWludDhBcnJheSIsInByb3RvIiwiZm9vIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJlIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiaXNCdWZmZXIiLCJ1bmRlZmluZWQiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiY3JlYXRlQnVmZmVyIiwibGVuZ3RoIiwiUmFuZ2VFcnJvciIsImJ1ZiIsImFyZyIsImVuY29kaW5nT3JPZmZzZXQiLCJUeXBlRXJyb3IiLCJhbGxvY1Vuc2FmZSIsImZyb20iLCJwb29sU2l6ZSIsInZhbHVlIiwiZnJvbVN0cmluZyIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiZnJvbUFycmF5VmlldyIsImlzSW5zdGFuY2UiLCJmcm9tQXJyYXlCdWZmZXIiLCJTaGFyZWRBcnJheUJ1ZmZlciIsInZhbHVlT2YiLCJiIiwiZnJvbU9iamVjdCIsInRvUHJpbWl0aXZlIiwiYXNzZXJ0U2l6ZSIsInNpemUiLCJhbGxvYyIsImZpbGwiLCJlbmNvZGluZyIsImNoZWNrZWQiLCJhbGxvY1Vuc2FmZVNsb3ciLCJzdHJpbmciLCJpc0VuY29kaW5nIiwiYnl0ZUxlbmd0aCIsImFjdHVhbCIsIndyaXRlIiwic2xpY2UiLCJmcm9tQXJyYXlMaWtlIiwiYXJyYXkiLCJpIiwiYXJyYXlWaWV3IiwiY29weSIsIm9iaiIsImxlbiIsIm51bWJlcklzTmFOIiwidHlwZSIsIkFycmF5IiwiaXNBcnJheSIsImRhdGEiLCJ0b1N0cmluZyIsIl9pc0J1ZmZlciIsImNvbXBhcmUiLCJhIiwib2Zmc2V0IiwieCIsInkiLCJNYXRoIiwibWluIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJjb25jYXQiLCJsaXN0IiwicG9zIiwic2V0IiwiY2FsbCIsIm11c3RNYXRjaCIsImFyZ3VtZW50cyIsImxvd2VyZWRDYXNlIiwidXRmOFRvQnl0ZXMiLCJiYXNlNjRUb0J5dGVzIiwic2xvd1RvU3RyaW5nIiwic3RhcnQiLCJlbmQiLCJoZXhTbGljZSIsInV0ZjhTbGljZSIsImFzY2lpU2xpY2UiLCJsYXRpbjFTbGljZSIsImJhc2U2NFNsaWNlIiwidXRmMTZsZVNsaWNlIiwic3dhcCIsIm4iLCJtIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiYXBwbHkiLCJ0b0xvY2FsZVN0cmluZyIsImVxdWFscyIsImluc3BlY3QiLCJzdHIiLCJtYXgiLCJyZXBsYWNlIiwidHJpbSIsInRhcmdldCIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsInZhbCIsImRpciIsImFycmF5SW5kZXhPZiIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJqIiwiaW5jbHVkZXMiLCJoZXhXcml0ZSIsIk51bWJlciIsInJlbWFpbmluZyIsInN0ckxlbiIsInBhcnNlZCIsInBhcnNlSW50Iiwic3Vic3RyIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJiYXNlNjRXcml0ZSIsInVjczJXcml0ZSIsInV0ZjE2bGVUb0J5dGVzIiwiaXNGaW5pdGUiLCJFcnJvciIsInRvSlNPTiIsIl9hcnIiLCJmcm9tQnl0ZUFycmF5IiwicmVzIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsInB1c2giLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJNQVhfQVJHVU1FTlRTX0xFTkdUSCIsImNvZGVQb2ludHMiLCJmcm9tQ2hhckNvZGUiLCJyZXQiLCJvdXQiLCJoZXhTbGljZUxvb2t1cFRhYmxlIiwiYnl0ZXMiLCJuZXdCdWYiLCJzdWJhcnJheSIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVpbnRMRSIsInJlYWRVSW50TEUiLCJub0Fzc2VydCIsIm11bCIsInJlYWRVaW50QkUiLCJyZWFkVUludEJFIiwicmVhZFVpbnQ4IiwicmVhZFVJbnQ4IiwicmVhZFVpbnQxNkxFIiwicmVhZFVJbnQxNkxFIiwicmVhZFVpbnQxNkJFIiwicmVhZFVpbnQzMkxFIiwicmVhZFVJbnQzMkxFIiwicmVhZFVpbnQzMkJFIiwicmVhZFVJbnQzMkJFIiwicmVhZEJpZ1VJbnQ2NExFIiwiZGVmaW5lQmlnSW50TWV0aG9kIiwidmFsaWRhdGVOdW1iZXIiLCJmaXJzdCIsImxhc3QiLCJib3VuZHNFcnJvciIsImxvIiwiaGkiLCJCaWdJbnQiLCJyZWFkQmlnVUludDY0QkUiLCJyZWFkSW50TEUiLCJwb3ciLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEJpZ0ludDY0TEUiLCJyZWFkQmlnSW50NjRCRSIsInJlYWRGbG9hdExFIiwicmVhZEZsb2F0QkUiLCJyZWFkRG91YmxlTEUiLCJyZWFkRG91YmxlQkUiLCJjaGVja0ludCIsIndyaXRlVWludExFIiwid3JpdGVVSW50TEUiLCJtYXhCeXRlcyIsIndyaXRlVWludEJFIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVpbnQ4Iiwid3JpdGVVSW50OCIsIndyaXRlVWludDE2TEUiLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVaW50MTZCRSIsIndyaXRlVUludDE2QkUiLCJ3cml0ZVVpbnQzMkxFIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVWludDMyQkUiLCJ3cml0ZVVJbnQzMkJFIiwid3J0QmlnVUludDY0TEUiLCJjaGVja0ludEJJIiwid3J0QmlnVUludDY0QkUiLCJ3cml0ZUJpZ1VJbnQ2NExFIiwid3JpdGVCaWdVSW50NjRCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsInN1YiIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJ3cml0ZUJpZ0ludDY0TEUiLCJ3cml0ZUJpZ0ludDY0QkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0IiwibGl0dGxlRW5kaWFuIiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiY29weVdpdGhpbiIsImNvZGUiLCJjaGFyQ29kZUF0IiwiZXJyb3JzIiwiRSIsInN5bSIsImdldE1lc3NhZ2UiLCJCYXNlIiwiTm9kZUVycm9yIiwiY29uc3RydWN0b3IiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsIm5hbWUiLCJzdGFjayIsIm1lc3NhZ2UiLCJyYW5nZSIsImlucHV0IiwibXNnIiwicmVjZWl2ZWQiLCJpc0ludGVnZXIiLCJhYnMiLCJhZGROdW1lcmljYWxTZXBhcmF0b3IiLCJjaGVja0JvdW5kcyIsIkVSUl9PVVRfT0ZfUkFOR0UiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsImZsb29yIiwiRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTIiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInNwbGl0IiwidW5pdHMiLCJJbmZpbml0eSIsImxlYWRTdXJyb2dhdGUiLCJieXRlQXJyYXkiLCJjIiwidG9CeXRlQXJyYXkiLCJzcmMiLCJkc3QiLCJhbHBoYWJldCIsInRhYmxlIiwiaTE2IiwiZm4iLCJCdWZmZXJCaWdJbnROb3REZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/buffer/index.js\n"));

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? nBytes - 1 : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n  i += d;\n  e = s & (1 << -nBits) - 1;\n  s >>= -nBits;\n  nBits += eLen;\n\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : (s ? -1 : 1) * Infinity;\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n  var i = isLE ? 0 : nBytes - 1;\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = e << mLen | m;\n  eLen += mLen;\n\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0FBRyxDQUFkLEVBQWlCUCxNQUFNLENBQUNDLE1BQU0sR0FBR1UsQ0FBVixDQUFOLEdBQXFCTixDQUFDLEdBQUcsSUFBekIsRUFBK0JNLENBQUMsSUFBSUMsQ0FBcEMsRUFBdUNQLENBQUMsSUFBSSxHQUE1QyxFQUFpREUsSUFBSSxJQUFJLENBQTFFLEVBQTZFLENBQUU7O0VBRS9FUCxNQUFNLENBQUNDLE1BQU0sR0FBR1UsQ0FBVCxHQUFhQyxDQUFkLENBQU4sSUFBMEJDLENBQUMsR0FBRyxHQUE5QjtBQUNELENBbEREIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzP2ViYzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiJdLCJuYW1lcyI6WyJleHBvcnRzIiwicmVhZCIsImJ1ZmZlciIsIm9mZnNldCIsImlzTEUiLCJtTGVuIiwibkJ5dGVzIiwiZSIsIm0iLCJlTGVuIiwiZU1heCIsImVCaWFzIiwibkJpdHMiLCJpIiwiZCIsInMiLCJOYU4iLCJJbmZpbml0eSIsIk1hdGgiLCJwb3ciLCJ3cml0ZSIsInZhbHVlIiwiYyIsInJ0IiwiYWJzIiwiaXNOYU4iLCJmbG9vciIsImxvZyIsIkxOMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/client/_utils.js":
/*!*************************************************!*\
  !*** ./node_modules/next-auth/client/_utils.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BroadcastChannel = BroadcastChannel;\nexports.apiBaseUrl = apiBaseUrl;\nexports.fetchData = fetchData;\nexports.now = now;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction fetchData(_x, _x2, _x3) {\n  return _fetchData.apply(this, arguments);\n}\n\nfunction _fetchData() {\n  _fetchData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(path, __NEXTAUTH, logger) {\n    var _ref,\n        ctx,\n        _ref$req,\n        req,\n        url,\n        options,\n        res,\n        data,\n        _args = arguments;\n\n    return _regenerator.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref = _args.length > 3 && _args[3] !== undefined ? _args[3] : {}, ctx = _ref.ctx, _ref$req = _ref.req, req = _ref$req === void 0 ? ctx === null || ctx === void 0 ? void 0 : ctx.req : _ref$req;\n            url = \"\".concat(apiBaseUrl(__NEXTAUTH), \"/\").concat(path);\n            _context.prev = 2;\n            options = req !== null && req !== void 0 && req.headers.cookie ? {\n              headers: {\n                cookie: req.headers.cookie\n              }\n            } : {};\n            _context.next = 6;\n            return fetch(url, options);\n\n          case 6:\n            res = _context.sent;\n            _context.next = 9;\n            return res.json();\n\n          case 9:\n            data = _context.sent;\n\n            if (res.ok) {\n              _context.next = 12;\n              break;\n            }\n\n            throw data;\n\n          case 12:\n            return _context.abrupt(\"return\", Object.keys(data).length > 0 ? data : null);\n\n          case 15:\n            _context.prev = 15;\n            _context.t0 = _context[\"catch\"](2);\n            logger.error(\"CLIENT_FETCH_ERROR\", {\n              error: _context.t0,\n              url: url\n            });\n            return _context.abrupt(\"return\", null);\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[2, 15]]);\n  }));\n  return _fetchData.apply(this, arguments);\n}\n\nfunction apiBaseUrl(__NEXTAUTH) {\n  if (typeof window === \"undefined\") {\n    return \"\".concat(__NEXTAUTH.baseUrlServer).concat(__NEXTAUTH.basePathServer);\n  }\n\n  return __NEXTAUTH.basePath;\n}\n\nfunction now() {\n  return Math.floor(Date.now() / 1000);\n}\n\nfunction BroadcastChannel() {\n  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"nextauth.message\";\n  return {\n    receive: function receive(onReceive) {\n      var handler = function handler(event) {\n        var _event$newValue;\n\n        if (event.key !== name) return;\n        var message = JSON.parse((_event$newValue = event.newValue) !== null && _event$newValue !== void 0 ? _event$newValue : \"{}\");\n        if ((message === null || message === void 0 ? void 0 : message.event) !== \"session\" || !(message !== null && message !== void 0 && message.data)) return;\n        onReceive(message);\n      };\n\n      window.addEventListener(\"storage\", handler);\n      return function () {\n        return window.removeEventListener(\"storage\", handler);\n      };\n    },\n    post: function post(message) {\n      if (typeof window === \"undefined\") return;\n\n      try {\n        localStorage.setItem(name, JSON.stringify(_objectSpread(_objectSpread({}, message), {}, {\n          timestamp: now()\n        })));\n      } catch (_unused) {}\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2NsaWVudC9fdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSUEsc0JBQXNCLEdBQUdDLG1CQUFPLENBQUMsb0hBQUQsQ0FBcEM7O0FBRUFDLDhDQUE2QztFQUMzQ0csS0FBSyxFQUFFO0FBRG9DLENBQTdDO0FBR0FELHdCQUFBLEdBQTJCRSxnQkFBM0I7QUFDQUYsa0JBQUEsR0FBcUJHLFVBQXJCO0FBQ0FILGlCQUFBLEdBQW9CSSxTQUFwQjtBQUNBSixXQUFBLEdBQWNLLEdBQWQ7O0FBRUEsSUFBSUMsWUFBWSxHQUFHVixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxzRkFBRCxDQUFSLENBQXpDOztBQUVBLElBQUlVLGdCQUFnQixHQUFHWCxzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxzR0FBRCxDQUFSLENBQTdDOztBQUVBLElBQUlXLGtCQUFrQixHQUFHWixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQywwR0FBRCxDQUFSLENBQS9DOztBQUVBLFNBQVNZLE9BQVQsQ0FBaUJDLE1BQWpCLEVBQXlCQyxjQUF6QixFQUF5QztFQUFFLElBQUlDLElBQUksR0FBR2QsTUFBTSxDQUFDYyxJQUFQLENBQVlGLE1BQVosQ0FBWDs7RUFBZ0MsSUFBSVosTUFBTSxDQUFDZSxxQkFBWCxFQUFrQztJQUFFLElBQUlDLE9BQU8sR0FBR2hCLE1BQU0sQ0FBQ2UscUJBQVAsQ0FBNkJILE1BQTdCLENBQWQ7SUFBb0RDLGNBQWMsS0FBS0csT0FBTyxHQUFHQSxPQUFPLENBQUNDLE1BQVIsQ0FBZSxVQUFVQyxHQUFWLEVBQWU7TUFBRSxPQUFPbEIsTUFBTSxDQUFDbUIsd0JBQVAsQ0FBZ0NQLE1BQWhDLEVBQXdDTSxHQUF4QyxFQUE2Q0UsVUFBcEQ7SUFBaUUsQ0FBakcsQ0FBZixDQUFkLEVBQWtJTixJQUFJLENBQUNPLElBQUwsQ0FBVUMsS0FBVixDQUFnQlIsSUFBaEIsRUFBc0JFLE9BQXRCLENBQWxJO0VBQW1LOztFQUFD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aUM7VUFDdEZVLFNBQVMsRUFBRXJGLEdBQUc7UUFEd0UsQ0FBakMsQ0FBNUIsQ0FBM0I7TUFHRCxDQUpELENBSUUsT0FBT3NGLE9BQVAsRUFBZ0IsQ0FBRTtJQUNyQjtFQXhCSSxDQUFQO0FBMEJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvY2xpZW50L191dGlscy5qcz8wZGEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQnJvYWRjYXN0Q2hhbm5lbCA9IEJyb2FkY2FzdENoYW5uZWw7XG5leHBvcnRzLmFwaUJhc2VVcmwgPSBhcGlCYXNlVXJsO1xuZXhwb3J0cy5mZXRjaERhdGEgPSBmZXRjaERhdGE7XG5leHBvcnRzLm5vdyA9IG5vdztcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gZmV0Y2hEYXRhKF94LCBfeDIsIF94Mykge1xuICByZXR1cm4gX2ZldGNoRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZmV0Y2hEYXRhKCkge1xuICBfZmV0Y2hEYXRhID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocGF0aCwgX19ORVhUQVVUSCwgbG9nZ2VyKSB7XG4gICAgdmFyIF9yZWYsXG4gICAgICAgIGN0eCxcbiAgICAgICAgX3JlZiRyZXEsXG4gICAgICAgIHJlcSxcbiAgICAgICAgdXJsLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICByZXMsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfcmVmID0gX2FyZ3MubGVuZ3RoID4gMyAmJiBfYXJnc1szXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbM10gOiB7fSwgY3R4ID0gX3JlZi5jdHgsIF9yZWYkcmVxID0gX3JlZi5yZXEsIHJlcSA9IF9yZWYkcmVxID09PSB2b2lkIDAgPyBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgucmVxIDogX3JlZiRyZXE7XG4gICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdChhcGlCYXNlVXJsKF9fTkVYVEFVVEgpLCBcIi9cIikuY29uY2F0KHBhdGgpO1xuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI7XG4gICAgICAgICAgICBvcHRpb25zID0gcmVxICE9PSBudWxsICYmIHJlcSAhPT0gdm9pZCAwICYmIHJlcS5oZWFkZXJzLmNvb2tpZSA/IHtcbiAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIGNvb2tpZTogcmVxLmhlYWRlcnMuY29va2llXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gOiB7fTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKHVybCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXMgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmpzb24oKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IGRhdGE7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggPiAwID8gZGF0YSA6IG51bGwpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxNTtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgyKTtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkNMSUVOVF9GRVRDSF9FUlJPUlwiLCB7XG4gICAgICAgICAgICAgIGVycm9yOiBfY29udGV4dC50MCxcbiAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBudWxsKTtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMiwgMTVdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9mZXRjaERhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gYXBpQmFzZVVybChfX05FWFRBVVRIKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KF9fTkVYVEFVVEguYmFzZVVybFNlcnZlcikuY29uY2F0KF9fTkVYVEFVVEguYmFzZVBhdGhTZXJ2ZXIpO1xuICB9XG5cbiAgcmV0dXJuIF9fTkVYVEFVVEguYmFzZVBhdGg7XG59XG5cbmZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xufVxuXG5mdW5jdGlvbiBCcm9hZGNhc3RDaGFubmVsKCkge1xuICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJuZXh0YXV0aC5tZXNzYWdlXCI7XG4gIHJldHVybiB7XG4gICAgcmVjZWl2ZTogZnVuY3Rpb24gcmVjZWl2ZShvblJlY2VpdmUpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgICAgICB2YXIgX2V2ZW50JG5ld1ZhbHVlO1xuXG4gICAgICAgIGlmIChldmVudC5rZXkgIT09IG5hbWUpIHJldHVybjtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKChfZXZlbnQkbmV3VmFsdWUgPSBldmVudC5uZXdWYWx1ZSkgIT09IG51bGwgJiYgX2V2ZW50JG5ld1ZhbHVlICE9PSB2b2lkIDAgPyBfZXZlbnQkbmV3VmFsdWUgOiBcInt9XCIpO1xuICAgICAgICBpZiAoKG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVzc2FnZS5ldmVudCkgIT09IFwic2Vzc2lvblwiIHx8ICEobWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgJiYgbWVzc2FnZS5kYXRhKSkgcmV0dXJuO1xuICAgICAgICBvblJlY2VpdmUobWVzc2FnZSk7XG4gICAgICB9O1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInN0b3JhZ2VcIiwgaGFuZGxlcik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdG9yYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIHBvc3Q6IGZ1bmN0aW9uIHBvc3QobWVzc2FnZSkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obmFtZSwgSlNPTi5zdHJpbmdpZnkoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBtZXNzYWdlKSwge30sIHtcbiAgICAgICAgICB0aW1lc3RhbXA6IG5vdygpXG4gICAgICAgIH0pKSk7XG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7fVxuICAgIH1cbiAgfTtcbn0iXSwibmFtZXMiOlsiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJyb2FkY2FzdENoYW5uZWwiLCJhcGlCYXNlVXJsIiwiZmV0Y2hEYXRhIiwibm93IiwiX3JlZ2VuZXJhdG9yIiwiX2RlZmluZVByb3BlcnR5MiIsIl9hc3luY1RvR2VuZXJhdG9yMiIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwiZm9yRWFjaCIsImtleSIsImRlZmF1bHQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl94IiwiX3gyIiwiX3gzIiwiX2ZldGNoRGF0YSIsIm1hcmsiLCJfY2FsbGVlIiwicGF0aCIsIl9fTkVYVEFVVEgiLCJsb2dnZXIiLCJfcmVmIiwiY3R4IiwiX3JlZiRyZXEiLCJyZXEiLCJ1cmwiLCJvcHRpb25zIiwicmVzIiwiZGF0YSIsIl9hcmdzIiwid3JhcCIsIl9jYWxsZWUkIiwiX2NvbnRleHQiLCJwcmV2IiwibmV4dCIsInVuZGVmaW5lZCIsImNvbmNhdCIsImhlYWRlcnMiLCJjb29raWUiLCJmZXRjaCIsInNlbnQiLCJqc29uIiwib2siLCJhYnJ1cHQiLCJ0MCIsImVycm9yIiwic3RvcCIsIndpbmRvdyIsImJhc2VVcmxTZXJ2ZXIiLCJiYXNlUGF0aFNlcnZlciIsImJhc2VQYXRoIiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsIm5hbWUiLCJyZWNlaXZlIiwib25SZWNlaXZlIiwiaGFuZGxlciIsImV2ZW50IiwiX2V2ZW50JG5ld1ZhbHVlIiwibWVzc2FnZSIsIkpTT04iLCJwYXJzZSIsIm5ld1ZhbHVlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwb3N0IiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInRpbWVzdGFtcCIsIl91bnVzZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next-auth/client/_utils.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/core/errors.js":
/*!***********************************************!*\
  !*** ./node_modules/next-auth/core/errors.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.UnsupportedStrategy = exports.UnknownError = exports.OAuthCallbackError = exports.MissingSecret = exports.MissingAuthorize = exports.MissingAdapter = exports.MissingAPIRoute = exports.InvalidCallbackUrl = exports.AccountNotLinkedError = void 0;\nexports.adapterErrorHandler = adapterErrorHandler;\nexports.capitalize = capitalize;\nexports.eventsErrorHandler = eventsErrorHandler;\nexports.upperSnake = upperSnake;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ \"./node_modules/@babel/runtime/helpers/wrapNativeSuper.js\"));\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar UnknownError = function (_Error) {\n  (0, _inherits2.default)(UnknownError, _Error);\n\n  var _super = _createSuper(UnknownError);\n\n  function UnknownError(error) {\n    var _message;\n\n    var _this;\n\n    (0, _classCallCheck2.default)(this, UnknownError);\n    _this = _super.call(this, (_message = error === null || error === void 0 ? void 0 : error.message) !== null && _message !== void 0 ? _message : error);\n    _this.name = \"UnknownError\";\n    _this.code = error.code;\n\n    if (error instanceof Error) {\n      _this.stack = error.stack;\n    }\n\n    return _this;\n  }\n\n  (0, _createClass2.default)(UnknownError, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        name: this.name,\n        message: this.message,\n        stack: this.stack\n      };\n    }\n  }]);\n  return UnknownError;\n}((0, _wrapNativeSuper2.default)(Error));\n\nexports.UnknownError = UnknownError;\n\nvar OAuthCallbackError = function (_UnknownError) {\n  (0, _inherits2.default)(OAuthCallbackError, _UnknownError);\n\n  var _super2 = _createSuper(OAuthCallbackError);\n\n  function OAuthCallbackError() {\n    var _this2;\n\n    (0, _classCallCheck2.default)(this, OAuthCallbackError);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this2 = _super2.call.apply(_super2, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), \"name\", \"OAuthCallbackError\");\n    return _this2;\n  }\n\n  return (0, _createClass2.default)(OAuthCallbackError);\n}(UnknownError);\n\nexports.OAuthCallbackError = OAuthCallbackError;\n\nvar AccountNotLinkedError = function (_UnknownError2) {\n  (0, _inherits2.default)(AccountNotLinkedError, _UnknownError2);\n\n  var _super3 = _createSuper(AccountNotLinkedError);\n\n  function AccountNotLinkedError() {\n    var _this3;\n\n    (0, _classCallCheck2.default)(this, AccountNotLinkedError);\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    _this3 = _super3.call.apply(_super3, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this3), \"name\", \"AccountNotLinkedError\");\n    return _this3;\n  }\n\n  return (0, _createClass2.default)(AccountNotLinkedError);\n}(UnknownError);\n\nexports.AccountNotLinkedError = AccountNotLinkedError;\n\nvar MissingAPIRoute = function (_UnknownError3) {\n  (0, _inherits2.default)(MissingAPIRoute, _UnknownError3);\n\n  var _super4 = _createSuper(MissingAPIRoute);\n\n  function MissingAPIRoute() {\n    var _this4;\n\n    (0, _classCallCheck2.default)(this, MissingAPIRoute);\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    _this4 = _super4.call.apply(_super4, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), \"name\", \"MissingAPIRouteError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), \"code\", \"MISSING_NEXTAUTH_API_ROUTE_ERROR\");\n    return _this4;\n  }\n\n  return (0, _createClass2.default)(MissingAPIRoute);\n}(UnknownError);\n\nexports.MissingAPIRoute = MissingAPIRoute;\n\nvar MissingSecret = function (_UnknownError4) {\n  (0, _inherits2.default)(MissingSecret, _UnknownError4);\n\n  var _super5 = _createSuper(MissingSecret);\n\n  function MissingSecret() {\n    var _this5;\n\n    (0, _classCallCheck2.default)(this, MissingSecret);\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    _this5 = _super5.call.apply(_super5, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), \"name\", \"MissingSecretError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), \"code\", \"NO_SECRET\");\n    return _this5;\n  }\n\n  return (0, _createClass2.default)(MissingSecret);\n}(UnknownError);\n\nexports.MissingSecret = MissingSecret;\n\nvar MissingAuthorize = function (_UnknownError5) {\n  (0, _inherits2.default)(MissingAuthorize, _UnknownError5);\n\n  var _super6 = _createSuper(MissingAuthorize);\n\n  function MissingAuthorize() {\n    var _this6;\n\n    (0, _classCallCheck2.default)(this, MissingAuthorize);\n\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    _this6 = _super6.call.apply(_super6, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), \"name\", \"MissingAuthorizeError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), \"code\", \"CALLBACK_CREDENTIALS_HANDLER_ERROR\");\n    return _this6;\n  }\n\n  return (0, _createClass2.default)(MissingAuthorize);\n}(UnknownError);\n\nexports.MissingAuthorize = MissingAuthorize;\n\nvar MissingAdapter = function (_UnknownError6) {\n  (0, _inherits2.default)(MissingAdapter, _UnknownError6);\n\n  var _super7 = _createSuper(MissingAdapter);\n\n  function MissingAdapter() {\n    var _this7;\n\n    (0, _classCallCheck2.default)(this, MissingAdapter);\n\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    _this7 = _super7.call.apply(_super7, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), \"name\", \"MissingAdapterError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), \"code\", \"EMAIL_REQUIRES_ADAPTER_ERROR\");\n    return _this7;\n  }\n\n  return (0, _createClass2.default)(MissingAdapter);\n}(UnknownError);\n\nexports.MissingAdapter = MissingAdapter;\n\nvar UnsupportedStrategy = function (_UnknownError7) {\n  (0, _inherits2.default)(UnsupportedStrategy, _UnknownError7);\n\n  var _super8 = _createSuper(UnsupportedStrategy);\n\n  function UnsupportedStrategy() {\n    var _this8;\n\n    (0, _classCallCheck2.default)(this, UnsupportedStrategy);\n\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    _this8 = _super8.call.apply(_super8, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this8), \"name\", \"UnsupportedStrategyError\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this8), \"code\", \"CALLBACK_CREDENTIALS_JWT_ERROR\");\n    return _this8;\n  }\n\n  return (0, _createClass2.default)(UnsupportedStrategy);\n}(UnknownError);\n\nexports.UnsupportedStrategy = UnsupportedStrategy;\n\nvar InvalidCallbackUrl = function (_UnknownError8) {\n  (0, _inherits2.default)(InvalidCallbackUrl, _UnknownError8);\n\n  var _super9 = _createSuper(InvalidCallbackUrl);\n\n  function InvalidCallbackUrl() {\n    var _this9;\n\n    (0, _classCallCheck2.default)(this, InvalidCallbackUrl);\n\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n\n    _this9 = _super9.call.apply(_super9, [this].concat(args));\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this9), \"name\", \"InvalidCallbackUrl\");\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this9), \"code\", \"INVALID_CALLBACK_URL_ERROR\");\n    return _this9;\n  }\n\n  return (0, _createClass2.default)(InvalidCallbackUrl);\n}(UnknownError);\n\nexports.InvalidCallbackUrl = InvalidCallbackUrl;\n\nfunction upperSnake(s) {\n  return s.replace(/([A-Z])/g, \"_$1\").toUpperCase();\n}\n\nfunction capitalize(s) {\n  return \"\".concat(s[0].toUpperCase()).concat(s.slice(1));\n}\n\nfunction eventsErrorHandler(methods, logger) {\n  return Object.keys(methods).reduce(function (acc, name) {\n    acc[name] = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {\n      var method,\n          _args = arguments;\n      return _regenerator.default.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              method = methods[name];\n              _context.next = 4;\n              return method.apply(void 0, _args);\n\n            case 4:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 7:\n              _context.prev = 7;\n              _context.t0 = _context[\"catch\"](0);\n              logger.error(\"\".concat(upperSnake(name), \"_EVENT_ERROR\"), _context.t0);\n\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 7]]);\n    }));\n    return acc;\n  }, {});\n}\n\nfunction adapterErrorHandler(adapter, logger) {\n  if (!adapter) return;\n  return Object.keys(adapter).reduce(function (acc, name) {\n    acc[name] = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {\n      var _len9,\n          args,\n          _key9,\n          method,\n          e,\n          _args2 = arguments;\n\n      return _regenerator.default.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n\n              for (_len9 = _args2.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n                args[_key9] = _args2[_key9];\n              }\n\n              logger.debug(\"adapter_\".concat(name), {\n                args: args\n              });\n              method = adapter[name];\n              _context2.next = 6;\n              return method.apply(void 0, args);\n\n            case 6:\n              return _context2.abrupt(\"return\", _context2.sent);\n\n            case 9:\n              _context2.prev = 9;\n              _context2.t0 = _context2[\"catch\"](0);\n              logger.error(\"adapter_error_\".concat(name), _context2.t0);\n              e = new UnknownError(_context2.t0);\n              e.name = \"\".concat(capitalize(name), \"Error\");\n              throw e;\n\n            case 15:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[0, 9]]);\n    }));\n    return acc;\n  }, {});\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2NvcmUvZXJyb3JzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUlBLHNCQUFzQixHQUFHQyxtQkFBTyxDQUFDLG9IQUFELENBQXBDOztBQUVBQyw4Q0FBNkM7RUFDM0NHLEtBQUssRUFBRTtBQURvQyxDQUE3QztBQUdBRCwyQkFBQSxHQUE4QkEsb0JBQUEsR0FBdUJBLDBCQUFBLEdBQTZCQSxxQkFBQSxHQUF3QkEsd0JBQUEsR0FBMkJBLHNCQUFBLEdBQXlCQSx1QkFBQSxHQUEwQkEsMEJBQUEsR0FBNkJBLDZCQUFBLEdBQWdDLEtBQUssQ0FBMVA7QUFDQUEsMkJBQUEsR0FBOEJXLG1CQUE5QjtBQUNBWCxrQkFBQSxHQUFxQlksVUFBckI7QUFDQVosMEJBQUEsR0FBNkJhLGtCQUE3QjtBQUNBYixrQkFBQSxHQUFxQmMsVUFBckI7O0FBRUEsSUFBSUMsWUFBWSxHQUFHbkIsc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsc0ZBQUQsQ0FBUixDQUF6Qzs7QUFFQSxJQUFJbUIsa0JBQWtCLEdBQUdwQixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQywwR0FBRCxDQUFSLENBQS9DOztBQUVBLElBQUlvQix1QkFBdUIsR0FBR3JCLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLG9IQUFELENBQVIsQ0FBcEQ7O0FBRUEsSUFBSXFCLGdCQUFnQixHQUFHdEIsc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsc0dBQUQsQ0FBUixDQUE3Qzs7QUFFQSxJQUFJc0IsZ0JBQWdCLEdBQUd2QixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxzR0FBRCxDQUFSLENBQTdDOztBQUVBLElBQUl1QixhQUFhLEdBQUd4QixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxnR0FBRCxDQUFSLENBQTFDOztBQUVBLElBQUl3QixVQUFVLEdBQUd6QixzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQywwRkFBRCxDQUFSLENBQXZDOztBQUVBLElBQUl5QiwyQkFBMkIsR0FB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QUEzQixDQUFKO2NBQ0E3RSxDQUFDLENBQUNPLElBQUYsR0FBUyxHQUFHYyxNQUFILENBQVV0RCxVQUFVLENBQUN3QyxJQUFELENBQXBCLEVBQTRCLE9BQTVCLENBQVQ7Y0FDQSxNQUFNUCxDQUFOOztZQUVGLEtBQUssRUFBTDtZQUNBLEtBQUssS0FBTDtjQUNFLE9BQU9xRixTQUFTLENBQUNQLElBQVYsRUFBUDtVQTVCSjtRQThCRDtNQUNGLENBakNNLEVBaUNKRSxRQWpDSSxFQWlDTSxJQWpDTixFQWlDWSxDQUFDLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBRCxDQWpDWixDQUFQO0lBa0NELENBMUMyQyxDQUFoQyxDQUFaO0lBMkNBLE9BQU9mLEdBQVA7RUFDRCxDQTdDTSxFQTZDSixFQTdDSSxDQUFQO0FBOENEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvY29yZS9lcnJvcnMuanM/ZGRjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlVuc3VwcG9ydGVkU3RyYXRlZ3kgPSBleHBvcnRzLlVua25vd25FcnJvciA9IGV4cG9ydHMuT0F1dGhDYWxsYmFja0Vycm9yID0gZXhwb3J0cy5NaXNzaW5nU2VjcmV0ID0gZXhwb3J0cy5NaXNzaW5nQXV0aG9yaXplID0gZXhwb3J0cy5NaXNzaW5nQWRhcHRlciA9IGV4cG9ydHMuTWlzc2luZ0FQSVJvdXRlID0gZXhwb3J0cy5JbnZhbGlkQ2FsbGJhY2tVcmwgPSBleHBvcnRzLkFjY291bnROb3RMaW5rZWRFcnJvciA9IHZvaWQgMDtcbmV4cG9ydHMuYWRhcHRlckVycm9ySGFuZGxlciA9IGFkYXB0ZXJFcnJvckhhbmRsZXI7XG5leHBvcnRzLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuZXhwb3J0cy5ldmVudHNFcnJvckhhbmRsZXIgPSBldmVudHNFcnJvckhhbmRsZXI7XG5leHBvcnRzLnVwcGVyU25ha2UgPSB1cHBlclNuYWtlO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF93cmFwTmF0aXZlU3VwZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXJcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFVua25vd25FcnJvciA9IGZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVW5rbm93bkVycm9yLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVW5rbm93bkVycm9yKTtcblxuICBmdW5jdGlvbiBVbmtub3duRXJyb3IoZXJyb3IpIHtcbiAgICB2YXIgX21lc3NhZ2U7XG5cbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBVbmtub3duRXJyb3IpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgKF9tZXNzYWdlID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpICE9PSBudWxsICYmIF9tZXNzYWdlICE9PSB2b2lkIDAgPyBfbWVzc2FnZSA6IGVycm9yKTtcbiAgICBfdGhpcy5uYW1lID0gXCJVbmtub3duRXJyb3JcIjtcbiAgICBfdGhpcy5jb2RlID0gZXJyb3IuY29kZTtcblxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBfdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFVua25vd25FcnJvciwgW3tcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICBzdGFjazogdGhpcy5zdGFja1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFVua25vd25FcnJvcjtcbn0oKDAsIF93cmFwTmF0aXZlU3VwZXIyLmRlZmF1bHQpKEVycm9yKSk7XG5cbmV4cG9ydHMuVW5rbm93bkVycm9yID0gVW5rbm93bkVycm9yO1xuXG52YXIgT0F1dGhDYWxsYmFja0Vycm9yID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3IpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoT0F1dGhDYWxsYmFja0Vycm9yLCBfVW5rbm93bkVycm9yKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihPQXV0aENhbGxiYWNrRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIE9BdXRoQ2FsbGJhY2tFcnJvcigpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgT0F1dGhDYWxsYmFja0Vycm9yKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpczIgPSBfc3VwZXIyLmNhbGwuYXBwbHkoX3N1cGVyMiwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzMiksIFwibmFtZVwiLCBcIk9BdXRoQ2FsbGJhY2tFcnJvclwiKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgcmV0dXJuICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKE9BdXRoQ2FsbGJhY2tFcnJvcik7XG59KFVua25vd25FcnJvcik7XG5cbmV4cG9ydHMuT0F1dGhDYWxsYmFja0Vycm9yID0gT0F1dGhDYWxsYmFja0Vycm9yO1xuXG52YXIgQWNjb3VudE5vdExpbmtlZEVycm9yID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3IyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEFjY291bnROb3RMaW5rZWRFcnJvciwgX1Vua25vd25FcnJvcjIpO1xuXG4gIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKEFjY291bnROb3RMaW5rZWRFcnJvcik7XG5cbiAgZnVuY3Rpb24gQWNjb3VudE5vdExpbmtlZEVycm9yKCkge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBBY2NvdW50Tm90TGlua2VkRXJyb3IpO1xuXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgX3RoaXMzID0gX3N1cGVyMy5jYWxsLmFwcGx5KF9zdXBlcjMsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczMpLCBcIm5hbWVcIiwgXCJBY2NvdW50Tm90TGlua2VkRXJyb3JcIik7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShBY2NvdW50Tm90TGlua2VkRXJyb3IpO1xufShVbmtub3duRXJyb3IpO1xuXG5leHBvcnRzLkFjY291bnROb3RMaW5rZWRFcnJvciA9IEFjY291bnROb3RMaW5rZWRFcnJvcjtcblxudmFyIE1pc3NpbmdBUElSb3V0ZSA9IGZ1bmN0aW9uIChfVW5rbm93bkVycm9yMykge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShNaXNzaW5nQVBJUm91dGUsIF9Vbmtub3duRXJyb3IzKTtcblxuICB2YXIgX3N1cGVyNCA9IF9jcmVhdGVTdXBlcihNaXNzaW5nQVBJUm91dGUpO1xuXG4gIGZ1bmN0aW9uIE1pc3NpbmdBUElSb3V0ZSgpIHtcbiAgICB2YXIgX3RoaXM0O1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgTWlzc2luZ0FQSVJvdXRlKTtcblxuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cblxuICAgIF90aGlzNCA9IF9zdXBlcjQuY2FsbC5hcHBseShfc3VwZXI0LCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM0KSwgXCJuYW1lXCIsIFwiTWlzc2luZ0FQSVJvdXRlRXJyb3JcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNCksIFwiY29kZVwiLCBcIk1JU1NJTkdfTkVYVEFVVEhfQVBJX1JPVVRFX0VSUk9SXCIpO1xuICAgIHJldHVybiBfdGhpczQ7XG4gIH1cblxuICByZXR1cm4gKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoTWlzc2luZ0FQSVJvdXRlKTtcbn0oVW5rbm93bkVycm9yKTtcblxuZXhwb3J0cy5NaXNzaW5nQVBJUm91dGUgPSBNaXNzaW5nQVBJUm91dGU7XG5cbnZhciBNaXNzaW5nU2VjcmV0ID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3I0KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKE1pc3NpbmdTZWNyZXQsIF9Vbmtub3duRXJyb3I0KTtcblxuICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihNaXNzaW5nU2VjcmV0KTtcblxuICBmdW5jdGlvbiBNaXNzaW5nU2VjcmV0KCkge1xuICAgIHZhciBfdGhpczU7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBNaXNzaW5nU2VjcmV0KTtcblxuICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgIH1cblxuICAgIF90aGlzNSA9IF9zdXBlcjUuY2FsbC5hcHBseShfc3VwZXI1LCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM1KSwgXCJuYW1lXCIsIFwiTWlzc2luZ1NlY3JldEVycm9yXCIpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczUpLCBcImNvZGVcIiwgXCJOT19TRUNSRVRcIik7XG4gICAgcmV0dXJuIF90aGlzNTtcbiAgfVxuXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShNaXNzaW5nU2VjcmV0KTtcbn0oVW5rbm93bkVycm9yKTtcblxuZXhwb3J0cy5NaXNzaW5nU2VjcmV0ID0gTWlzc2luZ1NlY3JldDtcblxudmFyIE1pc3NpbmdBdXRob3JpemUgPSBmdW5jdGlvbiAoX1Vua25vd25FcnJvcjUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoTWlzc2luZ0F1dGhvcml6ZSwgX1Vua25vd25FcnJvcjUpO1xuXG4gIHZhciBfc3VwZXI2ID0gX2NyZWF0ZVN1cGVyKE1pc3NpbmdBdXRob3JpemUpO1xuXG4gIGZ1bmN0aW9uIE1pc3NpbmdBdXRob3JpemUoKSB7XG4gICAgdmFyIF90aGlzNjtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIE1pc3NpbmdBdXRob3JpemUpO1xuXG4gICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgfVxuXG4gICAgX3RoaXM2ID0gX3N1cGVyNi5jYWxsLmFwcGx5KF9zdXBlcjYsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczYpLCBcIm5hbWVcIiwgXCJNaXNzaW5nQXV0aG9yaXplRXJyb3JcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNiksIFwiY29kZVwiLCBcIkNBTExCQUNLX0NSRURFTlRJQUxTX0hBTkRMRVJfRVJST1JcIik7XG4gICAgcmV0dXJuIF90aGlzNjtcbiAgfVxuXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShNaXNzaW5nQXV0aG9yaXplKTtcbn0oVW5rbm93bkVycm9yKTtcblxuZXhwb3J0cy5NaXNzaW5nQXV0aG9yaXplID0gTWlzc2luZ0F1dGhvcml6ZTtcblxudmFyIE1pc3NpbmdBZGFwdGVyID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3I2KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKE1pc3NpbmdBZGFwdGVyLCBfVW5rbm93bkVycm9yNik7XG5cbiAgdmFyIF9zdXBlcjcgPSBfY3JlYXRlU3VwZXIoTWlzc2luZ0FkYXB0ZXIpO1xuXG4gIGZ1bmN0aW9uIE1pc3NpbmdBZGFwdGVyKCkge1xuICAgIHZhciBfdGhpczc7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBNaXNzaW5nQWRhcHRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICAgIGFyZ3NbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgICB9XG5cbiAgICBfdGhpczcgPSBfc3VwZXI3LmNhbGwuYXBwbHkoX3N1cGVyNywgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNyksIFwibmFtZVwiLCBcIk1pc3NpbmdBZGFwdGVyRXJyb3JcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNyksIFwiY29kZVwiLCBcIkVNQUlMX1JFUVVJUkVTX0FEQVBURVJfRVJST1JcIik7XG4gICAgcmV0dXJuIF90aGlzNztcbiAgfVxuXG4gIHJldHVybiAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShNaXNzaW5nQWRhcHRlcik7XG59KFVua25vd25FcnJvcik7XG5cbmV4cG9ydHMuTWlzc2luZ0FkYXB0ZXIgPSBNaXNzaW5nQWRhcHRlcjtcblxudmFyIFVuc3VwcG9ydGVkU3RyYXRlZ3kgPSBmdW5jdGlvbiAoX1Vua25vd25FcnJvcjcpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVW5zdXBwb3J0ZWRTdHJhdGVneSwgX1Vua25vd25FcnJvcjcpO1xuXG4gIHZhciBfc3VwZXI4ID0gX2NyZWF0ZVN1cGVyKFVuc3VwcG9ydGVkU3RyYXRlZ3kpO1xuXG4gIGZ1bmN0aW9uIFVuc3VwcG9ydGVkU3RyYXRlZ3koKSB7XG4gICAgdmFyIF90aGlzODtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFVuc3VwcG9ydGVkU3RyYXRlZ3kpO1xuXG4gICAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43KSwgX2tleTcgPSAwOyBfa2V5NyA8IF9sZW43OyBfa2V5NysrKSB7XG4gICAgICBhcmdzW19rZXk3XSA9IGFyZ3VtZW50c1tfa2V5N107XG4gICAgfVxuXG4gICAgX3RoaXM4ID0gX3N1cGVyOC5jYWxsLmFwcGx5KF9zdXBlcjgsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczgpLCBcIm5hbWVcIiwgXCJVbnN1cHBvcnRlZFN0cmF0ZWd5RXJyb3JcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzOCksIFwiY29kZVwiLCBcIkNBTExCQUNLX0NSRURFTlRJQUxTX0pXVF9FUlJPUlwiKTtcbiAgICByZXR1cm4gX3RoaXM4O1xuICB9XG5cbiAgcmV0dXJuICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFVuc3VwcG9ydGVkU3RyYXRlZ3kpO1xufShVbmtub3duRXJyb3IpO1xuXG5leHBvcnRzLlVuc3VwcG9ydGVkU3RyYXRlZ3kgPSBVbnN1cHBvcnRlZFN0cmF0ZWd5O1xuXG52YXIgSW52YWxpZENhbGxiYWNrVXJsID0gZnVuY3Rpb24gKF9Vbmtub3duRXJyb3I4KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEludmFsaWRDYWxsYmFja1VybCwgX1Vua25vd25FcnJvcjgpO1xuXG4gIHZhciBfc3VwZXI5ID0gX2NyZWF0ZVN1cGVyKEludmFsaWRDYWxsYmFja1VybCk7XG5cbiAgZnVuY3Rpb24gSW52YWxpZENhbGxiYWNrVXJsKCkge1xuICAgIHZhciBfdGhpczk7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBJbnZhbGlkQ2FsbGJhY2tVcmwpO1xuXG4gICAgZm9yICh2YXIgX2xlbjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW44KSwgX2tleTggPSAwOyBfa2V5OCA8IF9sZW44OyBfa2V5OCsrKSB7XG4gICAgICBhcmdzW19rZXk4XSA9IGFyZ3VtZW50c1tfa2V5OF07XG4gICAgfVxuXG4gICAgX3RoaXM5ID0gX3N1cGVyOS5jYWxsLmFwcGx5KF9zdXBlcjksIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczkpLCBcIm5hbWVcIiwgXCJJbnZhbGlkQ2FsbGJhY2tVcmxcIik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzOSksIFwiY29kZVwiLCBcIklOVkFMSURfQ0FMTEJBQ0tfVVJMX0VSUk9SXCIpO1xuICAgIHJldHVybiBfdGhpczk7XG4gIH1cblxuICByZXR1cm4gKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoSW52YWxpZENhbGxiYWNrVXJsKTtcbn0oVW5rbm93bkVycm9yKTtcblxuZXhwb3J0cy5JbnZhbGlkQ2FsbGJhY2tVcmwgPSBJbnZhbGlkQ2FsbGJhY2tVcmw7XG5cbmZ1bmN0aW9uIHVwcGVyU25ha2Uocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC8oW0EtWl0pL2csIFwiXyQxXCIpLnRvVXBwZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUocykge1xuICByZXR1cm4gXCJcIi5jb25jYXQoc1swXS50b1VwcGVyQ2FzZSgpKS5jb25jYXQocy5zbGljZSgxKSk7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c0Vycm9ySGFuZGxlcihtZXRob2RzLCBsb2dnZXIpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1ldGhvZHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBuYW1lKSB7XG4gICAgYWNjW25hbWVdID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICB2YXIgbWV0aG9kLFxuICAgICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgICBtZXRob2QgPSBtZXRob2RzW25hbWVdO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh2b2lkIDAsIF9hcmdzKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA3O1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIlwiLmNvbmNhdCh1cHBlclNuYWtlKG5hbWUpLCBcIl9FVkVOVF9FUlJPUlwiKSwgX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1swLCA3XV0pO1xuICAgIH0pKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGFkYXB0ZXJFcnJvckhhbmRsZXIoYWRhcHRlciwgbG9nZ2VyKSB7XG4gIGlmICghYWRhcHRlcikgcmV0dXJuO1xuICByZXR1cm4gT2JqZWN0LmtleXMoYWRhcHRlcikucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5hbWUpIHtcbiAgICBhY2NbbmFtZV0gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICB2YXIgX2xlbjksXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgICBfa2V5OSxcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgZSxcbiAgICAgICAgICBfYXJnczIgPSBhcmd1bWVudHM7XG5cbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAwO1xuXG4gICAgICAgICAgICAgIGZvciAoX2xlbjkgPSBfYXJnczIubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW45KSwgX2tleTkgPSAwOyBfa2V5OSA8IF9sZW45OyBfa2V5OSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5OV0gPSBfYXJnczJbX2tleTldO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiYWRhcHRlcl9cIi5jb25jYXQobmFtZSksIHtcbiAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBtZXRob2QgPSBhZGFwdGVyW25hbWVdO1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodm9pZCAwLCBhcmdzKTtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA5O1xuICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiYWRhcHRlcl9lcnJvcl9cIi5jb25jYXQobmFtZSksIF9jb250ZXh0Mi50MCk7XG4gICAgICAgICAgICAgIGUgPSBuZXcgVW5rbm93bkVycm9yKF9jb250ZXh0Mi50MCk7XG4gICAgICAgICAgICAgIGUubmFtZSA9IFwiXCIuY29uY2F0KGNhcGl0YWxpemUobmFtZSksIFwiRXJyb3JcIik7XG4gICAgICAgICAgICAgIHRocm93IGU7XG5cbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbMCwgOV1dKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufSJdLCJuYW1lcyI6WyJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVW5zdXBwb3J0ZWRTdHJhdGVneSIsIlVua25vd25FcnJvciIsIk9BdXRoQ2FsbGJhY2tFcnJvciIsIk1pc3NpbmdTZWNyZXQiLCJNaXNzaW5nQXV0aG9yaXplIiwiTWlzc2luZ0FkYXB0ZXIiLCJNaXNzaW5nQVBJUm91dGUiLCJJbnZhbGlkQ2FsbGJhY2tVcmwiLCJBY2NvdW50Tm90TGlua2VkRXJyb3IiLCJhZGFwdGVyRXJyb3JIYW5kbGVyIiwiY2FwaXRhbGl6ZSIsImV2ZW50c0Vycm9ySGFuZGxlciIsInVwcGVyU25ha2UiLCJfcmVnZW5lcmF0b3IiLCJfYXN5bmNUb0dlbmVyYXRvcjIiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkMiIsIl9kZWZpbmVQcm9wZXJ0eTIiLCJfY2xhc3NDYWxsQ2hlY2syIiwiX2NyZWF0ZUNsYXNzMiIsIl9pbmhlcml0czIiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIiLCJfZ2V0UHJvdG90eXBlT2YyIiwiX3dyYXBOYXRpdmVTdXBlcjIiLCJfY3JlYXRlU3VwZXIiLCJEZXJpdmVkIiwiaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY3JlYXRlU3VwZXJJbnRlcm5hbCIsIlN1cGVyIiwiZGVmYXVsdCIsInJlc3VsdCIsIk5ld1RhcmdldCIsImNvbnN0cnVjdG9yIiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsImFyZ3VtZW50cyIsImFwcGx5Iiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInByb3RvdHlwZSIsInZhbHVlT2YiLCJjYWxsIiwiZSIsIl9FcnJvciIsIl9zdXBlciIsImVycm9yIiwiX21lc3NhZ2UiLCJfdGhpcyIsIm1lc3NhZ2UiLCJuYW1lIiwiY29kZSIsIkVycm9yIiwic3RhY2siLCJrZXkiLCJ0b0pTT04iLCJfVW5rbm93bkVycm9yIiwiX3N1cGVyMiIsIl90aGlzMiIsIl9sZW4iLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiY29uY2F0IiwiX1Vua25vd25FcnJvcjIiLCJfc3VwZXIzIiwiX3RoaXMzIiwiX2xlbjIiLCJfa2V5MiIsIl9Vbmtub3duRXJyb3IzIiwiX3N1cGVyNCIsIl90aGlzNCIsIl9sZW4zIiwiX2tleTMiLCJfVW5rbm93bkVycm9yNCIsIl9zdXBlcjUiLCJfdGhpczUiLCJfbGVuNCIsIl9rZXk0IiwiX1Vua25vd25FcnJvcjUiLCJfc3VwZXI2IiwiX3RoaXM2IiwiX2xlbjUiLCJfa2V5NSIsIl9Vbmtub3duRXJyb3I2IiwiX3N1cGVyNyIsIl90aGlzNyIsIl9sZW42IiwiX2tleTYiLCJfVW5rbm93bkVycm9yNyIsIl9zdXBlcjgiLCJfdGhpczgiLCJfbGVuNyIsIl9rZXk3IiwiX1Vua25vd25FcnJvcjgiLCJfc3VwZXI5IiwiX3RoaXM5IiwiX2xlbjgiLCJfa2V5OCIsInMiLCJyZXBsYWNlIiwidG9VcHBlckNhc2UiLCJzbGljZSIsIm1ldGhvZHMiLCJsb2dnZXIiLCJrZXlzIiwicmVkdWNlIiwiYWNjIiwibWFyayIsIl9jYWxsZWUiLCJtZXRob2QiLCJfYXJncyIsIndyYXAiLCJfY2FsbGVlJCIsIl9jb250ZXh0IiwicHJldiIsIm5leHQiLCJhYnJ1cHQiLCJzZW50IiwidDAiLCJzdG9wIiwiYWRhcHRlciIsIl9jYWxsZWUyIiwiX2xlbjkiLCJfa2V5OSIsIl9hcmdzMiIsIl9jYWxsZWUyJCIsIl9jb250ZXh0MiIsImRlYnVnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next-auth/core/errors.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/react/index.js":
/*!***********************************************!*\
  !*** ./node_modules/next-auth/react/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar _exportNames = {\n  useSession: true,\n  getSession: true,\n  getCsrfToken: true,\n  getProviders: true,\n  signIn: true,\n  signOut: true,\n  SessionProvider: true\n};\nexports.SessionProvider = SessionProvider;\nexports.getCsrfToken = getCsrfToken;\nexports.getProviders = getProviders;\nexports.getSession = getSession;\nexports.signIn = signIn;\nexports.signOut = signOut;\nexports.useSession = useSession;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _logger2 = _interopRequireWildcard(__webpack_require__(/*! ../utils/logger */ \"./node_modules/next-auth/utils/logger.js\"));\n\nvar _parseUrl = _interopRequireDefault(__webpack_require__(/*! ../utils/parse-url */ \"./node_modules/next-auth/utils/parse-url.js\"));\n\nvar _utils = __webpack_require__(/*! ../client/_utils */ \"./node_modules/next-auth/client/_utils.js\");\n\nvar _jsxRuntime = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/next-auth/react/types.js\");\n\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _types[key];\n    }\n  });\n});\n\nvar _process$env$NEXTAUTH, _ref, _process$env$NEXTAUTH2, _process$env$NEXTAUTH3;\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nvar __NEXTAUTH = {\n  baseUrl: (0, _parseUrl.default)((_process$env$NEXTAUTH = process.env.NEXTAUTH_URL) !== null && _process$env$NEXTAUTH !== void 0 ? _process$env$NEXTAUTH : process.env.VERCEL_URL).origin,\n  basePath: (0, _parseUrl.default)(process.env.NEXTAUTH_URL).path,\n  baseUrlServer: (0, _parseUrl.default)((_ref = (_process$env$NEXTAUTH2 = process.env.NEXTAUTH_URL_INTERNAL) !== null && _process$env$NEXTAUTH2 !== void 0 ? _process$env$NEXTAUTH2 : process.env.NEXTAUTH_URL) !== null && _ref !== void 0 ? _ref : process.env.VERCEL_URL).origin,\n  basePathServer: (0, _parseUrl.default)((_process$env$NEXTAUTH3 = process.env.NEXTAUTH_URL_INTERNAL) !== null && _process$env$NEXTAUTH3 !== void 0 ? _process$env$NEXTAUTH3 : process.env.NEXTAUTH_URL).path,\n  _lastSync: 0,\n  _session: undefined,\n  _getSession: function _getSession() {}\n};\nvar broadcast = (0, _utils.BroadcastChannel)();\nvar logger = (0, _logger2.proxyLogger)(_logger2.default, __NEXTAUTH.basePath);\nvar SessionContext = React.createContext(undefined);\n\nfunction useSession(options) {\n  var value = React.useContext(SessionContext);\n\n  if (!value && \"development\" !== \"production\") {\n    throw new Error(\"[next-auth]: `useSession` must be wrapped in a <SessionProvider />\");\n  }\n\n  var _ref2 = options !== null && options !== void 0 ? options : {},\n      required = _ref2.required,\n      onUnauthenticated = _ref2.onUnauthenticated;\n\n  var requiredAndNotLoading = required && value.status === \"unauthenticated\";\n  React.useEffect(function () {\n    if (requiredAndNotLoading) {\n      var url = \"/api/auth/signin?\".concat(new URLSearchParams({\n        error: \"SessionRequired\",\n        callbackUrl: window.location.href\n      }));\n      if (onUnauthenticated) onUnauthenticated();else window.location.href = url;\n    }\n  }, [requiredAndNotLoading, onUnauthenticated]);\n\n  if (requiredAndNotLoading) {\n    return {\n      data: value.data,\n      status: \"loading\"\n    };\n  }\n\n  return value;\n}\n\nfunction getSession(_x) {\n  return _getSession2.apply(this, arguments);\n}\n\nfunction _getSession2() {\n  _getSession2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(params) {\n    var _params$broadcast;\n\n    var session;\n    return _regenerator.default.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return (0, _utils.fetchData)(\"session\", __NEXTAUTH, logger, params);\n\n          case 2:\n            session = _context2.sent;\n\n            if ((_params$broadcast = params === null || params === void 0 ? void 0 : params.broadcast) !== null && _params$broadcast !== void 0 ? _params$broadcast : true) {\n              broadcast.post({\n                event: \"session\",\n                data: {\n                  trigger: \"getSession\"\n                }\n              });\n            }\n\n            return _context2.abrupt(\"return\", session);\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getSession2.apply(this, arguments);\n}\n\nfunction getCsrfToken(_x2) {\n  return _getCsrfToken.apply(this, arguments);\n}\n\nfunction _getCsrfToken() {\n  _getCsrfToken = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(params) {\n    var response;\n    return _regenerator.default.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return (0, _utils.fetchData)(\"csrf\", __NEXTAUTH, logger, params);\n\n          case 2:\n            response = _context3.sent;\n            return _context3.abrupt(\"return\", response === null || response === void 0 ? void 0 : response.csrfToken);\n\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getCsrfToken.apply(this, arguments);\n}\n\nfunction getProviders() {\n  return _getProviders.apply(this, arguments);\n}\n\nfunction _getProviders() {\n  _getProviders = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4() {\n    return _regenerator.default.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return (0, _utils.fetchData)(\"providers\", __NEXTAUTH, logger);\n\n          case 2:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 3:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _getProviders.apply(this, arguments);\n}\n\nfunction signIn(_x3, _x4, _x5) {\n  return _signIn.apply(this, arguments);\n}\n\nfunction _signIn() {\n  _signIn = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5(provider, options, authorizationParams) {\n    var _ref5, _ref5$callbackUrl, callbackUrl, _ref5$redirect, redirect, baseUrl, providers, isCredentials, isEmail, isSupportingReturn, signInUrl, _signInUrl, res, data, _data$url, url, error;\n\n    return _regenerator.default.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _ref5 = options !== null && options !== void 0 ? options : {}, _ref5$callbackUrl = _ref5.callbackUrl, callbackUrl = _ref5$callbackUrl === void 0 ? window.location.href : _ref5$callbackUrl, _ref5$redirect = _ref5.redirect, redirect = _ref5$redirect === void 0 ? true : _ref5$redirect;\n            baseUrl = (0, _utils.apiBaseUrl)(__NEXTAUTH);\n            _context5.next = 4;\n            return getProviders();\n\n          case 4:\n            providers = _context5.sent;\n\n            if (providers) {\n              _context5.next = 8;\n              break;\n            }\n\n            window.location.href = \"\".concat(baseUrl, \"/error\");\n            return _context5.abrupt(\"return\");\n\n          case 8:\n            if (!(!provider || !(provider in providers))) {\n              _context5.next = 11;\n              break;\n            }\n\n            window.location.href = \"\".concat(baseUrl, \"/signin?\").concat(new URLSearchParams({\n              callbackUrl: callbackUrl\n            }));\n            return _context5.abrupt(\"return\");\n\n          case 11:\n            isCredentials = providers[provider].type === \"credentials\";\n            isEmail = providers[provider].type === \"email\";\n            isSupportingReturn = isCredentials || isEmail;\n            signInUrl = \"\".concat(baseUrl, \"/\").concat(isCredentials ? \"callback\" : \"signin\", \"/\").concat(provider);\n            _signInUrl = \"\".concat(signInUrl, \"?\").concat(new URLSearchParams(authorizationParams));\n            _context5.t0 = fetch;\n            _context5.t1 = _signInUrl;\n            _context5.t2 = {\n              \"Content-Type\": \"application/x-www-form-urlencoded\"\n            };\n            _context5.t3 = URLSearchParams;\n            _context5.t4 = _objectSpread;\n            _context5.t5 = _objectSpread({}, options);\n            _context5.t6 = {};\n            _context5.next = 25;\n            return getCsrfToken();\n\n          case 25:\n            _context5.t7 = _context5.sent;\n            _context5.t8 = callbackUrl;\n            _context5.t9 = {\n              csrfToken: _context5.t7,\n              callbackUrl: _context5.t8,\n              json: true\n            };\n            _context5.t10 = (0, _context5.t4)(_context5.t5, _context5.t6, _context5.t9);\n            _context5.t11 = new _context5.t3(_context5.t10);\n            _context5.t12 = {\n              method: \"post\",\n              headers: _context5.t2,\n              body: _context5.t11\n            };\n            _context5.next = 33;\n            return (0, _context5.t0)(_context5.t1, _context5.t12);\n\n          case 33:\n            res = _context5.sent;\n            _context5.next = 36;\n            return res.json();\n\n          case 36:\n            data = _context5.sent;\n\n            if (!(redirect || !isSupportingReturn)) {\n              _context5.next = 42;\n              break;\n            }\n\n            url = (_data$url = data.url) !== null && _data$url !== void 0 ? _data$url : callbackUrl;\n            window.location.href = url;\n            if (url.includes(\"#\")) window.location.reload();\n            return _context5.abrupt(\"return\");\n\n          case 42:\n            error = new URL(data.url).searchParams.get(\"error\");\n\n            if (!res.ok) {\n              _context5.next = 46;\n              break;\n            }\n\n            _context5.next = 46;\n            return __NEXTAUTH._getSession({\n              event: \"storage\"\n            });\n\n          case 46:\n            return _context5.abrupt(\"return\", {\n              error: error,\n              status: res.status,\n              ok: res.ok,\n              url: error ? null : data.url\n            });\n\n          case 47:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _signIn.apply(this, arguments);\n}\n\nfunction signOut(_x6) {\n  return _signOut.apply(this, arguments);\n}\n\nfunction _signOut() {\n  _signOut = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee6(options) {\n    var _options$redirect;\n\n    var _ref6, _ref6$callbackUrl, callbackUrl, baseUrl, fetchOptions, res, data, _data$url2, url;\n\n    return _regenerator.default.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _ref6 = options !== null && options !== void 0 ? options : {}, _ref6$callbackUrl = _ref6.callbackUrl, callbackUrl = _ref6$callbackUrl === void 0 ? window.location.href : _ref6$callbackUrl;\n            baseUrl = (0, _utils.apiBaseUrl)(__NEXTAUTH);\n            _context6.t0 = {\n              \"Content-Type\": \"application/x-www-form-urlencoded\"\n            };\n            _context6.t1 = URLSearchParams;\n            _context6.next = 6;\n            return getCsrfToken();\n\n          case 6:\n            _context6.t2 = _context6.sent;\n            _context6.t3 = callbackUrl;\n            _context6.t4 = {\n              csrfToken: _context6.t2,\n              callbackUrl: _context6.t3,\n              json: true\n            };\n            _context6.t5 = new _context6.t1(_context6.t4);\n            fetchOptions = {\n              method: \"post\",\n              headers: _context6.t0,\n              body: _context6.t5\n            };\n            _context6.next = 13;\n            return fetch(\"\".concat(baseUrl, \"/signout\"), fetchOptions);\n\n          case 13:\n            res = _context6.sent;\n            _context6.next = 16;\n            return res.json();\n\n          case 16:\n            data = _context6.sent;\n            broadcast.post({\n              event: \"session\",\n              data: {\n                trigger: \"signout\"\n              }\n            });\n\n            if (!((_options$redirect = options === null || options === void 0 ? void 0 : options.redirect) !== null && _options$redirect !== void 0 ? _options$redirect : true)) {\n              _context6.next = 23;\n              break;\n            }\n\n            url = (_data$url2 = data.url) !== null && _data$url2 !== void 0 ? _data$url2 : callbackUrl;\n            window.location.href = url;\n            if (url.includes(\"#\")) window.location.reload();\n            return _context6.abrupt(\"return\");\n\n          case 23:\n            _context6.next = 25;\n            return __NEXTAUTH._getSession({\n              event: \"storage\"\n            });\n\n          case 25:\n            return _context6.abrupt(\"return\", data);\n\n          case 26:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _signOut.apply(this, arguments);\n}\n\nfunction SessionProvider(props) {\n  var children = props.children,\n      basePath = props.basePath;\n  if (basePath) __NEXTAUTH.basePath = basePath;\n  var hasInitialSession = props.session !== undefined;\n  __NEXTAUTH._lastSync = hasInitialSession ? (0, _utils.now)() : 0;\n\n  var _React$useState = React.useState(function () {\n    if (hasInitialSession) __NEXTAUTH._session = props.session;\n    return props.session;\n  }),\n      _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),\n      session = _React$useState2[0],\n      setSession = _React$useState2[1];\n\n  var _React$useState3 = React.useState(!hasInitialSession),\n      _React$useState4 = (0, _slicedToArray2.default)(_React$useState3, 2),\n      loading = _React$useState4[0],\n      setLoading = _React$useState4[1];\n\n  React.useEffect(function () {\n    __NEXTAUTH._getSession = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {\n      var _ref4,\n          event,\n          storageEvent,\n          _args = arguments;\n\n      return _regenerator.default.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _ref4 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, event = _ref4.event;\n              _context.prev = 1;\n              storageEvent = event === \"storage\";\n\n              if (!(storageEvent || __NEXTAUTH._session === undefined)) {\n                _context.next = 10;\n                break;\n              }\n\n              __NEXTAUTH._lastSync = (0, _utils.now)();\n              _context.next = 7;\n              return getSession({\n                broadcast: !storageEvent\n              });\n\n            case 7:\n              __NEXTAUTH._session = _context.sent;\n              setSession(__NEXTAUTH._session);\n              return _context.abrupt(\"return\");\n\n            case 10:\n              if (!(!event || __NEXTAUTH._session === null || (0, _utils.now)() < __NEXTAUTH._lastSync)) {\n                _context.next = 12;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 12:\n              __NEXTAUTH._lastSync = (0, _utils.now)();\n              _context.next = 15;\n              return getSession();\n\n            case 15:\n              __NEXTAUTH._session = _context.sent;\n              setSession(__NEXTAUTH._session);\n              _context.next = 22;\n              break;\n\n            case 19:\n              _context.prev = 19;\n              _context.t0 = _context[\"catch\"](1);\n              logger.error(\"CLIENT_SESSION_ERROR\", _context.t0);\n\n            case 22:\n              _context.prev = 22;\n              setLoading(false);\n              return _context.finish(22);\n\n            case 25:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 19, 22, 25]]);\n    }));\n\n    __NEXTAUTH._getSession();\n\n    return function () {\n      __NEXTAUTH._lastSync = 0;\n      __NEXTAUTH._session = undefined;\n\n      __NEXTAUTH._getSession = function () {};\n    };\n  }, []);\n  React.useEffect(function () {\n    var unsubscribe = broadcast.receive(function () {\n      return __NEXTAUTH._getSession({\n        event: \"storage\"\n      });\n    });\n    return function () {\n      return unsubscribe();\n    };\n  }, []);\n  React.useEffect(function () {\n    var _props$refetchOnWindo = props.refetchOnWindowFocus,\n        refetchOnWindowFocus = _props$refetchOnWindo === void 0 ? true : _props$refetchOnWindo;\n\n    var visibilityHandler = function visibilityHandler() {\n      if (refetchOnWindowFocus && document.visibilityState === \"visible\") __NEXTAUTH._getSession({\n        event: \"visibilitychange\"\n      });\n    };\n\n    document.addEventListener(\"visibilitychange\", visibilityHandler, false);\n    return function () {\n      return document.removeEventListener(\"visibilitychange\", visibilityHandler, false);\n    };\n  }, [props.refetchOnWindowFocus]);\n  React.useEffect(function () {\n    var refetchInterval = props.refetchInterval;\n\n    if (refetchInterval) {\n      var refetchIntervalTimer = setInterval(function () {\n        if (__NEXTAUTH._session) {\n          __NEXTAUTH._getSession({\n            event: \"poll\"\n          });\n        }\n      }, refetchInterval * 1000);\n      return function () {\n        return clearInterval(refetchIntervalTimer);\n      };\n    }\n  }, [props.refetchInterval]);\n  var value = React.useMemo(function () {\n    return {\n      data: session,\n      status: loading ? \"loading\" : session ? \"authenticated\" : \"unauthenticated\"\n    };\n  }, [session, loading]);\n  return (0, _jsxRuntime.jsx)(SessionContext.Provider, {\n    value: value,\n    children: children\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTs7QUFFYixJQUFJQSxzQkFBc0IsR0FBR0MsbUJBQU8sQ0FBQyxvSEFBRCxDQUFwQzs7QUFFQSxJQUFJQyxPQUFPLEdBQUdELG1CQUFPLENBQUMsc0ZBQUQsQ0FBckI7O0FBRUFFLDhDQUE2QztFQUMzQ0csS0FBSyxFQUFFO0FBRG9DLENBQTdDO0FBR0EsSUFBSUMsWUFBWSxHQUFHO0VBQ2pCQyxVQUFVLEVBQUUsSUFESztFQUVqQkMsVUFBVSxFQUFFLElBRks7RUFHakJDLFlBQVksRUFBRSxJQUhHO0VBSWpCQyxZQUFZLEVBQUUsSUFKRztFQUtqQkMsTUFBTSxFQUFFLElBTFM7RUFNakJDLE9BQU8sRUFBRSxJQU5RO0VBT2pCQyxlQUFlLEVBQUU7QUFQQSxDQUFuQjtBQVNBVCx1QkFBQSxHQUEwQlMsZUFBMUI7QUFDQVQsb0JBQUEsR0FBdUJLLFlBQXZCO0FBQ0FMLG9CQUFBLEdBQXVCTSxZQUF2QjtBQUNBTixrQkFBQSxHQUFxQkksVUFBckI7QUFDQUosY0FBQSxHQUFpQk8sTUFBakI7QUFDQVAsZUFBQSxHQUFrQlEsT0FBbEI7QUFDQVIsa0JBQUEsR0FBcUJHLFVBQXJCOztBQUVBLElBQUlPLFlBQVksR0FBR2Ysc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsc0ZBQUQsQ0FBUixDQUF6Qzs7QUFFQSxJQUFJZSxnQkFBZ0IsR0FBR2hCLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLHNHQUFELENBQVIsQ0FBN0M7O0FBRUEsSUFBSWdCLGVBQWUsR0FBR2pCLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLG9HQUFELENBQVIsQ0FBNUM7O0FBRUEsSUFBSWlCLGtCQUFrQixHQUFHbEIsc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsMEdBQUQsQ0FBUixDQUEvQzs7QUFFQSxJQUFJa0IsS0FBSyxHQUFHQyx1QkFBdUIsQ0FBQ25CLG1CQUFPLENBQUMsNENBQUQsQ0FBUixD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MUIsSUFBSTRILGVBQWUsR0FBRzVCLEtBQUssQ0FBQzRCLGVBQTVCOztJQUVBLElBQUlBLGVBQUosRUFBcUI7TUFDbkIsSUFBSUMsb0JBQW9CLEdBQUdDLFdBQVcsQ0FBQyxZQUFZO1FBQ2pELElBQUk3SixVQUFVLENBQUNhLFFBQWYsRUFBeUI7VUFDdkJiLFVBQVUsQ0FBQ2UsV0FBWCxDQUF1QjtZQUNyQnlDLEtBQUssRUFBRTtVQURjLENBQXZCO1FBR0Q7TUFDRixDQU5xQyxFQU1uQ21HLGVBQWUsR0FBRyxJQU5pQixDQUF0QztNQU9BLE9BQU8sWUFBWTtRQUNqQixPQUFPRyxhQUFhLENBQUNGLG9CQUFELENBQXBCO01BQ0QsQ0FGRDtJQUdEO0VBQ0YsQ0FmRCxFQWVHLENBQUM3QixLQUFLLENBQUM0QixlQUFQLENBZkg7RUFnQkEsSUFBSTNOLEtBQUssR0FBR2EsS0FBSyxDQUFDa04sT0FBTixDQUFjLFlBQVk7SUFDcEMsT0FBTztNQUNMdkgsSUFBSSxFQUFFTyxPQUREO01BRUxqQixNQUFNLEVBQUUyRyxPQUFPLEdBQUcsU0FBSCxHQUFlMUYsT0FBTyxHQUFHLGVBQUgsR0FBcUI7SUFGckQsQ0FBUDtFQUlELENBTFcsRUFLVCxDQUFDQSxPQUFELEVBQVUwRixPQUFWLENBTFMsQ0FBWjtFQU1BLE9BQU8sQ0FBQyxHQUFHdkwsV0FBVyxDQUFDOE0sR0FBaEIsRUFBcUI1SSxjQUFjLENBQUM2SSxRQUFwQyxFQUE4QztJQUNuRGpPLEtBQUssRUFBRUEsS0FENEM7SUFFbkRnTSxRQUFRLEVBQUVBO0VBRnlDLENBQTlDLENBQVA7QUFJRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0L2luZGV4LmpzP2MxOWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBfZXhwb3J0TmFtZXMgPSB7XG4gIHVzZVNlc3Npb246IHRydWUsXG4gIGdldFNlc3Npb246IHRydWUsXG4gIGdldENzcmZUb2tlbjogdHJ1ZSxcbiAgZ2V0UHJvdmlkZXJzOiB0cnVlLFxuICBzaWduSW46IHRydWUsXG4gIHNpZ25PdXQ6IHRydWUsXG4gIFNlc3Npb25Qcm92aWRlcjogdHJ1ZVxufTtcbmV4cG9ydHMuU2Vzc2lvblByb3ZpZGVyID0gU2Vzc2lvblByb3ZpZGVyO1xuZXhwb3J0cy5nZXRDc3JmVG9rZW4gPSBnZXRDc3JmVG9rZW47XG5leHBvcnRzLmdldFByb3ZpZGVycyA9IGdldFByb3ZpZGVycztcbmV4cG9ydHMuZ2V0U2Vzc2lvbiA9IGdldFNlc3Npb247XG5leHBvcnRzLnNpZ25JbiA9IHNpZ25JbjtcbmV4cG9ydHMuc2lnbk91dCA9IHNpZ25PdXQ7XG5leHBvcnRzLnVzZVNlc3Npb24gPSB1c2VTZXNzaW9uO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5XCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfbG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuLi91dGlscy9sb2dnZXJcIikpO1xuXG52YXIgX3BhcnNlVXJsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvcGFyc2UtdXJsXCIpKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi9jbGllbnQvX3V0aWxzXCIpO1xuXG52YXIgX2pzeFJ1bnRpbWUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxuT2JqZWN0LmtleXMoX3R5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfdHlwZXNba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfdHlwZXNba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBfcHJvY2VzcyRlbnYkTkVYVEFVVEgsIF9yZWYsIF9wcm9jZXNzJGVudiRORVhUQVVUSDIsIF9wcm9jZXNzJGVudiRORVhUQVVUSDM7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgX19ORVhUQVVUSCA9IHtcbiAgYmFzZVVybDogKDAsIF9wYXJzZVVybC5kZWZhdWx0KSgoX3Byb2Nlc3MkZW52JE5FWFRBVVRIID0gcHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMKSAhPT0gbnVsbCAmJiBfcHJvY2VzcyRlbnYkTkVYVEFVVEggIT09IHZvaWQgMCA/IF9wcm9jZXNzJGVudiRORVhUQVVUSCA6IHByb2Nlc3MuZW52LlZFUkNFTF9VUkwpLm9yaWdpbixcbiAgYmFzZVBhdGg6ICgwLCBfcGFyc2VVcmwuZGVmYXVsdCkocHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMKS5wYXRoLFxuICBiYXNlVXJsU2VydmVyOiAoMCwgX3BhcnNlVXJsLmRlZmF1bHQpKChfcmVmID0gKF9wcm9jZXNzJGVudiRORVhUQVVUSDIgPSBwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkxfSU5URVJOQUwpICE9PSBudWxsICYmIF9wcm9jZXNzJGVudiRORVhUQVVUSDIgIT09IHZvaWQgMCA/IF9wcm9jZXNzJGVudiRORVhUQVVUSDIgOiBwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkwpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiBwcm9jZXNzLmVudi5WRVJDRUxfVVJMKS5vcmlnaW4sXG4gIGJhc2VQYXRoU2VydmVyOiAoMCwgX3BhcnNlVXJsLmRlZmF1bHQpKChfcHJvY2VzcyRlbnYkTkVYVEFVVEgzID0gcHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMX0lOVEVSTkFMKSAhPT0gbnVsbCAmJiBfcHJvY2VzcyRlbnYkTkVYVEFVVEgzICE9PSB2b2lkIDAgPyBfcHJvY2VzcyRlbnYkTkVYVEFVVEgzIDogcHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMKS5wYXRoLFxuICBfbGFzdFN5bmM6IDAsXG4gIF9zZXNzaW9uOiB1bmRlZmluZWQsXG4gIF9nZXRTZXNzaW9uOiBmdW5jdGlvbiBfZ2V0U2Vzc2lvbigpIHt9XG59O1xudmFyIGJyb2FkY2FzdCA9ICgwLCBfdXRpbHMuQnJvYWRjYXN0Q2hhbm5lbCkoKTtcbnZhciBsb2dnZXIgPSAoMCwgX2xvZ2dlcjIucHJveHlMb2dnZXIpKF9sb2dnZXIyLmRlZmF1bHQsIF9fTkVYVEFVVEguYmFzZVBhdGgpO1xudmFyIFNlc3Npb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuXG5mdW5jdGlvbiB1c2VTZXNzaW9uKG9wdGlvbnMpIHtcbiAgdmFyIHZhbHVlID0gUmVhY3QudXNlQ29udGV4dChTZXNzaW9uQ29udGV4dCk7XG5cbiAgaWYgKCF2YWx1ZSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbmV4dC1hdXRoXTogYHVzZVNlc3Npb25gIG11c3QgYmUgd3JhcHBlZCBpbiBhIDxTZXNzaW9uUHJvdmlkZXIgLz5cIik7XG4gIH1cblxuICB2YXIgX3JlZjIgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSxcbiAgICAgIHJlcXVpcmVkID0gX3JlZjIucmVxdWlyZWQsXG4gICAgICBvblVuYXV0aGVudGljYXRlZCA9IF9yZWYyLm9uVW5hdXRoZW50aWNhdGVkO1xuXG4gIHZhciByZXF1aXJlZEFuZE5vdExvYWRpbmcgPSByZXF1aXJlZCAmJiB2YWx1ZS5zdGF0dXMgPT09IFwidW5hdXRoZW50aWNhdGVkXCI7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJlcXVpcmVkQW5kTm90TG9hZGluZykge1xuICAgICAgdmFyIHVybCA9IFwiL2FwaS9hdXRoL3NpZ25pbj9cIi5jb25jYXQobmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGVycm9yOiBcIlNlc3Npb25SZXF1aXJlZFwiLFxuICAgICAgICBjYWxsYmFja1VybDogd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICAgIH0pKTtcbiAgICAgIGlmIChvblVuYXV0aGVudGljYXRlZCkgb25VbmF1dGhlbnRpY2F0ZWQoKTtlbHNlIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgIH1cbiAgfSwgW3JlcXVpcmVkQW5kTm90TG9hZGluZywgb25VbmF1dGhlbnRpY2F0ZWRdKTtcblxuICBpZiAocmVxdWlyZWRBbmROb3RMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHZhbHVlLmRhdGEsXG4gICAgICBzdGF0dXM6IFwibG9hZGluZ1wiXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Vzc2lvbihfeCkge1xuICByZXR1cm4gX2dldFNlc3Npb24yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRTZXNzaW9uMigpIHtcbiAgX2dldFNlc3Npb24yID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHBhcmFtcykge1xuICAgIHZhciBfcGFyYW1zJGJyb2FkY2FzdDtcblxuICAgIHZhciBzZXNzaW9uO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmZldGNoRGF0YSkoXCJzZXNzaW9uXCIsIF9fTkVYVEFVVEgsIGxvZ2dlciwgcGFyYW1zKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHNlc3Npb24gPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgaWYgKChfcGFyYW1zJGJyb2FkY2FzdCA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5icm9hZGNhc3QpICE9PSBudWxsICYmIF9wYXJhbXMkYnJvYWRjYXN0ICE9PSB2b2lkIDAgPyBfcGFyYW1zJGJyb2FkY2FzdCA6IHRydWUpIHtcbiAgICAgICAgICAgICAgYnJvYWRjYXN0LnBvc3Qoe1xuICAgICAgICAgICAgICAgIGV2ZW50OiBcInNlc3Npb25cIixcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICB0cmlnZ2VyOiBcImdldFNlc3Npb25cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHNlc3Npb24pO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0U2Vzc2lvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q3NyZlRva2VuKF94Mikge1xuICByZXR1cm4gX2dldENzcmZUb2tlbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0Q3NyZlRva2VuKCkge1xuICBfZ2V0Q3NyZlRva2VuID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKHBhcmFtcykge1xuICAgIHZhciByZXNwb25zZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF91dGlscy5mZXRjaERhdGEpKFwiY3NyZlwiLCBfX05FWFRBVVRILCBsb2dnZXIsIHBhcmFtcyk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmNzcmZUb2tlbik7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRDc3JmVG9rZW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvdmlkZXJzKCkge1xuICByZXR1cm4gX2dldFByb3ZpZGVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdmlkZXJzKCkge1xuICBfZ2V0UHJvdmlkZXJzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KCkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmZldGNoRGF0YSkoXCJwcm92aWRlcnNcIiwgX19ORVhUQVVUSCwgbG9nZ2VyKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0KTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFByb3ZpZGVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBzaWduSW4oX3gzLCBfeDQsIF94NSkge1xuICByZXR1cm4gX3NpZ25Jbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfc2lnbkluKCkge1xuICBfc2lnbkluID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KHByb3ZpZGVyLCBvcHRpb25zLCBhdXRob3JpemF0aW9uUGFyYW1zKSB7XG4gICAgdmFyIF9yZWY1LCBfcmVmNSRjYWxsYmFja1VybCwgY2FsbGJhY2tVcmwsIF9yZWY1JHJlZGlyZWN0LCByZWRpcmVjdCwgYmFzZVVybCwgcHJvdmlkZXJzLCBpc0NyZWRlbnRpYWxzLCBpc0VtYWlsLCBpc1N1cHBvcnRpbmdSZXR1cm4sIHNpZ25JblVybCwgX3NpZ25JblVybCwgcmVzLCBkYXRhLCBfZGF0YSR1cmwsIHVybCwgZXJyb3I7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfcmVmNSA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCBfcmVmNSRjYWxsYmFja1VybCA9IF9yZWY1LmNhbGxiYWNrVXJsLCBjYWxsYmFja1VybCA9IF9yZWY1JGNhbGxiYWNrVXJsID09PSB2b2lkIDAgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6IF9yZWY1JGNhbGxiYWNrVXJsLCBfcmVmNSRyZWRpcmVjdCA9IF9yZWY1LnJlZGlyZWN0LCByZWRpcmVjdCA9IF9yZWY1JHJlZGlyZWN0ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjUkcmVkaXJlY3Q7XG4gICAgICAgICAgICBiYXNlVXJsID0gKDAsIF91dGlscy5hcGlCYXNlVXJsKShfX05FWFRBVVRIKTtcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiBnZXRQcm92aWRlcnMoKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHByb3ZpZGVycyA9IF9jb250ZXh0NS5zZW50O1xuXG4gICAgICAgICAgICBpZiAocHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gXCJcIi5jb25jYXQoYmFzZVVybCwgXCIvZXJyb3JcIik7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGlmICghKCFwcm92aWRlciB8fCAhKHByb3ZpZGVyIGluIHByb3ZpZGVycykpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IFwiXCIuY29uY2F0KGJhc2VVcmwsIFwiL3NpZ25pbj9cIikuY29uY2F0KG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgICBjYWxsYmFja1VybDogY2FsbGJhY2tVcmxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGlzQ3JlZGVudGlhbHMgPSBwcm92aWRlcnNbcHJvdmlkZXJdLnR5cGUgPT09IFwiY3JlZGVudGlhbHNcIjtcbiAgICAgICAgICAgIGlzRW1haWwgPSBwcm92aWRlcnNbcHJvdmlkZXJdLnR5cGUgPT09IFwiZW1haWxcIjtcbiAgICAgICAgICAgIGlzU3VwcG9ydGluZ1JldHVybiA9IGlzQ3JlZGVudGlhbHMgfHwgaXNFbWFpbDtcbiAgICAgICAgICAgIHNpZ25JblVybCA9IFwiXCIuY29uY2F0KGJhc2VVcmwsIFwiL1wiKS5jb25jYXQoaXNDcmVkZW50aWFscyA/IFwiY2FsbGJhY2tcIiA6IFwic2lnbmluXCIsIFwiL1wiKS5jb25jYXQocHJvdmlkZXIpO1xuICAgICAgICAgICAgX3NpZ25JblVybCA9IFwiXCIuY29uY2F0KHNpZ25JblVybCwgXCI/XCIpLmNvbmNhdChuZXcgVVJMU2VhcmNoUGFyYW1zKGF1dGhvcml6YXRpb25QYXJhbXMpKTtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IGZldGNoO1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQxID0gX3NpZ25JblVybDtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MiA9IHtcbiAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MyA9IFVSTFNlYXJjaFBhcmFtcztcbiAgICAgICAgICAgIF9jb250ZXh0NS50NCA9IF9vYmplY3RTcHJlYWQ7XG4gICAgICAgICAgICBfY29udGV4dDUudDUgPSBfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIF9jb250ZXh0NS50NiA9IHt9O1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAyNTtcbiAgICAgICAgICAgIHJldHVybiBnZXRDc3JmVG9rZW4oKTtcblxuICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICBfY29udGV4dDUudDcgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0NS50OCA9IGNhbGxiYWNrVXJsO1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQ5ID0ge1xuICAgICAgICAgICAgICBjc3JmVG9rZW46IF9jb250ZXh0NS50NyxcbiAgICAgICAgICAgICAgY2FsbGJhY2tVcmw6IF9jb250ZXh0NS50OCxcbiAgICAgICAgICAgICAganNvbjogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MTAgPSAoMCwgX2NvbnRleHQ1LnQ0KShfY29udGV4dDUudDUsIF9jb250ZXh0NS50NiwgX2NvbnRleHQ1LnQ5KTtcbiAgICAgICAgICAgIF9jb250ZXh0NS50MTEgPSBuZXcgX2NvbnRleHQ1LnQzKF9jb250ZXh0NS50MTApO1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQxMiA9IHtcbiAgICAgICAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgICAgICAgaGVhZGVyczogX2NvbnRleHQ1LnQyLFxuICAgICAgICAgICAgICBib2R5OiBfY29udGV4dDUudDExXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzMztcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2NvbnRleHQ1LnQwKShfY29udGV4dDUudDEsIF9jb250ZXh0NS50MTIpO1xuXG4gICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgIHJlcyA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzNjtcbiAgICAgICAgICAgIHJldHVybiByZXMuanNvbigpO1xuXG4gICAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDUuc2VudDtcblxuICAgICAgICAgICAgaWYgKCEocmVkaXJlY3QgfHwgIWlzU3VwcG9ydGluZ1JldHVybikpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0MjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVybCA9IChfZGF0YSR1cmwgPSBkYXRhLnVybCkgIT09IG51bGwgJiYgX2RhdGEkdXJsICE9PSB2b2lkIDAgPyBfZGF0YSR1cmwgOiBjYWxsYmFja1VybDtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgaWYgKHVybC5pbmNsdWRlcyhcIiNcIikpIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFVSTChkYXRhLnVybCkuc2VhcmNoUGFyYW1zLmdldChcImVycm9yXCIpO1xuXG4gICAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQ2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0NjtcbiAgICAgICAgICAgIHJldHVybiBfX05FWFRBVVRILl9nZXRTZXNzaW9uKHtcbiAgICAgICAgICAgICAgZXZlbnQ6IFwic3RvcmFnZVwiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNDY6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgICAgICAgICBvazogcmVzLm9rLFxuICAgICAgICAgICAgICB1cmw6IGVycm9yID8gbnVsbCA6IGRhdGEudXJsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9zaWduSW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gc2lnbk91dChfeDYpIHtcbiAgcmV0dXJuIF9zaWduT3V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9zaWduT3V0KCkge1xuICBfc2lnbk91dCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNihvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zJHJlZGlyZWN0O1xuXG4gICAgdmFyIF9yZWY2LCBfcmVmNiRjYWxsYmFja1VybCwgY2FsbGJhY2tVcmwsIGJhc2VVcmwsIGZldGNoT3B0aW9ucywgcmVzLCBkYXRhLCBfZGF0YSR1cmwyLCB1cmw7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfcmVmNiA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCBfcmVmNiRjYWxsYmFja1VybCA9IF9yZWY2LmNhbGxiYWNrVXJsLCBjYWxsYmFja1VybCA9IF9yZWY2JGNhbGxiYWNrVXJsID09PSB2b2lkIDAgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6IF9yZWY2JGNhbGxiYWNrVXJsO1xuICAgICAgICAgICAgYmFzZVVybCA9ICgwLCBfdXRpbHMuYXBpQmFzZVVybCkoX19ORVhUQVVUSCk7XG4gICAgICAgICAgICBfY29udGV4dDYudDAgPSB7XG4gICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfY29udGV4dDYudDEgPSBVUkxTZWFyY2hQYXJhbXM7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q3NyZlRva2VuKCk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBfY29udGV4dDYudDIgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Ni50MyA9IGNhbGxiYWNrVXJsO1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQ0ID0ge1xuICAgICAgICAgICAgICBjc3JmVG9rZW46IF9jb250ZXh0Ni50MixcbiAgICAgICAgICAgICAgY2FsbGJhY2tVcmw6IF9jb250ZXh0Ni50MyxcbiAgICAgICAgICAgICAganNvbjogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9jb250ZXh0Ni50NSA9IG5ldyBfY29udGV4dDYudDEoX2NvbnRleHQ2LnQ0KTtcbiAgICAgICAgICAgIGZldGNoT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgICAgICAgaGVhZGVyczogX2NvbnRleHQ2LnQwLFxuICAgICAgICAgICAgICBib2R5OiBfY29udGV4dDYudDVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDEzO1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKFwiXCIuY29uY2F0KGJhc2VVcmwsIFwiL3NpZ25vdXRcIiksIGZldGNoT3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgYnJvYWRjYXN0LnBvc3Qoe1xuICAgICAgICAgICAgICBldmVudDogXCJzZXNzaW9uXCIsXG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBcInNpZ25vdXRcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCEoKF9vcHRpb25zJHJlZGlyZWN0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZGlyZWN0KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRyZWRpcmVjdCAhPT0gdm9pZCAwID8gX29wdGlvbnMkcmVkaXJlY3QgOiB0cnVlKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDIzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXJsID0gKF9kYXRhJHVybDIgPSBkYXRhLnVybCkgIT09IG51bGwgJiYgX2RhdGEkdXJsMiAhPT0gdm9pZCAwID8gX2RhdGEkdXJsMiA6IGNhbGxiYWNrVXJsO1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICBpZiAodXJsLmluY2x1ZGVzKFwiI1wiKSkgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAyNTtcbiAgICAgICAgICAgIHJldHVybiBfX05FWFRBVVRILl9nZXRTZXNzaW9uKHtcbiAgICAgICAgICAgICAgZXZlbnQ6IFwic3RvcmFnZVwiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBkYXRhKTtcblxuICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNik7XG4gIH0pKTtcbiAgcmV0dXJuIF9zaWduT3V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIFNlc3Npb25Qcm92aWRlcihwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGJhc2VQYXRoID0gcHJvcHMuYmFzZVBhdGg7XG4gIGlmIChiYXNlUGF0aCkgX19ORVhUQVVUSC5iYXNlUGF0aCA9IGJhc2VQYXRoO1xuICB2YXIgaGFzSW5pdGlhbFNlc3Npb24gPSBwcm9wcy5zZXNzaW9uICE9PSB1bmRlZmluZWQ7XG4gIF9fTkVYVEFVVEguX2xhc3RTeW5jID0gaGFzSW5pdGlhbFNlc3Npb24gPyAoMCwgX3V0aWxzLm5vdykoKSA6IDA7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGFzSW5pdGlhbFNlc3Npb24pIF9fTkVYVEFVVEguX3Nlc3Npb24gPSBwcm9wcy5zZXNzaW9uO1xuICAgIHJldHVybiBwcm9wcy5zZXNzaW9uO1xuICB9KSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSAoMCwgX3NsaWNlZFRvQXJyYXkyLmRlZmF1bHQpKF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICBzZXNzaW9uID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldFNlc3Npb24gPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoIWhhc0luaXRpYWxTZXNzaW9uKSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTQgPSAoMCwgX3NsaWNlZFRvQXJyYXkyLmRlZmF1bHQpKF9SZWFjdCR1c2VTdGF0ZTMsIDIpLFxuICAgICAgbG9hZGluZyA9IF9SZWFjdCR1c2VTdGF0ZTRbMF0sXG4gICAgICBzZXRMb2FkaW5nID0gX1JlYWN0JHVzZVN0YXRlNFsxXTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIF9fTkVYVEFVVEguX2dldFNlc3Npb24gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgIHZhciBfcmVmNCxcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgICBzdG9yYWdlRXZlbnQsXG4gICAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfcmVmNCA9IF9hcmdzLmxlbmd0aCA+IDAgJiYgX2FyZ3NbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzBdIDoge30sIGV2ZW50ID0gX3JlZjQuZXZlbnQ7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuICAgICAgICAgICAgICBzdG9yYWdlRXZlbnQgPSBldmVudCA9PT0gXCJzdG9yYWdlXCI7XG5cbiAgICAgICAgICAgICAgaWYgKCEoc3RvcmFnZUV2ZW50IHx8IF9fTkVYVEFVVEguX3Nlc3Npb24gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfX05FWFRBVVRILl9sYXN0U3luYyA9ICgwLCBfdXRpbHMubm93KSgpO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuIGdldFNlc3Npb24oe1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdDogIXN0b3JhZ2VFdmVudFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfX05FWFRBVVRILl9zZXNzaW9uID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgc2V0U2Vzc2lvbihfX05FWFRBVVRILl9zZXNzaW9uKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgaWYgKCEoIWV2ZW50IHx8IF9fTkVYVEFVVEguX3Nlc3Npb24gPT09IG51bGwgfHwgKDAsIF91dGlscy5ub3cpKCkgPCBfX05FWFRBVVRILl9sYXN0U3luYykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBfX05FWFRBVVRILl9sYXN0U3luYyA9ICgwLCBfdXRpbHMubm93KSgpO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRTZXNzaW9uKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIF9fTkVYVEFVVEguX3Nlc3Npb24gPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBzZXRTZXNzaW9uKF9fTkVYVEFVVEguX3Nlc3Npb24pO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTk7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiQ0xJRU5UX1NFU1NJT05fRVJST1JcIiwgX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjI7XG4gICAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDIyKTtcblxuICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMSwgMTksIDIyLCAyNV1dKTtcbiAgICB9KSk7XG5cbiAgICBfX05FWFRBVVRILl9nZXRTZXNzaW9uKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgX19ORVhUQVVUSC5fbGFzdFN5bmMgPSAwO1xuICAgICAgX19ORVhUQVVUSC5fc2Vzc2lvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIH07XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdW5zdWJzY3JpYmUgPSBicm9hZGNhc3QucmVjZWl2ZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7XG4gICAgICAgIGV2ZW50OiBcInN0b3JhZ2VcIlxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB1bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3Byb3BzJHJlZmV0Y2hPbldpbmRvID0gcHJvcHMucmVmZXRjaE9uV2luZG93Rm9jdXMsXG4gICAgICAgIHJlZmV0Y2hPbldpbmRvd0ZvY3VzID0gX3Byb3BzJHJlZmV0Y2hPbldpbmRvID09PSB2b2lkIDAgPyB0cnVlIDogX3Byb3BzJHJlZmV0Y2hPbldpbmRvO1xuXG4gICAgdmFyIHZpc2liaWxpdHlIYW5kbGVyID0gZnVuY3Rpb24gdmlzaWJpbGl0eUhhbmRsZXIoKSB7XG4gICAgICBpZiAocmVmZXRjaE9uV2luZG93Rm9jdXMgJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIikgX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7XG4gICAgICAgIGV2ZW50OiBcInZpc2liaWxpdHljaGFuZ2VcIlxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHZpc2liaWxpdHlIYW5kbGVyLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB2aXNpYmlsaXR5SGFuZGxlciwgZmFsc2UpO1xuICAgIH07XG4gIH0sIFtwcm9wcy5yZWZldGNoT25XaW5kb3dGb2N1c10pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWZldGNoSW50ZXJ2YWwgPSBwcm9wcy5yZWZldGNoSW50ZXJ2YWw7XG5cbiAgICBpZiAocmVmZXRjaEludGVydmFsKSB7XG4gICAgICB2YXIgcmVmZXRjaEludGVydmFsVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfX05FWFRBVVRILl9zZXNzaW9uKSB7XG4gICAgICAgICAgX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7XG4gICAgICAgICAgICBldmVudDogXCJwb2xsXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgcmVmZXRjaEludGVydmFsICogMTAwMCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2xlYXJJbnRlcnZhbChyZWZldGNoSW50ZXJ2YWxUaW1lcik7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3Byb3BzLnJlZmV0Y2hJbnRlcnZhbF0pO1xuICB2YXIgdmFsdWUgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogc2Vzc2lvbixcbiAgICAgIHN0YXR1czogbG9hZGluZyA/IFwibG9hZGluZ1wiIDogc2Vzc2lvbiA/IFwiYXV0aGVudGljYXRlZFwiIDogXCJ1bmF1dGhlbnRpY2F0ZWRcIlxuICAgIH07XG4gIH0sIFtzZXNzaW9uLCBsb2FkaW5nXSk7XG4gIHJldHVybiAoMCwgX2pzeFJ1bnRpbWUuanN4KShTZXNzaW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59Il0sIm5hbWVzIjpbIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3R5cGVvZiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX2V4cG9ydE5hbWVzIiwidXNlU2Vzc2lvbiIsImdldFNlc3Npb24iLCJnZXRDc3JmVG9rZW4iLCJnZXRQcm92aWRlcnMiLCJzaWduSW4iLCJzaWduT3V0IiwiU2Vzc2lvblByb3ZpZGVyIiwiX3JlZ2VuZXJhdG9yIiwiX2RlZmluZVByb3BlcnR5MiIsIl9zbGljZWRUb0FycmF5MiIsIl9hc3luY1RvR2VuZXJhdG9yMiIsIlJlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfbG9nZ2VyMiIsIl9wYXJzZVVybCIsIl91dGlscyIsIl9qc3hSdW50aW1lIiwiX3R5cGVzIiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3Byb2Nlc3MkZW52JE5FWFRBVVRIIiwiX3JlZiIsIl9wcm9jZXNzJGVudiRORVhUQVVUSDIiLCJfcHJvY2VzcyRlbnYkTkVYVEFVVEgzIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwibm9kZUludGVyb3AiLCJXZWFrTWFwIiwiY2FjaGVCYWJlbEludGVyb3AiLCJjYWNoZU5vZGVJbnRlcm9wIiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJjYWNoZSIsImhhcyIsIm5ld09iaiIsImhhc1Byb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlc2MiLCJzZXQiLCJvd25LZXlzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9fTkVYVEFVVEgiLCJiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRBVVRIX1VSTCIsIlZFUkNFTF9VUkwiLCJvcmlnaW4iLCJiYXNlUGF0aCIsInBhdGgiLCJiYXNlVXJsU2VydmVyIiwiTkVYVEFVVEhfVVJMX0lOVEVSTkFMIiwiYmFzZVBhdGhTZXJ2ZXIiLCJfbGFzdFN5bmMiLCJfc2Vzc2lvbiIsInVuZGVmaW5lZCIsIl9nZXRTZXNzaW9uIiwiYnJvYWRjYXN0IiwiQnJvYWRjYXN0Q2hhbm5lbCIsImxvZ2dlciIsInByb3h5TG9nZ2VyIiwiU2Vzc2lvbkNvbnRleHQiLCJjcmVhdGVDb250ZXh0Iiwib3B0aW9ucyIsInVzZUNvbnRleHQiLCJOT0RFX0VOViIsIkVycm9yIiwiX3JlZjIiLCJyZXF1aXJlZCIsIm9uVW5hdXRoZW50aWNhdGVkIiwicmVxdWlyZWRBbmROb3RMb2FkaW5nIiwic3RhdHVzIiwidXNlRWZmZWN0IiwidXJsIiwiY29uY2F0IiwiVVJMU2VhcmNoUGFyYW1zIiwiZXJyb3IiLCJjYWxsYmFja1VybCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsImRhdGEiLCJfeCIsIl9nZXRTZXNzaW9uMiIsIm1hcmsiLCJfY2FsbGVlMiIsInBhcmFtcyIsIl9wYXJhbXMkYnJvYWRjYXN0Iiwic2Vzc2lvbiIsIndyYXAiLCJfY2FsbGVlMiQiLCJfY29udGV4dDIiLCJwcmV2IiwibmV4dCIsImZldGNoRGF0YSIsInNlbnQiLCJwb3N0IiwiZXZlbnQiLCJ0cmlnZ2VyIiwiYWJydXB0Iiwic3RvcCIsIl94MiIsIl9nZXRDc3JmVG9rZW4iLCJfY2FsbGVlMyIsInJlc3BvbnNlIiwiX2NhbGxlZTMkIiwiX2NvbnRleHQzIiwiY3NyZlRva2VuIiwiX2dldFByb3ZpZGVycyIsIl9jYWxsZWU0IiwiX2NhbGxlZTQkIiwiX2NvbnRleHQ0IiwiX3gzIiwiX3g0IiwiX3g1IiwiX3NpZ25JbiIsIl9jYWxsZWU1IiwicHJvdmlkZXIiLCJhdXRob3JpemF0aW9uUGFyYW1zIiwiX3JlZjUiLCJfcmVmNSRjYWxsYmFja1VybCIsIl9yZWY1JHJlZGlyZWN0IiwicmVkaXJlY3QiLCJwcm92aWRlcnMiLCJpc0NyZWRlbnRpYWxzIiwiaXNFbWFpbCIsImlzU3VwcG9ydGluZ1JldHVybiIsInNpZ25JblVybCIsIl9zaWduSW5VcmwiLCJyZXMiLCJfZGF0YSR1cmwiLCJfY2FsbGVlNSQiLCJfY29udGV4dDUiLCJhcGlCYXNlVXJsIiwidHlwZSIsInQwIiwiZmV0Y2giLCJ0MSIsInQyIiwidDMiLCJ0NCIsInQ1IiwidDYiLCJ0NyIsInQ4IiwidDkiLCJqc29uIiwidDEwIiwidDExIiwidDEyIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJpbmNsdWRlcyIsInJlbG9hZCIsIlVSTCIsInNlYXJjaFBhcmFtcyIsIm9rIiwiX3g2IiwiX3NpZ25PdXQiLCJfY2FsbGVlNiIsIl9vcHRpb25zJHJlZGlyZWN0IiwiX3JlZjYiLCJfcmVmNiRjYWxsYmFja1VybCIsImZldGNoT3B0aW9ucyIsIl9kYXRhJHVybDIiLCJfY2FsbGVlNiQiLCJfY29udGV4dDYiLCJwcm9wcyIsImNoaWxkcmVuIiwiaGFzSW5pdGlhbFNlc3Npb24iLCJub3ciLCJfUmVhY3QkdXNlU3RhdGUiLCJ1c2VTdGF0ZSIsIl9SZWFjdCR1c2VTdGF0ZTIiLCJzZXRTZXNzaW9uIiwiX1JlYWN0JHVzZVN0YXRlMyIsIl9SZWFjdCR1c2VTdGF0ZTQiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsIl9jYWxsZWUiLCJfcmVmNCIsInN0b3JhZ2VFdmVudCIsIl9hcmdzIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsImZpbmlzaCIsInVuc3Vic2NyaWJlIiwicmVjZWl2ZSIsIl9wcm9wcyRyZWZldGNoT25XaW5kbyIsInJlZmV0Y2hPbldpbmRvd0ZvY3VzIiwidmlzaWJpbGl0eUhhbmRsZXIiLCJkb2N1bWVudCIsInZpc2liaWxpdHlTdGF0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVmZXRjaEludGVydmFsIiwicmVmZXRjaEludGVydmFsVGltZXIiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJ1c2VNZW1vIiwianN4IiwiUHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next-auth/react/index.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/react/types.js":
/*!***********************************************!*\
  !*** ./node_modules/next-auth/react/types.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0L3R5cGVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViQSw4Q0FBNkM7RUFDM0NHLEtBQUssRUFBRTtBQURvQyxDQUE3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0L3R5cGVzLmpzPzFlNWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next-auth/react/types.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/utils/logger.js":
/*!************************************************!*\
  !*** ./node_modules/next-auth/utils/logger.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nexports.proxyLogger = proxyLogger;\nexports.setLogger = setLogger;\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _errors = __webpack_require__(/*! ../core/errors */ \"./node_modules/next-auth/core/errors.js\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction formatError(o) {\n  if (o instanceof Error && !(o instanceof _errors.UnknownError)) {\n    return {\n      message: o.message,\n      stack: o.stack,\n      name: o.name\n    };\n  }\n\n  if (hasErrorProperty(o)) {\n    var _o$message;\n\n    o.error = formatError(o.error);\n    o.message = (_o$message = o.message) !== null && _o$message !== void 0 ? _o$message : o.error.message;\n  }\n\n  return o;\n}\n\nfunction hasErrorProperty(x) {\n  return !!(x !== null && x !== void 0 && x.error);\n}\n\nvar _logger = {\n  error: function error(code, metadata) {\n    metadata = formatError(metadata);\n    console.error(\"[next-auth][error][\".concat(code, \"]\"), \"\\nhttps://next-auth.js.org/errors#\".concat(code.toLowerCase()), metadata.message, metadata);\n  },\n  warn: function warn(code) {\n    console.warn(\"[next-auth][warn][\".concat(code, \"]\"), \"\\nhttps://next-auth.js.org/warnings#\".concat(code.toLowerCase()));\n  },\n  debug: function debug(code, metadata) {\n    console.log(\"[next-auth][debug][\".concat(code, \"]\"), metadata);\n  }\n};\n\nfunction setLogger() {\n  var newLogger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var debug = arguments.length > 1 ? arguments[1] : undefined;\n  if (!debug) _logger.debug = function () {};\n  if (newLogger.error) _logger.error = newLogger.error;\n  if (newLogger.warn) _logger.warn = newLogger.warn;\n  if (newLogger.debug) _logger.debug = newLogger.debug;\n}\n\nvar _default = _logger;\nexports[\"default\"] = _default;\n\nfunction proxyLogger() {\n  var logger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _logger;\n  var basePath = arguments.length > 1 ? arguments[1] : undefined;\n\n  try {\n    if (typeof window === \"undefined\") {\n      return logger;\n    }\n\n    var clientLogger = {};\n\n    var _loop = function _loop(level) {\n      clientLogger[level] = function (code, metadata) {\n        _logger[level](code, metadata);\n\n        if (level === \"error\") {\n          metadata = formatError(metadata);\n        }\n\n        ;\n        metadata.client = true;\n        var url = \"\".concat(basePath, \"/_log\");\n        var body = new URLSearchParams(_objectSpread({\n          level: level,\n          code: code\n        }, metadata));\n\n        if (navigator.sendBeacon) {\n          return navigator.sendBeacon(url, body);\n        }\n\n        return fetch(url, {\n          method: \"POST\",\n          body: body,\n          keepalive: true\n        });\n      };\n    };\n\n    for (var level in logger) {\n      _loop(level);\n    }\n\n    return clientLogger;\n  } catch (_unused) {\n    return _logger;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3V0aWxzL2xvZ2dlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJQSxzQkFBc0IsR0FBR0MsbUJBQU8sQ0FBQyxvSEFBRCxDQUFwQzs7QUFFQUMsOENBQTZDO0VBQzNDRyxLQUFLLEVBQUU7QUFEb0MsQ0FBN0M7QUFHQUQsa0JBQUEsR0FBa0IsS0FBSyxDQUF2QjtBQUNBQSxtQkFBQSxHQUFzQkcsV0FBdEI7QUFDQUgsaUJBQUEsR0FBb0JJLFNBQXBCOztBQUVBLElBQUlDLGdCQUFnQixHQUFHVCxzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxzR0FBRCxDQUFSLENBQTdDOztBQUVBLElBQUlTLE9BQU8sR0FBR1QsbUJBQU8sQ0FBQywrREFBRCxDQUFyQjs7QUFFQSxTQUFTVSxPQUFULENBQWlCQyxNQUFqQixFQUF5QkMsY0FBekIsRUFBeUM7RUFBRSxJQUFJQyxJQUFJLEdBQUdaLE1BQU0sQ0FBQ1ksSUFBUCxDQUFZRixNQUFaLENBQVg7O0VBQWdDLElBQUlWLE1BQU0sQ0FBQ2EscUJBQVgsRUFBa0M7SUFBRSxJQUFJQyxPQUFPLEdBQUdkLE1BQU0sQ0FBQ2EscUJBQVAsQ0FBNkJILE1BQTdCLENBQWQ7SUFBb0RDLGNBQWMsS0FBS0csT0FBTyxHQUFHQSxPQUFPLENBQUNDLE1BQVIsQ0FBZSxVQUFVQyxHQUFWLEVBQWU7TUFBRSxPQUFPaEIsTUFBTSxDQUFDaUIsd0JBQVAsQ0FBZ0NQLE1BQWhDLEVBQXdDTSxHQUF4QyxFQUE2Q0UsVUFBcEQ7SUFBaUUsQ0FBakcsQ0FBZixDQUFkLEVBQWtJTixJQUFJLENBQUNPLElBQUwsQ0FBVUMsS0FBVixDQUFnQlIsSUFBaEIsRUFBc0JFLE9BQXRCLENBQWxJO0VBQW1LOztFQUFDLE9BQU9GLElBQVA7QUFBYzs7QUFFclYsU0FBU1MsYUFBVCxDQUF1QkMsTUFBdkIsRUFBK0I7RUFBRSxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdDLFNB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aEJMLElBQUksRUFBRUEsSUFGVTtVQUdoQk0sU0FBUyxFQUFFO1FBSEssQ0FBTixDQUFaO01BS0QsQ0F4QkQ7SUF5QkQsQ0ExQkQ7O0lBNEJBLEtBQUssSUFBSVQsS0FBVCxJQUFrQkwsTUFBbEIsRUFBMEI7TUFDeEJJLEtBQUssQ0FBQ0MsS0FBRCxDQUFMO0lBQ0Q7O0lBRUQsT0FBT0YsWUFBUDtFQUNELENBeENELENBd0NFLE9BQU9ZLE9BQVAsRUFBZ0I7SUFDaEIsT0FBTzNCLE9BQVA7RUFDRDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvdXRpbHMvbG9nZ2VyLmpzP2YyOTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuZXhwb3J0cy5wcm94eUxvZ2dlciA9IHByb3h5TG9nZ2VyO1xuZXhwb3J0cy5zZXRMb2dnZXIgPSBzZXRMb2dnZXI7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfZXJyb3JzID0gcmVxdWlyZShcIi4uL2NvcmUvZXJyb3JzXCIpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBFcnJvciAmJiAhKG8gaW5zdGFuY2VvZiBfZXJyb3JzLlVua25vd25FcnJvcikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogby5tZXNzYWdlLFxuICAgICAgc3RhY2s6IG8uc3RhY2ssXG4gICAgICBuYW1lOiBvLm5hbWVcbiAgICB9O1xuICB9XG5cbiAgaWYgKGhhc0Vycm9yUHJvcGVydHkobykpIHtcbiAgICB2YXIgX28kbWVzc2FnZTtcblxuICAgIG8uZXJyb3IgPSBmb3JtYXRFcnJvcihvLmVycm9yKTtcbiAgICBvLm1lc3NhZ2UgPSAoX28kbWVzc2FnZSA9IG8ubWVzc2FnZSkgIT09IG51bGwgJiYgX28kbWVzc2FnZSAhPT0gdm9pZCAwID8gX28kbWVzc2FnZSA6IG8uZXJyb3IubWVzc2FnZTtcbiAgfVxuXG4gIHJldHVybiBvO1xufVxuXG5mdW5jdGlvbiBoYXNFcnJvclByb3BlcnR5KHgpIHtcbiAgcmV0dXJuICEhKHggIT09IG51bGwgJiYgeCAhPT0gdm9pZCAwICYmIHguZXJyb3IpO1xufVxuXG52YXIgX2xvZ2dlciA9IHtcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKGNvZGUsIG1ldGFkYXRhKSB7XG4gICAgbWV0YWRhdGEgPSBmb3JtYXRFcnJvcihtZXRhZGF0YSk7XG4gICAgY29uc29sZS5lcnJvcihcIltuZXh0LWF1dGhdW2Vycm9yXVtcIi5jb25jYXQoY29kZSwgXCJdXCIpLCBcIlxcbmh0dHBzOi8vbmV4dC1hdXRoLmpzLm9yZy9lcnJvcnMjXCIuY29uY2F0KGNvZGUudG9Mb3dlckNhc2UoKSksIG1ldGFkYXRhLm1lc3NhZ2UsIG1ldGFkYXRhKTtcbiAgfSxcbiAgd2FybjogZnVuY3Rpb24gd2Fybihjb2RlKSB7XG4gICAgY29uc29sZS53YXJuKFwiW25leHQtYXV0aF1bd2Fybl1bXCIuY29uY2F0KGNvZGUsIFwiXVwiKSwgXCJcXG5odHRwczovL25leHQtYXV0aC5qcy5vcmcvd2FybmluZ3MjXCIuY29uY2F0KGNvZGUudG9Mb3dlckNhc2UoKSkpO1xuICB9LFxuICBkZWJ1ZzogZnVuY3Rpb24gZGVidWcoY29kZSwgbWV0YWRhdGEpIHtcbiAgICBjb25zb2xlLmxvZyhcIltuZXh0LWF1dGhdW2RlYnVnXVtcIi5jb25jYXQoY29kZSwgXCJdXCIpLCBtZXRhZGF0YSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldExvZ2dlcigpIHtcbiAgdmFyIG5ld0xvZ2dlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICBpZiAoIWRlYnVnKSBfbG9nZ2VyLmRlYnVnID0gZnVuY3Rpb24gKCkge307XG4gIGlmIChuZXdMb2dnZXIuZXJyb3IpIF9sb2dnZXIuZXJyb3IgPSBuZXdMb2dnZXIuZXJyb3I7XG4gIGlmIChuZXdMb2dnZXIud2FybikgX2xvZ2dlci53YXJuID0gbmV3TG9nZ2VyLndhcm47XG4gIGlmIChuZXdMb2dnZXIuZGVidWcpIF9sb2dnZXIuZGVidWcgPSBuZXdMb2dnZXIuZGVidWc7XG59XG5cbnZhciBfZGVmYXVsdCA9IF9sb2dnZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcblxuZnVuY3Rpb24gcHJveHlMb2dnZXIoKSB7XG4gIHZhciBsb2dnZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9sb2dnZXI7XG4gIHZhciBiYXNlUGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfVxuXG4gICAgdmFyIGNsaWVudExvZ2dlciA9IHt9O1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AobGV2ZWwpIHtcbiAgICAgIGNsaWVudExvZ2dlcltsZXZlbF0gPSBmdW5jdGlvbiAoY29kZSwgbWV0YWRhdGEpIHtcbiAgICAgICAgX2xvZ2dlcltsZXZlbF0oY29kZSwgbWV0YWRhdGEpO1xuXG4gICAgICAgIGlmIChsZXZlbCA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgbWV0YWRhdGEgPSBmb3JtYXRFcnJvcihtZXRhZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICA7XG4gICAgICAgIG1ldGFkYXRhLmNsaWVudCA9IHRydWU7XG4gICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChiYXNlUGF0aCwgXCIvX2xvZ1wiKTtcbiAgICAgICAgdmFyIGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgICBjb2RlOiBjb2RlXG4gICAgICAgIH0sIG1ldGFkYXRhKSk7XG5cbiAgICAgICAgaWYgKG5hdmlnYXRvci5zZW5kQmVhY29uKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5zZW5kQmVhY29uKHVybCwgYm9keSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgIGtlZXBhbGl2ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZvciAodmFyIGxldmVsIGluIGxvZ2dlcikge1xuICAgICAgX2xvb3AobGV2ZWwpO1xuICAgIH1cblxuICAgIHJldHVybiBjbGllbnRMb2dnZXI7XG4gIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICByZXR1cm4gX2xvZ2dlcjtcbiAgfVxufSJdLCJuYW1lcyI6WyJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsInByb3h5TG9nZ2VyIiwic2V0TG9nZ2VyIiwiX2RlZmluZVByb3BlcnR5MiIsIl9lcnJvcnMiLCJvd25LZXlzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImZvckVhY2giLCJrZXkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImZvcm1hdEVycm9yIiwibyIsIkVycm9yIiwiVW5rbm93bkVycm9yIiwibWVzc2FnZSIsInN0YWNrIiwibmFtZSIsImhhc0Vycm9yUHJvcGVydHkiLCJfbyRtZXNzYWdlIiwiZXJyb3IiLCJ4IiwiX2xvZ2dlciIsImNvZGUiLCJtZXRhZGF0YSIsImNvbnNvbGUiLCJjb25jYXQiLCJ0b0xvd2VyQ2FzZSIsIndhcm4iLCJkZWJ1ZyIsImxvZyIsIm5ld0xvZ2dlciIsInVuZGVmaW5lZCIsIl9kZWZhdWx0IiwibG9nZ2VyIiwiYmFzZVBhdGgiLCJ3aW5kb3ciLCJjbGllbnRMb2dnZXIiLCJfbG9vcCIsImxldmVsIiwiY2xpZW50IiwidXJsIiwiYm9keSIsIlVSTFNlYXJjaFBhcmFtcyIsIm5hdmlnYXRvciIsInNlbmRCZWFjb24iLCJmZXRjaCIsIm1ldGhvZCIsImtlZXBhbGl2ZSIsIl91bnVzZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next-auth/utils/logger.js\n"));

/***/ }),

/***/ "./node_modules/next-auth/utils/parse-url.js":
/*!***************************************************!*\
  !*** ./node_modules/next-auth/utils/parse-url.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = parseUrl;\n\nfunction parseUrl(url) {\n  var _url2;\n\n  const defaultUrl = new URL(\"http://localhost:3000/api/auth\");\n\n  if (url && !url.startsWith(\"http\")) {\n    url = `https://${url}`;\n  }\n\n  const _url = new URL((_url2 = url) !== null && _url2 !== void 0 ? _url2 : defaultUrl);\n\n  const path = (_url.pathname === \"/\" ? defaultUrl.pathname : _url.pathname).replace(/\\/$/, \"\");\n  const base = `${_url.origin}${path}`;\n  return {\n    origin: _url.origin,\n    host: _url.host,\n    path,\n    base,\n    toString: () => base\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3V0aWxzL3BhcnNlLXVybC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYkEsOENBQTZDO0VBQzNDRyxLQUFLLEVBQUU7QUFEb0MsQ0FBN0M7QUFHQUQsa0JBQUEsR0FBa0JHLFFBQWxCOztBQUVBLFNBQVNBLFFBQVQsQ0FBa0JDLEdBQWxCLEVBQXVCO0VBQ3JCLElBQUlDLEtBQUo7O0VBRUEsTUFBTUMsVUFBVSxHQUFHLElBQUlDLEdBQUosQ0FBUSxnQ0FBUixDQUFuQjs7RUFFQSxJQUFJSCxHQUFHLElBQUksQ0FBQ0EsR0FBRyxDQUFDSSxVQUFKLENBQWUsTUFBZixDQUFaLEVBQW9DO0lBQ2xDSixHQUFHLEdBQUksV0FBVUEsR0FBSSxFQUFyQjtFQUNEOztFQUVELE1BQU1LLElBQUksR0FBRyxJQUFJRixHQUFKLENBQVEsQ0FBQ0YsS0FBSyxHQUFHRCxHQUFULE1BQWtCLElBQWxCLElBQTBCQyxLQUFLLEtBQUssS0FBSyxDQUF6QyxHQUE2Q0EsS0FBN0MsR0FBcURDLFVBQTdELENBQWI7O0VBRUEsTUFBTUksSUFBSSxHQUFHLENBQUNELElBQUksQ0FBQ0UsUUFBTCxLQUFrQixHQUFsQixHQUF3QkwsVUFBVSxDQUFDSyxRQUFuQyxHQUE4Q0YsSUFBSSxDQUFDRSxRQUFwRCxFQUE4REMsT0FBOUQsQ0FBc0UsS0FBdEUsRUFBNkUsRUFBN0UsQ0FBYjtFQUNBLE1BQU1DLElBQUksR0FBSSxHQUFFSixJQUFJLENBQUNLLE1BQU8sR0FBRUosSUFBSyxFQUFuQztFQUNBLE9BQU87SUFDTEksTUFBTSxFQUFFTCxJQUFJLENBQUNLLE1BRFI7SUFFTEMsSUFBSSxFQUFFTixJQUFJLENBQUNNLElBRk47SUFHTEwsSUFISztJQUlMRyxJQUpLO0lBS0xHLFFBQVEsRUFBRSxNQUFNSDtFQUxYLENBQVA7QUFPRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3V0aWxzL3BhcnNlLXVybC5qcz9jMzM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VVcmw7XG5cbmZ1bmN0aW9uIHBhcnNlVXJsKHVybCkge1xuICB2YXIgX3VybDI7XG5cbiAgY29uc3QgZGVmYXVsdFVybCA9IG5ldyBVUkwoXCJodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGhcIik7XG5cbiAgaWYgKHVybCAmJiAhdXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgdXJsID0gYGh0dHBzOi8vJHt1cmx9YDtcbiAgfVxuXG4gIGNvbnN0IF91cmwgPSBuZXcgVVJMKChfdXJsMiA9IHVybCkgIT09IG51bGwgJiYgX3VybDIgIT09IHZvaWQgMCA/IF91cmwyIDogZGVmYXVsdFVybCk7XG5cbiAgY29uc3QgcGF0aCA9IChfdXJsLnBhdGhuYW1lID09PSBcIi9cIiA/IGRlZmF1bHRVcmwucGF0aG5hbWUgOiBfdXJsLnBhdGhuYW1lKS5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gIGNvbnN0IGJhc2UgPSBgJHtfdXJsLm9yaWdpbn0ke3BhdGh9YDtcbiAgcmV0dXJuIHtcbiAgICBvcmlnaW46IF91cmwub3JpZ2luLFxuICAgIGhvc3Q6IF91cmwuaG9zdCxcbiAgICBwYXRoLFxuICAgIGJhc2UsXG4gICAgdG9TdHJpbmc6ICgpID0+IGJhc2VcbiAgfTtcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwicGFyc2VVcmwiLCJ1cmwiLCJfdXJsMiIsImRlZmF1bHRVcmwiLCJVUkwiLCJzdGFydHNXaXRoIiwiX3VybCIsInBhdGgiLCJwYXRobmFtZSIsInJlcGxhY2UiLCJiYXNlIiwib3JpZ2luIiwiaG9zdCIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next-auth/utils/parse-url.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar ref, ref1;\nmodule.exports = ((ref = __webpack_require__.g.process) == null ? void 0 : ref.env) && typeof ((ref1 = __webpack_require__.g.process) == null ? void 0 : ref1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! ../../compiled/process */ \"./node_modules/next/dist/compiled/process/browser.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBQTs7SUFDRUMsS0FBOEJBO0FBRGhDRCxNQUFNLENBQUNFLE9BQVBGLEdBQ0VDLEtBQWMsR0FBZEEscUJBQU0sQ0FBQ0UsT0FBUEYsS0FBYyxJQUFkQSxlQUFjLENBQUVHLEdBQWhCSCxLQUF1QixRQUFPQSxLQUFjLEdBQWRBLHFCQUFNLENBQUNFLE9BQVBGLEtBQWMsSUFBZEEsZ0JBQWMsQ0FBRUcsR0FBdkIsTUFBK0IsUUFBdERILEdBQ0lBLHFCQUFNLENBQUNFLE9BRFhGLEdBRUlJLG1CQUFPLENBQUMsb0ZBQUQsQ0FIYkwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzPzkyOWIiXSwibmFtZXMiOlsibW9kdWxlIiwiZ2xvYmFsIiwiZXhwb3J0cyIsInByb2Nlc3MiLCJlbnYiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function (useSourceMap) {\n  var list = [] // return the list of modules as css string\n  ;\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  } // import a list of modules into the list\n  ; // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \"\" // eslint-disable-next-line prefer-destructuring\n  ;\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \"function\") {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFNQUE7QUFOQTs7OztBQUlBO0FBQ0E7O0FBQ0FBLE1BQU0sQ0FBQ0MsT0FBUEQsR0FBaUIsVUFBVUUsWUFBVixFQUF3QjtFQUN2QyxJQUFJQyxJQUFJLEdBQUcsRUFBWCxDQUFjO0VBQWQ7O0VBRUFBLElBQUksQ0FBQ0MsUUFBTEQsR0FBZ0IsU0FBU0MsUUFBVCxHQUFvQjtJQUNsQyxPQUFPLEtBQUtDLEdBQUwsQ0FBUyxVQUFVQyxJQUFWLEVBQWdCO01BQzlCLElBQUlDLE9BQU8sR0FBR0Msc0JBQXNCLENBQUNGLElBQUQsRUFBT0osWUFBUCxDQUFwQzs7TUFFQSxJQUFJSSxJQUFJLENBQUMsQ0FBRCxDQUFSLEVBQWE7UUFDWCxPQUFPLFVBQVVHLE1BQVYsQ0FBaUJILElBQUksQ0FBQyxDQUFELENBQXJCLEVBQTBCLElBQTFCLEVBQWdDRyxNQUFoQyxDQUF1Q0YsT0FBdkMsRUFBZ0QsR0FBaEQsQ0FBUDtNQUNEOztNQUVELE9BQU9BLE9BQVA7SUFDRCxDQVJNLEVBUUpHLElBUkksQ0FRQyxFQVJELENBQVA7RUFTRCxDQVZEUCxDQVVFO0VBVkZBLENBSHVDLENBY3ZDOzs7RUFFQUEsSUFBSSxDQUFDUSxDQUFMUixHQUFTLFVBQVVTLE9BQVYsRUFBbUJDLFVBQW5CLEVBQStCQyxNQUEvQixFQUF1QztJQUM5QyxJQUFJLE9BQU9GLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7TUFDL0I7TUFDQUEsT0FBTyxHQUFHLENBQUMsQ0FBQyxJQUFELEVBQU9BLE9BQVAsRUFBZ0IsRUFBaEIsQ0FBRCxDQUFWQTtJQUNEOztJQUVELElBQUlHLHNCQUFzQixHQUFHLEVBQTdCOztJQUVBLElBQUlELE1BQUosRUFBWTtNQUNWLEtBQUssSUFBSUgsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLSyxNQUF6QixFQUFpQ0wsQ0FBQyxFQUFsQyxFQUFzQztRQUNwQztRQUNBLElBQUlNLEVBQUUsR0FBRyxLQUFLTixDQUFMLEVBQVEsQ0FBUixDQUFUOztRQUVBLElBQUlNLEVBQUUsSUFBSSxJQUFWLEVBQWdCO1VBQ2RGLHNCQUFzQixDQUFDRSxFQUFELENBQXRCRixHQUE2QixJQUE3QkE7UUFDRDtNQUNGO0lBQ0Y7O0lBRUQsS0FBSyxJQUFJRyxFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxHQUFHTixPQUFPLENBQUNJLE1BQTlCLEVBQXNDRSxFQUFFLEVBQXhDLEVBQTRDO01BQzFDLElBQUlaLElBQUksR0FBRyxHQUFHRyxNQUFILENBQVVHLE9BQU8sQ0FBQ00sRUFBRCxDQUFqQixDQUFYOztNQUVBLElBQUlKLE1BQU0sSUFBSUMsc0JBQXNCLENBQUNULElBQUksQ0FBQyxDQUFELENBQUwsQ0FBcEMsRUFBK0M7UUFFN0M7TUFDRDs7TUFFRCxJQUFJTyxVQUFKLEVBQWdCO1FBQ2QsSUFBSSxDQUFDUCxJQUFJLENBQUMsQ0FBRCxDQUFULEVBQWM7VUFDWkEsSUFBSSxDQUFDLENBQUQsQ0FBSkEsR0FBVU8sVUFBVlA7UUFDRCxDQUZELE1BRU87VUFDTEEsSUFBSSxDQUFDLENBQUQsQ0FBSkEsR0FBVSxHQUFHRyxNQUFILENBQVVJLFVBQVYsRUFBc0IsT0FBdEIsRUFBK0JKLE1BQS9CLENBQXNDSCxJQUFJLENBQUMsQ0FBRCxDQUExQyxDQUFWQTtRQUNEO01BQ0Y7O01BRURILElBQUksQ0FBQ2dCLElBQUxoQixDQUFVRyxJQUFWSDtJQUNEO0VBQ0YsQ0FyQ0RBOztFQXVDQSxPQUFPQSxJQUFQO0FBQ0QsQ0F4RERIOztBQTBEQSxTQUFTUSxzQkFBVCxDQUFnQ0YsSUFBaEMsRUFBc0NKLFlBQXRDLEVBQW9EO0VBQ2xELElBQUlLLE9BQU8sR0FBR0QsSUFBSSxDQUFDLENBQUQsQ0FBSkEsSUFBVyxFQUF6QixDQUE0QjtFQUE1QjtFQUVBLElBQUljLFVBQVUsR0FBR2QsSUFBSSxDQUFDLENBQUQsQ0FBckI7O0VBRUEsSUFBSSxDQUFDYyxVQUFMLEVBQWlCO0lBQ2YsT0FBT2IsT0FBUDtFQUNEOztFQUVELElBQUlMLFlBQVksSUFBSSxPQUFPbUIsSUFBUCxLQUFnQixVQUFwQyxFQUFnRDtJQUM5QyxJQUFJQyxhQUFhLEdBQUdDLFNBQVMsQ0FBQ0gsVUFBRCxDQUE3QjtJQUNBLElBQUlJLFVBQVUsR0FBR0osVUFBVSxDQUFDSyxPQUFYTCxDQUFtQmYsR0FBbkJlLENBQXVCLFVBQVVNLE1BQVYsRUFBa0I7TUFDeEQsT0FBTyxpQkFDSmpCLE1BREksQ0FDR1csVUFBVSxDQUFDTyxVQUFYUCxJQUF5QixFQUQ1QixFQUVKWCxNQUZJLENBRUdpQixNQUZILEVBRVcsS0FGWCxDQUFQO0lBR0QsQ0FKZ0JOLENBQWpCO0lBS0EsT0FBTyxDQUFDYixPQUFELEVBQVVFLE1BQVYsQ0FBaUJlLFVBQWpCLEVBQTZCZixNQUE3QixDQUFvQyxDQUFDYSxhQUFELENBQXBDLEVBQXFEWixJQUFyRCxDQUEwRCxJQUExRCxDQUFQO0VBQ0Q7O0VBRUQsT0FBTyxDQUFDSCxPQUFELEVBQVVHLElBQVYsQ0FBZSxJQUFmLENBQVA7QUFDRCxDLENBQUM7OztBQUVGLFNBQVNhLFNBQVQsQ0FBbUJLLFNBQW5CLEVBQThCO0VBQzVCO0VBQ0EsSUFBSUMsTUFBTSxHQUFHUixJQUFJLENBQUNTLFFBQVEsQ0FBQ0Msa0JBQWtCLENBQUNDLElBQUksQ0FBQ0MsU0FBTEQsQ0FBZUosU0FBZkksQ0FBRCxDQUFuQixDQUFULENBQWpCO0VBQ0EsSUFBSUUsSUFBSSxHQUNOLCtEQUErRHpCLE1BQS9ELENBQ0VvQixNQURGLENBREY7RUFJQSxPQUFPLE9BQU9wQixNQUFQLENBQWN5QixJQUFkLEVBQW9CLEtBQXBCLENBQVA7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzP2NjZmMiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVzZVNvdXJjZU1hcCIsImxpc3QiLCJ0b1N0cmluZyIsIm1hcCIsIml0ZW0iLCJjb250ZW50IiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsImNvbmNhdCIsImpvaW4iLCJpIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJkZWR1cGUiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwibGVuZ3RoIiwiaWQiLCJfaSIsInB1c2giLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZSIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getDomainLocale = getDomainLocale;\nvar basePath =  false || \"\";\n\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n  if (false) { var finalLocale, proto, domain, target, detectDomainLocale, normalizeLocalePath; } else {\n    return false;\n  }\n}\n\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n  Object.defineProperty(exports.default, \"__esModule\", {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0NILEVBQUFBO0FBR0FFLHVCQUFBQSxHQUEwQkUsZUFBMUJGO0FBQ0EsSUFBTUcsUUFBUSxHQUFHQyxNQUFBQSxJQUFzQyxFQUF2RDs7QUFDQSxTQUFTRixlQUFULENBQXlCSyxJQUF6QixFQUErQkMsTUFBL0IsRUFBdUNDLE9BQXZDLEVBQWdEQyxhQUFoRCxFQUErRDtFQUMzRCxJQUFJTixLQUFKLEVBQXFDLG9GQUFyQyxNQVdPO0lBQ0gsT0FBTyxLQUFQO0VBQ0g7QUFDSjs7QUFFRCxJQUFJLENBQUMsT0FBT0osT0FBTyxDQUFDd0IsT0FBZixLQUEyQixVQUEzQixJQUEwQyxPQUFPeEIsT0FBTyxDQUFDd0IsT0FBZixLQUEyQixRQUEzQixJQUF1Q3hCLE9BQU8sQ0FBQ3dCLE9BQVJ4QixLQUFvQixJQUF0RyxLQUFnSCxPQUFPQSxPQUFPLENBQUN3QixPQUFSeEIsQ0FBZ0J5QixVQUF2QixLQUFzQyxXQUExSixFQUF1SztFQUNySzNCLE1BQU0sQ0FBQ0MsY0FBUEQsQ0FBc0JFLE9BQU8sQ0FBQ3dCLE9BQTlCMUIsRUFBdUMsWUFBdkNBLEVBQXFEO0lBQUVHLEtBQUssRUFBRTtFQUFULENBQXJESDtFQUNBQSxNQUFNLENBQUM0QixNQUFQNUIsQ0FBY0UsT0FBTyxDQUFDd0IsT0FBdEIxQixFQUErQkUsT0FBL0JGO0VBQ0E2QixNQUFNLENBQUMzQixPQUFQMkIsR0FBaUIzQixPQUFPLENBQUN3QixPQUF6Qkc7QUFDRCxDLENBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZ2V0LWRvbWFpbi1sb2NhbGUuanM/NWMyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0RG9tYWluTG9jYWxlID0gZ2V0RG9tYWluTG9jYWxlO1xuY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnO1xuZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKHBhdGgsIGxvY2FsZSwgbG9jYWxlcywgZG9tYWluTG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZUxvY2FsZVBhdGggPSByZXF1aXJlKCcuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCcpLm5vcm1hbGl6ZUxvY2FsZVBhdGg7XG4gICAgICAgIGNvbnN0IGRldGVjdERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoJy4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKS5kZXRlY3REb21haW5Mb2NhbGU7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGxvY2FsZSB8fCBub3JtYWxpemVMb2NhbGVQYXRoKHBhdGgsIGxvY2FsZXMpLmRldGVjdGVkTG9jYWxlO1xuICAgICAgICBjb25zdCBkb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUoZG9tYWluTG9jYWxlcywgdW5kZWZpbmVkLCB0YXJnZXQpO1xuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICBjb25zdCBwcm90byA9IGBodHRwJHtkb21haW4uaHR0cCA/ICcnIDogJ3MnfTovL2A7XG4gICAgICAgICAgICBjb25zdCBmaW5hbExvY2FsZSA9IHRhcmdldCA9PT0gZG9tYWluLmRlZmF1bHRMb2NhbGUgPyAnJyA6IGAvJHt0YXJnZXR9YDtcbiAgICAgICAgICAgIHJldHVybiBgJHtwcm90b30ke2RvbWFpbi5kb21haW59JHtiYXNlUGF0aH0ke2ZpbmFsTG9jYWxlfSR7cGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtZG9tYWluLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXREb21haW5Mb2NhbGUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsImxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJyZXF1aXJlIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwidGFyZ2V0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJkb21haW4iLCJ1bmRlZmluZWQiLCJwcm90byIsImNvbmNhdCIsImh0dHAiLCJmaW5hbExvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/image.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/image.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _defineProperty = (__webpack_require__(/*! @swc/helpers/lib/_define_property.js */ \"./node_modules/@swc/helpers/lib/_define_property.js\")[\"default\"]);\n\nvar _slicedToArray = (__webpack_require__(/*! @swc/helpers/lib/_sliced_to_array.js */ \"./node_modules/@swc/helpers/lib/_sliced_to_array.js\")[\"default\"]);\n\nvar _toConsumableArray = (__webpack_require__(/*! @swc/helpers/lib/_to_consumable_array.js */ \"./node_modules/@swc/helpers/lib/_to_consumable_array.js\")[\"default\"]);\n\nvar _s = $RefreshSig$(),\n    _s1 = $RefreshSig$();\n\n\"client\";\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = Image;\n\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\n\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\n\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\n\nvar _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ \"./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\")[\"default\"]);\n\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _head = _interop_require_default(__webpack_require__(/*! ../shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\"));\n\nvar _imageConfig = __webpack_require__(/*! ../shared/lib/image-config */ \"./node_modules/next/dist/shared/lib/image-config.js\");\n\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\n\nvar _imageConfigContext = __webpack_require__(/*! ../shared/lib/image-config-context */ \"./node_modules/next/dist/shared/lib/image-config-context.js\");\n\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\n\nvar _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\n\nfunction Image(_param) {\n  _s();\n\n  var src = _param.src,\n      sizes = _param.sizes,\n      _unoptimized = _param.unoptimized,\n      unoptimized = _unoptimized === void 0 ? false : _unoptimized,\n      _priority = _param.priority,\n      priority = _priority === void 0 ? false : _priority,\n      loading = _param.loading,\n      _lazyRoot = _param.lazyRoot,\n      lazyRoot = _lazyRoot === void 0 ? null : _lazyRoot,\n      lazyBoundary = _param.lazyBoundary,\n      className = _param.className,\n      quality = _param.quality,\n      width = _param.width,\n      height = _param.height,\n      style = _param.style,\n      objectFit = _param.objectFit,\n      objectPosition = _param.objectPosition,\n      onLoadingComplete = _param.onLoadingComplete,\n      _placeholder = _param.placeholder,\n      placeholder = _placeholder === void 0 ? \"empty\" : _placeholder,\n      blurDataURL = _param.blurDataURL,\n      all = _object_without_properties_loose(_param, [\"src\", \"sizes\", \"unoptimized\", \"priority\", \"loading\", \"lazyRoot\", \"lazyBoundary\", \"className\", \"quality\", \"width\", \"height\", \"style\", \"objectFit\", \"objectPosition\", \"onLoadingComplete\", \"placeholder\", \"blurDataURL\"]);\n\n  var configContext = (0, _react).useContext(_imageConfigContext.ImageConfigContext);\n  var config = (0, _react).useMemo(function () {\n    var c = configEnv || configContext || _imageConfig.imageConfigDefault;\n\n    var allSizes = _toConsumableArray(c.deviceSizes).concat(_toConsumableArray(c.imageSizes)).sort(function (a, b) {\n      return a - b;\n    });\n\n    var deviceSizes = c.deviceSizes.sort(function (a, b) {\n      return a - b;\n    });\n    return _extends({}, c, {\n      allSizes: allSizes,\n      deviceSizes: deviceSizes\n    });\n  }, [configContext]);\n  var rest = all;\n  var layout = sizes ? \"responsive\" : \"intrinsic\";\n\n  if (\"layout\" in rest) {\n    // Override default layout if the user specified one:\n    if (rest.layout) layout = rest.layout; // Remove property so it's not spread on <img>:\n\n    delete rest.layout;\n  }\n\n  var loader = defaultImageLoader;\n\n  if (\"loader\" in rest) {\n    if (rest.loader) {\n      var customImageLoader = rest.loader;\n\n      var _tmp;\n\n      _tmp = function (obj) {\n        var _ = obj.config,\n            opts = _object_without_properties_loose(obj, [\"config\"]); // The config object is internal only so we must\n        // not pass it to the user-defined loader()\n\n\n        return customImageLoader(opts);\n      }, loader = _tmp, _tmp;\n    } // Remove property so it's not spread on <img>\n\n\n    delete rest.loader;\n  }\n\n  var staticSrc = \"\";\n\n  if (isStaticImport(src)) {\n    var staticImageData = isStaticRequire(src) ? src.default : src;\n\n    if (!staticImageData.src) {\n      throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \".concat(JSON.stringify(staticImageData)));\n    }\n\n    blurDataURL = blurDataURL || staticImageData.blurDataURL;\n    staticSrc = staticImageData.src;\n\n    if (!layout || layout !== \"fill\") {\n      height = height || staticImageData.height;\n      width = width || staticImageData.width;\n\n      if (!staticImageData.height || !staticImageData.width) {\n        throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \".concat(JSON.stringify(staticImageData)));\n      }\n    }\n  }\n\n  src = typeof src === \"string\" ? src : staticSrc;\n  var isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n\n  if (src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n    unoptimized = true;\n    isLazy = false;\n  }\n\n  if ( true && loadedImageURLs.has(src)) {\n    isLazy = false;\n  }\n\n  if (config.unoptimized) {\n    unoptimized = true;\n  }\n\n  var ref = _slicedToArray((0, _react).useState(false), 2),\n      blurComplete = ref[0],\n      setBlurComplete = ref[1];\n\n  var ref1 = _slicedToArray((0, _useIntersection).useIntersection({\n    rootRef: lazyRoot,\n    rootMargin: lazyBoundary || \"200px\",\n    disabled: !isLazy\n  }), 3),\n      setIntersection = ref1[0],\n      isIntersected = ref1[1],\n      resetIntersected = ref1[2];\n\n  var isVisible = !isLazy || isIntersected;\n  var wrapperStyle = {\n    boxSizing: \"border-box\",\n    display: \"block\",\n    overflow: \"hidden\",\n    width: \"initial\",\n    height: \"initial\",\n    background: \"none\",\n    opacity: 1,\n    border: 0,\n    margin: 0,\n    padding: 0\n  };\n  var sizerStyle = {\n    boxSizing: \"border-box\",\n    display: \"block\",\n    width: \"initial\",\n    height: \"initial\",\n    background: \"none\",\n    opacity: 1,\n    border: 0,\n    margin: 0,\n    padding: 0\n  };\n  var hasSizer = false;\n  var sizerSvgUrl;\n  var layoutStyle = {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0,\n    boxSizing: \"border-box\",\n    padding: 0,\n    border: \"none\",\n    margin: \"auto\",\n    display: \"block\",\n    width: 0,\n    height: 0,\n    minWidth: \"100%\",\n    maxWidth: \"100%\",\n    minHeight: \"100%\",\n    maxHeight: \"100%\",\n    objectFit: objectFit,\n    objectPosition: objectPosition\n  };\n  var widthInt = getInt(width);\n  var heightInt = getInt(height);\n  var qualityInt = getInt(quality);\n\n  if (true) {\n    if (!src) {\n      // React doesn't show the stack trace and there's\n      // no `src` to help identify which image, so we\n      // instead console.error(ref) during mount.\n      widthInt = widthInt || 1;\n      heightInt = heightInt || 1;\n      unoptimized = true;\n    } else {\n      if (!VALID_LAYOUT_VALUES.includes(layout)) {\n        if (layout === \"raw\") {\n          throw new Error('The layout=\"raw\" experiment has been moved to a new module. Please import `next/future/image` instead.');\n        }\n\n        throw new Error('Image with src \"'.concat(src, '\" has invalid \"layout\" property. Provided \"').concat(layout, '\" should be one of ').concat(VALID_LAYOUT_VALUES.map(String).join(\",\"), \".\"));\n      }\n\n      if (typeof widthInt !== \"undefined\" && isNaN(widthInt) || typeof heightInt !== \"undefined\" && isNaN(heightInt)) {\n        throw new Error('Image with src \"'.concat(src, '\" has invalid \"width\" or \"height\" property. These should be numeric values.'));\n      }\n\n      if (layout === \"fill\" && (width || height)) {\n        (0, _utils).warnOnce('Image with src \"'.concat(src, '\" and \"layout=\\'fill\\'\" has unused properties assigned. Please remove \"width\" and \"height\".'));\n      }\n\n      if (!VALID_LOADING_VALUES.includes(loading)) {\n        throw new Error('Image with src \"'.concat(src, '\" has invalid \"loading\" property. Provided \"').concat(loading, '\" should be one of ').concat(VALID_LOADING_VALUES.map(String).join(\",\"), \".\"));\n      }\n\n      if (priority && loading === \"lazy\") {\n        throw new Error('Image with src \"'.concat(src, '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.'));\n      }\n\n      if (sizes && layout !== \"fill\" && layout !== \"responsive\") {\n        (0, _utils).warnOnce('Image with src \"'.concat(src, '\" has \"sizes\" property but it will be ignored. Only use \"sizes\" with \"layout=\\'fill\\'\" or \"layout=\\'responsive\\'\"'));\n      }\n\n      if (placeholder === \"blur\") {\n        if (layout !== \"fill\" && (widthInt || 0) * (heightInt || 0) < 1600) {\n          (0, _utils).warnOnce('Image with src \"'.concat(src, '\" is smaller than 40x40. Consider removing the \"placeholder=\\'blur\\'\" property to improve performance.'));\n        }\n\n        if (!blurDataURL) {\n          var VALID_BLUR_EXT = [\"jpeg\", \"png\", \"webp\", \"avif\"] // should match next-image-loader\n          ;\n          throw new Error('Image with src \"'.concat(src, '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n          Possible solutions:\\n            - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n            - Change the \"src\" property to a static import with one of the supported file types: ').concat(VALID_BLUR_EXT.join(\",\"), '\\n            - Remove the \"placeholder\" property, effectively no blur effect\\n          Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url'));\n        }\n      }\n\n      if (\"ref\" in rest) {\n        (0, _utils).warnOnce('Image with src \"'.concat(src, '\" is using unsupported \"ref\" property. Consider using the \"onLoadingComplete\" property instead.'));\n      }\n\n      if (!unoptimized && loader !== defaultImageLoader) {\n        var urlStr = loader({\n          config: config,\n          src: src,\n          width: widthInt || 400,\n          quality: qualityInt || 75\n        });\n        var url;\n\n        try {\n          url = new URL(urlStr);\n        } catch (err) {}\n\n        if (urlStr === src || url && url.pathname === src && !url.search) {\n          (0, _utils).warnOnce('Image with src \"'.concat(src, '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.') + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n        }\n      }\n\n      if (style) {\n        var overwrittenStyles = Object.keys(style).filter(function (key) {\n          return key in layoutStyle;\n        });\n\n        if (overwrittenStyles.length) {\n          (0, _utils).warnOnce(\"Image with src \".concat(src, \" is assigned the following styles, which are overwritten by automatically-generated styles: \").concat(overwrittenStyles.join(\", \")));\n        }\n      }\n\n      if ( true && !perfObserver && window.PerformanceObserver) {\n        perfObserver = new PerformanceObserver(function (entryList) {\n          var _iteratorNormalCompletion = true,\n              _didIteratorError = false,\n              _iteratorError = undefined;\n\n          try {\n            for (var _iterator = entryList.getEntries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var entry = _step.value;\n              var ref; // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n\n              var imgSrc = (entry == null ? void 0 : (ref = entry.element) == null ? void 0 : ref.src) || \"\";\n              var lcpImage = allImgs.get(imgSrc);\n\n              if (lcpImage && !lcpImage.priority && lcpImage.placeholder !== \"blur\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                // https://web.dev/lcp/#measure-lcp-in-javascript\n                (0, _utils).warnOnce('Image with src \"'.concat(lcpImage.src, '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.') + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        });\n\n        try {\n          perfObserver.observe({\n            type: \"largest-contentful-paint\",\n            buffered: true\n          });\n        } catch (err1) {\n          // Log error but don't crash the app\n          console.error(err1);\n        }\n      }\n    }\n  }\n\n  var imgStyle = Object.assign({}, style, layoutStyle);\n  var blurStyle = placeholder === \"blur\" && !blurComplete ? {\n    backgroundSize: objectFit || \"cover\",\n    backgroundPosition: objectPosition || \"0% 0%\",\n    filter: \"blur(20px)\",\n    backgroundImage: 'url(\"'.concat(blurDataURL, '\")')\n  } : {};\n\n  if (layout === \"fill\") {\n    // <Image src=\"i.png\" layout=\"fill\" />\n    wrapperStyle.display = \"block\";\n    wrapperStyle.position = \"absolute\";\n    wrapperStyle.top = 0;\n    wrapperStyle.left = 0;\n    wrapperStyle.bottom = 0;\n    wrapperStyle.right = 0;\n  } else if (typeof widthInt !== \"undefined\" && typeof heightInt !== \"undefined\") {\n    // <Image src=\"i.png\" width=\"100\" height=\"100\" />\n    var quotient = heightInt / widthInt;\n    var paddingTop = isNaN(quotient) ? \"100%\" : \"\".concat(quotient * 100, \"%\");\n\n    if (layout === \"responsive\") {\n      // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"responsive\" />\n      wrapperStyle.display = \"block\";\n      wrapperStyle.position = \"relative\";\n      hasSizer = true;\n      sizerStyle.paddingTop = paddingTop;\n    } else if (layout === \"intrinsic\") {\n      // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"intrinsic\" />\n      wrapperStyle.display = \"inline-block\";\n      wrapperStyle.position = \"relative\";\n      wrapperStyle.maxWidth = \"100%\";\n      hasSizer = true;\n      sizerStyle.maxWidth = \"100%\";\n      sizerSvgUrl = \"data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27\".concat(widthInt, \"%27%20height=%27\").concat(heightInt, \"%27/%3e\");\n    } else if (layout === \"fixed\") {\n      // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"fixed\" />\n      wrapperStyle.display = \"inline-block\";\n      wrapperStyle.position = \"relative\";\n      wrapperStyle.width = widthInt;\n      wrapperStyle.height = heightInt;\n    }\n  } else {\n    // <Image src=\"i.png\" />\n    if (true) {\n      throw new Error('Image with src \"'.concat(src, '\" must use \"width\" and \"height\" properties or \"layout=\\'fill\\'\" property.'));\n    }\n  }\n\n  var imgAttributes = {\n    src: emptyDataURL,\n    srcSet: undefined,\n    sizes: undefined\n  };\n\n  if (isVisible) {\n    imgAttributes = generateImgAttrs({\n      config: config,\n      src: src,\n      unoptimized: unoptimized,\n      layout: layout,\n      width: widthInt,\n      quality: qualityInt,\n      sizes: sizes,\n      loader: loader\n    });\n  }\n\n  var srcString = src;\n\n  if (true) {\n    if (true) {\n      var fullUrl;\n\n      try {\n        fullUrl = new URL(imgAttributes.src);\n      } catch (e) {\n        fullUrl = new URL(imgAttributes.src, window.location.href);\n      }\n\n      allImgs.set(fullUrl.href, {\n        src: src,\n        priority: priority,\n        placeholder: placeholder\n      });\n    }\n  }\n\n  var imageSrcSetPropName = \"imagesrcset\";\n  var imageSizesPropName = \"imagesizes\";\n\n  if (false) {}\n\n  var _obj;\n\n  var linkProps = (_obj = {}, // Note: imagesrcset and imagesizes are not in the link element type with react 17.\n  _defineProperty(_obj, imageSrcSetPropName, imgAttributes.srcSet), _defineProperty(_obj, imageSizesPropName, imgAttributes.sizes), _defineProperty(_obj, \"crossOrigin\", rest.crossOrigin), _obj);\n  var useLayoutEffect =  false ? 0 : _react.default.useLayoutEffect;\n  var onLoadingCompleteRef = (0, _react).useRef(onLoadingComplete);\n  var previousImageSrc = (0, _react).useRef(src);\n  (0, _react).useEffect(function () {\n    onLoadingCompleteRef.current = onLoadingComplete;\n  }, [onLoadingComplete]);\n  useLayoutEffect(function () {\n    if (previousImageSrc.current !== src) {\n      resetIntersected();\n      previousImageSrc.current = src;\n    }\n  }, [resetIntersected, src]);\n\n  var imgElementArgs = _extends({\n    isLazy: isLazy,\n    imgAttributes: imgAttributes,\n    heightInt: heightInt,\n    widthInt: widthInt,\n    qualityInt: qualityInt,\n    layout: layout,\n    className: className,\n    imgStyle: imgStyle,\n    blurStyle: blurStyle,\n    loading: loading,\n    config: config,\n    unoptimized: unoptimized,\n    placeholder: placeholder,\n    loader: loader,\n    srcString: srcString,\n    onLoadingCompleteRef: onLoadingCompleteRef,\n    setBlurComplete: setBlurComplete,\n    setIntersection: setIntersection,\n    isVisible: isVisible,\n    noscriptSizes: sizes\n  }, rest);\n\n  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"span\", {\n    style: wrapperStyle\n  }, hasSizer ? /*#__PURE__*/_react.default.createElement(\"span\", {\n    style: sizerStyle\n  }, sizerSvgUrl ? /*#__PURE__*/_react.default.createElement(\"img\", {\n    style: {\n      display: \"block\",\n      maxWidth: \"100%\",\n      width: \"initial\",\n      height: \"initial\",\n      background: \"none\",\n      opacity: 1,\n      border: 0,\n      margin: 0,\n      padding: 0\n    },\n    alt: \"\",\n    \"aria-hidden\": true,\n    src: sizerSvgUrl\n  }) : null) : null, /*#__PURE__*/_react.default.createElement(ImageElement, Object.assign({}, imgElementArgs))), priority ? // for browsers that do not support `imagesrcset`, and in those cases\n  // it would likely cause the incorrect image to be preloaded.\n  //\n  // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n\n  /*#__PURE__*/\n  _react.default.createElement(_head.default, null, /*#__PURE__*/_react.default.createElement(\"link\", Object.assign({\n    key: \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes,\n    rel: \"preload\",\n    as: \"image\",\n    href: imgAttributes.srcSet ? undefined : imgAttributes.src\n  }, linkProps))) : null);\n}\n\n_s(Image, \"JC32V8ZswcgqIp1SSTncST29uwM=\");\n\n_c = Image;\n\"client\";\n\nfunction normalizeSrc(src) {\n  return src[0] === \"/\" ? src.slice(1) : src;\n}\n\nvar configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[\"lh3.googleusercontent.com\",\"avatars.githubusercontent.com\",\"imagedelivery.net\"],\"remotePatterns\":[]};\nvar loadedImageURLs = new Set();\nvar allImgs = new Map();\nvar perfObserver;\nvar emptyDataURL = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n\nif (false) {}\n\nvar VALID_LOADING_VALUES = [\"lazy\", \"eager\", undefined];\n\nfunction imgixLoader(param) {\n  var config = param.config,\n      src = param.src,\n      width = param.width,\n      quality = param.quality; // Demo: https://static.imgix.net/daisy.png?auto=format&fit=max&w=300\n\n  var url = new URL(\"\".concat(config.path).concat(normalizeSrc(src)));\n  var params = url.searchParams; // auto params can be combined with comma separation, or reiteration\n\n  params.set(\"auto\", params.getAll(\"auto\").join(\",\") || \"format\");\n  params.set(\"fit\", params.get(\"fit\") || \"max\");\n  params.set(\"w\", params.get(\"w\") || width.toString());\n\n  if (quality) {\n    params.set(\"q\", quality.toString());\n  }\n\n  return url.href;\n}\n\nfunction akamaiLoader(param) {\n  var config = param.config,\n      src = param.src,\n      width = param.width;\n  return \"\".concat(config.path).concat(normalizeSrc(src), \"?imwidth=\").concat(width);\n}\n\nfunction cloudinaryLoader(param) {\n  var config = param.config,\n      src = param.src,\n      width = param.width,\n      quality = param.quality; // Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg\n\n  var params = [\"f_auto\", \"c_limit\", \"w_\" + width, \"q_\" + (quality || \"auto\")];\n  var paramsString = params.join(\",\") + \"/\";\n  return \"\".concat(config.path).concat(paramsString).concat(normalizeSrc(src));\n}\n\nfunction customLoader(param) {\n  var src = param.src;\n  throw new Error('Image with src \"'.concat(src, '\" is missing \"loader\" prop.') + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n}\n\nfunction defaultLoader(param) {\n  var config = param.config,\n      src = param.src,\n      width = param.width,\n      quality = param.quality;\n\n  if (true) {\n    var missingValues = []; // these should always be provided but make sure they are\n\n    if (!src) missingValues.push(\"src\");\n    if (!width) missingValues.push(\"width\");\n\n    if (missingValues.length > 0) {\n      throw new Error(\"Next Image Optimization requires \".concat(missingValues.join(\", \"), \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \").concat(JSON.stringify({\n        src: src,\n        width: width,\n        quality: quality\n      })));\n    }\n\n    if (src.startsWith(\"//\")) {\n      throw new Error('Failed to parse src \"'.concat(src, '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)'));\n    }\n\n    if (!src.startsWith(\"/\") && (config.domains || config.remotePatterns)) {\n      var parsedSrc;\n\n      try {\n        parsedSrc = new URL(src);\n      } catch (err) {\n        console.error(err);\n        throw new Error('Failed to parse src \"'.concat(src, '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)'));\n      }\n\n      if (true) {\n        // We use dynamic require because this should only error in development\n        var hasMatch = (__webpack_require__(/*! ../shared/lib/match-remote-pattern */ \"./node_modules/next/dist/shared/lib/match-remote-pattern.js\").hasMatch);\n\n        if (!hasMatch(config.domains, config.remotePatterns, parsedSrc)) {\n          throw new Error(\"Invalid src prop (\".concat(src, ') on `next/image`, hostname \"').concat(parsedSrc.hostname, '\" is not configured under images in your `next.config.js`\\n') + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n        }\n      }\n    }\n  }\n\n  if (src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n    // Special case to make svg serve as-is to avoid proxying\n    // through the built-in Image Optimization API.\n    return src;\n  }\n\n  return \"\".concat((0, _normalizeTrailingSlash).normalizePathTrailingSlash(config.path), \"?url=\").concat(encodeURIComponent(src), \"&w=\").concat(width, \"&q=\").concat(quality || 75);\n}\n\nvar loaders = new Map([[\"default\", defaultLoader], [\"imgix\", imgixLoader], [\"cloudinary\", cloudinaryLoader], [\"akamai\", akamaiLoader], [\"custom\", customLoader]]);\nvar VALID_LAYOUT_VALUES = [\"fill\", \"fixed\", \"intrinsic\", \"responsive\", undefined];\n\nfunction isStaticRequire(src) {\n  return src.default !== undefined;\n}\n\nfunction isStaticImageData(src) {\n  return src.src !== undefined;\n}\n\nfunction isStaticImport(src) {\n  return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\n\nfunction getWidths(param, width, layout, sizes) {\n  var deviceSizes = param.deviceSizes,\n      allSizes = param.allSizes;\n\n  if (sizes && (layout === \"fill\" || layout === \"responsive\")) {\n    // Find all the \"vw\" percent sizes used in the sizes prop\n    var viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n    var percentSizes = [];\n\n    for (var match; match = viewportWidthRe.exec(sizes); match) {\n      percentSizes.push(parseInt(match[2]));\n    }\n\n    if (percentSizes.length) {\n      var _Math;\n\n      var smallestRatio = (_Math = Math).min.apply(_Math, _toConsumableArray(percentSizes)) * 0.01;\n      return {\n        widths: allSizes.filter(function (s) {\n          return s >= deviceSizes[0] * smallestRatio;\n        }),\n        kind: \"w\"\n      };\n    }\n\n    return {\n      widths: allSizes,\n      kind: \"w\"\n    };\n  }\n\n  if (typeof width !== \"number\" || layout === \"fill\" || layout === \"responsive\") {\n    return {\n      widths: deviceSizes,\n      kind: \"w\"\n    };\n  }\n\n  var widths = _toConsumableArray(new Set( // > are actually 3x in the green color, but only 1.5x in the red and\n  // > blue colors. Showing a 3x resolution image in the app vs a 2x\n  // > resolution image will be visually the same, though the 3x image\n  // > takes significantly more data. Even true 3x resolution screens are\n  // > wasteful as the human eye cannot see that level of detail without\n  // > something like a magnifying glass.\n  // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n  [width, width * 2\n  /*, width * 3*/\n  ].map(function (w) {\n    return allSizes.find(function (p) {\n      return p >= w;\n    }) || allSizes[allSizes.length - 1];\n  })));\n\n  return {\n    widths: widths,\n    kind: \"x\"\n  };\n}\n\nfunction generateImgAttrs(param) {\n  var config = param.config,\n      src = param.src,\n      unoptimized = param.unoptimized,\n      layout = param.layout,\n      width = param.width,\n      quality = param.quality,\n      sizes = param.sizes,\n      loader = param.loader;\n\n  if (unoptimized) {\n    return {\n      src: src,\n      srcSet: undefined,\n      sizes: undefined\n    };\n  }\n\n  var ref = getWidths(config, width, layout, sizes),\n      widths = ref.widths,\n      kind = ref.kind;\n  var last = widths.length - 1;\n  return {\n    sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n    srcSet: widths.map(function (w, i) {\n      return \"\".concat(loader({\n        config: config,\n        src: src,\n        quality: quality,\n        width: w\n      }), \" \").concat(kind === \"w\" ? w : i + 1).concat(kind);\n    }).join(\", \"),\n    // It's intended to keep `src` the last attribute because React updates\n    // attributes in order. If we keep `src` the first one, Safari will\n    // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n    // updated by React. That causes multiple unnecessary requests if `srcSet`\n    // and `sizes` are defined.\n    // This bug cannot be reproduced in Chrome or Firefox.\n    src: loader({\n      config: config,\n      src: src,\n      quality: quality,\n      width: widths[last]\n    })\n  };\n}\n\nfunction getInt(x) {\n  if (typeof x === \"number\") {\n    return x;\n  }\n\n  if (typeof x === \"string\") {\n    return parseInt(x, 10);\n  }\n\n  return undefined;\n}\n\nfunction defaultImageLoader(loaderProps) {\n  var ref;\n  var loaderKey = ((ref = loaderProps.config) == null ? void 0 : ref.loader) || \"default\";\n  var load = loaders.get(loaderKey);\n\n  if (load) {\n    return load(loaderProps);\n  }\n\n  throw new Error('Unknown \"loader\" found in \"next.config.js\". Expected: '.concat(_imageConfig.VALID_LOADERS.join(\", \"), \". Received: \").concat(loaderKey));\n} // See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\n\n\nfunction handleLoading(img, src, layout, placeholder, onLoadingCompleteRef, setBlurComplete) {\n  if (!img || img.src === emptyDataURL || img[\"data-loaded-src\"] === src) {\n    return;\n  }\n\n  img[\"data-loaded-src\"] = src;\n  var p = \"decode\" in img ? img.decode() : Promise.resolve();\n  p.catch(function () {}).then(function () {\n    if (!img.parentNode) {\n      // Exit early in case of race condition:\n      // - onload() is called\n      // - decode() is called but incomplete\n      // - unmount is called\n      // - decode() completes\n      return;\n    }\n\n    loadedImageURLs.add(src);\n\n    if (placeholder === \"blur\") {\n      setBlurComplete(true);\n    }\n\n    if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n      var naturalWidth = img.naturalWidth,\n          naturalHeight = img.naturalHeight; // Pass back read-only primitive values but not the\n      // underlying DOM element because it could be misused.\n\n      onLoadingCompleteRef.current({\n        naturalWidth: naturalWidth,\n        naturalHeight: naturalHeight\n      });\n    }\n\n    if (true) {\n      var ref;\n\n      if ((ref = img.parentElement) == null ? void 0 : ref.parentElement) {\n        var parent = getComputedStyle(img.parentElement.parentElement);\n\n        if (!parent.position) {// The parent has not been rendered to the dom yet and therefore it has no position. Skip the warnings for such cases.\n        } else if (layout === \"responsive\" && parent.display === \"flex\") {\n          (0, _utils).warnOnce('Image with src \"'.concat(src, '\" may not render properly as a child of a flex container. Consider wrapping the image with a div to configure the width.'));\n        } else if (layout === \"fill\" && parent.position !== \"relative\" && parent.position !== \"fixed\" && parent.position !== \"absolute\") {\n          (0, _utils).warnOnce('Image with src \"'.concat(src, '\" may not render properly with a parent using position:\"').concat(parent.position, '\". Consider changing the parent style to position:\"relative\" with a width and height.'));\n        }\n      }\n    }\n  });\n}\n\nvar ImageElement = function (_param) {\n  _s1();\n\n  var imgAttributes = _param.imgAttributes,\n      heightInt = _param.heightInt,\n      widthInt = _param.widthInt,\n      qualityInt = _param.qualityInt,\n      layout = _param.layout,\n      className = _param.className,\n      imgStyle = _param.imgStyle,\n      blurStyle = _param.blurStyle,\n      isLazy = _param.isLazy,\n      placeholder = _param.placeholder,\n      loading = _param.loading,\n      srcString = _param.srcString,\n      config = _param.config,\n      unoptimized = _param.unoptimized,\n      loader = _param.loader,\n      onLoadingCompleteRef = _param.onLoadingCompleteRef,\n      setBlurComplete = _param.setBlurComplete,\n      setIntersection = _param.setIntersection,\n      onLoad = _param.onLoad,\n      onError = _param.onError,\n      isVisible = _param.isVisible,\n      noscriptSizes = _param.noscriptSizes,\n      rest = _object_without_properties_loose(_param, [\"imgAttributes\", \"heightInt\", \"widthInt\", \"qualityInt\", \"layout\", \"className\", \"imgStyle\", \"blurStyle\", \"isLazy\", \"placeholder\", \"loading\", \"srcString\", \"config\", \"unoptimized\", \"loader\", \"onLoadingCompleteRef\", \"setBlurComplete\", \"setIntersection\", \"onLoad\", \"onError\", \"isVisible\", \"noscriptSizes\"]);\n\n  loading = isLazy ? \"lazy\" : loading;\n  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(\"img\", Object.assign({}, rest, imgAttributes, {\n    decoding: \"async\",\n    \"data-nimg\": layout,\n    className: className,\n    style: _extends({}, imgStyle, blurStyle),\n    ref: (0, _react).useCallback(function (img) {\n      if (true) {\n        if (img && !srcString) {\n          console.error('Image is missing required \"src\" property:', img);\n        }\n      }\n\n      setIntersection(img);\n\n      if (img == null ? void 0 : img.complete) {\n        handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);\n      }\n    }, [setIntersection, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete]),\n    onLoad: function (event) {\n      var img = event.currentTarget;\n      handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);\n\n      if (onLoad) {\n        onLoad(event);\n      }\n    },\n    onError: function (event) {\n      if (placeholder === \"blur\") {\n        // If the real image fails to load, this will still remove the placeholder.\n        setBlurComplete(true);\n      }\n\n      if (onError) {\n        onError(event);\n      }\n    }\n  })), (isLazy || placeholder === \"blur\") && /*#__PURE__*/_react.default.createElement(\"noscript\", null, /*#__PURE__*/_react.default.createElement(\"img\", Object.assign({}, rest, generateImgAttrs({\n    config: config,\n    src: srcString,\n    unoptimized: unoptimized,\n    layout: layout,\n    width: widthInt,\n    quality: qualityInt,\n    sizes: noscriptSizes,\n    loader: loader\n  }), {\n    decoding: \"async\",\n    \"data-nimg\": layout,\n    style: imgStyle,\n    className: className,\n    // @ts-ignore - TODO: upgrade to `@types/react@17`\n    loading: loading\n  }))));\n};\n\n_s1(ImageElement, \"epj4qY15NHsef74wNqHIp5fdZmg=\");\n\n_c1 = ImageElement;\n\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n  Object.defineProperty(exports.default, \"__esModule\", {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n} //# sourceMappingURL=image.js.map\n\n\nvar _c, _c1;\n\n$RefreshReg$(_c, \"Image\");\n$RefreshReg$(_c1, \"ImageElement\");\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTs7Ozs7Ozs7Ozs7Ozs7O0FBRGI7QUFFQUEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0NILEVBQUFBO0FBR0FFLGtCQUFBQSxHQUFrQkcsS0FBbEJIOztBQUNBLElBQUlJLFFBQVEsR0FBR0MsbUhBQWY7O0FBQ0EsSUFBSUMsd0JBQXdCLEdBQUdELG1KQUEvQjs7QUFDQSxJQUFJRSx5QkFBeUIsR0FBR0YscUpBQWhDOztBQUNBLElBQUlHLGdDQUFnQyxHQUFHSCxtS0FBdkM7O0FBQ0EsSUFBSUksTUFBTSxHQUFHRix5QkFBeUIsQ0FBQ0YsbUJBQU8sQ0FBQyw0Q0FBRCxDQUFSLENBQXRDOztBQUNBLElBQUlLLEtBQUssR0FBR0osd0JBQXdCLENBQUNELG1CQUFPLENBQUMsdUVBQUQsQ0FBUixDQUFwQzs7QUFDQSxJQUFJTSxZQUFZLEdBQUdOLG1CQUFPLENBQUMsdUZBQUQsQ0FBMUI7O0FBQ0EsSUFBSU8sZ0JBQWdCLEdBQUdQLG1CQUFPLENBQUMsK0VBQUQsQ0FBOUI7O0FBQ0EsSUFBSVEsbUJBQW1CLEdBQUdSLG1CQUFPLENBQUMsdUdBQUQsQ0FBakM7O0FBQ0EsSUFBSVMsTUFBTSxHQUFHVCxtQkFBTyxDQUFDLHlFQUFELENBQXBCOztBQUNBLElBQUlVLHVCQUF1QixHQUFHVixtQkFBTyxDQUFDLCtGQUFELENBQXJDOztBQUNBLFNBQVNGLEtBQVQsQ0FBZWEsTUFBZixFQUF1Qjs7O0VBQ25CLElBQU1DLEdBQUcsR0FBb09ELE1BQU0sQ0FBN09DLEdBQU47RUFBQSxJQUFZQyxLQUFLLEdBQTRORixNQUFNLENBQXZPRSxLQUFaO0VBQUEsSUFBaUJDLGVBQTROSCxNQUFNLENBQS9OSSxXQUFwQjtFQUFBLElBQW9CQSxXQUFXLDZCQUFFLEtBQUYsR0FBT0QsWUFBdEM7RUFBQSxJQUFzQ0UsWUFBdU1MLE1BQU0sQ0FBMU1NLFFBQXpDO0VB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PzgyZjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSW1hZ2U7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZS5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfaGVhZCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9oZWFkXCIpKTtcbnZhciBfaW1hZ2VDb25maWcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWdcIik7XG52YXIgX3VzZUludGVyc2VjdGlvbiA9IHJlcXVpcmUoXCIuL3VzZS1pbnRlcnNlY3Rpb25cIik7XG52YXIgX2ltYWdlQ29uZmlnQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0XCIpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzXCIpO1xudmFyIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoXCIpO1xuZnVuY3Rpb24gSW1hZ2UoX3BhcmFtKSB7XG4gICAgdmFyIHsgc3JjICwgc2l6ZXMgLCB1bm9wdGltaXplZCA9ZmFsc2UgLCBwcmlvcml0eSA9ZmFsc2UgLCBsb2FkaW5nICwgbGF6eVJvb3QgPW51bGwgLCBsYXp5Qm91bmRhcnkgLCBjbGFzc05hbWUgLCBxdWFsaXR5ICwgd2lkdGggLCBoZWlnaHQgLCBzdHlsZSAsIG9iamVjdEZpdCAsIG9iamVjdFBvc2l0aW9uICwgb25Mb2FkaW5nQ29tcGxldGUgLCBwbGFjZWhvbGRlciA9J2VtcHR5JyAsIGJsdXJEYXRhVVJMICB9ID0gX3BhcmFtLCBhbGwgPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShfcGFyYW0sIFtcbiAgICAgICAgXCJzcmNcIixcbiAgICAgICAgXCJzaXplc1wiLFxuICAgICAgICBcInVub3B0aW1pemVkXCIsXG4gICAgICAgIFwicHJpb3JpdHlcIixcbiAgICAgICAgXCJsb2FkaW5nXCIsXG4gICAgICAgIFwibGF6eVJvb3RcIixcbiAgICAgICAgXCJsYXp5Qm91bmRhcnlcIixcbiAgICAgICAgXCJjbGFzc05hbWVcIixcbiAgICAgICAgXCJxdWFsaXR5XCIsXG4gICAgICAgIFwid2lkdGhcIixcbiAgICAgICAgXCJoZWlnaHRcIixcbiAgICAgICAgXCJzdHlsZVwiLFxuICAgICAgICBcIm9iamVjdEZpdFwiLFxuICAgICAgICBcIm9iamVjdFBvc2l0aW9uXCIsXG4gICAgICAgIFwib25Mb2FkaW5nQ29tcGxldGVcIixcbiAgICAgICAgXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICBcImJsdXJEYXRhVVJMXCJcbiAgICBdKTtcbiAgICBjb25zdCBjb25maWdDb250ZXh0ID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfaW1hZ2VDb25maWdDb250ZXh0LkltYWdlQ29uZmlnQ29udGV4dCk7XG4gICAgY29uc3QgY29uZmlnID0gKDAsIF9yZWFjdCkudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCBjID0gY29uZmlnRW52IHx8IGNvbmZpZ0NvbnRleHQgfHwgX2ltYWdlQ29uZmlnLmltYWdlQ29uZmlnRGVmYXVsdDtcbiAgICAgICAgY29uc3QgYWxsU2l6ZXMgPSBbXG4gICAgICAgICAgICAuLi5jLmRldmljZVNpemVzLFxuICAgICAgICAgICAgLi4uYy5pbWFnZVNpemVzXG4gICAgICAgIF0uc29ydCgoYSwgYik9PmEgLSBiKTtcbiAgICAgICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBjLmRldmljZVNpemVzLnNvcnQoKGEsIGIpPT5hIC0gYik7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYywge1xuICAgICAgICAgICAgYWxsU2l6ZXMsXG4gICAgICAgICAgICBkZXZpY2VTaXplc1xuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIGNvbmZpZ0NvbnRleHRcbiAgICBdKTtcbiAgICBsZXQgcmVzdCA9IGFsbDtcbiAgICBsZXQgbGF5b3V0ID0gc2l6ZXMgPyAncmVzcG9uc2l2ZScgOiAnaW50cmluc2ljJztcbiAgICBpZiAoJ2xheW91dCcgaW4gcmVzdCkge1xuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0IGxheW91dCBpZiB0aGUgdXNlciBzcGVjaWZpZWQgb25lOlxuICAgICAgICBpZiAocmVzdC5sYXlvdXQpIGxheW91dCA9IHJlc3QubGF5b3V0O1xuICAgICAgICAvLyBSZW1vdmUgcHJvcGVydHkgc28gaXQncyBub3Qgc3ByZWFkIG9uIDxpbWc+OlxuICAgICAgICBkZWxldGUgcmVzdC5sYXlvdXQ7XG4gICAgfVxuICAgIGxldCBsb2FkZXIgPSBkZWZhdWx0SW1hZ2VMb2FkZXI7XG4gICAgaWYgKCdsb2FkZXInIGluIHJlc3QpIHtcbiAgICAgICAgaWYgKHJlc3QubG9hZGVyKSB7XG4gICAgICAgICAgICBjb25zdCBjdXN0b21JbWFnZUxvYWRlciA9IHJlc3QubG9hZGVyO1xuICAgICAgICAgICAgdmFyIF90bXA7XG4gICAgICAgICAgICBfdG1wID0gKG9iaik9PntcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvbmZpZzogXyAgfSA9IG9iaiwgb3B0cyA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKG9iaiwgW1xuICAgICAgICAgICAgICAgICAgICBcImNvbmZpZ1wiXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbmZpZyBvYmplY3QgaXMgaW50ZXJuYWwgb25seSBzbyB3ZSBtdXN0XG4gICAgICAgICAgICAgICAgLy8gbm90IHBhc3MgaXQgdG8gdGhlIHVzZXItZGVmaW5lZCBsb2FkZXIoKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21JbWFnZUxvYWRlcihvcHRzKTtcbiAgICAgICAgICAgIH0sIGxvYWRlciA9IF90bXAsIF90bXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHByb3BlcnR5IHNvIGl0J3Mgbm90IHNwcmVhZCBvbiA8aW1nPlxuICAgICAgICBkZWxldGUgcmVzdC5sb2FkZXI7XG4gICAgfVxuICAgIGxldCBzdGF0aWNTcmMgPSAnJztcbiAgICBpZiAoaXNTdGF0aWNJbXBvcnQoc3JjKSkge1xuICAgICAgICBjb25zdCBzdGF0aWNJbWFnZURhdGEgPSBpc1N0YXRpY1JlcXVpcmUoc3JjKSA/IHNyYy5kZWZhdWx0IDogc3JjO1xuICAgICAgICBpZiAoIXN0YXRpY0ltYWdlRGF0YS5zcmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBzcmMuIFJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoc3RhdGljSW1hZ2VEYXRhKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBibHVyRGF0YVVSTCA9IGJsdXJEYXRhVVJMIHx8IHN0YXRpY0ltYWdlRGF0YS5ibHVyRGF0YVVSTDtcbiAgICAgICAgc3RhdGljU3JjID0gc3RhdGljSW1hZ2VEYXRhLnNyYztcbiAgICAgICAgaWYgKCFsYXlvdXQgfHwgbGF5b3V0ICE9PSAnZmlsbCcpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCBzdGF0aWNJbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgd2lkdGggPSB3aWR0aCB8fCBzdGF0aWNJbWFnZURhdGEud2lkdGg7XG4gICAgICAgICAgICBpZiAoIXN0YXRpY0ltYWdlRGF0YS5oZWlnaHQgfHwgIXN0YXRpY0ltYWdlRGF0YS53aWR0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBoZWlnaHQgYW5kIHdpZHRoLiBSZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHN0YXRpY0ltYWdlRGF0YSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3JjID0gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyBzcmMgOiBzdGF0aWNTcmM7XG4gICAgbGV0IGlzTGF6eSA9ICFwcmlvcml0eSAmJiAobG9hZGluZyA9PT0gJ2xhenknIHx8IHR5cGVvZiBsb2FkaW5nID09PSAndW5kZWZpbmVkJyk7XG4gICAgaWYgKHNyYy5zdGFydHNXaXRoKCdkYXRhOicpIHx8IHNyYy5zdGFydHNXaXRoKCdibG9iOicpKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvRGF0YV9VUklzXG4gICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgaXNMYXp5ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBsb2FkZWRJbWFnZVVSTHMuaGFzKHNyYykpIHtcbiAgICAgICAgaXNMYXp5ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjb25maWcudW5vcHRpbWl6ZWQpIHtcbiAgICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBbYmx1ckNvbXBsZXRlLCBzZXRCbHVyQ29tcGxldGVdID0gKDAsIF9yZWFjdCkudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtzZXRJbnRlcnNlY3Rpb24sIGlzSW50ZXJzZWN0ZWQsIHJlc2V0SW50ZXJzZWN0ZWRdID0gKDAsIF91c2VJbnRlcnNlY3Rpb24pLnVzZUludGVyc2VjdGlvbih7XG4gICAgICAgIHJvb3RSZWY6IGxhenlSb290LFxuICAgICAgICByb290TWFyZ2luOiBsYXp5Qm91bmRhcnkgfHwgJzIwMHB4JyxcbiAgICAgICAgZGlzYWJsZWQ6ICFpc0xhenlcbiAgICB9KTtcbiAgICBjb25zdCBpc1Zpc2libGUgPSAhaXNMYXp5IHx8IGlzSW50ZXJzZWN0ZWQ7XG4gICAgY29uc3Qgd3JhcHBlclN0eWxlID0ge1xuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICB3aWR0aDogJ2luaXRpYWwnLFxuICAgICAgICBoZWlnaHQ6ICdpbml0aWFsJyxcbiAgICAgICAgYmFja2dyb3VuZDogJ25vbmUnLFxuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgcGFkZGluZzogMFxuICAgIH07XG4gICAgY29uc3Qgc2l6ZXJTdHlsZSA9IHtcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgIHdpZHRoOiAnaW5pdGlhbCcsXG4gICAgICAgIGhlaWdodDogJ2luaXRpYWwnLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBwYWRkaW5nOiAwXG4gICAgfTtcbiAgICBsZXQgaGFzU2l6ZXIgPSBmYWxzZTtcbiAgICBsZXQgc2l6ZXJTdmdVcmw7XG4gICAgY29uc3QgbGF5b3V0U3R5bGUgPSB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgbWFyZ2luOiAnYXV0bycsXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIG1pbldpZHRoOiAnMTAwJScsXG4gICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgIG1pbkhlaWdodDogJzEwMCUnLFxuICAgICAgICBtYXhIZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgb2JqZWN0Rml0LFxuICAgICAgICBvYmplY3RQb3NpdGlvblxuICAgIH07XG4gICAgbGV0IHdpZHRoSW50ID0gZ2V0SW50KHdpZHRoKTtcbiAgICBsZXQgaGVpZ2h0SW50ID0gZ2V0SW50KGhlaWdodCk7XG4gICAgY29uc3QgcXVhbGl0eUludCA9IGdldEludChxdWFsaXR5KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgLy8gUmVhY3QgZG9lc24ndCBzaG93IHRoZSBzdGFjayB0cmFjZSBhbmQgdGhlcmUnc1xuICAgICAgICAgICAgLy8gbm8gYHNyY2AgdG8gaGVscCBpZGVudGlmeSB3aGljaCBpbWFnZSwgc28gd2VcbiAgICAgICAgICAgIC8vIGluc3RlYWQgY29uc29sZS5lcnJvcihyZWYpIGR1cmluZyBtb3VudC5cbiAgICAgICAgICAgIHdpZHRoSW50ID0gd2lkdGhJbnQgfHwgMTtcbiAgICAgICAgICAgIGhlaWdodEludCA9IGhlaWdodEludCB8fCAxO1xuICAgICAgICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFWQUxJRF9MQVlPVVRfVkFMVUVTLmluY2x1ZGVzKGxheW91dCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0ID09PSAncmF3Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBsYXlvdXQ9XCJyYXdcIiBleHBlcmltZW50IGhhcyBiZWVuIG1vdmVkIHRvIGEgbmV3IG1vZHVsZS4gUGxlYXNlIGltcG9ydCBcXGBuZXh0L2Z1dHVyZS9pbWFnZVxcYCBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGludmFsaWQgXCJsYXlvdXRcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCIke2xheW91dH1cIiBzaG91bGQgYmUgb25lIG9mICR7VkFMSURfTEFZT1VUX1ZBTFVFUy5tYXAoU3RyaW5nKS5qb2luKCcsJyl9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aWR0aEludCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYU4od2lkdGhJbnQpIHx8IHR5cGVvZiBoZWlnaHRJbnQgIT09ICd1bmRlZmluZWQnICYmIGlzTmFOKGhlaWdodEludCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGludmFsaWQgXCJ3aWR0aFwiIG9yIFwiaGVpZ2h0XCIgcHJvcGVydHkuIFRoZXNlIHNob3VsZCBiZSBudW1lcmljIHZhbHVlcy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXlvdXQgPT09ICdmaWxsJyAmJiAod2lkdGggfHwgaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbHMpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGFuZCBcImxheW91dD0nZmlsbCdcIiBoYXMgdW51c2VkIHByb3BlcnRpZXMgYXNzaWduZWQuIFBsZWFzZSByZW1vdmUgXCJ3aWR0aFwiIGFuZCBcImhlaWdodFwiLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFWQUxJRF9MT0FESU5HX1ZBTFVFUy5pbmNsdWRlcyhsb2FkaW5nKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcImxvYWRpbmdcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCIke2xvYWRpbmd9XCIgc2hvdWxkIGJlIG9uZSBvZiAke1ZBTElEX0xPQURJTkdfVkFMVUVTLm1hcChTdHJpbmcpLmpvaW4oJywnKX0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJpb3JpdHkgJiYgbG9hZGluZyA9PT0gJ2xhenknKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwicHJpb3JpdHlcIiBhbmQgXCJsb2FkaW5nPSdsYXp5J1wiIHByb3BlcnRpZXMuIE9ubHkgb25lIHNob3VsZCBiZSB1c2VkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNpemVzICYmIGxheW91dCAhPT0gJ2ZpbGwnICYmIGxheW91dCAhPT0gJ3Jlc3BvbnNpdmUnKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIFwic2l6ZXNcIiBwcm9wZXJ0eSBidXQgaXQgd2lsbCBiZSBpZ25vcmVkLiBPbmx5IHVzZSBcInNpemVzXCIgd2l0aCBcImxheW91dD0nZmlsbCdcIiBvciBcImxheW91dD0ncmVzcG9uc2l2ZSdcImApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyID09PSAnYmx1cicpIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0ICE9PSAnZmlsbCcgJiYgKHdpZHRoSW50IHx8IDApICogKGhlaWdodEludCB8fCAwKSA8IDE2MDApIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgc21hbGxlciB0aGFuIDQweDQwLiBDb25zaWRlciByZW1vdmluZyB0aGUgXCJwbGFjZWhvbGRlcj0nYmx1cidcIiBwcm9wZXJ0eSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWJsdXJEYXRhVVJMKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFZBTElEX0JMVVJfRVhUID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2pwZWcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BuZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2VicCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXZpZidcbiAgICAgICAgICAgICAgICAgICAgXSAvLyBzaG91bGQgbWF0Y2ggbmV4dC1pbWFnZS1sb2FkZXJcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIFwicGxhY2Vob2xkZXI9J2JsdXInXCIgcHJvcGVydHkgYnV0IGlzIG1pc3NpbmcgdGhlIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eS5cbiAgICAgICAgICBQb3NzaWJsZSBzb2x1dGlvbnM6XG4gICAgICAgICAgICAtIEFkZCBhIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eSwgdGhlIGNvbnRlbnRzIHNob3VsZCBiZSBhIHNtYWxsIERhdGEgVVJMIHRvIHJlcHJlc2VudCB0aGUgaW1hZ2VcbiAgICAgICAgICAgIC0gQ2hhbmdlIHRoZSBcInNyY1wiIHByb3BlcnR5IHRvIGEgc3RhdGljIGltcG9ydCB3aXRoIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZpbGUgdHlwZXM6ICR7VkFMSURfQkxVUl9FWFQuam9pbignLCcpfVxuICAgICAgICAgICAgLSBSZW1vdmUgdGhlIFwicGxhY2Vob2xkZXJcIiBwcm9wZXJ0eSwgZWZmZWN0aXZlbHkgbm8gYmx1ciBlZmZlY3RcbiAgICAgICAgICBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3BsYWNlaG9sZGVyLWJsdXItZGF0YS11cmxgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3JlZicgaW4gcmVzdCkge1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbHMpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIHVzaW5nIHVuc3VwcG9ydGVkIFwicmVmXCIgcHJvcGVydHkuIENvbnNpZGVyIHVzaW5nIHRoZSBcIm9uTG9hZGluZ0NvbXBsZXRlXCIgcHJvcGVydHkgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdW5vcHRpbWl6ZWQgJiYgbG9hZGVyICE9PSBkZWZhdWx0SW1hZ2VMb2FkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmxTdHIgPSBsb2FkZXIoe1xuICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoSW50IHx8IDQwMCxcbiAgICAgICAgICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCB8fCA3NVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCB1cmw7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gbmV3IFVSTCh1cmxTdHIpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICBpZiAodXJsU3RyID09PSBzcmMgfHwgdXJsICYmIHVybC5wYXRobmFtZSA9PT0gc3JjICYmICF1cmwuc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbHMpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBhIFwibG9hZGVyXCIgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnQgd2lkdGguIFBsZWFzZSBpbXBsZW1lbnQgaXQgb3IgdXNlIHRoZSBcInVub3B0aW1pemVkXCIgcHJvcGVydHkgaW5zdGVhZC5gICsgYFxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS1taXNzaW5nLWxvYWRlci13aWR0aGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgICAgIGxldCBvdmVyd3JpdHRlblN0eWxlcyA9IE9iamVjdC5rZXlzKHN0eWxlKS5maWx0ZXIoKGtleSk9PmtleSBpbiBsYXlvdXRTdHlsZSk7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJ3cml0dGVuU3R5bGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgJHtzcmN9IGlzIGFzc2lnbmVkIHRoZSBmb2xsb3dpbmcgc3R5bGVzLCB3aGljaCBhcmUgb3ZlcndyaXR0ZW4gYnkgYXV0b21hdGljYWxseS1nZW5lcmF0ZWQgc3R5bGVzOiAke292ZXJ3cml0dGVuU3R5bGVzLmpvaW4oJywgJyl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICFwZXJmT2JzZXJ2ZXIgJiYgd2luZG93LlBlcmZvcm1hbmNlT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBwZXJmT2JzZXJ2ZXIgPSBuZXcgUGVyZm9ybWFuY2VPYnNlcnZlcigoZW50cnlMaXN0KT0+e1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJ5TGlzdC5nZXRFbnRyaWVzKCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBtaXNzaW5nIFwiTGFyZ2VzdENvbnRlbnRmdWxQYWludFwiIGNsYXNzIHdpdGggXCJlbGVtZW50XCIgcHJvcFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1nU3JjID0gKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiAocmVmID0gZW50cnkuZWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5zcmMpIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGNwSW1hZ2UgPSBhbGxJbWdzLmdldChpbWdTcmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxjcEltYWdlICYmICFsY3BJbWFnZS5wcmlvcml0eSAmJiBsY3BJbWFnZS5wbGFjZWhvbGRlciAhPT0gJ2JsdXInICYmICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aCgnZGF0YTonKSAmJiAhbGNwSW1hZ2Uuc3JjLnN0YXJ0c1dpdGgoJ2Jsb2I6JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3dlYi5kZXYvbGNwLyNtZWFzdXJlLWxjcC1pbi1qYXZhc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtsY3BJbWFnZS5zcmN9XCIgd2FzIGRldGVjdGVkIGFzIHRoZSBMYXJnZXN0IENvbnRlbnRmdWwgUGFpbnQgKExDUCkuIFBsZWFzZSBhZGQgdGhlIFwicHJpb3JpdHlcIiBwcm9wZXJ0eSBpZiB0aGlzIGltYWdlIGlzIGFib3ZlIHRoZSBmb2xkLmAgKyBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjcHJpb3JpdHlgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcmZPYnNlcnZlci5vYnNlcnZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsYXJnZXN0LWNvbnRlbnRmdWwtcGFpbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyZWQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExvZyBlcnJvciBidXQgZG9uJ3QgY3Jhc2ggdGhlIGFwcFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGltZ1N0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIGxheW91dFN0eWxlKTtcbiAgICBjb25zdCBibHVyU3R5bGUgPSBwbGFjZWhvbGRlciA9PT0gJ2JsdXInICYmICFibHVyQ29tcGxldGUgPyB7XG4gICAgICAgIGJhY2tncm91bmRTaXplOiBvYmplY3RGaXQgfHwgJ2NvdmVyJyxcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBvYmplY3RQb3NpdGlvbiB8fCAnMCUgMCUnLFxuICAgICAgICBmaWx0ZXI6ICdibHVyKDIwcHgpJyxcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKFwiJHtibHVyRGF0YVVSTH1cIilgXG4gICAgfSA6IHt9O1xuICAgIGlmIChsYXlvdXQgPT09ICdmaWxsJykge1xuICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiBsYXlvdXQ9XCJmaWxsXCIgLz5cbiAgICAgICAgd3JhcHBlclN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB3cmFwcGVyU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB3cmFwcGVyU3R5bGUudG9wID0gMDtcbiAgICAgICAgd3JhcHBlclN0eWxlLmxlZnQgPSAwO1xuICAgICAgICB3cmFwcGVyU3R5bGUuYm90dG9tID0gMDtcbiAgICAgICAgd3JhcHBlclN0eWxlLnJpZ2h0ID0gMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aWR0aEludCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGhlaWdodEludCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiAvPlxuICAgICAgICBjb25zdCBxdW90aWVudCA9IGhlaWdodEludCAvIHdpZHRoSW50O1xuICAgICAgICBjb25zdCBwYWRkaW5nVG9wID0gaXNOYU4ocXVvdGllbnQpID8gJzEwMCUnIDogYCR7cXVvdGllbnQgKiAxMDB9JWA7XG4gICAgICAgIGlmIChsYXlvdXQgPT09ICdyZXNwb25zaXZlJykge1xuICAgICAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiBsYXlvdXQ9XCJyZXNwb25zaXZlXCIgLz5cbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICBoYXNTaXplciA9IHRydWU7XG4gICAgICAgICAgICBzaXplclN0eWxlLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wO1xuICAgICAgICB9IGVsc2UgaWYgKGxheW91dCA9PT0gJ2ludHJpbnNpYycpIHtcbiAgICAgICAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgbGF5b3V0PVwiaW50cmluc2ljXCIgLz5cbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLm1heFdpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgaGFzU2l6ZXIgPSB0cnVlO1xuICAgICAgICAgICAgc2l6ZXJTdHlsZS5tYXhXaWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgIHNpemVyU3ZnVXJsID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbCwlM2NzdmclMjB4bWxucz0lMjdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyUyNyUyMHZlcnNpb249JTI3MS4xJTI3JTIwd2lkdGg9JTI3JHt3aWR0aEludH0lMjclMjBoZWlnaHQ9JTI3JHtoZWlnaHRJbnR9JTI3LyUzZWA7XG4gICAgICAgIH0gZWxzZSBpZiAobGF5b3V0ID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIGxheW91dD1cImZpeGVkXCIgLz5cbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLndpZHRoID0gd2lkdGhJbnQ7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0SW50O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgLz5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBtdXN0IHVzZSBcIndpZHRoXCIgYW5kIFwiaGVpZ2h0XCIgcHJvcGVydGllcyBvciBcImxheW91dD0nZmlsbCdcIiBwcm9wZXJ0eS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgaW1nQXR0cmlidXRlcyA9IHtcbiAgICAgICAgc3JjOiBlbXB0eURhdGFVUkwsXG4gICAgICAgIHNyY1NldDogdW5kZWZpbmVkLFxuICAgICAgICBzaXplczogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBpZiAoaXNWaXNpYmxlKSB7XG4gICAgICAgIGltZ0F0dHJpYnV0ZXMgPSBnZW5lcmF0ZUltZ0F0dHJzKHtcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoSW50LFxuICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCxcbiAgICAgICAgICAgIHNpemVzLFxuICAgICAgICAgICAgbG9hZGVyXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgc3JjU3RyaW5nID0gc3JjO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbGV0IGZ1bGxVcmw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZ1bGxVcmwgPSBuZXcgVVJMKGltZ0F0dHJpYnV0ZXMuc3JjKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBmdWxsVXJsID0gbmV3IFVSTChpbWdBdHRyaWJ1dGVzLnNyYywgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxsSW1ncy5zZXQoZnVsbFVybC5ocmVmLCB7XG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgaW1hZ2VTcmNTZXRQcm9wTmFtZSA9ICdpbWFnZXNyY3NldCc7XG4gICAgbGV0IGltYWdlU2l6ZXNQcm9wTmFtZSA9ICdpbWFnZXNpemVzJztcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1JFQUNUX1JPT1QpIHtcbiAgICAgICAgaW1hZ2VTcmNTZXRQcm9wTmFtZSA9ICdpbWFnZVNyY1NldCc7XG4gICAgICAgIGltYWdlU2l6ZXNQcm9wTmFtZSA9ICdpbWFnZVNpemVzJztcbiAgICB9XG4gICAgY29uc3QgbGlua1Byb3BzID0ge1xuICAgICAgICAvLyBOb3RlOiBpbWFnZXNyY3NldCBhbmQgaW1hZ2VzaXplcyBhcmUgbm90IGluIHRoZSBsaW5rIGVsZW1lbnQgdHlwZSB3aXRoIHJlYWN0IDE3LlxuICAgICAgICBbaW1hZ2VTcmNTZXRQcm9wTmFtZV06IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgICAgICBbaW1hZ2VTaXplc1Byb3BOYW1lXTogaW1nQXR0cmlidXRlcy5zaXplcyxcbiAgICAgICAgY3Jvc3NPcmlnaW46IHJlc3QuY3Jvc3NPcmlnaW5cbiAgICB9O1xuICAgIGNvbnN0IHVzZUxheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0IDogX3JlYWN0LmRlZmF1bHQudXNlTGF5b3V0RWZmZWN0O1xuICAgIGNvbnN0IG9uTG9hZGluZ0NvbXBsZXRlUmVmID0gKDAsIF9yZWFjdCkudXNlUmVmKG9uTG9hZGluZ0NvbXBsZXRlKTtcbiAgICBjb25zdCBwcmV2aW91c0ltYWdlU3JjID0gKDAsIF9yZWFjdCkudXNlUmVmKHNyYyk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQgPSBvbkxvYWRpbmdDb21wbGV0ZTtcbiAgICB9LCBbXG4gICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlXG4gICAgXSk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChwcmV2aW91c0ltYWdlU3JjLmN1cnJlbnQgIT09IHNyYykge1xuICAgICAgICAgICAgcmVzZXRJbnRlcnNlY3RlZCgpO1xuICAgICAgICAgICAgcHJldmlvdXNJbWFnZVNyYy5jdXJyZW50ID0gc3JjO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICByZXNldEludGVyc2VjdGVkLFxuICAgICAgICBzcmNcbiAgICBdKTtcbiAgICBjb25zdCBpbWdFbGVtZW50QXJncyA9IF9leHRlbmRzKHtcbiAgICAgICAgaXNMYXp5LFxuICAgICAgICBpbWdBdHRyaWJ1dGVzLFxuICAgICAgICBoZWlnaHRJbnQsXG4gICAgICAgIHdpZHRoSW50LFxuICAgICAgICBxdWFsaXR5SW50LFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgaW1nU3R5bGUsXG4gICAgICAgIGJsdXJTdHlsZSxcbiAgICAgICAgbG9hZGluZyxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgIGxvYWRlcixcbiAgICAgICAgc3JjU3RyaW5nLFxuICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgICAgc2V0Qmx1ckNvbXBsZXRlLFxuICAgICAgICBzZXRJbnRlcnNlY3Rpb24sXG4gICAgICAgIGlzVmlzaWJsZSxcbiAgICAgICAgbm9zY3JpcHRTaXplczogc2l6ZXNcbiAgICB9LCByZXN0KTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgc3R5bGU6IHdyYXBwZXJTdHlsZVxuICAgIH0sIGhhc1NpemVyID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIHN0eWxlOiBzaXplclN0eWxlXG4gICAgfSwgc2l6ZXJTdmdVcmwgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwge1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICB3aWR0aDogJ2luaXRpYWwnLFxuICAgICAgICAgICAgaGVpZ2h0OiAnaW5pdGlhbCcsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgcGFkZGluZzogMFxuICAgICAgICB9LFxuICAgICAgICBhbHQ6IFwiXCIsXG4gICAgICAgIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSxcbiAgICAgICAgc3JjOiBzaXplclN2Z1VybFxuICAgIH0pIDogbnVsbCkgOiBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSW1hZ2VFbGVtZW50LCBPYmplY3QuYXNzaWduKHt9LCBpbWdFbGVtZW50QXJncykpKSwgcHJpb3JpdHkgPyAvLyBOb3RlIGhvdyB3ZSBvbWl0IHRoZSBgaHJlZmAgYXR0cmlidXRlLCBhcyBpdCB3b3VsZCBvbmx5IGJlIHJlbGV2YW50XG4gICAgLy8gZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgYGltYWdlc3Jjc2V0YCwgYW5kIGluIHRob3NlIGNhc2VzXG4gICAgLy8gaXQgd291bGQgbGlrZWx5IGNhdXNlIHRoZSBpbmNvcnJlY3QgaW1hZ2UgdG8gYmUgcHJlbG9hZGVkLlxuICAgIC8vXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjYXR0ci1saW5rLWltYWdlc3Jjc2V0XG4gICAgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9oZWFkLmRlZmF1bHQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGtleTogJ19fbmltZy0nICsgaW1nQXR0cmlidXRlcy5zcmMgKyBpbWdBdHRyaWJ1dGVzLnNyY1NldCArIGltZ0F0dHJpYnV0ZXMuc2l6ZXMsXG4gICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgIGFzOiBcImltYWdlXCIsXG4gICAgICAgIGhyZWY6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0ID8gdW5kZWZpbmVkIDogaW1nQXR0cmlidXRlcy5zcmNcbiAgICB9LCBsaW5rUHJvcHMpKSkgOiBudWxsKTtcbn1cbidjbGllbnQnO1xuZnVuY3Rpb24gbm9ybWFsaXplU3JjKHNyYykge1xuICAgIHJldHVybiBzcmNbMF0gPT09ICcvJyA/IHNyYy5zbGljZSgxKSA6IHNyYztcbn1cbmNvbnN0IGNvbmZpZ0VudiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTO1xuY29uc3QgbG9hZGVkSW1hZ2VVUkxzID0gbmV3IFNldCgpO1xuY29uc3QgYWxsSW1ncyA9IG5ldyBNYXAoKTtcbmxldCBwZXJmT2JzZXJ2ZXI7XG5jb25zdCBlbXB0eURhdGFVUkwgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3JztcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIGdsb2JhbC5fX05FWFRfSU1BR0VfSU1QT1JURUQgPSB0cnVlO1xufVxuY29uc3QgVkFMSURfTE9BRElOR19WQUxVRVMgPSBbXG4gICAgJ2xhenknLFxuICAgICdlYWdlcicsXG4gICAgdW5kZWZpbmVkXG5dO1xuZnVuY3Rpb24gaW1naXhMb2FkZXIoeyBjb25maWcgLCBzcmMgLCB3aWR0aCAsIHF1YWxpdHkgIH0pIHtcbiAgICAvLyBEZW1vOiBodHRwczovL3N0YXRpYy5pbWdpeC5uZXQvZGFpc3kucG5nP2F1dG89Zm9ybWF0JmZpdD1tYXgmdz0zMDBcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke2NvbmZpZy5wYXRofSR7bm9ybWFsaXplU3JjKHNyYyl9YCk7XG4gICAgY29uc3QgcGFyYW1zID0gdXJsLnNlYXJjaFBhcmFtcztcbiAgICAvLyBhdXRvIHBhcmFtcyBjYW4gYmUgY29tYmluZWQgd2l0aCBjb21tYSBzZXBhcmF0aW9uLCBvciByZWl0ZXJhdGlvblxuICAgIHBhcmFtcy5zZXQoJ2F1dG8nLCBwYXJhbXMuZ2V0QWxsKCdhdXRvJykuam9pbignLCcpIHx8ICdmb3JtYXQnKTtcbiAgICBwYXJhbXMuc2V0KCdmaXQnLCBwYXJhbXMuZ2V0KCdmaXQnKSB8fCAnbWF4Jyk7XG4gICAgcGFyYW1zLnNldCgndycsIHBhcmFtcy5nZXQoJ3cnKSB8fCB3aWR0aC50b1N0cmluZygpKTtcbiAgICBpZiAocXVhbGl0eSkge1xuICAgICAgICBwYXJhbXMuc2V0KCdxJywgcXVhbGl0eS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybC5ocmVmO1xufVxuZnVuY3Rpb24gYWthbWFpTG9hZGVyKHsgY29uZmlnICwgc3JjICwgd2lkdGggIH0pIHtcbiAgICByZXR1cm4gYCR7Y29uZmlnLnBhdGh9JHtub3JtYWxpemVTcmMoc3JjKX0/aW13aWR0aD0ke3dpZHRofWA7XG59XG5mdW5jdGlvbiBjbG91ZGluYXJ5TG9hZGVyKHsgY29uZmlnICwgc3JjICwgd2lkdGggLCBxdWFsaXR5ICB9KSB7XG4gICAgLy8gRGVtbzogaHR0cHM6Ly9yZXMuY2xvdWRpbmFyeS5jb20vZGVtby9pbWFnZS91cGxvYWQvd18zMDAsY19saW1pdCxxX2F1dG8vdHVydGxlcy5qcGdcbiAgICBjb25zdCBwYXJhbXMgPSBbXG4gICAgICAgICdmX2F1dG8nLFxuICAgICAgICAnY19saW1pdCcsXG4gICAgICAgICd3XycgKyB3aWR0aCxcbiAgICAgICAgJ3FfJyArIChxdWFsaXR5IHx8ICdhdXRvJylcbiAgICBdO1xuICAgIGNvbnN0IHBhcmFtc1N0cmluZyA9IHBhcmFtcy5qb2luKCcsJykgKyAnLyc7XG4gICAgcmV0dXJuIGAke2NvbmZpZy5wYXRofSR7cGFyYW1zU3RyaW5nfSR7bm9ybWFsaXplU3JjKHNyYyl9YDtcbn1cbmZ1bmN0aW9uIGN1c3RvbUxvYWRlcih7IHNyYyAgfSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyBtaXNzaW5nIFwibG9hZGVyXCIgcHJvcC5gICsgYFxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS1taXNzaW5nLWxvYWRlcmApO1xufVxuZnVuY3Rpb24gZGVmYXVsdExvYWRlcih7IGNvbmZpZyAsIHNyYyAsIHdpZHRoICwgcXVhbGl0eSAgfSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdWYWx1ZXMgPSBbXTtcbiAgICAgICAgLy8gdGhlc2Ugc2hvdWxkIGFsd2F5cyBiZSBwcm92aWRlZCBidXQgbWFrZSBzdXJlIHRoZXkgYXJlXG4gICAgICAgIGlmICghc3JjKSBtaXNzaW5nVmFsdWVzLnB1c2goJ3NyYycpO1xuICAgICAgICBpZiAoIXdpZHRoKSBtaXNzaW5nVmFsdWVzLnB1c2goJ3dpZHRoJyk7XG4gICAgICAgIGlmIChtaXNzaW5nVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTmV4dCBJbWFnZSBPcHRpbWl6YXRpb24gcmVxdWlyZXMgJHttaXNzaW5nVmFsdWVzLmpvaW4oJywgJyl9IHRvIGJlIHByb3ZpZGVkLiBNYWtlIHN1cmUgeW91IHBhc3MgdGhlbSBhcyBwcm9wcyB0byB0aGUgXFxgbmV4dC9pbWFnZVxcYCBjb21wb25lbnQuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgcXVhbGl0eVxuICAgICAgICAgICAgfSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKCcvLycpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzcmMgXCIke3NyY31cIiBvbiBcXGBuZXh0L2ltYWdlXFxgLCBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgKC8vKSBtdXN0IGJlIGNoYW5nZWQgdG8gYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3JjLnN0YXJ0c1dpdGgoJy8nKSAmJiAoY29uZmlnLmRvbWFpbnMgfHwgY29uZmlnLnJlbW90ZVBhdHRlcm5zKSkge1xuICAgICAgICAgICAgbGV0IHBhcnNlZFNyYztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkU3JjID0gbmV3IFVSTChzcmMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHNyYyBcIiR7c3JjfVwiIG9uIFxcYG5leHQvaW1hZ2VcXGAsIGlmIHVzaW5nIHJlbGF0aXZlIGltYWdlIGl0IG11c3Qgc3RhcnQgd2l0aCBhIGxlYWRpbmcgc2xhc2ggXCIvXCIgb3IgYmUgYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgZHluYW1pYyByZXF1aXJlIGJlY2F1c2UgdGhpcyBzaG91bGQgb25seSBlcnJvciBpbiBkZXZlbG9wbWVudFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGFzTWF0Y2ggIH0gPSByZXF1aXJlKCcuLi9zaGFyZWQvbGliL21hdGNoLXJlbW90ZS1wYXR0ZXJuJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNNYXRjaChjb25maWcuZG9tYWlucywgY29uZmlnLnJlbW90ZVBhdHRlcm5zLCBwYXJzZWRTcmMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzcmMgcHJvcCAoJHtzcmN9KSBvbiBcXGBuZXh0L2ltYWdlXFxgLCBob3N0bmFtZSBcIiR7cGFyc2VkU3JjLmhvc3RuYW1lfVwiIGlzIG5vdCBjb25maWd1cmVkIHVuZGVyIGltYWdlcyBpbiB5b3VyIFxcYG5leHQuY29uZmlnLmpzXFxgXFxuYCArIGBTZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1ob3N0YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzcmMuZW5kc1dpdGgoJy5zdmcnKSAmJiAhY29uZmlnLmRhbmdlcm91c2x5QWxsb3dTVkcpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIG1ha2Ugc3ZnIHNlcnZlIGFzLWlzIHRvIGF2b2lkIHByb3h5aW5nXG4gICAgICAgIC8vIHRocm91Z2ggdGhlIGJ1aWx0LWluIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXG4gICAgICAgIHJldHVybiBzcmM7XG4gICAgfVxuICAgIHJldHVybiBgJHsoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGNvbmZpZy5wYXRoKX0/dXJsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHNyYyl9Jnc9JHt3aWR0aH0mcT0ke3F1YWxpdHkgfHwgNzV9YDtcbn1cbmNvbnN0IGxvYWRlcnMgPSBuZXcgTWFwKFtcbiAgICBbXG4gICAgICAgICdkZWZhdWx0JyxcbiAgICAgICAgZGVmYXVsdExvYWRlclxuICAgIF0sXG4gICAgW1xuICAgICAgICAnaW1naXgnLFxuICAgICAgICBpbWdpeExvYWRlclxuICAgIF0sXG4gICAgW1xuICAgICAgICAnY2xvdWRpbmFyeScsXG4gICAgICAgIGNsb3VkaW5hcnlMb2FkZXJcbiAgICBdLFxuICAgIFtcbiAgICAgICAgJ2FrYW1haScsXG4gICAgICAgIGFrYW1haUxvYWRlclxuICAgIF0sXG4gICAgW1xuICAgICAgICAnY3VzdG9tJyxcbiAgICAgICAgY3VzdG9tTG9hZGVyXG4gICAgXSwgXG5dKTtcbmNvbnN0IFZBTElEX0xBWU9VVF9WQUxVRVMgPSBbXG4gICAgJ2ZpbGwnLFxuICAgICdmaXhlZCcsXG4gICAgJ2ludHJpbnNpYycsXG4gICAgJ3Jlc3BvbnNpdmUnLFxuICAgIHVuZGVmaW5lZCwgXG5dO1xuZnVuY3Rpb24gaXNTdGF0aWNSZXF1aXJlKHNyYykge1xuICAgIHJldHVybiBzcmMuZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNTdGF0aWNJbWFnZURhdGEoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5zcmMgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzU3RhdGljSW1wb3J0KHNyYykge1xuICAgIHJldHVybiB0eXBlb2Ygc3JjID09PSAnb2JqZWN0JyAmJiAoaXNTdGF0aWNSZXF1aXJlKHNyYykgfHwgaXNTdGF0aWNJbWFnZURhdGEoc3JjKSk7XG59XG5mdW5jdGlvbiBnZXRXaWR0aHMoeyBkZXZpY2VTaXplcyAsIGFsbFNpemVzICB9LCB3aWR0aCwgbGF5b3V0LCBzaXplcykge1xuICAgIGlmIChzaXplcyAmJiAobGF5b3V0ID09PSAnZmlsbCcgfHwgbGF5b3V0ID09PSAncmVzcG9uc2l2ZScpKSB7XG4gICAgICAgIC8vIEZpbmQgYWxsIHRoZSBcInZ3XCIgcGVyY2VudCBzaXplcyB1c2VkIGluIHRoZSBzaXplcyBwcm9wXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0V2lkdGhSZSA9IC8oXnxcXHMpKDE/XFxkP1xcZCl2dy9nO1xuICAgICAgICBjb25zdCBwZXJjZW50U2l6ZXMgPSBbXTtcbiAgICAgICAgZm9yKGxldCBtYXRjaDsgbWF0Y2ggPSB2aWV3cG9ydFdpZHRoUmUuZXhlYyhzaXplcyk7IG1hdGNoKXtcbiAgICAgICAgICAgIHBlcmNlbnRTaXplcy5wdXNoKHBhcnNlSW50KG1hdGNoWzJdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcmNlbnRTaXplcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNtYWxsZXN0UmF0aW8gPSBNYXRoLm1pbiguLi5wZXJjZW50U2l6ZXMpICogMC4wMTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGhzOiBhbGxTaXplcy5maWx0ZXIoKHMpPT5zID49IGRldmljZVNpemVzWzBdICogc21hbGxlc3RSYXRpbyksXG4gICAgICAgICAgICAgICAga2luZDogJ3cnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aHM6IGFsbFNpemVzLFxuICAgICAgICAgICAga2luZDogJ3cnXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICdudW1iZXInIHx8IGxheW91dCA9PT0gJ2ZpbGwnIHx8IGxheW91dCA9PT0gJ3Jlc3BvbnNpdmUnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aHM6IGRldmljZVNpemVzLFxuICAgICAgICAgICAga2luZDogJ3cnXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHdpZHRocyA9IFtcbiAgICAgICAgLi4ubmV3IFNldCgvLyA+IFRoaXMgbWVhbnMgdGhhdCBtb3N0IE9MRUQgc2NyZWVucyB0aGF0IHNheSB0aGV5IGFyZSAzeCByZXNvbHV0aW9uLFxuICAgICAgICAvLyA+IGFyZSBhY3R1YWxseSAzeCBpbiB0aGUgZ3JlZW4gY29sb3IsIGJ1dCBvbmx5IDEuNXggaW4gdGhlIHJlZCBhbmRcbiAgICAgICAgLy8gPiBibHVlIGNvbG9ycy4gU2hvd2luZyBhIDN4IHJlc29sdXRpb24gaW1hZ2UgaW4gdGhlIGFwcCB2cyBhIDJ4XG4gICAgICAgIC8vID4gcmVzb2x1dGlvbiBpbWFnZSB3aWxsIGJlIHZpc3VhbGx5IHRoZSBzYW1lLCB0aG91Z2ggdGhlIDN4IGltYWdlXG4gICAgICAgIC8vID4gdGFrZXMgc2lnbmlmaWNhbnRseSBtb3JlIGRhdGEuIEV2ZW4gdHJ1ZSAzeCByZXNvbHV0aW9uIHNjcmVlbnMgYXJlXG4gICAgICAgIC8vID4gd2FzdGVmdWwgYXMgdGhlIGh1bWFuIGV5ZSBjYW5ub3Qgc2VlIHRoYXQgbGV2ZWwgb2YgZGV0YWlsIHdpdGhvdXRcbiAgICAgICAgLy8gPiBzb21ldGhpbmcgbGlrZSBhIG1hZ25pZnlpbmcgZ2xhc3MuXG4gICAgICAgIC8vIGh0dHBzOi8vYmxvZy50d2l0dGVyLmNvbS9lbmdpbmVlcmluZy9lbl91cy90b3BpY3MvaW5mcmFzdHJ1Y3R1cmUvMjAxOS9jYXBwaW5nLWltYWdlLWZpZGVsaXR5LW9uLXVsdHJhLWhpZ2gtcmVzb2x1dGlvbi1kZXZpY2VzLmh0bWxcbiAgICAgICAgW1xuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICB3aWR0aCAqIDIgLyosIHdpZHRoICogMyovIFxuICAgICAgICBdLm1hcCgodyk9PmFsbFNpemVzLmZpbmQoKHApPT5wID49IHcpIHx8IGFsbFNpemVzW2FsbFNpemVzLmxlbmd0aCAtIDFdKSksIFxuICAgIF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGhzLFxuICAgICAgICBraW5kOiAneCdcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWdBdHRycyh7IGNvbmZpZyAsIHNyYyAsIHVub3B0aW1pemVkICwgbGF5b3V0ICwgd2lkdGggLCBxdWFsaXR5ICwgc2l6ZXMgLCBsb2FkZXIgIH0pIHtcbiAgICBpZiAodW5vcHRpbWl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHNyY1NldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2l6ZXM6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7IHdpZHRocyAsIGtpbmQgIH0gPSBnZXRXaWR0aHMoY29uZmlnLCB3aWR0aCwgbGF5b3V0LCBzaXplcyk7XG4gICAgY29uc3QgbGFzdCA9IHdpZHRocy5sZW5ndGggLSAxO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpemVzOiAhc2l6ZXMgJiYga2luZCA9PT0gJ3cnID8gJzEwMHZ3JyA6IHNpemVzLFxuICAgICAgICBzcmNTZXQ6IHdpZHRocy5tYXAoKHcsIGkpPT5gJHtsb2FkZXIoe1xuICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgICAgcXVhbGl0eSxcbiAgICAgICAgICAgICAgICB3aWR0aDogd1xuICAgICAgICAgICAgfSl9ICR7a2luZCA9PT0gJ3cnID8gdyA6IGkgKyAxfSR7a2luZH1gKS5qb2luKCcsICcpLFxuICAgICAgICAvLyBJdCdzIGludGVuZGVkIHRvIGtlZXAgYHNyY2AgdGhlIGxhc3QgYXR0cmlidXRlIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgICAgICAvLyBhdHRyaWJ1dGVzIGluIG9yZGVyLiBJZiB3ZSBrZWVwIGBzcmNgIHRoZSBmaXJzdCBvbmUsIFNhZmFyaSB3aWxsXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IHN0YXJ0IHRvIGZldGNoIGBzcmNgLCBiZWZvcmUgYHNpemVzYCBhbmQgYHNyY1NldGAgYXJlIGV2ZW5cbiAgICAgICAgLy8gdXBkYXRlZCBieSBSZWFjdC4gVGhhdCBjYXVzZXMgbXVsdGlwbGUgdW5uZWNlc3NhcnkgcmVxdWVzdHMgaWYgYHNyY1NldGBcbiAgICAgICAgLy8gYW5kIGBzaXplc2AgYXJlIGRlZmluZWQuXG4gICAgICAgIC8vIFRoaXMgYnVnIGNhbm5vdCBiZSByZXByb2R1Y2VkIGluIENocm9tZSBvciBGaXJlZm94LlxuICAgICAgICBzcmM6IGxvYWRlcih7XG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICBxdWFsaXR5LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoc1tsYXN0XVxuICAgICAgICB9KVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRJbnQoeCkge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHgsIDEwKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRJbWFnZUxvYWRlcihsb2FkZXJQcm9wcykge1xuICAgIHZhciByZWY7XG4gICAgY29uc3QgbG9hZGVyS2V5ID0gKChyZWYgPSBsb2FkZXJQcm9wcy5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiByZWYubG9hZGVyKSB8fCAnZGVmYXVsdCc7XG4gICAgY29uc3QgbG9hZCA9IGxvYWRlcnMuZ2V0KGxvYWRlcktleSk7XG4gICAgaWYgKGxvYWQpIHtcbiAgICAgICAgcmV0dXJuIGxvYWQobG9hZGVyUHJvcHMpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gXCJsb2FkZXJcIiBmb3VuZCBpbiBcIm5leHQuY29uZmlnLmpzXCIuIEV4cGVjdGVkOiAke19pbWFnZUNvbmZpZy5WQUxJRF9MT0FERVJTLmpvaW4oJywgJyl9LiBSZWNlaXZlZDogJHtsb2FkZXJLZXl9YCk7XG59XG4vLyBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzM5Nzc3ODMzLzI2NjUzNSBmb3Igd2h5IHdlIHVzZSB0aGlzIHJlZlxuLy8gaGFuZGxlciBpbnN0ZWFkIG9mIHRoZSBpbWcncyBvbkxvYWQgYXR0cmlidXRlLlxuZnVuY3Rpb24gaGFuZGxlTG9hZGluZyhpbWcsIHNyYywgbGF5b3V0LCBwbGFjZWhvbGRlciwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSkge1xuICAgIGlmICghaW1nIHx8IGltZy5zcmMgPT09IGVtcHR5RGF0YVVSTCB8fCBpbWdbJ2RhdGEtbG9hZGVkLXNyYyddID09PSBzcmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbWdbJ2RhdGEtbG9hZGVkLXNyYyddID0gc3JjO1xuICAgIGNvbnN0IHAgPSAnZGVjb2RlJyBpbiBpbWcgPyBpbWcuZGVjb2RlKCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBwLmNhdGNoKCgpPT57fSkudGhlbigoKT0+e1xuICAgICAgICBpZiAoIWltZy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGluIGNhc2Ugb2YgcmFjZSBjb25kaXRpb246XG4gICAgICAgICAgICAvLyAtIG9ubG9hZCgpIGlzIGNhbGxlZFxuICAgICAgICAgICAgLy8gLSBkZWNvZGUoKSBpcyBjYWxsZWQgYnV0IGluY29tcGxldGVcbiAgICAgICAgICAgIC8vIC0gdW5tb3VudCBpcyBjYWxsZWRcbiAgICAgICAgICAgIC8vIC0gZGVjb2RlKCkgY29tcGxldGVzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVkSW1hZ2VVUkxzLmFkZChzcmMpO1xuICAgICAgICBpZiAocGxhY2Vob2xkZXIgPT09ICdibHVyJykge1xuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkxvYWRpbmdDb21wbGV0ZVJlZiA9PSBudWxsID8gdm9pZCAwIDogb25Mb2FkaW5nQ29tcGxldGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBuYXR1cmFsV2lkdGggLCBuYXR1cmFsSGVpZ2h0ICB9ID0gaW1nO1xuICAgICAgICAgICAgLy8gUGFzcyBiYWNrIHJlYWQtb25seSBwcmltaXRpdmUgdmFsdWVzIGJ1dCBub3QgdGhlXG4gICAgICAgICAgICAvLyB1bmRlcmx5aW5nIERPTSBlbGVtZW50IGJlY2F1c2UgaXQgY291bGQgYmUgbWlzdXNlZC5cbiAgICAgICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQoe1xuICAgICAgICAgICAgICAgIG5hdHVyYWxXaWR0aCxcbiAgICAgICAgICAgICAgICBuYXR1cmFsSGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgIGlmICgocmVmID0gaW1nLnBhcmVudEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiByZWYucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGdldENvbXB1dGVkU3R5bGUoaW1nLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcGFyZW50IGhhcyBub3QgYmVlbiByZW5kZXJlZCB0byB0aGUgZG9tIHlldCBhbmQgdGhlcmVmb3JlIGl0IGhhcyBubyBwb3NpdGlvbi4gU2tpcCB0aGUgd2FybmluZ3MgZm9yIHN1Y2ggY2FzZXMuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXlvdXQgPT09ICdyZXNwb25zaXZlJyAmJiBwYXJlbnQuZGlzcGxheSA9PT0gJ2ZsZXgnKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbHMpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIG1heSBub3QgcmVuZGVyIHByb3Blcmx5IGFzIGEgY2hpbGQgb2YgYSBmbGV4IGNvbnRhaW5lci4gQ29uc2lkZXIgd3JhcHBpbmcgdGhlIGltYWdlIHdpdGggYSBkaXYgdG8gY29uZmlndXJlIHRoZSB3aWR0aC5gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxheW91dCA9PT0gJ2ZpbGwnICYmIHBhcmVudC5wb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJyAmJiBwYXJlbnQucG9zaXRpb24gIT09ICdmaXhlZCcgJiYgcGFyZW50LnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbHMpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIG1heSBub3QgcmVuZGVyIHByb3Blcmx5IHdpdGggYSBwYXJlbnQgdXNpbmcgcG9zaXRpb246XCIke3BhcmVudC5wb3NpdGlvbn1cIi4gQ29uc2lkZXIgY2hhbmdpbmcgdGhlIHBhcmVudCBzdHlsZSB0byBwb3NpdGlvbjpcInJlbGF0aXZlXCIgd2l0aCBhIHdpZHRoIGFuZCBoZWlnaHQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBJbWFnZUVsZW1lbnQgPSAoX3BhcmFtKT0+e1xuICAgIHZhciB7IGltZ0F0dHJpYnV0ZXMgLCBoZWlnaHRJbnQgLCB3aWR0aEludCAsIHF1YWxpdHlJbnQgLCBsYXlvdXQgLCBjbGFzc05hbWUgLCBpbWdTdHlsZSAsIGJsdXJTdHlsZSAsIGlzTGF6eSAsIHBsYWNlaG9sZGVyICwgbG9hZGluZyAsIHNyY1N0cmluZyAsIGNvbmZpZyAsIHVub3B0aW1pemVkICwgbG9hZGVyICwgb25Mb2FkaW5nQ29tcGxldGVSZWYgLCBzZXRCbHVyQ29tcGxldGUgLCBzZXRJbnRlcnNlY3Rpb24gLCBvbkxvYWQgLCBvbkVycm9yICwgaXNWaXNpYmxlICwgbm9zY3JpcHRTaXplcyAgfSA9IF9wYXJhbSwgcmVzdCA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKF9wYXJhbSwgW1xuICAgICAgICBcImltZ0F0dHJpYnV0ZXNcIixcbiAgICAgICAgXCJoZWlnaHRJbnRcIixcbiAgICAgICAgXCJ3aWR0aEludFwiLFxuICAgICAgICBcInF1YWxpdHlJbnRcIixcbiAgICAgICAgXCJsYXlvdXRcIixcbiAgICAgICAgXCJjbGFzc05hbWVcIixcbiAgICAgICAgXCJpbWdTdHlsZVwiLFxuICAgICAgICBcImJsdXJTdHlsZVwiLFxuICAgICAgICBcImlzTGF6eVwiLFxuICAgICAgICBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgIFwibG9hZGluZ1wiLFxuICAgICAgICBcInNyY1N0cmluZ1wiLFxuICAgICAgICBcImNvbmZpZ1wiLFxuICAgICAgICBcInVub3B0aW1pemVkXCIsXG4gICAgICAgIFwibG9hZGVyXCIsXG4gICAgICAgIFwib25Mb2FkaW5nQ29tcGxldGVSZWZcIixcbiAgICAgICAgXCJzZXRCbHVyQ29tcGxldGVcIixcbiAgICAgICAgXCJzZXRJbnRlcnNlY3Rpb25cIixcbiAgICAgICAgXCJvbkxvYWRcIixcbiAgICAgICAgXCJvbkVycm9yXCIsXG4gICAgICAgIFwiaXNWaXNpYmxlXCIsXG4gICAgICAgIFwibm9zY3JpcHRTaXplc1wiXG4gICAgXSk7XG4gICAgbG9hZGluZyA9IGlzTGF6eSA/ICdsYXp5JyA6IGxvYWRpbmc7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIE9iamVjdC5hc3NpZ24oe30sIHJlc3QsIGltZ0F0dHJpYnV0ZXMsIHtcbiAgICAgICAgZGVjb2Rpbmc6IFwiYXN5bmNcIixcbiAgICAgICAgXCJkYXRhLW5pbWdcIjogbGF5b3V0LFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBpbWdTdHlsZSwgYmx1clN0eWxlKSxcbiAgICAgICAgcmVmOiAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygoaW1nKT0+e1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW1nICYmICFzcmNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcInNyY1wiIHByb3BlcnR5OmAsIGltZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0SW50ZXJzZWN0aW9uKGltZyk7XG4gICAgICAgICAgICBpZiAoaW1nID09IG51bGwgPyB2b2lkIDAgOiBpbWcuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVMb2FkaW5nKGltZywgc3JjU3RyaW5nLCBsYXlvdXQsIHBsYWNlaG9sZGVyLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW1xuICAgICAgICAgICAgc2V0SW50ZXJzZWN0aW9uLFxuICAgICAgICAgICAgc3JjU3RyaW5nLFxuICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSwgXG4gICAgICAgIF0pLFxuICAgICAgICBvbkxvYWQ6IChldmVudCk9PntcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBoYW5kbGVMb2FkaW5nKGltZywgc3JjU3RyaW5nLCBsYXlvdXQsIHBsYWNlaG9sZGVyLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlKTtcbiAgICAgICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBvbkxvYWQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiAoZXZlbnQpPT57XG4gICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIgPT09ICdibHVyJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZWFsIGltYWdlIGZhaWxzIHRvIGxvYWQsIHRoaXMgd2lsbCBzdGlsbCByZW1vdmUgdGhlIHBsYWNlaG9sZGVyLlxuICAgICAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSksIChpc0xhenkgfHwgcGxhY2Vob2xkZXIgPT09ICdibHVyJykgJiYgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibm9zY3JpcHRcIiwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIE9iamVjdC5hc3NpZ24oe30sIHJlc3QsIGdlbmVyYXRlSW1nQXR0cnMoe1xuICAgICAgICBjb25maWcsXG4gICAgICAgIHNyYzogc3JjU3RyaW5nLFxuICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICB3aWR0aDogd2lkdGhJbnQsXG4gICAgICAgIHF1YWxpdHk6IHF1YWxpdHlJbnQsXG4gICAgICAgIHNpemVzOiBub3NjcmlwdFNpemVzLFxuICAgICAgICBsb2FkZXJcbiAgICB9KSwge1xuICAgICAgICBkZWNvZGluZzogXCJhc3luY1wiLFxuICAgICAgICBcImRhdGEtbmltZ1wiOiBsYXlvdXQsXG4gICAgICAgIHN0eWxlOiBpbWdTdHlsZSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgLSBUT0RPOiB1cGdyYWRlIHRvIGBAdHlwZXMvcmVhY3RAMTdgXG4gICAgICAgIGxvYWRpbmc6IGxvYWRpbmdcbiAgICB9KSkpKTtcbn07XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJJbWFnZSIsIl9leHRlbmRzIiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZSIsIl9yZWFjdCIsIl9oZWFkIiwiX2ltYWdlQ29uZmlnIiwiX3VzZUludGVyc2VjdGlvbiIsIl9pbWFnZUNvbmZpZ0NvbnRleHQiLCJfdXRpbHMiLCJfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCIsIl9wYXJhbSIsInNyYyIsInNpemVzIiwiX3Vub3B0aW1pemVkIiwidW5vcHRpbWl6ZWQiLCJfcHJpb3JpdHkiLCJwcmlvcml0eSIsImxvYWRpbmciLCJfbGF6eVJvb3QiLCJsYXp5Um9vdCIsImxhenlCb3VuZGFyeSIsImNsYXNzTmFtZSIsInF1YWxpdHkiLCJ3aWR0aCIsImhlaWdodCIsInN0eWxlIiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJvbkxvYWRpbmdDb21wbGV0ZSIsIl9wbGFjZWhvbGRlciIsInBsYWNlaG9sZGVyIiwiYmx1ckRhdGFVUkwiLCJhbGwiLCJjb25maWdDb250ZXh0IiwidXNlQ29udGV4dCIsIkltYWdlQ29uZmlnQ29udGV4dCIsImNvbmZpZyIsInVzZU1lbW8iLCJjIiwiY29uZmlnRW52IiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiYWxsU2l6ZXMiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJkZXZpY2VTaXplcyIsImltYWdlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJyZXN0IiwibGF5b3V0IiwibG9hZGVyIiwiZGVmYXVsdEltYWdlTG9hZGVyIiwiY3VzdG9tSW1hZ2VMb2FkZXIiLCJfdG1wIiwib2JqIiwib3B0cyIsInN0YXRpY1NyYyIsImlzU3RhdGljSW1wb3J0Iiwic3RhdGljSW1hZ2VEYXRhIiwiaXNTdGF0aWNSZXF1aXJlIiwiRXJyb3IiLCJjb25jYXQiLCJKU09OIiwic3RyaW5naWZ5IiwiaXNMYXp5Iiwic3RhcnRzV2l0aCIsImxvYWRlZEltYWdlVVJMcyIsImhhcyIsInJlZiIsInVzZVN0YXRlIiwiYmx1ckNvbXBsZXRlIiwic2V0Qmx1ckNvbXBsZXRlIiwicmVmMSIsInVzZUludGVyc2VjdGlvbiIsInJvb3RSZWYiLCJyb290TWFyZ2luIiwiZGlzYWJsZWQiLCJzZXRJbnRlcnNlY3Rpb24iLCJpc0ludGVyc2VjdGVkIiwicmVzZXRJbnRlcnNlY3RlZCIsImlzVmlzaWJsZSIsIndyYXBwZXJTdHlsZSIsImJveFNpemluZyIsImRpc3BsYXkiLCJvdmVyZmxvdyIsImJhY2tncm91bmQiLCJvcGFjaXR5IiwiYm9yZGVyIiwibWFyZ2luIiwicGFkZGluZyIsInNpemVyU3R5bGUiLCJoYXNTaXplciIsInNpemVyU3ZnVXJsIiwibGF5b3V0U3R5bGUiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJtaW5IZWlnaHQiLCJtYXhIZWlnaHQiLCJ3aWR0aEludCIsImdldEludCIsImhlaWdodEludCIsInF1YWxpdHlJbnQiLCJwcm9jZXNzIiwiVkFMSURfTEFZT1VUX1ZBTFVFUyIsImluY2x1ZGVzIiwibWFwIiwiU3RyaW5nIiwiam9pbiIsImlzTmFOIiwid2Fybk9uY2UiLCJWQUxJRF9MT0FESU5HX1ZBTFVFUyIsIlZBTElEX0JMVVJfRVhUIiwidXJsU3RyIiwidXJsIiwiVVJMIiwiZXJyIiwicGF0aG5hbWUiLCJzZWFyY2giLCJvdmVyd3JpdHRlblN0eWxlcyIsImtleXMiLCJmaWx0ZXIiLCJrZXkiLCJsZW5ndGgiLCJwZXJmT2JzZXJ2ZXIiLCJ3aW5kb3ciLCJQZXJmb3JtYW5jZU9ic2VydmVyIiwiZW50cnlMaXN0IiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiIsIl9kaWRJdGVyYXRvckVycm9yIiwiX2l0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3IiLCJnZXRFbnRyaWVzIiwiU3ltYm9sIiwiX3N0ZXAiLCJlbnRyeSIsImltZ1NyYyIsImVsZW1lbnQiLCJsY3BJbWFnZSIsImFsbEltZ3MiLCJnZXQiLCJvYnNlcnZlIiwidHlwZSIsImJ1ZmZlcmVkIiwiY29uc29sZSIsImVycm9yIiwiaW1nU3R5bGUiLCJhc3NpZ24iLCJibHVyU3R5bGUiLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRQb3NpdGlvbiIsImJhY2tncm91bmRJbWFnZSIsInF1b3RpZW50IiwicGFkZGluZ1RvcCIsImltZ0F0dHJpYnV0ZXMiLCJlbXB0eURhdGFVUkwiLCJzcmNTZXQiLCJ1bmRlZmluZWQiLCJnZW5lcmF0ZUltZ0F0dHJzIiwic3JjU3RyaW5nIiwiZnVsbFVybCIsImUiLCJsb2NhdGlvbiIsImhyZWYiLCJzZXQiLCJpbWFnZVNyY1NldFByb3BOYW1lIiwiaW1hZ2VTaXplc1Byb3BOYW1lIiwiZW52IiwiX19ORVhUX1JFQUNUX1JPT1QiLCJfb2JqIiwibGlua1Byb3BzIiwiX2RlZmluZVByb3BlcnR5IiwiY3Jvc3NPcmlnaW4iLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJvbkxvYWRpbmdDb21wbGV0ZVJlZiIsInVzZVJlZiIsInByZXZpb3VzSW1hZ2VTcmMiLCJjdXJyZW50IiwiaW1nRWxlbWVudEFyZ3MiLCJub3NjcmlwdFNpemVzIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwiYWx0IiwiSW1hZ2VFbGVtZW50IiwicmVsIiwiYXMiLCJub3JtYWxpemVTcmMiLCJzbGljZSIsIl9fTkVYVF9JTUFHRV9PUFRTIiwiU2V0IiwiTWFwIiwiZ2xvYmFsIiwiX19ORVhUX0lNQUdFX0lNUE9SVEVEIiwiaW1naXhMb2FkZXIiLCJwYXJhbSIsInBhdGgiLCJwYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJnZXRBbGwiLCJ0b1N0cmluZyIsImFrYW1haUxvYWRlciIsImNsb3VkaW5hcnlMb2FkZXIiLCJwYXJhbXNTdHJpbmciLCJjdXN0b21Mb2FkZXIiLCJkZWZhdWx0TG9hZGVyIiwibWlzc2luZ1ZhbHVlcyIsInB1c2giLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJwYXJzZWRTcmMiLCJoYXNNYXRjaCIsImhvc3RuYW1lIiwiZW5kc1dpdGgiLCJkYW5nZXJvdXNseUFsbG93U1ZHIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJsb2FkZXJzIiwiaXNTdGF0aWNJbWFnZURhdGEiLCJnZXRXaWR0aHMiLCJ2aWV3cG9ydFdpZHRoUmUiLCJwZXJjZW50U2l6ZXMiLCJtYXRjaCIsImV4ZWMiLCJwYXJzZUludCIsIk1hdGgiLCJzbWFsbGVzdFJhdGlvIiwibWluIiwid2lkdGhzIiwicyIsImtpbmQiLCJ3IiwiZmluZCIsInAiLCJsYXN0IiwiaSIsIngiLCJsb2FkZXJQcm9wcyIsImxvYWRlcktleSIsImxvYWQiLCJWQUxJRF9MT0FERVJTIiwiaGFuZGxlTG9hZGluZyIsImltZyIsImRlY29kZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2F0Y2giLCJ0aGVuIiwicGFyZW50Tm9kZSIsImFkZCIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaHQiLCJwYXJlbnRFbGVtZW50IiwicGFyZW50IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm9uTG9hZCIsIm9uRXJyb3IiLCJkZWNvZGluZyIsInVzZUNhbGxiYWNrIiwiY29tcGxldGUiLCJldmVudCIsImN1cnJlbnRUYXJnZXQiLCJfX2VzTW9kdWxlIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/image.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _slicedToArray = (__webpack_require__(/*! @swc/helpers/lib/_sliced_to_array.js */ \"./node_modules/@swc/helpers/lib/_sliced_to_array.js\")[\"default\"]);\n\nvar _typeOf = (__webpack_require__(/*! @swc/helpers/lib/_type_of.js */ \"./node_modules/@swc/helpers/lib/_type_of.js\")[\"default\"]);\n\nvar _s = $RefreshSig$();\n\n\"client\";\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\n\nvar _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ \"./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\")[\"default\"]);\n\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _router = __webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\");\n\nvar _addLocale = __webpack_require__(/*! ./add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\n\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\n\nvar _appRouterContext = __webpack_require__(/*! ../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\n\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\n\nvar _getDomainLocale = __webpack_require__(/*! ./get-domain-locale */ \"./node_modules/next/dist/client/get-domain-locale.js\");\n\nvar _addBasePath = __webpack_require__(/*! ./add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\n\n\"client\";\nvar prefetched = {};\n\nfunction prefetch(router, href, as, options) {\n  if ( false || !router) return;\n  if (!(0, _router).isLocalURL(href)) return; // Prefetch the JSON page if asked (only in the client)\n  // We need to handle a prefetch error here since we may be\n  // loading with priority which can reject but we don't\n  // want to force navigation since this is only a prefetch\n\n  Promise.resolve(router.prefetch(href, as, options)).catch(function (err) {\n    if (true) {\n      // rethrow to show invalid URL errors\n      throw err;\n    }\n  });\n  var curLocale = options && typeof options.locale !== \"undefined\" ? options.locale : router && router.locale; // Join on an invalid URI character\n\n  prefetched[href + \"%\" + as + (curLocale ? \"%\" + curLocale : \"\")] = true;\n}\n\nfunction isModifiedEvent(event) {\n  var target = event.currentTarget.target;\n  return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || event.nativeEvent && event.nativeEvent.which === 2;\n}\n\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled) {\n  var nodeName = e.currentTarget.nodeName; // anchors inside an svg have a lowercase nodeName\n\n  var isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n\n  if (isAnchorNodeName && (isModifiedEvent(e) || !(0, _router).isLocalURL(href))) {\n    // ignore click for browsers default behavior\n    return;\n  }\n\n  e.preventDefault();\n\n  var navigate = function () {\n    // If the router is an NextRouter instance it will have `beforePopState`\n    if (\"beforePopState\" in router) {\n      router[replace ? \"replace\" : \"push\"](href, as, {\n        shallow: shallow,\n        locale: locale,\n        scroll: scroll\n      });\n    } else {\n      // If `beforePopState` doesn't exist on the router it's the AppRouter.\n      var method = replace ? \"replace\" : \"push\";\n      router[method](href, {\n        forceOptimisticNavigation: !prefetchEnabled\n      });\n    }\n  };\n\n  if (isAppRouter) {\n    // @ts-expect-error startTransition exists.\n    _react.default.startTransition(navigate);\n  } else {\n    navigate();\n  }\n}\n\nvar Link = /*#__PURE__*/_s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n  _s();\n\n  if (true) {\n    var createPropError = function createPropError(args) {\n      return new Error(\"Failed prop type: The prop `\".concat(args.key, \"` expects a \").concat(args.expected, \" in `<Link>`, but got `\").concat(args.actual, \"` instead.\") + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0));\n    }; // TypeScript trick for type-guarding:\n\n\n    var requiredPropsGuard = {\n      href: true\n    };\n    var requiredProps = Object.keys(requiredPropsGuard);\n    requiredProps.forEach(function (key) {\n      if (key === \"href\") {\n        if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n          throw createPropError({\n            key: key,\n            expected: \"`string` or `object`\",\n            actual: props[key] === null ? \"null\" : _typeOf(props[key])\n          });\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _ = key;\n      }\n    }); // TypeScript trick for type-guarding:\n\n    var optionalPropsGuard = {\n      as: true,\n      replace: true,\n      scroll: true,\n      shallow: true,\n      passHref: true,\n      prefetch: true,\n      locale: true,\n      onClick: true,\n      onMouseEnter: true,\n      onTouchStart: true,\n      legacyBehavior: true\n    };\n    var optionalProps = Object.keys(optionalPropsGuard);\n    optionalProps.forEach(function (key) {\n      var valType = _typeOf(props[key]);\n\n      if (key === \"as\") {\n        if (props[key] && valType !== \"string\" && valType !== \"object\") {\n          throw createPropError({\n            key: key,\n            expected: \"`string` or `object`\",\n            actual: valType\n          });\n        }\n      } else if (key === \"locale\") {\n        if (props[key] && valType !== \"string\") {\n          throw createPropError({\n            key: key,\n            expected: \"`string`\",\n            actual: valType\n          });\n        }\n      } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n        if (props[key] && valType !== \"function\") {\n          throw createPropError({\n            key: key,\n            expected: \"`function`\",\n            actual: valType\n          });\n        }\n      } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n        if (props[key] != null && valType !== \"boolean\") {\n          throw createPropError({\n            key: key,\n            expected: \"`boolean`\",\n            actual: valType\n          });\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _ = key;\n      }\n    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n\n    var hasWarned = _react.default.useRef(false);\n\n    if (props.prefetch && !hasWarned.current) {\n      hasWarned.current = true;\n      console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n    }\n  }\n\n  var children;\n\n  var hrefProp = props.href,\n      asProp = props.as,\n      childrenProp = props.children,\n      prefetchProp = props.prefetch,\n      passHref = props.passHref,\n      replace = props.replace,\n      shallow = props.shallow,\n      scroll = props.scroll,\n      locale = props.locale,\n      onClick = props.onClick,\n      onMouseEnter = props.onMouseEnter,\n      onTouchStart = props.onTouchStart,\n      _legacyBehavior = props.legacyBehavior,\n      legacyBehavior = _legacyBehavior === void 0 ? Boolean(false) !== true : _legacyBehavior,\n      restProps = _object_without_properties_loose(props, [\"href\", \"as\", \"children\", \"prefetch\", \"passHref\", \"replace\", \"shallow\", \"scroll\", \"locale\", \"onClick\", \"onMouseEnter\", \"onTouchStart\", \"legacyBehavior\"]);\n\n  children = childrenProp;\n\n  if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n    children = /*#__PURE__*/_react.default.createElement(\"a\", null, children);\n  }\n\n  var p = prefetchProp !== false;\n\n  var router = _react.default.useContext(_routerContext.RouterContext); // TODO-APP: type error. Remove `as any`\n\n\n  var appRouter = _react.default.useContext(_appRouterContext.AppRouterContext);\n\n  if (appRouter) {\n    router = appRouter;\n  }\n\n  var ref = _react.default.useMemo(function () {\n    var ref = _slicedToArray((0, _router).resolveHref(router, hrefProp, true), 2),\n        resolvedHref = ref[0],\n        resolvedAs = ref[1];\n\n    return {\n      href: resolvedHref,\n      as: asProp ? (0, _router).resolveHref(router, asProp) : resolvedAs || resolvedHref\n    };\n  }, [router, hrefProp, asProp]),\n      href = ref.href,\n      as = ref.as;\n\n  var previousHref = _react.default.useRef(href);\n\n  var previousAs = _react.default.useRef(as); // This will return the first child, if multiple are provided it will throw an error\n\n\n  var child;\n\n  if (legacyBehavior) {\n    if (true) {\n      if (onClick) {\n        console.warn('\"onClick\" was passed to <Link> with `href` of `'.concat(hrefProp, '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link'));\n      }\n\n      if (onMouseEnter) {\n        console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `'.concat(hrefProp, '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link'));\n      }\n\n      try {\n        child = _react.default.Children.only(children);\n      } catch (err) {\n        if (!children) {\n          throw new Error(\"No children were passed to <Link> with `href` of `\".concat(hrefProp, \"` but one child is required https://nextjs.org/docs/messages/link-no-children\"));\n        }\n\n        throw new Error(\"Multiple children were passed to <Link> with `href` of `\".concat(hrefProp, \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\") + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0));\n      }\n    } else {}\n  }\n\n  var childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n\n  var ref1 = _slicedToArray((0, _useIntersection).useIntersection({\n    rootMargin: \"200px\"\n  }), 3),\n      setIntersectionRef = ref1[0],\n      isVisible = ref1[1],\n      resetVisible = ref1[2];\n\n  var setRef = _react.default.useCallback(function (el) {\n    // Before the link getting observed, check if visible state need to be reset\n    if (previousAs.current !== as || previousHref.current !== href) {\n      resetVisible();\n      previousAs.current = as;\n      previousHref.current = href;\n    }\n\n    setIntersectionRef(el);\n\n    if (childRef) {\n      if (typeof childRef === \"function\") childRef(el);else if (typeof childRef === \"object\") {\n        childRef.current = el;\n      }\n    }\n  }, [as, childRef, href, resetVisible, setIntersectionRef]);\n\n  _react.default.useEffect(function () {\n    var shouldPrefetch = isVisible && p && (0, _router).isLocalURL(href);\n    var curLocale = typeof locale !== \"undefined\" ? locale : router && router.locale;\n    var isPrefetched = prefetched[href + \"%\" + as + (curLocale ? \"%\" + curLocale : \"\")];\n\n    if (shouldPrefetch && !isPrefetched) {\n      prefetch(router, href, as, {\n        locale: curLocale\n      });\n    }\n  }, [as, href, isVisible, locale, p, router]);\n\n  var childProps = {\n    ref: setRef,\n    onClick: function (e) {\n      if (true) {\n        if (!e) {\n          throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n        }\n      }\n\n      if (!legacyBehavior && typeof onClick === \"function\") {\n        onClick(e);\n      }\n\n      if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n        child.props.onClick(e);\n      }\n\n      if (!e.defaultPrevented) {\n        linkClicked(e, router, href, as, replace, shallow, scroll, locale, Boolean(appRouter), p);\n      }\n    },\n    onMouseEnter: function (e) {\n      if (!legacyBehavior && typeof onMouseEnter === \"function\") {\n        onMouseEnter(e);\n      }\n\n      if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n        child.props.onMouseEnter(e);\n      } // Check for not prefetch disabled in page using appRouter\n\n\n      if (!(!p && appRouter)) {\n        if ((0, _router).isLocalURL(href)) {\n          prefetch(router, href, as, {\n            priority: true\n          });\n        }\n      }\n    },\n    onTouchStart: function (e) {\n      if (!legacyBehavior && typeof onTouchStart === \"function\") {\n        onTouchStart(e);\n      }\n\n      if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n        child.props.onTouchStart(e);\n      } // Check for not prefetch disabled in page using appRouter\n\n\n      if (!(!p && appRouter)) {\n        if ((0, _router).isLocalURL(href)) {\n          prefetch(router, href, as, {\n            priority: true\n          });\n        }\n      }\n    }\n  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n  // defined, we specify the current 'href', so that repetition is not needed by the user\n\n  if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n    var curLocale = typeof locale !== \"undefined\" ? locale : router && router.locale; // we only render domain locales if we are currently on a domain locale\n    // so that locale links are still visitable in development/preview envs\n\n    var localeDomain = router && router.isLocaleDomain && (0, _getDomainLocale).getDomainLocale(as, curLocale, router.locales, router.domainLocales);\n    childProps.href = localeDomain || (0, _addBasePath).addBasePath((0, _addLocale).addLocale(as, curLocale, router && router.defaultLocale));\n  }\n\n  return legacyBehavior ? /*#__PURE__*/_react.default.cloneElement(child, childProps) : /*#__PURE__*/_react.default.createElement(\"a\", Object.assign({}, restProps, childProps), children);\n}, \"xuB00qEWT1T+jc4Svm2qUBtJuIg=\")), \"xuB00qEWT1T+jc4Svm2qUBtJuIg=\");\n\n_c1 = Link;\nvar _default = Link;\nexports[\"default\"] = _default;\n\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n  Object.defineProperty(exports.default, \"__esModule\", {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\n\n\nvar _c, _c1;\n\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUNhOzs7Ozs7Ozs7Ozs7QUFEYjtBQUVBQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3Q0gsRUFBQUE7QUFHQUUsa0JBQUFBLEdBQWtCLEtBQUssQ0FBdkJBOztBQUNBLElBQUlHLHdCQUF3QixHQUFHQyxtSkFBL0I7O0FBQ0EsSUFBSUMsZ0NBQWdDLEdBQUdELG1LQUF2Qzs7QUFDQSxJQUFJRSxNQUFNLEdBQUdILHdCQUF3QixDQUFDQyxtQkFBTyxDQUFDLDRDQUFELENBQVIsQ0FBckM7O0FBQ0EsSUFBSUcsT0FBTyxHQUFHSCxtQkFBTyxDQUFDLHlGQUFELENBQXJCOztBQUNBLElBQUlJLFVBQVUsR0FBR0osbUJBQU8sQ0FBQyxtRUFBRCxDQUF4Qjs7QUFDQSxJQUFJSyxjQUFjLEdBQUdMLG1CQUFPLENBQUMsMkZBQUQsQ0FBNUI7O0FBQ0EsSUFBSU0saUJBQWlCLEdBQUdOLG1CQUFPLENBQUMsbUdBQUQsQ0FBL0I7O0FBQ0EsSUFBSU8sZ0JBQWdCLEdBQUdQLG1CQUFPLENBQUMsK0VBQUQsQ0FBOUI7O0FBQ0EsSUFBSVEsZ0JBQWdCLEdBQUdSLG1CQUFPLENBQUMsaUZBQUQsQ0FBOUI7O0FBQ0EsSUFBSVMsWUFBWSxHQUFHVCxtQkFBTyxDQUFDLHlFQUFELENBQTFCOztBQUNBO0FBQ0EsSUFBTVUsVUFBVSxHQUFHLEVBQW5COztBQUNBLFNBQVNDLFFBQVQsQ0FBa0JDLE1BQWxCLEVBQTBCQyxJQUExQixFQUFnQ0MsRUFBaEMsRUFBb0NDLE9BQXBDLEVBQTZDO0VBQ3pDLElBQUksVUFBaUMsQ0FBQ0gsTUFBdEMsRUFBOEM7RUFDOUMsSUFBSSxDQUFDLENBQUMsR0FBR1QsT0FBSixFQUFhYSxVQUFiLENBQXdCSCxJQUF4QixDQUFMLEVBQW9DLE9BRkssQ0FHekM7RUFDQTtFQUNBO0VBQ0E7O0VBQ0FJLE9BQU8sQ0FBQ0MsT0FBUkQsQ0FBZ0JM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T0FBTyxDQUFDRSxPQUE5QkosRUFBdUMsWUFBdkNBLEVBQXFEO0lBQUVHLEtBQUssRUFBRTtFQUFULENBQXJESDtFQUNBQSxNQUFNLENBQUMySSxNQUFQM0ksQ0FBY0UsT0FBTyxDQUFDRSxPQUF0QkosRUFBK0JFLE9BQS9CRjtFQUNBOEksTUFBTSxDQUFDNUksT0FBUDRJLEdBQWlCNUksT0FBTyxDQUFDRSxPQUF6QjBJO0FBQ0QsQyxDQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanM/ZTRmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcImNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZS5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yb3V0ZXIgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyXCIpO1xudmFyIF9hZGRMb2NhbGUgPSByZXF1aXJlKFwiLi9hZGQtbG9jYWxlXCIpO1xudmFyIF9yb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHRcIik7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG52YXIgX3VzZUludGVyc2VjdGlvbiA9IHJlcXVpcmUoXCIuL3VzZS1pbnRlcnNlY3Rpb25cIik7XG52YXIgX2dldERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoXCIuL2dldC1kb21haW4tbG9jYWxlXCIpO1xudmFyIF9hZGRCYXNlUGF0aCA9IHJlcXVpcmUoXCIuL2FkZC1iYXNlLXBhdGhcIik7XG4nY2xpZW50JztcbmNvbnN0IHByZWZldGNoZWQgPSB7fTtcbmZ1bmN0aW9uIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXJvdXRlcikgcmV0dXJuO1xuICAgIGlmICghKDAsIF9yb3V0ZXIpLmlzTG9jYWxVUkwoaHJlZikpIHJldHVybjtcbiAgICAvLyBQcmVmZXRjaCB0aGUgSlNPTiBwYWdlIGlmIGFza2VkIChvbmx5IGluIHRoZSBjbGllbnQpXG4gICAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAgIC8vIGxvYWRpbmcgd2l0aCBwcmlvcml0eSB3aGljaCBjYW4gcmVqZWN0IGJ1dCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgdG8gZm9yY2UgbmF2aWdhdGlvbiBzaW5jZSB0aGlzIGlzIG9ubHkgYSBwcmVmZXRjaFxuICAgIFByb21pc2UucmVzb2x2ZShyb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXMsIG9wdGlvbnMpKS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgY3VyTG9jYWxlID0gb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5sb2NhbGUgOiByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZTtcbiAgICAvLyBKb2luIG9uIGFuIGludmFsaWQgVVJJIGNoYXJhY3RlclxuICAgIHByZWZldGNoZWRbaHJlZiArICclJyArIGFzICsgKGN1ckxvY2FsZSA/ICclJyArIGN1ckxvY2FsZSA6ICcnKV0gPSB0cnVlO1xufVxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgeyB0YXJnZXQgIH0gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0ICE9PSAnX3NlbGYnIHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDI7XG59XG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSwgaXNBcHBSb3V0ZXIsIHByZWZldGNoRW5hYmxlZCkge1xuICAgIGNvbnN0IHsgbm9kZU5hbWUgIH0gPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgLy8gYW5jaG9ycyBpbnNpZGUgYW4gc3ZnIGhhdmUgYSBsb3dlcmNhc2Ugbm9kZU5hbWVcbiAgICBjb25zdCBpc0FuY2hvck5vZGVOYW1lID0gbm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0EnO1xuICAgIGlmIChpc0FuY2hvck5vZGVOYW1lICYmIChpc01vZGlmaWVkRXZlbnQoZSkgfHwgISgwLCBfcm91dGVyKS5pc0xvY2FsVVJMKGhyZWYpKSkge1xuICAgICAgICAvLyBpZ25vcmUgY2xpY2sgZm9yIGJyb3dzZXLigJlzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgbmF2aWdhdGUgPSAoKT0+e1xuICAgICAgICAvLyBJZiB0aGUgcm91dGVyIGlzIGFuIE5leHRSb3V0ZXIgaW5zdGFuY2UgaXQgd2lsbCBoYXZlIGBiZWZvcmVQb3BTdGF0ZWBcbiAgICAgICAgaWYgKCdiZWZvcmVQb3BTdGF0ZScgaW4gcm91dGVyKSB7XG4gICAgICAgICAgICByb3V0ZXJbcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdwdXNoJ10oaHJlZiwgYXMsIHtcbiAgICAgICAgICAgICAgICBzaGFsbG93LFxuICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBzY3JvbGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgYGJlZm9yZVBvcFN0YXRlYCBkb2Vzbid0IGV4aXN0IG9uIHRoZSByb3V0ZXIgaXQncyB0aGUgQXBwUm91dGVyLlxuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdwdXNoJztcbiAgICAgICAgICAgIHJvdXRlclttZXRob2RdKGhyZWYsIHtcbiAgICAgICAgICAgICAgICBmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uOiAhcHJlZmV0Y2hFbmFibGVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQXBwUm91dGVyKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc3RhcnRUcmFuc2l0aW9uIGV4aXN0cy5cbiAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKG5hdmlnYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuYXZpZ2F0ZSgpO1xuICAgIH1cbn1cbmNvbnN0IExpbmsgPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmZvcndhcmRSZWYoZnVuY3Rpb24gTGlua0NvbXBvbmVudChwcm9wcywgZm9yd2FyZGVkUmVmKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUHJvcEVycm9yKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYEZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIFxcYCR7YXJncy5rZXl9XFxgIGV4cGVjdHMgYSAke2FyZ3MuZXhwZWN0ZWR9IGluIFxcYDxMaW5rPlxcYCwgYnV0IGdvdCBcXGAke2FyZ3MuYWN0dWFsfVxcYCBpbnN0ZWFkLmAgKyAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCIgOiAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcHNHdWFyZCA9IHtcbiAgICAgICAgICAgIGhyZWY6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWRQcm9wcyA9IE9iamVjdC5rZXlzKHJlcXVpcmVkUHJvcHNHdWFyZCk7XG4gICAgICAgIHJlcXVpcmVkUHJvcHMuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHByb3BzW2tleV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBwcm9wc1trZXldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgY29uc3QgXyA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHNHdWFyZCA9IHtcbiAgICAgICAgICAgIGFzOiB0cnVlLFxuICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgIHNoYWxsb3c6IHRydWUsXG4gICAgICAgICAgICBwYXNzSHJlZjogdHJ1ZSxcbiAgICAgICAgICAgIHByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgbG9jYWxlOiB0cnVlLFxuICAgICAgICAgICAgb25DbGljazogdHJ1ZSxcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcjogdHJ1ZSxcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydDogdHJ1ZSxcbiAgICAgICAgICAgIGxlZ2FjeUJlaGF2aW9yOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSBPYmplY3Qua2V5cyhvcHRpb25hbFByb3BzR3VhcmQpO1xuICAgICAgICBvcHRpb25hbFByb3BzLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IHZhbFR5cGUgPSB0eXBlb2YgcHJvcHNba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdhcycpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJyAmJiB2YWxUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCBvciBgb2JqZWN0YCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdsb2NhbGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnb25DbGljaycgfHwga2V5ID09PSAnb25Nb3VzZUVudGVyJyB8fCBrZXkgPT09ICdvblRvdWNoU3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgZnVuY3Rpb25gJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3JlcGxhY2UnIHx8IGtleSA9PT0gJ3Njcm9sbCcgfHwga2V5ID09PSAnc2hhbGxvdycgfHwga2V5ID09PSAncGFzc0hyZWYnIHx8IGtleSA9PT0gJ3ByZWZldGNoJyB8fCBrZXkgPT09ICdsZWdhY3lCZWhhdmlvcicpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAhPSBudWxsICYmIHZhbFR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgYm9vbGVhbmAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgY29uc3QgXyA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoaXMgaG9vayBpcyBpbiBhIGNvbmRpdGlvbmFsIGJ1dCB0aGF0IGlzIG9rIGJlY2F1c2UgYHByb2Nlc3MuZW52Lk5PREVfRU5WYCBuZXZlciBjaGFuZ2VzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICBjb25zdCBoYXNXYXJuZWQgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoZmFsc2UpO1xuICAgICAgICBpZiAocHJvcHMucHJlZmV0Y2ggJiYgIWhhc1dhcm5lZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBoYXNXYXJuZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05leHQuanMgYXV0by1wcmVmZXRjaGVzIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdmlld3BvcnQuIFRoZSBwcmVmZXRjaCBhdHRyaWJ1dGUgaXMgbm8gbG9uZ2VyIG5lZWRlZC4gTW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcHJlZmV0Y2gtdHJ1ZS1kZXByZWNhdGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuO1xuICAgIGNvbnN0IHsgaHJlZjogaHJlZlByb3AgLCBhczogYXNQcm9wICwgY2hpbGRyZW46IGNoaWxkcmVuUHJvcCAsIHByZWZldGNoOiBwcmVmZXRjaFByb3AgLCBwYXNzSHJlZiAsIHJlcGxhY2UgLCBzaGFsbG93ICwgc2Nyb2xsICwgbG9jYWxlICwgb25DbGljayAsIG9uTW91c2VFbnRlciAsIG9uVG91Y2hTdGFydCAsIGxlZ2FjeUJlaGF2aW9yID1Cb29sZWFuKHByb2Nlc3MuZW52Ll9fTkVYVF9ORVdfTElOS19CRUhBVklPUikgIT09IHRydWUgIH0gPSBwcm9wcywgcmVzdFByb3BzID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UocHJvcHMsIFtcbiAgICAgICAgXCJocmVmXCIsXG4gICAgICAgIFwiYXNcIixcbiAgICAgICAgXCJjaGlsZHJlblwiLFxuICAgICAgICBcInByZWZldGNoXCIsXG4gICAgICAgIFwicGFzc0hyZWZcIixcbiAgICAgICAgXCJyZXBsYWNlXCIsXG4gICAgICAgIFwic2hhbGxvd1wiLFxuICAgICAgICBcInNjcm9sbFwiLFxuICAgICAgICBcImxvY2FsZVwiLFxuICAgICAgICBcIm9uQ2xpY2tcIixcbiAgICAgICAgXCJvbk1vdXNlRW50ZXJcIixcbiAgICAgICAgXCJvblRvdWNoU3RhcnRcIixcbiAgICAgICAgXCJsZWdhY3lCZWhhdmlvclwiXG4gICAgXSk7XG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlblByb3A7XG4gICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZHJlbiA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYVwiLCBudWxsLCBjaGlsZHJlbik7XG4gICAgfVxuICAgIGNvbnN0IHAgPSBwcmVmZXRjaFByb3AgIT09IGZhbHNlO1xuICAgIGxldCByb3V0ZXIgPSBfcmVhY3QuZGVmYXVsdC51c2VDb250ZXh0KF9yb3V0ZXJDb250ZXh0LlJvdXRlckNvbnRleHQpO1xuICAgIC8vIFRPRE8tQVBQOiB0eXBlIGVycm9yLiBSZW1vdmUgYGFzIGFueWBcbiAgICBjb25zdCBhcHBSb3V0ZXIgPSBfcmVhY3QuZGVmYXVsdC51c2VDb250ZXh0KF9hcHBSb3V0ZXJDb250ZXh0LkFwcFJvdXRlckNvbnRleHQpO1xuICAgIGlmIChhcHBSb3V0ZXIpIHtcbiAgICAgICAgcm91dGVyID0gYXBwUm91dGVyO1xuICAgIH1cbiAgICBjb25zdCB7IGhyZWYgLCBhcyAgfSA9IF9yZWFjdC5kZWZhdWx0LnVzZU1lbW8oKCk9PntcbiAgICAgICAgY29uc3QgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSAoMCwgX3JvdXRlcikucmVzb2x2ZUhyZWYocm91dGVyLCBocmVmUHJvcCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICBhczogYXNQcm9wID8gKDAsIF9yb3V0ZXIpLnJlc29sdmVIcmVmKHJvdXRlciwgYXNQcm9wKSA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICByb3V0ZXIsXG4gICAgICAgIGhyZWZQcm9wLFxuICAgICAgICBhc1Byb3BcbiAgICBdKTtcbiAgICBjb25zdCBwcmV2aW91c0hyZWYgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoaHJlZik7XG4gICAgY29uc3QgcHJldmlvdXNBcyA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihhcyk7XG4gICAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gICAgbGV0IGNoaWxkO1xuICAgIGlmIChsZWdhY3lCZWhhdmlvcikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBcIm9uQ2xpY2tcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uQ2xpY2sgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmtgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbk1vdXNlRW50ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFwib25Nb3VzZUVudGVyXCIgd2FzIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBcImxlZ2FjeUJlaGF2aW9yXCIgd2FzIHNldC4gVGhlIGxlZ2FjeSBiZWhhdmlvciByZXF1aXJlcyBvbk1vdXNlRW50ZXIgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmtgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBjaGlsZHJlbiB3ZXJlIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBvbmUgY2hpbGQgaXMgcmVxdWlyZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1uby1jaGlsZHJlbmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGxlIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IG9ubHkgb25lIGNoaWxkIGlzIHN1cHBvcnRlZCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9saW5rLW11bHRpcGxlLWNoaWxkcmVuYCArICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFwiIFxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCIgOiAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGQgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaGlsZFJlZiA9IGxlZ2FjeUJlaGF2aW9yID8gY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09PSAnb2JqZWN0JyAmJiBjaGlsZC5yZWYgOiBmb3J3YXJkZWRSZWY7XG4gICAgY29uc3QgW3NldEludGVyc2VjdGlvblJlZiwgaXNWaXNpYmxlLCByZXNldFZpc2libGVdID0gKDAsIF91c2VJbnRlcnNlY3Rpb24pLnVzZUludGVyc2VjdGlvbih7XG4gICAgICAgIHJvb3RNYXJnaW46ICcyMDBweCdcbiAgICB9KTtcbiAgICBjb25zdCBzZXRSZWYgPSBfcmVhY3QuZGVmYXVsdC51c2VDYWxsYmFjaygoZWwpPT57XG4gICAgICAgIC8vIEJlZm9yZSB0aGUgbGluayBnZXR0aW5nIG9ic2VydmVkLCBjaGVjayBpZiB2aXNpYmxlIHN0YXRlIG5lZWQgdG8gYmUgcmVzZXRcbiAgICAgICAgaWYgKHByZXZpb3VzQXMuY3VycmVudCAhPT0gYXMgfHwgcHJldmlvdXNIcmVmLmN1cnJlbnQgIT09IGhyZWYpIHtcbiAgICAgICAgICAgIHJlc2V0VmlzaWJsZSgpO1xuICAgICAgICAgICAgcHJldmlvdXNBcy5jdXJyZW50ID0gYXM7XG4gICAgICAgICAgICBwcmV2aW91c0hyZWYuY3VycmVudCA9IGhyZWY7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW50ZXJzZWN0aW9uUmVmKGVsKTtcbiAgICAgICAgaWYgKGNoaWxkUmVmKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkUmVmID09PSAnZnVuY3Rpb24nKSBjaGlsZFJlZihlbCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRSZWYuY3VycmVudCA9IGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBhcyxcbiAgICAgICAgY2hpbGRSZWYsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIHJlc2V0VmlzaWJsZSxcbiAgICAgICAgc2V0SW50ZXJzZWN0aW9uUmVmXG4gICAgXSk7XG4gICAgX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGNvbnN0IHNob3VsZFByZWZldGNoID0gaXNWaXNpYmxlICYmIHAgJiYgKDAsIF9yb3V0ZXIpLmlzTG9jYWxVUkwoaHJlZik7XG4gICAgICAgIGNvbnN0IGN1ckxvY2FsZSA9IHR5cGVvZiBsb2NhbGUgIT09ICd1bmRlZmluZWQnID8gbG9jYWxlIDogcm91dGVyICYmIHJvdXRlci5sb2NhbGU7XG4gICAgICAgIGNvbnN0IGlzUHJlZmV0Y2hlZCA9IHByZWZldGNoZWRbaHJlZiArICclJyArIGFzICsgKGN1ckxvY2FsZSA/ICclJyArIGN1ckxvY2FsZSA6ICcnKV07XG4gICAgICAgIGlmIChzaG91bGRQcmVmZXRjaCAmJiAhaXNQcmVmZXRjaGVkKSB7XG4gICAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgbG9jYWxlOiBjdXJMb2NhbGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBhcyxcbiAgICAgICAgaHJlZixcbiAgICAgICAgaXNWaXNpYmxlLFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIHAsXG4gICAgICAgIHJvdXRlclxuICAgIF0pO1xuICAgIGNvbnN0IGNoaWxkUHJvcHMgPSB7XG4gICAgICAgIHJlZjogc2V0UmVmLFxuICAgICAgICBvbkNsaWNrOiAoZSk9PntcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9uZW50IHJlbmRlcmVkIGluc2lkZSBuZXh0L2xpbmsgaGFzIHRvIHBhc3MgY2xpY2sgZXZlbnQgdG8gXCJvbkNsaWNrXCIgcHJvcC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25DbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uQ2xpY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlLCBCb29sZWFuKGFwcFJvdXRlciksIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRW50ZXI6IChlKT0+e1xuICAgICAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25Nb3VzZUVudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3Igbm90IHByZWZldGNoIGRpc2FibGVkIGluIHBhZ2UgdXNpbmcgYXBwUm91dGVyXG4gICAgICAgICAgICBpZiAoISghcCAmJiBhcHBSb3V0ZXIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfcm91dGVyKS5pc0xvY2FsVVJMKGhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Ub3VjaFN0YXJ0OiAoZSk9PntcbiAgICAgICAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uVG91Y2hTdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9uVG91Y2hTdGFydChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Ub3VjaFN0YXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25Ub3VjaFN0YXJ0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG5vdCBwcmVmZXRjaCBkaXNhYmxlZCBpbiBwYWdlIHVzaW5nIGFwcFJvdXRlclxuICAgICAgICAgICAgaWYgKCEoIXAgJiYgYXBwUm91dGVyKSkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX3JvdXRlcikuaXNMb2NhbFVSTChocmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIElmIGNoaWxkIGlzIGFuIDxhPiB0YWcgYW5kIGRvZXNuJ3QgaGF2ZSBhIGhyZWYgYXR0cmlidXRlLCBvciBpZiB0aGUgJ3Bhc3NIcmVmJyBwcm9wZXJ0eSBpc1xuICAgIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlclxuICAgIGlmICghbGVnYWN5QmVoYXZpb3IgfHwgcGFzc0hyZWYgfHwgY2hpbGQudHlwZSA9PT0gJ2EnICYmICEoJ2hyZWYnIGluIGNoaWxkLnByb3BzKSkge1xuICAgICAgICBjb25zdCBjdXJMb2NhbGUgPSB0eXBlb2YgbG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IGxvY2FsZSA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlO1xuICAgICAgICAvLyB3ZSBvbmx5IHJlbmRlciBkb21haW4gbG9jYWxlcyBpZiB3ZSBhcmUgY3VycmVudGx5IG9uIGEgZG9tYWluIGxvY2FsZVxuICAgICAgICAvLyBzbyB0aGF0IGxvY2FsZSBsaW5rcyBhcmUgc3RpbGwgdmlzaXRhYmxlIGluIGRldmVsb3BtZW50L3ByZXZpZXcgZW52c1xuICAgICAgICBjb25zdCBsb2NhbGVEb21haW4gPSByb3V0ZXIgJiYgcm91dGVyLmlzTG9jYWxlRG9tYWluICYmICgwLCBfZ2V0RG9tYWluTG9jYWxlKS5nZXREb21haW5Mb2NhbGUoYXMsIGN1ckxvY2FsZSwgcm91dGVyLmxvY2FsZXMsIHJvdXRlci5kb21haW5Mb2NhbGVzKTtcbiAgICAgICAgY2hpbGRQcm9wcy5ocmVmID0gbG9jYWxlRG9tYWluIHx8ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKCgwLCBfYWRkTG9jYWxlKS5hZGRMb2NhbGUoYXMsIGN1ckxvY2FsZSwgcm91dGVyICYmIHJvdXRlci5kZWZhdWx0TG9jYWxlKSk7XG4gICAgfVxuICAgIHJldHVybiBsZWdhY3lCZWhhdmlvciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwgT2JqZWN0LmFzc2lnbih7fSwgcmVzdFByb3BzLCBjaGlsZFByb3BzKSwgY2hpbGRyZW4pO1xufSk7XG52YXIgX2RlZmF1bHQgPSBMaW5rO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmsuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZSIsIl9yZWFjdCIsIl9yb3V0ZXIiLCJfYWRkTG9jYWxlIiwiX3JvdXRlckNvbnRleHQiLCJfYXBwUm91dGVyQ29udGV4dCIsIl91c2VJbnRlcnNlY3Rpb24iLCJfZ2V0RG9tYWluTG9jYWxlIiwiX2FkZEJhc2VQYXRoIiwicHJlZmV0Y2hlZCIsInByZWZldGNoIiwicm91dGVyIiwiaHJlZiIsImFzIiwib3B0aW9ucyIsImlzTG9jYWxVUkwiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhdGNoIiwiZXJyIiwicHJvY2VzcyIsImN1ckxvY2FsZSIsImxvY2FsZSIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwidGFyZ2V0IiwiY3VycmVudFRhcmdldCIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwicmVwbGFjZSIsInNoYWxsb3ciLCJzY3JvbGwiLCJpc0FwcFJvdXRlciIsInByZWZldGNoRW5hYmxlZCIsIm5vZGVOYW1lIiwiaXNBbmNob3JOb2RlTmFtZSIsInRvVXBwZXJDYXNlIiwicHJldmVudERlZmF1bHQiLCJuYXZpZ2F0ZSIsIm1ldGhvZCIsImZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24iLCJzdGFydFRyYW5zaXRpb24iLCJMaW5rIiwiZm9yd2FyZFJlZiIsIl9jIiwiTGlua0NvbXBvbmVudCIsInByb3BzIiwiZm9yd2FyZGVkUmVmIiwiY3JlYXRlUHJvcEVycm9yIiwiYXJncyIsIkVycm9yIiwia2V5IiwiZXhwZWN0ZWQiLCJjb25jYXQiLCJhY3R1YWwiLCJyZXF1aXJlZFByb3BzR3VhcmQiLCJyZXF1aXJlZFByb3BzIiwia2V5cyIsImZvckVhY2giLCJfdHlwZU9mIiwiXyIsIm9wdGlvbmFsUHJvcHNHdWFyZCIsInBhc3NIcmVmIiwib25DbGljayIsIm9uTW91c2VFbnRlciIsIm9uVG91Y2hTdGFydCIsImxlZ2FjeUJlaGF2aW9yIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJoYXNXYXJuZWQiLCJ1c2VSZWYiLCJjdXJyZW50IiwiY29uc29sZSIsIndhcm4iLCJjaGlsZHJlbiIsIl9sZWdhY3lCZWhhdmlvciIsIkJvb2xlYW4iLCJlbnYiLCJfX05FWFRfTkVXX0xJTktfQkVIQVZJT1IiLCJyZXN0UHJvcHMiLCJjaGlsZHJlblByb3AiLCJjcmVhdGVFbGVtZW50IiwicCIsInByZWZldGNoUHJvcCIsInVzZUNvbnRleHQiLCJSb3V0ZXJDb250ZXh0IiwiYXBwUm91dGVyIiwiQXBwUm91dGVyQ29udGV4dCIsInVzZU1lbW8iLCJyZWYiLCJyZXNvbHZlSHJlZiIsImhyZWZQcm9wIiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZWRBcyIsImFzUHJvcCIsInByZXZpb3VzSHJlZiIsInByZXZpb3VzQXMiLCJjaGlsZCIsIkNoaWxkcmVuIiwib25seSIsImNoaWxkUmVmIiwicmVmMSIsInVzZUludGVyc2VjdGlvbiIsInJvb3RNYXJnaW4iLCJzZXRJbnRlcnNlY3Rpb25SZWYiLCJpc1Zpc2libGUiLCJyZXNldFZpc2libGUiLCJzZXRSZWYiLCJ1c2VDYWxsYmFjayIsImVsIiwidXNlRWZmZWN0Iiwic2hvdWxkUHJlZmV0Y2giLCJpc1ByZWZldGNoZWQiLCJjaGlsZFByb3BzIiwiZGVmYXVsdFByZXZlbnRlZCIsInByaW9yaXR5IiwidHlwZSIsImxvY2FsZURvbWFpbiIsImlzTG9jYWxlRG9tYWluIiwiZ2V0RG9tYWluTG9jYWxlIiwibG9jYWxlcyIsImRvbWFpbkxvY2FsZXMiLCJhZGRCYXNlUGF0aCIsImFkZExvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJjbG9uZUVsZW1lbnQiLCJhc3NpZ24iLCJfZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _slicedToArray = (__webpack_require__(/*! @swc/helpers/lib/_sliced_to_array.js */ \"./node_modules/@swc/helpers/lib/_sliced_to_array.js\")[\"default\"]);\n\nvar _s = $RefreshSig$();\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.useIntersection = useIntersection;\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\n\nvar hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nvar observers = new Map();\nvar idList = [];\n\nfunction createObserver(options) {\n  var id = {\n    root: options.root || null,\n    margin: options.rootMargin || \"\"\n  };\n  var existing = idList.find(function (obj) {\n    return obj.root === id.root && obj.margin === id.margin;\n  });\n  var instance;\n\n  if (existing) {\n    instance = observers.get(existing);\n\n    if (instance) {\n      return instance;\n    }\n  }\n\n  var elements = new Map();\n  var observer = new IntersectionObserver(function (entries) {\n    entries.forEach(function (entry) {\n      var callback = elements.get(entry.target);\n      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n\n      if (callback && isVisible) {\n        callback(isVisible);\n      }\n    });\n  }, options);\n  instance = {\n    id: id,\n    observer: observer,\n    elements: elements\n  };\n  idList.push(id);\n  observers.set(id, instance);\n  return instance;\n}\n\nfunction observe(element, callback, options) {\n  var ref = createObserver(options),\n      id = ref.id,\n      observer = ref.observer,\n      elements = ref.elements;\n  elements.set(element, callback);\n  observer.observe(element);\n  return function unobserve() {\n    elements.delete(element);\n    observer.unobserve(element); // Destroy observer when there's nothing left to watch:\n\n    if (elements.size === 0) {\n      observer.disconnect();\n      observers.delete(id);\n      var index = idList.findIndex(function (obj) {\n        return obj.root === id.root && obj.margin === id.margin;\n      });\n\n      if (index > -1) {\n        idList.splice(index, 1);\n      }\n    }\n  };\n}\n\nfunction useIntersection(param) {\n  var rootRef = param.rootRef,\n      rootMargin = param.rootMargin,\n      disabled = param.disabled;\n\n  _s();\n\n  var isDisabled = disabled || !hasIntersectionObserver;\n\n  var ref = _slicedToArray((0, _react).useState(false), 2),\n      visible = ref[0],\n      setVisible = ref[1];\n\n  var ref1 = _slicedToArray((0, _react).useState(null), 2),\n      element = ref1[0],\n      setElement = ref1[1];\n\n  (0, _react).useEffect(function () {\n    if (hasIntersectionObserver) {\n      if (isDisabled || visible) return;\n\n      if (element && element.tagName) {\n        var unobserve = observe(element, function (isVisible) {\n          return isVisible && setVisible(isVisible);\n        }, {\n          root: rootRef == null ? void 0 : rootRef.current,\n          rootMargin: rootMargin\n        });\n        return unobserve;\n      }\n    } else {\n      if (!visible) {\n        var idleCallback = (0, _requestIdleCallback).requestIdleCallback(function () {\n          return setVisible(true);\n        });\n        return function () {\n          return (0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n        };\n      }\n    }\n  }, [element, isDisabled, rootMargin, rootRef, visible]);\n  var resetVisible = (0, _react).useCallback(function () {\n    setVisible(false);\n  }, []);\n  return [setElement, visible, resetVisible];\n}\n\n_s(useIntersection, \"mCSdCffdW7h1A87zcVCmaEd/d2A=\");\n\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n  Object.defineProperty(exports.default, \"__esModule\", {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOzs7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDSCxFQUFBQTtBQUdBRSx1QkFBQUEsR0FBMEJFLGVBQTFCRjs7QUFDQSxJQUFJRyxNQUFNLEdBQUdDLG1CQUFPLENBQUMsNENBQUQsQ0FBcEI7O0FBQ0EsSUFBSUMsb0JBQW9CLEdBQUdELG1CQUFPLENBQUMseUZBQUQsQ0FBbEM7O0FBQ0EsSUFBTUUsdUJBQXVCLEdBQUcsT0FBT0Msb0JBQVAsS0FBZ0MsVUFBaEU7QUFDQSxJQUFNQyxTQUFTLEdBQUcsSUFBSUMsR0FBSixFQUFsQjtBQUNBLElBQU1DLE1BQU0sR0FBRyxFQUFmOztBQUNBLFNBQVNDLGNBQVQsQ0FBd0JDLE9BQXhCLEVBQWlDO0VBQzdCLElBQU1DLEVBQUUsR0FBRztJQUNQQyxJQUFJLEVBQUVGLE9BQU8sQ0FBQ0UsSUFBUkYsSUFBZ0IsSUFEZjtJQUVQRyxNQUFNLEVBQUVILE9BQU8sQ0FBQ0ksVUFBUkosSUFBc0I7RUFGdkIsQ0FBWDtFQUlBLElBQU1LLFFBQVEsR0FBR1AsTUFBTSxDQUFDUSxJQUFQUixDQUFZLFVBQUNTLEdBQUQsRUFBSTtXQUFHQSxHQUFHLENBQUNMLElBQUpLLEtBQWFOLEVBQUUsQ0FBQ0MsSUFBaEJLLElBQXdCQSxHQUFHLENBQUNKLE1BQUpJLEtBQWVOLEVBQUUsQ0FBQ0U7RUFBTSxDQUFuRUwsQ0FBakI7RUFDQSxJQUFJVSxRQUFKOztFQUNBLElBQUlILFFBQUosRUFBYztJQUNWRyxRQUFRLEdBQUdaLFNBQVMsQ0FBQ2EsR0FBVmIsQ0FBY1MsUUFBZFQsQ0FBWFk7O0lBQ0EsSUFBSUEsUUFBSixFQUFjO01BQ1YsT0FBT0EsUUFBUDtJQUNIO0VBQ0o7O0VBQ0QsSUFBTUUsUUFBUSxHQUFHLElBQUliLEdBQUosRUFBakI7RUFDQSxJQUFNYyxRQUFRLEdB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QUVISCxPQUZHLEVBR0hVLFlBSEcsQ0FBUDtBQUtIOztHQW5DUXpELGlCQUFlOztBQXFDeEIsSUFBSSxDQUFDLE9BQU9GLE9BQU8sQ0FBQzZELE9BQWYsS0FBMkIsVUFBM0IsSUFBMEMsT0FBTzdELE9BQU8sQ0FBQzZELE9BQWYsS0FBMkIsUUFBM0IsSUFBdUM3RCxPQUFPLENBQUM2RCxPQUFSN0QsS0FBb0IsSUFBdEcsS0FBZ0gsT0FBT0EsT0FBTyxDQUFDNkQsT0FBUjdELENBQWdCOEQsVUFBdkIsS0FBc0MsV0FBMUosRUFBdUs7RUFDcktoRSxNQUFNLENBQUNDLGNBQVBELENBQXNCRSxPQUFPLENBQUM2RCxPQUE5Qi9ELEVBQXVDLFlBQXZDQSxFQUFxRDtJQUFFRyxLQUFLLEVBQUU7RUFBVCxDQUFyREg7RUFDQUEsTUFBTSxDQUFDaUUsTUFBUGpFLENBQWNFLE9BQU8sQ0FBQzZELE9BQXRCL0QsRUFBK0JFLE9BQS9CRjtFQUNBa0UsTUFBTSxDQUFDaEUsT0FBUGdFLEdBQWlCaEUsT0FBTyxDQUFDNkQsT0FBekJHO0FBQ0QsQyxDQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanM/ZmQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudXNlSW50ZXJzZWN0aW9uID0gdXNlSW50ZXJzZWN0aW9uO1xudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBfcmVxdWVzdElkbGVDYWxsYmFjayA9IHJlcXVpcmUoXCIuL3JlcXVlc3QtaWRsZS1jYWxsYmFja1wiKTtcbmNvbnN0IGhhc0ludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nO1xuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuY29uc3QgaWRMaXN0ID0gW107XG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zKSB7XG4gICAgY29uc3QgaWQgPSB7XG4gICAgICAgIHJvb3Q6IG9wdGlvbnMucm9vdCB8fCBudWxsLFxuICAgICAgICBtYXJnaW46IG9wdGlvbnMucm9vdE1hcmdpbiB8fCAnJ1xuICAgIH07XG4gICAgY29uc3QgZXhpc3RpbmcgPSBpZExpc3QuZmluZCgob2JqKT0+b2JqLnJvb3QgPT09IGlkLnJvb3QgJiYgb2JqLm1hcmdpbiA9PT0gaWQubWFyZ2luKTtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgIGluc3RhbmNlID0gb2JzZXJ2ZXJzLmdldChleGlzdGluZyk7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKT0+e1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KT0+e1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBlbGVtZW50cy5nZXQoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMDtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBpc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpc1Zpc2libGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpbnN0YW5jZSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIG9ic2VydmVyLFxuICAgICAgICBlbGVtZW50c1xuICAgIH07XG4gICAgaWRMaXN0LnB1c2goaWQpO1xuICAgIG9ic2VydmVycy5zZXQoaWQsIGluc3RhbmNlKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBvYnNlcnZlKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBpZCAsIG9ic2VydmVyICwgZWxlbWVudHMgIH0gPSBjcmVhdGVPYnNlcnZlcihvcHRpb25zKTtcbiAgICBlbGVtZW50cy5zZXQoZWxlbWVudCwgY2FsbGJhY2spO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVub2JzZXJ2ZSgpIHtcbiAgICAgICAgZWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgIC8vIERlc3Ryb3kgb2JzZXJ2ZXIgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byB3YXRjaDpcbiAgICAgICAgaWYgKGVsZW1lbnRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIG9ic2VydmVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpZExpc3QuZmluZEluZGV4KChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW4pO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZExpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiB1c2VJbnRlcnNlY3Rpb24oeyByb290UmVmICwgcm9vdE1hcmdpbiAsIGRpc2FibGVkICB9KSB7XG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IGRpc2FibGVkIHx8ICFoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbiAgICBjb25zdCBbdmlzaWJsZSwgc2V0VmlzaWJsZV0gPSAoMCwgX3JlYWN0KS51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2VsZW1lbnQsIHNldEVsZW1lbnRdID0gKDAsIF9yZWFjdCkudXNlU3RhdGUobnVsbCk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgdmlzaWJsZSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5vYnNlcnZlID0gb2JzZXJ2ZShlbGVtZW50LCAoaXNWaXNpYmxlKT0+aXNWaXNpYmxlICYmIHNldFZpc2libGUoaXNWaXNpYmxlKSwge1xuICAgICAgICAgICAgICAgICAgICByb290OiByb290UmVmID09IG51bGwgPyB2b2lkIDAgOiByb290UmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIHJvb3RNYXJnaW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5vYnNlcnZlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWRsZUNhbGxiYWNrID0gKDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpPT5zZXRWaXNpYmxlKHRydWUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCk9PigwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykuY2FuY2VsSWRsZUNhbGxiYWNrKGlkbGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIGlzRGlzYWJsZWQsXG4gICAgICAgIHJvb3RNYXJnaW4sXG4gICAgICAgIHJvb3RSZWYsXG4gICAgICAgIHZpc2libGVcbiAgICBdKTtcbiAgICBjb25zdCByZXNldFZpc2libGUgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygoKT0+e1xuICAgICAgICBzZXRWaXNpYmxlKGZhbHNlKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc2V0RWxlbWVudCxcbiAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgcmVzZXRWaXNpYmxlXG4gICAgXTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWludGVyc2VjdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1c2VJbnRlcnNlY3Rpb24iLCJfcmVhY3QiLCJyZXF1aXJlIiwiX3JlcXVlc3RJZGxlQ2FsbGJhY2siLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwib2JzZXJ2ZXJzIiwiTWFwIiwiaWRMaXN0IiwiY3JlYXRlT2JzZXJ2ZXIiLCJvcHRpb25zIiwiaWQiLCJyb290IiwibWFyZ2luIiwicm9vdE1hcmdpbiIsImV4aXN0aW5nIiwiZmluZCIsIm9iaiIsImluc3RhbmNlIiwiZ2V0IiwiZWxlbWVudHMiLCJvYnNlcnZlciIsImVudHJpZXMiLCJmb3JFYWNoIiwiZW50cnkiLCJjYWxsYmFjayIsInRhcmdldCIsImlzVmlzaWJsZSIsImlzSW50ZXJzZWN0aW5nIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJwdXNoIiwic2V0Iiwib2JzZXJ2ZSIsImVsZW1lbnQiLCJ1bm9ic2VydmUiLCJkZWxldGUiLCJzaXplIiwiZGlzY29ubmVjdCIsImluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwicGFyYW0iLCJyb290UmVmIiwiZGlzYWJsZWQiLCJpc0Rpc2FibGVkIiwicmVmIiwidXNlU3RhdGUiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsInJlZjEiLCJzZXRFbGVtZW50IiwidXNlRWZmZWN0IiwidGFnTmFtZSIsImN1cnJlbnQiLCJpZGxlQ2FsbGJhY2siLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwicmVzZXRWaXNpYmxlIiwidXNlQ2FsbGJhY2siLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/app-router-context.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/app-router-context.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TemplateContext = exports.GlobalLayoutRouterContext = exports.LayoutRouterContext = exports.AppRouterContext = void 0;\n\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\n\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar AppRouterContext = _react.default.createContext(null);\n\nexports.AppRouterContext = AppRouterContext;\n\nvar LayoutRouterContext = _react.default.createContext(null);\n\nexports.LayoutRouterContext = LayoutRouterContext;\n\nvar GlobalLayoutRouterContext = _react.default.createContext(null);\n\nexports.GlobalLayoutRouterContext = GlobalLayoutRouterContext;\n\nvar TemplateContext = _react.default.createContext(null);\n\nexports.TemplateContext = TemplateContext;\n\nif (true) {\n  AppRouterContext.displayName = \"AppRouterContext\";\n  LayoutRouterContext.displayName = \"LayoutRouterContext\";\n  GlobalLayoutRouterContext.displayName = \"GlobalLayoutRouterContext\";\n  TemplateContext.displayName = \"TemplateContext\";\n} //# sourceMappingURL=app-router-context.js.map\n\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3Q0gsRUFBQUE7QUFHQUUsdUJBQUFBLEdBQTBCQSxpQ0FBQUEsR0FBb0NBLDJCQUFBQSxHQUE4QkEsd0JBQUFBLEdBQTJCLEtBQUssQ0FBNUhBOztBQUNBLElBQUlNLHdCQUF3QixHQUFHQyxtSkFBL0I7O0FBQ0EsSUFBSUUsTUFBTSxHQUFHSCx3QkFBd0IsQ0FBQ0MsbUJBQU8sQ0FBQyw0Q0FBRCxDQUFSLENBQXJDOztBQUNBLElBQU1GLGdCQUFnQixHQUFHSSxNQUFNLENBQUNELE9BQVBDLENBQWVDLGFBQWZELENBQTZCLElBQTdCQSxDQUF6Qjs7QUFDQVQsd0JBQUFBLEdBQTJCSyxnQkFBM0JMOztBQUNBLElBQU1JLG1CQUFtQixHQUFHSyxNQUFNLENBQUNELE9BQVBDLENBQWVDLGFBQWZELENBQTZCLElBQTdCQSxDQUE1Qjs7QUFDQVQsMkJBQUFBLEdBQThCSSxtQkFBOUJKOztBQUNBLElBQU1HLHlCQUF5QixHQUFHTSxNQUFNLENBQUNELE9BQVBDLENBQWVDLGFBQWZELENBQTZCLElBQTdCQSxDQUFsQzs7QUFDQVQsaUNBQUFBLEdBQW9DRyx5QkFBcENIOztBQUNBLElBQU1FLGVBQWUsR0FBR08sTUFBTSxDQUFDRCxPQUFQQyxDQUFlQyxhQUFmRCxDQUE2QixJQUE3QkEsQ0FBeEI7O0FBQ0FULHVCQUFBQSxHQUEwQkUsZUFBMUJGOztBQUNBLElBQUlXLElBQUosRUFBMkM7RUFDdkNOLGdCQUFnQixDQUFDTyxXQUFqQlAsR0FBK0Isa0JBQS9CQTtFQUNBRCxtQkFBbUIsQ0FBQ1EsV0FBcEJSLEdBQWtDLHFCQUFsQ0E7RUFDQUQseUJBQXlCLENBQUNTLFdBQTFCVCxHQUF3QywyQkFBeENBO0VBQ0FELGVBQWUsQ0FBQ1UsV0FBaEJWLEdBQThCLGlCQUE5QkE7QUFDSCxDLENBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5qcz9kYmRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5UZW1wbGF0ZUNvbnRleHQgPSBleHBvcnRzLkdsb2JhbExheW91dFJvdXRlckNvbnRleHQgPSBleHBvcnRzLkxheW91dFJvdXRlckNvbnRleHQgPSBleHBvcnRzLkFwcFJvdXRlckNvbnRleHQgPSB2b2lkIDA7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBBcHBSb3V0ZXJDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChudWxsKTtcbmV4cG9ydHMuQXBwUm91dGVyQ29udGV4dCA9IEFwcFJvdXRlckNvbnRleHQ7XG5jb25zdCBMYXlvdXRSb3V0ZXJDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChudWxsKTtcbmV4cG9ydHMuTGF5b3V0Um91dGVyQ29udGV4dCA9IExheW91dFJvdXRlckNvbnRleHQ7XG5jb25zdCBHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChudWxsKTtcbmV4cG9ydHMuR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCA9IEdsb2JhbExheW91dFJvdXRlckNvbnRleHQ7XG5jb25zdCBUZW1wbGF0ZUNvbnRleHQgPSBfcmVhY3QuZGVmYXVsdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuZXhwb3J0cy5UZW1wbGF0ZUNvbnRleHQgPSBUZW1wbGF0ZUNvbnRleHQ7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIEFwcFJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnQXBwUm91dGVyQ29udGV4dCc7XG4gICAgTGF5b3V0Um91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdMYXlvdXRSb3V0ZXJDb250ZXh0JztcbiAgICBHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0dsb2JhbExheW91dFJvdXRlckNvbnRleHQnO1xuICAgIFRlbXBsYXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdUZW1wbGF0ZUNvbnRleHQnO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGVyLWNvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVGVtcGxhdGVDb250ZXh0IiwiR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsIkxheW91dFJvdXRlckNvbnRleHQiLCJBcHBSb3V0ZXJDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsImRlZmF1bHQiLCJfcmVhY3QiLCJjcmVhdGVDb250ZXh0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/app-router-context.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.matchRemotePattern = matchRemotePattern;\nexports.hasMatch = hasMatch;\n\nvar _micromatch = __webpack_require__(/*! next/dist/compiled/micromatch */ \"./node_modules/next/dist/compiled/micromatch/index.js\");\n\nfunction matchRemotePattern(pattern, url) {\n  if (pattern.protocol !== undefined) {\n    var actualProto = url.protocol.slice(0, -1);\n\n    if (pattern.protocol !== actualProto) {\n      return false;\n    }\n  }\n\n  if (pattern.port !== undefined) {\n    if (pattern.port !== url.port) {\n      return false;\n    }\n  }\n\n  if (pattern.hostname === undefined) {\n    throw new Error(\"Pattern should define hostname but found\\n\".concat(JSON.stringify(pattern)));\n  } else {\n    if (!(0, _micromatch).makeRe(pattern.hostname).test(url.hostname)) {\n      return false;\n    }\n  }\n\n  var _pathname;\n\n  if (!(0, _micromatch).makeRe((_pathname = pattern.pathname) != null ? _pathname : \"**\").test(url.pathname)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction hasMatch(domains, remotePatterns, url) {\n  return domains.some(function (domain) {\n    return url.hostname === domain;\n  }) || remotePatterns.some(function (p) {\n    return matchRemotePattern(p, url);\n  });\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = module.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      module.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      module.hot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          module.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        module.hot.invalidate();\n      }\n    }\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbWF0Y2gtcmVtb3RlLXBhdHRlcm4uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDSCxFQUFBQTtBQUdBRSwwQkFBQUEsR0FBNkJFLGtCQUE3QkY7QUFDQUEsZ0JBQUFBLEdBQW1CRyxRQUFuQkg7O0FBQ0EsSUFBSUksV0FBVyxHQUFHQyxtQkFBTyxDQUFDLDRGQUFELENBQXpCOztBQUNBLFNBQVNILGtCQUFULENBQTRCSSxPQUE1QixFQUFxQ0MsR0FBckMsRUFBMEM7RUFDdEMsSUFBSUQsT0FBTyxDQUFDRSxRQUFSRixLQUFxQkcsU0FBekIsRUFBb0M7SUFDaEMsSUFBTUMsV0FBVyxHQUFHSCxHQUFHLENBQUNDLFFBQUpELENBQWFJLEtBQWJKLENBQW1CLENBQW5CQSxFQUFzQixDQUFDLENBQXZCQSxDQUFwQjs7SUFDQSxJQUFJRCxPQUFPLENBQUNFLFFBQVJGLEtBQXFCSSxXQUF6QixFQUFzQztNQUNsQyxPQUFPLEtBQVA7SUFDSDtFQUNKOztFQUNELElBQUlKLE9BQU8sQ0FBQ00sSUFBUk4sS0FBaUJHLFNBQXJCLEVBQWdDO0lBQzVCLElBQUlILE9BQU8sQ0FBQ00sSUFBUk4sS0FBaUJDLEdBQUcsQ0FBQ0ssSUFBekIsRUFBK0I7TUFDM0IsT0FBTyxLQUFQO0lBQ0g7RUFDSjs7RUFDRCxJQUFJTixPQUFPLENBQUNPLFFBQVJQLEtBQXFCRyxTQUF6QixFQUFvQztJQUNoQyxNQUFNLElBQUlLLEtBQUosQ0FBVSw2Q0FBcUVDLE1BQXJFLENBQTZDQyxJQUFJLENBQUNDLFNBQUxELENBQWVWLE9BQWZVLENBQTdDLENBQVYsQ0FBTjtFQUNKLENBRkEsTUFFTztJQUNILElBQUksQ0FBQyxDQUFDLEdBQUdaLFdBQUosRUFBaUJjLE1BQWpCLENBQXdCWixPQUFPLENBQUNPLFFBQWhDLEVBQTBDTSxJQUExQyxDQUErQ1osR0FBRyxDQUFDTSxRQUFuRCxDQUFMLEVBQW1FO01BQy9ELE9BQU8sS0FBUDtJQUNIO0VBQ0o7O0VBQ0QsSUFBSU8sU0FBSjs7RUFDQSxJQUFJLENBQUMsQ0FBQyxHQUFHaEIsV0FBSixFQUFpQmMsTUFBakIsQ0FBd0IsQ0FBQ0UsU0FBUyxHQUFHZCxPQUFPLENBQUNlLFFBQXJCLEtBQWtDLElBQWxDLEdBQXlDRCxTQUF6QyxHQUFxRCxJQUE3RSxFQUFtRkQsSUFBbkYsQ0FBd0ZaLEdBQUcsQ0FBQ2MsUUFBNUYsQ0FBTCxFQUE0RztJQUN4RyxPQUFPLEtBQVA7RUFDSDs7RUFDRCxPQUFPLElBQVA7QUFDSDs7QUFDRCxTQUFTbEIsUUFBVCxDQUFrQm1CLE9BQWxCLEVBQTJCQyxjQUEzQixFQUEyQ2hCLEdBQTNDLEVBQWdEO0VBQzVDLE9BQU9lLE9BQU8sQ0FBQ0UsSUFBUkYsQ0FBYSxVQUFDRyxNQUFELEVBQU87V0FBR2xCLEdBQUcsQ0FBQ00sUUFBSk4sS0FBaUJrQjtFQUFNLENBQTlDSCxLQUFtREMsY0FBYyxDQUFDQyxJQUFmRCxDQUFvQixVQUFDRyxDQUFELEVBQUU7V0FBR3hCLGtCQUFrQixDQUFDd0IsQ0FBRCxFQUFJbkIsR0FBSjtFQUFRLENBQW5EZ0IsQ0FBMUQ7QUFDSCxDLENBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL21hdGNoLXJlbW90ZS1wYXR0ZXJuLmpzPzBjOWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1hdGNoUmVtb3RlUGF0dGVybiA9IG1hdGNoUmVtb3RlUGF0dGVybjtcbmV4cG9ydHMuaGFzTWF0Y2ggPSBoYXNNYXRjaDtcbnZhciBfbWljcm9tYXRjaCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvbWljcm9tYXRjaFwiKTtcbmZ1bmN0aW9uIG1hdGNoUmVtb3RlUGF0dGVybihwYXR0ZXJuLCB1cmwpIHtcbiAgICBpZiAocGF0dGVybi5wcm90b2NvbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGFjdHVhbFByb3RvID0gdXJsLnByb3RvY29sLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgaWYgKHBhdHRlcm4ucHJvdG9jb2wgIT09IGFjdHVhbFByb3RvKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdHRlcm4ucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuLnBvcnQgIT09IHVybC5wb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdHRlcm4uaG9zdG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdHRlcm4gc2hvdWxkIGRlZmluZSBob3N0bmFtZSBidXQgZm91bmRcXG4ke0pTT04uc3RyaW5naWZ5KHBhdHRlcm4pfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKDAsIF9taWNyb21hdGNoKS5tYWtlUmUocGF0dGVybi5ob3N0bmFtZSkudGVzdCh1cmwuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9wYXRobmFtZTtcbiAgICBpZiAoISgwLCBfbWljcm9tYXRjaCkubWFrZVJlKChfcGF0aG5hbWUgPSBwYXR0ZXJuLnBhdGhuYW1lKSAhPSBudWxsID8gX3BhdGhuYW1lIDogJyoqJykudGVzdCh1cmwucGF0aG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBoYXNNYXRjaChkb21haW5zLCByZW1vdGVQYXR0ZXJucywgdXJsKSB7XG4gICAgcmV0dXJuIGRvbWFpbnMuc29tZSgoZG9tYWluKT0+dXJsLmhvc3RuYW1lID09PSBkb21haW4pIHx8IHJlbW90ZVBhdHRlcm5zLnNvbWUoKHApPT5tYXRjaFJlbW90ZVBhdHRlcm4ocCwgdXJsKSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGNoLXJlbW90ZS1wYXR0ZXJuLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1hdGNoUmVtb3RlUGF0dGVybiIsImhhc01hdGNoIiwiX21pY3JvbWF0Y2giLCJyZXF1aXJlIiwicGF0dGVybiIsInVybCIsInByb3RvY29sIiwidW5kZWZpbmVkIiwiYWN0dWFsUHJvdG8iLCJzbGljZSIsInBvcnQiLCJob3N0bmFtZSIsIkVycm9yIiwiY29uY2F0IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1ha2VSZSIsInRlc3QiLCJfcGF0aG5hbWUiLCJwYXRobmFtZSIsImRvbWFpbnMiLCJyZW1vdGVQYXR0ZXJucyIsInNvbWUiLCJkb21haW4iLCJwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/micromatch/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/micromatch/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n(() => {\n  \"use strict\";\n\n  var e = {\n    333: (e, t, r) => {\n      const n = r(137);\n      const u = r(179);\n      const s = r(13);\n      const o = r(719);\n\n      const braces = (e, t = {}) => {\n        let r = [];\n\n        if (Array.isArray(e)) {\n          for (let n of e) {\n            let e = braces.create(n, t);\n\n            if (Array.isArray(e)) {\n              r.push(...e);\n            } else {\n              r.push(e);\n            }\n          }\n        } else {\n          r = [].concat(braces.create(e, t));\n        }\n\n        if (t && t.expand === true && t.nodupes === true) {\n          r = [...new Set(r)];\n        }\n\n        return r;\n      };\n\n      braces.parse = (e, t = {}) => o(e, t);\n\n      braces.stringify = (e, t = {}) => {\n        if (typeof e === \"string\") {\n          return n(braces.parse(e, t), t);\n        }\n\n        return n(e, t);\n      };\n\n      braces.compile = (e, t = {}) => {\n        if (typeof e === \"string\") {\n          e = braces.parse(e, t);\n        }\n\n        return u(e, t);\n      };\n\n      braces.expand = (e, t = {}) => {\n        if (typeof e === \"string\") {\n          e = braces.parse(e, t);\n        }\n\n        let r = s(e, t);\n\n        if (t.noempty === true) {\n          r = r.filter(Boolean);\n        }\n\n        if (t.nodupes === true) {\n          r = [...new Set(r)];\n        }\n\n        return r;\n      };\n\n      braces.create = (e, t = {}) => {\n        if (e === \"\" || e.length < 3) {\n          return [e];\n        }\n\n        return t.expand !== true ? braces.compile(e, t) : braces.expand(e, t);\n      };\n\n      e.exports = braces;\n    },\n    179: (e, t, r) => {\n      const n = r(783);\n      const u = r(617);\n\n      const compile = (e, t = {}) => {\n        let walk = (e, r = {}) => {\n          let s = u.isInvalidBrace(r);\n          let o = e.invalid === true && t.escapeInvalid === true;\n          let i = s === true || o === true;\n          let a = t.escapeInvalid === true ? \"\\\\\" : \"\";\n          let l = \"\";\n\n          if (e.isOpen === true) {\n            return a + e.value;\n          }\n\n          if (e.isClose === true) {\n            return a + e.value;\n          }\n\n          if (e.type === \"open\") {\n            return i ? a + e.value : \"(\";\n          }\n\n          if (e.type === \"close\") {\n            return i ? a + e.value : \")\";\n          }\n\n          if (e.type === \"comma\") {\n            return e.prev.type === \"comma\" ? \"\" : i ? e.value : \"|\";\n          }\n\n          if (e.value) {\n            return e.value;\n          }\n\n          if (e.nodes && e.ranges > 0) {\n            let r = u.reduce(e.nodes);\n            let s = n(...r, { ...t,\n              wrap: false,\n              toRegex: true\n            });\n\n            if (s.length !== 0) {\n              return r.length > 1 && s.length > 1 ? `(${s})` : s;\n            }\n          }\n\n          if (e.nodes) {\n            for (let t of e.nodes) {\n              l += walk(t, e);\n            }\n          }\n\n          return l;\n        };\n\n        return walk(e);\n      };\n\n      e.exports = compile;\n    },\n    457: e => {\n      e.exports = {\n        MAX_LENGTH: 1024 * 64,\n        CHAR_0: \"0\",\n        CHAR_9: \"9\",\n        CHAR_UPPERCASE_A: \"A\",\n        CHAR_LOWERCASE_A: \"a\",\n        CHAR_UPPERCASE_Z: \"Z\",\n        CHAR_LOWERCASE_Z: \"z\",\n        CHAR_LEFT_PARENTHESES: \"(\",\n        CHAR_RIGHT_PARENTHESES: \")\",\n        CHAR_ASTERISK: \"*\",\n        CHAR_AMPERSAND: \"&\",\n        CHAR_AT: \"@\",\n        CHAR_BACKSLASH: \"\\\\\",\n        CHAR_BACKTICK: \"`\",\n        CHAR_CARRIAGE_RETURN: \"\\r\",\n        CHAR_CIRCUMFLEX_ACCENT: \"^\",\n        CHAR_COLON: \":\",\n        CHAR_COMMA: \",\",\n        CHAR_DOLLAR: \"$\",\n        CHAR_DOT: \".\",\n        CHAR_DOUBLE_QUOTE: '\"',\n        CHAR_EQUAL: \"=\",\n        CHAR_EXCLAMATION_MARK: \"!\",\n        CHAR_FORM_FEED: \"\\f\",\n        CHAR_FORWARD_SLASH: \"/\",\n        CHAR_HASH: \"#\",\n        CHAR_HYPHEN_MINUS: \"-\",\n        CHAR_LEFT_ANGLE_BRACKET: \"<\",\n        CHAR_LEFT_CURLY_BRACE: \"{\",\n        CHAR_LEFT_SQUARE_BRACKET: \"[\",\n        CHAR_LINE_FEED: \"\\n\",\n        CHAR_NO_BREAK_SPACE: \"\",\n        CHAR_PERCENT: \"%\",\n        CHAR_PLUS: \"+\",\n        CHAR_QUESTION_MARK: \"?\",\n        CHAR_RIGHT_ANGLE_BRACKET: \">\",\n        CHAR_RIGHT_CURLY_BRACE: \"}\",\n        CHAR_RIGHT_SQUARE_BRACKET: \"]\",\n        CHAR_SEMICOLON: \";\",\n        CHAR_SINGLE_QUOTE: \"'\",\n        CHAR_SPACE: \" \",\n        CHAR_TAB: \"\\t\",\n        CHAR_UNDERSCORE: \"_\",\n        CHAR_VERTICAL_LINE: \"|\",\n        CHAR_ZERO_WIDTH_NOBREAK_SPACE: \"\\ufeff\"\n      };\n    },\n    13: (e, t, r) => {\n      const n = r(783);\n      const u = r(137);\n      const s = r(617);\n\n      const append = (e = \"\", t = \"\", r = false) => {\n        let n = [];\n        e = [].concat(e);\n        t = [].concat(t);\n        if (!t.length) return e;\n\n        if (!e.length) {\n          return r ? s.flatten(t).map(e => `{${e}}`) : t;\n        }\n\n        for (let u of e) {\n          if (Array.isArray(u)) {\n            for (let e of u) {\n              n.push(append(e, t, r));\n            }\n          } else {\n            for (let e of t) {\n              if (r === true && typeof e === \"string\") e = `{${e}}`;\n              n.push(Array.isArray(e) ? append(u, e, r) : u + e);\n            }\n          }\n        }\n\n        return s.flatten(n);\n      };\n\n      const expand = (e, t = {}) => {\n        let r = t.rangeLimit === void 0 ? 1e3 : t.rangeLimit;\n\n        let walk = (e, o = {}) => {\n          e.queue = [];\n          let i = o;\n          let a = o.queue;\n\n          while (i.type !== \"brace\" && i.type !== \"root\" && i.parent) {\n            i = i.parent;\n            a = i.queue;\n          }\n\n          if (e.invalid || e.dollar) {\n            a.push(append(a.pop(), u(e, t)));\n            return;\n          }\n\n          if (e.type === \"brace\" && e.invalid !== true && e.nodes.length === 2) {\n            a.push(append(a.pop(), [\"{}\"]));\n            return;\n          }\n\n          if (e.nodes && e.ranges > 0) {\n            let o = s.reduce(e.nodes);\n\n            if (s.exceedsLimit(...o, t.step, r)) {\n              throw new RangeError(\"expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.\");\n            }\n\n            let i = n(...o, t);\n\n            if (i.length === 0) {\n              i = u(e, t);\n            }\n\n            a.push(append(a.pop(), i));\n            e.nodes = [];\n            return;\n          }\n\n          let l = s.encloseBrace(e);\n          let c = e.queue;\n          let p = e;\n\n          while (p.type !== \"brace\" && p.type !== \"root\" && p.parent) {\n            p = p.parent;\n            c = p.queue;\n          }\n\n          for (let t = 0; t < e.nodes.length; t++) {\n            let r = e.nodes[t];\n\n            if (r.type === \"comma\" && e.type === \"brace\") {\n              if (t === 1) c.push(\"\");\n              c.push(\"\");\n              continue;\n            }\n\n            if (r.type === \"close\") {\n              a.push(append(a.pop(), c, l));\n              continue;\n            }\n\n            if (r.value && r.type !== \"open\") {\n              c.push(append(c.pop(), r.value));\n              continue;\n            }\n\n            if (r.nodes) {\n              walk(r, e);\n            }\n          }\n\n          return c;\n        };\n\n        return s.flatten(walk(e));\n      };\n\n      e.exports = expand;\n    },\n    719: (e, t, r) => {\n      const n = r(137);\n      const {\n        MAX_LENGTH: u,\n        CHAR_BACKSLASH: s,\n        CHAR_BACKTICK: o,\n        CHAR_COMMA: i,\n        CHAR_DOT: a,\n        CHAR_LEFT_PARENTHESES: l,\n        CHAR_RIGHT_PARENTHESES: c,\n        CHAR_LEFT_CURLY_BRACE: p,\n        CHAR_RIGHT_CURLY_BRACE: f,\n        CHAR_LEFT_SQUARE_BRACKET: A,\n        CHAR_RIGHT_SQUARE_BRACKET: R,\n        CHAR_DOUBLE_QUOTE: _,\n        CHAR_SINGLE_QUOTE: h,\n        CHAR_NO_BREAK_SPACE: g,\n        CHAR_ZERO_WIDTH_NOBREAK_SPACE: E\n      } = r(457);\n\n      const parse = (e, t = {}) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(\"Expected a string\");\n        }\n\n        let r = t || {};\n        let C = typeof r.maxLength === \"number\" ? Math.min(u, r.maxLength) : u;\n\n        if (e.length > C) {\n          throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${C})`);\n        }\n\n        let y = {\n          type: \"root\",\n          input: e,\n          nodes: []\n        };\n        let d = [y];\n        let x = y;\n        let b = y;\n        let S = 0;\n        let H = e.length;\n        let v = 0;\n        let $ = 0;\n        let m;\n        let T = {};\n\n        const advance = () => e[v++];\n\n        const push = e => {\n          if (e.type === \"text\" && b.type === \"dot\") {\n            b.type = \"text\";\n          }\n\n          if (b && b.type === \"text\" && e.type === \"text\") {\n            b.value += e.value;\n            return;\n          }\n\n          x.nodes.push(e);\n          e.parent = x;\n          e.prev = b;\n          b = e;\n          return e;\n        };\n\n        push({\n          type: \"bos\"\n        });\n\n        while (v < H) {\n          x = d[d.length - 1];\n          m = advance();\n\n          if (m === E || m === g) {\n            continue;\n          }\n\n          if (m === s) {\n            push({\n              type: \"text\",\n              value: (t.keepEscaping ? m : \"\") + advance()\n            });\n            continue;\n          }\n\n          if (m === R) {\n            push({\n              type: \"text\",\n              value: \"\\\\\" + m\n            });\n            continue;\n          }\n\n          if (m === A) {\n            S++;\n            let e = true;\n            let t;\n\n            while (v < H && (t = advance())) {\n              m += t;\n\n              if (t === A) {\n                S++;\n                continue;\n              }\n\n              if (t === s) {\n                m += advance();\n                continue;\n              }\n\n              if (t === R) {\n                S--;\n\n                if (S === 0) {\n                  break;\n                }\n              }\n            }\n\n            push({\n              type: \"text\",\n              value: m\n            });\n            continue;\n          }\n\n          if (m === l) {\n            x = push({\n              type: \"paren\",\n              nodes: []\n            });\n            d.push(x);\n            push({\n              type: \"text\",\n              value: m\n            });\n            continue;\n          }\n\n          if (m === c) {\n            if (x.type !== \"paren\") {\n              push({\n                type: \"text\",\n                value: m\n              });\n              continue;\n            }\n\n            x = d.pop();\n            push({\n              type: \"text\",\n              value: m\n            });\n            x = d[d.length - 1];\n            continue;\n          }\n\n          if (m === _ || m === h || m === o) {\n            let e = m;\n            let r;\n\n            if (t.keepQuotes !== true) {\n              m = \"\";\n            }\n\n            while (v < H && (r = advance())) {\n              if (r === s) {\n                m += r + advance();\n                continue;\n              }\n\n              if (r === e) {\n                if (t.keepQuotes === true) m += r;\n                break;\n              }\n\n              m += r;\n            }\n\n            push({\n              type: \"text\",\n              value: m\n            });\n            continue;\n          }\n\n          if (m === p) {\n            $++;\n            let e = b.value && b.value.slice(-1) === \"$\" || x.dollar === true;\n            let t = {\n              type: \"brace\",\n              open: true,\n              close: false,\n              dollar: e,\n              depth: $,\n              commas: 0,\n              ranges: 0,\n              nodes: []\n            };\n            x = push(t);\n            d.push(x);\n            push({\n              type: \"open\",\n              value: m\n            });\n            continue;\n          }\n\n          if (m === f) {\n            if (x.type !== \"brace\") {\n              push({\n                type: \"text\",\n                value: m\n              });\n              continue;\n            }\n\n            let e = \"close\";\n            x = d.pop();\n            x.close = true;\n            push({\n              type: e,\n              value: m\n            });\n            $--;\n            x = d[d.length - 1];\n            continue;\n          }\n\n          if (m === i && $ > 0) {\n            if (x.ranges > 0) {\n              x.ranges = 0;\n              let e = x.nodes.shift();\n              x.nodes = [e, {\n                type: \"text\",\n                value: n(x)\n              }];\n            }\n\n            push({\n              type: \"comma\",\n              value: m\n            });\n            x.commas++;\n            continue;\n          }\n\n          if (m === a && $ > 0 && x.commas === 0) {\n            let e = x.nodes;\n\n            if ($ === 0 || e.length === 0) {\n              push({\n                type: \"text\",\n                value: m\n              });\n              continue;\n            }\n\n            if (b.type === \"dot\") {\n              x.range = [];\n              b.value += m;\n              b.type = \"range\";\n\n              if (x.nodes.length !== 3 && x.nodes.length !== 5) {\n                x.invalid = true;\n                x.ranges = 0;\n                b.type = \"text\";\n                continue;\n              }\n\n              x.ranges++;\n              x.args = [];\n              continue;\n            }\n\n            if (b.type === \"range\") {\n              e.pop();\n              let t = e[e.length - 1];\n              t.value += b.value + m;\n              b = t;\n              x.ranges--;\n              continue;\n            }\n\n            push({\n              type: \"dot\",\n              value: m\n            });\n            continue;\n          }\n\n          push({\n            type: \"text\",\n            value: m\n          });\n        }\n\n        do {\n          x = d.pop();\n\n          if (x.type !== \"root\") {\n            x.nodes.forEach(e => {\n              if (!e.nodes) {\n                if (e.type === \"open\") e.isOpen = true;\n                if (e.type === \"close\") e.isClose = true;\n                if (!e.nodes) e.type = \"text\";\n                e.invalid = true;\n              }\n            });\n            let e = d[d.length - 1];\n            let t = e.nodes.indexOf(x);\n            e.nodes.splice(t, 1, ...x.nodes);\n          }\n        } while (d.length > 0);\n\n        push({\n          type: \"eos\"\n        });\n        return y;\n      };\n\n      e.exports = parse;\n    },\n    137: (e, t, r) => {\n      const n = r(617);\n\n      e.exports = (e, t = {}) => {\n        let stringify = (e, r = {}) => {\n          let u = t.escapeInvalid && n.isInvalidBrace(r);\n          let s = e.invalid === true && t.escapeInvalid === true;\n          let o = \"\";\n\n          if (e.value) {\n            if ((u || s) && n.isOpenOrClose(e)) {\n              return \"\\\\\" + e.value;\n            }\n\n            return e.value;\n          }\n\n          if (e.value) {\n            return e.value;\n          }\n\n          if (e.nodes) {\n            for (let t of e.nodes) {\n              o += stringify(t);\n            }\n          }\n\n          return o;\n        };\n\n        return stringify(e);\n      };\n    },\n    617: (e, t) => {\n      t.isInteger = e => {\n        if (typeof e === \"number\") {\n          return Number.isInteger(e);\n        }\n\n        if (typeof e === \"string\" && e.trim() !== \"\") {\n          return Number.isInteger(Number(e));\n        }\n\n        return false;\n      };\n\n      t.find = (e, t) => e.nodes.find(e => e.type === t);\n\n      t.exceedsLimit = (e, r, n = 1, u) => {\n        if (u === false) return false;\n        if (!t.isInteger(e) || !t.isInteger(r)) return false;\n        return (Number(r) - Number(e)) / Number(n) >= u;\n      };\n\n      t.escapeNode = (e, t = 0, r) => {\n        let n = e.nodes[t];\n        if (!n) return;\n\n        if (r && n.type === r || n.type === \"open\" || n.type === \"close\") {\n          if (n.escaped !== true) {\n            n.value = \"\\\\\" + n.value;\n            n.escaped = true;\n          }\n        }\n      };\n\n      t.encloseBrace = e => {\n        if (e.type !== \"brace\") return false;\n\n        if (e.commas >> 0 + e.ranges >> 0 === 0) {\n          e.invalid = true;\n          return true;\n        }\n\n        return false;\n      };\n\n      t.isInvalidBrace = e => {\n        if (e.type !== \"brace\") return false;\n        if (e.invalid === true || e.dollar) return true;\n\n        if (e.commas >> 0 + e.ranges >> 0 === 0) {\n          e.invalid = true;\n          return true;\n        }\n\n        if (e.open !== true || e.close !== true) {\n          e.invalid = true;\n          return true;\n        }\n\n        return false;\n      };\n\n      t.isOpenOrClose = e => {\n        if (e.type === \"open\" || e.type === \"close\") {\n          return true;\n        }\n\n        return e.open === true || e.close === true;\n      };\n\n      t.reduce = e => e.reduce((e, t) => {\n        if (t.type === \"text\") e.push(t.value);\n        if (t.type === \"range\") t.type = \"text\";\n        return e;\n      }, []);\n\n      t.flatten = (...e) => {\n        const t = [];\n\n        const flat = e => {\n          for (let r = 0; r < e.length; r++) {\n            let n = e[r];\n            Array.isArray(n) ? flat(n, t) : n !== void 0 && t.push(n);\n          }\n\n          return t;\n        };\n\n        flat(e);\n        return t;\n      };\n    },\n    783: (e, t, r) => {\n      /*!\n       * fill-range <https://github.com/jonschlinkert/fill-range>\n       *\n       * Copyright (c) 2014-present, Jon Schlinkert.\n       * Licensed under the MIT License.\n       */\n      const n = r(837);\n      const u = r(492);\n\n      const isObject = e => e !== null && typeof e === \"object\" && !Array.isArray(e);\n\n      const transform = e => t => e === true ? Number(t) : String(t);\n\n      const isValidValue = e => typeof e === \"number\" || typeof e === \"string\" && e !== \"\";\n\n      const isNumber = e => Number.isInteger(+e);\n\n      const zeros = e => {\n        let t = `${e}`;\n        let r = -1;\n        if (t[0] === \"-\") t = t.slice(1);\n        if (t === \"0\") return false;\n\n        while (t[++r] === \"0\");\n\n        return r > 0;\n      };\n\n      const stringify = (e, t, r) => {\n        if (typeof e === \"string\" || typeof t === \"string\") {\n          return true;\n        }\n\n        return r.stringify === true;\n      };\n\n      const pad = (e, t, r) => {\n        if (t > 0) {\n          let r = e[0] === \"-\" ? \"-\" : \"\";\n          if (r) e = e.slice(1);\n          e = r + e.padStart(r ? t - 1 : t, \"0\");\n        }\n\n        if (r === false) {\n          return String(e);\n        }\n\n        return e;\n      };\n\n      const toMaxLen = (e, t) => {\n        let r = e[0] === \"-\" ? \"-\" : \"\";\n\n        if (r) {\n          e = e.slice(1);\n          t--;\n        }\n\n        while (e.length < t) e = \"0\" + e;\n\n        return r ? \"-\" + e : e;\n      };\n\n      const toSequence = (e, t) => {\n        e.negatives.sort((e, t) => e < t ? -1 : e > t ? 1 : 0);\n        e.positives.sort((e, t) => e < t ? -1 : e > t ? 1 : 0);\n        let r = t.capture ? \"\" : \"?:\";\n        let n = \"\";\n        let u = \"\";\n        let s;\n\n        if (e.positives.length) {\n          n = e.positives.join(\"|\");\n        }\n\n        if (e.negatives.length) {\n          u = `-(${r}${e.negatives.join(\"|\")})`;\n        }\n\n        if (n && u) {\n          s = `${n}|${u}`;\n        } else {\n          s = n || u;\n        }\n\n        if (t.wrap) {\n          return `(${r}${s})`;\n        }\n\n        return s;\n      };\n\n      const toRange = (e, t, r, n) => {\n        if (r) {\n          return u(e, t, {\n            wrap: false,\n            ...n\n          });\n        }\n\n        let s = String.fromCharCode(e);\n        if (e === t) return s;\n        let o = String.fromCharCode(t);\n        return `[${s}-${o}]`;\n      };\n\n      const toRegex = (e, t, r) => {\n        if (Array.isArray(e)) {\n          let t = r.wrap === true;\n          let n = r.capture ? \"\" : \"?:\";\n          return t ? `(${n}${e.join(\"|\")})` : e.join(\"|\");\n        }\n\n        return u(e, t, r);\n      };\n\n      const rangeError = (...e) => new RangeError(\"Invalid range arguments: \" + n.inspect(...e));\n\n      const invalidRange = (e, t, r) => {\n        if (r.strictRanges === true) throw rangeError([e, t]);\n        return [];\n      };\n\n      const invalidStep = (e, t) => {\n        if (t.strictRanges === true) {\n          throw new TypeError(`Expected step \"${e}\" to be a number`);\n        }\n\n        return [];\n      };\n\n      const fillNumbers = (e, t, r = 1, n = {}) => {\n        let u = Number(e);\n        let s = Number(t);\n\n        if (!Number.isInteger(u) || !Number.isInteger(s)) {\n          if (n.strictRanges === true) throw rangeError([e, t]);\n          return [];\n        }\n\n        if (u === 0) u = 0;\n        if (s === 0) s = 0;\n        let o = u > s;\n        let i = String(e);\n        let a = String(t);\n        let l = String(r);\n        r = Math.max(Math.abs(r), 1);\n        let c = zeros(i) || zeros(a) || zeros(l);\n        let p = c ? Math.max(i.length, a.length, l.length) : 0;\n        let f = c === false && stringify(e, t, n) === false;\n        let A = n.transform || transform(f);\n\n        if (n.toRegex && r === 1) {\n          return toRange(toMaxLen(e, p), toMaxLen(t, p), true, n);\n        }\n\n        let R = {\n          negatives: [],\n          positives: []\n        };\n\n        let push = e => R[e < 0 ? \"negatives\" : \"positives\"].push(Math.abs(e));\n\n        let _ = [];\n        let h = 0;\n\n        while (o ? u >= s : u <= s) {\n          if (n.toRegex === true && r > 1) {\n            push(u);\n          } else {\n            _.push(pad(A(u, h), p, f));\n          }\n\n          u = o ? u - r : u + r;\n          h++;\n        }\n\n        if (n.toRegex === true) {\n          return r > 1 ? toSequence(R, n) : toRegex(_, null, {\n            wrap: false,\n            ...n\n          });\n        }\n\n        return _;\n      };\n\n      const fillLetters = (e, t, r = 1, n = {}) => {\n        if (!isNumber(e) && e.length > 1 || !isNumber(t) && t.length > 1) {\n          return invalidRange(e, t, n);\n        }\n\n        let u = n.transform || (e => String.fromCharCode(e));\n\n        let s = `${e}`.charCodeAt(0);\n        let o = `${t}`.charCodeAt(0);\n        let i = s > o;\n        let a = Math.min(s, o);\n        let l = Math.max(s, o);\n\n        if (n.toRegex && r === 1) {\n          return toRange(a, l, false, n);\n        }\n\n        let c = [];\n        let p = 0;\n\n        while (i ? s >= o : s <= o) {\n          c.push(u(s, p));\n          s = i ? s - r : s + r;\n          p++;\n        }\n\n        if (n.toRegex === true) {\n          return toRegex(c, null, {\n            wrap: false,\n            options: n\n          });\n        }\n\n        return c;\n      };\n\n      const fill = (e, t, r, n = {}) => {\n        if (t == null && isValidValue(e)) {\n          return [e];\n        }\n\n        if (!isValidValue(e) || !isValidValue(t)) {\n          return invalidRange(e, t, n);\n        }\n\n        if (typeof r === \"function\") {\n          return fill(e, t, 1, {\n            transform: r\n          });\n        }\n\n        if (isObject(r)) {\n          return fill(e, t, 0, r);\n        }\n\n        let u = { ...n\n        };\n        if (u.capture === true) u.wrap = true;\n        r = r || u.step || 1;\n\n        if (!isNumber(r)) {\n          if (r != null && !isObject(r)) return invalidStep(r, u);\n          return fill(e, t, 1, r);\n        }\n\n        if (isNumber(e) && isNumber(t)) {\n          return fillNumbers(e, t, r, u);\n        }\n\n        return fillLetters(e, t, Math.max(Math.abs(r), 1), u);\n      };\n\n      e.exports = fill;\n    },\n    357: e => {\n      /*!\n       * is-number <https://github.com/jonschlinkert/is-number>\n       *\n       * Copyright (c) 2014-present, Jon Schlinkert.\n       * Released under the MIT License.\n       */\n      e.exports = function (e) {\n        if (typeof e === \"number\") {\n          return e - e === 0;\n        }\n\n        if (typeof e === \"string\" && e.trim() !== \"\") {\n          return Number.isFinite ? Number.isFinite(+e) : isFinite(+e);\n        }\n\n        return false;\n      };\n    },\n    971: (e, t, r) => {\n      const n = r(837);\n      const u = r(333);\n      const s = r(251);\n      const o = r(513);\n\n      const isEmptyString = e => e === \"\" || e === \"./\";\n\n      const micromatch = (e, t, r) => {\n        t = [].concat(t);\n        e = [].concat(e);\n        let n = new Set();\n        let u = new Set();\n        let o = new Set();\n        let i = 0;\n\n        let onResult = e => {\n          o.add(e.output);\n\n          if (r && r.onResult) {\n            r.onResult(e);\n          }\n        };\n\n        for (let o = 0; o < t.length; o++) {\n          let a = s(String(t[o]), { ...r,\n            onResult: onResult\n          }, true);\n          let l = a.state.negated || a.state.negatedExtglob;\n          if (l) i++;\n\n          for (let t of e) {\n            let e = a(t, true);\n            let r = l ? !e.isMatch : e.isMatch;\n            if (!r) continue;\n\n            if (l) {\n              n.add(e.output);\n            } else {\n              n.delete(e.output);\n              u.add(e.output);\n            }\n          }\n        }\n\n        let a = i === t.length ? [...o] : [...u];\n        let l = a.filter(e => !n.has(e));\n\n        if (r && l.length === 0) {\n          if (r.failglob === true) {\n            throw new Error(`No matches found for \"${t.join(\", \")}\"`);\n          }\n\n          if (r.nonull === true || r.nullglob === true) {\n            return r.unescape ? t.map(e => e.replace(/\\\\/g, \"\")) : t;\n          }\n        }\n\n        return l;\n      };\n\n      micromatch.match = micromatch;\n\n      micromatch.matcher = (e, t) => s(e, t);\n\n      micromatch.isMatch = (e, t, r) => s(t, r)(e);\n\n      micromatch.any = micromatch.isMatch;\n\n      micromatch.not = (e, t, r = {}) => {\n        t = [].concat(t).map(String);\n        let n = new Set();\n        let u = [];\n\n        let onResult = e => {\n          if (r.onResult) r.onResult(e);\n          u.push(e.output);\n        };\n\n        let s = micromatch(e, t, { ...r,\n          onResult: onResult\n        });\n\n        for (let e of u) {\n          if (!s.includes(e)) {\n            n.add(e);\n          }\n        }\n\n        return [...n];\n      };\n\n      micromatch.contains = (e, t, r) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(`Expected a string: \"${n.inspect(e)}\"`);\n        }\n\n        if (Array.isArray(t)) {\n          return t.some(t => micromatch.contains(e, t, r));\n        }\n\n        if (typeof t === \"string\") {\n          if (isEmptyString(e) || isEmptyString(t)) {\n            return false;\n          }\n\n          if (e.includes(t) || e.startsWith(\"./\") && e.slice(2).includes(t)) {\n            return true;\n          }\n        }\n\n        return micromatch.isMatch(e, t, { ...r,\n          contains: true\n        });\n      };\n\n      micromatch.matchKeys = (e, t, r) => {\n        if (!o.isObject(e)) {\n          throw new TypeError(\"Expected the first argument to be an object\");\n        }\n\n        let n = micromatch(Object.keys(e), t, r);\n        let u = {};\n\n        for (let t of n) u[t] = e[t];\n\n        return u;\n      };\n\n      micromatch.some = (e, t, r) => {\n        let n = [].concat(e);\n\n        for (let e of [].concat(t)) {\n          let t = s(String(e), r);\n\n          if (n.some(e => t(e))) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      micromatch.every = (e, t, r) => {\n        let n = [].concat(e);\n\n        for (let e of [].concat(t)) {\n          let t = s(String(e), r);\n\n          if (!n.every(e => t(e))) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n\n      micromatch.all = (e, t, r) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(`Expected a string: \"${n.inspect(e)}\"`);\n        }\n\n        return [].concat(t).every(t => s(t, r)(e));\n      };\n\n      micromatch.capture = (e, t, r) => {\n        let n = o.isWindows(r);\n        let u = s.makeRe(String(e), { ...r,\n          capture: true\n        });\n        let i = u.exec(n ? o.toPosixSlashes(t) : t);\n\n        if (i) {\n          return i.slice(1).map(e => e === void 0 ? \"\" : e);\n        }\n      };\n\n      micromatch.makeRe = (...e) => s.makeRe(...e);\n\n      micromatch.scan = (...e) => s.scan(...e);\n\n      micromatch.parse = (e, t) => {\n        let r = [];\n\n        for (let n of [].concat(e || [])) {\n          for (let e of u(String(n), t)) {\n            r.push(s.parse(e, t));\n          }\n        }\n\n        return r;\n      };\n\n      micromatch.braces = (e, t) => {\n        if (typeof e !== \"string\") throw new TypeError(\"Expected a string\");\n\n        if (t && t.nobrace === true || !/\\{.*\\}/.test(e)) {\n          return [e];\n        }\n\n        return u(e, t);\n      };\n\n      micromatch.braceExpand = (e, t) => {\n        if (typeof e !== \"string\") throw new TypeError(\"Expected a string\");\n        return micromatch.braces(e, { ...t,\n          expand: true\n        });\n      };\n\n      e.exports = micromatch;\n    },\n    251: (e, t, r) => {\n      e.exports = r(683);\n    },\n    356: (e, t, r) => {\n      const n = r(17);\n      const u = \"\\\\\\\\/\";\n      const s = `[^${u}]`;\n      const o = \"\\\\.\";\n      const i = \"\\\\+\";\n      const a = \"\\\\?\";\n      const l = \"\\\\/\";\n      const c = \"(?=.)\";\n      const p = \"[^/]\";\n      const f = `(?:${l}|$)`;\n      const A = `(?:^|${l})`;\n      const R = `${o}{1,2}${f}`;\n      const _ = `(?!${o})`;\n      const h = `(?!${A}${R})`;\n      const g = `(?!${o}{0,1}${f})`;\n      const E = `(?!${R})`;\n      const C = `[^.${l}]`;\n      const y = `${p}*?`;\n      const d = {\n        DOT_LITERAL: o,\n        PLUS_LITERAL: i,\n        QMARK_LITERAL: a,\n        SLASH_LITERAL: l,\n        ONE_CHAR: c,\n        QMARK: p,\n        END_ANCHOR: f,\n        DOTS_SLASH: R,\n        NO_DOT: _,\n        NO_DOTS: h,\n        NO_DOT_SLASH: g,\n        NO_DOTS_SLASH: E,\n        QMARK_NO_DOT: C,\n        STAR: y,\n        START_ANCHOR: A\n      };\n      const x = { ...d,\n        SLASH_LITERAL: `[${u}]`,\n        QMARK: s,\n        STAR: `${s}*?`,\n        DOTS_SLASH: `${o}{1,2}(?:[${u}]|$)`,\n        NO_DOT: `(?!${o})`,\n        NO_DOTS: `(?!(?:^|[${u}])${o}{1,2}(?:[${u}]|$))`,\n        NO_DOT_SLASH: `(?!${o}{0,1}(?:[${u}]|$))`,\n        NO_DOTS_SLASH: `(?!${o}{1,2}(?:[${u}]|$))`,\n        QMARK_NO_DOT: `[^.${u}]`,\n        START_ANCHOR: `(?:^|[${u}])`,\n        END_ANCHOR: `(?:[${u}]|$)`\n      };\n      const b = {\n        alnum: \"a-zA-Z0-9\",\n        alpha: \"a-zA-Z\",\n        ascii: \"\\\\x00-\\\\x7F\",\n        blank: \" \\\\t\",\n        cntrl: \"\\\\x00-\\\\x1F\\\\x7F\",\n        digit: \"0-9\",\n        graph: \"\\\\x21-\\\\x7E\",\n        lower: \"a-z\",\n        print: \"\\\\x20-\\\\x7E \",\n        punct: \"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",\n        space: \" \\\\t\\\\r\\\\n\\\\v\\\\f\",\n        upper: \"A-Z\",\n        word: \"A-Za-z0-9_\",\n        xdigit: \"A-Fa-f0-9\"\n      };\n      e.exports = {\n        MAX_LENGTH: 1024 * 64,\n        POSIX_REGEX_SOURCE: b,\n        REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n        REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n        REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n        REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n        REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n        REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n        REPLACEMENTS: {\n          \"***\": \"*\",\n          \"**/**\": \"**\",\n          \"**/**/**\": \"**\"\n        },\n        CHAR_0: 48,\n        CHAR_9: 57,\n        CHAR_UPPERCASE_A: 65,\n        CHAR_LOWERCASE_A: 97,\n        CHAR_UPPERCASE_Z: 90,\n        CHAR_LOWERCASE_Z: 122,\n        CHAR_LEFT_PARENTHESES: 40,\n        CHAR_RIGHT_PARENTHESES: 41,\n        CHAR_ASTERISK: 42,\n        CHAR_AMPERSAND: 38,\n        CHAR_AT: 64,\n        CHAR_BACKWARD_SLASH: 92,\n        CHAR_CARRIAGE_RETURN: 13,\n        CHAR_CIRCUMFLEX_ACCENT: 94,\n        CHAR_COLON: 58,\n        CHAR_COMMA: 44,\n        CHAR_DOT: 46,\n        CHAR_DOUBLE_QUOTE: 34,\n        CHAR_EQUAL: 61,\n        CHAR_EXCLAMATION_MARK: 33,\n        CHAR_FORM_FEED: 12,\n        CHAR_FORWARD_SLASH: 47,\n        CHAR_GRAVE_ACCENT: 96,\n        CHAR_HASH: 35,\n        CHAR_HYPHEN_MINUS: 45,\n        CHAR_LEFT_ANGLE_BRACKET: 60,\n        CHAR_LEFT_CURLY_BRACE: 123,\n        CHAR_LEFT_SQUARE_BRACKET: 91,\n        CHAR_LINE_FEED: 10,\n        CHAR_NO_BREAK_SPACE: 160,\n        CHAR_PERCENT: 37,\n        CHAR_PLUS: 43,\n        CHAR_QUESTION_MARK: 63,\n        CHAR_RIGHT_ANGLE_BRACKET: 62,\n        CHAR_RIGHT_CURLY_BRACE: 125,\n        CHAR_RIGHT_SQUARE_BRACKET: 93,\n        CHAR_SEMICOLON: 59,\n        CHAR_SINGLE_QUOTE: 39,\n        CHAR_SPACE: 32,\n        CHAR_TAB: 9,\n        CHAR_UNDERSCORE: 95,\n        CHAR_VERTICAL_LINE: 124,\n        CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n        SEP: n.sep,\n\n        extglobChars(e) {\n          return {\n            \"!\": {\n              type: \"negate\",\n              open: \"(?:(?!(?:\",\n              close: `))${e.STAR})`\n            },\n            \"?\": {\n              type: \"qmark\",\n              open: \"(?:\",\n              close: \")?\"\n            },\n            \"+\": {\n              type: \"plus\",\n              open: \"(?:\",\n              close: \")+\"\n            },\n            \"*\": {\n              type: \"star\",\n              open: \"(?:\",\n              close: \")*\"\n            },\n            \"@\": {\n              type: \"at\",\n              open: \"(?:\",\n              close: \")\"\n            }\n          };\n        },\n\n        globChars(e) {\n          return e === true ? x : d;\n        }\n\n      };\n    },\n    754: (e, t, r) => {\n      const n = r(356);\n      const u = r(513);\n      const {\n        MAX_LENGTH: s,\n        POSIX_REGEX_SOURCE: o,\n        REGEX_NON_SPECIAL_CHARS: i,\n        REGEX_SPECIAL_CHARS_BACKREF: a,\n        REPLACEMENTS: l\n      } = n;\n\n      const expandRange = (e, t) => {\n        if (typeof t.expandRange === \"function\") {\n          return t.expandRange(...e, t);\n        }\n\n        e.sort();\n        const r = `[${e.join(\"-\")}]`;\n\n        try {\n          new RegExp(r);\n        } catch (t) {\n          return e.map(e => u.escapeRegex(e)).join(\"..\");\n        }\n\n        return r;\n      };\n\n      const syntaxError = (e, t) => `Missing ${e}: \"${t}\" - use \"\\\\\\\\${t}\" to match literal characters`;\n\n      const parse = (e, t) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(\"Expected a string\");\n        }\n\n        e = l[e] || e;\n        const r = { ...t\n        };\n        const c = typeof r.maxLength === \"number\" ? Math.min(s, r.maxLength) : s;\n        let p = e.length;\n\n        if (p > c) {\n          throw new SyntaxError(`Input length: ${p}, exceeds maximum allowed length: ${c}`);\n        }\n\n        const f = {\n          type: \"bos\",\n          value: \"\",\n          output: r.prepend || \"\"\n        };\n        const A = [f];\n        const R = r.capture ? \"\" : \"?:\";\n\n        const _ = u.isWindows(t);\n\n        const h = n.globChars(_);\n        const g = n.extglobChars(h);\n        const {\n          DOT_LITERAL: E,\n          PLUS_LITERAL: C,\n          SLASH_LITERAL: y,\n          ONE_CHAR: d,\n          DOTS_SLASH: x,\n          NO_DOT: b,\n          NO_DOT_SLASH: S,\n          NO_DOTS_SLASH: H,\n          QMARK: v,\n          QMARK_NO_DOT: $,\n          STAR: m,\n          START_ANCHOR: T\n        } = h;\n\n        const globstar = e => `(${R}(?:(?!${T}${e.dot ? x : E}).)*?)`;\n\n        const L = r.dot ? \"\" : b;\n        const O = r.dot ? v : $;\n        let w = r.bash === true ? globstar(r) : m;\n\n        if (r.capture) {\n          w = `(${w})`;\n        }\n\n        if (typeof r.noext === \"boolean\") {\n          r.noextglob = r.noext;\n        }\n\n        const N = {\n          input: e,\n          index: -1,\n          start: 0,\n          dot: r.dot === true,\n          consumed: \"\",\n          output: \"\",\n          prefix: \"\",\n          backtrack: false,\n          negated: false,\n          brackets: 0,\n          braces: 0,\n          parens: 0,\n          quotes: 0,\n          globstar: false,\n          tokens: A\n        };\n        e = u.removePrefix(e, N);\n        p = e.length;\n        const k = [];\n        const I = [];\n        const M = [];\n        let P = f;\n        let B;\n\n        const eos = () => N.index === p - 1;\n\n        const G = N.peek = (t = 1) => e[N.index + t];\n\n        const D = N.advance = () => e[++N.index];\n\n        const remaining = () => e.slice(N.index + 1);\n\n        const consume = (e = \"\", t = 0) => {\n          N.consumed += e;\n          N.index += t;\n        };\n\n        const append = e => {\n          N.output += e.output != null ? e.output : e.value;\n          consume(e.value);\n        };\n\n        const negate = () => {\n          let e = 1;\n\n          while (G() === \"!\" && (G(2) !== \"(\" || G(3) === \"?\")) {\n            D();\n            N.start++;\n            e++;\n          }\n\n          if (e % 2 === 0) {\n            return false;\n          }\n\n          N.negated = true;\n          N.start++;\n          return true;\n        };\n\n        const increment = e => {\n          N[e]++;\n          M.push(e);\n        };\n\n        const decrement = e => {\n          N[e]--;\n          M.pop();\n        };\n\n        const push = e => {\n          if (P.type === \"globstar\") {\n            const t = N.braces > 0 && (e.type === \"comma\" || e.type === \"brace\");\n            const r = e.extglob === true || k.length && (e.type === \"pipe\" || e.type === \"paren\");\n\n            if (e.type !== \"slash\" && e.type !== \"paren\" && !t && !r) {\n              N.output = N.output.slice(0, -P.output.length);\n              P.type = \"star\";\n              P.value = \"*\";\n              P.output = w;\n              N.output += P.output;\n            }\n          }\n\n          if (k.length && e.type !== \"paren\" && !g[e.value]) {\n            k[k.length - 1].inner += e.value;\n          }\n\n          if (e.value || e.output) append(e);\n\n          if (P && P.type === \"text\" && e.type === \"text\") {\n            P.value += e.value;\n            P.output = (P.output || \"\") + e.value;\n            return;\n          }\n\n          e.prev = P;\n          A.push(e);\n          P = e;\n        };\n\n        const extglobOpen = (e, t) => {\n          const n = { ...g[t],\n            conditions: 1,\n            inner: \"\"\n          };\n          n.prev = P;\n          n.parens = N.parens;\n          n.output = N.output;\n          const u = (r.capture ? \"(\" : \"\") + n.open;\n          increment(\"parens\");\n          push({\n            type: e,\n            value: t,\n            output: N.output ? \"\" : d\n          });\n          push({\n            type: \"paren\",\n            extglob: true,\n            value: D(),\n            output: u\n          });\n          k.push(n);\n        };\n\n        const extglobClose = e => {\n          let t = e.close + (r.capture ? \")\" : \"\");\n\n          if (e.type === \"negate\") {\n            let n = w;\n\n            if (e.inner && e.inner.length > 1 && e.inner.includes(\"/\")) {\n              n = globstar(r);\n            }\n\n            if (n !== w || eos() || /^\\)+$/.test(remaining())) {\n              t = e.close = `)$))${n}`;\n            }\n\n            if (e.prev.type === \"bos\") {\n              N.negatedExtglob = true;\n            }\n          }\n\n          push({\n            type: \"paren\",\n            extglob: true,\n            value: B,\n            output: t\n          });\n          decrement(\"parens\");\n        };\n\n        if (r.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(e)) {\n          let n = false;\n          let s = e.replace(a, (e, t, r, u, s, o) => {\n            if (u === \"\\\\\") {\n              n = true;\n              return e;\n            }\n\n            if (u === \"?\") {\n              if (t) {\n                return t + u + (s ? v.repeat(s.length) : \"\");\n              }\n\n              if (o === 0) {\n                return O + (s ? v.repeat(s.length) : \"\");\n              }\n\n              return v.repeat(r.length);\n            }\n\n            if (u === \".\") {\n              return E.repeat(r.length);\n            }\n\n            if (u === \"*\") {\n              if (t) {\n                return t + u + (s ? w : \"\");\n              }\n\n              return w;\n            }\n\n            return t ? e : `\\\\${e}`;\n          });\n\n          if (n === true) {\n            if (r.unescape === true) {\n              s = s.replace(/\\\\/g, \"\");\n            } else {\n              s = s.replace(/\\\\+/g, e => e.length % 2 === 0 ? \"\\\\\\\\\" : e ? \"\\\\\" : \"\");\n            }\n          }\n\n          if (s === e && r.contains === true) {\n            N.output = e;\n            return N;\n          }\n\n          N.output = u.wrapOutput(s, N, t);\n          return N;\n        }\n\n        while (!eos()) {\n          B = D();\n\n          if (B === \"\\0\") {\n            continue;\n          }\n\n          if (B === \"\\\\\") {\n            const e = G();\n\n            if (e === \"/\" && r.bash !== true) {\n              continue;\n            }\n\n            if (e === \".\" || e === \";\") {\n              continue;\n            }\n\n            if (!e) {\n              B += \"\\\\\";\n              push({\n                type: \"text\",\n                value: B\n              });\n              continue;\n            }\n\n            const t = /^\\\\+/.exec(remaining());\n            let n = 0;\n\n            if (t && t[0].length > 2) {\n              n = t[0].length;\n              N.index += n;\n\n              if (n % 2 !== 0) {\n                B += \"\\\\\";\n              }\n            }\n\n            if (r.unescape === true) {\n              B = D() || \"\";\n            } else {\n              B += D() || \"\";\n            }\n\n            if (N.brackets === 0) {\n              push({\n                type: \"text\",\n                value: B\n              });\n              continue;\n            }\n          }\n\n          if (N.brackets > 0 && (B !== \"]\" || P.value === \"[\" || P.value === \"[^\")) {\n            if (r.posix !== false && B === \":\") {\n              const e = P.value.slice(1);\n\n              if (e.includes(\"[\")) {\n                P.posix = true;\n\n                if (e.includes(\":\")) {\n                  const e = P.value.lastIndexOf(\"[\");\n                  const t = P.value.slice(0, e);\n                  const r = P.value.slice(e + 2);\n                  const n = o[r];\n\n                  if (n) {\n                    P.value = t + n;\n                    N.backtrack = true;\n                    D();\n\n                    if (!f.output && A.indexOf(P) === 1) {\n                      f.output = d;\n                    }\n\n                    continue;\n                  }\n                }\n              }\n            }\n\n            if (B === \"[\" && G() !== \":\" || B === \"-\" && G() === \"]\") {\n              B = `\\\\${B}`;\n            }\n\n            if (B === \"]\" && (P.value === \"[\" || P.value === \"[^\")) {\n              B = `\\\\${B}`;\n            }\n\n            if (r.posix === true && B === \"!\" && P.value === \"[\") {\n              B = \"^\";\n            }\n\n            P.value += B;\n            append({\n              value: B\n            });\n            continue;\n          }\n\n          if (N.quotes === 1 && B !== '\"') {\n            B = u.escapeRegex(B);\n            P.value += B;\n            append({\n              value: B\n            });\n            continue;\n          }\n\n          if (B === '\"') {\n            N.quotes = N.quotes === 1 ? 0 : 1;\n\n            if (r.keepQuotes === true) {\n              push({\n                type: \"text\",\n                value: B\n              });\n            }\n\n            continue;\n          }\n\n          if (B === \"(\") {\n            increment(\"parens\");\n            push({\n              type: \"paren\",\n              value: B\n            });\n            continue;\n          }\n\n          if (B === \")\") {\n            if (N.parens === 0 && r.strictBrackets === true) {\n              throw new SyntaxError(syntaxError(\"opening\", \"(\"));\n            }\n\n            const e = k[k.length - 1];\n\n            if (e && N.parens === e.parens + 1) {\n              extglobClose(k.pop());\n              continue;\n            }\n\n            push({\n              type: \"paren\",\n              value: B,\n              output: N.parens ? \")\" : \"\\\\)\"\n            });\n            decrement(\"parens\");\n            continue;\n          }\n\n          if (B === \"[\") {\n            if (r.nobracket === true || !remaining().includes(\"]\")) {\n              if (r.nobracket !== true && r.strictBrackets === true) {\n                throw new SyntaxError(syntaxError(\"closing\", \"]\"));\n              }\n\n              B = `\\\\${B}`;\n            } else {\n              increment(\"brackets\");\n            }\n\n            push({\n              type: \"bracket\",\n              value: B\n            });\n            continue;\n          }\n\n          if (B === \"]\") {\n            if (r.nobracket === true || P && P.type === \"bracket\" && P.value.length === 1) {\n              push({\n                type: \"text\",\n                value: B,\n                output: `\\\\${B}`\n              });\n              continue;\n            }\n\n            if (N.brackets === 0) {\n              if (r.strictBrackets === true) {\n                throw new SyntaxError(syntaxError(\"opening\", \"[\"));\n              }\n\n              push({\n                type: \"text\",\n                value: B,\n                output: `\\\\${B}`\n              });\n              continue;\n            }\n\n            decrement(\"brackets\");\n            const e = P.value.slice(1);\n\n            if (P.posix !== true && e[0] === \"^\" && !e.includes(\"/\")) {\n              B = `/${B}`;\n            }\n\n            P.value += B;\n            append({\n              value: B\n            });\n\n            if (r.literalBrackets === false || u.hasRegexChars(e)) {\n              continue;\n            }\n\n            const t = u.escapeRegex(P.value);\n            N.output = N.output.slice(0, -P.value.length);\n\n            if (r.literalBrackets === true) {\n              N.output += t;\n              P.value = t;\n              continue;\n            }\n\n            P.value = `(${R}${t}|${P.value})`;\n            N.output += P.value;\n            continue;\n          }\n\n          if (B === \"{\" && r.nobrace !== true) {\n            increment(\"braces\");\n            const e = {\n              type: \"brace\",\n              value: B,\n              output: \"(\",\n              outputIndex: N.output.length,\n              tokensIndex: N.tokens.length\n            };\n            I.push(e);\n            push(e);\n            continue;\n          }\n\n          if (B === \"}\") {\n            const e = I[I.length - 1];\n\n            if (r.nobrace === true || !e) {\n              push({\n                type: \"text\",\n                value: B,\n                output: B\n              });\n              continue;\n            }\n\n            let t = \")\";\n\n            if (e.dots === true) {\n              const e = A.slice();\n              const n = [];\n\n              for (let t = e.length - 1; t >= 0; t--) {\n                A.pop();\n\n                if (e[t].type === \"brace\") {\n                  break;\n                }\n\n                if (e[t].type !== \"dots\") {\n                  n.unshift(e[t].value);\n                }\n              }\n\n              t = expandRange(n, r);\n              N.backtrack = true;\n            }\n\n            if (e.comma !== true && e.dots !== true) {\n              const r = N.output.slice(0, e.outputIndex);\n              const n = N.tokens.slice(e.tokensIndex);\n              e.value = e.output = \"\\\\{\";\n              B = t = \"\\\\}\";\n              N.output = r;\n\n              for (const e of n) {\n                N.output += e.output || e.value;\n              }\n            }\n\n            push({\n              type: \"brace\",\n              value: B,\n              output: t\n            });\n            decrement(\"braces\");\n            I.pop();\n            continue;\n          }\n\n          if (B === \"|\") {\n            if (k.length > 0) {\n              k[k.length - 1].conditions++;\n            }\n\n            push({\n              type: \"text\",\n              value: B\n            });\n            continue;\n          }\n\n          if (B === \",\") {\n            let e = B;\n            const t = I[I.length - 1];\n\n            if (t && M[M.length - 1] === \"braces\") {\n              t.comma = true;\n              e = \"|\";\n            }\n\n            push({\n              type: \"comma\",\n              value: B,\n              output: e\n            });\n            continue;\n          }\n\n          if (B === \"/\") {\n            if (P.type === \"dot\" && N.index === N.start + 1) {\n              N.start = N.index + 1;\n              N.consumed = \"\";\n              N.output = \"\";\n              A.pop();\n              P = f;\n              continue;\n            }\n\n            push({\n              type: \"slash\",\n              value: B,\n              output: y\n            });\n            continue;\n          }\n\n          if (B === \".\") {\n            if (N.braces > 0 && P.type === \"dot\") {\n              if (P.value === \".\") P.output = E;\n              const e = I[I.length - 1];\n              P.type = \"dots\";\n              P.output += B;\n              P.value += B;\n              e.dots = true;\n              continue;\n            }\n\n            if (N.braces + N.parens === 0 && P.type !== \"bos\" && P.type !== \"slash\") {\n              push({\n                type: \"text\",\n                value: B,\n                output: E\n              });\n              continue;\n            }\n\n            push({\n              type: \"dot\",\n              value: B,\n              output: E\n            });\n            continue;\n          }\n\n          if (B === \"?\") {\n            const e = P && P.value === \"(\";\n\n            if (!e && r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n              extglobOpen(\"qmark\", B);\n              continue;\n            }\n\n            if (P && P.type === \"paren\") {\n              const e = G();\n              let t = B;\n\n              if (e === \"<\" && !u.supportsLookbehinds()) {\n                throw new Error(\"Node.js v10 or higher is required for regex lookbehinds\");\n              }\n\n              if (P.value === \"(\" && !/[!=<:]/.test(e) || e === \"<\" && !/<([!=]|\\w+>)/.test(remaining())) {\n                t = `\\\\${B}`;\n              }\n\n              push({\n                type: \"text\",\n                value: B,\n                output: t\n              });\n              continue;\n            }\n\n            if (r.dot !== true && (P.type === \"slash\" || P.type === \"bos\")) {\n              push({\n                type: \"qmark\",\n                value: B,\n                output: $\n              });\n              continue;\n            }\n\n            push({\n              type: \"qmark\",\n              value: B,\n              output: v\n            });\n            continue;\n          }\n\n          if (B === \"!\") {\n            if (r.noextglob !== true && G() === \"(\") {\n              if (G(2) !== \"?\" || !/[!=<:]/.test(G(3))) {\n                extglobOpen(\"negate\", B);\n                continue;\n              }\n            }\n\n            if (r.nonegate !== true && N.index === 0) {\n              negate();\n              continue;\n            }\n          }\n\n          if (B === \"+\") {\n            if (r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n              extglobOpen(\"plus\", B);\n              continue;\n            }\n\n            if (P && P.value === \"(\" || r.regex === false) {\n              push({\n                type: \"plus\",\n                value: B,\n                output: C\n              });\n              continue;\n            }\n\n            if (P && (P.type === \"bracket\" || P.type === \"paren\" || P.type === \"brace\") || N.parens > 0) {\n              push({\n                type: \"plus\",\n                value: B\n              });\n              continue;\n            }\n\n            push({\n              type: \"plus\",\n              value: C\n            });\n            continue;\n          }\n\n          if (B === \"@\") {\n            if (r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n              push({\n                type: \"at\",\n                extglob: true,\n                value: B,\n                output: \"\"\n              });\n              continue;\n            }\n\n            push({\n              type: \"text\",\n              value: B\n            });\n            continue;\n          }\n\n          if (B !== \"*\") {\n            if (B === \"$\" || B === \"^\") {\n              B = `\\\\${B}`;\n            }\n\n            const e = i.exec(remaining());\n\n            if (e) {\n              B += e[0];\n              N.index += e[0].length;\n            }\n\n            push({\n              type: \"text\",\n              value: B\n            });\n            continue;\n          }\n\n          if (P && (P.type === \"globstar\" || P.star === true)) {\n            P.type = \"star\";\n            P.star = true;\n            P.value += B;\n            P.output = w;\n            N.backtrack = true;\n            N.globstar = true;\n            consume(B);\n            continue;\n          }\n\n          let t = remaining();\n\n          if (r.noextglob !== true && /^\\([^?]/.test(t)) {\n            extglobOpen(\"star\", B);\n            continue;\n          }\n\n          if (P.type === \"star\") {\n            if (r.noglobstar === true) {\n              consume(B);\n              continue;\n            }\n\n            const n = P.prev;\n            const u = n.prev;\n            const s = n.type === \"slash\" || n.type === \"bos\";\n            const o = u && (u.type === \"star\" || u.type === \"globstar\");\n\n            if (r.bash === true && (!s || t[0] && t[0] !== \"/\")) {\n              push({\n                type: \"star\",\n                value: B,\n                output: \"\"\n              });\n              continue;\n            }\n\n            const i = N.braces > 0 && (n.type === \"comma\" || n.type === \"brace\");\n            const a = k.length && (n.type === \"pipe\" || n.type === \"paren\");\n\n            if (!s && n.type !== \"paren\" && !i && !a) {\n              push({\n                type: \"star\",\n                value: B,\n                output: \"\"\n              });\n              continue;\n            }\n\n            while (t.slice(0, 3) === \"/**\") {\n              const r = e[N.index + 4];\n\n              if (r && r !== \"/\") {\n                break;\n              }\n\n              t = t.slice(3);\n              consume(\"/**\", 3);\n            }\n\n            if (n.type === \"bos\" && eos()) {\n              P.type = \"globstar\";\n              P.value += B;\n              P.output = globstar(r);\n              N.output = P.output;\n              N.globstar = true;\n              consume(B);\n              continue;\n            }\n\n            if (n.type === \"slash\" && n.prev.type !== \"bos\" && !o && eos()) {\n              N.output = N.output.slice(0, -(n.output + P.output).length);\n              n.output = `(?:${n.output}`;\n              P.type = \"globstar\";\n              P.output = globstar(r) + (r.strictSlashes ? \")\" : \"|$)\");\n              P.value += B;\n              N.globstar = true;\n              N.output += n.output + P.output;\n              consume(B);\n              continue;\n            }\n\n            if (n.type === \"slash\" && n.prev.type !== \"bos\" && t[0] === \"/\") {\n              const e = t[1] !== void 0 ? \"|$\" : \"\";\n              N.output = N.output.slice(0, -(n.output + P.output).length);\n              n.output = `(?:${n.output}`;\n              P.type = \"globstar\";\n              P.output = `${globstar(r)}${y}|${y}${e})`;\n              P.value += B;\n              N.output += n.output + P.output;\n              N.globstar = true;\n              consume(B + D());\n              push({\n                type: \"slash\",\n                value: \"/\",\n                output: \"\"\n              });\n              continue;\n            }\n\n            if (n.type === \"bos\" && t[0] === \"/\") {\n              P.type = \"globstar\";\n              P.value += B;\n              P.output = `(?:^|${y}|${globstar(r)}${y})`;\n              N.output = P.output;\n              N.globstar = true;\n              consume(B + D());\n              push({\n                type: \"slash\",\n                value: \"/\",\n                output: \"\"\n              });\n              continue;\n            }\n\n            N.output = N.output.slice(0, -P.output.length);\n            P.type = \"globstar\";\n            P.output = globstar(r);\n            P.value += B;\n            N.output += P.output;\n            N.globstar = true;\n            consume(B);\n            continue;\n          }\n\n          const n = {\n            type: \"star\",\n            value: B,\n            output: w\n          };\n\n          if (r.bash === true) {\n            n.output = \".*?\";\n\n            if (P.type === \"bos\" || P.type === \"slash\") {\n              n.output = L + n.output;\n            }\n\n            push(n);\n            continue;\n          }\n\n          if (P && (P.type === \"bracket\" || P.type === \"paren\") && r.regex === true) {\n            n.output = B;\n            push(n);\n            continue;\n          }\n\n          if (N.index === N.start || P.type === \"slash\" || P.type === \"dot\") {\n            if (P.type === \"dot\") {\n              N.output += S;\n              P.output += S;\n            } else if (r.dot === true) {\n              N.output += H;\n              P.output += H;\n            } else {\n              N.output += L;\n              P.output += L;\n            }\n\n            if (G() !== \"*\") {\n              N.output += d;\n              P.output += d;\n            }\n          }\n\n          push(n);\n        }\n\n        while (N.brackets > 0) {\n          if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \"]\"));\n          N.output = u.escapeLast(N.output, \"[\");\n          decrement(\"brackets\");\n        }\n\n        while (N.parens > 0) {\n          if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \")\"));\n          N.output = u.escapeLast(N.output, \"(\");\n          decrement(\"parens\");\n        }\n\n        while (N.braces > 0) {\n          if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \"}\"));\n          N.output = u.escapeLast(N.output, \"{\");\n          decrement(\"braces\");\n        }\n\n        if (r.strictSlashes !== true && (P.type === \"star\" || P.type === \"bracket\")) {\n          push({\n            type: \"maybe_slash\",\n            value: \"\",\n            output: `${y}?`\n          });\n        }\n\n        if (N.backtrack === true) {\n          N.output = \"\";\n\n          for (const e of N.tokens) {\n            N.output += e.output != null ? e.output : e.value;\n\n            if (e.suffix) {\n              N.output += e.suffix;\n            }\n          }\n        }\n\n        return N;\n      };\n\n      parse.fastpaths = (e, t) => {\n        const r = { ...t\n        };\n        const o = typeof r.maxLength === \"number\" ? Math.min(s, r.maxLength) : s;\n        const i = e.length;\n\n        if (i > o) {\n          throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${o}`);\n        }\n\n        e = l[e] || e;\n        const a = u.isWindows(t);\n        const {\n          DOT_LITERAL: c,\n          SLASH_LITERAL: p,\n          ONE_CHAR: f,\n          DOTS_SLASH: A,\n          NO_DOT: R,\n          NO_DOTS: _,\n          NO_DOTS_SLASH: h,\n          STAR: g,\n          START_ANCHOR: E\n        } = n.globChars(a);\n        const C = r.dot ? _ : R;\n        const y = r.dot ? h : R;\n        const d = r.capture ? \"\" : \"?:\";\n        const x = {\n          negated: false,\n          prefix: \"\"\n        };\n        let b = r.bash === true ? \".*?\" : g;\n\n        if (r.capture) {\n          b = `(${b})`;\n        }\n\n        const globstar = e => {\n          if (e.noglobstar === true) return b;\n          return `(${d}(?:(?!${E}${e.dot ? A : c}).)*?)`;\n        };\n\n        const create = e => {\n          switch (e) {\n            case \"*\":\n              return `${C}${f}${b}`;\n\n            case \".*\":\n              return `${c}${f}${b}`;\n\n            case \"*.*\":\n              return `${C}${b}${c}${f}${b}`;\n\n            case \"*/*\":\n              return `${C}${b}${p}${f}${y}${b}`;\n\n            case \"**\":\n              return C + globstar(r);\n\n            case \"**/*\":\n              return `(?:${C}${globstar(r)}${p})?${y}${f}${b}`;\n\n            case \"**/*.*\":\n              return `(?:${C}${globstar(r)}${p})?${y}${b}${c}${f}${b}`;\n\n            case \"**/.*\":\n              return `(?:${C}${globstar(r)}${p})?${c}${f}${b}`;\n\n            default:\n              {\n                const t = /^(.*?)\\.(\\w+)$/.exec(e);\n                if (!t) return;\n                const r = create(t[1]);\n                if (!r) return;\n                return r + c + t[2];\n              }\n          }\n        };\n\n        const S = u.removePrefix(e, x);\n        let H = create(S);\n\n        if (H && r.strictSlashes !== true) {\n          H += `${p}?`;\n        }\n\n        return H;\n      };\n\n      e.exports = parse;\n    },\n    683: (e, t, r) => {\n      const n = r(17);\n      const u = r(700);\n      const s = r(754);\n      const o = r(513);\n      const i = r(356);\n\n      const isObject = e => e && typeof e === \"object\" && !Array.isArray(e);\n\n      const picomatch = (e, t, r = false) => {\n        if (Array.isArray(e)) {\n          const n = e.map(e => picomatch(e, t, r));\n\n          const arrayMatcher = e => {\n            for (const t of n) {\n              const r = t(e);\n              if (r) return r;\n            }\n\n            return false;\n          };\n\n          return arrayMatcher;\n        }\n\n        const n = isObject(e) && e.tokens && e.input;\n\n        if (e === \"\" || typeof e !== \"string\" && !n) {\n          throw new TypeError(\"Expected pattern to be a non-empty string\");\n        }\n\n        const u = t || {};\n        const s = o.isWindows(t);\n        const i = n ? picomatch.compileRe(e, t) : picomatch.makeRe(e, t, false, true);\n        const a = i.state;\n        delete i.state;\n\n        let isIgnored = () => false;\n\n        if (u.ignore) {\n          const e = { ...t,\n            ignore: null,\n            onMatch: null,\n            onResult: null\n          };\n          isIgnored = picomatch(u.ignore, e, r);\n        }\n\n        const matcher = (r, n = false) => {\n          const {\n            isMatch: o,\n            match: l,\n            output: c\n          } = picomatch.test(r, i, t, {\n            glob: e,\n            posix: s\n          });\n          const p = {\n            glob: e,\n            state: a,\n            regex: i,\n            posix: s,\n            input: r,\n            output: c,\n            match: l,\n            isMatch: o\n          };\n\n          if (typeof u.onResult === \"function\") {\n            u.onResult(p);\n          }\n\n          if (o === false) {\n            p.isMatch = false;\n            return n ? p : false;\n          }\n\n          if (isIgnored(r)) {\n            if (typeof u.onIgnore === \"function\") {\n              u.onIgnore(p);\n            }\n\n            p.isMatch = false;\n            return n ? p : false;\n          }\n\n          if (typeof u.onMatch === \"function\") {\n            u.onMatch(p);\n          }\n\n          return n ? p : true;\n        };\n\n        if (r) {\n          matcher.state = a;\n        }\n\n        return matcher;\n      };\n\n      picomatch.test = (e, t, r, {\n        glob: n,\n        posix: u\n      } = {}) => {\n        if (typeof e !== \"string\") {\n          throw new TypeError(\"Expected input to be a string\");\n        }\n\n        if (e === \"\") {\n          return {\n            isMatch: false,\n            output: \"\"\n          };\n        }\n\n        const s = r || {};\n        const i = s.format || (u ? o.toPosixSlashes : null);\n        let a = e === n;\n        let l = a && i ? i(e) : e;\n\n        if (a === false) {\n          l = i ? i(e) : e;\n          a = l === n;\n        }\n\n        if (a === false || s.capture === true) {\n          if (s.matchBase === true || s.basename === true) {\n            a = picomatch.matchBase(e, t, r, u);\n          } else {\n            a = t.exec(l);\n          }\n        }\n\n        return {\n          isMatch: Boolean(a),\n          match: a,\n          output: l\n        };\n      };\n\n      picomatch.matchBase = (e, t, r, u = o.isWindows(r)) => {\n        const s = t instanceof RegExp ? t : picomatch.makeRe(t, r);\n        return s.test(n.basename(e));\n      };\n\n      picomatch.isMatch = (e, t, r) => picomatch(t, r)(e);\n\n      picomatch.parse = (e, t) => {\n        if (Array.isArray(e)) return e.map(e => picomatch.parse(e, t));\n        return s(e, { ...t,\n          fastpaths: false\n        });\n      };\n\n      picomatch.scan = (e, t) => u(e, t);\n\n      picomatch.compileRe = (e, t, r = false, n = false) => {\n        if (r === true) {\n          return e.output;\n        }\n\n        const u = t || {};\n        const s = u.contains ? \"\" : \"^\";\n        const o = u.contains ? \"\" : \"$\";\n        let i = `${s}(?:${e.output})${o}`;\n\n        if (e && e.negated === true) {\n          i = `^(?!${i}).*$`;\n        }\n\n        const a = picomatch.toRegex(i, t);\n\n        if (n === true) {\n          a.state = e;\n        }\n\n        return a;\n      };\n\n      picomatch.makeRe = (e, t, r = false, n = false) => {\n        if (!e || typeof e !== \"string\") {\n          throw new TypeError(\"Expected a non-empty string\");\n        }\n\n        const u = t || {};\n        let o = {\n          negated: false,\n          fastpaths: true\n        };\n        let i = \"\";\n        let a;\n\n        if (e.startsWith(\"./\")) {\n          e = e.slice(2);\n          i = o.prefix = \"./\";\n        }\n\n        if (u.fastpaths !== false && (e[0] === \".\" || e[0] === \"*\")) {\n          a = s.fastpaths(e, t);\n        }\n\n        if (a === undefined) {\n          o = s(e, t);\n          o.prefix = i + (o.prefix || \"\");\n        } else {\n          o.output = a;\n        }\n\n        return picomatch.compileRe(o, t, r, n);\n      };\n\n      picomatch.toRegex = (e, t) => {\n        try {\n          const r = t || {};\n          return new RegExp(e, r.flags || (r.nocase ? \"i\" : \"\"));\n        } catch (e) {\n          if (t && t.debug === true) throw e;\n          return /$^/;\n        }\n      };\n\n      picomatch.constants = i;\n      e.exports = picomatch;\n    },\n    700: (e, t, r) => {\n      const n = r(513);\n      const {\n        CHAR_ASTERISK: u,\n        CHAR_AT: s,\n        CHAR_BACKWARD_SLASH: o,\n        CHAR_COMMA: i,\n        CHAR_DOT: a,\n        CHAR_EXCLAMATION_MARK: l,\n        CHAR_FORWARD_SLASH: c,\n        CHAR_LEFT_CURLY_BRACE: p,\n        CHAR_LEFT_PARENTHESES: f,\n        CHAR_LEFT_SQUARE_BRACKET: A,\n        CHAR_PLUS: R,\n        CHAR_QUESTION_MARK: _,\n        CHAR_RIGHT_CURLY_BRACE: h,\n        CHAR_RIGHT_PARENTHESES: g,\n        CHAR_RIGHT_SQUARE_BRACKET: E\n      } = r(356);\n\n      const isPathSeparator = e => e === c || e === o;\n\n      const depth = e => {\n        if (e.isPrefix !== true) {\n          e.depth = e.isGlobstar ? Infinity : 1;\n        }\n      };\n\n      const scan = (e, t) => {\n        const r = t || {};\n        const C = e.length - 1;\n        const y = r.parts === true || r.scanToEnd === true;\n        const d = [];\n        const x = [];\n        const b = [];\n        let S = e;\n        let H = -1;\n        let v = 0;\n        let $ = 0;\n        let m = false;\n        let T = false;\n        let L = false;\n        let O = false;\n        let w = false;\n        let N = false;\n        let k = false;\n        let I = false;\n        let M = false;\n        let P = 0;\n        let B;\n        let G;\n        let D = {\n          value: \"\",\n          depth: 0,\n          isGlob: false\n        };\n\n        const eos = () => H >= C;\n\n        const peek = () => S.charCodeAt(H + 1);\n\n        const advance = () => {\n          B = G;\n          return S.charCodeAt(++H);\n        };\n\n        while (H < C) {\n          G = advance();\n          let e;\n\n          if (G === o) {\n            k = D.backslashes = true;\n            G = advance();\n\n            if (G === p) {\n              N = true;\n            }\n\n            continue;\n          }\n\n          if (N === true || G === p) {\n            P++;\n\n            while (eos() !== true && (G = advance())) {\n              if (G === o) {\n                k = D.backslashes = true;\n                advance();\n                continue;\n              }\n\n              if (G === p) {\n                P++;\n                continue;\n              }\n\n              if (N !== true && G === a && (G = advance()) === a) {\n                m = D.isBrace = true;\n                L = D.isGlob = true;\n                M = true;\n\n                if (y === true) {\n                  continue;\n                }\n\n                break;\n              }\n\n              if (N !== true && G === i) {\n                m = D.isBrace = true;\n                L = D.isGlob = true;\n                M = true;\n\n                if (y === true) {\n                  continue;\n                }\n\n                break;\n              }\n\n              if (G === h) {\n                P--;\n\n                if (P === 0) {\n                  N = false;\n                  m = D.isBrace = true;\n                  M = true;\n                  break;\n                }\n              }\n            }\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n\n          if (G === c) {\n            d.push(H);\n            x.push(D);\n            D = {\n              value: \"\",\n              depth: 0,\n              isGlob: false\n            };\n            if (M === true) continue;\n\n            if (B === a && H === v + 1) {\n              v += 2;\n              continue;\n            }\n\n            $ = H + 1;\n            continue;\n          }\n\n          if (r.noext !== true) {\n            const e = G === R || G === s || G === u || G === _ || G === l;\n\n            if (e === true && peek() === f) {\n              L = D.isGlob = true;\n              O = D.isExtglob = true;\n              M = true;\n\n              if (y === true) {\n                while (eos() !== true && (G = advance())) {\n                  if (G === o) {\n                    k = D.backslashes = true;\n                    G = advance();\n                    continue;\n                  }\n\n                  if (G === g) {\n                    L = D.isGlob = true;\n                    M = true;\n                    break;\n                  }\n                }\n\n                continue;\n              }\n\n              break;\n            }\n          }\n\n          if (G === u) {\n            if (B === u) w = D.isGlobstar = true;\n            L = D.isGlob = true;\n            M = true;\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n\n          if (G === _) {\n            L = D.isGlob = true;\n            M = true;\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n\n          if (G === A) {\n            while (eos() !== true && (e = advance())) {\n              if (e === o) {\n                k = D.backslashes = true;\n                advance();\n                continue;\n              }\n\n              if (e === E) {\n                T = D.isBracket = true;\n                L = D.isGlob = true;\n                M = true;\n                break;\n              }\n            }\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n\n          if (r.nonegate !== true && G === l && H === v) {\n            I = D.negated = true;\n            v++;\n            continue;\n          }\n\n          if (r.noparen !== true && G === f) {\n            L = D.isGlob = true;\n\n            if (y === true) {\n              while (eos() !== true && (G = advance())) {\n                if (G === f) {\n                  k = D.backslashes = true;\n                  G = advance();\n                  continue;\n                }\n\n                if (G === g) {\n                  M = true;\n                  break;\n                }\n              }\n\n              continue;\n            }\n\n            break;\n          }\n\n          if (L === true) {\n            M = true;\n\n            if (y === true) {\n              continue;\n            }\n\n            break;\n          }\n        }\n\n        if (r.noext === true) {\n          O = false;\n          L = false;\n        }\n\n        let U = S;\n        let K = \"\";\n        let F = \"\";\n\n        if (v > 0) {\n          K = S.slice(0, v);\n          S = S.slice(v);\n          $ -= v;\n        }\n\n        if (U && L === true && $ > 0) {\n          U = S.slice(0, $);\n          F = S.slice($);\n        } else if (L === true) {\n          U = \"\";\n          F = S;\n        } else {\n          U = S;\n        }\n\n        if (U && U !== \"\" && U !== \"/\" && U !== S) {\n          if (isPathSeparator(U.charCodeAt(U.length - 1))) {\n            U = U.slice(0, -1);\n          }\n        }\n\n        if (r.unescape === true) {\n          if (F) F = n.removeBackslashes(F);\n\n          if (U && k === true) {\n            U = n.removeBackslashes(U);\n          }\n        }\n\n        const Q = {\n          prefix: K,\n          input: e,\n          start: v,\n          base: U,\n          glob: F,\n          isBrace: m,\n          isBracket: T,\n          isGlob: L,\n          isExtglob: O,\n          isGlobstar: w,\n          negated: I\n        };\n\n        if (r.tokens === true) {\n          Q.maxDepth = 0;\n\n          if (!isPathSeparator(G)) {\n            x.push(D);\n          }\n\n          Q.tokens = x;\n        }\n\n        if (r.parts === true || r.tokens === true) {\n          let t;\n\n          for (let n = 0; n < d.length; n++) {\n            const u = t ? t + 1 : v;\n            const s = d[n];\n            const o = e.slice(u, s);\n\n            if (r.tokens) {\n              if (n === 0 && v !== 0) {\n                x[n].isPrefix = true;\n                x[n].value = K;\n              } else {\n                x[n].value = o;\n              }\n\n              depth(x[n]);\n              Q.maxDepth += x[n].depth;\n            }\n\n            if (n !== 0 || o !== \"\") {\n              b.push(o);\n            }\n\n            t = s;\n          }\n\n          if (t && t + 1 < e.length) {\n            const n = e.slice(t + 1);\n            b.push(n);\n\n            if (r.tokens) {\n              x[x.length - 1].value = n;\n              depth(x[x.length - 1]);\n              Q.maxDepth += x[x.length - 1].depth;\n            }\n          }\n\n          Q.slashes = d;\n          Q.parts = b;\n        }\n\n        return Q;\n      };\n\n      e.exports = scan;\n    },\n    513: (e, t, r) => {\n      const n = r(17);\n      const u = process.platform === \"win32\";\n      const {\n        REGEX_BACKSLASH: s,\n        REGEX_REMOVE_BACKSLASH: o,\n        REGEX_SPECIAL_CHARS: i,\n        REGEX_SPECIAL_CHARS_GLOBAL: a\n      } = r(356);\n\n      t.isObject = e => e !== null && typeof e === \"object\" && !Array.isArray(e);\n\n      t.hasRegexChars = e => i.test(e);\n\n      t.isRegexChar = e => e.length === 1 && t.hasRegexChars(e);\n\n      t.escapeRegex = e => e.replace(a, \"\\\\$1\");\n\n      t.toPosixSlashes = e => e.replace(s, \"/\");\n\n      t.removeBackslashes = e => e.replace(o, e => e === \"\\\\\" ? \"\" : e);\n\n      t.supportsLookbehinds = () => {\n        const e = process.version.slice(1).split(\".\").map(Number);\n\n        if (e.length === 3 && e[0] >= 9 || e[0] === 8 && e[1] >= 10) {\n          return true;\n        }\n\n        return false;\n      };\n\n      t.isWindows = e => {\n        if (e && typeof e.windows === \"boolean\") {\n          return e.windows;\n        }\n\n        return u === true || n.sep === \"\\\\\";\n      };\n\n      t.escapeLast = (e, r, n) => {\n        const u = e.lastIndexOf(r, n);\n        if (u === -1) return e;\n        if (e[u - 1] === \"\\\\\") return t.escapeLast(e, r, u - 1);\n        return `${e.slice(0, u)}\\\\${e.slice(u)}`;\n      };\n\n      t.removePrefix = (e, t = {}) => {\n        let r = e;\n\n        if (r.startsWith(\"./\")) {\n          r = r.slice(2);\n          t.prefix = \"./\";\n        }\n\n        return r;\n      };\n\n      t.wrapOutput = (e, t = {}, r = {}) => {\n        const n = r.contains ? \"\" : \"^\";\n        const u = r.contains ? \"\" : \"$\";\n        let s = `${n}(?:${e})${u}`;\n\n        if (t.negated === true) {\n          s = `(?:^(?!${s}).*$)`;\n        }\n\n        return s;\n      };\n    },\n    492: (e, t, r) => {\n      /*!\n       * to-regex-range <https://github.com/micromatch/to-regex-range>\n       *\n       * Copyright (c) 2015-present, Jon Schlinkert.\n       * Released under the MIT License.\n       */\n      const n = r(357);\n\n      const toRegexRange = (e, t, r) => {\n        if (n(e) === false) {\n          throw new TypeError(\"toRegexRange: expected the first argument to be a number\");\n        }\n\n        if (t === void 0 || e === t) {\n          return String(e);\n        }\n\n        if (n(t) === false) {\n          throw new TypeError(\"toRegexRange: expected the second argument to be a number.\");\n        }\n\n        let u = {\n          relaxZeros: true,\n          ...r\n        };\n\n        if (typeof u.strictZeros === \"boolean\") {\n          u.relaxZeros = u.strictZeros === false;\n        }\n\n        let s = String(u.relaxZeros);\n        let o = String(u.shorthand);\n        let i = String(u.capture);\n        let a = String(u.wrap);\n        let l = e + \":\" + t + \"=\" + s + o + i + a;\n\n        if (toRegexRange.cache.hasOwnProperty(l)) {\n          return toRegexRange.cache[l].result;\n        }\n\n        let c = Math.min(e, t);\n        let p = Math.max(e, t);\n\n        if (Math.abs(c - p) === 1) {\n          let r = e + \"|\" + t;\n\n          if (u.capture) {\n            return `(${r})`;\n          }\n\n          if (u.wrap === false) {\n            return r;\n          }\n\n          return `(?:${r})`;\n        }\n\n        let f = hasPadding(e) || hasPadding(t);\n        let A = {\n          min: e,\n          max: t,\n          a: c,\n          b: p\n        };\n        let R = [];\n        let _ = [];\n\n        if (f) {\n          A.isPadded = f;\n          A.maxLen = String(A.max).length;\n        }\n\n        if (c < 0) {\n          let e = p < 0 ? Math.abs(p) : 1;\n          _ = splitToPatterns(e, Math.abs(c), A, u);\n          c = A.a = 0;\n        }\n\n        if (p >= 0) {\n          R = splitToPatterns(c, p, A, u);\n        }\n\n        A.negatives = _;\n        A.positives = R;\n        A.result = collatePatterns(_, R, u);\n\n        if (u.capture === true) {\n          A.result = `(${A.result})`;\n        } else if (u.wrap !== false && R.length + _.length > 1) {\n          A.result = `(?:${A.result})`;\n        }\n\n        toRegexRange.cache[l] = A;\n        return A.result;\n      };\n\n      function collatePatterns(e, t, r) {\n        let n = filterPatterns(e, t, \"-\", false, r) || [];\n        let u = filterPatterns(t, e, \"\", false, r) || [];\n        let s = filterPatterns(e, t, \"-?\", true, r) || [];\n        let o = n.concat(s).concat(u);\n        return o.join(\"|\");\n      }\n\n      function splitToRanges(e, t) {\n        let r = 1;\n        let n = 1;\n        let u = countNines(e, r);\n        let s = new Set([t]);\n\n        while (e <= u && u <= t) {\n          s.add(u);\n          r += 1;\n          u = countNines(e, r);\n        }\n\n        u = countZeros(t + 1, n) - 1;\n\n        while (e < u && u <= t) {\n          s.add(u);\n          n += 1;\n          u = countZeros(t + 1, n) - 1;\n        }\n\n        s = [...s];\n        s.sort(compare);\n        return s;\n      }\n\n      function rangeToPattern(e, t, r) {\n        if (e === t) {\n          return {\n            pattern: e,\n            count: [],\n            digits: 0\n          };\n        }\n\n        let n = zip(e, t);\n        let u = n.length;\n        let s = \"\";\n        let o = 0;\n\n        for (let e = 0; e < u; e++) {\n          let [t, u] = n[e];\n\n          if (t === u) {\n            s += t;\n          } else if (t !== \"0\" || u !== \"9\") {\n            s += toCharacterClass(t, u, r);\n          } else {\n            o++;\n          }\n        }\n\n        if (o) {\n          s += r.shorthand === true ? \"\\\\d\" : \"[0-9]\";\n        }\n\n        return {\n          pattern: s,\n          count: [o],\n          digits: u\n        };\n      }\n\n      function splitToPatterns(e, t, r, n) {\n        let u = splitToRanges(e, t);\n        let s = [];\n        let o = e;\n        let i;\n\n        for (let e = 0; e < u.length; e++) {\n          let t = u[e];\n          let a = rangeToPattern(String(o), String(t), n);\n          let l = \"\";\n\n          if (!r.isPadded && i && i.pattern === a.pattern) {\n            if (i.count.length > 1) {\n              i.count.pop();\n            }\n\n            i.count.push(a.count[0]);\n            i.string = i.pattern + toQuantifier(i.count);\n            o = t + 1;\n            continue;\n          }\n\n          if (r.isPadded) {\n            l = padZeros(t, r, n);\n          }\n\n          a.string = l + a.pattern + toQuantifier(a.count);\n          s.push(a);\n          o = t + 1;\n          i = a;\n        }\n\n        return s;\n      }\n\n      function filterPatterns(e, t, r, n, u) {\n        let s = [];\n\n        for (let u of e) {\n          let {\n            string: e\n          } = u;\n\n          if (!n && !contains(t, \"string\", e)) {\n            s.push(r + e);\n          }\n\n          if (n && contains(t, \"string\", e)) {\n            s.push(r + e);\n          }\n        }\n\n        return s;\n      }\n\n      function zip(e, t) {\n        let r = [];\n\n        for (let n = 0; n < e.length; n++) r.push([e[n], t[n]]);\n\n        return r;\n      }\n\n      function compare(e, t) {\n        return e > t ? 1 : t > e ? -1 : 0;\n      }\n\n      function contains(e, t, r) {\n        return e.some(e => e[t] === r);\n      }\n\n      function countNines(e, t) {\n        return Number(String(e).slice(0, -t) + \"9\".repeat(t));\n      }\n\n      function countZeros(e, t) {\n        return e - e % Math.pow(10, t);\n      }\n\n      function toQuantifier(e) {\n        let [t = 0, r = \"\"] = e;\n\n        if (r || t > 1) {\n          return `{${t + (r ? \",\" + r : \"\")}}`;\n        }\n\n        return \"\";\n      }\n\n      function toCharacterClass(e, t, r) {\n        return `[${e}${t - e === 1 ? \"\" : \"-\"}${t}]`;\n      }\n\n      function hasPadding(e) {\n        return /^-?(0+)\\d/.test(e);\n      }\n\n      function padZeros(e, t, r) {\n        if (!t.isPadded) {\n          return e;\n        }\n\n        let n = Math.abs(t.maxLen - String(e).length);\n        let u = r.relaxZeros !== false;\n\n        switch (n) {\n          case 0:\n            return \"\";\n\n          case 1:\n            return u ? \"0?\" : \"0\";\n\n          case 2:\n            return u ? \"0{0,2}\" : \"00\";\n\n          default:\n            {\n              return u ? `0{0,${n}}` : `0{${n}}`;\n            }\n        }\n      }\n\n      toRegexRange.cache = {};\n\n      toRegexRange.clearCache = () => toRegexRange.cache = {};\n\n      e.exports = toRegexRange;\n    },\n    17: e => {\n      e.exports = __webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\");\n    },\n    837: e => {\n      e.exports = __webpack_require__(/*! util */ \"./node_modules/next/dist/compiled/util/util.js\");\n    }\n  };\n  var t = {};\n\n  function __nccwpck_require__(r) {\n    var n = t[r];\n\n    if (n !== undefined) {\n      return n.exports;\n    }\n\n    var u = t[r] = {\n      exports: {}\n    };\n    var s = true;\n\n    try {\n      e[r](u, u.exports, __nccwpck_require__);\n      s = false;\n    } finally {\n      if (s) delete t[r];\n    }\n\n    return u.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var r = __nccwpck_require__(971);\n\n  module.exports = r;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2gvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQSxDQUFDLE1BQUk7RUFBQzs7RUFBYSxJQUFJQSxDQUFDLEdBQUM7SUFBQyxLQUFJLENBQUNBLENBQUQsRUFBR0MsQ0FBSCxFQUFLQyxDQUFMLEtBQVM7TUFBQyxNQUFNQyxDQUFDLEdBQUNELENBQUMsQ0FBQyxHQUFELENBQVQ7TUFBZSxNQUFNRSxDQUFDLEdBQUNGLENBQUMsQ0FBQyxHQUFELENBQVQ7TUFBZSxNQUFNRyxDQUFDLEdBQUNILENBQUMsQ0FBQyxFQUFELENBQVQ7TUFBYyxNQUFNSSxDQUFDLEdBQUNKLENBQUMsQ0FBQyxHQUFELENBQVQ7O01BQWUsTUFBTUssTUFBTSxHQUFDLENBQUNQLENBQUQsRUFBR0MsQ0FBQyxHQUFDLEVBQUwsS0FBVTtRQUFDLElBQUlDLENBQUMsR0FBQyxFQUFOOztRQUFTLElBQUdNLEtBQUssQ0FBQ0MsT0FBTixDQUFjVCxDQUFkLENBQUgsRUFBb0I7VUFBQyxLQUFJLElBQUlHLENBQVIsSUFBYUgsQ0FBYixFQUFlO1lBQUMsSUFBSUEsQ0FBQyxHQUFDTyxNQUFNLENBQUNHLE1BQVAsQ0FBY1AsQ0FBZCxFQUFnQkYsQ0FBaEIsQ0FBTjs7WUFBeUIsSUFBR08sS0FBSyxDQUFDQyxPQUFOLENBQWNULENBQWQsQ0FBSCxFQUFvQjtjQUFDRSxDQUFDLENBQUNTLElBQUYsQ0FBTyxHQUFHWCxDQUFWO1lBQWEsQ0FBbEMsTUFBc0M7Y0FBQ0UsQ0FBQyxDQUFDUyxJQUFGLENBQU9YLENBQVA7WUFBVTtVQUFDO1FBQUMsQ0FBakgsTUFBcUg7VUFBQ0UsQ0FBQyxHQUFDLEdBQUdVLE1BQUgsQ0FBVUwsTUFBTSxDQUFDRyxNQUFQLENBQWNWLENBQWQsRUFBZ0JDLENBQWhCLENBQVYsQ0FBRjtRQUFnQzs7UUFBQSxJQUFHQSxDQUFDLElBQUVBLENBQUMsQ0FBQ1ksTUFBRixLQUFXLElBQWQsSUFBb0Ja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OztJQUFXLElBQUc7TUFBQ0wsQ0FBQyxDQUFDRSxDQUFELENBQUQsQ0FBS0UsQ0FBTCxFQUFPQSxDQUFDLENBQUNtQixPQUFULEVBQWlCa1gsbUJBQWpCO01BQXNDcFksQ0FBQyxHQUFDLEtBQUY7SUFBUSxDQUFsRCxTQUF5RDtNQUFDLElBQUdBLENBQUgsRUFBSyxPQUFPSixDQUFDLENBQUNDLENBQUQsQ0FBUjtJQUFZOztJQUFBLE9BQU9FLENBQUMsQ0FBQ21CLE9BQVQ7RUFBaUI7O0VBQUEsSUFBRyxPQUFPa1gsbUJBQVAsS0FBNkIsV0FBaEMsRUFBNENBLG1CQUFtQixDQUFDQyxFQUFwQixHQUF1QkMsU0FBUyxHQUFDLEdBQWpDOztFQUFxQyxJQUFJelksQ0FBQyxHQUFDdVksbUJBQW1CLENBQUMsR0FBRCxDQUF6Qjs7RUFBK0JHLE1BQU0sQ0FBQ3JYLE9BQVAsR0FBZXJCLENBQWY7QUFBaUIsQ0FyQnh2SCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2gvaW5kZXguanM/M2NlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17MzMzOihlLHQscik9Pntjb25zdCBuPXIoMTM3KTtjb25zdCB1PXIoMTc5KTtjb25zdCBzPXIoMTMpO2NvbnN0IG89cig3MTkpO2NvbnN0IGJyYWNlcz0oZSx0PXt9KT0+e2xldCByPVtdO2lmKEFycmF5LmlzQXJyYXkoZSkpe2ZvcihsZXQgbiBvZiBlKXtsZXQgZT1icmFjZXMuY3JlYXRlKG4sdCk7aWYoQXJyYXkuaXNBcnJheShlKSl7ci5wdXNoKC4uLmUpfWVsc2V7ci5wdXNoKGUpfX19ZWxzZXtyPVtdLmNvbmNhdChicmFjZXMuY3JlYXRlKGUsdCkpfWlmKHQmJnQuZXhwYW5kPT09dHJ1ZSYmdC5ub2R1cGVzPT09dHJ1ZSl7cj1bLi4ubmV3IFNldChyKV19cmV0dXJuIHJ9O2JyYWNlcy5wYXJzZT0oZSx0PXt9KT0+byhlLHQpO2JyYWNlcy5zdHJpbmdpZnk9KGUsdD17fSk9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBuKGJyYWNlcy5wYXJzZShlLHQpLHQpfXJldHVybiBuKGUsdCl9O2JyYWNlcy5jb21waWxlPShlLHQ9e30pPT57aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtlPWJyYWNlcy5wYXJzZShlLHQpfXJldHVybiB1KGUsdCl9O2JyYWNlcy5leHBhbmQ9KGUsdD17fSk9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2U9YnJhY2VzLnBhcnNlKGUsdCl9bGV0IHI9cyhlLHQpO2lmKHQubm9lbXB0eT09PXRydWUpe3I9ci5maWx0ZXIoQm9vbGVhbil9aWYodC5ub2R1cGVzPT09dHJ1ZSl7cj1bLi4ubmV3IFNldChyKV19cmV0dXJuIHJ9O2JyYWNlcy5jcmVhdGU9KGUsdD17fSk9PntpZihlPT09XCJcInx8ZS5sZW5ndGg8Myl7cmV0dXJuW2VdfXJldHVybiB0LmV4cGFuZCE9PXRydWU/YnJhY2VzLmNvbXBpbGUoZSx0KTpicmFjZXMuZXhwYW5kKGUsdCl9O2UuZXhwb3J0cz1icmFjZXN9LDE3OTooZSx0LHIpPT57Y29uc3Qgbj1yKDc4Myk7Y29uc3QgdT1yKDYxNyk7Y29uc3QgY29tcGlsZT0oZSx0PXt9KT0+e2xldCB3YWxrPShlLHI9e30pPT57bGV0IHM9dS5pc0ludmFsaWRCcmFjZShyKTtsZXQgbz1lLmludmFsaWQ9PT10cnVlJiZ0LmVzY2FwZUludmFsaWQ9PT10cnVlO2xldCBpPXM9PT10cnVlfHxvPT09dHJ1ZTtsZXQgYT10LmVzY2FwZUludmFsaWQ9PT10cnVlP1wiXFxcXFwiOlwiXCI7bGV0IGw9XCJcIjtpZihlLmlzT3Blbj09PXRydWUpe3JldHVybiBhK2UudmFsdWV9aWYoZS5pc0Nsb3NlPT09dHJ1ZSl7cmV0dXJuIGErZS52YWx1ZX1pZihlLnR5cGU9PT1cIm9wZW5cIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKFwifWlmKGUudHlwZT09PVwiY2xvc2VcIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKVwifWlmKGUudHlwZT09PVwiY29tbWFcIil7cmV0dXJuIGUucHJldi50eXBlPT09XCJjb21tYVwiP1wiXCI6aT9lLnZhbHVlOlwifFwifWlmKGUudmFsdWUpe3JldHVybiBlLnZhbHVlfWlmKGUubm9kZXMmJmUucmFuZ2VzPjApe2xldCByPXUucmVkdWNlKGUubm9kZXMpO2xldCBzPW4oLi4ucix7Li4udCx3cmFwOmZhbHNlLHRvUmVnZXg6dHJ1ZX0pO2lmKHMubGVuZ3RoIT09MCl7cmV0dXJuIHIubGVuZ3RoPjEmJnMubGVuZ3RoPjE/YCgke3N9KWA6c319aWYoZS5ub2Rlcyl7Zm9yKGxldCB0IG9mIGUubm9kZXMpe2wrPXdhbGsodCxlKX19cmV0dXJuIGx9O3JldHVybiB3YWxrKGUpfTtlLmV4cG9ydHM9Y29tcGlsZX0sNDU3OmU9PntlLmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxDSEFSXzA6XCIwXCIsQ0hBUl85OlwiOVwiLENIQVJfVVBQRVJDQVNFX0E6XCJBXCIsQ0hBUl9MT1dFUkNBU0VfQTpcImFcIixDSEFSX1VQUEVSQ0FTRV9aOlwiWlwiLENIQVJfTE9XRVJDQVNFX1o6XCJ6XCIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOlwiKFwiLENIQVJfUklHSFRfUEFSRU5USEVTRVM6XCIpXCIsQ0hBUl9BU1RFUklTSzpcIipcIixDSEFSX0FNUEVSU0FORDpcIiZcIixDSEFSX0FUOlwiQFwiLENIQVJfQkFDS1NMQVNIOlwiXFxcXFwiLENIQVJfQkFDS1RJQ0s6XCJgXCIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46XCJcXHJcIixDSEFSX0NJUkNVTUZMRVhfQUNDRU5UOlwiXlwiLENIQVJfQ09MT046XCI6XCIsQ0hBUl9DT01NQTpcIixcIixDSEFSX0RPTExBUjpcIiRcIixDSEFSX0RPVDpcIi5cIixDSEFSX0RPVUJMRV9RVU9URTonXCInLENIQVJfRVFVQUw6XCI9XCIsQ0hBUl9FWENMQU1BVElPTl9NQVJLOlwiIVwiLENIQVJfRk9STV9GRUVEOlwiXFxmXCIsQ0hBUl9GT1JXQVJEX1NMQVNIOlwiL1wiLENIQVJfSEFTSDpcIiNcIixDSEFSX0hZUEhFTl9NSU5VUzpcIi1cIixDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDpcIjxcIixDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6XCJ7XCIsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOlwiW1wiLENIQVJfTElORV9GRUVEOlwiXFxuXCIsQ0hBUl9OT19CUkVBS19TUEFDRTpcIsKgXCIsQ0hBUl9QRVJDRU5UOlwiJVwiLENIQVJfUExVUzpcIitcIixDSEFSX1FVRVNUSU9OX01BUks6XCI/XCIsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOlwiPlwiLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6XCJ9XCIsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpcIl1cIixDSEFSX1NFTUlDT0xPTjpcIjtcIixDSEFSX1NJTkdMRV9RVU9URTpcIidcIixDSEFSX1NQQUNFOlwiIFwiLENIQVJfVEFCOlwiXFx0XCIsQ0hBUl9VTkRFUlNDT1JFOlwiX1wiLENIQVJfVkVSVElDQUxfTElORTpcInxcIixDSEFSX1pFUk9fV0lEVEhfTk9CUkVBS19TUEFDRTpcIlxcdWZlZmZcIn19LDEzOihlLHQscik9Pntjb25zdCBuPXIoNzgzKTtjb25zdCB1PXIoMTM3KTtjb25zdCBzPXIoNjE3KTtjb25zdCBhcHBlbmQ9KGU9XCJcIix0PVwiXCIscj1mYWxzZSk9PntsZXQgbj1bXTtlPVtdLmNvbmNhdChlKTt0PVtdLmNvbmNhdCh0KTtpZighdC5sZW5ndGgpcmV0dXJuIGU7aWYoIWUubGVuZ3RoKXtyZXR1cm4gcj9zLmZsYXR0ZW4odCkubWFwKChlPT5geyR7ZX19YCkpOnR9Zm9yKGxldCB1IG9mIGUpe2lmKEFycmF5LmlzQXJyYXkodSkpe2ZvcihsZXQgZSBvZiB1KXtuLnB1c2goYXBwZW5kKGUsdCxyKSl9fWVsc2V7Zm9yKGxldCBlIG9mIHQpe2lmKHI9PT10cnVlJiZ0eXBlb2YgZT09PVwic3RyaW5nXCIpZT1geyR7ZX19YDtuLnB1c2goQXJyYXkuaXNBcnJheShlKT9hcHBlbmQodSxlLHIpOnUrZSl9fX1yZXR1cm4gcy5mbGF0dGVuKG4pfTtjb25zdCBleHBhbmQ9KGUsdD17fSk9PntsZXQgcj10LnJhbmdlTGltaXQ9PT12b2lkIDA/MWUzOnQucmFuZ2VMaW1pdDtsZXQgd2Fsaz0oZSxvPXt9KT0+e2UucXVldWU9W107bGV0IGk9bztsZXQgYT1vLnF1ZXVlO3doaWxlKGkudHlwZSE9PVwiYnJhY2VcIiYmaS50eXBlIT09XCJyb290XCImJmkucGFyZW50KXtpPWkucGFyZW50O2E9aS5xdWV1ZX1pZihlLmludmFsaWR8fGUuZG9sbGFyKXthLnB1c2goYXBwZW5kKGEucG9wKCksdShlLHQpKSk7cmV0dXJufWlmKGUudHlwZT09PVwiYnJhY2VcIiYmZS5pbnZhbGlkIT09dHJ1ZSYmZS5ub2Rlcy5sZW5ndGg9PT0yKXthLnB1c2goYXBwZW5kKGEucG9wKCksW1wie31cIl0pKTtyZXR1cm59aWYoZS5ub2RlcyYmZS5yYW5nZXM+MCl7bGV0IG89cy5yZWR1Y2UoZS5ub2Rlcyk7aWYocy5leGNlZWRzTGltaXQoLi4ubyx0LnN0ZXAscikpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiZXhwYW5kZWQgYXJyYXkgbGVuZ3RoIGV4Y2VlZHMgcmFuZ2UgbGltaXQuIFVzZSBvcHRpb25zLnJhbmdlTGltaXQgdG8gaW5jcmVhc2Ugb3IgZGlzYWJsZSB0aGUgbGltaXQuXCIpfWxldCBpPW4oLi4ubyx0KTtpZihpLmxlbmd0aD09PTApe2k9dShlLHQpfWEucHVzaChhcHBlbmQoYS5wb3AoKSxpKSk7ZS5ub2Rlcz1bXTtyZXR1cm59bGV0IGw9cy5lbmNsb3NlQnJhY2UoZSk7bGV0IGM9ZS5xdWV1ZTtsZXQgcD1lO3doaWxlKHAudHlwZSE9PVwiYnJhY2VcIiYmcC50eXBlIT09XCJyb290XCImJnAucGFyZW50KXtwPXAucGFyZW50O2M9cC5xdWV1ZX1mb3IobGV0IHQ9MDt0PGUubm9kZXMubGVuZ3RoO3QrKyl7bGV0IHI9ZS5ub2Rlc1t0XTtpZihyLnR5cGU9PT1cImNvbW1hXCImJmUudHlwZT09PVwiYnJhY2VcIil7aWYodD09PTEpYy5wdXNoKFwiXCIpO2MucHVzaChcIlwiKTtjb250aW51ZX1pZihyLnR5cGU9PT1cImNsb3NlXCIpe2EucHVzaChhcHBlbmQoYS5wb3AoKSxjLGwpKTtjb250aW51ZX1pZihyLnZhbHVlJiZyLnR5cGUhPT1cIm9wZW5cIil7Yy5wdXNoKGFwcGVuZChjLnBvcCgpLHIudmFsdWUpKTtjb250aW51ZX1pZihyLm5vZGVzKXt3YWxrKHIsZSl9fXJldHVybiBjfTtyZXR1cm4gcy5mbGF0dGVuKHdhbGsoZSkpfTtlLmV4cG9ydHM9ZXhwYW5kfSw3MTk6KGUsdCxyKT0+e2NvbnN0IG49cigxMzcpO2NvbnN0e01BWF9MRU5HVEg6dSxDSEFSX0JBQ0tTTEFTSDpzLENIQVJfQkFDS1RJQ0s6byxDSEFSX0NPTU1BOmksQ0hBUl9ET1Q6YSxDSEFSX0xFRlRfUEFSRU5USEVTRVM6bCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmMsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOnAsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6UixDSEFSX0RPVUJMRV9RVU9URTpfLENIQVJfU0lOR0xFX1FVT1RFOmgsQ0hBUl9OT19CUkVBS19TUEFDRTpnLENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOkV9PXIoNDU3KTtjb25zdCBwYXJzZT0oZSx0PXt9KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpfWxldCByPXR8fHt9O2xldCBDPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4odSxyLm1heExlbmd0aCk6dTtpZihlLmxlbmd0aD5DKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aCAoJHtlLmxlbmd0aH0pLCBleGNlZWRzIG1heCBjaGFyYWN0ZXJzICgke0N9KWApfWxldCB5PXt0eXBlOlwicm9vdFwiLGlucHV0OmUsbm9kZXM6W119O2xldCBkPVt5XTtsZXQgeD15O2xldCBiPXk7bGV0IFM9MDtsZXQgSD1lLmxlbmd0aDtsZXQgdj0wO2xldCAkPTA7bGV0IG07bGV0IFQ9e307Y29uc3QgYWR2YW5jZT0oKT0+ZVt2KytdO2NvbnN0IHB1c2g9ZT0+e2lmKGUudHlwZT09PVwidGV4dFwiJiZiLnR5cGU9PT1cImRvdFwiKXtiLnR5cGU9XCJ0ZXh0XCJ9aWYoYiYmYi50eXBlPT09XCJ0ZXh0XCImJmUudHlwZT09PVwidGV4dFwiKXtiLnZhbHVlKz1lLnZhbHVlO3JldHVybn14Lm5vZGVzLnB1c2goZSk7ZS5wYXJlbnQ9eDtlLnByZXY9YjtiPWU7cmV0dXJuIGV9O3B1c2goe3R5cGU6XCJib3NcIn0pO3doaWxlKHY8SCl7eD1kW2QubGVuZ3RoLTFdO209YWR2YW5jZSgpO2lmKG09PT1FfHxtPT09Zyl7Y29udGludWV9aWYobT09PXMpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6KHQua2VlcEVzY2FwaW5nP206XCJcIikrYWR2YW5jZSgpfSk7Y29udGludWV9aWYobT09PVIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6XCJcXFxcXCIrbX0pO2NvbnRpbnVlfWlmKG09PT1BKXtTKys7bGV0IGU9dHJ1ZTtsZXQgdDt3aGlsZSh2PEgmJih0PWFkdmFuY2UoKSkpe20rPXQ7aWYodD09PUEpe1MrKztjb250aW51ZX1pZih0PT09cyl7bSs9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKHQ9PT1SKXtTLS07aWYoUz09PTApe2JyZWFrfX19cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWwpe3g9cHVzaCh7dHlwZTpcInBhcmVuXCIsbm9kZXM6W119KTtkLnB1c2goeCk7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWMpe2lmKHgudHlwZSE9PVwicGFyZW5cIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9eD1kLnBvcCgpO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09X3x8bT09PWh8fG09PT1vKXtsZXQgZT1tO2xldCByO2lmKHQua2VlcFF1b3RlcyE9PXRydWUpe209XCJcIn13aGlsZSh2PEgmJihyPWFkdmFuY2UoKSkpe2lmKHI9PT1zKXttKz1yK2FkdmFuY2UoKTtjb250aW51ZX1pZihyPT09ZSl7aWYodC5rZWVwUXVvdGVzPT09dHJ1ZSltKz1yO2JyZWFrfW0rPXJ9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PXApeyQrKztsZXQgZT1iLnZhbHVlJiZiLnZhbHVlLnNsaWNlKC0xKT09PVwiJFwifHx4LmRvbGxhcj09PXRydWU7bGV0IHQ9e3R5cGU6XCJicmFjZVwiLG9wZW46dHJ1ZSxjbG9zZTpmYWxzZSxkb2xsYXI6ZSxkZXB0aDokLGNvbW1hczowLHJhbmdlczowLG5vZGVzOltdfTt4PXB1c2godCk7ZC5wdXNoKHgpO3B1c2goe3R5cGU6XCJvcGVuXCIsdmFsdWU6bX0pO2NvbnRpbnVlfWlmKG09PT1mKXtpZih4LnR5cGUhPT1cImJyYWNlXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO2NvbnRpbnVlfWxldCBlPVwiY2xvc2VcIjt4PWQucG9wKCk7eC5jbG9zZT10cnVlO3B1c2goe3R5cGU6ZSx2YWx1ZTptfSk7JC0tO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09aSYmJD4wKXtpZih4LnJhbmdlcz4wKXt4LnJhbmdlcz0wO2xldCBlPXgubm9kZXMuc2hpZnQoKTt4Lm5vZGVzPVtlLHt0eXBlOlwidGV4dFwiLHZhbHVlOm4oeCl9XX1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTptfSk7eC5jb21tYXMrKztjb250aW51ZX1pZihtPT09YSYmJD4wJiZ4LmNvbW1hcz09PTApe2xldCBlPXgubm9kZXM7aWYoJD09PTB8fGUubGVuZ3RoPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYoYi50eXBlPT09XCJkb3RcIil7eC5yYW5nZT1bXTtiLnZhbHVlKz1tO2IudHlwZT1cInJhbmdlXCI7aWYoeC5ub2Rlcy5sZW5ndGghPT0zJiZ4Lm5vZGVzLmxlbmd0aCE9PTUpe3guaW52YWxpZD10cnVlO3gucmFuZ2VzPTA7Yi50eXBlPVwidGV4dFwiO2NvbnRpbnVlfXgucmFuZ2VzKys7eC5hcmdzPVtdO2NvbnRpbnVlfWlmKGIudHlwZT09PVwicmFuZ2VcIil7ZS5wb3AoKTtsZXQgdD1lW2UubGVuZ3RoLTFdO3QudmFsdWUrPWIudmFsdWUrbTtiPXQ7eC5yYW5nZXMtLTtjb250aW51ZX1wdXNoKHt0eXBlOlwiZG90XCIsdmFsdWU6bX0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pfWRve3g9ZC5wb3AoKTtpZih4LnR5cGUhPT1cInJvb3RcIil7eC5ub2Rlcy5mb3JFYWNoKChlPT57aWYoIWUubm9kZXMpe2lmKGUudHlwZT09PVwib3BlblwiKWUuaXNPcGVuPXRydWU7aWYoZS50eXBlPT09XCJjbG9zZVwiKWUuaXNDbG9zZT10cnVlO2lmKCFlLm5vZGVzKWUudHlwZT1cInRleHRcIjtlLmludmFsaWQ9dHJ1ZX19KSk7bGV0IGU9ZFtkLmxlbmd0aC0xXTtsZXQgdD1lLm5vZGVzLmluZGV4T2YoeCk7ZS5ub2Rlcy5zcGxpY2UodCwxLC4uLngubm9kZXMpfX13aGlsZShkLmxlbmd0aD4wKTtwdXNoKHt0eXBlOlwiZW9zXCJ9KTtyZXR1cm4geX07ZS5leHBvcnRzPXBhcnNlfSwxMzc6KGUsdCxyKT0+e2NvbnN0IG49cig2MTcpO2UuZXhwb3J0cz0oZSx0PXt9KT0+e2xldCBzdHJpbmdpZnk9KGUscj17fSk9PntsZXQgdT10LmVzY2FwZUludmFsaWQmJm4uaXNJbnZhbGlkQnJhY2Uocik7bGV0IHM9ZS5pbnZhbGlkPT09dHJ1ZSYmdC5lc2NhcGVJbnZhbGlkPT09dHJ1ZTtsZXQgbz1cIlwiO2lmKGUudmFsdWUpe2lmKCh1fHxzKSYmbi5pc09wZW5PckNsb3NlKGUpKXtyZXR1cm5cIlxcXFxcIitlLnZhbHVlfXJldHVybiBlLnZhbHVlfWlmKGUudmFsdWUpe3JldHVybiBlLnZhbHVlfWlmKGUubm9kZXMpe2ZvcihsZXQgdCBvZiBlLm5vZGVzKXtvKz1zdHJpbmdpZnkodCl9fXJldHVybiBvfTtyZXR1cm4gc3RyaW5naWZ5KGUpfX0sNjE3OihlLHQpPT57dC5pc0ludGVnZXI9ZT0+e2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7cmV0dXJuIE51bWJlci5pc0ludGVnZXIoZSl9aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlLnRyaW0oKSE9PVwiXCIpe3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcihlKSl9cmV0dXJuIGZhbHNlfTt0LmZpbmQ9KGUsdCk9PmUubm9kZXMuZmluZCgoZT0+ZS50eXBlPT09dCkpO3QuZXhjZWVkc0xpbWl0PShlLHIsbj0xLHUpPT57aWYodT09PWZhbHNlKXJldHVybiBmYWxzZTtpZighdC5pc0ludGVnZXIoZSl8fCF0LmlzSW50ZWdlcihyKSlyZXR1cm4gZmFsc2U7cmV0dXJuKE51bWJlcihyKS1OdW1iZXIoZSkpL051bWJlcihuKT49dX07dC5lc2NhcGVOb2RlPShlLHQ9MCxyKT0+e2xldCBuPWUubm9kZXNbdF07aWYoIW4pcmV0dXJuO2lmKHImJm4udHlwZT09PXJ8fG4udHlwZT09PVwib3BlblwifHxuLnR5cGU9PT1cImNsb3NlXCIpe2lmKG4uZXNjYXBlZCE9PXRydWUpe24udmFsdWU9XCJcXFxcXCIrbi52YWx1ZTtuLmVzY2FwZWQ9dHJ1ZX19fTt0LmVuY2xvc2VCcmFjZT1lPT57aWYoZS50eXBlIT09XCJicmFjZVwiKXJldHVybiBmYWxzZTtpZihlLmNvbW1hcz4+MCtlLnJhbmdlcz4+MD09PTApe2UuaW52YWxpZD10cnVlO3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dC5pc0ludmFsaWRCcmFjZT1lPT57aWYoZS50eXBlIT09XCJicmFjZVwiKXJldHVybiBmYWxzZTtpZihlLmludmFsaWQ9PT10cnVlfHxlLmRvbGxhcilyZXR1cm4gdHJ1ZTtpZihlLmNvbW1hcz4+MCtlLnJhbmdlcz4+MD09PTApe2UuaW52YWxpZD10cnVlO3JldHVybiB0cnVlfWlmKGUub3BlbiE9PXRydWV8fGUuY2xvc2UhPT10cnVlKXtlLmludmFsaWQ9dHJ1ZTtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9O3QuaXNPcGVuT3JDbG9zZT1lPT57aWYoZS50eXBlPT09XCJvcGVuXCJ8fGUudHlwZT09PVwiY2xvc2VcIil7cmV0dXJuIHRydWV9cmV0dXJuIGUub3Blbj09PXRydWV8fGUuY2xvc2U9PT10cnVlfTt0LnJlZHVjZT1lPT5lLnJlZHVjZSgoKGUsdCk9PntpZih0LnR5cGU9PT1cInRleHRcIillLnB1c2godC52YWx1ZSk7aWYodC50eXBlPT09XCJyYW5nZVwiKXQudHlwZT1cInRleHRcIjtyZXR1cm4gZX0pLFtdKTt0LmZsYXR0ZW49KC4uLmUpPT57Y29uc3QgdD1bXTtjb25zdCBmbGF0PWU9Pntmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7bGV0IG49ZVtyXTtBcnJheS5pc0FycmF5KG4pP2ZsYXQobix0KTpuIT09dm9pZCAwJiZ0LnB1c2gobil9cmV0dXJuIHR9O2ZsYXQoZSk7cmV0dXJuIHR9fSw3ODM6KGUsdCxyKT0+e1xuLyohXG4gKiBmaWxsLXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9maWxsLXJhbmdlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY29uc3Qgbj1yKDgzNyk7Y29uc3QgdT1yKDQ5Mik7Y29uc3QgaXNPYmplY3Q9ZT0+ZSE9PW51bGwmJnR5cGVvZiBlPT09XCJvYmplY3RcIiYmIUFycmF5LmlzQXJyYXkoZSk7Y29uc3QgdHJhbnNmb3JtPWU9PnQ9PmU9PT10cnVlP051bWJlcih0KTpTdHJpbmcodCk7Y29uc3QgaXNWYWxpZFZhbHVlPWU9PnR5cGVvZiBlPT09XCJudW1iZXJcInx8dHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlIT09XCJcIjtjb25zdCBpc051bWJlcj1lPT5OdW1iZXIuaXNJbnRlZ2VyKCtlKTtjb25zdCB6ZXJvcz1lPT57bGV0IHQ9YCR7ZX1gO2xldCByPS0xO2lmKHRbMF09PT1cIi1cIil0PXQuc2xpY2UoMSk7aWYodD09PVwiMFwiKXJldHVybiBmYWxzZTt3aGlsZSh0Wysrcl09PT1cIjBcIik7cmV0dXJuIHI+MH07Y29uc3Qgc3RyaW5naWZ5PShlLHQscik9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCJ8fHR5cGVvZiB0PT09XCJzdHJpbmdcIil7cmV0dXJuIHRydWV9cmV0dXJuIHIuc3RyaW5naWZ5PT09dHJ1ZX07Y29uc3QgcGFkPShlLHQscik9PntpZih0PjApe2xldCByPWVbMF09PT1cIi1cIj9cIi1cIjpcIlwiO2lmKHIpZT1lLnNsaWNlKDEpO2U9citlLnBhZFN0YXJ0KHI/dC0xOnQsXCIwXCIpfWlmKHI9PT1mYWxzZSl7cmV0dXJuIFN0cmluZyhlKX1yZXR1cm4gZX07Y29uc3QgdG9NYXhMZW49KGUsdCk9PntsZXQgcj1lWzBdPT09XCItXCI/XCItXCI6XCJcIjtpZihyKXtlPWUuc2xpY2UoMSk7dC0tfXdoaWxlKGUubGVuZ3RoPHQpZT1cIjBcIitlO3JldHVybiByP1wiLVwiK2U6ZX07Y29uc3QgdG9TZXF1ZW5jZT0oZSx0KT0+e2UubmVnYXRpdmVzLnNvcnQoKChlLHQpPT5lPHQ/LTE6ZT50PzE6MCkpO2UucG9zaXRpdmVzLnNvcnQoKChlLHQpPT5lPHQ/LTE6ZT50PzE6MCkpO2xldCByPXQuY2FwdHVyZT9cIlwiOlwiPzpcIjtsZXQgbj1cIlwiO2xldCB1PVwiXCI7bGV0IHM7aWYoZS5wb3NpdGl2ZXMubGVuZ3RoKXtuPWUucG9zaXRpdmVzLmpvaW4oXCJ8XCIpfWlmKGUubmVnYXRpdmVzLmxlbmd0aCl7dT1gLSgke3J9JHtlLm5lZ2F0aXZlcy5qb2luKFwifFwiKX0pYH1pZihuJiZ1KXtzPWAke259fCR7dX1gfWVsc2V7cz1ufHx1fWlmKHQud3JhcCl7cmV0dXJuYCgke3J9JHtzfSlgfXJldHVybiBzfTtjb25zdCB0b1JhbmdlPShlLHQscixuKT0+e2lmKHIpe3JldHVybiB1KGUsdCx7d3JhcDpmYWxzZSwuLi5ufSl9bGV0IHM9U3RyaW5nLmZyb21DaGFyQ29kZShlKTtpZihlPT09dClyZXR1cm4gcztsZXQgbz1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpO3JldHVybmBbJHtzfS0ke299XWB9O2NvbnN0IHRvUmVnZXg9KGUsdCxyKT0+e2lmKEFycmF5LmlzQXJyYXkoZSkpe2xldCB0PXIud3JhcD09PXRydWU7bGV0IG49ci5jYXB0dXJlP1wiXCI6XCI/OlwiO3JldHVybiB0P2AoJHtufSR7ZS5qb2luKFwifFwiKX0pYDplLmpvaW4oXCJ8XCIpfXJldHVybiB1KGUsdCxyKX07Y29uc3QgcmFuZ2VFcnJvcj0oLi4uZSk9Pm5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByYW5nZSBhcmd1bWVudHM6IFwiK24uaW5zcGVjdCguLi5lKSk7Y29uc3QgaW52YWxpZFJhbmdlPShlLHQscik9PntpZihyLnN0cmljdFJhbmdlcz09PXRydWUpdGhyb3cgcmFuZ2VFcnJvcihbZSx0XSk7cmV0dXJuW119O2NvbnN0IGludmFsaWRTdGVwPShlLHQpPT57aWYodC5zdHJpY3RSYW5nZXM9PT10cnVlKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBzdGVwIFwiJHtlfVwiIHRvIGJlIGEgbnVtYmVyYCl9cmV0dXJuW119O2NvbnN0IGZpbGxOdW1iZXJzPShlLHQscj0xLG49e30pPT57bGV0IHU9TnVtYmVyKGUpO2xldCBzPU51bWJlcih0KTtpZighTnVtYmVyLmlzSW50ZWdlcih1KXx8IU51bWJlci5pc0ludGVnZXIocykpe2lmKG4uc3RyaWN0UmFuZ2VzPT09dHJ1ZSl0aHJvdyByYW5nZUVycm9yKFtlLHRdKTtyZXR1cm5bXX1pZih1PT09MCl1PTA7aWYocz09PTApcz0wO2xldCBvPXU+cztsZXQgaT1TdHJpbmcoZSk7bGV0IGE9U3RyaW5nKHQpO2xldCBsPVN0cmluZyhyKTtyPU1hdGgubWF4KE1hdGguYWJzKHIpLDEpO2xldCBjPXplcm9zKGkpfHx6ZXJvcyhhKXx8emVyb3MobCk7bGV0IHA9Yz9NYXRoLm1heChpLmxlbmd0aCxhLmxlbmd0aCxsLmxlbmd0aCk6MDtsZXQgZj1jPT09ZmFsc2UmJnN0cmluZ2lmeShlLHQsbik9PT1mYWxzZTtsZXQgQT1uLnRyYW5zZm9ybXx8dHJhbnNmb3JtKGYpO2lmKG4udG9SZWdleCYmcj09PTEpe3JldHVybiB0b1JhbmdlKHRvTWF4TGVuKGUscCksdG9NYXhMZW4odCxwKSx0cnVlLG4pfWxldCBSPXtuZWdhdGl2ZXM6W10scG9zaXRpdmVzOltdfTtsZXQgcHVzaD1lPT5SW2U8MD9cIm5lZ2F0aXZlc1wiOlwicG9zaXRpdmVzXCJdLnB1c2goTWF0aC5hYnMoZSkpO2xldCBfPVtdO2xldCBoPTA7d2hpbGUobz91Pj1zOnU8PXMpe2lmKG4udG9SZWdleD09PXRydWUmJnI+MSl7cHVzaCh1KX1lbHNle18ucHVzaChwYWQoQSh1LGgpLHAsZikpfXU9bz91LXI6dStyO2grK31pZihuLnRvUmVnZXg9PT10cnVlKXtyZXR1cm4gcj4xP3RvU2VxdWVuY2UoUixuKTp0b1JlZ2V4KF8sbnVsbCx7d3JhcDpmYWxzZSwuLi5ufSl9cmV0dXJuIF99O2NvbnN0IGZpbGxMZXR0ZXJzPShlLHQscj0xLG49e30pPT57aWYoIWlzTnVtYmVyKGUpJiZlLmxlbmd0aD4xfHwhaXNOdW1iZXIodCkmJnQubGVuZ3RoPjEpe3JldHVybiBpbnZhbGlkUmFuZ2UoZSx0LG4pfWxldCB1PW4udHJhbnNmb3JtfHwoZT0+U3RyaW5nLmZyb21DaGFyQ29kZShlKSk7bGV0IHM9YCR7ZX1gLmNoYXJDb2RlQXQoMCk7bGV0IG89YCR7dH1gLmNoYXJDb2RlQXQoMCk7bGV0IGk9cz5vO2xldCBhPU1hdGgubWluKHMsbyk7bGV0IGw9TWF0aC5tYXgocyxvKTtpZihuLnRvUmVnZXgmJnI9PT0xKXtyZXR1cm4gdG9SYW5nZShhLGwsZmFsc2Usbil9bGV0IGM9W107bGV0IHA9MDt3aGlsZShpP3M+PW86czw9byl7Yy5wdXNoKHUocyxwKSk7cz1pP3MtcjpzK3I7cCsrfWlmKG4udG9SZWdleD09PXRydWUpe3JldHVybiB0b1JlZ2V4KGMsbnVsbCx7d3JhcDpmYWxzZSxvcHRpb25zOm59KX1yZXR1cm4gY307Y29uc3QgZmlsbD0oZSx0LHIsbj17fSk9PntpZih0PT1udWxsJiZpc1ZhbGlkVmFsdWUoZSkpe3JldHVybltlXX1pZighaXNWYWxpZFZhbHVlKGUpfHwhaXNWYWxpZFZhbHVlKHQpKXtyZXR1cm4gaW52YWxpZFJhbmdlKGUsdCxuKX1pZih0eXBlb2Ygcj09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZpbGwoZSx0LDEse3RyYW5zZm9ybTpyfSl9aWYoaXNPYmplY3Qocikpe3JldHVybiBmaWxsKGUsdCwwLHIpfWxldCB1PXsuLi5ufTtpZih1LmNhcHR1cmU9PT10cnVlKXUud3JhcD10cnVlO3I9cnx8dS5zdGVwfHwxO2lmKCFpc051bWJlcihyKSl7aWYociE9bnVsbCYmIWlzT2JqZWN0KHIpKXJldHVybiBpbnZhbGlkU3RlcChyLHUpO3JldHVybiBmaWxsKGUsdCwxLHIpfWlmKGlzTnVtYmVyKGUpJiZpc051bWJlcih0KSl7cmV0dXJuIGZpbGxOdW1iZXJzKGUsdCxyLHUpfXJldHVybiBmaWxsTGV0dGVycyhlLHQsTWF0aC5tYXgoTWF0aC5hYnMociksMSksdSl9O2UuZXhwb3J0cz1maWxsfSwzNTc6ZT0+e1xuLyohXG4gKiBpcy1udW1iZXIgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLW51bWJlcj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmUuZXhwb3J0cz1mdW5jdGlvbihlKXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe3JldHVybiBlLWU9PT0wfWlmKHR5cGVvZiBlPT09XCJzdHJpbmdcIiYmZS50cmltKCkhPT1cIlwiKXtyZXR1cm4gTnVtYmVyLmlzRmluaXRlP051bWJlci5pc0Zpbml0ZSgrZSk6aXNGaW5pdGUoK2UpfXJldHVybiBmYWxzZX19LDk3MTooZSx0LHIpPT57Y29uc3Qgbj1yKDgzNyk7Y29uc3QgdT1yKDMzMyk7Y29uc3Qgcz1yKDI1MSk7Y29uc3Qgbz1yKDUxMyk7Y29uc3QgaXNFbXB0eVN0cmluZz1lPT5lPT09XCJcInx8ZT09PVwiLi9cIjtjb25zdCBtaWNyb21hdGNoPShlLHQscik9Pnt0PVtdLmNvbmNhdCh0KTtlPVtdLmNvbmNhdChlKTtsZXQgbj1uZXcgU2V0O2xldCB1PW5ldyBTZXQ7bGV0IG89bmV3IFNldDtsZXQgaT0wO2xldCBvblJlc3VsdD1lPT57by5hZGQoZS5vdXRwdXQpO2lmKHImJnIub25SZXN1bHQpe3Iub25SZXN1bHQoZSl9fTtmb3IobGV0IG89MDtvPHQubGVuZ3RoO28rKyl7bGV0IGE9cyhTdHJpbmcodFtvXSksey4uLnIsb25SZXN1bHQ6b25SZXN1bHR9LHRydWUpO2xldCBsPWEuc3RhdGUubmVnYXRlZHx8YS5zdGF0ZS5uZWdhdGVkRXh0Z2xvYjtpZihsKWkrKztmb3IobGV0IHQgb2YgZSl7bGV0IGU9YSh0LHRydWUpO2xldCByPWw/IWUuaXNNYXRjaDplLmlzTWF0Y2g7aWYoIXIpY29udGludWU7aWYobCl7bi5hZGQoZS5vdXRwdXQpfWVsc2V7bi5kZWxldGUoZS5vdXRwdXQpO3UuYWRkKGUub3V0cHV0KX19fWxldCBhPWk9PT10Lmxlbmd0aD9bLi4ub106Wy4uLnVdO2xldCBsPWEuZmlsdGVyKChlPT4hbi5oYXMoZSkpKTtpZihyJiZsLmxlbmd0aD09PTApe2lmKHIuZmFpbGdsb2I9PT10cnVlKXt0aHJvdyBuZXcgRXJyb3IoYE5vIG1hdGNoZXMgZm91bmQgZm9yIFwiJHt0LmpvaW4oXCIsIFwiKX1cImApfWlmKHIubm9udWxsPT09dHJ1ZXx8ci5udWxsZ2xvYj09PXRydWUpe3JldHVybiByLnVuZXNjYXBlP3QubWFwKChlPT5lLnJlcGxhY2UoL1xcXFwvZyxcIlwiKSkpOnR9fXJldHVybiBsfTttaWNyb21hdGNoLm1hdGNoPW1pY3JvbWF0Y2g7bWljcm9tYXRjaC5tYXRjaGVyPShlLHQpPT5zKGUsdCk7bWljcm9tYXRjaC5pc01hdGNoPShlLHQscik9PnModCxyKShlKTttaWNyb21hdGNoLmFueT1taWNyb21hdGNoLmlzTWF0Y2g7bWljcm9tYXRjaC5ub3Q9KGUsdCxyPXt9KT0+e3Q9W10uY29uY2F0KHQpLm1hcChTdHJpbmcpO2xldCBuPW5ldyBTZXQ7bGV0IHU9W107bGV0IG9uUmVzdWx0PWU9PntpZihyLm9uUmVzdWx0KXIub25SZXN1bHQoZSk7dS5wdXNoKGUub3V0cHV0KX07bGV0IHM9bWljcm9tYXRjaChlLHQsey4uLnIsb25SZXN1bHQ6b25SZXN1bHR9KTtmb3IobGV0IGUgb2YgdSl7aWYoIXMuaW5jbHVkZXMoZSkpe24uYWRkKGUpfX1yZXR1cm5bLi4ubl19O21pY3JvbWF0Y2guY29udGFpbnM9KGUsdCxyKT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmc6IFwiJHtuLmluc3BlY3QoZSl9XCJgKX1pZihBcnJheS5pc0FycmF5KHQpKXtyZXR1cm4gdC5zb21lKCh0PT5taWNyb21hdGNoLmNvbnRhaW5zKGUsdCxyKSkpfWlmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7aWYoaXNFbXB0eVN0cmluZyhlKXx8aXNFbXB0eVN0cmluZyh0KSl7cmV0dXJuIGZhbHNlfWlmKGUuaW5jbHVkZXModCl8fGUuc3RhcnRzV2l0aChcIi4vXCIpJiZlLnNsaWNlKDIpLmluY2x1ZGVzKHQpKXtyZXR1cm4gdHJ1ZX19cmV0dXJuIG1pY3JvbWF0Y2guaXNNYXRjaChlLHQsey4uLnIsY29udGFpbnM6dHJ1ZX0pfTttaWNyb21hdGNoLm1hdGNoS2V5cz0oZSx0LHIpPT57aWYoIW8uaXNPYmplY3QoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0XCIpfWxldCBuPW1pY3JvbWF0Y2goT2JqZWN0LmtleXMoZSksdCxyKTtsZXQgdT17fTtmb3IobGV0IHQgb2Ygbil1W3RdPWVbdF07cmV0dXJuIHV9O21pY3JvbWF0Y2guc29tZT0oZSx0LHIpPT57bGV0IG49W10uY29uY2F0KGUpO2ZvcihsZXQgZSBvZltdLmNvbmNhdCh0KSl7bGV0IHQ9cyhTdHJpbmcoZSkscik7aWYobi5zb21lKChlPT50KGUpKSkpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9O21pY3JvbWF0Y2guZXZlcnk9KGUsdCxyKT0+e2xldCBuPVtdLmNvbmNhdChlKTtmb3IobGV0IGUgb2ZbXS5jb25jYXQodCkpe2xldCB0PXMoU3RyaW5nKGUpLHIpO2lmKCFuLmV2ZXJ5KChlPT50KGUpKSkpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9O21pY3JvbWF0Y2guYWxsPShlLHQscik9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nOiBcIiR7bi5pbnNwZWN0KGUpfVwiYCl9cmV0dXJuW10uY29uY2F0KHQpLmV2ZXJ5KCh0PT5zKHQscikoZSkpKX07bWljcm9tYXRjaC5jYXB0dXJlPShlLHQscik9PntsZXQgbj1vLmlzV2luZG93cyhyKTtsZXQgdT1zLm1ha2VSZShTdHJpbmcoZSksey4uLnIsY2FwdHVyZTp0cnVlfSk7bGV0IGk9dS5leGVjKG4/by50b1Bvc2l4U2xhc2hlcyh0KTp0KTtpZihpKXtyZXR1cm4gaS5zbGljZSgxKS5tYXAoKGU9PmU9PT12b2lkIDA/XCJcIjplKSl9fTttaWNyb21hdGNoLm1ha2VSZT0oLi4uZSk9PnMubWFrZVJlKC4uLmUpO21pY3JvbWF0Y2guc2Nhbj0oLi4uZSk9PnMuc2NhbiguLi5lKTttaWNyb21hdGNoLnBhcnNlPShlLHQpPT57bGV0IHI9W107Zm9yKGxldCBuIG9mW10uY29uY2F0KGV8fFtdKSl7Zm9yKGxldCBlIG9mIHUoU3RyaW5nKG4pLHQpKXtyLnB1c2gocy5wYXJzZShlLHQpKX19cmV0dXJuIHJ9O21pY3JvbWF0Y2guYnJhY2VzPShlLHQpPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKTtpZih0JiZ0Lm5vYnJhY2U9PT10cnVlfHwhL1xcey4qXFx9Ly50ZXN0KGUpKXtyZXR1cm5bZV19cmV0dXJuIHUoZSx0KX07bWljcm9tYXRjaC5icmFjZUV4cGFuZD0oZSx0KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBzdHJpbmdcIik7cmV0dXJuIG1pY3JvbWF0Y2guYnJhY2VzKGUsey4uLnQsZXhwYW5kOnRydWV9KX07ZS5leHBvcnRzPW1pY3JvbWF0Y2h9LDI1MTooZSx0LHIpPT57ZS5leHBvcnRzPXIoNjgzKX0sMzU2OihlLHQscik9Pntjb25zdCBuPXIoMTcpO2NvbnN0IHU9XCJcXFxcXFxcXC9cIjtjb25zdCBzPWBbXiR7dX1dYDtjb25zdCBvPVwiXFxcXC5cIjtjb25zdCBpPVwiXFxcXCtcIjtjb25zdCBhPVwiXFxcXD9cIjtjb25zdCBsPVwiXFxcXC9cIjtjb25zdCBjPVwiKD89LilcIjtjb25zdCBwPVwiW14vXVwiO2NvbnN0IGY9YCg/OiR7bH18JClgO2NvbnN0IEE9YCg/Ol58JHtsfSlgO2NvbnN0IFI9YCR7b317MSwyfSR7Zn1gO2NvbnN0IF89YCg/ISR7b30pYDtjb25zdCBoPWAoPyEke0F9JHtSfSlgO2NvbnN0IGc9YCg/ISR7b317MCwxfSR7Zn0pYDtjb25zdCBFPWAoPyEke1J9KWA7Y29uc3QgQz1gW14uJHtsfV1gO2NvbnN0IHk9YCR7cH0qP2A7Y29uc3QgZD17RE9UX0xJVEVSQUw6byxQTFVTX0xJVEVSQUw6aSxRTUFSS19MSVRFUkFMOmEsU0xBU0hfTElURVJBTDpsLE9ORV9DSEFSOmMsUU1BUks6cCxFTkRfQU5DSE9SOmYsRE9UU19TTEFTSDpSLE5PX0RPVDpfLE5PX0RPVFM6aCxOT19ET1RfU0xBU0g6ZyxOT19ET1RTX1NMQVNIOkUsUU1BUktfTk9fRE9UOkMsU1RBUjp5LFNUQVJUX0FOQ0hPUjpBfTtjb25zdCB4PXsuLi5kLFNMQVNIX0xJVEVSQUw6YFske3V9XWAsUU1BUks6cyxTVEFSOmAke3N9Kj9gLERPVFNfU0xBU0g6YCR7b317MSwyfSg/Olske3V9XXwkKWAsTk9fRE9UOmAoPyEke299KWAsTk9fRE9UUzpgKD8hKD86XnxbJHt1fV0pJHtvfXsxLDJ9KD86WyR7dX1dfCQpKWAsTk9fRE9UX1NMQVNIOmAoPyEke299ezAsMX0oPzpbJHt1fV18JCkpYCxOT19ET1RTX1NMQVNIOmAoPyEke299ezEsMn0oPzpbJHt1fV18JCkpYCxRTUFSS19OT19ET1Q6YFteLiR7dX1dYCxTVEFSVF9BTkNIT1I6YCg/Ol58WyR7dX1dKWAsRU5EX0FOQ0hPUjpgKD86WyR7dX1dfCQpYH07Y29uc3QgYj17YWxudW06XCJhLXpBLVowLTlcIixhbHBoYTpcImEtekEtWlwiLGFzY2lpOlwiXFxcXHgwMC1cXFxceDdGXCIsYmxhbms6XCIgXFxcXHRcIixjbnRybDpcIlxcXFx4MDAtXFxcXHgxRlxcXFx4N0ZcIixkaWdpdDpcIjAtOVwiLGdyYXBoOlwiXFxcXHgyMS1cXFxceDdFXCIsbG93ZXI6XCJhLXpcIixwcmludDpcIlxcXFx4MjAtXFxcXHg3RSBcIixwdW5jdDpcIlxcXFwtIVxcXCIjJCUmJygpXFxcXCorLC4vOjs8PT4/QFtcXFxcXV5fYHt8fX5cIixzcGFjZTpcIiBcXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmXCIsdXBwZXI6XCJBLVpcIix3b3JkOlwiQS1aYS16MC05X1wiLHhkaWdpdDpcIkEtRmEtZjAtOVwifTtlLmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxQT1NJWF9SRUdFWF9TT1VSQ0U6YixSRUdFWF9CQUNLU0xBU0g6L1xcXFwoPyFbKis/XiR7fSh8KVtcXF1dKS9nLFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOi9eW15AIVtcXF0uLCQqKz9ee30oKXxcXFxcL10rLyxSRUdFWF9TUEVDSUFMX0NIQVJTOi9bLSorPy5eJHt9KHwpW1xcXV0vLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjovKFxcXFw/KSgoXFxXKShcXDMqKSkvZyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDovKFstKis/Ll4ke30ofClbXFxdXSkvZyxSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOi8oPzpcXFsuKj9bXlxcXFxdXFxdfFxcXFwoPz0uKSkvZyxSRVBMQUNFTUVOVFM6e1wiKioqXCI6XCIqXCIsXCIqKi8qKlwiOlwiKipcIixcIioqLyoqLyoqXCI6XCIqKlwifSxDSEFSXzA6NDgsQ0hBUl85OjU3LENIQVJfVVBQRVJDQVNFX0E6NjUsQ0hBUl9MT1dFUkNBU0VfQTo5NyxDSEFSX1VQUEVSQ0FTRV9aOjkwLENIQVJfTE9XRVJDQVNFX1o6MTIyLENIQVJfTEVGVF9QQVJFTlRIRVNFUzo0MCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOjQxLENIQVJfQVNURVJJU0s6NDIsQ0hBUl9BTVBFUlNBTkQ6MzgsQ0hBUl9BVDo2NCxDSEFSX0JBQ0tXQVJEX1NMQVNIOjkyLENIQVJfQ0FSUklBR0VfUkVUVVJOOjEzLENIQVJfQ0lSQ1VNRkxFWF9BQ0NFTlQ6OTQsQ0hBUl9DT0xPTjo1OCxDSEFSX0NPTU1BOjQ0LENIQVJfRE9UOjQ2LENIQVJfRE9VQkxFX1FVT1RFOjM0LENIQVJfRVFVQUw6NjEsQ0hBUl9FWENMQU1BVElPTl9NQVJLOjMzLENIQVJfRk9STV9GRUVEOjEyLENIQVJfRk9SV0FSRF9TTEFTSDo0NyxDSEFSX0dSQVZFX0FDQ0VOVDo5NixDSEFSX0hBU0g6MzUsQ0hBUl9IWVBIRU5fTUlOVVM6NDUsQ0hBUl9MRUZUX0FOR0xFX0JSQUNLRVQ6NjAsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOjEyMyxDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQ6OTEsQ0hBUl9MSU5FX0ZFRUQ6MTAsQ0hBUl9OT19CUkVBS19TUEFDRToxNjAsQ0hBUl9QRVJDRU5UOjM3LENIQVJfUExVUzo0MyxDSEFSX1FVRVNUSU9OX01BUks6NjMsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOjYyLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6MTI1LENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6OTMsQ0hBUl9TRU1JQ09MT046NTksQ0hBUl9TSU5HTEVfUVVPVEU6MzksQ0hBUl9TUEFDRTozMixDSEFSX1RBQjo5LENIQVJfVU5ERVJTQ09SRTo5NSxDSEFSX1ZFUlRJQ0FMX0xJTkU6MTI0LENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOjY1Mjc5LFNFUDpuLnNlcCxleHRnbG9iQ2hhcnMoZSl7cmV0dXJue1wiIVwiOnt0eXBlOlwibmVnYXRlXCIsb3BlbjpcIig/Oig/ISg/OlwiLGNsb3NlOmApKSR7ZS5TVEFSfSlgfSxcIj9cIjp7dHlwZTpcInFtYXJrXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKT9cIn0sXCIrXCI6e3R5cGU6XCJwbHVzXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKStcIn0sXCIqXCI6e3R5cGU6XCJzdGFyXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKSpcIn0sXCJAXCI6e3R5cGU6XCJhdFwiLG9wZW46XCIoPzpcIixjbG9zZTpcIilcIn19fSxnbG9iQ2hhcnMoZSl7cmV0dXJuIGU9PT10cnVlP3g6ZH19fSw3NTQ6KGUsdCxyKT0+e2NvbnN0IG49cigzNTYpO2NvbnN0IHU9cig1MTMpO2NvbnN0e01BWF9MRU5HVEg6cyxQT1NJWF9SRUdFWF9TT1VSQ0U6byxSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzppLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjphLFJFUExBQ0VNRU5UUzpsfT1uO2NvbnN0IGV4cGFuZFJhbmdlPShlLHQpPT57aWYodHlwZW9mIHQuZXhwYW5kUmFuZ2U9PT1cImZ1bmN0aW9uXCIpe3JldHVybiB0LmV4cGFuZFJhbmdlKC4uLmUsdCl9ZS5zb3J0KCk7Y29uc3Qgcj1gWyR7ZS5qb2luKFwiLVwiKX1dYDt0cnl7bmV3IFJlZ0V4cChyKX1jYXRjaCh0KXtyZXR1cm4gZS5tYXAoKGU9PnUuZXNjYXBlUmVnZXgoZSkpKS5qb2luKFwiLi5cIil9cmV0dXJuIHJ9O2NvbnN0IHN5bnRheEVycm9yPShlLHQpPT5gTWlzc2luZyAke2V9OiBcIiR7dH1cIiAtIHVzZSBcIlxcXFxcXFxcJHt0fVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7Y29uc3QgcGFyc2U9KGUsdCk9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX1lPWxbZV18fGU7Y29uc3Qgcj17Li4udH07Y29uc3QgYz10eXBlb2Ygci5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsci5tYXhMZW5ndGgpOnM7bGV0IHA9ZS5sZW5ndGg7aWYocD5jKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtwfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke2N9YCl9Y29uc3QgZj17dHlwZTpcImJvc1wiLHZhbHVlOlwiXCIsb3V0cHV0OnIucHJlcGVuZHx8XCJcIn07Y29uc3QgQT1bZl07Y29uc3QgUj1yLmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgXz11LmlzV2luZG93cyh0KTtjb25zdCBoPW4uZ2xvYkNoYXJzKF8pO2NvbnN0IGc9bi5leHRnbG9iQ2hhcnMoaCk7Y29uc3R7RE9UX0xJVEVSQUw6RSxQTFVTX0xJVEVSQUw6QyxTTEFTSF9MSVRFUkFMOnksT05FX0NIQVI6ZCxET1RTX1NMQVNIOngsTk9fRE9UOmIsTk9fRE9UX1NMQVNIOlMsTk9fRE9UU19TTEFTSDpILFFNQVJLOnYsUU1BUktfTk9fRE9UOiQsU1RBUjptLFNUQVJUX0FOQ0hPUjpUfT1oO2NvbnN0IGdsb2JzdGFyPWU9PmAoJHtSfSg/Oig/ISR7VH0ke2UuZG90P3g6RX0pLikqPylgO2NvbnN0IEw9ci5kb3Q/XCJcIjpiO2NvbnN0IE89ci5kb3Q/djokO2xldCB3PXIuYmFzaD09PXRydWU/Z2xvYnN0YXIocik6bTtpZihyLmNhcHR1cmUpe3c9YCgke3d9KWB9aWYodHlwZW9mIHIubm9leHQ9PT1cImJvb2xlYW5cIil7ci5ub2V4dGdsb2I9ci5ub2V4dH1jb25zdCBOPXtpbnB1dDplLGluZGV4Oi0xLHN0YXJ0OjAsZG90OnIuZG90PT09dHJ1ZSxjb25zdW1lZDpcIlwiLG91dHB1dDpcIlwiLHByZWZpeDpcIlwiLGJhY2t0cmFjazpmYWxzZSxuZWdhdGVkOmZhbHNlLGJyYWNrZXRzOjAsYnJhY2VzOjAscGFyZW5zOjAscXVvdGVzOjAsZ2xvYnN0YXI6ZmFsc2UsdG9rZW5zOkF9O2U9dS5yZW1vdmVQcmVmaXgoZSxOKTtwPWUubGVuZ3RoO2NvbnN0IGs9W107Y29uc3QgST1bXTtjb25zdCBNPVtdO2xldCBQPWY7bGV0IEI7Y29uc3QgZW9zPSgpPT5OLmluZGV4PT09cC0xO2NvbnN0IEc9Ti5wZWVrPSh0PTEpPT5lW04uaW5kZXgrdF07Y29uc3QgRD1OLmFkdmFuY2U9KCk9PmVbKytOLmluZGV4XTtjb25zdCByZW1haW5pbmc9KCk9PmUuc2xpY2UoTi5pbmRleCsxKTtjb25zdCBjb25zdW1lPShlPVwiXCIsdD0wKT0+e04uY29uc3VtZWQrPWU7Ti5pbmRleCs9dH07Y29uc3QgYXBwZW5kPWU9PntOLm91dHB1dCs9ZS5vdXRwdXQhPW51bGw/ZS5vdXRwdXQ6ZS52YWx1ZTtjb25zdW1lKGUudmFsdWUpfTtjb25zdCBuZWdhdGU9KCk9PntsZXQgZT0xO3doaWxlKEcoKT09PVwiIVwiJiYoRygyKSE9PVwiKFwifHxHKDMpPT09XCI/XCIpKXtEKCk7Ti5zdGFydCsrO2UrK31pZihlJTI9PT0wKXtyZXR1cm4gZmFsc2V9Ti5uZWdhdGVkPXRydWU7Ti5zdGFydCsrO3JldHVybiB0cnVlfTtjb25zdCBpbmNyZW1lbnQ9ZT0+e05bZV0rKztNLnB1c2goZSl9O2NvbnN0IGRlY3JlbWVudD1lPT57TltlXS0tO00ucG9wKCl9O2NvbnN0IHB1c2g9ZT0+e2lmKFAudHlwZT09PVwiZ2xvYnN0YXJcIil7Y29uc3QgdD1OLmJyYWNlcz4wJiYoZS50eXBlPT09XCJjb21tYVwifHxlLnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IHI9ZS5leHRnbG9iPT09dHJ1ZXx8ay5sZW5ndGgmJihlLnR5cGU9PT1cInBpcGVcInx8ZS50eXBlPT09XCJwYXJlblwiKTtpZihlLnR5cGUhPT1cInNsYXNoXCImJmUudHlwZSE9PVwicGFyZW5cIiYmIXQmJiFyKXtOLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC1QLm91dHB1dC5sZW5ndGgpO1AudHlwZT1cInN0YXJcIjtQLnZhbHVlPVwiKlwiO1Aub3V0cHV0PXc7Ti5vdXRwdXQrPVAub3V0cHV0fX1pZihrLmxlbmd0aCYmZS50eXBlIT09XCJwYXJlblwiJiYhZ1tlLnZhbHVlXSl7a1trLmxlbmd0aC0xXS5pbm5lcis9ZS52YWx1ZX1pZihlLnZhbHVlfHxlLm91dHB1dClhcHBlbmQoZSk7aWYoUCYmUC50eXBlPT09XCJ0ZXh0XCImJmUudHlwZT09PVwidGV4dFwiKXtQLnZhbHVlKz1lLnZhbHVlO1Aub3V0cHV0PShQLm91dHB1dHx8XCJcIikrZS52YWx1ZTtyZXR1cm59ZS5wcmV2PVA7QS5wdXNoKGUpO1A9ZX07Y29uc3QgZXh0Z2xvYk9wZW49KGUsdCk9Pntjb25zdCBuPXsuLi5nW3RdLGNvbmRpdGlvbnM6MSxpbm5lcjpcIlwifTtuLnByZXY9UDtuLnBhcmVucz1OLnBhcmVucztuLm91dHB1dD1OLm91dHB1dDtjb25zdCB1PShyLmNhcHR1cmU/XCIoXCI6XCJcIikrbi5vcGVuO2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOmUsdmFsdWU6dCxvdXRwdXQ6Ti5vdXRwdXQ/XCJcIjpkfSk7cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkQoKSxvdXRwdXQ6dX0pO2sucHVzaChuKX07Y29uc3QgZXh0Z2xvYkNsb3NlPWU9PntsZXQgdD1lLmNsb3NlKyhyLmNhcHR1cmU/XCIpXCI6XCJcIik7aWYoZS50eXBlPT09XCJuZWdhdGVcIil7bGV0IG49dztpZihlLmlubmVyJiZlLmlubmVyLmxlbmd0aD4xJiZlLmlubmVyLmluY2x1ZGVzKFwiL1wiKSl7bj1nbG9ic3RhcihyKX1pZihuIT09d3x8ZW9zKCl8fC9eXFwpKyQvLnRlc3QocmVtYWluaW5nKCkpKXt0PWUuY2xvc2U9YCkkKSkke259YH1pZihlLnByZXYudHlwZT09PVwiYm9zXCIpe04ubmVnYXRlZEV4dGdsb2I9dHJ1ZX19cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkIsb3V0cHV0OnR9KTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9O2lmKHIuZmFzdHBhdGhzIT09ZmFsc2UmJiEvKF5bKiFdfFsvKClbXFxde31cIl0pLy50ZXN0KGUpKXtsZXQgbj1mYWxzZTtsZXQgcz1lLnJlcGxhY2UoYSwoKGUsdCxyLHUscyxvKT0+e2lmKHU9PT1cIlxcXFxcIil7bj10cnVlO3JldHVybiBlfWlmKHU9PT1cIj9cIil7aWYodCl7cmV0dXJuIHQrdSsocz92LnJlcGVhdChzLmxlbmd0aCk6XCJcIil9aWYobz09PTApe3JldHVybiBPKyhzP3YucmVwZWF0KHMubGVuZ3RoKTpcIlwiKX1yZXR1cm4gdi5yZXBlYXQoci5sZW5ndGgpfWlmKHU9PT1cIi5cIil7cmV0dXJuIEUucmVwZWF0KHIubGVuZ3RoKX1pZih1PT09XCIqXCIpe2lmKHQpe3JldHVybiB0K3UrKHM/dzpcIlwiKX1yZXR1cm4gd31yZXR1cm4gdD9lOmBcXFxcJHtlfWB9KSk7aWYobj09PXRydWUpe2lmKHIudW5lc2NhcGU9PT10cnVlKXtzPXMucmVwbGFjZSgvXFxcXC9nLFwiXCIpfWVsc2V7cz1zLnJlcGxhY2UoL1xcXFwrL2csKGU9PmUubGVuZ3RoJTI9PT0wP1wiXFxcXFxcXFxcIjplP1wiXFxcXFwiOlwiXCIpKX19aWYocz09PWUmJnIuY29udGFpbnM9PT10cnVlKXtOLm91dHB1dD1lO3JldHVybiBOfU4ub3V0cHV0PXUud3JhcE91dHB1dChzLE4sdCk7cmV0dXJuIE59d2hpbGUoIWVvcygpKXtCPUQoKTtpZihCPT09XCJcXDBcIil7Y29udGludWV9aWYoQj09PVwiXFxcXFwiKXtjb25zdCBlPUcoKTtpZihlPT09XCIvXCImJnIuYmFzaCE9PXRydWUpe2NvbnRpbnVlfWlmKGU9PT1cIi5cInx8ZT09PVwiO1wiKXtjb250aW51ZX1pZighZSl7Qis9XCJcXFxcXCI7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCfSk7Y29udGludWV9Y29uc3QgdD0vXlxcXFwrLy5leGVjKHJlbWFpbmluZygpKTtsZXQgbj0wO2lmKHQmJnRbMF0ubGVuZ3RoPjIpe249dFswXS5sZW5ndGg7Ti5pbmRleCs9bjtpZihuJTIhPT0wKXtCKz1cIlxcXFxcIn19aWYoci51bmVzY2FwZT09PXRydWUpe0I9RCgpfHxcIlwifWVsc2V7Qis9RCgpfHxcIlwifWlmKE4uYnJhY2tldHM9PT0wKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX19aWYoTi5icmFja2V0cz4wJiYoQiE9PVwiXVwifHxQLnZhbHVlPT09XCJbXCJ8fFAudmFsdWU9PT1cIlteXCIpKXtpZihyLnBvc2l4IT09ZmFsc2UmJkI9PT1cIjpcIil7Y29uc3QgZT1QLnZhbHVlLnNsaWNlKDEpO2lmKGUuaW5jbHVkZXMoXCJbXCIpKXtQLnBvc2l4PXRydWU7aWYoZS5pbmNsdWRlcyhcIjpcIikpe2NvbnN0IGU9UC52YWx1ZS5sYXN0SW5kZXhPZihcIltcIik7Y29uc3QgdD1QLnZhbHVlLnNsaWNlKDAsZSk7Y29uc3Qgcj1QLnZhbHVlLnNsaWNlKGUrMik7Y29uc3Qgbj1vW3JdO2lmKG4pe1AudmFsdWU9dCtuO04uYmFja3RyYWNrPXRydWU7RCgpO2lmKCFmLm91dHB1dCYmQS5pbmRleE9mKFApPT09MSl7Zi5vdXRwdXQ9ZH1jb250aW51ZX19fX1pZihCPT09XCJbXCImJkcoKSE9PVwiOlwifHxCPT09XCItXCImJkcoKT09PVwiXVwiKXtCPWBcXFxcJHtCfWB9aWYoQj09PVwiXVwiJiYoUC52YWx1ZT09PVwiW1wifHxQLnZhbHVlPT09XCJbXlwiKSl7Qj1gXFxcXCR7Qn1gfWlmKHIucG9zaXg9PT10cnVlJiZCPT09XCIhXCImJlAudmFsdWU9PT1cIltcIil7Qj1cIl5cIn1QLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2NvbnRpbnVlfWlmKE4ucXVvdGVzPT09MSYmQiE9PSdcIicpe0I9dS5lc2NhcGVSZWdleChCKTtQLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT0nXCInKXtOLnF1b3Rlcz1OLnF1b3Rlcz09PTE/MDoxO2lmKHIua2VlcFF1b3Rlcz09PXRydWUpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pfWNvbnRpbnVlfWlmKEI9PT1cIihcIil7aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6XCJwYXJlblwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihCPT09XCIpXCIpe2lmKE4ucGFyZW5zPT09MCYmci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIihcIikpfWNvbnN0IGU9a1trLmxlbmd0aC0xXTtpZihlJiZOLnBhcmVucz09PWUucGFyZW5zKzEpe2V4dGdsb2JDbG9zZShrLnBvcCgpKTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpCLG91dHB1dDpOLnBhcmVucz9cIilcIjpcIlxcXFwpXCJ9KTtkZWNyZW1lbnQoXCJwYXJlbnNcIik7Y29udGludWV9aWYoQj09PVwiW1wiKXtpZihyLm5vYnJhY2tldD09PXRydWV8fCFyZW1haW5pbmcoKS5pbmNsdWRlcyhcIl1cIikpe2lmKHIubm9icmFja2V0IT09dHJ1ZSYmci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpfUI9YFxcXFwke0J9YH1lbHNle2luY3JlbWVudChcImJyYWNrZXRzXCIpfXB1c2goe3R5cGU6XCJicmFja2V0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT1cIl1cIil7aWYoci5ub2JyYWNrZXQ9PT10cnVlfHxQJiZQLnR5cGU9PT1cImJyYWNrZXRcIiYmUC52YWx1ZS5sZW5ndGg9PT0xKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OmBcXFxcJHtCfWB9KTtjb250aW51ZX1pZihOLmJyYWNrZXRzPT09MCl7aWYoci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIltcIikpfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6QixvdXRwdXQ6YFxcXFwke0J9YH0pO2NvbnRpbnVlfWRlY3JlbWVudChcImJyYWNrZXRzXCIpO2NvbnN0IGU9UC52YWx1ZS5zbGljZSgxKTtpZihQLnBvc2l4IT09dHJ1ZSYmZVswXT09PVwiXlwiJiYhZS5pbmNsdWRlcyhcIi9cIikpe0I9YC8ke0J9YH1QLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2lmKHIubGl0ZXJhbEJyYWNrZXRzPT09ZmFsc2V8fHUuaGFzUmVnZXhDaGFycyhlKSl7Y29udGludWV9Y29uc3QgdD11LmVzY2FwZVJlZ2V4KFAudmFsdWUpO04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLVAudmFsdWUubGVuZ3RoKTtpZihyLmxpdGVyYWxCcmFja2V0cz09PXRydWUpe04ub3V0cHV0Kz10O1AudmFsdWU9dDtjb250aW51ZX1QLnZhbHVlPWAoJHtSfSR7dH18JHtQLnZhbHVlfSlgO04ub3V0cHV0Kz1QLnZhbHVlO2NvbnRpbnVlfWlmKEI9PT1cIntcIiYmci5ub2JyYWNlIT09dHJ1ZSl7aW5jcmVtZW50KFwiYnJhY2VzXCIpO2NvbnN0IGU9e3R5cGU6XCJicmFjZVwiLHZhbHVlOkIsb3V0cHV0OlwiKFwiLG91dHB1dEluZGV4Ok4ub3V0cHV0Lmxlbmd0aCx0b2tlbnNJbmRleDpOLnRva2Vucy5sZW5ndGh9O0kucHVzaChlKTtwdXNoKGUpO2NvbnRpbnVlfWlmKEI9PT1cIn1cIil7Y29uc3QgZT1JW0kubGVuZ3RoLTFdO2lmKHIubm9icmFjZT09PXRydWV8fCFlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OkJ9KTtjb250aW51ZX1sZXQgdD1cIilcIjtpZihlLmRvdHM9PT10cnVlKXtjb25zdCBlPUEuc2xpY2UoKTtjb25zdCBuPVtdO2ZvcihsZXQgdD1lLmxlbmd0aC0xO3Q+PTA7dC0tKXtBLnBvcCgpO2lmKGVbdF0udHlwZT09PVwiYnJhY2VcIil7YnJlYWt9aWYoZVt0XS50eXBlIT09XCJkb3RzXCIpe24udW5zaGlmdChlW3RdLnZhbHVlKX19dD1leHBhbmRSYW5nZShuLHIpO04uYmFja3RyYWNrPXRydWV9aWYoZS5jb21tYSE9PXRydWUmJmUuZG90cyE9PXRydWUpe2NvbnN0IHI9Ti5vdXRwdXQuc2xpY2UoMCxlLm91dHB1dEluZGV4KTtjb25zdCBuPU4udG9rZW5zLnNsaWNlKGUudG9rZW5zSW5kZXgpO2UudmFsdWU9ZS5vdXRwdXQ9XCJcXFxce1wiO0I9dD1cIlxcXFx9XCI7Ti5vdXRwdXQ9cjtmb3IoY29uc3QgZSBvZiBuKXtOLm91dHB1dCs9ZS5vdXRwdXR8fGUudmFsdWV9fXB1c2goe3R5cGU6XCJicmFjZVwiLHZhbHVlOkIsb3V0cHV0OnR9KTtkZWNyZW1lbnQoXCJicmFjZXNcIik7SS5wb3AoKTtjb250aW51ZX1pZihCPT09XCJ8XCIpe2lmKGsubGVuZ3RoPjApe2tbay5sZW5ndGgtMV0uY29uZGl0aW9ucysrfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT1cIixcIil7bGV0IGU9Qjtjb25zdCB0PUlbSS5sZW5ndGgtMV07aWYodCYmTVtNLmxlbmd0aC0xXT09PVwiYnJhY2VzXCIpe3QuY29tbWE9dHJ1ZTtlPVwifFwifXB1c2goe3R5cGU6XCJjb21tYVwiLHZhbHVlOkIsb3V0cHV0OmV9KTtjb250aW51ZX1pZihCPT09XCIvXCIpe2lmKFAudHlwZT09PVwiZG90XCImJk4uaW5kZXg9PT1OLnN0YXJ0KzEpe04uc3RhcnQ9Ti5pbmRleCsxO04uY29uc3VtZWQ9XCJcIjtOLm91dHB1dD1cIlwiO0EucG9wKCk7UD1mO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOkIsb3V0cHV0Onl9KTtjb250aW51ZX1pZihCPT09XCIuXCIpe2lmKE4uYnJhY2VzPjAmJlAudHlwZT09PVwiZG90XCIpe2lmKFAudmFsdWU9PT1cIi5cIilQLm91dHB1dD1FO2NvbnN0IGU9SVtJLmxlbmd0aC0xXTtQLnR5cGU9XCJkb3RzXCI7UC5vdXRwdXQrPUI7UC52YWx1ZSs9QjtlLmRvdHM9dHJ1ZTtjb250aW51ZX1pZihOLmJyYWNlcytOLnBhcmVucz09PTAmJlAudHlwZSE9PVwiYm9zXCImJlAudHlwZSE9PVwic2xhc2hcIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDpFfSk7Y29udGludWV9cHVzaCh7dHlwZTpcImRvdFwiLHZhbHVlOkIsb3V0cHV0OkV9KTtjb250aW51ZX1pZihCPT09XCI/XCIpe2NvbnN0IGU9UCYmUC52YWx1ZT09PVwiKFwiO2lmKCFlJiZyLm5vZXh0Z2xvYiE9PXRydWUmJkcoKT09PVwiKFwiJiZHKDIpIT09XCI/XCIpe2V4dGdsb2JPcGVuKFwicW1hcmtcIixCKTtjb250aW51ZX1pZihQJiZQLnR5cGU9PT1cInBhcmVuXCIpe2NvbnN0IGU9RygpO2xldCB0PUI7aWYoZT09PVwiPFwiJiYhdS5zdXBwb3J0c0xvb2tiZWhpbmRzKCkpe3Rocm93IG5ldyBFcnJvcihcIk5vZGUuanMgdjEwIG9yIGhpZ2hlciBpcyByZXF1aXJlZCBmb3IgcmVnZXggbG9va2JlaGluZHNcIil9aWYoUC52YWx1ZT09PVwiKFwiJiYhL1shPTw6XS8udGVzdChlKXx8ZT09PVwiPFwiJiYhLzwoWyE9XXxcXHcrPikvLnRlc3QocmVtYWluaW5nKCkpKXt0PWBcXFxcJHtCfWB9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDp0fSk7Y29udGludWV9aWYoci5kb3QhPT10cnVlJiYoUC50eXBlPT09XCJzbGFzaFwifHxQLnR5cGU9PT1cImJvc1wiKSl7cHVzaCh7dHlwZTpcInFtYXJrXCIsdmFsdWU6QixvdXRwdXQ6JH0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkIsb3V0cHV0OnZ9KTtjb250aW51ZX1pZihCPT09XCIhXCIpe2lmKHIubm9leHRnbG9iIT09dHJ1ZSYmRygpPT09XCIoXCIpe2lmKEcoMikhPT1cIj9cInx8IS9bIT08Ol0vLnRlc3QoRygzKSkpe2V4dGdsb2JPcGVuKFwibmVnYXRlXCIsQik7Y29udGludWV9fWlmKHIubm9uZWdhdGUhPT10cnVlJiZOLmluZGV4PT09MCl7bmVnYXRlKCk7Y29udGludWV9fWlmKEI9PT1cIitcIil7aWYoci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIiYmRygyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInBsdXNcIixCKTtjb250aW51ZX1pZihQJiZQLnZhbHVlPT09XCIoXCJ8fHIucmVnZXg9PT1mYWxzZSl7cHVzaCh7dHlwZTpcInBsdXNcIix2YWx1ZTpCLG91dHB1dDpDfSk7Y29udGludWV9aWYoUCYmKFAudHlwZT09PVwiYnJhY2tldFwifHxQLnR5cGU9PT1cInBhcmVuXCJ8fFAudHlwZT09PVwiYnJhY2VcIil8fE4ucGFyZW5zPjApe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6Qn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6Q30pO2NvbnRpbnVlfWlmKEI9PT1cIkBcIil7aWYoci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIiYmRygyKSE9PVwiP1wiKXtwdXNoKHt0eXBlOlwiYXRcIixleHRnbG9iOnRydWUsdmFsdWU6QixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEIhPT1cIipcIil7aWYoQj09PVwiJFwifHxCPT09XCJeXCIpe0I9YFxcXFwke0J9YH1jb25zdCBlPWkuZXhlYyhyZW1haW5pbmcoKSk7aWYoZSl7Qis9ZVswXTtOLmluZGV4Kz1lWzBdLmxlbmd0aH1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihQJiYoUC50eXBlPT09XCJnbG9ic3RhclwifHxQLnN0YXI9PT10cnVlKSl7UC50eXBlPVwic3RhclwiO1Auc3Rhcj10cnVlO1AudmFsdWUrPUI7UC5vdXRwdXQ9dztOLmJhY2t0cmFjaz10cnVlO04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIpO2NvbnRpbnVlfWxldCB0PXJlbWFpbmluZygpO2lmKHIubm9leHRnbG9iIT09dHJ1ZSYmL15cXChbXj9dLy50ZXN0KHQpKXtleHRnbG9iT3BlbihcInN0YXJcIixCKTtjb250aW51ZX1pZihQLnR5cGU9PT1cInN0YXJcIil7aWYoci5ub2dsb2JzdGFyPT09dHJ1ZSl7Y29uc3VtZShCKTtjb250aW51ZX1jb25zdCBuPVAucHJldjtjb25zdCB1PW4ucHJldjtjb25zdCBzPW4udHlwZT09PVwic2xhc2hcInx8bi50eXBlPT09XCJib3NcIjtjb25zdCBvPXUmJih1LnR5cGU9PT1cInN0YXJcInx8dS50eXBlPT09XCJnbG9ic3RhclwiKTtpZihyLmJhc2g9PT10cnVlJiYoIXN8fHRbMF0mJnRbMF0hPT1cIi9cIikpe3B1c2goe3R5cGU6XCJzdGFyXCIsdmFsdWU6QixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWNvbnN0IGk9Ti5icmFjZXM+MCYmKG4udHlwZT09PVwiY29tbWFcInx8bi50eXBlPT09XCJicmFjZVwiKTtjb25zdCBhPWsubGVuZ3RoJiYobi50eXBlPT09XCJwaXBlXCJ8fG4udHlwZT09PVwicGFyZW5cIik7aWYoIXMmJm4udHlwZSE9PVwicGFyZW5cIiYmIWkmJiFhKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX13aGlsZSh0LnNsaWNlKDAsMyk9PT1cIi8qKlwiKXtjb25zdCByPWVbTi5pbmRleCs0XTtpZihyJiZyIT09XCIvXCIpe2JyZWFrfXQ9dC5zbGljZSgzKTtjb25zdW1lKFwiLyoqXCIsMyl9aWYobi50eXBlPT09XCJib3NcIiYmZW9zKCkpe1AudHlwZT1cImdsb2JzdGFyXCI7UC52YWx1ZSs9QjtQLm91dHB1dD1nbG9ic3RhcihyKTtOLm91dHB1dD1QLm91dHB1dDtOLmdsb2JzdGFyPXRydWU7Y29uc3VtZShCKTtjb250aW51ZX1pZihuLnR5cGU9PT1cInNsYXNoXCImJm4ucHJldi50eXBlIT09XCJib3NcIiYmIW8mJmVvcygpKXtOLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrUC5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtQLnR5cGU9XCJnbG9ic3RhclwiO1Aub3V0cHV0PWdsb2JzdGFyKHIpKyhyLnN0cmljdFNsYXNoZXM/XCIpXCI6XCJ8JClcIik7UC52YWx1ZSs9QjtOLmdsb2JzdGFyPXRydWU7Ti5vdXRwdXQrPW4ub3V0cHV0K1Aub3V0cHV0O2NvbnN1bWUoQik7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJnRbMF09PT1cIi9cIil7Y29uc3QgZT10WzFdIT09dm9pZCAwP1wifCRcIjpcIlwiO04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLShuLm91dHB1dCtQLm91dHB1dCkubGVuZ3RoKTtuLm91dHB1dD1gKD86JHtuLm91dHB1dH1gO1AudHlwZT1cImdsb2JzdGFyXCI7UC5vdXRwdXQ9YCR7Z2xvYnN0YXIocil9JHt5fXwke3l9JHtlfSlgO1AudmFsdWUrPUI7Ti5vdXRwdXQrPW4ub3V0cHV0K1Aub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIrRCgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWlmKG4udHlwZT09PVwiYm9zXCImJnRbMF09PT1cIi9cIil7UC50eXBlPVwiZ2xvYnN0YXJcIjtQLnZhbHVlKz1CO1Aub3V0cHV0PWAoPzpefCR7eX18JHtnbG9ic3RhcihyKX0ke3l9KWA7Ti5vdXRwdXQ9UC5vdXRwdXQ7Ti5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoQitEKCkpO3B1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOlwiL1wiLG91dHB1dDpcIlwifSk7Y29udGludWV9Ti5vdXRwdXQ9Ti5vdXRwdXQuc2xpY2UoMCwtUC5vdXRwdXQubGVuZ3RoKTtQLnR5cGU9XCJnbG9ic3RhclwiO1Aub3V0cHV0PWdsb2JzdGFyKHIpO1AudmFsdWUrPUI7Ti5vdXRwdXQrPVAub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIpO2NvbnRpbnVlfWNvbnN0IG49e3R5cGU6XCJzdGFyXCIsdmFsdWU6QixvdXRwdXQ6d307aWYoci5iYXNoPT09dHJ1ZSl7bi5vdXRwdXQ9XCIuKj9cIjtpZihQLnR5cGU9PT1cImJvc1wifHxQLnR5cGU9PT1cInNsYXNoXCIpe24ub3V0cHV0PUwrbi5vdXRwdXR9cHVzaChuKTtjb250aW51ZX1pZihQJiYoUC50eXBlPT09XCJicmFja2V0XCJ8fFAudHlwZT09PVwicGFyZW5cIikmJnIucmVnZXg9PT10cnVlKXtuLm91dHB1dD1CO3B1c2gobik7Y29udGludWV9aWYoTi5pbmRleD09PU4uc3RhcnR8fFAudHlwZT09PVwic2xhc2hcInx8UC50eXBlPT09XCJkb3RcIil7aWYoUC50eXBlPT09XCJkb3RcIil7Ti5vdXRwdXQrPVM7UC5vdXRwdXQrPVN9ZWxzZSBpZihyLmRvdD09PXRydWUpe04ub3V0cHV0Kz1IO1Aub3V0cHV0Kz1IfWVsc2V7Ti5vdXRwdXQrPUw7UC5vdXRwdXQrPUx9aWYoRygpIT09XCIqXCIpe04ub3V0cHV0Kz1kO1Aub3V0cHV0Kz1kfX1wdXNoKG4pfXdoaWxlKE4uYnJhY2tldHM+MCl7aWYoci5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiXVwiKSk7Ti5vdXRwdXQ9dS5lc2NhcGVMYXN0KE4ub3V0cHV0LFwiW1wiKTtkZWNyZW1lbnQoXCJicmFja2V0c1wiKX13aGlsZShOLnBhcmVucz4wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCIpXCIpKTtOLm91dHB1dD11LmVzY2FwZUxhc3QoTi5vdXRwdXQsXCIoXCIpO2RlY3JlbWVudChcInBhcmVuc1wiKX13aGlsZShOLmJyYWNlcz4wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJ9XCIpKTtOLm91dHB1dD11LmVzY2FwZUxhc3QoTi5vdXRwdXQsXCJ7XCIpO2RlY3JlbWVudChcImJyYWNlc1wiKX1pZihyLnN0cmljdFNsYXNoZXMhPT10cnVlJiYoUC50eXBlPT09XCJzdGFyXCJ8fFAudHlwZT09PVwiYnJhY2tldFwiKSl7cHVzaCh7dHlwZTpcIm1heWJlX3NsYXNoXCIsdmFsdWU6XCJcIixvdXRwdXQ6YCR7eX0/YH0pfWlmKE4uYmFja3RyYWNrPT09dHJ1ZSl7Ti5vdXRwdXQ9XCJcIjtmb3IoY29uc3QgZSBvZiBOLnRva2Vucyl7Ti5vdXRwdXQrPWUub3V0cHV0IT1udWxsP2Uub3V0cHV0OmUudmFsdWU7aWYoZS5zdWZmaXgpe04ub3V0cHV0Kz1lLnN1ZmZpeH19fXJldHVybiBOfTtwYXJzZS5mYXN0cGF0aHM9KGUsdCk9Pntjb25zdCByPXsuLi50fTtjb25zdCBvPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4ocyxyLm1heExlbmd0aCk6cztjb25zdCBpPWUubGVuZ3RoO2lmKGk+byl7dGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7aX0sIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIGxlbmd0aDogJHtvfWApfWU9bFtlXXx8ZTtjb25zdCBhPXUuaXNXaW5kb3dzKHQpO2NvbnN0e0RPVF9MSVRFUkFMOmMsU0xBU0hfTElURVJBTDpwLE9ORV9DSEFSOmYsRE9UU19TTEFTSDpBLE5PX0RPVDpSLE5PX0RPVFM6XyxOT19ET1RTX1NMQVNIOmgsU1RBUjpnLFNUQVJUX0FOQ0hPUjpFfT1uLmdsb2JDaGFycyhhKTtjb25zdCBDPXIuZG90P186Ujtjb25zdCB5PXIuZG90P2g6Ujtjb25zdCBkPXIuY2FwdHVyZT9cIlwiOlwiPzpcIjtjb25zdCB4PXtuZWdhdGVkOmZhbHNlLHByZWZpeDpcIlwifTtsZXQgYj1yLmJhc2g9PT10cnVlP1wiLio/XCI6ZztpZihyLmNhcHR1cmUpe2I9YCgke2J9KWB9Y29uc3QgZ2xvYnN0YXI9ZT0+e2lmKGUubm9nbG9ic3Rhcj09PXRydWUpcmV0dXJuIGI7cmV0dXJuYCgke2R9KD86KD8hJHtFfSR7ZS5kb3Q/QTpjfSkuKSo/KWB9O2NvbnN0IGNyZWF0ZT1lPT57c3dpdGNoKGUpe2Nhc2VcIipcIjpyZXR1cm5gJHtDfSR7Zn0ke2J9YDtjYXNlXCIuKlwiOnJldHVybmAke2N9JHtmfSR7Yn1gO2Nhc2VcIiouKlwiOnJldHVybmAke0N9JHtifSR7Y30ke2Z9JHtifWA7Y2FzZVwiKi8qXCI6cmV0dXJuYCR7Q30ke2J9JHtwfSR7Zn0ke3l9JHtifWA7Y2FzZVwiKipcIjpyZXR1cm4gQytnbG9ic3RhcihyKTtjYXNlXCIqKi8qXCI6cmV0dXJuYCg/OiR7Q30ke2dsb2JzdGFyKHIpfSR7cH0pPyR7eX0ke2Z9JHtifWA7Y2FzZVwiKiovKi4qXCI6cmV0dXJuYCg/OiR7Q30ke2dsb2JzdGFyKHIpfSR7cH0pPyR7eX0ke2J9JHtjfSR7Zn0ke2J9YDtjYXNlXCIqKi8uKlwiOnJldHVybmAoPzoke0N9JHtnbG9ic3RhcihyKX0ke3B9KT8ke2N9JHtmfSR7Yn1gO2RlZmF1bHQ6e2NvbnN0IHQ9L14oLio/KVxcLihcXHcrKSQvLmV4ZWMoZSk7aWYoIXQpcmV0dXJuO2NvbnN0IHI9Y3JlYXRlKHRbMV0pO2lmKCFyKXJldHVybjtyZXR1cm4gcitjK3RbMl19fX07Y29uc3QgUz11LnJlbW92ZVByZWZpeChlLHgpO2xldCBIPWNyZWF0ZShTKTtpZihIJiZyLnN0cmljdFNsYXNoZXMhPT10cnVlKXtIKz1gJHtwfT9gfXJldHVybiBIfTtlLmV4cG9ydHM9cGFyc2V9LDY4MzooZSx0LHIpPT57Y29uc3Qgbj1yKDE3KTtjb25zdCB1PXIoNzAwKTtjb25zdCBzPXIoNzU0KTtjb25zdCBvPXIoNTEzKTtjb25zdCBpPXIoMzU2KTtjb25zdCBpc09iamVjdD1lPT5lJiZ0eXBlb2YgZT09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KGUpO2NvbnN0IHBpY29tYXRjaD0oZSx0LHI9ZmFsc2UpPT57aWYoQXJyYXkuaXNBcnJheShlKSl7Y29uc3Qgbj1lLm1hcCgoZT0+cGljb21hdGNoKGUsdCxyKSkpO2NvbnN0IGFycmF5TWF0Y2hlcj1lPT57Zm9yKGNvbnN0IHQgb2Ygbil7Y29uc3Qgcj10KGUpO2lmKHIpcmV0dXJuIHJ9cmV0dXJuIGZhbHNlfTtyZXR1cm4gYXJyYXlNYXRjaGVyfWNvbnN0IG49aXNPYmplY3QoZSkmJmUudG9rZW5zJiZlLmlucHV0O2lmKGU9PT1cIlwifHx0eXBlb2YgZSE9PVwic3RyaW5nXCImJiFuKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9Y29uc3QgdT10fHx7fTtjb25zdCBzPW8uaXNXaW5kb3dzKHQpO2NvbnN0IGk9bj9waWNvbWF0Y2guY29tcGlsZVJlKGUsdCk6cGljb21hdGNoLm1ha2VSZShlLHQsZmFsc2UsdHJ1ZSk7Y29uc3QgYT1pLnN0YXRlO2RlbGV0ZSBpLnN0YXRlO2xldCBpc0lnbm9yZWQ9KCk9PmZhbHNlO2lmKHUuaWdub3JlKXtjb25zdCBlPXsuLi50LGlnbm9yZTpudWxsLG9uTWF0Y2g6bnVsbCxvblJlc3VsdDpudWxsfTtpc0lnbm9yZWQ9cGljb21hdGNoKHUuaWdub3JlLGUscil9Y29uc3QgbWF0Y2hlcj0ocixuPWZhbHNlKT0+e2NvbnN0e2lzTWF0Y2g6byxtYXRjaDpsLG91dHB1dDpjfT1waWNvbWF0Y2gudGVzdChyLGksdCx7Z2xvYjplLHBvc2l4OnN9KTtjb25zdCBwPXtnbG9iOmUsc3RhdGU6YSxyZWdleDppLHBvc2l4OnMsaW5wdXQ6cixvdXRwdXQ6YyxtYXRjaDpsLGlzTWF0Y2g6b307aWYodHlwZW9mIHUub25SZXN1bHQ9PT1cImZ1bmN0aW9uXCIpe3Uub25SZXN1bHQocCl9aWYobz09PWZhbHNlKXtwLmlzTWF0Y2g9ZmFsc2U7cmV0dXJuIG4/cDpmYWxzZX1pZihpc0lnbm9yZWQocikpe2lmKHR5cGVvZiB1Lm9uSWdub3JlPT09XCJmdW5jdGlvblwiKXt1Lm9uSWdub3JlKHApfXAuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9wOmZhbHNlfWlmKHR5cGVvZiB1Lm9uTWF0Y2g9PT1cImZ1bmN0aW9uXCIpe3Uub25NYXRjaChwKX1yZXR1cm4gbj9wOnRydWV9O2lmKHIpe21hdGNoZXIuc3RhdGU9YX1yZXR1cm4gbWF0Y2hlcn07cGljb21hdGNoLnRlc3Q9KGUsdCxyLHtnbG9iOm4scG9zaXg6dX09e30pPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgaW5wdXQgdG8gYmUgYSBzdHJpbmdcIil9aWYoZT09PVwiXCIpe3JldHVybntpc01hdGNoOmZhbHNlLG91dHB1dDpcIlwifX1jb25zdCBzPXJ8fHt9O2NvbnN0IGk9cy5mb3JtYXR8fCh1P28udG9Qb3NpeFNsYXNoZXM6bnVsbCk7bGV0IGE9ZT09PW47bGV0IGw9YSYmaT9pKGUpOmU7aWYoYT09PWZhbHNlKXtsPWk/aShlKTplO2E9bD09PW59aWYoYT09PWZhbHNlfHxzLmNhcHR1cmU9PT10cnVlKXtpZihzLm1hdGNoQmFzZT09PXRydWV8fHMuYmFzZW5hbWU9PT10cnVlKXthPXBpY29tYXRjaC5tYXRjaEJhc2UoZSx0LHIsdSl9ZWxzZXthPXQuZXhlYyhsKX19cmV0dXJue2lzTWF0Y2g6Qm9vbGVhbihhKSxtYXRjaDphLG91dHB1dDpsfX07cGljb21hdGNoLm1hdGNoQmFzZT0oZSx0LHIsdT1vLmlzV2luZG93cyhyKSk9Pntjb25zdCBzPXQgaW5zdGFuY2VvZiBSZWdFeHA/dDpwaWNvbWF0Y2gubWFrZVJlKHQscik7cmV0dXJuIHMudGVzdChuLmJhc2VuYW1lKGUpKX07cGljb21hdGNoLmlzTWF0Y2g9KGUsdCxyKT0+cGljb21hdGNoKHQscikoZSk7cGljb21hdGNoLnBhcnNlPShlLHQpPT57aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZS5tYXAoKGU9PnBpY29tYXRjaC5wYXJzZShlLHQpKSk7cmV0dXJuIHMoZSx7Li4udCxmYXN0cGF0aHM6ZmFsc2V9KX07cGljb21hdGNoLnNjYW49KGUsdCk9PnUoZSx0KTtwaWNvbWF0Y2guY29tcGlsZVJlPShlLHQscj1mYWxzZSxuPWZhbHNlKT0+e2lmKHI9PT10cnVlKXtyZXR1cm4gZS5vdXRwdXR9Y29uc3QgdT10fHx7fTtjb25zdCBzPXUuY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCBvPXUuY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgaT1gJHtzfSg/OiR7ZS5vdXRwdXR9KSR7b31gO2lmKGUmJmUubmVnYXRlZD09PXRydWUpe2k9YF4oPyEke2l9KS4qJGB9Y29uc3QgYT1waWNvbWF0Y2gudG9SZWdleChpLHQpO2lmKG49PT10cnVlKXthLnN0YXRlPWV9cmV0dXJuIGF9O3BpY29tYXRjaC5tYWtlUmU9KGUsdCxyPWZhbHNlLG49ZmFsc2UpPT57aWYoIWV8fHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1jb25zdCB1PXR8fHt9O2xldCBvPXtuZWdhdGVkOmZhbHNlLGZhc3RwYXRoczp0cnVlfTtsZXQgaT1cIlwiO2xldCBhO2lmKGUuc3RhcnRzV2l0aChcIi4vXCIpKXtlPWUuc2xpY2UoMik7aT1vLnByZWZpeD1cIi4vXCJ9aWYodS5mYXN0cGF0aHMhPT1mYWxzZSYmKGVbMF09PT1cIi5cInx8ZVswXT09PVwiKlwiKSl7YT1zLmZhc3RwYXRocyhlLHQpfWlmKGE9PT11bmRlZmluZWQpe289cyhlLHQpO28ucHJlZml4PWkrKG8ucHJlZml4fHxcIlwiKX1lbHNle28ub3V0cHV0PWF9cmV0dXJuIHBpY29tYXRjaC5jb21waWxlUmUobyx0LHIsbil9O3BpY29tYXRjaC50b1JlZ2V4PShlLHQpPT57dHJ5e2NvbnN0IHI9dHx8e307cmV0dXJuIG5ldyBSZWdFeHAoZSxyLmZsYWdzfHwoci5ub2Nhc2U/XCJpXCI6XCJcIikpfWNhdGNoKGUpe2lmKHQmJnQuZGVidWc9PT10cnVlKXRocm93IGU7cmV0dXJuLyReL319O3BpY29tYXRjaC5jb25zdGFudHM9aTtlLmV4cG9ydHM9cGljb21hdGNofSw3MDA6KGUsdCxyKT0+e2NvbnN0IG49cig1MTMpO2NvbnN0e0NIQVJfQVNURVJJU0s6dSxDSEFSX0FUOnMsQ0hBUl9CQUNLV0FSRF9TTEFTSDpvLENIQVJfQ09NTUE6aSxDSEFSX0RPVDphLENIQVJfRVhDTEFNQVRJT05fTUFSSzpsLENIQVJfRk9SV0FSRF9TTEFTSDpjLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpwLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUExVUzpSLENIQVJfUVVFU1RJT05fTUFSSzpfLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6aCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmcsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpFfT1yKDM1Nik7Y29uc3QgaXNQYXRoU2VwYXJhdG9yPWU9PmU9PT1jfHxlPT09bztjb25zdCBkZXB0aD1lPT57aWYoZS5pc1ByZWZpeCE9PXRydWUpe2UuZGVwdGg9ZS5pc0dsb2JzdGFyP0luZmluaXR5OjF9fTtjb25zdCBzY2FuPShlLHQpPT57Y29uc3Qgcj10fHx7fTtjb25zdCBDPWUubGVuZ3RoLTE7Y29uc3QgeT1yLnBhcnRzPT09dHJ1ZXx8ci5zY2FuVG9FbmQ9PT10cnVlO2NvbnN0IGQ9W107Y29uc3QgeD1bXTtjb25zdCBiPVtdO2xldCBTPWU7bGV0IEg9LTE7bGV0IHY9MDtsZXQgJD0wO2xldCBtPWZhbHNlO2xldCBUPWZhbHNlO2xldCBMPWZhbHNlO2xldCBPPWZhbHNlO2xldCB3PWZhbHNlO2xldCBOPWZhbHNlO2xldCBrPWZhbHNlO2xldCBJPWZhbHNlO2xldCBNPWZhbHNlO2xldCBQPTA7bGV0IEI7bGV0IEc7bGV0IEQ9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2NvbnN0IGVvcz0oKT0+SD49Qztjb25zdCBwZWVrPSgpPT5TLmNoYXJDb2RlQXQoSCsxKTtjb25zdCBhZHZhbmNlPSgpPT57Qj1HO3JldHVybiBTLmNoYXJDb2RlQXQoKytIKX07d2hpbGUoSDxDKXtHPWFkdmFuY2UoKTtsZXQgZTtpZihHPT09byl7az1ELmJhY2tzbGFzaGVzPXRydWU7Rz1hZHZhbmNlKCk7aWYoRz09PXApe049dHJ1ZX1jb250aW51ZX1pZihOPT09dHJ1ZXx8Rz09PXApe1ArKzt3aGlsZShlb3MoKSE9PXRydWUmJihHPWFkdmFuY2UoKSkpe2lmKEc9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoRz09PXApe1ArKztjb250aW51ZX1pZihOIT09dHJ1ZSYmRz09PWEmJihHPWFkdmFuY2UoKSk9PT1hKXttPUQuaXNCcmFjZT10cnVlO0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKE4hPT10cnVlJiZHPT09aSl7bT1ELmlzQnJhY2U9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2lmKHk9PT10cnVlKXtjb250aW51ZX1icmVha31pZihHPT09aCl7UC0tO2lmKFA9PT0wKXtOPWZhbHNlO209RC5pc0JyYWNlPXRydWU7TT10cnVlO2JyZWFrfX19aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1jKXtkLnB1c2goSCk7eC5wdXNoKEQpO0Q9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2lmKE09PT10cnVlKWNvbnRpbnVlO2lmKEI9PT1hJiZIPT09disxKXt2Kz0yO2NvbnRpbnVlfSQ9SCsxO2NvbnRpbnVlfWlmKHIubm9leHQhPT10cnVlKXtjb25zdCBlPUc9PT1SfHxHPT09c3x8Rz09PXV8fEc9PT1ffHxHPT09bDtpZihlPT09dHJ1ZSYmcGVlaygpPT09Zil7TD1ELmlzR2xvYj10cnVlO089RC5pc0V4dGdsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKEc9YWR2YW5jZSgpKSl7aWYoRz09PW8pe2s9RC5iYWNrc2xhc2hlcz10cnVlO0c9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKEc9PT1nKXtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha319aWYoRz09PXUpe2lmKEI9PT11KXc9RC5pc0dsb2JzdGFyPXRydWU7TD1ELmlzR2xvYj10cnVlO009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoRz09PV8pe0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1BKXt3aGlsZShlb3MoKSE9PXRydWUmJihlPWFkdmFuY2UoKSkpe2lmKGU9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoZT09PUUpe1Q9RC5pc0JyYWNrZXQ9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2JyZWFrfX1pZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoci5ub25lZ2F0ZSE9PXRydWUmJkc9PT1sJiZIPT09dil7ST1ELm5lZ2F0ZWQ9dHJ1ZTt2Kys7Y29udGludWV9aWYoci5ub3BhcmVuIT09dHJ1ZSYmRz09PWYpe0w9RC5pc0dsb2I9dHJ1ZTtpZih5PT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoRz1hZHZhbmNlKCkpKXtpZihHPT09Zil7az1ELmJhY2tzbGFzaGVzPXRydWU7Rz1hZHZhbmNlKCk7Y29udGludWV9aWYoRz09PWcpe009dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9aWYoTD09PXRydWUpe009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9fWlmKHIubm9leHQ9PT10cnVlKXtPPWZhbHNlO0w9ZmFsc2V9bGV0IFU9UztsZXQgSz1cIlwiO2xldCBGPVwiXCI7aWYodj4wKXtLPVMuc2xpY2UoMCx2KTtTPVMuc2xpY2Uodik7JC09dn1pZihVJiZMPT09dHJ1ZSYmJD4wKXtVPVMuc2xpY2UoMCwkKTtGPVMuc2xpY2UoJCl9ZWxzZSBpZihMPT09dHJ1ZSl7VT1cIlwiO0Y9U31lbHNle1U9U31pZihVJiZVIT09XCJcIiYmVSE9PVwiL1wiJiZVIT09Uyl7aWYoaXNQYXRoU2VwYXJhdG9yKFUuY2hhckNvZGVBdChVLmxlbmd0aC0xKSkpe1U9VS5zbGljZSgwLC0xKX19aWYoci51bmVzY2FwZT09PXRydWUpe2lmKEYpRj1uLnJlbW92ZUJhY2tzbGFzaGVzKEYpO2lmKFUmJms9PT10cnVlKXtVPW4ucmVtb3ZlQmFja3NsYXNoZXMoVSl9fWNvbnN0IFE9e3ByZWZpeDpLLGlucHV0OmUsc3RhcnQ6dixiYXNlOlUsZ2xvYjpGLGlzQnJhY2U6bSxpc0JyYWNrZXQ6VCxpc0dsb2I6TCxpc0V4dGdsb2I6Tyxpc0dsb2JzdGFyOncsbmVnYXRlZDpJfTtpZihyLnRva2Vucz09PXRydWUpe1EubWF4RGVwdGg9MDtpZighaXNQYXRoU2VwYXJhdG9yKEcpKXt4LnB1c2goRCl9US50b2tlbnM9eH1pZihyLnBhcnRzPT09dHJ1ZXx8ci50b2tlbnM9PT10cnVlKXtsZXQgdDtmb3IobGV0IG49MDtuPGQubGVuZ3RoO24rKyl7Y29uc3QgdT10P3QrMTp2O2NvbnN0IHM9ZFtuXTtjb25zdCBvPWUuc2xpY2UodSxzKTtpZihyLnRva2Vucyl7aWYobj09PTAmJnYhPT0wKXt4W25dLmlzUHJlZml4PXRydWU7eFtuXS52YWx1ZT1LfWVsc2V7eFtuXS52YWx1ZT1vfWRlcHRoKHhbbl0pO1EubWF4RGVwdGgrPXhbbl0uZGVwdGh9aWYobiE9PTB8fG8hPT1cIlwiKXtiLnB1c2gobyl9dD1zfWlmKHQmJnQrMTxlLmxlbmd0aCl7Y29uc3Qgbj1lLnNsaWNlKHQrMSk7Yi5wdXNoKG4pO2lmKHIudG9rZW5zKXt4W3gubGVuZ3RoLTFdLnZhbHVlPW47ZGVwdGgoeFt4Lmxlbmd0aC0xXSk7US5tYXhEZXB0aCs9eFt4Lmxlbmd0aC0xXS5kZXB0aH19US5zbGFzaGVzPWQ7US5wYXJ0cz1ifXJldHVybiBRfTtlLmV4cG9ydHM9c2Nhbn0sNTEzOihlLHQscik9Pntjb25zdCBuPXIoMTcpO2NvbnN0IHU9cHJvY2Vzcy5wbGF0Zm9ybT09PVwid2luMzJcIjtjb25zdHtSRUdFWF9CQUNLU0xBU0g6cyxSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOm8sUkVHRVhfU1BFQ0lBTF9DSEFSUzppLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOmF9PXIoMzU2KTt0LmlzT2JqZWN0PWU9PmUhPT1udWxsJiZ0eXBlb2YgZT09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KGUpO3QuaGFzUmVnZXhDaGFycz1lPT5pLnRlc3QoZSk7dC5pc1JlZ2V4Q2hhcj1lPT5lLmxlbmd0aD09PTEmJnQuaGFzUmVnZXhDaGFycyhlKTt0LmVzY2FwZVJlZ2V4PWU9PmUucmVwbGFjZShhLFwiXFxcXCQxXCIpO3QudG9Qb3NpeFNsYXNoZXM9ZT0+ZS5yZXBsYWNlKHMsXCIvXCIpO3QucmVtb3ZlQmFja3NsYXNoZXM9ZT0+ZS5yZXBsYWNlKG8sKGU9PmU9PT1cIlxcXFxcIj9cIlwiOmUpKTt0LnN1cHBvcnRzTG9va2JlaGluZHM9KCk9Pntjb25zdCBlPXByb2Nlc3MudmVyc2lvbi5zbGljZSgxKS5zcGxpdChcIi5cIikubWFwKE51bWJlcik7aWYoZS5sZW5ndGg9PT0zJiZlWzBdPj05fHxlWzBdPT09OCYmZVsxXT49MTApe3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dC5pc1dpbmRvd3M9ZT0+e2lmKGUmJnR5cGVvZiBlLndpbmRvd3M9PT1cImJvb2xlYW5cIil7cmV0dXJuIGUud2luZG93c31yZXR1cm4gdT09PXRydWV8fG4uc2VwPT09XCJcXFxcXCJ9O3QuZXNjYXBlTGFzdD0oZSxyLG4pPT57Y29uc3QgdT1lLmxhc3RJbmRleE9mKHIsbik7aWYodT09PS0xKXJldHVybiBlO2lmKGVbdS0xXT09PVwiXFxcXFwiKXJldHVybiB0LmVzY2FwZUxhc3QoZSxyLHUtMSk7cmV0dXJuYCR7ZS5zbGljZSgwLHUpfVxcXFwke2Uuc2xpY2UodSl9YH07dC5yZW1vdmVQcmVmaXg9KGUsdD17fSk9PntsZXQgcj1lO2lmKHIuc3RhcnRzV2l0aChcIi4vXCIpKXtyPXIuc2xpY2UoMik7dC5wcmVmaXg9XCIuL1wifXJldHVybiByfTt0LndyYXBPdXRwdXQ9KGUsdD17fSxyPXt9KT0+e2NvbnN0IG49ci5jb250YWlucz9cIlwiOlwiXlwiO2NvbnN0IHU9ci5jb250YWlucz9cIlwiOlwiJFwiO2xldCBzPWAke259KD86JHtlfSkke3V9YDtpZih0Lm5lZ2F0ZWQ9PT10cnVlKXtzPWAoPzpeKD8hJHtzfSkuKiQpYH1yZXR1cm4gc319LDQ5MjooZSx0LHIpPT57XG4vKiFcbiAqIHRvLXJlZ2V4LXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vbWljcm9tYXRjaC90by1yZWdleC1yYW5nZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmNvbnN0IG49cigzNTcpO2NvbnN0IHRvUmVnZXhSYW5nZT0oZSx0LHIpPT57aWYobihlKT09PWZhbHNlKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9SZWdleFJhbmdlOiBleHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYSBudW1iZXJcIil9aWYodD09PXZvaWQgMHx8ZT09PXQpe3JldHVybiBTdHJpbmcoZSl9aWYobih0KT09PWZhbHNlKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9SZWdleFJhbmdlOiBleHBlY3RlZCB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgbnVtYmVyLlwiKX1sZXQgdT17cmVsYXhaZXJvczp0cnVlLC4uLnJ9O2lmKHR5cGVvZiB1LnN0cmljdFplcm9zPT09XCJib29sZWFuXCIpe3UucmVsYXhaZXJvcz11LnN0cmljdFplcm9zPT09ZmFsc2V9bGV0IHM9U3RyaW5nKHUucmVsYXhaZXJvcyk7bGV0IG89U3RyaW5nKHUuc2hvcnRoYW5kKTtsZXQgaT1TdHJpbmcodS5jYXB0dXJlKTtsZXQgYT1TdHJpbmcodS53cmFwKTtsZXQgbD1lK1wiOlwiK3QrXCI9XCIrcytvK2krYTtpZih0b1JlZ2V4UmFuZ2UuY2FjaGUuaGFzT3duUHJvcGVydHkobCkpe3JldHVybiB0b1JlZ2V4UmFuZ2UuY2FjaGVbbF0ucmVzdWx0fWxldCBjPU1hdGgubWluKGUsdCk7bGV0IHA9TWF0aC5tYXgoZSx0KTtpZihNYXRoLmFicyhjLXApPT09MSl7bGV0IHI9ZStcInxcIit0O2lmKHUuY2FwdHVyZSl7cmV0dXJuYCgke3J9KWB9aWYodS53cmFwPT09ZmFsc2Upe3JldHVybiByfXJldHVybmAoPzoke3J9KWB9bGV0IGY9aGFzUGFkZGluZyhlKXx8aGFzUGFkZGluZyh0KTtsZXQgQT17bWluOmUsbWF4OnQsYTpjLGI6cH07bGV0IFI9W107bGV0IF89W107aWYoZil7QS5pc1BhZGRlZD1mO0EubWF4TGVuPVN0cmluZyhBLm1heCkubGVuZ3RofWlmKGM8MCl7bGV0IGU9cDwwP01hdGguYWJzKHApOjE7Xz1zcGxpdFRvUGF0dGVybnMoZSxNYXRoLmFicyhjKSxBLHUpO2M9QS5hPTB9aWYocD49MCl7Uj1zcGxpdFRvUGF0dGVybnMoYyxwLEEsdSl9QS5uZWdhdGl2ZXM9XztBLnBvc2l0aXZlcz1SO0EucmVzdWx0PWNvbGxhdGVQYXR0ZXJucyhfLFIsdSk7aWYodS5jYXB0dXJlPT09dHJ1ZSl7QS5yZXN1bHQ9YCgke0EucmVzdWx0fSlgfWVsc2UgaWYodS53cmFwIT09ZmFsc2UmJlIubGVuZ3RoK18ubGVuZ3RoPjEpe0EucmVzdWx0PWAoPzoke0EucmVzdWx0fSlgfXRvUmVnZXhSYW5nZS5jYWNoZVtsXT1BO3JldHVybiBBLnJlc3VsdH07ZnVuY3Rpb24gY29sbGF0ZVBhdHRlcm5zKGUsdCxyKXtsZXQgbj1maWx0ZXJQYXR0ZXJucyhlLHQsXCItXCIsZmFsc2Uscil8fFtdO2xldCB1PWZpbHRlclBhdHRlcm5zKHQsZSxcIlwiLGZhbHNlLHIpfHxbXTtsZXQgcz1maWx0ZXJQYXR0ZXJucyhlLHQsXCItP1wiLHRydWUscil8fFtdO2xldCBvPW4uY29uY2F0KHMpLmNvbmNhdCh1KTtyZXR1cm4gby5qb2luKFwifFwiKX1mdW5jdGlvbiBzcGxpdFRvUmFuZ2VzKGUsdCl7bGV0IHI9MTtsZXQgbj0xO2xldCB1PWNvdW50TmluZXMoZSxyKTtsZXQgcz1uZXcgU2V0KFt0XSk7d2hpbGUoZTw9dSYmdTw9dCl7cy5hZGQodSk7cis9MTt1PWNvdW50TmluZXMoZSxyKX11PWNvdW50WmVyb3ModCsxLG4pLTE7d2hpbGUoZTx1JiZ1PD10KXtzLmFkZCh1KTtuKz0xO3U9Y291bnRaZXJvcyh0KzEsbiktMX1zPVsuLi5zXTtzLnNvcnQoY29tcGFyZSk7cmV0dXJuIHN9ZnVuY3Rpb24gcmFuZ2VUb1BhdHRlcm4oZSx0LHIpe2lmKGU9PT10KXtyZXR1cm57cGF0dGVybjplLGNvdW50OltdLGRpZ2l0czowfX1sZXQgbj16aXAoZSx0KTtsZXQgdT1uLmxlbmd0aDtsZXQgcz1cIlwiO2xldCBvPTA7Zm9yKGxldCBlPTA7ZTx1O2UrKyl7bGV0W3QsdV09bltlXTtpZih0PT09dSl7cys9dH1lbHNlIGlmKHQhPT1cIjBcInx8dSE9PVwiOVwiKXtzKz10b0NoYXJhY3RlckNsYXNzKHQsdSxyKX1lbHNle28rK319aWYobyl7cys9ci5zaG9ydGhhbmQ9PT10cnVlP1wiXFxcXGRcIjpcIlswLTldXCJ9cmV0dXJue3BhdHRlcm46cyxjb3VudDpbb10sZGlnaXRzOnV9fWZ1bmN0aW9uIHNwbGl0VG9QYXR0ZXJucyhlLHQscixuKXtsZXQgdT1zcGxpdFRvUmFuZ2VzKGUsdCk7bGV0IHM9W107bGV0IG89ZTtsZXQgaTtmb3IobGV0IGU9MDtlPHUubGVuZ3RoO2UrKyl7bGV0IHQ9dVtlXTtsZXQgYT1yYW5nZVRvUGF0dGVybihTdHJpbmcobyksU3RyaW5nKHQpLG4pO2xldCBsPVwiXCI7aWYoIXIuaXNQYWRkZWQmJmkmJmkucGF0dGVybj09PWEucGF0dGVybil7aWYoaS5jb3VudC5sZW5ndGg+MSl7aS5jb3VudC5wb3AoKX1pLmNvdW50LnB1c2goYS5jb3VudFswXSk7aS5zdHJpbmc9aS5wYXR0ZXJuK3RvUXVhbnRpZmllcihpLmNvdW50KTtvPXQrMTtjb250aW51ZX1pZihyLmlzUGFkZGVkKXtsPXBhZFplcm9zKHQscixuKX1hLnN0cmluZz1sK2EucGF0dGVybit0b1F1YW50aWZpZXIoYS5jb3VudCk7cy5wdXNoKGEpO289dCsxO2k9YX1yZXR1cm4gc31mdW5jdGlvbiBmaWx0ZXJQYXR0ZXJucyhlLHQscixuLHUpe2xldCBzPVtdO2ZvcihsZXQgdSBvZiBlKXtsZXR7c3RyaW5nOmV9PXU7aWYoIW4mJiFjb250YWlucyh0LFwic3RyaW5nXCIsZSkpe3MucHVzaChyK2UpfWlmKG4mJmNvbnRhaW5zKHQsXCJzdHJpbmdcIixlKSl7cy5wdXNoKHIrZSl9fXJldHVybiBzfWZ1bmN0aW9uIHppcChlLHQpe2xldCByPVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXIucHVzaChbZVtuXSx0W25dXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gY29tcGFyZShlLHQpe3JldHVybiBlPnQ/MTp0PmU/LTE6MH1mdW5jdGlvbiBjb250YWlucyhlLHQscil7cmV0dXJuIGUuc29tZSgoZT0+ZVt0XT09PXIpKX1mdW5jdGlvbiBjb3VudE5pbmVzKGUsdCl7cmV0dXJuIE51bWJlcihTdHJpbmcoZSkuc2xpY2UoMCwtdCkrXCI5XCIucmVwZWF0KHQpKX1mdW5jdGlvbiBjb3VudFplcm9zKGUsdCl7cmV0dXJuIGUtZSVNYXRoLnBvdygxMCx0KX1mdW5jdGlvbiB0b1F1YW50aWZpZXIoZSl7bGV0W3Q9MCxyPVwiXCJdPWU7aWYocnx8dD4xKXtyZXR1cm5geyR7dCsocj9cIixcIityOlwiXCIpfX1gfXJldHVyblwiXCJ9ZnVuY3Rpb24gdG9DaGFyYWN0ZXJDbGFzcyhlLHQscil7cmV0dXJuYFske2V9JHt0LWU9PT0xP1wiXCI6XCItXCJ9JHt0fV1gfWZ1bmN0aW9uIGhhc1BhZGRpbmcoZSl7cmV0dXJuL14tPygwKylcXGQvLnRlc3QoZSl9ZnVuY3Rpb24gcGFkWmVyb3MoZSx0LHIpe2lmKCF0LmlzUGFkZGVkKXtyZXR1cm4gZX1sZXQgbj1NYXRoLmFicyh0Lm1heExlbi1TdHJpbmcoZSkubGVuZ3RoKTtsZXQgdT1yLnJlbGF4WmVyb3MhPT1mYWxzZTtzd2l0Y2gobil7Y2FzZSAwOnJldHVyblwiXCI7Y2FzZSAxOnJldHVybiB1P1wiMD9cIjpcIjBcIjtjYXNlIDI6cmV0dXJuIHU/XCIwezAsMn1cIjpcIjAwXCI7ZGVmYXVsdDp7cmV0dXJuIHU/YDB7MCwke259fWA6YDB7JHtufX1gfX19dG9SZWdleFJhbmdlLmNhY2hlPXt9O3RvUmVnZXhSYW5nZS5jbGVhckNhY2hlPSgpPT50b1JlZ2V4UmFuZ2UuY2FjaGU9e307ZS5leHBvcnRzPXRvUmVnZXhSYW5nZX0sMTc6ZT0+e2UuZXhwb3J0cz1yZXF1aXJlKFwicGF0aFwiKX0sODM3OmU9PntlLmV4cG9ydHM9cmVxdWlyZShcInV0aWxcIil9fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgdT10W3JdPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXtlW3JdKHUsdS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSB0W3JdfXJldHVybiB1LmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oOTcxKTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOlsiZSIsInQiLCJyIiwibiIsInUiLCJzIiwibyIsImJyYWNlcyIsIkFycmF5IiwiaXNBcnJheSIsImNyZWF0ZSIsInB1c2giLCJjb25jYXQiLCJleHBhbmQiLCJub2R1cGVzIiwiU2V0IiwicGFyc2UiLCJzdHJpbmdpZnkiLCJjb21waWxlIiwibm9lbXB0eSIsImZpbHRlciIsIkJvb2xlYW4iLCJsZW5ndGgiLCJleHBvcnRzIiwid2FsayIsImlzSW52YWxpZEJyYWNlIiwiaW52YWxpZCIsImVzY2FwZUludmFsaWQiLCJpIiwiYSIsImwiLCJpc09wZW4iLCJ2YWx1ZSIsImlzQ2xvc2UiLCJ0eXBlIiwicHJldiIsIm5vZGVzIiwicmFuZ2VzIiwicmVkdWNlIiwid3JhcCIsInRvUmVnZXgiLCJNQVhfTEVOR1RIIiwiQ0hBUl8wIiwiQ0hBUl85IiwiQ0hBUl9VUFBFUkNBU0VfQSIsIkNIQVJfTE9XRVJDQVNFX0EiLCJDSEFSX1VQUEVSQ0FTRV9aIiwiQ0hBUl9MT1dFUkNBU0VfWiIsIkNIQVJfTEVGVF9QQVJFTlRIRVNFUyIsIkNIQVJfUklHSFRfUEFSRU5USEVTRVMiLCJDSEFSX0FTVEVSSVNLIiwiQ0hBUl9BTVBFUlNBTkQiLCJDSEFSX0FUIiwiQ0hBUl9CQUNLU0xBU0giLCJDSEFSX0JBQ0tUSUNLIiwiQ0hBUl9DQVJSSUFHRV9SRVRVUk4iLCJDSEFSX0NJUkNVTUZMRVhfQUNDRU5UIiwiQ0hBUl9DT0xPTiIsIkNIQVJfQ09NTUEiLCJDSEFSX0RPTExBUiIsIkNIQVJfRE9UIiwiQ0hBUl9ET1VCTEVfUVVPVEUiLCJDSEFSX0VRVUFMIiwiQ0hBUl9FWENMQU1BVElPTl9NQVJLIiwiQ0hBUl9GT1JNX0ZFRUQiLCJDSEFSX0ZPUldBUkRfU0xBU0giLCJDSEFSX0hBU0giLCJDSEFSX0hZUEhFTl9NSU5VUyIsIkNIQVJfTEVGVF9BTkdMRV9CUkFDS0VUIiwiQ0hBUl9MRUZUX0NVUkxZX0JSQUNFIiwiQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUIiwiQ0hBUl9MSU5FX0ZFRUQiLCJDSEFSX05PX0JSRUFLX1NQQUNFIiwiQ0hBUl9QRVJDRU5UIiwiQ0hBUl9QTFVTIiwiQ0hBUl9RVUVTVElPTl9NQVJLIiwiQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUIiwiQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRSIsIkNIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQiLCJDSEFSX1NFTUlDT0xPTiIsIkNIQVJfU0lOR0xFX1FVT1RFIiwiQ0hBUl9TUEFDRSIsIkNIQVJfVEFCIiwiQ0hBUl9VTkRFUlNDT1JFIiwiQ0hBUl9WRVJUSUNBTF9MSU5FIiwiQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0UiLCJhcHBlbmQiLCJmbGF0dGVuIiwibWFwIiwicmFuZ2VMaW1pdCIsInF1ZXVlIiwicGFyZW50IiwiZG9sbGFyIiwicG9wIiwiZXhjZWVkc0xpbWl0Iiwic3RlcCIsIlJhbmdlRXJyb3IiLCJlbmNsb3NlQnJhY2UiLCJjIiwicCIsImYiLCJBIiwiUiIsIl8iLCJoIiwiZyIsIkUiLCJUeXBlRXJyb3IiLCJDIiwibWF4TGVuZ3RoIiwiTWF0aCIsIm1pbiIsIlN5bnRheEVycm9yIiwieSIsImlucHV0IiwiZCIsIngiLCJiIiwiUyIsIkgiLCJ2IiwiJCIsIm0iLCJUIiwiYWR2YW5jZSIsImtlZXBFc2NhcGluZyIsImtlZXBRdW90ZXMiLCJzbGljZSIsIm9wZW4iLCJjbG9zZSIsImRlcHRoIiwiY29tbWFzIiwic2hpZnQiLCJyYW5nZSIsImFyZ3MiLCJmb3JFYWNoIiwiaW5kZXhPZiIsInNwbGljZSIsImlzT3Blbk9yQ2xvc2UiLCJpc0ludGVnZXIiLCJOdW1iZXIiLCJ0cmltIiwiZmluZCIsImVzY2FwZU5vZGUiLCJlc2NhcGVkIiwiZmxhdCIsImlzT2JqZWN0IiwidHJhbnNmb3JtIiwiU3RyaW5nIiwiaXNWYWxpZFZhbHVlIiwiaXNOdW1iZXIiLCJ6ZXJvcyIsInBhZCIsInBhZFN0YXJ0IiwidG9NYXhMZW4iLCJ0b1NlcXVlbmNlIiwibmVnYXRpdmVzIiwic29ydCIsInBvc2l0aXZlcyIsImNhcHR1cmUiLCJqb2luIiwidG9SYW5nZSIsImZyb21DaGFyQ29kZSIsInJhbmdlRXJyb3IiLCJpbnNwZWN0IiwiaW52YWxpZFJhbmdlIiwic3RyaWN0UmFuZ2VzIiwiaW52YWxpZFN0ZXAiLCJmaWxsTnVtYmVycyIsIm1heCIsImFicyIsImZpbGxMZXR0ZXJzIiwiY2hhckNvZGVBdCIsIm9wdGlvbnMiLCJmaWxsIiwiaXNGaW5pdGUiLCJpc0VtcHR5U3RyaW5nIiwibWljcm9tYXRjaCIsIm9uUmVzdWx0IiwiYWRkIiwib3V0cHV0Iiwic3RhdGUiLCJuZWdhdGVkIiwibmVnYXRlZEV4dGdsb2IiLCJpc01hdGNoIiwiZGVsZXRlIiwiaGFzIiwiZmFpbGdsb2IiLCJFcnJvciIsIm5vbnVsbCIsIm51bGxnbG9iIiwidW5lc2NhcGUiLCJyZXBsYWNlIiwibWF0Y2giLCJtYXRjaGVyIiwiYW55Iiwibm90IiwiaW5jbHVkZXMiLCJjb250YWlucyIsInNvbWUiLCJzdGFydHNXaXRoIiwibWF0Y2hLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImV2ZXJ5IiwiYWxsIiwiaXNXaW5kb3dzIiwibWFrZVJlIiwiZXhlYyIsInRvUG9zaXhTbGFzaGVzIiwic2NhbiIsIm5vYnJhY2UiLCJ0ZXN0IiwiYnJhY2VFeHBhbmQiLCJET1RfTElURVJBTCIsIlBMVVNfTElURVJBTCIsIlFNQVJLX0xJVEVSQUwiLCJTTEFTSF9MSVRFUkFMIiwiT05FX0NIQVIiLCJRTUFSSyIsIkVORF9BTkNIT1IiLCJET1RTX1NMQVNIIiwiTk9fRE9UIiwiTk9fRE9UUyIsIk5PX0RPVF9TTEFTSCIsIk5PX0RPVFNfU0xBU0giLCJRTUFSS19OT19ET1QiLCJTVEFSIiwiU1RBUlRfQU5DSE9SIiwiYWxudW0iLCJhbHBoYSIsImFzY2lpIiwiYmxhbmsiLCJjbnRybCIsImRpZ2l0IiwiZ3JhcGgiLCJsb3dlciIsInByaW50IiwicHVuY3QiLCJzcGFjZSIsInVwcGVyIiwid29yZCIsInhkaWdpdCIsIlBPU0lYX1JFR0VYX1NPVVJDRSIsIlJFR0VYX0JBQ0tTTEFTSCIsIlJFR0VYX05PTl9TUEVDSUFMX0NIQVJTIiwiUkVHRVhfU1BFQ0lBTF9DSEFSUyIsIlJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRiIsIlJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMIiwiUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSCIsIlJFUExBQ0VNRU5UUyIsIkNIQVJfQkFDS1dBUkRfU0xBU0giLCJDSEFSX0dSQVZFX0FDQ0VOVCIsIlNFUCIsInNlcCIsImV4dGdsb2JDaGFycyIsImdsb2JDaGFycyIsImV4cGFuZFJhbmdlIiwiUmVnRXhwIiwiZXNjYXBlUmVnZXgiLCJzeW50YXhFcnJvciIsInByZXBlbmQiLCJnbG9ic3RhciIsImRvdCIsIkwiLCJPIiwidyIsImJhc2giLCJub2V4dCIsIm5vZXh0Z2xvYiIsIk4iLCJpbmRleCIsInN0YXJ0IiwiY29uc3VtZWQiLCJwcmVmaXgiLCJiYWNrdHJhY2siLCJicmFja2V0cyIsInBhcmVucyIsInF1b3RlcyIsInRva2VucyIsInJlbW92ZVByZWZpeCIsImsiLCJJIiwiTSIsIlAiLCJCIiwiZW9zIiwiRyIsInBlZWsiLCJEIiwicmVtYWluaW5nIiwiY29uc3VtZSIsIm5lZ2F0ZSIsImluY3JlbWVudCIsImRlY3JlbWVudCIsImV4dGdsb2IiLCJpbm5lciIsImV4dGdsb2JPcGVuIiwiY29uZGl0aW9ucyIsImV4dGdsb2JDbG9zZSIsImZhc3RwYXRocyIsInJlcGVhdCIsIndyYXBPdXRwdXQiLCJwb3NpeCIsImxhc3RJbmRleE9mIiwic3RyaWN0QnJhY2tldHMiLCJub2JyYWNrZXQiLCJsaXRlcmFsQnJhY2tldHMiLCJoYXNSZWdleENoYXJzIiwib3V0cHV0SW5kZXgiLCJ0b2tlbnNJbmRleCIsImRvdHMiLCJ1bnNoaWZ0IiwiY29tbWEiLCJzdXBwb3J0c0xvb2tiZWhpbmRzIiwibm9uZWdhdGUiLCJyZWdleCIsInN0YXIiLCJub2dsb2JzdGFyIiwic3RyaWN0U2xhc2hlcyIsImVzY2FwZUxhc3QiLCJzdWZmaXgiLCJwaWNvbWF0Y2giLCJhcnJheU1hdGNoZXIiLCJjb21waWxlUmUiLCJpc0lnbm9yZWQiLCJpZ25vcmUiLCJvbk1hdGNoIiwiZ2xvYiIsIm9uSWdub3JlIiwiZm9ybWF0IiwibWF0Y2hCYXNlIiwiYmFzZW5hbWUiLCJ1bmRlZmluZWQiLCJmbGFncyIsIm5vY2FzZSIsImRlYnVnIiwiY29uc3RhbnRzIiwiaXNQYXRoU2VwYXJhdG9yIiwiaXNQcmVmaXgiLCJpc0dsb2JzdGFyIiwiSW5maW5pdHkiLCJwYXJ0cyIsInNjYW5Ub0VuZCIsImlzR2xvYiIsImJhY2tzbGFzaGVzIiwiaXNCcmFjZSIsImlzRXh0Z2xvYiIsImlzQnJhY2tldCIsIm5vcGFyZW4iLCJVIiwiSyIsIkYiLCJyZW1vdmVCYWNrc2xhc2hlcyIsIlEiLCJiYXNlIiwibWF4RGVwdGgiLCJzbGFzaGVzIiwicHJvY2VzcyIsInBsYXRmb3JtIiwiaXNSZWdleENoYXIiLCJ2ZXJzaW9uIiwic3BsaXQiLCJ3aW5kb3dzIiwidG9SZWdleFJhbmdlIiwicmVsYXhaZXJvcyIsInN0cmljdFplcm9zIiwic2hvcnRoYW5kIiwiY2FjaGUiLCJoYXNPd25Qcm9wZXJ0eSIsInJlc3VsdCIsImhhc1BhZGRpbmciLCJpc1BhZGRlZCIsIm1heExlbiIsInNwbGl0VG9QYXR0ZXJucyIsImNvbGxhdGVQYXR0ZXJucyIsImZpbHRlclBhdHRlcm5zIiwic3BsaXRUb1JhbmdlcyIsImNvdW50TmluZXMiLCJjb3VudFplcm9zIiwiY29tcGFyZSIsInJhbmdlVG9QYXR0ZXJuIiwicGF0dGVybiIsImNvdW50IiwiZGlnaXRzIiwiemlwIiwidG9DaGFyYWN0ZXJDbGFzcyIsInN0cmluZyIsInRvUXVhbnRpZmllciIsInBhZFplcm9zIiwicG93IiwiY2xlYXJDYWNoZSIsInJlcXVpcmUiLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/micromatch/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-browserify/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-browserify/index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function () {\n  \"use strict\";\n\n  var e = {\n    114: function (e) {\n      function assertPath(e) {\n        if (typeof e !== \"string\") {\n          throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(e));\n        }\n      }\n\n      function normalizeStringPosix(e, r) {\n        var t = \"\";\n        var i = 0;\n        var n = -1;\n        var a = 0;\n        var f;\n\n        for (var l = 0; l <= e.length; ++l) {\n          if (l < e.length) f = e.charCodeAt(l);else if (f === 47) break;else f = 47;\n\n          if (f === 47) {\n            if (n === l - 1 || a === 1) {} else if (n !== l - 1 && a === 2) {\n              if (t.length < 2 || i !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {\n                if (t.length > 2) {\n                  var s = t.lastIndexOf(\"/\");\n\n                  if (s !== t.length - 1) {\n                    if (s === -1) {\n                      t = \"\";\n                      i = 0;\n                    } else {\n                      t = t.slice(0, s);\n                      i = t.length - 1 - t.lastIndexOf(\"/\");\n                    }\n\n                    n = l;\n                    a = 0;\n                    continue;\n                  }\n                } else if (t.length === 2 || t.length === 1) {\n                  t = \"\";\n                  i = 0;\n                  n = l;\n                  a = 0;\n                  continue;\n                }\n              }\n\n              if (r) {\n                if (t.length > 0) t += \"/..\";else t = \"..\";\n                i = 2;\n              }\n            } else {\n              if (t.length > 0) t += \"/\" + e.slice(n + 1, l);else t = e.slice(n + 1, l);\n              i = l - n - 1;\n            }\n\n            n = l;\n            a = 0;\n          } else if (f === 46 && a !== -1) {\n            ++a;\n          } else {\n            a = -1;\n          }\n        }\n\n        return t;\n      }\n\n      function _format(e, r) {\n        var t = r.dir || r.root;\n        var i = r.base || (r.name || \"\") + (r.ext || \"\");\n\n        if (!t) {\n          return i;\n        }\n\n        if (t === r.root) {\n          return t + i;\n        }\n\n        return t + e + i;\n      }\n\n      var r = {\n        resolve: function resolve() {\n          var e = \"\";\n          var r = false;\n          var t;\n\n          for (var i = arguments.length - 1; i >= -1 && !r; i--) {\n            var n;\n            if (i >= 0) n = arguments[i];else {\n              if (t === undefined) t = \"\";\n              n = t;\n            }\n            assertPath(n);\n\n            if (n.length === 0) {\n              continue;\n            }\n\n            e = n + \"/\" + e;\n            r = n.charCodeAt(0) === 47;\n          }\n\n          e = normalizeStringPosix(e, !r);\n\n          if (r) {\n            if (e.length > 0) return \"/\" + e;else return \"/\";\n          } else if (e.length > 0) {\n            return e;\n          } else {\n            return \".\";\n          }\n        },\n        normalize: function normalize(e) {\n          assertPath(e);\n          if (e.length === 0) return \".\";\n          var r = e.charCodeAt(0) === 47;\n          var t = e.charCodeAt(e.length - 1) === 47;\n          e = normalizeStringPosix(e, !r);\n          if (e.length === 0 && !r) e = \".\";\n          if (e.length > 0 && t) e += \"/\";\n          if (r) return \"/\" + e;\n          return e;\n        },\n        isAbsolute: function isAbsolute(e) {\n          assertPath(e);\n          return e.length > 0 && e.charCodeAt(0) === 47;\n        },\n        join: function join() {\n          if (arguments.length === 0) return \".\";\n          var e;\n\n          for (var t = 0; t < arguments.length; ++t) {\n            var i = arguments[t];\n            assertPath(i);\n\n            if (i.length > 0) {\n              if (e === undefined) e = i;else e += \"/\" + i;\n            }\n          }\n\n          if (e === undefined) return \".\";\n          return r.normalize(e);\n        },\n        relative: function relative(e, t) {\n          assertPath(e);\n          assertPath(t);\n          if (e === t) return \"\";\n          e = r.resolve(e);\n          t = r.resolve(t);\n          if (e === t) return \"\";\n          var i = 1;\n\n          for (; i < e.length; ++i) {\n            if (e.charCodeAt(i) !== 47) break;\n          }\n\n          var n = e.length;\n          var a = n - i;\n          var f = 1;\n\n          for (; f < t.length; ++f) {\n            if (t.charCodeAt(f) !== 47) break;\n          }\n\n          var l = t.length;\n          var s = l - f;\n          var o = a < s ? a : s;\n          var u = -1;\n          var h = 0;\n\n          for (; h <= o; ++h) {\n            if (h === o) {\n              if (s > o) {\n                if (t.charCodeAt(f + h) === 47) {\n                  return t.slice(f + h + 1);\n                } else if (h === 0) {\n                  return t.slice(f + h);\n                }\n              } else if (a > o) {\n                if (e.charCodeAt(i + h) === 47) {\n                  u = h;\n                } else if (h === 0) {\n                  u = 0;\n                }\n              }\n\n              break;\n            }\n\n            var c = e.charCodeAt(i + h);\n            var v = t.charCodeAt(f + h);\n            if (c !== v) break;else if (c === 47) u = h;\n          }\n\n          var g = \"\";\n\n          for (h = i + u + 1; h <= n; ++h) {\n            if (h === n || e.charCodeAt(h) === 47) {\n              if (g.length === 0) g += \"..\";else g += \"/..\";\n            }\n          }\n\n          if (g.length > 0) return g + t.slice(f + u);else {\n            f += u;\n            if (t.charCodeAt(f) === 47) ++f;\n            return t.slice(f);\n          }\n        },\n        _makeLong: function _makeLong(e) {\n          return e;\n        },\n        dirname: function dirname(e) {\n          assertPath(e);\n          if (e.length === 0) return \".\";\n          var r = e.charCodeAt(0);\n          var t = r === 47;\n          var i = -1;\n          var n = true;\n\n          for (var a = e.length - 1; a >= 1; --a) {\n            r = e.charCodeAt(a);\n\n            if (r === 47) {\n              if (!n) {\n                i = a;\n                break;\n              }\n            } else {\n              n = false;\n            }\n          }\n\n          if (i === -1) return t ? \"/\" : \".\";\n          if (t && i === 1) return \"//\";\n          return e.slice(0, i);\n        },\n        basename: function basename(e, r) {\n          if (r !== undefined && typeof r !== \"string\") throw new TypeError('\"ext\" argument must be a string');\n          assertPath(e);\n          var t = 0;\n          var i = -1;\n          var n = true;\n          var a;\n\n          if (r !== undefined && r.length > 0 && r.length <= e.length) {\n            if (r.length === e.length && r === e) return \"\";\n            var f = r.length - 1;\n            var l = -1;\n\n            for (a = e.length - 1; a >= 0; --a) {\n              var s = e.charCodeAt(a);\n\n              if (s === 47) {\n                if (!n) {\n                  t = a + 1;\n                  break;\n                }\n              } else {\n                if (l === -1) {\n                  n = false;\n                  l = a + 1;\n                }\n\n                if (f >= 0) {\n                  if (s === r.charCodeAt(f)) {\n                    if (--f === -1) {\n                      i = a;\n                    }\n                  } else {\n                    f = -1;\n                    i = l;\n                  }\n                }\n              }\n            }\n\n            if (t === i) i = l;else if (i === -1) i = e.length;\n            return e.slice(t, i);\n          } else {\n            for (a = e.length - 1; a >= 0; --a) {\n              if (e.charCodeAt(a) === 47) {\n                if (!n) {\n                  t = a + 1;\n                  break;\n                }\n              } else if (i === -1) {\n                n = false;\n                i = a + 1;\n              }\n            }\n\n            if (i === -1) return \"\";\n            return e.slice(t, i);\n          }\n        },\n        extname: function extname(e) {\n          assertPath(e);\n          var r = -1;\n          var t = 0;\n          var i = -1;\n          var n = true;\n          var a = 0;\n\n          for (var f = e.length - 1; f >= 0; --f) {\n            var l = e.charCodeAt(f);\n\n            if (l === 47) {\n              if (!n) {\n                t = f + 1;\n                break;\n              }\n\n              continue;\n            }\n\n            if (i === -1) {\n              n = false;\n              i = f + 1;\n            }\n\n            if (l === 46) {\n              if (r === -1) r = f;else if (a !== 1) a = 1;\n            } else if (r !== -1) {\n              a = -1;\n            }\n          }\n\n          if (r === -1 || i === -1 || a === 0 || a === 1 && r === i - 1 && r === t + 1) {\n            return \"\";\n          }\n\n          return e.slice(r, i);\n        },\n        format: function format(e) {\n          if (e === null || typeof e !== \"object\") {\n            throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof e);\n          }\n\n          return _format(\"/\", e);\n        },\n        parse: function parse(e) {\n          assertPath(e);\n          var r = {\n            root: \"\",\n            dir: \"\",\n            base: \"\",\n            ext: \"\",\n            name: \"\"\n          };\n          if (e.length === 0) return r;\n          var t = e.charCodeAt(0);\n          var i = t === 47;\n          var n;\n\n          if (i) {\n            r.root = \"/\";\n            n = 1;\n          } else {\n            n = 0;\n          }\n\n          var a = -1;\n          var f = 0;\n          var l = -1;\n          var s = true;\n          var o = e.length - 1;\n          var u = 0;\n\n          for (; o >= n; --o) {\n            t = e.charCodeAt(o);\n\n            if (t === 47) {\n              if (!s) {\n                f = o + 1;\n                break;\n              }\n\n              continue;\n            }\n\n            if (l === -1) {\n              s = false;\n              l = o + 1;\n            }\n\n            if (t === 46) {\n              if (a === -1) a = o;else if (u !== 1) u = 1;\n            } else if (a !== -1) {\n              u = -1;\n            }\n          }\n\n          if (a === -1 || l === -1 || u === 0 || u === 1 && a === l - 1 && a === f + 1) {\n            if (l !== -1) {\n              if (f === 0 && i) r.base = r.name = e.slice(1, l);else r.base = r.name = e.slice(f, l);\n            }\n          } else {\n            if (f === 0 && i) {\n              r.name = e.slice(1, a);\n              r.base = e.slice(1, l);\n            } else {\n              r.name = e.slice(f, a);\n              r.base = e.slice(f, l);\n            }\n\n            r.ext = e.slice(a, l);\n          }\n\n          if (f > 0) r.dir = e.slice(0, f - 1);else if (i) r.dir = \"/\";\n          return r;\n        },\n        sep: \"/\",\n        delimiter: \":\",\n        win32: null,\n        posix: null\n      };\n      r.posix = r;\n      e.exports = r;\n    }\n  };\n  var r = {};\n\n  function __nccwpck_require__(t) {\n    var i = r[t];\n\n    if (i !== undefined) {\n      return i.exports;\n    }\n\n    var n = r[t] = {\n      exports: {}\n    };\n    var a = true;\n\n    try {\n      e[t](n, n.exports, __nccwpck_require__);\n      a = false;\n    } finally {\n      if (a) delete r[t];\n    }\n\n    return n.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var t = __nccwpck_require__(114);\n\n  module.exports = t;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsQ0FBQyxZQUFVO0VBQUM7O0VBQWEsSUFBSUEsQ0FBQyxHQUFDO0lBQUMsS0FBSSxVQUFTQSxDQUFULEVBQVc7TUFBQyxTQUFTQyxVQUFULENBQW9CRCxDQUFwQixFQUFzQjtRQUFDLElBQUcsT0FBT0EsQ0FBUCxLQUFXLFFBQWQsRUFBdUI7VUFBQyxNQUFNLElBQUlFLFNBQUosQ0FBYyxxQ0FBbUNDLElBQUksQ0FBQ0MsU0FBTCxDQUFlSixDQUFmLENBQWpELENBQU47UUFBMEU7TUFBQzs7TUFBQSxTQUFTSyxvQkFBVCxDQUE4QkwsQ0FBOUIsRUFBZ0NNLENBQWhDLEVBQWtDO1FBQUMsSUFBSUMsQ0FBQyxHQUFDLEVBQU47UUFBUyxJQUFJQyxDQUFDLEdBQUMsQ0FBTjtRQUFRLElBQUlDLENBQUMsR0FBQyxDQUFDLENBQVA7UUFBUyxJQUFJQyxDQUFDLEdBQUMsQ0FBTjtRQUFRLElBQUlDLENBQUo7O1FBQU0sS0FBSSxJQUFJQyxDQUFDLEdBQUMsQ0FBVixFQUFZQSxDQUFDLElBQUVaLENBQUMsQ0FBQ2EsTUFBakIsRUFBd0IsRUFBRUQsQ0FBMUIsRUFBNEI7VUFBQyxJQUFHQSxDQUFDLEdBQUNaLENBQUMsQ0FBQ2EsTUFBUCxFQUFjRixDQUFDLEdBQUNYLENBQUMsQ0FBQ2MsVUFBRixDQUFhRixDQUFiLENBQUYsQ0FBZCxLQUFxQyxJQUFHRCxDQUFDLEtBQUcsRUFBUCxFQUFVLE1BQVYsS0FBcUJBLENBQUMsR0FBQyxFQUFGOztVQUFLLElBQUdBLENBQUMsS0FBRyxFQUFQLEVBQVU7WUFBQyxJQUFHRixDQUFDLEtBQUdHLENBQUMsR0FBQyxDQUFOLElBQVNGLENBQUMsS0FBRyxDQUFoQixFQUFrQixDQUFFLENBQXBCLE1BQXlCLElBQUdELENBQUMsS0FBR0csQ0FBQyxHQUFDLENBQU4sSUFBU0YsQ0FBQyxLQUFHLENB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QUssRUFBQyxJQUFoNUg7UUFBcTVIQyxLQUFLLEVBQUM7TUFBMzVILENBQU47TUFBdTZIeEMsQ0FBQyxDQUFDd0MsS0FBRixHQUFReEMsQ0FBUjtNQUFVTixDQUFDLENBQUMrQyxPQUFGLEdBQVV6QyxDQUFWO0lBQVk7RUFBbjRKLENBQU47RUFBMjRKLElBQUlBLENBQUMsR0FBQyxFQUFOOztFQUFTLFNBQVMwQyxtQkFBVCxDQUE2QnpDLENBQTdCLEVBQStCO0lBQUMsSUFBSUMsQ0FBQyxHQUFDRixDQUFDLENBQUNDLENBQUQsQ0FBUDs7SUFBVyxJQUFHQyxDQUFDLEtBQUdrQixTQUFQLEVBQWlCO01BQUMsT0FBT2xCLENBQUMsQ0FBQ3VDLE9BQVQ7SUFBaUI7O0lBQUEsSUFBSXRDLENBQUMsR0FBQ0gsQ0FBQyxDQUFDQyxDQUFELENBQUQsR0FBSztNQUFDd0MsT0FBTyxFQUFDO0lBQVQsQ0FBWDtJQUF3QixJQUFJckMsQ0FBQyxHQUFDLElBQU47O0lBQVcsSUFBRztNQUFDVixDQUFDLENBQUNPLENBQUQsQ0FBRCxDQUFLRSxDQUFMLEVBQU9BLENBQUMsQ0FBQ3NDLE9BQVQsRUFBaUJDLG1CQUFqQjtNQUFzQ3RDLENBQUMsR0FBQyxLQUFGO0lBQVEsQ0FBbEQsU0FBeUQ7TUFBQyxJQUFHQSxDQUFILEVBQUssT0FBT0osQ0FBQyxDQUFDQyxDQUFELENBQVI7SUFBWTs7SUFBQSxPQUFPRSxDQUFDLENBQUNzQyxPQUFUO0VBQWlCOztFQUFBLElBQUcsT0FBT0MsbUJBQVAsS0FBNkIsV0FBaEMsRUFBNENBLG1CQUFtQixDQUFDQyxFQUFwQixHQUF1QkMsU0FBUyxHQUFDLEdBQWpDOztFQUFxQyxJQUFJM0MsQ0FBQyxHQUFDeUMsbUJBQW1CLENBQUMsR0FBRCxDQUF6Qjs7RUFBK0JHLE1BQU0sQ0FBQ0osT0FBUCxHQUFleEMsQ0FBZjtBQUFpQixDQUEzdksiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanM/M2NkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT17MTE0OmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGFzc2VydFBhdGgoZSl7aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShlKSl9fWZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KGUscil7dmFyIHQ9XCJcIjt2YXIgaT0wO3ZhciBuPS0xO3ZhciBhPTA7dmFyIGY7Zm9yKHZhciBsPTA7bDw9ZS5sZW5ndGg7KytsKXtpZihsPGUubGVuZ3RoKWY9ZS5jaGFyQ29kZUF0KGwpO2Vsc2UgaWYoZj09PTQ3KWJyZWFrO2Vsc2UgZj00NztpZihmPT09NDcpe2lmKG49PT1sLTF8fGE9PT0xKXt9ZWxzZSBpZihuIT09bC0xJiZhPT09Mil7aWYodC5sZW5ndGg8Mnx8aSE9PTJ8fHQuY2hhckNvZGVBdCh0Lmxlbmd0aC0xKSE9PTQ2fHx0LmNoYXJDb2RlQXQodC5sZW5ndGgtMikhPT00Nil7aWYodC5sZW5ndGg+Mil7dmFyIHM9dC5sYXN0SW5kZXhPZihcIi9cIik7aWYocyE9PXQubGVuZ3RoLTEpe2lmKHM9PT0tMSl7dD1cIlwiO2k9MH1lbHNle3Q9dC5zbGljZSgwLHMpO2k9dC5sZW5ndGgtMS10Lmxhc3RJbmRleE9mKFwiL1wiKX1uPWw7YT0wO2NvbnRpbnVlfX1lbHNlIGlmKHQubGVuZ3RoPT09Mnx8dC5sZW5ndGg9PT0xKXt0PVwiXCI7aT0wO249bDthPTA7Y29udGludWV9fWlmKHIpe2lmKHQubGVuZ3RoPjApdCs9XCIvLi5cIjtlbHNlIHQ9XCIuLlwiO2k9Mn19ZWxzZXtpZih0Lmxlbmd0aD4wKXQrPVwiL1wiK2Uuc2xpY2UobisxLGwpO2Vsc2UgdD1lLnNsaWNlKG4rMSxsKTtpPWwtbi0xfW49bDthPTB9ZWxzZSBpZihmPT09NDYmJmEhPT0tMSl7KythfWVsc2V7YT0tMX19cmV0dXJuIHR9ZnVuY3Rpb24gX2Zvcm1hdChlLHIpe3ZhciB0PXIuZGlyfHxyLnJvb3Q7dmFyIGk9ci5iYXNlfHwoci5uYW1lfHxcIlwiKSsoci5leHR8fFwiXCIpO2lmKCF0KXtyZXR1cm4gaX1pZih0PT09ci5yb290KXtyZXR1cm4gdCtpfXJldHVybiB0K2UraX12YXIgcj17cmVzb2x2ZTpmdW5jdGlvbiByZXNvbHZlKCl7dmFyIGU9XCJcIjt2YXIgcj1mYWxzZTt2YXIgdDtmb3IodmFyIGk9YXJndW1lbnRzLmxlbmd0aC0xO2k+PS0xJiYhcjtpLS0pe3ZhciBuO2lmKGk+PTApbj1hcmd1bWVudHNbaV07ZWxzZXtpZih0PT09dW5kZWZpbmVkKXQ9XCJcIjtuPXR9YXNzZXJ0UGF0aChuKTtpZihuLmxlbmd0aD09PTApe2NvbnRpbnVlfWU9bitcIi9cIitlO3I9bi5jaGFyQ29kZUF0KDApPT09NDd9ZT1ub3JtYWxpemVTdHJpbmdQb3NpeChlLCFyKTtpZihyKXtpZihlLmxlbmd0aD4wKXJldHVyblwiL1wiK2U7ZWxzZSByZXR1cm5cIi9cIn1lbHNlIGlmKGUubGVuZ3RoPjApe3JldHVybiBlfWVsc2V7cmV0dXJuXCIuXCJ9fSxub3JtYWxpemU6ZnVuY3Rpb24gbm9ybWFsaXplKGUpe2Fzc2VydFBhdGgoZSk7aWYoZS5sZW5ndGg9PT0wKXJldHVyblwiLlwiO3ZhciByPWUuY2hhckNvZGVBdCgwKT09PTQ3O3ZhciB0PWUuY2hhckNvZGVBdChlLmxlbmd0aC0xKT09PTQ3O2U9bm9ybWFsaXplU3RyaW5nUG9zaXgoZSwhcik7aWYoZS5sZW5ndGg9PT0wJiYhcillPVwiLlwiO2lmKGUubGVuZ3RoPjAmJnQpZSs9XCIvXCI7aWYocilyZXR1cm5cIi9cIitlO3JldHVybiBlfSxpc0Fic29sdXRlOmZ1bmN0aW9uIGlzQWJzb2x1dGUoZSl7YXNzZXJ0UGF0aChlKTtyZXR1cm4gZS5sZW5ndGg+MCYmZS5jaGFyQ29kZUF0KDApPT09NDd9LGpvaW46ZnVuY3Rpb24gam9pbigpe2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0wKXJldHVyblwiLlwiO3ZhciBlO2Zvcih2YXIgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDsrK3Qpe3ZhciBpPWFyZ3VtZW50c1t0XTthc3NlcnRQYXRoKGkpO2lmKGkubGVuZ3RoPjApe2lmKGU9PT11bmRlZmluZWQpZT1pO2Vsc2UgZSs9XCIvXCIraX19aWYoZT09PXVuZGVmaW5lZClyZXR1cm5cIi5cIjtyZXR1cm4gci5ub3JtYWxpemUoZSl9LHJlbGF0aXZlOmZ1bmN0aW9uIHJlbGF0aXZlKGUsdCl7YXNzZXJ0UGF0aChlKTthc3NlcnRQYXRoKHQpO2lmKGU9PT10KXJldHVyblwiXCI7ZT1yLnJlc29sdmUoZSk7dD1yLnJlc29sdmUodCk7aWYoZT09PXQpcmV0dXJuXCJcIjt2YXIgaT0xO2Zvcig7aTxlLmxlbmd0aDsrK2kpe2lmKGUuY2hhckNvZGVBdChpKSE9PTQ3KWJyZWFrfXZhciBuPWUubGVuZ3RoO3ZhciBhPW4taTt2YXIgZj0xO2Zvcig7Zjx0Lmxlbmd0aDsrK2Ype2lmKHQuY2hhckNvZGVBdChmKSE9PTQ3KWJyZWFrfXZhciBsPXQubGVuZ3RoO3ZhciBzPWwtZjt2YXIgbz1hPHM/YTpzO3ZhciB1PS0xO3ZhciBoPTA7Zm9yKDtoPD1vOysraCl7aWYoaD09PW8pe2lmKHM+byl7aWYodC5jaGFyQ29kZUF0KGYraCk9PT00Nyl7cmV0dXJuIHQuc2xpY2UoZitoKzEpfWVsc2UgaWYoaD09PTApe3JldHVybiB0LnNsaWNlKGYraCl9fWVsc2UgaWYoYT5vKXtpZihlLmNoYXJDb2RlQXQoaStoKT09PTQ3KXt1PWh9ZWxzZSBpZihoPT09MCl7dT0wfX1icmVha312YXIgYz1lLmNoYXJDb2RlQXQoaStoKTt2YXIgdj10LmNoYXJDb2RlQXQoZitoKTtpZihjIT09dilicmVhaztlbHNlIGlmKGM9PT00Nyl1PWh9dmFyIGc9XCJcIjtmb3IoaD1pK3UrMTtoPD1uOysraCl7aWYoaD09PW58fGUuY2hhckNvZGVBdChoKT09PTQ3KXtpZihnLmxlbmd0aD09PTApZys9XCIuLlwiO2Vsc2UgZys9XCIvLi5cIn19aWYoZy5sZW5ndGg+MClyZXR1cm4gZyt0LnNsaWNlKGYrdSk7ZWxzZXtmKz11O2lmKHQuY2hhckNvZGVBdChmKT09PTQ3KSsrZjtyZXR1cm4gdC5zbGljZShmKX19LF9tYWtlTG9uZzpmdW5jdGlvbiBfbWFrZUxvbmcoZSl7cmV0dXJuIGV9LGRpcm5hbWU6ZnVuY3Rpb24gZGlybmFtZShlKXthc3NlcnRQYXRoKGUpO2lmKGUubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgcj1lLmNoYXJDb2RlQXQoMCk7dmFyIHQ9cj09PTQ3O3ZhciBpPS0xO3ZhciBuPXRydWU7Zm9yKHZhciBhPWUubGVuZ3RoLTE7YT49MTstLWEpe3I9ZS5jaGFyQ29kZUF0KGEpO2lmKHI9PT00Nyl7aWYoIW4pe2k9YTticmVha319ZWxzZXtuPWZhbHNlfX1pZihpPT09LTEpcmV0dXJuIHQ/XCIvXCI6XCIuXCI7aWYodCYmaT09PTEpcmV0dXJuXCIvL1wiO3JldHVybiBlLnNsaWNlKDAsaSl9LGJhc2VuYW1lOmZ1bmN0aW9uIGJhc2VuYW1lKGUscil7aWYociE9PXVuZGVmaW5lZCYmdHlwZW9mIHIhPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXh0XCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO2Fzc2VydFBhdGgoZSk7dmFyIHQ9MDt2YXIgaT0tMTt2YXIgbj10cnVlO3ZhciBhO2lmKHIhPT11bmRlZmluZWQmJnIubGVuZ3RoPjAmJnIubGVuZ3RoPD1lLmxlbmd0aCl7aWYoci5sZW5ndGg9PT1lLmxlbmd0aCYmcj09PWUpcmV0dXJuXCJcIjt2YXIgZj1yLmxlbmd0aC0xO3ZhciBsPS0xO2ZvcihhPWUubGVuZ3RoLTE7YT49MDstLWEpe3ZhciBzPWUuY2hhckNvZGVBdChhKTtpZihzPT09NDcpe2lmKCFuKXt0PWErMTticmVha319ZWxzZXtpZihsPT09LTEpe249ZmFsc2U7bD1hKzF9aWYoZj49MCl7aWYocz09PXIuY2hhckNvZGVBdChmKSl7aWYoLS1mPT09LTEpe2k9YX19ZWxzZXtmPS0xO2k9bH19fX1pZih0PT09aSlpPWw7ZWxzZSBpZihpPT09LTEpaT1lLmxlbmd0aDtyZXR1cm4gZS5zbGljZSh0LGkpfWVsc2V7Zm9yKGE9ZS5sZW5ndGgtMTthPj0wOy0tYSl7aWYoZS5jaGFyQ29kZUF0KGEpPT09NDcpe2lmKCFuKXt0PWErMTticmVha319ZWxzZSBpZihpPT09LTEpe249ZmFsc2U7aT1hKzF9fWlmKGk9PT0tMSlyZXR1cm5cIlwiO3JldHVybiBlLnNsaWNlKHQsaSl9fSxleHRuYW1lOmZ1bmN0aW9uIGV4dG5hbWUoZSl7YXNzZXJ0UGF0aChlKTt2YXIgcj0tMTt2YXIgdD0wO3ZhciBpPS0xO3ZhciBuPXRydWU7dmFyIGE9MDtmb3IodmFyIGY9ZS5sZW5ndGgtMTtmPj0wOy0tZil7dmFyIGw9ZS5jaGFyQ29kZUF0KGYpO2lmKGw9PT00Nyl7aWYoIW4pe3Q9ZisxO2JyZWFrfWNvbnRpbnVlfWlmKGk9PT0tMSl7bj1mYWxzZTtpPWYrMX1pZihsPT09NDYpe2lmKHI9PT0tMSlyPWY7ZWxzZSBpZihhIT09MSlhPTF9ZWxzZSBpZihyIT09LTEpe2E9LTF9fWlmKHI9PT0tMXx8aT09PS0xfHxhPT09MHx8YT09PTEmJnI9PT1pLTEmJnI9PT10KzEpe3JldHVyblwiXCJ9cmV0dXJuIGUuc2xpY2UocixpKX0sZm9ybWF0OmZ1bmN0aW9uIGZvcm1hdChlKXtpZihlPT09bnVsbHx8dHlwZW9mIGUhPT1cIm9iamVjdFwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJwYXRoT2JqZWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnK3R5cGVvZiBlKX1yZXR1cm4gX2Zvcm1hdChcIi9cIixlKX0scGFyc2U6ZnVuY3Rpb24gcGFyc2UoZSl7YXNzZXJ0UGF0aChlKTt2YXIgcj17cm9vdDpcIlwiLGRpcjpcIlwiLGJhc2U6XCJcIixleHQ6XCJcIixuYW1lOlwiXCJ9O2lmKGUubGVuZ3RoPT09MClyZXR1cm4gcjt2YXIgdD1lLmNoYXJDb2RlQXQoMCk7dmFyIGk9dD09PTQ3O3ZhciBuO2lmKGkpe3Iucm9vdD1cIi9cIjtuPTF9ZWxzZXtuPTB9dmFyIGE9LTE7dmFyIGY9MDt2YXIgbD0tMTt2YXIgcz10cnVlO3ZhciBvPWUubGVuZ3RoLTE7dmFyIHU9MDtmb3IoO28+PW47LS1vKXt0PWUuY2hhckNvZGVBdChvKTtpZih0PT09NDcpe2lmKCFzKXtmPW8rMTticmVha31jb250aW51ZX1pZihsPT09LTEpe3M9ZmFsc2U7bD1vKzF9aWYodD09PTQ2KXtpZihhPT09LTEpYT1vO2Vsc2UgaWYodSE9PTEpdT0xfWVsc2UgaWYoYSE9PS0xKXt1PS0xfX1pZihhPT09LTF8fGw9PT0tMXx8dT09PTB8fHU9PT0xJiZhPT09bC0xJiZhPT09ZisxKXtpZihsIT09LTEpe2lmKGY9PT0wJiZpKXIuYmFzZT1yLm5hbWU9ZS5zbGljZSgxLGwpO2Vsc2Ugci5iYXNlPXIubmFtZT1lLnNsaWNlKGYsbCl9fWVsc2V7aWYoZj09PTAmJmkpe3IubmFtZT1lLnNsaWNlKDEsYSk7ci5iYXNlPWUuc2xpY2UoMSxsKX1lbHNle3IubmFtZT1lLnNsaWNlKGYsYSk7ci5iYXNlPWUuc2xpY2UoZixsKX1yLmV4dD1lLnNsaWNlKGEsbCl9aWYoZj4wKXIuZGlyPWUuc2xpY2UoMCxmLTEpO2Vsc2UgaWYoaSlyLmRpcj1cIi9cIjtyZXR1cm4gcn0sc2VwOlwiL1wiLGRlbGltaXRlcjpcIjpcIix3aW4zMjpudWxsLHBvc2l4Om51bGx9O3IucG9zaXg9cjtlLmV4cG9ydHM9cn19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIGk9clt0XTtpZihpIT09dW5kZWZpbmVkKXtyZXR1cm4gaS5leHBvcnRzfXZhciBuPXJbdF09e2V4cG9ydHM6e319O3ZhciBhPXRydWU7dHJ5e2VbdF0obixuLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7YT1mYWxzZX1maW5hbGx5e2lmKGEpZGVsZXRlIHJbdF19cmV0dXJuIG4uZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXygxMTQpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6WyJlIiwiYXNzZXJ0UGF0aCIsIlR5cGVFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJub3JtYWxpemVTdHJpbmdQb3NpeCIsInIiLCJ0IiwiaSIsIm4iLCJhIiwiZiIsImwiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwicyIsImxhc3RJbmRleE9mIiwic2xpY2UiLCJfZm9ybWF0IiwiZGlyIiwicm9vdCIsImJhc2UiLCJuYW1lIiwiZXh0IiwicmVzb2x2ZSIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsIm5vcm1hbGl6ZSIsImlzQWJzb2x1dGUiLCJqb2luIiwicmVsYXRpdmUiLCJvIiwidSIsImgiLCJjIiwidiIsImciLCJfbWFrZUxvbmciLCJkaXJuYW1lIiwiYmFzZW5hbWUiLCJleHRuYW1lIiwiZm9ybWF0IiwicGFyc2UiLCJzZXAiLCJkZWxpbWl0ZXIiLCJ3aW4zMiIsInBvc2l4IiwiZXhwb3J0cyIsIl9fbmNjd3Bja19yZXF1aXJlX18iLCJhYiIsIl9fZGlybmFtZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/path-browserify/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function () {\n  var e = {\n    229: function (e) {\n      var t = e.exports = {};\n      var r;\n      var n;\n\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n\n      (function () {\n        try {\n          if (typeof setTimeout === \"function\") {\n            r = setTimeout;\n          } else {\n            r = defaultSetTimout;\n          }\n        } catch (e) {\n          r = defaultSetTimout;\n        }\n\n        try {\n          if (typeof clearTimeout === \"function\") {\n            n = clearTimeout;\n          } else {\n            n = defaultClearTimeout;\n          }\n        } catch (e) {\n          n = defaultClearTimeout;\n        }\n      })();\n\n      function runTimeout(e) {\n        if (r === setTimeout) {\n          return setTimeout(e, 0);\n        }\n\n        if ((r === defaultSetTimout || !r) && setTimeout) {\n          r = setTimeout;\n          return setTimeout(e, 0);\n        }\n\n        try {\n          return r(e, 0);\n        } catch (t) {\n          try {\n            return r.call(null, e, 0);\n          } catch (t) {\n            return r.call(this, e, 0);\n          }\n        }\n      }\n\n      function runClearTimeout(e) {\n        if (n === clearTimeout) {\n          return clearTimeout(e);\n        }\n\n        if ((n === defaultClearTimeout || !n) && clearTimeout) {\n          n = clearTimeout;\n          return clearTimeout(e);\n        }\n\n        try {\n          return n(e);\n        } catch (t) {\n          try {\n            return n.call(null, e);\n          } catch (t) {\n            return n.call(this, e);\n          }\n        }\n      }\n\n      var i = [];\n      var o = false;\n      var u;\n      var a = -1;\n\n      function cleanUpNextTick() {\n        if (!o || !u) {\n          return;\n        }\n\n        o = false;\n\n        if (u.length) {\n          i = u.concat(i);\n        } else {\n          a = -1;\n        }\n\n        if (i.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (o) {\n          return;\n        }\n\n        var e = runTimeout(cleanUpNextTick);\n        o = true;\n        var t = i.length;\n\n        while (t) {\n          u = i;\n          i = [];\n\n          while (++a < t) {\n            if (u) {\n              u[a].run();\n            }\n          }\n\n          a = -1;\n          t = i.length;\n        }\n\n        u = null;\n        o = false;\n        runClearTimeout(e);\n      }\n\n      t.nextTick = function (e) {\n        var t = new Array(arguments.length - 1);\n\n        if (arguments.length > 1) {\n          for (var r = 1; r < arguments.length; r++) {\n            t[r - 1] = arguments[r];\n          }\n        }\n\n        i.push(new Item(e, t));\n\n        if (i.length === 1 && !o) {\n          runTimeout(drainQueue);\n        }\n      };\n\n      function Item(e, t) {\n        this.fun = e;\n        this.array = t;\n      }\n\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n\n      t.title = \"browser\";\n      t.browser = true;\n      t.env = {};\n      t.argv = [];\n      t.version = \"\";\n      t.versions = {};\n\n      function noop() {}\n\n      t.on = noop;\n      t.addListener = noop;\n      t.once = noop;\n      t.off = noop;\n      t.removeListener = noop;\n      t.removeAllListeners = noop;\n      t.emit = noop;\n      t.prependListener = noop;\n      t.prependOnceListener = noop;\n\n      t.listeners = function (e) {\n        return [];\n      };\n\n      t.binding = function (e) {\n        throw new Error(\"process.binding is not supported\");\n      };\n\n      t.cwd = function () {\n        return \"/\";\n      };\n\n      t.chdir = function (e) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n\n      t.umask = function () {\n        return 0;\n      };\n    }\n  };\n  var t = {};\n\n  function __nccwpck_require__(r) {\n    var n = t[r];\n\n    if (n !== undefined) {\n      return n.exports;\n    }\n\n    var i = t[r] = {\n      exports: {}\n    };\n    var o = true;\n\n    try {\n      e[r](i, i.exports, __nccwpck_require__);\n      o = false;\n    } finally {\n      if (o) delete t[r];\n    }\n\n    return i.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var r = __nccwpck_require__(229);\n\n  module.exports = r;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsQ0FBQyxZQUFVO0VBQUMsSUFBSUEsQ0FBQyxHQUFDO0lBQUMsS0FBSSxVQUFTQSxDQUFULEVBQVc7TUFBQyxJQUFJQyxDQUFDLEdBQUNELENBQUMsQ0FBQ0UsT0FBRixHQUFVLEVBQWhCO01BQW1CLElBQUlDLENBQUo7TUFBTSxJQUFJQyxDQUFKOztNQUFNLFNBQVNDLGdCQUFULEdBQTJCO1FBQUMsTUFBTSxJQUFJQyxLQUFKLENBQVUsaUNBQVYsQ0FBTjtNQUFtRDs7TUFBQSxTQUFTQyxtQkFBVCxHQUE4QjtRQUFDLE1BQU0sSUFBSUQsS0FBSixDQUFVLG1DQUFWLENBQU47TUFBcUQ7O01BQUEsQ0FBQyxZQUFVO1FBQUMsSUFBRztVQUFDLElBQUcsT0FBT0UsVUFBUCxLQUFvQixVQUF2QixFQUFrQztZQUFDTCxDQUFDLEdBQUNLLFVBQUY7VUFBYSxDQUFoRCxNQUFvRDtZQUFDTCxDQUFDLEdBQUNFLGdCQUFGO1VBQW1CO1FBQUMsQ0FBN0UsQ0FBNkUsT0FBTUwsQ0FBTixFQUFRO1VBQUNHLENBQUMsR0FBQ0UsZ0JBQUY7UUFBbUI7O1FBQUEsSUFBRztVQUFDLElBQUcsT0FBT0ksWUFBUCxLQUFzQixVQUF6QixFQUFvQztZQUFDTCxDQUFDLEdBQUNLLFlBQUY7VUFBZSxDQUFwRCxNQUF3RDtZQUFDTCxDQUFDLEdBQUNHLG1CQUFGO1VBQXNCO1FBQUMsQ0FBcEYsQ0FBb0YsT0FBTVAsQ0FBTixFQUFRO1VBQUNJLENBQUMsR0FBQ0csbUJBQUY7UUFBc0I7TUFBQyxDQUF6Tzs7TUFBNk8sU0FBU0csVUFBVCxDQUFvQlYsQ0FBcEIsRUFBc0I7UUFBQyxJQUFHRyxDQUFDLEtBQUdLLFVBQVAsRUFBa0I7VUFBQyxPQUFPQSxVQUFVLENBQUNSLENBQUQsRUFBRyxDQUFILENBQWpCO1FBQXVCOztRQUFBLElBQUcsQ0FBQ0csQ0FBQyxLQUFH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SUFBaUI7O0lBQUEsSUFBSVcsQ0FBQyxHQUFDWixDQUFDLENBQUNFLENBQUQsQ0FBRCxHQUFLO01BQUNELE9BQU8sRUFBQztJQUFULENBQVg7SUFBd0IsSUFBSVksQ0FBQyxHQUFDLElBQU47O0lBQVcsSUFBRztNQUFDZCxDQUFDLENBQUNHLENBQUQsQ0FBRCxDQUFLVSxDQUFMLEVBQU9BLENBQUMsQ0FBQ1gsT0FBVCxFQUFpQmtELG1CQUFqQjtNQUFzQ3RDLENBQUMsR0FBQyxLQUFGO0lBQVEsQ0FBbEQsU0FBeUQ7TUFBQyxJQUFHQSxDQUFILEVBQUssT0FBT2IsQ0FBQyxDQUFDRSxDQUFELENBQVI7SUFBWTs7SUFBQSxPQUFPVSxDQUFDLENBQUNYLE9BQVQ7RUFBaUI7O0VBQUEsSUFBRyxPQUFPa0QsbUJBQVAsS0FBNkIsV0FBaEMsRUFBNENBLG1CQUFtQixDQUFDRSxFQUFwQixHQUF1QkMsU0FBUyxHQUFDLEdBQWpDOztFQUFxQyxJQUFJcEQsQ0FBQyxHQUFDaUQsbUJBQW1CLENBQUMsR0FBRCxDQUF6Qjs7RUFBK0JJLE1BQU0sQ0FBQ3RELE9BQVAsR0FBZUMsQ0FBZjtBQUFpQixDQUF0NEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanM/MWIxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17MjI5OmZ1bmN0aW9uKGUpe3ZhciB0PWUuZXhwb3J0cz17fTt2YXIgcjt2YXIgbjtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfShmdW5jdGlvbigpe3RyeXtpZih0eXBlb2Ygc2V0VGltZW91dD09PVwiZnVuY3Rpb25cIil7cj1zZXRUaW1lb3V0fWVsc2V7cj1kZWZhdWx0U2V0VGltb3V0fX1jYXRjaChlKXtyPWRlZmF1bHRTZXRUaW1vdXR9dHJ5e2lmKHR5cGVvZiBjbGVhclRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe249Y2xlYXJUaW1lb3V0fWVsc2V7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX1jYXRjaChlKXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fSkoKTtmdW5jdGlvbiBydW5UaW1lb3V0KGUpe2lmKHI9PT1zZXRUaW1lb3V0KXtyZXR1cm4gc2V0VGltZW91dChlLDApfWlmKChyPT09ZGVmYXVsdFNldFRpbW91dHx8IXIpJiZzZXRUaW1lb3V0KXtyPXNldFRpbWVvdXQ7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX10cnl7cmV0dXJuIHIoZSwwKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUsMCl9Y2F0Y2godCl7cmV0dXJuIHIuY2FsbCh0aGlzLGUsMCl9fX1mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQoZSl7aWYobj09PWNsZWFyVGltZW91dCl7cmV0dXJuIGNsZWFyVGltZW91dChlKX1pZigobj09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCFuKSYmY2xlYXJUaW1lb3V0KXtuPWNsZWFyVGltZW91dDtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfXRyeXtyZXR1cm4gbihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlKX19fXZhciBpPVtdO3ZhciBvPWZhbHNlO3ZhciB1O3ZhciBhPS0xO2Z1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpe2lmKCFvfHwhdSl7cmV0dXJufW89ZmFsc2U7aWYodS5sZW5ndGgpe2k9dS5jb25jYXQoaSl9ZWxzZXthPS0xfWlmKGkubGVuZ3RoKXtkcmFpblF1ZXVlKCl9fWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZihvKXtyZXR1cm59dmFyIGU9cnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO289dHJ1ZTt2YXIgdD1pLmxlbmd0aDt3aGlsZSh0KXt1PWk7aT1bXTt3aGlsZSgrK2E8dCl7aWYodSl7dVthXS5ydW4oKX19YT0tMTt0PWkubGVuZ3RofXU9bnVsbDtvPWZhbHNlO3J1bkNsZWFyVGltZW91dChlKX10Lm5leHRUaWNrPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dFtyLTFdPWFyZ3VtZW50c1tyXX19aS5wdXNoKG5ldyBJdGVtKGUsdCkpO2lmKGkubGVuZ3RoPT09MSYmIW8pe3J1blRpbWVvdXQoZHJhaW5RdWV1ZSl9fTtmdW5jdGlvbiBJdGVtKGUsdCl7dGhpcy5mdW49ZTt0aGlzLmFycmF5PXR9SXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX07dC50aXRsZT1cImJyb3dzZXJcIjt0LmJyb3dzZXI9dHJ1ZTt0LmVudj17fTt0LmFyZ3Y9W107dC52ZXJzaW9uPVwiXCI7dC52ZXJzaW9ucz17fTtmdW5jdGlvbiBub29wKCl7fXQub249bm9vcDt0LmFkZExpc3RlbmVyPW5vb3A7dC5vbmNlPW5vb3A7dC5vZmY9bm9vcDt0LnJlbW92ZUxpc3RlbmVyPW5vb3A7dC5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDt0LmVtaXQ9bm9vcDt0LnByZXBlbmRMaXN0ZW5lcj1ub29wO3QucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wO3QubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybltdfTt0LmJpbmRpbmc9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3QuY2hkaXI9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGk9dFtyXT17ZXhwb3J0czp7fX07dmFyIG89dHJ1ZTt0cnl7ZVtyXShpLGkuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtvPWZhbHNlfWZpbmFsbHl7aWYobylkZWxldGUgdFtyXX1yZXR1cm4gaS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj1fX25jY3dwY2tfcmVxdWlyZV9fKDIyOSk7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbImUiLCJ0IiwiZXhwb3J0cyIsInIiLCJuIiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiY2FsbCIsInJ1bkNsZWFyVGltZW91dCIsImkiLCJvIiwidSIsImEiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwicnVuIiwibmV4dFRpY2siLCJBcnJheSIsImFyZ3VtZW50cyIsInB1c2giLCJJdGVtIiwiZnVuIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwidW5kZWZpbmVkIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/util/util.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/compiled/util/util.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n(function () {\n  var r = {\n    992: function (r) {\n      r.exports = function (r, t, n) {\n        if (r.filter) return r.filter(t, n);\n        if (void 0 === r || null === r) throw new TypeError();\n        if (\"function\" != typeof t) throw new TypeError();\n        var o = [];\n\n        for (var i = 0; i < r.length; i++) {\n          if (!e.call(r, i)) continue;\n          var a = r[i];\n          if (t.call(n, a, i, r)) o.push(a);\n        }\n\n        return o;\n      };\n\n      var e = Object.prototype.hasOwnProperty;\n    },\n    256: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(838);\n      var o = t(139);\n      var i = o(n(\"String.prototype.indexOf\"));\n\n      r.exports = function callBoundIntrinsic(r, e) {\n        var t = n(r, !!e);\n\n        if (typeof t === \"function\" && i(r, \".prototype.\") > -1) {\n          return o(t);\n        }\n\n        return t;\n      };\n    },\n    139: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(174);\n      var o = t(838);\n      var i = o(\"%Function.prototype.apply%\");\n      var a = o(\"%Function.prototype.call%\");\n      var f = o(\"%Reflect.apply%\", true) || n.call(a, i);\n      var u = o(\"%Object.getOwnPropertyDescriptor%\", true);\n      var s = o(\"%Object.defineProperty%\", true);\n      var y = o(\"%Math.max%\");\n\n      if (s) {\n        try {\n          s({}, \"a\", {\n            value: 1\n          });\n        } catch (r) {\n          s = null;\n        }\n      }\n\n      r.exports = function callBind(r) {\n        var e = f(n, a, arguments);\n\n        if (u && s) {\n          var t = u(e, \"length\");\n\n          if (t.configurable) {\n            s(e, \"length\", {\n              value: 1 + y(0, r.length - (arguments.length - 1))\n            });\n          }\n        }\n\n        return e;\n      };\n\n      var c = function applyBind() {\n        return f(n, i, arguments);\n      };\n\n      if (s) {\n        s(r.exports, \"apply\", {\n          value: c\n        });\n      } else {\n        r.exports.apply = c;\n      }\n    },\n    144: function (r) {\n      var e = Object.prototype.hasOwnProperty;\n      var t = Object.prototype.toString;\n\n      r.exports = function forEach(r, n, o) {\n        if (t.call(n) !== \"[object Function]\") {\n          throw new TypeError(\"iterator must be a function\");\n        }\n\n        var i = r.length;\n\n        if (i === +i) {\n          for (var a = 0; a < i; a++) {\n            n.call(o, r[a], a, r);\n          }\n        } else {\n          for (var f in r) {\n            if (e.call(r, f)) {\n              n.call(o, r[f], f, r);\n            }\n          }\n        }\n      };\n    },\n    426: function (r) {\n      \"use strict\";\n\n      var e = \"Function.prototype.bind called on incompatible \";\n      var t = Array.prototype.slice;\n      var n = Object.prototype.toString;\n      var o = \"[object Function]\";\n\n      r.exports = function bind(r) {\n        var i = this;\n\n        if (typeof i !== \"function\" || n.call(i) !== o) {\n          throw new TypeError(e + i);\n        }\n\n        var a = t.call(arguments, 1);\n        var f;\n\n        var binder = function () {\n          if (this instanceof f) {\n            var e = i.apply(this, a.concat(t.call(arguments)));\n\n            if (Object(e) === e) {\n              return e;\n            }\n\n            return this;\n          } else {\n            return i.apply(r, a.concat(t.call(arguments)));\n          }\n        };\n\n        var u = Math.max(0, i.length - a.length);\n        var s = [];\n\n        for (var y = 0; y < u; y++) {\n          s.push(\"$\" + y);\n        }\n\n        f = Function(\"binder\", \"return function (\" + s.join(\",\") + \"){ return binder.apply(this,arguments); }\")(binder);\n\n        if (i.prototype) {\n          var c = function Empty() {};\n\n          c.prototype = i.prototype;\n          f.prototype = new c();\n          c.prototype = null;\n        }\n\n        return f;\n      };\n    },\n    174: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(426);\n      r.exports = Function.prototype.bind || n;\n    },\n    838: function (r, e, t) {\n      \"use strict\";\n\n      var n;\n      var o = SyntaxError;\n      var i = Function;\n      var a = TypeError;\n\n      var getEvalledConstructor = function (r) {\n        try {\n          return i('\"use strict\"; return (' + r + \").constructor;\")();\n        } catch (r) {}\n      };\n\n      var f = Object.getOwnPropertyDescriptor;\n\n      if (f) {\n        try {\n          f({}, \"\");\n        } catch (r) {\n          f = null;\n        }\n      }\n\n      var throwTypeError = function () {\n        throw new a();\n      };\n\n      var u = f ? function () {\n        try {\n          arguments.callee;\n          return throwTypeError;\n        } catch (r) {\n          try {\n            return f(arguments, \"callee\").get;\n          } catch (r) {\n            return throwTypeError;\n          }\n        }\n      }() : throwTypeError;\n      var s = t(115)();\n\n      var y = Object.getPrototypeOf || function (r) {\n        return r.__proto__;\n      };\n\n      var c = {};\n      var p = typeof Uint8Array === \"undefined\" ? n : y(Uint8Array);\n      var l = {\n        \"%AggregateError%\": typeof AggregateError === \"undefined\" ? n : AggregateError,\n        \"%Array%\": Array,\n        \"%ArrayBuffer%\": typeof ArrayBuffer === \"undefined\" ? n : ArrayBuffer,\n        \"%ArrayIteratorPrototype%\": s ? y([][Symbol.iterator]()) : n,\n        \"%AsyncFromSyncIteratorPrototype%\": n,\n        \"%AsyncFunction%\": c,\n        \"%AsyncGenerator%\": c,\n        \"%AsyncGeneratorFunction%\": c,\n        \"%AsyncIteratorPrototype%\": c,\n        \"%Atomics%\": typeof Atomics === \"undefined\" ? n : Atomics,\n        \"%BigInt%\": typeof BigInt === \"undefined\" ? n : BigInt,\n        \"%Boolean%\": Boolean,\n        \"%DataView%\": typeof DataView === \"undefined\" ? n : DataView,\n        \"%Date%\": Date,\n        \"%decodeURI%\": decodeURI,\n        \"%decodeURIComponent%\": decodeURIComponent,\n        \"%encodeURI%\": encodeURI,\n        \"%encodeURIComponent%\": encodeURIComponent,\n        \"%Error%\": Error,\n        \"%eval%\": eval,\n        \"%EvalError%\": EvalError,\n        \"%Float32Array%\": typeof Float32Array === \"undefined\" ? n : Float32Array,\n        \"%Float64Array%\": typeof Float64Array === \"undefined\" ? n : Float64Array,\n        \"%FinalizationRegistry%\": typeof FinalizationRegistry === \"undefined\" ? n : FinalizationRegistry,\n        \"%Function%\": i,\n        \"%GeneratorFunction%\": c,\n        \"%Int8Array%\": typeof Int8Array === \"undefined\" ? n : Int8Array,\n        \"%Int16Array%\": typeof Int16Array === \"undefined\" ? n : Int16Array,\n        \"%Int32Array%\": typeof Int32Array === \"undefined\" ? n : Int32Array,\n        \"%isFinite%\": isFinite,\n        \"%isNaN%\": isNaN,\n        \"%IteratorPrototype%\": s ? y(y([][Symbol.iterator]())) : n,\n        \"%JSON%\": typeof JSON === \"object\" ? JSON : n,\n        \"%Map%\": typeof Map === \"undefined\" ? n : Map,\n        \"%MapIteratorPrototype%\": typeof Map === \"undefined\" || !s ? n : y(new Map()[Symbol.iterator]()),\n        \"%Math%\": Math,\n        \"%Number%\": Number,\n        \"%Object%\": Object,\n        \"%parseFloat%\": parseFloat,\n        \"%parseInt%\": parseInt,\n        \"%Promise%\": typeof Promise === \"undefined\" ? n : Promise,\n        \"%Proxy%\": typeof Proxy === \"undefined\" ? n : Proxy,\n        \"%RangeError%\": RangeError,\n        \"%ReferenceError%\": ReferenceError,\n        \"%Reflect%\": typeof Reflect === \"undefined\" ? n : Reflect,\n        \"%RegExp%\": RegExp,\n        \"%Set%\": typeof Set === \"undefined\" ? n : Set,\n        \"%SetIteratorPrototype%\": typeof Set === \"undefined\" || !s ? n : y(new Set()[Symbol.iterator]()),\n        \"%SharedArrayBuffer%\": typeof SharedArrayBuffer === \"undefined\" ? n : SharedArrayBuffer,\n        \"%String%\": String,\n        \"%StringIteratorPrototype%\": s ? y(\"\"[Symbol.iterator]()) : n,\n        \"%Symbol%\": s ? Symbol : n,\n        \"%SyntaxError%\": o,\n        \"%ThrowTypeError%\": u,\n        \"%TypedArray%\": p,\n        \"%TypeError%\": a,\n        \"%Uint8Array%\": typeof Uint8Array === \"undefined\" ? n : Uint8Array,\n        \"%Uint8ClampedArray%\": typeof Uint8ClampedArray === \"undefined\" ? n : Uint8ClampedArray,\n        \"%Uint16Array%\": typeof Uint16Array === \"undefined\" ? n : Uint16Array,\n        \"%Uint32Array%\": typeof Uint32Array === \"undefined\" ? n : Uint32Array,\n        \"%URIError%\": URIError,\n        \"%WeakMap%\": typeof WeakMap === \"undefined\" ? n : WeakMap,\n        \"%WeakRef%\": typeof WeakRef === \"undefined\" ? n : WeakRef,\n        \"%WeakSet%\": typeof WeakSet === \"undefined\" ? n : WeakSet\n      };\n\n      var g = function doEval(r) {\n        var e;\n\n        if (r === \"%AsyncFunction%\") {\n          e = getEvalledConstructor(\"async function () {}\");\n        } else if (r === \"%GeneratorFunction%\") {\n          e = getEvalledConstructor(\"function* () {}\");\n        } else if (r === \"%AsyncGeneratorFunction%\") {\n          e = getEvalledConstructor(\"async function* () {}\");\n        } else if (r === \"%AsyncGenerator%\") {\n          var t = doEval(\"%AsyncGeneratorFunction%\");\n\n          if (t) {\n            e = t.prototype;\n          }\n        } else if (r === \"%AsyncIteratorPrototype%\") {\n          var n = doEval(\"%AsyncGenerator%\");\n\n          if (n) {\n            e = y(n.prototype);\n          }\n        }\n\n        l[r] = e;\n        return e;\n      };\n\n      var b = {\n        \"%ArrayBufferPrototype%\": [\"ArrayBuffer\", \"prototype\"],\n        \"%ArrayPrototype%\": [\"Array\", \"prototype\"],\n        \"%ArrayProto_entries%\": [\"Array\", \"prototype\", \"entries\"],\n        \"%ArrayProto_forEach%\": [\"Array\", \"prototype\", \"forEach\"],\n        \"%ArrayProto_keys%\": [\"Array\", \"prototype\", \"keys\"],\n        \"%ArrayProto_values%\": [\"Array\", \"prototype\", \"values\"],\n        \"%AsyncFunctionPrototype%\": [\"AsyncFunction\", \"prototype\"],\n        \"%AsyncGenerator%\": [\"AsyncGeneratorFunction\", \"prototype\"],\n        \"%AsyncGeneratorPrototype%\": [\"AsyncGeneratorFunction\", \"prototype\", \"prototype\"],\n        \"%BooleanPrototype%\": [\"Boolean\", \"prototype\"],\n        \"%DataViewPrototype%\": [\"DataView\", \"prototype\"],\n        \"%DatePrototype%\": [\"Date\", \"prototype\"],\n        \"%ErrorPrototype%\": [\"Error\", \"prototype\"],\n        \"%EvalErrorPrototype%\": [\"EvalError\", \"prototype\"],\n        \"%Float32ArrayPrototype%\": [\"Float32Array\", \"prototype\"],\n        \"%Float64ArrayPrototype%\": [\"Float64Array\", \"prototype\"],\n        \"%FunctionPrototype%\": [\"Function\", \"prototype\"],\n        \"%Generator%\": [\"GeneratorFunction\", \"prototype\"],\n        \"%GeneratorPrototype%\": [\"GeneratorFunction\", \"prototype\", \"prototype\"],\n        \"%Int8ArrayPrototype%\": [\"Int8Array\", \"prototype\"],\n        \"%Int16ArrayPrototype%\": [\"Int16Array\", \"prototype\"],\n        \"%Int32ArrayPrototype%\": [\"Int32Array\", \"prototype\"],\n        \"%JSONParse%\": [\"JSON\", \"parse\"],\n        \"%JSONStringify%\": [\"JSON\", \"stringify\"],\n        \"%MapPrototype%\": [\"Map\", \"prototype\"],\n        \"%NumberPrototype%\": [\"Number\", \"prototype\"],\n        \"%ObjectPrototype%\": [\"Object\", \"prototype\"],\n        \"%ObjProto_toString%\": [\"Object\", \"prototype\", \"toString\"],\n        \"%ObjProto_valueOf%\": [\"Object\", \"prototype\", \"valueOf\"],\n        \"%PromisePrototype%\": [\"Promise\", \"prototype\"],\n        \"%PromiseProto_then%\": [\"Promise\", \"prototype\", \"then\"],\n        \"%Promise_all%\": [\"Promise\", \"all\"],\n        \"%Promise_reject%\": [\"Promise\", \"reject\"],\n        \"%Promise_resolve%\": [\"Promise\", \"resolve\"],\n        \"%RangeErrorPrototype%\": [\"RangeError\", \"prototype\"],\n        \"%ReferenceErrorPrototype%\": [\"ReferenceError\", \"prototype\"],\n        \"%RegExpPrototype%\": [\"RegExp\", \"prototype\"],\n        \"%SetPrototype%\": [\"Set\", \"prototype\"],\n        \"%SharedArrayBufferPrototype%\": [\"SharedArrayBuffer\", \"prototype\"],\n        \"%StringPrototype%\": [\"String\", \"prototype\"],\n        \"%SymbolPrototype%\": [\"Symbol\", \"prototype\"],\n        \"%SyntaxErrorPrototype%\": [\"SyntaxError\", \"prototype\"],\n        \"%TypedArrayPrototype%\": [\"TypedArray\", \"prototype\"],\n        \"%TypeErrorPrototype%\": [\"TypeError\", \"prototype\"],\n        \"%Uint8ArrayPrototype%\": [\"Uint8Array\", \"prototype\"],\n        \"%Uint8ClampedArrayPrototype%\": [\"Uint8ClampedArray\", \"prototype\"],\n        \"%Uint16ArrayPrototype%\": [\"Uint16Array\", \"prototype\"],\n        \"%Uint32ArrayPrototype%\": [\"Uint32Array\", \"prototype\"],\n        \"%URIErrorPrototype%\": [\"URIError\", \"prototype\"],\n        \"%WeakMapPrototype%\": [\"WeakMap\", \"prototype\"],\n        \"%WeakSetPrototype%\": [\"WeakSet\", \"prototype\"]\n      };\n      var d = t(174);\n      var v = t(101);\n      var m = d.call(Function.call, Array.prototype.concat);\n      var S = d.call(Function.apply, Array.prototype.splice);\n      var A = d.call(Function.call, String.prototype.replace);\n      var h = d.call(Function.call, String.prototype.slice);\n      var O = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\n      var j = /\\\\(\\\\)?/g;\n\n      var w = function stringToPath(r) {\n        var e = h(r, 0, 1);\n        var t = h(r, -1);\n\n        if (e === \"%\" && t !== \"%\") {\n          throw new o(\"invalid intrinsic syntax, expected closing `%`\");\n        } else if (t === \"%\" && e !== \"%\") {\n          throw new o(\"invalid intrinsic syntax, expected opening `%`\");\n        }\n\n        var n = [];\n        A(r, O, function (r, e, t, o) {\n          n[n.length] = t ? A(o, j, \"$1\") : e || r;\n        });\n        return n;\n      };\n\n      var P = function getBaseIntrinsic(r, e) {\n        var t = r;\n        var n;\n\n        if (v(b, t)) {\n          n = b[t];\n          t = \"%\" + n[0] + \"%\";\n        }\n\n        if (v(l, t)) {\n          var i = l[t];\n\n          if (i === c) {\n            i = g(t);\n          }\n\n          if (typeof i === \"undefined\" && !e) {\n            throw new a(\"intrinsic \" + r + \" exists, but is not available. Please file an issue!\");\n          }\n\n          return {\n            alias: n,\n            name: t,\n            value: i\n          };\n        }\n\n        throw new o(\"intrinsic \" + r + \" does not exist!\");\n      };\n\n      r.exports = function GetIntrinsic(r, e) {\n        if (typeof r !== \"string\" || r.length === 0) {\n          throw new a(\"intrinsic name must be a non-empty string\");\n        }\n\n        if (arguments.length > 1 && typeof e !== \"boolean\") {\n          throw new a('\"allowMissing\" argument must be a boolean');\n        }\n\n        var t = w(r);\n        var i = t.length > 0 ? t[0] : \"\";\n        var u = P(\"%\" + i + \"%\", e);\n        var s = u.name;\n        var y = u.value;\n        var c = false;\n        var p = u.alias;\n\n        if (p) {\n          i = p[0];\n          S(t, m([0, 1], p));\n        }\n\n        for (var g = 1, b = true; g < t.length; g += 1) {\n          var d = t[g];\n          var A = h(d, 0, 1);\n          var O = h(d, -1);\n\n          if ((A === '\"' || A === \"'\" || A === \"`\" || O === '\"' || O === \"'\" || O === \"`\") && A !== O) {\n            throw new o(\"property names with quotes must have matching quotes\");\n          }\n\n          if (d === \"constructor\" || !b) {\n            c = true;\n          }\n\n          i += \".\" + d;\n          s = \"%\" + i + \"%\";\n\n          if (v(l, s)) {\n            y = l[s];\n          } else if (y != null) {\n            if (!(d in y)) {\n              if (!e) {\n                throw new a(\"base intrinsic for \" + r + \" exists, but the property is not available.\");\n              }\n\n              return void n;\n            }\n\n            if (f && g + 1 >= t.length) {\n              var j = f(y, d);\n              b = !!j;\n\n              if (b && \"get\" in j && !(\"originalValue\" in j.get)) {\n                y = j.get;\n              } else {\n                y = y[d];\n              }\n            } else {\n              b = v(y, d);\n              y = y[d];\n            }\n\n            if (b && !c) {\n              l[s] = y;\n            }\n          }\n        }\n\n        return y;\n      };\n    },\n    942: function (r, e, t) {\n      \"use strict\";\n\n      var n = typeof Symbol !== \"undefined\" && Symbol;\n      var o = t(773);\n\n      r.exports = function hasNativeSymbols() {\n        if (typeof n !== \"function\") {\n          return false;\n        }\n\n        if (typeof Symbol !== \"function\") {\n          return false;\n        }\n\n        if (typeof n(\"foo\") !== \"symbol\") {\n          return false;\n        }\n\n        if (typeof Symbol(\"bar\") !== \"symbol\") {\n          return false;\n        }\n\n        return o();\n      };\n    },\n    773: function (r) {\n      \"use strict\";\n\n      r.exports = function hasSymbols() {\n        if (typeof Symbol !== \"function\" || typeof Object.getOwnPropertySymbols !== \"function\") {\n          return false;\n        }\n\n        if (typeof Symbol.iterator === \"symbol\") {\n          return true;\n        }\n\n        var r = {};\n        var e = Symbol(\"test\");\n        var t = Object(e);\n\n        if (typeof e === \"string\") {\n          return false;\n        }\n\n        if (Object.prototype.toString.call(e) !== \"[object Symbol]\") {\n          return false;\n        }\n\n        if (Object.prototype.toString.call(t) !== \"[object Symbol]\") {\n          return false;\n        }\n\n        var n = 42;\n        r[e] = n;\n\n        for (e in r) {\n          return false;\n        }\n\n        if (typeof Object.keys === \"function\" && Object.keys(r).length !== 0) {\n          return false;\n        }\n\n        if (typeof Object.getOwnPropertyNames === \"function\" && Object.getOwnPropertyNames(r).length !== 0) {\n          return false;\n        }\n\n        var o = Object.getOwnPropertySymbols(r);\n\n        if (o.length !== 1 || o[0] !== e) {\n          return false;\n        }\n\n        if (!Object.prototype.propertyIsEnumerable.call(r, e)) {\n          return false;\n        }\n\n        if (typeof Object.getOwnPropertyDescriptor === \"function\") {\n          var i = Object.getOwnPropertyDescriptor(r, e);\n\n          if (i.value !== n || i.enumerable !== true) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n    },\n    115: function (r, e, t) {\n      \"use strict\";\n\n      var n = typeof Symbol !== \"undefined\" && Symbol;\n      var o = t(832);\n\n      r.exports = function hasNativeSymbols() {\n        if (typeof n !== \"function\") {\n          return false;\n        }\n\n        if (typeof Symbol !== \"function\") {\n          return false;\n        }\n\n        if (typeof n(\"foo\") !== \"symbol\") {\n          return false;\n        }\n\n        if (typeof Symbol(\"bar\") !== \"symbol\") {\n          return false;\n        }\n\n        return o();\n      };\n    },\n    832: function (r) {\n      \"use strict\";\n\n      r.exports = function hasSymbols() {\n        if (typeof Symbol !== \"function\" || typeof Object.getOwnPropertySymbols !== \"function\") {\n          return false;\n        }\n\n        if (typeof Symbol.iterator === \"symbol\") {\n          return true;\n        }\n\n        var r = {};\n        var e = Symbol(\"test\");\n        var t = Object(e);\n\n        if (typeof e === \"string\") {\n          return false;\n        }\n\n        if (Object.prototype.toString.call(e) !== \"[object Symbol]\") {\n          return false;\n        }\n\n        if (Object.prototype.toString.call(t) !== \"[object Symbol]\") {\n          return false;\n        }\n\n        var n = 42;\n        r[e] = n;\n\n        for (e in r) {\n          return false;\n        }\n\n        if (typeof Object.keys === \"function\" && Object.keys(r).length !== 0) {\n          return false;\n        }\n\n        if (typeof Object.getOwnPropertyNames === \"function\" && Object.getOwnPropertyNames(r).length !== 0) {\n          return false;\n        }\n\n        var o = Object.getOwnPropertySymbols(r);\n\n        if (o.length !== 1 || o[0] !== e) {\n          return false;\n        }\n\n        if (!Object.prototype.propertyIsEnumerable.call(r, e)) {\n          return false;\n        }\n\n        if (typeof Object.getOwnPropertyDescriptor === \"function\") {\n          var i = Object.getOwnPropertyDescriptor(r, e);\n\n          if (i.value !== n || i.enumerable !== true) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n    },\n    101: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(174);\n      r.exports = n.call(Function.call, Object.prototype.hasOwnProperty);\n    },\n    782: function (r) {\n      if (typeof Object.create === \"function\") {\n        r.exports = function inherits(r, e) {\n          if (e) {\n            r.super_ = e;\n            r.prototype = Object.create(e.prototype, {\n              constructor: {\n                value: r,\n                enumerable: false,\n                writable: true,\n                configurable: true\n              }\n            });\n          }\n        };\n      } else {\n        r.exports = function inherits(r, e) {\n          if (e) {\n            r.super_ = e;\n\n            var TempCtor = function () {};\n\n            TempCtor.prototype = e.prototype;\n            r.prototype = new TempCtor();\n            r.prototype.constructor = r;\n          }\n        };\n      }\n    },\n    157: function (r) {\n      \"use strict\";\n\n      var e = typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\";\n      var t = Object.prototype.toString;\n\n      var n = function isArguments(r) {\n        if (e && r && typeof r === \"object\" && Symbol.toStringTag in r) {\n          return false;\n        }\n\n        return t.call(r) === \"[object Arguments]\";\n      };\n\n      var o = function isArguments(r) {\n        if (n(r)) {\n          return true;\n        }\n\n        return r !== null && typeof r === \"object\" && typeof r.length === \"number\" && r.length >= 0 && t.call(r) !== \"[object Array]\" && t.call(r.callee) === \"[object Function]\";\n      };\n\n      var i = function () {\n        return n(arguments);\n      }();\n\n      n.isLegacyArguments = o;\n      r.exports = i ? n : o;\n    },\n    391: function (r) {\n      \"use strict\";\n\n      var e = Object.prototype.toString;\n      var t = Function.prototype.toString;\n      var n = /^\\s*(?:function)?\\*/;\n      var o = typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\";\n      var i = Object.getPrototypeOf;\n\n      var getGeneratorFunc = function () {\n        if (!o) {\n          return false;\n        }\n\n        try {\n          return Function(\"return function*() {}\")();\n        } catch (r) {}\n      };\n\n      var a = getGeneratorFunc();\n      var f = a ? i(a) : {};\n\n      r.exports = function isGeneratorFunction(r) {\n        if (typeof r !== \"function\") {\n          return false;\n        }\n\n        if (n.test(t.call(r))) {\n          return true;\n        }\n\n        if (!o) {\n          var a = e.call(r);\n          return a === \"[object GeneratorFunction]\";\n        }\n\n        return i(r) === f;\n      };\n    },\n    994: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(144);\n      var o = t(349);\n      var i = t(256);\n      var a = i(\"Object.prototype.toString\");\n      var f = t(942)();\n      var u = f && typeof Symbol.toStringTag === \"symbol\";\n      var s = o();\n\n      var y = i(\"Array.prototype.indexOf\", true) || function indexOf(r, e) {\n        for (var t = 0; t < r.length; t += 1) {\n          if (r[t] === e) {\n            return t;\n          }\n        }\n\n        return -1;\n      };\n\n      var c = i(\"String.prototype.slice\");\n      var p = {};\n      var l = t(466);\n      var g = Object.getPrototypeOf;\n\n      if (u && l && g) {\n        n(s, function (r) {\n          var e = new __webpack_require__.g[r]();\n\n          if (!(Symbol.toStringTag in e)) {\n            throw new EvalError(\"this engine has support for Symbol.toStringTag, but \" + r + \" does not have the property! Please report this.\");\n          }\n\n          var t = g(e);\n          var n = l(t, Symbol.toStringTag);\n\n          if (!n) {\n            var o = g(t);\n            n = l(o, Symbol.toStringTag);\n          }\n\n          p[r] = n.get;\n        });\n      }\n\n      var b = function tryAllTypedArrays(r) {\n        var e = false;\n        n(p, function (t, n) {\n          if (!e) {\n            try {\n              e = t.call(r) === n;\n            } catch (r) {}\n          }\n        });\n        return e;\n      };\n\n      r.exports = function isTypedArray(r) {\n        if (!r || typeof r !== \"object\") {\n          return false;\n        }\n\n        if (!u) {\n          var e = c(a(r), 8, -1);\n          return y(s, e) > -1;\n        }\n\n        if (!l) {\n          return false;\n        }\n\n        return b(r);\n      };\n    },\n    369: function (r) {\n      r.exports = function isBuffer(r) {\n        return r instanceof Buffer;\n      };\n    },\n    584: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(157);\n      var o = t(391);\n      var i = t(490);\n      var a = t(994);\n\n      function uncurryThis(r) {\n        return r.call.bind(r);\n      }\n\n      var f = typeof BigInt !== \"undefined\";\n      var u = typeof Symbol !== \"undefined\";\n      var s = uncurryThis(Object.prototype.toString);\n      var y = uncurryThis(Number.prototype.valueOf);\n      var c = uncurryThis(String.prototype.valueOf);\n      var p = uncurryThis(Boolean.prototype.valueOf);\n\n      if (f) {\n        var l = uncurryThis(BigInt.prototype.valueOf);\n      }\n\n      if (u) {\n        var g = uncurryThis(Symbol.prototype.valueOf);\n      }\n\n      function checkBoxedPrimitive(r, e) {\n        if (typeof r !== \"object\") {\n          return false;\n        }\n\n        try {\n          e(r);\n          return true;\n        } catch (r) {\n          return false;\n        }\n      }\n\n      e.isArgumentsObject = n;\n      e.isGeneratorFunction = o;\n      e.isTypedArray = a;\n\n      function isPromise(r) {\n        return typeof Promise !== \"undefined\" && r instanceof Promise || r !== null && typeof r === \"object\" && typeof r.then === \"function\" && typeof r.catch === \"function\";\n      }\n\n      e.isPromise = isPromise;\n\n      function isArrayBufferView(r) {\n        if (typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView) {\n          return ArrayBuffer.isView(r);\n        }\n\n        return a(r) || isDataView(r);\n      }\n\n      e.isArrayBufferView = isArrayBufferView;\n\n      function isUint8Array(r) {\n        return i(r) === \"Uint8Array\";\n      }\n\n      e.isUint8Array = isUint8Array;\n\n      function isUint8ClampedArray(r) {\n        return i(r) === \"Uint8ClampedArray\";\n      }\n\n      e.isUint8ClampedArray = isUint8ClampedArray;\n\n      function isUint16Array(r) {\n        return i(r) === \"Uint16Array\";\n      }\n\n      e.isUint16Array = isUint16Array;\n\n      function isUint32Array(r) {\n        return i(r) === \"Uint32Array\";\n      }\n\n      e.isUint32Array = isUint32Array;\n\n      function isInt8Array(r) {\n        return i(r) === \"Int8Array\";\n      }\n\n      e.isInt8Array = isInt8Array;\n\n      function isInt16Array(r) {\n        return i(r) === \"Int16Array\";\n      }\n\n      e.isInt16Array = isInt16Array;\n\n      function isInt32Array(r) {\n        return i(r) === \"Int32Array\";\n      }\n\n      e.isInt32Array = isInt32Array;\n\n      function isFloat32Array(r) {\n        return i(r) === \"Float32Array\";\n      }\n\n      e.isFloat32Array = isFloat32Array;\n\n      function isFloat64Array(r) {\n        return i(r) === \"Float64Array\";\n      }\n\n      e.isFloat64Array = isFloat64Array;\n\n      function isBigInt64Array(r) {\n        return i(r) === \"BigInt64Array\";\n      }\n\n      e.isBigInt64Array = isBigInt64Array;\n\n      function isBigUint64Array(r) {\n        return i(r) === \"BigUint64Array\";\n      }\n\n      e.isBigUint64Array = isBigUint64Array;\n\n      function isMapToString(r) {\n        return s(r) === \"[object Map]\";\n      }\n\n      isMapToString.working = typeof Map !== \"undefined\" && isMapToString(new Map());\n\n      function isMap(r) {\n        if (typeof Map === \"undefined\") {\n          return false;\n        }\n\n        return isMapToString.working ? isMapToString(r) : r instanceof Map;\n      }\n\n      e.isMap = isMap;\n\n      function isSetToString(r) {\n        return s(r) === \"[object Set]\";\n      }\n\n      isSetToString.working = typeof Set !== \"undefined\" && isSetToString(new Set());\n\n      function isSet(r) {\n        if (typeof Set === \"undefined\") {\n          return false;\n        }\n\n        return isSetToString.working ? isSetToString(r) : r instanceof Set;\n      }\n\n      e.isSet = isSet;\n\n      function isWeakMapToString(r) {\n        return s(r) === \"[object WeakMap]\";\n      }\n\n      isWeakMapToString.working = typeof WeakMap !== \"undefined\" && isWeakMapToString(new WeakMap());\n\n      function isWeakMap(r) {\n        if (typeof WeakMap === \"undefined\") {\n          return false;\n        }\n\n        return isWeakMapToString.working ? isWeakMapToString(r) : r instanceof WeakMap;\n      }\n\n      e.isWeakMap = isWeakMap;\n\n      function isWeakSetToString(r) {\n        return s(r) === \"[object WeakSet]\";\n      }\n\n      isWeakSetToString.working = typeof WeakSet !== \"undefined\" && isWeakSetToString(new WeakSet());\n\n      function isWeakSet(r) {\n        return isWeakSetToString(r);\n      }\n\n      e.isWeakSet = isWeakSet;\n\n      function isArrayBufferToString(r) {\n        return s(r) === \"[object ArrayBuffer]\";\n      }\n\n      isArrayBufferToString.working = typeof ArrayBuffer !== \"undefined\" && isArrayBufferToString(new ArrayBuffer());\n\n      function isArrayBuffer(r) {\n        if (typeof ArrayBuffer === \"undefined\") {\n          return false;\n        }\n\n        return isArrayBufferToString.working ? isArrayBufferToString(r) : r instanceof ArrayBuffer;\n      }\n\n      e.isArrayBuffer = isArrayBuffer;\n\n      function isDataViewToString(r) {\n        return s(r) === \"[object DataView]\";\n      }\n\n      isDataViewToString.working = typeof ArrayBuffer !== \"undefined\" && typeof DataView !== \"undefined\" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));\n\n      function isDataView(r) {\n        if (typeof DataView === \"undefined\") {\n          return false;\n        }\n\n        return isDataViewToString.working ? isDataViewToString(r) : r instanceof DataView;\n      }\n\n      e.isDataView = isDataView;\n      var b = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : undefined;\n\n      function isSharedArrayBufferToString(r) {\n        return s(r) === \"[object SharedArrayBuffer]\";\n      }\n\n      function isSharedArrayBuffer(r) {\n        if (typeof b === \"undefined\") {\n          return false;\n        }\n\n        if (typeof isSharedArrayBufferToString.working === \"undefined\") {\n          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new b());\n        }\n\n        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(r) : r instanceof b;\n      }\n\n      e.isSharedArrayBuffer = isSharedArrayBuffer;\n\n      function isAsyncFunction(r) {\n        return s(r) === \"[object AsyncFunction]\";\n      }\n\n      e.isAsyncFunction = isAsyncFunction;\n\n      function isMapIterator(r) {\n        return s(r) === \"[object Map Iterator]\";\n      }\n\n      e.isMapIterator = isMapIterator;\n\n      function isSetIterator(r) {\n        return s(r) === \"[object Set Iterator]\";\n      }\n\n      e.isSetIterator = isSetIterator;\n\n      function isGeneratorObject(r) {\n        return s(r) === \"[object Generator]\";\n      }\n\n      e.isGeneratorObject = isGeneratorObject;\n\n      function isWebAssemblyCompiledModule(r) {\n        return s(r) === \"[object WebAssembly.Module]\";\n      }\n\n      e.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\n      function isNumberObject(r) {\n        return checkBoxedPrimitive(r, y);\n      }\n\n      e.isNumberObject = isNumberObject;\n\n      function isStringObject(r) {\n        return checkBoxedPrimitive(r, c);\n      }\n\n      e.isStringObject = isStringObject;\n\n      function isBooleanObject(r) {\n        return checkBoxedPrimitive(r, p);\n      }\n\n      e.isBooleanObject = isBooleanObject;\n\n      function isBigIntObject(r) {\n        return f && checkBoxedPrimitive(r, l);\n      }\n\n      e.isBigIntObject = isBigIntObject;\n\n      function isSymbolObject(r) {\n        return u && checkBoxedPrimitive(r, g);\n      }\n\n      e.isSymbolObject = isSymbolObject;\n\n      function isBoxedPrimitive(r) {\n        return isNumberObject(r) || isStringObject(r) || isBooleanObject(r) || isBigIntObject(r) || isSymbolObject(r);\n      }\n\n      e.isBoxedPrimitive = isBoxedPrimitive;\n\n      function isAnyArrayBuffer(r) {\n        return typeof Uint8Array !== \"undefined\" && (isArrayBuffer(r) || isSharedArrayBuffer(r));\n      }\n\n      e.isAnyArrayBuffer = isAnyArrayBuffer;\n      [\"isProxy\", \"isExternal\", \"isModuleNamespaceObject\"].forEach(function (r) {\n        Object.defineProperty(e, r, {\n          enumerable: false,\n          value: function () {\n            throw new Error(r + \" is not supported in userland\");\n          }\n        });\n      });\n    },\n    177: function (r, e, t) {\n      var n = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(r) {\n        var e = Object.keys(r);\n        var t = {};\n\n        for (var n = 0; n < e.length; n++) {\n          t[e[n]] = Object.getOwnPropertyDescriptor(r, e[n]);\n        }\n\n        return t;\n      };\n\n      var o = /%[sdj%]/g;\n\n      e.format = function (r) {\n        if (!isString(r)) {\n          var e = [];\n\n          for (var t = 0; t < arguments.length; t++) {\n            e.push(inspect(arguments[t]));\n          }\n\n          return e.join(\" \");\n        }\n\n        var t = 1;\n        var n = arguments;\n        var i = n.length;\n        var a = String(r).replace(o, function (r) {\n          if (r === \"%%\") return \"%\";\n          if (t >= i) return r;\n\n          switch (r) {\n            case \"%s\":\n              return String(n[t++]);\n\n            case \"%d\":\n              return Number(n[t++]);\n\n            case \"%j\":\n              try {\n                return JSON.stringify(n[t++]);\n              } catch (r) {\n                return \"[Circular]\";\n              }\n\n            default:\n              return r;\n          }\n        });\n\n        for (var f = n[t]; t < i; f = n[++t]) {\n          if (isNull(f) || !isObject(f)) {\n            a += \" \" + f;\n          } else {\n            a += \" \" + inspect(f);\n          }\n        }\n\n        return a;\n      };\n\n      e.deprecate = function (r, t) {\n        if (typeof process !== \"undefined\" && process.noDeprecation === true) {\n          return r;\n        }\n\n        if (typeof process === \"undefined\") {\n          return function () {\n            return e.deprecate(r, t).apply(this, arguments);\n          };\n        }\n\n        var n = false;\n\n        function deprecated() {\n          if (!n) {\n            if (process.throwDeprecation) {\n              throw new Error(t);\n            } else if (process.traceDeprecation) {\n              console.trace(t);\n            } else {\n              console.error(t);\n            }\n\n            n = true;\n          }\n\n          return r.apply(this, arguments);\n        }\n\n        return deprecated;\n      };\n\n      var i = {};\n      var a = /^$/;\n\n      if (process.env.NODE_DEBUG) {\n        var f = process.env.NODE_DEBUG;\n        f = f.replace(/[|\\\\{}()[\\]^$+?.]/g, \"\\\\$&\").replace(/\\*/g, \".*\").replace(/,/g, \"$|^\").toUpperCase();\n        a = new RegExp(\"^\" + f + \"$\", \"i\");\n      }\n\n      e.debuglog = function (r) {\n        r = r.toUpperCase();\n\n        if (!i[r]) {\n          if (a.test(r)) {\n            var t = process.pid;\n\n            i[r] = function () {\n              var n = e.format.apply(e, arguments);\n              console.error(\"%s %d: %s\", r, t, n);\n            };\n          } else {\n            i[r] = function () {};\n          }\n        }\n\n        return i[r];\n      };\n\n      function inspect(r, t) {\n        var n = {\n          seen: [],\n          stylize: stylizeNoColor\n        };\n        if (arguments.length >= 3) n.depth = arguments[2];\n        if (arguments.length >= 4) n.colors = arguments[3];\n\n        if (isBoolean(t)) {\n          n.showHidden = t;\n        } else if (t) {\n          e._extend(n, t);\n        }\n\n        if (isUndefined(n.showHidden)) n.showHidden = false;\n        if (isUndefined(n.depth)) n.depth = 2;\n        if (isUndefined(n.colors)) n.colors = false;\n        if (isUndefined(n.customInspect)) n.customInspect = true;\n        if (n.colors) n.stylize = stylizeWithColor;\n        return formatValue(n, r, n.depth);\n      }\n\n      e.inspect = inspect;\n      inspect.colors = {\n        bold: [1, 22],\n        italic: [3, 23],\n        underline: [4, 24],\n        inverse: [7, 27],\n        white: [37, 39],\n        grey: [90, 39],\n        black: [30, 39],\n        blue: [34, 39],\n        cyan: [36, 39],\n        green: [32, 39],\n        magenta: [35, 39],\n        red: [31, 39],\n        yellow: [33, 39]\n      };\n      inspect.styles = {\n        special: \"cyan\",\n        number: \"yellow\",\n        boolean: \"yellow\",\n        undefined: \"grey\",\n        null: \"bold\",\n        string: \"green\",\n        date: \"magenta\",\n        regexp: \"red\"\n      };\n\n      function stylizeWithColor(r, e) {\n        var t = inspect.styles[e];\n\n        if (t) {\n          return \"\u001b[\" + inspect.colors[t][0] + \"m\" + r + \"\u001b[\" + inspect.colors[t][1] + \"m\";\n        } else {\n          return r;\n        }\n      }\n\n      function stylizeNoColor(r, e) {\n        return r;\n      }\n\n      function arrayToHash(r) {\n        var e = {};\n        r.forEach(function (r, t) {\n          e[r] = true;\n        });\n        return e;\n      }\n\n      function formatValue(r, t, n) {\n        if (r.customInspect && t && isFunction(t.inspect) && t.inspect !== e.inspect && !(t.constructor && t.constructor.prototype === t)) {\n          var o = t.inspect(n, r);\n\n          if (!isString(o)) {\n            o = formatValue(r, o, n);\n          }\n\n          return o;\n        }\n\n        var i = formatPrimitive(r, t);\n\n        if (i) {\n          return i;\n        }\n\n        var a = Object.keys(t);\n        var f = arrayToHash(a);\n\n        if (r.showHidden) {\n          a = Object.getOwnPropertyNames(t);\n        }\n\n        if (isError(t) && (a.indexOf(\"message\") >= 0 || a.indexOf(\"description\") >= 0)) {\n          return formatError(t);\n        }\n\n        if (a.length === 0) {\n          if (isFunction(t)) {\n            var u = t.name ? \": \" + t.name : \"\";\n            return r.stylize(\"[Function\" + u + \"]\", \"special\");\n          }\n\n          if (isRegExp(t)) {\n            return r.stylize(RegExp.prototype.toString.call(t), \"regexp\");\n          }\n\n          if (isDate(t)) {\n            return r.stylize(Date.prototype.toString.call(t), \"date\");\n          }\n\n          if (isError(t)) {\n            return formatError(t);\n          }\n        }\n\n        var s = \"\",\n            y = false,\n            c = [\"{\", \"}\"];\n\n        if (isArray(t)) {\n          y = true;\n          c = [\"[\", \"]\"];\n        }\n\n        if (isFunction(t)) {\n          var p = t.name ? \": \" + t.name : \"\";\n          s = \" [Function\" + p + \"]\";\n        }\n\n        if (isRegExp(t)) {\n          s = \" \" + RegExp.prototype.toString.call(t);\n        }\n\n        if (isDate(t)) {\n          s = \" \" + Date.prototype.toUTCString.call(t);\n        }\n\n        if (isError(t)) {\n          s = \" \" + formatError(t);\n        }\n\n        if (a.length === 0 && (!y || t.length == 0)) {\n          return c[0] + s + c[1];\n        }\n\n        if (n < 0) {\n          if (isRegExp(t)) {\n            return r.stylize(RegExp.prototype.toString.call(t), \"regexp\");\n          } else {\n            return r.stylize(\"[Object]\", \"special\");\n          }\n        }\n\n        r.seen.push(t);\n        var l;\n\n        if (y) {\n          l = formatArray(r, t, n, f, a);\n        } else {\n          l = a.map(function (e) {\n            return formatProperty(r, t, n, f, e, y);\n          });\n        }\n\n        r.seen.pop();\n        return reduceToSingleString(l, s, c);\n      }\n\n      function formatPrimitive(r, e) {\n        if (isUndefined(e)) return r.stylize(\"undefined\", \"undefined\");\n\n        if (isString(e)) {\n          var t = \"'\" + JSON.stringify(e).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n          return r.stylize(t, \"string\");\n        }\n\n        if (isNumber(e)) return r.stylize(\"\" + e, \"number\");\n        if (isBoolean(e)) return r.stylize(\"\" + e, \"boolean\");\n        if (isNull(e)) return r.stylize(\"null\", \"null\");\n      }\n\n      function formatError(r) {\n        return \"[\" + Error.prototype.toString.call(r) + \"]\";\n      }\n\n      function formatArray(r, e, t, n, o) {\n        var i = [];\n\n        for (var a = 0, f = e.length; a < f; ++a) {\n          if (hasOwnProperty(e, String(a))) {\n            i.push(formatProperty(r, e, t, n, String(a), true));\n          } else {\n            i.push(\"\");\n          }\n        }\n\n        o.forEach(function (o) {\n          if (!o.match(/^\\d+$/)) {\n            i.push(formatProperty(r, e, t, n, o, true));\n          }\n        });\n        return i;\n      }\n\n      function formatProperty(r, e, t, n, o, i) {\n        var a, f, u;\n        u = Object.getOwnPropertyDescriptor(e, o) || {\n          value: e[o]\n        };\n\n        if (u.get) {\n          if (u.set) {\n            f = r.stylize(\"[Getter/Setter]\", \"special\");\n          } else {\n            f = r.stylize(\"[Getter]\", \"special\");\n          }\n        } else {\n          if (u.set) {\n            f = r.stylize(\"[Setter]\", \"special\");\n          }\n        }\n\n        if (!hasOwnProperty(n, o)) {\n          a = \"[\" + o + \"]\";\n        }\n\n        if (!f) {\n          if (r.seen.indexOf(u.value) < 0) {\n            if (isNull(t)) {\n              f = formatValue(r, u.value, null);\n            } else {\n              f = formatValue(r, u.value, t - 1);\n            }\n\n            if (f.indexOf(\"\\n\") > -1) {\n              if (i) {\n                f = f.split(\"\\n\").map(function (r) {\n                  return \"  \" + r;\n                }).join(\"\\n\").substr(2);\n              } else {\n                f = \"\\n\" + f.split(\"\\n\").map(function (r) {\n                  return \"   \" + r;\n                }).join(\"\\n\");\n              }\n            }\n          } else {\n            f = r.stylize(\"[Circular]\", \"special\");\n          }\n        }\n\n        if (isUndefined(a)) {\n          if (i && o.match(/^\\d+$/)) {\n            return f;\n          }\n\n          a = JSON.stringify(\"\" + o);\n\n          if (a.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n            a = a.substr(1, a.length - 2);\n            a = r.stylize(a, \"name\");\n          } else {\n            a = a.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n            a = r.stylize(a, \"string\");\n          }\n        }\n\n        return a + \": \" + f;\n      }\n\n      function reduceToSingleString(r, e, t) {\n        var n = 0;\n        var o = r.reduce(function (r, e) {\n          n++;\n          if (e.indexOf(\"\\n\") >= 0) n++;\n          return r + e.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n        }, 0);\n\n        if (o > 60) {\n          return t[0] + (e === \"\" ? \"\" : e + \"\\n \") + \" \" + r.join(\",\\n  \") + \" \" + t[1];\n        }\n\n        return t[0] + e + \" \" + r.join(\", \") + \" \" + t[1];\n      }\n\n      e.types = t(584);\n\n      function isArray(r) {\n        return Array.isArray(r);\n      }\n\n      e.isArray = isArray;\n\n      function isBoolean(r) {\n        return typeof r === \"boolean\";\n      }\n\n      e.isBoolean = isBoolean;\n\n      function isNull(r) {\n        return r === null;\n      }\n\n      e.isNull = isNull;\n\n      function isNullOrUndefined(r) {\n        return r == null;\n      }\n\n      e.isNullOrUndefined = isNullOrUndefined;\n\n      function isNumber(r) {\n        return typeof r === \"number\";\n      }\n\n      e.isNumber = isNumber;\n\n      function isString(r) {\n        return typeof r === \"string\";\n      }\n\n      e.isString = isString;\n\n      function isSymbol(r) {\n        return typeof r === \"symbol\";\n      }\n\n      e.isSymbol = isSymbol;\n\n      function isUndefined(r) {\n        return r === void 0;\n      }\n\n      e.isUndefined = isUndefined;\n\n      function isRegExp(r) {\n        return isObject(r) && objectToString(r) === \"[object RegExp]\";\n      }\n\n      e.isRegExp = isRegExp;\n      e.types.isRegExp = isRegExp;\n\n      function isObject(r) {\n        return typeof r === \"object\" && r !== null;\n      }\n\n      e.isObject = isObject;\n\n      function isDate(r) {\n        return isObject(r) && objectToString(r) === \"[object Date]\";\n      }\n\n      e.isDate = isDate;\n      e.types.isDate = isDate;\n\n      function isError(r) {\n        return isObject(r) && (objectToString(r) === \"[object Error]\" || r instanceof Error);\n      }\n\n      e.isError = isError;\n      e.types.isNativeError = isError;\n\n      function isFunction(r) {\n        return typeof r === \"function\";\n      }\n\n      e.isFunction = isFunction;\n\n      function isPrimitive(r) {\n        return r === null || typeof r === \"boolean\" || typeof r === \"number\" || typeof r === \"string\" || typeof r === \"symbol\" || typeof r === \"undefined\";\n      }\n\n      e.isPrimitive = isPrimitive;\n      e.isBuffer = t(369);\n\n      function objectToString(r) {\n        return Object.prototype.toString.call(r);\n      }\n\n      function pad(r) {\n        return r < 10 ? \"0\" + r.toString(10) : r.toString(10);\n      }\n\n      var u = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n      function timestamp() {\n        var r = new Date();\n        var e = [pad(r.getHours()), pad(r.getMinutes()), pad(r.getSeconds())].join(\":\");\n        return [r.getDate(), u[r.getMonth()], e].join(\" \");\n      }\n\n      e.log = function () {\n        console.log(\"%s - %s\", timestamp(), e.format.apply(e, arguments));\n      };\n\n      e.inherits = t(782);\n\n      e._extend = function (r, e) {\n        if (!e || !isObject(e)) return r;\n        var t = Object.keys(e);\n        var n = t.length;\n\n        while (n--) {\n          r[t[n]] = e[t[n]];\n        }\n\n        return r;\n      };\n\n      function hasOwnProperty(r, e) {\n        return Object.prototype.hasOwnProperty.call(r, e);\n      }\n\n      var s = typeof Symbol !== \"undefined\" ? Symbol(\"util.promisify.custom\") : undefined;\n\n      e.promisify = function promisify(r) {\n        if (typeof r !== \"function\") throw new TypeError('The \"original\" argument must be of type Function');\n\n        if (s && r[s]) {\n          var e = r[s];\n\n          if (typeof e !== \"function\") {\n            throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n          }\n\n          Object.defineProperty(e, s, {\n            value: e,\n            enumerable: false,\n            writable: false,\n            configurable: true\n          });\n          return e;\n        }\n\n        function e() {\n          var e, t;\n          var n = new Promise(function (r, n) {\n            e = r;\n            t = n;\n          });\n          var o = [];\n\n          for (var i = 0; i < arguments.length; i++) {\n            o.push(arguments[i]);\n          }\n\n          o.push(function (r, n) {\n            if (r) {\n              t(r);\n            } else {\n              e(n);\n            }\n          });\n\n          try {\n            r.apply(this, o);\n          } catch (r) {\n            t(r);\n          }\n\n          return n;\n        }\n\n        Object.setPrototypeOf(e, Object.getPrototypeOf(r));\n        if (s) Object.defineProperty(e, s, {\n          value: e,\n          enumerable: false,\n          writable: false,\n          configurable: true\n        });\n        return Object.defineProperties(e, n(r));\n      };\n\n      e.promisify.custom = s;\n\n      function callbackifyOnRejected(r, e) {\n        if (!r) {\n          var t = new Error(\"Promise was rejected with a falsy value\");\n          t.reason = r;\n          r = t;\n        }\n\n        return e(r);\n      }\n\n      function callbackify(r) {\n        if (typeof r !== \"function\") {\n          throw new TypeError('The \"original\" argument must be of type Function');\n        }\n\n        function callbackified() {\n          var e = [];\n\n          for (var t = 0; t < arguments.length; t++) {\n            e.push(arguments[t]);\n          }\n\n          var n = e.pop();\n\n          if (typeof n !== \"function\") {\n            throw new TypeError(\"The last argument must be of type Function\");\n          }\n\n          var o = this;\n\n          var cb = function () {\n            return n.apply(o, arguments);\n          };\n\n          r.apply(this, e).then(function (r) {\n            process.nextTick(cb.bind(null, null, r));\n          }, function (r) {\n            process.nextTick(callbackifyOnRejected.bind(null, r, cb));\n          });\n        }\n\n        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(r));\n        Object.defineProperties(callbackified, n(r));\n        return callbackified;\n      }\n\n      e.callbackify = callbackify;\n    },\n    490: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(144);\n      var o = t(349);\n      var i = t(256);\n      var a = i(\"Object.prototype.toString\");\n      var f = t(942)();\n      var u = f && typeof Symbol.toStringTag === \"symbol\";\n      var s = o();\n      var y = i(\"String.prototype.slice\");\n      var c = {};\n      var p = t(466);\n      var l = Object.getPrototypeOf;\n\n      if (u && p && l) {\n        n(s, function (r) {\n          if (typeof __webpack_require__.g[r] === \"function\") {\n            var e = new __webpack_require__.g[r]();\n\n            if (!(Symbol.toStringTag in e)) {\n              throw new EvalError(\"this engine has support for Symbol.toStringTag, but \" + r + \" does not have the property! Please report this.\");\n            }\n\n            var t = l(e);\n            var n = p(t, Symbol.toStringTag);\n\n            if (!n) {\n              var o = l(t);\n              n = p(o, Symbol.toStringTag);\n            }\n\n            c[r] = n.get;\n          }\n        });\n      }\n\n      var g = function tryAllTypedArrays(r) {\n        var e = false;\n        n(c, function (t, n) {\n          if (!e) {\n            try {\n              var o = t.call(r);\n\n              if (o === n) {\n                e = o;\n              }\n            } catch (r) {}\n          }\n        });\n        return e;\n      };\n\n      var b = t(994);\n\n      r.exports = function whichTypedArray(r) {\n        if (!b(r)) {\n          return false;\n        }\n\n        if (!u) {\n          return y(a(r), 8, -1);\n        }\n\n        return g(r);\n      };\n    },\n    349: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(992);\n\n      r.exports = function availableTypedArrays() {\n        return n([\"BigInt64Array\", \"BigUint64Array\", \"Float32Array\", \"Float64Array\", \"Int16Array\", \"Int32Array\", \"Int8Array\", \"Uint16Array\", \"Uint32Array\", \"Uint8Array\", \"Uint8ClampedArray\"], function (r) {\n          return typeof __webpack_require__.g[r] === \"function\";\n        });\n      };\n    },\n    466: function (r, e, t) {\n      \"use strict\";\n\n      var n = t(838);\n      var o = n(\"%Object.getOwnPropertyDescriptor%\", true);\n\n      if (o) {\n        try {\n          o([], \"length\");\n        } catch (r) {\n          o = null;\n        }\n      }\n\n      r.exports = o;\n    }\n  };\n  var e = {};\n\n  function __nccwpck_require__(t) {\n    var n = e[t];\n\n    if (n !== undefined) {\n      return n.exports;\n    }\n\n    var o = e[t] = {\n      exports: {}\n    };\n    var i = true;\n\n    try {\n      r[t](o, o.exports, __nccwpck_require__);\n      i = false;\n    } finally {\n      if (i) delete e[t];\n    }\n\n    return o.exports;\n  }\n\n  if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n\n  var t = __nccwpck_require__(177);\n\n  module.exports = t;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3V0aWwvdXRpbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxDQUFDLFlBQVU7RUFBQyxJQUFJQSxDQUFDLEdBQUM7SUFBQyxLQUFJLFVBQVNBLENBQVQsRUFBVztNQUFDQSxDQUFDLENBQUNDLE9BQUYsR0FBVSxVQUFTRCxDQUFULEVBQVdFLENBQVgsRUFBYUMsQ0FBYixFQUFlO1FBQUMsSUFBR0gsQ0FBQyxDQUFDSSxNQUFMLEVBQVksT0FBT0osQ0FBQyxDQUFDSSxNQUFGLENBQVNGLENBQVQsRUFBV0MsQ0FBWCxDQUFQO1FBQXFCLElBQUcsS0FBSyxDQUFMLEtBQVNILENBQVQsSUFBWSxTQUFPQSxDQUF0QixFQUF3QixNQUFNLElBQUlLLFNBQUosRUFBTjtRQUFvQixJQUFHLGNBQVksT0FBT0gsQ0FBdEIsRUFBd0IsTUFBTSxJQUFJRyxTQUFKLEVBQU47UUFBb0IsSUFBSUMsQ0FBQyxHQUFDLEVBQU47O1FBQVMsS0FBSSxJQUFJQyxDQUFDLEdBQUMsQ0FBVixFQUFZQSxDQUFDLEdBQUNQLENBQUMsQ0FBQ1EsTUFBaEIsRUFBdUJELENBQUMsRUFBeEIsRUFBMkI7VUFBQyxJQUFHLENBQUNFLENBQUMsQ0FBQ0MsSUFBRixDQUFPVixDQUFQLEVBQVNPLENBQVQsQ0FBSixFQUFnQjtVQUFTLElBQUlJLENBQUMsR0FBQ1gsQ0FBQyxDQUFDTyxDQUFELENBQVA7VUFBVyxJQUFHTCxDQUFDLENBQUNRLElBQUYsQ0FBT1AsQ0FBUCxFQUFTUSxDQUFULEVBQVdKLENBQVgsRUFBYVAsQ0FBYixDQUFILEVBQW1CTSxDQUFDLENBQUNNLElBQUYsQ0FBT0QsQ0FBUDtRQUFVOztRQUFBLE9BQU9MLENBQVA7TUFBUyxDQUFsUTs7TUFBbVEsSUFBSUcsQ0FBQyxHQUFDSSxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLGNBQXZCO0lBQXNDLENBQTFUO0lBQTJULEtBQUksVUFBU2YsQ0FBVCxFQUFXUyxDQUFYLEVBQWFQLENB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QSxDQUFILEVBQUssT0FBT0UsQ0FBQyxDQUFDUCxDQUFELENBQVI7SUFBWTs7SUFBQSxPQUFPSSxDQUFDLENBQUNMLE9BQVQ7RUFBaUI7O0VBQUEsSUFBRyxPQUFPaVMsbUJBQVAsS0FBNkIsV0FBaEMsRUFBNENBLG1CQUFtQixDQUFDQyxFQUFwQixHQUF1QkMsU0FBUyxHQUFDLEdBQWpDOztFQUFxQyxJQUFJbFMsQ0FBQyxHQUFDZ1MsbUJBQW1CLENBQUMsR0FBRCxDQUF6Qjs7RUFBK0JHLE1BQU0sQ0FBQ3BTLE9BQVAsR0FBZUMsQ0FBZjtBQUFpQixDQUExNS9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvdXRpbC91dGlsLmpzP2FjMTQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIHI9ezk5MjpmdW5jdGlvbihyKXtyLmV4cG9ydHM9ZnVuY3Rpb24ocix0LG4pe2lmKHIuZmlsdGVyKXJldHVybiByLmZpbHRlcih0LG4pO2lmKHZvaWQgMD09PXJ8fG51bGw9PT1yKXRocm93IG5ldyBUeXBlRXJyb3I7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO3ZhciBvPVtdO2Zvcih2YXIgaT0wO2k8ci5sZW5ndGg7aSsrKXtpZighZS5jYWxsKHIsaSkpY29udGludWU7dmFyIGE9cltpXTtpZih0LmNhbGwobixhLGkscikpby5wdXNoKGEpfXJldHVybiBvfTt2YXIgZT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5fSwyNTY6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoODM4KTt2YXIgbz10KDEzOSk7dmFyIGk9byhuKFwiU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mXCIpKTtyLmV4cG9ydHM9ZnVuY3Rpb24gY2FsbEJvdW5kSW50cmluc2ljKHIsZSl7dmFyIHQ9bihyLCEhZSk7aWYodHlwZW9mIHQ9PT1cImZ1bmN0aW9uXCImJmkocixcIi5wcm90b3R5cGUuXCIpPi0xKXtyZXR1cm4gbyh0KX1yZXR1cm4gdH19LDEzOTpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCgxNzQpO3ZhciBvPXQoODM4KTt2YXIgaT1vKFwiJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSVcIik7dmFyIGE9byhcIiVGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCVcIik7dmFyIGY9byhcIiVSZWZsZWN0LmFwcGx5JVwiLHRydWUpfHxuLmNhbGwoYSxpKTt2YXIgdT1vKFwiJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlXCIsdHJ1ZSk7dmFyIHM9byhcIiVPYmplY3QuZGVmaW5lUHJvcGVydHklXCIsdHJ1ZSk7dmFyIHk9byhcIiVNYXRoLm1heCVcIik7aWYocyl7dHJ5e3Moe30sXCJhXCIse3ZhbHVlOjF9KX1jYXRjaChyKXtzPW51bGx9fXIuZXhwb3J0cz1mdW5jdGlvbiBjYWxsQmluZChyKXt2YXIgZT1mKG4sYSxhcmd1bWVudHMpO2lmKHUmJnMpe3ZhciB0PXUoZSxcImxlbmd0aFwiKTtpZih0LmNvbmZpZ3VyYWJsZSl7cyhlLFwibGVuZ3RoXCIse3ZhbHVlOjEreSgwLHIubGVuZ3RoLShhcmd1bWVudHMubGVuZ3RoLTEpKX0pfX1yZXR1cm4gZX07dmFyIGM9ZnVuY3Rpb24gYXBwbHlCaW5kKCl7cmV0dXJuIGYobixpLGFyZ3VtZW50cyl9O2lmKHMpe3Moci5leHBvcnRzLFwiYXBwbHlcIix7dmFsdWU6Y30pfWVsc2V7ci5leHBvcnRzLmFwcGx5PWN9fSwxNDQ6ZnVuY3Rpb24ocil7dmFyIGU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTt2YXIgdD1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO3IuZXhwb3J0cz1mdW5jdGlvbiBmb3JFYWNoKHIsbixvKXtpZih0LmNhbGwobikhPT1cIltvYmplY3QgRnVuY3Rpb25dXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIil9dmFyIGk9ci5sZW5ndGg7aWYoaT09PStpKXtmb3IodmFyIGE9MDthPGk7YSsrKXtuLmNhbGwobyxyW2FdLGEscil9fWVsc2V7Zm9yKHZhciBmIGluIHIpe2lmKGUuY2FsbChyLGYpKXtuLmNhbGwobyxyW2ZdLGYscil9fX19fSw0MjY6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9XCJGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlIFwiO3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZTt2YXIgbj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO3ZhciBvPVwiW29iamVjdCBGdW5jdGlvbl1cIjtyLmV4cG9ydHM9ZnVuY3Rpb24gYmluZChyKXt2YXIgaT10aGlzO2lmKHR5cGVvZiBpIT09XCJmdW5jdGlvblwifHxuLmNhbGwoaSkhPT1vKXt0aHJvdyBuZXcgVHlwZUVycm9yKGUraSl9dmFyIGE9dC5jYWxsKGFyZ3VtZW50cywxKTt2YXIgZjt2YXIgYmluZGVyPWZ1bmN0aW9uKCl7aWYodGhpcyBpbnN0YW5jZW9mIGYpe3ZhciBlPWkuYXBwbHkodGhpcyxhLmNvbmNhdCh0LmNhbGwoYXJndW1lbnRzKSkpO2lmKE9iamVjdChlKT09PWUpe3JldHVybiBlfXJldHVybiB0aGlzfWVsc2V7cmV0dXJuIGkuYXBwbHkocixhLmNvbmNhdCh0LmNhbGwoYXJndW1lbnRzKSkpfX07dmFyIHU9TWF0aC5tYXgoMCxpLmxlbmd0aC1hLmxlbmd0aCk7dmFyIHM9W107Zm9yKHZhciB5PTA7eTx1O3krKyl7cy5wdXNoKFwiJFwiK3kpfWY9RnVuY3Rpb24oXCJiaW5kZXJcIixcInJldHVybiBmdW5jdGlvbiAoXCIrcy5qb2luKFwiLFwiKStcIil7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9XCIpKGJpbmRlcik7aWYoaS5wcm90b3R5cGUpe3ZhciBjPWZ1bmN0aW9uIEVtcHR5KCl7fTtjLnByb3RvdHlwZT1pLnByb3RvdHlwZTtmLnByb3RvdHlwZT1uZXcgYztjLnByb3RvdHlwZT1udWxsfXJldHVybiBmfX0sMTc0OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KDQyNik7ci5leHBvcnRzPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kfHxufSw4Mzg6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuO3ZhciBvPVN5bnRheEVycm9yO3ZhciBpPUZ1bmN0aW9uO3ZhciBhPVR5cGVFcnJvcjt2YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yPWZ1bmN0aW9uKHIpe3RyeXtyZXR1cm4gaSgnXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJytyK1wiKS5jb25zdHJ1Y3RvcjtcIikoKX1jYXRjaChyKXt9fTt2YXIgZj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2lmKGYpe3RyeXtmKHt9LFwiXCIpfWNhdGNoKHIpe2Y9bnVsbH19dmFyIHRocm93VHlwZUVycm9yPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IGF9O3ZhciB1PWY/ZnVuY3Rpb24oKXt0cnl7YXJndW1lbnRzLmNhbGxlZTtyZXR1cm4gdGhyb3dUeXBlRXJyb3J9Y2F0Y2gocil7dHJ5e3JldHVybiBmKGFyZ3VtZW50cyxcImNhbGxlZVwiKS5nZXR9Y2F0Y2gocil7cmV0dXJuIHRocm93VHlwZUVycm9yfX19KCk6dGhyb3dUeXBlRXJyb3I7dmFyIHM9dCgxMTUpKCk7dmFyIHk9T2JqZWN0LmdldFByb3RvdHlwZU9mfHxmdW5jdGlvbihyKXtyZXR1cm4gci5fX3Byb3RvX199O3ZhciBjPXt9O3ZhciBwPXR5cGVvZiBVaW50OEFycmF5PT09XCJ1bmRlZmluZWRcIj9uOnkoVWludDhBcnJheSk7dmFyIGw9e1wiJUFnZ3JlZ2F0ZUVycm9yJVwiOnR5cGVvZiBBZ2dyZWdhdGVFcnJvcj09PVwidW5kZWZpbmVkXCI/bjpBZ2dyZWdhdGVFcnJvcixcIiVBcnJheSVcIjpBcnJheSxcIiVBcnJheUJ1ZmZlciVcIjp0eXBlb2YgQXJyYXlCdWZmZXI9PT1cInVuZGVmaW5lZFwiP246QXJyYXlCdWZmZXIsXCIlQXJyYXlJdGVyYXRvclByb3RvdHlwZSVcIjpzP3koW11bU3ltYm9sLml0ZXJhdG9yXSgpKTpuLFwiJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSVcIjpuLFwiJUFzeW5jRnVuY3Rpb24lXCI6YyxcIiVBc3luY0dlbmVyYXRvciVcIjpjLFwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCI6YyxcIiVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJVwiOmMsXCIlQXRvbWljcyVcIjp0eXBlb2YgQXRvbWljcz09PVwidW5kZWZpbmVkXCI/bjpBdG9taWNzLFwiJUJpZ0ludCVcIjp0eXBlb2YgQmlnSW50PT09XCJ1bmRlZmluZWRcIj9uOkJpZ0ludCxcIiVCb29sZWFuJVwiOkJvb2xlYW4sXCIlRGF0YVZpZXclXCI6dHlwZW9mIERhdGFWaWV3PT09XCJ1bmRlZmluZWRcIj9uOkRhdGFWaWV3LFwiJURhdGUlXCI6RGF0ZSxcIiVkZWNvZGVVUkklXCI6ZGVjb2RlVVJJLFwiJWRlY29kZVVSSUNvbXBvbmVudCVcIjpkZWNvZGVVUklDb21wb25lbnQsXCIlZW5jb2RlVVJJJVwiOmVuY29kZVVSSSxcIiVlbmNvZGVVUklDb21wb25lbnQlXCI6ZW5jb2RlVVJJQ29tcG9uZW50LFwiJUVycm9yJVwiOkVycm9yLFwiJWV2YWwlXCI6ZXZhbCxcIiVFdmFsRXJyb3IlXCI6RXZhbEVycm9yLFwiJUZsb2F0MzJBcnJheSVcIjp0eXBlb2YgRmxvYXQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9uOkZsb2F0MzJBcnJheSxcIiVGbG9hdDY0QXJyYXklXCI6dHlwZW9mIEZsb2F0NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bjpGbG9hdDY0QXJyYXksXCIlRmluYWxpemF0aW9uUmVnaXN0cnklXCI6dHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5PT09XCJ1bmRlZmluZWRcIj9uOkZpbmFsaXphdGlvblJlZ2lzdHJ5LFwiJUZ1bmN0aW9uJVwiOmksXCIlR2VuZXJhdG9yRnVuY3Rpb24lXCI6YyxcIiVJbnQ4QXJyYXklXCI6dHlwZW9mIEludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bjpJbnQ4QXJyYXksXCIlSW50MTZBcnJheSVcIjp0eXBlb2YgSW50MTZBcnJheT09PVwidW5kZWZpbmVkXCI/bjpJbnQxNkFycmF5LFwiJUludDMyQXJyYXklXCI6dHlwZW9mIEludDMyQXJyYXk9PT1cInVuZGVmaW5lZFwiP246SW50MzJBcnJheSxcIiVpc0Zpbml0ZSVcIjppc0Zpbml0ZSxcIiVpc05hTiVcIjppc05hTixcIiVJdGVyYXRvclByb3RvdHlwZSVcIjpzP3koeShbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKTpuLFwiJUpTT04lXCI6dHlwZW9mIEpTT049PT1cIm9iamVjdFwiP0pTT046bixcIiVNYXAlXCI6dHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCI/bjpNYXAsXCIlTWFwSXRlcmF0b3JQcm90b3R5cGUlXCI6dHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCJ8fCFzP246eSgobmV3IE1hcClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcIiVNYXRoJVwiOk1hdGgsXCIlTnVtYmVyJVwiOk51bWJlcixcIiVPYmplY3QlXCI6T2JqZWN0LFwiJXBhcnNlRmxvYXQlXCI6cGFyc2VGbG9hdCxcIiVwYXJzZUludCVcIjpwYXJzZUludCxcIiVQcm9taXNlJVwiOnR5cGVvZiBQcm9taXNlPT09XCJ1bmRlZmluZWRcIj9uOlByb21pc2UsXCIlUHJveHklXCI6dHlwZW9mIFByb3h5PT09XCJ1bmRlZmluZWRcIj9uOlByb3h5LFwiJVJhbmdlRXJyb3IlXCI6UmFuZ2VFcnJvcixcIiVSZWZlcmVuY2VFcnJvciVcIjpSZWZlcmVuY2VFcnJvcixcIiVSZWZsZWN0JVwiOnR5cGVvZiBSZWZsZWN0PT09XCJ1bmRlZmluZWRcIj9uOlJlZmxlY3QsXCIlUmVnRXhwJVwiOlJlZ0V4cCxcIiVTZXQlXCI6dHlwZW9mIFNldD09PVwidW5kZWZpbmVkXCI/bjpTZXQsXCIlU2V0SXRlcmF0b3JQcm90b3R5cGUlXCI6dHlwZW9mIFNldD09PVwidW5kZWZpbmVkXCJ8fCFzP246eSgobmV3IFNldClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcIiVTaGFyZWRBcnJheUJ1ZmZlciVcIjp0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI9PT1cInVuZGVmaW5lZFwiP246U2hhcmVkQXJyYXlCdWZmZXIsXCIlU3RyaW5nJVwiOlN0cmluZyxcIiVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSVcIjpzP3koXCJcIltTeW1ib2wuaXRlcmF0b3JdKCkpOm4sXCIlU3ltYm9sJVwiOnM/U3ltYm9sOm4sXCIlU3ludGF4RXJyb3IlXCI6byxcIiVUaHJvd1R5cGVFcnJvciVcIjp1LFwiJVR5cGVkQXJyYXklXCI6cCxcIiVUeXBlRXJyb3IlXCI6YSxcIiVVaW50OEFycmF5JVwiOnR5cGVvZiBVaW50OEFycmF5PT09XCJ1bmRlZmluZWRcIj9uOlVpbnQ4QXJyYXksXCIlVWludDhDbGFtcGVkQXJyYXklXCI6dHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5PT09XCJ1bmRlZmluZWRcIj9uOlVpbnQ4Q2xhbXBlZEFycmF5LFwiJVVpbnQxNkFycmF5JVwiOnR5cGVvZiBVaW50MTZBcnJheT09PVwidW5kZWZpbmVkXCI/bjpVaW50MTZBcnJheSxcIiVVaW50MzJBcnJheSVcIjp0eXBlb2YgVWludDMyQXJyYXk9PT1cInVuZGVmaW5lZFwiP246VWludDMyQXJyYXksXCIlVVJJRXJyb3IlXCI6VVJJRXJyb3IsXCIlV2Vha01hcCVcIjp0eXBlb2YgV2Vha01hcD09PVwidW5kZWZpbmVkXCI/bjpXZWFrTWFwLFwiJVdlYWtSZWYlXCI6dHlwZW9mIFdlYWtSZWY9PT1cInVuZGVmaW5lZFwiP246V2Vha1JlZixcIiVXZWFrU2V0JVwiOnR5cGVvZiBXZWFrU2V0PT09XCJ1bmRlZmluZWRcIj9uOldlYWtTZXR9O3ZhciBnPWZ1bmN0aW9uIGRvRXZhbChyKXt2YXIgZTtpZihyPT09XCIlQXN5bmNGdW5jdGlvbiVcIil7ZT1nZXRFdmFsbGVkQ29uc3RydWN0b3IoXCJhc3luYyBmdW5jdGlvbiAoKSB7fVwiKX1lbHNlIGlmKHI9PT1cIiVHZW5lcmF0b3JGdW5jdGlvbiVcIil7ZT1nZXRFdmFsbGVkQ29uc3RydWN0b3IoXCJmdW5jdGlvbiogKCkge31cIil9ZWxzZSBpZihyPT09XCIlQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiVcIil7ZT1nZXRFdmFsbGVkQ29uc3RydWN0b3IoXCJhc3luYyBmdW5jdGlvbiogKCkge31cIil9ZWxzZSBpZihyPT09XCIlQXN5bmNHZW5lcmF0b3IlXCIpe3ZhciB0PWRvRXZhbChcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiKTtpZih0KXtlPXQucHJvdG90eXBlfX1lbHNlIGlmKHI9PT1cIiVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJVwiKXt2YXIgbj1kb0V2YWwoXCIlQXN5bmNHZW5lcmF0b3IlXCIpO2lmKG4pe2U9eShuLnByb3RvdHlwZSl9fWxbcl09ZTtyZXR1cm4gZX07dmFyIGI9e1wiJUFycmF5QnVmZmVyUHJvdG90eXBlJVwiOltcIkFycmF5QnVmZmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlQXJyYXlQcm90b3R5cGUlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVBcnJheVByb3RvX2VudHJpZXMlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwiZW50cmllc1wiXSxcIiVBcnJheVByb3RvX2ZvckVhY2glXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwiZm9yRWFjaFwiXSxcIiVBcnJheVByb3RvX2tleXMlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwia2V5c1wiXSxcIiVBcnJheVByb3RvX3ZhbHVlcyVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJ2YWx1ZXNcIl0sXCIlQXN5bmNGdW5jdGlvblByb3RvdHlwZSVcIjpbXCJBc3luY0Z1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlQXN5bmNHZW5lcmF0b3IlXCI6W1wiQXN5bmNHZW5lcmF0b3JGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJVwiOltcIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiLFwicHJvdG90eXBlXCJdLFwiJUJvb2xlYW5Qcm90b3R5cGUlXCI6W1wiQm9vbGVhblwiLFwicHJvdG90eXBlXCJdLFwiJURhdGFWaWV3UHJvdG90eXBlJVwiOltcIkRhdGFWaWV3XCIsXCJwcm90b3R5cGVcIl0sXCIlRGF0ZVByb3RvdHlwZSVcIjpbXCJEYXRlXCIsXCJwcm90b3R5cGVcIl0sXCIlRXJyb3JQcm90b3R5cGUlXCI6W1wiRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVFdmFsRXJyb3JQcm90b3R5cGUlXCI6W1wiRXZhbEVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlRmxvYXQzMkFycmF5UHJvdG90eXBlJVwiOltcIkZsb2F0MzJBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUZsb2F0NjRBcnJheVByb3RvdHlwZSVcIjpbXCJGbG9hdDY0QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVGdW5jdGlvblByb3RvdHlwZSVcIjpbXCJGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUdlbmVyYXRvciVcIjpbXCJHZW5lcmF0b3JGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUdlbmVyYXRvclByb3RvdHlwZSVcIjpbXCJHZW5lcmF0b3JGdW5jdGlvblwiLFwicHJvdG90eXBlXCIsXCJwcm90b3R5cGVcIl0sXCIlSW50OEFycmF5UHJvdG90eXBlJVwiOltcIkludDhBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUludDE2QXJyYXlQcm90b3R5cGUlXCI6W1wiSW50MTZBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUludDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiSW50MzJBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUpTT05QYXJzZSVcIjpbXCJKU09OXCIsXCJwYXJzZVwiXSxcIiVKU09OU3RyaW5naWZ5JVwiOltcIkpTT05cIixcInN0cmluZ2lmeVwiXSxcIiVNYXBQcm90b3R5cGUlXCI6W1wiTWFwXCIsXCJwcm90b3R5cGVcIl0sXCIlTnVtYmVyUHJvdG90eXBlJVwiOltcIk51bWJlclwiLFwicHJvdG90eXBlXCJdLFwiJU9iamVjdFByb3RvdHlwZSVcIjpbXCJPYmplY3RcIixcInByb3RvdHlwZVwiXSxcIiVPYmpQcm90b190b1N0cmluZyVcIjpbXCJPYmplY3RcIixcInByb3RvdHlwZVwiLFwidG9TdHJpbmdcIl0sXCIlT2JqUHJvdG9fdmFsdWVPZiVcIjpbXCJPYmplY3RcIixcInByb3RvdHlwZVwiLFwidmFsdWVPZlwiXSxcIiVQcm9taXNlUHJvdG90eXBlJVwiOltcIlByb21pc2VcIixcInByb3RvdHlwZVwiXSxcIiVQcm9taXNlUHJvdG9fdGhlbiVcIjpbXCJQcm9taXNlXCIsXCJwcm90b3R5cGVcIixcInRoZW5cIl0sXCIlUHJvbWlzZV9hbGwlXCI6W1wiUHJvbWlzZVwiLFwiYWxsXCJdLFwiJVByb21pc2VfcmVqZWN0JVwiOltcIlByb21pc2VcIixcInJlamVjdFwiXSxcIiVQcm9taXNlX3Jlc29sdmUlXCI6W1wiUHJvbWlzZVwiLFwicmVzb2x2ZVwiXSxcIiVSYW5nZUVycm9yUHJvdG90eXBlJVwiOltcIlJhbmdlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSVcIjpbXCJSZWZlcmVuY2VFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVJlZ0V4cFByb3RvdHlwZSVcIjpbXCJSZWdFeHBcIixcInByb3RvdHlwZVwiXSxcIiVTZXRQcm90b3R5cGUlXCI6W1wiU2V0XCIsXCJwcm90b3R5cGVcIl0sXCIlU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlXCI6W1wiU2hhcmVkQXJyYXlCdWZmZXJcIixcInByb3RvdHlwZVwiXSxcIiVTdHJpbmdQcm90b3R5cGUlXCI6W1wiU3RyaW5nXCIsXCJwcm90b3R5cGVcIl0sXCIlU3ltYm9sUHJvdG90eXBlJVwiOltcIlN5bWJvbFwiLFwicHJvdG90eXBlXCJdLFwiJVN5bnRheEVycm9yUHJvdG90eXBlJVwiOltcIlN5bnRheEVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlVHlwZWRBcnJheVByb3RvdHlwZSVcIjpbXCJUeXBlZEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVHlwZUVycm9yUHJvdG90eXBlJVwiOltcIlR5cGVFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQ4QXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDhBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQ4Q2xhbXBlZEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDE2QXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDE2QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50MzJBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50MzJBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVSSUVycm9yUHJvdG90eXBlJVwiOltcIlVSSUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlV2Vha01hcFByb3RvdHlwZSVcIjpbXCJXZWFrTWFwXCIsXCJwcm90b3R5cGVcIl0sXCIlV2Vha1NldFByb3RvdHlwZSVcIjpbXCJXZWFrU2V0XCIsXCJwcm90b3R5cGVcIl19O3ZhciBkPXQoMTc0KTt2YXIgdj10KDEwMSk7dmFyIG09ZC5jYWxsKEZ1bmN0aW9uLmNhbGwsQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7dmFyIFM9ZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO3ZhciBBPWQuY2FsbChGdW5jdGlvbi5jYWxsLFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7dmFyIGg9ZC5jYWxsKEZ1bmN0aW9uLmNhbGwsU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7dmFyIE89L1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7dmFyIGo9L1xcXFwoXFxcXCk/L2c7dmFyIHc9ZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHIpe3ZhciBlPWgociwwLDEpO3ZhciB0PWgociwtMSk7aWYoZT09PVwiJVwiJiZ0IT09XCIlXCIpe3Rocm93IG5ldyBvKFwiaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYFwiKX1lbHNlIGlmKHQ9PT1cIiVcIiYmZSE9PVwiJVwiKXt0aHJvdyBuZXcgbyhcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWBcIil9dmFyIG49W107QShyLE8sKGZ1bmN0aW9uKHIsZSx0LG8pe25bbi5sZW5ndGhdPXQ/QShvLGosXCIkMVwiKTplfHxyfSkpO3JldHVybiBufTt2YXIgUD1mdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKHIsZSl7dmFyIHQ9cjt2YXIgbjtpZih2KGIsdCkpe249Ylt0XTt0PVwiJVwiK25bMF0rXCIlXCJ9aWYodihsLHQpKXt2YXIgaT1sW3RdO2lmKGk9PT1jKXtpPWcodCl9aWYodHlwZW9mIGk9PT1cInVuZGVmaW5lZFwiJiYhZSl7dGhyb3cgbmV3IGEoXCJpbnRyaW5zaWMgXCIrcitcIiBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSFcIil9cmV0dXJue2FsaWFzOm4sbmFtZTp0LHZhbHVlOml9fXRocm93IG5ldyBvKFwiaW50cmluc2ljIFwiK3IrXCIgZG9lcyBub3QgZXhpc3QhXCIpfTtyLmV4cG9ydHM9ZnVuY3Rpb24gR2V0SW50cmluc2ljKHIsZSl7aWYodHlwZW9mIHIhPT1cInN0cmluZ1wifHxyLmxlbmd0aD09PTApe3Rocm93IG5ldyBhKFwiaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9aWYoYXJndW1lbnRzLmxlbmd0aD4xJiZ0eXBlb2YgZSE9PVwiYm9vbGVhblwiKXt0aHJvdyBuZXcgYSgnXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpfXZhciB0PXcocik7dmFyIGk9dC5sZW5ndGg+MD90WzBdOlwiXCI7dmFyIHU9UChcIiVcIitpK1wiJVwiLGUpO3ZhciBzPXUubmFtZTt2YXIgeT11LnZhbHVlO3ZhciBjPWZhbHNlO3ZhciBwPXUuYWxpYXM7aWYocCl7aT1wWzBdO1ModCxtKFswLDFdLHApKX1mb3IodmFyIGc9MSxiPXRydWU7Zzx0Lmxlbmd0aDtnKz0xKXt2YXIgZD10W2ddO3ZhciBBPWgoZCwwLDEpO3ZhciBPPWgoZCwtMSk7aWYoKEE9PT0nXCInfHxBPT09XCInXCJ8fEE9PT1cImBcInx8KE89PT0nXCInfHxPPT09XCInXCJ8fE89PT1cImBcIikpJiZBIT09Tyl7dGhyb3cgbmV3IG8oXCJwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzXCIpfWlmKGQ9PT1cImNvbnN0cnVjdG9yXCJ8fCFiKXtjPXRydWV9aSs9XCIuXCIrZDtzPVwiJVwiK2krXCIlXCI7aWYodihsLHMpKXt5PWxbc119ZWxzZSBpZih5IT1udWxsKXtpZighKGQgaW4geSkpe2lmKCFlKXt0aHJvdyBuZXcgYShcImJhc2UgaW50cmluc2ljIGZvciBcIityK1wiIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLlwiKX1yZXR1cm4gdm9pZCBufWlmKGYmJmcrMT49dC5sZW5ndGgpe3ZhciBqPWYoeSxkKTtiPSEhajtpZihiJiZcImdldFwiaW4gaiYmIShcIm9yaWdpbmFsVmFsdWVcImluIGouZ2V0KSl7eT1qLmdldH1lbHNle3k9eVtkXX19ZWxzZXtiPXYoeSxkKTt5PXlbZF19aWYoYiYmIWMpe2xbc109eX19fXJldHVybiB5fX0sOTQyOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIiYmU3ltYm9sO3ZhciBvPXQoNzczKTtyLmV4cG9ydHM9ZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpe2lmKHR5cGVvZiBuIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbCE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBuKFwiZm9vXCIpIT09XCJzeW1ib2xcIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBTeW1ib2woXCJiYXJcIikhPT1cInN5bWJvbFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIG8oKX19LDc3MzpmdW5jdGlvbihyKXtcInVzZSBzdHJpY3RcIjtyLmV4cG9ydHM9ZnVuY3Rpb24gaGFzU3ltYm9scygpe2lmKHR5cGVvZiBTeW1ib2whPT1cImZ1bmN0aW9uXCJ8fHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbC5pdGVyYXRvcj09PVwic3ltYm9sXCIpe3JldHVybiB0cnVlfXZhciByPXt9O3ZhciBlPVN5bWJvbChcInRlc3RcIik7dmFyIHQ9T2JqZWN0KGUpO2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSE9PVwiW29iamVjdCBTeW1ib2xdXCIpe3JldHVybiBmYWxzZX1pZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkhPT1cIltvYmplY3QgU3ltYm9sXVwiKXtyZXR1cm4gZmFsc2V9dmFyIG49NDI7cltlXT1uO2ZvcihlIGluIHIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgT2JqZWN0LmtleXM9PT1cImZ1bmN0aW9uXCImJk9iamVjdC5rZXlzKHIpLmxlbmd0aCE9PTApe3JldHVybiBmYWxzZX1pZih0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM9PT1cImZ1bmN0aW9uXCImJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHIpLmxlbmd0aCE9PTApe3JldHVybiBmYWxzZX12YXIgbz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHIpO2lmKG8ubGVuZ3RoIT09MXx8b1swXSE9PWUpe3JldHVybiBmYWxzZX1pZighT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHIsZSkpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcj09PVwiZnVuY3Rpb25cIil7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLGUpO2lmKGkudmFsdWUhPT1ufHxpLmVudW1lcmFibGUhPT10cnVlKXtyZXR1cm4gZmFsc2V9fXJldHVybiB0cnVlfX0sMTE1OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIiYmU3ltYm9sO3ZhciBvPXQoODMyKTtyLmV4cG9ydHM9ZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpe2lmKHR5cGVvZiBuIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbCE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBuKFwiZm9vXCIpIT09XCJzeW1ib2xcIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBTeW1ib2woXCJiYXJcIikhPT1cInN5bWJvbFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIG8oKX19LDgzMjpmdW5jdGlvbihyKXtcInVzZSBzdHJpY3RcIjtyLmV4cG9ydHM9ZnVuY3Rpb24gaGFzU3ltYm9scygpe2lmKHR5cGVvZiBTeW1ib2whPT1cImZ1bmN0aW9uXCJ8fHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbC5pdGVyYXRvcj09PVwic3ltYm9sXCIpe3JldHVybiB0cnVlfXZhciByPXt9O3ZhciBlPVN5bWJvbChcInRlc3RcIik7dmFyIHQ9T2JqZWN0KGUpO2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSE9PVwiW29iamVjdCBTeW1ib2xdXCIpe3JldHVybiBmYWxzZX1pZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkhPT1cIltvYmplY3QgU3ltYm9sXVwiKXtyZXR1cm4gZmFsc2V9dmFyIG49NDI7cltlXT1uO2ZvcihlIGluIHIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgT2JqZWN0LmtleXM9PT1cImZ1bmN0aW9uXCImJk9iamVjdC5rZXlzKHIpLmxlbmd0aCE9PTApe3JldHVybiBmYWxzZX1pZih0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM9PT1cImZ1bmN0aW9uXCImJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHIpLmxlbmd0aCE9PTApe3JldHVybiBmYWxzZX12YXIgbz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHIpO2lmKG8ubGVuZ3RoIT09MXx8b1swXSE9PWUpe3JldHVybiBmYWxzZX1pZighT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHIsZSkpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcj09PVwiZnVuY3Rpb25cIil7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLGUpO2lmKGkudmFsdWUhPT1ufHxpLmVudW1lcmFibGUhPT10cnVlKXtyZXR1cm4gZmFsc2V9fXJldHVybiB0cnVlfX0sMTAxOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KDE3NCk7ci5leHBvcnRzPW4uY2FsbChGdW5jdGlvbi5jYWxsLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpfSw3ODI6ZnVuY3Rpb24ocil7aWYodHlwZW9mIE9iamVjdC5jcmVhdGU9PT1cImZ1bmN0aW9uXCIpe3IuZXhwb3J0cz1mdW5jdGlvbiBpbmhlcml0cyhyLGUpe2lmKGUpe3Iuc3VwZXJfPWU7ci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnIsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfX0pfX19ZWxzZXtyLmV4cG9ydHM9ZnVuY3Rpb24gaW5oZXJpdHMocixlKXtpZihlKXtyLnN1cGVyXz1lO3ZhciBUZW1wQ3Rvcj1mdW5jdGlvbigpe307VGVtcEN0b3IucHJvdG90eXBlPWUucHJvdG90eXBlO3IucHJvdG90eXBlPW5ldyBUZW1wQ3RvcjtyLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1yfX19fSwxNTc6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgbj1mdW5jdGlvbiBpc0FyZ3VtZW50cyhyKXtpZihlJiZyJiZ0eXBlb2Ygcj09PVwib2JqZWN0XCImJlN5bWJvbC50b1N0cmluZ1RhZyBpbiByKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHQuY2FsbChyKT09PVwiW29iamVjdCBBcmd1bWVudHNdXCJ9O3ZhciBvPWZ1bmN0aW9uIGlzQXJndW1lbnRzKHIpe2lmKG4ocikpe3JldHVybiB0cnVlfXJldHVybiByIT09bnVsbCYmdHlwZW9mIHI9PT1cIm9iamVjdFwiJiZ0eXBlb2Ygci5sZW5ndGg9PT1cIm51bWJlclwiJiZyLmxlbmd0aD49MCYmdC5jYWxsKHIpIT09XCJbb2JqZWN0IEFycmF5XVwiJiZ0LmNhbGwoci5jYWxsZWUpPT09XCJbb2JqZWN0IEZ1bmN0aW9uXVwifTt2YXIgaT1mdW5jdGlvbigpe3JldHVybiBuKGFyZ3VtZW50cyl9KCk7bi5pc0xlZ2FjeUFyZ3VtZW50cz1vO3IuZXhwb3J0cz1pP246b30sMzkxOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3ZhciBlPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7dmFyIHQ9RnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO3ZhciBuPS9eXFxzKig/OmZ1bmN0aW9uKT9cXCovO3ZhciBvPXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PT1cInN5bWJvbFwiO3ZhciBpPU9iamVjdC5nZXRQcm90b3R5cGVPZjt2YXIgZ2V0R2VuZXJhdG9yRnVuYz1mdW5jdGlvbigpe2lmKCFvKXtyZXR1cm4gZmFsc2V9dHJ5e3JldHVybiBGdW5jdGlvbihcInJldHVybiBmdW5jdGlvbiooKSB7fVwiKSgpfWNhdGNoKHIpe319O3ZhciBhPWdldEdlbmVyYXRvckZ1bmMoKTt2YXIgZj1hP2koYSk6e307ci5leHBvcnRzPWZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24ocil7aWYodHlwZW9mIHIhPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZihuLnRlc3QodC5jYWxsKHIpKSl7cmV0dXJuIHRydWV9aWYoIW8pe3ZhciBhPWUuY2FsbChyKTtyZXR1cm4gYT09PVwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIn1yZXR1cm4gaShyKT09PWZ9fSw5OTQ6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoMTQ0KTt2YXIgbz10KDM0OSk7dmFyIGk9dCgyNTYpO3ZhciBhPWkoXCJPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXCIpO3ZhciBmPXQoOTQyKSgpO3ZhciB1PWYmJnR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PT1cInN5bWJvbFwiO3ZhciBzPW8oKTt2YXIgeT1pKFwiQXJyYXkucHJvdG90eXBlLmluZGV4T2ZcIix0cnVlKXx8ZnVuY3Rpb24gaW5kZXhPZihyLGUpe2Zvcih2YXIgdD0wO3Q8ci5sZW5ndGg7dCs9MSl7aWYoclt0XT09PWUpe3JldHVybiB0fX1yZXR1cm4tMX07dmFyIGM9aShcIlN0cmluZy5wcm90b3R5cGUuc2xpY2VcIik7dmFyIHA9e307dmFyIGw9dCg0NjYpO3ZhciBnPU9iamVjdC5nZXRQcm90b3R5cGVPZjtpZih1JiZsJiZnKXtuKHMsKGZ1bmN0aW9uKHIpe3ZhciBlPW5ldyBnbG9iYWxbcl07aWYoIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gZSkpe3Rocm93IG5ldyBFdmFsRXJyb3IoXCJ0aGlzIGVuZ2luZSBoYXMgc3VwcG9ydCBmb3IgU3ltYm9sLnRvU3RyaW5nVGFnLCBidXQgXCIrcitcIiBkb2VzIG5vdCBoYXZlIHRoZSBwcm9wZXJ0eSEgUGxlYXNlIHJlcG9ydCB0aGlzLlwiKX12YXIgdD1nKGUpO3ZhciBuPWwodCxTeW1ib2wudG9TdHJpbmdUYWcpO2lmKCFuKXt2YXIgbz1nKHQpO249bChvLFN5bWJvbC50b1N0cmluZ1RhZyl9cFtyXT1uLmdldH0pKX12YXIgYj1mdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyhyKXt2YXIgZT1mYWxzZTtuKHAsKGZ1bmN0aW9uKHQsbil7aWYoIWUpe3RyeXtlPXQuY2FsbChyKT09PW59Y2F0Y2gocil7fX19KSk7cmV0dXJuIGV9O3IuZXhwb3J0cz1mdW5jdGlvbiBpc1R5cGVkQXJyYXkocil7aWYoIXJ8fHR5cGVvZiByIT09XCJvYmplY3RcIil7cmV0dXJuIGZhbHNlfWlmKCF1KXt2YXIgZT1jKGEociksOCwtMSk7cmV0dXJuIHkocyxlKT4tMX1pZighbCl7cmV0dXJuIGZhbHNlfXJldHVybiBiKHIpfX0sMzY5OmZ1bmN0aW9uKHIpe3IuZXhwb3J0cz1mdW5jdGlvbiBpc0J1ZmZlcihyKXtyZXR1cm4gciBpbnN0YW5jZW9mIEJ1ZmZlcn19LDU4NDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCgxNTcpO3ZhciBvPXQoMzkxKTt2YXIgaT10KDQ5MCk7dmFyIGE9dCg5OTQpO2Z1bmN0aW9uIHVuY3VycnlUaGlzKHIpe3JldHVybiByLmNhbGwuYmluZChyKX12YXIgZj10eXBlb2YgQmlnSW50IT09XCJ1bmRlZmluZWRcIjt2YXIgdT10eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIjt2YXIgcz11bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTt2YXIgeT11bmN1cnJ5VGhpcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YpO3ZhciBjPXVuY3VycnlUaGlzKFN0cmluZy5wcm90b3R5cGUudmFsdWVPZik7dmFyIHA9dW5jdXJyeVRoaXMoQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZik7aWYoZil7dmFyIGw9dW5jdXJyeVRoaXMoQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mKX1pZih1KXt2YXIgZz11bmN1cnJ5VGhpcyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpfWZ1bmN0aW9uIGNoZWNrQm94ZWRQcmltaXRpdmUocixlKXtpZih0eXBlb2YgciE9PVwib2JqZWN0XCIpe3JldHVybiBmYWxzZX10cnl7ZShyKTtyZXR1cm4gdHJ1ZX1jYXRjaChyKXtyZXR1cm4gZmFsc2V9fWUuaXNBcmd1bWVudHNPYmplY3Q9bjtlLmlzR2VuZXJhdG9yRnVuY3Rpb249bztlLmlzVHlwZWRBcnJheT1hO2Z1bmN0aW9uIGlzUHJvbWlzZShyKXtyZXR1cm4gdHlwZW9mIFByb21pc2UhPT1cInVuZGVmaW5lZFwiJiZyIGluc3RhbmNlb2YgUHJvbWlzZXx8ciE9PW51bGwmJnR5cGVvZiByPT09XCJvYmplY3RcIiYmdHlwZW9mIHIudGhlbj09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIHIuY2F0Y2g9PT1cImZ1bmN0aW9uXCJ9ZS5pc1Byb21pc2U9aXNQcm9taXNlO2Z1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHIpe2lmKHR5cGVvZiBBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCImJkFycmF5QnVmZmVyLmlzVmlldyl7cmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhyKX1yZXR1cm4gYShyKXx8aXNEYXRhVmlldyhyKX1lLmlzQXJyYXlCdWZmZXJWaWV3PWlzQXJyYXlCdWZmZXJWaWV3O2Z1bmN0aW9uIGlzVWludDhBcnJheShyKXtyZXR1cm4gaShyKT09PVwiVWludDhBcnJheVwifWUuaXNVaW50OEFycmF5PWlzVWludDhBcnJheTtmdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJVaW50OENsYW1wZWRBcnJheVwifWUuaXNVaW50OENsYW1wZWRBcnJheT1pc1VpbnQ4Q2xhbXBlZEFycmF5O2Z1bmN0aW9uIGlzVWludDE2QXJyYXkocil7cmV0dXJuIGkocik9PT1cIlVpbnQxNkFycmF5XCJ9ZS5pc1VpbnQxNkFycmF5PWlzVWludDE2QXJyYXk7ZnVuY3Rpb24gaXNVaW50MzJBcnJheShyKXtyZXR1cm4gaShyKT09PVwiVWludDMyQXJyYXlcIn1lLmlzVWludDMyQXJyYXk9aXNVaW50MzJBcnJheTtmdW5jdGlvbiBpc0ludDhBcnJheShyKXtyZXR1cm4gaShyKT09PVwiSW50OEFycmF5XCJ9ZS5pc0ludDhBcnJheT1pc0ludDhBcnJheTtmdW5jdGlvbiBpc0ludDE2QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkludDE2QXJyYXlcIn1lLmlzSW50MTZBcnJheT1pc0ludDE2QXJyYXk7ZnVuY3Rpb24gaXNJbnQzMkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJJbnQzMkFycmF5XCJ9ZS5pc0ludDMyQXJyYXk9aXNJbnQzMkFycmF5O2Z1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJGbG9hdDMyQXJyYXlcIn1lLmlzRmxvYXQzMkFycmF5PWlzRmxvYXQzMkFycmF5O2Z1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJGbG9hdDY0QXJyYXlcIn1lLmlzRmxvYXQ2NEFycmF5PWlzRmxvYXQ2NEFycmF5O2Z1bmN0aW9uIGlzQmlnSW50NjRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiQmlnSW50NjRBcnJheVwifWUuaXNCaWdJbnQ2NEFycmF5PWlzQmlnSW50NjRBcnJheTtmdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJCaWdVaW50NjRBcnJheVwifWUuaXNCaWdVaW50NjRBcnJheT1pc0JpZ1VpbnQ2NEFycmF5O2Z1bmN0aW9uIGlzTWFwVG9TdHJpbmcocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgTWFwXVwifWlzTWFwVG9TdHJpbmcud29ya2luZz10eXBlb2YgTWFwIT09XCJ1bmRlZmluZWRcIiYmaXNNYXBUb1N0cmluZyhuZXcgTWFwKTtmdW5jdGlvbiBpc01hcChyKXtpZih0eXBlb2YgTWFwPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc01hcFRvU3RyaW5nLndvcmtpbmc/aXNNYXBUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgTWFwfWUuaXNNYXA9aXNNYXA7ZnVuY3Rpb24gaXNTZXRUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBTZXRdXCJ9aXNTZXRUb1N0cmluZy53b3JraW5nPXR5cGVvZiBTZXQhPT1cInVuZGVmaW5lZFwiJiZpc1NldFRvU3RyaW5nKG5ldyBTZXQpO2Z1bmN0aW9uIGlzU2V0KHIpe2lmKHR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGlzU2V0VG9TdHJpbmcud29ya2luZz9pc1NldFRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBTZXR9ZS5pc1NldD1pc1NldDtmdW5jdGlvbiBpc1dlYWtNYXBUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBXZWFrTWFwXVwifWlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIFdlYWtNYXAhPT1cInVuZGVmaW5lZFwiJiZpc1dlYWtNYXBUb1N0cmluZyhuZXcgV2Vha01hcCk7ZnVuY3Rpb24gaXNXZWFrTWFwKHIpe2lmKHR5cGVvZiBXZWFrTWFwPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc1dlYWtNYXBUb1N0cmluZy53b3JraW5nP2lzV2Vha01hcFRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBXZWFrTWFwfWUuaXNXZWFrTWFwPWlzV2Vha01hcDtmdW5jdGlvbiBpc1dlYWtTZXRUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBXZWFrU2V0XVwifWlzV2Vha1NldFRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIFdlYWtTZXQhPT1cInVuZGVmaW5lZFwiJiZpc1dlYWtTZXRUb1N0cmluZyhuZXcgV2Vha1NldCk7ZnVuY3Rpb24gaXNXZWFrU2V0KHIpe3JldHVybiBpc1dlYWtTZXRUb1N0cmluZyhyKX1lLmlzV2Vha1NldD1pc1dlYWtTZXQ7ZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IEFycmF5QnVmZmVyXVwifWlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nPXR5cGVvZiBBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCImJmlzQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgQXJyYXlCdWZmZXIpO2Z1bmN0aW9uIGlzQXJyYXlCdWZmZXIocil7aWYodHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz9pc0FycmF5QnVmZmVyVG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfWUuaXNBcnJheUJ1ZmZlcj1pc0FycmF5QnVmZmVyO2Z1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBEYXRhVmlld11cIn1pc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZz10eXBlb2YgQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiZ0eXBlb2YgRGF0YVZpZXchPT1cInVuZGVmaW5lZFwiJiZpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwwLDEpKTtmdW5jdGlvbiBpc0RhdGFWaWV3KHIpe2lmKHR5cGVvZiBEYXRhVmlldz09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmc/aXNEYXRhVmlld1RvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBEYXRhVmlld31lLmlzRGF0YVZpZXc9aXNEYXRhVmlldzt2YXIgYj10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiP1NoYXJlZEFycmF5QnVmZmVyOnVuZGVmaW5lZDtmdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdXCJ9ZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlcihyKXtpZih0eXBlb2YgYj09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc9PT1cInVuZGVmaW5lZFwiKXtpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz1pc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcobmV3IGIpfXJldHVybiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz9pc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIGJ9ZS5pc1NoYXJlZEFycmF5QnVmZmVyPWlzU2hhcmVkQXJyYXlCdWZmZXI7ZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dXCJ9ZS5pc0FzeW5jRnVuY3Rpb249aXNBc3luY0Z1bmN0aW9uO2Z1bmN0aW9uIGlzTWFwSXRlcmF0b3Iocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgTWFwIEl0ZXJhdG9yXVwifWUuaXNNYXBJdGVyYXRvcj1pc01hcEl0ZXJhdG9yO2Z1bmN0aW9uIGlzU2V0SXRlcmF0b3Iocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgU2V0IEl0ZXJhdG9yXVwifWUuaXNTZXRJdGVyYXRvcj1pc1NldEl0ZXJhdG9yO2Z1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IEdlbmVyYXRvcl1cIn1lLmlzR2VuZXJhdG9yT2JqZWN0PWlzR2VuZXJhdG9yT2JqZWN0O2Z1bmN0aW9uIGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZShyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBXZWJBc3NlbWJseS5Nb2R1bGVdXCJ9ZS5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU9aXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlO2Z1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHIpe3JldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHIseSl9ZS5pc051bWJlck9iamVjdD1pc051bWJlck9iamVjdDtmdW5jdGlvbiBpc1N0cmluZ09iamVjdChyKXtyZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZShyLGMpfWUuaXNTdHJpbmdPYmplY3Q9aXNTdHJpbmdPYmplY3Q7ZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHIpe3JldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHIscCl9ZS5pc0Jvb2xlYW5PYmplY3Q9aXNCb29sZWFuT2JqZWN0O2Z1bmN0aW9uIGlzQmlnSW50T2JqZWN0KHIpe3JldHVybiBmJiZjaGVja0JveGVkUHJpbWl0aXZlKHIsbCl9ZS5pc0JpZ0ludE9iamVjdD1pc0JpZ0ludE9iamVjdDtmdW5jdGlvbiBpc1N5bWJvbE9iamVjdChyKXtyZXR1cm4gdSYmY2hlY2tCb3hlZFByaW1pdGl2ZShyLGcpfWUuaXNTeW1ib2xPYmplY3Q9aXNTeW1ib2xPYmplY3Q7ZnVuY3Rpb24gaXNCb3hlZFByaW1pdGl2ZShyKXtyZXR1cm4gaXNOdW1iZXJPYmplY3Qocil8fGlzU3RyaW5nT2JqZWN0KHIpfHxpc0Jvb2xlYW5PYmplY3Qocil8fGlzQmlnSW50T2JqZWN0KHIpfHxpc1N5bWJvbE9iamVjdChyKX1lLmlzQm94ZWRQcmltaXRpdmU9aXNCb3hlZFByaW1pdGl2ZTtmdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHIpe3JldHVybiB0eXBlb2YgVWludDhBcnJheSE9PVwidW5kZWZpbmVkXCImJihpc0FycmF5QnVmZmVyKHIpfHxpc1NoYXJlZEFycmF5QnVmZmVyKHIpKX1lLmlzQW55QXJyYXlCdWZmZXI9aXNBbnlBcnJheUJ1ZmZlcjtbXCJpc1Byb3h5XCIsXCJpc0V4dGVybmFsXCIsXCJpc01vZHVsZU5hbWVzcGFjZU9iamVjdFwiXS5mb3JFYWNoKChmdW5jdGlvbihyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOmZhbHNlLHZhbHVlOmZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKHIrXCIgaXMgbm90IHN1cHBvcnRlZCBpbiB1c2VybGFuZFwiKX19KX0pKX0sMTc3OmZ1bmN0aW9uKHIsZSx0KXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yc3x8ZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhyKXt2YXIgZT1PYmplY3Qua2V5cyhyKTt2YXIgdD17fTtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dFtlW25dXT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZVtuXSl9cmV0dXJuIHR9O3ZhciBvPS8lW3NkaiVdL2c7ZS5mb3JtYXQ9ZnVuY3Rpb24ocil7aWYoIWlzU3RyaW5nKHIpKXt2YXIgZT1bXTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXtlLnB1c2goaW5zcGVjdChhcmd1bWVudHNbdF0pKX1yZXR1cm4gZS5qb2luKFwiIFwiKX12YXIgdD0xO3ZhciBuPWFyZ3VtZW50czt2YXIgaT1uLmxlbmd0aDt2YXIgYT1TdHJpbmcocikucmVwbGFjZShvLChmdW5jdGlvbihyKXtpZihyPT09XCIlJVwiKXJldHVyblwiJVwiO2lmKHQ+PWkpcmV0dXJuIHI7c3dpdGNoKHIpe2Nhc2VcIiVzXCI6cmV0dXJuIFN0cmluZyhuW3QrK10pO2Nhc2VcIiVkXCI6cmV0dXJuIE51bWJlcihuW3QrK10pO2Nhc2VcIiVqXCI6dHJ5e3JldHVybiBKU09OLnN0cmluZ2lmeShuW3QrK10pfWNhdGNoKHIpe3JldHVyblwiW0NpcmN1bGFyXVwifWRlZmF1bHQ6cmV0dXJuIHJ9fSkpO2Zvcih2YXIgZj1uW3RdO3Q8aTtmPW5bKyt0XSl7aWYoaXNOdWxsKGYpfHwhaXNPYmplY3QoZikpe2ErPVwiIFwiK2Z9ZWxzZXthKz1cIiBcIitpbnNwZWN0KGYpfX1yZXR1cm4gYX07ZS5kZXByZWNhdGU9ZnVuY3Rpb24ocix0KXtpZih0eXBlb2YgcHJvY2VzcyE9PVwidW5kZWZpbmVkXCImJnByb2Nlc3Mubm9EZXByZWNhdGlvbj09PXRydWUpe3JldHVybiByfWlmKHR5cGVvZiBwcm9jZXNzPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUuZGVwcmVjYXRlKHIsdCkuYXBwbHkodGhpcyxhcmd1bWVudHMpfX12YXIgbj1mYWxzZTtmdW5jdGlvbiBkZXByZWNhdGVkKCl7aWYoIW4pe2lmKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbil7dGhyb3cgbmV3IEVycm9yKHQpfWVsc2UgaWYocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKXtjb25zb2xlLnRyYWNlKHQpfWVsc2V7Y29uc29sZS5lcnJvcih0KX1uPXRydWV9cmV0dXJuIHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBkZXByZWNhdGVkfTt2YXIgaT17fTt2YXIgYT0vXiQvO2lmKHByb2Nlc3MuZW52Lk5PREVfREVCVUcpe3ZhciBmPXByb2Nlc3MuZW52Lk5PREVfREVCVUc7Zj1mLnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csXCJcXFxcJCZcIikucmVwbGFjZSgvXFwqL2csXCIuKlwiKS5yZXBsYWNlKC8sL2csXCIkfF5cIikudG9VcHBlckNhc2UoKTthPW5ldyBSZWdFeHAoXCJeXCIrZitcIiRcIixcImlcIil9ZS5kZWJ1Z2xvZz1mdW5jdGlvbihyKXtyPXIudG9VcHBlckNhc2UoKTtpZighaVtyXSl7aWYoYS50ZXN0KHIpKXt2YXIgdD1wcm9jZXNzLnBpZDtpW3JdPWZ1bmN0aW9uKCl7dmFyIG49ZS5mb3JtYXQuYXBwbHkoZSxhcmd1bWVudHMpO2NvbnNvbGUuZXJyb3IoXCIlcyAlZDogJXNcIixyLHQsbil9fWVsc2V7aVtyXT1mdW5jdGlvbigpe319fXJldHVybiBpW3JdfTtmdW5jdGlvbiBpbnNwZWN0KHIsdCl7dmFyIG49e3NlZW46W10sc3R5bGl6ZTpzdHlsaXplTm9Db2xvcn07aWYoYXJndW1lbnRzLmxlbmd0aD49MyluLmRlcHRoPWFyZ3VtZW50c1syXTtpZihhcmd1bWVudHMubGVuZ3RoPj00KW4uY29sb3JzPWFyZ3VtZW50c1szXTtpZihpc0Jvb2xlYW4odCkpe24uc2hvd0hpZGRlbj10fWVsc2UgaWYodCl7ZS5fZXh0ZW5kKG4sdCl9aWYoaXNVbmRlZmluZWQobi5zaG93SGlkZGVuKSluLnNob3dIaWRkZW49ZmFsc2U7aWYoaXNVbmRlZmluZWQobi5kZXB0aCkpbi5kZXB0aD0yO2lmKGlzVW5kZWZpbmVkKG4uY29sb3JzKSluLmNvbG9ycz1mYWxzZTtpZihpc1VuZGVmaW5lZChuLmN1c3RvbUluc3BlY3QpKW4uY3VzdG9tSW5zcGVjdD10cnVlO2lmKG4uY29sb3JzKW4uc3R5bGl6ZT1zdHlsaXplV2l0aENvbG9yO3JldHVybiBmb3JtYXRWYWx1ZShuLHIsbi5kZXB0aCl9ZS5pbnNwZWN0PWluc3BlY3Q7aW5zcGVjdC5jb2xvcnM9e2JvbGQ6WzEsMjJdLGl0YWxpYzpbMywyM10sdW5kZXJsaW5lOls0LDI0XSxpbnZlcnNlOls3LDI3XSx3aGl0ZTpbMzcsMzldLGdyZXk6WzkwLDM5XSxibGFjazpbMzAsMzldLGJsdWU6WzM0LDM5XSxjeWFuOlszNiwzOV0sZ3JlZW46WzMyLDM5XSxtYWdlbnRhOlszNSwzOV0scmVkOlszMSwzOV0seWVsbG93OlszMywzOV19O2luc3BlY3Quc3R5bGVzPXtzcGVjaWFsOlwiY3lhblwiLG51bWJlcjpcInllbGxvd1wiLGJvb2xlYW46XCJ5ZWxsb3dcIix1bmRlZmluZWQ6XCJncmV5XCIsbnVsbDpcImJvbGRcIixzdHJpbmc6XCJncmVlblwiLGRhdGU6XCJtYWdlbnRhXCIscmVnZXhwOlwicmVkXCJ9O2Z1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3IocixlKXt2YXIgdD1pbnNwZWN0LnN0eWxlc1tlXTtpZih0KXtyZXR1cm5cIlx1MDAxYltcIitpbnNwZWN0LmNvbG9yc1t0XVswXStcIm1cIityK1wiXHUwMDFiW1wiK2luc3BlY3QuY29sb3JzW3RdWzFdK1wibVwifWVsc2V7cmV0dXJuIHJ9fWZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHIsZSl7cmV0dXJuIHJ9ZnVuY3Rpb24gYXJyYXlUb0hhc2gocil7dmFyIGU9e307ci5mb3JFYWNoKChmdW5jdGlvbihyLHQpe2Vbcl09dHJ1ZX0pKTtyZXR1cm4gZX1mdW5jdGlvbiBmb3JtYXRWYWx1ZShyLHQsbil7aWYoci5jdXN0b21JbnNwZWN0JiZ0JiZpc0Z1bmN0aW9uKHQuaW5zcGVjdCkmJnQuaW5zcGVjdCE9PWUuaW5zcGVjdCYmISh0LmNvbnN0cnVjdG9yJiZ0LmNvbnN0cnVjdG9yLnByb3RvdHlwZT09PXQpKXt2YXIgbz10Lmluc3BlY3QobixyKTtpZighaXNTdHJpbmcobykpe289Zm9ybWF0VmFsdWUocixvLG4pfXJldHVybiBvfXZhciBpPWZvcm1hdFByaW1pdGl2ZShyLHQpO2lmKGkpe3JldHVybiBpfXZhciBhPU9iamVjdC5rZXlzKHQpO3ZhciBmPWFycmF5VG9IYXNoKGEpO2lmKHIuc2hvd0hpZGRlbil7YT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0KX1pZihpc0Vycm9yKHQpJiYoYS5pbmRleE9mKFwibWVzc2FnZVwiKT49MHx8YS5pbmRleE9mKFwiZGVzY3JpcHRpb25cIik+PTApKXtyZXR1cm4gZm9ybWF0RXJyb3IodCl9aWYoYS5sZW5ndGg9PT0wKXtpZihpc0Z1bmN0aW9uKHQpKXt2YXIgdT10Lm5hbWU/XCI6IFwiK3QubmFtZTpcIlwiO3JldHVybiByLnN0eWxpemUoXCJbRnVuY3Rpb25cIit1K1wiXVwiLFwic3BlY2lhbFwiKX1pZihpc1JlZ0V4cCh0KSl7cmV0dXJuIHIuc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCksXCJyZWdleHBcIil9aWYoaXNEYXRlKHQpKXtyZXR1cm4gci5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCksXCJkYXRlXCIpfWlmKGlzRXJyb3IodCkpe3JldHVybiBmb3JtYXRFcnJvcih0KX19dmFyIHM9XCJcIix5PWZhbHNlLGM9W1wie1wiLFwifVwiXTtpZihpc0FycmF5KHQpKXt5PXRydWU7Yz1bXCJbXCIsXCJdXCJdfWlmKGlzRnVuY3Rpb24odCkpe3ZhciBwPXQubmFtZT9cIjogXCIrdC5uYW1lOlwiXCI7cz1cIiBbRnVuY3Rpb25cIitwK1wiXVwifWlmKGlzUmVnRXhwKHQpKXtzPVwiIFwiK1JlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX1pZihpc0RhdGUodCkpe3M9XCIgXCIrRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh0KX1pZihpc0Vycm9yKHQpKXtzPVwiIFwiK2Zvcm1hdEVycm9yKHQpfWlmKGEubGVuZ3RoPT09MCYmKCF5fHx0Lmxlbmd0aD09MCkpe3JldHVybiBjWzBdK3MrY1sxXX1pZihuPDApe2lmKGlzUmVnRXhwKHQpKXtyZXR1cm4gci5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSxcInJlZ2V4cFwiKX1lbHNle3JldHVybiByLnN0eWxpemUoXCJbT2JqZWN0XVwiLFwic3BlY2lhbFwiKX19ci5zZWVuLnB1c2godCk7dmFyIGw7aWYoeSl7bD1mb3JtYXRBcnJheShyLHQsbixmLGEpfWVsc2V7bD1hLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGZvcm1hdFByb3BlcnR5KHIsdCxuLGYsZSx5KX0pKX1yLnNlZW4ucG9wKCk7cmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKGwscyxjKX1mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUocixlKXtpZihpc1VuZGVmaW5lZChlKSlyZXR1cm4gci5zdHlsaXplKFwidW5kZWZpbmVkXCIsXCJ1bmRlZmluZWRcIik7aWYoaXNTdHJpbmcoZSkpe3ZhciB0PVwiJ1wiK0pTT04uc3RyaW5naWZ5KGUpLnJlcGxhY2UoL15cInxcIiQvZyxcIlwiKS5yZXBsYWNlKC8nL2csXCJcXFxcJ1wiKS5yZXBsYWNlKC9cXFxcXCIvZywnXCInKStcIidcIjtyZXR1cm4gci5zdHlsaXplKHQsXCJzdHJpbmdcIil9aWYoaXNOdW1iZXIoZSkpcmV0dXJuIHIuc3R5bGl6ZShcIlwiK2UsXCJudW1iZXJcIik7aWYoaXNCb29sZWFuKGUpKXJldHVybiByLnN0eWxpemUoXCJcIitlLFwiYm9vbGVhblwiKTtpZihpc051bGwoZSkpcmV0dXJuIHIuc3R5bGl6ZShcIm51bGxcIixcIm51bGxcIil9ZnVuY3Rpb24gZm9ybWF0RXJyb3Iocil7cmV0dXJuXCJbXCIrRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocikrXCJdXCJ9ZnVuY3Rpb24gZm9ybWF0QXJyYXkocixlLHQsbixvKXt2YXIgaT1bXTtmb3IodmFyIGE9MCxmPWUubGVuZ3RoO2E8ZjsrK2Epe2lmKGhhc093blByb3BlcnR5KGUsU3RyaW5nKGEpKSl7aS5wdXNoKGZvcm1hdFByb3BlcnR5KHIsZSx0LG4sU3RyaW5nKGEpLHRydWUpKX1lbHNle2kucHVzaChcIlwiKX19by5mb3JFYWNoKChmdW5jdGlvbihvKXtpZighby5tYXRjaCgvXlxcZCskLykpe2kucHVzaChmb3JtYXRQcm9wZXJ0eShyLGUsdCxuLG8sdHJ1ZSkpfX0pKTtyZXR1cm4gaX1mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShyLGUsdCxuLG8saSl7dmFyIGEsZix1O3U9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG8pfHx7dmFsdWU6ZVtvXX07aWYodS5nZXQpe2lmKHUuc2V0KXtmPXIuc3R5bGl6ZShcIltHZXR0ZXIvU2V0dGVyXVwiLFwic3BlY2lhbFwiKX1lbHNle2Y9ci5zdHlsaXplKFwiW0dldHRlcl1cIixcInNwZWNpYWxcIil9fWVsc2V7aWYodS5zZXQpe2Y9ci5zdHlsaXplKFwiW1NldHRlcl1cIixcInNwZWNpYWxcIil9fWlmKCFoYXNPd25Qcm9wZXJ0eShuLG8pKXthPVwiW1wiK28rXCJdXCJ9aWYoIWYpe2lmKHIuc2Vlbi5pbmRleE9mKHUudmFsdWUpPDApe2lmKGlzTnVsbCh0KSl7Zj1mb3JtYXRWYWx1ZShyLHUudmFsdWUsbnVsbCl9ZWxzZXtmPWZvcm1hdFZhbHVlKHIsdS52YWx1ZSx0LTEpfWlmKGYuaW5kZXhPZihcIlxcblwiKT4tMSl7aWYoaSl7Zj1mLnNwbGl0KFwiXFxuXCIpLm1hcCgoZnVuY3Rpb24ocil7cmV0dXJuXCIgIFwiK3J9KSkuam9pbihcIlxcblwiKS5zdWJzdHIoMil9ZWxzZXtmPVwiXFxuXCIrZi5zcGxpdChcIlxcblwiKS5tYXAoKGZ1bmN0aW9uKHIpe3JldHVyblwiICAgXCIrcn0pKS5qb2luKFwiXFxuXCIpfX19ZWxzZXtmPXIuc3R5bGl6ZShcIltDaXJjdWxhcl1cIixcInNwZWNpYWxcIil9fWlmKGlzVW5kZWZpbmVkKGEpKXtpZihpJiZvLm1hdGNoKC9eXFxkKyQvKSl7cmV0dXJuIGZ9YT1KU09OLnN0cmluZ2lmeShcIlwiK28pO2lmKGEubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKXthPWEuc3Vic3RyKDEsYS5sZW5ndGgtMik7YT1yLnN0eWxpemUoYSxcIm5hbWVcIil9ZWxzZXthPWEucmVwbGFjZSgvJy9nLFwiXFxcXCdcIikucmVwbGFjZSgvXFxcXFwiL2csJ1wiJykucmVwbGFjZSgvKF5cInxcIiQpL2csXCInXCIpO2E9ci5zdHlsaXplKGEsXCJzdHJpbmdcIil9fXJldHVybiBhK1wiOiBcIitmfWZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKHIsZSx0KXt2YXIgbj0wO3ZhciBvPXIucmVkdWNlKChmdW5jdGlvbihyLGUpe24rKztpZihlLmluZGV4T2YoXCJcXG5cIik+PTApbisrO3JldHVybiByK2UucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csXCJcIikubGVuZ3RoKzF9KSwwKTtpZihvPjYwKXtyZXR1cm4gdFswXSsoZT09PVwiXCI/XCJcIjplK1wiXFxuIFwiKStcIiBcIityLmpvaW4oXCIsXFxuICBcIikrXCIgXCIrdFsxXX1yZXR1cm4gdFswXStlK1wiIFwiK3Iuam9pbihcIiwgXCIpK1wiIFwiK3RbMV19ZS50eXBlcz10KDU4NCk7ZnVuY3Rpb24gaXNBcnJheShyKXtyZXR1cm4gQXJyYXkuaXNBcnJheShyKX1lLmlzQXJyYXk9aXNBcnJheTtmdW5jdGlvbiBpc0Jvb2xlYW4ocil7cmV0dXJuIHR5cGVvZiByPT09XCJib29sZWFuXCJ9ZS5pc0Jvb2xlYW49aXNCb29sZWFuO2Z1bmN0aW9uIGlzTnVsbChyKXtyZXR1cm4gcj09PW51bGx9ZS5pc051bGw9aXNOdWxsO2Z1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHIpe3JldHVybiByPT1udWxsfWUuaXNOdWxsT3JVbmRlZmluZWQ9aXNOdWxsT3JVbmRlZmluZWQ7ZnVuY3Rpb24gaXNOdW1iZXIocil7cmV0dXJuIHR5cGVvZiByPT09XCJudW1iZXJcIn1lLmlzTnVtYmVyPWlzTnVtYmVyO2Z1bmN0aW9uIGlzU3RyaW5nKHIpe3JldHVybiB0eXBlb2Ygcj09PVwic3RyaW5nXCJ9ZS5pc1N0cmluZz1pc1N0cmluZztmdW5jdGlvbiBpc1N5bWJvbChyKXtyZXR1cm4gdHlwZW9mIHI9PT1cInN5bWJvbFwifWUuaXNTeW1ib2w9aXNTeW1ib2w7ZnVuY3Rpb24gaXNVbmRlZmluZWQocil7cmV0dXJuIHI9PT12b2lkIDB9ZS5pc1VuZGVmaW5lZD1pc1VuZGVmaW5lZDtmdW5jdGlvbiBpc1JlZ0V4cChyKXtyZXR1cm4gaXNPYmplY3QocikmJm9iamVjdFRvU3RyaW5nKHIpPT09XCJbb2JqZWN0IFJlZ0V4cF1cIn1lLmlzUmVnRXhwPWlzUmVnRXhwO2UudHlwZXMuaXNSZWdFeHA9aXNSZWdFeHA7ZnVuY3Rpb24gaXNPYmplY3Qocil7cmV0dXJuIHR5cGVvZiByPT09XCJvYmplY3RcIiYmciE9PW51bGx9ZS5pc09iamVjdD1pc09iamVjdDtmdW5jdGlvbiBpc0RhdGUocil7cmV0dXJuIGlzT2JqZWN0KHIpJiZvYmplY3RUb1N0cmluZyhyKT09PVwiW29iamVjdCBEYXRlXVwifWUuaXNEYXRlPWlzRGF0ZTtlLnR5cGVzLmlzRGF0ZT1pc0RhdGU7ZnVuY3Rpb24gaXNFcnJvcihyKXtyZXR1cm4gaXNPYmplY3QocikmJihvYmplY3RUb1N0cmluZyhyKT09PVwiW29iamVjdCBFcnJvcl1cInx8ciBpbnN0YW5jZW9mIEVycm9yKX1lLmlzRXJyb3I9aXNFcnJvcjtlLnR5cGVzLmlzTmF0aXZlRXJyb3I9aXNFcnJvcjtmdW5jdGlvbiBpc0Z1bmN0aW9uKHIpe3JldHVybiB0eXBlb2Ygcj09PVwiZnVuY3Rpb25cIn1lLmlzRnVuY3Rpb249aXNGdW5jdGlvbjtmdW5jdGlvbiBpc1ByaW1pdGl2ZShyKXtyZXR1cm4gcj09PW51bGx8fHR5cGVvZiByPT09XCJib29sZWFuXCJ8fHR5cGVvZiByPT09XCJudW1iZXJcInx8dHlwZW9mIHI9PT1cInN0cmluZ1wifHx0eXBlb2Ygcj09PVwic3ltYm9sXCJ8fHR5cGVvZiByPT09XCJ1bmRlZmluZWRcIn1lLmlzUHJpbWl0aXZlPWlzUHJpbWl0aXZlO2UuaXNCdWZmZXI9dCgzNjkpO2Z1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHIpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocil9ZnVuY3Rpb24gcGFkKHIpe3JldHVybiByPDEwP1wiMFwiK3IudG9TdHJpbmcoMTApOnIudG9TdHJpbmcoMTApfXZhciB1PVtcIkphblwiLFwiRmViXCIsXCJNYXJcIixcIkFwclwiLFwiTWF5XCIsXCJKdW5cIixcIkp1bFwiLFwiQXVnXCIsXCJTZXBcIixcIk9jdFwiLFwiTm92XCIsXCJEZWNcIl07ZnVuY3Rpb24gdGltZXN0YW1wKCl7dmFyIHI9bmV3IERhdGU7dmFyIGU9W3BhZChyLmdldEhvdXJzKCkpLHBhZChyLmdldE1pbnV0ZXMoKSkscGFkKHIuZ2V0U2Vjb25kcygpKV0uam9pbihcIjpcIik7cmV0dXJuW3IuZ2V0RGF0ZSgpLHVbci5nZXRNb250aCgpXSxlXS5qb2luKFwiIFwiKX1lLmxvZz1mdW5jdGlvbigpe2NvbnNvbGUubG9nKFwiJXMgLSAlc1wiLHRpbWVzdGFtcCgpLGUuZm9ybWF0LmFwcGx5KGUsYXJndW1lbnRzKSl9O2UuaW5oZXJpdHM9dCg3ODIpO2UuX2V4dGVuZD1mdW5jdGlvbihyLGUpe2lmKCFlfHwhaXNPYmplY3QoZSkpcmV0dXJuIHI7dmFyIHQ9T2JqZWN0LmtleXMoZSk7dmFyIG49dC5sZW5ndGg7d2hpbGUobi0tKXtyW3Rbbl1dPWVbdFtuXV19cmV0dXJuIHJ9O2Z1bmN0aW9uIGhhc093blByb3BlcnR5KHIsZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLGUpfXZhciBzPXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiP1N5bWJvbChcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiKTp1bmRlZmluZWQ7ZS5wcm9taXNpZnk9ZnVuY3Rpb24gcHJvbWlzaWZ5KHIpe2lmKHR5cGVvZiByIT09XCJmdW5jdGlvblwiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7aWYocyYmcltzXSl7dmFyIGU9cltzXTtpZih0eXBlb2YgZSE9PVwiZnVuY3Rpb25cIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscyx7dmFsdWU6ZSxlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOmZhbHNlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7cmV0dXJuIGV9ZnVuY3Rpb24gZSgpe3ZhciBlLHQ7dmFyIG49bmV3IFByb21pc2UoKGZ1bmN0aW9uKHIsbil7ZT1yO3Q9bn0pKTt2YXIgbz1bXTtmb3IodmFyIGk9MDtpPGFyZ3VtZW50cy5sZW5ndGg7aSsrKXtvLnB1c2goYXJndW1lbnRzW2ldKX1vLnB1c2goKGZ1bmN0aW9uKHIsbil7aWYocil7dChyKX1lbHNle2Uobil9fSkpO3RyeXtyLmFwcGx5KHRoaXMsbyl9Y2F0Y2gocil7dChyKX1yZXR1cm4gbn1PYmplY3Quc2V0UHJvdG90eXBlT2YoZSxPYmplY3QuZ2V0UHJvdG90eXBlT2YocikpO2lmKHMpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscyx7dmFsdWU6ZSxlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOmZhbHNlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsbihyKSl9O2UucHJvbWlzaWZ5LmN1c3RvbT1zO2Z1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyLGUpe2lmKCFyKXt2YXIgdD1uZXcgRXJyb3IoXCJQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWVcIik7dC5yZWFzb249cjtyPXR9cmV0dXJuIGUocil9ZnVuY3Rpb24gY2FsbGJhY2tpZnkocil7aWYodHlwZW9mIHIhPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyl9ZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpe3ZhciBlPVtdO2Zvcih2YXIgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe2UucHVzaChhcmd1bWVudHNbdF0pfXZhciBuPWUucG9wKCk7aWYodHlwZW9mIG4hPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb25cIil9dmFyIG89dGhpczt2YXIgY2I9ZnVuY3Rpb24oKXtyZXR1cm4gbi5hcHBseShvLGFyZ3VtZW50cyl9O3IuYXBwbHkodGhpcyxlKS50aGVuKChmdW5jdGlvbihyKXtwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCxudWxsLHIpKX0pLChmdW5jdGlvbihyKXtwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZC5iaW5kKG51bGwscixjYikpfSkpfU9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLE9iamVjdC5nZXRQcm90b3R5cGVPZihyKSk7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxuKHIpKTtyZXR1cm4gY2FsbGJhY2tpZmllZH1lLmNhbGxiYWNraWZ5PWNhbGxiYWNraWZ5fSw0OTA6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoMTQ0KTt2YXIgbz10KDM0OSk7dmFyIGk9dCgyNTYpO3ZhciBhPWkoXCJPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXCIpO3ZhciBmPXQoOTQyKSgpO3ZhciB1PWYmJnR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PT1cInN5bWJvbFwiO3ZhciBzPW8oKTt2YXIgeT1pKFwiU3RyaW5nLnByb3RvdHlwZS5zbGljZVwiKTt2YXIgYz17fTt2YXIgcD10KDQ2Nik7dmFyIGw9T2JqZWN0LmdldFByb3RvdHlwZU9mO2lmKHUmJnAmJmwpe24ocywoZnVuY3Rpb24ocil7aWYodHlwZW9mIGdsb2JhbFtyXT09PVwiZnVuY3Rpb25cIil7dmFyIGU9bmV3IGdsb2JhbFtyXTtpZighKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBlKSl7dGhyb3cgbmV3IEV2YWxFcnJvcihcInRoaXMgZW5naW5lIGhhcyBzdXBwb3J0IGZvciBTeW1ib2wudG9TdHJpbmdUYWcsIGJ1dCBcIityK1wiIGRvZXMgbm90IGhhdmUgdGhlIHByb3BlcnR5ISBQbGVhc2UgcmVwb3J0IHRoaXMuXCIpfXZhciB0PWwoZSk7dmFyIG49cCh0LFN5bWJvbC50b1N0cmluZ1RhZyk7aWYoIW4pe3ZhciBvPWwodCk7bj1wKG8sU3ltYm9sLnRvU3RyaW5nVGFnKX1jW3JdPW4uZ2V0fX0pKX12YXIgZz1mdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyhyKXt2YXIgZT1mYWxzZTtuKGMsKGZ1bmN0aW9uKHQsbil7aWYoIWUpe3RyeXt2YXIgbz10LmNhbGwocik7aWYobz09PW4pe2U9b319Y2F0Y2gocil7fX19KSk7cmV0dXJuIGV9O3ZhciBiPXQoOTk0KTtyLmV4cG9ydHM9ZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHIpe2lmKCFiKHIpKXtyZXR1cm4gZmFsc2V9aWYoIXUpe3JldHVybiB5KGEociksOCwtMSl9cmV0dXJuIGcocil9fSwzNDk6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoOTkyKTtyLmV4cG9ydHM9ZnVuY3Rpb24gYXZhaWxhYmxlVHlwZWRBcnJheXMoKXtyZXR1cm4gbihbXCJCaWdJbnQ2NEFycmF5XCIsXCJCaWdVaW50NjRBcnJheVwiLFwiRmxvYXQzMkFycmF5XCIsXCJGbG9hdDY0QXJyYXlcIixcIkludDE2QXJyYXlcIixcIkludDMyQXJyYXlcIixcIkludDhBcnJheVwiLFwiVWludDE2QXJyYXlcIixcIlVpbnQzMkFycmF5XCIsXCJVaW50OEFycmF5XCIsXCJVaW50OENsYW1wZWRBcnJheVwiXSwoZnVuY3Rpb24ocil7cmV0dXJuIHR5cGVvZiBnbG9iYWxbcl09PT1cImZ1bmN0aW9uXCJ9KSl9fSw0NjY6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoODM4KTt2YXIgbz1uKFwiJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlXCIsdHJ1ZSk7aWYobyl7dHJ5e28oW10sXCJsZW5ndGhcIil9Y2F0Y2gocil7bz1udWxsfX1yLmV4cG9ydHM9b319O3ZhciBlPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIG49ZVt0XTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBvPWVbdF09e2V4cG9ydHM6e319O3ZhciBpPXRydWU7dHJ5e3JbdF0obyxvLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7aT1mYWxzZX1maW5hbGx5e2lmKGkpZGVsZXRlIGVbdF19cmV0dXJuIG8uZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXygxNzcpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6WyJyIiwiZXhwb3J0cyIsInQiLCJuIiwiZmlsdGVyIiwiVHlwZUVycm9yIiwibyIsImkiLCJsZW5ndGgiLCJlIiwiY2FsbCIsImEiLCJwdXNoIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsQm91bmRJbnRyaW5zaWMiLCJmIiwidSIsInMiLCJ5IiwidmFsdWUiLCJjYWxsQmluZCIsImFyZ3VtZW50cyIsImNvbmZpZ3VyYWJsZSIsImMiLCJhcHBseUJpbmQiLCJhcHBseSIsInRvU3RyaW5nIiwiZm9yRWFjaCIsIkFycmF5Iiwic2xpY2UiLCJiaW5kIiwiYmluZGVyIiwiY29uY2F0IiwiTWF0aCIsIm1heCIsIkZ1bmN0aW9uIiwiam9pbiIsIkVtcHR5IiwiU3ludGF4RXJyb3IiLCJnZXRFdmFsbGVkQ29uc3RydWN0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ0aHJvd1R5cGVFcnJvciIsImNhbGxlZSIsImdldCIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwicCIsIlVpbnQ4QXJyYXkiLCJsIiwiQWdncmVnYXRlRXJyb3IiLCJBcnJheUJ1ZmZlciIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiQXRvbWljcyIsIkJpZ0ludCIsIkJvb2xlYW4iLCJEYXRhVmlldyIsIkRhdGUiLCJkZWNvZGVVUkkiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlbmNvZGVVUkkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJFcnJvciIsImV2YWwiLCJFdmFsRXJyb3IiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiaXNGaW5pdGUiLCJpc05hTiIsIkpTT04iLCJNYXAiLCJOdW1iZXIiLCJwYXJzZUZsb2F0IiwicGFyc2VJbnQiLCJQcm9taXNlIiwiUHJveHkiLCJSYW5nZUVycm9yIiwiUmVmZXJlbmNlRXJyb3IiLCJSZWZsZWN0IiwiUmVnRXhwIiwiU2V0IiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJTdHJpbmciLCJVaW50OENsYW1wZWRBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJVUklFcnJvciIsIldlYWtNYXAiLCJXZWFrUmVmIiwiV2Vha1NldCIsImciLCJkb0V2YWwiLCJiIiwiZCIsInYiLCJtIiwiUyIsInNwbGljZSIsIkEiLCJyZXBsYWNlIiwiaCIsIk8iLCJqIiwidyIsInN0cmluZ1RvUGF0aCIsIlAiLCJnZXRCYXNlSW50cmluc2ljIiwiYWxpYXMiLCJuYW1lIiwiR2V0SW50cmluc2ljIiwiaGFzTmF0aXZlU3ltYm9scyIsImhhc1N5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZW51bWVyYWJsZSIsImNyZWF0ZSIsImluaGVyaXRzIiwic3VwZXJfIiwiY29uc3RydWN0b3IiLCJ3cml0YWJsZSIsIlRlbXBDdG9yIiwidG9TdHJpbmdUYWciLCJpc0FyZ3VtZW50cyIsImlzTGVnYWN5QXJndW1lbnRzIiwiZ2V0R2VuZXJhdG9yRnVuYyIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJ0ZXN0IiwiaW5kZXhPZiIsImdsb2JhbCIsInRyeUFsbFR5cGVkQXJyYXlzIiwiaXNUeXBlZEFycmF5IiwiaXNCdWZmZXIiLCJCdWZmZXIiLCJ1bmN1cnJ5VGhpcyIsInZhbHVlT2YiLCJjaGVja0JveGVkUHJpbWl0aXZlIiwiaXNBcmd1bWVudHNPYmplY3QiLCJpc1Byb21pc2UiLCJ0aGVuIiwiY2F0Y2giLCJpc0FycmF5QnVmZmVyVmlldyIsImlzVmlldyIsImlzRGF0YVZpZXciLCJpc1VpbnQ4QXJyYXkiLCJpc1VpbnQ4Q2xhbXBlZEFycmF5IiwiaXNVaW50MTZBcnJheSIsImlzVWludDMyQXJyYXkiLCJpc0ludDhBcnJheSIsImlzSW50MTZBcnJheSIsImlzSW50MzJBcnJheSIsImlzRmxvYXQzMkFycmF5IiwiaXNGbG9hdDY0QXJyYXkiLCJpc0JpZ0ludDY0QXJyYXkiLCJpc0JpZ1VpbnQ2NEFycmF5IiwiaXNNYXBUb1N0cmluZyIsIndvcmtpbmciLCJpc01hcCIsImlzU2V0VG9TdHJpbmciLCJpc1NldCIsImlzV2Vha01hcFRvU3RyaW5nIiwiaXNXZWFrTWFwIiwiaXNXZWFrU2V0VG9TdHJpbmciLCJpc1dlYWtTZXQiLCJpc0FycmF5QnVmZmVyVG9TdHJpbmciLCJpc0FycmF5QnVmZmVyIiwiaXNEYXRhVmlld1RvU3RyaW5nIiwidW5kZWZpbmVkIiwiaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nIiwiaXNTaGFyZWRBcnJheUJ1ZmZlciIsImlzQXN5bmNGdW5jdGlvbiIsImlzTWFwSXRlcmF0b3IiLCJpc1NldEl0ZXJhdG9yIiwiaXNHZW5lcmF0b3JPYmplY3QiLCJpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUiLCJpc051bWJlck9iamVjdCIsImlzU3RyaW5nT2JqZWN0IiwiaXNCb29sZWFuT2JqZWN0IiwiaXNCaWdJbnRPYmplY3QiLCJpc1N5bWJvbE9iamVjdCIsImlzQm94ZWRQcmltaXRpdmUiLCJpc0FueUFycmF5QnVmZmVyIiwiZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZm9ybWF0IiwiaXNTdHJpbmciLCJpbnNwZWN0Iiwic3RyaW5naWZ5IiwiaXNOdWxsIiwiaXNPYmplY3QiLCJkZXByZWNhdGUiLCJwcm9jZXNzIiwibm9EZXByZWNhdGlvbiIsImRlcHJlY2F0ZWQiLCJ0aHJvd0RlcHJlY2F0aW9uIiwidHJhY2VEZXByZWNhdGlvbiIsImNvbnNvbGUiLCJ0cmFjZSIsImVycm9yIiwiZW52IiwiTk9ERV9ERUJVRyIsInRvVXBwZXJDYXNlIiwiZGVidWdsb2ciLCJwaWQiLCJzZWVuIiwic3R5bGl6ZSIsInN0eWxpemVOb0NvbG9yIiwiZGVwdGgiLCJjb2xvcnMiLCJpc0Jvb2xlYW4iLCJzaG93SGlkZGVuIiwiX2V4dGVuZCIsImlzVW5kZWZpbmVkIiwiY3VzdG9tSW5zcGVjdCIsInN0eWxpemVXaXRoQ29sb3IiLCJmb3JtYXRWYWx1ZSIsImJvbGQiLCJpdGFsaWMiLCJ1bmRlcmxpbmUiLCJpbnZlcnNlIiwid2hpdGUiLCJncmV5IiwiYmxhY2siLCJibHVlIiwiY3lhbiIsImdyZWVuIiwibWFnZW50YSIsInJlZCIsInllbGxvdyIsInN0eWxlcyIsInNwZWNpYWwiLCJudW1iZXIiLCJib29sZWFuIiwibnVsbCIsInN0cmluZyIsImRhdGUiLCJyZWdleHAiLCJhcnJheVRvSGFzaCIsImlzRnVuY3Rpb24iLCJmb3JtYXRQcmltaXRpdmUiLCJpc0Vycm9yIiwiZm9ybWF0RXJyb3IiLCJpc1JlZ0V4cCIsImlzRGF0ZSIsImlzQXJyYXkiLCJ0b1VUQ1N0cmluZyIsImZvcm1hdEFycmF5IiwibWFwIiwiZm9ybWF0UHJvcGVydHkiLCJwb3AiLCJyZWR1Y2VUb1NpbmdsZVN0cmluZyIsImlzTnVtYmVyIiwibWF0Y2giLCJzZXQiLCJzcGxpdCIsInN1YnN0ciIsInJlZHVjZSIsInR5cGVzIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc1N5bWJvbCIsIm9iamVjdFRvU3RyaW5nIiwiaXNOYXRpdmVFcnJvciIsImlzUHJpbWl0aXZlIiwicGFkIiwidGltZXN0YW1wIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldERhdGUiLCJnZXRNb250aCIsImxvZyIsInByb21pc2lmeSIsInNldFByb3RvdHlwZU9mIiwiZGVmaW5lUHJvcGVydGllcyIsImN1c3RvbSIsImNhbGxiYWNraWZ5T25SZWplY3RlZCIsInJlYXNvbiIsImNhbGxiYWNraWZ5IiwiY2FsbGJhY2tpZmllZCIsImNiIiwibmV4dFRpY2siLCJ3aGljaFR5cGVkQXJyYXkiLCJhdmFpbGFibGVUeXBlZEFycmF5cyIsIl9fbmNjd3Bja19yZXF1aXJlX18iLCJhYiIsIl9fZGlybmFtZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/util/util.js\n"));

/***/ }),

/***/ "./node_modules/next/image.js":
/*!************************************!*\
  !*** ./node_modules/next/image.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/image */ \"./node_modules/next/dist/client/image.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQUEsMkdBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvaW1hZ2UuanM/MDUzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGllbnQvaW1hZ2UnKVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/image.js\n"));

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/link */ \"./node_modules/next/dist/client/link.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBQSx5R0FBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzPzc1YjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/link.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/** @license React v17.0.2\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nif (true) {\n  (function () {\n    'use strict';\n\n    var React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n    var _assign = __webpack_require__(/*! object-assign */ \"./node_modules/next/dist/build/polyfills/object-assign.js\"); // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n\n    var REACT_ELEMENT_TYPE = 0xeac7;\n    var REACT_PORTAL_TYPE = 0xeaca;\n    exports.Fragment = 0xeacb;\n    var REACT_STRICT_MODE_TYPE = 0xeacc;\n    var REACT_PROFILER_TYPE = 0xead2;\n    var REACT_PROVIDER_TYPE = 0xeacd;\n    var REACT_CONTEXT_TYPE = 0xeace;\n    var REACT_FORWARD_REF_TYPE = 0xead0;\n    var REACT_SUSPENSE_TYPE = 0xead1;\n    var REACT_SUSPENSE_LIST_TYPE = 0xead8;\n    var REACT_MEMO_TYPE = 0xead3;\n    var REACT_LAZY_TYPE = 0xead4;\n    var REACT_BLOCK_TYPE = 0xead9;\n    var REACT_SERVER_BLOCK_TYPE = 0xeada;\n    var REACT_FUNDAMENTAL_TYPE = 0xead5;\n    var REACT_SCOPE_TYPE = 0xead7;\n    var REACT_OPAQUE_ID_TYPE = 0xeae0;\n    var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\n    var REACT_OFFSCREEN_TYPE = 0xeae2;\n    var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\n\n    if (typeof Symbol === 'function' && Symbol.for) {\n      var symbolFor = Symbol.for;\n      REACT_ELEMENT_TYPE = symbolFor('react.element');\n      REACT_PORTAL_TYPE = symbolFor('react.portal');\n      exports.Fragment = symbolFor('react.fragment');\n      REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\n      REACT_PROFILER_TYPE = symbolFor('react.profiler');\n      REACT_PROVIDER_TYPE = symbolFor('react.provider');\n      REACT_CONTEXT_TYPE = symbolFor('react.context');\n      REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n      REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\n      REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\n      REACT_MEMO_TYPE = symbolFor('react.memo');\n      REACT_LAZY_TYPE = symbolFor('react.lazy');\n      REACT_BLOCK_TYPE = symbolFor('react.block');\n      REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');\n      REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');\n      REACT_SCOPE_TYPE = symbolFor('react.scope');\n      REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');\n      REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\n      REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\n      REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\n    }\n\n    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable !== 'object') {\n        return null;\n      }\n\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n\n      return null;\n    }\n\n    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n    function error(format) {\n      {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        printWarning('error', format, args);\n      }\n    }\n\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        }\n\n        var argsWithFormat = args.map(function (item) {\n          return '' + item;\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    } // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.\n\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n      if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {\n        return true;\n      }\n\n      if (typeof type === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var functionName = innerType.displayName || innerType.name || '';\n      return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n    }\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    }\n\n    function getComponentName(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      switch (type) {\n        case exports.Fragment:\n          return 'Fragment';\n\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n\n        case REACT_PROFILER_TYPE:\n          return 'Profiler';\n\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n\n        case REACT_SUSPENSE_TYPE:\n          return 'Suspense';\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return 'SuspenseList';\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n\n          case REACT_MEMO_TYPE:\n            return getComponentName(type.type);\n\n          case REACT_BLOCK_TYPE:\n            return getComponentName(type._render);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                return getComponentName(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n        }\n      }\n\n      return null;\n    } // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n\n\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n\n    function disabledLog() {}\n\n    disabledLog.__reactDisabledLog = true;\n\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        disabledDepth++;\n      }\n    }\n\n    function reenableLogs() {\n      {\n        disabledDepth--;\n\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: _assign({}, props, {\n              value: prevLog\n            }),\n            info: _assign({}, props, {\n              value: prevInfo\n            }),\n            warn: _assign({}, props, {\n              value: prevWarn\n            }),\n            error: _assign({}, props, {\n              value: prevError\n            }),\n            group: _assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: _assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: _assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n\n    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n        return '\\n' + prefix + name;\n      }\n    }\n\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n\n      {\n        var frame = componentFrameCache.get(fn);\n\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher.current = null;\n        disableLogs();\n      }\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\n\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame('Suspense');\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n          case REACT_BLOCK_TYPE:\n            return describeFunctionComponentFrame(type._render);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n\n      return '';\n    }\n\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n              setCurrentlyValidatingElement(null);\n            }\n\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n\n    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown;\n    var specialPropRefWarningShown;\n    var didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n\n    function warnIfStringRefCannotBeAutoConverted(config, self) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n          var componentName = getComponentName(ReactCurrentOwner.current.type);\n\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n\n    function defineKeyPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingKey = function () {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingKey.isReactWarning = true;\n        Object.defineProperty(props, 'key', {\n          get: warnAboutAccessingKey,\n          configurable: true\n        });\n      }\n    }\n\n    function defineRefPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingRef = function () {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingRef.isReactWarning = true;\n        Object.defineProperty(props, 'ref', {\n          get: warnAboutAccessingRef,\n          configurable: true\n        });\n      }\n    }\n    /**\n     * Factory method to create a new React element. This no longer adheres to\n     * the class pattern, so do not use new to call it. Also, instanceof check\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n     * if something is a React Element.\n     *\n     * @param {*} type\n     * @param {*} props\n     * @param {*} key\n     * @param {string|object} ref\n     * @param {*} owner\n     * @param {*} self A *temporary* helper to detect places where `this` is\n     * different from the `owner` when React.createElement is called, so that we\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n     * functions, and as long as `this` and owner are the same, there will be no\n     * change in behavior.\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\n     * indicating filename, line number, and/or other information.\n     * @internal\n     */\n\n\n    var ReactElement = function (type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\n     * https://github.com/reactjs/rfcs/pull/107\n     * @param {*} type\n     * @param {object} props\n     * @param {string} key\n     */\n\n\n    function jsxDEV(type, config, maybeKey, source, self) {\n      {\n        var propName; // Reserved names are extracted\n\n        var props = {};\n        var key = null;\n        var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n        // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n        // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n        // but as an intermediary step, we will use jsxDEV for everything except\n        // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n        // key is explicitly declared to be undefined or not.\n\n        if (maybeKey !== undefined) {\n          key = '' + maybeKey;\n        }\n\n        if (hasValidKey(config)) {\n          key = '' + config.key;\n        }\n\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          warnIfStringRefCannotBeAutoConverted(config, self);\n        } // Remaining properties are added to a new props object\n\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        } // Resolve default props\n\n\n        if (type && type.defaultProps) {\n          var defaultProps = type.defaultProps;\n\n          for (propName in defaultProps) {\n            if (props[propName] === undefined) {\n              props[propName] = defaultProps[propName];\n            }\n          }\n        }\n\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n\n        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n      }\n    }\n\n    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n    /**\n     * Verifies the object is a ReactElement.\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\n     * @param {?object} object\n     * @return {boolean} True if `object` is a ReactElement.\n     * @final\n     */\n\n    function isValidElement(object) {\n      {\n        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n      }\n    }\n\n    function getDeclarationErrorAddendum() {\n      {\n        if (ReactCurrentOwner$1.current) {\n          var name = getComponentName(ReactCurrentOwner$1.current.type);\n\n          if (name) {\n            return '\\n\\nCheck the render method of `' + name + '`.';\n          }\n        }\n\n        return '';\n      }\n    }\n\n    function getSourceInfoErrorAddendum(source) {\n      {\n        if (source !== undefined) {\n          var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n          var lineNumber = source.lineNumber;\n          return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n        }\n\n        return '';\n      }\n    }\n    /**\n     * Warn if there's no key explicitly set on dynamic arrays of children or\n     * object keys are not valid. This allows us to keep track of children between\n     * updates.\n     */\n\n\n    var ownerHasKeyUseWarning = {};\n\n    function getCurrentComponentErrorInfo(parentType) {\n      {\n        var info = getDeclarationErrorAddendum();\n\n        if (!info) {\n          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n          if (parentName) {\n            info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n          }\n        }\n\n        return info;\n      }\n    }\n    /**\n     * Warn if the element doesn't have an explicit key assigned to it.\n     * This element is in an array. The array could grow and shrink or be\n     * reordered. All children that haven't already been validated are required to\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n     * will only be shown once.\n     *\n     * @internal\n     * @param {ReactElement} element Element that requires a key.\n     * @param {*} parentType element's parent's type.\n     */\n\n\n    function validateExplicitKey(element, parentType) {\n      {\n        if (!element._store || element._store.validated || element.key != null) {\n          return;\n        }\n\n        element._store.validated = true;\n        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n          return;\n        }\n\n        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n        // property, it may be the creator of the child that's responsible for\n        // assigning it a key.\n\n        var childOwner = '';\n\n        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n          // Give the component that originally created this child.\n          childOwner = \" It was passed a child from \" + getComponentName(element._owner.type) + \".\";\n        }\n\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\n     * Ensure that every element either is passed in a static location, in an\n     * array with an explicit keys property defined, or in an object literal\n     * with valid key property.\n     *\n     * @internal\n     * @param {ReactNode} node Statically passed child of any type.\n     * @param {*} parentType node's parent's type.\n     */\n\n\n    function validateChildKeys(node, parentType) {\n      {\n        if (typeof node !== 'object') {\n          return;\n        }\n\n        if (Array.isArray(node)) {\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n\n            if (isValidElement(child)) {\n              validateExplicitKey(child, parentType);\n            }\n          }\n        } else if (isValidElement(node)) {\n          // This element was passed in a valid location.\n          if (node._store) {\n            node._store.validated = true;\n          }\n        } else if (node) {\n          var iteratorFn = getIteratorFn(node);\n\n          if (typeof iteratorFn === 'function') {\n            // Entry iterators used to provide implicit keys,\n            // but now we print a separate warning for them later.\n            if (iteratorFn !== node.entries) {\n              var iterator = iteratorFn.call(node);\n              var step;\n\n              while (!(step = iterator.next()).done) {\n                if (isValidElement(step.value)) {\n                  validateExplicitKey(step.value, parentType);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Given an element, validate that its props follow the propTypes definition,\n     * provided by the type.\n     *\n     * @param {ReactElement} element\n     */\n\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n\n        var propTypes;\n\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentName(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentName(type);\n\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\n     * Given a fragment, validate that it can only be provided with fragment props\n     * @param {ReactElement} fragment\n     */\n\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n\n    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n      {\n        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n        // succeed and there will likely be errors in render.\n\n        if (!validType) {\n          var info = '';\n\n          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n            info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n          }\n\n          var sourceInfo = getSourceInfoErrorAddendum(source);\n\n          if (sourceInfo) {\n            info += sourceInfo;\n          } else {\n            info += getDeclarationErrorAddendum();\n          }\n\n          var typeString;\n\n          if (type === null) {\n            typeString = 'null';\n          } else if (Array.isArray(type)) {\n            typeString = 'array';\n          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n            typeString = \"<\" + (getComponentName(type.type) || 'Unknown') + \" />\";\n            info = ' Did you accidentally export a JSX literal instead of a component?';\n          } else {\n            typeString = typeof type;\n          }\n\n          error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n\n        var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n        // TODO: Drop this when these are no longer allowed as the type argument.\n\n        if (element == null) {\n          return element;\n        } // Skip key warning if the type isn't valid since our key validation logic\n        // doesn't expect a non-string/function type and can throw confusing errors.\n        // We don't want exception behavior to differ between dev and prod.\n        // (Rendering will throw with a helpful message and as soon as the type is\n        // fixed, the key warnings will appear.)\n\n\n        if (validType) {\n          var children = props.children;\n\n          if (children !== undefined) {\n            if (isStaticChildren) {\n              if (Array.isArray(children)) {\n                for (var i = 0; i < children.length; i++) {\n                  validateChildKeys(children[i], type);\n                }\n\n                if (Object.freeze) {\n                  Object.freeze(children);\n                }\n              } else {\n                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n              }\n            } else {\n              validateChildKeys(children, type);\n            }\n          }\n        }\n\n        if (type === exports.Fragment) {\n          validateFragmentProps(element);\n        } else {\n          validatePropTypes(element);\n        }\n\n        return element;\n      }\n    } // These two functions exist to still get child warnings in dev\n\n\n    var jsxDEV$1 = jsxWithValidation;\n    exports.jsxDEV = jsxDEV$1;\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRWE7O0FBRWIsSUFBSUEsSUFBSixFQUEyQztFQUN6QyxDQUFDLFlBQVc7SUFDZDs7SUFFQSxJQUFJRyxLQUFLLEdBQUdDLG1CQUFPLENBQUMsNENBQUQsQ0FBbkI7O0lBQ0EsSUFBSUMsT0FBTyxHQUFHRCxtQkFBTyxDQUFDLGdGQUFELENBQXJCLENBSmMsQ0FNZDtJQUNBO0lBQ0E7SUFDQTtJQUNBOzs7SUFDQSxJQUFJRSxrQkFBa0IsR0FBRyxNQUF6QjtJQUNBLElBQUlDLGlCQUFpQixHQUFHLE1BQXhCO0lBQ0FDLGdCQUFBLEdBQW1CLE1BQW5CO0lBQ0EsSUFBSUUsc0JBQXNCLEdBQUcsTUFBN0I7SUFDQSxJQUFJQyxtQkFBbUIsR0FBRyxNQUExQjtJQUNBLElBQUlDLG1CQUFtQixHQUFHLE1BQTFCO0lBQ0EsSUFBSUMsa0JBQWtCLEdBQUcsTUFBekI7SUFDQSxJQUFJQyxzQkFBc0IsR0FBRyxNQUE3QjtJQUNBLElBQUlDLG1CQUFtQixHQUFHLE1BQTFCO0lBQ0EsSUFBSUMsd0JBQXdCLEdBQUcsTUFBL0I7SUFDQSxJQUFJQyxlQUFlLEdBQUcsTUFBdEI7SUFDQSxJQUFJQyxlQUFlLEdBQUcsTUFBdEI7SUFDQSxJQUFJQyxnQkFBZ0IsR0FBRyxNQUF2QjtJQUNBLElBQUlDLHVCQUF1QixHQUFHLE1BQTlCO0lBQ0EsSUFBSUMsc0JBQXNCLEdBQUcsTUFBN0I7SUFDQSxJQUFJQyxnQkFBZ0IsR0FBRyxNQUF2QjtJQUNBLElBQUlDLG9CQUFvQixHQUFHLE1BQTNCO0lBQ0EsSUFBSUMsNkJBQTZCLEdBQUcsTUFBcEM7SUFDQSxJQUFJQyxvQkFBb0IsR0FBRyxNQUEzQjtJQUNBLElBQUlDLHdCQUF3QixHQUFHLE1BQS9COztJQUVBLElBQUksT0FBT0Ms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Q0FBRCxDQUFULEVBQWNoSyxJQUFkLENBQWpCO2dCQUNEOztnQkFFRCxJQUFJNkMsTUFBTSxDQUFDeUYsTUFBWCxFQUFtQjtrQkFDakJ6RixNQUFNLENBQUN5RixNQUFQLENBQWMrQyxRQUFkO2dCQUNEO2NBQ0YsQ0FSRCxNQVFPO2dCQUNMOU0sS0FBSyxDQUFDLDJEQUEyRCxnRUFBM0QsR0FBOEgsa0NBQS9ILENBQUw7Y0FDRDtZQUNGLENBWkQsTUFZTztjQUNMc0wsaUJBQWlCLENBQUN3QixRQUFELEVBQVdyTCxJQUFYLENBQWpCO1lBQ0Q7VUFDRjtRQUNGOztRQUVELElBQUlBLElBQUksS0FBS3ZELE9BQU8sQ0FBQ0MsUUFBckIsRUFBK0I7VUFDN0JtTyxxQkFBcUIsQ0FBQ2pGLE9BQUQsQ0FBckI7UUFDRCxDQUZELE1BRU87VUFDTDJFLGlCQUFpQixDQUFDM0UsT0FBRCxDQUFqQjtRQUNEOztRQUVELE9BQU9BLE9BQVA7TUFDRDtJQUNGLENBaHFDYSxDQWdxQ1o7OztJQUVGLElBQUkwRixRQUFRLEdBQUlOLGlCQUFoQjtJQUVBdk8sY0FBQSxHQUFpQjZPLFFBQWpCO0VBQ0csQ0FycUNEO0FBc3FDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz8xN2UxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG5leHBvcnRzLkZyYWdtZW50ID0gMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBleHBvcnRzLkZyYWdtZW50ID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50IHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSB8fCB0eXBlWzBdID09PSBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLkZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcblxudmFyIGpzeERFViQxID0gIGpzeFdpdGhWYWxpZGF0aW9uIDtcblxuZXhwb3J0cy5qc3hERVYgPSBqc3hERVYkMTtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJSZWFjdCIsInJlcXVpcmUiLCJfYXNzaWduIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJleHBvcnRzIiwiRnJhZ21lbnQiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX0JMT0NLX1RZUEUiLCJSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSIsIlJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUiLCJSRUFDVF9TQ09QRV9UWVBFIiwiUkVBQ1RfT1BBUVVFX0lEX1RZUEUiLCJSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIiwiU3ltYm9sIiwiZm9yIiwic3ltYm9sRm9yIiwiTUFZQkVfSVRFUkFUT1JfU1lNQk9MIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwibWF5YmVJdGVyYXRvciIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJlcnJvciIsImZvcm1hdCIsIl9sZW4yIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleTIiLCJwcmludFdhcm5pbmciLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJzdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiZW5hYmxlU2NvcGVBUEkiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZnVuY3Rpb25OYW1lIiwiZGlzcGxheU5hbWUiLCJuYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lIiwidGFnIiwiY29udGV4dCIsInByb3ZpZGVyIiwiX2NvbnRleHQiLCJyZW5kZXIiLCJfcmVuZGVyIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJ1bmRlZmluZWQiLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwiY29udHJvbCIsInByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsImN1cnJlbnQiLCJGYWtlIiwiZGVmaW5lUHJvcGVydHkiLCJzZXQiLCJSZWZsZWN0Iiwic2FtcGxlIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiX2ZyYW1lIiwicmVwbGFjZSIsInN5bnRoZXRpY0ZyYW1lIiwiZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lIiwic2hvdWxkQ29uc3RydWN0IiwiQ29tcG9uZW50IiwiaXNSZWFjdENvbXBvbmVudCIsImRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFViIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50IiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsImhhc093blByb3BlcnR5IiwidHlwZVNwZWNOYW1lIiwiZXJyb3IkMSIsImVyciIsImV4IiwibWVzc2FnZSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYiLCJtYXliZUtleSIsInByb3BOYW1lIiwiZGVmYXVsdFByb3BzIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpc0FycmF5IiwiaSIsImNoaWxkIiwiaXRlcmF0b3JGbiIsImVudHJpZXMiLCJzdGVwIiwibmV4dCIsImRvbmUiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsIl9uYW1lIiwiZ2V0RGVmYXVsdFByb3BzIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJmcmFnbWVudCIsImtleXMiLCJqc3hXaXRoVmFsaWRhdGlvbiIsImlzU3RhdGljQ2hpbGRyZW4iLCJ2YWxpZFR5cGUiLCJzb3VyY2VJbmZvIiwidHlwZVN0cmluZyIsImNoaWxkcmVuIiwianN4REVWJDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/** @license React v17.0.2\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nif (true) {\n  (function () {\n    'use strict';\n\n    var React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n    var _assign = __webpack_require__(/*! object-assign */ \"./node_modules/next/dist/build/polyfills/object-assign.js\"); // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n\n    var REACT_ELEMENT_TYPE = 0xeac7;\n    var REACT_PORTAL_TYPE = 0xeaca;\n    exports.Fragment = 0xeacb;\n    var REACT_STRICT_MODE_TYPE = 0xeacc;\n    var REACT_PROFILER_TYPE = 0xead2;\n    var REACT_PROVIDER_TYPE = 0xeacd;\n    var REACT_CONTEXT_TYPE = 0xeace;\n    var REACT_FORWARD_REF_TYPE = 0xead0;\n    var REACT_SUSPENSE_TYPE = 0xead1;\n    var REACT_SUSPENSE_LIST_TYPE = 0xead8;\n    var REACT_MEMO_TYPE = 0xead3;\n    var REACT_LAZY_TYPE = 0xead4;\n    var REACT_BLOCK_TYPE = 0xead9;\n    var REACT_SERVER_BLOCK_TYPE = 0xeada;\n    var REACT_FUNDAMENTAL_TYPE = 0xead5;\n    var REACT_SCOPE_TYPE = 0xead7;\n    var REACT_OPAQUE_ID_TYPE = 0xeae0;\n    var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\n    var REACT_OFFSCREEN_TYPE = 0xeae2;\n    var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\n\n    if (typeof Symbol === 'function' && Symbol.for) {\n      var symbolFor = Symbol.for;\n      REACT_ELEMENT_TYPE = symbolFor('react.element');\n      REACT_PORTAL_TYPE = symbolFor('react.portal');\n      exports.Fragment = symbolFor('react.fragment');\n      REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\n      REACT_PROFILER_TYPE = symbolFor('react.profiler');\n      REACT_PROVIDER_TYPE = symbolFor('react.provider');\n      REACT_CONTEXT_TYPE = symbolFor('react.context');\n      REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n      REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\n      REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\n      REACT_MEMO_TYPE = symbolFor('react.memo');\n      REACT_LAZY_TYPE = symbolFor('react.lazy');\n      REACT_BLOCK_TYPE = symbolFor('react.block');\n      REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');\n      REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');\n      REACT_SCOPE_TYPE = symbolFor('react.scope');\n      REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');\n      REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\n      REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\n      REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\n    }\n\n    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable !== 'object') {\n        return null;\n      }\n\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n\n      return null;\n    }\n\n    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n    function error(format) {\n      {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        printWarning('error', format, args);\n      }\n    }\n\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        }\n\n        var argsWithFormat = args.map(function (item) {\n          return '' + item;\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    } // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.\n\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n      if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {\n        return true;\n      }\n\n      if (typeof type === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var functionName = innerType.displayName || innerType.name || '';\n      return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n    }\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    }\n\n    function getComponentName(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      switch (type) {\n        case exports.Fragment:\n          return 'Fragment';\n\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n\n        case REACT_PROFILER_TYPE:\n          return 'Profiler';\n\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n\n        case REACT_SUSPENSE_TYPE:\n          return 'Suspense';\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return 'SuspenseList';\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n\n          case REACT_MEMO_TYPE:\n            return getComponentName(type.type);\n\n          case REACT_BLOCK_TYPE:\n            return getComponentName(type._render);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                return getComponentName(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n        }\n      }\n\n      return null;\n    } // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n\n\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n\n    function disabledLog() {}\n\n    disabledLog.__reactDisabledLog = true;\n\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        disabledDepth++;\n      }\n    }\n\n    function reenableLogs() {\n      {\n        disabledDepth--;\n\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: _assign({}, props, {\n              value: prevLog\n            }),\n            info: _assign({}, props, {\n              value: prevInfo\n            }),\n            warn: _assign({}, props, {\n              value: prevWarn\n            }),\n            error: _assign({}, props, {\n              value: prevError\n            }),\n            group: _assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: _assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: _assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n\n    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n        return '\\n' + prefix + name;\n      }\n    }\n\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n\n      {\n        var frame = componentFrameCache.get(fn);\n\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher.current = null;\n        disableLogs();\n      }\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\n\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame('Suspense');\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n          case REACT_BLOCK_TYPE:\n            return describeFunctionComponentFrame(type._render);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n\n      return '';\n    }\n\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n              setCurrentlyValidatingElement(null);\n            }\n\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n\n    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown;\n    var specialPropRefWarningShown;\n    var didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n\n    function warnIfStringRefCannotBeAutoConverted(config, self) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n          var componentName = getComponentName(ReactCurrentOwner.current.type);\n\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n\n    function defineKeyPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingKey = function () {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingKey.isReactWarning = true;\n        Object.defineProperty(props, 'key', {\n          get: warnAboutAccessingKey,\n          configurable: true\n        });\n      }\n    }\n\n    function defineRefPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingRef = function () {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingRef.isReactWarning = true;\n        Object.defineProperty(props, 'ref', {\n          get: warnAboutAccessingRef,\n          configurable: true\n        });\n      }\n    }\n    /**\n     * Factory method to create a new React element. This no longer adheres to\n     * the class pattern, so do not use new to call it. Also, instanceof check\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n     * if something is a React Element.\n     *\n     * @param {*} type\n     * @param {*} props\n     * @param {*} key\n     * @param {string|object} ref\n     * @param {*} owner\n     * @param {*} self A *temporary* helper to detect places where `this` is\n     * different from the `owner` when React.createElement is called, so that we\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n     * functions, and as long as `this` and owner are the same, there will be no\n     * change in behavior.\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\n     * indicating filename, line number, and/or other information.\n     * @internal\n     */\n\n\n    var ReactElement = function (type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\n     * https://github.com/reactjs/rfcs/pull/107\n     * @param {*} type\n     * @param {object} props\n     * @param {string} key\n     */\n\n\n    function jsxDEV(type, config, maybeKey, source, self) {\n      {\n        var propName; // Reserved names are extracted\n\n        var props = {};\n        var key = null;\n        var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n        // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n        // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n        // but as an intermediary step, we will use jsxDEV for everything except\n        // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n        // key is explicitly declared to be undefined or not.\n\n        if (maybeKey !== undefined) {\n          key = '' + maybeKey;\n        }\n\n        if (hasValidKey(config)) {\n          key = '' + config.key;\n        }\n\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          warnIfStringRefCannotBeAutoConverted(config, self);\n        } // Remaining properties are added to a new props object\n\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        } // Resolve default props\n\n\n        if (type && type.defaultProps) {\n          var defaultProps = type.defaultProps;\n\n          for (propName in defaultProps) {\n            if (props[propName] === undefined) {\n              props[propName] = defaultProps[propName];\n            }\n          }\n        }\n\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n\n        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n      }\n    }\n\n    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n    /**\n     * Verifies the object is a ReactElement.\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\n     * @param {?object} object\n     * @return {boolean} True if `object` is a ReactElement.\n     * @final\n     */\n\n    function isValidElement(object) {\n      {\n        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n      }\n    }\n\n    function getDeclarationErrorAddendum() {\n      {\n        if (ReactCurrentOwner$1.current) {\n          var name = getComponentName(ReactCurrentOwner$1.current.type);\n\n          if (name) {\n            return '\\n\\nCheck the render method of `' + name + '`.';\n          }\n        }\n\n        return '';\n      }\n    }\n\n    function getSourceInfoErrorAddendum(source) {\n      {\n        if (source !== undefined) {\n          var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n          var lineNumber = source.lineNumber;\n          return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n        }\n\n        return '';\n      }\n    }\n    /**\n     * Warn if there's no key explicitly set on dynamic arrays of children or\n     * object keys are not valid. This allows us to keep track of children between\n     * updates.\n     */\n\n\n    var ownerHasKeyUseWarning = {};\n\n    function getCurrentComponentErrorInfo(parentType) {\n      {\n        var info = getDeclarationErrorAddendum();\n\n        if (!info) {\n          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n          if (parentName) {\n            info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n          }\n        }\n\n        return info;\n      }\n    }\n    /**\n     * Warn if the element doesn't have an explicit key assigned to it.\n     * This element is in an array. The array could grow and shrink or be\n     * reordered. All children that haven't already been validated are required to\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n     * will only be shown once.\n     *\n     * @internal\n     * @param {ReactElement} element Element that requires a key.\n     * @param {*} parentType element's parent's type.\n     */\n\n\n    function validateExplicitKey(element, parentType) {\n      {\n        if (!element._store || element._store.validated || element.key != null) {\n          return;\n        }\n\n        element._store.validated = true;\n        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n          return;\n        }\n\n        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n        // property, it may be the creator of the child that's responsible for\n        // assigning it a key.\n\n        var childOwner = '';\n\n        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n          // Give the component that originally created this child.\n          childOwner = \" It was passed a child from \" + getComponentName(element._owner.type) + \".\";\n        }\n\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\n     * Ensure that every element either is passed in a static location, in an\n     * array with an explicit keys property defined, or in an object literal\n     * with valid key property.\n     *\n     * @internal\n     * @param {ReactNode} node Statically passed child of any type.\n     * @param {*} parentType node's parent's type.\n     */\n\n\n    function validateChildKeys(node, parentType) {\n      {\n        if (typeof node !== 'object') {\n          return;\n        }\n\n        if (Array.isArray(node)) {\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n\n            if (isValidElement(child)) {\n              validateExplicitKey(child, parentType);\n            }\n          }\n        } else if (isValidElement(node)) {\n          // This element was passed in a valid location.\n          if (node._store) {\n            node._store.validated = true;\n          }\n        } else if (node) {\n          var iteratorFn = getIteratorFn(node);\n\n          if (typeof iteratorFn === 'function') {\n            // Entry iterators used to provide implicit keys,\n            // but now we print a separate warning for them later.\n            if (iteratorFn !== node.entries) {\n              var iterator = iteratorFn.call(node);\n              var step;\n\n              while (!(step = iterator.next()).done) {\n                if (isValidElement(step.value)) {\n                  validateExplicitKey(step.value, parentType);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Given an element, validate that its props follow the propTypes definition,\n     * provided by the type.\n     *\n     * @param {ReactElement} element\n     */\n\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n\n        var propTypes;\n\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentName(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentName(type);\n\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\n     * Given a fragment, validate that it can only be provided with fragment props\n     * @param {ReactElement} fragment\n     */\n\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n\n    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n      {\n        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n        // succeed and there will likely be errors in render.\n\n        if (!validType) {\n          var info = '';\n\n          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n            info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n          }\n\n          var sourceInfo = getSourceInfoErrorAddendum(source);\n\n          if (sourceInfo) {\n            info += sourceInfo;\n          } else {\n            info += getDeclarationErrorAddendum();\n          }\n\n          var typeString;\n\n          if (type === null) {\n            typeString = 'null';\n          } else if (Array.isArray(type)) {\n            typeString = 'array';\n          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n            typeString = \"<\" + (getComponentName(type.type) || 'Unknown') + \" />\";\n            info = ' Did you accidentally export a JSX literal instead of a component?';\n          } else {\n            typeString = typeof type;\n          }\n\n          error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n\n        var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n        // TODO: Drop this when these are no longer allowed as the type argument.\n\n        if (element == null) {\n          return element;\n        } // Skip key warning if the type isn't valid since our key validation logic\n        // doesn't expect a non-string/function type and can throw confusing errors.\n        // We don't want exception behavior to differ between dev and prod.\n        // (Rendering will throw with a helpful message and as soon as the type is\n        // fixed, the key warnings will appear.)\n\n\n        if (validType) {\n          var children = props.children;\n\n          if (children !== undefined) {\n            if (isStaticChildren) {\n              if (Array.isArray(children)) {\n                for (var i = 0; i < children.length; i++) {\n                  validateChildKeys(children[i], type);\n                }\n\n                if (Object.freeze) {\n                  Object.freeze(children);\n                }\n              } else {\n                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n              }\n            } else {\n              validateChildKeys(children, type);\n            }\n          }\n        }\n\n        if (type === exports.Fragment) {\n          validateFragmentProps(element);\n        } else {\n          validatePropTypes(element);\n        }\n\n        return element;\n      }\n    } // These two functions exist to still get child warnings in dev\n    // even with the prod transform. This means that jsxDEV is purely\n    // opt-in behavior for better messages but that we won't stop\n    // giving you warnings if you use production apis.\n\n\n    function jsxWithValidationStatic(type, props, key) {\n      {\n        return jsxWithValidation(type, props, key, true);\n      }\n    }\n\n    function jsxWithValidationDynamic(type, props, key) {\n      {\n        return jsxWithValidation(type, props, key, false);\n      }\n    }\n\n    var jsx = jsxWithValidationDynamic; // we may want to special case jsxs internally to take advantage of static children.\n    // for now we can ship identical prod functions\n\n    var jsxs = jsxWithValidationStatic;\n    exports.jsx = jsx;\n    exports.jsxs = jsxs;\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFYTs7QUFFYixJQUFJQSxJQUFKLEVBQTJDO0VBQ3pDLENBQUMsWUFBVztJQUNkOztJQUVBLElBQUlHLEtBQUssR0FBR0MsbUJBQU8sQ0FBQyw0Q0FBRCxDQUFuQjs7SUFDQSxJQUFJQyxPQUFPLEdBQUdELG1CQUFPLENBQUMsZ0ZBQUQsQ0FBckIsQ0FKYyxDQU1kO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7OztJQUNBLElBQUlFLGtCQUFrQixHQUFHLE1BQXpCO0lBQ0EsSUFBSUMsaUJBQWlCLEdBQUcsTUFBeEI7SUFDQUMsZ0JBQUEsR0FBbUIsTUFBbkI7SUFDQSxJQUFJRSxzQkFBc0IsR0FBRyxNQUE3QjtJQUNBLElBQUlDLG1CQUFtQixHQUFHLE1BQTFCO0lBQ0EsSUFBSUMsbUJBQW1CLEdBQUcsTUFBMUI7SUFDQSxJQUFJQyxrQkFBa0IsR0FBRyxNQUF6QjtJQUNBLElBQUlDLHNCQUFzQixHQUFHLE1BQTdCO0lBQ0EsSUFBSUMsbUJBQW1CLEdBQUcsTUFBMUI7SUFDQSxJQUFJQyx3QkFBd0IsR0FBRyxNQUEvQjtJQUNBLElBQUlDLGVBQWUsR0FBRyxNQUF0QjtJQUNBLElBQUlDLGVBQWUsR0FBRyxNQUF0QjtJQUNBLElBQUlDLGdCQUFnQixHQUFHLE1BQXZCO0lBQ0EsSUFBSUMsdUJBQXVCLEdBQUcsTUFBOUI7SUFDQSxJQUFJQyxzQkFBc0IsR0FBRyxNQUE3QjtJQUNBLElBQUlDLGdCQUFnQixHQUFHLE1BQXZCO0lBQ0EsSUFBSUMsb0JBQW9CLEdBQUcsTUFBM0I7SUFDQSxJQUFJQyw2QkFBNkIsR0FBRyxNQUFwQztJQUNBLElBQUlDLG9CQUFvQixHQUFHLE1BQTNCO0lBQ0EsSUFBSUMsd0JBQXdCLEdBQUcsTUFBL0I7O0lBRUEsSUFBSSxPQUFPQyxNQUFQ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Q0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcz8yZmMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFIHx8IHR5cGVbMF0gPT09IFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50KSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuLy8gZXZlbiB3aXRoIHRoZSBwcm9kIHRyYW5zZm9ybS4gVGhpcyBtZWFucyB0aGF0IGpzeERFViBpcyBwdXJlbHlcbi8vIG9wdC1pbiBiZWhhdmlvciBmb3IgYmV0dGVyIG1lc3NhZ2VzIGJ1dCB0aGF0IHdlIHdvbid0IHN0b3Bcbi8vIGdpdmluZyB5b3Ugd2FybmluZ3MgaWYgeW91IHVzZSBwcm9kdWN0aW9uIGFwaXMuXG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljKHR5cGUsIHByb3BzLCBrZXkpIHtcbiAge1xuICAgIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25EeW5hbWljKHR5cGUsIHByb3BzLCBrZXkpIHtcbiAge1xuICAgIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBmYWxzZSk7XG4gIH1cbn1cblxudmFyIGpzeCA9ICBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWMgOyAvLyB3ZSBtYXkgd2FudCB0byBzcGVjaWFsIGNhc2UganN4cyBpbnRlcm5hbGx5IHRvIHRha2UgYWR2YW50YWdlIG9mIHN0YXRpYyBjaGlsZHJlbi5cbi8vIGZvciBub3cgd2UgY2FuIHNoaXAgaWRlbnRpY2FsIHByb2QgZnVuY3Rpb25zXG5cbnZhciBqc3hzID0gIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljIDtcblxuZXhwb3J0cy5qc3ggPSBqc3g7XG5leHBvcnRzLmpzeHMgPSBqc3hzO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIlJlYWN0IiwicmVxdWlyZSIsIl9hc3NpZ24iLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsImV4cG9ydHMiLCJGcmFnbWVudCIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfQkxPQ0tfVFlQRSIsIlJFQUNUX1NFUlZFUl9CTE9DS19UWVBFIiwiUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSIsIlJFQUNUX1NDT1BFX1RZUEUiLCJSRUFDVF9PUEFRVUVfSURfVFlQRSIsIlJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJzeW1ib2xGb3IiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiUmVhY3RTaGFyZWRJbnRlcm5hbHMiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsImVycm9yIiwiZm9ybWF0IiwiX2xlbjIiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5MiIsInByaW50V2FybmluZyIsImxldmVsIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSIsInN0YWNrIiwiZ2V0U3RhY2tBZGRlbmR1bSIsImNvbmNhdCIsImFyZ3NXaXRoRm9ybWF0IiwibWFwIiwiaXRlbSIsInVuc2hpZnQiLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImFwcGx5IiwiY2FsbCIsImNvbnNvbGUiLCJlbmFibGVTY29wZUFQSSIsImlzVmFsaWRFbGVtZW50VHlwZSIsInR5cGUiLCIkJHR5cGVvZiIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJmdW5jdGlvbk5hbWUiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsImdldENvbXBvbmVudE5hbWUiLCJ0YWciLCJjb250ZXh0IiwicHJvdmlkZXIiLCJfY29udGV4dCIsInJlbmRlciIsIl9yZW5kZXIiLCJsYXp5Q29tcG9uZW50IiwicGF5bG9hZCIsIl9wYXlsb2FkIiwiaW5pdCIsIl9pbml0IiwieCIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwicHJldkluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImRpc2FibGVkTG9nIiwiX19yZWFjdERpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJsb2ciLCJpbmZvIiwid2FybiIsImdyb3VwIiwiZ3JvdXBDb2xsYXBzZWQiLCJncm91cEVuZCIsInByb3BzIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsInZhbHVlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsInByZWZpeCIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwic291cmNlIiwib3duZXJGbiIsInVuZGVmaW5lZCIsIkVycm9yIiwibWF0Y2giLCJ0cmltIiwicmVlbnRyeSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJQb3NzaWJseVdlYWtNYXAiLCJXZWFrTWFwIiwiTWFwIiwiZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSIsImZuIiwiY29uc3RydWN0IiwiZnJhbWUiLCJnZXQiLCJjb250cm9sIiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJzYW1wbGUiLCJzYW1wbGVMaW5lcyIsInNwbGl0IiwiY29udHJvbExpbmVzIiwicyIsImMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJlbGVtZW50Iiwib3duZXIiLCJfb3duZXIiLCJfc291cmNlIiwic2V0RXh0cmFTdGFja0ZyYW1lIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImNvbXBvbmVudE5hbWUiLCJoYXMiLCJiaW5kIiwiaGFzT3duUHJvcGVydHkiLCJ0eXBlU3BlY05hbWUiLCJlcnJvciQxIiwiZXJyIiwiZXgiLCJtZXNzYWdlIiwiUmVhY3RDdXJyZW50T3duZXIiLCJSRVNFUlZFRF9QUk9QUyIsImtleSIsInJlZiIsIl9fc2VsZiIsIl9fc291cmNlIiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biIsImRpZFdhcm5BYm91dFN0cmluZ1JlZnMiLCJoYXNWYWxpZFJlZiIsImNvbmZpZyIsImdldHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlzUmVhY3RXYXJuaW5nIiwiaGFzVmFsaWRLZXkiLCJ3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQiLCJzZWxmIiwic3RhdGVOb2RlIiwiZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdLZXkiLCJkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ1JlZiIsIlJlYWN0RWxlbWVudCIsIl9zdG9yZSIsImZyZWV6ZSIsImpzeERFViIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSZWFjdEN1cnJlbnRPd25lciQxIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMSIsInByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duIiwiaXNWYWxpZEVsZW1lbnQiLCJvYmplY3QiLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnRUeXBlIiwicGFyZW50TmFtZSIsInZhbGlkYXRlRXhwbGljaXRLZXkiLCJ2YWxpZGF0ZWQiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lciIsInZhbGlkYXRlQ2hpbGRLZXlzIiwibm9kZSIsImlzQXJyYXkiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyIsImpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyIsImpzeCIsImpzeHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUlBLEtBQUosRUFBMkMsRUFBM0MsTUFFTztFQUNMRyx1SkFBQTtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/NTc3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-runtime.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSUEsS0FBSixFQUEyQyxFQUEzQyxNQUVPO0VBQ0xHLCtJQUFBO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzPzM0ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-runtime.js\n"));

/***/ }),

/***/ "./node_modules/recoil/es/index.js":
/*!*****************************************!*\
  !*** ./node_modules/recoil/es/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultValue\": function() { return /* binding */ Recoil_index_1; },\n/* harmony export */   \"RecoilLoadable\": function() { return /* binding */ Recoil_index_3; },\n/* harmony export */   \"RecoilRoot\": function() { return /* binding */ Recoil_index_4; },\n/* harmony export */   \"atom\": function() { return /* binding */ Recoil_index_7; },\n/* harmony export */   \"atomFamily\": function() { return /* binding */ Recoil_index_9; },\n/* harmony export */   \"constSelector\": function() { return /* binding */ Recoil_index_11; },\n/* harmony export */   \"errorSelector\": function() { return /* binding */ Recoil_index_12; },\n/* harmony export */   \"isRecoilValue\": function() { return /* binding */ Recoil_index_2; },\n/* harmony export */   \"noWait\": function() { return /* binding */ Recoil_index_14; },\n/* harmony export */   \"readOnlySelector\": function() { return /* binding */ Recoil_index_13; },\n/* harmony export */   \"retentionZone\": function() { return /* binding */ Recoil_index_37; },\n/* harmony export */   \"selector\": function() { return /* binding */ Recoil_index_8; },\n/* harmony export */   \"selectorFamily\": function() { return /* binding */ Recoil_index_10; },\n/* harmony export */   \"snapshot_UNSTABLE\": function() { return /* binding */ Recoil_index_35; },\n/* harmony export */   \"useGetRecoilValueInfo_UNSTABLE\": function() { return /* binding */ Recoil_index_25; },\n/* harmony export */   \"useGotoRecoilSnapshot\": function() { return /* binding */ Recoil_index_32; },\n/* harmony export */   \"useRecoilBridgeAcrossReactRoots_UNSTABLE\": function() { return /* binding */ Recoil_index_6; },\n/* harmony export */   \"useRecoilCallback\": function() { return /* binding */ Recoil_index_30; },\n/* harmony export */   \"useRecoilRefresher_UNSTABLE\": function() { return /* binding */ Recoil_index_26; },\n/* harmony export */   \"useRecoilSnapshot\": function() { return /* binding */ Recoil_index_33; },\n/* harmony export */   \"useRecoilState\": function() { return /* binding */ Recoil_index_21; },\n/* harmony export */   \"useRecoilStateLoadable\": function() { return /* binding */ Recoil_index_22; },\n/* harmony export */   \"useRecoilState_TRANSITION_SUPPORT_UNSTABLE\": function() { return /* binding */ Recoil_index_29; },\n/* harmony export */   \"useRecoilStoreID\": function() { return /* binding */ Recoil_index_5; },\n/* harmony export */   \"useRecoilTransactionObserver_UNSTABLE\": function() { return /* binding */ Recoil_index_34; },\n/* harmony export */   \"useRecoilTransaction_UNSTABLE\": function() { return /* binding */ Recoil_index_31; },\n/* harmony export */   \"useRecoilValue\": function() { return /* binding */ Recoil_index_19; },\n/* harmony export */   \"useRecoilValueLoadable\": function() { return /* binding */ Recoil_index_20; },\n/* harmony export */   \"useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE\": function() { return /* binding */ Recoil_index_27; },\n/* harmony export */   \"useRecoilValue_TRANSITION_SUPPORT_UNSTABLE\": function() { return /* binding */ Recoil_index_28; },\n/* harmony export */   \"useResetRecoilState\": function() { return /* binding */ Recoil_index_24; },\n/* harmony export */   \"useRetain\": function() { return /* binding */ Recoil_index_36; },\n/* harmony export */   \"useSetRecoilState\": function() { return /* binding */ Recoil_index_23; },\n/* harmony export */   \"waitForAll\": function() { return /* binding */ Recoil_index_17; },\n/* harmony export */   \"waitForAllSettled\": function() { return /* binding */ Recoil_index_18; },\n/* harmony export */   \"waitForAny\": function() { return /* binding */ Recoil_index_16; },\n/* harmony export */   \"waitForNone\": function() { return /* binding */ Recoil_index_15; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction err(message) {\n  const error = new Error(message); // In V8, Error objects keep the closure scope chain alive until the\n  // err.stack property is accessed.\n\n  if (error.stack === undefined) {\n    // IE sets the stack only if error is thrown\n    try {\n      throw error;\n    } catch (_) {} // eslint-disable-line fb-www/no-unused-catch-bindings, no-empty\n\n  }\n\n  return error;\n}\n\nvar err_1 = err; // @oss-only\n\nvar Recoil_err = err_1;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n// Split declaration and implementation to allow this function to pretend to\n// check for actual instance of Promise instead of something with a `then`\n// method.\n// eslint-disable-next-line no-redeclare\n\nfunction isPromise(p) {\n  return !!p && typeof p.then === 'function';\n}\n\nvar Recoil_isPromise = isPromise;\n\nfunction nullthrows(x, message) {\n  if (x != null) {\n    return x;\n  }\n\n  throw Recoil_err(message !== null && message !== void 0 ? message : 'Got unexpected null or undefined');\n}\n\nvar Recoil_nullthrows = nullthrows;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass BaseLoadable {\n  getValue() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  toPromise() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  valueMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  valueOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected value, but in \"${this.state}\" state`);\n  }\n\n  promiseMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  promiseOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected promise, but in \"${this.state}\" state`);\n  }\n\n  errorMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  errorOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected error, but in \"${this.state}\" state`);\n  }\n\n  is(other) {\n    // $FlowFixMe[prop-missing]\n    return other.state === this.state && other.contents === this.contents;\n  }\n\n  map(_map) {\n    throw Recoil_err('BaseLoadable');\n  }\n\n}\n\nclass ValueLoadable extends BaseLoadable {\n  constructor(value) {\n    super();\n\n    _defineProperty(this, \"state\", 'hasValue');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = value;\n  }\n\n  getValue() {\n    return this.contents;\n  }\n\n  toPromise() {\n    return Promise.resolve(this.contents);\n  }\n\n  valueMaybe() {\n    return this.contents;\n  }\n\n  valueOrThrow() {\n    return this.contents;\n  }\n\n  promiseMaybe() {\n    return undefined;\n  }\n\n  errorMaybe() {\n    return undefined;\n  }\n\n  map(map) {\n    try {\n      const next = map(this.contents);\n      return Recoil_isPromise(next) ? loadableWithPromise(next) : isLoadable(next) ? next : loadableWithValue(next);\n    } catch (e) {\n      return Recoil_isPromise(e) ? // If we \"suspended\", then try again.\n      // errors and subsequent retries will be handled in 'loading' case\n      // $FlowFixMe[prop-missing]\n      loadableWithPromise(e.next(() => this.map(map))) : loadableWithError(e);\n    }\n  }\n\n}\n\nclass ErrorLoadable extends BaseLoadable {\n  constructor(error) {\n    super();\n\n    _defineProperty(this, \"state\", 'hasError');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = error;\n  }\n\n  getValue() {\n    throw this.contents;\n  }\n\n  toPromise() {\n    return Promise.reject(this.contents);\n  }\n\n  valueMaybe() {\n    return undefined;\n  }\n\n  promiseMaybe() {\n    return undefined;\n  }\n\n  errorMaybe() {\n    return this.contents;\n  }\n\n  errorOrThrow() {\n    return this.contents;\n  }\n\n  map(_map) {\n    // $FlowIssue[incompatible-return]\n    return this;\n  }\n\n}\n\nclass LoadingLoadable extends BaseLoadable {\n  constructor(promise) {\n    super();\n\n    _defineProperty(this, \"state\", 'loading');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = promise;\n  }\n\n  getValue() {\n    throw this.contents;\n  }\n\n  toPromise() {\n    return this.contents;\n  }\n\n  valueMaybe() {\n    return undefined;\n  }\n\n  promiseMaybe() {\n    return this.contents;\n  }\n\n  promiseOrThrow() {\n    return this.contents;\n  }\n\n  errorMaybe() {\n    return undefined;\n  }\n\n  map(map) {\n    return loadableWithPromise(this.contents.then(value => {\n      const next = map(value);\n\n      if (isLoadable(next)) {\n        const nextLoadable = next;\n\n        switch (nextLoadable.state) {\n          case 'hasValue':\n            return nextLoadable.contents;\n\n          case 'hasError':\n            throw nextLoadable.contents;\n\n          case 'loading':\n            return nextLoadable.contents;\n        }\n      } // $FlowIssue[incompatible-return]\n\n\n      return next;\n    }).catch(e => {\n      if (Recoil_isPromise(e)) {\n        // we were \"suspended,\" try again\n        return e.then(() => this.map(map).contents);\n      }\n\n      throw e;\n    }));\n  }\n\n}\n\nfunction loadableWithValue(value) {\n  return Object.freeze(new ValueLoadable(value));\n}\n\nfunction loadableWithError(error) {\n  return Object.freeze(new ErrorLoadable(error));\n}\n\nfunction loadableWithPromise(promise) {\n  return Object.freeze(new LoadingLoadable(promise));\n}\n\nfunction loadableLoading() {\n  return Object.freeze(new LoadingLoadable(new Promise(() => {})));\n}\n\nfunction loadableAllArray(inputs) {\n  return inputs.every(i => i.state === 'hasValue') ? loadableWithValue(inputs.map(i => i.contents)) : inputs.some(i => i.state === 'hasError') ? loadableWithError(Recoil_nullthrows(inputs.find(i => i.state === 'hasError'), 'Invalid loadable passed to loadableAll').contents) : loadableWithPromise(Promise.all(inputs.map(i => i.contents)));\n}\n\nfunction loadableAll(inputs) {\n  const unwrapedInputs = Array.isArray(inputs) ? inputs : Object.getOwnPropertyNames(inputs).map(key => inputs[key]);\n  const normalizedInputs = unwrapedInputs.map(x => isLoadable(x) ? x : Recoil_isPromise(x) ? loadableWithPromise(x) : loadableWithValue(x));\n  const output = loadableAllArray(normalizedInputs);\n  return Array.isArray(inputs) ? // $FlowIssue[incompatible-return]\n  output : // Object.getOwnPropertyNames() has consistent key ordering with ES6\n  // $FlowIssue[incompatible-call]\n  output.map(outputs => Object.getOwnPropertyNames(inputs).reduce((out, key, idx) => ({ ...out,\n    [key]: outputs[idx]\n  }), {}));\n}\n\nfunction isLoadable(x) {\n  return x instanceof BaseLoadable;\n}\n\nconst LoadableStaticInterface = {\n  of: value => Recoil_isPromise(value) ? loadableWithPromise(value) : isLoadable(value) ? value : loadableWithValue(value),\n  error: error => loadableWithError(error),\n  // $FlowIssue[incompatible-return]\n  loading: () => loadableLoading(),\n  // $FlowIssue[unclear-type]\n  all: loadableAll,\n  isLoadable\n};\nvar Recoil_Loadable = {\n  loadableWithValue,\n  loadableWithError,\n  loadableWithPromise,\n  loadableLoading,\n  loadableAll,\n  isLoadable,\n  RecoilLoadable: LoadableStaticInterface\n};\nvar Recoil_Loadable_1 = Recoil_Loadable.loadableWithValue;\nvar Recoil_Loadable_2 = Recoil_Loadable.loadableWithError;\nvar Recoil_Loadable_3 = Recoil_Loadable.loadableWithPromise;\nvar Recoil_Loadable_4 = Recoil_Loadable.loadableLoading;\nvar Recoil_Loadable_5 = Recoil_Loadable.loadableAll;\nvar Recoil_Loadable_6 = Recoil_Loadable.isLoadable;\nvar Recoil_Loadable_7 = Recoil_Loadable.RecoilLoadable;\nvar Recoil_Loadable$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  loadableWithValue: Recoil_Loadable_1,\n  loadableWithError: Recoil_Loadable_2,\n  loadableWithPromise: Recoil_Loadable_3,\n  loadableLoading: Recoil_Loadable_4,\n  loadableAll: Recoil_Loadable_5,\n  isLoadable: Recoil_Loadable_6,\n  RecoilLoadable: Recoil_Loadable_7\n});\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nconst gks = new Map().set('recoil_hamt_2020', true).set('recoil_sync_external_store', true).set('recoil_suppress_rerender_in_callback', true).set('recoil_memory_managament_2020', true);\n\nfunction Recoil_gkx_OSS(gk) {\n  var _gks$get;\n\n  return (_gks$get = gks.get(gk)) !== null && _gks$get !== void 0 ? _gks$get : false;\n}\n\nRecoil_gkx_OSS.setPass = gk => {\n  gks.set(gk, true);\n};\n\nRecoil_gkx_OSS.setFail = gk => {\n  gks.set(gk, false);\n};\n\nRecoil_gkx_OSS.clear = () => {\n  gks.clear();\n};\n\nvar Recoil_gkx = Recoil_gkx_OSS; // @oss-only\n\nvar _createMutableSource, _useMutableSource, _useSyncExternalStore;\n\nconst createMutableSource = // flowlint-next-line unclear-type:off\n(_createMutableSource = (react__WEBPACK_IMPORTED_MODULE_0___default().createMutableSource)) !== null && _createMutableSource !== void 0 ? _createMutableSource : (react__WEBPACK_IMPORTED_MODULE_0___default().unstable_createMutableSource);\nconst useMutableSource = // flowlint-next-line unclear-type:off\n(_useMutableSource = (react__WEBPACK_IMPORTED_MODULE_0___default().useMutableSource)) !== null && _useMutableSource !== void 0 ? _useMutableSource : (react__WEBPACK_IMPORTED_MODULE_0___default().unstable_useMutableSource); // https://github.com/reactwg/react-18/discussions/86\n\nconst useSyncExternalStore = // flowlint-next-line unclear-type:off\n(_useSyncExternalStore = (react__WEBPACK_IMPORTED_MODULE_0___default().useSyncExternalStore)) !== null && _useSyncExternalStore !== void 0 ? _useSyncExternalStore : // flowlint-next-line unclear-type:off\n(react__WEBPACK_IMPORTED_MODULE_0___default().unstable_useSyncExternalStore);\n/**\n * mode: The React API and approach to use for syncing state with React\n * early: Re-renders from Recoil updates occur:\n *    1) earlier\n *    2) in sync with React updates in the same batch\n *    3) before transaction observers instead of after.\n * concurrent: Is the current mode compatible with Concurrent Mode and useTransition()\n */\n\nfunction reactMode() {\n  // NOTE: This mode is currently broken with some Suspense cases\n  // see Recoil_selector-test.js\n  if (Recoil_gkx('recoil_transition_support')) {\n    return {\n      mode: 'TRANSITION_SUPPORT',\n      early: true,\n      concurrent: true\n    };\n  }\n\n  if (Recoil_gkx('recoil_sync_external_store') && useSyncExternalStore != null) {\n    return {\n      mode: 'SYNC_EXTERNAL_STORE',\n      early: true,\n      concurrent: false\n    };\n  }\n\n  if (Recoil_gkx('recoil_mutable_source') && useMutableSource != null && typeof window !== 'undefined' && !window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE) {\n    return Recoil_gkx('recoil_suppress_rerender_in_callback') ? {\n      mode: 'MUTABLE_SOURCE',\n      early: true,\n      concurrent: true\n    } : {\n      mode: 'MUTABLE_SOURCE',\n      early: false,\n      concurrent: false\n    };\n  }\n\n  return Recoil_gkx('recoil_suppress_rerender_in_callback') ? {\n    mode: 'LEGACY',\n    early: true,\n    concurrent: false\n  } : {\n    mode: 'LEGACY',\n    early: false,\n    concurrent: false\n  };\n} // TODO Need to figure out if there is a standard/open-source equivalent to see if hot module replacement is happening:\n\n\nfunction isFastRefreshEnabled() {\n  // @fb-only: const {isAcceptingUpdate} = require('__debug');\n  // @fb-only: return typeof isAcceptingUpdate === 'function' && isAcceptingUpdate();\n  return false; // @oss-only\n}\n\nvar Recoil_ReactMode = {\n  createMutableSource,\n  useMutableSource,\n  useSyncExternalStore,\n  reactMode,\n  isFastRefreshEnabled\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n// eslint-disable-next-line no-unused-vars\n\nclass AbstractRecoilValue {\n  constructor(newKey) {\n    _defineProperty(this, \"key\", void 0);\n\n    this.key = newKey;\n  }\n\n  toJSON() {\n    return {\n      key: this.key\n    };\n  }\n\n}\n\nclass RecoilState extends AbstractRecoilValue {}\n\nclass RecoilValueReadOnly extends AbstractRecoilValue {}\n\nfunction isRecoilValue(x) {\n  return x instanceof RecoilState || x instanceof RecoilValueReadOnly;\n}\n\nvar Recoil_RecoilValue = {\n  AbstractRecoilValue,\n  RecoilState,\n  RecoilValueReadOnly,\n  isRecoilValue\n};\nvar Recoil_RecoilValue_1 = Recoil_RecoilValue.AbstractRecoilValue;\nvar Recoil_RecoilValue_2 = Recoil_RecoilValue.RecoilState;\nvar Recoil_RecoilValue_3 = Recoil_RecoilValue.RecoilValueReadOnly;\nvar Recoil_RecoilValue_4 = Recoil_RecoilValue.isRecoilValue;\nvar Recoil_RecoilValue$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AbstractRecoilValue: Recoil_RecoilValue_1,\n  RecoilState: Recoil_RecoilValue_2,\n  RecoilValueReadOnly: Recoil_RecoilValue_3,\n  isRecoilValue: Recoil_RecoilValue_4\n});\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction sprintf(format, ...args) {\n  let index = 0;\n  return format.replace(/%s/g, () => String(args[index++]));\n}\n\nvar sprintf_1 = sprintf;\n\nfunction expectationViolation(format, ...args) {\n  if (true) {\n    const message = sprintf_1.call(null, format, ...args);\n    const error = new Error(message);\n    error.name = 'Expectation Violation';\n    console.error(error);\n  }\n}\n\nvar expectationViolation_1 = expectationViolation; // @oss-only\n\nvar Recoil_expectationViolation = expectationViolation_1;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Creates a new iterable whose output is generated by passing the input\n * iterable's values through the mapper function.\n */\n\nfunction mapIterable(iterable, callback) {\n  // Use generator to create iterable/iterator\n  return function* () {\n    let index = 0;\n\n    for (const value of iterable) {\n      yield callback(value, index++);\n    }\n  }();\n}\n\nvar Recoil_mapIterable = mapIterable;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction recoverableViolation(message, _projectName, {\n  error\n} = {}) {\n  if (true) {\n    console.error(message, error);\n  }\n\n  return null;\n}\n\nvar recoverableViolation_1 = recoverableViolation; // @oss-only\n\nvar Recoil_recoverableViolation = recoverableViolation_1;\nconst {\n  isFastRefreshEnabled: isFastRefreshEnabled$1\n} = Recoil_ReactMode;\n\nclass DefaultValue {}\n\nconst DEFAULT_VALUE = new DefaultValue(); // flowlint-next-line unclear-type:off\n\nconst nodes = new Map(); // flowlint-next-line unclear-type:off\n\nconst recoilValues = new Map();\n/* eslint-disable no-redeclare */\n\nfunction recoilValuesForKeys(keys) {\n  return Recoil_mapIterable(keys, key => Recoil_nullthrows(recoilValues.get(key)));\n}\n\nfunction registerNode(node) {\n  if (nodes.has(node.key)) {\n    const message = `Duplicate atom key \"${node.key}\". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;\n\n    if (true) {\n      // TODO Figure this out for open-source\n      if (!isFastRefreshEnabled$1()) {\n        Recoil_expectationViolation(message, 'recoil');\n      }\n    } else {}\n  }\n\n  nodes.set(node.key, node);\n  const recoilValue = node.set == null ? new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key) : new Recoil_RecoilValue$1.RecoilState(node.key);\n  recoilValues.set(node.key, recoilValue);\n  return recoilValue;\n}\n/* eslint-enable no-redeclare */\n\n\nclass NodeMissingError extends Error {} // flowlint-next-line unclear-type:off\n\n\nfunction getNode(key) {\n  const node = nodes.get(key);\n\n  if (node == null) {\n    throw new NodeMissingError(`Missing definition for RecoilValue: \"${key}\"\"`);\n  }\n\n  return node;\n} // flowlint-next-line unclear-type:off\n\n\nfunction getNodeMaybe(key) {\n  return nodes.get(key);\n}\n\nconst configDeletionHandlers = new Map();\n\nfunction deleteNodeConfigIfPossible(key) {\n  var _node$shouldDeleteCon;\n\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const node = nodes.get(key);\n\n  if (node !== null && node !== void 0 && (_node$shouldDeleteCon = node.shouldDeleteConfigOnRelease) !== null && _node$shouldDeleteCon !== void 0 && _node$shouldDeleteCon.call(node)) {\n    var _getConfigDeletionHan;\n\n    nodes.delete(key);\n    (_getConfigDeletionHan = getConfigDeletionHandler(key)) === null || _getConfigDeletionHan === void 0 ? void 0 : _getConfigDeletionHan();\n    configDeletionHandlers.delete(key);\n  }\n}\n\nfunction setConfigDeletionHandler(key, fn) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  if (fn === undefined) {\n    configDeletionHandlers.delete(key);\n  } else {\n    configDeletionHandlers.set(key, fn);\n  }\n}\n\nfunction getConfigDeletionHandler(key) {\n  return configDeletionHandlers.get(key);\n}\n\nvar Recoil_Node = {\n  nodes,\n  recoilValues,\n  registerNode,\n  getNode,\n  getNodeMaybe,\n  deleteNodeConfigIfPossible,\n  setConfigDeletionHandler,\n  getConfigDeletionHandler,\n  recoilValuesForKeys,\n  NodeMissingError,\n  DefaultValue,\n  DEFAULT_VALUE\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction enqueueExecution(s, f) {\n  f();\n}\n\nvar Recoil_Queue = {\n  enqueueExecution\n};\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar hamt_1 = createCommonjsModule(function (module) {\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n  /**\n      @fileOverview Hash Array Mapped Trie.\n  \n      Code based on: https://github.com/exclipy/pdata\n  */\n\n\n  var hamt = {}; // export\n\n  /* Configuration\n   ******************************************************************************/\n\n  var SIZE = 5;\n  var BUCKET_SIZE = Math.pow(2, SIZE);\n  var MASK = BUCKET_SIZE - 1;\n  var MAX_INDEX_NODE = BUCKET_SIZE / 2;\n  var MIN_ARRAY_NODE = BUCKET_SIZE / 4;\n  /*\n   ******************************************************************************/\n\n  var nothing = {};\n\n  var constant = function constant(x) {\n    return function () {\n      return x;\n    };\n  };\n  /**\n      Get 32 bit hash of string.\n  \n      Based on:\n      http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n  */\n\n\n  var hash = hamt.hash = function (str) {\n    var type = typeof str === 'undefined' ? 'undefined' : _typeof(str);\n    if (type === 'number') return str;\n    if (type !== 'string') str += '';\n    var hash = 0;\n\n    for (var i = 0, len = str.length; i < len; ++i) {\n      var c = str.charCodeAt(i);\n      hash = (hash << 5) - hash + c | 0;\n    }\n\n    return hash;\n  };\n  /* Bit Ops\n   ******************************************************************************/\n\n  /**\n      Hamming weight.\n  \n      Taken from: http://jsperf.com/hamming-weight\n  */\n\n\n  var popcount = function popcount(x) {\n    x -= x >> 1 & 0x55555555;\n    x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n    x = x + (x >> 4) & 0x0f0f0f0f;\n    x += x >> 8;\n    x += x >> 16;\n    return x & 0x7f;\n  };\n\n  var hashFragment = function hashFragment(shift, h) {\n    return h >>> shift & MASK;\n  };\n\n  var toBitmap = function toBitmap(x) {\n    return 1 << x;\n  };\n\n  var fromBitmap = function fromBitmap(bitmap, bit) {\n    return popcount(bitmap & bit - 1);\n  };\n  /* Array Ops\n   ******************************************************************************/\n\n  /**\n      Set a value in an array.\n  \n      @param mutate Should the input array be mutated?\n      @param at Index to change.\n      @param v New value\n      @param arr Array.\n  */\n\n\n  var arrayUpdate = function arrayUpdate(mutate, at, v, arr) {\n    var out = arr;\n\n    if (!mutate) {\n      var len = arr.length;\n      out = new Array(len);\n\n      for (var i = 0; i < len; ++i) {\n        out[i] = arr[i];\n      }\n    }\n\n    out[at] = v;\n    return out;\n  };\n  /**\n      Remove a value from an array.\n  \n      @param mutate Should the input array be mutated?\n      @param at Index to remove.\n      @param arr Array.\n  */\n\n\n  var arraySpliceOut = function arraySpliceOut(mutate, at, arr) {\n    var newLen = arr.length - 1;\n    var i = 0;\n    var g = 0;\n    var out = arr;\n\n    if (mutate) {\n      i = g = at;\n    } else {\n      out = new Array(newLen);\n\n      while (i < at) {\n        out[g++] = arr[i++];\n      }\n    }\n\n    ++i;\n\n    while (i <= newLen) {\n      out[g++] = arr[i++];\n    }\n\n    if (mutate) {\n      out.length = newLen;\n    }\n\n    return out;\n  };\n  /**\n      Insert a value into an array.\n  \n      @param mutate Should the input array be mutated?\n      @param at Index to insert at.\n      @param v Value to insert,\n      @param arr Array.\n  */\n\n\n  var arraySpliceIn = function arraySpliceIn(mutate, at, v, arr) {\n    var len = arr.length;\n\n    if (mutate) {\n      var _i = len;\n\n      while (_i >= at) {\n        arr[_i--] = arr[_i];\n      }\n\n      arr[at] = v;\n      return arr;\n    }\n\n    var i = 0,\n        g = 0;\n    var out = new Array(len + 1);\n\n    while (i < at) {\n      out[g++] = arr[i++];\n    }\n\n    out[at] = v;\n\n    while (i < len) {\n      out[++g] = arr[i++];\n    }\n\n    return out;\n  };\n  /* Node Structures\n   ******************************************************************************/\n\n\n  var LEAF = 1;\n  var COLLISION = 2;\n  var INDEX = 3;\n  var ARRAY = 4;\n  /**\n      Empty node.\n  */\n\n  var empty = {\n    __hamt_isEmpty: true\n  };\n\n  var isEmptyNode = function isEmptyNode(x) {\n    return x === empty || x && x.__hamt_isEmpty;\n  };\n  /**\n      Leaf holding a value.\n  \n      @member edit Edit of the node.\n      @member hash Hash of key.\n      @member key Key.\n      @member value Value stored.\n  */\n\n\n  var Leaf = function Leaf(edit, hash, key, value) {\n    return {\n      type: LEAF,\n      edit: edit,\n      hash: hash,\n      key: key,\n      value: value,\n      _modify: Leaf__modify\n    };\n  };\n  /**\n      Leaf holding multiple values with the same hash but different keys.\n  \n      @member edit Edit of the node.\n      @member hash Hash of key.\n      @member children Array of collision children node.\n  */\n\n\n  var Collision = function Collision(edit, hash, children) {\n    return {\n      type: COLLISION,\n      edit: edit,\n      hash: hash,\n      children: children,\n      _modify: Collision__modify\n    };\n  };\n  /**\n      Internal node with a sparse set of children.\n  \n      Uses a bitmap and array to pack children.\n  \n    @member edit Edit of the node.\n      @member mask Bitmap that encode the positions of children in the array.\n      @member children Array of child nodes.\n  */\n\n\n  var IndexedNode = function IndexedNode(edit, mask, children) {\n    return {\n      type: INDEX,\n      edit: edit,\n      mask: mask,\n      children: children,\n      _modify: IndexedNode__modify\n    };\n  };\n  /**\n      Internal node with many children.\n  \n      @member edit Edit of the node.\n      @member size Number of children.\n      @member children Array of child nodes.\n  */\n\n\n  var ArrayNode = function ArrayNode(edit, size, children) {\n    return {\n      type: ARRAY,\n      edit: edit,\n      size: size,\n      children: children,\n      _modify: ArrayNode__modify\n    };\n  };\n  /**\n      Is `node` a leaf node?\n  */\n\n\n  var isLeaf = function isLeaf(node) {\n    return node === empty || node.type === LEAF || node.type === COLLISION;\n  };\n  /* Internal node operations.\n   ******************************************************************************/\n\n  /**\n      Expand an indexed node into an array node.\n  \n    @param edit Current edit.\n      @param frag Index of added child.\n      @param child Added child.\n      @param mask Index node mask before child added.\n      @param subNodes Index node children before child added.\n  */\n\n\n  var expand = function expand(edit, frag, child, bitmap, subNodes) {\n    var arr = [];\n    var bit = bitmap;\n    var count = 0;\n\n    for (var i = 0; bit; ++i) {\n      if (bit & 1) arr[i] = subNodes[count++];\n      bit >>>= 1;\n    }\n\n    arr[frag] = child;\n    return ArrayNode(edit, count + 1, arr);\n  };\n  /**\n      Collapse an array node into a indexed node.\n  \n    @param edit Current edit.\n      @param count Number of elements in new array.\n      @param removed Index of removed element.\n      @param elements Array node children before remove.\n  */\n\n\n  var pack = function pack(edit, count, removed, elements) {\n    var children = new Array(count - 1);\n    var g = 0;\n    var bitmap = 0;\n\n    for (var i = 0, len = elements.length; i < len; ++i) {\n      if (i !== removed) {\n        var elem = elements[i];\n\n        if (elem && !isEmptyNode(elem)) {\n          children[g++] = elem;\n          bitmap |= 1 << i;\n        }\n      }\n    }\n\n    return IndexedNode(edit, bitmap, children);\n  };\n  /**\n      Merge two leaf nodes.\n  \n      @param shift Current shift.\n      @param h1 Node 1 hash.\n      @param n1 Node 1.\n      @param h2 Node 2 hash.\n      @param n2 Node 2.\n  */\n\n\n  var mergeLeaves = function mergeLeaves(edit, shift, h1, n1, h2, n2) {\n    if (h1 === h2) return Collision(edit, h1, [n2, n1]);\n    var subH1 = hashFragment(shift, h1);\n    var subH2 = hashFragment(shift, h2);\n    return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [mergeLeaves(edit, shift + SIZE, h1, n1, h2, n2)] : subH1 < subH2 ? [n1, n2] : [n2, n1]);\n  };\n  /**\n      Update an entry in a collision list.\n  \n      @param mutate Should mutation be used?\n      @param edit Current edit.\n      @param keyEq Key compare function.\n      @param hash Hash of collision.\n      @param list Collision list.\n      @param f Update function.\n      @param k Key to update.\n      @param size Size ref.\n  */\n\n\n  var updateCollisionList = function updateCollisionList(mutate, edit, keyEq, h, list, f, k, size) {\n    var len = list.length;\n\n    for (var i = 0; i < len; ++i) {\n      var child = list[i];\n\n      if (keyEq(k, child.key)) {\n        var value = child.value;\n\n        var _newValue = f(value);\n\n        if (_newValue === value) return list;\n\n        if (_newValue === nothing) {\n          --size.value;\n          return arraySpliceOut(mutate, i, list);\n        }\n\n        return arrayUpdate(mutate, i, Leaf(edit, h, k, _newValue), list);\n      }\n    }\n\n    var newValue = f();\n    if (newValue === nothing) return list;\n    ++size.value;\n    return arrayUpdate(mutate, len, Leaf(edit, h, k, newValue), list);\n  };\n\n  var canEditNode = function canEditNode(edit, node) {\n    return edit === node.edit;\n  };\n  /* Editing\n   ******************************************************************************/\n\n\n  var Leaf__modify = function Leaf__modify(edit, keyEq, shift, f, h, k, size) {\n    if (keyEq(k, this.key)) {\n      var _v = f(this.value);\n\n      if (_v === this.value) return this;else if (_v === nothing) {\n        --size.value;\n        return empty;\n      }\n\n      if (canEditNode(edit, this)) {\n        this.value = _v;\n        return this;\n      }\n\n      return Leaf(edit, h, k, _v);\n    }\n\n    var v = f();\n    if (v === nothing) return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n  };\n\n  var Collision__modify = function Collision__modify(edit, keyEq, shift, f, h, k, size) {\n    if (h === this.hash) {\n      var canEdit = canEditNode(edit, this);\n      var list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f, k, size);\n      if (list === this.children) return this;\n      return list.length > 1 ? Collision(edit, this.hash, list) : list[0]; // collapse single element collision list\n    }\n\n    var v = f();\n    if (v === nothing) return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n  };\n\n  var IndexedNode__modify = function IndexedNode__modify(edit, keyEq, shift, f, h, k, size) {\n    var mask = this.mask;\n    var children = this.children;\n    var frag = hashFragment(shift, h);\n    var bit = toBitmap(frag);\n    var indx = fromBitmap(mask, bit);\n    var exists = mask & bit;\n    var current = exists ? children[indx] : empty;\n\n    var child = current._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n\n    if (current === child) return this;\n    var canEdit = canEditNode(edit, this);\n    var bitmap = mask;\n    var newChildren = void 0;\n\n    if (exists && isEmptyNode(child)) {\n      // remove\n      bitmap &= ~bit;\n      if (!bitmap) return empty;\n      if (children.length <= 2 && isLeaf(children[indx ^ 1])) return children[indx ^ 1]; // collapse\n\n      newChildren = arraySpliceOut(canEdit, indx, children);\n    } else if (!exists && !isEmptyNode(child)) {\n      // add\n      if (children.length >= MAX_INDEX_NODE) return expand(edit, frag, child, mask, children);\n      bitmap |= bit;\n      newChildren = arraySpliceIn(canEdit, indx, child, children);\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, indx, child, children);\n    }\n\n    if (canEdit) {\n      this.mask = bitmap;\n      this.children = newChildren;\n      return this;\n    }\n\n    return IndexedNode(edit, bitmap, newChildren);\n  };\n\n  var ArrayNode__modify = function ArrayNode__modify(edit, keyEq, shift, f, h, k, size) {\n    var count = this.size;\n    var children = this.children;\n    var frag = hashFragment(shift, h);\n    var child = children[frag];\n\n    var newChild = (child || empty)._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n\n    if (child === newChild) return this;\n    var canEdit = canEditNode(edit, this);\n    var newChildren = void 0;\n\n    if (isEmptyNode(child) && !isEmptyNode(newChild)) {\n      // add\n      ++count;\n      newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {\n      // remove\n      --count;\n      if (count <= MIN_ARRAY_NODE) return pack(edit, count, frag, children);\n      newChildren = arrayUpdate(canEdit, frag, empty, children);\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    }\n\n    if (canEdit) {\n      this.size = count;\n      this.children = newChildren;\n      return this;\n    }\n\n    return ArrayNode(edit, count, newChildren);\n  };\n\n  empty._modify = function (edit, keyEq, shift, f, h, k, size) {\n    var v = f();\n    if (v === nothing) return empty;\n    ++size.value;\n    return Leaf(edit, h, k, v);\n  };\n  /*\n   ******************************************************************************/\n\n\n  function Map(editable, edit, config, root, size) {\n    this._editable = editable;\n    this._edit = edit;\n    this._config = config;\n    this._root = root;\n    this._size = size;\n  }\n\n  Map.prototype.setTree = function (newRoot, newSize) {\n    if (this._editable) {\n      this._root = newRoot;\n      this._size = newSize;\n      return this;\n    }\n\n    return newRoot === this._root ? this : new Map(this._editable, this._edit, this._config, newRoot, newSize);\n  };\n  /* Queries\n   ******************************************************************************/\n\n  /**\n      Lookup the value for `key` in `map` using a custom `hash`.\n  \n      Returns the value or `alt` if none.\n  */\n\n\n  var tryGetHash = hamt.tryGetHash = function (alt, hash, key, map) {\n    var node = map._root;\n    var shift = 0;\n    var keyEq = map._config.keyEq;\n\n    while (true) {\n      switch (node.type) {\n        case LEAF:\n          {\n            return keyEq(key, node.key) ? node.value : alt;\n          }\n\n        case COLLISION:\n          {\n            if (hash === node.hash) {\n              var children = node.children;\n\n              for (var i = 0, len = children.length; i < len; ++i) {\n                var child = children[i];\n                if (keyEq(key, child.key)) return child.value;\n              }\n            }\n\n            return alt;\n          }\n\n        case INDEX:\n          {\n            var frag = hashFragment(shift, hash);\n            var bit = toBitmap(frag);\n\n            if (node.mask & bit) {\n              node = node.children[fromBitmap(node.mask, bit)];\n              shift += SIZE;\n              break;\n            }\n\n            return alt;\n          }\n\n        case ARRAY:\n          {\n            node = node.children[hashFragment(shift, hash)];\n\n            if (node) {\n              shift += SIZE;\n              break;\n            }\n\n            return alt;\n          }\n\n        default:\n          return alt;\n      }\n    }\n  };\n\n  Map.prototype.tryGetHash = function (alt, hash, key) {\n    return tryGetHash(alt, hash, key, this);\n  };\n  /**\n      Lookup the value for `key` in `map` using internal hash function.\n  \n      @see `tryGetHash`\n  */\n\n\n  var tryGet = hamt.tryGet = function (alt, key, map) {\n    return tryGetHash(alt, map._config.hash(key), key, map);\n  };\n\n  Map.prototype.tryGet = function (alt, key) {\n    return tryGet(alt, key, this);\n  };\n  /**\n      Lookup the value for `key` in `map` using a custom `hash`.\n  \n      Returns the value or `undefined` if none.\n  */\n\n\n  var getHash = hamt.getHash = function (hash, key, map) {\n    return tryGetHash(undefined, hash, key, map);\n  };\n\n  Map.prototype.getHash = function (hash, key) {\n    return getHash(hash, key, this);\n  };\n  /**\n      Lookup the value for `key` in `map` using internal hash function.\n  \n      @see `get`\n  */\n\n\n  var get = hamt.get = function (key, map) {\n    return tryGetHash(undefined, map._config.hash(key), key, map);\n  };\n\n  Map.prototype.get = function (key, alt) {\n    return tryGet(alt, key, this);\n  };\n  /**\n      Does an entry exist for `key` in `map`? Uses custom `hash`.\n  */\n\n\n  var hasHash = hamt.has = function (hash, key, map) {\n    return tryGetHash(nothing, hash, key, map) !== nothing;\n  };\n\n  Map.prototype.hasHash = function (hash, key) {\n    return hasHash(hash, key, this);\n  };\n  /**\n      Does an entry exist for `key` in `map`? Uses internal hash function.\n  */\n\n\n  var has = hamt.has = function (key, map) {\n    return hasHash(map._config.hash(key), key, map);\n  };\n\n  Map.prototype.has = function (key) {\n    return has(key, this);\n  };\n\n  var defKeyCompare = function defKeyCompare(x, y) {\n    return x === y;\n  };\n  /**\n      Create an empty map.\n  \n      @param config Configuration.\n  */\n\n\n  hamt.make = function (config) {\n    return new Map(0, 0, {\n      keyEq: config && config.keyEq || defKeyCompare,\n      hash: config && config.hash || hash\n    }, empty, 0);\n  };\n  /**\n      Empty map.\n  */\n\n\n  hamt.empty = hamt.make();\n  /**\n      Does `map` contain any elements?\n  */\n\n  var isEmpty = hamt.isEmpty = function (map) {\n    return map && !!isEmptyNode(map._root);\n  };\n\n  Map.prototype.isEmpty = function () {\n    return isEmpty(this);\n  };\n  /* Updates\n   ******************************************************************************/\n\n  /**\n      Alter the value stored for `key` in `map` using function `f` using\n      custom hash.\n  \n      `f` is invoked with the current value for `k` if it exists,\n      or no arguments if no such value exists. `modify` will always either\n      update or insert a value into the map.\n  \n      Returns a map with the modified value. Does not alter `map`.\n  */\n\n\n  var modifyHash = hamt.modifyHash = function (f, hash, key, map) {\n    var size = {\n      value: map._size\n    };\n\n    var newRoot = map._root._modify(map._editable ? map._edit : NaN, map._config.keyEq, 0, f, hash, key, size);\n\n    return map.setTree(newRoot, size.value);\n  };\n\n  Map.prototype.modifyHash = function (hash, key, f) {\n    return modifyHash(f, hash, key, this);\n  };\n  /**\n      Alter the value stored for `key` in `map` using function `f` using\n      internal hash function.\n  \n      @see `modifyHash`\n  */\n\n\n  var modify = hamt.modify = function (f, key, map) {\n    return modifyHash(f, map._config.hash(key), key, map);\n  };\n\n  Map.prototype.modify = function (key, f) {\n    return modify(f, key, this);\n  };\n  /**\n      Store `value` for `key` in `map` using custom `hash`.\n  \n      Returns a map with the modified value. Does not alter `map`.\n  */\n\n\n  var setHash = hamt.setHash = function (hash, key, value, map) {\n    return modifyHash(constant(value), hash, key, map);\n  };\n\n  Map.prototype.setHash = function (hash, key, value) {\n    return setHash(hash, key, value, this);\n  };\n  /**\n      Store `value` for `key` in `map` using internal hash function.\n  \n      @see `setHash`\n  */\n\n\n  var set = hamt.set = function (key, value, map) {\n    return setHash(map._config.hash(key), key, value, map);\n  };\n\n  Map.prototype.set = function (key, value) {\n    return set(key, value, this);\n  };\n  /**\n      Remove the entry for `key` in `map`.\n  \n      Returns a map with the value removed. Does not alter `map`.\n  */\n\n\n  var del = constant(nothing);\n\n  var removeHash = hamt.removeHash = function (hash, key, map) {\n    return modifyHash(del, hash, key, map);\n  };\n\n  Map.prototype.removeHash = Map.prototype.deleteHash = function (hash, key) {\n    return removeHash(hash, key, this);\n  };\n  /**\n      Remove the entry for `key` in `map` using internal hash function.\n  \n      @see `removeHash`\n  */\n\n\n  var remove = hamt.remove = function (key, map) {\n    return removeHash(map._config.hash(key), key, map);\n  };\n\n  Map.prototype.remove = Map.prototype.delete = function (key) {\n    return remove(key, this);\n  };\n  /* Mutation\n   ******************************************************************************/\n\n  /**\n      Mark `map` as mutable.\n   */\n\n\n  var beginMutation = hamt.beginMutation = function (map) {\n    return new Map(map._editable + 1, map._edit + 1, map._config, map._root, map._size);\n  };\n\n  Map.prototype.beginMutation = function () {\n    return beginMutation(this);\n  };\n  /**\n      Mark `map` as immutable.\n   */\n\n\n  var endMutation = hamt.endMutation = function (map) {\n    map._editable = map._editable && map._editable - 1;\n    return map;\n  };\n\n  Map.prototype.endMutation = function () {\n    return endMutation(this);\n  };\n  /**\n      Mutate `map` within the context of `f`.\n      @param f\n      @param map HAMT\n  */\n\n\n  var mutate = hamt.mutate = function (f, map) {\n    var transient = beginMutation(map);\n    f(transient);\n    return endMutation(transient);\n  };\n\n  Map.prototype.mutate = function (f) {\n    return mutate(f, this);\n  };\n  /* Traversal\n   ******************************************************************************/\n\n  /**\n      Apply a continuation.\n  */\n\n\n  var appk = function appk(k) {\n    return k && lazyVisitChildren(k[0], k[1], k[2], k[3], k[4]);\n  };\n  /**\n      Recursively visit all values stored in an array of nodes lazily.\n  */\n\n\n  var lazyVisitChildren = function lazyVisitChildren(len, children, i, f, k) {\n    while (i < len) {\n      var child = children[i++];\n      if (child && !isEmptyNode(child)) return lazyVisit(child, f, [len, children, i, f, k]);\n    }\n\n    return appk(k);\n  };\n  /**\n      Recursively visit all values stored in `node` lazily.\n  */\n\n\n  var lazyVisit = function lazyVisit(node, f, k) {\n    switch (node.type) {\n      case LEAF:\n        return {\n          value: f(node),\n          rest: k\n        };\n\n      case COLLISION:\n      case ARRAY:\n      case INDEX:\n        var children = node.children;\n        return lazyVisitChildren(children.length, children, 0, f, k);\n\n      default:\n        return appk(k);\n    }\n  };\n\n  var DONE = {\n    done: true\n  };\n  /**\n      Javascript iterator over a map.\n  */\n\n  function MapIterator(v) {\n    this.v = v;\n  }\n\n  MapIterator.prototype.next = function () {\n    if (!this.v) return DONE;\n    var v0 = this.v;\n    this.v = appk(v0.rest);\n    return v0;\n  };\n\n  MapIterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n  /**\n      Lazily visit each value in map with function `f`.\n  */\n\n\n  var visit = function visit(map, f) {\n    return new MapIterator(lazyVisit(map._root, f));\n  };\n  /**\n      Get a Javascsript iterator of `map`.\n  \n      Iterates over `[key, value]` arrays.\n  */\n\n\n  var buildPairs = function buildPairs(x) {\n    return [x.key, x.value];\n  };\n\n  var entries = hamt.entries = function (map) {\n    return visit(map, buildPairs);\n  };\n\n  Map.prototype.entries = Map.prototype[Symbol.iterator] = function () {\n    return entries(this);\n  };\n  /**\n      Get array of all keys in `map`.\n  \n      Order is not guaranteed.\n  */\n\n\n  var buildKeys = function buildKeys(x) {\n    return x.key;\n  };\n\n  var keys = hamt.keys = function (map) {\n    return visit(map, buildKeys);\n  };\n\n  Map.prototype.keys = function () {\n    return keys(this);\n  };\n  /**\n      Get array of all values in `map`.\n  \n      Order is not guaranteed, duplicates are preserved.\n  */\n\n\n  var buildValues = function buildValues(x) {\n    return x.value;\n  };\n\n  var values = hamt.values = Map.prototype.values = function (map) {\n    return visit(map, buildValues);\n  };\n\n  Map.prototype.values = function () {\n    return values(this);\n  };\n  /* Fold\n   ******************************************************************************/\n\n  /**\n      Visit every entry in the map, aggregating data.\n  \n      Order of nodes is not guaranteed.\n  \n      @param f Function mapping accumulated value, value, and key to new value.\n      @param z Starting value.\n      @param m HAMT\n  */\n\n\n  var fold = hamt.fold = function (f, z, m) {\n    var root = m._root;\n    if (root.type === LEAF) return f(z, root.value, root.key);\n    var toVisit = [root.children];\n    var children = void 0;\n\n    while (children = toVisit.pop()) {\n      for (var i = 0, len = children.length; i < len;) {\n        var child = children[i++];\n\n        if (child && child.type) {\n          if (child.type === LEAF) z = f(z, child.value, child.key);else toVisit.push(child.children);\n        }\n      }\n    }\n\n    return z;\n  };\n\n  Map.prototype.fold = function (f, z) {\n    return fold(f, z, this);\n  };\n  /**\n      Visit every entry in the map, aggregating data.\n  \n      Order of nodes is not guaranteed.\n  \n      @param f Function invoked with value and key\n      @param map HAMT\n  */\n\n\n  var forEach = hamt.forEach = function (f, map) {\n    return fold(function (_, value, key) {\n      return f(value, key, map);\n    }, null, map);\n  };\n\n  Map.prototype.forEach = function (f) {\n    return forEach(f, this);\n  };\n  /* Aggregate\n   ******************************************************************************/\n\n  /**\n      Get the number of entries in `map`.\n  */\n\n\n  var count = hamt.count = function (map) {\n    return map._size;\n  };\n\n  Map.prototype.count = function () {\n    return count(this);\n  };\n\n  Object.defineProperty(Map.prototype, 'size', {\n    get: Map.prototype.count\n  });\n  /* Export\n   ******************************************************************************/\n\n  if (module.exports) {\n    module.exports = hamt;\n  } else {\n    undefined.hamt = hamt;\n  }\n});\n\nclass BuiltInMap {\n  constructor(existing) {\n    _defineProperty(this, \"_map\", void 0);\n\n    this._map = new Map(existing === null || existing === void 0 ? void 0 : existing.entries());\n  }\n\n  keys() {\n    return this._map.keys();\n  }\n\n  entries() {\n    return this._map.entries();\n  }\n\n  get(k) {\n    return this._map.get(k);\n  }\n\n  has(k) {\n    return this._map.has(k);\n  }\n\n  set(k, v) {\n    this._map.set(k, v);\n\n    return this;\n  }\n\n  delete(k) {\n    this._map.delete(k);\n\n    return this;\n  }\n\n  clone() {\n    return persistentMap(this);\n  }\n\n  toMap() {\n    return new Map(this._map);\n  }\n\n}\n\nclass HashArrayMappedTrieMap {\n  // Because hamt.empty is not a function there is no way to introduce type\n  // parameters on it, so empty is typed as HAMTPlusMap<string, mixed>.\n  // $FlowIssue\n  constructor(existing) {\n    _defineProperty(this, \"_hamt\", hamt_1.empty.beginMutation());\n\n    if (existing instanceof HashArrayMappedTrieMap) {\n      const h = existing._hamt.endMutation();\n\n      existing._hamt = h.beginMutation();\n      this._hamt = h.beginMutation();\n    } else if (existing) {\n      for (const [k, v] of existing.entries()) {\n        this._hamt.set(k, v);\n      }\n    }\n  }\n\n  keys() {\n    return this._hamt.keys();\n  }\n\n  entries() {\n    return this._hamt.entries();\n  }\n\n  get(k) {\n    return this._hamt.get(k);\n  }\n\n  has(k) {\n    return this._hamt.has(k);\n  }\n\n  set(k, v) {\n    this._hamt.set(k, v);\n\n    return this;\n  }\n\n  delete(k) {\n    this._hamt.delete(k);\n\n    return this;\n  }\n\n  clone() {\n    return persistentMap(this);\n  }\n\n  toMap() {\n    return new Map(this._hamt);\n  }\n\n}\n\nfunction persistentMap(existing) {\n  if (Recoil_gkx('recoil_hamt_2020')) {\n    return new HashArrayMappedTrieMap(existing);\n  } else {\n    return new BuiltInMap(existing);\n  }\n}\n\nvar Recoil_PersistentMap = {\n  persistentMap\n};\nvar Recoil_PersistentMap_1 = Recoil_PersistentMap.persistentMap;\nvar Recoil_PersistentMap$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  persistentMap: Recoil_PersistentMap_1\n});\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Returns a set containing all of the values from the first set that are not\n * present in any of the subsequent sets.\n *\n * Note: this is written procedurally (i.e., without filterSet) for performant\n * use in tight loops.\n */\n\nfunction differenceSets(set, ...setsWithValuesToRemove) {\n  const ret = new Set();\n\n  FIRST: for (const value of set) {\n    for (const otherSet of setsWithValuesToRemove) {\n      if (otherSet.has(value)) {\n        continue FIRST;\n      }\n    }\n\n    ret.add(value);\n  }\n\n  return ret;\n}\n\nvar Recoil_differenceSets = differenceSets;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Returns a new Map object with the same keys as the original, but with the\n * values replaced with the output of the given callback function.\n */\n\nfunction mapMap(map, callback) {\n  const result = new Map();\n  map.forEach((value, key) => {\n    result.set(key, callback(value, key));\n  });\n  return result;\n}\n\nvar Recoil_mapMap = mapMap;\n\nfunction makeGraph() {\n  return {\n    nodeDeps: new Map(),\n    nodeToNodeSubscriptions: new Map()\n  };\n}\n\nfunction cloneGraph(graph) {\n  return {\n    nodeDeps: Recoil_mapMap(graph.nodeDeps, s => new Set(s)),\n    nodeToNodeSubscriptions: Recoil_mapMap(graph.nodeToNodeSubscriptions, s => new Set(s))\n  };\n} // Note that this overwrites the deps of existing nodes, rather than unioning\n// the new deps with the old deps.\n\n\nfunction mergeDepsIntoGraph(key, newDeps, graph, // If olderGraph is given then we will not overwrite changes made to the given\n// graph compared with olderGraph:\nolderGraph) {\n  const {\n    nodeDeps,\n    nodeToNodeSubscriptions\n  } = graph;\n  const oldDeps = nodeDeps.get(key);\n\n  if (oldDeps && olderGraph && oldDeps !== olderGraph.nodeDeps.get(key)) {\n    return;\n  } // Update nodeDeps:\n\n\n  nodeDeps.set(key, newDeps); // Add new deps to nodeToNodeSubscriptions:\n\n  const addedDeps = oldDeps == null ? newDeps : Recoil_differenceSets(newDeps, oldDeps);\n\n  for (const dep of addedDeps) {\n    if (!nodeToNodeSubscriptions.has(dep)) {\n      nodeToNodeSubscriptions.set(dep, new Set());\n    }\n\n    const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));\n    existing.add(key);\n  } // Remove removed deps from nodeToNodeSubscriptions:\n\n\n  if (oldDeps) {\n    const removedDeps = Recoil_differenceSets(oldDeps, newDeps);\n\n    for (const dep of removedDeps) {\n      if (!nodeToNodeSubscriptions.has(dep)) {\n        return;\n      }\n\n      const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));\n      existing.delete(key);\n\n      if (existing.size === 0) {\n        nodeToNodeSubscriptions.delete(dep);\n      }\n    }\n  }\n}\n\nfunction saveDepsToStore(key, deps, store, version) {\n  var _storeState$nextTree, _storeState$previousT, _storeState$previousT2, _storeState$previousT3;\n\n  const storeState = store.getState();\n\n  if (!(version === storeState.currentTree.version || version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {\n    Recoil_recoverableViolation('Tried to save dependencies to a discarded tree');\n  } // Merge the dependencies discovered into the store's dependency map\n  // for the version that was read:\n\n\n  const graph = store.getGraph(version);\n  mergeDepsIntoGraph(key, deps, graph); // If this version is not the latest version, also write these dependencies\n  // into later versions if they don't already have their own:\n\n  if (version === ((_storeState$previousT2 = storeState.previousTree) === null || _storeState$previousT2 === void 0 ? void 0 : _storeState$previousT2.version)) {\n    const currentGraph = store.getGraph(storeState.currentTree.version);\n    mergeDepsIntoGraph(key, deps, currentGraph, graph);\n  }\n\n  if (version === ((_storeState$previousT3 = storeState.previousTree) === null || _storeState$previousT3 === void 0 ? void 0 : _storeState$previousT3.version) || version === storeState.currentTree.version) {\n    var _storeState$nextTree2;\n\n    const nextVersion = (_storeState$nextTree2 = storeState.nextTree) === null || _storeState$nextTree2 === void 0 ? void 0 : _storeState$nextTree2.version;\n\n    if (nextVersion !== undefined) {\n      const nextGraph = store.getGraph(nextVersion);\n      mergeDepsIntoGraph(key, deps, nextGraph, graph);\n    }\n  }\n}\n\nvar Recoil_Graph = {\n  cloneGraph,\n  graph: makeGraph,\n  saveDepsToStore\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nlet nextTreeStateVersion = 0;\n\nconst getNextTreeStateVersion = () => nextTreeStateVersion++;\n\nlet nextStoreID = 0;\n\nconst getNextStoreID = () => nextStoreID++;\n\nlet nextComponentID = 0;\n\nconst getNextComponentID = () => nextComponentID++;\n\nvar Recoil_Keys = {\n  getNextTreeStateVersion,\n  getNextStoreID,\n  getNextComponentID\n};\nconst {\n  persistentMap: persistentMap$1\n} = Recoil_PersistentMap$1;\nconst {\n  graph\n} = Recoil_Graph;\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$1\n} = Recoil_Keys;\n\nfunction makeEmptyTreeState() {\n  const version = getNextTreeStateVersion$1();\n  return {\n    version,\n    stateID: version,\n    transactionMetadata: {},\n    dirtyAtoms: new Set(),\n    atomValues: persistentMap$1(),\n    nonvalidatedAtoms: persistentMap$1()\n  };\n}\n\nfunction makeEmptyStoreState() {\n  const currentTree = makeEmptyTreeState();\n  return {\n    currentTree,\n    nextTree: null,\n    previousTree: null,\n    commitDepth: 0,\n    knownAtoms: new Set(),\n    knownSelectors: new Set(),\n    transactionSubscriptions: new Map(),\n    nodeTransactionSubscriptions: new Map(),\n    nodeToComponentSubscriptions: new Map(),\n    queuedComponentCallbacks_DEPRECATED: [],\n    suspendedComponentResolvers: new Set(),\n    graphsByVersion: new Map().set(currentTree.version, graph()),\n    retention: {\n      referenceCounts: new Map(),\n      nodesRetainedByZone: new Map(),\n      retainablesToCheckForRelease: new Set()\n    },\n    nodeCleanupFunctions: new Map()\n  };\n}\n\nvar Recoil_State = {\n  makeEmptyTreeState,\n  makeEmptyStoreState,\n  getNextTreeStateVersion: getNextTreeStateVersion$1\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nclass RetentionZone {}\n\nfunction retentionZone() {\n  return new RetentionZone();\n}\n\nvar Recoil_RetentionZone = {\n  RetentionZone,\n  retentionZone\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Utilities for working with built-in Maps and Sets without mutating them.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction setByAddingToSet(set, v) {\n  const next = new Set(set);\n  next.add(v);\n  return next;\n}\n\nfunction setByDeletingFromSet(set, v) {\n  const next = new Set(set);\n  next.delete(v);\n  return next;\n}\n\nfunction mapBySettingInMap(map, k, v) {\n  const next = new Map(map);\n  next.set(k, v);\n  return next;\n}\n\nfunction mapByUpdatingInMap(map, k, updater) {\n  const next = new Map(map);\n  next.set(k, updater(next.get(k)));\n  return next;\n}\n\nfunction mapByDeletingFromMap(map, k) {\n  const next = new Map(map);\n  next.delete(k);\n  return next;\n}\n\nfunction mapByDeletingMultipleFromMap(map, ks) {\n  const next = new Map(map);\n  ks.forEach(k => next.delete(k));\n  return next;\n}\n\nvar Recoil_CopyOnWrite = {\n  setByAddingToSet,\n  setByDeletingFromSet,\n  mapBySettingInMap,\n  mapByUpdatingInMap,\n  mapByDeletingFromMap,\n  mapByDeletingMultipleFromMap\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Creates a new iterable whose output is generated by passing the input\n * iterable's values through the filter function.\n */\n\nfunction* filterIterable(iterable, predicate) {\n  // Use generator to create iterable/iterator\n  let index = 0;\n\n  for (const value of iterable) {\n    if (predicate(value, index++)) {\n      yield value;\n    }\n  }\n}\n\nvar Recoil_filterIterable = filterIterable;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Return a proxy object based on the provided base and factories objects.\n * The proxy will include all properties of the base object as-is.\n * The factories object contains callbacks to obtain the values of the properies\n * for its keys.\n *\n * This is useful for providing users an object where some properties may be\n * lazily computed only on first access.\n */\n// $FlowIssue[unclear-type]\n\nfunction lazyProxy(base, factories) {\n  const proxy = new Proxy(base, {\n    // Compute and cache lazy property if not already done.\n    get: (target, prop) => {\n      if (!(prop in target) && prop in factories) {\n        target[prop] = factories[prop]();\n      }\n\n      return target[prop];\n    },\n    // This method allows user to iterate keys as normal\n    ownKeys: target => {\n      return Object.keys(target);\n    }\n  }); // $FlowIssue[incompatible-return]\n\n  return proxy;\n}\n\nvar Recoil_lazyProxy = lazyProxy;\nconst {\n  getNode: getNode$1,\n  getNodeMaybe: getNodeMaybe$1,\n  recoilValuesForKeys: recoilValuesForKeys$1\n} = Recoil_Node;\nconst {\n  RetentionZone: RetentionZone$1\n} = Recoil_RetentionZone;\nconst {\n  setByAddingToSet: setByAddingToSet$1\n} = Recoil_CopyOnWrite; // flowlint-next-line unclear-type:off\n\nconst emptySet = Object.freeze(new Set());\n\nclass ReadOnlyRecoilValueError extends Error {}\n\nfunction initializeRetentionForNode(store, nodeKey, retainedBy) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return () => undefined;\n  }\n\n  const {\n    nodesRetainedByZone\n  } = store.getState().retention;\n\n  function addToZone(zone) {\n    let set = nodesRetainedByZone.get(zone);\n\n    if (!set) {\n      nodesRetainedByZone.set(zone, set = new Set());\n    }\n\n    set.add(nodeKey);\n  }\n\n  if (retainedBy instanceof RetentionZone$1) {\n    addToZone(retainedBy);\n  } else if (Array.isArray(retainedBy)) {\n    for (const zone of retainedBy) {\n      addToZone(zone);\n    }\n  }\n\n  return () => {\n    if (!Recoil_gkx('recoil_memory_managament_2020')) {\n      return;\n    }\n\n    const {\n      retention\n    } = store.getState();\n\n    function deleteFromZone(zone) {\n      const set = retention.nodesRetainedByZone.get(zone);\n      set === null || set === void 0 ? void 0 : set.delete(nodeKey);\n\n      if (set && set.size === 0) {\n        retention.nodesRetainedByZone.delete(zone);\n      }\n    }\n\n    if (retainedBy instanceof RetentionZone$1) {\n      deleteFromZone(retainedBy);\n    } else if (Array.isArray(retainedBy)) {\n      for (const zone of retainedBy) {\n        deleteFromZone(zone);\n      }\n    }\n  };\n}\n\nfunction initializeNodeIfNewToStore(store, treeState, key, trigger) {\n  const storeState = store.getState();\n\n  if (storeState.nodeCleanupFunctions.has(key)) {\n    return;\n  }\n\n  const node = getNode$1(key);\n  const retentionCleanup = initializeRetentionForNode(store, key, node.retainedBy);\n  const nodeCleanup = node.init(store, treeState, trigger);\n  storeState.nodeCleanupFunctions.set(key, () => {\n    nodeCleanup();\n    retentionCleanup();\n  });\n}\n\nfunction initializeNode(store, key, trigger) {\n  initializeNodeIfNewToStore(store, store.getState().currentTree, key, trigger);\n}\n\nfunction cleanUpNode(store, key) {\n  var _state$nodeCleanupFun;\n\n  const state = store.getState();\n  (_state$nodeCleanupFun = state.nodeCleanupFunctions.get(key)) === null || _state$nodeCleanupFun === void 0 ? void 0 : _state$nodeCleanupFun();\n  state.nodeCleanupFunctions.delete(key);\n} // Get the current value loadable of a node and update the state.\n// Update dependencies and subscriptions for selectors.\n// Update saved value validation for atoms.\n\n\nfunction getNodeLoadable(store, state, key) {\n  initializeNodeIfNewToStore(store, state, key, 'get');\n  return getNode$1(key).get(store, state);\n} // Peek at the current value loadable for a node without any evaluation or state change\n\n\nfunction peekNodeLoadable(store, state, key) {\n  return getNode$1(key).peek(store, state);\n} // Write value directly to state bypassing the Node interface as the node\n// definitions may not have been loaded yet when processing the initial snapshot.\n\n\nfunction setUnvalidatedAtomValue_DEPRECATED(state, key, newValue) {\n  var _node$invalidate;\n\n  const node = getNodeMaybe$1(key);\n  node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);\n  return { ...state,\n    atomValues: state.atomValues.clone().delete(key),\n    nonvalidatedAtoms: state.nonvalidatedAtoms.clone().set(key, newValue),\n    dirtyAtoms: setByAddingToSet$1(state.dirtyAtoms, key)\n  };\n} // Return the discovered dependencies and values to be written by setting\n// a node value. (Multiple values may be written due to selectors getting to\n// set upstreams; deps may be discovered because of reads in updater functions.)\n\n\nfunction setNodeValue(store, state, key, newValue) {\n  const node = getNode$1(key);\n\n  if (node.set == null) {\n    throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${key}`);\n  }\n\n  const set = node.set; // so flow doesn't lose the above refinement.\n\n  initializeNodeIfNewToStore(store, state, key, 'set');\n  return set(store, state, newValue);\n}\n\nfunction peekNodeInfo(store, state, key) {\n  const storeState = store.getState();\n  const graph = store.getGraph(state.version);\n  const type = getNode$1(key).nodeType;\n  return Recoil_lazyProxy({\n    type\n  }, {\n    loadable: () => peekNodeLoadable(store, state, key),\n    isActive: () => storeState.knownAtoms.has(key) || storeState.knownSelectors.has(key),\n    isSet: () => type === 'selector' ? false : state.atomValues.has(key),\n    isModified: () => state.dirtyAtoms.has(key),\n    // Report current dependencies.  If the node hasn't been evaluated, then\n    // dependencies may be missing based on the current state.\n    deps: () => {\n      var _graph$nodeDeps$get;\n\n      return recoilValuesForKeys$1((_graph$nodeDeps$get = graph.nodeDeps.get(key)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : []);\n    },\n    // Reports all \"current\" subscribers.  Evaluating other nodes or\n    // previous in-progress async evaluations may introduce new subscribers.\n    subscribers: () => {\n      var _storeState$nodeToCom, _storeState$nodeToCom2;\n\n      return {\n        nodes: recoilValuesForKeys$1(Recoil_filterIterable(getDownstreamNodes(store, state, new Set([key])), nodeKey => nodeKey !== key)),\n        components: Recoil_mapIterable((_storeState$nodeToCom = (_storeState$nodeToCom2 = storeState.nodeToComponentSubscriptions.get(key)) === null || _storeState$nodeToCom2 === void 0 ? void 0 : _storeState$nodeToCom2.values()) !== null && _storeState$nodeToCom !== void 0 ? _storeState$nodeToCom : [], ([name]) => ({\n          name\n        }))\n      };\n    }\n  });\n} // Find all of the recursively dependent nodes\n\n\nfunction getDownstreamNodes(store, state, keys) {\n  const visitedNodes = new Set();\n  const visitingNodes = Array.from(keys);\n  const graph = store.getGraph(state.version);\n\n  for (let key = visitingNodes.pop(); key; key = visitingNodes.pop()) {\n    var _graph$nodeToNodeSubs;\n\n    visitedNodes.add(key);\n    const subscribedNodes = (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(key)) !== null && _graph$nodeToNodeSubs !== void 0 ? _graph$nodeToNodeSubs : emptySet;\n\n    for (const downstreamNode of subscribedNodes) {\n      if (!visitedNodes.has(downstreamNode)) {\n        visitingNodes.push(downstreamNode);\n      }\n    }\n  }\n\n  return visitedNodes;\n}\n\nvar Recoil_FunctionalCore = {\n  getNodeLoadable,\n  peekNodeLoadable,\n  setNodeValue,\n  initializeNode,\n  cleanUpNode,\n  setUnvalidatedAtomValue_DEPRECATED,\n  peekNodeInfo,\n  getDownstreamNodes\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nlet _invalidateMemoizedSnapshot = null;\n\nfunction setInvalidateMemoizedSnapshot(invalidate) {\n  _invalidateMemoizedSnapshot = invalidate;\n}\n\nfunction invalidateMemoizedSnapshot() {\n  var _invalidateMemoizedSn;\n\n  (_invalidateMemoizedSn = _invalidateMemoizedSnapshot) === null || _invalidateMemoizedSn === void 0 ? void 0 : _invalidateMemoizedSn();\n}\n\nvar Recoil_SnapshotCache = {\n  setInvalidateMemoizedSnapshot,\n  invalidateMemoizedSnapshot\n};\nconst {\n  getDownstreamNodes: getDownstreamNodes$1,\n  getNodeLoadable: getNodeLoadable$1,\n  setNodeValue: setNodeValue$1\n} = Recoil_FunctionalCore;\nconst {\n  getNextComponentID: getNextComponentID$1\n} = Recoil_Keys;\nconst {\n  getNode: getNode$2,\n  getNodeMaybe: getNodeMaybe$2\n} = Recoil_Node;\nconst {\n  DefaultValue: DefaultValue$1\n} = Recoil_Node;\nconst {\n  reactMode: reactMode$1\n} = Recoil_ReactMode;\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$1,\n  RecoilState: RecoilState$1,\n  RecoilValueReadOnly: RecoilValueReadOnly$1,\n  isRecoilValue: isRecoilValue$1\n} = Recoil_RecoilValue$1;\nconst {\n  invalidateMemoizedSnapshot: invalidateMemoizedSnapshot$1\n} = Recoil_SnapshotCache;\n\nfunction getRecoilValueAsLoadable(store, {\n  key\n}, treeState = store.getState().currentTree) {\n  var _storeState$nextTree, _storeState$previousT; // Reading from an older tree can cause bugs because the dependencies that we\n  // discover during the read are lost.\n\n\n  const storeState = store.getState();\n\n  if (!(treeState.version === storeState.currentTree.version || treeState.version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || treeState.version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {\n    Recoil_recoverableViolation('Tried to read from a discarded tree');\n  }\n\n  const loadable = getNodeLoadable$1(store, treeState, key);\n\n  if (loadable.state === 'loading') {\n    loadable.contents.catch(() => {\n      /**\n       * HACK: intercept thrown error here to prevent an uncaught promise exception. Ideally this would happen closer to selector\n       * execution (perhaps introducing a new ERROR class to be resolved by async selectors that are in an error state)\n       */\n      return;\n    });\n  }\n\n  return loadable;\n}\n\nfunction applyAtomValueWrites(atomValues, writes) {\n  const result = atomValues.clone();\n  writes.forEach((v, k) => {\n    if (v.state === 'hasValue' && v.contents instanceof DefaultValue$1) {\n      result.delete(k);\n    } else {\n      result.set(k, v);\n    }\n  });\n  return result;\n}\n\nfunction valueFromValueOrUpdater(store, state, {\n  key\n}, valueOrUpdater) {\n  if (typeof valueOrUpdater === 'function') {\n    // Updater form: pass in the current value. Throw if the current value\n    // is unavailable (namely when updating an async selector that's\n    // pending or errored):\n    const current = getNodeLoadable$1(store, state, key);\n\n    if (current.state === 'loading') {\n      const msg = `Tried to set atom or selector \"${key}\" using an updater function while the current state is pending, this is not currently supported.`;\n      Recoil_recoverableViolation(msg);\n      throw Recoil_err(msg);\n    } else if (current.state === 'hasError') {\n      throw current.contents;\n    } // T itself may be a function, so our refinement is not sufficient:\n\n\n    return valueOrUpdater(current.contents); // flowlint-line unclear-type:off\n  } else {\n    return valueOrUpdater;\n  }\n}\n\nfunction applyAction(store, state, action) {\n  if (action.type === 'set') {\n    const {\n      recoilValue,\n      valueOrUpdater\n    } = action;\n    const newValue = valueFromValueOrUpdater(store, state, recoilValue, valueOrUpdater);\n    const writes = setNodeValue$1(store, state, recoilValue.key, newValue);\n\n    for (const [key, loadable] of writes.entries()) {\n      writeLoadableToTreeState(state, key, loadable);\n    }\n  } else if (action.type === 'setLoadable') {\n    const {\n      recoilValue: {\n        key\n      },\n      loadable\n    } = action;\n    writeLoadableToTreeState(state, key, loadable);\n  } else if (action.type === 'markModified') {\n    const {\n      recoilValue: {\n        key\n      }\n    } = action;\n    state.dirtyAtoms.add(key);\n  } else if (action.type === 'setUnvalidated') {\n    var _node$invalidate; // Write value directly to state bypassing the Node interface as the node\n    // definitions may not have been loaded yet when processing the initial snapshot.\n\n\n    const {\n      recoilValue: {\n        key\n      },\n      unvalidatedValue\n    } = action;\n    const node = getNodeMaybe$2(key);\n    node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);\n    state.atomValues.delete(key);\n    state.nonvalidatedAtoms.set(key, unvalidatedValue);\n    state.dirtyAtoms.add(key);\n  } else {\n    Recoil_recoverableViolation(`Unknown action ${action.type}`);\n  }\n}\n\nfunction writeLoadableToTreeState(state, key, loadable) {\n  if (loadable.state === 'hasValue' && loadable.contents instanceof DefaultValue$1) {\n    state.atomValues.delete(key);\n  } else {\n    state.atomValues.set(key, loadable);\n  }\n\n  state.dirtyAtoms.add(key);\n  state.nonvalidatedAtoms.delete(key);\n}\n\nfunction applyActionsToStore(store, actions) {\n  store.replaceState(state => {\n    const newState = copyTreeState(state);\n\n    for (const action of actions) {\n      applyAction(store, newState, action);\n    }\n\n    invalidateDownstreams(store, newState);\n    invalidateMemoizedSnapshot$1();\n    return newState;\n  });\n}\n\nfunction queueOrPerformStateUpdate(store, action) {\n  if (batchStack.length) {\n    const actionsByStore = batchStack[batchStack.length - 1];\n    let actions = actionsByStore.get(store);\n\n    if (!actions) {\n      actionsByStore.set(store, actions = []);\n    }\n\n    actions.push(action);\n  } else {\n    applyActionsToStore(store, [action]);\n  }\n}\n\nconst batchStack = [];\n\nfunction batchStart() {\n  const actionsByStore = new Map();\n  batchStack.push(actionsByStore);\n  return () => {\n    for (const [store, actions] of actionsByStore) {\n      applyActionsToStore(store, actions);\n    }\n\n    const popped = batchStack.pop();\n\n    if (popped !== actionsByStore) {\n      Recoil_recoverableViolation('Incorrect order of batch popping');\n    }\n  };\n}\n\nfunction copyTreeState(state) {\n  return { ...state,\n    atomValues: state.atomValues.clone(),\n    nonvalidatedAtoms: state.nonvalidatedAtoms.clone(),\n    dirtyAtoms: new Set(state.dirtyAtoms)\n  };\n}\n\nfunction invalidateDownstreams(store, state) {\n  // Inform any nodes that were changed or downstream of changes so that they\n  // can clear out any caches as needed due to the update:\n  const downstreams = getDownstreamNodes$1(store, state, state.dirtyAtoms);\n\n  for (const key of downstreams) {\n    var _getNodeMaybe, _getNodeMaybe$invalid;\n\n    (_getNodeMaybe = getNodeMaybe$2(key)) === null || _getNodeMaybe === void 0 ? void 0 : (_getNodeMaybe$invalid = _getNodeMaybe.invalidate) === null || _getNodeMaybe$invalid === void 0 ? void 0 : _getNodeMaybe$invalid.call(_getNodeMaybe, state);\n  }\n}\n\nfunction setRecoilValue(store, recoilValue, valueOrUpdater) {\n  queueOrPerformStateUpdate(store, {\n    type: 'set',\n    recoilValue,\n    valueOrUpdater\n  });\n}\n\nfunction setRecoilValueLoadable(store, recoilValue, loadable) {\n  if (loadable instanceof DefaultValue$1) {\n    return setRecoilValue(store, recoilValue, loadable);\n  }\n\n  queueOrPerformStateUpdate(store, {\n    type: 'setLoadable',\n    recoilValue,\n    loadable: loadable\n  });\n}\n\nfunction markRecoilValueModified(store, recoilValue) {\n  queueOrPerformStateUpdate(store, {\n    type: 'markModified',\n    recoilValue\n  });\n}\n\nfunction setUnvalidatedRecoilValue(store, recoilValue, unvalidatedValue) {\n  queueOrPerformStateUpdate(store, {\n    type: 'setUnvalidated',\n    recoilValue,\n    unvalidatedValue\n  });\n}\n\nfunction subscribeToRecoilValue(store, {\n  key\n}, callback, componentDebugName = null) {\n  const subID = getNextComponentID$1();\n  const storeState = store.getState();\n\n  if (!storeState.nodeToComponentSubscriptions.has(key)) {\n    storeState.nodeToComponentSubscriptions.set(key, new Map());\n  }\n\n  Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID, [componentDebugName !== null && componentDebugName !== void 0 ? componentDebugName : '<not captured>', callback]); // Handle the case that, during the same tick that we are subscribing, an atom\n  // has been updated by some effect handler. Otherwise we will miss the update.\n\n  const mode = reactMode$1();\n\n  if (mode.early && (mode.mode === 'LEGACY' || mode.mode === 'MUTABLE_SOURCE')) {\n    const nextTree = store.getState().nextTree;\n\n    if (nextTree && nextTree.dirtyAtoms.has(key)) {\n      callback(nextTree);\n    }\n  }\n\n  return {\n    release: () => {\n      const releaseStoreState = store.getState();\n      const subs = releaseStoreState.nodeToComponentSubscriptions.get(key);\n\n      if (subs === undefined || !subs.has(subID)) {\n        Recoil_recoverableViolation(`Subscription missing at release time for atom ${key}. This is a bug in Recoil.`);\n        return;\n      }\n\n      subs.delete(subID);\n\n      if (subs.size === 0) {\n        releaseStoreState.nodeToComponentSubscriptions.delete(key);\n      }\n    }\n  };\n}\n\nfunction refreshRecoilValue(store, recoilValue) {\n  var _node$clearCache;\n\n  const {\n    currentTree\n  } = store.getState();\n  const node = getNode$2(recoilValue.key);\n  (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, currentTree);\n}\n\nvar Recoil_RecoilValueInterface = {\n  RecoilValueReadOnly: RecoilValueReadOnly$1,\n  AbstractRecoilValue: AbstractRecoilValue$1,\n  RecoilState: RecoilState$1,\n  getRecoilValueAsLoadable,\n  setRecoilValue,\n  setRecoilValueLoadable,\n  markRecoilValueModified,\n  setUnvalidatedRecoilValue,\n  subscribeToRecoilValue,\n  isRecoilValue: isRecoilValue$1,\n  applyAtomValueWrites,\n  // TODO Remove export when deprecating initialStoreState_DEPRECATED in RecoilRoot\n  batchStart,\n  writeLoadableToTreeState,\n  invalidateDownstreams,\n  copyTreeState,\n  refreshRecoilValue\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * The someSet() method tests whether some elements in the given Set pass the\n * test implemented by the provided function.\n */\n\nfunction someSet(set, callback, context) {\n  const iterator = set.entries();\n  let current = iterator.next();\n\n  while (!current.done) {\n    const entry = current.value;\n\n    if (callback.call(context, entry[1], entry[0], set)) {\n      return true;\n    }\n\n    current = iterator.next();\n  }\n\n  return false;\n}\n\nvar Recoil_someSet = someSet;\nconst {\n  cleanUpNode: cleanUpNode$1\n} = Recoil_FunctionalCore;\nconst {\n  deleteNodeConfigIfPossible: deleteNodeConfigIfPossible$1,\n  getNode: getNode$3\n} = Recoil_Node;\nconst {\n  RetentionZone: RetentionZone$2\n} = Recoil_RetentionZone; // Components that aren't mounted after suspending for this long will be assumed\n// to be discarded and their resources released.\n\nconst SUSPENSE_TIMEOUT_MS = 120000;\nconst emptySet$1 = new Set();\n\nfunction releaseRetainablesNowOnCurrentTree(store, retainables) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree;\n\n  if (storeState.nextTree) {\n    Recoil_recoverableViolation('releaseNodesNowOnCurrentTree should only be called at the end of a batch');\n    return; // leak memory rather than erase something that's about to be used.\n  }\n\n  const nodes = new Set();\n\n  for (const r of retainables) {\n    if (r instanceof RetentionZone$2) {\n      for (const n of nodesRetainedByZone(storeState, r)) {\n        nodes.add(n);\n      }\n    } else {\n      nodes.add(r);\n    }\n  }\n\n  const releasableNodes = findReleasableNodes(store, nodes);\n\n  for (const node of releasableNodes) {\n    releaseNode(store, treeState, node);\n  }\n}\n\nfunction findReleasableNodes(store, searchFromNodes) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree;\n  const graph = store.getGraph(treeState.version);\n  const releasableNodes = new Set(); // mutated to collect answer\n\n  const nonReleasableNodes = new Set();\n  findReleasableNodesInner(searchFromNodes);\n  return releasableNodes;\n\n  function findReleasableNodesInner(searchFromNodes) {\n    const releasableNodesFoundThisIteration = new Set();\n    const downstreams = getDownstreamNodesInTopologicalOrder(store, treeState, searchFromNodes, releasableNodes, // don't descend into these\n    nonReleasableNodes // don't descend into these\n    ); // Find which of the downstream nodes are releasable and which are not:\n\n    for (const node of downstreams) {\n      var _storeState$retention; // Not releasable if configured to be retained forever:\n\n\n      if (getNode$3(node).retainedBy === 'recoilRoot') {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if retained directly by a component:\n\n\n      if (((_storeState$retention = storeState.retention.referenceCounts.get(node)) !== null && _storeState$retention !== void 0 ? _storeState$retention : 0) > 0) {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if retained by a zone:\n\n\n      if (zonesThatCouldRetainNode(node).some(z => storeState.retention.referenceCounts.get(z))) {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if it has a non-releasable child (which will already be in\n      // nonReleasableNodes because we are going in topological order):\n\n\n      const nodeChildren = graph.nodeToNodeSubscriptions.get(node);\n\n      if (nodeChildren && Recoil_someSet(nodeChildren, child => nonReleasableNodes.has(child))) {\n        nonReleasableNodes.add(node);\n        continue;\n      }\n\n      releasableNodes.add(node);\n      releasableNodesFoundThisIteration.add(node);\n    } // If we found any releasable nodes, we need to walk UP from those nodes to\n    // find whether their parents can now be released as well:\n\n\n    const parents = new Set();\n\n    for (const node of releasableNodesFoundThisIteration) {\n      for (const parent of (_graph$nodeDeps$get = graph.nodeDeps.get(node)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : emptySet$1) {\n        var _graph$nodeDeps$get;\n\n        if (!releasableNodes.has(parent)) {\n          parents.add(parent);\n        }\n      }\n    }\n\n    if (parents.size) {\n      findReleasableNodesInner(parents);\n    }\n  }\n} // Children before parents\n\n\nfunction getDownstreamNodesInTopologicalOrder(store, treeState, nodes, // Mutable set is destroyed in place\ndoNotDescendInto1, doNotDescendInto2) {\n  const graph = store.getGraph(treeState.version);\n  const answer = [];\n  const visited = new Set();\n\n  while (nodes.size > 0) {\n    visit(Recoil_nullthrows(nodes.values().next().value));\n  }\n\n  return answer;\n\n  function visit(node) {\n    if (doNotDescendInto1.has(node) || doNotDescendInto2.has(node)) {\n      nodes.delete(node);\n      return;\n    }\n\n    if (visited.has(node)) {\n      return;\n    }\n\n    const children = graph.nodeToNodeSubscriptions.get(node);\n\n    if (children) {\n      for (const child of children) {\n        visit(child);\n      }\n    }\n\n    visited.add(node);\n    nodes.delete(node);\n    answer.push(node);\n  }\n}\n\nfunction releaseNode(store, treeState, node) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  } // Atom effects, in-closure caches, etc.:\n\n\n  cleanUpNode$1(store, node); // Delete from store state:\n\n  const storeState = store.getState();\n  storeState.knownAtoms.delete(node);\n  storeState.knownSelectors.delete(node);\n  storeState.nodeTransactionSubscriptions.delete(node);\n  storeState.retention.referenceCounts.delete(node);\n  const zones = zonesThatCouldRetainNode(node);\n\n  for (const zone of zones) {\n    var _storeState$retention2;\n\n    (_storeState$retention2 = storeState.retention.nodesRetainedByZone.get(zone)) === null || _storeState$retention2 === void 0 ? void 0 : _storeState$retention2.delete(node);\n  } // Note that we DO NOT delete from nodeToComponentSubscriptions because this\n  // already happens when the last component that was retaining the node unmounts,\n  // and this could happen either before or after that.\n  // Delete from TreeState and dep graph:\n\n\n  treeState.atomValues.delete(node);\n  treeState.dirtyAtoms.delete(node);\n  treeState.nonvalidatedAtoms.delete(node);\n  const graph = storeState.graphsByVersion.get(treeState.version);\n\n  if (graph) {\n    const deps = graph.nodeDeps.get(node);\n\n    if (deps !== undefined) {\n      graph.nodeDeps.delete(node);\n\n      for (const dep of deps) {\n        var _graph$nodeToNodeSubs;\n\n        (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(dep)) === null || _graph$nodeToNodeSubs === void 0 ? void 0 : _graph$nodeToNodeSubs.delete(node);\n      }\n    } // No need to delete sub's deps as there should be no subs at this point.\n    // But an invariant would require deleting nodes in topological order.\n\n\n    graph.nodeToNodeSubscriptions.delete(node);\n  } // Node config (for family members only as their configs can be recreated, and\n  // only if they are not retained within any other Stores):\n\n\n  deleteNodeConfigIfPossible$1(node);\n}\n\nfunction nodesRetainedByZone(storeState, zone) {\n  var _storeState$retention3;\n\n  return (_storeState$retention3 = storeState.retention.nodesRetainedByZone.get(zone)) !== null && _storeState$retention3 !== void 0 ? _storeState$retention3 : emptySet$1;\n}\n\nfunction zonesThatCouldRetainNode(node) {\n  const retainedBy = getNode$3(node).retainedBy;\n\n  if (retainedBy === undefined || retainedBy === 'components' || retainedBy === 'recoilRoot') {\n    return [];\n  } else if (retainedBy instanceof RetentionZone$2) {\n    return [retainedBy];\n  } else {\n    return retainedBy; // it's an array of zones\n  }\n}\n\nfunction scheduleOrPerformPossibleReleaseOfRetainable(store, retainable) {\n  const state = store.getState();\n\n  if (state.nextTree) {\n    state.retention.retainablesToCheckForRelease.add(retainable);\n  } else {\n    releaseRetainablesNowOnCurrentTree(store, new Set([retainable]));\n  }\n}\n\nfunction updateRetainCount(store, retainable, delta) {\n  var _map$get;\n\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const map = store.getState().retention.referenceCounts;\n  const newCount = ((_map$get = map.get(retainable)) !== null && _map$get !== void 0 ? _map$get : 0) + delta;\n\n  if (newCount === 0) {\n    updateRetainCountToZero(store, retainable);\n  } else {\n    map.set(retainable, newCount);\n  }\n}\n\nfunction updateRetainCountToZero(store, retainable) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const map = store.getState().retention.referenceCounts;\n  map.delete(retainable);\n  scheduleOrPerformPossibleReleaseOfRetainable(store, retainable);\n}\n\nfunction releaseScheduledRetainablesNow(store) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const state = store.getState();\n  releaseRetainablesNowOnCurrentTree(store, state.retention.retainablesToCheckForRelease);\n  state.retention.retainablesToCheckForRelease.clear();\n}\n\nfunction retainedByOptionWithDefault(r) {\n  // The default will change from 'recoilRoot' to 'components' in the future.\n  return r === undefined ? 'recoilRoot' : r;\n}\n\nvar Recoil_Retention = {\n  SUSPENSE_TIMEOUT_MS,\n  updateRetainCount,\n  updateRetainCountToZero,\n  releaseScheduledRetainablesNow,\n  retainedByOptionWithDefault\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is to export esstiential functions from react-dom\n * for our web build\n *\n * \n * @format\n * @oncall recoil\n */\n\nconst {\n  unstable_batchedUpdates\n} = (react_dom__WEBPACK_IMPORTED_MODULE_1___default());\nvar ReactBatchedUpdates = {\n  unstable_batchedUpdates\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is to export esstiential functions from react-dom\n * for our web build\n *\n * \n * @format\n * @oncall recoil\n */\n// @fb-only: const {unstable_batchedUpdates} = require('ReactDOMComet');\n// prettier-ignore\n\nconst {\n  unstable_batchedUpdates: unstable_batchedUpdates$1\n} = ReactBatchedUpdates; // @oss-only\n\nvar Recoil_ReactBatchedUpdates = {\n  unstable_batchedUpdates: unstable_batchedUpdates$1\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nconst {\n  batchStart: batchStart$1\n} = Recoil_RecoilValueInterface;\nconst {\n  unstable_batchedUpdates: unstable_batchedUpdates$2\n} = Recoil_ReactBatchedUpdates;\nlet batcher = unstable_batchedUpdates$2; // flowlint-next-line unclear-type:off\n\n/**\n * Sets the provided batcher function as the batcher function used by Recoil.\n *\n * Set the batcher to a custom batcher for your renderer,\n * if you use a renderer other than React DOM or React Native.\n */\n\nconst setBatcher = newBatcher => {\n  batcher = newBatcher;\n};\n/**\n * Returns the current batcher function.\n */\n\n\nconst getBatcher = () => batcher;\n/**\n * Calls the current batcher function and passes the\n * provided callback function.\n */\n\n\nconst batchUpdates = callback => {\n  batcher(() => {\n    let batchEnd = () => undefined;\n\n    try {\n      batchEnd = batchStart$1();\n      callback();\n    } finally {\n      batchEnd();\n    }\n  });\n};\n\nvar Recoil_Batching = {\n  getBatcher,\n  setBatcher,\n  batchUpdates\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Combines multiple Iterables into a single Iterable.\n * Traverses the input Iterables in the order provided and maintains the order\n * of their elements.\n *\n * Example:\n * ```\n * const r = Array.from(concatIterables(['a', 'b'], ['c'], ['d', 'e', 'f']));\n * r == ['a', 'b', 'c', 'd', 'e', 'f'];\n * ```\n */\n\nfunction* concatIterables(iters) {\n  for (const iter of iters) {\n    for (const val of iter) {\n      yield val;\n    }\n  }\n}\n\nvar Recoil_concatIterables = concatIterables;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/* eslint-disable fb-www/typeof-undefined */\n\nconst isSSR = // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709\ntypeof Window === 'undefined' || typeof window === 'undefined';\n/* eslint-enable fb-www/typeof-undefined */\n\nconst isWindow = value => !isSSR && ( // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709\nvalue === window || value instanceof Window);\n\nconst isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative'; // eslint-disable-line fb-www/typeof-undefined\n\nvar Recoil_Environment = {\n  isSSR,\n  isReactNative,\n  isWindow\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Caches a function's results based on the key returned by the passed\n * hashFunction.\n */\n\nfunction memoizeWithArgsHash(fn, hashFunction) {\n  let cache;\n\n  const memoizedFn = (...args) => {\n    if (!cache) {\n      cache = {};\n    }\n\n    const key = hashFunction(...args);\n\n    if (!Object.hasOwnProperty.call(cache, key)) {\n      cache[key] = fn(...args);\n    }\n\n    return cache[key];\n  };\n\n  return memoizedFn;\n}\n/**\n * Caches a function's results based on a comparison of the arguments.\n * Only caches the last return of the function.\n * Defaults to reference equality\n */\n\n\nfunction memoizeOneWithArgsHash(fn, hashFunction) {\n  let lastKey;\n  let lastResult; // breaking cache when arguments change\n\n  const memoizedFn = (...args) => {\n    const key = hashFunction(...args);\n\n    if (lastKey === key) {\n      return lastResult;\n    }\n\n    lastKey = key;\n    lastResult = fn(...args);\n    return lastResult;\n  };\n\n  return memoizedFn;\n}\n/**\n * Caches a function's results based on a comparison of the arguments.\n * Only caches the last return of the function.\n * Defaults to reference equality\n */\n\n\nfunction memoizeOneWithArgsHashAndInvalidation(fn, hashFunction) {\n  let lastKey;\n  let lastResult; // breaking cache when arguments change\n\n  const memoizedFn = (...args) => {\n    const key = hashFunction(...args);\n\n    if (lastKey === key) {\n      return lastResult;\n    }\n\n    lastKey = key;\n    lastResult = fn(...args);\n    return lastResult;\n  };\n\n  const invalidate = () => {\n    lastKey = null;\n  };\n\n  return [memoizedFn, invalidate];\n}\n\nvar Recoil_Memoize = {\n  memoizeWithArgsHash,\n  memoizeOneWithArgsHash,\n  memoizeOneWithArgsHashAndInvalidation\n};\nconst {\n  batchUpdates: batchUpdates$1\n} = Recoil_Batching;\nconst {\n  initializeNode: initializeNode$1,\n  peekNodeInfo: peekNodeInfo$1\n} = Recoil_FunctionalCore;\nconst {\n  graph: graph$1\n} = Recoil_Graph;\nconst {\n  getNextStoreID: getNextStoreID$1\n} = Recoil_Keys;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$1,\n  recoilValues: recoilValues$1,\n  recoilValuesForKeys: recoilValuesForKeys$2\n} = Recoil_Node;\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$2,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$1,\n  setRecoilValue: setRecoilValue$1,\n  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$1\n} = Recoil_RecoilValueInterface;\nconst {\n  updateRetainCount: updateRetainCount$1\n} = Recoil_Retention;\nconst {\n  setInvalidateMemoizedSnapshot: setInvalidateMemoizedSnapshot$1\n} = Recoil_SnapshotCache;\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$2,\n  makeEmptyStoreState: makeEmptyStoreState$1\n} = Recoil_State;\nconst {\n  isSSR: isSSR$1\n} = Recoil_Environment;\nconst {\n  memoizeOneWithArgsHashAndInvalidation: memoizeOneWithArgsHashAndInvalidation$1\n} = Recoil_Memoize; // Opaque at this surface because it's part of the public API from here.\n\nconst retainWarning = `\nRecoil Snapshots only last for the duration of the callback they are provided to. To keep a Snapshot longer, do this:\n\n  const release = snapshot.retain();\n  try {\n    await doSomethingWithSnapshot(snapshot);\n  } finally {\n    release();\n  }\n\nThis is currently a DEV-only warning but will become a thrown exception in the next release of Recoil.\n`; // A \"Snapshot\" is \"read-only\" and captures a specific set of values of atoms.\n// However, the data-flow-graph and selector values may evolve as selector\n// evaluation functions are executed and async selectors resolve.\n\nclass Snapshot {\n  // eslint-disable-next-line fb-www/no-uninitialized-properties\n  constructor(storeState, parentStoreID) {\n    _defineProperty(this, \"_store\", void 0);\n\n    _defineProperty(this, \"_refCount\", 1);\n\n    _defineProperty(this, \"getLoadable\", recoilValue => {\n      this.checkRefCount_INTERNAL();\n      return getRecoilValueAsLoadable$1(this._store, recoilValue);\n    });\n\n    _defineProperty(this, \"getPromise\", recoilValue => {\n      this.checkRefCount_INTERNAL();\n      return this.getLoadable(recoilValue).toPromise();\n    });\n\n    _defineProperty(this, \"getNodes_UNSTABLE\", opt => {\n      this.checkRefCount_INTERNAL(); // TODO Deal with modified selectors\n\n      if ((opt === null || opt === void 0 ? void 0 : opt.isModified) === true) {\n        if ((opt === null || opt === void 0 ? void 0 : opt.isInitialized) === false) {\n          return [];\n        }\n\n        const state = this._store.getState().currentTree;\n\n        return recoilValuesForKeys$2(state.dirtyAtoms);\n      }\n\n      const knownAtoms = this._store.getState().knownAtoms;\n\n      const knownSelectors = this._store.getState().knownSelectors;\n\n      return (opt === null || opt === void 0 ? void 0 : opt.isInitialized) == null ? recoilValues$1.values() : opt.isInitialized === true ? recoilValuesForKeys$2(Recoil_concatIterables([knownAtoms, knownSelectors])) : Recoil_filterIterable(recoilValues$1.values(), ({\n        key\n      }) => !knownAtoms.has(key) && !knownSelectors.has(key));\n    });\n\n    _defineProperty(this, \"getInfo_UNSTABLE\", ({\n      key\n    }) => {\n      this.checkRefCount_INTERNAL();\n      return peekNodeInfo$1(this._store, this._store.getState().currentTree, key);\n    });\n\n    _defineProperty(this, \"map\", mapper => {\n      this.checkRefCount_INTERNAL();\n      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);\n      mapper(mutableSnapshot); // if removing batchUpdates from `set` add it here\n\n      return mutableSnapshot;\n    });\n\n    _defineProperty(this, \"asyncMap\", async mapper => {\n      this.checkRefCount_INTERNAL();\n      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);\n      mutableSnapshot.retain(); // Retain new snapshot during async mapper\n\n      await mapper(mutableSnapshot); // Continue to retain the new snapshot for the user, but auto-release it\n      // after the next tick, the same as a new synchronous snapshot.\n\n      mutableSnapshot.autoRelease_INTERNAL();\n      return mutableSnapshot;\n    });\n\n    this._store = {\n      storeID: getNextStoreID$1(),\n      parentStoreID,\n      getState: () => storeState,\n      replaceState: replacer => {\n        // no batching, so nextTree is never active\n        storeState.currentTree = replacer(storeState.currentTree);\n      },\n      getGraph: version => {\n        const graphs = storeState.graphsByVersion;\n\n        if (graphs.has(version)) {\n          return Recoil_nullthrows(graphs.get(version));\n        }\n\n        const newGraph = graph$1();\n        graphs.set(version, newGraph);\n        return newGraph;\n      },\n      subscribeToTransactions: () => ({\n        release: () => {}\n      }),\n      addTransactionMetadata: () => {\n        throw Recoil_err('Cannot subscribe to Snapshots');\n      }\n    }; // Initialize any nodes that are live in the parent store (primarily so that\n    // this snapshot gets counted towards the node's live stores count).\n    // TODO Optimize this when cloning snapshots for callbacks\n\n    for (const nodeKey of this._store.getState().knownAtoms) {\n      initializeNode$1(this._store, nodeKey, 'get');\n      updateRetainCount$1(this._store, nodeKey, 1);\n    }\n\n    this.autoRelease_INTERNAL();\n  }\n\n  retain() {\n    if (this._refCount <= 0) {\n      if (true) {\n        throw Recoil_err('Snapshot has already been released.');\n      } else {}\n    }\n\n    this._refCount++;\n    let released = false;\n    return () => {\n      if (!released) {\n        released = true;\n\n        this._release();\n      }\n    };\n  }\n  /**\n   * Release the snapshot on the next tick.  This means the snapshot is retained\n   * during the execution of the current function using it.\n   */\n\n\n  autoRelease_INTERNAL() {\n    if (!isSSR$1) {\n      // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936\n      window.setTimeout(() => this._release(), 10);\n    }\n  }\n\n  _release() {\n    this._refCount--;\n\n    if (this._refCount === 0) {\n      this._store.getState().nodeCleanupFunctions.forEach(cleanup => cleanup());\n\n      this._store.getState().nodeCleanupFunctions.clear();\n\n      if (!Recoil_gkx('recoil_memory_managament_2020')) {\n        return;\n      } // Temporarily nerfing this to allow us to find broken call sites without\n      // actually breaking anybody yet.\n      // for (const k of this._store.getState().knownAtoms) {\n      //   updateRetainCountToZero(this._store, k);\n      // }\n\n    } else if (this._refCount < 0) {\n      if (true) {\n        Recoil_recoverableViolation('Snapshot released an extra time.');\n      }\n    }\n  }\n\n  isRetained() {\n    return this._refCount > 0;\n  }\n\n  checkRefCount_INTERNAL() {\n    if (Recoil_gkx('recoil_memory_managament_2020') && this._refCount <= 0) {\n      if (true) {\n        Recoil_recoverableViolation(retainWarning);\n      } // What we will ship later:\n      // throw err(retainWarning);\n\n    }\n  }\n\n  getStore_INTERNAL() {\n    this.checkRefCount_INTERNAL();\n    return this._store;\n  }\n\n  getID() {\n    this.checkRefCount_INTERNAL();\n    return this._store.getState().currentTree.stateID;\n  }\n\n  getStoreID() {\n    this.checkRefCount_INTERNAL();\n    return this._store.storeID;\n  } // We want to allow the methods to be destructured and used as accessors\n\n  /* eslint-disable fb-www/extra-arrow-initializer */\n\n  /* eslint-enable fb-www/extra-arrow-initializer */\n\n\n}\n\nfunction cloneStoreState(store, treeState, bumpVersion = false) {\n  const storeState = store.getState();\n  const version = bumpVersion ? getNextTreeStateVersion$2() : treeState.version;\n  return {\n    // Always clone the TreeState to isolate stores from accidental mutations.\n    // For example, reading a selector from a cloned snapshot shouldn't cache\n    // in the original treestate which may cause the original to skip\n    // initialization of upstream atoms.\n    currentTree: {\n      // TODO snapshots shouldn't really have versions because a new version number\n      // is always assigned when the snapshot is gone to.\n      version: bumpVersion ? version : treeState.version,\n      stateID: bumpVersion ? version : treeState.stateID,\n      transactionMetadata: { ...treeState.transactionMetadata\n      },\n      dirtyAtoms: new Set(treeState.dirtyAtoms),\n      atomValues: treeState.atomValues.clone(),\n      nonvalidatedAtoms: treeState.nonvalidatedAtoms.clone()\n    },\n    commitDepth: 0,\n    nextTree: null,\n    previousTree: null,\n    knownAtoms: new Set(storeState.knownAtoms),\n    // FIXME here's a copy\n    knownSelectors: new Set(storeState.knownSelectors),\n    // FIXME here's a copy\n    transactionSubscriptions: new Map(),\n    nodeTransactionSubscriptions: new Map(),\n    nodeToComponentSubscriptions: new Map(),\n    queuedComponentCallbacks_DEPRECATED: [],\n    suspendedComponentResolvers: new Set(),\n    graphsByVersion: new Map().set(version, store.getGraph(treeState.version)),\n    retention: {\n      referenceCounts: new Map(),\n      nodesRetainedByZone: new Map(),\n      retainablesToCheckForRelease: new Set()\n    },\n    // FIXME here's a copy\n    // Create blank cleanup handlers for atoms so snapshots don't re-run\n    // atom effects.\n    nodeCleanupFunctions: new Map(Recoil_mapIterable(storeState.nodeCleanupFunctions.entries(), ([key]) => [key, () => {}]))\n  };\n} // Factory to build a fresh snapshot\n\n\nfunction freshSnapshot(initializeState) {\n  const snapshot = new Snapshot(makeEmptyStoreState$1());\n  return initializeState != null ? snapshot.map(initializeState) : snapshot;\n} // Factory to clone a snapshot state\n\n\nconst [memoizedCloneSnapshot, invalidateMemoizedSnapshot$2] = memoizeOneWithArgsHashAndInvalidation$1((store, version) => {\n  var _storeState$nextTree;\n\n  const storeState = store.getState();\n  const treeState = version === 'latest' ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : Recoil_nullthrows(storeState.previousTree);\n  return new Snapshot(cloneStoreState(store, treeState), store.storeID);\n}, (store, version) => {\n  var _store$getState$nextT, _store$getState$previ;\n\n  return String(version) + String(store.storeID) + String((_store$getState$nextT = store.getState().nextTree) === null || _store$getState$nextT === void 0 ? void 0 : _store$getState$nextT.version) + String(store.getState().currentTree.version) + String((_store$getState$previ = store.getState().previousTree) === null || _store$getState$previ === void 0 ? void 0 : _store$getState$previ.version);\n}); // Avoid circular dependencies\n\nsetInvalidateMemoizedSnapshot$1(invalidateMemoizedSnapshot$2);\n\nfunction cloneSnapshot(store, version = 'latest') {\n  const snapshot = memoizedCloneSnapshot(store, version);\n\n  if (!snapshot.isRetained()) {\n    invalidateMemoizedSnapshot$2();\n    return memoizedCloneSnapshot(store, version);\n  }\n\n  return snapshot;\n}\n\nclass MutableSnapshot extends Snapshot {\n  constructor(snapshot, batch) {\n    super(cloneStoreState(snapshot.getStore_INTERNAL(), snapshot.getStore_INTERNAL().getState().currentTree, true), snapshot.getStoreID());\n\n    _defineProperty(this, \"_batch\", void 0);\n\n    _defineProperty(this, \"set\", (recoilState, newValueOrUpdater) => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // This batchUpdates ensures this `set` is applied immediately and you can\n      // read the written value after calling `set`. I would like to remove this\n      // behavior and only batch in `Snapshot.map`, but this would be a breaking\n      // change potentially.\n\n      this._batch(() => {\n        updateRetainCount$1(store, recoilState.key, 1);\n        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, newValueOrUpdater);\n      });\n    });\n\n    _defineProperty(this, \"reset\", recoilState => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.\n\n      this._batch(() => {\n        updateRetainCount$1(store, recoilState.key, 1);\n        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, DEFAULT_VALUE$1);\n      });\n    });\n\n    _defineProperty(this, \"setUnvalidatedAtomValues_DEPRECATED\", values => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.\n\n      batchUpdates$1(() => {\n        for (const [k, v] of values.entries()) {\n          updateRetainCount$1(store, k, 1);\n          setUnvalidatedRecoilValue$1(store, new AbstractRecoilValue$2(k), v);\n        }\n      });\n    });\n\n    this._batch = batch;\n  }\n\n}\n\nvar Recoil_Snapshot = {\n  Snapshot,\n  MutableSnapshot,\n  freshSnapshot,\n  cloneSnapshot\n};\nvar Recoil_Snapshot_1 = Recoil_Snapshot.Snapshot;\nvar Recoil_Snapshot_2 = Recoil_Snapshot.MutableSnapshot;\nvar Recoil_Snapshot_3 = Recoil_Snapshot.freshSnapshot;\nvar Recoil_Snapshot_4 = Recoil_Snapshot.cloneSnapshot;\nvar Recoil_Snapshot$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Snapshot: Recoil_Snapshot_1,\n  MutableSnapshot: Recoil_Snapshot_2,\n  freshSnapshot: Recoil_Snapshot_3,\n  cloneSnapshot: Recoil_Snapshot_4\n});\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction unionSets(...sets) {\n  const result = new Set();\n\n  for (const set of sets) {\n    for (const value of set) {\n      result.add(value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_unionSets = unionSets;\nconst {\n  useRef\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n/**\n * The same as `useRef()` except that if a function is specified then it will\n * call that function to get the value to initialize the reference with.\n * This is similar to how `useState()` behaves when given a function.  It allows\n * the user to avoid generating the initial value for subsequent renders.\n * The tradeoff is that to set the reference to a function itself you need to\n * nest it: useRefInitOnce(() => () => {...});\n */\n\nfunction useRefInitOnce(initialValue) {\n  // $FlowExpectedError[incompatible-call]\n  const ref = useRef(initialValue);\n\n  if (ref.current === initialValue && typeof initialValue === 'function') {\n    // $FlowExpectedError[incompatible-use]\n    ref.current = initialValue();\n  }\n\n  return ref;\n}\n\nvar Recoil_useRefInitOnce = useRefInitOnce; // @fb-only: const RecoilusagelogEvent = require('RecoilusagelogEvent');\n// @fb-only: const RecoilUsageLogFalcoEvent = require('RecoilUsageLogFalcoEvent');\n// @fb-only: const URI = require('URI');\n\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$3,\n  makeEmptyStoreState: makeEmptyStoreState$2\n} = Recoil_State;\nconst {\n  cleanUpNode: cleanUpNode$2,\n  getDownstreamNodes: getDownstreamNodes$2,\n  initializeNode: initializeNode$2,\n  setNodeValue: setNodeValue$2,\n  setUnvalidatedAtomValue_DEPRECATED: setUnvalidatedAtomValue_DEPRECATED$1\n} = Recoil_FunctionalCore;\nconst {\n  graph: graph$2\n} = Recoil_Graph;\nconst {\n  cloneGraph: cloneGraph$1\n} = Recoil_Graph;\nconst {\n  getNextStoreID: getNextStoreID$2\n} = Recoil_Keys;\nconst {\n  createMutableSource: createMutableSource$1,\n  reactMode: reactMode$2\n} = Recoil_ReactMode;\nconst {\n  applyAtomValueWrites: applyAtomValueWrites$1\n} = Recoil_RecoilValueInterface;\nconst {\n  releaseScheduledRetainablesNow: releaseScheduledRetainablesNow$1\n} = Recoil_Retention;\nconst {\n  freshSnapshot: freshSnapshot$1\n} = Recoil_Snapshot$1;\nconst {\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef: useRef$1,\n  useState\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction notInAContext() {\n  throw Recoil_err('This component must be used inside a <RecoilRoot> component.');\n}\n\nconst defaultStore = Object.freeze({\n  storeID: getNextStoreID$2(),\n  getState: notInAContext,\n  replaceState: notInAContext,\n  getGraph: notInAContext,\n  subscribeToTransactions: notInAContext,\n  addTransactionMetadata: notInAContext\n});\nlet stateReplacerIsBeingExecuted = false;\n\nfunction startNextTreeIfNeeded(store) {\n  if (stateReplacerIsBeingExecuted) {\n    throw Recoil_err('An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.');\n  }\n\n  const storeState = store.getState();\n\n  if (storeState.nextTree === null) {\n    if (Recoil_gkx('recoil_memory_managament_2020') && Recoil_gkx('recoil_release_on_cascading_update_killswitch_2021')) {\n      // If this is a cascading update (that is, rendering due to one state change\n      // invokes a second state change), we won't have cleaned up retainables yet\n      // because this normally happens after notifying components. Do it before\n      // proceeding with the cascading update so that it remains predictable:\n      if (storeState.commitDepth > 0) {\n        releaseScheduledRetainablesNow$1(store);\n      }\n    }\n\n    const version = storeState.currentTree.version;\n    const nextVersion = getNextTreeStateVersion$3();\n    storeState.nextTree = { ...storeState.currentTree,\n      version: nextVersion,\n      stateID: nextVersion,\n      dirtyAtoms: new Set(),\n      transactionMetadata: {}\n    };\n    storeState.graphsByVersion.set(nextVersion, cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))));\n  }\n}\n\nconst AppContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext({\n  current: defaultStore\n});\n\nconst useStoreRef = () => useContext(AppContext); // $FlowExpectedError[incompatible-call]\n\n\nconst MutableSourceContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\n\nfunction useRecoilMutableSource() {\n  const mutableSource = useContext(MutableSourceContext);\n\n  if (mutableSource == null) {\n    Recoil_expectationViolation('Attempted to use a Recoil hook outside of a <RecoilRoot>. ' + '<RecoilRoot> must be an ancestor of any component that uses ' + 'Recoil hooks.');\n  }\n\n  return mutableSource;\n}\n\nfunction notifyComponents(store, storeState, treeState) {\n  const dependentNodes = getDownstreamNodes$2(store, treeState, treeState.dirtyAtoms);\n\n  for (const key of dependentNodes) {\n    const comps = storeState.nodeToComponentSubscriptions.get(key);\n\n    if (comps) {\n      for (const [_subID, [_debugName, callback]] of comps) {\n        callback(treeState);\n      }\n    }\n  }\n}\n\nfunction sendEndOfBatchNotifications(store) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree; // Inform transaction subscribers of the transaction:\n\n  const dirtyAtoms = treeState.dirtyAtoms;\n\n  if (dirtyAtoms.size) {\n    // Execute Node-specific subscribers before global subscribers\n    for (const [key, subscriptions] of storeState.nodeTransactionSubscriptions) {\n      if (dirtyAtoms.has(key)) {\n        for (const [_, subscription] of subscriptions) {\n          subscription(store);\n        }\n      }\n    }\n\n    for (const [_, subscription] of storeState.transactionSubscriptions) {\n      subscription(store);\n    }\n\n    if (!reactMode$2().early || storeState.suspendedComponentResolvers.size > 0) {\n      // Notifying components is needed to wake from suspense, even when using\n      // early rendering.\n      notifyComponents(store, storeState, treeState); // Wake all suspended components so the right one(s) can try to re-render.\n      // We need to wake up components not just when some asynchronous selector\n      // resolved, but also when changing synchronous values because this may cause\n      // a selector to change from asynchronous to synchronous, in which case there\n      // would be no follow-up asynchronous resolution to wake us up.\n      // TODO OPTIMIZATION Only wake up related downstream components\n\n      storeState.suspendedComponentResolvers.forEach(cb => cb());\n      storeState.suspendedComponentResolvers.clear();\n    }\n  } // Special behavior ONLY invoked by useInterface.\n  // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.\n\n\n  storeState.queuedComponentCallbacks_DEPRECATED.forEach(cb => cb(treeState));\n  storeState.queuedComponentCallbacks_DEPRECATED.splice(0, storeState.queuedComponentCallbacks_DEPRECATED.length);\n}\n\nfunction endBatch(store) {\n  const storeState = store.getState();\n  storeState.commitDepth++;\n\n  try {\n    const {\n      nextTree\n    } = storeState; // Ignore commits that are not because of Recoil transactions -- namely,\n    // because something above RecoilRoot re-rendered:\n\n    if (nextTree == null) {\n      return;\n    } // nextTree is now committed -- note that copying and reset occurs when\n    // a transaction begins, in startNextTreeIfNeeded:\n\n\n    storeState.previousTree = storeState.currentTree;\n    storeState.currentTree = nextTree;\n    storeState.nextTree = null;\n    sendEndOfBatchNotifications(store);\n\n    if (storeState.previousTree != null) {\n      storeState.graphsByVersion.delete(storeState.previousTree.version);\n    } else {\n      Recoil_recoverableViolation('Ended batch with no previous state, which is unexpected', 'recoil');\n    }\n\n    storeState.previousTree = null;\n\n    if (Recoil_gkx('recoil_memory_managament_2020')) {\n      // Only release retainables if there were no writes during the end of the\n      // batch.  This avoids releasing something we might be about to use.\n      if (nextTree == null) {\n        releaseScheduledRetainablesNow$1(store);\n      }\n    }\n  } finally {\n    storeState.commitDepth--;\n  }\n}\n/*\n * The purpose of the Batcher is to observe when React batches end so that\n * Recoil state changes can be batched. Whenever Recoil state changes, we call\n * setState on the batcher. Then we wait for that change to be committed, which\n * signifies the end of the batch. That's when we respond to the Recoil change.\n */\n\n\nfunction Batcher({\n  setNotifyBatcherOfChange\n}) {\n  const storeRef = useStoreRef();\n  const [, setState] = useState([]);\n  setNotifyBatcherOfChange(() => setState({}));\n  useEffect(() => {\n    setNotifyBatcherOfChange(() => setState({})); // If an asynchronous selector resolves after the Batcher is unmounted,\n    // notifyBatcherOfChange will still be called. An error gets thrown whenever\n    // setState is called after a component is already unmounted, so this sets\n    // notifyBatcherOfChange to be a no-op.\n\n    return () => {\n      setNotifyBatcherOfChange(() => {});\n    };\n  }, [setNotifyBatcherOfChange]);\n  useEffect(() => {\n    // enqueueExecution runs this function immediately; it is only used to\n    // manipulate the order of useEffects during tests, since React seems to\n    // call useEffect in an unpredictable order sometimes.\n    Recoil_Queue.enqueueExecution('Batcher', () => {\n      endBatch(storeRef.current);\n    });\n  });\n  return null;\n}\n\nif (true) {\n  if (typeof window !== 'undefined' && !window.$recoilDebugStates) {\n    window.$recoilDebugStates = [];\n  }\n} // When removing this deprecated function, remove stateBySettingRecoilValue\n// which will no longer be needed.\n\n\nfunction initialStoreState_DEPRECATED(store, initializeState) {\n  const initial = makeEmptyStoreState$2();\n  initializeState({\n    set: (atom, value) => {\n      const state = initial.currentTree;\n      const writes = setNodeValue$2(store, state, atom.key, value);\n      const writtenNodes = new Set(writes.keys());\n      const nonvalidatedAtoms = state.nonvalidatedAtoms.clone();\n\n      for (const n of writtenNodes) {\n        nonvalidatedAtoms.delete(n);\n      }\n\n      initial.currentTree = { ...state,\n        dirtyAtoms: Recoil_unionSets(state.dirtyAtoms, writtenNodes),\n        atomValues: applyAtomValueWrites$1(state.atomValues, writes),\n        // NB: PLEASE un-export applyAtomValueWrites when deleting this code\n        nonvalidatedAtoms\n      };\n    },\n    setUnvalidatedAtomValues: atomValues => {\n      // FIXME replace this with a mutative loop\n      atomValues.forEach((v, k) => {\n        initial.currentTree = setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree, k, v);\n      });\n    }\n  });\n  return initial;\n} // Initialize state snapshot for <RecoilRoot> for the initializeState prop.\n// Atom effect initialization takes precedence over this prop.\n// Any atom effects will be run before initialization, but then cleaned up,\n// they are then re-run when used as part of rendering.  These semantics are\n// compatible with React StrictMode where effects may be re-run multiple times\n// but state initialization only happens once the first time.\n\n\nfunction initialStoreState(initializeState) {\n  // Initialize a snapshot and get its store\n  const snapshot = freshSnapshot$1(initializeState);\n  const storeState = snapshot.getStore_INTERNAL().getState(); // Counteract the snapshot auto-release\n\n  snapshot.retain(); // Cleanup any effects run during initialization and clear the handlers so\n  // they will re-initialize if used during rendering.  This allows atom effect\n  // initialization to take precedence over initializeState and be compatible\n  // with StrictMode semantics.\n\n  storeState.nodeCleanupFunctions.forEach(cleanup => cleanup());\n  storeState.nodeCleanupFunctions.clear();\n  return storeState;\n}\n\nlet nextID = 0;\n\nfunction RecoilRoot_INTERNAL({\n  initializeState_DEPRECATED,\n  initializeState,\n  store_INTERNAL: storeProp,\n  // For use with React \"context bridging\"\n  children\n}) {\n  // prettier-ignore\n  // @fb-only: useEffect(() => {\n  // @fb-only: if (gkx('recoil_usage_logging')) {\n  // @fb-only: try {\n  // @fb-only: RecoilUsageLogFalcoEvent.log(() => ({\n  // @fb-only: type: RecoilusagelogEvent.RECOIL_ROOT_MOUNTED,\n  // @fb-only: path: URI.getRequestURI().getPath(),\n  // @fb-only: }));\n  // @fb-only: } catch {\n  // @fb-only: recoverableViolation(\n  // @fb-only: 'Error when logging Recoil Usage event',\n  // @fb-only: 'recoil',\n  // @fb-only: );\n  // @fb-only: }\n  // @fb-only: }\n  // @fb-only: }, []);\n  let storeStateRef; // eslint-disable-line prefer-const\n\n  const getGraph = version => {\n    const graphs = storeStateRef.current.graphsByVersion;\n\n    if (graphs.has(version)) {\n      return Recoil_nullthrows(graphs.get(version));\n    }\n\n    const newGraph = graph$2();\n    graphs.set(version, newGraph);\n    return newGraph;\n  };\n\n  const subscribeToTransactions = (callback, key) => {\n    if (key == null) {\n      // Global transaction subscriptions\n      const {\n        transactionSubscriptions\n      } = storeRef.current.getState();\n      const id = nextID++;\n      transactionSubscriptions.set(id, callback);\n      return {\n        release: () => {\n          transactionSubscriptions.delete(id);\n        }\n      };\n    } else {\n      // Node-specific transaction subscriptions:\n      const {\n        nodeTransactionSubscriptions\n      } = storeRef.current.getState();\n\n      if (!nodeTransactionSubscriptions.has(key)) {\n        nodeTransactionSubscriptions.set(key, new Map());\n      }\n\n      const id = nextID++;\n      Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id, callback);\n      return {\n        release: () => {\n          const subs = nodeTransactionSubscriptions.get(key);\n\n          if (subs) {\n            subs.delete(id);\n\n            if (subs.size === 0) {\n              nodeTransactionSubscriptions.delete(key);\n            }\n          }\n        }\n      };\n    }\n  };\n\n  const addTransactionMetadata = metadata => {\n    startNextTreeIfNeeded(storeRef.current);\n\n    for (const k of Object.keys(metadata)) {\n      Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k] = metadata[k];\n    }\n  };\n\n  const replaceState = replacer => {\n    startNextTreeIfNeeded(storeRef.current); // Use replacer to get the next state:\n\n    const nextTree = Recoil_nullthrows(storeStateRef.current.nextTree);\n    let replaced;\n\n    try {\n      stateReplacerIsBeingExecuted = true;\n      replaced = replacer(nextTree);\n    } finally {\n      stateReplacerIsBeingExecuted = false;\n    }\n\n    if (replaced === nextTree) {\n      return;\n    }\n\n    if (true) {\n      if (typeof window !== 'undefined') {\n        window.$recoilDebugStates.push(replaced); // TODO this shouldn't happen here because it's not batched\n      }\n    } // Save changes to nextTree and schedule a React update:\n\n\n    storeStateRef.current.nextTree = replaced;\n\n    if (reactMode$2().early) {\n      notifyComponents(storeRef.current, storeStateRef.current, replaced);\n    }\n\n    Recoil_nullthrows(notifyBatcherOfChange.current)();\n  };\n\n  const notifyBatcherOfChange = useRef$1(null);\n  const setNotifyBatcherOfChange = useCallback(x => {\n    notifyBatcherOfChange.current = x;\n  }, [notifyBatcherOfChange]);\n  const storeRef = Recoil_useRefInitOnce(() => storeProp !== null && storeProp !== void 0 ? storeProp : {\n    storeID: getNextStoreID$2(),\n    getState: () => storeStateRef.current,\n    replaceState,\n    getGraph,\n    subscribeToTransactions,\n    addTransactionMetadata\n  });\n\n  if (storeProp != null) {\n    storeRef.current = storeProp;\n  }\n\n  storeStateRef = Recoil_useRefInitOnce(() => initializeState_DEPRECATED != null ? initialStoreState_DEPRECATED(storeRef.current, initializeState_DEPRECATED) : initializeState != null ? initialStoreState(initializeState) : makeEmptyStoreState$2());\n  const mutableSource = useMemo(() => createMutableSource$1 === null || createMutableSource$1 === void 0 ? void 0 : createMutableSource$1(storeStateRef, () => storeStateRef.current.currentTree.version), [storeStateRef]); // Cleanup when the <RecoilRoot> is unmounted\n\n  useEffect(() => {\n    // React is free to call effect cleanup handlers and effects at will, the\n    // deps array is only an optimization.  For example, React strict mode\n    // will execute each effect twice for testing.  Therefore, we need symmetry\n    // to re-initialize all known atoms after they were cleaned up.\n    const store = storeRef.current;\n\n    for (const atomKey of new Set(store.getState().knownAtoms)) {\n      initializeNode$2(store, atomKey, 'get');\n    }\n\n    return () => {\n      for (const atomKey of store.getState().knownAtoms) {\n        cleanUpNode$2(store, atomKey);\n      }\n    };\n  }, [storeRef]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AppContext.Provider, {\n    value: storeRef\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MutableSourceContext.Provider, {\n    value: mutableSource\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Batcher, {\n    setNotifyBatcherOfChange: setNotifyBatcherOfChange\n  }), children));\n}\n\nfunction RecoilRoot(props) {\n  const {\n    override,\n    ...propsExceptOverride\n  } = props;\n  const ancestorStoreRef = useStoreRef();\n\n  if (override === false && ancestorStoreRef.current !== defaultStore) {\n    // If ancestorStoreRef.current !== defaultStore, it means that this\n    // RecoilRoot is not nested within another.\n    return props.children;\n  }\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RecoilRoot_INTERNAL, propsExceptOverride);\n}\n\nfunction useRecoilStoreID() {\n  return useStoreRef().current.storeID;\n}\n\nvar Recoil_RecoilRoot = {\n  RecoilRoot,\n  useStoreRef,\n  useRecoilMutableSource,\n  useRecoilStoreID,\n  notifyComponents_FOR_TESTING: notifyComponents,\n  sendEndOfBatchNotifications_FOR_TESTING: sendEndOfBatchNotifications\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction shallowArrayEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar Recoil_shallowArrayEqual = shallowArrayEqual;\nconst {\n  useEffect: useEffect$1,\n  useRef: useRef$2\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction usePrevious(value) {\n  const ref = useRef$2();\n  useEffect$1(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\nvar Recoil_usePrevious = usePrevious;\nconst {\n  useStoreRef: useStoreRef$1\n} = Recoil_RecoilRoot;\nconst {\n  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$1\n} = Recoil_Retention;\nconst {\n  updateRetainCount: updateRetainCount$2\n} = Recoil_Retention;\nconst {\n  RetentionZone: RetentionZone$3\n} = Recoil_RetentionZone;\nconst {\n  useEffect: useEffect$2,\n  useRef: useRef$3\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\nconst {\n  isSSR: isSSR$2\n} = Recoil_Environment; // I don't see a way to avoid the any type here because we want to accept readable\n// and writable values with any type parameter, but normally with writable ones\n// RecoilState<SomeT> is not a subtype of RecoilState<mixed>.\n// flowlint-line unclear-type:off\n\nfunction useRetain(toRetain) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  } // eslint-disable-next-line fb-www/react-hooks\n\n\n  return useRetain_ACTUAL(toRetain);\n}\n\nfunction useRetain_ACTUAL(toRetain) {\n  const array = Array.isArray(toRetain) ? toRetain : [toRetain];\n  const retainables = array.map(a => a instanceof RetentionZone$3 ? a : a.key);\n  const storeRef = useStoreRef$1();\n  useEffect$2(() => {\n    if (!Recoil_gkx('recoil_memory_managament_2020')) {\n      return;\n    }\n\n    const store = storeRef.current;\n\n    if (timeoutID.current && !isSSR$2) {\n      // Already performed a temporary retain on render, simply cancel the release\n      // of that temporary retain.\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n    } else {\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, 1);\n      }\n    }\n\n    return () => {\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }; // eslint-disable-next-line fb-www/react-hooks-deps\n  }, [storeRef, ...retainables]); // We want to retain if the component suspends. This is terrible but the Suspense\n  // API affords us no better option. If we suspend and never commit after some\n  // seconds, then release. The 'actual' retain/release in the effect above\n  // cancels this.\n\n  const timeoutID = useRef$3();\n  const previousRetainables = Recoil_usePrevious(retainables);\n\n  if (!isSSR$2 && (previousRetainables === undefined || !Recoil_shallowArrayEqual(previousRetainables, retainables))) {\n    const store = storeRef.current;\n\n    for (const r of retainables) {\n      updateRetainCount$2(store, r, 1);\n    }\n\n    if (previousRetainables) {\n      for (const r of previousRetainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }\n\n    if (timeoutID.current) {\n      window.clearTimeout(timeoutID.current);\n    }\n\n    timeoutID.current = window.setTimeout(() => {\n      timeoutID.current = null;\n\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }, SUSPENSE_TIMEOUT_MS$1);\n  }\n}\n\nvar Recoil_useRetain = useRetain;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * THIS CODE HAS BEEN COMMENTED OUT INTENTIONALLY\n *\n * This technique of getting the component name is imperfect, since it both only\n * works in a non-minified code base, and more importantly introduces performance\n * problems since it relies in throwing errors which is an expensive operation.\n *\n * At some point we may want to reevaluate this technique hence why we have commented\n * this code out, rather than delete it all together.\n */\n// const {useRef} = require('react');\n// const gkx = require('recoil-shared/util/Recoil_gkx');\n// const stackTraceParser = require('recoil-shared/util/Recoil_stackTraceParser');\n\nfunction useComponentName() {\n  // const nameRef = useRef();\n  // if (__DEV__) {\n  //   if (gkx('recoil_infer_component_names')) {\n  //     if (nameRef.current === undefined) {\n  //       // There is no blessed way to determine the calling React component from\n  //       // within a hook. This hack uses the fact that hooks must start with 'use'\n  //       // and that hooks are either called by React Components or other hooks. It\n  //       // follows therefore, that to find the calling component, you simply need\n  //       // to look down the stack and find the first function which doesn't start\n  //       // with 'use'. We are only enabling this in dev for now, since once the\n  //       // codebase is minified, the naming assumptions no longer hold true.\n  //       // eslint-disable-next-line fb-www/no-new-error\n  //       const frames = stackTraceParser(new Error().stack);\n  //       for (const {methodName} of frames) {\n  //         // I observed cases where the frame was of the form 'Object.useXXX'\n  //         // hence why I'm searching for hooks following a word boundary\n  //         if (!methodName.match(/\\buse[^\\b]+$/)) {\n  //           return (nameRef.current = methodName);\n  //         }\n  //       }\n  //       nameRef.current = null;\n  //     }\n  //     return nameRef.current ?? '<unable to determine component name>';\n  //   }\n  // }\n  // @fb-only: return \"<component name only available when both in dev mode and when passing GK 'recoil_infer_component_names'>\";\n  return '<component name not available>'; // @oss-only\n}\n\nvar Recoil_useComponentName = useComponentName;\nconst {\n  batchUpdates: batchUpdates$2\n} = Recoil_Batching;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$2\n} = Recoil_Node;\nconst {\n  reactMode: reactMode$3,\n  useMutableSource: useMutableSource$1,\n  useSyncExternalStore: useSyncExternalStore$1\n} = Recoil_ReactMode;\nconst {\n  useRecoilMutableSource: useRecoilMutableSource$1,\n  useStoreRef: useStoreRef$2\n} = Recoil_RecoilRoot;\nconst {\n  isRecoilValue: isRecoilValue$2\n} = Recoil_RecoilValue$1;\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$3,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$2,\n  setRecoilValue: setRecoilValue$2,\n  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$2,\n  subscribeToRecoilValue: subscribeToRecoilValue$1\n} = Recoil_RecoilValueInterface;\nconst {\n  useCallback: useCallback$1,\n  useEffect: useEffect$3,\n  useMemo: useMemo$1,\n  useRef: useRef$4,\n  useState: useState$1\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\nconst {\n  setByAddingToSet: setByAddingToSet$2\n} = Recoil_CopyOnWrite;\n\nfunction handleLoadable(loadable, recoilValue, storeRef) {\n  // We can't just throw the promise we are waiting on to Suspense.  If the\n  // upstream dependencies change it may produce a state in which the component\n  // can render, but it would still be suspended on a Promise that may never resolve.\n  if (loadable.state === 'hasValue') {\n    return loadable.contents;\n  } else if (loadable.state === 'loading') {\n    const promise = new Promise(resolve => {\n      storeRef.current.getState().suspendedComponentResolvers.add(resolve);\n    }); // $FlowExpectedError Flow(prop-missing) for integrating with tools that inspect thrown promises @fb-only\n    // @fb-only: promise.displayName = `Recoil State: ${recoilValue.key}`;\n\n    throw promise;\n  } else if (loadable.state === 'hasError') {\n    throw loadable.contents;\n  } else {\n    throw Recoil_err(`Invalid value of loadable atom \"${recoilValue.key}\"`);\n  }\n}\n\nfunction validateRecoilValue(recoilValue, hookName) {\n  if (!isRecoilValue$2(recoilValue)) {\n    throw Recoil_err(`Invalid argument to ${hookName}: expected an atom or selector but got ${String(recoilValue)}`);\n  }\n}\n/**\n * Various things are broken with useRecoilInterface, particularly concurrent\n * mode, React strict mode, and memory management. They will not be fixed.\n * */\n\n\nfunction useRecoilInterface_DEPRECATED() {\n  const componentName = Recoil_useComponentName();\n  const storeRef = useStoreRef$2();\n  const [, forceUpdate] = useState$1([]);\n  const recoilValuesUsed = useRef$4(new Set());\n  recoilValuesUsed.current = new Set(); // Track the RecoilValues used just during this render\n\n  const previousSubscriptions = useRef$4(new Set());\n  const subscriptions = useRef$4(new Map());\n  const unsubscribeFrom = useCallback$1(key => {\n    const sub = subscriptions.current.get(key);\n\n    if (sub) {\n      sub.release();\n      subscriptions.current.delete(key);\n    }\n  }, [subscriptions]);\n  const updateState = useCallback$1((_state, key) => {\n    if (subscriptions.current.has(key)) {\n      forceUpdate([]);\n    }\n  }, []); // Effect to add/remove subscriptions as nodes are used\n\n  useEffect$3(() => {\n    const store = storeRef.current;\n    Recoil_differenceSets(recoilValuesUsed.current, previousSubscriptions.current).forEach(key => {\n      if (subscriptions.current.has(key)) {\n        Recoil_expectationViolation(`Double subscription to RecoilValue \"${key}\"`);\n        return;\n      }\n\n      const sub = subscribeToRecoilValue$1(store, new AbstractRecoilValue$3(key), state => updateState(state, key), componentName);\n      subscriptions.current.set(key, sub);\n      /**\n       * Since we're subscribing in an effect we need to update to the latest\n       * value of the atom since it may have changed since we rendered. We can\n       * go ahead and do that now, unless we're in the middle of a batch --\n       * in which case we should do it at the end of the batch, due to the\n       * following edge case: Suppose an atom is updated in another useEffect\n       * of this same component. Then the following sequence of events occur:\n       * 1. Atom is updated and subs fired (but we may not be subscribed\n       *    yet depending on order of effects, so we miss this) Updated value\n       *    is now in nextTree, but not currentTree.\n       * 2. This effect happens. We subscribe and update.\n       * 3. From the update we re-render and read currentTree, with old value.\n       * 4. Batcher's effect sets currentTree to nextTree.\n       * In this sequence we miss the update. To avoid that, add the update\n       * to queuedComponentCallback if a batch is in progress.\n       */\n      // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.\n\n      const state = store.getState();\n\n      if (state.nextTree) {\n        store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {\n          updateState(store.getState(), key);\n        });\n      } else {\n        updateState(store.getState(), key);\n      }\n    });\n    Recoil_differenceSets(previousSubscriptions.current, recoilValuesUsed.current).forEach(key => {\n      unsubscribeFrom(key);\n    });\n    previousSubscriptions.current = recoilValuesUsed.current;\n  }); // Effect to unsubscribe from all when unmounting\n\n  useEffect$3(() => {\n    const currentSubscriptions = subscriptions.current; // Restore subscriptions that were cleared due to StrictMode running this effect twice\n\n    Recoil_differenceSets(recoilValuesUsed.current, new Set(currentSubscriptions.keys())).forEach(key => {\n      const sub = subscribeToRecoilValue$1(storeRef.current, new AbstractRecoilValue$3(key), state => updateState(state, key), componentName);\n      currentSubscriptions.set(key, sub);\n    });\n    return () => currentSubscriptions.forEach((_, key) => unsubscribeFrom(key));\n  }, [componentName, storeRef, unsubscribeFrom, updateState]);\n  return useMemo$1(() => {\n    // eslint-disable-next-line no-shadow\n    function useSetRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useSetRecoilState');\n      }\n\n      return newValueOrUpdater => {\n        setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);\n      };\n    } // eslint-disable-next-line no-shadow\n\n\n    function useResetRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useResetRecoilState');\n      }\n\n      return () => setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilValueLoadable(recoilValue) {\n      var _storeState$nextTree;\n\n      if (true) {\n        validateRecoilValue(recoilValue, 'useRecoilValueLoadable');\n      }\n\n      if (!recoilValuesUsed.current.has(recoilValue.key)) {\n        recoilValuesUsed.current = setByAddingToSet$2(recoilValuesUsed.current, recoilValue.key);\n      } // TODO Restore optimization to memoize lookup\n\n\n      const storeState = storeRef.current.getState();\n      return getRecoilValueAsLoadable$2(storeRef.current, recoilValue, reactMode$3().early ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : storeState.currentTree);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilValue(recoilValue) {\n      if (true) {\n        validateRecoilValue(recoilValue, 'useRecoilValue');\n      }\n\n      const loadable = useRecoilValueLoadable(recoilValue);\n      return handleLoadable(loadable, recoilValue, storeRef);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useRecoilState');\n      }\n\n      return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilStateLoadable(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useRecoilStateLoadable');\n      }\n\n      return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];\n    }\n\n    return {\n      getRecoilValue: useRecoilValue,\n      getRecoilValueLoadable: useRecoilValueLoadable,\n      getRecoilState: useRecoilState,\n      getRecoilStateLoadable: useRecoilStateLoadable,\n      getSetRecoilState: useSetRecoilState,\n      getResetRecoilState: useResetRecoilState\n    };\n  }, [recoilValuesUsed, storeRef]);\n}\n\nconst recoilComponentGetRecoilValueCount_FOR_TESTING = {\n  current: 0\n};\n\nfunction useRecoilValueLoadable_SYNC_EXTERNAL_STORE(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const componentName = Recoil_useComponentName();\n  const getSnapshot = useCallback$1(() => {\n    var _storeState$nextTree2;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree2 = storeState.nextTree) !== null && _storeState$nextTree2 !== void 0 ? _storeState$nextTree2 : storeState.currentTree : storeState.currentTree;\n    const loadable = getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n    return {\n      loadable,\n      key: recoilValue.key\n    };\n  }, [storeRef, recoilValue]); // Memoize the state to avoid unnecessary rerenders\n\n  const memoizePreviousSnapshot = useCallback$1(getState => {\n    let prevState;\n    return () => {\n      var _prevState, _prevState2;\n\n      const nextState = getState();\n\n      if ((_prevState = prevState) !== null && _prevState !== void 0 && _prevState.loadable.is(nextState.loadable) && ((_prevState2 = prevState) === null || _prevState2 === void 0 ? void 0 : _prevState2.key) === nextState.key) {\n        return prevState;\n      }\n\n      prevState = nextState;\n      return nextState;\n    };\n  }, []);\n  const getMemoizedSnapshot = useMemo$1(() => memoizePreviousSnapshot(getSnapshot), [getSnapshot, memoizePreviousSnapshot]);\n  const subscribe = useCallback$1(notify => {\n    const store = storeRef.current;\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, notify, componentName);\n    return subscription.release;\n  }, [storeRef, recoilValue, componentName]);\n  return useSyncExternalStore$1(subscribe, getMemoizedSnapshot, // getSnapshot()\n  getMemoizedSnapshot // getServerSnapshot() for SSR support\n  ).loadable;\n}\n\nfunction useRecoilValueLoadable_MUTABLE_SOURCE(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree3;\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree3 = storeState.nextTree) !== null && _storeState$nextTree3 !== void 0 ? _storeState$nextTree3 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const getLoadableWithTesting = useCallback$1(() => {\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    return getLoadable();\n  }, [getLoadable]);\n  const componentName = Recoil_useComponentName();\n  const subscribe = useCallback$1((_storeState, notify) => {\n    const store = storeRef.current;\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, () => {\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return notify();\n      } // Only re-render if the value has changed.\n      // This will evaluate the atom/selector now as well as when the\n      // component renders, but that may help with prefetching.\n\n\n      const newLoadable = getLoadable();\n\n      if (!prevLoadableRef.current.is(newLoadable)) {\n        notify();\n      } // If the component is suspended then the effect setting prevLoadableRef\n      // will not run.  So, set the previous value here when its subscription\n      // is fired to wake it up.  We can't just rely on this, though, because\n      // this only executes when an atom/selector is dirty and the atom/selector\n      // passed to the hook can dynamically change.\n\n\n      prevLoadableRef.current = newLoadable;\n    }, componentName);\n    return subscription.release;\n  }, [storeRef, recoilValue, componentName, getLoadable]);\n  const source = useRecoilMutableSource$1();\n\n  if (source == null) {\n    throw Recoil_err('Recoil hooks must be used in components contained within a <RecoilRoot> component.');\n  }\n\n  const loadable = useMutableSource$1(source, getLoadableWithTesting, subscribe);\n  const prevLoadableRef = useRef$4(loadable);\n  useEffect$3(() => {\n    prevLoadableRef.current = loadable;\n  });\n  return loadable;\n}\n\nfunction useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const componentName = Recoil_useComponentName(); // Accessors to get the current state\n\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree4;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree4 = storeState.nextTree) !== null && _storeState$nextTree4 !== void 0 ? _storeState$nextTree4 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const getState = useCallback$1(() => ({\n    loadable: getLoadable(),\n    key: recoilValue.key\n  }), [getLoadable, recoilValue.key]); // Memoize state snapshots\n\n  const updateState = useCallback$1(prevState => {\n    const nextState = getState();\n    return prevState.loadable.is(nextState.loadable) && prevState.key === nextState.key ? prevState : nextState;\n  }, [getState]); // Subscribe to Recoil state changes\n\n  useEffect$3(() => {\n    const subscription = subscribeToRecoilValue$1(storeRef.current, recoilValue, _state => {\n      setState(updateState);\n    }, componentName); // Update state in case we are using a different key\n\n    setState(updateState);\n    return subscription.release;\n  }, [componentName, recoilValue, storeRef, updateState]); // Get the current state\n\n  const [state, setState] = useState$1(getState); // If we changed keys, then return the state for the new key.\n  // This is important in case the old key would cause the component to suspend.\n  // We don't have to set the new state here since the subscribing effect above\n  // will do that.\n\n  return state.key !== recoilValue.key ? getState().loadable : state.loadable;\n}\n\nfunction useRecoilValueLoadable_LEGACY(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const [, forceUpdate] = useState$1([]);\n  const componentName = Recoil_useComponentName();\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree5;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree5 = storeState.nextTree) !== null && _storeState$nextTree5 !== void 0 ? _storeState$nextTree5 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const loadable = getLoadable();\n  const prevLoadableRef = useRef$4(loadable);\n  useEffect$3(() => {\n    prevLoadableRef.current = loadable;\n  });\n  useEffect$3(() => {\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, _state => {\n      var _prevLoadableRef$curr;\n\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return forceUpdate([]);\n      }\n\n      const newLoadable = getLoadable();\n\n      if (!((_prevLoadableRef$curr = prevLoadableRef.current) !== null && _prevLoadableRef$curr !== void 0 && _prevLoadableRef$curr.is(newLoadable))) {\n        forceUpdate(newLoadable);\n      }\n\n      prevLoadableRef.current = newLoadable;\n    }, componentName);\n    /**\n     * Since we're subscribing in an effect we need to update to the latest\n     * value of the atom since it may have changed since we rendered. We can\n     * go ahead and do that now, unless we're in the middle of a batch --\n     * in which case we should do it at the end of the batch, due to the\n     * following edge case: Suppose an atom is updated in another useEffect\n     * of this same component. Then the following sequence of events occur:\n     * 1. Atom is updated and subs fired (but we may not be subscribed\n     *    yet depending on order of effects, so we miss this) Updated value\n     *    is now in nextTree, but not currentTree.\n     * 2. This effect happens. We subscribe and update.\n     * 3. From the update we re-render and read currentTree, with old value.\n     * 4. Batcher's effect sets currentTree to nextTree.\n     * In this sequence we miss the update. To avoid that, add the update\n     * to queuedComponentCallback if a batch is in progress.\n     */\n\n    if (storeState.nextTree) {\n      store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {\n        prevLoadableRef.current = null;\n        forceUpdate([]);\n      });\n    } else {\n      var _prevLoadableRef$curr2;\n\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return forceUpdate([]);\n      }\n\n      const newLoadable = getLoadable();\n\n      if (!((_prevLoadableRef$curr2 = prevLoadableRef.current) !== null && _prevLoadableRef$curr2 !== void 0 && _prevLoadableRef$curr2.is(newLoadable))) {\n        forceUpdate(newLoadable);\n      }\n\n      prevLoadableRef.current = newLoadable;\n    }\n\n    return subscription.release;\n  }, [componentName, getLoadable, recoilValue, storeRef]);\n  return loadable;\n}\n/**\n  Like useRecoilValue(), but either returns the value if available or\n  just undefined if not available for any reason, such as pending or error.\n*/\n\n\nfunction useRecoilValueLoadable(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValueLoadable');\n  }\n\n  if (Recoil_gkx('recoil_memory_managament_2020')) {\n    // eslint-disable-next-line fb-www/react-hooks\n    Recoil_useRetain(recoilValue);\n  }\n\n  return {\n    TRANSITION_SUPPORT: useRecoilValueLoadable_TRANSITION_SUPPORT,\n    SYNC_EXTERNAL_STORE: useRecoilValueLoadable_SYNC_EXTERNAL_STORE,\n    MUTABLE_SOURCE: useRecoilValueLoadable_MUTABLE_SOURCE,\n    LEGACY: useRecoilValueLoadable_LEGACY\n  }[reactMode$3().mode](recoilValue);\n}\n/**\n  Returns the value represented by the RecoilValue.\n  If the value is pending, it will throw a Promise to suspend the component,\n  if the value is an error it will throw it for the nearest React error boundary.\n  This will also subscribe the component for any updates in the value.\n  */\n\n\nfunction useRecoilValue(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValue');\n  }\n\n  const storeRef = useStoreRef$2();\n  const loadable = useRecoilValueLoadable(recoilValue);\n  return handleLoadable(loadable, recoilValue, storeRef);\n}\n/**\n  Returns a function that allows the value of a RecoilState to be updated, but does\n  not subscribe the component to changes to that RecoilState.\n*/\n\n\nfunction useSetRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useSetRecoilState');\n  }\n\n  const storeRef = useStoreRef$2();\n  return useCallback$1(newValueOrUpdater => {\n    setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);\n  }, [storeRef, recoilState]);\n}\n/**\n  Returns a function that will reset the value of a RecoilState to its default\n*/\n\n\nfunction useResetRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useResetRecoilState');\n  }\n\n  const storeRef = useStoreRef$2();\n  return useCallback$1(() => {\n    setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n  }, [storeRef, recoilState]);\n}\n/**\n  Equivalent to useState(). Allows the value of the RecoilState to be read and written.\n  Subsequent updates to the RecoilState will cause the component to re-render. If the\n  RecoilState is pending, this will suspend the component and initiate the\n  retrieval of the value. If evaluating the RecoilState resulted in an error, this will\n  throw the error so that the nearest React error boundary can catch it.\n*/\n\n\nfunction useRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilState');\n  }\n\n  return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];\n}\n/**\n  Like useRecoilState(), but does not cause Suspense or React error handling. Returns\n  an object that indicates whether the RecoilState is available, pending, or\n  unavailable due to an error.\n*/\n\n\nfunction useRecoilStateLoadable(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilStateLoadable');\n  }\n\n  return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];\n}\n\nfunction useSetUnvalidatedAtomValues() {\n  const storeRef = useStoreRef$2();\n  return (values, transactionMetadata = {}) => {\n    batchUpdates$2(() => {\n      storeRef.current.addTransactionMetadata(transactionMetadata);\n      values.forEach((value, key) => setUnvalidatedRecoilValue$2(storeRef.current, new AbstractRecoilValue$3(key), value));\n    });\n  };\n}\n/**\n * Experimental variants of hooks with support for useTransition()\n */\n\n\nfunction useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE');\n\n    if (!reactMode$3().early) {\n      Recoil_recoverableViolation('Attepmt to use a hook with UNSTABLE_TRANSITION_SUPPORT in a rendering mode incompatible with concurrent rendering.  Try enabling the recoil_sync_external_store or recoil_transition_support GKs.');\n    }\n  }\n\n  if (Recoil_gkx('recoil_memory_managament_2020')) {\n    // eslint-disable-next-line fb-www/react-hooks\n    Recoil_useRetain(recoilValue);\n  }\n\n  return useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue);\n}\n\nfunction useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValue_TRANSITION_SUPPORT_UNSTABLE');\n  }\n\n  const storeRef = useStoreRef$2();\n  const loadable = useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue);\n  return handleLoadable(loadable, recoilValue, storeRef);\n}\n\nfunction useRecoilState_TRANSITION_SUPPORT_UNSTABLE(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilState_TRANSITION_SUPPORT_UNSTABLE');\n  }\n\n  return [useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilState), useSetRecoilState(recoilState)];\n}\n\nvar Recoil_Hooks = {\n  recoilComponentGetRecoilValueCount_FOR_TESTING,\n  useRecoilInterface: useRecoilInterface_DEPRECATED,\n  useRecoilState,\n  useRecoilStateLoadable,\n  useRecoilValue,\n  useRecoilValueLoadable,\n  useResetRecoilState,\n  useSetRecoilState,\n  useSetUnvalidatedAtomValues,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Returns a map containing all of the keys + values from the original map where\n * the given callback returned true.\n */\n\nfunction filterMap(map, callback) {\n  const result = new Map();\n\n  for (const [key, value] of map) {\n    if (callback(value, key)) {\n      result.set(key, value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_filterMap = filterMap;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n/**\n * Returns a set containing all of the values from the original set where\n * the given callback returned true.\n */\n\nfunction filterSet(set, callback) {\n  const result = new Set();\n\n  for (const value of set) {\n    if (callback(value)) {\n      result.add(value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_filterSet = filterSet;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction mergeMaps(...maps) {\n  const result = new Map();\n\n  for (let i = 0; i < maps.length; i++) {\n    const iterator = maps[i].keys();\n    let nextKey;\n\n    while (!(nextKey = iterator.next()).done) {\n      // $FlowIssue[incompatible-call] - map/iterator knows nothing about flow types\n      result.set(nextKey.value, maps[i].get(nextKey.value));\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_mergeMaps = mergeMaps;\nconst {\n  batchUpdates: batchUpdates$3\n} = Recoil_Batching;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$3,\n  getNode: getNode$4,\n  nodes: nodes$1\n} = Recoil_Node;\nconst {\n  useStoreRef: useStoreRef$3\n} = Recoil_RecoilRoot;\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$4,\n  setRecoilValueLoadable: setRecoilValueLoadable$1\n} = Recoil_RecoilValueInterface;\nconst {\n  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$2\n} = Recoil_Retention;\nconst {\n  cloneSnapshot: cloneSnapshot$1\n} = Recoil_Snapshot$1;\nconst {\n  useCallback: useCallback$2,\n  useEffect: useEffect$4,\n  useRef: useRef$5,\n  useState: useState$2\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\nconst {\n  isSSR: isSSR$3\n} = Recoil_Environment;\n\nfunction useTransactionSubscription(callback) {\n  const storeRef = useStoreRef$3();\n  useEffect$4(() => {\n    const sub = storeRef.current.subscribeToTransactions(callback);\n    return sub.release;\n  }, [callback, storeRef]);\n}\n\nfunction externallyVisibleAtomValuesInState(state) {\n  const atomValues = state.atomValues.toMap();\n  const persistedAtomContentsValues = Recoil_mapMap(Recoil_filterMap(atomValues, (v, k) => {\n    const node = getNode$4(k);\n    const persistence = node.persistence_UNSTABLE;\n    return persistence != null && persistence.type !== 'none' && v.state === 'hasValue';\n  }), v => v.contents); // Merge in nonvalidated atoms; we may not have defs for them but they will\n  // all have persistence on or they wouldn't be there in the first place.\n\n  return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(), persistedAtomContentsValues);\n}\n/**\n  Calls the given callback after any atoms have been modified and the consequent\n  component re-renders have been committed. This is intended for persisting\n  the values of the atoms to storage. The stored values can then be restored\n  using the useSetUnvalidatedAtomValues hook.\n\n  The callback receives the following info:\n\n  atomValues: The current value of every atom that is both persistable (persistence\n              type not set to 'none') and whose value is available (not in an\n              error or loading state).\n\n  previousAtomValues: The value of every persistable and available atom before\n               the transaction began.\n\n  atomInfo: A map containing the persistence settings for each atom. Every key\n            that exists in atomValues will also exist in atomInfo.\n\n  modifiedAtoms: The set of atoms that were written to during the transaction.\n\n  transactionMetadata: Arbitrary information that was added via the\n          useSetUnvalidatedAtomValues hook. Useful for ignoring the useSetUnvalidatedAtomValues\n          transaction, to avoid loops.\n*/\n\n\nfunction useTransactionObservation_DEPRECATED(callback) {\n  useTransactionSubscription(useCallback$2(store => {\n    let previousTree = store.getState().previousTree;\n    const currentTree = store.getState().currentTree;\n\n    if (!previousTree) {\n      Recoil_recoverableViolation('Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil');\n      previousTree = store.getState().currentTree; // attempt to trundle on\n    }\n\n    const atomValues = externallyVisibleAtomValuesInState(currentTree);\n    const previousAtomValues = externallyVisibleAtomValuesInState(previousTree);\n    const atomInfo = Recoil_mapMap(nodes$1, node => {\n      var _node$persistence_UNS, _node$persistence_UNS2, _node$persistence_UNS3, _node$persistence_UNS4;\n\n      return {\n        persistence_UNSTABLE: {\n          type: (_node$persistence_UNS = (_node$persistence_UNS2 = node.persistence_UNSTABLE) === null || _node$persistence_UNS2 === void 0 ? void 0 : _node$persistence_UNS2.type) !== null && _node$persistence_UNS !== void 0 ? _node$persistence_UNS : 'none',\n          backButton: (_node$persistence_UNS3 = (_node$persistence_UNS4 = node.persistence_UNSTABLE) === null || _node$persistence_UNS4 === void 0 ? void 0 : _node$persistence_UNS4.backButton) !== null && _node$persistence_UNS3 !== void 0 ? _node$persistence_UNS3 : false\n        }\n      };\n    }); // Filter on existance in atomValues so that externally-visible rules\n    // are also applied to modified atoms (specifically exclude selectors):\n\n    const modifiedAtoms = Recoil_filterSet(currentTree.dirtyAtoms, k => atomValues.has(k) || previousAtomValues.has(k));\n    callback({\n      atomValues,\n      previousAtomValues,\n      atomInfo,\n      modifiedAtoms,\n      transactionMetadata: { ...currentTree.transactionMetadata\n      }\n    });\n  }, [callback]));\n}\n\nfunction useRecoilTransactionObserver(callback) {\n  useTransactionSubscription(useCallback$2(store => {\n    const snapshot = cloneSnapshot$1(store, 'latest');\n    const previousSnapshot = cloneSnapshot$1(store, 'previous');\n    callback({\n      snapshot,\n      previousSnapshot\n    });\n  }, [callback]));\n} // Return a snapshot of the current state and subscribe to all state changes\n\n\nfunction useRecoilSnapshot() {\n  const storeRef = useStoreRef$3();\n  const [snapshot, setSnapshot] = useState$2(() => cloneSnapshot$1(storeRef.current));\n  const previousSnapshot = Recoil_usePrevious(snapshot);\n  const timeoutID = useRef$5();\n  const releaseRef = useRef$5();\n  useTransactionSubscription(useCallback$2(store => setSnapshot(cloneSnapshot$1(store)), [])); // Retain snapshot for duration component is mounted\n\n  useEffect$4(() => {\n    const release = snapshot.retain(); // Release the retain from the rendering call\n\n    if (timeoutID.current && !isSSR$3) {\n      var _releaseRef$current;\n\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n      (_releaseRef$current = releaseRef.current) === null || _releaseRef$current === void 0 ? void 0 : _releaseRef$current.call(releaseRef);\n      releaseRef.current = null;\n    }\n\n    return () => {\n      // Defer the release.  If \"Fast Refresh\"\" is used then the component may\n      // re-render with the same state.  The previous cleanup will then run and\n      // then the new effect will run. We don't want the snapshot to be released\n      // by that cleanup before the new effect has a chance to retain it again.\n      // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936\n      window.setTimeout(release, 10);\n    };\n  }, [snapshot]); // Retain snapshot until above effect is run.\n  // Release after a threshold in case component is suspended.\n\n  if (previousSnapshot !== snapshot && !isSSR$3) {\n    // Release the previous snapshot\n    if (timeoutID.current) {\n      var _releaseRef$current2;\n\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n      (_releaseRef$current2 = releaseRef.current) === null || _releaseRef$current2 === void 0 ? void 0 : _releaseRef$current2.call(releaseRef);\n      releaseRef.current = null;\n    }\n\n    releaseRef.current = snapshot.retain();\n    timeoutID.current = window.setTimeout(() => {\n      var _releaseRef$current3;\n\n      timeoutID.current = null;\n      (_releaseRef$current3 = releaseRef.current) === null || _releaseRef$current3 === void 0 ? void 0 : _releaseRef$current3.call(releaseRef);\n      releaseRef.current = null;\n    }, SUSPENSE_TIMEOUT_MS$2);\n  }\n\n  return snapshot;\n}\n\nfunction gotoSnapshot(store, snapshot) {\n  var _storeState$nextTree;\n\n  const storeState = store.getState();\n  const prev = (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree;\n  const next = snapshot.getStore_INTERNAL().getState().currentTree;\n  batchUpdates$3(() => {\n    const keysToUpdate = new Set();\n\n    for (const keys of [prev.atomValues.keys(), next.atomValues.keys()]) {\n      for (const key of keys) {\n        var _prev$atomValues$get, _next$atomValues$get;\n\n        if (((_prev$atomValues$get = prev.atomValues.get(key)) === null || _prev$atomValues$get === void 0 ? void 0 : _prev$atomValues$get.contents) !== ((_next$atomValues$get = next.atomValues.get(key)) === null || _next$atomValues$get === void 0 ? void 0 : _next$atomValues$get.contents) && getNode$4(key).shouldRestoreFromSnapshots) {\n          keysToUpdate.add(key);\n        }\n      }\n    }\n\n    keysToUpdate.forEach(key => {\n      setRecoilValueLoadable$1(store, new AbstractRecoilValue$4(key), next.atomValues.has(key) ? Recoil_nullthrows(next.atomValues.get(key)) : DEFAULT_VALUE$3);\n    });\n    store.replaceState(state => ({ ...state,\n      stateID: snapshot.getID()\n    }));\n  });\n}\n\nfunction useGotoRecoilSnapshot() {\n  const storeRef = useStoreRef$3();\n  return useCallback$2(snapshot => gotoSnapshot(storeRef.current, snapshot), [storeRef]);\n}\n\nvar Recoil_SnapshotHooks = {\n  useRecoilSnapshot,\n  gotoSnapshot,\n  useGotoRecoilSnapshot,\n  useRecoilTransactionObserver,\n  useTransactionObservation_DEPRECATED,\n  useTransactionSubscription_DEPRECATED: useTransactionSubscription\n};\nconst {\n  peekNodeInfo: peekNodeInfo$2\n} = Recoil_FunctionalCore;\nconst {\n  useStoreRef: useStoreRef$4\n} = Recoil_RecoilRoot;\n\nfunction useGetRecoilValueInfo() {\n  const storeRef = useStoreRef$4();\n  return ({\n    key\n  }) => peekNodeInfo$2(storeRef.current, storeRef.current.getState().currentTree, key);\n}\n\nvar Recoil_useGetRecoilValueInfo = useGetRecoilValueInfo;\nconst {\n  reactMode: reactMode$4\n} = Recoil_ReactMode;\nconst {\n  RecoilRoot: RecoilRoot$1,\n  useStoreRef: useStoreRef$5\n} = Recoil_RecoilRoot;\nconst {\n  useMemo: useMemo$2\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction useRecoilBridgeAcrossReactRoots() {\n  // The test fails when using useMutableSource(), but only if act() is used\n  // for the nested root.  So, this may only be a testing environment issue.\n  if (reactMode$4().mode === 'MUTABLE_SOURCE') {\n    // eslint-disable-next-line fb-www/no-console\n    console.warn('Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.');\n  }\n\n  const store = useStoreRef$5().current;\n  return useMemo$2(() => {\n    // eslint-disable-next-line no-shadow\n    function RecoilBridge({\n      children\n    }) {\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RecoilRoot$1, {\n        store_INTERNAL: store\n      }, children);\n    }\n\n    return RecoilBridge;\n  }, [store]);\n}\n\nvar Recoil_useRecoilBridgeAcrossReactRoots = useRecoilBridgeAcrossReactRoots;\nconst {\n  loadableWithValue: loadableWithValue$1\n} = Recoil_Loadable$1;\nconst {\n  initializeNode: initializeNode$3\n} = Recoil_FunctionalCore;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$4,\n  getNode: getNode$5\n} = Recoil_Node;\nconst {\n  copyTreeState: copyTreeState$1,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$3,\n  invalidateDownstreams: invalidateDownstreams$1,\n  writeLoadableToTreeState: writeLoadableToTreeState$1\n} = Recoil_RecoilValueInterface;\n\nfunction isAtom(recoilValue) {\n  return getNode$5(recoilValue.key).nodeType === 'atom';\n}\n\nclass TransactionInterfaceImpl {\n  constructor(store, treeState) {\n    _defineProperty(this, \"_store\", void 0);\n\n    _defineProperty(this, \"_treeState\", void 0);\n\n    _defineProperty(this, \"_changes\", void 0);\n\n    _defineProperty(this, \"get\", recoilValue => {\n      if (this._changes.has(recoilValue.key)) {\n        // $FlowIssue[incompatible-return]\n        return this._changes.get(recoilValue.key);\n      }\n\n      if (!isAtom(recoilValue)) {\n        throw Recoil_err('Reading selectors within atomicUpdate is not supported');\n      }\n\n      const loadable = getRecoilValueAsLoadable$3(this._store, recoilValue, this._treeState);\n\n      if (loadable.state === 'hasValue') {\n        return loadable.contents;\n      } else if (loadable.state === 'hasError') {\n        throw loadable.contents;\n      } else {\n        throw Recoil_err(`Expected Recoil atom ${recoilValue.key} to have a value, but it is in a loading state.`);\n      }\n    });\n\n    _defineProperty(this, \"set\", (recoilState, valueOrUpdater) => {\n      if (!isAtom(recoilState)) {\n        throw Recoil_err('Setting selectors within atomicUpdate is not supported');\n      }\n\n      if (typeof valueOrUpdater === 'function') {\n        const current = this.get(recoilState);\n\n        this._changes.set(recoilState.key, valueOrUpdater(current)); // flowlint-line unclear-type:off\n\n      } else {\n        // Initialize atom and run effects if not initialized yet\n        initializeNode$3(this._store, recoilState.key, 'set');\n\n        this._changes.set(recoilState.key, valueOrUpdater);\n      }\n    });\n\n    _defineProperty(this, \"reset\", recoilState => {\n      this.set(recoilState, DEFAULT_VALUE$4);\n    });\n\n    this._store = store;\n    this._treeState = treeState;\n    this._changes = new Map();\n  } // Allow destructing\n  // eslint-disable-next-line fb-www/extra-arrow-initializer\n\n\n  newTreeState_INTERNAL() {\n    if (this._changes.size === 0) {\n      return this._treeState;\n    }\n\n    const newState = copyTreeState$1(this._treeState);\n\n    for (const [k, v] of this._changes) {\n      writeLoadableToTreeState$1(newState, k, loadableWithValue$1(v));\n    }\n\n    invalidateDownstreams$1(this._store, newState);\n    return newState;\n  }\n\n}\n\nfunction atomicUpdater(store) {\n  return fn => {\n    store.replaceState(treeState => {\n      const changeset = new TransactionInterfaceImpl(store, treeState);\n      fn(changeset);\n      return changeset.newTreeState_INTERNAL();\n    });\n  };\n}\n\nvar Recoil_AtomicUpdates = {\n  atomicUpdater\n};\nvar Recoil_AtomicUpdates_1 = Recoil_AtomicUpdates.atomicUpdater;\nvar Recoil_AtomicUpdates$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  atomicUpdater: Recoil_AtomicUpdates_1\n});\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nvar invariant_1 = invariant; // @oss-only\n\nvar Recoil_invariant = invariant_1;\nconst {\n  atomicUpdater: atomicUpdater$1\n} = Recoil_AtomicUpdates$1;\nconst {\n  batchUpdates: batchUpdates$4\n} = Recoil_Batching;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$5\n} = Recoil_Node;\nconst {\n  useStoreRef: useStoreRef$6\n} = Recoil_RecoilRoot;\nconst {\n  refreshRecoilValue: refreshRecoilValue$1,\n  setRecoilValue: setRecoilValue$3\n} = Recoil_RecoilValueInterface;\nconst {\n  cloneSnapshot: cloneSnapshot$2\n} = Recoil_Snapshot$1;\nconst {\n  gotoSnapshot: gotoSnapshot$1\n} = Recoil_SnapshotHooks;\nconst {\n  useCallback: useCallback$3\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nclass Sentinel {}\n\nconst SENTINEL = new Sentinel();\n\nfunction recoilCallback(store, fn, args, extraInterface) {\n  let ret = SENTINEL;\n  let releaseSnapshot;\n  batchUpdates$4(() => {\n    const errMsg = 'useRecoilCallback() expects a function that returns a function: ' + 'it accepts a function of the type (RecoilInterface) => (Args) => ReturnType ' + 'and returns a callback function (Args) => ReturnType, where RecoilInterface is ' + 'an object {snapshot, set, ...} and Args and ReturnType are the argument and return ' + 'types of the callback you want to create.  Please see the docs ' + 'at recoiljs.org for details.';\n\n    if (typeof fn !== 'function') {\n      throw Recoil_err(errMsg);\n    } // Clone the snapshot lazily to avoid overhead if the callback does not use it.\n    // Note that this means the snapshot may represent later state from when\n    // the callback was called if it first accesses the snapshot asynchronously.\n\n\n    const callbackInterface = Recoil_lazyProxy({ ...(extraInterface !== null && extraInterface !== void 0 ? extraInterface : {}),\n      // flowlint-line unclear-type:off\n      set: (node, newValue) => setRecoilValue$3(store, node, newValue),\n      reset: node => setRecoilValue$3(store, node, DEFAULT_VALUE$5),\n      refresh: node => refreshRecoilValue$1(store, node),\n      gotoSnapshot: snapshot => gotoSnapshot$1(store, snapshot),\n      transact_UNSTABLE: transaction => atomicUpdater$1(store)(transaction)\n    }, {\n      snapshot: () => {\n        const snapshot = cloneSnapshot$2(store);\n        releaseSnapshot = snapshot.retain();\n        return snapshot;\n      }\n    });\n    const callback = fn(callbackInterface);\n\n    if (typeof callback !== 'function') {\n      throw Recoil_err(errMsg);\n    }\n\n    ret = callback(...args);\n  });\n  !!(ret instanceof Sentinel) ?  true ? Recoil_invariant(false, 'batchUpdates should return immediately') : 0 : void 0;\n\n  if (Recoil_isPromise(ret)) {\n    ret.finally(() => {\n      var _releaseSnapshot;\n\n      (_releaseSnapshot = releaseSnapshot) === null || _releaseSnapshot === void 0 ? void 0 : _releaseSnapshot();\n    });\n  } else {\n    var _releaseSnapshot2;\n\n    (_releaseSnapshot2 = releaseSnapshot) === null || _releaseSnapshot2 === void 0 ? void 0 : _releaseSnapshot2();\n  } // $FlowFixMe[incompatible-cast]\n\n\n  return ret;\n}\n\nfunction useRecoilCallback(fn, deps) {\n  const storeRef = useStoreRef$6();\n  return useCallback$3( // $FlowIssue[incompatible-call]\n  (...args) => {\n    return recoilCallback(storeRef.current, fn, args);\n  }, deps != null ? [...deps, storeRef] : undefined // eslint-disable-line fb-www/react-hooks-deps\n  );\n}\n\nvar Recoil_useRecoilCallback = {\n  recoilCallback,\n  useRecoilCallback\n};\nconst {\n  useStoreRef: useStoreRef$7\n} = Recoil_RecoilRoot;\nconst {\n  refreshRecoilValue: refreshRecoilValue$2\n} = Recoil_RecoilValueInterface;\nconst {\n  useCallback: useCallback$4\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction useRecoilRefresher(recoilValue) {\n  const storeRef = useStoreRef$7();\n  return useCallback$4(() => {\n    const store = storeRef.current;\n    refreshRecoilValue$2(store, recoilValue);\n  }, [recoilValue, storeRef]);\n}\n\nvar Recoil_useRecoilRefresher = useRecoilRefresher;\nconst {\n  atomicUpdater: atomicUpdater$2\n} = Recoil_AtomicUpdates$1;\nconst {\n  useStoreRef: useStoreRef$8\n} = Recoil_RecoilRoot;\nconst {\n  useMemo: useMemo$3\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction useRecoilTransaction(fn, deps) {\n  const storeRef = useStoreRef$8();\n  return useMemo$3(() => (...args) => {\n    const atomicUpdate = atomicUpdater$2(storeRef.current);\n    atomicUpdate(transactionInterface => {\n      fn(transactionInterface)(...args);\n    });\n  }, deps != null ? [...deps, storeRef] : undefined // eslint-disable-line fb-www/react-hooks-deps\n  );\n}\n\nvar Recoil_useRecoilTransaction = useRecoilTransaction;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nclass WrappedValue {\n  constructor(value) {\n    _defineProperty(this, \"value\", void 0);\n\n    this.value = value;\n  }\n\n}\n\nvar Recoil_Wrapper = {\n  WrappedValue\n};\nvar Recoil_Wrapper_1 = Recoil_Wrapper.WrappedValue;\nvar Recoil_Wrapper$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  WrappedValue: Recoil_Wrapper_1\n});\nconst {\n  isFastRefreshEnabled: isFastRefreshEnabled$2\n} = Recoil_ReactMode;\n\nclass ChangedPathError extends Error {}\n\nclass TreeCache {\n  // $FlowIssue[unclear-type]\n  constructor(options) {\n    var _options$onHit, _options$onSet, _options$mapNodeValue;\n\n    _defineProperty(this, \"_name\", void 0);\n\n    _defineProperty(this, \"_numLeafs\", void 0);\n\n    _defineProperty(this, \"_root\", void 0);\n\n    _defineProperty(this, \"_onHit\", void 0);\n\n    _defineProperty(this, \"_onSet\", void 0);\n\n    _defineProperty(this, \"_mapNodeValue\", void 0);\n\n    this._name = options === null || options === void 0 ? void 0 : options.name;\n    this._numLeafs = 0;\n    this._root = null;\n    this._onHit = (_options$onHit = options === null || options === void 0 ? void 0 : options.onHit) !== null && _options$onHit !== void 0 ? _options$onHit : () => {};\n    this._onSet = (_options$onSet = options === null || options === void 0 ? void 0 : options.onSet) !== null && _options$onSet !== void 0 ? _options$onSet : () => {};\n    this._mapNodeValue = (_options$mapNodeValue = options === null || options === void 0 ? void 0 : options.mapNodeValue) !== null && _options$mapNodeValue !== void 0 ? _options$mapNodeValue : val => val;\n  }\n\n  size() {\n    return this._numLeafs;\n  } // $FlowIssue[unclear-type]\n\n\n  root() {\n    return this._root;\n  }\n\n  get(getNodeValue, handlers) {\n    var _this$getLeafNode;\n\n    return (_this$getLeafNode = this.getLeafNode(getNodeValue, handlers)) === null || _this$getLeafNode === void 0 ? void 0 : _this$getLeafNode.value;\n  }\n\n  getLeafNode(getNodeValue, handlers) {\n    if (this._root == null) {\n      return undefined;\n    } // Iterate down the tree based on the current node values until we hit a leaf\n    // $FlowIssue[unclear-type]\n\n\n    let node = this._root;\n\n    while (node) {\n      handlers === null || handlers === void 0 ? void 0 : handlers.onNodeVisit(node);\n\n      if (node.type === 'leaf') {\n        this._onHit(node);\n\n        return node;\n      }\n\n      const nodeValue = this._mapNodeValue(getNodeValue(node.nodeKey));\n\n      node = node.branches.get(nodeValue);\n    }\n\n    return undefined;\n  }\n\n  set(route, value, handlers) {\n    const addLeaf = () => {\n      var _node2, _node3, _this$_root2, _handlers$onNodeVisit2; // First, setup the branch nodes for the route:\n      // Iterate down the tree to find or add branch nodes following the route\n\n\n      let node;\n      let branchKey;\n\n      for (const [nodeKey, nodeValue] of route) {\n        var _node, _handlers$onNodeVisit, _this$_root; // If the previous root was a leaf, while we not have a get(), it means\n        // the selector has inconsistent values or implementation changed.\n\n\n        const root = this._root;\n\n        if ((root === null || root === void 0 ? void 0 : root.type) === 'leaf') {\n          throw this.invalidCacheError();\n        } // node now refers to the next node down in the tree\n\n\n        const parent = node; // $FlowFixMe[prop-missing]\n        // $FlowFixMe[incompatible-type]\n\n        node = parent ? parent.branches.get(branchKey) : root; // $FlowFixMe[prop-missing]\n        // $FlowFixMe[incompatible-type]\n\n        node = (_node = node) !== null && _node !== void 0 ? _node : {\n          type: 'branch',\n          nodeKey,\n          parent,\n          branches: new Map(),\n          branchKey\n        }; // If we found an existing node, confirm it has a consistent value\n\n        if (node.type !== 'branch' || node.nodeKey !== nodeKey) {\n          throw this.invalidCacheError();\n        } // Add the branch node to the tree\n\n\n        parent === null || parent === void 0 ? void 0 : parent.branches.set(branchKey, node);\n        handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit = handlers.onNodeVisit) === null || _handlers$onNodeVisit === void 0 ? void 0 : _handlers$onNodeVisit.call(handlers, node); // Prepare for next iteration and install root if it is new.\n\n        branchKey = this._mapNodeValue(nodeValue);\n        this._root = (_this$_root = this._root) !== null && _this$_root !== void 0 ? _this$_root : node;\n      } // Second, setup the leaf node:\n      // If there is an existing leaf for this route confirm it is consistent\n\n\n      const oldLeaf = node ? (_node2 = node) === null || _node2 === void 0 ? void 0 : _node2.branches.get(branchKey) : this._root;\n\n      if (oldLeaf != null && (oldLeaf.type !== 'leaf' || oldLeaf.branchKey !== branchKey)) {\n        throw this.invalidCacheError();\n      } // Create a new or replacement leaf.\n\n\n      const leafNode = {\n        type: 'leaf',\n        value,\n        parent: node,\n        branchKey\n      }; // Install the leaf and call handlers\n\n      (_node3 = node) === null || _node3 === void 0 ? void 0 : _node3.branches.set(branchKey, leafNode);\n      this._root = (_this$_root2 = this._root) !== null && _this$_root2 !== void 0 ? _this$_root2 : leafNode;\n      this._numLeafs++;\n\n      this._onSet(leafNode);\n\n      handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit2 = handlers.onNodeVisit) === null || _handlers$onNodeVisit2 === void 0 ? void 0 : _handlers$onNodeVisit2.call(handlers, leafNode);\n    };\n\n    try {\n      addLeaf();\n    } catch (error) {\n      // If the cache was stale or observed inconsistent values, such as with\n      // Fast Refresh, then clear it and rebuild with the new values.\n      if (error instanceof ChangedPathError) {\n        this.clear();\n        addLeaf();\n      } else {\n        throw error;\n      }\n    }\n  } // Returns true if leaf was actually deleted from the tree\n\n\n  delete(leaf) {\n    const root = this.root();\n\n    if (!root) {\n      return false;\n    }\n\n    if (leaf === root) {\n      this._root = null;\n      this._numLeafs = 0;\n      return true;\n    } // Iterate up from the leaf deleteing it from it's parent's branches.\n\n\n    let node = leaf.parent;\n    let branchKey = leaf.branchKey;\n\n    while (node) {\n      var _node4;\n\n      node.branches.delete(branchKey); // Stop iterating if we hit the root.\n\n      if (node === root) {\n        if (node.branches.size === 0) {\n          this._root = null;\n          this._numLeafs = 0;\n        } else {\n          this._numLeafs--;\n        }\n\n        return true;\n      } // Stop iterating if there are other branches since we don't need to\n      // remove any more nodes.\n\n\n      if (node.branches.size > 0) {\n        break;\n      } // Iterate up to our parent\n\n\n      branchKey = (_node4 = node) === null || _node4 === void 0 ? void 0 : _node4.branchKey;\n      node = node.parent;\n    } // Confirm that the leaf we are deleting is actually attached to our tree\n\n\n    for (; node !== root; node = node.parent) {\n      if (node == null) {\n        return false;\n      }\n    }\n\n    this._numLeafs--;\n    return true;\n  }\n\n  clear() {\n    this._numLeafs = 0;\n    this._root = null;\n  }\n\n  invalidCacheError() {\n    const CHANGED_PATH_ERROR_MESSAGE = isFastRefreshEnabled$2() ? 'Possible Fast Refresh module reload detected.  ' + 'This may also be caused by an selector returning inconsistent values. ' + 'Resetting cache.' : 'Invalid cache values.  This happens when selectors do not return ' + 'consistent values for the same input dependency values.  That may also ' + 'be caused when using Fast Refresh to change a selector implementation.  ' + 'Resetting cache.';\n    Recoil_recoverableViolation(CHANGED_PATH_ERROR_MESSAGE + (this._name != null ? ` - ${this._name}` : ''));\n    throw new ChangedPathError();\n  }\n\n}\n\nvar Recoil_TreeCache = {\n  TreeCache\n};\nvar Recoil_TreeCache_1 = Recoil_TreeCache.TreeCache;\nvar Recoil_TreeCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  TreeCache: Recoil_TreeCache_1\n});\n\nclass LRUCache {\n  constructor(options) {\n    var _options$mapKey;\n\n    _defineProperty(this, \"_maxSize\", void 0);\n\n    _defineProperty(this, \"_size\", void 0);\n\n    _defineProperty(this, \"_head\", void 0);\n\n    _defineProperty(this, \"_tail\", void 0);\n\n    _defineProperty(this, \"_map\", void 0);\n\n    _defineProperty(this, \"_keyMapper\", void 0);\n\n    this._maxSize = options.maxSize;\n    this._size = 0;\n    this._head = null;\n    this._tail = null;\n    this._map = new Map();\n    this._keyMapper = (_options$mapKey = options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : v => v;\n  }\n\n  head() {\n    return this._head;\n  }\n\n  tail() {\n    return this._tail;\n  }\n\n  size() {\n    return this._size;\n  }\n\n  maxSize() {\n    return this._maxSize;\n  }\n\n  has(key) {\n    return this._map.has(this._keyMapper(key));\n  }\n\n  get(key) {\n    const mappedKey = this._keyMapper(key);\n\n    const node = this._map.get(mappedKey);\n\n    if (!node) {\n      return undefined;\n    }\n\n    this.set(key, node.value);\n    return node.value;\n  }\n\n  set(key, val) {\n    const mappedKey = this._keyMapper(key);\n\n    const existingNode = this._map.get(mappedKey);\n\n    if (existingNode) {\n      this.delete(key);\n    }\n\n    const head = this.head();\n    const node = {\n      key,\n      right: head,\n      left: null,\n      value: val\n    };\n\n    if (head) {\n      head.left = node;\n    } else {\n      this._tail = node;\n    }\n\n    this._map.set(mappedKey, node);\n\n    this._head = node;\n    this._size++;\n\n    this._maybeDeleteLRU();\n  }\n\n  _maybeDeleteLRU() {\n    if (this.size() > this.maxSize()) {\n      this.deleteLru();\n    }\n  }\n\n  deleteLru() {\n    const tail = this.tail();\n\n    if (tail) {\n      this.delete(tail.key);\n    }\n  }\n\n  delete(key) {\n    const mappedKey = this._keyMapper(key);\n\n    if (!this._size || !this._map.has(mappedKey)) {\n      return;\n    }\n\n    const node = Recoil_nullthrows(this._map.get(mappedKey));\n    const right = node.right;\n    const left = node.left;\n\n    if (right) {\n      right.left = node.left;\n    }\n\n    if (left) {\n      left.right = node.right;\n    }\n\n    if (node === this.head()) {\n      this._head = right;\n    }\n\n    if (node === this.tail()) {\n      this._tail = left;\n    }\n\n    this._map.delete(mappedKey);\n\n    this._size--;\n  }\n\n  clear() {\n    this._size = 0;\n    this._head = null;\n    this._tail = null;\n    this._map = new Map();\n  }\n\n}\n\nvar Recoil_LRUCache = {\n  LRUCache\n};\nvar Recoil_LRUCache_1 = Recoil_LRUCache.LRUCache;\nvar Recoil_LRUCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  LRUCache: Recoil_LRUCache_1\n});\nconst {\n  LRUCache: LRUCache$1\n} = Recoil_LRUCache$1;\nconst {\n  TreeCache: TreeCache$1\n} = Recoil_TreeCache$1;\n\nfunction treeCacheLRU({\n  name,\n  maxSize,\n  mapNodeValue = v => v\n}) {\n  const lruCache = new LRUCache$1({\n    maxSize\n  });\n  const cache = new TreeCache$1({\n    name,\n    mapNodeValue,\n    onHit: node => {\n      lruCache.set(node, true);\n    },\n    onSet: node => {\n      const lruNode = lruCache.tail();\n      lruCache.set(node, true);\n\n      if (lruNode && cache.size() > maxSize) {\n        cache.delete(lruNode.key);\n      }\n    }\n  });\n  return cache;\n}\n\nvar Recoil_treeCacheLRU = treeCacheLRU;\nconst TIME_WARNING_THRESHOLD_MS = 15;\n\nfunction stringify(x, opt, key) {\n  // A optimization to avoid the more expensive JSON.stringify() for simple strings\n  // This may lose protection for u2028 and u2029, though.\n  if (typeof x === 'string' && !x.includes('\"') && !x.includes('\\\\')) {\n    return `\"${x}\"`;\n  } // Handle primitive types\n\n\n  switch (typeof x) {\n    case 'undefined':\n      return '';\n    // JSON.stringify(undefined) returns undefined, but we always want to return a string\n\n    case 'boolean':\n      return x ? 'true' : 'false';\n\n    case 'number':\n    case 'symbol':\n      // case 'bigint': // BigInt is not supported in www\n      return String(x);\n\n    case 'string':\n      // Add surrounding quotes and escape internal quotes\n      return JSON.stringify(x);\n\n    case 'function':\n      if ((opt === null || opt === void 0 ? void 0 : opt.allowFunctions) !== true) {\n        throw Recoil_err('Attempt to serialize function in a Recoil cache key');\n      }\n\n      return `__FUNCTION(${x.name})__`;\n  }\n\n  if (x === null) {\n    return 'null';\n  } // Fallback case for unknown types\n\n\n  if (typeof x !== 'object') {\n    var _JSON$stringify;\n\n    return (_JSON$stringify = JSON.stringify(x)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : '';\n  } // Deal with all promises as equivalent for now.\n\n\n  if (Recoil_isPromise(x)) {\n    return '__PROMISE__';\n  } // Arrays handle recursive stringification\n\n\n  if (Array.isArray(x)) {\n    return `[${x.map((v, i) => stringify(v, opt, i.toString()))}]`;\n  } // If an object defines a toJSON() method, then use that to override the\n  // serialization.  This matches the behavior of JSON.stringify().\n  // Pass the key for compatibility.\n  // Immutable.js collections define this method to allow us to serialize them.\n\n\n  if (typeof x.toJSON === 'function') {\n    // flowlint-next-line unclear-type: off\n    return stringify(x.toJSON(key), opt, key);\n  } // For built-in Maps, sort the keys in a stable order instead of the\n  // default insertion order.  Support non-string keys.\n\n\n  if (x instanceof Map) {\n    const obj = {};\n\n    for (const [k, v] of x) {\n      // Stringify will escape any nested quotes\n      obj[typeof k === 'string' ? k : stringify(k, opt)] = v;\n    }\n\n    return stringify(obj, opt, key);\n  } // For built-in Sets, sort the keys in a stable order instead of the\n  // default insertion order.\n\n\n  if (x instanceof Set) {\n    return stringify(Array.from(x).sort((a, b) => stringify(a, opt).localeCompare(stringify(b, opt))), opt, key);\n  } // Anything else that is iterable serialize as an Array.\n\n\n  if (Symbol !== undefined && x[Symbol.iterator] != null && typeof x[Symbol.iterator] === 'function') {\n    // flowlint-next-line unclear-type: off\n    return stringify(Array.from(x), opt, key);\n  } // For all other Objects, sort the keys in a stable order.\n\n\n  return `{${Object.keys(x).filter(k => x[k] !== undefined).sort() // stringify the key to add quotes and escape any nested slashes or quotes.\n  .map(k => `${stringify(k, opt)}:${stringify(x[k], opt, k)}`).join(',')}}`;\n} // Utility similar to JSON.stringify() except:\n// * Serialize built-in Sets as an Array\n// * Serialize built-in Maps as an Object.  Supports non-string keys.\n// * Serialize other iterables as arrays\n// * Sort the keys of Objects and Maps to have a stable order based on string conversion.\n//    This overrides their default insertion order.\n// * Still uses toJSON() of any object to override serialization\n// * Support Symbols (though don't guarantee uniqueness)\n// * We could support BigInt, but Flow doesn't seem to like it.\n// See Recoil_stableStringify-test.js for examples\n\n\nfunction stableStringify(x, opt = {\n  allowFunctions: false\n}) {\n  if (true) {\n    if (typeof window !== 'undefined') {\n      const startTime = window.performance ? window.performance.now() : 0;\n      const str = stringify(x, opt);\n      const endTime = window.performance ? window.performance.now() : 0;\n\n      if (endTime - startTime > TIME_WARNING_THRESHOLD_MS) {\n        /* eslint-disable fb-www/no-console */\n        console.groupCollapsed(`Recoil: Spent ${endTime - startTime}ms computing a cache key`);\n        console.warn(x, str);\n        console.groupEnd();\n        /* eslint-enable fb-www/no-console */\n      }\n\n      return str;\n    }\n  }\n\n  return stringify(x, opt);\n}\n\nvar Recoil_stableStringify = stableStringify;\nconst {\n  TreeCache: TreeCache$2\n} = Recoil_TreeCache$1;\nconst defaultPolicy = {\n  equality: 'reference',\n  eviction: 'keep-all',\n  maxSize: Infinity\n};\n\nfunction treeCacheFromPolicy({\n  equality = defaultPolicy.equality,\n  eviction = defaultPolicy.eviction,\n  maxSize = defaultPolicy.maxSize\n} = defaultPolicy, name) {\n  const valueMapper = getValueMapper(equality);\n  return getTreeCache(eviction, maxSize, valueMapper, name);\n}\n\nfunction getValueMapper(equality) {\n  switch (equality) {\n    case 'reference':\n      return val => val;\n\n    case 'value':\n      return val => Recoil_stableStringify(val);\n  }\n\n  throw Recoil_err(`Unrecognized equality policy ${equality}`);\n}\n\nfunction getTreeCache(eviction, maxSize, mapNodeValue, name) {\n  switch (eviction) {\n    case 'keep-all':\n      return new TreeCache$2({\n        name,\n        mapNodeValue\n      });\n\n    case 'lru':\n      return Recoil_treeCacheLRU({\n        name,\n        maxSize: Recoil_nullthrows(maxSize),\n        mapNodeValue\n      });\n\n    case 'most-recent':\n      return Recoil_treeCacheLRU({\n        name,\n        maxSize: 1,\n        mapNodeValue\n      });\n  }\n\n  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);\n}\n\nvar Recoil_treeCacheFromPolicy = treeCacheFromPolicy;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction isNode(object) {\n  var _ownerDocument, _doc$defaultView;\n\n  if (typeof window === 'undefined') {\n    return false;\n  }\n\n  const doc = object != null ? (_ownerDocument = object.ownerDocument) !== null && _ownerDocument !== void 0 ? _ownerDocument : object : document;\n  const defaultView = (_doc$defaultView = doc.defaultView) !== null && _doc$defaultView !== void 0 ? _doc$defaultView : window;\n  return !!(object != null && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));\n}\n\nvar Recoil_isNode = isNode;\nconst {\n  isReactNative: isReactNative$1,\n  isWindow: isWindow$1\n} = Recoil_Environment;\n\nfunction shouldNotBeFrozen(value) {\n  // Primitives and functions:\n  if (value === null || typeof value !== 'object') {\n    return true;\n  } // React elements:\n\n\n  switch (typeof value.$$typeof) {\n    case 'symbol':\n      return true;\n\n    case 'number':\n      return true;\n  } // Immutable structures:\n\n\n  if (value['@@__IMMUTABLE_ITERABLE__@@'] != null || value['@@__IMMUTABLE_KEYED__@@'] != null || value['@@__IMMUTABLE_INDEXED__@@'] != null || value['@@__IMMUTABLE_ORDERED__@@'] != null || value['@@__IMMUTABLE_RECORD__@@'] != null) {\n    return true;\n  } // DOM nodes:\n\n\n  if (Recoil_isNode(value)) {\n    return true;\n  }\n\n  if (Recoil_isPromise(value)) {\n    return true;\n  }\n\n  if (value instanceof Error) {\n    return true;\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return true;\n  } // Some environments, just as Jest, don't work with the instanceof check\n\n\n  if (!isReactNative$1 && isWindow$1(value)) {\n    return true;\n  }\n\n  return false;\n} // Recursively freeze a value to enforce it is read-only.\n// This may also have minimal performance improvements for enumerating\n// objects (based on browser implementations, of course)\n\n\nfunction deepFreezeValue(value) {\n  if (typeof value !== 'object' || shouldNotBeFrozen(value)) {\n    return;\n  }\n\n  Object.freeze(value); // Make all properties read-only\n\n  for (const key in value) {\n    // $FlowIssue[method-unbinding] added when improving typing for this parameters\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      const prop = value[key]; // Prevent infinite recurssion for circular references.\n\n      if (typeof prop === 'object' && prop != null && !Object.isFrozen(prop)) {\n        deepFreezeValue(prop);\n      }\n    }\n  }\n\n  Object.seal(value); // This also makes existing properties non-configurable.\n}\n\nvar Recoil_deepFreezeValue = deepFreezeValue;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is a stub for some integration into FB internal stuff\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction startPerfBlock(_id) {\n  return () => null;\n}\n\nvar Recoil_PerformanceTimings = {\n  startPerfBlock\n};\nconst {\n  isLoadable: isLoadable$1,\n  loadableWithError: loadableWithError$1,\n  loadableWithPromise: loadableWithPromise$1,\n  loadableWithValue: loadableWithValue$2\n} = Recoil_Loadable$1;\nconst {\n  WrappedValue: WrappedValue$1\n} = Recoil_Wrapper$1;\nconst {\n  getNodeLoadable: getNodeLoadable$2,\n  peekNodeLoadable: peekNodeLoadable$1,\n  setNodeValue: setNodeValue$3\n} = Recoil_FunctionalCore;\nconst {\n  saveDepsToStore: saveDepsToStore$1\n} = Recoil_Graph;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$6,\n  getConfigDeletionHandler: getConfigDeletionHandler$1,\n  getNode: getNode$6,\n  registerNode: registerNode$1\n} = Recoil_Node;\nconst {\n  isRecoilValue: isRecoilValue$3\n} = Recoil_RecoilValue$1;\nconst {\n  markRecoilValueModified: markRecoilValueModified$1\n} = Recoil_RecoilValueInterface;\nconst {\n  retainedByOptionWithDefault: retainedByOptionWithDefault$1\n} = Recoil_Retention;\nconst {\n  recoilCallback: recoilCallback$1\n} = Recoil_useRecoilCallback;\nconst {\n  startPerfBlock: startPerfBlock$1\n} = Recoil_PerformanceTimings;\n\nclass Canceled {}\n\nconst CANCELED = new Canceled();\n/**\n * An ExecutionID is an arbitrary ID that lets us distinguish executions from\n * each other. This is necessary as we need a way of solving this problem:\n * \"given 3 async executions, only update state for the 'latest' execution when\n * it finishes running regardless of when the other 2 finish\". ExecutionIDs\n * provide a convenient way of identifying executions so that we can track and\n * manage them over time.\n */\n\nconst dependencyStack = []; // for detecting circular dependencies.\n\nconst waitingStores = new Map();\n\nconst getNewExecutionID = (() => {\n  let executionID = 0;\n  return () => executionID++;\n})();\n/* eslint-disable no-redeclare */\n\n\nfunction selector(options) {\n  let recoilValue = null;\n  const {\n    key,\n    get,\n    cachePolicy_UNSTABLE: cachePolicy\n  } = options;\n  const set = options.set != null ? options.set : undefined; // flow\n\n  if (true) {\n    if (typeof key !== 'string') {\n      throw Recoil_err('A key option with a unique string value must be provided when creating a selector.');\n    }\n\n    if (typeof get !== 'function') {\n      throw Recoil_err('Selectors must specify a get callback option to get the selector value.');\n    }\n  } // This is every discovered dependency across all executions\n\n\n  const discoveredDependencyNodeKeys = new Set();\n  const cache = Recoil_treeCacheFromPolicy(cachePolicy !== null && cachePolicy !== void 0 ? cachePolicy : {\n    equality: 'reference',\n    eviction: 'keep-all'\n  }, key);\n  const retainedBy = retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE);\n  const executionInfoMap = new Map();\n  let liveStoresCount = 0;\n\n  function selectorIsLive() {\n    return !Recoil_gkx('recoil_memory_managament_2020') || liveStoresCount > 0;\n  }\n\n  function selectorInit(store) {\n    store.getState().knownSelectors.add(key);\n    liveStoresCount++;\n    return () => {\n      liveStoresCount--;\n    };\n  }\n\n  function selectorShouldDeleteConfigOnRelease() {\n    return getConfigDeletionHandler$1(key) !== undefined && !selectorIsLive();\n  }\n\n  function resolveAsync(store, state, executionID, loadable, depValues) {\n    setCache(state, loadable, depValues);\n    notifyStoresOfResolvedAsync(store, executionID);\n  }\n\n  function notifyStoresOfResolvedAsync(store, executionID) {\n    if (isLatestExecution(store, executionID)) {\n      clearExecutionInfo(store);\n    }\n\n    notifyWaitingStores(executionID, true);\n  }\n  /**\n   * Notify stores to pull the selector again if a new async dep was discovered.\n   * 1) Async selector adds a new dep but doesn't resolve yet.\n   *    Note that deps for an async selector are based on the state when the\n   *    evaluation started, in order to provide a consistent picture of state.\n   * 2) But, new value of dep based on the current state might cause the selector\n   *    to resolve or resolve differently.\n   * 3) Therefore, this notification will pull the selector based on the current\n   *    state for the components\n   */\n\n\n  function notifyStoresOfNewAsyncDep(store, executionID) {\n    if (isLatestExecution(store, executionID)) {\n      const executionInfo = Recoil_nullthrows(getExecutionInfo(store));\n      executionInfo.stateVersions.clear();\n      notifyWaitingStores(executionID, false);\n    }\n  }\n\n  function notifyWaitingStores(executionID, clearWaitlist) {\n    const stores = waitingStores.get(executionID);\n\n    if (stores != null) {\n      for (const waitingStore of stores) {\n        markRecoilValueModified$1(waitingStore, Recoil_nullthrows(recoilValue));\n      }\n\n      if (clearWaitlist) {\n        waitingStores.delete(executionID);\n      }\n    }\n  }\n\n  function markStoreWaitingForResolvedAsync(store, executionID) {\n    let stores = waitingStores.get(executionID);\n\n    if (stores == null) {\n      waitingStores.set(executionID, stores = new Set());\n    }\n\n    stores.add(store);\n  }\n  /**\n   * This function attaches a then() and a catch() to a promise that was\n   * returned from a selector's get() (either explicitly or implicitly by\n   * running a function that uses the \"async\" keyword). If a selector's get()\n   * returns a promise, we have two possibilities:\n   *\n   * 1. The promise will resolve, in which case it will have completely finished\n   *    executing without any remaining pending dependencies. No more retries\n   *    are needed and we can proceed with updating the cache and notifying\n   *    subscribers (if it is the latest execution, otherwise only the cache\n   *    will be updated and subscriptions will not be fired). This is the case\n   *    handled by the attached then() handler.\n   *\n   * 2. The promise will throw because it either has an error or it came across\n   *    an async dependency that has not yet resolved, in which case we will\n   *    call wrapDepdencyPromise(), whose responsibility is to handle dependency\n   *    promises. This case is handled by the attached catch() handler.\n   *\n   * Both branches will eventually resolve to the final result of the selector\n   * (or an error if a real error occurred).\n   *\n   * The execution will run to completion even if it is stale, and its value\n   * will be cached. But stale executions will not update global state or update\n   * executionInfo as that is the responsibility of the 'latest' execution.\n   *\n   * Note this function should not be passed a promise that was thrown--AKA a\n   * dependency promise. Dependency promises should be passed to\n   * wrapPendingDependencyPromise()).\n   */\n\n\n  function wrapResultPromise(store, promise, state, depValues, executionID, loadingDepsState) {\n    return promise.then(value => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      const loadable = loadableWithValue$2(value);\n      resolveAsync(store, state, executionID, loadable, depValues);\n      return value;\n    }).catch(errorOrPromise => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      if (Recoil_isPromise(errorOrPromise)) {\n        return wrapPendingDependencyPromise(store, errorOrPromise, state, depValues, executionID, loadingDepsState);\n      }\n\n      const loadable = loadableWithError$1(errorOrPromise);\n      resolveAsync(store, state, executionID, loadable, depValues);\n      throw errorOrPromise;\n    });\n  }\n  /**\n   * This function attaches a then() and a catch() to a promise that was\n   * thrown from a selector's get(). If a selector's get() throws a promise,\n   * we have two possibilities:\n   *\n   * 1. The promise will resolve, meaning one of our selector's dependencies is\n   *    now available and we should \"retry\" our get() by running it again. This\n   *    is the case handled by the attached then() handler.\n   *\n   * 2. The promise will throw because something went wrong with the dependency\n   *    promise (in other words a real error occurred). This case is handled by\n   *    the attached catch() handler. If the dependency promise throws, it is\n   *    _always_ a real error and not another dependency promise (any dependency\n   *    promises would have been handled upstream).\n   *\n   * The then() branch will eventually resolve to the final result of the\n   * selector (or an error if a real error occurs), and the catch() will always\n   * resolve to an error because the dependency promise is a promise that was\n   * wrapped upstream, meaning it will only resolve to its real value or to a\n   * real error.\n   *\n   * The execution will run to completion even if it is stale, and its value\n   * will be cached. But stale executions will not update global state or update\n   * executionInfo as that is the responsibility of the 'latest' execution.\n   *\n   * Note this function should not be passed a promise that was returned from\n   * get(). The intention is that this function is only passed promises that\n   * were thrown due to a pending dependency. Promises returned by get() should\n   * be passed to wrapResultPromise() instead.\n   */\n\n\n  function wrapPendingDependencyPromise(store, promise, state, existingDeps, executionID, loadingDepsState) {\n    return promise.then(resolvedDep => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      } // Check if we are handling a pending Recoil dependency or if the user\n      // threw their own Promise to \"suspend\" a selector evaluation.  We need\n      // to check that the loadingDepPromise actually matches the promise that\n      // we caught in case the selector happened to catch the promise we threw\n      // for a pending Recoil dependency from `getRecoilValue()` and threw\n      // their own promise instead.\n\n\n      if (loadingDepsState.loadingDepKey != null && loadingDepsState.loadingDepPromise === promise) {\n        /**\n         * Note for async atoms, this means we are changing the atom's value\n         * in the store for the given version. This should be alright because\n         * the version of state is now stale and a new version will have\n         * already been triggered by the atom being resolved (see this logic\n         * in Recoil_atom.js)\n         */\n        state.atomValues.set(loadingDepsState.loadingDepKey, loadableWithValue$2(resolvedDep));\n      } else {\n        /**\n         * If resolvedDepKey is not defined, the promise was a user-thrown\n         * promise. User-thrown promises are an advanced feature and they\n         * should be avoided in almost all cases. Using `loadable.map()` inside\n         * of selectors for loading loadables and then throwing that mapped\n         * loadable's promise is an example of a user-thrown promise.\n         *\n         * When we hit a user-thrown promise, we have to bail out of an optimization\n         * where we bypass calculating selector cache keys for selectors that\n         * have been previously seen for a given state (these selectors are saved in\n         * state.atomValues) to avoid stale state as we have no way of knowing\n         * what state changes happened (if any) in result to the promise resolving.\n         *\n         * Ideally we would only bail out selectors that are in the chain of\n         * dependencies for this selector, but there's currently no way to get\n         * a full list of a selector's downstream nodes because the state that\n         * is executing may be a discarded tree (so store.getGraph(state.version)\n         * will be empty), and the full dep tree may not be in the selector\n         * caches in the case where the selector's cache was cleared. To solve\n         * for this we would have to keep track of all running selector\n         * executions and their downstream deps. Because this only covers edge\n         * cases, that complexity might not be justifyable.\n         */\n        store.getState().knownSelectors.forEach(nodeKey => {\n          state.atomValues.delete(nodeKey);\n        });\n      }\n      /**\n       * Optimization: Now that the dependency has resolved, let's try hitting\n       * the cache in case the dep resolved to a value we have previously seen.\n       *\n       * TODO:\n       * Note this optimization is not perfect because it only prevents re-executions\n       * _after_ the point where an async dependency is found. Any code leading\n       * up to the async dependency may have run unnecessarily. The ideal case\n       * would be to wait for the async dependency to resolve first, check the\n       * cache, and prevent _any_ execution of the selector if the resulting\n       * value of the dependency leads to a path that is found in the cache.\n       * The ideal case is more difficult to implement as it would require that\n       * we capture and wait for the the async dependency right after checking\n       * the cache. The current approach takes advantage of the fact that running\n       * the selector already has a code path that lets us exit early when\n       * an async dep resolves.\n       */\n\n\n      const cachedLoadable = getLoadableFromCacheAndUpdateDeps(store, state);\n\n      if (cachedLoadable && cachedLoadable.state !== 'loading') {\n        /**\n         * This has to notify stores of a resolved async, even if there is no\n         * current pending execution for the following case:\n         * 1) A component renders with this pending loadable.\n         * 2) The upstream dependency resolves.\n         * 3) While processing some other selector it reads this one, such as\n         *    while traversing its dependencies.  At this point it gets the\n         *    new resolved value synchronously and clears the current\n         *    execution ID.  The component wasn't getting the value itself,\n         *    though, so it still has the pending loadable.\n         * 4) When this code executes the current execution id was cleared\n         *    and it wouldn't notify the component of the new value.\n         *\n         * I think this is only an issue with \"early\" rendering since the\n         * components got their value using the in-progress execution.\n         * We don't have a unit test for this case yet.  I'm not sure it is\n         * necessary with recoil_transition_support mode.\n         */\n        if (isLatestExecution(store, executionID) || getExecutionInfo(store) == null) {\n          notifyStoresOfResolvedAsync(store, executionID);\n        }\n\n        if (cachedLoadable.state === 'hasValue') {\n          return cachedLoadable.contents;\n        } else {\n          throw cachedLoadable.contents;\n        }\n      }\n      /**\n       * If this execution is stale, let's check to see if there is some in\n       * progress execution with a matching state. If we find a match, then\n       * we can take the value from that in-progress execution. Note this may\n       * sound like an edge case, but may be very common in cases where a\n       * loading dependency resolves from loading to having a value (thus\n       * possibly triggering a re-render), and React re-renders before the\n       * chained .then() functions run, thus starting a new execution as the\n       * dep has changed value. Without this check we will run the selector\n       * twice (once in the new execution and once again in this .then(), so\n       * this check is necessary to keep unnecessary re-executions to a\n       * minimum).\n       *\n       * Also note this code does not check across all executions that may be\n       * running. It only optimizes for the _latest_ execution per store as\n       * we currently do not maintain a list of all currently running executions.\n       * This means in some cases we may run selectors more than strictly\n       * necessary when there are multiple executions running for the same\n       * selector. This may be a valid tradeoff as checking for dep changes\n       * across all in-progress executions may take longer than just\n       * re-running the selector. This will be app-dependent, and maybe in the\n       * future we can make the behavior configurable. An ideal fix may be\n       * to extend the tree cache to support caching loading states.\n       */\n\n\n      if (!isLatestExecution(store, executionID)) {\n        const executionInfo = getInProgressExecutionInfo(store, state);\n\n        if (executionInfo != null) {\n          /**\n           * Returning promise here without wrapping as the wrapper logic was\n           * already done upstream when this promise was generated.\n           */\n          return executionInfo.loadingLoadable.contents;\n        }\n      } // Retry the selector evaluation now that the dependency has resolved\n\n\n      const [loadable, depValues] = evaluateSelectorGetter(store, state, executionID);\n\n      if (loadable.state !== 'loading') {\n        resolveAsync(store, state, executionID, loadable, depValues);\n      }\n\n      if (loadable.state === 'hasError') {\n        throw loadable.contents;\n      }\n\n      return loadable.contents;\n    }).catch(error => {\n      // The selector was released since the request began; ignore the response.\n      if (error instanceof Canceled) {\n        throw CANCELED;\n      }\n\n      if (!selectorIsLive()) {\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      const loadable = loadableWithError$1(error);\n      resolveAsync(store, state, executionID, loadable, existingDeps);\n      throw error;\n    });\n  }\n\n  function updateDeps(store, state, deps, executionID) {\n    var _store$getState, _store$getState$curre, _store$getState2, _store$getState2$next;\n\n    if (isLatestExecution(store, executionID) || state.version === ((_store$getState = store.getState()) === null || _store$getState === void 0 ? void 0 : (_store$getState$curre = _store$getState.currentTree) === null || _store$getState$curre === void 0 ? void 0 : _store$getState$curre.version) || state.version === ((_store$getState2 = store.getState()) === null || _store$getState2 === void 0 ? void 0 : (_store$getState2$next = _store$getState2.nextTree) === null || _store$getState2$next === void 0 ? void 0 : _store$getState2$next.version)) {\n      var _store$getState$nextT, _store$getState3, _store$getState3$next;\n\n      saveDepsToStore$1(key, deps, store, (_store$getState$nextT = (_store$getState3 = store.getState()) === null || _store$getState3 === void 0 ? void 0 : (_store$getState3$next = _store$getState3.nextTree) === null || _store$getState3$next === void 0 ? void 0 : _store$getState3$next.version) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree.version);\n    }\n\n    for (const nodeKey of deps) {\n      discoveredDependencyNodeKeys.add(nodeKey);\n    }\n  }\n\n  function evaluateSelectorGetter(store, state, executionID) {\n    const endPerfBlock = startPerfBlock$1(key); // TODO T63965866: use execution ID here\n\n    let duringSynchronousExecution = true;\n    let duringAsynchronousExecution = true;\n\n    const finishEvaluation = () => {\n      endPerfBlock();\n      duringAsynchronousExecution = false;\n    };\n\n    let result;\n    let resultIsError = false;\n    let loadable;\n    const loadingDepsState = {\n      loadingDepKey: null,\n      loadingDepPromise: null\n    };\n    /**\n     * Starting a fresh set of deps that we'll be using to update state. We're\n     * starting a new set versus adding it in existing state deps because\n     * the version of state that we update deps for may be a more recent version\n     * than the version the selector was called with. This is because the latest\n     * execution will update the deps of the current/latest version of state\n     * (This is safe to do because the fact that the selector is the latest\n     * execution means the deps we discover below are our best guess at the\n     * deps for the current/latest state in the store)\n     */\n\n    const depValues = new Map();\n\n    function getRecoilValue({\n      key: depKey\n    }) {\n      const depLoadable = getNodeLoadable$2(store, state, depKey);\n      depValues.set(depKey, depLoadable); // We need to update asynchronous dependencies as we go so the selector\n      // knows if it has to restart evaluation if one of them is updated before\n      // the asynchronous selector completely resolves.\n\n      if (!duringSynchronousExecution) {\n        updateDeps(store, state, new Set(depValues.keys()), executionID);\n        notifyStoresOfNewAsyncDep(store, executionID);\n      }\n\n      switch (depLoadable.state) {\n        case 'hasValue':\n          return depLoadable.contents;\n\n        case 'hasError':\n          throw depLoadable.contents;\n\n        case 'loading':\n          loadingDepsState.loadingDepKey = depKey;\n          loadingDepsState.loadingDepPromise = depLoadable.contents;\n          throw depLoadable.contents;\n      }\n\n      throw Recoil_err('Invalid Loadable state');\n    }\n\n    const getCallback = fn => {\n      return (...args) => {\n        if (duringAsynchronousExecution) {\n          throw Recoil_err('Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.');\n        }\n\n        !(recoilValue != null) ?  true ? Recoil_invariant(false, 'Recoil Value can never be null') : 0 : void 0;\n        return recoilCallback$1(store, fn, args, {\n          node: recoilValue\n        } // flowlint-line unclear-type:off\n        );\n      };\n    };\n\n    try {\n      result = get({\n        get: getRecoilValue,\n        getCallback\n      });\n      result = isRecoilValue$3(result) ? getRecoilValue(result) : result;\n\n      if (isLoadable$1(result)) {\n        if (result.state === 'hasError') {\n          resultIsError = true;\n        }\n\n        result = result.contents;\n      }\n\n      if (Recoil_isPromise(result)) {\n        result = wrapResultPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);\n      } else {\n        finishEvaluation();\n      }\n\n      result = result instanceof WrappedValue$1 ? result.value : result;\n    } catch (errorOrDepPromise) {\n      result = errorOrDepPromise;\n\n      if (Recoil_isPromise(result)) {\n        result = wrapPendingDependencyPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);\n      } else {\n        resultIsError = true;\n        finishEvaluation();\n      }\n    }\n\n    if (resultIsError) {\n      loadable = loadableWithError$1(result);\n    } else if (Recoil_isPromise(result)) {\n      loadable = loadableWithPromise$1(result);\n    } else {\n      loadable = loadableWithValue$2(result);\n    }\n\n    duringSynchronousExecution = false;\n    updateExecutionInfoDepValues(store, executionID, depValues);\n    updateDeps(store, state, new Set(depValues.keys()), executionID);\n    return [loadable, depValues];\n  }\n\n  function getLoadableFromCacheAndUpdateDeps(store, state) {\n    // First, look up in the state cache\n    // If it's here, then the deps in the store should already be valid.\n    let cachedLoadable = state.atomValues.get(key);\n\n    if (cachedLoadable != null) {\n      return cachedLoadable;\n    } // Second, look up in the selector cache and update the deps in the store\n\n\n    const depsAfterCacheLookup = new Set();\n\n    try {\n      cachedLoadable = cache.get(nodeKey => {\n        !(typeof nodeKey === 'string') ?  true ? Recoil_invariant(false, 'Cache nodeKey is type string') : 0 : void 0;\n        return getNodeLoadable$2(store, state, nodeKey).contents;\n      }, {\n        onNodeVisit: node => {\n          if (node.type === 'branch' && node.nodeKey !== key) {\n            depsAfterCacheLookup.add(node.nodeKey);\n          }\n        }\n      });\n    } catch (error) {\n      throw Recoil_err(`Problem with cache lookup for selector \"${key}\": ${error.message}`);\n    }\n\n    if (cachedLoadable) {\n      var _getExecutionInfo; // Cache the results in the state to allow for cheaper lookup than\n      // iterating the tree cache of dependencies.\n\n\n      state.atomValues.set(key, cachedLoadable);\n      /**\n       * Ensure store contains correct dependencies if we hit the cache so that\n       * the store deps and cache are in sync for a given state. This is important\n       * because store deps are normally updated when new executions are created,\n       * but cache hits don't trigger new executions but they still _may_ signify\n       * a change in deps in the store if the store deps for this state are empty\n       * or stale.\n       */\n\n      updateDeps(store, state, depsAfterCacheLookup, (_getExecutionInfo = getExecutionInfo(store)) === null || _getExecutionInfo === void 0 ? void 0 : _getExecutionInfo.executionID);\n    }\n\n    return cachedLoadable;\n  }\n  /**\n   * Given a tree state, this function returns a Loadable of the current state.\n   *\n   * The selector's get() function will only be re-evaluated if _both_ of the\n   * following statements are true:\n   *\n   * 1. The current dep values from the given state produced a cache key that\n   *    was not found in the cache.\n   * 2. There is no currently running async execution OR there is an\n   *    async execution that is running, but after comparing the dep values in\n   *    the given state with the dep values that the execution has discovered so\n   *    far we find that at least one dep value has changed, in which case we\n   *    start a new execution (the previously running execution will continue to\n   *    run to completion, but only the new execution will be deemed the\n   *    'latest' execution, meaning it will be the only execution that will\n   *    update global state when it is finished. Any non-latest executions will\n   *    run to completion and update the selector cache but not global state).\n   */\n\n\n  function getSelectorLoadableAndUpdateDeps(store, state) {\n    // First, see if our current state is cached\n    const cachedVal = getLoadableFromCacheAndUpdateDeps(store, state);\n\n    if (cachedVal != null) {\n      clearExecutionInfo(store);\n      return cachedVal;\n    } // Second, check if there is already an ongoing execution based on the current state\n\n\n    const inProgressExecutionInfo = getInProgressExecutionInfo(store, state);\n\n    if (inProgressExecutionInfo != null) {\n      var _inProgressExecutionI;\n\n      if (((_inProgressExecutionI = inProgressExecutionInfo.loadingLoadable) === null || _inProgressExecutionI === void 0 ? void 0 : _inProgressExecutionI.state) === 'loading') {\n        markStoreWaitingForResolvedAsync(store, inProgressExecutionInfo.executionID);\n      } // FIXME: check after the fact to see if we made the right choice by waiting\n\n\n      return inProgressExecutionInfo.loadingLoadable;\n    } // Third, start a new evaluation of the selector\n\n\n    const newExecutionID = getNewExecutionID();\n    const [loadable, newDepValues] = evaluateSelectorGetter(store, state, newExecutionID);\n    /**\n     * Conditionally updates the cache with a given loadable.\n     *\n     * We only cache loadables that are not loading because our cache keys are\n     * based on dep values, which are in an unfinished state for loadables that\n     * have a 'loading' state (new deps may be discovered while the selector\n     * runs its async code). We never want to cache partial dependencies b/c it\n     * could lead to errors, such as prematurely returning the result based on a\n     * partial list of deps-- we need the full list of deps to ensure that we\n     * are returning the correct result from cache.\n     */\n\n    if (loadable.state === 'loading') {\n      setExecutionInfo(store, newExecutionID, loadable, newDepValues, state);\n      markStoreWaitingForResolvedAsync(store, newExecutionID);\n    } else {\n      clearExecutionInfo(store);\n      setCache(state, loadable, newDepValues);\n    }\n\n    return loadable;\n  }\n  /**\n   * Searches execution info across all stores to see if there is an in-progress\n   * execution whose dependency values match the values of the requesting store.\n   */\n\n\n  function getInProgressExecutionInfo(store, state) {\n    // Sort the pending executions so that our current store is checked first.\n    const pendingExecutions = Recoil_concatIterables([executionInfoMap.has(store) ? [Recoil_nullthrows(executionInfoMap.get(store))] : [], Recoil_mapIterable(Recoil_filterIterable(executionInfoMap, ([s]) => s !== store), ([, execInfo]) => execInfo)]);\n\n    function anyDepChanged(execDepValues) {\n      for (const [depKey, execLoadable] of execDepValues) {\n        if (!getNodeLoadable$2(store, state, depKey).is(execLoadable)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    for (const execInfo of pendingExecutions) {\n      if ( // If this execution was already checked to be valid with this version\n      // of state, then let's use it!\n      execInfo.stateVersions.get(state.version) || // If the deps for the execution match our current state, then it's valid\n      !anyDepChanged(execInfo.depValuesDiscoveredSoFarDuringAsyncWork)) {\n        execInfo.stateVersions.set(state.version, true);\n        return execInfo;\n      } else {\n        execInfo.stateVersions.set(state.version, false);\n      }\n    }\n\n    return undefined;\n  }\n\n  function getExecutionInfo(store) {\n    return executionInfoMap.get(store);\n  }\n  /**\n   * This function will update the selector's execution info when the selector\n   * has either finished running an execution or has started a new execution. If\n   * the given loadable is in a 'loading' state, the intention is that a new\n   * execution has started. Otherwise, the intention is that an execution has\n   * just finished.\n   */\n\n\n  function setExecutionInfo(store, newExecutionID, loadable, depValues, state) {\n    executionInfoMap.set(store, {\n      depValuesDiscoveredSoFarDuringAsyncWork: depValues,\n      executionID: newExecutionID,\n      loadingLoadable: loadable,\n      stateVersions: new Map([[state.version, true]])\n    });\n  }\n\n  function updateExecutionInfoDepValues(store, executionID, depValues) {\n    // We only need to bother updating the deps for the latest execution because\n    // that's all getInProgressExecutionInfo() will be looking for.\n    if (isLatestExecution(store, executionID)) {\n      const executionInfo = getExecutionInfo(store);\n\n      if (executionInfo != null) {\n        executionInfo.depValuesDiscoveredSoFarDuringAsyncWork = depValues;\n      }\n    }\n  }\n\n  function clearExecutionInfo(store) {\n    executionInfoMap.delete(store);\n  }\n\n  function isLatestExecution(store, executionID) {\n    var _getExecutionInfo2;\n\n    return executionID === ((_getExecutionInfo2 = getExecutionInfo(store)) === null || _getExecutionInfo2 === void 0 ? void 0 : _getExecutionInfo2.executionID);\n  }\n  /**\n   * FIXME: dep keys should take into account the state of the loadable to\n   * prevent the edge case where a loadable with an error and a loadable with\n   * an error as a value are treated as the same thing incorrectly. For example\n   * these two should be treated differently:\n   *\n   * selector({key: '', get: () => new Error('hi')});\n   * selector({key: '', get () => {throw new Error('hi')}});\n   *\n   * With current implementation they are treated the same\n   */\n\n\n  function depValuesToDepRoute(depValues) {\n    return Array.from(depValues.entries()).map(([depKey, valLoadable]) => [depKey, valLoadable.contents]);\n  }\n\n  function setCache(state, loadable, depValues) {\n    if (true) {\n      if (loadable.state !== 'loading' && Boolean(options.dangerouslyAllowMutability) === false) {\n        Recoil_deepFreezeValue(loadable.contents);\n      }\n    }\n\n    state.atomValues.set(key, loadable);\n\n    try {\n      cache.set(depValuesToDepRoute(depValues), loadable);\n    } catch (error) {\n      throw Recoil_err(`Problem with setting cache for selector \"${key}\": ${error.message}`);\n    }\n  }\n\n  function detectCircularDependencies(fn) {\n    if (dependencyStack.includes(key)) {\n      const message = `Recoil selector has circular dependencies: ${dependencyStack.slice(dependencyStack.indexOf(key)).join(' \\u2192 ')}`;\n      return loadableWithError$1(Recoil_err(message));\n    }\n\n    dependencyStack.push(key);\n\n    try {\n      return fn();\n    } finally {\n      dependencyStack.pop();\n    }\n  }\n\n  function selectorPeek(store, state) {\n    const cachedLoadable = state.atomValues.get(key);\n\n    if (cachedLoadable != null) {\n      return cachedLoadable;\n    }\n\n    return cache.get(nodeKey => {\n      var _peekNodeLoadable;\n\n      !(typeof nodeKey === 'string') ?  true ? Recoil_invariant(false, 'Cache nodeKey is type string') : 0 : void 0;\n      return (_peekNodeLoadable = peekNodeLoadable$1(store, state, nodeKey)) === null || _peekNodeLoadable === void 0 ? void 0 : _peekNodeLoadable.contents;\n    });\n  }\n\n  function selectorGet(store, state) {\n    return detectCircularDependencies(() => getSelectorLoadableAndUpdateDeps(store, state));\n  }\n\n  function invalidateSelector(state) {\n    state.atomValues.delete(key);\n  }\n\n  function clearSelectorCache(store, treeState) {\n    !(recoilValue != null) ?  true ? Recoil_invariant(false, 'Recoil Value can never be null') : 0 : void 0;\n\n    for (const nodeKey of discoveredDependencyNodeKeys) {\n      var _node$clearCache;\n\n      const node = getNode$6(nodeKey);\n      (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, treeState);\n    }\n\n    discoveredDependencyNodeKeys.clear();\n    invalidateSelector(treeState);\n    cache.clear();\n    markRecoilValueModified$1(store, recoilValue);\n  }\n\n  if (set != null) {\n    /**\n     * ES5 strict mode prohibits defining non-top-level function declarations,\n     * so don't use function declaration syntax here\n     */\n    const selectorSet = (store, state, newValue) => {\n      let syncSelectorSetFinished = false;\n      const writes = new Map();\n\n      function getRecoilValue({\n        key: depKey\n      }) {\n        if (syncSelectorSetFinished) {\n          throw Recoil_err('Recoil: Async selector sets are not currently supported.');\n        }\n\n        const loadable = getNodeLoadable$2(store, state, depKey);\n\n        if (loadable.state === 'hasValue') {\n          return loadable.contents;\n        } else if (loadable.state === 'loading') {\n          const msg = `Getting value of asynchronous atom or selector \"${depKey}\" in a pending state while setting selector \"${key}\" is not yet supported.`;\n          Recoil_recoverableViolation(msg);\n          throw Recoil_err(msg);\n        } else {\n          throw loadable.contents;\n        }\n      }\n\n      function setRecoilState(recoilState, valueOrUpdater) {\n        if (syncSelectorSetFinished) {\n          const msg = 'Recoil: Async selector sets are not currently supported.';\n          Recoil_recoverableViolation(msg);\n          throw Recoil_err(msg);\n        }\n\n        const setValue = typeof valueOrUpdater === 'function' ? // cast to any because we can't restrict type S from being a function itself without losing support for opaque types\n        // flowlint-next-line unclear-type:off\n        valueOrUpdater(getRecoilValue(recoilState)) : valueOrUpdater;\n        const upstreamWrites = setNodeValue$3(store, state, recoilState.key, setValue);\n        upstreamWrites.forEach((v, k) => writes.set(k, v));\n      }\n\n      function resetRecoilState(recoilState) {\n        setRecoilState(recoilState, DEFAULT_VALUE$6);\n      }\n\n      const ret = set({\n        set: setRecoilState,\n        get: getRecoilValue,\n        reset: resetRecoilState\n      }, newValue); // set should be a void method, but if the user makes it `async`, then it\n      // will return a Promise, which we don't currently support.\n\n      if (ret !== undefined) {\n        throw Recoil_isPromise(ret) ? Recoil_err('Recoil: Async selector sets are not currently supported.') : Recoil_err('Recoil: selector set should be a void function.');\n      }\n\n      syncSelectorSetFinished = true;\n      return writes;\n    };\n\n    return recoilValue = registerNode$1({\n      key,\n      nodeType: 'selector',\n      peek: selectorPeek,\n      get: selectorGet,\n      set: selectorSet,\n      init: selectorInit,\n      invalidate: invalidateSelector,\n      clearCache: clearSelectorCache,\n      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,\n      dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n      shouldRestoreFromSnapshots: false,\n      retainedBy\n    });\n  } else {\n    return recoilValue = registerNode$1({\n      key,\n      nodeType: 'selector',\n      peek: selectorPeek,\n      get: selectorGet,\n      init: selectorInit,\n      invalidate: invalidateSelector,\n      clearCache: clearSelectorCache,\n      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,\n      dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n      shouldRestoreFromSnapshots: false,\n      retainedBy\n    });\n  }\n}\n/* eslint-enable no-redeclare */\n// $FlowIssue[incompatible-use]\n\n\nselector.value = value => new WrappedValue$1(value);\n\nvar Recoil_selector = selector; // @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';\n// @fb-only: const {scopedAtom} = require('Recoil_ScopedAtom');\n\nconst {\n  isLoadable: isLoadable$2,\n  loadableWithError: loadableWithError$2,\n  loadableWithPromise: loadableWithPromise$2,\n  loadableWithValue: loadableWithValue$3\n} = Recoil_Loadable$1;\nconst {\n  WrappedValue: WrappedValue$2\n} = Recoil_Wrapper$1;\nconst {\n  peekNodeInfo: peekNodeInfo$3\n} = Recoil_FunctionalCore;\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$7,\n  DefaultValue: DefaultValue$2,\n  getConfigDeletionHandler: getConfigDeletionHandler$2,\n  registerNode: registerNode$2,\n  setConfigDeletionHandler: setConfigDeletionHandler$1\n} = Recoil_Node;\nconst {\n  isRecoilValue: isRecoilValue$4\n} = Recoil_RecoilValue$1;\nconst {\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$4,\n  markRecoilValueModified: markRecoilValueModified$2,\n  setRecoilValue: setRecoilValue$4,\n  setRecoilValueLoadable: setRecoilValueLoadable$2\n} = Recoil_RecoilValueInterface;\nconst {\n  retainedByOptionWithDefault: retainedByOptionWithDefault$2\n} = Recoil_Retention;\n\nconst unwrap = x => x instanceof WrappedValue$2 ? x.value : x;\n\nfunction baseAtom(options) {\n  const {\n    key,\n    persistence_UNSTABLE: persistence\n  } = options;\n  const retainedBy = retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE);\n  let liveStoresCount = 0;\n\n  function unwrapPromise(promise) {\n    return loadableWithPromise$2(promise.then(value => {\n      defaultLoadable = loadableWithValue$3(value);\n      return value;\n    }).catch(error => {\n      defaultLoadable = loadableWithError$2(error);\n      throw error;\n    }));\n  }\n\n  let defaultLoadable = Recoil_isPromise(options.default) ? unwrapPromise(options.default) : isLoadable$2(options.default) ? options.default.state === 'loading' ? unwrapPromise(options.default.contents) : options.default : loadableWithValue$3(unwrap(options.default));\n  maybeFreezeValueOrPromise(defaultLoadable.contents);\n  let cachedAnswerForUnvalidatedValue = undefined; // Cleanup handlers for this atom\n  // Rely on stable reference equality of the store to use it as a key per <RecoilRoot>\n\n  const cleanupEffectsByStore = new Map();\n\n  function maybeFreezeValueOrPromise(valueOrPromise) {\n    if (true) {\n      if (options.dangerouslyAllowMutability !== true) {\n        if (Recoil_isPromise(valueOrPromise)) {\n          return valueOrPromise.then(value => {\n            Recoil_deepFreezeValue(value);\n            return value;\n          });\n        } else {\n          Recoil_deepFreezeValue(valueOrPromise);\n          return valueOrPromise;\n        }\n      }\n    }\n\n    return valueOrPromise;\n  }\n\n  function wrapPendingPromise(store, promise) {\n    const wrappedPromise = promise.then(value => {\n      var _store$getState$nextT, _state$atomValues$get;\n\n      const state = (_store$getState$nextT = store.getState().nextTree) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree;\n\n      if (((_state$atomValues$get = state.atomValues.get(key)) === null || _state$atomValues$get === void 0 ? void 0 : _state$atomValues$get.contents) === wrappedPromise) {\n        setRecoilValue$4(store, node, value);\n      }\n\n      return value;\n    }).catch(error => {\n      var _store$getState$nextT2, _state$atomValues$get2;\n\n      const state = (_store$getState$nextT2 = store.getState().nextTree) !== null && _store$getState$nextT2 !== void 0 ? _store$getState$nextT2 : store.getState().currentTree;\n\n      if (((_state$atomValues$get2 = state.atomValues.get(key)) === null || _state$atomValues$get2 === void 0 ? void 0 : _state$atomValues$get2.contents) === wrappedPromise) {\n        setRecoilValueLoadable$2(store, node, loadableWithError$2(error));\n      }\n\n      throw error;\n    });\n    return wrappedPromise;\n  }\n\n  function initAtom(store, initState, trigger) {\n    var _options$effects;\n\n    liveStoresCount++;\n\n    const cleanupAtom = () => {\n      var _cleanupEffectsByStor;\n\n      liveStoresCount--;\n      (_cleanupEffectsByStor = cleanupEffectsByStore.get(store)) === null || _cleanupEffectsByStor === void 0 ? void 0 : _cleanupEffectsByStor.forEach(cleanup => cleanup());\n      cleanupEffectsByStore.delete(store);\n    };\n\n    store.getState().knownAtoms.add(key); // Setup async defaults to notify subscribers when they resolve\n\n    if (defaultLoadable.state === 'loading') {\n      const notifyDefaultSubscribers = () => {\n        var _store$getState$nextT3;\n\n        const state = (_store$getState$nextT3 = store.getState().nextTree) !== null && _store$getState$nextT3 !== void 0 ? _store$getState$nextT3 : store.getState().currentTree;\n\n        if (!state.atomValues.has(key)) {\n          markRecoilValueModified$2(store, node);\n        }\n      };\n\n      defaultLoadable.contents.finally(notifyDefaultSubscribers);\n    } ///////////////////\n    // Run Atom Effects\n    ///////////////////\n\n\n    const effects = (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE;\n\n    if (effects != null) {\n      // This state is scoped by Store, since this is in the initAtom() closure\n      let initValue = DEFAULT_VALUE$7;\n      let isDuringInit = true;\n      let isInitError = false;\n      let pendingSetSelf = null;\n\n      function getLoadable(recoilValue) {\n        // Normally we can just get the current value of another atom.\n        // But for our own value we need to check if there is a pending\n        // initialized value or get the fallback default value.\n        if (isDuringInit && recoilValue.key === key) {\n          // Cast T to S\n          const retValue = initValue; // flowlint-line unclear-type:off\n\n          return retValue instanceof DefaultValue$2 ? peekAtom(store, initState) // flowlint-line unclear-type:off\n          : Recoil_isPromise(retValue) ? loadableWithPromise$2(retValue.then(v => v instanceof DefaultValue$2 ? // Cast T to S\n          defaultLoadable.toPromise() // flowlint-line unclear-type:off\n          : v)) : loadableWithValue$3(retValue);\n        }\n\n        return getRecoilValueAsLoadable$4(store, recoilValue);\n      }\n\n      function getPromise(recoilValue) {\n        return getLoadable(recoilValue).toPromise();\n      }\n\n      function getInfo_UNSTABLE(recoilValue) {\n        var _store$getState$nextT4;\n\n        const info = peekNodeInfo$3(store, (_store$getState$nextT4 = store.getState().nextTree) !== null && _store$getState$nextT4 !== void 0 ? _store$getState$nextT4 : store.getState().currentTree, recoilValue.key);\n        return isDuringInit && recoilValue.key === key && !(initValue instanceof DefaultValue$2) ? { ...info,\n          isSet: true,\n          loadable: getLoadable(recoilValue)\n        } : info;\n      }\n\n      const setSelf = effect => valueOrUpdater => {\n        if (isDuringInit) {\n          const currentLoadable = getLoadable(node);\n          const currentValue = currentLoadable.state === 'hasValue' ? currentLoadable.contents : DEFAULT_VALUE$7;\n          initValue = typeof valueOrUpdater === 'function' ? // cast to any because we can't restrict T from being a function without losing support for opaque types\n          valueOrUpdater(currentValue) // flowlint-line unclear-type:off\n          : valueOrUpdater;\n\n          if (Recoil_isPromise(initValue)) {\n            initValue = initValue.then(value => {\n              // Avoid calling onSet() when setSelf() initializes with a Promise\n              pendingSetSelf = {\n                effect,\n                value\n              };\n              return value;\n            });\n          }\n        } else {\n          if (Recoil_isPromise(valueOrUpdater)) {\n            throw Recoil_err('Setting atoms to async values is not implemented.');\n          }\n\n          if (typeof valueOrUpdater !== 'function') {\n            pendingSetSelf = {\n              effect,\n              value: unwrap(valueOrUpdater)\n            };\n          }\n\n          setRecoilValue$4(store, node, typeof valueOrUpdater === 'function' ? currentValue => {\n            const newValue = unwrap( // cast to any because we can't restrict T from being a function without losing support for opaque types\n            valueOrUpdater(currentValue) // flowlint-line unclear-type:off\n            );\n            pendingSetSelf = {\n              effect,\n              value: newValue\n            };\n            return newValue;\n          } : unwrap(valueOrUpdater));\n        }\n      };\n\n      const resetSelf = effect => () => setSelf(effect)(DEFAULT_VALUE$7);\n\n      const onSet = effect => handler => {\n        var _cleanupEffectsByStor2;\n\n        const {\n          release\n        } = store.subscribeToTransactions(currentStore => {\n          var _currentTree$atomValu; // eslint-disable-next-line prefer-const\n\n\n          let {\n            currentTree,\n            previousTree\n          } = currentStore.getState();\n\n          if (!previousTree) {\n            Recoil_recoverableViolation('Transaction subscribers notified without a next tree being present -- this is a bug in Recoil');\n            previousTree = currentTree; // attempt to trundle on\n          }\n\n          const newLoadable = (_currentTree$atomValu = currentTree.atomValues.get(key)) !== null && _currentTree$atomValu !== void 0 ? _currentTree$atomValu : defaultLoadable;\n\n          if (newLoadable.state === 'hasValue') {\n            var _previousTree$atomVal, _pendingSetSelf, _pendingSetSelf2, _pendingSetSelf3;\n\n            const newValue = newLoadable.contents;\n            const oldLoadable = (_previousTree$atomVal = previousTree.atomValues.get(key)) !== null && _previousTree$atomVal !== void 0 ? _previousTree$atomVal : defaultLoadable;\n            const oldValue = oldLoadable.state === 'hasValue' ? oldLoadable.contents : DEFAULT_VALUE$7; // TODO This isn't actually valid, use as a placeholder for now.\n            // Ignore atom value changes that were set via setSelf() in the same effect.\n            // We will still properly call the handler if there was a subsequent\n            // set from something other than an atom effect which was batched\n            // with the `setSelf()` call.  However, we may incorrectly ignore\n            // the handler if the subsequent batched call happens to set the\n            // atom to the exact same value as the `setSelf()`.   But, in that\n            // case, it was kind of a noop, so the semantics are debatable..\n\n            if (((_pendingSetSelf = pendingSetSelf) === null || _pendingSetSelf === void 0 ? void 0 : _pendingSetSelf.effect) !== effect || ((_pendingSetSelf2 = pendingSetSelf) === null || _pendingSetSelf2 === void 0 ? void 0 : _pendingSetSelf2.value) !== newValue) {\n              handler(newValue, oldValue, !currentTree.atomValues.has(key));\n            } else if (((_pendingSetSelf3 = pendingSetSelf) === null || _pendingSetSelf3 === void 0 ? void 0 : _pendingSetSelf3.effect) === effect) {\n              pendingSetSelf = null;\n            }\n          }\n        }, key);\n        cleanupEffectsByStore.set(store, [...((_cleanupEffectsByStor2 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor2 !== void 0 ? _cleanupEffectsByStor2 : []), release]);\n      };\n\n      for (const effect of effects) {\n        try {\n          const cleanup = effect({\n            node,\n            storeID: store.storeID,\n            parentStoreID_UNSTABLE: store.parentStoreID,\n            trigger,\n            setSelf: setSelf(effect),\n            resetSelf: resetSelf(effect),\n            onSet: onSet(effect),\n            getPromise,\n            getLoadable,\n            getInfo_UNSTABLE\n          });\n\n          if (cleanup != null) {\n            var _cleanupEffectsByStor3;\n\n            cleanupEffectsByStore.set(store, [...((_cleanupEffectsByStor3 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor3 !== void 0 ? _cleanupEffectsByStor3 : []), cleanup]);\n          }\n        } catch (error) {\n          initValue = error;\n          isInitError = true;\n        }\n      }\n\n      isDuringInit = false; // Mutate initial state in place since we know there are no other subscribers\n      // since we are the ones initializing on first use.\n\n      if (!(initValue instanceof DefaultValue$2)) {\n        var _store$getState$nextT5;\n\n        const initLoadable = isInitError ? loadableWithError$2(initValue) : Recoil_isPromise(initValue) ? loadableWithPromise$2(wrapPendingPromise(store, initValue)) : loadableWithValue$3(unwrap(initValue));\n        maybeFreezeValueOrPromise(initLoadable.contents);\n        initState.atomValues.set(key, initLoadable); // If there is a pending transaction, then also mutate the next state tree.\n        // This could happen if the atom was first initialized in an action that\n        // also updated some other atom's state.\n\n        (_store$getState$nextT5 = store.getState().nextTree) === null || _store$getState$nextT5 === void 0 ? void 0 : _store$getState$nextT5.atomValues.set(key, initLoadable);\n      }\n    }\n\n    return cleanupAtom;\n  }\n\n  function peekAtom(_store, state) {\n    var _ref, _state$atomValues$get3;\n\n    return (_ref = (_state$atomValues$get3 = state.atomValues.get(key)) !== null && _state$atomValues$get3 !== void 0 ? _state$atomValues$get3 : cachedAnswerForUnvalidatedValue) !== null && _ref !== void 0 ? _ref : defaultLoadable;\n  }\n\n  function getAtom(_store, state) {\n    if (state.atomValues.has(key)) {\n      // Atom value is stored in state:\n      return Recoil_nullthrows(state.atomValues.get(key));\n    } else if (state.nonvalidatedAtoms.has(key)) {\n      // Atom value is stored but needs validation before use.\n      // We might have already validated it and have a cached validated value:\n      if (cachedAnswerForUnvalidatedValue != null) {\n        return cachedAnswerForUnvalidatedValue;\n      }\n\n      if (persistence == null) {\n        Recoil_expectationViolation(`Tried to restore a persisted value for atom ${key} but it has no persistence settings.`);\n        return defaultLoadable;\n      }\n\n      const nonvalidatedValue = state.nonvalidatedAtoms.get(key);\n      const validatorResult = persistence.validator(nonvalidatedValue, DEFAULT_VALUE$7);\n      const validatedValueLoadable = validatorResult instanceof DefaultValue$2 ? defaultLoadable : loadableWithValue$3(validatorResult);\n      cachedAnswerForUnvalidatedValue = validatedValueLoadable;\n      return cachedAnswerForUnvalidatedValue;\n    } else {\n      return defaultLoadable;\n    }\n  }\n\n  function invalidateAtom() {\n    cachedAnswerForUnvalidatedValue = undefined;\n  }\n\n  function setAtom(_store, state, newValue) {\n    // Bail out if we're being set to the existing value, or if we're being\n    // reset but have no stored value (validated or unvalidated) to reset from:\n    if (state.atomValues.has(key)) {\n      const existing = Recoil_nullthrows(state.atomValues.get(key));\n\n      if (existing.state === 'hasValue' && newValue === existing.contents) {\n        return new Map();\n      }\n    } else if (!state.nonvalidatedAtoms.has(key) && newValue instanceof DefaultValue$2) {\n      return new Map();\n    }\n\n    maybeFreezeValueOrPromise(newValue);\n    cachedAnswerForUnvalidatedValue = undefined; // can be released now if it was previously in use\n\n    return new Map().set(key, loadableWithValue$3(newValue));\n  }\n\n  function shouldDeleteConfigOnReleaseAtom() {\n    return getConfigDeletionHandler$2(key) !== undefined && liveStoresCount <= 0;\n  }\n\n  const node = registerNode$2({\n    key,\n    nodeType: 'atom',\n    peek: peekAtom,\n    get: getAtom,\n    set: setAtom,\n    init: initAtom,\n    invalidate: invalidateAtom,\n    shouldDeleteConfigOnRelease: shouldDeleteConfigOnReleaseAtom,\n    dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n    persistence_UNSTABLE: options.persistence_UNSTABLE ? {\n      type: options.persistence_UNSTABLE.type,\n      backButton: options.persistence_UNSTABLE.backButton\n    } : undefined,\n    shouldRestoreFromSnapshots: true,\n    retainedBy\n  });\n  return node;\n} // prettier-ignore\n\n\nfunction atom(options) {\n  if (true) {\n    if (typeof options.key !== 'string') {\n      throw Recoil_err('A key option with a unique string value must be provided when creating an atom.');\n    }\n  }\n\n  const { // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n    ...restOptions\n  } = options;\n  const optionsDefault = 'default' in options ? // $FlowIssue[prop-missing] No way to refine in Flow that property is not defined\n  // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined\n  options.default : new Promise(() => {});\n\n  if (isRecoilValue$4(optionsDefault) // Continue to use atomWithFallback for promise defaults for scoped atoms\n  // for now, since scoped atoms don't support async defaults\n  // @fb-only: || (isPromise(optionsDefault) && scopeRules_APPEND_ONLY_READ_THE_DOCS)\n  // @fb-only: || (isLoadable(optionsDefault) && scopeRules_APPEND_ONLY_READ_THE_DOCS)\n  ) {\n    return atomWithFallback({ ...restOptions,\n      default: optionsDefault // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n\n    }); // @fb-only: } else if (scopeRules_APPEND_ONLY_READ_THE_DOCS\n    // @fb-only: && !isPromise(optionsDefault)\n    // @fb-only: && !isLoadable(optionsDefault)\n    // @fb-only: ) {\n    // @fb-only: return scopedAtom<T>({\n    // @fb-only: ...restOptions,\n    // @fb-only: default: unwrap<T>(optionsDefault),\n    // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n    // @fb-only: });\n  } else {\n    return baseAtom({ ...restOptions,\n      default: optionsDefault\n    });\n  }\n}\n\nfunction atomWithFallback(options) {\n  const base = atom({ ...options,\n    default: DEFAULT_VALUE$7,\n    persistence_UNSTABLE: options.persistence_UNSTABLE === undefined ? undefined : { ...options.persistence_UNSTABLE,\n      validator: storedValue => storedValue instanceof DefaultValue$2 ? storedValue : Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue, DEFAULT_VALUE$7)\n    },\n    // TODO Hack for now.\n    effects: options.effects,\n    // flowlint-line unclear-type: off\n    effects_UNSTABLE: options.effects_UNSTABLE // flowlint-line unclear-type: off\n\n  });\n  const sel = Recoil_selector({\n    key: `${options.key}__withFallback`,\n    get: ({\n      get\n    }) => {\n      const baseValue = get(base);\n      return baseValue instanceof DefaultValue$2 ? options.default : baseValue;\n    },\n    set: ({\n      set\n    }, newValue) => set(base, newValue),\n    // This selector does not need to cache as it is a wrapper selector\n    // and the selector within the wrapper selector will have a cache\n    // option by default\n    cachePolicy_UNSTABLE: {\n      eviction: 'most-recent'\n    },\n    dangerouslyAllowMutability: options.dangerouslyAllowMutability\n  });\n  setConfigDeletionHandler$1(sel.key, getConfigDeletionHandler$2(options.key));\n  return sel;\n}\n\natom.value = value => new WrappedValue$2(value);\n\nvar Recoil_atom = atom;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nclass MapCache {\n  constructor(options) {\n    var _options$mapKey;\n\n    _defineProperty(this, \"_map\", void 0);\n\n    _defineProperty(this, \"_keyMapper\", void 0);\n\n    this._map = new Map();\n    this._keyMapper = (_options$mapKey = options === null || options === void 0 ? void 0 : options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : v => v;\n  }\n\n  size() {\n    return this._map.size;\n  }\n\n  has(key) {\n    return this._map.has(this._keyMapper(key));\n  }\n\n  get(key) {\n    return this._map.get(this._keyMapper(key));\n  }\n\n  set(key, val) {\n    this._map.set(this._keyMapper(key), val);\n  }\n\n  delete(key) {\n    this._map.delete(this._keyMapper(key));\n  }\n\n  clear() {\n    this._map.clear();\n  }\n\n}\n\nvar Recoil_MapCache = {\n  MapCache\n};\nvar Recoil_MapCache_1 = Recoil_MapCache.MapCache;\nvar Recoil_MapCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MapCache: Recoil_MapCache_1\n});\nconst {\n  LRUCache: LRUCache$2\n} = Recoil_LRUCache$1;\nconst {\n  MapCache: MapCache$1\n} = Recoil_MapCache$1;\nconst defaultPolicy$1 = {\n  equality: 'reference',\n  eviction: 'none',\n  maxSize: Infinity\n};\n\nfunction cacheFromPolicy({\n  equality = defaultPolicy$1.equality,\n  eviction = defaultPolicy$1.eviction,\n  maxSize = defaultPolicy$1.maxSize\n} = defaultPolicy$1) {\n  const valueMapper = getValueMapper$1(equality);\n  const cache = getCache(eviction, maxSize, valueMapper);\n  return cache;\n}\n\nfunction getValueMapper$1(equality) {\n  switch (equality) {\n    case 'reference':\n      return val => val;\n\n    case 'value':\n      return val => Recoil_stableStringify(val);\n  }\n\n  throw Recoil_err(`Unrecognized equality policy ${equality}`);\n}\n\nfunction getCache(eviction, maxSize, mapKey) {\n  switch (eviction) {\n    case 'keep-all':\n      return new MapCache$1({\n        mapKey\n      });\n\n    case 'lru':\n      return new LRUCache$2({\n        mapKey,\n        maxSize: Recoil_nullthrows(maxSize)\n      });\n\n    case 'most-recent':\n      return new LRUCache$2({\n        mapKey,\n        maxSize: 1\n      });\n  }\n\n  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);\n}\n\nvar Recoil_cacheFromPolicy = cacheFromPolicy; // @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';\n\nconst {\n  setConfigDeletionHandler: setConfigDeletionHandler$2\n} = Recoil_Node; // Process scopeRules to handle any entries which are functions taking parameters\n// prettier-ignore\n// @fb-only: function mapScopeRules<P>(\n// @fb-only: scopeRules?: ParameterizedScopeRules<P>,\n// @fb-only: param: P,\n// @fb-only: ): ScopeRules | void {\n// @fb-only: return scopeRules?.map(rule =>\n// @fb-only: Array.isArray(rule)\n// @fb-only: ? rule.map(entry => (typeof entry === 'function' ? entry(param) : entry))\n// @fb-only: : rule,\n// @fb-only: );\n// @fb-only: }\n\n/*\nA function which returns an atom based on the input parameter.\n\nEach unique parameter returns a unique atom. E.g.,\n\n  const f = atomFamily(...);\n  f({a: 1}) => an atom\n  f({a: 2}) => a different atom\n\nThis allows components to persist local, private state using atoms.  Each\ninstance of the component may have a different key, which it uses as the\nparameter for a family of atoms; in this way, each component will have\nits own atom not shared by other instances.  These state keys may be composed\ninto children's state keys as well.\n*/\n\nfunction atomFamily(options) {\n  var _options$cachePolicyF, _options$cachePolicyF2;\n\n  const atomCache = Recoil_cacheFromPolicy({\n    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : 'value',\n    eviction: 'keep-all'\n  }); // Simple atomFamily implementation to cache individual atoms based\n  // on the parameter value equality.\n\n  return params => {\n    var _stableStringify, _options$effects;\n\n    const cachedAtom = atomCache.get(params);\n\n    if (cachedAtom != null) {\n      return cachedAtom;\n    }\n\n    const {\n      cachePolicyForParams_UNSTABLE,\n      ...atomOptions\n    } = options;\n    const optionsDefault = 'default' in options ? // $FlowIssue[prop-missing] No way to refine in Flow that property is not defined\n    // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined\n    options.default : new Promise(() => {});\n    const newAtom = Recoil_atom({ ...atomOptions,\n      key: `${options.key}__${(_stableStringify = Recoil_stableStringify(params)) !== null && _stableStringify !== void 0 ? _stableStringify : 'void'}`,\n      default: typeof optionsDefault === 'function' ? // The default was parameterized\n      // Flow doesn't know that T isn't a function, so we need to case to any\n      // $FlowIssue[incompatible-use]\n      optionsDefault(params) : // Default may be a static value, promise, or RecoilValue\n      optionsDefault,\n      retainedBy_UNSTABLE: typeof options.retainedBy_UNSTABLE === 'function' ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE,\n      effects: typeof options.effects === 'function' ? options.effects(params) : typeof options.effects_UNSTABLE === 'function' ? options.effects_UNSTABLE(params) : (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE // prettier-ignore\n      // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS: mapScopeRules(\n      // @fb-only: options.scopeRules_APPEND_ONLY_READ_THE_DOCS,\n      // @fb-only: params,\n      // @fb-only: ),\n\n    });\n    atomCache.set(params, newAtom);\n    setConfigDeletionHandler$2(newAtom.key, () => {\n      atomCache.delete(params);\n    });\n    return newAtom;\n  };\n}\n\nvar Recoil_atomFamily = atomFamily;\nconst {\n  setConfigDeletionHandler: setConfigDeletionHandler$3\n} = Recoil_Node; // Keep in mind the parameter needs to be serializable as a cahche key\n// using Recoil_stableStringify\n// Add a unique index to each selector in case the cache implementation allows\n// duplicate keys based on equivalent stringified parameters\n\nlet nextIndex = 0;\n/* eslint-disable no-redeclare */\n// Return a function that returns members of a family of selectors of the same type\n// E.g.,\n//\n// const s = selectorFamily(...);\n// s({a: 1}) => a selector\n// s({a: 2}) => a different selector\n//\n// By default, the selectors are distinguished by distinct values of the\n// parameter based on value equality, not reference equality.  This allows using\n// object literals or other equivalent objects at callsites to not create\n// duplicate cache entries.  This behavior may be overridden with the\n// cacheImplementationForParams option.\n\nfunction selectorFamily(options) {\n  var _options$cachePolicyF, _options$cachePolicyF2;\n\n  const selectorCache = Recoil_cacheFromPolicy({\n    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : 'value',\n    eviction: 'keep-all'\n  });\n  return params => {\n    var _stableStringify; // Throw an error with selector key so that it is clear which\n    // selector is causing an error\n\n\n    let cachedSelector;\n\n    try {\n      cachedSelector = selectorCache.get(params);\n    } catch (error) {\n      throw Recoil_err(`Problem with cache lookup for selector ${options.key}: ${error.message}`);\n    }\n\n    if (cachedSelector != null) {\n      return cachedSelector;\n    }\n\n    const myKey = `${options.key}__selectorFamily/${(_stableStringify = Recoil_stableStringify(params, {\n      // It is possible to use functions in parameters if the user uses\n      // a cache with reference equality thanks to the incrementing index.\n      allowFunctions: true\n    })) !== null && _stableStringify !== void 0 ? _stableStringify : 'void'}/${nextIndex++}`; // Append index in case values serialize to the same key string\n\n    const myGet = callbacks => options.get(params)(callbacks);\n\n    const myCachePolicy = options.cachePolicy_UNSTABLE;\n    const retainedBy = typeof options.retainedBy_UNSTABLE === 'function' ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE;\n    let newSelector;\n\n    if (options.set != null) {\n      const set = options.set;\n\n      const mySet = (callbacks, newValue) => set(params)(callbacks, newValue);\n\n      newSelector = Recoil_selector({\n        key: myKey,\n        get: myGet,\n        set: mySet,\n        cachePolicy_UNSTABLE: myCachePolicy,\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n        retainedBy_UNSTABLE: retainedBy\n      });\n    } else {\n      newSelector = Recoil_selector({\n        key: myKey,\n        get: myGet,\n        cachePolicy_UNSTABLE: myCachePolicy,\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n        retainedBy_UNSTABLE: retainedBy\n      });\n    }\n\n    selectorCache.set(params, newSelector);\n    setConfigDeletionHandler$3(newSelector.key, () => {\n      selectorCache.delete(params);\n    });\n    return newSelector;\n  };\n}\n/* eslint-enable no-redeclare */\n\n\nvar Recoil_selectorFamily = selectorFamily; // flowlint-next-line unclear-type:off\n\nconst constantSelector = Recoil_selectorFamily({\n  key: '__constant',\n  get: constant => () => constant,\n  cachePolicyForParams_UNSTABLE: {\n    equality: 'reference'\n  }\n}); // Function that returns a selector which always produces the\n// same constant value.  It may be called multiple times with the\n// same value, based on reference equality, and will provide the\n// same selector.\n\nfunction constSelector(constant) {\n  return constantSelector(constant);\n}\n\nvar Recoil_constSelector = constSelector; // flowlint-next-line unclear-type:off\n\nconst throwingSelector = Recoil_selectorFamily({\n  key: '__error',\n  get: message => () => {\n    throw Recoil_err(message);\n  },\n  // TODO Why?\n  cachePolicyForParams_UNSTABLE: {\n    equality: 'reference'\n  }\n}); // Function that returns a selector which always throws an error\n// with the provided message.\n\nfunction errorSelector(message) {\n  return throwingSelector(message);\n}\n\nvar Recoil_errorSelector = errorSelector;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Wraps another recoil value and prevents writing to it.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction readOnlySelector(atom) {\n  // flowlint-next-line unclear-type: off\n  return atom;\n}\n\nvar Recoil_readOnlySelector = readOnlySelector;\nconst {\n  loadableWithError: loadableWithError$3,\n  loadableWithPromise: loadableWithPromise$3,\n  loadableWithValue: loadableWithValue$4\n} = Recoil_Loadable$1; /////////////////\n//  TRUTH TABLE\n/////////////////\n// Dependencies        waitForNone         waitForAny        waitForAll       waitForAllSettled\n//  [loading, loading]  [Promise, Promise]  Promise           Promise         Promise\n//  [value, loading]    [value, Promise]    [value, Promise]  Promise         Promise\n//  [value, value]      [value, value]      [value, value]    [value, value]  [value, value]\n//\n//  [error, loading]    [Error, Promise]    [Error, Promise]  Error           Promise\n//  [error, error]      [Error, Error]      [Error, Error]    Error           [error, error]\n//  [value, error]      [value, Error]      [value, Error]    Error           [value, error]\n// Issue parallel requests for all dependencies and return the current\n// status if they have results, have some error, or are still pending.\n\nfunction concurrentRequests(getRecoilValue, deps) {\n  const results = Array(deps.length).fill(undefined);\n  const exceptions = Array(deps.length).fill(undefined);\n\n  for (const [i, dep] of deps.entries()) {\n    try {\n      results[i] = getRecoilValue(dep);\n    } catch (e) {\n      // exceptions can either be Promises of pending results or real errors\n      exceptions[i] = e;\n    }\n  }\n\n  return [results, exceptions];\n}\n\nfunction isError(exp) {\n  return exp != null && !Recoil_isPromise(exp);\n}\n\nfunction unwrapDependencies(dependencies) {\n  return Array.isArray(dependencies) ? dependencies : Object.getOwnPropertyNames(dependencies).map(key => dependencies[key]);\n}\n\nfunction wrapResults(dependencies,\n/* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n * LTI update could not be added via codemod */\nresults) {\n  return Array.isArray(dependencies) ? results : // Object.getOwnPropertyNames() has consistent key ordering with ES6\n  Object.getOwnPropertyNames(dependencies).reduce((out, key, idx) => ({ ...out,\n    [key]: results[idx]\n  }), {});\n}\n\nfunction wrapLoadables(dependencies, results, exceptions) {\n  const output = exceptions.map((exception, idx) => exception == null ? loadableWithValue$4(results[idx]) : Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));\n  return wrapResults(dependencies, output);\n}\n\nfunction combineAsyncResultsWithSyncResults(syncResults, asyncResults) {\n  return asyncResults.map((result, idx) =>\n  /**\n   * it's important we use === undefined as opposed to == null, because the\n   * resolved value of the async promise could be `null`, in which case we\n   * don't want to use syncResults[idx], which would be undefined. If async\n   * promise resolves to `undefined`, that's ok because `syncResults[idx]`\n   * will also be `undefined`. That's a little hacky, but it works.\n   */\n  result === undefined ? syncResults[idx] : result);\n} // Selector that requests all dependencies in parallel and immediately returns\n// current results without waiting.\n\n\nconst waitForNone = Recoil_selectorFamily({\n  key: '__waitForNone',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // Always return the current status of the results; never block.\n\n    return wrapLoadables(dependencies, results, exceptions);\n  },\n  dangerouslyAllowMutability: true\n}); // Selector that requests all dependencies in parallel and waits for at least\n// one to be available before returning results.  It will only error if all\n// dependencies have errors.\n\nconst waitForAny = Recoil_selectorFamily({\n  key: '__waitForAny',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If any results are available, value or error, return the current status\n\n    if (exceptions.some(exp => !Recoil_isPromise(exp))) {\n      return wrapLoadables(dependencies, results, exceptions);\n    } // Otherwise, return a promise that will resolve when the next result is\n    // available, whichever one happens to be next.  But, if all pending\n    // dependencies end up with errors, then reject the promise.\n\n\n    return new Promise(resolve => {\n      for (const [i, exp] of exceptions.entries()) {\n        if (Recoil_isPromise(exp)) {\n          exp.then(result => {\n            results[i] = result;\n            exceptions[i] = undefined;\n            resolve(wrapLoadables(dependencies, results, exceptions));\n          }).catch(error => {\n            exceptions[i] = error;\n            resolve(wrapLoadables(dependencies, results, exceptions));\n          });\n        }\n      }\n    });\n  },\n  dangerouslyAllowMutability: true\n}); // Selector that requests all dependencies in parallel and waits for all to be\n// available before returning a value.  It will error if any dependencies error.\n\nconst waitForAll = Recoil_selectorFamily({\n  key: '__waitForAll',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results\n\n    if (exceptions.every(exp => exp == null)) {\n      return wrapResults(dependencies, results);\n    } // If we have any errors, throw the first error\n\n\n    const error = exceptions.find(isError);\n\n    if (error != null) {\n      throw error;\n    } // Otherwise, return a promise that will resolve when all results are available\n\n\n    return Promise.all(exceptions).then(exceptionResults => wrapResults(dependencies, combineAsyncResultsWithSyncResults(results, exceptionResults)));\n  },\n  dangerouslyAllowMutability: true\n});\nconst waitForAllSettled = Recoil_selectorFamily({\n  key: '__waitForAllSettled',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results\n\n    if (exceptions.every(exp => !Recoil_isPromise(exp))) {\n      return wrapLoadables(dependencies, results, exceptions);\n    } // Wait for all results to settle\n\n\n    return Promise.all(exceptions.map((exp, i) => Recoil_isPromise(exp) ? exp.then(result => {\n      results[i] = result;\n      exceptions[i] = undefined;\n    }).catch(error => {\n      results[i] = undefined;\n      exceptions[i] = error;\n    }) : null)) // Then wrap them as loadables\n    .then(() => wrapLoadables(dependencies, results, exceptions));\n  },\n  dangerouslyAllowMutability: true\n});\nconst noWait = Recoil_selectorFamily({\n  key: '__noWait',\n  get: dependency => ({\n    get\n  }) => {\n    try {\n      return Recoil_selector.value(loadableWithValue$4(get(dependency)));\n    } catch (exception) {\n      return Recoil_selector.value(Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));\n    }\n  },\n  dangerouslyAllowMutability: true\n});\nvar Recoil_WaitFor = {\n  waitForNone,\n  waitForAny,\n  waitForAll,\n  waitForAllSettled,\n  noWait\n};\nconst {\n  RecoilLoadable\n} = Recoil_Loadable$1;\nconst {\n  DefaultValue: DefaultValue$3\n} = Recoil_Node;\nconst {\n  RecoilRoot: RecoilRoot$2,\n  useRecoilStoreID: useRecoilStoreID$1\n} = Recoil_RecoilRoot;\nconst {\n  isRecoilValue: isRecoilValue$5\n} = Recoil_RecoilValue$1;\nconst {\n  retentionZone: retentionZone$1\n} = Recoil_RetentionZone;\nconst {\n  freshSnapshot: freshSnapshot$2\n} = Recoil_Snapshot$1;\nconst {\n  useRecoilState: useRecoilState$1,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilStateLoadable: useRecoilStateLoadable$1,\n  useRecoilValue: useRecoilValue$1,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilValueLoadable: useRecoilValueLoadable$1,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,\n  useResetRecoilState: useResetRecoilState$1,\n  useSetRecoilState: useSetRecoilState$1\n} = Recoil_Hooks;\nconst {\n  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,\n  useRecoilSnapshot: useRecoilSnapshot$1,\n  useRecoilTransactionObserver: useRecoilTransactionObserver$1\n} = Recoil_SnapshotHooks;\nconst {\n  useRecoilCallback: useRecoilCallback$1\n} = Recoil_useRecoilCallback;\nconst {\n  noWait: noWait$1,\n  waitForAll: waitForAll$1,\n  waitForAllSettled: waitForAllSettled$1,\n  waitForAny: waitForAny$1,\n  waitForNone: waitForNone$1\n} = Recoil_WaitFor;\nvar Recoil_index = {\n  // Types\n  DefaultValue: DefaultValue$3,\n  isRecoilValue: isRecoilValue$5,\n  RecoilLoadable,\n  // Recoil Root\n  RecoilRoot: RecoilRoot$2,\n  useRecoilStoreID: useRecoilStoreID$1,\n  useRecoilBridgeAcrossReactRoots_UNSTABLE: Recoil_useRecoilBridgeAcrossReactRoots,\n  // Atoms/Selectors\n  atom: Recoil_atom,\n  selector: Recoil_selector,\n  // Convenience Atoms/Selectors\n  atomFamily: Recoil_atomFamily,\n  selectorFamily: Recoil_selectorFamily,\n  constSelector: Recoil_constSelector,\n  errorSelector: Recoil_errorSelector,\n  readOnlySelector: Recoil_readOnlySelector,\n  // Concurrency Helpers for Atoms/Selectors\n  noWait: noWait$1,\n  waitForNone: waitForNone$1,\n  waitForAny: waitForAny$1,\n  waitForAll: waitForAll$1,\n  waitForAllSettled: waitForAllSettled$1,\n  // Hooks for Atoms/Selectors\n  useRecoilValue: useRecoilValue$1,\n  useRecoilValueLoadable: useRecoilValueLoadable$1,\n  useRecoilState: useRecoilState$1,\n  useRecoilStateLoadable: useRecoilStateLoadable$1,\n  useSetRecoilState: useSetRecoilState$1,\n  useResetRecoilState: useResetRecoilState$1,\n  useGetRecoilValueInfo_UNSTABLE: Recoil_useGetRecoilValueInfo,\n  useRecoilRefresher_UNSTABLE: Recoil_useRecoilRefresher,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,\n  // Hooks for complex operations\n  useRecoilCallback: useRecoilCallback$1,\n  useRecoilTransaction_UNSTABLE: Recoil_useRecoilTransaction,\n  // Snapshots\n  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,\n  useRecoilSnapshot: useRecoilSnapshot$1,\n  useRecoilTransactionObserver_UNSTABLE: useRecoilTransactionObserver$1,\n  snapshot_UNSTABLE: freshSnapshot$2,\n  // Memory Management\n  useRetain: Recoil_useRetain,\n  retentionZone: retentionZone$1\n};\nvar Recoil_index_1 = Recoil_index.DefaultValue;\nvar Recoil_index_2 = Recoil_index.isRecoilValue;\nvar Recoil_index_3 = Recoil_index.RecoilLoadable;\nvar Recoil_index_4 = Recoil_index.RecoilRoot;\nvar Recoil_index_5 = Recoil_index.useRecoilStoreID;\nvar Recoil_index_6 = Recoil_index.useRecoilBridgeAcrossReactRoots_UNSTABLE;\nvar Recoil_index_7 = Recoil_index.atom;\nvar Recoil_index_8 = Recoil_index.selector;\nvar Recoil_index_9 = Recoil_index.atomFamily;\nvar Recoil_index_10 = Recoil_index.selectorFamily;\nvar Recoil_index_11 = Recoil_index.constSelector;\nvar Recoil_index_12 = Recoil_index.errorSelector;\nvar Recoil_index_13 = Recoil_index.readOnlySelector;\nvar Recoil_index_14 = Recoil_index.noWait;\nvar Recoil_index_15 = Recoil_index.waitForNone;\nvar Recoil_index_16 = Recoil_index.waitForAny;\nvar Recoil_index_17 = Recoil_index.waitForAll;\nvar Recoil_index_18 = Recoil_index.waitForAllSettled;\nvar Recoil_index_19 = Recoil_index.useRecoilValue;\nvar Recoil_index_20 = Recoil_index.useRecoilValueLoadable;\nvar Recoil_index_21 = Recoil_index.useRecoilState;\nvar Recoil_index_22 = Recoil_index.useRecoilStateLoadable;\nvar Recoil_index_23 = Recoil_index.useSetRecoilState;\nvar Recoil_index_24 = Recoil_index.useResetRecoilState;\nvar Recoil_index_25 = Recoil_index.useGetRecoilValueInfo_UNSTABLE;\nvar Recoil_index_26 = Recoil_index.useRecoilRefresher_UNSTABLE;\nvar Recoil_index_27 = Recoil_index.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_28 = Recoil_index.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_29 = Recoil_index.useRecoilState_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_30 = Recoil_index.useRecoilCallback;\nvar Recoil_index_31 = Recoil_index.useRecoilTransaction_UNSTABLE;\nvar Recoil_index_32 = Recoil_index.useGotoRecoilSnapshot;\nvar Recoil_index_33 = Recoil_index.useRecoilSnapshot;\nvar Recoil_index_34 = Recoil_index.useRecoilTransactionObserver_UNSTABLE;\nvar Recoil_index_35 = Recoil_index.snapshot_UNSTABLE;\nvar Recoil_index_36 = Recoil_index.useRetain;\nvar Recoil_index_37 = Recoil_index.retentionZone;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Recoil_index);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM3aEIsMENBQW5DO0FBQ0EsSUFBSWlrQixlQUFlLEdBQUdwQyxZQUFZLENBQUM3YSxpQkFBbkM7QUFDQSxJQUFJa2QsZUFBZSxHQUFHckMsWUFBWSxDQUFDSSw2QkFBbkM7QUFDQSxJQUFJa0MsZUFBZSxHQUFHdEMsWUFBWSxDQUFDeGUscUJBQW5DO0FBQ0EsSUFBSStnQixlQUFlLEdBQUd2QyxZQUFZLENBQUNwZixpQkFBbkM7QUFDQSxJQUFJNGhCLGVBQWUsR0FBR3hDLFlBQVksQ0FBQ0sscUNBQW5DO0FBQ0EsSUFBSW9DLGVBQWUsR0FBR3pDLFlBQVksQ0FBQ00saUJBQW5DO0FBQ0EsSUFBSW9DLGVBQWUsR0FBRzFDLFlBQVksQ0FBQ2xuQixTQUFuQztBQUNBLElBQUk2cEIsZUFBZSxHQUFHM0MsWUFBWSxDQUFDcitCLGFBQW5DO0FBRUEsK0RBQWVxK0IsWUFBZiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVjb2lsL2VzL2luZGV4LmpzPzNhNjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCByZWFjdERvbSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBlcnIobWVzc2FnZSkge1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTsgLy8gSW4gVjgsIEVycm9yIG9iamVjdHMga2VlcCB0aGUgY2xvc3VyZSBzY29wZSBjaGFpbiBhbGl2ZSB1bnRpbCB0aGVcbiAgLy8gZXJyLnN0YWNrIHByb3BlcnR5IGlzIGFjY2Vzc2VkLlxuXG4gIGlmIChlcnJvci5zdGFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gSUUgc2V0cyB0aGUgc3RhY2sgb25seSBpZiBlcnJvciBpcyB0aHJvd25cbiAgICB0cnkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBjYXRjaCAoXykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBmYi13d3cvbm8tdW51c2VkLWNhdGNoLWJpbmRpbmdzLCBuby1lbXB0eVxuXG4gIH1cblxuICByZXR1cm4gZXJyb3I7XG59XG5cbnZhciBlcnJfMSA9IGVycjtcblxuLy8gQG9zcy1vbmx5XG5cblxudmFyIFJlY29pbF9lcnIgPSBlcnJfMTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuLy8gU3BsaXQgZGVjbGFyYXRpb24gYW5kIGltcGxlbWVudGF0aW9uIHRvIGFsbG93IHRoaXMgZnVuY3Rpb24gdG8gcHJldGVuZCB0b1xuLy8gY2hlY2sgZm9yIGFjdHVhbCBpbnN0YW5jZSBvZiBQcm9taXNlIGluc3RlYWQgb2Ygc29tZXRoaW5nIHdpdGggYSBgdGhlbmBcbi8vIG1ldGhvZC5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmZ1bmN0aW9uIGlzUHJvbWlzZShwKSB7XG4gIHJldHVybiAhIXAgJiYgdHlwZW9mIHAudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIFJlY29pbF9pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIG51bGx0aHJvd3MoeCwgbWVzc2FnZSkge1xuICBpZiAoeCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cblxuICB0aHJvdyBSZWNvaWxfZXJyKG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICdHb3QgdW5leHBlY3RlZCBudWxsIG9yIHVuZGVmaW5lZCcpO1xufVxuXG52YXIgUmVjb2lsX251bGx0aHJvd3MgPSBudWxsdGhyb3dzO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuY2xhc3MgQmFzZUxvYWRhYmxlIHtcbiAgZ2V0VmFsdWUoKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XG4gIH1cblxuICB0b1Byb21pc2UoKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XG4gIH1cblxuICB2YWx1ZU1heWJlKCkge1xuICAgIHRocm93IFJlY29pbF9lcnIoJ0Jhc2VMb2FkYWJsZScpO1xuICB9XG5cbiAgdmFsdWVPclRocm93KCkge1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHRocm93IFJlY29pbF9lcnIoYExvYWRhYmxlIGV4cGVjdGVkIHZhbHVlLCBidXQgaW4gXCIke3RoaXMuc3RhdGV9XCIgc3RhdGVgKTtcbiAgfVxuXG4gIHByb21pc2VNYXliZSgpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcbiAgfVxuXG4gIHByb21pc2VPclRocm93KCkge1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHRocm93IFJlY29pbF9lcnIoYExvYWRhYmxlIGV4cGVjdGVkIHByb21pc2UsIGJ1dCBpbiBcIiR7dGhpcy5zdGF0ZX1cIiBzdGF0ZWApO1xuICB9XG5cbiAgZXJyb3JNYXliZSgpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcbiAgfVxuXG4gIGVycm9yT3JUaHJvdygpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICB0aHJvdyBSZWNvaWxfZXJyKGBMb2FkYWJsZSBleHBlY3RlZCBlcnJvciwgYnV0IGluIFwiJHt0aGlzLnN0YXRlfVwiIHN0YXRlYCk7XG4gIH1cblxuICBpcyhvdGhlcikge1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHJldHVybiBvdGhlci5zdGF0ZSA9PT0gdGhpcy5zdGF0ZSAmJiBvdGhlci5jb250ZW50cyA9PT0gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIG1hcChfbWFwKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XG4gIH1cblxufVxuXG5jbGFzcyBWYWx1ZUxvYWRhYmxlIGV4dGVuZHMgQmFzZUxvYWRhYmxlIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwgJ2hhc1ZhbHVlJyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZW50c1wiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5jb250ZW50cyA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICB0b1Byb21pc2UoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmNvbnRlbnRzKTtcbiAgfVxuXG4gIHZhbHVlTWF5YmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICB2YWx1ZU9yVGhyb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICBwcm9taXNlTWF5YmUoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGVycm9yTWF5YmUoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIG1hcChtYXApIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV4dCA9IG1hcCh0aGlzLmNvbnRlbnRzKTtcbiAgICAgIHJldHVybiBSZWNvaWxfaXNQcm9taXNlKG5leHQpID8gbG9hZGFibGVXaXRoUHJvbWlzZShuZXh0KSA6IGlzTG9hZGFibGUobmV4dCkgPyBuZXh0IDogbG9hZGFibGVXaXRoVmFsdWUobmV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFJlY29pbF9pc1Byb21pc2UoZSkgPyAvLyBJZiB3ZSBcInN1c3BlbmRlZFwiLCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICAgIC8vIGVycm9ycyBhbmQgc3Vic2VxdWVudCByZXRyaWVzIHdpbGwgYmUgaGFuZGxlZCBpbiAnbG9hZGluZycgY2FzZVxuICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBsb2FkYWJsZVdpdGhQcm9taXNlKGUubmV4dCgoKSA9PiB0aGlzLm1hcChtYXApKSkgOiBsb2FkYWJsZVdpdGhFcnJvcihlKTtcbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBFcnJvckxvYWRhYmxlIGV4dGVuZHMgQmFzZUxvYWRhYmxlIHtcbiAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwgJ2hhc0Vycm9yJyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZW50c1wiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5jb250ZW50cyA9IGVycm9yO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgdGhyb3cgdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIHRvUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5jb250ZW50cyk7XG4gIH1cblxuICB2YWx1ZU1heWJlKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBwcm9taXNlTWF5YmUoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGVycm9yTWF5YmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICBlcnJvck9yVGhyb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICBtYXAoX21hcCkge1xuICAgIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5cbmNsYXNzIExvYWRpbmdMb2FkYWJsZSBleHRlbmRzIEJhc2VMb2FkYWJsZSB7XG4gIGNvbnN0cnVjdG9yKHByb21pc2UpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwgJ2xvYWRpbmcnKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRlbnRzXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmNvbnRlbnRzID0gcHJvbWlzZTtcbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIHRocm93IHRoaXMuY29udGVudHM7XG4gIH1cblxuICB0b1Byb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICB2YWx1ZU1heWJlKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBwcm9taXNlTWF5YmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICBwcm9taXNlT3JUaHJvdygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIGVycm9yTWF5YmUoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIG1hcChtYXApIHtcbiAgICByZXR1cm4gbG9hZGFibGVXaXRoUHJvbWlzZSh0aGlzLmNvbnRlbnRzLnRoZW4odmFsdWUgPT4ge1xuICAgICAgY29uc3QgbmV4dCA9IG1hcCh2YWx1ZSk7XG5cbiAgICAgIGlmIChpc0xvYWRhYmxlKG5leHQpKSB7XG4gICAgICAgIGNvbnN0IG5leHRMb2FkYWJsZSA9IG5leHQ7XG5cbiAgICAgICAgc3dpdGNoIChuZXh0TG9hZGFibGUuc3RhdGUpIHtcbiAgICAgICAgICBjYXNlICdoYXNWYWx1ZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV4dExvYWRhYmxlLmNvbnRlbnRzO1xuXG4gICAgICAgICAgY2FzZSAnaGFzRXJyb3InOlxuICAgICAgICAgICAgdGhyb3cgbmV4dExvYWRhYmxlLmNvbnRlbnRzO1xuXG4gICAgICAgICAgY2FzZSAnbG9hZGluZyc6XG4gICAgICAgICAgICByZXR1cm4gbmV4dExvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICB9IC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuXG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKGUpKSB7XG4gICAgICAgIC8vIHdlIHdlcmUgXCJzdXNwZW5kZWQsXCIgdHJ5IGFnYWluXG4gICAgICAgIHJldHVybiBlLnRoZW4oKCkgPT4gdGhpcy5tYXAobWFwKS5jb250ZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGU7XG4gICAgfSkpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gbG9hZGFibGVXaXRoVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobmV3IFZhbHVlTG9hZGFibGUodmFsdWUpKTtcbn1cblxuZnVuY3Rpb24gbG9hZGFibGVXaXRoRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobmV3IEVycm9yTG9hZGFibGUoZXJyb3IpKTtcbn1cblxuZnVuY3Rpb24gbG9hZGFibGVXaXRoUHJvbWlzZShwcm9taXNlKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG5ldyBMb2FkaW5nTG9hZGFibGUocHJvbWlzZSkpO1xufVxuXG5mdW5jdGlvbiBsb2FkYWJsZUxvYWRpbmcoKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG5ldyBMb2FkaW5nTG9hZGFibGUobmV3IFByb21pc2UoKCkgPT4ge30pKSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRhYmxlQWxsQXJyYXkoaW5wdXRzKSB7XG4gIHJldHVybiBpbnB1dHMuZXZlcnkoaSA9PiBpLnN0YXRlID09PSAnaGFzVmFsdWUnKSA/IGxvYWRhYmxlV2l0aFZhbHVlKGlucHV0cy5tYXAoaSA9PiBpLmNvbnRlbnRzKSkgOiBpbnB1dHMuc29tZShpID0+IGkuc3RhdGUgPT09ICdoYXNFcnJvcicpID8gbG9hZGFibGVXaXRoRXJyb3IoUmVjb2lsX251bGx0aHJvd3MoaW5wdXRzLmZpbmQoaSA9PiBpLnN0YXRlID09PSAnaGFzRXJyb3InKSwgJ0ludmFsaWQgbG9hZGFibGUgcGFzc2VkIHRvIGxvYWRhYmxlQWxsJykuY29udGVudHMpIDogbG9hZGFibGVXaXRoUHJvbWlzZShQcm9taXNlLmFsbChpbnB1dHMubWFwKGkgPT4gaS5jb250ZW50cykpKTtcbn1cblxuZnVuY3Rpb24gbG9hZGFibGVBbGwoaW5wdXRzKSB7XG4gIGNvbnN0IHVud3JhcGVkSW5wdXRzID0gQXJyYXkuaXNBcnJheShpbnB1dHMpID8gaW5wdXRzIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5wdXRzKS5tYXAoa2V5ID0+IGlucHV0c1trZXldKTtcbiAgY29uc3Qgbm9ybWFsaXplZElucHV0cyA9IHVud3JhcGVkSW5wdXRzLm1hcCh4ID0+IGlzTG9hZGFibGUoeCkgPyB4IDogUmVjb2lsX2lzUHJvbWlzZSh4KSA/IGxvYWRhYmxlV2l0aFByb21pc2UoeCkgOiBsb2FkYWJsZVdpdGhWYWx1ZSh4KSk7XG4gIGNvbnN0IG91dHB1dCA9IGxvYWRhYmxlQWxsQXJyYXkobm9ybWFsaXplZElucHV0cyk7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0cykgPyAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gIG91dHB1dCA6IC8vIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCkgaGFzIGNvbnNpc3RlbnQga2V5IG9yZGVyaW5nIHdpdGggRVM2XG4gIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLWNhbGxdXG4gIG91dHB1dC5tYXAob3V0cHV0cyA9PiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbnB1dHMpLnJlZHVjZSgob3V0LCBrZXksIGlkeCkgPT4gKHsgLi4ub3V0LFxuICAgIFtrZXldOiBvdXRwdXRzW2lkeF1cbiAgfSksIHt9KSk7XG59XG5cbmZ1bmN0aW9uIGlzTG9hZGFibGUoeCkge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIEJhc2VMb2FkYWJsZTtcbn1cblxuY29uc3QgTG9hZGFibGVTdGF0aWNJbnRlcmZhY2UgPSB7XG4gIG9mOiB2YWx1ZSA9PiBSZWNvaWxfaXNQcm9taXNlKHZhbHVlKSA/IGxvYWRhYmxlV2l0aFByb21pc2UodmFsdWUpIDogaXNMb2FkYWJsZSh2YWx1ZSkgPyB2YWx1ZSA6IGxvYWRhYmxlV2l0aFZhbHVlKHZhbHVlKSxcbiAgZXJyb3I6IGVycm9yID0+IGxvYWRhYmxlV2l0aEVycm9yKGVycm9yKSxcbiAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICBsb2FkaW5nOiAoKSA9PiBsb2FkYWJsZUxvYWRpbmcoKSxcbiAgLy8gJEZsb3dJc3N1ZVt1bmNsZWFyLXR5cGVdXG4gIGFsbDogbG9hZGFibGVBbGwsXG4gIGlzTG9hZGFibGVcbn07XG52YXIgUmVjb2lsX0xvYWRhYmxlID0ge1xuICBsb2FkYWJsZVdpdGhWYWx1ZSxcbiAgbG9hZGFibGVXaXRoRXJyb3IsXG4gIGxvYWRhYmxlV2l0aFByb21pc2UsXG4gIGxvYWRhYmxlTG9hZGluZyxcbiAgbG9hZGFibGVBbGwsXG4gIGlzTG9hZGFibGUsXG4gIFJlY29pbExvYWRhYmxlOiBMb2FkYWJsZVN0YXRpY0ludGVyZmFjZVxufTtcblxudmFyIFJlY29pbF9Mb2FkYWJsZV8xID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlV2l0aFZhbHVlO1xudmFyIFJlY29pbF9Mb2FkYWJsZV8yID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlV2l0aEVycm9yO1xudmFyIFJlY29pbF9Mb2FkYWJsZV8zID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlV2l0aFByb21pc2U7XG52YXIgUmVjb2lsX0xvYWRhYmxlXzQgPSBSZWNvaWxfTG9hZGFibGUubG9hZGFibGVMb2FkaW5nO1xudmFyIFJlY29pbF9Mb2FkYWJsZV81ID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlQWxsO1xudmFyIFJlY29pbF9Mb2FkYWJsZV82ID0gUmVjb2lsX0xvYWRhYmxlLmlzTG9hZGFibGU7XG52YXIgUmVjb2lsX0xvYWRhYmxlXzcgPSBSZWNvaWxfTG9hZGFibGUuUmVjb2lsTG9hZGFibGU7XG5cbnZhciBSZWNvaWxfTG9hZGFibGUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBsb2FkYWJsZVdpdGhWYWx1ZTogUmVjb2lsX0xvYWRhYmxlXzEsXG4gIGxvYWRhYmxlV2l0aEVycm9yOiBSZWNvaWxfTG9hZGFibGVfMixcbiAgbG9hZGFibGVXaXRoUHJvbWlzZTogUmVjb2lsX0xvYWRhYmxlXzMsXG4gIGxvYWRhYmxlTG9hZGluZzogUmVjb2lsX0xvYWRhYmxlXzQsXG4gIGxvYWRhYmxlQWxsOiBSZWNvaWxfTG9hZGFibGVfNSxcbiAgaXNMb2FkYWJsZTogUmVjb2lsX0xvYWRhYmxlXzYsXG4gIFJlY29pbExvYWRhYmxlOiBSZWNvaWxfTG9hZGFibGVfN1xufSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmNvbnN0IGdrcyA9IG5ldyBNYXAoKS5zZXQoJ3JlY29pbF9oYW10XzIwMjAnLCB0cnVlKS5zZXQoJ3JlY29pbF9zeW5jX2V4dGVybmFsX3N0b3JlJywgdHJ1ZSkuc2V0KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snLCB0cnVlKS5zZXQoJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJywgdHJ1ZSk7XG5cbmZ1bmN0aW9uIFJlY29pbF9na3hfT1NTKGdrKSB7XG4gIHZhciBfZ2tzJGdldDtcblxuICByZXR1cm4gKF9na3MkZ2V0ID0gZ2tzLmdldChnaykpICE9PSBudWxsICYmIF9na3MkZ2V0ICE9PSB2b2lkIDAgPyBfZ2tzJGdldCA6IGZhbHNlO1xufVxuXG5SZWNvaWxfZ2t4X09TUy5zZXRQYXNzID0gZ2sgPT4ge1xuICBna3Muc2V0KGdrLCB0cnVlKTtcbn07XG5cblJlY29pbF9na3hfT1NTLnNldEZhaWwgPSBnayA9PiB7XG4gIGdrcy5zZXQoZ2ssIGZhbHNlKTtcbn07XG5cblJlY29pbF9na3hfT1NTLmNsZWFyID0gKCkgPT4ge1xuICBna3MuY2xlYXIoKTtcbn07XG5cbnZhciBSZWNvaWxfZ2t4ID0gUmVjb2lsX2dreF9PU1M7IC8vIEBvc3Mtb25seVxuXG52YXIgX2NyZWF0ZU11dGFibGVTb3VyY2UsIF91c2VNdXRhYmxlU291cmNlLCBfdXNlU3luY0V4dGVybmFsU3RvcmU7XG5cblxuXG5cblxuY29uc3QgY3JlYXRlTXV0YWJsZVNvdXJjZSA9IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4oX2NyZWF0ZU11dGFibGVTb3VyY2UgPSByZWFjdC5jcmVhdGVNdXRhYmxlU291cmNlKSAhPT0gbnVsbCAmJiBfY3JlYXRlTXV0YWJsZVNvdXJjZSAhPT0gdm9pZCAwID8gX2NyZWF0ZU11dGFibGVTb3VyY2UgOiByZWFjdC51bnN0YWJsZV9jcmVhdGVNdXRhYmxlU291cmNlO1xuY29uc3QgdXNlTXV0YWJsZVNvdXJjZSA9IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4oX3VzZU11dGFibGVTb3VyY2UgPSByZWFjdC51c2VNdXRhYmxlU291cmNlKSAhPT0gbnVsbCAmJiBfdXNlTXV0YWJsZVNvdXJjZSAhPT0gdm9pZCAwID8gX3VzZU11dGFibGVTb3VyY2UgOiByZWFjdC51bnN0YWJsZV91c2VNdXRhYmxlU291cmNlOyAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVhY3R3Zy9yZWFjdC0xOC9kaXNjdXNzaW9ucy84NlxuXG5jb25zdCB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4oX3VzZVN5bmNFeHRlcm5hbFN0b3JlID0gcmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUpICE9PSBudWxsICYmIF91c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPT0gdm9pZCAwID8gX3VzZVN5bmNFeHRlcm5hbFN0b3JlIDogLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbnJlYWN0LnVuc3RhYmxlX3VzZVN5bmNFeHRlcm5hbFN0b3JlO1xuXG4vKipcbiAqIG1vZGU6IFRoZSBSZWFjdCBBUEkgYW5kIGFwcHJvYWNoIHRvIHVzZSBmb3Igc3luY2luZyBzdGF0ZSB3aXRoIFJlYWN0XG4gKiBlYXJseTogUmUtcmVuZGVycyBmcm9tIFJlY29pbCB1cGRhdGVzIG9jY3VyOlxuICogICAgMSkgZWFybGllclxuICogICAgMikgaW4gc3luYyB3aXRoIFJlYWN0IHVwZGF0ZXMgaW4gdGhlIHNhbWUgYmF0Y2hcbiAqICAgIDMpIGJlZm9yZSB0cmFuc2FjdGlvbiBvYnNlcnZlcnMgaW5zdGVhZCBvZiBhZnRlci5cbiAqIGNvbmN1cnJlbnQ6IElzIHRoZSBjdXJyZW50IG1vZGUgY29tcGF0aWJsZSB3aXRoIENvbmN1cnJlbnQgTW9kZSBhbmQgdXNlVHJhbnNpdGlvbigpXG4gKi9cbmZ1bmN0aW9uIHJlYWN0TW9kZSgpIHtcbiAgLy8gTk9URTogVGhpcyBtb2RlIGlzIGN1cnJlbnRseSBicm9rZW4gd2l0aCBzb21lIFN1c3BlbnNlIGNhc2VzXG4gIC8vIHNlZSBSZWNvaWxfc2VsZWN0b3ItdGVzdC5qc1xuICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX3RyYW5zaXRpb25fc3VwcG9ydCcpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGU6ICdUUkFOU0lUSU9OX1NVUFBPUlQnLFxuICAgICAgZWFybHk6IHRydWUsXG4gICAgICBjb25jdXJyZW50OiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfc3luY19leHRlcm5hbF9zdG9yZScpICYmIHVzZVN5bmNFeHRlcm5hbFN0b3JlICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kZTogJ1NZTkNfRVhURVJOQUxfU1RPUkUnLFxuICAgICAgZWFybHk6IHRydWUsXG4gICAgICBjb25jdXJyZW50OiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX211dGFibGVfc291cmNlJykgJiYgdXNlTXV0YWJsZVNvdXJjZSAhPSBudWxsICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuJGRpc2FibGVSZWNvaWxWYWx1ZU11dGFibGVTb3VyY2VfVEVNUF9IQUNLX0RPX05PVF9VU0UpIHtcbiAgICByZXR1cm4gUmVjb2lsX2dreCgncmVjb2lsX3N1cHByZXNzX3JlcmVuZGVyX2luX2NhbGxiYWNrJykgPyB7XG4gICAgICBtb2RlOiAnTVVUQUJMRV9TT1VSQ0UnLFxuICAgICAgZWFybHk6IHRydWUsXG4gICAgICBjb25jdXJyZW50OiB0cnVlXG4gICAgfSA6IHtcbiAgICAgIG1vZGU6ICdNVVRBQkxFX1NPVVJDRScsXG4gICAgICBlYXJseTogZmFsc2UsXG4gICAgICBjb25jdXJyZW50OiBmYWxzZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gUmVjb2lsX2dreCgncmVjb2lsX3N1cHByZXNzX3JlcmVuZGVyX2luX2NhbGxiYWNrJykgPyB7XG4gICAgbW9kZTogJ0xFR0FDWScsXG4gICAgZWFybHk6IHRydWUsXG4gICAgY29uY3VycmVudDogZmFsc2VcbiAgfSA6IHtcbiAgICBtb2RlOiAnTEVHQUNZJyxcbiAgICBlYXJseTogZmFsc2UsXG4gICAgY29uY3VycmVudDogZmFsc2VcbiAgfTtcbn0gLy8gVE9ETyBOZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhlcmUgaXMgYSBzdGFuZGFyZC9vcGVuLXNvdXJjZSBlcXVpdmFsZW50IHRvIHNlZSBpZiBob3QgbW9kdWxlIHJlcGxhY2VtZW50IGlzIGhhcHBlbmluZzpcblxuXG5mdW5jdGlvbiBpc0Zhc3RSZWZyZXNoRW5hYmxlZCgpIHtcbiAgLy8gQGZiLW9ubHk6IGNvbnN0IHtpc0FjY2VwdGluZ1VwZGF0ZX0gPSByZXF1aXJlKCdfX2RlYnVnJyk7XG4gIC8vIEBmYi1vbmx5OiByZXR1cm4gdHlwZW9mIGlzQWNjZXB0aW5nVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGlzQWNjZXB0aW5nVXBkYXRlKCk7XG4gIHJldHVybiBmYWxzZTsgLy8gQG9zcy1vbmx5XG59XG5cbnZhciBSZWNvaWxfUmVhY3RNb2RlID0ge1xuICBjcmVhdGVNdXRhYmxlU291cmNlLFxuICB1c2VNdXRhYmxlU291cmNlLFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZSxcbiAgcmVhY3RNb2RlLFxuICBpc0Zhc3RSZWZyZXNoRW5hYmxlZFxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5jbGFzcyBBYnN0cmFjdFJlY29pbFZhbHVlIHtcbiAgY29uc3RydWN0b3IobmV3S2V5KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5XCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmtleSA9IG5ld0tleTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiB0aGlzLmtleVxuICAgIH07XG4gIH1cblxufVxuXG5jbGFzcyBSZWNvaWxTdGF0ZSBleHRlbmRzIEFic3RyYWN0UmVjb2lsVmFsdWUge31cblxuY2xhc3MgUmVjb2lsVmFsdWVSZWFkT25seSBleHRlbmRzIEFic3RyYWN0UmVjb2lsVmFsdWUge31cblxuZnVuY3Rpb24gaXNSZWNvaWxWYWx1ZSh4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVjb2lsU3RhdGUgfHwgeCBpbnN0YW5jZW9mIFJlY29pbFZhbHVlUmVhZE9ubHk7XG59XG5cbnZhciBSZWNvaWxfUmVjb2lsVmFsdWUgPSB7XG4gIEFic3RyYWN0UmVjb2lsVmFsdWUsXG4gIFJlY29pbFN0YXRlLFxuICBSZWNvaWxWYWx1ZVJlYWRPbmx5LFxuICBpc1JlY29pbFZhbHVlXG59O1xuXG52YXIgUmVjb2lsX1JlY29pbFZhbHVlXzEgPSBSZWNvaWxfUmVjb2lsVmFsdWUuQWJzdHJhY3RSZWNvaWxWYWx1ZTtcbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVfMiA9IFJlY29pbF9SZWNvaWxWYWx1ZS5SZWNvaWxTdGF0ZTtcbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVfMyA9IFJlY29pbF9SZWNvaWxWYWx1ZS5SZWNvaWxWYWx1ZVJlYWRPbmx5O1xudmFyIFJlY29pbF9SZWNvaWxWYWx1ZV80ID0gUmVjb2lsX1JlY29pbFZhbHVlLmlzUmVjb2lsVmFsdWU7XG5cbnZhciBSZWNvaWxfUmVjb2lsVmFsdWUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBBYnN0cmFjdFJlY29pbFZhbHVlOiBSZWNvaWxfUmVjb2lsVmFsdWVfMSxcbiAgUmVjb2lsU3RhdGU6IFJlY29pbF9SZWNvaWxWYWx1ZV8yLFxuICBSZWNvaWxWYWx1ZVJlYWRPbmx5OiBSZWNvaWxfUmVjb2lsVmFsdWVfMyxcbiAgaXNSZWNvaWxWYWx1ZTogUmVjb2lsX1JlY29pbFZhbHVlXzRcbn0pO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBzcHJpbnRmKGZvcm1hdCwgLi4uYXJncykge1xuICBsZXQgaW5kZXggPSAwO1xuICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoLyVzL2csICgpID0+IFN0cmluZyhhcmdzW2luZGV4KytdKSk7XG59XG5cbnZhciBzcHJpbnRmXzEgPSBzcHJpbnRmO1xuXG5mdW5jdGlvbiBleHBlY3RhdGlvblZpb2xhdGlvbihmb3JtYXQsIC4uLmFyZ3MpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBzcHJpbnRmXzEuY2FsbChudWxsLCBmb3JtYXQsIC4uLmFyZ3MpO1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGVycm9yLm5hbWUgPSAnRXhwZWN0YXRpb24gVmlvbGF0aW9uJztcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgfVxufVxuXG52YXIgZXhwZWN0YXRpb25WaW9sYXRpb25fMSA9IGV4cGVjdGF0aW9uVmlvbGF0aW9uO1xuXG4vLyBAb3NzLW9ubHlcblxuXG52YXIgUmVjb2lsX2V4cGVjdGF0aW9uVmlvbGF0aW9uID0gZXhwZWN0YXRpb25WaW9sYXRpb25fMTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpdGVyYWJsZSB3aG9zZSBvdXRwdXQgaXMgZ2VuZXJhdGVkIGJ5IHBhc3NpbmcgdGhlIGlucHV0XG4gKiBpdGVyYWJsZSdzIHZhbHVlcyB0aHJvdWdoIHRoZSBtYXBwZXIgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gbWFwSXRlcmFibGUoaXRlcmFibGUsIGNhbGxiYWNrKSB7XG4gIC8vIFVzZSBnZW5lcmF0b3IgdG8gY3JlYXRlIGl0ZXJhYmxlL2l0ZXJhdG9yXG4gIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgIGxldCBpbmRleCA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhYmxlKSB7XG4gICAgICB5aWVsZCBjYWxsYmFjayh2YWx1ZSwgaW5kZXgrKyk7XG4gICAgfVxuICB9KCk7XG59XG5cbnZhciBSZWNvaWxfbWFwSXRlcmFibGUgPSBtYXBJdGVyYWJsZTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gcmVjb3ZlcmFibGVWaW9sYXRpb24obWVzc2FnZSwgX3Byb2plY3ROYW1lLCB7XG4gIGVycm9yXG59ID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgZXJyb3IpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciByZWNvdmVyYWJsZVZpb2xhdGlvbl8xID0gcmVjb3ZlcmFibGVWaW9sYXRpb247XG5cbi8vIEBvc3Mtb25seVxuXG5cbnZhciBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24gPSByZWNvdmVyYWJsZVZpb2xhdGlvbl8xO1xuXG5jb25zdCB7XG4gIGlzRmFzdFJlZnJlc2hFbmFibGVkOiBpc0Zhc3RSZWZyZXNoRW5hYmxlZCQxXG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgRGVmYXVsdFZhbHVlIHt9XG5cbmNvbnN0IERFRkFVTFRfVkFMVUUgPSBuZXcgRGVmYXVsdFZhbHVlKCk7XG4vLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuY29uc3Qgbm9kZXMgPSBuZXcgTWFwKCk7IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cbmNvbnN0IHJlY29pbFZhbHVlcyA9IG5ldyBNYXAoKTtcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuXG5mdW5jdGlvbiByZWNvaWxWYWx1ZXNGb3JLZXlzKGtleXMpIHtcbiAgcmV0dXJuIFJlY29pbF9tYXBJdGVyYWJsZShrZXlzLCBrZXkgPT4gUmVjb2lsX251bGx0aHJvd3MocmVjb2lsVmFsdWVzLmdldChrZXkpKSk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTm9kZShub2RlKSB7XG4gIGlmIChub2Rlcy5oYXMobm9kZS5rZXkpKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBEdXBsaWNhdGUgYXRvbSBrZXkgXCIke25vZGUua2V5fVwiLiBUaGlzIGlzIGEgRkFUQUwgRVJST1IgaW5cbiAgICAgIHByb2R1Y3Rpb24uIEJ1dCBpdCBpcyBzYWZlIHRvIGlnbm9yZSB0aGlzIHdhcm5pbmcgaWYgaXQgb2NjdXJyZWQgYmVjYXVzZSBvZlxuICAgICAgaG90IG1vZHVsZSByZXBsYWNlbWVudC5gO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgLy8gVE9ETyBGaWd1cmUgdGhpcyBvdXQgZm9yIG9wZW4tc291cmNlXG4gICAgICBpZiAoIWlzRmFzdFJlZnJlc2hFbmFibGVkJDEoKSkge1xuICAgICAgICBSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24obWVzc2FnZSwgJ3JlY29pbCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAZmItb25seTogcmVjb3ZlcmFibGVWaW9sYXRpb24obWVzc2FnZSwgJ3JlY29pbCcpO1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpOyAvLyBAb3NzLW9ubHlcbiAgICB9XG4gIH1cblxuICBub2Rlcy5zZXQobm9kZS5rZXksIG5vZGUpO1xuICBjb25zdCByZWNvaWxWYWx1ZSA9IG5vZGUuc2V0ID09IG51bGwgPyBuZXcgUmVjb2lsX1JlY29pbFZhbHVlJDEuUmVjb2lsVmFsdWVSZWFkT25seShub2RlLmtleSkgOiBuZXcgUmVjb2lsX1JlY29pbFZhbHVlJDEuUmVjb2lsU3RhdGUobm9kZS5rZXkpO1xuICByZWNvaWxWYWx1ZXMuc2V0KG5vZGUua2V5LCByZWNvaWxWYWx1ZSk7XG4gIHJldHVybiByZWNvaWxWYWx1ZTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tcmVkZWNsYXJlICovXG5cblxuY2xhc3MgTm9kZU1pc3NpbmdFcnJvciBleHRlbmRzIEVycm9yIHt9IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cblxuZnVuY3Rpb24gZ2V0Tm9kZShrZXkpIHtcbiAgY29uc3Qgbm9kZSA9IG5vZGVzLmdldChrZXkpO1xuXG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTm9kZU1pc3NpbmdFcnJvcihgTWlzc2luZyBkZWZpbml0aW9uIGZvciBSZWNvaWxWYWx1ZTogXCIke2tleX1cIlwiYCk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0gLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcblxuXG5mdW5jdGlvbiBnZXROb2RlTWF5YmUoa2V5KSB7XG4gIHJldHVybiBub2Rlcy5nZXQoa2V5KTtcbn1cblxuY29uc3QgY29uZmlnRGVsZXRpb25IYW5kbGVycyA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGUoa2V5KSB7XG4gIHZhciBfbm9kZSRzaG91bGREZWxldGVDb247XG5cbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgbm9kZSA9IG5vZGVzLmdldChrZXkpO1xuXG4gIGlmIChub2RlICE9PSBudWxsICYmIG5vZGUgIT09IHZvaWQgMCAmJiAoX25vZGUkc2hvdWxkRGVsZXRlQ29uID0gbm9kZS5zaG91bGREZWxldGVDb25maWdPblJlbGVhc2UpICE9PSBudWxsICYmIF9ub2RlJHNob3VsZERlbGV0ZUNvbiAhPT0gdm9pZCAwICYmIF9ub2RlJHNob3VsZERlbGV0ZUNvbi5jYWxsKG5vZGUpKSB7XG4gICAgdmFyIF9nZXRDb25maWdEZWxldGlvbkhhbjtcblxuICAgIG5vZGVzLmRlbGV0ZShrZXkpO1xuICAgIChfZ2V0Q29uZmlnRGVsZXRpb25IYW4gPSBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIoa2V5KSkgPT09IG51bGwgfHwgX2dldENvbmZpZ0RlbGV0aW9uSGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0Q29uZmlnRGVsZXRpb25IYW4oKTtcbiAgICBjb25maWdEZWxldGlvbkhhbmRsZXJzLmRlbGV0ZShrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlcihrZXksIGZuKSB7XG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChmbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uZmlnRGVsZXRpb25IYW5kbGVycy5kZWxldGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWdEZWxldGlvbkhhbmRsZXJzLnNldChrZXksIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIoa2V5KSB7XG4gIHJldHVybiBjb25maWdEZWxldGlvbkhhbmRsZXJzLmdldChrZXkpO1xufVxuXG52YXIgUmVjb2lsX05vZGUgPSB7XG4gIG5vZGVzLFxuICByZWNvaWxWYWx1ZXMsXG4gIHJlZ2lzdGVyTm9kZSxcbiAgZ2V0Tm9kZSxcbiAgZ2V0Tm9kZU1heWJlLFxuICBkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZSxcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyLFxuICBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIsXG4gIHJlY29pbFZhbHVlc0ZvcktleXMsXG4gIE5vZGVNaXNzaW5nRXJyb3IsXG4gIERlZmF1bHRWYWx1ZSxcbiAgREVGQVVMVF9WQUxVRVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gZW5xdWV1ZUV4ZWN1dGlvbihzLCBmKSB7XG4gIGYoKTtcbn1cblxudmFyIFJlY29pbF9RdWV1ZSA9IHtcbiAgZW5xdWV1ZUV4ZWN1dGlvblxufTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciBoYW10XzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuLyoqXG4gICAgQGZpbGVPdmVydmlldyBIYXNoIEFycmF5IE1hcHBlZCBUcmllLlxuXG4gICAgQ29kZSBiYXNlZCBvbjogaHR0cHM6Ly9naXRodWIuY29tL2V4Y2xpcHkvcGRhdGFcbiovXG5cblxudmFyIGhhbXQgPSB7fTsgLy8gZXhwb3J0XG5cbi8qIENvbmZpZ3VyYXRpb25cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBTSVpFID0gNTtcbnZhciBCVUNLRVRfU0laRSA9IE1hdGgucG93KDIsIFNJWkUpO1xudmFyIE1BU0sgPSBCVUNLRVRfU0laRSAtIDE7XG52YXIgTUFYX0lOREVYX05PREUgPSBCVUNLRVRfU0laRSAvIDI7XG52YXIgTUlOX0FSUkFZX05PREUgPSBCVUNLRVRfU0laRSAvIDQ7XG4vKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIG5vdGhpbmcgPSB7fTtcblxudmFyIGNvbnN0YW50ID0gZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufTtcbi8qKlxuICAgIEdldCAzMiBiaXQgaGFzaCBvZiBzdHJpbmcuXG5cbiAgICBCYXNlZCBvbjpcbiAgICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc2MTY0NjEvZ2VuZXJhdGUtYS1oYXNoLWZyb20tc3RyaW5nLWluLWphdmFzY3JpcHQtanF1ZXJ5XG4qL1xuXG5cbnZhciBoYXNoID0gaGFtdC5oYXNoID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN0cik7XG4gIGlmICh0eXBlID09PSAnbnVtYmVyJykgcmV0dXJuIHN0cjtcbiAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSBzdHIgKz0gJyc7XG4gIHZhciBoYXNoID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgYyB8IDA7XG4gIH1cblxuICByZXR1cm4gaGFzaDtcbn07XG4vKiBCaXQgT3BzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBIYW1taW5nIHdlaWdodC5cblxuICAgIFRha2VuIGZyb206IGh0dHA6Ly9qc3BlcmYuY29tL2hhbW1pbmctd2VpZ2h0XG4qL1xuXG5cbnZhciBwb3Bjb3VudCA9IGZ1bmN0aW9uIHBvcGNvdW50KHgpIHtcbiAgeCAtPSB4ID4+IDEgJiAweDU1NTU1NTU1O1xuICB4ID0gKHggJiAweDMzMzMzMzMzKSArICh4ID4+IDIgJiAweDMzMzMzMzMzKTtcbiAgeCA9IHggKyAoeCA+PiA0KSAmIDB4MGYwZjBmMGY7XG4gIHggKz0geCA+PiA4O1xuICB4ICs9IHggPj4gMTY7XG4gIHJldHVybiB4ICYgMHg3Zjtcbn07XG5cbnZhciBoYXNoRnJhZ21lbnQgPSBmdW5jdGlvbiBoYXNoRnJhZ21lbnQoc2hpZnQsIGgpIHtcbiAgcmV0dXJuIGggPj4+IHNoaWZ0ICYgTUFTSztcbn07XG5cbnZhciB0b0JpdG1hcCA9IGZ1bmN0aW9uIHRvQml0bWFwKHgpIHtcbiAgcmV0dXJuIDEgPDwgeDtcbn07XG5cbnZhciBmcm9tQml0bWFwID0gZnVuY3Rpb24gZnJvbUJpdG1hcChiaXRtYXAsIGJpdCkge1xuICByZXR1cm4gcG9wY291bnQoYml0bWFwICYgYml0IC0gMSk7XG59O1xuLyogQXJyYXkgT3BzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBTZXQgYSB2YWx1ZSBpbiBhbiBhcnJheS5cblxuICAgIEBwYXJhbSBtdXRhdGUgU2hvdWxkIHRoZSBpbnB1dCBhcnJheSBiZSBtdXRhdGVkP1xuICAgIEBwYXJhbSBhdCBJbmRleCB0byBjaGFuZ2UuXG4gICAgQHBhcmFtIHYgTmV3IHZhbHVlXG4gICAgQHBhcmFtIGFyciBBcnJheS5cbiovXG5cblxudmFyIGFycmF5VXBkYXRlID0gZnVuY3Rpb24gYXJyYXlVcGRhdGUobXV0YXRlLCBhdCwgdiwgYXJyKSB7XG4gIHZhciBvdXQgPSBhcnI7XG5cbiAgaWYgKCFtdXRhdGUpIHtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBvdXQgPSBuZXcgQXJyYXkobGVuKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIG91dFtpXSA9IGFycltpXTtcbiAgICB9XG4gIH1cblxuICBvdXRbYXRdID0gdjtcbiAgcmV0dXJuIG91dDtcbn07XG4vKipcbiAgICBSZW1vdmUgYSB2YWx1ZSBmcm9tIGFuIGFycmF5LlxuXG4gICAgQHBhcmFtIG11dGF0ZSBTaG91bGQgdGhlIGlucHV0IGFycmF5IGJlIG11dGF0ZWQ/XG4gICAgQHBhcmFtIGF0IEluZGV4IHRvIHJlbW92ZS5cbiAgICBAcGFyYW0gYXJyIEFycmF5LlxuKi9cblxuXG52YXIgYXJyYXlTcGxpY2VPdXQgPSBmdW5jdGlvbiBhcnJheVNwbGljZU91dChtdXRhdGUsIGF0LCBhcnIpIHtcbiAgdmFyIG5ld0xlbiA9IGFyci5sZW5ndGggLSAxO1xuICB2YXIgaSA9IDA7XG4gIHZhciBnID0gMDtcbiAgdmFyIG91dCA9IGFycjtcblxuICBpZiAobXV0YXRlKSB7XG4gICAgaSA9IGcgPSBhdDtcbiAgfSBlbHNlIHtcbiAgICBvdXQgPSBuZXcgQXJyYXkobmV3TGVuKTtcblxuICAgIHdoaWxlIChpIDwgYXQpIHtcbiAgICAgIG91dFtnKytdID0gYXJyW2krK107XG4gICAgfVxuICB9XG5cbiAgKytpO1xuXG4gIHdoaWxlIChpIDw9IG5ld0xlbikge1xuICAgIG91dFtnKytdID0gYXJyW2krK107XG4gIH1cblxuICBpZiAobXV0YXRlKSB7XG4gICAgb3V0Lmxlbmd0aCA9IG5ld0xlbjtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuLyoqXG4gICAgSW5zZXJ0IGEgdmFsdWUgaW50byBhbiBhcnJheS5cblxuICAgIEBwYXJhbSBtdXRhdGUgU2hvdWxkIHRoZSBpbnB1dCBhcnJheSBiZSBtdXRhdGVkP1xuICAgIEBwYXJhbSBhdCBJbmRleCB0byBpbnNlcnQgYXQuXG4gICAgQHBhcmFtIHYgVmFsdWUgdG8gaW5zZXJ0LFxuICAgIEBwYXJhbSBhcnIgQXJyYXkuXG4qL1xuXG5cbnZhciBhcnJheVNwbGljZUluID0gZnVuY3Rpb24gYXJyYXlTcGxpY2VJbihtdXRhdGUsIGF0LCB2LCBhcnIpIHtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgaWYgKG11dGF0ZSkge1xuICAgIHZhciBfaSA9IGxlbjtcblxuICAgIHdoaWxlIChfaSA+PSBhdCkge1xuICAgICAgYXJyW19pLS1dID0gYXJyW19pXTtcbiAgICB9XG5cbiAgICBhcnJbYXRdID0gdjtcbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgdmFyIGkgPSAwLFxuICAgICAgZyA9IDA7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXkobGVuICsgMSk7XG5cbiAgd2hpbGUgKGkgPCBhdCkge1xuICAgIG91dFtnKytdID0gYXJyW2krK107XG4gIH1cblxuICBvdXRbYXRdID0gdjtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIG91dFsrK2ddID0gYXJyW2krK107XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcbi8qIE5vZGUgU3RydWN0dXJlc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG52YXIgTEVBRiA9IDE7XG52YXIgQ09MTElTSU9OID0gMjtcbnZhciBJTkRFWCA9IDM7XG52YXIgQVJSQVkgPSA0O1xuLyoqXG4gICAgRW1wdHkgbm9kZS5cbiovXG5cbnZhciBlbXB0eSA9IHtcbiAgX19oYW10X2lzRW1wdHk6IHRydWVcbn07XG5cbnZhciBpc0VtcHR5Tm9kZSA9IGZ1bmN0aW9uIGlzRW1wdHlOb2RlKHgpIHtcbiAgcmV0dXJuIHggPT09IGVtcHR5IHx8IHggJiYgeC5fX2hhbXRfaXNFbXB0eTtcbn07XG4vKipcbiAgICBMZWFmIGhvbGRpbmcgYSB2YWx1ZS5cblxuICAgIEBtZW1iZXIgZWRpdCBFZGl0IG9mIHRoZSBub2RlLlxuICAgIEBtZW1iZXIgaGFzaCBIYXNoIG9mIGtleS5cbiAgICBAbWVtYmVyIGtleSBLZXkuXG4gICAgQG1lbWJlciB2YWx1ZSBWYWx1ZSBzdG9yZWQuXG4qL1xuXG5cbnZhciBMZWFmID0gZnVuY3Rpb24gTGVhZihlZGl0LCBoYXNoLCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogTEVBRixcbiAgICBlZGl0OiBlZGl0LFxuICAgIGhhc2g6IGhhc2gsXG4gICAga2V5OiBrZXksXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIF9tb2RpZnk6IExlYWZfX21vZGlmeVxuICB9O1xufTtcbi8qKlxuICAgIExlYWYgaG9sZGluZyBtdWx0aXBsZSB2YWx1ZXMgd2l0aCB0aGUgc2FtZSBoYXNoIGJ1dCBkaWZmZXJlbnQga2V5cy5cblxuICAgIEBtZW1iZXIgZWRpdCBFZGl0IG9mIHRoZSBub2RlLlxuICAgIEBtZW1iZXIgaGFzaCBIYXNoIG9mIGtleS5cbiAgICBAbWVtYmVyIGNoaWxkcmVuIEFycmF5IG9mIGNvbGxpc2lvbiBjaGlsZHJlbiBub2RlLlxuKi9cblxuXG52YXIgQ29sbGlzaW9uID0gZnVuY3Rpb24gQ29sbGlzaW9uKGVkaXQsIGhhc2gsIGNoaWxkcmVuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQ09MTElTSU9OLFxuICAgIGVkaXQ6IGVkaXQsXG4gICAgaGFzaDogaGFzaCxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgX21vZGlmeTogQ29sbGlzaW9uX19tb2RpZnlcbiAgfTtcbn07XG4vKipcbiAgICBJbnRlcm5hbCBub2RlIHdpdGggYSBzcGFyc2Ugc2V0IG9mIGNoaWxkcmVuLlxuXG4gICAgVXNlcyBhIGJpdG1hcCBhbmQgYXJyYXkgdG8gcGFjayBjaGlsZHJlbi5cblxuICBAbWVtYmVyIGVkaXQgRWRpdCBvZiB0aGUgbm9kZS5cbiAgICBAbWVtYmVyIG1hc2sgQml0bWFwIHRoYXQgZW5jb2RlIHRoZSBwb3NpdGlvbnMgb2YgY2hpbGRyZW4gaW4gdGhlIGFycmF5LlxuICAgIEBtZW1iZXIgY2hpbGRyZW4gQXJyYXkgb2YgY2hpbGQgbm9kZXMuXG4qL1xuXG5cbnZhciBJbmRleGVkTm9kZSA9IGZ1bmN0aW9uIEluZGV4ZWROb2RlKGVkaXQsIG1hc2ssIGNoaWxkcmVuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogSU5ERVgsXG4gICAgZWRpdDogZWRpdCxcbiAgICBtYXNrOiBtYXNrLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBfbW9kaWZ5OiBJbmRleGVkTm9kZV9fbW9kaWZ5XG4gIH07XG59O1xuLyoqXG4gICAgSW50ZXJuYWwgbm9kZSB3aXRoIG1hbnkgY2hpbGRyZW4uXG5cbiAgICBAbWVtYmVyIGVkaXQgRWRpdCBvZiB0aGUgbm9kZS5cbiAgICBAbWVtYmVyIHNpemUgTnVtYmVyIG9mIGNoaWxkcmVuLlxuICAgIEBtZW1iZXIgY2hpbGRyZW4gQXJyYXkgb2YgY2hpbGQgbm9kZXMuXG4qL1xuXG5cbnZhciBBcnJheU5vZGUgPSBmdW5jdGlvbiBBcnJheU5vZGUoZWRpdCwgc2l6ZSwgY2hpbGRyZW4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBUlJBWSxcbiAgICBlZGl0OiBlZGl0LFxuICAgIHNpemU6IHNpemUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIF9tb2RpZnk6IEFycmF5Tm9kZV9fbW9kaWZ5XG4gIH07XG59O1xuLyoqXG4gICAgSXMgYG5vZGVgIGEgbGVhZiBub2RlP1xuKi9cblxuXG52YXIgaXNMZWFmID0gZnVuY3Rpb24gaXNMZWFmKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgPT09IGVtcHR5IHx8IG5vZGUudHlwZSA9PT0gTEVBRiB8fCBub2RlLnR5cGUgPT09IENPTExJU0lPTjtcbn07XG4vKiBJbnRlcm5hbCBub2RlIG9wZXJhdGlvbnMuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBFeHBhbmQgYW4gaW5kZXhlZCBub2RlIGludG8gYW4gYXJyYXkgbm9kZS5cblxuICBAcGFyYW0gZWRpdCBDdXJyZW50IGVkaXQuXG4gICAgQHBhcmFtIGZyYWcgSW5kZXggb2YgYWRkZWQgY2hpbGQuXG4gICAgQHBhcmFtIGNoaWxkIEFkZGVkIGNoaWxkLlxuICAgIEBwYXJhbSBtYXNrIEluZGV4IG5vZGUgbWFzayBiZWZvcmUgY2hpbGQgYWRkZWQuXG4gICAgQHBhcmFtIHN1Yk5vZGVzIEluZGV4IG5vZGUgY2hpbGRyZW4gYmVmb3JlIGNoaWxkIGFkZGVkLlxuKi9cblxuXG52YXIgZXhwYW5kID0gZnVuY3Rpb24gZXhwYW5kKGVkaXQsIGZyYWcsIGNoaWxkLCBiaXRtYXAsIHN1Yk5vZGVzKSB7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGJpdCA9IGJpdG1hcDtcbiAgdmFyIGNvdW50ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgYml0OyArK2kpIHtcbiAgICBpZiAoYml0ICYgMSkgYXJyW2ldID0gc3ViTm9kZXNbY291bnQrK107XG4gICAgYml0ID4+Pj0gMTtcbiAgfVxuXG4gIGFycltmcmFnXSA9IGNoaWxkO1xuICByZXR1cm4gQXJyYXlOb2RlKGVkaXQsIGNvdW50ICsgMSwgYXJyKTtcbn07XG4vKipcbiAgICBDb2xsYXBzZSBhbiBhcnJheSBub2RlIGludG8gYSBpbmRleGVkIG5vZGUuXG5cbiAgQHBhcmFtIGVkaXQgQ3VycmVudCBlZGl0LlxuICAgIEBwYXJhbSBjb3VudCBOdW1iZXIgb2YgZWxlbWVudHMgaW4gbmV3IGFycmF5LlxuICAgIEBwYXJhbSByZW1vdmVkIEluZGV4IG9mIHJlbW92ZWQgZWxlbWVudC5cbiAgICBAcGFyYW0gZWxlbWVudHMgQXJyYXkgbm9kZSBjaGlsZHJlbiBiZWZvcmUgcmVtb3ZlLlxuKi9cblxuXG52YXIgcGFjayA9IGZ1bmN0aW9uIHBhY2soZWRpdCwgY291bnQsIHJlbW92ZWQsIGVsZW1lbnRzKSB7XG4gIHZhciBjaGlsZHJlbiA9IG5ldyBBcnJheShjb3VudCAtIDEpO1xuICB2YXIgZyA9IDA7XG4gIHZhciBiaXRtYXAgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChpICE9PSByZW1vdmVkKSB7XG4gICAgICB2YXIgZWxlbSA9IGVsZW1lbnRzW2ldO1xuXG4gICAgICBpZiAoZWxlbSAmJiAhaXNFbXB0eU5vZGUoZWxlbSkpIHtcbiAgICAgICAgY2hpbGRyZW5bZysrXSA9IGVsZW07XG4gICAgICAgIGJpdG1hcCB8PSAxIDw8IGk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEluZGV4ZWROb2RlKGVkaXQsIGJpdG1hcCwgY2hpbGRyZW4pO1xufTtcbi8qKlxuICAgIE1lcmdlIHR3byBsZWFmIG5vZGVzLlxuXG4gICAgQHBhcmFtIHNoaWZ0IEN1cnJlbnQgc2hpZnQuXG4gICAgQHBhcmFtIGgxIE5vZGUgMSBoYXNoLlxuICAgIEBwYXJhbSBuMSBOb2RlIDEuXG4gICAgQHBhcmFtIGgyIE5vZGUgMiBoYXNoLlxuICAgIEBwYXJhbSBuMiBOb2RlIDIuXG4qL1xuXG5cbnZhciBtZXJnZUxlYXZlcyA9IGZ1bmN0aW9uIG1lcmdlTGVhdmVzKGVkaXQsIHNoaWZ0LCBoMSwgbjEsIGgyLCBuMikge1xuICBpZiAoaDEgPT09IGgyKSByZXR1cm4gQ29sbGlzaW9uKGVkaXQsIGgxLCBbbjIsIG4xXSk7XG4gIHZhciBzdWJIMSA9IGhhc2hGcmFnbWVudChzaGlmdCwgaDEpO1xuICB2YXIgc3ViSDIgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGgyKTtcbiAgcmV0dXJuIEluZGV4ZWROb2RlKGVkaXQsIHRvQml0bWFwKHN1YkgxKSB8IHRvQml0bWFwKHN1YkgyKSwgc3ViSDEgPT09IHN1YkgyID8gW21lcmdlTGVhdmVzKGVkaXQsIHNoaWZ0ICsgU0laRSwgaDEsIG4xLCBoMiwgbjIpXSA6IHN1YkgxIDwgc3ViSDIgPyBbbjEsIG4yXSA6IFtuMiwgbjFdKTtcbn07XG4vKipcbiAgICBVcGRhdGUgYW4gZW50cnkgaW4gYSBjb2xsaXNpb24gbGlzdC5cblxuICAgIEBwYXJhbSBtdXRhdGUgU2hvdWxkIG11dGF0aW9uIGJlIHVzZWQ/XG4gICAgQHBhcmFtIGVkaXQgQ3VycmVudCBlZGl0LlxuICAgIEBwYXJhbSBrZXlFcSBLZXkgY29tcGFyZSBmdW5jdGlvbi5cbiAgICBAcGFyYW0gaGFzaCBIYXNoIG9mIGNvbGxpc2lvbi5cbiAgICBAcGFyYW0gbGlzdCBDb2xsaXNpb24gbGlzdC5cbiAgICBAcGFyYW0gZiBVcGRhdGUgZnVuY3Rpb24uXG4gICAgQHBhcmFtIGsgS2V5IHRvIHVwZGF0ZS5cbiAgICBAcGFyYW0gc2l6ZSBTaXplIHJlZi5cbiovXG5cblxudmFyIHVwZGF0ZUNvbGxpc2lvbkxpc3QgPSBmdW5jdGlvbiB1cGRhdGVDb2xsaXNpb25MaXN0KG11dGF0ZSwgZWRpdCwga2V5RXEsIGgsIGxpc3QsIGYsIGssIHNpemUpIHtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgY2hpbGQgPSBsaXN0W2ldO1xuXG4gICAgaWYgKGtleUVxKGssIGNoaWxkLmtleSkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGNoaWxkLnZhbHVlO1xuXG4gICAgICB2YXIgX25ld1ZhbHVlID0gZih2YWx1ZSk7XG5cbiAgICAgIGlmIChfbmV3VmFsdWUgPT09IHZhbHVlKSByZXR1cm4gbGlzdDtcblxuICAgICAgaWYgKF9uZXdWYWx1ZSA9PT0gbm90aGluZykge1xuICAgICAgICAtLXNpemUudmFsdWU7XG4gICAgICAgIHJldHVybiBhcnJheVNwbGljZU91dChtdXRhdGUsIGksIGxpc3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyYXlVcGRhdGUobXV0YXRlLCBpLCBMZWFmKGVkaXQsIGgsIGssIF9uZXdWYWx1ZSksIGxpc3QpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdWYWx1ZSA9IGYoKTtcbiAgaWYgKG5ld1ZhbHVlID09PSBub3RoaW5nKSByZXR1cm4gbGlzdDtcbiAgKytzaXplLnZhbHVlO1xuICByZXR1cm4gYXJyYXlVcGRhdGUobXV0YXRlLCBsZW4sIExlYWYoZWRpdCwgaCwgaywgbmV3VmFsdWUpLCBsaXN0KTtcbn07XG5cbnZhciBjYW5FZGl0Tm9kZSA9IGZ1bmN0aW9uIGNhbkVkaXROb2RlKGVkaXQsIG5vZGUpIHtcbiAgcmV0dXJuIGVkaXQgPT09IG5vZGUuZWRpdDtcbn07XG4vKiBFZGl0aW5nXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbnZhciBMZWFmX19tb2RpZnkgPSBmdW5jdGlvbiBMZWFmX19tb2RpZnkoZWRpdCwga2V5RXEsIHNoaWZ0LCBmLCBoLCBrLCBzaXplKSB7XG4gIGlmIChrZXlFcShrLCB0aGlzLmtleSkpIHtcbiAgICB2YXIgX3YgPSBmKHRoaXMudmFsdWUpO1xuXG4gICAgaWYgKF92ID09PSB0aGlzLnZhbHVlKSByZXR1cm4gdGhpcztlbHNlIGlmIChfdiA9PT0gbm90aGluZykge1xuICAgICAgLS1zaXplLnZhbHVlO1xuICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH1cblxuICAgIGlmIChjYW5FZGl0Tm9kZShlZGl0LCB0aGlzKSkge1xuICAgICAgdGhpcy52YWx1ZSA9IF92O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIExlYWYoZWRpdCwgaCwgaywgX3YpO1xuICB9XG5cbiAgdmFyIHYgPSBmKCk7XG4gIGlmICh2ID09PSBub3RoaW5nKSByZXR1cm4gdGhpcztcbiAgKytzaXplLnZhbHVlO1xuICByZXR1cm4gbWVyZ2VMZWF2ZXMoZWRpdCwgc2hpZnQsIHRoaXMuaGFzaCwgdGhpcywgaCwgTGVhZihlZGl0LCBoLCBrLCB2KSk7XG59O1xuXG52YXIgQ29sbGlzaW9uX19tb2RpZnkgPSBmdW5jdGlvbiBDb2xsaXNpb25fX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQsIGYsIGgsIGssIHNpemUpIHtcbiAgaWYgKGggPT09IHRoaXMuaGFzaCkge1xuICAgIHZhciBjYW5FZGl0ID0gY2FuRWRpdE5vZGUoZWRpdCwgdGhpcyk7XG4gICAgdmFyIGxpc3QgPSB1cGRhdGVDb2xsaXNpb25MaXN0KGNhbkVkaXQsIGVkaXQsIGtleUVxLCB0aGlzLmhhc2gsIHRoaXMuY2hpbGRyZW4sIGYsIGssIHNpemUpO1xuICAgIGlmIChsaXN0ID09PSB0aGlzLmNoaWxkcmVuKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gbGlzdC5sZW5ndGggPiAxID8gQ29sbGlzaW9uKGVkaXQsIHRoaXMuaGFzaCwgbGlzdCkgOiBsaXN0WzBdOyAvLyBjb2xsYXBzZSBzaW5nbGUgZWxlbWVudCBjb2xsaXNpb24gbGlzdFxuICB9XG5cbiAgdmFyIHYgPSBmKCk7XG4gIGlmICh2ID09PSBub3RoaW5nKSByZXR1cm4gdGhpcztcbiAgKytzaXplLnZhbHVlO1xuICByZXR1cm4gbWVyZ2VMZWF2ZXMoZWRpdCwgc2hpZnQsIHRoaXMuaGFzaCwgdGhpcywgaCwgTGVhZihlZGl0LCBoLCBrLCB2KSk7XG59O1xuXG52YXIgSW5kZXhlZE5vZGVfX21vZGlmeSA9IGZ1bmN0aW9uIEluZGV4ZWROb2RlX19tb2RpZnkoZWRpdCwga2V5RXEsIHNoaWZ0LCBmLCBoLCBrLCBzaXplKSB7XG4gIHZhciBtYXNrID0gdGhpcy5tYXNrO1xuICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICB2YXIgZnJhZyA9IGhhc2hGcmFnbWVudChzaGlmdCwgaCk7XG4gIHZhciBiaXQgPSB0b0JpdG1hcChmcmFnKTtcbiAgdmFyIGluZHggPSBmcm9tQml0bWFwKG1hc2ssIGJpdCk7XG4gIHZhciBleGlzdHMgPSBtYXNrICYgYml0O1xuICB2YXIgY3VycmVudCA9IGV4aXN0cyA/IGNoaWxkcmVuW2luZHhdIDogZW1wdHk7XG5cbiAgdmFyIGNoaWxkID0gY3VycmVudC5fbW9kaWZ5KGVkaXQsIGtleUVxLCBzaGlmdCArIFNJWkUsIGYsIGgsIGssIHNpemUpO1xuXG4gIGlmIChjdXJyZW50ID09PSBjaGlsZCkgcmV0dXJuIHRoaXM7XG4gIHZhciBjYW5FZGl0ID0gY2FuRWRpdE5vZGUoZWRpdCwgdGhpcyk7XG4gIHZhciBiaXRtYXAgPSBtYXNrO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSB2b2lkIDA7XG5cbiAgaWYgKGV4aXN0cyAmJiBpc0VtcHR5Tm9kZShjaGlsZCkpIHtcbiAgICAvLyByZW1vdmVcbiAgICBiaXRtYXAgJj0gfmJpdDtcbiAgICBpZiAoIWJpdG1hcCkgcmV0dXJuIGVtcHR5O1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPD0gMiAmJiBpc0xlYWYoY2hpbGRyZW5baW5keCBeIDFdKSkgcmV0dXJuIGNoaWxkcmVuW2luZHggXiAxXTsgLy8gY29sbGFwc2VcblxuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlTcGxpY2VPdXQoY2FuRWRpdCwgaW5keCwgY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKCFleGlzdHMgJiYgIWlzRW1wdHlOb2RlKGNoaWxkKSkge1xuICAgIC8vIGFkZFxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPj0gTUFYX0lOREVYX05PREUpIHJldHVybiBleHBhbmQoZWRpdCwgZnJhZywgY2hpbGQsIG1hc2ssIGNoaWxkcmVuKTtcbiAgICBiaXRtYXAgfD0gYml0O1xuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlTcGxpY2VJbihjYW5FZGl0LCBpbmR4LCBjaGlsZCwgY2hpbGRyZW4pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1vZGlmeVxuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlVcGRhdGUoY2FuRWRpdCwgaW5keCwgY2hpbGQsIGNoaWxkcmVuKTtcbiAgfVxuXG4gIGlmIChjYW5FZGl0KSB7XG4gICAgdGhpcy5tYXNrID0gYml0bWFwO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldHVybiBJbmRleGVkTm9kZShlZGl0LCBiaXRtYXAsIG5ld0NoaWxkcmVuKTtcbn07XG5cbnZhciBBcnJheU5vZGVfX21vZGlmeSA9IGZ1bmN0aW9uIEFycmF5Tm9kZV9fbW9kaWZ5KGVkaXQsIGtleUVxLCBzaGlmdCwgZiwgaCwgaywgc2l6ZSkge1xuICB2YXIgY291bnQgPSB0aGlzLnNpemU7XG4gIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gIHZhciBmcmFnID0gaGFzaEZyYWdtZW50KHNoaWZ0LCBoKTtcbiAgdmFyIGNoaWxkID0gY2hpbGRyZW5bZnJhZ107XG5cbiAgdmFyIG5ld0NoaWxkID0gKGNoaWxkIHx8IGVtcHR5KS5fbW9kaWZ5KGVkaXQsIGtleUVxLCBzaGlmdCArIFNJWkUsIGYsIGgsIGssIHNpemUpO1xuXG4gIGlmIChjaGlsZCA9PT0gbmV3Q2hpbGQpIHJldHVybiB0aGlzO1xuICB2YXIgY2FuRWRpdCA9IGNhbkVkaXROb2RlKGVkaXQsIHRoaXMpO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSB2b2lkIDA7XG5cbiAgaWYgKGlzRW1wdHlOb2RlKGNoaWxkKSAmJiAhaXNFbXB0eU5vZGUobmV3Q2hpbGQpKSB7XG4gICAgLy8gYWRkXG4gICAgKytjb3VudDtcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5VXBkYXRlKGNhbkVkaXQsIGZyYWcsIG5ld0NoaWxkLCBjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAoIWlzRW1wdHlOb2RlKGNoaWxkKSAmJiBpc0VtcHR5Tm9kZShuZXdDaGlsZCkpIHtcbiAgICAvLyByZW1vdmVcbiAgICAtLWNvdW50O1xuICAgIGlmIChjb3VudCA8PSBNSU5fQVJSQVlfTk9ERSkgcmV0dXJuIHBhY2soZWRpdCwgY291bnQsIGZyYWcsIGNoaWxkcmVuKTtcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5VXBkYXRlKGNhbkVkaXQsIGZyYWcsIGVtcHR5LCBjaGlsZHJlbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gbW9kaWZ5XG4gICAgbmV3Q2hpbGRyZW4gPSBhcnJheVVwZGF0ZShjYW5FZGl0LCBmcmFnLCBuZXdDaGlsZCwgY2hpbGRyZW4pO1xuICB9XG5cbiAgaWYgKGNhbkVkaXQpIHtcbiAgICB0aGlzLnNpemUgPSBjb3VudDtcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gQXJyYXlOb2RlKGVkaXQsIGNvdW50LCBuZXdDaGlsZHJlbik7XG59O1xuXG5lbXB0eS5fbW9kaWZ5ID0gZnVuY3Rpb24gKGVkaXQsIGtleUVxLCBzaGlmdCwgZiwgaCwgaywgc2l6ZSkge1xuICB2YXIgdiA9IGYoKTtcbiAgaWYgKHYgPT09IG5vdGhpbmcpIHJldHVybiBlbXB0eTtcbiAgKytzaXplLnZhbHVlO1xuICByZXR1cm4gTGVhZihlZGl0LCBoLCBrLCB2KTtcbn07XG4vKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5mdW5jdGlvbiBNYXAoZWRpdGFibGUsIGVkaXQsIGNvbmZpZywgcm9vdCwgc2l6ZSkge1xuICB0aGlzLl9lZGl0YWJsZSA9IGVkaXRhYmxlO1xuICB0aGlzLl9lZGl0ID0gZWRpdDtcbiAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICB0aGlzLl9yb290ID0gcm9vdDtcbiAgdGhpcy5fc2l6ZSA9IHNpemU7XG59XG5cbk1hcC5wcm90b3R5cGUuc2V0VHJlZSA9IGZ1bmN0aW9uIChuZXdSb290LCBuZXdTaXplKSB7XG4gIGlmICh0aGlzLl9lZGl0YWJsZSkge1xuICAgIHRoaXMuX3Jvb3QgPSBuZXdSb290O1xuICAgIHRoaXMuX3NpemUgPSBuZXdTaXplO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIG5ld1Jvb3QgPT09IHRoaXMuX3Jvb3QgPyB0aGlzIDogbmV3IE1hcCh0aGlzLl9lZGl0YWJsZSwgdGhpcy5fZWRpdCwgdGhpcy5fY29uZmlnLCBuZXdSb290LCBuZXdTaXplKTtcbn07XG4vKiBRdWVyaWVzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBMb29rdXAgdGhlIHZhbHVlIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBhIGN1c3RvbSBgaGFzaGAuXG5cbiAgICBSZXR1cm5zIHRoZSB2YWx1ZSBvciBgYWx0YCBpZiBub25lLlxuKi9cblxuXG52YXIgdHJ5R2V0SGFzaCA9IGhhbXQudHJ5R2V0SGFzaCA9IGZ1bmN0aW9uIChhbHQsIGhhc2gsIGtleSwgbWFwKSB7XG4gIHZhciBub2RlID0gbWFwLl9yb290O1xuICB2YXIgc2hpZnQgPSAwO1xuICB2YXIga2V5RXEgPSBtYXAuX2NvbmZpZy5rZXlFcTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIExFQUY6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4ga2V5RXEoa2V5LCBub2RlLmtleSkgPyBub2RlLnZhbHVlIDogYWx0O1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ09MTElTSU9OOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGhhc2ggPT09IG5vZGUuaGFzaCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICBpZiAoa2V5RXEoa2V5LCBjaGlsZC5rZXkpKSByZXR1cm4gY2hpbGQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFsdDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIElOREVYOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGZyYWcgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGhhc2gpO1xuICAgICAgICAgIHZhciBiaXQgPSB0b0JpdG1hcChmcmFnKTtcblxuICAgICAgICAgIGlmIChub2RlLm1hc2sgJiBiaXQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW2Zyb21CaXRtYXAobm9kZS5tYXNrLCBiaXQpXTtcbiAgICAgICAgICAgIHNoaWZ0ICs9IFNJWkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYWx0O1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQVJSQVk6XG4gICAgICAgIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlbltoYXNoRnJhZ21lbnQoc2hpZnQsIGhhc2gpXTtcblxuICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBzaGlmdCArPSBTSVpFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFsdDtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYWx0O1xuICAgIH1cbiAgfVxufTtcblxuTWFwLnByb3RvdHlwZS50cnlHZXRIYXNoID0gZnVuY3Rpb24gKGFsdCwgaGFzaCwga2V5KSB7XG4gIHJldHVybiB0cnlHZXRIYXNoKGFsdCwgaGFzaCwga2V5LCB0aGlzKTtcbn07XG4vKipcbiAgICBMb29rdXAgdGhlIHZhbHVlIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxuXG4gICAgQHNlZSBgdHJ5R2V0SGFzaGBcbiovXG5cblxudmFyIHRyeUdldCA9IGhhbXQudHJ5R2V0ID0gZnVuY3Rpb24gKGFsdCwga2V5LCBtYXApIHtcbiAgcmV0dXJuIHRyeUdldEhhc2goYWx0LCBtYXAuX2NvbmZpZy5oYXNoKGtleSksIGtleSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUudHJ5R2V0ID0gZnVuY3Rpb24gKGFsdCwga2V5KSB7XG4gIHJldHVybiB0cnlHZXQoYWx0LCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIExvb2t1cCB0aGUgdmFsdWUgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGEgY3VzdG9tIGBoYXNoYC5cblxuICAgIFJldHVybnMgdGhlIHZhbHVlIG9yIGB1bmRlZmluZWRgIGlmIG5vbmUuXG4qL1xuXG5cbnZhciBnZXRIYXNoID0gaGFtdC5nZXRIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgbWFwKSB7XG4gIHJldHVybiB0cnlHZXRIYXNoKHVuZGVmaW5lZCwgaGFzaCwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5nZXRIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSkge1xuICByZXR1cm4gZ2V0SGFzaChoYXNoLCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIExvb2t1cCB0aGUgdmFsdWUgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGludGVybmFsIGhhc2ggZnVuY3Rpb24uXG5cbiAgICBAc2VlIGBnZXRgXG4qL1xuXG5cbnZhciBnZXQgPSBoYW10LmdldCA9IGZ1bmN0aW9uIChrZXksIG1hcCkge1xuICByZXR1cm4gdHJ5R2V0SGFzaCh1bmRlZmluZWQsIG1hcC5fY29uZmlnLmhhc2goa2V5KSwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5LCBhbHQpIHtcbiAgcmV0dXJuIHRyeUdldChhbHQsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgRG9lcyBhbiBlbnRyeSBleGlzdCBmb3IgYGtleWAgaW4gYG1hcGA/IFVzZXMgY3VzdG9tIGBoYXNoYC5cbiovXG5cblxudmFyIGhhc0hhc2ggPSBoYW10LmhhcyA9IGZ1bmN0aW9uIChoYXNoLCBrZXksIG1hcCkge1xuICByZXR1cm4gdHJ5R2V0SGFzaChub3RoaW5nLCBoYXNoLCBrZXksIG1hcCkgIT09IG5vdGhpbmc7XG59O1xuXG5NYXAucHJvdG90eXBlLmhhc0hhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5KSB7XG4gIHJldHVybiBoYXNIYXNoKGhhc2gsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgRG9lcyBhbiBlbnRyeSBleGlzdCBmb3IgYGtleWAgaW4gYG1hcGA/IFVzZXMgaW50ZXJuYWwgaGFzaCBmdW5jdGlvbi5cbiovXG5cblxudmFyIGhhcyA9IGhhbXQuaGFzID0gZnVuY3Rpb24gKGtleSwgbWFwKSB7XG4gIHJldHVybiBoYXNIYXNoKG1hcC5fY29uZmlnLmhhc2goa2V5KSwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBoYXMoa2V5LCB0aGlzKTtcbn07XG5cbnZhciBkZWZLZXlDb21wYXJlID0gZnVuY3Rpb24gZGVmS2V5Q29tcGFyZSh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5O1xufTtcbi8qKlxuICAgIENyZWF0ZSBhbiBlbXB0eSBtYXAuXG5cbiAgICBAcGFyYW0gY29uZmlnIENvbmZpZ3VyYXRpb24uXG4qL1xuXG5cbmhhbXQubWFrZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBNYXAoMCwgMCwge1xuICAgIGtleUVxOiBjb25maWcgJiYgY29uZmlnLmtleUVxIHx8IGRlZktleUNvbXBhcmUsXG4gICAgaGFzaDogY29uZmlnICYmIGNvbmZpZy5oYXNoIHx8IGhhc2hcbiAgfSwgZW1wdHksIDApO1xufTtcbi8qKlxuICAgIEVtcHR5IG1hcC5cbiovXG5cblxuaGFtdC5lbXB0eSA9IGhhbXQubWFrZSgpO1xuLyoqXG4gICAgRG9lcyBgbWFwYCBjb250YWluIGFueSBlbGVtZW50cz9cbiovXG5cbnZhciBpc0VtcHR5ID0gaGFtdC5pc0VtcHR5ID0gZnVuY3Rpb24gKG1hcCkge1xuICByZXR1cm4gbWFwICYmICEhaXNFbXB0eU5vZGUobWFwLl9yb290KTtcbn07XG5cbk1hcC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRW1wdHkodGhpcyk7XG59O1xuLyogVXBkYXRlc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgQWx0ZXIgdGhlIHZhbHVlIHN0b3JlZCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgZnVuY3Rpb24gYGZgIHVzaW5nXG4gICAgY3VzdG9tIGhhc2guXG5cbiAgICBgZmAgaXMgaW52b2tlZCB3aXRoIHRoZSBjdXJyZW50IHZhbHVlIGZvciBga2AgaWYgaXQgZXhpc3RzLFxuICAgIG9yIG5vIGFyZ3VtZW50cyBpZiBubyBzdWNoIHZhbHVlIGV4aXN0cy4gYG1vZGlmeWAgd2lsbCBhbHdheXMgZWl0aGVyXG4gICAgdXBkYXRlIG9yIGluc2VydCBhIHZhbHVlIGludG8gdGhlIG1hcC5cblxuICAgIFJldHVybnMgYSBtYXAgd2l0aCB0aGUgbW9kaWZpZWQgdmFsdWUuIERvZXMgbm90IGFsdGVyIGBtYXBgLlxuKi9cblxuXG52YXIgbW9kaWZ5SGFzaCA9IGhhbXQubW9kaWZ5SGFzaCA9IGZ1bmN0aW9uIChmLCBoYXNoLCBrZXksIG1hcCkge1xuICB2YXIgc2l6ZSA9IHtcbiAgICB2YWx1ZTogbWFwLl9zaXplXG4gIH07XG5cbiAgdmFyIG5ld1Jvb3QgPSBtYXAuX3Jvb3QuX21vZGlmeShtYXAuX2VkaXRhYmxlID8gbWFwLl9lZGl0IDogTmFOLCBtYXAuX2NvbmZpZy5rZXlFcSwgMCwgZiwgaGFzaCwga2V5LCBzaXplKTtcblxuICByZXR1cm4gbWFwLnNldFRyZWUobmV3Um9vdCwgc2l6ZS52YWx1ZSk7XG59O1xuXG5NYXAucHJvdG90eXBlLm1vZGlmeUhhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5LCBmKSB7XG4gIHJldHVybiBtb2RpZnlIYXNoKGYsIGhhc2gsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgQWx0ZXIgdGhlIHZhbHVlIHN0b3JlZCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgZnVuY3Rpb24gYGZgIHVzaW5nXG4gICAgaW50ZXJuYWwgaGFzaCBmdW5jdGlvbi5cblxuICAgIEBzZWUgYG1vZGlmeUhhc2hgXG4qL1xuXG5cbnZhciBtb2RpZnkgPSBoYW10Lm1vZGlmeSA9IGZ1bmN0aW9uIChmLCBrZXksIG1hcCkge1xuICByZXR1cm4gbW9kaWZ5SGFzaChmLCBtYXAuX2NvbmZpZy5oYXNoKGtleSksIGtleSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUubW9kaWZ5ID0gZnVuY3Rpb24gKGtleSwgZikge1xuICByZXR1cm4gbW9kaWZ5KGYsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgU3RvcmUgYHZhbHVlYCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgY3VzdG9tIGBoYXNoYC5cblxuICAgIFJldHVybnMgYSBtYXAgd2l0aCB0aGUgbW9kaWZpZWQgdmFsdWUuIERvZXMgbm90IGFsdGVyIGBtYXBgLlxuKi9cblxuXG52YXIgc2V0SGFzaCA9IGhhbXQuc2V0SGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXksIHZhbHVlLCBtYXApIHtcbiAgcmV0dXJuIG1vZGlmeUhhc2goY29uc3RhbnQodmFsdWUpLCBoYXNoLCBrZXksIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLnNldEhhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc2V0SGFzaChoYXNoLCBrZXksIHZhbHVlLCB0aGlzKTtcbn07XG4vKipcbiAgICBTdG9yZSBgdmFsdWVgIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxuXG4gICAgQHNlZSBgc2V0SGFzaGBcbiovXG5cblxudmFyIHNldCA9IGhhbXQuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG1hcCkge1xuICByZXR1cm4gc2V0SGFzaChtYXAuX2NvbmZpZy5oYXNoKGtleSksIGtleSwgdmFsdWUsIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzZXQoa2V5LCB2YWx1ZSwgdGhpcyk7XG59O1xuLyoqXG4gICAgUmVtb3ZlIHRoZSBlbnRyeSBmb3IgYGtleWAgaW4gYG1hcGAuXG5cbiAgICBSZXR1cm5zIGEgbWFwIHdpdGggdGhlIHZhbHVlIHJlbW92ZWQuIERvZXMgbm90IGFsdGVyIGBtYXBgLlxuKi9cblxuXG52YXIgZGVsID0gY29uc3RhbnQobm90aGluZyk7XG5cbnZhciByZW1vdmVIYXNoID0gaGFtdC5yZW1vdmVIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgbWFwKSB7XG4gIHJldHVybiBtb2RpZnlIYXNoKGRlbCwgaGFzaCwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5yZW1vdmVIYXNoID0gTWFwLnByb3RvdHlwZS5kZWxldGVIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSkge1xuICByZXR1cm4gcmVtb3ZlSGFzaChoYXNoLCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIFJlbW92ZSB0aGUgZW50cnkgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGludGVybmFsIGhhc2ggZnVuY3Rpb24uXG5cbiAgICBAc2VlIGByZW1vdmVIYXNoYFxuKi9cblxuXG52YXIgcmVtb3ZlID0gaGFtdC5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5LCBtYXApIHtcbiAgcmV0dXJuIHJlbW92ZUhhc2gobWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLnJlbW92ZSA9IE1hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gcmVtb3ZlKGtleSwgdGhpcyk7XG59O1xuLyogTXV0YXRpb25cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICAgIE1hcmsgYG1hcGAgYXMgbXV0YWJsZS5cbiAqL1xuXG5cbnZhciBiZWdpbk11dGF0aW9uID0gaGFtdC5iZWdpbk11dGF0aW9uID0gZnVuY3Rpb24gKG1hcCkge1xuICByZXR1cm4gbmV3IE1hcChtYXAuX2VkaXRhYmxlICsgMSwgbWFwLl9lZGl0ICsgMSwgbWFwLl9jb25maWcsIG1hcC5fcm9vdCwgbWFwLl9zaXplKTtcbn07XG5cbk1hcC5wcm90b3R5cGUuYmVnaW5NdXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGJlZ2luTXV0YXRpb24odGhpcyk7XG59O1xuLyoqXG4gICAgTWFyayBgbWFwYCBhcyBpbW11dGFibGUuXG4gKi9cblxuXG52YXIgZW5kTXV0YXRpb24gPSBoYW10LmVuZE11dGF0aW9uID0gZnVuY3Rpb24gKG1hcCkge1xuICBtYXAuX2VkaXRhYmxlID0gbWFwLl9lZGl0YWJsZSAmJiBtYXAuX2VkaXRhYmxlIC0gMTtcbiAgcmV0dXJuIG1hcDtcbn07XG5cbk1hcC5wcm90b3R5cGUuZW5kTXV0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBlbmRNdXRhdGlvbih0aGlzKTtcbn07XG4vKipcbiAgICBNdXRhdGUgYG1hcGAgd2l0aGluIHRoZSBjb250ZXh0IG9mIGBmYC5cbiAgICBAcGFyYW0gZlxuICAgIEBwYXJhbSBtYXAgSEFNVFxuKi9cblxuXG52YXIgbXV0YXRlID0gaGFtdC5tdXRhdGUgPSBmdW5jdGlvbiAoZiwgbWFwKSB7XG4gIHZhciB0cmFuc2llbnQgPSBiZWdpbk11dGF0aW9uKG1hcCk7XG4gIGYodHJhbnNpZW50KTtcbiAgcmV0dXJuIGVuZE11dGF0aW9uKHRyYW5zaWVudCk7XG59O1xuXG5NYXAucHJvdG90eXBlLm11dGF0ZSA9IGZ1bmN0aW9uIChmKSB7XG4gIHJldHVybiBtdXRhdGUoZiwgdGhpcyk7XG59O1xuLyogVHJhdmVyc2FsXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBBcHBseSBhIGNvbnRpbnVhdGlvbi5cbiovXG5cblxudmFyIGFwcGsgPSBmdW5jdGlvbiBhcHBrKGspIHtcbiAgcmV0dXJuIGsgJiYgbGF6eVZpc2l0Q2hpbGRyZW4oa1swXSwga1sxXSwga1syXSwga1szXSwga1s0XSk7XG59O1xuLyoqXG4gICAgUmVjdXJzaXZlbHkgdmlzaXQgYWxsIHZhbHVlcyBzdG9yZWQgaW4gYW4gYXJyYXkgb2Ygbm9kZXMgbGF6aWx5LlxuKi9cblxuXG52YXIgbGF6eVZpc2l0Q2hpbGRyZW4gPSBmdW5jdGlvbiBsYXp5VmlzaXRDaGlsZHJlbihsZW4sIGNoaWxkcmVuLCBpLCBmLCBrKSB7XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baSsrXTtcbiAgICBpZiAoY2hpbGQgJiYgIWlzRW1wdHlOb2RlKGNoaWxkKSkgcmV0dXJuIGxhenlWaXNpdChjaGlsZCwgZiwgW2xlbiwgY2hpbGRyZW4sIGksIGYsIGtdKTtcbiAgfVxuXG4gIHJldHVybiBhcHBrKGspO1xufTtcbi8qKlxuICAgIFJlY3Vyc2l2ZWx5IHZpc2l0IGFsbCB2YWx1ZXMgc3RvcmVkIGluIGBub2RlYCBsYXppbHkuXG4qL1xuXG5cbnZhciBsYXp5VmlzaXQgPSBmdW5jdGlvbiBsYXp5VmlzaXQobm9kZSwgZiwgaykge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgTEVBRjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBmKG5vZGUpLFxuICAgICAgICByZXN0OiBrXG4gICAgICB9O1xuXG4gICAgY2FzZSBDT0xMSVNJT046XG4gICAgY2FzZSBBUlJBWTpcbiAgICBjYXNlIElOREVYOlxuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIHJldHVybiBsYXp5VmlzaXRDaGlsZHJlbihjaGlsZHJlbi5sZW5ndGgsIGNoaWxkcmVuLCAwLCBmLCBrKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXBwayhrKTtcbiAgfVxufTtcblxudmFyIERPTkUgPSB7XG4gIGRvbmU6IHRydWVcbn07XG4vKipcbiAgICBKYXZhc2NyaXB0IGl0ZXJhdG9yIG92ZXIgYSBtYXAuXG4qL1xuXG5mdW5jdGlvbiBNYXBJdGVyYXRvcih2KSB7XG4gIHRoaXMudiA9IHY7XG59XG5cbk1hcEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudikgcmV0dXJuIERPTkU7XG4gIHZhciB2MCA9IHRoaXMudjtcbiAgdGhpcy52ID0gYXBwayh2MC5yZXN0KTtcbiAgcmV0dXJuIHYwO1xufTtcblxuTWFwSXRlcmF0b3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICAgIExhemlseSB2aXNpdCBlYWNoIHZhbHVlIGluIG1hcCB3aXRoIGZ1bmN0aW9uIGBmYC5cbiovXG5cblxudmFyIHZpc2l0ID0gZnVuY3Rpb24gdmlzaXQobWFwLCBmKSB7XG4gIHJldHVybiBuZXcgTWFwSXRlcmF0b3IobGF6eVZpc2l0KG1hcC5fcm9vdCwgZikpO1xufTtcbi8qKlxuICAgIEdldCBhIEphdmFzY3NyaXB0IGl0ZXJhdG9yIG9mIGBtYXBgLlxuXG4gICAgSXRlcmF0ZXMgb3ZlciBgW2tleSwgdmFsdWVdYCBhcnJheXMuXG4qL1xuXG5cbnZhciBidWlsZFBhaXJzID0gZnVuY3Rpb24gYnVpbGRQYWlycyh4KSB7XG4gIHJldHVybiBbeC5rZXksIHgudmFsdWVdO1xufTtcblxudmFyIGVudHJpZXMgPSBoYW10LmVudHJpZXMgPSBmdW5jdGlvbiAobWFwKSB7XG4gIHJldHVybiB2aXNpdChtYXAsIGJ1aWxkUGFpcnMpO1xufTtcblxuTWFwLnByb3RvdHlwZS5lbnRyaWVzID0gTWFwLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZW50cmllcyh0aGlzKTtcbn07XG4vKipcbiAgICBHZXQgYXJyYXkgb2YgYWxsIGtleXMgaW4gYG1hcGAuXG5cbiAgICBPcmRlciBpcyBub3QgZ3VhcmFudGVlZC5cbiovXG5cblxudmFyIGJ1aWxkS2V5cyA9IGZ1bmN0aW9uIGJ1aWxkS2V5cyh4KSB7XG4gIHJldHVybiB4LmtleTtcbn07XG5cbnZhciBrZXlzID0gaGFtdC5rZXlzID0gZnVuY3Rpb24gKG1hcCkge1xuICByZXR1cm4gdmlzaXQobWFwLCBidWlsZEtleXMpO1xufTtcblxuTWFwLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ga2V5cyh0aGlzKTtcbn07XG4vKipcbiAgICBHZXQgYXJyYXkgb2YgYWxsIHZhbHVlcyBpbiBgbWFwYC5cblxuICAgIE9yZGVyIGlzIG5vdCBndWFyYW50ZWVkLCBkdXBsaWNhdGVzIGFyZSBwcmVzZXJ2ZWQuXG4qL1xuXG5cbnZhciBidWlsZFZhbHVlcyA9IGZ1bmN0aW9uIGJ1aWxkVmFsdWVzKHgpIHtcbiAgcmV0dXJuIHgudmFsdWU7XG59O1xuXG52YXIgdmFsdWVzID0gaGFtdC52YWx1ZXMgPSBNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uIChtYXApIHtcbiAgcmV0dXJuIHZpc2l0KG1hcCwgYnVpbGRWYWx1ZXMpO1xufTtcblxuTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB2YWx1ZXModGhpcyk7XG59O1xuLyogRm9sZFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgVmlzaXQgZXZlcnkgZW50cnkgaW4gdGhlIG1hcCwgYWdncmVnYXRpbmcgZGF0YS5cblxuICAgIE9yZGVyIG9mIG5vZGVzIGlzIG5vdCBndWFyYW50ZWVkLlxuXG4gICAgQHBhcmFtIGYgRnVuY3Rpb24gbWFwcGluZyBhY2N1bXVsYXRlZCB2YWx1ZSwgdmFsdWUsIGFuZCBrZXkgdG8gbmV3IHZhbHVlLlxuICAgIEBwYXJhbSB6IFN0YXJ0aW5nIHZhbHVlLlxuICAgIEBwYXJhbSBtIEhBTVRcbiovXG5cblxudmFyIGZvbGQgPSBoYW10LmZvbGQgPSBmdW5jdGlvbiAoZiwgeiwgbSkge1xuICB2YXIgcm9vdCA9IG0uX3Jvb3Q7XG4gIGlmIChyb290LnR5cGUgPT09IExFQUYpIHJldHVybiBmKHosIHJvb3QudmFsdWUsIHJvb3Qua2V5KTtcbiAgdmFyIHRvVmlzaXQgPSBbcm9vdC5jaGlsZHJlbl07XG4gIHZhciBjaGlsZHJlbiA9IHZvaWQgMDtcblxuICB3aGlsZSAoY2hpbGRyZW4gPSB0b1Zpc2l0LnBvcCgpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2krK107XG5cbiAgICAgIGlmIChjaGlsZCAmJiBjaGlsZC50eXBlKSB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBMRUFGKSB6ID0gZih6LCBjaGlsZC52YWx1ZSwgY2hpbGQua2V5KTtlbHNlIHRvVmlzaXQucHVzaChjaGlsZC5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHo7XG59O1xuXG5NYXAucHJvdG90eXBlLmZvbGQgPSBmdW5jdGlvbiAoZiwgeikge1xuICByZXR1cm4gZm9sZChmLCB6LCB0aGlzKTtcbn07XG4vKipcbiAgICBWaXNpdCBldmVyeSBlbnRyeSBpbiB0aGUgbWFwLCBhZ2dyZWdhdGluZyBkYXRhLlxuXG4gICAgT3JkZXIgb2Ygbm9kZXMgaXMgbm90IGd1YXJhbnRlZWQuXG5cbiAgICBAcGFyYW0gZiBGdW5jdGlvbiBpbnZva2VkIHdpdGggdmFsdWUgYW5kIGtleVxuICAgIEBwYXJhbSBtYXAgSEFNVFxuKi9cblxuXG52YXIgZm9yRWFjaCA9IGhhbXQuZm9yRWFjaCA9IGZ1bmN0aW9uIChmLCBtYXApIHtcbiAgcmV0dXJuIGZvbGQoZnVuY3Rpb24gKF8sIHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gZih2YWx1ZSwga2V5LCBtYXApO1xuICB9LCBudWxsLCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGYpIHtcbiAgcmV0dXJuIGZvckVhY2goZiwgdGhpcyk7XG59O1xuLyogQWdncmVnYXRlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBHZXQgdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIGBtYXBgLlxuKi9cblxuXG52YXIgY291bnQgPSBoYW10LmNvdW50ID0gZnVuY3Rpb24gKG1hcCkge1xuICByZXR1cm4gbWFwLl9zaXplO1xufTtcblxuTWFwLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNvdW50KHRoaXMpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcC5wcm90b3R5cGUsICdzaXplJywge1xuICBnZXQ6IE1hcC5wcm90b3R5cGUuY291bnRcbn0pO1xuLyogRXhwb3J0XG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5pZiAoIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaGFtdDtcbn0gZWxzZSB7XG4gIHVuZGVmaW5lZC5oYW10ID0gaGFtdDtcbn1cbn0pO1xuXG5jbGFzcyBCdWlsdEluTWFwIHtcbiAgY29uc3RydWN0b3IoZXhpc3RpbmcpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWFwXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKGV4aXN0aW5nID09PSBudWxsIHx8IGV4aXN0aW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGlzdGluZy5lbnRyaWVzKCkpO1xuICB9XG5cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcbiAgfVxuXG4gIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5lbnRyaWVzKCk7XG4gIH1cblxuICBnZXQoaykge1xuICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0KGspO1xuICB9XG5cbiAgaGFzKGspIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyhrKTtcbiAgfVxuXG4gIHNldChrLCB2KSB7XG4gICAgdGhpcy5fbWFwLnNldChrLCB2KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGVsZXRlKGspIHtcbiAgICB0aGlzLl9tYXAuZGVsZXRlKGspO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gcGVyc2lzdGVudE1hcCh0aGlzKTtcbiAgfVxuXG4gIHRvTWFwKCkge1xuICAgIHJldHVybiBuZXcgTWFwKHRoaXMuX21hcCk7XG4gIH1cblxufVxuXG5jbGFzcyBIYXNoQXJyYXlNYXBwZWRUcmllTWFwIHtcbiAgLy8gQmVjYXVzZSBoYW10LmVtcHR5IGlzIG5vdCBhIGZ1bmN0aW9uIHRoZXJlIGlzIG5vIHdheSB0byBpbnRyb2R1Y2UgdHlwZVxuICAvLyBwYXJhbWV0ZXJzIG9uIGl0LCBzbyBlbXB0eSBpcyB0eXBlZCBhcyBIQU1UUGx1c01hcDxzdHJpbmcsIG1peGVkPi5cbiAgLy8gJEZsb3dJc3N1ZVxuICBjb25zdHJ1Y3RvcihleGlzdGluZykge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9oYW10XCIsIGhhbXRfMS5lbXB0eS5iZWdpbk11dGF0aW9uKCkpO1xuXG4gICAgaWYgKGV4aXN0aW5nIGluc3RhbmNlb2YgSGFzaEFycmF5TWFwcGVkVHJpZU1hcCkge1xuICAgICAgY29uc3QgaCA9IGV4aXN0aW5nLl9oYW10LmVuZE11dGF0aW9uKCk7XG5cbiAgICAgIGV4aXN0aW5nLl9oYW10ID0gaC5iZWdpbk11dGF0aW9uKCk7XG4gICAgICB0aGlzLl9oYW10ID0gaC5iZWdpbk11dGF0aW9uKCk7XG4gICAgfSBlbHNlIGlmIChleGlzdGluZykge1xuICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgZXhpc3RpbmcuZW50cmllcygpKSB7XG4gICAgICAgIHRoaXMuX2hhbXQuc2V0KGssIHYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhbXQua2V5cygpO1xuICB9XG5cbiAgZW50cmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5faGFtdC5lbnRyaWVzKCk7XG4gIH1cblxuICBnZXQoaykge1xuICAgIHJldHVybiB0aGlzLl9oYW10LmdldChrKTtcbiAgfVxuXG4gIGhhcyhrKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhbXQuaGFzKGspO1xuICB9XG5cbiAgc2V0KGssIHYpIHtcbiAgICB0aGlzLl9oYW10LnNldChrLCB2KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGVsZXRlKGspIHtcbiAgICB0aGlzLl9oYW10LmRlbGV0ZShrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIHBlcnNpc3RlbnRNYXAodGhpcyk7XG4gIH1cblxuICB0b01hcCgpIHtcbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzLl9oYW10KTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHBlcnNpc3RlbnRNYXAoZXhpc3RpbmcpIHtcbiAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9oYW10XzIwMjAnKSkge1xuICAgIHJldHVybiBuZXcgSGFzaEFycmF5TWFwcGVkVHJpZU1hcChleGlzdGluZyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBCdWlsdEluTWFwKGV4aXN0aW5nKTtcbiAgfVxufVxuXG52YXIgUmVjb2lsX1BlcnNpc3RlbnRNYXAgPSB7XG4gIHBlcnNpc3RlbnRNYXBcbn07XG5cbnZhciBSZWNvaWxfUGVyc2lzdGVudE1hcF8xID0gUmVjb2lsX1BlcnNpc3RlbnRNYXAucGVyc2lzdGVudE1hcDtcblxudmFyIFJlY29pbF9QZXJzaXN0ZW50TWFwJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgcGVyc2lzdGVudE1hcDogUmVjb2lsX1BlcnNpc3RlbnRNYXBfMVxufSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIFJldHVybnMgYSBzZXQgY29udGFpbmluZyBhbGwgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBmaXJzdCBzZXQgdGhhdCBhcmUgbm90XG4gKiBwcmVzZW50IGluIGFueSBvZiB0aGUgc3Vic2VxdWVudCBzZXRzLlxuICpcbiAqIE5vdGU6IHRoaXMgaXMgd3JpdHRlbiBwcm9jZWR1cmFsbHkgKGkuZS4sIHdpdGhvdXQgZmlsdGVyU2V0KSBmb3IgcGVyZm9ybWFudFxuICogdXNlIGluIHRpZ2h0IGxvb3BzLlxuICovXG5cbmZ1bmN0aW9uIGRpZmZlcmVuY2VTZXRzKHNldCwgLi4uc2V0c1dpdGhWYWx1ZXNUb1JlbW92ZSkge1xuICBjb25zdCByZXQgPSBuZXcgU2V0KCk7XG5cbiAgRklSU1Q6IGZvciAoY29uc3QgdmFsdWUgb2Ygc2V0KSB7XG4gICAgZm9yIChjb25zdCBvdGhlclNldCBvZiBzZXRzV2l0aFZhbHVlc1RvUmVtb3ZlKSB7XG4gICAgICBpZiAob3RoZXJTZXQuaGFzKHZhbHVlKSkge1xuICAgICAgICBjb250aW51ZSBGSVJTVDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXQuYWRkKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbnZhciBSZWNvaWxfZGlmZmVyZW5jZVNldHMgPSBkaWZmZXJlbmNlU2V0cztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIG5ldyBNYXAgb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyB0aGUgb3JpZ2luYWwsIGJ1dCB3aXRoIHRoZVxuICogdmFsdWVzIHJlcGxhY2VkIHdpdGggdGhlIG91dHB1dCBvZiB0aGUgZ2l2ZW4gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gbWFwTWFwKG1hcCwgY2FsbGJhY2spIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICBtYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIHJlc3VsdC5zZXQoa2V5LCBjYWxsYmFjayh2YWx1ZSwga2V5KSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVjb2lsX21hcE1hcCA9IG1hcE1hcDtcblxuZnVuY3Rpb24gbWFrZUdyYXBoKCkge1xuICByZXR1cm4ge1xuICAgIG5vZGVEZXBzOiBuZXcgTWFwKCksXG4gICAgbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBjbG9uZUdyYXBoKGdyYXBoKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZURlcHM6IFJlY29pbF9tYXBNYXAoZ3JhcGgubm9kZURlcHMsIHMgPT4gbmV3IFNldChzKSksXG4gICAgbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnM6IFJlY29pbF9tYXBNYXAoZ3JhcGgubm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMsIHMgPT4gbmV3IFNldChzKSlcbiAgfTtcbn0gLy8gTm90ZSB0aGF0IHRoaXMgb3ZlcndyaXRlcyB0aGUgZGVwcyBvZiBleGlzdGluZyBub2RlcywgcmF0aGVyIHRoYW4gdW5pb25pbmdcbi8vIHRoZSBuZXcgZGVwcyB3aXRoIHRoZSBvbGQgZGVwcy5cblxuXG5mdW5jdGlvbiBtZXJnZURlcHNJbnRvR3JhcGgoa2V5LCBuZXdEZXBzLCBncmFwaCwgLy8gSWYgb2xkZXJHcmFwaCBpcyBnaXZlbiB0aGVuIHdlIHdpbGwgbm90IG92ZXJ3cml0ZSBjaGFuZ2VzIG1hZGUgdG8gdGhlIGdpdmVuXG4vLyBncmFwaCBjb21wYXJlZCB3aXRoIG9sZGVyR3JhcGg6XG5vbGRlckdyYXBoKSB7XG4gIGNvbnN0IHtcbiAgICBub2RlRGVwcyxcbiAgICBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uc1xuICB9ID0gZ3JhcGg7XG4gIGNvbnN0IG9sZERlcHMgPSBub2RlRGVwcy5nZXQoa2V5KTtcblxuICBpZiAob2xkRGVwcyAmJiBvbGRlckdyYXBoICYmIG9sZERlcHMgIT09IG9sZGVyR3JhcGgubm9kZURlcHMuZ2V0KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVXBkYXRlIG5vZGVEZXBzOlxuXG5cbiAgbm9kZURlcHMuc2V0KGtleSwgbmV3RGVwcyk7IC8vIEFkZCBuZXcgZGVwcyB0byBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uczpcblxuICBjb25zdCBhZGRlZERlcHMgPSBvbGREZXBzID09IG51bGwgPyBuZXdEZXBzIDogUmVjb2lsX2RpZmZlcmVuY2VTZXRzKG5ld0RlcHMsIG9sZERlcHMpO1xuXG4gIGZvciAoY29uc3QgZGVwIG9mIGFkZGVkRGVwcykge1xuICAgIGlmICghbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuaGFzKGRlcCkpIHtcbiAgICAgIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zLnNldChkZXAsIG5ldyBTZXQoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmcgPSBSZWNvaWxfbnVsbHRocm93cyhub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQoZGVwKSk7XG4gICAgZXhpc3RpbmcuYWRkKGtleSk7XG4gIH0gLy8gUmVtb3ZlIHJlbW92ZWQgZGVwcyBmcm9tIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zOlxuXG5cbiAgaWYgKG9sZERlcHMpIHtcbiAgICBjb25zdCByZW1vdmVkRGVwcyA9IFJlY29pbF9kaWZmZXJlbmNlU2V0cyhvbGREZXBzLCBuZXdEZXBzKTtcblxuICAgIGZvciAoY29uc3QgZGVwIG9mIHJlbW92ZWREZXBzKSB7XG4gICAgICBpZiAoIW5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmhhcyhkZXApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXhpc3RpbmcgPSBSZWNvaWxfbnVsbHRocm93cyhub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQoZGVwKSk7XG4gICAgICBleGlzdGluZy5kZWxldGUoa2V5KTtcblxuICAgICAgaWYgKGV4aXN0aW5nLnNpemUgPT09IDApIHtcbiAgICAgICAgbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGRlcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhdmVEZXBzVG9TdG9yZShrZXksIGRlcHMsIHN0b3JlLCB2ZXJzaW9uKSB7XG4gIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZSwgX3N0b3JlU3RhdGUkcHJldmlvdXNULCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QyLCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QzO1xuXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gIGlmICghKHZlcnNpb24gPT09IHN0b3JlU3RhdGUuY3VycmVudFRyZWUudmVyc2lvbiB8fCB2ZXJzaW9uID09PSAoKF9zdG9yZVN0YXRlJG5leHRUcmVlID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkbmV4dFRyZWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJG5leHRUcmVlLnZlcnNpb24pIHx8IHZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUID0gc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJHByZXZpb3VzVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNULnZlcnNpb24pKSkge1xuICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignVHJpZWQgdG8gc2F2ZSBkZXBlbmRlbmNpZXMgdG8gYSBkaXNjYXJkZWQgdHJlZScpO1xuICB9IC8vIE1lcmdlIHRoZSBkZXBlbmRlbmNpZXMgZGlzY292ZXJlZCBpbnRvIHRoZSBzdG9yZSdzIGRlcGVuZGVuY3kgbWFwXG4gIC8vIGZvciB0aGUgdmVyc2lvbiB0aGF0IHdhcyByZWFkOlxuXG5cbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaCh2ZXJzaW9uKTtcbiAgbWVyZ2VEZXBzSW50b0dyYXBoKGtleSwgZGVwcywgZ3JhcGgpOyAvLyBJZiB0aGlzIHZlcnNpb24gaXMgbm90IHRoZSBsYXRlc3QgdmVyc2lvbiwgYWxzbyB3cml0ZSB0aGVzZSBkZXBlbmRlbmNpZXNcbiAgLy8gaW50byBsYXRlciB2ZXJzaW9ucyBpZiB0aGV5IGRvbid0IGFscmVhZHkgaGF2ZSB0aGVpciBvd246XG5cbiAgaWYgKHZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUMiA9IHN0b3JlU3RhdGUucHJldmlvdXNUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRwcmV2aW91c1QyLnZlcnNpb24pKSB7XG4gICAgY29uc3QgY3VycmVudEdyYXBoID0gc3RvcmUuZ2V0R3JhcGgoc3RvcmVTdGF0ZS5jdXJyZW50VHJlZS52ZXJzaW9uKTtcbiAgICBtZXJnZURlcHNJbnRvR3JhcGgoa2V5LCBkZXBzLCBjdXJyZW50R3JhcGgsIGdyYXBoKTtcbiAgfVxuXG4gIGlmICh2ZXJzaW9uID09PSAoKF9zdG9yZVN0YXRlJHByZXZpb3VzVDMgPSBzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkcHJldmlvdXNUMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNUMy52ZXJzaW9uKSB8fCB2ZXJzaW9uID09PSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlLnZlcnNpb24pIHtcbiAgICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWUyO1xuXG4gICAgY29uc3QgbmV4dFZlcnNpb24gPSAoX3N0b3JlU3RhdGUkbmV4dFRyZWUyID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkbmV4dFRyZWUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRuZXh0VHJlZTIudmVyc2lvbjtcblxuICAgIGlmIChuZXh0VmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBuZXh0R3JhcGggPSBzdG9yZS5nZXRHcmFwaChuZXh0VmVyc2lvbik7XG4gICAgICBtZXJnZURlcHNJbnRvR3JhcGgoa2V5LCBkZXBzLCBuZXh0R3JhcGgsIGdyYXBoKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlY29pbF9HcmFwaCA9IHtcbiAgY2xvbmVHcmFwaCxcbiAgZ3JhcGg6IG1ha2VHcmFwaCxcbiAgc2F2ZURlcHNUb1N0b3JlXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5sZXQgbmV4dFRyZWVTdGF0ZVZlcnNpb24gPSAwO1xuXG5jb25zdCBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiA9ICgpID0+IG5leHRUcmVlU3RhdGVWZXJzaW9uKys7XG5cbmxldCBuZXh0U3RvcmVJRCA9IDA7XG5cbmNvbnN0IGdldE5leHRTdG9yZUlEID0gKCkgPT4gbmV4dFN0b3JlSUQrKztcblxubGV0IG5leHRDb21wb25lbnRJRCA9IDA7XG5cbmNvbnN0IGdldE5leHRDb21wb25lbnRJRCA9ICgpID0+IG5leHRDb21wb25lbnRJRCsrO1xuXG52YXIgUmVjb2lsX0tleXMgPSB7XG4gIGdldE5leHRUcmVlU3RhdGVWZXJzaW9uLFxuICBnZXROZXh0U3RvcmVJRCxcbiAgZ2V0TmV4dENvbXBvbmVudElEXG59O1xuXG5jb25zdCB7XG4gIHBlcnNpc3RlbnRNYXA6IHBlcnNpc3RlbnRNYXAkMVxufSA9IFJlY29pbF9QZXJzaXN0ZW50TWFwJDE7XG5cbmNvbnN0IHtcbiAgZ3JhcGhcbn0gPSBSZWNvaWxfR3JhcGg7XG5cbmNvbnN0IHtcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb246IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDFcbn0gPSBSZWNvaWxfS2V5cztcblxuZnVuY3Rpb24gbWFrZUVtcHR5VHJlZVN0YXRlKCkge1xuICBjb25zdCB2ZXJzaW9uID0gZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMSgpO1xuICByZXR1cm4ge1xuICAgIHZlcnNpb24sXG4gICAgc3RhdGVJRDogdmVyc2lvbixcbiAgICB0cmFuc2FjdGlvbk1ldGFkYXRhOiB7fSxcbiAgICBkaXJ0eUF0b21zOiBuZXcgU2V0KCksXG4gICAgYXRvbVZhbHVlczogcGVyc2lzdGVudE1hcCQxKCksXG4gICAgbm9udmFsaWRhdGVkQXRvbXM6IHBlcnNpc3RlbnRNYXAkMSgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VFbXB0eVN0b3JlU3RhdGUoKSB7XG4gIGNvbnN0IGN1cnJlbnRUcmVlID0gbWFrZUVtcHR5VHJlZVN0YXRlKCk7XG4gIHJldHVybiB7XG4gICAgY3VycmVudFRyZWUsXG4gICAgbmV4dFRyZWU6IG51bGwsXG4gICAgcHJldmlvdXNUcmVlOiBudWxsLFxuICAgIGNvbW1pdERlcHRoOiAwLFxuICAgIGtub3duQXRvbXM6IG5ldyBTZXQoKSxcbiAgICBrbm93blNlbGVjdG9yczogbmV3IFNldCgpLFxuICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxuICAgIG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKSxcbiAgICBub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXG4gICAgcXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQ6IFtdLFxuICAgIHN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVyczogbmV3IFNldCgpLFxuICAgIGdyYXBoc0J5VmVyc2lvbjogbmV3IE1hcCgpLnNldChjdXJyZW50VHJlZS52ZXJzaW9uLCBncmFwaCgpKSxcbiAgICByZXRlbnRpb246IHtcbiAgICAgIHJlZmVyZW5jZUNvdW50czogbmV3IE1hcCgpLFxuICAgICAgbm9kZXNSZXRhaW5lZEJ5Wm9uZTogbmV3IE1hcCgpLFxuICAgICAgcmV0YWluYWJsZXNUb0NoZWNrRm9yUmVsZWFzZTogbmV3IFNldCgpXG4gICAgfSxcbiAgICBub2RlQ2xlYW51cEZ1bmN0aW9uczogbmV3IE1hcCgpXG4gIH07XG59XG5cbnZhciBSZWNvaWxfU3RhdGUgPSB7XG4gIG1ha2VFbXB0eVRyZWVTdGF0ZSxcbiAgbWFrZUVtcHR5U3RvcmVTdGF0ZSxcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb246IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDFcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmNsYXNzIFJldGVudGlvblpvbmUge31cblxuZnVuY3Rpb24gcmV0ZW50aW9uWm9uZSgpIHtcbiAgcmV0dXJuIG5ldyBSZXRlbnRpb25ab25lKCk7XG59XG5cbnZhciBSZWNvaWxfUmV0ZW50aW9uWm9uZSA9IHtcbiAgUmV0ZW50aW9uWm9uZSxcbiAgcmV0ZW50aW9uWm9uZVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBVdGlsaXRpZXMgZm9yIHdvcmtpbmcgd2l0aCBidWlsdC1pbiBNYXBzIGFuZCBTZXRzIHdpdGhvdXQgbXV0YXRpbmcgdGhlbS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gc2V0QnlBZGRpbmdUb1NldChzZXQsIHYpIHtcbiAgY29uc3QgbmV4dCA9IG5ldyBTZXQoc2V0KTtcbiAgbmV4dC5hZGQodik7XG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRCeURlbGV0aW5nRnJvbVNldChzZXQsIHYpIHtcbiAgY29uc3QgbmV4dCA9IG5ldyBTZXQoc2V0KTtcbiAgbmV4dC5kZWxldGUodik7XG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiBtYXBCeVNldHRpbmdJbk1hcChtYXAsIGssIHYpIHtcbiAgY29uc3QgbmV4dCA9IG5ldyBNYXAobWFwKTtcbiAgbmV4dC5zZXQoaywgdik7XG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiBtYXBCeVVwZGF0aW5nSW5NYXAobWFwLCBrLCB1cGRhdGVyKSB7XG4gIGNvbnN0IG5leHQgPSBuZXcgTWFwKG1hcCk7XG4gIG5leHQuc2V0KGssIHVwZGF0ZXIobmV4dC5nZXQoaykpKTtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIG1hcEJ5RGVsZXRpbmdGcm9tTWFwKG1hcCwgaykge1xuICBjb25zdCBuZXh0ID0gbmV3IE1hcChtYXApO1xuICBuZXh0LmRlbGV0ZShrKTtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIG1hcEJ5RGVsZXRpbmdNdWx0aXBsZUZyb21NYXAobWFwLCBrcykge1xuICBjb25zdCBuZXh0ID0gbmV3IE1hcChtYXApO1xuICBrcy5mb3JFYWNoKGsgPT4gbmV4dC5kZWxldGUoaykpO1xuICByZXR1cm4gbmV4dDtcbn1cblxudmFyIFJlY29pbF9Db3B5T25Xcml0ZSA9IHtcbiAgc2V0QnlBZGRpbmdUb1NldCxcbiAgc2V0QnlEZWxldGluZ0Zyb21TZXQsXG4gIG1hcEJ5U2V0dGluZ0luTWFwLFxuICBtYXBCeVVwZGF0aW5nSW5NYXAsXG4gIG1hcEJ5RGVsZXRpbmdGcm9tTWFwLFxuICBtYXBCeURlbGV0aW5nTXVsdGlwbGVGcm9tTWFwXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGl0ZXJhYmxlIHdob3NlIG91dHB1dCBpcyBnZW5lcmF0ZWQgYnkgcGFzc2luZyB0aGUgaW5wdXRcbiAqIGl0ZXJhYmxlJ3MgdmFsdWVzIHRocm91Z2ggdGhlIGZpbHRlciBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiogZmlsdGVySXRlcmFibGUoaXRlcmFibGUsIHByZWRpY2F0ZSkge1xuICAvLyBVc2UgZ2VuZXJhdG9yIHRvIGNyZWF0ZSBpdGVyYWJsZS9pdGVyYXRvclxuICBsZXQgaW5kZXggPSAwO1xuXG4gIGZvciAoY29uc3QgdmFsdWUgb2YgaXRlcmFibGUpIHtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCsrKSkge1xuICAgICAgeWllbGQgdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWNvaWxfZmlsdGVySXRlcmFibGUgPSBmaWx0ZXJJdGVyYWJsZTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogUmV0dXJuIGEgcHJveHkgb2JqZWN0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBiYXNlIGFuZCBmYWN0b3JpZXMgb2JqZWN0cy5cbiAqIFRoZSBwcm94eSB3aWxsIGluY2x1ZGUgYWxsIHByb3BlcnRpZXMgb2YgdGhlIGJhc2Ugb2JqZWN0IGFzLWlzLlxuICogVGhlIGZhY3RvcmllcyBvYmplY3QgY29udGFpbnMgY2FsbGJhY2tzIHRvIG9idGFpbiB0aGUgdmFsdWVzIG9mIHRoZSBwcm9wZXJpZXNcbiAqIGZvciBpdHMga2V5cy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgcHJvdmlkaW5nIHVzZXJzIGFuIG9iamVjdCB3aGVyZSBzb21lIHByb3BlcnRpZXMgbWF5IGJlXG4gKiBsYXppbHkgY29tcHV0ZWQgb25seSBvbiBmaXJzdCBhY2Nlc3MuXG4gKi9cbi8vICRGbG93SXNzdWVbdW5jbGVhci10eXBlXVxuXG5mdW5jdGlvbiBsYXp5UHJveHkoYmFzZSwgZmFjdG9yaWVzKSB7XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KGJhc2UsIHtcbiAgICAvLyBDb21wdXRlIGFuZCBjYWNoZSBsYXp5IHByb3BlcnR5IGlmIG5vdCBhbHJlYWR5IGRvbmUuXG4gICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICBpZiAoIShwcm9wIGluIHRhcmdldCkgJiYgcHJvcCBpbiBmYWN0b3JpZXMpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gZmFjdG9yaWVzW3Byb3BdKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgfSxcbiAgICAvLyBUaGlzIG1ldGhvZCBhbGxvd3MgdXNlciB0byBpdGVyYXRlIGtleXMgYXMgbm9ybWFsXG4gICAgb3duS2V5czogdGFyZ2V0ID0+IHtcblxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCk7XG4gICAgfVxuICB9KTsgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gIHJldHVybiBwcm94eTtcbn1cblxudmFyIFJlY29pbF9sYXp5UHJveHkgPSBsYXp5UHJveHk7XG5cbmNvbnN0IHtcbiAgZ2V0Tm9kZTogZ2V0Tm9kZSQxLFxuICBnZXROb2RlTWF5YmU6IGdldE5vZGVNYXliZSQxLFxuICByZWNvaWxWYWx1ZXNGb3JLZXlzOiByZWNvaWxWYWx1ZXNGb3JLZXlzJDFcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBSZXRlbnRpb25ab25lOiBSZXRlbnRpb25ab25lJDFcbn0gPSBSZWNvaWxfUmV0ZW50aW9uWm9uZTtcblxuY29uc3Qge1xuICBzZXRCeUFkZGluZ1RvU2V0OiBzZXRCeUFkZGluZ1RvU2V0JDFcbn0gPSBSZWNvaWxfQ29weU9uV3JpdGU7XG5cblxuXG5cblxuXG5cbiAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG5cbmNvbnN0IGVtcHR5U2V0ID0gT2JqZWN0LmZyZWV6ZShuZXcgU2V0KCkpO1xuXG5jbGFzcyBSZWFkT25seVJlY29pbFZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUmV0ZW50aW9uRm9yTm9kZShzdG9yZSwgbm9kZUtleSwgcmV0YWluZWRCeSkge1xuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIG5vZGVzUmV0YWluZWRCeVpvbmVcbiAgfSA9IHN0b3JlLmdldFN0YXRlKCkucmV0ZW50aW9uO1xuXG4gIGZ1bmN0aW9uIGFkZFRvWm9uZSh6b25lKSB7XG4gICAgbGV0IHNldCA9IG5vZGVzUmV0YWluZWRCeVpvbmUuZ2V0KHpvbmUpO1xuXG4gICAgaWYgKCFzZXQpIHtcbiAgICAgIG5vZGVzUmV0YWluZWRCeVpvbmUuc2V0KHpvbmUsIHNldCA9IG5ldyBTZXQoKSk7XG4gICAgfVxuXG4gICAgc2V0LmFkZChub2RlS2V5KTtcbiAgfVxuXG4gIGlmIChyZXRhaW5lZEJ5IGluc3RhbmNlb2YgUmV0ZW50aW9uWm9uZSQxKSB7XG4gICAgYWRkVG9ab25lKHJldGFpbmVkQnkpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmV0YWluZWRCeSkpIHtcbiAgICBmb3IgKGNvbnN0IHpvbmUgb2YgcmV0YWluZWRCeSkge1xuICAgICAgYWRkVG9ab25lKHpvbmUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgcmV0ZW50aW9uXG4gICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICBmdW5jdGlvbiBkZWxldGVGcm9tWm9uZSh6b25lKSB7XG4gICAgICBjb25zdCBzZXQgPSByZXRlbnRpb24ubm9kZXNSZXRhaW5lZEJ5Wm9uZS5nZXQoem9uZSk7XG4gICAgICBzZXQgPT09IG51bGwgfHwgc2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXQuZGVsZXRlKG5vZGVLZXkpO1xuXG4gICAgICBpZiAoc2V0ICYmIHNldC5zaXplID09PSAwKSB7XG4gICAgICAgIHJldGVudGlvbi5ub2Rlc1JldGFpbmVkQnlab25lLmRlbGV0ZSh6b25lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmV0YWluZWRCeSBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMSkge1xuICAgICAgZGVsZXRlRnJvbVpvbmUocmV0YWluZWRCeSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldGFpbmVkQnkpKSB7XG4gICAgICBmb3IgKGNvbnN0IHpvbmUgb2YgcmV0YWluZWRCeSkge1xuICAgICAgICBkZWxldGVGcm9tWm9uZSh6b25lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlKHN0b3JlLCB0cmVlU3RhdGUsIGtleSwgdHJpZ2dlcikge1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICBpZiAoc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5oYXMoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG5vZGUgPSBnZXROb2RlJDEoa2V5KTtcbiAgY29uc3QgcmV0ZW50aW9uQ2xlYW51cCA9IGluaXRpYWxpemVSZXRlbnRpb25Gb3JOb2RlKHN0b3JlLCBrZXksIG5vZGUucmV0YWluZWRCeSk7XG4gIGNvbnN0IG5vZGVDbGVhbnVwID0gbm9kZS5pbml0KHN0b3JlLCB0cmVlU3RhdGUsIHRyaWdnZXIpO1xuICBzdG9yZVN0YXRlLm5vZGVDbGVhbnVwRnVuY3Rpb25zLnNldChrZXksICgpID0+IHtcbiAgICBub2RlQ2xlYW51cCgpO1xuICAgIHJldGVudGlvbkNsZWFudXAoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVOb2RlKHN0b3JlLCBrZXksIHRyaWdnZXIpIHtcbiAgaW5pdGlhbGl6ZU5vZGVJZk5ld1RvU3RvcmUoc3RvcmUsIHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUsIGtleSwgdHJpZ2dlcik7XG59XG5cbmZ1bmN0aW9uIGNsZWFuVXBOb2RlKHN0b3JlLCBrZXkpIHtcbiAgdmFyIF9zdGF0ZSRub2RlQ2xlYW51cEZ1bjtcblxuICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIChfc3RhdGUkbm9kZUNsZWFudXBGdW4gPSBzdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5nZXQoa2V5KSkgPT09IG51bGwgfHwgX3N0YXRlJG5vZGVDbGVhbnVwRnVuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGUkbm9kZUNsZWFudXBGdW4oKTtcbiAgc3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuZGVsZXRlKGtleSk7XG59IC8vIEdldCB0aGUgY3VycmVudCB2YWx1ZSBsb2FkYWJsZSBvZiBhIG5vZGUgYW5kIHVwZGF0ZSB0aGUgc3RhdGUuXG4vLyBVcGRhdGUgZGVwZW5kZW5jaWVzIGFuZCBzdWJzY3JpcHRpb25zIGZvciBzZWxlY3RvcnMuXG4vLyBVcGRhdGUgc2F2ZWQgdmFsdWUgdmFsaWRhdGlvbiBmb3IgYXRvbXMuXG5cblxuZnVuY3Rpb24gZ2V0Tm9kZUxvYWRhYmxlKHN0b3JlLCBzdGF0ZSwga2V5KSB7XG4gIGluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlKHN0b3JlLCBzdGF0ZSwga2V5LCAnZ2V0Jyk7XG4gIHJldHVybiBnZXROb2RlJDEoa2V5KS5nZXQoc3RvcmUsIHN0YXRlKTtcbn0gLy8gUGVlayBhdCB0aGUgY3VycmVudCB2YWx1ZSBsb2FkYWJsZSBmb3IgYSBub2RlIHdpdGhvdXQgYW55IGV2YWx1YXRpb24gb3Igc3RhdGUgY2hhbmdlXG5cblxuZnVuY3Rpb24gcGVla05vZGVMb2FkYWJsZShzdG9yZSwgc3RhdGUsIGtleSkge1xuICByZXR1cm4gZ2V0Tm9kZSQxKGtleSkucGVlayhzdG9yZSwgc3RhdGUpO1xufSAvLyBXcml0ZSB2YWx1ZSBkaXJlY3RseSB0byBzdGF0ZSBieXBhc3NpbmcgdGhlIE5vZGUgaW50ZXJmYWNlIGFzIHRoZSBub2RlXG4vLyBkZWZpbml0aW9ucyBtYXkgbm90IGhhdmUgYmVlbiBsb2FkZWQgeWV0IHdoZW4gcHJvY2Vzc2luZyB0aGUgaW5pdGlhbCBzbmFwc2hvdC5cblxuXG5mdW5jdGlvbiBzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVEKHN0YXRlLCBrZXksIG5ld1ZhbHVlKSB7XG4gIHZhciBfbm9kZSRpbnZhbGlkYXRlO1xuXG4gIGNvbnN0IG5vZGUgPSBnZXROb2RlTWF5YmUkMShrZXkpO1xuICBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbm9kZSRpbnZhbGlkYXRlID0gbm9kZS5pbnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfbm9kZSRpbnZhbGlkYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRpbnZhbGlkYXRlLmNhbGwobm9kZSwgc3RhdGUpO1xuICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICBhdG9tVmFsdWVzOiBzdGF0ZS5hdG9tVmFsdWVzLmNsb25lKCkuZGVsZXRlKGtleSksXG4gICAgbm9udmFsaWRhdGVkQXRvbXM6IHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmNsb25lKCkuc2V0KGtleSwgbmV3VmFsdWUpLFxuICAgIGRpcnR5QXRvbXM6IHNldEJ5QWRkaW5nVG9TZXQkMShzdGF0ZS5kaXJ0eUF0b21zLCBrZXkpXG4gIH07XG59IC8vIFJldHVybiB0aGUgZGlzY292ZXJlZCBkZXBlbmRlbmNpZXMgYW5kIHZhbHVlcyB0byBiZSB3cml0dGVuIGJ5IHNldHRpbmdcbi8vIGEgbm9kZSB2YWx1ZS4gKE11bHRpcGxlIHZhbHVlcyBtYXkgYmUgd3JpdHRlbiBkdWUgdG8gc2VsZWN0b3JzIGdldHRpbmcgdG9cbi8vIHNldCB1cHN0cmVhbXM7IGRlcHMgbWF5IGJlIGRpc2NvdmVyZWQgYmVjYXVzZSBvZiByZWFkcyBpbiB1cGRhdGVyIGZ1bmN0aW9ucy4pXG5cblxuZnVuY3Rpb24gc2V0Tm9kZVZhbHVlKHN0b3JlLCBzdGF0ZSwga2V5LCBuZXdWYWx1ZSkge1xuICBjb25zdCBub2RlID0gZ2V0Tm9kZSQxKGtleSk7XG5cbiAgaWYgKG5vZGUuc2V0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgUmVhZE9ubHlSZWNvaWxWYWx1ZUVycm9yKGBBdHRlbXB0IHRvIHNldCByZWFkLW9ubHkgUmVjb2lsVmFsdWU6ICR7a2V5fWApO1xuICB9XG5cbiAgY29uc3Qgc2V0ID0gbm9kZS5zZXQ7IC8vIHNvIGZsb3cgZG9lc24ndCBsb3NlIHRoZSBhYm92ZSByZWZpbmVtZW50LlxuXG4gIGluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlKHN0b3JlLCBzdGF0ZSwga2V5LCAnc2V0Jyk7XG4gIHJldHVybiBzZXQoc3RvcmUsIHN0YXRlLCBuZXdWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHBlZWtOb2RlSW5mbyhzdG9yZSwgc3RhdGUsIGtleSkge1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaChzdGF0ZS52ZXJzaW9uKTtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGUkMShrZXkpLm5vZGVUeXBlO1xuICByZXR1cm4gUmVjb2lsX2xhenlQcm94eSh7XG4gICAgdHlwZVxuICB9LCB7XG4gICAgbG9hZGFibGU6ICgpID0+IHBlZWtOb2RlTG9hZGFibGUoc3RvcmUsIHN0YXRlLCBrZXkpLFxuICAgIGlzQWN0aXZlOiAoKSA9PiBzdG9yZVN0YXRlLmtub3duQXRvbXMuaGFzKGtleSkgfHwgc3RvcmVTdGF0ZS5rbm93blNlbGVjdG9ycy5oYXMoa2V5KSxcbiAgICBpc1NldDogKCkgPT4gdHlwZSA9PT0gJ3NlbGVjdG9yJyA/IGZhbHNlIDogc3RhdGUuYXRvbVZhbHVlcy5oYXMoa2V5KSxcbiAgICBpc01vZGlmaWVkOiAoKSA9PiBzdGF0ZS5kaXJ0eUF0b21zLmhhcyhrZXkpLFxuICAgIC8vIFJlcG9ydCBjdXJyZW50IGRlcGVuZGVuY2llcy4gIElmIHRoZSBub2RlIGhhc24ndCBiZWVuIGV2YWx1YXRlZCwgdGhlblxuICAgIC8vIGRlcGVuZGVuY2llcyBtYXkgYmUgbWlzc2luZyBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICBkZXBzOiAoKSA9PiB7XG4gICAgICB2YXIgX2dyYXBoJG5vZGVEZXBzJGdldDtcblxuICAgICAgcmV0dXJuIHJlY29pbFZhbHVlc0ZvcktleXMkMSgoX2dyYXBoJG5vZGVEZXBzJGdldCA9IGdyYXBoLm5vZGVEZXBzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfZ3JhcGgkbm9kZURlcHMkZ2V0ICE9PSB2b2lkIDAgPyBfZ3JhcGgkbm9kZURlcHMkZ2V0IDogW10pO1xuICAgIH0sXG4gICAgLy8gUmVwb3J0cyBhbGwgXCJjdXJyZW50XCIgc3Vic2NyaWJlcnMuICBFdmFsdWF0aW5nIG90aGVyIG5vZGVzIG9yXG4gICAgLy8gcHJldmlvdXMgaW4tcHJvZ3Jlc3MgYXN5bmMgZXZhbHVhdGlvbnMgbWF5IGludHJvZHVjZSBuZXcgc3Vic2NyaWJlcnMuXG4gICAgc3Vic2NyaWJlcnM6ICgpID0+IHtcbiAgICAgIHZhciBfc3RvcmVTdGF0ZSRub2RlVG9Db20sIF9zdG9yZVN0YXRlJG5vZGVUb0NvbTI7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVzOiByZWNvaWxWYWx1ZXNGb3JLZXlzJDEoUmVjb2lsX2ZpbHRlckl0ZXJhYmxlKGdldERvd25zdHJlYW1Ob2RlcyhzdG9yZSwgc3RhdGUsIG5ldyBTZXQoW2tleV0pKSwgbm9kZUtleSA9PiBub2RlS2V5ICE9PSBrZXkpKSxcbiAgICAgICAgY29tcG9uZW50czogUmVjb2lsX21hcEl0ZXJhYmxlKChfc3RvcmVTdGF0ZSRub2RlVG9Db20gPSAoX3N0b3JlU3RhdGUkbm9kZVRvQ29tMiA9IHN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5nZXQoa2V5KSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkbm9kZVRvQ29tMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkbm9kZVRvQ29tMi52YWx1ZXMoKSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbm9kZVRvQ29tICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRub2RlVG9Db20gOiBbXSwgKFtuYW1lXSkgPT4gKHtcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH0pKVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufSAvLyBGaW5kIGFsbCBvZiB0aGUgcmVjdXJzaXZlbHkgZGVwZW5kZW50IG5vZGVzXG5cblxuZnVuY3Rpb24gZ2V0RG93bnN0cmVhbU5vZGVzKHN0b3JlLCBzdGF0ZSwga2V5cykge1xuICBjb25zdCB2aXNpdGVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IHZpc2l0aW5nTm9kZXMgPSBBcnJheS5mcm9tKGtleXMpO1xuICBjb25zdCBncmFwaCA9IHN0b3JlLmdldEdyYXBoKHN0YXRlLnZlcnNpb24pO1xuXG4gIGZvciAobGV0IGtleSA9IHZpc2l0aW5nTm9kZXMucG9wKCk7IGtleTsga2V5ID0gdmlzaXRpbmdOb2Rlcy5wb3AoKSkge1xuICAgIHZhciBfZ3JhcGgkbm9kZVRvTm9kZVN1YnM7XG5cbiAgICB2aXNpdGVkTm9kZXMuYWRkKGtleSk7XG4gICAgY29uc3Qgc3Vic2NyaWJlZE5vZGVzID0gKF9ncmFwaCRub2RlVG9Ob2RlU3VicyA9IGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgIT09IHZvaWQgMCA/IF9ncmFwaCRub2RlVG9Ob2RlU3VicyA6IGVtcHR5U2V0O1xuXG4gICAgZm9yIChjb25zdCBkb3duc3RyZWFtTm9kZSBvZiBzdWJzY3JpYmVkTm9kZXMpIHtcbiAgICAgIGlmICghdmlzaXRlZE5vZGVzLmhhcyhkb3duc3RyZWFtTm9kZSkpIHtcbiAgICAgICAgdmlzaXRpbmdOb2Rlcy5wdXNoKGRvd25zdHJlYW1Ob2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmlzaXRlZE5vZGVzO1xufVxuXG52YXIgUmVjb2lsX0Z1bmN0aW9uYWxDb3JlID0ge1xuICBnZXROb2RlTG9hZGFibGUsXG4gIHBlZWtOb2RlTG9hZGFibGUsXG4gIHNldE5vZGVWYWx1ZSxcbiAgaW5pdGlhbGl6ZU5vZGUsXG4gIGNsZWFuVXBOb2RlLFxuICBzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVELFxuICBwZWVrTm9kZUluZm8sXG4gIGdldERvd25zdHJlYW1Ob2Rlc1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxubGV0IF9pbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCA9IG51bGw7XG5cbmZ1bmN0aW9uIHNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90KGludmFsaWRhdGUpIHtcbiAgX2ludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90ID0gaW52YWxpZGF0ZTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QoKSB7XG4gIHZhciBfaW52YWxpZGF0ZU1lbW9pemVkU247XG5cbiAgKF9pbnZhbGlkYXRlTWVtb2l6ZWRTbiA9IF9pbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCkgPT09IG51bGwgfHwgX2ludmFsaWRhdGVNZW1vaXplZFNuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW52YWxpZGF0ZU1lbW9pemVkU24oKTtcbn1cblxudmFyIFJlY29pbF9TbmFwc2hvdENhY2hlID0ge1xuICBzZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCxcbiAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3Rcbn07XG5cbmNvbnN0IHtcbiAgZ2V0RG93bnN0cmVhbU5vZGVzOiBnZXREb3duc3RyZWFtTm9kZXMkMSxcbiAgZ2V0Tm9kZUxvYWRhYmxlOiBnZXROb2RlTG9hZGFibGUkMSxcbiAgc2V0Tm9kZVZhbHVlOiBzZXROb2RlVmFsdWUkMVxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICBnZXROZXh0Q29tcG9uZW50SUQ6IGdldE5leHRDb21wb25lbnRJRCQxXG59ID0gUmVjb2lsX0tleXM7XG5cbmNvbnN0IHtcbiAgZ2V0Tm9kZTogZ2V0Tm9kZSQyLFxuICBnZXROb2RlTWF5YmU6IGdldE5vZGVNYXliZSQyXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgRGVmYXVsdFZhbHVlOiBEZWZhdWx0VmFsdWUkMVxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDFcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xuXG5jb25zdCB7XG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkMSxcbiAgUmVjb2lsU3RhdGU6IFJlY29pbFN0YXRlJDEsXG4gIFJlY29pbFZhbHVlUmVhZE9ubHk6IFJlY29pbFZhbHVlUmVhZE9ubHkkMSxcbiAgaXNSZWNvaWxWYWx1ZTogaXNSZWNvaWxWYWx1ZSQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlJDE7XG5cbmNvbnN0IHtcbiAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3Q6IGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDFcbn0gPSBSZWNvaWxfU25hcHNob3RDYWNoZTtcblxuXG5cblxuXG5cblxuZnVuY3Rpb24gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlKHN0b3JlLCB7XG4gIGtleVxufSwgdHJlZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSkge1xuICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWUsIF9zdG9yZVN0YXRlJHByZXZpb3VzVDtcblxuICAvLyBSZWFkaW5nIGZyb20gYW4gb2xkZXIgdHJlZSBjYW4gY2F1c2UgYnVncyBiZWNhdXNlIHRoZSBkZXBlbmRlbmNpZXMgdGhhdCB3ZVxuICAvLyBkaXNjb3ZlciBkdXJpbmcgdGhlIHJlYWQgYXJlIGxvc3QuXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gIGlmICghKHRyZWVTdGF0ZS52ZXJzaW9uID09PSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlLnZlcnNpb24gfHwgdHJlZVN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkbmV4dFRyZWUudmVyc2lvbikgfHwgdHJlZVN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUID0gc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJHByZXZpb3VzVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNULnZlcnNpb24pKSkge1xuICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignVHJpZWQgdG8gcmVhZCBmcm9tIGEgZGlzY2FyZGVkIHRyZWUnKTtcbiAgfVxuXG4gIGNvbnN0IGxvYWRhYmxlID0gZ2V0Tm9kZUxvYWRhYmxlJDEoc3RvcmUsIHRyZWVTdGF0ZSwga2V5KTtcblxuICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgIGxvYWRhYmxlLmNvbnRlbnRzLmNhdGNoKCgpID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogSEFDSzogaW50ZXJjZXB0IHRocm93biBlcnJvciBoZXJlIHRvIHByZXZlbnQgYW4gdW5jYXVnaHQgcHJvbWlzZSBleGNlcHRpb24uIElkZWFsbHkgdGhpcyB3b3VsZCBoYXBwZW4gY2xvc2VyIHRvIHNlbGVjdG9yXG4gICAgICAgKiBleGVjdXRpb24gKHBlcmhhcHMgaW50cm9kdWNpbmcgYSBuZXcgRVJST1IgY2xhc3MgdG8gYmUgcmVzb2x2ZWQgYnkgYXN5bmMgc2VsZWN0b3JzIHRoYXQgYXJlIGluIGFuIGVycm9yIHN0YXRlKVxuICAgICAgICovXG4gICAgICByZXR1cm47XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbG9hZGFibGU7XG59XG5cbmZ1bmN0aW9uIGFwcGx5QXRvbVZhbHVlV3JpdGVzKGF0b21WYWx1ZXMsIHdyaXRlcykge1xuICBjb25zdCByZXN1bHQgPSBhdG9tVmFsdWVzLmNsb25lKCk7XG4gIHdyaXRlcy5mb3JFYWNoKCh2LCBrKSA9PiB7XG4gICAgaWYgKHYuc3RhdGUgPT09ICdoYXNWYWx1ZScgJiYgdi5jb250ZW50cyBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQxKSB7XG4gICAgICByZXN1bHQuZGVsZXRlKGspO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuc2V0KGssIHYpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHZhbHVlRnJvbVZhbHVlT3JVcGRhdGVyKHN0b3JlLCBzdGF0ZSwge1xuICBrZXlcbn0sIHZhbHVlT3JVcGRhdGVyKSB7XG4gIGlmICh0eXBlb2YgdmFsdWVPclVwZGF0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVcGRhdGVyIGZvcm06IHBhc3MgaW4gdGhlIGN1cnJlbnQgdmFsdWUuIFRocm93IGlmIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgLy8gaXMgdW5hdmFpbGFibGUgKG5hbWVseSB3aGVuIHVwZGF0aW5nIGFuIGFzeW5jIHNlbGVjdG9yIHRoYXQnc1xuICAgIC8vIHBlbmRpbmcgb3IgZXJyb3JlZCk6XG4gICAgY29uc3QgY3VycmVudCA9IGdldE5vZGVMb2FkYWJsZSQxKHN0b3JlLCBzdGF0ZSwga2V5KTtcblxuICAgIGlmIChjdXJyZW50LnN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGBUcmllZCB0byBzZXQgYXRvbSBvciBzZWxlY3RvciBcIiR7a2V5fVwiIHVzaW5nIGFuIHVwZGF0ZXIgZnVuY3Rpb24gd2hpbGUgdGhlIGN1cnJlbnQgc3RhdGUgaXMgcGVuZGluZywgdGhpcyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZC5gO1xuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKG1zZyk7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKG1zZyk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50LnN0YXRlID09PSAnaGFzRXJyb3InKSB7XG4gICAgICB0aHJvdyBjdXJyZW50LmNvbnRlbnRzO1xuICAgIH0gLy8gVCBpdHNlbGYgbWF5IGJlIGEgZnVuY3Rpb24sIHNvIG91ciByZWZpbmVtZW50IGlzIG5vdCBzdWZmaWNpZW50OlxuXG5cbiAgICByZXR1cm4gdmFsdWVPclVwZGF0ZXIoY3VycmVudC5jb250ZW50cyk7IC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZU9yVXBkYXRlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseUFjdGlvbihzdG9yZSwgc3RhdGUsIGFjdGlvbikge1xuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdzZXQnKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVjb2lsVmFsdWUsXG4gICAgICB2YWx1ZU9yVXBkYXRlclxuICAgIH0gPSBhY3Rpb247XG4gICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZUZyb21WYWx1ZU9yVXBkYXRlcihzdG9yZSwgc3RhdGUsIHJlY29pbFZhbHVlLCB2YWx1ZU9yVXBkYXRlcik7XG4gICAgY29uc3Qgd3JpdGVzID0gc2V0Tm9kZVZhbHVlJDEoc3RvcmUsIHN0YXRlLCByZWNvaWxWYWx1ZS5rZXksIG5ld1ZhbHVlKTtcblxuICAgIGZvciAoY29uc3QgW2tleSwgbG9hZGFibGVdIG9mIHdyaXRlcy5lbnRyaWVzKCkpIHtcbiAgICAgIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZShzdGF0ZSwga2V5LCBsb2FkYWJsZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFjdGlvbi50eXBlID09PSAnc2V0TG9hZGFibGUnKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVjb2lsVmFsdWU6IHtcbiAgICAgICAga2V5XG4gICAgICB9LFxuICAgICAgbG9hZGFibGVcbiAgICB9ID0gYWN0aW9uO1xuICAgIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZShzdGF0ZSwga2V5LCBsb2FkYWJsZSk7XG4gIH0gZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09ICdtYXJrTW9kaWZpZWQnKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVjb2lsVmFsdWU6IHtcbiAgICAgICAga2V5XG4gICAgICB9XG4gICAgfSA9IGFjdGlvbjtcbiAgICBzdGF0ZS5kaXJ0eUF0b21zLmFkZChrZXkpO1xuICB9IGVsc2UgaWYgKGFjdGlvbi50eXBlID09PSAnc2V0VW52YWxpZGF0ZWQnKSB7XG4gICAgdmFyIF9ub2RlJGludmFsaWRhdGU7XG5cbiAgICAvLyBXcml0ZSB2YWx1ZSBkaXJlY3RseSB0byBzdGF0ZSBieXBhc3NpbmcgdGhlIE5vZGUgaW50ZXJmYWNlIGFzIHRoZSBub2RlXG4gICAgLy8gZGVmaW5pdGlvbnMgbWF5IG5vdCBoYXZlIGJlZW4gbG9hZGVkIHlldCB3aGVuIHByb2Nlc3NpbmcgdGhlIGluaXRpYWwgc25hcHNob3QuXG4gICAgY29uc3Qge1xuICAgICAgcmVjb2lsVmFsdWU6IHtcbiAgICAgICAga2V5XG4gICAgICB9LFxuICAgICAgdW52YWxpZGF0ZWRWYWx1ZVxuICAgIH0gPSBhY3Rpb247XG4gICAgY29uc3Qgbm9kZSA9IGdldE5vZGVNYXliZSQyKGtleSk7XG4gICAgbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX25vZGUkaW52YWxpZGF0ZSA9IG5vZGUuaW52YWxpZGF0ZSkgPT09IG51bGwgfHwgX25vZGUkaW52YWxpZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkaW52YWxpZGF0ZS5jYWxsKG5vZGUsIHN0YXRlKTtcbiAgICBzdGF0ZS5hdG9tVmFsdWVzLmRlbGV0ZShrZXkpO1xuICAgIHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLnNldChrZXksIHVudmFsaWRhdGVkVmFsdWUpO1xuICAgIHN0YXRlLmRpcnR5QXRvbXMuYWRkKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKGBVbmtub3duIGFjdGlvbiAke2FjdGlvbi50eXBlfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZShzdGF0ZSwga2V5LCBsb2FkYWJsZSkge1xuICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScgJiYgbG9hZGFibGUuY29udGVudHMgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMSkge1xuICAgIHN0YXRlLmF0b21WYWx1ZXMuZGVsZXRlKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuYXRvbVZhbHVlcy5zZXQoa2V5LCBsb2FkYWJsZSk7XG4gIH1cblxuICBzdGF0ZS5kaXJ0eUF0b21zLmFkZChrZXkpO1xuICBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5kZWxldGUoa2V5KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlBY3Rpb25zVG9TdG9yZShzdG9yZSwgYWN0aW9ucykge1xuICBzdG9yZS5yZXBsYWNlU3RhdGUoc3RhdGUgPT4ge1xuICAgIGNvbnN0IG5ld1N0YXRlID0gY29weVRyZWVTdGF0ZShzdGF0ZSk7XG5cbiAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBhY3Rpb25zKSB7XG4gICAgICBhcHBseUFjdGlvbihzdG9yZSwgbmV3U3RhdGUsIGFjdGlvbik7XG4gICAgfVxuXG4gICAgaW52YWxpZGF0ZURvd25zdHJlYW1zKHN0b3JlLCBuZXdTdGF0ZSk7XG4gICAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMSgpO1xuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlT3JQZXJmb3JtU3RhdGVVcGRhdGUoc3RvcmUsIGFjdGlvbikge1xuICBpZiAoYmF0Y2hTdGFjay5sZW5ndGgpIHtcbiAgICBjb25zdCBhY3Rpb25zQnlTdG9yZSA9IGJhdGNoU3RhY2tbYmF0Y2hTdGFjay5sZW5ndGggLSAxXTtcbiAgICBsZXQgYWN0aW9ucyA9IGFjdGlvbnNCeVN0b3JlLmdldChzdG9yZSk7XG5cbiAgICBpZiAoIWFjdGlvbnMpIHtcbiAgICAgIGFjdGlvbnNCeVN0b3JlLnNldChzdG9yZSwgYWN0aW9ucyA9IFtdKTtcbiAgICB9XG5cbiAgICBhY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBhcHBseUFjdGlvbnNUb1N0b3JlKHN0b3JlLCBbYWN0aW9uXSk7XG4gIH1cbn1cblxuY29uc3QgYmF0Y2hTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBiYXRjaFN0YXJ0KCkge1xuICBjb25zdCBhY3Rpb25zQnlTdG9yZSA9IG5ldyBNYXAoKTtcbiAgYmF0Y2hTdGFjay5wdXNoKGFjdGlvbnNCeVN0b3JlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtzdG9yZSwgYWN0aW9uc10gb2YgYWN0aW9uc0J5U3RvcmUpIHtcbiAgICAgIGFwcGx5QWN0aW9uc1RvU3RvcmUoc3RvcmUsIGFjdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IHBvcHBlZCA9IGJhdGNoU3RhY2sucG9wKCk7XG5cbiAgICBpZiAocG9wcGVkICE9PSBhY3Rpb25zQnlTdG9yZSkge1xuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdJbmNvcnJlY3Qgb3JkZXIgb2YgYmF0Y2ggcG9wcGluZycpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29weVRyZWVTdGF0ZShzdGF0ZSkge1xuICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICBhdG9tVmFsdWVzOiBzdGF0ZS5hdG9tVmFsdWVzLmNsb25lKCksXG4gICAgbm9udmFsaWRhdGVkQXRvbXM6IHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmNsb25lKCksXG4gICAgZGlydHlBdG9tczogbmV3IFNldChzdGF0ZS5kaXJ0eUF0b21zKVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlRG93bnN0cmVhbXMoc3RvcmUsIHN0YXRlKSB7XG4gIC8vIEluZm9ybSBhbnkgbm9kZXMgdGhhdCB3ZXJlIGNoYW5nZWQgb3IgZG93bnN0cmVhbSBvZiBjaGFuZ2VzIHNvIHRoYXQgdGhleVxuICAvLyBjYW4gY2xlYXIgb3V0IGFueSBjYWNoZXMgYXMgbmVlZGVkIGR1ZSB0byB0aGUgdXBkYXRlOlxuICBjb25zdCBkb3duc3RyZWFtcyA9IGdldERvd25zdHJlYW1Ob2RlcyQxKHN0b3JlLCBzdGF0ZSwgc3RhdGUuZGlydHlBdG9tcyk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgZG93bnN0cmVhbXMpIHtcbiAgICB2YXIgX2dldE5vZGVNYXliZSwgX2dldE5vZGVNYXliZSRpbnZhbGlkO1xuXG4gICAgKF9nZXROb2RlTWF5YmUgPSBnZXROb2RlTWF5YmUkMihrZXkpKSA9PT0gbnVsbCB8fCBfZ2V0Tm9kZU1heWJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2dldE5vZGVNYXliZSRpbnZhbGlkID0gX2dldE5vZGVNYXliZS5pbnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfZ2V0Tm9kZU1heWJlJGludmFsaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXROb2RlTWF5YmUkaW52YWxpZC5jYWxsKF9nZXROb2RlTWF5YmUsIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRSZWNvaWxWYWx1ZShzdG9yZSwgcmVjb2lsVmFsdWUsIHZhbHVlT3JVcGRhdGVyKSB7XG4gIHF1ZXVlT3JQZXJmb3JtU3RhdGVVcGRhdGUoc3RvcmUsIHtcbiAgICB0eXBlOiAnc2V0JyxcbiAgICByZWNvaWxWYWx1ZSxcbiAgICB2YWx1ZU9yVXBkYXRlclxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0UmVjb2lsVmFsdWVMb2FkYWJsZShzdG9yZSwgcmVjb2lsVmFsdWUsIGxvYWRhYmxlKSB7XG4gIGlmIChsb2FkYWJsZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQxKSB7XG4gICAgcmV0dXJuIHNldFJlY29pbFZhbHVlKHN0b3JlLCByZWNvaWxWYWx1ZSwgbG9hZGFibGUpO1xuICB9XG5cbiAgcXVldWVPclBlcmZvcm1TdGF0ZVVwZGF0ZShzdG9yZSwge1xuICAgIHR5cGU6ICdzZXRMb2FkYWJsZScsXG4gICAgcmVjb2lsVmFsdWUsXG4gICAgbG9hZGFibGU6IGxvYWRhYmxlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZChzdG9yZSwgcmVjb2lsVmFsdWUpIHtcbiAgcXVldWVPclBlcmZvcm1TdGF0ZVVwZGF0ZShzdG9yZSwge1xuICAgIHR5cGU6ICdtYXJrTW9kaWZpZWQnLFxuICAgIHJlY29pbFZhbHVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlKHN0b3JlLCByZWNvaWxWYWx1ZSwgdW52YWxpZGF0ZWRWYWx1ZSkge1xuICBxdWV1ZU9yUGVyZm9ybVN0YXRlVXBkYXRlKHN0b3JlLCB7XG4gICAgdHlwZTogJ3NldFVudmFsaWRhdGVkJyxcbiAgICByZWNvaWxWYWx1ZSxcbiAgICB1bnZhbGlkYXRlZFZhbHVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmVUb1JlY29pbFZhbHVlKHN0b3JlLCB7XG4gIGtleVxufSwgY2FsbGJhY2ssIGNvbXBvbmVudERlYnVnTmFtZSA9IG51bGwpIHtcbiAgY29uc3Qgc3ViSUQgPSBnZXROZXh0Q29tcG9uZW50SUQkMSgpO1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICBpZiAoIXN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5oYXMoa2V5KSkge1xuICAgIHN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5zZXQoa2V5LCBuZXcgTWFwKCkpO1xuICB9XG5cbiAgUmVjb2lsX251bGx0aHJvd3Moc3RvcmVTdGF0ZS5ub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zLmdldChrZXkpKS5zZXQoc3ViSUQsIFtjb21wb25lbnREZWJ1Z05hbWUgIT09IG51bGwgJiYgY29tcG9uZW50RGVidWdOYW1lICE9PSB2b2lkIDAgPyBjb21wb25lbnREZWJ1Z05hbWUgOiAnPG5vdCBjYXB0dXJlZD4nLCBjYWxsYmFja10pOyAvLyBIYW5kbGUgdGhlIGNhc2UgdGhhdCwgZHVyaW5nIHRoZSBzYW1lIHRpY2sgdGhhdCB3ZSBhcmUgc3Vic2NyaWJpbmcsIGFuIGF0b21cbiAgLy8gaGFzIGJlZW4gdXBkYXRlZCBieSBzb21lIGVmZmVjdCBoYW5kbGVyLiBPdGhlcndpc2Ugd2Ugd2lsbCBtaXNzIHRoZSB1cGRhdGUuXG5cbiAgY29uc3QgbW9kZSA9IHJlYWN0TW9kZSQxKCk7XG5cbiAgaWYgKG1vZGUuZWFybHkgJiYgKG1vZGUubW9kZSA9PT0gJ0xFR0FDWScgfHwgbW9kZS5tb2RlID09PSAnTVVUQUJMRV9TT1VSQ0UnKSkge1xuICAgIGNvbnN0IG5leHRUcmVlID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZTtcblxuICAgIGlmIChuZXh0VHJlZSAmJiBuZXh0VHJlZS5kaXJ0eUF0b21zLmhhcyhrZXkpKSB7XG4gICAgICBjYWxsYmFjayhuZXh0VHJlZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZWxlYXNlOiAoKSA9PiB7XG4gICAgICBjb25zdCByZWxlYXNlU3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBjb25zdCBzdWJzID0gcmVsZWFzZVN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5nZXQoa2V5KTtcblxuICAgICAgaWYgKHN1YnMgPT09IHVuZGVmaW5lZCB8fCAhc3Vicy5oYXMoc3ViSUQpKSB7XG4gICAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbihgU3Vic2NyaXB0aW9uIG1pc3NpbmcgYXQgcmVsZWFzZSB0aW1lIGZvciBhdG9tICR7a2V5fS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWNvaWwuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3Vicy5kZWxldGUoc3ViSUQpO1xuXG4gICAgICBpZiAoc3Vicy5zaXplID09PSAwKSB7XG4gICAgICAgIHJlbGVhc2VTdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiByZWZyZXNoUmVjb2lsVmFsdWUoc3RvcmUsIHJlY29pbFZhbHVlKSB7XG4gIHZhciBfbm9kZSRjbGVhckNhY2hlO1xuXG4gIGNvbnN0IHtcbiAgICBjdXJyZW50VHJlZVxuICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3Qgbm9kZSA9IGdldE5vZGUkMihyZWNvaWxWYWx1ZS5rZXkpO1xuICAoX25vZGUkY2xlYXJDYWNoZSA9IG5vZGUuY2xlYXJDYWNoZSkgPT09IG51bGwgfHwgX25vZGUkY2xlYXJDYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkY2xlYXJDYWNoZS5jYWxsKG5vZGUsIHN0b3JlLCBjdXJyZW50VHJlZSk7XG59XG5cbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2UgPSB7XG4gIFJlY29pbFZhbHVlUmVhZE9ubHk6IFJlY29pbFZhbHVlUmVhZE9ubHkkMSxcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZTogQWJzdHJhY3RSZWNvaWxWYWx1ZSQxLFxuICBSZWNvaWxTdGF0ZTogUmVjb2lsU3RhdGUkMSxcbiAgZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlLFxuICBzZXRSZWNvaWxWYWx1ZSxcbiAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSxcbiAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQsXG4gIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUsXG4gIHN1YnNjcmliZVRvUmVjb2lsVmFsdWUsXG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkMSxcbiAgYXBwbHlBdG9tVmFsdWVXcml0ZXMsXG4gIC8vIFRPRE8gUmVtb3ZlIGV4cG9ydCB3aGVuIGRlcHJlY2F0aW5nIGluaXRpYWxTdG9yZVN0YXRlX0RFUFJFQ0FURUQgaW4gUmVjb2lsUm9vdFxuICBiYXRjaFN0YXJ0LFxuICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUsXG4gIGludmFsaWRhdGVEb3duc3RyZWFtcyxcbiAgY29weVRyZWVTdGF0ZSxcbiAgcmVmcmVzaFJlY29pbFZhbHVlXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBUaGUgc29tZVNldCgpIG1ldGhvZCB0ZXN0cyB3aGV0aGVyIHNvbWUgZWxlbWVudHMgaW4gdGhlIGdpdmVuIFNldCBwYXNzIHRoZVxuICogdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gc29tZVNldChzZXQsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGNvbnN0IGl0ZXJhdG9yID0gc2V0LmVudHJpZXMoKTtcbiAgbGV0IGN1cnJlbnQgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgd2hpbGUgKCFjdXJyZW50LmRvbmUpIHtcbiAgICBjb25zdCBlbnRyeSA9IGN1cnJlbnQudmFsdWU7XG5cbiAgICBpZiAoY2FsbGJhY2suY2FsbChjb250ZXh0LCBlbnRyeVsxXSwgZW50cnlbMF0sIHNldCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGN1cnJlbnQgPSBpdGVyYXRvci5uZXh0KCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBSZWNvaWxfc29tZVNldCA9IHNvbWVTZXQ7XG5cbmNvbnN0IHtcbiAgY2xlYW5VcE5vZGU6IGNsZWFuVXBOb2RlJDFcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGU6IGRlbGV0ZU5vZGVDb25maWdJZlBvc3NpYmxlJDEsXG4gIGdldE5vZGU6IGdldE5vZGUkM1xufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIFJldGVudGlvblpvbmU6IFJldGVudGlvblpvbmUkMlxufSA9IFJlY29pbF9SZXRlbnRpb25ab25lO1xuXG5cblxuXG5cblxuXG4gLy8gQ29tcG9uZW50cyB0aGF0IGFyZW4ndCBtb3VudGVkIGFmdGVyIHN1c3BlbmRpbmcgZm9yIHRoaXMgbG9uZyB3aWxsIGJlIGFzc3VtZWRcbi8vIHRvIGJlIGRpc2NhcmRlZCBhbmQgdGhlaXIgcmVzb3VyY2VzIHJlbGVhc2VkLlxuXG5cbmNvbnN0IFNVU1BFTlNFX1RJTUVPVVRfTVMgPSAxMjAwMDA7XG5jb25zdCBlbXB0eVNldCQxID0gbmV3IFNldCgpO1xuXG5mdW5jdGlvbiByZWxlYXNlUmV0YWluYWJsZXNOb3dPbkN1cnJlbnRUcmVlKHN0b3JlLCByZXRhaW5hYmxlcykge1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3QgdHJlZVN0YXRlID0gc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcblxuICBpZiAoc3RvcmVTdGF0ZS5uZXh0VHJlZSkge1xuICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbigncmVsZWFzZU5vZGVzTm93T25DdXJyZW50VHJlZSBzaG91bGQgb25seSBiZSBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhIGJhdGNoJyk7XG4gICAgcmV0dXJuOyAvLyBsZWFrIG1lbW9yeSByYXRoZXIgdGhhbiBlcmFzZSBzb21ldGhpbmcgdGhhdCdzIGFib3V0IHRvIGJlIHVzZWQuXG4gIH1cblxuICBjb25zdCBub2RlcyA9IG5ldyBTZXQoKTtcblxuICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcbiAgICBpZiAociBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMikge1xuICAgICAgZm9yIChjb25zdCBuIG9mIG5vZGVzUmV0YWluZWRCeVpvbmUoc3RvcmVTdGF0ZSwgcikpIHtcbiAgICAgICAgbm9kZXMuYWRkKG4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2Rlcy5hZGQocik7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVsZWFzYWJsZU5vZGVzID0gZmluZFJlbGVhc2FibGVOb2RlcyhzdG9yZSwgbm9kZXMpO1xuXG4gIGZvciAoY29uc3Qgbm9kZSBvZiByZWxlYXNhYmxlTm9kZXMpIHtcbiAgICByZWxlYXNlTm9kZShzdG9yZSwgdHJlZVN0YXRlLCBub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUmVsZWFzYWJsZU5vZGVzKHN0b3JlLCBzZWFyY2hGcm9tTm9kZXMpIHtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IHRyZWVTdGF0ZSA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG4gIGNvbnN0IGdyYXBoID0gc3RvcmUuZ2V0R3JhcGgodHJlZVN0YXRlLnZlcnNpb24pO1xuICBjb25zdCByZWxlYXNhYmxlTm9kZXMgPSBuZXcgU2V0KCk7IC8vIG11dGF0ZWQgdG8gY29sbGVjdCBhbnN3ZXJcblxuICBjb25zdCBub25SZWxlYXNhYmxlTm9kZXMgPSBuZXcgU2V0KCk7XG4gIGZpbmRSZWxlYXNhYmxlTm9kZXNJbm5lcihzZWFyY2hGcm9tTm9kZXMpO1xuICByZXR1cm4gcmVsZWFzYWJsZU5vZGVzO1xuXG4gIGZ1bmN0aW9uIGZpbmRSZWxlYXNhYmxlTm9kZXNJbm5lcihzZWFyY2hGcm9tTm9kZXMpIHtcbiAgICBjb25zdCByZWxlYXNhYmxlTm9kZXNGb3VuZFRoaXNJdGVyYXRpb24gPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgZG93bnN0cmVhbXMgPSBnZXREb3duc3RyZWFtTm9kZXNJblRvcG9sb2dpY2FsT3JkZXIoc3RvcmUsIHRyZWVTdGF0ZSwgc2VhcmNoRnJvbU5vZGVzLCByZWxlYXNhYmxlTm9kZXMsIC8vIGRvbid0IGRlc2NlbmQgaW50byB0aGVzZVxuICAgIG5vblJlbGVhc2FibGVOb2RlcyAvLyBkb24ndCBkZXNjZW5kIGludG8gdGhlc2VcbiAgICApOyAvLyBGaW5kIHdoaWNoIG9mIHRoZSBkb3duc3RyZWFtIG5vZGVzIGFyZSByZWxlYXNhYmxlIGFuZCB3aGljaCBhcmUgbm90OlxuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIGRvd25zdHJlYW1zKSB7XG4gICAgICB2YXIgX3N0b3JlU3RhdGUkcmV0ZW50aW9uO1xuXG4gICAgICAvLyBOb3QgcmVsZWFzYWJsZSBpZiBjb25maWd1cmVkIHRvIGJlIHJldGFpbmVkIGZvcmV2ZXI6XG4gICAgICBpZiAoZ2V0Tm9kZSQzKG5vZGUpLnJldGFpbmVkQnkgPT09ICdyZWNvaWxSb290Jykge1xuICAgICAgICBub25SZWxlYXNhYmxlTm9kZXMuYWRkKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gTm90IHJlbGVhc2FibGUgaWYgcmV0YWluZWQgZGlyZWN0bHkgYnkgYSBjb21wb25lbnQ6XG5cblxuICAgICAgaWYgKCgoX3N0b3JlU3RhdGUkcmV0ZW50aW9uID0gc3RvcmVTdGF0ZS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzLmdldChub2RlKSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkcmV0ZW50aW9uICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRyZXRlbnRpb24gOiAwKSA+IDApIHtcbiAgICAgICAgbm9uUmVsZWFzYWJsZU5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIE5vdCByZWxlYXNhYmxlIGlmIHJldGFpbmVkIGJ5IGEgem9uZTpcblxuXG4gICAgICBpZiAoem9uZXNUaGF0Q291bGRSZXRhaW5Ob2RlKG5vZGUpLnNvbWUoeiA9PiBzdG9yZVN0YXRlLnJldGVudGlvbi5yZWZlcmVuY2VDb3VudHMuZ2V0KHopKSkge1xuICAgICAgICBub25SZWxlYXNhYmxlTm9kZXMuYWRkKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gTm90IHJlbGVhc2FibGUgaWYgaXQgaGFzIGEgbm9uLXJlbGVhc2FibGUgY2hpbGQgKHdoaWNoIHdpbGwgYWxyZWFkeSBiZSBpblxuICAgICAgLy8gbm9uUmVsZWFzYWJsZU5vZGVzIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIGluIHRvcG9sb2dpY2FsIG9yZGVyKTpcblxuXG4gICAgICBjb25zdCBub2RlQ2hpbGRyZW4gPSBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQobm9kZSk7XG5cbiAgICAgIGlmIChub2RlQ2hpbGRyZW4gJiYgUmVjb2lsX3NvbWVTZXQobm9kZUNoaWxkcmVuLCBjaGlsZCA9PiBub25SZWxlYXNhYmxlTm9kZXMuaGFzKGNoaWxkKSkpIHtcbiAgICAgICAgbm9uUmVsZWFzYWJsZU5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJlbGVhc2FibGVOb2Rlcy5hZGQobm9kZSk7XG4gICAgICByZWxlYXNhYmxlTm9kZXNGb3VuZFRoaXNJdGVyYXRpb24uYWRkKG5vZGUpO1xuICAgIH0gLy8gSWYgd2UgZm91bmQgYW55IHJlbGVhc2FibGUgbm9kZXMsIHdlIG5lZWQgdG8gd2FsayBVUCBmcm9tIHRob3NlIG5vZGVzIHRvXG4gICAgLy8gZmluZCB3aGV0aGVyIHRoZWlyIHBhcmVudHMgY2FuIG5vdyBiZSByZWxlYXNlZCBhcyB3ZWxsOlxuXG5cbiAgICBjb25zdCBwYXJlbnRzID0gbmV3IFNldCgpO1xuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIHJlbGVhc2FibGVOb2Rlc0ZvdW5kVGhpc0l0ZXJhdGlvbikge1xuICAgICAgZm9yIChjb25zdCBwYXJlbnQgb2YgKF9ncmFwaCRub2RlRGVwcyRnZXQgPSBncmFwaC5ub2RlRGVwcy5nZXQobm9kZSkpICE9PSBudWxsICYmIF9ncmFwaCRub2RlRGVwcyRnZXQgIT09IHZvaWQgMCA/IF9ncmFwaCRub2RlRGVwcyRnZXQgOiBlbXB0eVNldCQxKSB7XG4gICAgICAgIHZhciBfZ3JhcGgkbm9kZURlcHMkZ2V0O1xuXG4gICAgICAgIGlmICghcmVsZWFzYWJsZU5vZGVzLmhhcyhwYXJlbnQpKSB7XG4gICAgICAgICAgcGFyZW50cy5hZGQocGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJlbnRzLnNpemUpIHtcbiAgICAgIGZpbmRSZWxlYXNhYmxlTm9kZXNJbm5lcihwYXJlbnRzKTtcbiAgICB9XG4gIH1cbn0gLy8gQ2hpbGRyZW4gYmVmb3JlIHBhcmVudHNcblxuXG5mdW5jdGlvbiBnZXREb3duc3RyZWFtTm9kZXNJblRvcG9sb2dpY2FsT3JkZXIoc3RvcmUsIHRyZWVTdGF0ZSwgbm9kZXMsIC8vIE11dGFibGUgc2V0IGlzIGRlc3Ryb3llZCBpbiBwbGFjZVxuZG9Ob3REZXNjZW5kSW50bzEsIGRvTm90RGVzY2VuZEludG8yKSB7XG4gIGNvbnN0IGdyYXBoID0gc3RvcmUuZ2V0R3JhcGgodHJlZVN0YXRlLnZlcnNpb24pO1xuICBjb25zdCBhbnN3ZXIgPSBbXTtcbiAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcblxuICB3aGlsZSAobm9kZXMuc2l6ZSA+IDApIHtcbiAgICB2aXNpdChSZWNvaWxfbnVsbHRocm93cyhub2Rlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWUpKTtcbiAgfVxuXG4gIHJldHVybiBhbnN3ZXI7XG5cbiAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xuICAgIGlmIChkb05vdERlc2NlbmRJbnRvMS5oYXMobm9kZSkgfHwgZG9Ob3REZXNjZW5kSW50bzIuaGFzKG5vZGUpKSB7XG4gICAgICBub2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZpc2l0ZWQuaGFzKG5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQobm9kZSk7XG5cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgdmlzaXQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgIG5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICBhbnN3ZXIucHVzaChub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWxlYXNlTm9kZShzdG9yZSwgdHJlZVN0YXRlLCBub2RlKSB7XG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBBdG9tIGVmZmVjdHMsIGluLWNsb3N1cmUgY2FjaGVzLCBldGMuOlxuXG5cbiAgY2xlYW5VcE5vZGUkMShzdG9yZSwgbm9kZSk7IC8vIERlbGV0ZSBmcm9tIHN0b3JlIHN0YXRlOlxuXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBzdG9yZVN0YXRlLmtub3duQXRvbXMuZGVsZXRlKG5vZGUpO1xuICBzdG9yZVN0YXRlLmtub3duU2VsZWN0b3JzLmRlbGV0ZShub2RlKTtcbiAgc3RvcmVTdGF0ZS5ub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLmRlbGV0ZShub2RlKTtcbiAgc3RvcmVTdGF0ZS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzLmRlbGV0ZShub2RlKTtcbiAgY29uc3Qgem9uZXMgPSB6b25lc1RoYXRDb3VsZFJldGFpbk5vZGUobm9kZSk7XG5cbiAgZm9yIChjb25zdCB6b25lIG9mIHpvbmVzKSB7XG4gICAgdmFyIF9zdG9yZVN0YXRlJHJldGVudGlvbjI7XG5cbiAgICAoX3N0b3JlU3RhdGUkcmV0ZW50aW9uMiA9IHN0b3JlU3RhdGUucmV0ZW50aW9uLm5vZGVzUmV0YWluZWRCeVpvbmUuZ2V0KHpvbmUpKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRyZXRlbnRpb24yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRyZXRlbnRpb24yLmRlbGV0ZShub2RlKTtcbiAgfSAvLyBOb3RlIHRoYXQgd2UgRE8gTk9UIGRlbGV0ZSBmcm9tIG5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMgYmVjYXVzZSB0aGlzXG4gIC8vIGFscmVhZHkgaGFwcGVucyB3aGVuIHRoZSBsYXN0IGNvbXBvbmVudCB0aGF0IHdhcyByZXRhaW5pbmcgdGhlIG5vZGUgdW5tb3VudHMsXG4gIC8vIGFuZCB0aGlzIGNvdWxkIGhhcHBlbiBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoYXQuXG4gIC8vIERlbGV0ZSBmcm9tIFRyZWVTdGF0ZSBhbmQgZGVwIGdyYXBoOlxuXG5cbiAgdHJlZVN0YXRlLmF0b21WYWx1ZXMuZGVsZXRlKG5vZGUpO1xuICB0cmVlU3RhdGUuZGlydHlBdG9tcy5kZWxldGUobm9kZSk7XG4gIHRyZWVTdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5kZWxldGUobm9kZSk7XG4gIGNvbnN0IGdyYXBoID0gc3RvcmVTdGF0ZS5ncmFwaHNCeVZlcnNpb24uZ2V0KHRyZWVTdGF0ZS52ZXJzaW9uKTtcblxuICBpZiAoZ3JhcGgpIHtcbiAgICBjb25zdCBkZXBzID0gZ3JhcGgubm9kZURlcHMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKGRlcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZ3JhcGgubm9kZURlcHMuZGVsZXRlKG5vZGUpO1xuXG4gICAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XG4gICAgICAgIHZhciBfZ3JhcGgkbm9kZVRvTm9kZVN1YnM7XG5cbiAgICAgICAgKF9ncmFwaCRub2RlVG9Ob2RlU3VicyA9IGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChkZXApKSA9PT0gbnVsbCB8fCBfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ncmFwaCRub2RlVG9Ob2RlU3Vicy5kZWxldGUobm9kZSk7XG4gICAgICB9XG4gICAgfSAvLyBObyBuZWVkIHRvIGRlbGV0ZSBzdWIncyBkZXBzIGFzIHRoZXJlIHNob3VsZCBiZSBubyBzdWJzIGF0IHRoaXMgcG9pbnQuXG4gICAgLy8gQnV0IGFuIGludmFyaWFudCB3b3VsZCByZXF1aXJlIGRlbGV0aW5nIG5vZGVzIGluIHRvcG9sb2dpY2FsIG9yZGVyLlxuXG5cbiAgICBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5kZWxldGUobm9kZSk7XG4gIH0gLy8gTm9kZSBjb25maWcgKGZvciBmYW1pbHkgbWVtYmVycyBvbmx5IGFzIHRoZWlyIGNvbmZpZ3MgY2FuIGJlIHJlY3JlYXRlZCwgYW5kXG4gIC8vIG9ubHkgaWYgdGhleSBhcmUgbm90IHJldGFpbmVkIHdpdGhpbiBhbnkgb3RoZXIgU3RvcmVzKTpcblxuXG4gIGRlbGV0ZU5vZGVDb25maWdJZlBvc3NpYmxlJDEobm9kZSk7XG59XG5cbmZ1bmN0aW9uIG5vZGVzUmV0YWluZWRCeVpvbmUoc3RvcmVTdGF0ZSwgem9uZSkge1xuICB2YXIgX3N0b3JlU3RhdGUkcmV0ZW50aW9uMztcblxuICByZXR1cm4gKF9zdG9yZVN0YXRlJHJldGVudGlvbjMgPSBzdG9yZVN0YXRlLnJldGVudGlvbi5ub2Rlc1JldGFpbmVkQnlab25lLmdldCh6b25lKSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkcmV0ZW50aW9uMyAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkcmV0ZW50aW9uMyA6IGVtcHR5U2V0JDE7XG59XG5cbmZ1bmN0aW9uIHpvbmVzVGhhdENvdWxkUmV0YWluTm9kZShub2RlKSB7XG4gIGNvbnN0IHJldGFpbmVkQnkgPSBnZXROb2RlJDMobm9kZSkucmV0YWluZWRCeTtcblxuICBpZiAocmV0YWluZWRCeSA9PT0gdW5kZWZpbmVkIHx8IHJldGFpbmVkQnkgPT09ICdjb21wb25lbnRzJyB8fCByZXRhaW5lZEJ5ID09PSAncmVjb2lsUm9vdCcpIHtcbiAgICByZXR1cm4gW107XG4gIH0gZWxzZSBpZiAocmV0YWluZWRCeSBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMikge1xuICAgIHJldHVybiBbcmV0YWluZWRCeV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJldGFpbmVkQnk7IC8vIGl0J3MgYW4gYXJyYXkgb2Ygem9uZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZU9yUGVyZm9ybVBvc3NpYmxlUmVsZWFzZU9mUmV0YWluYWJsZShzdG9yZSwgcmV0YWluYWJsZSkge1xuICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgaWYgKHN0YXRlLm5leHRUcmVlKSB7XG4gICAgc3RhdGUucmV0ZW50aW9uLnJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2UuYWRkKHJldGFpbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHJlbGVhc2VSZXRhaW5hYmxlc05vd09uQ3VycmVudFRyZWUoc3RvcmUsIG5ldyBTZXQoW3JldGFpbmFibGVdKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUmV0YWluQ291bnQoc3RvcmUsIHJldGFpbmFibGUsIGRlbHRhKSB7XG4gIHZhciBfbWFwJGdldDtcblxuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBtYXAgPSBzdG9yZS5nZXRTdGF0ZSgpLnJldGVudGlvbi5yZWZlcmVuY2VDb3VudHM7XG4gIGNvbnN0IG5ld0NvdW50ID0gKChfbWFwJGdldCA9IG1hcC5nZXQocmV0YWluYWJsZSkpICE9PSBudWxsICYmIF9tYXAkZ2V0ICE9PSB2b2lkIDAgPyBfbWFwJGdldCA6IDApICsgZGVsdGE7XG5cbiAgaWYgKG5ld0NvdW50ID09PSAwKSB7XG4gICAgdXBkYXRlUmV0YWluQ291bnRUb1plcm8oc3RvcmUsIHJldGFpbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIG1hcC5zZXQocmV0YWluYWJsZSwgbmV3Q291bnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJldGFpbkNvdW50VG9aZXJvKHN0b3JlLCByZXRhaW5hYmxlKSB7XG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG1hcCA9IHN0b3JlLmdldFN0YXRlKCkucmV0ZW50aW9uLnJlZmVyZW5jZUNvdW50cztcbiAgbWFwLmRlbGV0ZShyZXRhaW5hYmxlKTtcbiAgc2NoZWR1bGVPclBlcmZvcm1Qb3NzaWJsZVJlbGVhc2VPZlJldGFpbmFibGUoc3RvcmUsIHJldGFpbmFibGUpO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3coc3RvcmUpIHtcbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICByZWxlYXNlUmV0YWluYWJsZXNOb3dPbkN1cnJlbnRUcmVlKHN0b3JlLCBzdGF0ZS5yZXRlbnRpb24ucmV0YWluYWJsZXNUb0NoZWNrRm9yUmVsZWFzZSk7XG4gIHN0YXRlLnJldGVudGlvbi5yZXRhaW5hYmxlc1RvQ2hlY2tGb3JSZWxlYXNlLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdChyKSB7XG4gIC8vIFRoZSBkZWZhdWx0IHdpbGwgY2hhbmdlIGZyb20gJ3JlY29pbFJvb3QnIHRvICdjb21wb25lbnRzJyBpbiB0aGUgZnV0dXJlLlxuICByZXR1cm4gciA9PT0gdW5kZWZpbmVkID8gJ3JlY29pbFJvb3QnIDogcjtcbn1cblxudmFyIFJlY29pbF9SZXRlbnRpb24gPSB7XG4gIFNVU1BFTlNFX1RJTUVPVVRfTVMsXG4gIHVwZGF0ZVJldGFpbkNvdW50LFxuICB1cGRhdGVSZXRhaW5Db3VudFRvWmVybyxcbiAgcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93LFxuICByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHRcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogVGhpcyBpcyB0byBleHBvcnQgZXNzdGllbnRpYWwgZnVuY3Rpb25zIGZyb20gcmVhY3QtZG9tXG4gKiBmb3Igb3VyIHdlYiBidWlsZFxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuY29uc3Qge1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlc1xufSA9IHJlYWN0RG9tO1xuXG52YXIgUmVhY3RCYXRjaGVkVXBkYXRlcyA9IHtcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXNcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogVGhpcyBpcyB0byBleHBvcnQgZXNzdGllbnRpYWwgZnVuY3Rpb25zIGZyb20gcmVhY3QtZG9tXG4gKiBmb3Igb3VyIHdlYiBidWlsZFxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLy8gQGZiLW9ubHk6IGNvbnN0IHt1bnN0YWJsZV9iYXRjaGVkVXBkYXRlc30gPSByZXF1aXJlKCdSZWFjdERPTUNvbWV0Jyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHtcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDFcbn0gPSBSZWFjdEJhdGNoZWRVcGRhdGVzOyAvLyBAb3NzLW9ubHlcblxuXG52YXIgUmVjb2lsX1JlYWN0QmF0Y2hlZFVwZGF0ZXMgPSB7XG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQxXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuY29uc3Qge1xuICBiYXRjaFN0YXJ0OiBiYXRjaFN0YXJ0JDFcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XG5cbmNvbnN0IHtcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDJcbn0gPSBSZWNvaWxfUmVhY3RCYXRjaGVkVXBkYXRlcztcblxubGV0IGJhdGNoZXIgPSB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQyOyAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG4vKipcbiAqIFNldHMgdGhlIHByb3ZpZGVkIGJhdGNoZXIgZnVuY3Rpb24gYXMgdGhlIGJhdGNoZXIgZnVuY3Rpb24gdXNlZCBieSBSZWNvaWwuXG4gKlxuICogU2V0IHRoZSBiYXRjaGVyIHRvIGEgY3VzdG9tIGJhdGNoZXIgZm9yIHlvdXIgcmVuZGVyZXIsXG4gKiBpZiB5b3UgdXNlIGEgcmVuZGVyZXIgb3RoZXIgdGhhbiBSZWFjdCBET00gb3IgUmVhY3QgTmF0aXZlLlxuICovXG5jb25zdCBzZXRCYXRjaGVyID0gbmV3QmF0Y2hlciA9PiB7XG4gIGJhdGNoZXIgPSBuZXdCYXRjaGVyO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBiYXRjaGVyIGZ1bmN0aW9uLlxuICovXG5cblxuY29uc3QgZ2V0QmF0Y2hlciA9ICgpID0+IGJhdGNoZXI7XG4vKipcbiAqIENhbGxzIHRoZSBjdXJyZW50IGJhdGNoZXIgZnVuY3Rpb24gYW5kIHBhc3NlcyB0aGVcbiAqIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5cblxuY29uc3QgYmF0Y2hVcGRhdGVzID0gY2FsbGJhY2sgPT4ge1xuICBiYXRjaGVyKCgpID0+IHtcbiAgICBsZXQgYmF0Y2hFbmQgPSAoKSA9PiB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgYmF0Y2hFbmQgPSBiYXRjaFN0YXJ0JDEoKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGJhdGNoRW5kKCk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBSZWNvaWxfQmF0Y2hpbmcgPSB7XG4gIGdldEJhdGNoZXIsXG4gIHNldEJhdGNoZXIsXG4gIGJhdGNoVXBkYXRlc1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogQ29tYmluZXMgbXVsdGlwbGUgSXRlcmFibGVzIGludG8gYSBzaW5nbGUgSXRlcmFibGUuXG4gKiBUcmF2ZXJzZXMgdGhlIGlucHV0IEl0ZXJhYmxlcyBpbiB0aGUgb3JkZXIgcHJvdmlkZWQgYW5kIG1haW50YWlucyB0aGUgb3JkZXJcbiAqIG9mIHRoZWlyIGVsZW1lbnRzLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBcbiAqIGNvbnN0IHIgPSBBcnJheS5mcm9tKGNvbmNhdEl0ZXJhYmxlcyhbJ2EnLCAnYiddLCBbJ2MnXSwgWydkJywgJ2UnLCAnZiddKSk7XG4gKiByID09IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnXTtcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uKiBjb25jYXRJdGVyYWJsZXMoaXRlcnMpIHtcbiAgZm9yIChjb25zdCBpdGVyIG9mIGl0ZXJzKSB7XG4gICAgZm9yIChjb25zdCB2YWwgb2YgaXRlcikge1xuICAgICAgeWllbGQgdmFsO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVjb2lsX2NvbmNhdEl0ZXJhYmxlcyA9IGNvbmNhdEl0ZXJhYmxlcztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbmNvbnN0IGlzU1NSID0gLy8gJEZsb3dGaXhNZShzaXRlPXJlY29pbCkgV2luZG93IGRvZXMgbm90IGhhdmUgYSBGbG93VHlwZSBkZWZpbml0aW9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy82NzA5XG50eXBlb2YgV2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbi8qIGVzbGludC1lbmFibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuY29uc3QgaXNXaW5kb3cgPSB2YWx1ZSA9PiAhaXNTU1IgJiYgKCAvLyAkRmxvd0ZpeE1lKHNpdGU9cmVjb2lsKSBXaW5kb3cgZG9lcyBub3QgaGF2ZSBhIEZsb3dUeXBlIGRlZmluaXRpb24gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzY3MDlcbnZhbHVlID09PSB3aW5kb3cgfHwgdmFsdWUgaW5zdGFuY2VvZiBXaW5kb3cpO1xuXG5jb25zdCBpc1JlYWN0TmF0aXZlID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZSc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZmItd3d3L3R5cGVvZi11bmRlZmluZWRcblxudmFyIFJlY29pbF9FbnZpcm9ubWVudCA9IHtcbiAgaXNTU1IsXG4gIGlzUmVhY3ROYXRpdmUsXG4gIGlzV2luZG93XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBDYWNoZXMgYSBmdW5jdGlvbidzIHJlc3VsdHMgYmFzZWQgb24gdGhlIGtleSByZXR1cm5lZCBieSB0aGUgcGFzc2VkXG4gKiBoYXNoRnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZVdpdGhBcmdzSGFzaChmbiwgaGFzaEZ1bmN0aW9uKSB7XG4gIGxldCBjYWNoZTtcblxuICBjb25zdCBtZW1vaXplZEZuID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoIWNhY2hlKSB7XG4gICAgICBjYWNoZSA9IHt9O1xuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IGhhc2hGdW5jdGlvbiguLi5hcmdzKTtcblxuICAgIGlmICghT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGtleSkpIHtcbiAgICAgIGNhY2hlW2tleV0gPSBmbiguLi5hcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVba2V5XTtcbiAgfTtcblxuICByZXR1cm4gbWVtb2l6ZWRGbjtcbn1cbi8qKlxuICogQ2FjaGVzIGEgZnVuY3Rpb24ncyByZXN1bHRzIGJhc2VkIG9uIGEgY29tcGFyaXNvbiBvZiB0aGUgYXJndW1lbnRzLlxuICogT25seSBjYWNoZXMgdGhlIGxhc3QgcmV0dXJuIG9mIHRoZSBmdW5jdGlvbi5cbiAqIERlZmF1bHRzIHRvIHJlZmVyZW5jZSBlcXVhbGl0eVxuICovXG5cblxuZnVuY3Rpb24gbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaChmbiwgaGFzaEZ1bmN0aW9uKSB7XG4gIGxldCBsYXN0S2V5O1xuICBsZXQgbGFzdFJlc3VsdDsgLy8gYnJlYWtpbmcgY2FjaGUgd2hlbiBhcmd1bWVudHMgY2hhbmdlXG5cbiAgY29uc3QgbWVtb2l6ZWRGbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaGFzaEZ1bmN0aW9uKC4uLmFyZ3MpO1xuXG4gICAgaWYgKGxhc3RLZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfVxuXG4gICAgbGFzdEtleSA9IGtleTtcbiAgICBsYXN0UmVzdWx0ID0gZm4oLi4uYXJncyk7XG4gICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIG1lbW9pemVkRm47XG59XG4vKipcbiAqIENhY2hlcyBhIGZ1bmN0aW9uJ3MgcmVzdWx0cyBiYXNlZCBvbiBhIGNvbXBhcmlzb24gb2YgdGhlIGFyZ3VtZW50cy5cbiAqIE9ubHkgY2FjaGVzIHRoZSBsYXN0IHJldHVybiBvZiB0aGUgZnVuY3Rpb24uXG4gKiBEZWZhdWx0cyB0byByZWZlcmVuY2UgZXF1YWxpdHlcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb24oZm4sIGhhc2hGdW5jdGlvbikge1xuICBsZXQgbGFzdEtleTtcbiAgbGV0IGxhc3RSZXN1bHQ7IC8vIGJyZWFraW5nIGNhY2hlIHdoZW4gYXJndW1lbnRzIGNoYW5nZVxuXG4gIGNvbnN0IG1lbW9pemVkRm4gPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGhhc2hGdW5jdGlvbiguLi5hcmdzKTtcblxuICAgIGlmIChsYXN0S2V5ID09PSBrZXkpIHtcbiAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgIH1cblxuICAgIGxhc3RLZXkgPSBrZXk7XG4gICAgbGFzdFJlc3VsdCA9IGZuKC4uLmFyZ3MpO1xuICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICB9O1xuXG4gIGNvbnN0IGludmFsaWRhdGUgPSAoKSA9PiB7XG4gICAgbGFzdEtleSA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFttZW1vaXplZEZuLCBpbnZhbGlkYXRlXTtcbn1cblxudmFyIFJlY29pbF9NZW1vaXplID0ge1xuICBtZW1vaXplV2l0aEFyZ3NIYXNoLFxuICBtZW1vaXplT25lV2l0aEFyZ3NIYXNoLFxuICBtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uXG59O1xuXG5jb25zdCB7XG4gIGJhdGNoVXBkYXRlczogYmF0Y2hVcGRhdGVzJDFcbn0gPSBSZWNvaWxfQmF0Y2hpbmc7XG5cbmNvbnN0IHtcbiAgaW5pdGlhbGl6ZU5vZGU6IGluaXRpYWxpemVOb2RlJDEsXG4gIHBlZWtOb2RlSW5mbzogcGVla05vZGVJbmZvJDFcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgZ3JhcGg6IGdyYXBoJDFcbn0gPSBSZWNvaWxfR3JhcGg7XG5cbmNvbnN0IHtcbiAgZ2V0TmV4dFN0b3JlSUQ6IGdldE5leHRTdG9yZUlEJDFcbn0gPSBSZWNvaWxfS2V5cztcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDEsXG4gIHJlY29pbFZhbHVlczogcmVjb2lsVmFsdWVzJDEsXG4gIHJlY29pbFZhbHVlc0ZvcktleXM6IHJlY29pbFZhbHVlc0ZvcktleXMkMlxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkMixcbiAgZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlOiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMSxcbiAgc2V0UmVjb2lsVmFsdWU6IHNldFJlY29pbFZhbHVlJDEsXG4gIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWU6IHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuY29uc3Qge1xuICB1cGRhdGVSZXRhaW5Db3VudDogdXBkYXRlUmV0YWluQ291bnQkMVxufSA9IFJlY29pbF9SZXRlbnRpb247XG5cbmNvbnN0IHtcbiAgc2V0SW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3Q6IHNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDFcbn0gPSBSZWNvaWxfU25hcHNob3RDYWNoZTtcblxuY29uc3Qge1xuICBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbjogZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMixcbiAgbWFrZUVtcHR5U3RvcmVTdGF0ZTogbWFrZUVtcHR5U3RvcmVTdGF0ZSQxXG59ID0gUmVjb2lsX1N0YXRlO1xuXG5cblxuY29uc3Qge1xuICBpc1NTUjogaXNTU1IkMVxufSA9IFJlY29pbF9FbnZpcm9ubWVudDtcblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IHtcbiAgbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaEFuZEludmFsaWRhdGlvbjogbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaEFuZEludmFsaWRhdGlvbiQxXG59ID0gUmVjb2lsX01lbW9pemU7XG5cblxuXG4gLy8gT3BhcXVlIGF0IHRoaXMgc3VyZmFjZSBiZWNhdXNlIGl0J3MgcGFydCBvZiB0aGUgcHVibGljIEFQSSBmcm9tIGhlcmUuXG5cblxuY29uc3QgcmV0YWluV2FybmluZyA9IGBcblJlY29pbCBTbmFwc2hvdHMgb25seSBsYXN0IGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGNhbGxiYWNrIHRoZXkgYXJlIHByb3ZpZGVkIHRvLiBUbyBrZWVwIGEgU25hcHNob3QgbG9uZ2VyLCBkbyB0aGlzOlxuXG4gIGNvbnN0IHJlbGVhc2UgPSBzbmFwc2hvdC5yZXRhaW4oKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBkb1NvbWV0aGluZ1dpdGhTbmFwc2hvdChzbmFwc2hvdCk7XG4gIH0gZmluYWxseSB7XG4gICAgcmVsZWFzZSgpO1xuICB9XG5cblRoaXMgaXMgY3VycmVudGx5IGEgREVWLW9ubHkgd2FybmluZyBidXQgd2lsbCBiZWNvbWUgYSB0aHJvd24gZXhjZXB0aW9uIGluIHRoZSBuZXh0IHJlbGVhc2Ugb2YgUmVjb2lsLlxuYDsgLy8gQSBcIlNuYXBzaG90XCIgaXMgXCJyZWFkLW9ubHlcIiBhbmQgY2FwdHVyZXMgYSBzcGVjaWZpYyBzZXQgb2YgdmFsdWVzIG9mIGF0b21zLlxuLy8gSG93ZXZlciwgdGhlIGRhdGEtZmxvdy1ncmFwaCBhbmQgc2VsZWN0b3IgdmFsdWVzIG1heSBldm9sdmUgYXMgc2VsZWN0b3Jcbi8vIGV2YWx1YXRpb24gZnVuY3Rpb25zIGFyZSBleGVjdXRlZCBhbmQgYXN5bmMgc2VsZWN0b3JzIHJlc29sdmUuXG5cbmNsYXNzIFNuYXBzaG90IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9uby11bmluaXRpYWxpemVkLXByb3BlcnRpZXNcbiAgY29uc3RydWN0b3Ioc3RvcmVTdGF0ZSwgcGFyZW50U3RvcmVJRCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdG9yZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3JlZkNvdW50XCIsIDEpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0TG9hZGFibGVcIiwgcmVjb2lsVmFsdWUgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICByZXR1cm4gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDEodGhpcy5fc3RvcmUsIHJlY29pbFZhbHVlKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFByb21pc2VcIiwgcmVjb2lsVmFsdWUgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRMb2FkYWJsZShyZWNvaWxWYWx1ZSkudG9Qcm9taXNlKCk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXROb2Rlc19VTlNUQUJMRVwiLCBvcHQgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7IC8vIFRPRE8gRGVhbCB3aXRoIG1vZGlmaWVkIHNlbGVjdG9yc1xuXG4gICAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5pc01vZGlmaWVkKSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5pc0luaXRpYWxpemVkKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XG5cbiAgICAgICAgcmV0dXJuIHJlY29pbFZhbHVlc0ZvcktleXMkMihzdGF0ZS5kaXJ0eUF0b21zKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga25vd25BdG9tcyA9IHRoaXMuX3N0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcztcblxuICAgICAgY29uc3Qga25vd25TZWxlY3RvcnMgPSB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmtub3duU2VsZWN0b3JzO1xuXG4gICAgICByZXR1cm4gKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5pc0luaXRpYWxpemVkKSA9PSBudWxsID8gcmVjb2lsVmFsdWVzJDEudmFsdWVzKCkgOiBvcHQuaXNJbml0aWFsaXplZCA9PT0gdHJ1ZSA/IHJlY29pbFZhbHVlc0ZvcktleXMkMihSZWNvaWxfY29uY2F0SXRlcmFibGVzKFtrbm93bkF0b21zLCBrbm93blNlbGVjdG9yc10pKSA6IFJlY29pbF9maWx0ZXJJdGVyYWJsZShyZWNvaWxWYWx1ZXMkMS52YWx1ZXMoKSwgKHtcbiAgICAgICAga2V5XG4gICAgICB9KSA9PiAha25vd25BdG9tcy5oYXMoa2V5KSAmJiAha25vd25TZWxlY3RvcnMuaGFzKGtleSkpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0SW5mb19VTlNUQUJMRVwiLCAoe1xuICAgICAga2V5XG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICByZXR1cm4gcGVla05vZGVJbmZvJDEodGhpcy5fc3RvcmUsIHRoaXMuX3N0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUsIGtleSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXBcIiwgbWFwcGVyID0+IHtcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xuICAgICAgY29uc3QgbXV0YWJsZVNuYXBzaG90ID0gbmV3IE11dGFibGVTbmFwc2hvdCh0aGlzLCBiYXRjaFVwZGF0ZXMkMSk7XG4gICAgICBtYXBwZXIobXV0YWJsZVNuYXBzaG90KTsgLy8gaWYgcmVtb3ZpbmcgYmF0Y2hVcGRhdGVzIGZyb20gYHNldGAgYWRkIGl0IGhlcmVcblxuICAgICAgcmV0dXJuIG11dGFibGVTbmFwc2hvdDtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFzeW5jTWFwXCIsIGFzeW5jIG1hcHBlciA9PiB7XG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICAgIGNvbnN0IG11dGFibGVTbmFwc2hvdCA9IG5ldyBNdXRhYmxlU25hcHNob3QodGhpcywgYmF0Y2hVcGRhdGVzJDEpO1xuICAgICAgbXV0YWJsZVNuYXBzaG90LnJldGFpbigpOyAvLyBSZXRhaW4gbmV3IHNuYXBzaG90IGR1cmluZyBhc3luYyBtYXBwZXJcblxuICAgICAgYXdhaXQgbWFwcGVyKG11dGFibGVTbmFwc2hvdCk7IC8vIENvbnRpbnVlIHRvIHJldGFpbiB0aGUgbmV3IHNuYXBzaG90IGZvciB0aGUgdXNlciwgYnV0IGF1dG8tcmVsZWFzZSBpdFxuICAgICAgLy8gYWZ0ZXIgdGhlIG5leHQgdGljaywgdGhlIHNhbWUgYXMgYSBuZXcgc3luY2hyb25vdXMgc25hcHNob3QuXG5cbiAgICAgIG11dGFibGVTbmFwc2hvdC5hdXRvUmVsZWFzZV9JTlRFUk5BTCgpO1xuICAgICAgcmV0dXJuIG11dGFibGVTbmFwc2hvdDtcbiAgICB9KTtcblxuICAgIHRoaXMuX3N0b3JlID0ge1xuICAgICAgc3RvcmVJRDogZ2V0TmV4dFN0b3JlSUQkMSgpLFxuICAgICAgcGFyZW50U3RvcmVJRCxcbiAgICAgIGdldFN0YXRlOiAoKSA9PiBzdG9yZVN0YXRlLFxuICAgICAgcmVwbGFjZVN0YXRlOiByZXBsYWNlciA9PiB7XG4gICAgICAgIC8vIG5vIGJhdGNoaW5nLCBzbyBuZXh0VHJlZSBpcyBuZXZlciBhY3RpdmVcbiAgICAgICAgc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA9IHJlcGxhY2VyKHN0b3JlU3RhdGUuY3VycmVudFRyZWUpO1xuICAgICAgfSxcbiAgICAgIGdldEdyYXBoOiB2ZXJzaW9uID0+IHtcbiAgICAgICAgY29uc3QgZ3JhcGhzID0gc3RvcmVTdGF0ZS5ncmFwaHNCeVZlcnNpb247XG5cbiAgICAgICAgaWYgKGdyYXBocy5oYXModmVyc2lvbikpIHtcbiAgICAgICAgICByZXR1cm4gUmVjb2lsX251bGx0aHJvd3MoZ3JhcGhzLmdldCh2ZXJzaW9uKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdHcmFwaCA9IGdyYXBoJDEoKTtcbiAgICAgICAgZ3JhcGhzLnNldCh2ZXJzaW9uLCBuZXdHcmFwaCk7XG4gICAgICAgIHJldHVybiBuZXdHcmFwaDtcbiAgICAgIH0sXG4gICAgICBzdWJzY3JpYmVUb1RyYW5zYWN0aW9uczogKCkgPT4gKHtcbiAgICAgICAgcmVsZWFzZTogKCkgPT4ge31cbiAgICAgIH0pLFxuICAgICAgYWRkVHJhbnNhY3Rpb25NZXRhZGF0YTogKCkgPT4ge1xuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdDYW5ub3Qgc3Vic2NyaWJlIHRvIFNuYXBzaG90cycpO1xuICAgICAgfVxuICAgIH07IC8vIEluaXRpYWxpemUgYW55IG5vZGVzIHRoYXQgYXJlIGxpdmUgaW4gdGhlIHBhcmVudCBzdG9yZSAocHJpbWFyaWx5IHNvIHRoYXRcbiAgICAvLyB0aGlzIHNuYXBzaG90IGdldHMgY291bnRlZCB0b3dhcmRzIHRoZSBub2RlJ3MgbGl2ZSBzdG9yZXMgY291bnQpLlxuICAgIC8vIFRPRE8gT3B0aW1pemUgdGhpcyB3aGVuIGNsb25pbmcgc25hcHNob3RzIGZvciBjYWxsYmFja3NcblxuICAgIGZvciAoY29uc3Qgbm9kZUtleSBvZiB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMpIHtcbiAgICAgIGluaXRpYWxpemVOb2RlJDEodGhpcy5fc3RvcmUsIG5vZGVLZXksICdnZXQnKTtcbiAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDEodGhpcy5fc3RvcmUsIG5vZGVLZXksIDEpO1xuICAgIH1cblxuICAgIHRoaXMuYXV0b1JlbGVhc2VfSU5URVJOQUwoKTtcbiAgfVxuXG4gIHJldGFpbigpIHtcbiAgICBpZiAodGhpcy5fcmVmQ291bnQgPD0gMCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdTbmFwc2hvdCBoYXMgYWxyZWFkeSBiZWVuIHJlbGVhc2VkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdBdHRlbXB0IHRvIHJldGFpbigpIFNuYXBzaG90IHRoYXQgd2FzIGFscmVhZHkgcmVsZWFzZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcmVmQ291bnQrKztcbiAgICBsZXQgcmVsZWFzZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFyZWxlYXNlZCkge1xuICAgICAgICByZWxlYXNlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fcmVsZWFzZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlbGVhc2UgdGhlIHNuYXBzaG90IG9uIHRoZSBuZXh0IHRpY2suICBUaGlzIG1lYW5zIHRoZSBzbmFwc2hvdCBpcyByZXRhaW5lZFxuICAgKiBkdXJpbmcgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgY3VycmVudCBmdW5jdGlvbiB1c2luZyBpdC5cbiAgICovXG5cblxuICBhdXRvUmVsZWFzZV9JTlRFUk5BTCgpIHtcbiAgICBpZiAoIWlzU1NSJDEpIHtcbiAgICAgIC8vIFVzZSB0aW1lb3V0IG9mIDEwIHRvIHdvcmthcm91bmQgRmlyZWZveCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rZXhwZXJpbWVudGFsL1JlY29pbC9pc3N1ZXMvMTkzNlxuICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGhpcy5fcmVsZWFzZSgpLCAxMCk7XG4gICAgfVxuICB9XG5cbiAgX3JlbGVhc2UoKSB7XG4gICAgdGhpcy5fcmVmQ291bnQtLTtcblxuICAgIGlmICh0aGlzLl9yZWZDb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcblxuICAgICAgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5jbGVhcigpO1xuXG4gICAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBUZW1wb3JhcmlseSBuZXJmaW5nIHRoaXMgdG8gYWxsb3cgdXMgdG8gZmluZCBicm9rZW4gY2FsbCBzaXRlcyB3aXRob3V0XG4gICAgICAvLyBhY3R1YWxseSBicmVha2luZyBhbnlib2R5IHlldC5cbiAgICAgIC8vIGZvciAoY29uc3QgayBvZiB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMpIHtcbiAgICAgIC8vICAgdXBkYXRlUmV0YWluQ291bnRUb1plcm8odGhpcy5fc3RvcmUsIGspO1xuICAgICAgLy8gfVxuXG4gICAgfSBlbHNlIGlmICh0aGlzLl9yZWZDb3VudCA8IDApIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdTbmFwc2hvdCByZWxlYXNlZCBhbiBleHRyYSB0aW1lLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzUmV0YWluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZkNvdW50ID4gMDtcbiAgfVxuXG4gIGNoZWNrUmVmQ291bnRfSU5URVJOQUwoKSB7XG4gICAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykgJiYgdGhpcy5fcmVmQ291bnQgPD0gMCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24ocmV0YWluV2FybmluZyk7XG4gICAgICB9IC8vIFdoYXQgd2Ugd2lsbCBzaGlwIGxhdGVyOlxuICAgICAgLy8gdGhyb3cgZXJyKHJldGFpbldhcm5pbmcpO1xuXG4gICAgfVxuICB9XG5cbiAgZ2V0U3RvcmVfSU5URVJOQUwoKSB7XG4gICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlO1xuICB9XG5cbiAgZ2V0SUQoKSB7XG4gICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUuc3RhdGVJRDtcbiAgfVxuXG4gIGdldFN0b3JlSUQoKSB7XG4gICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLnN0b3JlSUQ7XG4gIH0gLy8gV2Ugd2FudCB0byBhbGxvdyB0aGUgbWV0aG9kcyB0byBiZSBkZXN0cnVjdHVyZWQgYW5kIHVzZWQgYXMgYWNjZXNzb3JzXG5cbiAgLyogZXNsaW50LWRpc2FibGUgZmItd3d3L2V4dHJhLWFycm93LWluaXRpYWxpemVyICovXG5cbiAgLyogZXNsaW50LWVuYWJsZSBmYi13d3cvZXh0cmEtYXJyb3ctaW5pdGlhbGl6ZXIgKi9cblxuXG59XG5cbmZ1bmN0aW9uIGNsb25lU3RvcmVTdGF0ZShzdG9yZSwgdHJlZVN0YXRlLCBidW1wVmVyc2lvbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBjb25zdCB2ZXJzaW9uID0gYnVtcFZlcnNpb24gPyBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQyKCkgOiB0cmVlU3RhdGUudmVyc2lvbjtcbiAgcmV0dXJuIHtcbiAgICAvLyBBbHdheXMgY2xvbmUgdGhlIFRyZWVTdGF0ZSB0byBpc29sYXRlIHN0b3JlcyBmcm9tIGFjY2lkZW50YWwgbXV0YXRpb25zLlxuICAgIC8vIEZvciBleGFtcGxlLCByZWFkaW5nIGEgc2VsZWN0b3IgZnJvbSBhIGNsb25lZCBzbmFwc2hvdCBzaG91bGRuJ3QgY2FjaGVcbiAgICAvLyBpbiB0aGUgb3JpZ2luYWwgdHJlZXN0YXRlIHdoaWNoIG1heSBjYXVzZSB0aGUgb3JpZ2luYWwgdG8gc2tpcFxuICAgIC8vIGluaXRpYWxpemF0aW9uIG9mIHVwc3RyZWFtIGF0b21zLlxuICAgIGN1cnJlbnRUcmVlOiB7XG4gICAgICAvLyBUT0RPIHNuYXBzaG90cyBzaG91bGRuJ3QgcmVhbGx5IGhhdmUgdmVyc2lvbnMgYmVjYXVzZSBhIG5ldyB2ZXJzaW9uIG51bWJlclxuICAgICAgLy8gaXMgYWx3YXlzIGFzc2lnbmVkIHdoZW4gdGhlIHNuYXBzaG90IGlzIGdvbmUgdG8uXG4gICAgICB2ZXJzaW9uOiBidW1wVmVyc2lvbiA/IHZlcnNpb24gOiB0cmVlU3RhdGUudmVyc2lvbixcbiAgICAgIHN0YXRlSUQ6IGJ1bXBWZXJzaW9uID8gdmVyc2lvbiA6IHRyZWVTdGF0ZS5zdGF0ZUlELFxuICAgICAgdHJhbnNhY3Rpb25NZXRhZGF0YTogeyAuLi50cmVlU3RhdGUudHJhbnNhY3Rpb25NZXRhZGF0YVxuICAgICAgfSxcbiAgICAgIGRpcnR5QXRvbXM6IG5ldyBTZXQodHJlZVN0YXRlLmRpcnR5QXRvbXMpLFxuICAgICAgYXRvbVZhbHVlczogdHJlZVN0YXRlLmF0b21WYWx1ZXMuY2xvbmUoKSxcbiAgICAgIG5vbnZhbGlkYXRlZEF0b21zOiB0cmVlU3RhdGUubm9udmFsaWRhdGVkQXRvbXMuY2xvbmUoKVxuICAgIH0sXG4gICAgY29tbWl0RGVwdGg6IDAsXG4gICAgbmV4dFRyZWU6IG51bGwsXG4gICAgcHJldmlvdXNUcmVlOiBudWxsLFxuICAgIGtub3duQXRvbXM6IG5ldyBTZXQoc3RvcmVTdGF0ZS5rbm93bkF0b21zKSxcbiAgICAvLyBGSVhNRSBoZXJlJ3MgYSBjb3B5XG4gICAga25vd25TZWxlY3RvcnM6IG5ldyBTZXQoc3RvcmVTdGF0ZS5rbm93blNlbGVjdG9ycyksXG4gICAgLy8gRklYTUUgaGVyZSdzIGEgY29weVxuICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxuICAgIG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKSxcbiAgICBub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXG4gICAgcXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQ6IFtdLFxuICAgIHN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVyczogbmV3IFNldCgpLFxuICAgIGdyYXBoc0J5VmVyc2lvbjogbmV3IE1hcCgpLnNldCh2ZXJzaW9uLCBzdG9yZS5nZXRHcmFwaCh0cmVlU3RhdGUudmVyc2lvbikpLFxuICAgIHJldGVudGlvbjoge1xuICAgICAgcmVmZXJlbmNlQ291bnRzOiBuZXcgTWFwKCksXG4gICAgICBub2Rlc1JldGFpbmVkQnlab25lOiBuZXcgTWFwKCksXG4gICAgICByZXRhaW5hYmxlc1RvQ2hlY2tGb3JSZWxlYXNlOiBuZXcgU2V0KClcbiAgICB9LFxuICAgIC8vIEZJWE1FIGhlcmUncyBhIGNvcHlcbiAgICAvLyBDcmVhdGUgYmxhbmsgY2xlYW51cCBoYW5kbGVycyBmb3IgYXRvbXMgc28gc25hcHNob3RzIGRvbid0IHJlLXJ1blxuICAgIC8vIGF0b20gZWZmZWN0cy5cbiAgICBub2RlQ2xlYW51cEZ1bmN0aW9uczogbmV3IE1hcChSZWNvaWxfbWFwSXRlcmFibGUoc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5lbnRyaWVzKCksIChba2V5XSkgPT4gW2tleSwgKCkgPT4ge31dKSlcbiAgfTtcbn0gLy8gRmFjdG9yeSB0byBidWlsZCBhIGZyZXNoIHNuYXBzaG90XG5cblxuZnVuY3Rpb24gZnJlc2hTbmFwc2hvdChpbml0aWFsaXplU3RhdGUpIHtcbiAgY29uc3Qgc25hcHNob3QgPSBuZXcgU25hcHNob3QobWFrZUVtcHR5U3RvcmVTdGF0ZSQxKCkpO1xuICByZXR1cm4gaW5pdGlhbGl6ZVN0YXRlICE9IG51bGwgPyBzbmFwc2hvdC5tYXAoaW5pdGlhbGl6ZVN0YXRlKSA6IHNuYXBzaG90O1xufSAvLyBGYWN0b3J5IHRvIGNsb25lIGEgc25hcHNob3Qgc3RhdGVcblxuXG5jb25zdCBbbWVtb2l6ZWRDbG9uZVNuYXBzaG90LCBpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQyXSA9IG1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb24kMSgoc3RvcmUsIHZlcnNpb24pID0+IHtcbiAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlO1xuXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBjb25zdCB0cmVlU3RhdGUgPSB2ZXJzaW9uID09PSAnbGF0ZXN0JyA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBSZWNvaWxfbnVsbHRocm93cyhzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSk7XG4gIHJldHVybiBuZXcgU25hcHNob3QoY2xvbmVTdG9yZVN0YXRlKHN0b3JlLCB0cmVlU3RhdGUpLCBzdG9yZS5zdG9yZUlEKTtcbn0sIChzdG9yZSwgdmVyc2lvbikgPT4ge1xuICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRULCBfc3RvcmUkZ2V0U3RhdGUkcHJldmk7XG5cbiAgcmV0dXJuIFN0cmluZyh2ZXJzaW9uKSArIFN0cmluZyhzdG9yZS5zdG9yZUlEKSArIFN0cmluZygoX3N0b3JlJGdldFN0YXRlJG5leHRUID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlJG5leHRUID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQudmVyc2lvbikgKyBTdHJpbmcoc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZS52ZXJzaW9uKSArIFN0cmluZygoX3N0b3JlJGdldFN0YXRlJHByZXZpID0gc3RvcmUuZ2V0U3RhdGUoKS5wcmV2aW91c1RyZWUpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZSRwcmV2aSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlJGdldFN0YXRlJHByZXZpLnZlcnNpb24pO1xufSk7IC8vIEF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuXG5zZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQxKGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDIpO1xuXG5mdW5jdGlvbiBjbG9uZVNuYXBzaG90KHN0b3JlLCB2ZXJzaW9uID0gJ2xhdGVzdCcpIHtcbiAgY29uc3Qgc25hcHNob3QgPSBtZW1vaXplZENsb25lU25hcHNob3Qoc3RvcmUsIHZlcnNpb24pO1xuXG4gIGlmICghc25hcHNob3QuaXNSZXRhaW5lZCgpKSB7XG4gICAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMigpO1xuICAgIHJldHVybiBtZW1vaXplZENsb25lU25hcHNob3Qoc3RvcmUsIHZlcnNpb24pO1xuICB9XG5cbiAgcmV0dXJuIHNuYXBzaG90O1xufVxuXG5jbGFzcyBNdXRhYmxlU25hcHNob3QgZXh0ZW5kcyBTbmFwc2hvdCB7XG4gIGNvbnN0cnVjdG9yKHNuYXBzaG90LCBiYXRjaCkge1xuICAgIHN1cGVyKGNsb25lU3RvcmVTdGF0ZShzbmFwc2hvdC5nZXRTdG9yZV9JTlRFUk5BTCgpLCBzbmFwc2hvdC5nZXRTdG9yZV9JTlRFUk5BTCgpLmdldFN0YXRlKCkuY3VycmVudFRyZWUsIHRydWUpLCBzbmFwc2hvdC5nZXRTdG9yZUlEKCkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2JhdGNoXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRcIiwgKHJlY29pbFN0YXRlLCBuZXdWYWx1ZU9yVXBkYXRlcikgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRoaXMuZ2V0U3RvcmVfSU5URVJOQUwoKTsgLy8gVGhpcyBiYXRjaFVwZGF0ZXMgZW5zdXJlcyB0aGlzIGBzZXRgIGlzIGFwcGxpZWQgaW1tZWRpYXRlbHkgYW5kIHlvdSBjYW5cbiAgICAgIC8vIHJlYWQgdGhlIHdyaXR0ZW4gdmFsdWUgYWZ0ZXIgY2FsbGluZyBgc2V0YC4gSSB3b3VsZCBsaWtlIHRvIHJlbW92ZSB0aGlzXG4gICAgICAvLyBiZWhhdmlvciBhbmQgb25seSBiYXRjaCBpbiBgU25hcHNob3QubWFwYCwgYnV0IHRoaXMgd291bGQgYmUgYSBicmVha2luZ1xuICAgICAgLy8gY2hhbmdlIHBvdGVudGlhbGx5LlxuXG4gICAgICB0aGlzLl9iYXRjaCgoKSA9PiB7XG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDEoc3RvcmUsIHJlY29pbFN0YXRlLmtleSwgMSk7XG4gICAgICAgIHNldFJlY29pbFZhbHVlJDEodGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpLCByZWNvaWxTdGF0ZSwgbmV3VmFsdWVPclVwZGF0ZXIpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNldFwiLCByZWNvaWxTdGF0ZSA9PiB7XG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpOyAvLyBTZWUgbm90ZSBhdCBgc2V0YCBhYm91dCBiYXRjaGVkIHVwZGF0ZXMuXG5cbiAgICAgIHRoaXMuX2JhdGNoKCgpID0+IHtcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMShzdG9yZSwgcmVjb2lsU3RhdGUua2V5LCAxKTtcbiAgICAgICAgc2V0UmVjb2lsVmFsdWUkMSh0aGlzLmdldFN0b3JlX0lOVEVSTkFMKCksIHJlY29pbFN0YXRlLCBERUZBVUxUX1ZBTFVFJDEpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXNfREVQUkVDQVRFRFwiLCB2YWx1ZXMgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRoaXMuZ2V0U3RvcmVfSU5URVJOQUwoKTsgLy8gU2VlIG5vdGUgYXQgYHNldGAgYWJvdXQgYmF0Y2hlZCB1cGRhdGVzLlxuXG4gICAgICBiYXRjaFVwZGF0ZXMkMSgoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHZhbHVlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICB1cGRhdGVSZXRhaW5Db3VudCQxKHN0b3JlLCBrLCAxKTtcbiAgICAgICAgICBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlJDEoc3RvcmUsIG5ldyBBYnN0cmFjdFJlY29pbFZhbHVlJDIoayksIHYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2JhdGNoID0gYmF0Y2g7XG4gIH1cblxufVxuXG52YXIgUmVjb2lsX1NuYXBzaG90ID0ge1xuICBTbmFwc2hvdCxcbiAgTXV0YWJsZVNuYXBzaG90LFxuICBmcmVzaFNuYXBzaG90LFxuICBjbG9uZVNuYXBzaG90XG59O1xuXG52YXIgUmVjb2lsX1NuYXBzaG90XzEgPSBSZWNvaWxfU25hcHNob3QuU25hcHNob3Q7XG52YXIgUmVjb2lsX1NuYXBzaG90XzIgPSBSZWNvaWxfU25hcHNob3QuTXV0YWJsZVNuYXBzaG90O1xudmFyIFJlY29pbF9TbmFwc2hvdF8zID0gUmVjb2lsX1NuYXBzaG90LmZyZXNoU25hcHNob3Q7XG52YXIgUmVjb2lsX1NuYXBzaG90XzQgPSBSZWNvaWxfU25hcHNob3QuY2xvbmVTbmFwc2hvdDtcblxudmFyIFJlY29pbF9TbmFwc2hvdCQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFNuYXBzaG90OiBSZWNvaWxfU25hcHNob3RfMSxcbiAgTXV0YWJsZVNuYXBzaG90OiBSZWNvaWxfU25hcHNob3RfMixcbiAgZnJlc2hTbmFwc2hvdDogUmVjb2lsX1NuYXBzaG90XzMsXG4gIGNsb25lU25hcHNob3Q6IFJlY29pbF9TbmFwc2hvdF80XG59KTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gdW5pb25TZXRzKC4uLnNldHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuXG4gIGZvciAoY29uc3Qgc2V0IG9mIHNldHMpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHNldCkge1xuICAgICAgcmVzdWx0LmFkZCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlY29pbF91bmlvblNldHMgPSB1bmlvblNldHM7XG5cbmNvbnN0IHtcbiAgdXNlUmVmXG59ID0gcmVhY3Q7XG4vKipcbiAqIFRoZSBzYW1lIGFzIGB1c2VSZWYoKWAgZXhjZXB0IHRoYXQgaWYgYSBmdW5jdGlvbiBpcyBzcGVjaWZpZWQgdGhlbiBpdCB3aWxsXG4gKiBjYWxsIHRoYXQgZnVuY3Rpb24gdG8gZ2V0IHRoZSB2YWx1ZSB0byBpbml0aWFsaXplIHRoZSByZWZlcmVuY2Ugd2l0aC5cbiAqIFRoaXMgaXMgc2ltaWxhciB0byBob3cgYHVzZVN0YXRlKClgIGJlaGF2ZXMgd2hlbiBnaXZlbiBhIGZ1bmN0aW9uLiAgSXQgYWxsb3dzXG4gKiB0aGUgdXNlciB0byBhdm9pZCBnZW5lcmF0aW5nIHRoZSBpbml0aWFsIHZhbHVlIGZvciBzdWJzZXF1ZW50IHJlbmRlcnMuXG4gKiBUaGUgdHJhZGVvZmYgaXMgdGhhdCB0byBzZXQgdGhlIHJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIGl0c2VsZiB5b3UgbmVlZCB0b1xuICogbmVzdCBpdDogdXNlUmVmSW5pdE9uY2UoKCkgPT4gKCkgPT4gey4uLn0pO1xuICovXG5cblxuZnVuY3Rpb24gdXNlUmVmSW5pdE9uY2UoaW5pdGlhbFZhbHVlKSB7XG4gIC8vICRGbG93RXhwZWN0ZWRFcnJvcltpbmNvbXBhdGlibGUtY2FsbF1cbiAgY29uc3QgcmVmID0gdXNlUmVmKGluaXRpYWxWYWx1ZSk7XG5cbiAgaWYgKHJlZi5jdXJyZW50ID09PSBpbml0aWFsVmFsdWUgJiYgdHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICRGbG93RXhwZWN0ZWRFcnJvcltpbmNvbXBhdGlibGUtdXNlXVxuICAgIHJlZi5jdXJyZW50ID0gaW5pdGlhbFZhbHVlKCk7XG4gIH1cblxuICByZXR1cm4gcmVmO1xufVxuXG52YXIgUmVjb2lsX3VzZVJlZkluaXRPbmNlID0gdXNlUmVmSW5pdE9uY2U7XG5cbi8vIEBmYi1vbmx5OiBjb25zdCBSZWNvaWx1c2FnZWxvZ0V2ZW50ID0gcmVxdWlyZSgnUmVjb2lsdXNhZ2Vsb2dFdmVudCcpO1xuLy8gQGZiLW9ubHk6IGNvbnN0IFJlY29pbFVzYWdlTG9nRmFsY29FdmVudCA9IHJlcXVpcmUoJ1JlY29pbFVzYWdlTG9nRmFsY29FdmVudCcpO1xuLy8gQGZiLW9ubHk6IGNvbnN0IFVSSSA9IHJlcXVpcmUoJ1VSSScpO1xuXG5cbmNvbnN0IHtcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb246IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDMsXG4gIG1ha2VFbXB0eVN0b3JlU3RhdGU6IG1ha2VFbXB0eVN0b3JlU3RhdGUkMlxufSA9IFJlY29pbF9TdGF0ZTtcblxuY29uc3Qge1xuICBjbGVhblVwTm9kZTogY2xlYW5VcE5vZGUkMixcbiAgZ2V0RG93bnN0cmVhbU5vZGVzOiBnZXREb3duc3RyZWFtTm9kZXMkMixcbiAgaW5pdGlhbGl6ZU5vZGU6IGluaXRpYWxpemVOb2RlJDIsXG4gIHNldE5vZGVWYWx1ZTogc2V0Tm9kZVZhbHVlJDIsXG4gIHNldFVudmFsaWRhdGVkQXRvbVZhbHVlX0RFUFJFQ0FURUQ6IHNldFVudmFsaWRhdGVkQXRvbVZhbHVlX0RFUFJFQ0FURUQkMVxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICBncmFwaDogZ3JhcGgkMlxufSA9IFJlY29pbF9HcmFwaDtcblxuY29uc3Qge1xuICBjbG9uZUdyYXBoOiBjbG9uZUdyYXBoJDFcbn0gPSBSZWNvaWxfR3JhcGg7XG5cbmNvbnN0IHtcbiAgZ2V0TmV4dFN0b3JlSUQ6IGdldE5leHRTdG9yZUlEJDJcbn0gPSBSZWNvaWxfS2V5cztcblxuY29uc3Qge1xuICBjcmVhdGVNdXRhYmxlU291cmNlOiBjcmVhdGVNdXRhYmxlU291cmNlJDEsXG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDJcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xuXG5jb25zdCB7XG4gIGFwcGx5QXRvbVZhbHVlV3JpdGVzOiBhcHBseUF0b21WYWx1ZVdyaXRlcyQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIHJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdzogcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93JDFcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5jb25zdCB7XG4gIGZyZXNoU25hcHNob3Q6IGZyZXNoU25hcHNob3QkMVxufSA9IFJlY29pbF9TbmFwc2hvdCQxO1xuXG5cblxuY29uc3Qge1xuICB1c2VDYWxsYmFjayxcbiAgdXNlQ29udGV4dCxcbiAgdXNlRWZmZWN0LFxuICB1c2VNZW1vLFxuICB1c2VSZWY6IHVzZVJlZiQxLFxuICB1c2VTdGF0ZVxufSA9IHJlYWN0O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gbm90SW5BQ29udGV4dCgpIHtcbiAgdGhyb3cgUmVjb2lsX2VycignVGhpcyBjb21wb25lbnQgbXVzdCBiZSB1c2VkIGluc2lkZSBhIDxSZWNvaWxSb290PiBjb21wb25lbnQuJyk7XG59XG5cbmNvbnN0IGRlZmF1bHRTdG9yZSA9IE9iamVjdC5mcmVlemUoe1xuICBzdG9yZUlEOiBnZXROZXh0U3RvcmVJRCQyKCksXG4gIGdldFN0YXRlOiBub3RJbkFDb250ZXh0LFxuICByZXBsYWNlU3RhdGU6IG5vdEluQUNvbnRleHQsXG4gIGdldEdyYXBoOiBub3RJbkFDb250ZXh0LFxuICBzdWJzY3JpYmVUb1RyYW5zYWN0aW9uczogbm90SW5BQ29udGV4dCxcbiAgYWRkVHJhbnNhY3Rpb25NZXRhZGF0YTogbm90SW5BQ29udGV4dFxufSk7XG5sZXQgc3RhdGVSZXBsYWNlcklzQmVpbmdFeGVjdXRlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzdGFydE5leHRUcmVlSWZOZWVkZWQoc3RvcmUpIHtcbiAgaWYgKHN0YXRlUmVwbGFjZXJJc0JlaW5nRXhlY3V0ZWQpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdBbiBhdG9tIHVwZGF0ZSB3YXMgdHJpZ2dlcmVkIHdpdGhpbiB0aGUgZXhlY3V0aW9uIG9mIGEgc3RhdGUgdXBkYXRlciBmdW5jdGlvbi4gU3RhdGUgdXBkYXRlciBmdW5jdGlvbnMgcHJvdmlkZWQgdG8gUmVjb2lsIG11c3QgYmUgcHVyZSBmdW5jdGlvbnMuJyk7XG4gIH1cblxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICBpZiAoc3RvcmVTdGF0ZS5uZXh0VHJlZSA9PT0gbnVsbCkge1xuICAgIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpICYmIFJlY29pbF9na3goJ3JlY29pbF9yZWxlYXNlX29uX2Nhc2NhZGluZ191cGRhdGVfa2lsbHN3aXRjaF8yMDIxJykpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjYXNjYWRpbmcgdXBkYXRlICh0aGF0IGlzLCByZW5kZXJpbmcgZHVlIHRvIG9uZSBzdGF0ZSBjaGFuZ2VcbiAgICAgIC8vIGludm9rZXMgYSBzZWNvbmQgc3RhdGUgY2hhbmdlKSwgd2Ugd29uJ3QgaGF2ZSBjbGVhbmVkIHVwIHJldGFpbmFibGVzIHlldFxuICAgICAgLy8gYmVjYXVzZSB0aGlzIG5vcm1hbGx5IGhhcHBlbnMgYWZ0ZXIgbm90aWZ5aW5nIGNvbXBvbmVudHMuIERvIGl0IGJlZm9yZVxuICAgICAgLy8gcHJvY2VlZGluZyB3aXRoIHRoZSBjYXNjYWRpbmcgdXBkYXRlIHNvIHRoYXQgaXQgcmVtYWlucyBwcmVkaWN0YWJsZTpcbiAgICAgIGlmIChzdG9yZVN0YXRlLmNvbW1pdERlcHRoID4gMCkge1xuICAgICAgICByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3ckMShzdG9yZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdmVyc2lvbiA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWUudmVyc2lvbjtcbiAgICBjb25zdCBuZXh0VmVyc2lvbiA9IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDMoKTtcbiAgICBzdG9yZVN0YXRlLm5leHRUcmVlID0geyAuLi5zdG9yZVN0YXRlLmN1cnJlbnRUcmVlLFxuICAgICAgdmVyc2lvbjogbmV4dFZlcnNpb24sXG4gICAgICBzdGF0ZUlEOiBuZXh0VmVyc2lvbixcbiAgICAgIGRpcnR5QXRvbXM6IG5ldyBTZXQoKSxcbiAgICAgIHRyYW5zYWN0aW9uTWV0YWRhdGE6IHt9XG4gICAgfTtcbiAgICBzdG9yZVN0YXRlLmdyYXBoc0J5VmVyc2lvbi5zZXQobmV4dFZlcnNpb24sIGNsb25lR3JhcGgkMShSZWNvaWxfbnVsbHRocm93cyhzdG9yZVN0YXRlLmdyYXBoc0J5VmVyc2lvbi5nZXQodmVyc2lvbikpKSk7XG4gIH1cbn1cblxuY29uc3QgQXBwQ29udGV4dCA9IHJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBjdXJyZW50OiBkZWZhdWx0U3RvcmVcbn0pO1xuXG5jb25zdCB1c2VTdG9yZVJlZiA9ICgpID0+IHVzZUNvbnRleHQoQXBwQ29udGV4dCk7IC8vICRGbG93RXhwZWN0ZWRFcnJvcltpbmNvbXBhdGlibGUtY2FsbF1cblxuXG5jb25zdCBNdXRhYmxlU291cmNlQ29udGV4dCA9IHJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmZ1bmN0aW9uIHVzZVJlY29pbE11dGFibGVTb3VyY2UoKSB7XG4gIGNvbnN0IG11dGFibGVTb3VyY2UgPSB1c2VDb250ZXh0KE11dGFibGVTb3VyY2VDb250ZXh0KTtcblxuICBpZiAobXV0YWJsZVNvdXJjZSA9PSBudWxsKSB7XG4gICAgUmVjb2lsX2V4cGVjdGF0aW9uVmlvbGF0aW9uKCdBdHRlbXB0ZWQgdG8gdXNlIGEgUmVjb2lsIGhvb2sgb3V0c2lkZSBvZiBhIDxSZWNvaWxSb290Pi4gJyArICc8UmVjb2lsUm9vdD4gbXVzdCBiZSBhbiBhbmNlc3RvciBvZiBhbnkgY29tcG9uZW50IHRoYXQgdXNlcyAnICsgJ1JlY29pbCBob29rcy4nKTtcbiAgfVxuXG4gIHJldHVybiBtdXRhYmxlU291cmNlO1xufVxuXG5mdW5jdGlvbiBub3RpZnlDb21wb25lbnRzKHN0b3JlLCBzdG9yZVN0YXRlLCB0cmVlU3RhdGUpIHtcbiAgY29uc3QgZGVwZW5kZW50Tm9kZXMgPSBnZXREb3duc3RyZWFtTm9kZXMkMihzdG9yZSwgdHJlZVN0YXRlLCB0cmVlU3RhdGUuZGlydHlBdG9tcyk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgZGVwZW5kZW50Tm9kZXMpIHtcbiAgICBjb25zdCBjb21wcyA9IHN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5nZXQoa2V5KTtcblxuICAgIGlmIChjb21wcykge1xuICAgICAgZm9yIChjb25zdCBbX3N1YklELCBbX2RlYnVnTmFtZSwgY2FsbGJhY2tdXSBvZiBjb21wcykge1xuICAgICAgICBjYWxsYmFjayh0cmVlU3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnMoc3RvcmUpIHtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IHRyZWVTdGF0ZSA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7IC8vIEluZm9ybSB0cmFuc2FjdGlvbiBzdWJzY3JpYmVycyBvZiB0aGUgdHJhbnNhY3Rpb246XG5cbiAgY29uc3QgZGlydHlBdG9tcyA9IHRyZWVTdGF0ZS5kaXJ0eUF0b21zO1xuXG4gIGlmIChkaXJ0eUF0b21zLnNpemUpIHtcbiAgICAvLyBFeGVjdXRlIE5vZGUtc3BlY2lmaWMgc3Vic2NyaWJlcnMgYmVmb3JlIGdsb2JhbCBzdWJzY3JpYmVyc1xuICAgIGZvciAoY29uc3QgW2tleSwgc3Vic2NyaXB0aW9uc10gb2Ygc3RvcmVTdGF0ZS5ub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zKSB7XG4gICAgICBpZiAoZGlydHlBdG9tcy5oYXMoa2V5KSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtfLCBzdWJzY3JpcHRpb25dIG9mIHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb24oc3RvcmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbXywgc3Vic2NyaXB0aW9uXSBvZiBzdG9yZVN0YXRlLnRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucykge1xuICAgICAgc3Vic2NyaXB0aW9uKHN0b3JlKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlYWN0TW9kZSQyKCkuZWFybHkgfHwgc3RvcmVTdGF0ZS5zdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMuc2l6ZSA+IDApIHtcbiAgICAgIC8vIE5vdGlmeWluZyBjb21wb25lbnRzIGlzIG5lZWRlZCB0byB3YWtlIGZyb20gc3VzcGVuc2UsIGV2ZW4gd2hlbiB1c2luZ1xuICAgICAgLy8gZWFybHkgcmVuZGVyaW5nLlxuICAgICAgbm90aWZ5Q29tcG9uZW50cyhzdG9yZSwgc3RvcmVTdGF0ZSwgdHJlZVN0YXRlKTsgLy8gV2FrZSBhbGwgc3VzcGVuZGVkIGNvbXBvbmVudHMgc28gdGhlIHJpZ2h0IG9uZShzKSBjYW4gdHJ5IHRvIHJlLXJlbmRlci5cbiAgICAgIC8vIFdlIG5lZWQgdG8gd2FrZSB1cCBjb21wb25lbnRzIG5vdCBqdXN0IHdoZW4gc29tZSBhc3luY2hyb25vdXMgc2VsZWN0b3JcbiAgICAgIC8vIHJlc29sdmVkLCBidXQgYWxzbyB3aGVuIGNoYW5naW5nIHN5bmNocm9ub3VzIHZhbHVlcyBiZWNhdXNlIHRoaXMgbWF5IGNhdXNlXG4gICAgICAvLyBhIHNlbGVjdG9yIHRvIGNoYW5nZSBmcm9tIGFzeW5jaHJvbm91cyB0byBzeW5jaHJvbm91cywgaW4gd2hpY2ggY2FzZSB0aGVyZVxuICAgICAgLy8gd291bGQgYmUgbm8gZm9sbG93LXVwIGFzeW5jaHJvbm91cyByZXNvbHV0aW9uIHRvIHdha2UgdXMgdXAuXG4gICAgICAvLyBUT0RPIE9QVElNSVpBVElPTiBPbmx5IHdha2UgdXAgcmVsYXRlZCBkb3duc3RyZWFtIGNvbXBvbmVudHNcblxuICAgICAgc3RvcmVTdGF0ZS5zdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMuZm9yRWFjaChjYiA9PiBjYigpKTtcbiAgICAgIHN0b3JlU3RhdGUuc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzLmNsZWFyKCk7XG4gICAgfVxuICB9IC8vIFNwZWNpYWwgYmVoYXZpb3IgT05MWSBpbnZva2VkIGJ5IHVzZUludGVyZmFjZS5cbiAgLy8gRklYTUUgZGVsZXRlIHF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVEIHdoZW4gZGVsZXRpbmcgdXNlSW50ZXJmYWNlLlxuXG5cbiAgc3RvcmVTdGF0ZS5xdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRC5mb3JFYWNoKGNiID0+IGNiKHRyZWVTdGF0ZSkpO1xuICBzdG9yZVN0YXRlLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELnNwbGljZSgwLCBzdG9yZVN0YXRlLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGVuZEJhdGNoKHN0b3JlKSB7XG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBzdG9yZVN0YXRlLmNvbW1pdERlcHRoKys7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7XG4gICAgICBuZXh0VHJlZVxuICAgIH0gPSBzdG9yZVN0YXRlOyAvLyBJZ25vcmUgY29tbWl0cyB0aGF0IGFyZSBub3QgYmVjYXVzZSBvZiBSZWNvaWwgdHJhbnNhY3Rpb25zIC0tIG5hbWVseSxcbiAgICAvLyBiZWNhdXNlIHNvbWV0aGluZyBhYm92ZSBSZWNvaWxSb290IHJlLXJlbmRlcmVkOlxuXG4gICAgaWYgKG5leHRUcmVlID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG5leHRUcmVlIGlzIG5vdyBjb21taXR0ZWQgLS0gbm90ZSB0aGF0IGNvcHlpbmcgYW5kIHJlc2V0IG9jY3VycyB3aGVuXG4gICAgLy8gYSB0cmFuc2FjdGlvbiBiZWdpbnMsIGluIHN0YXJ0TmV4dFRyZWVJZk5lZWRlZDpcblxuXG4gICAgc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUgPSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICAgIHN0b3JlU3RhdGUuY3VycmVudFRyZWUgPSBuZXh0VHJlZTtcbiAgICBzdG9yZVN0YXRlLm5leHRUcmVlID0gbnVsbDtcbiAgICBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnMoc3RvcmUpO1xuXG4gICAgaWYgKHN0b3JlU3RhdGUucHJldmlvdXNUcmVlICE9IG51bGwpIHtcbiAgICAgIHN0b3JlU3RhdGUuZ3JhcGhzQnlWZXJzaW9uLmRlbGV0ZShzdG9yZVN0YXRlLnByZXZpb3VzVHJlZS52ZXJzaW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdFbmRlZCBiYXRjaCB3aXRoIG5vIHByZXZpb3VzIHN0YXRlLCB3aGljaCBpcyB1bmV4cGVjdGVkJywgJ3JlY29pbCcpO1xuICAgIH1cblxuICAgIHN0b3JlU3RhdGUucHJldmlvdXNUcmVlID0gbnVsbDtcblxuICAgIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgICAvLyBPbmx5IHJlbGVhc2UgcmV0YWluYWJsZXMgaWYgdGhlcmUgd2VyZSBubyB3cml0ZXMgZHVyaW5nIHRoZSBlbmQgb2YgdGhlXG4gICAgICAvLyBiYXRjaC4gIFRoaXMgYXZvaWRzIHJlbGVhc2luZyBzb21ldGhpbmcgd2UgbWlnaHQgYmUgYWJvdXQgdG8gdXNlLlxuICAgICAgaWYgKG5leHRUcmVlID09IG51bGwpIHtcbiAgICAgICAgcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93JDEoc3RvcmUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBzdG9yZVN0YXRlLmNvbW1pdERlcHRoLS07XG4gIH1cbn1cbi8qXG4gKiBUaGUgcHVycG9zZSBvZiB0aGUgQmF0Y2hlciBpcyB0byBvYnNlcnZlIHdoZW4gUmVhY3QgYmF0Y2hlcyBlbmQgc28gdGhhdFxuICogUmVjb2lsIHN0YXRlIGNoYW5nZXMgY2FuIGJlIGJhdGNoZWQuIFdoZW5ldmVyIFJlY29pbCBzdGF0ZSBjaGFuZ2VzLCB3ZSBjYWxsXG4gKiBzZXRTdGF0ZSBvbiB0aGUgYmF0Y2hlci4gVGhlbiB3ZSB3YWl0IGZvciB0aGF0IGNoYW5nZSB0byBiZSBjb21taXR0ZWQsIHdoaWNoXG4gKiBzaWduaWZpZXMgdGhlIGVuZCBvZiB0aGUgYmF0Y2guIFRoYXQncyB3aGVuIHdlIHJlc3BvbmQgdG8gdGhlIFJlY29pbCBjaGFuZ2UuXG4gKi9cblxuXG5mdW5jdGlvbiBCYXRjaGVyKHtcbiAgc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlXG59KSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYoKTtcbiAgY29uc3QgWywgc2V0U3RhdGVdID0gdXNlU3RhdGUoW10pO1xuICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2UoKCkgPT4gc2V0U3RhdGUoe30pKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2UoKCkgPT4gc2V0U3RhdGUoe30pKTsgLy8gSWYgYW4gYXN5bmNocm9ub3VzIHNlbGVjdG9yIHJlc29sdmVzIGFmdGVyIHRoZSBCYXRjaGVyIGlzIHVubW91bnRlZCxcbiAgICAvLyBub3RpZnlCYXRjaGVyT2ZDaGFuZ2Ugd2lsbCBzdGlsbCBiZSBjYWxsZWQuIEFuIGVycm9yIGdldHMgdGhyb3duIHdoZW5ldmVyXG4gICAgLy8gc2V0U3RhdGUgaXMgY2FsbGVkIGFmdGVyIGEgY29tcG9uZW50IGlzIGFscmVhZHkgdW5tb3VudGVkLCBzbyB0aGlzIHNldHNcbiAgICAvLyBub3RpZnlCYXRjaGVyT2ZDaGFuZ2UgdG8gYmUgYSBuby1vcC5cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2UoKCkgPT4ge30pO1xuICAgIH07XG4gIH0sIFtzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2VdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBlbnF1ZXVlRXhlY3V0aW9uIHJ1bnMgdGhpcyBmdW5jdGlvbiBpbW1lZGlhdGVseTsgaXQgaXMgb25seSB1c2VkIHRvXG4gICAgLy8gbWFuaXB1bGF0ZSB0aGUgb3JkZXIgb2YgdXNlRWZmZWN0cyBkdXJpbmcgdGVzdHMsIHNpbmNlIFJlYWN0IHNlZW1zIHRvXG4gICAgLy8gY2FsbCB1c2VFZmZlY3QgaW4gYW4gdW5wcmVkaWN0YWJsZSBvcmRlciBzb21ldGltZXMuXG4gICAgUmVjb2lsX1F1ZXVlLmVucXVldWVFeGVjdXRpb24oJ0JhdGNoZXInLCAoKSA9PiB7XG4gICAgICBlbmRCYXRjaChzdG9yZVJlZi5jdXJyZW50KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LiRyZWNvaWxEZWJ1Z1N0YXRlcykge1xuICAgIHdpbmRvdy4kcmVjb2lsRGVidWdTdGF0ZXMgPSBbXTtcbiAgfVxufSAvLyBXaGVuIHJlbW92aW5nIHRoaXMgZGVwcmVjYXRlZCBmdW5jdGlvbiwgcmVtb3ZlIHN0YXRlQnlTZXR0aW5nUmVjb2lsVmFsdWVcbi8vIHdoaWNoIHdpbGwgbm8gbG9uZ2VyIGJlIG5lZWRlZC5cblxuXG5mdW5jdGlvbiBpbml0aWFsU3RvcmVTdGF0ZV9ERVBSRUNBVEVEKHN0b3JlLCBpbml0aWFsaXplU3RhdGUpIHtcbiAgY29uc3QgaW5pdGlhbCA9IG1ha2VFbXB0eVN0b3JlU3RhdGUkMigpO1xuICBpbml0aWFsaXplU3RhdGUoe1xuICAgIHNldDogKGF0b20sIHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGluaXRpYWwuY3VycmVudFRyZWU7XG4gICAgICBjb25zdCB3cml0ZXMgPSBzZXROb2RlVmFsdWUkMihzdG9yZSwgc3RhdGUsIGF0b20ua2V5LCB2YWx1ZSk7XG4gICAgICBjb25zdCB3cml0dGVuTm9kZXMgPSBuZXcgU2V0KHdyaXRlcy5rZXlzKCkpO1xuICAgICAgY29uc3Qgbm9udmFsaWRhdGVkQXRvbXMgPSBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5jbG9uZSgpO1xuXG4gICAgICBmb3IgKGNvbnN0IG4gb2Ygd3JpdHRlbk5vZGVzKSB7XG4gICAgICAgIG5vbnZhbGlkYXRlZEF0b21zLmRlbGV0ZShuKTtcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbC5jdXJyZW50VHJlZSA9IHsgLi4uc3RhdGUsXG4gICAgICAgIGRpcnR5QXRvbXM6IFJlY29pbF91bmlvblNldHMoc3RhdGUuZGlydHlBdG9tcywgd3JpdHRlbk5vZGVzKSxcbiAgICAgICAgYXRvbVZhbHVlczogYXBwbHlBdG9tVmFsdWVXcml0ZXMkMShzdGF0ZS5hdG9tVmFsdWVzLCB3cml0ZXMpLFxuICAgICAgICAvLyBOQjogUExFQVNFIHVuLWV4cG9ydCBhcHBseUF0b21WYWx1ZVdyaXRlcyB3aGVuIGRlbGV0aW5nIHRoaXMgY29kZVxuICAgICAgICBub252YWxpZGF0ZWRBdG9tc1xuICAgICAgfTtcbiAgICB9LFxuICAgIHNldFVudmFsaWRhdGVkQXRvbVZhbHVlczogYXRvbVZhbHVlcyA9PiB7XG4gICAgICAvLyBGSVhNRSByZXBsYWNlIHRoaXMgd2l0aCBhIG11dGF0aXZlIGxvb3BcbiAgICAgIGF0b21WYWx1ZXMuZm9yRWFjaCgodiwgaykgPT4ge1xuICAgICAgICBpbml0aWFsLmN1cnJlbnRUcmVlID0gc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCQxKGluaXRpYWwuY3VycmVudFRyZWUsIGssIHYpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGluaXRpYWw7XG59IC8vIEluaXRpYWxpemUgc3RhdGUgc25hcHNob3QgZm9yIDxSZWNvaWxSb290PiBmb3IgdGhlIGluaXRpYWxpemVTdGF0ZSBwcm9wLlxuLy8gQXRvbSBlZmZlY3QgaW5pdGlhbGl6YXRpb24gdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgcHJvcC5cbi8vIEFueSBhdG9tIGVmZmVjdHMgd2lsbCBiZSBydW4gYmVmb3JlIGluaXRpYWxpemF0aW9uLCBidXQgdGhlbiBjbGVhbmVkIHVwLFxuLy8gdGhleSBhcmUgdGhlbiByZS1ydW4gd2hlbiB1c2VkIGFzIHBhcnQgb2YgcmVuZGVyaW5nLiAgVGhlc2Ugc2VtYW50aWNzIGFyZVxuLy8gY29tcGF0aWJsZSB3aXRoIFJlYWN0IFN0cmljdE1vZGUgd2hlcmUgZWZmZWN0cyBtYXkgYmUgcmUtcnVuIG11bHRpcGxlIHRpbWVzXG4vLyBidXQgc3RhdGUgaW5pdGlhbGl6YXRpb24gb25seSBoYXBwZW5zIG9uY2UgdGhlIGZpcnN0IHRpbWUuXG5cblxuZnVuY3Rpb24gaW5pdGlhbFN0b3JlU3RhdGUoaW5pdGlhbGl6ZVN0YXRlKSB7XG4gIC8vIEluaXRpYWxpemUgYSBzbmFwc2hvdCBhbmQgZ2V0IGl0cyBzdG9yZVxuICBjb25zdCBzbmFwc2hvdCA9IGZyZXNoU25hcHNob3QkMShpbml0aWFsaXplU3RhdGUpO1xuICBjb25zdCBzdG9yZVN0YXRlID0gc25hcHNob3QuZ2V0U3RvcmVfSU5URVJOQUwoKS5nZXRTdGF0ZSgpOyAvLyBDb3VudGVyYWN0IHRoZSBzbmFwc2hvdCBhdXRvLXJlbGVhc2VcblxuICBzbmFwc2hvdC5yZXRhaW4oKTsgLy8gQ2xlYW51cCBhbnkgZWZmZWN0cyBydW4gZHVyaW5nIGluaXRpYWxpemF0aW9uIGFuZCBjbGVhciB0aGUgaGFuZGxlcnMgc29cbiAgLy8gdGhleSB3aWxsIHJlLWluaXRpYWxpemUgaWYgdXNlZCBkdXJpbmcgcmVuZGVyaW5nLiAgVGhpcyBhbGxvd3MgYXRvbSBlZmZlY3RcbiAgLy8gaW5pdGlhbGl6YXRpb24gdG8gdGFrZSBwcmVjZWRlbmNlIG92ZXIgaW5pdGlhbGl6ZVN0YXRlIGFuZCBiZSBjb21wYXRpYmxlXG4gIC8vIHdpdGggU3RyaWN0TW9kZSBzZW1hbnRpY3MuXG5cbiAgc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcbiAgc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5jbGVhcigpO1xuICByZXR1cm4gc3RvcmVTdGF0ZTtcbn1cblxubGV0IG5leHRJRCA9IDA7XG5cbmZ1bmN0aW9uIFJlY29pbFJvb3RfSU5URVJOQUwoe1xuICBpbml0aWFsaXplU3RhdGVfREVQUkVDQVRFRCxcbiAgaW5pdGlhbGl6ZVN0YXRlLFxuICBzdG9yZV9JTlRFUk5BTDogc3RvcmVQcm9wLFxuICAvLyBGb3IgdXNlIHdpdGggUmVhY3QgXCJjb250ZXh0IGJyaWRnaW5nXCJcbiAgY2hpbGRyZW5cbn0pIHtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIC8vIEBmYi1vbmx5OiB1c2VFZmZlY3QoKCkgPT4ge1xuICAvLyBAZmItb25seTogaWYgKGdreCgncmVjb2lsX3VzYWdlX2xvZ2dpbmcnKSkge1xuICAvLyBAZmItb25seTogdHJ5IHtcbiAgLy8gQGZiLW9ubHk6IFJlY29pbFVzYWdlTG9nRmFsY29FdmVudC5sb2coKCkgPT4gKHtcbiAgLy8gQGZiLW9ubHk6IHR5cGU6IFJlY29pbHVzYWdlbG9nRXZlbnQuUkVDT0lMX1JPT1RfTU9VTlRFRCxcbiAgLy8gQGZiLW9ubHk6IHBhdGg6IFVSSS5nZXRSZXF1ZXN0VVJJKCkuZ2V0UGF0aCgpLFxuICAvLyBAZmItb25seTogfSkpO1xuICAvLyBAZmItb25seTogfSBjYXRjaCB7XG4gIC8vIEBmYi1vbmx5OiByZWNvdmVyYWJsZVZpb2xhdGlvbihcbiAgLy8gQGZiLW9ubHk6ICdFcnJvciB3aGVuIGxvZ2dpbmcgUmVjb2lsIFVzYWdlIGV2ZW50JyxcbiAgLy8gQGZiLW9ubHk6ICdyZWNvaWwnLFxuICAvLyBAZmItb25seTogKTtcbiAgLy8gQGZiLW9ubHk6IH1cbiAgLy8gQGZiLW9ubHk6IH1cbiAgLy8gQGZiLW9ubHk6IH0sIFtdKTtcbiAgbGV0IHN0b3JlU3RhdGVSZWY7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWNvbnN0XG5cbiAgY29uc3QgZ2V0R3JhcGggPSB2ZXJzaW9uID0+IHtcbiAgICBjb25zdCBncmFwaHMgPSBzdG9yZVN0YXRlUmVmLmN1cnJlbnQuZ3JhcGhzQnlWZXJzaW9uO1xuXG4gICAgaWYgKGdyYXBocy5oYXModmVyc2lvbikpIHtcbiAgICAgIHJldHVybiBSZWNvaWxfbnVsbHRocm93cyhncmFwaHMuZ2V0KHZlcnNpb24pKTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdHcmFwaCA9IGdyYXBoJDIoKTtcbiAgICBncmFwaHMuc2V0KHZlcnNpb24sIG5ld0dyYXBoKTtcbiAgICByZXR1cm4gbmV3R3JhcGg7XG4gIH07XG5cbiAgY29uc3Qgc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnMgPSAoY2FsbGJhY2ssIGtleSkgPT4ge1xuICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgLy8gR2xvYmFsIHRyYW5zYWN0aW9uIHN1YnNjcmlwdGlvbnNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zXG4gICAgICB9ID0gc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3QgaWQgPSBuZXh0SUQrKztcbiAgICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5zZXQoaWQsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbGVhc2U6ICgpID0+IHtcbiAgICAgICAgICB0cmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9kZS1zcGVjaWZpYyB0cmFuc2FjdGlvbiBzdWJzY3JpcHRpb25zOlxuICAgICAgY29uc3Qge1xuICAgICAgICBub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zXG4gICAgICB9ID0gc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpO1xuXG4gICAgICBpZiAoIW5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuaGFzKGtleSkpIHtcbiAgICAgICAgbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5zZXQoa2V5LCBuZXcgTWFwKCkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpZCA9IG5leHRJRCsrO1xuICAgICAgUmVjb2lsX251bGx0aHJvd3Mobm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5nZXQoa2V5KSkuc2V0KGlkLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWxlYXNlOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3VicyA9IG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuZ2V0KGtleSk7XG5cbiAgICAgICAgICBpZiAoc3Vicykge1xuICAgICAgICAgICAgc3Vicy5kZWxldGUoaWQpO1xuXG4gICAgICAgICAgICBpZiAoc3Vicy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgIG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBhZGRUcmFuc2FjdGlvbk1ldGFkYXRhID0gbWV0YWRhdGEgPT4ge1xuICAgIHN0YXJ0TmV4dFRyZWVJZk5lZWRlZChzdG9yZVJlZi5jdXJyZW50KTtcblxuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhtZXRhZGF0YSkpIHtcbiAgICAgIFJlY29pbF9udWxsdGhyb3dzKHN0b3JlUmVmLmN1cnJlbnQuZ2V0U3RhdGUoKS5uZXh0VHJlZSkudHJhbnNhY3Rpb25NZXRhZGF0YVtrXSA9IG1ldGFkYXRhW2tdO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByZXBsYWNlU3RhdGUgPSByZXBsYWNlciA9PiB7XG4gICAgc3RhcnROZXh0VHJlZUlmTmVlZGVkKHN0b3JlUmVmLmN1cnJlbnQpOyAvLyBVc2UgcmVwbGFjZXIgdG8gZ2V0IHRoZSBuZXh0IHN0YXRlOlxuXG4gICAgY29uc3QgbmV4dFRyZWUgPSBSZWNvaWxfbnVsbHRocm93cyhzdG9yZVN0YXRlUmVmLmN1cnJlbnQubmV4dFRyZWUpO1xuICAgIGxldCByZXBsYWNlZDtcblxuICAgIHRyeSB7XG4gICAgICBzdGF0ZVJlcGxhY2VySXNCZWluZ0V4ZWN1dGVkID0gdHJ1ZTtcbiAgICAgIHJlcGxhY2VkID0gcmVwbGFjZXIobmV4dFRyZWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzdGF0ZVJlcGxhY2VySXNCZWluZ0V4ZWN1dGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2VkID09PSBuZXh0VHJlZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3aW5kb3cuJHJlY29pbERlYnVnU3RhdGVzLnB1c2gocmVwbGFjZWQpOyAvLyBUT0RPIHRoaXMgc2hvdWxkbid0IGhhcHBlbiBoZXJlIGJlY2F1c2UgaXQncyBub3QgYmF0Y2hlZFxuICAgICAgfVxuICAgIH0gLy8gU2F2ZSBjaGFuZ2VzIHRvIG5leHRUcmVlIGFuZCBzY2hlZHVsZSBhIFJlYWN0IHVwZGF0ZTpcblxuXG4gICAgc3RvcmVTdGF0ZVJlZi5jdXJyZW50Lm5leHRUcmVlID0gcmVwbGFjZWQ7XG5cbiAgICBpZiAocmVhY3RNb2RlJDIoKS5lYXJseSkge1xuICAgICAgbm90aWZ5Q29tcG9uZW50cyhzdG9yZVJlZi5jdXJyZW50LCBzdG9yZVN0YXRlUmVmLmN1cnJlbnQsIHJlcGxhY2VkKTtcbiAgICB9XG5cbiAgICBSZWNvaWxfbnVsbHRocm93cyhub3RpZnlCYXRjaGVyT2ZDaGFuZ2UuY3VycmVudCkoKTtcbiAgfTtcblxuICBjb25zdCBub3RpZnlCYXRjaGVyT2ZDaGFuZ2UgPSB1c2VSZWYkMShudWxsKTtcbiAgY29uc3Qgc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlID0gdXNlQ2FsbGJhY2soeCA9PiB7XG4gICAgbm90aWZ5QmF0Y2hlck9mQ2hhbmdlLmN1cnJlbnQgPSB4O1xuICB9LCBbbm90aWZ5QmF0Y2hlck9mQ2hhbmdlXSk7XG4gIGNvbnN0IHN0b3JlUmVmID0gUmVjb2lsX3VzZVJlZkluaXRPbmNlKCgpID0+IHN0b3JlUHJvcCAhPT0gbnVsbCAmJiBzdG9yZVByb3AgIT09IHZvaWQgMCA/IHN0b3JlUHJvcCA6IHtcbiAgICBzdG9yZUlEOiBnZXROZXh0U3RvcmVJRCQyKCksXG4gICAgZ2V0U3RhdGU6ICgpID0+IHN0b3JlU3RhdGVSZWYuY3VycmVudCxcbiAgICByZXBsYWNlU3RhdGUsXG4gICAgZ2V0R3JhcGgsXG4gICAgc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnMsXG4gICAgYWRkVHJhbnNhY3Rpb25NZXRhZGF0YVxuICB9KTtcblxuICBpZiAoc3RvcmVQcm9wICE9IG51bGwpIHtcbiAgICBzdG9yZVJlZi5jdXJyZW50ID0gc3RvcmVQcm9wO1xuICB9XG5cbiAgc3RvcmVTdGF0ZVJlZiA9IFJlY29pbF91c2VSZWZJbml0T25jZSgoKSA9PiBpbml0aWFsaXplU3RhdGVfREVQUkVDQVRFRCAhPSBudWxsID8gaW5pdGlhbFN0b3JlU3RhdGVfREVQUkVDQVRFRChzdG9yZVJlZi5jdXJyZW50LCBpbml0aWFsaXplU3RhdGVfREVQUkVDQVRFRCkgOiBpbml0aWFsaXplU3RhdGUgIT0gbnVsbCA/IGluaXRpYWxTdG9yZVN0YXRlKGluaXRpYWxpemVTdGF0ZSkgOiBtYWtlRW1wdHlTdG9yZVN0YXRlJDIoKSk7XG4gIGNvbnN0IG11dGFibGVTb3VyY2UgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZU11dGFibGVTb3VyY2UkMSA9PT0gbnVsbCB8fCBjcmVhdGVNdXRhYmxlU291cmNlJDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWF0ZU11dGFibGVTb3VyY2UkMShzdG9yZVN0YXRlUmVmLCAoKSA9PiBzdG9yZVN0YXRlUmVmLmN1cnJlbnQuY3VycmVudFRyZWUudmVyc2lvbiksIFtzdG9yZVN0YXRlUmVmXSk7IC8vIENsZWFudXAgd2hlbiB0aGUgPFJlY29pbFJvb3Q+IGlzIHVubW91bnRlZFxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gUmVhY3QgaXMgZnJlZSB0byBjYWxsIGVmZmVjdCBjbGVhbnVwIGhhbmRsZXJzIGFuZCBlZmZlY3RzIGF0IHdpbGwsIHRoZVxuICAgIC8vIGRlcHMgYXJyYXkgaXMgb25seSBhbiBvcHRpbWl6YXRpb24uICBGb3IgZXhhbXBsZSwgUmVhY3Qgc3RyaWN0IG1vZGVcbiAgICAvLyB3aWxsIGV4ZWN1dGUgZWFjaCBlZmZlY3QgdHdpY2UgZm9yIHRlc3RpbmcuICBUaGVyZWZvcmUsIHdlIG5lZWQgc3ltbWV0cnlcbiAgICAvLyB0byByZS1pbml0aWFsaXplIGFsbCBrbm93biBhdG9tcyBhZnRlciB0aGV5IHdlcmUgY2xlYW5lZCB1cC5cbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG5cbiAgICBmb3IgKGNvbnN0IGF0b21LZXkgb2YgbmV3IFNldChzdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMpKSB7XG4gICAgICBpbml0aWFsaXplTm9kZSQyKHN0b3JlLCBhdG9tS2V5LCAnZ2V0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgYXRvbUtleSBvZiBzdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMpIHtcbiAgICAgICAgY2xlYW5VcE5vZGUkMihzdG9yZSwgYXRvbUtleSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3N0b3JlUmVmXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChBcHBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHN0b3JlUmVmXG4gIH0sIC8qI19fUFVSRV9fKi9yZWFjdC5jcmVhdGVFbGVtZW50KE11dGFibGVTb3VyY2VDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IG11dGFibGVTb3VyY2VcbiAgfSwgLyojX19QVVJFX18qL3JlYWN0LmNyZWF0ZUVsZW1lbnQoQmF0Y2hlciwge1xuICAgIHNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZTogc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlXG4gIH0pLCBjaGlsZHJlbikpO1xufVxuXG5mdW5jdGlvbiBSZWNvaWxSb290KHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBvdmVycmlkZSxcbiAgICAuLi5wcm9wc0V4Y2VwdE92ZXJyaWRlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgYW5jZXN0b3JTdG9yZVJlZiA9IHVzZVN0b3JlUmVmKCk7XG5cbiAgaWYgKG92ZXJyaWRlID09PSBmYWxzZSAmJiBhbmNlc3RvclN0b3JlUmVmLmN1cnJlbnQgIT09IGRlZmF1bHRTdG9yZSkge1xuICAgIC8vIElmIGFuY2VzdG9yU3RvcmVSZWYuY3VycmVudCAhPT0gZGVmYXVsdFN0b3JlLCBpdCBtZWFucyB0aGF0IHRoaXNcbiAgICAvLyBSZWNvaWxSb290IGlzIG5vdCBuZXN0ZWQgd2l0aGluIGFub3RoZXIuXG4gICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9yZWFjdC5jcmVhdGVFbGVtZW50KFJlY29pbFJvb3RfSU5URVJOQUwsIHByb3BzRXhjZXB0T3ZlcnJpZGUpO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxTdG9yZUlEKCkge1xuICByZXR1cm4gdXNlU3RvcmVSZWYoKS5jdXJyZW50LnN0b3JlSUQ7XG59XG5cbnZhciBSZWNvaWxfUmVjb2lsUm9vdCA9IHtcbiAgUmVjb2lsUm9vdCxcbiAgdXNlU3RvcmVSZWYsXG4gIHVzZVJlY29pbE11dGFibGVTb3VyY2UsXG4gIHVzZVJlY29pbFN0b3JlSUQsXG4gIG5vdGlmeUNvbXBvbmVudHNfRk9SX1RFU1RJTkc6IG5vdGlmeUNvbXBvbmVudHMsXG4gIHNlbmRFbmRPZkJhdGNoTm90aWZpY2F0aW9uc19GT1JfVEVTVElORzogc2VuZEVuZE9mQmF0Y2hOb3RpZmljYXRpb25zXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBzaGFsbG93QXJyYXlFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBSZWNvaWxfc2hhbGxvd0FycmF5RXF1YWwgPSBzaGFsbG93QXJyYXlFcXVhbDtcblxuY29uc3Qge1xuICB1c2VFZmZlY3Q6IHVzZUVmZmVjdCQxLFxuICB1c2VSZWY6IHVzZVJlZiQyXG59ID0gcmVhY3Q7XG5cbmZ1bmN0aW9uIHVzZVByZXZpb3VzKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZiQyKCk7XG4gIHVzZUVmZmVjdCQxKCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuXG52YXIgUmVjb2lsX3VzZVByZXZpb3VzID0gdXNlUHJldmlvdXM7XG5cbmNvbnN0IHtcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDFcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuY29uc3Qge1xuICBTVVNQRU5TRV9USU1FT1VUX01TOiBTVVNQRU5TRV9USU1FT1VUX01TJDFcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5jb25zdCB7XG4gIHVwZGF0ZVJldGFpbkNvdW50OiB1cGRhdGVSZXRhaW5Db3VudCQyXG59ID0gUmVjb2lsX1JldGVudGlvbjtcblxuY29uc3Qge1xuICBSZXRlbnRpb25ab25lOiBSZXRlbnRpb25ab25lJDNcbn0gPSBSZWNvaWxfUmV0ZW50aW9uWm9uZTtcblxuY29uc3Qge1xuICB1c2VFZmZlY3Q6IHVzZUVmZmVjdCQyLFxuICB1c2VSZWY6IHVzZVJlZiQzXG59ID0gcmVhY3Q7XG5cbmNvbnN0IHtcbiAgaXNTU1I6IGlzU1NSJDJcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XG5cblxuXG5cblxuIC8vIEkgZG9uJ3Qgc2VlIGEgd2F5IHRvIGF2b2lkIHRoZSBhbnkgdHlwZSBoZXJlIGJlY2F1c2Ugd2Ugd2FudCB0byBhY2NlcHQgcmVhZGFibGVcbi8vIGFuZCB3cml0YWJsZSB2YWx1ZXMgd2l0aCBhbnkgdHlwZSBwYXJhbWV0ZXIsIGJ1dCBub3JtYWxseSB3aXRoIHdyaXRhYmxlIG9uZXNcbi8vIFJlY29pbFN0YXRlPFNvbWVUPiBpcyBub3QgYSBzdWJ0eXBlIG9mIFJlY29pbFN0YXRlPG1peGVkPi5cblxuXG4vLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbmZ1bmN0aW9uIHVzZVJldGFpbih0b1JldGFpbikge1xuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9yZWFjdC1ob29rc1xuXG5cbiAgcmV0dXJuIHVzZVJldGFpbl9BQ1RVQUwodG9SZXRhaW4pO1xufVxuXG5mdW5jdGlvbiB1c2VSZXRhaW5fQUNUVUFMKHRvUmV0YWluKSB7XG4gIGNvbnN0IGFycmF5ID0gQXJyYXkuaXNBcnJheSh0b1JldGFpbikgPyB0b1JldGFpbiA6IFt0b1JldGFpbl07XG4gIGNvbnN0IHJldGFpbmFibGVzID0gYXJyYXkubWFwKGEgPT4gYSBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMyA/IGEgOiBhLmtleSk7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMSgpO1xuICB1c2VFZmZlY3QkMigoKSA9PiB7XG4gICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuXG4gICAgaWYgKHRpbWVvdXRJRC5jdXJyZW50ICYmICFpc1NTUiQyKSB7XG4gICAgICAvLyBBbHJlYWR5IHBlcmZvcm1lZCBhIHRlbXBvcmFyeSByZXRhaW4gb24gcmVuZGVyLCBzaW1wbHkgY2FuY2VsIHRoZSByZWxlYXNlXG4gICAgICAvLyBvZiB0aGF0IHRlbXBvcmFyeSByZXRhaW4uXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcbiAgICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCByIG9mIHJldGFpbmFibGVzKSB7XG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMihzdG9yZSwgciwgLTEpO1xuICAgICAgfVxuICAgIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvcmVhY3QtaG9va3MtZGVwc1xuICB9LCBbc3RvcmVSZWYsIC4uLnJldGFpbmFibGVzXSk7IC8vIFdlIHdhbnQgdG8gcmV0YWluIGlmIHRoZSBjb21wb25lbnQgc3VzcGVuZHMuIFRoaXMgaXMgdGVycmlibGUgYnV0IHRoZSBTdXNwZW5zZVxuICAvLyBBUEkgYWZmb3JkcyB1cyBubyBiZXR0ZXIgb3B0aW9uLiBJZiB3ZSBzdXNwZW5kIGFuZCBuZXZlciBjb21taXQgYWZ0ZXIgc29tZVxuICAvLyBzZWNvbmRzLCB0aGVuIHJlbGVhc2UuIFRoZSAnYWN0dWFsJyByZXRhaW4vcmVsZWFzZSBpbiB0aGUgZWZmZWN0IGFib3ZlXG4gIC8vIGNhbmNlbHMgdGhpcy5cblxuICBjb25zdCB0aW1lb3V0SUQgPSB1c2VSZWYkMygpO1xuICBjb25zdCBwcmV2aW91c1JldGFpbmFibGVzID0gUmVjb2lsX3VzZVByZXZpb3VzKHJldGFpbmFibGVzKTtcblxuICBpZiAoIWlzU1NSJDIgJiYgKHByZXZpb3VzUmV0YWluYWJsZXMgPT09IHVuZGVmaW5lZCB8fCAhUmVjb2lsX3NoYWxsb3dBcnJheUVxdWFsKHByZXZpb3VzUmV0YWluYWJsZXMsIHJldGFpbmFibGVzKSkpIHtcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG5cbiAgICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcbiAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIDEpO1xuICAgIH1cblxuICAgIGlmIChwcmV2aW91c1JldGFpbmFibGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IHIgb2YgcHJldmlvdXNSZXRhaW5hYmxlcykge1xuICAgICAgICB1cGRhdGVSZXRhaW5Db3VudCQyKHN0b3JlLCByLCAtMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRpbWVvdXRJRC5jdXJyZW50KSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcbiAgICB9XG5cbiAgICB0aW1lb3V0SUQuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgZm9yIChjb25zdCByIG9mIHJldGFpbmFibGVzKSB7XG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIC0xKTtcbiAgICAgIH1cbiAgICB9LCBTVVNQRU5TRV9USU1FT1VUX01TJDEpO1xuICB9XG59XG5cbnZhciBSZWNvaWxfdXNlUmV0YWluID0gdXNlUmV0YWluO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBUSElTIENPREUgSEFTIEJFRU4gQ09NTUVOVEVEIE9VVCBJTlRFTlRJT05BTExZXG4gKlxuICogVGhpcyB0ZWNobmlxdWUgb2YgZ2V0dGluZyB0aGUgY29tcG9uZW50IG5hbWUgaXMgaW1wZXJmZWN0LCBzaW5jZSBpdCBib3RoIG9ubHlcbiAqIHdvcmtzIGluIGEgbm9uLW1pbmlmaWVkIGNvZGUgYmFzZSwgYW5kIG1vcmUgaW1wb3J0YW50bHkgaW50cm9kdWNlcyBwZXJmb3JtYW5jZVxuICogcHJvYmxlbXMgc2luY2UgaXQgcmVsaWVzIGluIHRocm93aW5nIGVycm9ycyB3aGljaCBpcyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uLlxuICpcbiAqIEF0IHNvbWUgcG9pbnQgd2UgbWF5IHdhbnQgdG8gcmVldmFsdWF0ZSB0aGlzIHRlY2huaXF1ZSBoZW5jZSB3aHkgd2UgaGF2ZSBjb21tZW50ZWRcbiAqIHRoaXMgY29kZSBvdXQsIHJhdGhlciB0aGFuIGRlbGV0ZSBpdCBhbGwgdG9nZXRoZXIuXG4gKi9cbi8vIGNvbnN0IHt1c2VSZWZ9ID0gcmVxdWlyZSgncmVhY3QnKTtcbi8vIGNvbnN0IGdreCA9IHJlcXVpcmUoJ3JlY29pbC1zaGFyZWQvdXRpbC9SZWNvaWxfZ2t4Jyk7XG4vLyBjb25zdCBzdGFja1RyYWNlUGFyc2VyID0gcmVxdWlyZSgncmVjb2lsLXNoYXJlZC91dGlsL1JlY29pbF9zdGFja1RyYWNlUGFyc2VyJyk7XG5cbmZ1bmN0aW9uIHVzZUNvbXBvbmVudE5hbWUoKSB7XG4gIC8vIGNvbnN0IG5hbWVSZWYgPSB1c2VSZWYoKTtcbiAgLy8gaWYgKF9fREVWX18pIHtcbiAgLy8gICBpZiAoZ2t4KCdyZWNvaWxfaW5mZXJfY29tcG9uZW50X25hbWVzJykpIHtcbiAgLy8gICAgIGlmIChuYW1lUmVmLmN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAvLyAgICAgICAvLyBUaGVyZSBpcyBubyBibGVzc2VkIHdheSB0byBkZXRlcm1pbmUgdGhlIGNhbGxpbmcgUmVhY3QgY29tcG9uZW50IGZyb21cbiAgLy8gICAgICAgLy8gd2l0aGluIGEgaG9vay4gVGhpcyBoYWNrIHVzZXMgdGhlIGZhY3QgdGhhdCBob29rcyBtdXN0IHN0YXJ0IHdpdGggJ3VzZSdcbiAgLy8gICAgICAgLy8gYW5kIHRoYXQgaG9va3MgYXJlIGVpdGhlciBjYWxsZWQgYnkgUmVhY3QgQ29tcG9uZW50cyBvciBvdGhlciBob29rcy4gSXRcbiAgLy8gICAgICAgLy8gZm9sbG93cyB0aGVyZWZvcmUsIHRoYXQgdG8gZmluZCB0aGUgY2FsbGluZyBjb21wb25lbnQsIHlvdSBzaW1wbHkgbmVlZFxuICAvLyAgICAgICAvLyB0byBsb29rIGRvd24gdGhlIHN0YWNrIGFuZCBmaW5kIHRoZSBmaXJzdCBmdW5jdGlvbiB3aGljaCBkb2Vzbid0IHN0YXJ0XG4gIC8vICAgICAgIC8vIHdpdGggJ3VzZScuIFdlIGFyZSBvbmx5IGVuYWJsaW5nIHRoaXMgaW4gZGV2IGZvciBub3csIHNpbmNlIG9uY2UgdGhlXG4gIC8vICAgICAgIC8vIGNvZGViYXNlIGlzIG1pbmlmaWVkLCB0aGUgbmFtaW5nIGFzc3VtcHRpb25zIG5vIGxvbmdlciBob2xkIHRydWUuXG4gIC8vICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvbm8tbmV3LWVycm9yXG4gIC8vICAgICAgIGNvbnN0IGZyYW1lcyA9IHN0YWNrVHJhY2VQYXJzZXIobmV3IEVycm9yKCkuc3RhY2spO1xuICAvLyAgICAgICBmb3IgKGNvbnN0IHttZXRob2ROYW1lfSBvZiBmcmFtZXMpIHtcbiAgLy8gICAgICAgICAvLyBJIG9ic2VydmVkIGNhc2VzIHdoZXJlIHRoZSBmcmFtZSB3YXMgb2YgdGhlIGZvcm0gJ09iamVjdC51c2VYWFgnXG4gIC8vICAgICAgICAgLy8gaGVuY2Ugd2h5IEknbSBzZWFyY2hpbmcgZm9yIGhvb2tzIGZvbGxvd2luZyBhIHdvcmQgYm91bmRhcnlcbiAgLy8gICAgICAgICBpZiAoIW1ldGhvZE5hbWUubWF0Y2goL1xcYnVzZVteXFxiXSskLykpIHtcbiAgLy8gICAgICAgICAgIHJldHVybiAobmFtZVJlZi5jdXJyZW50ID0gbWV0aG9kTmFtZSk7XG4gIC8vICAgICAgICAgfVxuICAvLyAgICAgICB9XG4gIC8vICAgICAgIG5hbWVSZWYuY3VycmVudCA9IG51bGw7XG4gIC8vICAgICB9XG4gIC8vICAgICByZXR1cm4gbmFtZVJlZi5jdXJyZW50ID8/ICc8dW5hYmxlIHRvIGRldGVybWluZSBjb21wb25lbnQgbmFtZT4nO1xuICAvLyAgIH1cbiAgLy8gfVxuICAvLyBAZmItb25seTogcmV0dXJuIFwiPGNvbXBvbmVudCBuYW1lIG9ubHkgYXZhaWxhYmxlIHdoZW4gYm90aCBpbiBkZXYgbW9kZSBhbmQgd2hlbiBwYXNzaW5nIEdLICdyZWNvaWxfaW5mZXJfY29tcG9uZW50X25hbWVzJz5cIjtcbiAgcmV0dXJuICc8Y29tcG9uZW50IG5hbWUgbm90IGF2YWlsYWJsZT4nOyAvLyBAb3NzLW9ubHlcbn1cblxudmFyIFJlY29pbF91c2VDb21wb25lbnROYW1lID0gdXNlQ29tcG9uZW50TmFtZTtcblxuY29uc3Qge1xuICBiYXRjaFVwZGF0ZXM6IGJhdGNoVXBkYXRlcyQyXG59ID0gUmVjb2lsX0JhdGNoaW5nO1xuXG5jb25zdCB7XG4gIERFRkFVTFRfVkFMVUU6IERFRkFVTFRfVkFMVUUkMlxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDMsXG4gIHVzZU11dGFibGVTb3VyY2U6IHVzZU11dGFibGVTb3VyY2UkMSxcbiAgdXNlU3luY0V4dGVybmFsU3RvcmU6IHVzZVN5bmNFeHRlcm5hbFN0b3JlJDFcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xuXG5jb25zdCB7XG4gIHVzZVJlY29pbE11dGFibGVTb3VyY2U6IHVzZVJlY29pbE11dGFibGVTb3VyY2UkMSxcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDJcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuY29uc3Qge1xuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWUkMTtcblxuY29uc3Qge1xuICBBYnN0cmFjdFJlY29pbFZhbHVlOiBBYnN0cmFjdFJlY29pbFZhbHVlJDMsXG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZTogZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIsXG4gIHNldFJlY29pbFZhbHVlOiBzZXRSZWNvaWxWYWx1ZSQyLFxuICBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlOiBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlJDIsXG4gIHN1YnNjcmliZVRvUmVjb2lsVmFsdWU6IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuXG5cbmNvbnN0IHtcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrJDEsXG4gIHVzZUVmZmVjdDogdXNlRWZmZWN0JDMsXG4gIHVzZU1lbW86IHVzZU1lbW8kMSxcbiAgdXNlUmVmOiB1c2VSZWYkNCxcbiAgdXNlU3RhdGU6IHVzZVN0YXRlJDFcbn0gPSByZWFjdDtcblxuY29uc3Qge1xuICBzZXRCeUFkZGluZ1RvU2V0OiBzZXRCeUFkZGluZ1RvU2V0JDJcbn0gPSBSZWNvaWxfQ29weU9uV3JpdGU7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGhhbmRsZUxvYWRhYmxlKGxvYWRhYmxlLCByZWNvaWxWYWx1ZSwgc3RvcmVSZWYpIHtcbiAgLy8gV2UgY2FuJ3QganVzdCB0aHJvdyB0aGUgcHJvbWlzZSB3ZSBhcmUgd2FpdGluZyBvbiB0byBTdXNwZW5zZS4gIElmIHRoZVxuICAvLyB1cHN0cmVhbSBkZXBlbmRlbmNpZXMgY2hhbmdlIGl0IG1heSBwcm9kdWNlIGEgc3RhdGUgaW4gd2hpY2ggdGhlIGNvbXBvbmVudFxuICAvLyBjYW4gcmVuZGVyLCBidXQgaXQgd291bGQgc3RpbGwgYmUgc3VzcGVuZGVkIG9uIGEgUHJvbWlzZSB0aGF0IG1heSBuZXZlciByZXNvbHZlLlxuICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScpIHtcbiAgICByZXR1cm4gbG9hZGFibGUuY29udGVudHM7XG4gIH0gZWxzZSBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHN0b3JlUmVmLmN1cnJlbnQuZ2V0U3RhdGUoKS5zdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMuYWRkKHJlc29sdmUpO1xuICAgIH0pOyAvLyAkRmxvd0V4cGVjdGVkRXJyb3IgRmxvdyhwcm9wLW1pc3NpbmcpIGZvciBpbnRlZ3JhdGluZyB3aXRoIHRvb2xzIHRoYXQgaW5zcGVjdCB0aHJvd24gcHJvbWlzZXMgQGZiLW9ubHlcbiAgICAvLyBAZmItb25seTogcHJvbWlzZS5kaXNwbGF5TmFtZSA9IGBSZWNvaWwgU3RhdGU6ICR7cmVjb2lsVmFsdWUua2V5fWA7XG5cbiAgICB0aHJvdyBwcm9taXNlO1xuICB9IGVsc2UgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzRXJyb3InKSB7XG4gICAgdGhyb3cgbG9hZGFibGUuY29udGVudHM7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycihgSW52YWxpZCB2YWx1ZSBvZiBsb2FkYWJsZSBhdG9tIFwiJHtyZWNvaWxWYWx1ZS5rZXl9XCJgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlLCBob29rTmFtZSkge1xuICBpZiAoIWlzUmVjb2lsVmFsdWUkMihyZWNvaWxWYWx1ZSkpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKGBJbnZhbGlkIGFyZ3VtZW50IHRvICR7aG9va05hbWV9OiBleHBlY3RlZCBhbiBhdG9tIG9yIHNlbGVjdG9yIGJ1dCBnb3QgJHtTdHJpbmcocmVjb2lsVmFsdWUpfWApO1xuICB9XG59XG5cbi8qKlxuICogVmFyaW91cyB0aGluZ3MgYXJlIGJyb2tlbiB3aXRoIHVzZVJlY29pbEludGVyZmFjZSwgcGFydGljdWxhcmx5IGNvbmN1cnJlbnRcbiAqIG1vZGUsIFJlYWN0IHN0cmljdCBtb2RlLCBhbmQgbWVtb3J5IG1hbmFnZW1lbnQuIFRoZXkgd2lsbCBub3QgYmUgZml4ZWQuXG4gKiAqL1xuZnVuY3Rpb24gdXNlUmVjb2lsSW50ZXJmYWNlX0RFUFJFQ0FURUQoKSB7XG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBSZWNvaWxfdXNlQ29tcG9uZW50TmFtZSgpO1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgY29uc3QgWywgZm9yY2VVcGRhdGVdID0gdXNlU3RhdGUkMShbXSk7XG4gIGNvbnN0IHJlY29pbFZhbHVlc1VzZWQgPSB1c2VSZWYkNChuZXcgU2V0KCkpO1xuICByZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQgPSBuZXcgU2V0KCk7IC8vIFRyYWNrIHRoZSBSZWNvaWxWYWx1ZXMgdXNlZCBqdXN0IGR1cmluZyB0aGlzIHJlbmRlclxuXG4gIGNvbnN0IHByZXZpb3VzU3Vic2NyaXB0aW9ucyA9IHVzZVJlZiQ0KG5ldyBTZXQoKSk7XG4gIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB1c2VSZWYkNChuZXcgTWFwKCkpO1xuICBjb25zdCB1bnN1YnNjcmliZUZyb20gPSB1c2VDYWxsYmFjayQxKGtleSA9PiB7XG4gICAgY29uc3Qgc3ViID0gc3Vic2NyaXB0aW9ucy5jdXJyZW50LmdldChrZXkpO1xuXG4gICAgaWYgKHN1Yikge1xuICAgICAgc3ViLnJlbGVhc2UoKTtcbiAgICAgIHN1YnNjcmlwdGlvbnMuY3VycmVudC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH0sIFtzdWJzY3JpcHRpb25zXSk7XG4gIGNvbnN0IHVwZGF0ZVN0YXRlID0gdXNlQ2FsbGJhY2skMSgoX3N0YXRlLCBrZXkpID0+IHtcbiAgICBpZiAoc3Vic2NyaXB0aW9ucy5jdXJyZW50LmhhcyhrZXkpKSB7XG4gICAgICBmb3JjZVVwZGF0ZShbXSk7XG4gICAgfVxuICB9LCBbXSk7IC8vIEVmZmVjdCB0byBhZGQvcmVtb3ZlIHN1YnNjcmlwdGlvbnMgYXMgbm9kZXMgYXJlIHVzZWRcblxuICB1c2VFZmZlY3QkMygoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIFJlY29pbF9kaWZmZXJlbmNlU2V0cyhyZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQsIHByZXZpb3VzU3Vic2NyaXB0aW9ucy5jdXJyZW50KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9ucy5jdXJyZW50LmhhcyhrZXkpKSB7XG4gICAgICAgIFJlY29pbF9leHBlY3RhdGlvblZpb2xhdGlvbihgRG91YmxlIHN1YnNjcmlwdGlvbiB0byBSZWNvaWxWYWx1ZSBcIiR7a2V5fVwiYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3ViID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlLCBuZXcgQWJzdHJhY3RSZWNvaWxWYWx1ZSQzKGtleSksIHN0YXRlID0+IHVwZGF0ZVN0YXRlKHN0YXRlLCBrZXkpLCBjb21wb25lbnROYW1lKTtcbiAgICAgIHN1YnNjcmlwdGlvbnMuY3VycmVudC5zZXQoa2V5LCBzdWIpO1xuICAgICAgLyoqXG4gICAgICAgKiBTaW5jZSB3ZSdyZSBzdWJzY3JpYmluZyBpbiBhbiBlZmZlY3Qgd2UgbmVlZCB0byB1cGRhdGUgdG8gdGhlIGxhdGVzdFxuICAgICAgICogdmFsdWUgb2YgdGhlIGF0b20gc2luY2UgaXQgbWF5IGhhdmUgY2hhbmdlZCBzaW5jZSB3ZSByZW5kZXJlZC4gV2UgY2FuXG4gICAgICAgKiBnbyBhaGVhZCBhbmQgZG8gdGhhdCBub3csIHVubGVzcyB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgYmF0Y2ggLS1cbiAgICAgICAqIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGRvIGl0IGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLCBkdWUgdG8gdGhlXG4gICAgICAgKiBmb2xsb3dpbmcgZWRnZSBjYXNlOiBTdXBwb3NlIGFuIGF0b20gaXMgdXBkYXRlZCBpbiBhbm90aGVyIHVzZUVmZmVjdFxuICAgICAgICogb2YgdGhpcyBzYW1lIGNvbXBvbmVudC4gVGhlbiB0aGUgZm9sbG93aW5nIHNlcXVlbmNlIG9mIGV2ZW50cyBvY2N1cjpcbiAgICAgICAqIDEuIEF0b20gaXMgdXBkYXRlZCBhbmQgc3VicyBmaXJlZCAoYnV0IHdlIG1heSBub3QgYmUgc3Vic2NyaWJlZFxuICAgICAgICogICAgeWV0IGRlcGVuZGluZyBvbiBvcmRlciBvZiBlZmZlY3RzLCBzbyB3ZSBtaXNzIHRoaXMpIFVwZGF0ZWQgdmFsdWVcbiAgICAgICAqICAgIGlzIG5vdyBpbiBuZXh0VHJlZSwgYnV0IG5vdCBjdXJyZW50VHJlZS5cbiAgICAgICAqIDIuIFRoaXMgZWZmZWN0IGhhcHBlbnMuIFdlIHN1YnNjcmliZSBhbmQgdXBkYXRlLlxuICAgICAgICogMy4gRnJvbSB0aGUgdXBkYXRlIHdlIHJlLXJlbmRlciBhbmQgcmVhZCBjdXJyZW50VHJlZSwgd2l0aCBvbGQgdmFsdWUuXG4gICAgICAgKiA0LiBCYXRjaGVyJ3MgZWZmZWN0IHNldHMgY3VycmVudFRyZWUgdG8gbmV4dFRyZWUuXG4gICAgICAgKiBJbiB0aGlzIHNlcXVlbmNlIHdlIG1pc3MgdGhlIHVwZGF0ZS4gVG8gYXZvaWQgdGhhdCwgYWRkIHRoZSB1cGRhdGVcbiAgICAgICAqIHRvIHF1ZXVlZENvbXBvbmVudENhbGxiYWNrIGlmIGEgYmF0Y2ggaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICAgKi9cbiAgICAgIC8vIEZJWE1FIGRlbGV0ZSBxdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRCB3aGVuIGRlbGV0aW5nIHVzZUludGVyZmFjZS5cblxuICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICBpZiAoc3RhdGUubmV4dFRyZWUpIHtcbiAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5xdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRC5wdXNoKCgpID0+IHtcbiAgICAgICAgICB1cGRhdGVTdGF0ZShzdG9yZS5nZXRTdGF0ZSgpLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHN0b3JlLmdldFN0YXRlKCksIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgUmVjb2lsX2RpZmZlcmVuY2VTZXRzKHByZXZpb3VzU3Vic2NyaXB0aW9ucy5jdXJyZW50LCByZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHVuc3Vic2NyaWJlRnJvbShrZXkpO1xuICAgIH0pO1xuICAgIHByZXZpb3VzU3Vic2NyaXB0aW9ucy5jdXJyZW50ID0gcmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50O1xuICB9KTsgLy8gRWZmZWN0IHRvIHVuc3Vic2NyaWJlIGZyb20gYWxsIHdoZW4gdW5tb3VudGluZ1xuXG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50U3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnMuY3VycmVudDsgLy8gUmVzdG9yZSBzdWJzY3JpcHRpb25zIHRoYXQgd2VyZSBjbGVhcmVkIGR1ZSB0byBTdHJpY3RNb2RlIHJ1bm5pbmcgdGhpcyBlZmZlY3QgdHdpY2VcblxuICAgIFJlY29pbF9kaWZmZXJlbmNlU2V0cyhyZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQsIG5ldyBTZXQoY3VycmVudFN1YnNjcmlwdGlvbnMua2V5cygpKSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3Qgc3ViID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlUmVmLmN1cnJlbnQsIG5ldyBBYnN0cmFjdFJlY29pbFZhbHVlJDMoa2V5KSwgc3RhdGUgPT4gdXBkYXRlU3RhdGUoc3RhdGUsIGtleSksIGNvbXBvbmVudE5hbWUpO1xuICAgICAgY3VycmVudFN1YnNjcmlwdGlvbnMuc2V0KGtleSwgc3ViKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gY3VycmVudFN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoXywga2V5KSA9PiB1bnN1YnNjcmliZUZyb20oa2V5KSk7XG4gIH0sIFtjb21wb25lbnROYW1lLCBzdG9yZVJlZiwgdW5zdWJzY3JpYmVGcm9tLCB1cGRhdGVTdGF0ZV0pO1xuICByZXR1cm4gdXNlTWVtbyQxKCgpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG4gICAgZnVuY3Rpb24gdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVNldFJlY29pbFN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdWYWx1ZU9yVXBkYXRlciA9PiB7XG4gICAgICAgIHNldFJlY29pbFZhbHVlJDIoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsU3RhdGUsIG5ld1ZhbHVlT3JVcGRhdGVyKTtcbiAgICAgIH07XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG5cblxuICAgIGZ1bmN0aW9uIHVzZVJlc2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlc2V0UmVjb2lsU3RhdGUnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgpID0+IHNldFJlY29pbFZhbHVlJDIoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsU3RhdGUsIERFRkFVTFRfVkFMVUUkMik7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG5cblxuICAgIGZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGUocmVjb2lsVmFsdWUpIHtcbiAgICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlLCAndXNlUmVjb2lsVmFsdWVMb2FkYWJsZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlY29pbFZhbHVlc1VzZWQuY3VycmVudC5oYXMocmVjb2lsVmFsdWUua2V5KSkge1xuICAgICAgICByZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQgPSBzZXRCeUFkZGluZ1RvU2V0JDIocmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50LCByZWNvaWxWYWx1ZS5rZXkpO1xuICAgICAgfSAvLyBUT0RPIFJlc3RvcmUgb3B0aW1pemF0aW9uIHRvIG1lbW9pemUgbG9va3VwXG5cblxuICAgICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlUmVmLmN1cnJlbnQuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMihzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxWYWx1ZSwgcmVhY3RNb2RlJDMoKS5lYXJseSA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcblxuXG4gICAgZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSwgJ3VzZVJlY29pbFZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvYWRhYmxlID0gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZShyZWNvaWxWYWx1ZSk7XG4gICAgICByZXR1cm4gaGFuZGxlTG9hZGFibGUobG9hZGFibGUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZik7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG5cblxuICAgIGZ1bmN0aW9uIHVzZVJlY29pbFN0YXRlKHJlY29pbFN0YXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZWNvaWxTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3VzZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcblxuXG4gICAgZnVuY3Rpb24gdXNlUmVjb2lsU3RhdGVMb2FkYWJsZShyZWNvaWxTdGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlUmVjb2lsU3RhdGVMb2FkYWJsZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3VzZVJlY29pbFZhbHVlTG9hZGFibGUocmVjb2lsU3RhdGUpLCB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSldO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBnZXRSZWNvaWxWYWx1ZTogdXNlUmVjb2lsVmFsdWUsXG4gICAgICBnZXRSZWNvaWxWYWx1ZUxvYWRhYmxlOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlLFxuICAgICAgZ2V0UmVjb2lsU3RhdGU6IHVzZVJlY29pbFN0YXRlLFxuICAgICAgZ2V0UmVjb2lsU3RhdGVMb2FkYWJsZTogdXNlUmVjb2lsU3RhdGVMb2FkYWJsZSxcbiAgICAgIGdldFNldFJlY29pbFN0YXRlOiB1c2VTZXRSZWNvaWxTdGF0ZSxcbiAgICAgIGdldFJlc2V0UmVjb2lsU3RhdGU6IHVzZVJlc2V0UmVjb2lsU3RhdGVcbiAgICB9O1xuICB9LCBbcmVjb2lsVmFsdWVzVXNlZCwgc3RvcmVSZWZdKTtcbn1cblxuY29uc3QgcmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORyA9IHtcbiAgY3VycmVudDogMFxufTtcblxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9TWU5DX0VYVEVSTkFMX1NUT1JFKHJlY29pbFZhbHVlKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICBjb25zdCBjb21wb25lbnROYW1lID0gUmVjb2lsX3VzZUNvbXBvbmVudE5hbWUoKTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSB1c2VDYWxsYmFjayQxKCgpID0+IHtcbiAgICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWUyO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORy5jdXJyZW50Kys7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHRyZWVTdGF0ZSA9IHJlYWN0TW9kZSQzKCkuZWFybHkgPyAoX3N0b3JlU3RhdGUkbmV4dFRyZWUyID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWUyICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZTIgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcbiAgICBjb25zdCBsb2FkYWJsZSA9IGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyKHN0b3JlLCByZWNvaWxWYWx1ZSwgdHJlZVN0YXRlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9hZGFibGUsXG4gICAgICBrZXk6IHJlY29pbFZhbHVlLmtleVxuICAgIH07XG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsVmFsdWVdKTsgLy8gTWVtb2l6ZSB0aGUgc3RhdGUgdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmVyZW5kZXJzXG5cbiAgY29uc3QgbWVtb2l6ZVByZXZpb3VzU25hcHNob3QgPSB1c2VDYWxsYmFjayQxKGdldFN0YXRlID0+IHtcbiAgICBsZXQgcHJldlN0YXRlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB2YXIgX3ByZXZTdGF0ZSwgX3ByZXZTdGF0ZTI7XG5cbiAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IGdldFN0YXRlKCk7XG5cbiAgICAgIGlmICgoX3ByZXZTdGF0ZSA9IHByZXZTdGF0ZSkgIT09IG51bGwgJiYgX3ByZXZTdGF0ZSAhPT0gdm9pZCAwICYmIF9wcmV2U3RhdGUubG9hZGFibGUuaXMobmV4dFN0YXRlLmxvYWRhYmxlKSAmJiAoKF9wcmV2U3RhdGUyID0gcHJldlN0YXRlKSA9PT0gbnVsbCB8fCBfcHJldlN0YXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ByZXZTdGF0ZTIua2V5KSA9PT0gbmV4dFN0YXRlLmtleSkge1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgfVxuXG4gICAgICBwcmV2U3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICByZXR1cm4gbmV4dFN0YXRlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgZ2V0TWVtb2l6ZWRTbmFwc2hvdCA9IHVzZU1lbW8kMSgoKSA9PiBtZW1vaXplUHJldmlvdXNTbmFwc2hvdChnZXRTbmFwc2hvdCksIFtnZXRTbmFwc2hvdCwgbWVtb2l6ZVByZXZpb3VzU25hcHNob3RdKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gdXNlQ2FsbGJhY2skMShub3RpZnkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmUsIHJlY29pbFZhbHVlLCBub3RpZnksIGNvbXBvbmVudE5hbWUpO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucmVsZWFzZTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZSwgY29tcG9uZW50TmFtZV0pO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUkMShzdWJzY3JpYmUsIGdldE1lbW9pemVkU25hcHNob3QsIC8vIGdldFNuYXBzaG90KClcbiAgZ2V0TWVtb2l6ZWRTbmFwc2hvdCAvLyBnZXRTZXJ2ZXJTbmFwc2hvdCgpIGZvciBTU1Igc3VwcG9ydFxuICApLmxvYWRhYmxlO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX01VVEFCTEVfU09VUkNFKHJlY29pbFZhbHVlKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICBjb25zdCBnZXRMb2FkYWJsZSA9IHVzZUNhbGxiYWNrJDEoKCkgPT4ge1xuICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTM7XG5cbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgdHJlZVN0YXRlID0gcmVhY3RNb2RlJDMoKS5lYXJseSA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZTMgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZTMgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJG5leHRUcmVlMyA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMihzdG9yZSwgcmVjb2lsVmFsdWUsIHRyZWVTdGF0ZSk7XG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsVmFsdWVdKTtcbiAgY29uc3QgZ2V0TG9hZGFibGVXaXRoVGVzdGluZyA9IHVzZUNhbGxiYWNrJDEoKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkcuY3VycmVudCsrO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRMb2FkYWJsZSgpO1xuICB9LCBbZ2V0TG9hZGFibGVdKTtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHVzZUNhbGxiYWNrJDEoKF9zdG9yZVN0YXRlLCBub3RpZnkpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlLCByZWNvaWxWYWx1ZSwgKCkgPT4ge1xuICAgICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snKSkge1xuICAgICAgICByZXR1cm4gbm90aWZ5KCk7XG4gICAgICB9IC8vIE9ubHkgcmUtcmVuZGVyIGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZC5cbiAgICAgIC8vIFRoaXMgd2lsbCBldmFsdWF0ZSB0aGUgYXRvbS9zZWxlY3RvciBub3cgYXMgd2VsbCBhcyB3aGVuIHRoZVxuICAgICAgLy8gY29tcG9uZW50IHJlbmRlcnMsIGJ1dCB0aGF0IG1heSBoZWxwIHdpdGggcHJlZmV0Y2hpbmcuXG5cblxuICAgICAgY29uc3QgbmV3TG9hZGFibGUgPSBnZXRMb2FkYWJsZSgpO1xuXG4gICAgICBpZiAoIXByZXZMb2FkYWJsZVJlZi5jdXJyZW50LmlzKG5ld0xvYWRhYmxlKSkge1xuICAgICAgICBub3RpZnkoKTtcbiAgICAgIH0gLy8gSWYgdGhlIGNvbXBvbmVudCBpcyBzdXNwZW5kZWQgdGhlbiB0aGUgZWZmZWN0IHNldHRpbmcgcHJldkxvYWRhYmxlUmVmXG4gICAgICAvLyB3aWxsIG5vdCBydW4uICBTbywgc2V0IHRoZSBwcmV2aW91cyB2YWx1ZSBoZXJlIHdoZW4gaXRzIHN1YnNjcmlwdGlvblxuICAgICAgLy8gaXMgZmlyZWQgdG8gd2FrZSBpdCB1cC4gIFdlIGNhbid0IGp1c3QgcmVseSBvbiB0aGlzLCB0aG91Z2gsIGJlY2F1c2VcbiAgICAgIC8vIHRoaXMgb25seSBleGVjdXRlcyB3aGVuIGFuIGF0b20vc2VsZWN0b3IgaXMgZGlydHkgYW5kIHRoZSBhdG9tL3NlbGVjdG9yXG4gICAgICAvLyBwYXNzZWQgdG8gdGhlIGhvb2sgY2FuIGR5bmFtaWNhbGx5IGNoYW5nZS5cblxuXG4gICAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IG5ld0xvYWRhYmxlO1xuICAgIH0sIGNvbXBvbmVudE5hbWUpO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucmVsZWFzZTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZSwgY29tcG9uZW50TmFtZSwgZ2V0TG9hZGFibGVdKTtcbiAgY29uc3Qgc291cmNlID0gdXNlUmVjb2lsTXV0YWJsZVNvdXJjZSQxKCk7XG5cbiAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignUmVjb2lsIGhvb2tzIG11c3QgYmUgdXNlZCBpbiBjb21wb25lbnRzIGNvbnRhaW5lZCB3aXRoaW4gYSA8UmVjb2lsUm9vdD4gY29tcG9uZW50LicpO1xuICB9XG5cbiAgY29uc3QgbG9hZGFibGUgPSB1c2VNdXRhYmxlU291cmNlJDEoc291cmNlLCBnZXRMb2FkYWJsZVdpdGhUZXN0aW5nLCBzdWJzY3JpYmUpO1xuICBjb25zdCBwcmV2TG9hZGFibGVSZWYgPSB1c2VSZWYkNChsb2FkYWJsZSk7XG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcbiAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IGxvYWRhYmxlO1xuICB9KTtcbiAgcmV0dXJuIGxvYWRhYmxlO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVChyZWNvaWxWYWx1ZSkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7IC8vIEFjY2Vzc29ycyB0byBnZXQgdGhlIGN1cnJlbnQgc3RhdGVcblxuICBjb25zdCBnZXRMb2FkYWJsZSA9IHVzZUNhbGxiYWNrJDEoKCkgPT4ge1xuICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTQ7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HLmN1cnJlbnQrKztcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgdHJlZVN0YXRlID0gcmVhY3RNb2RlJDMoKS5lYXJseSA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZTQgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZTQgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJG5leHRUcmVlNCA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMihzdG9yZSwgcmVjb2lsVmFsdWUsIHRyZWVTdGF0ZSk7XG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsVmFsdWVdKTtcbiAgY29uc3QgZ2V0U3RhdGUgPSB1c2VDYWxsYmFjayQxKCgpID0+ICh7XG4gICAgbG9hZGFibGU6IGdldExvYWRhYmxlKCksXG4gICAga2V5OiByZWNvaWxWYWx1ZS5rZXlcbiAgfSksIFtnZXRMb2FkYWJsZSwgcmVjb2lsVmFsdWUua2V5XSk7IC8vIE1lbW9pemUgc3RhdGUgc25hcHNob3RzXG5cbiAgY29uc3QgdXBkYXRlU3RhdGUgPSB1c2VDYWxsYmFjayQxKHByZXZTdGF0ZSA9PiB7XG4gICAgY29uc3QgbmV4dFN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4gcHJldlN0YXRlLmxvYWRhYmxlLmlzKG5leHRTdGF0ZS5sb2FkYWJsZSkgJiYgcHJldlN0YXRlLmtleSA9PT0gbmV4dFN0YXRlLmtleSA/IHByZXZTdGF0ZSA6IG5leHRTdGF0ZTtcbiAgfSwgW2dldFN0YXRlXSk7IC8vIFN1YnNjcmliZSB0byBSZWNvaWwgc3RhdGUgY2hhbmdlc1xuXG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsVmFsdWUsIF9zdGF0ZSA9PiB7XG4gICAgICBzZXRTdGF0ZSh1cGRhdGVTdGF0ZSk7XG4gICAgfSwgY29tcG9uZW50TmFtZSk7IC8vIFVwZGF0ZSBzdGF0ZSBpbiBjYXNlIHdlIGFyZSB1c2luZyBhIGRpZmZlcmVudCBrZXlcblxuICAgIHNldFN0YXRlKHVwZGF0ZVN0YXRlKTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uLnJlbGVhc2U7XG4gIH0sIFtjb21wb25lbnROYW1lLCByZWNvaWxWYWx1ZSwgc3RvcmVSZWYsIHVwZGF0ZVN0YXRlXSk7IC8vIEdldCB0aGUgY3VycmVudCBzdGF0ZVxuXG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUkMShnZXRTdGF0ZSk7IC8vIElmIHdlIGNoYW5nZWQga2V5cywgdGhlbiByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgbmV3IGtleS5cbiAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgaW4gY2FzZSB0aGUgb2xkIGtleSB3b3VsZCBjYXVzZSB0aGUgY29tcG9uZW50IHRvIHN1c3BlbmQuXG4gIC8vIFdlIGRvbid0IGhhdmUgdG8gc2V0IHRoZSBuZXcgc3RhdGUgaGVyZSBzaW5jZSB0aGUgc3Vic2NyaWJpbmcgZWZmZWN0IGFib3ZlXG4gIC8vIHdpbGwgZG8gdGhhdC5cblxuICByZXR1cm4gc3RhdGUua2V5ICE9PSByZWNvaWxWYWx1ZS5rZXkgPyBnZXRTdGF0ZSgpLmxvYWRhYmxlIDogc3RhdGUubG9hZGFibGU7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfTEVHQUNZKHJlY29pbFZhbHVlKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICBjb25zdCBbLCBmb3JjZVVwZGF0ZV0gPSB1c2VTdGF0ZSQxKFtdKTtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7XG4gIGNvbnN0IGdldExvYWRhYmxlID0gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XG4gICAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlNTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkcuY3VycmVudCsrO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0cmVlU3RhdGUgPSByZWFjdE1vZGUkMygpLmVhcmx5ID8gKF9zdG9yZVN0YXRlJG5leHRUcmVlNSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlNSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWU1IDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG4gICAgcmV0dXJuIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyKHN0b3JlLCByZWNvaWxWYWx1ZSwgdHJlZVN0YXRlKTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZV0pO1xuICBjb25zdCBsb2FkYWJsZSA9IGdldExvYWRhYmxlKCk7XG4gIGNvbnN0IHByZXZMb2FkYWJsZVJlZiA9IHVzZVJlZiQ0KGxvYWRhYmxlKTtcbiAgdXNlRWZmZWN0JDMoKCkgPT4ge1xuICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbG9hZGFibGU7XG4gIH0pO1xuICB1c2VFZmZlY3QkMygoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMShzdG9yZSwgcmVjb2lsVmFsdWUsIF9zdGF0ZSA9PiB7XG4gICAgICB2YXIgX3ByZXZMb2FkYWJsZVJlZiRjdXJyO1xuXG4gICAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycpKSB7XG4gICAgICAgIHJldHVybiBmb3JjZVVwZGF0ZShbXSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0xvYWRhYmxlID0gZ2V0TG9hZGFibGUoKTtcblxuICAgICAgaWYgKCEoKF9wcmV2TG9hZGFibGVSZWYkY3VyciA9IHByZXZMb2FkYWJsZVJlZi5jdXJyZW50KSAhPT0gbnVsbCAmJiBfcHJldkxvYWRhYmxlUmVmJGN1cnIgIT09IHZvaWQgMCAmJiBfcHJldkxvYWRhYmxlUmVmJGN1cnIuaXMobmV3TG9hZGFibGUpKSkge1xuICAgICAgICBmb3JjZVVwZGF0ZShuZXdMb2FkYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbmV3TG9hZGFibGU7XG4gICAgfSwgY29tcG9uZW50TmFtZSk7XG4gICAgLyoqXG4gICAgICogU2luY2Ugd2UncmUgc3Vic2NyaWJpbmcgaW4gYW4gZWZmZWN0IHdlIG5lZWQgdG8gdXBkYXRlIHRvIHRoZSBsYXRlc3RcbiAgICAgKiB2YWx1ZSBvZiB0aGUgYXRvbSBzaW5jZSBpdCBtYXkgaGF2ZSBjaGFuZ2VkIHNpbmNlIHdlIHJlbmRlcmVkLiBXZSBjYW5cbiAgICAgKiBnbyBhaGVhZCBhbmQgZG8gdGhhdCBub3csIHVubGVzcyB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgYmF0Y2ggLS1cbiAgICAgKiBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBkbyBpdCBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaCwgZHVlIHRvIHRoZVxuICAgICAqIGZvbGxvd2luZyBlZGdlIGNhc2U6IFN1cHBvc2UgYW4gYXRvbSBpcyB1cGRhdGVkIGluIGFub3RoZXIgdXNlRWZmZWN0XG4gICAgICogb2YgdGhpcyBzYW1lIGNvbXBvbmVudC4gVGhlbiB0aGUgZm9sbG93aW5nIHNlcXVlbmNlIG9mIGV2ZW50cyBvY2N1cjpcbiAgICAgKiAxLiBBdG9tIGlzIHVwZGF0ZWQgYW5kIHN1YnMgZmlyZWQgKGJ1dCB3ZSBtYXkgbm90IGJlIHN1YnNjcmliZWRcbiAgICAgKiAgICB5ZXQgZGVwZW5kaW5nIG9uIG9yZGVyIG9mIGVmZmVjdHMsIHNvIHdlIG1pc3MgdGhpcykgVXBkYXRlZCB2YWx1ZVxuICAgICAqICAgIGlzIG5vdyBpbiBuZXh0VHJlZSwgYnV0IG5vdCBjdXJyZW50VHJlZS5cbiAgICAgKiAyLiBUaGlzIGVmZmVjdCBoYXBwZW5zLiBXZSBzdWJzY3JpYmUgYW5kIHVwZGF0ZS5cbiAgICAgKiAzLiBGcm9tIHRoZSB1cGRhdGUgd2UgcmUtcmVuZGVyIGFuZCByZWFkIGN1cnJlbnRUcmVlLCB3aXRoIG9sZCB2YWx1ZS5cbiAgICAgKiA0LiBCYXRjaGVyJ3MgZWZmZWN0IHNldHMgY3VycmVudFRyZWUgdG8gbmV4dFRyZWUuXG4gICAgICogSW4gdGhpcyBzZXF1ZW5jZSB3ZSBtaXNzIHRoZSB1cGRhdGUuIFRvIGF2b2lkIHRoYXQsIGFkZCB0aGUgdXBkYXRlXG4gICAgICogdG8gcXVldWVkQ29tcG9uZW50Q2FsbGJhY2sgaWYgYSBiYXRjaCBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKi9cblxuICAgIGlmIChzdG9yZVN0YXRlLm5leHRUcmVlKSB7XG4gICAgICBzdG9yZS5nZXRTdGF0ZSgpLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELnB1c2goKCkgPT4ge1xuICAgICAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGZvcmNlVXBkYXRlKFtdKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3ByZXZMb2FkYWJsZVJlZiRjdXJyMjtcblxuICAgICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snKSkge1xuICAgICAgICByZXR1cm4gZm9yY2VVcGRhdGUoW10pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdMb2FkYWJsZSA9IGdldExvYWRhYmxlKCk7XG5cbiAgICAgIGlmICghKChfcHJldkxvYWRhYmxlUmVmJGN1cnIyID0gcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQpICE9PSBudWxsICYmIF9wcmV2TG9hZGFibGVSZWYkY3VycjIgIT09IHZvaWQgMCAmJiBfcHJldkxvYWRhYmxlUmVmJGN1cnIyLmlzKG5ld0xvYWRhYmxlKSkpIHtcbiAgICAgICAgZm9yY2VVcGRhdGUobmV3TG9hZGFibGUpO1xuICAgICAgfVxuXG4gICAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IG5ld0xvYWRhYmxlO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucmVsZWFzZTtcbiAgfSwgW2NvbXBvbmVudE5hbWUsIGdldExvYWRhYmxlLCByZWNvaWxWYWx1ZSwgc3RvcmVSZWZdKTtcbiAgcmV0dXJuIGxvYWRhYmxlO1xufVxuLyoqXG4gIExpa2UgdXNlUmVjb2lsVmFsdWUoKSwgYnV0IGVpdGhlciByZXR1cm5zIHRoZSB2YWx1ZSBpZiBhdmFpbGFibGUgb3JcbiAganVzdCB1bmRlZmluZWQgaWYgbm90IGF2YWlsYWJsZSBmb3IgYW55IHJlYXNvbiwgc3VjaCBhcyBwZW5kaW5nIG9yIGVycm9yLlxuKi9cblxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlLCAndXNlUmVjb2lsVmFsdWVMb2FkYWJsZScpO1xuICB9XG5cbiAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L3JlYWN0LWhvb2tzXG4gICAgUmVjb2lsX3VzZVJldGFpbihyZWNvaWxWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIFRSQU5TSVRJT05fU1VQUE9SVDogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlQsXG4gICAgU1lOQ19FWFRFUk5BTF9TVE9SRTogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9TWU5DX0VYVEVSTkFMX1NUT1JFLFxuICAgIE1VVEFCTEVfU09VUkNFOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX01VVEFCTEVfU09VUkNFLFxuICAgIExFR0FDWTogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9MRUdBQ1lcbiAgfVtyZWFjdE1vZGUkMygpLm1vZGVdKHJlY29pbFZhbHVlKTtcbn1cbi8qKlxuICBSZXR1cm5zIHRoZSB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgUmVjb2lsVmFsdWUuXG4gIElmIHRoZSB2YWx1ZSBpcyBwZW5kaW5nLCBpdCB3aWxsIHRocm93IGEgUHJvbWlzZSB0byBzdXNwZW5kIHRoZSBjb21wb25lbnQsXG4gIGlmIHRoZSB2YWx1ZSBpcyBhbiBlcnJvciBpdCB3aWxsIHRocm93IGl0IGZvciB0aGUgbmVhcmVzdCBSZWFjdCBlcnJvciBib3VuZGFyeS5cbiAgVGhpcyB3aWxsIGFsc28gc3Vic2NyaWJlIHRoZSBjb21wb25lbnQgZm9yIGFueSB1cGRhdGVzIGluIHRoZSB2YWx1ZS5cbiAgKi9cblxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSwgJ3VzZVJlY29pbFZhbHVlJyk7XG4gIH1cblxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgY29uc3QgbG9hZGFibGUgPSB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFZhbHVlKTtcbiAgcmV0dXJuIGhhbmRsZUxvYWRhYmxlKGxvYWRhYmxlLCByZWNvaWxWYWx1ZSwgc3RvcmVSZWYpO1xufVxuLyoqXG4gIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFsbG93cyB0aGUgdmFsdWUgb2YgYSBSZWNvaWxTdGF0ZSB0byBiZSB1cGRhdGVkLCBidXQgZG9lc1xuICBub3Qgc3Vic2NyaWJlIHRoZSBjb21wb25lbnQgdG8gY2hhbmdlcyB0byB0aGF0IFJlY29pbFN0YXRlLlxuKi9cblxuXG5mdW5jdGlvbiB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVNldFJlY29pbFN0YXRlJyk7XG4gIH1cblxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDEobmV3VmFsdWVPclVwZGF0ZXIgPT4ge1xuICAgIHNldFJlY29pbFZhbHVlJDIoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsU3RhdGUsIG5ld1ZhbHVlT3JVcGRhdGVyKTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxTdGF0ZV0pO1xufVxuLyoqXG4gIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVzZXQgdGhlIHZhbHVlIG9mIGEgUmVjb2lsU3RhdGUgdG8gaXRzIGRlZmF1bHRcbiovXG5cblxuZnVuY3Rpb24gdXNlUmVzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlc2V0UmVjb2lsU3RhdGUnKTtcbiAgfVxuXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XG4gICAgc2V0UmVjb2lsVmFsdWUkMihzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxTdGF0ZSwgREVGQVVMVF9WQUxVRSQyKTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxTdGF0ZV0pO1xufVxuLyoqXG4gIEVxdWl2YWxlbnQgdG8gdXNlU3RhdGUoKS4gQWxsb3dzIHRoZSB2YWx1ZSBvZiB0aGUgUmVjb2lsU3RhdGUgdG8gYmUgcmVhZCBhbmQgd3JpdHRlbi5cbiAgU3Vic2VxdWVudCB1cGRhdGVzIHRvIHRoZSBSZWNvaWxTdGF0ZSB3aWxsIGNhdXNlIHRoZSBjb21wb25lbnQgdG8gcmUtcmVuZGVyLiBJZiB0aGVcbiAgUmVjb2lsU3RhdGUgaXMgcGVuZGluZywgdGhpcyB3aWxsIHN1c3BlbmQgdGhlIGNvbXBvbmVudCBhbmQgaW5pdGlhdGUgdGhlXG4gIHJldHJpZXZhbCBvZiB0aGUgdmFsdWUuIElmIGV2YWx1YXRpbmcgdGhlIFJlY29pbFN0YXRlIHJlc3VsdGVkIGluIGFuIGVycm9yLCB0aGlzIHdpbGxcbiAgdGhyb3cgdGhlIGVycm9yIHNvIHRoYXQgdGhlIG5lYXJlc3QgUmVhY3QgZXJyb3IgYm91bmRhcnkgY2FuIGNhdGNoIGl0LlxuKi9cblxuXG5mdW5jdGlvbiB1c2VSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlY29pbFN0YXRlJyk7XG4gIH1cblxuICByZXR1cm4gW3VzZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcbn1cbi8qKlxuICBMaWtlIHVzZVJlY29pbFN0YXRlKCksIGJ1dCBkb2VzIG5vdCBjYXVzZSBTdXNwZW5zZSBvciBSZWFjdCBlcnJvciBoYW5kbGluZy4gUmV0dXJuc1xuICBhbiBvYmplY3QgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgUmVjb2lsU3RhdGUgaXMgYXZhaWxhYmxlLCBwZW5kaW5nLCBvclxuICB1bmF2YWlsYWJsZSBkdWUgdG8gYW4gZXJyb3IuXG4qL1xuXG5cbmZ1bmN0aW9uIHVzZVJlY29pbFN0YXRlTG9hZGFibGUocmVjb2lsU3RhdGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlJyk7XG4gIH1cblxuICByZXR1cm4gW3VzZVJlY29pbFZhbHVlTG9hZGFibGUocmVjb2lsU3RhdGUpLCB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSldO1xufVxuXG5mdW5jdGlvbiB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMoKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICByZXR1cm4gKHZhbHVlcywgdHJhbnNhY3Rpb25NZXRhZGF0YSA9IHt9KSA9PiB7XG4gICAgYmF0Y2hVcGRhdGVzJDIoKCkgPT4ge1xuICAgICAgc3RvcmVSZWYuY3VycmVudC5hZGRUcmFuc2FjdGlvbk1ldGFkYXRhKHRyYW5zYWN0aW9uTWV0YWRhdGEpO1xuICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMihzdG9yZVJlZi5jdXJyZW50LCBuZXcgQWJzdHJhY3RSZWNvaWxWYWx1ZSQzKGtleSksIHZhbHVlKSk7XG4gICAgfSk7XG4gIH07XG59XG4vKipcbiAqIEV4cGVyaW1lbnRhbCB2YXJpYW50cyBvZiBob29rcyB3aXRoIHN1cHBvcnQgZm9yIHVzZVRyYW5zaXRpb24oKVxuICovXG5cblxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsVmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRScpO1xuXG4gICAgaWYgKCFyZWFjdE1vZGUkMygpLmVhcmx5KSB7XG4gICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ0F0dGVwbXQgdG8gdXNlIGEgaG9vayB3aXRoIFVOU1RBQkxFX1RSQU5TSVRJT05fU1VQUE9SVCBpbiBhIHJlbmRlcmluZyBtb2RlIGluY29tcGF0aWJsZSB3aXRoIGNvbmN1cnJlbnQgcmVuZGVyaW5nLiAgVHJ5IGVuYWJsaW5nIHRoZSByZWNvaWxfc3luY19leHRlcm5hbF9zdG9yZSBvciByZWNvaWxfdHJhbnNpdGlvbl9zdXBwb3J0IEdLcy4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvcmVhY3QtaG9va3NcbiAgICBSZWNvaWxfdXNlUmV0YWluKHJlY29pbFZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVChyZWNvaWxWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRShyZWNvaWxWYWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSwgJ3VzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRScpO1xuICB9XG5cbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XG4gIGNvbnN0IGxvYWRhYmxlID0gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsVmFsdWUpO1xuICByZXR1cm4gaGFuZGxlTG9hZGFibGUobG9hZGFibGUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZik7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRShyZWNvaWxTdGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRScpO1xuICB9XG5cbiAgcmV0dXJuIFt1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsU3RhdGUpLCB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSldO1xufVxuXG52YXIgUmVjb2lsX0hvb2tzID0ge1xuICByZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HLFxuICB1c2VSZWNvaWxJbnRlcmZhY2U6IHVzZVJlY29pbEludGVyZmFjZV9ERVBSRUNBVEVELFxuICB1c2VSZWNvaWxTdGF0ZSxcbiAgdXNlUmVjb2lsU3RhdGVMb2FkYWJsZSxcbiAgdXNlUmVjb2lsVmFsdWUsXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGUsXG4gIHVzZVJlc2V0UmVjb2lsU3RhdGUsXG4gIHVzZVNldFJlY29pbFN0YXRlLFxuICB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMsXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFLFxuICB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUsXG4gIHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIG1hcCBjb250YWluaW5nIGFsbCBvZiB0aGUga2V5cyArIHZhbHVlcyBmcm9tIHRoZSBvcmlnaW5hbCBtYXAgd2hlcmVcbiAqIHRoZSBnaXZlbiBjYWxsYmFjayByZXR1cm5lZCB0cnVlLlxuICovXG5cbmZ1bmN0aW9uIGZpbHRlck1hcChtYXAsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcblxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXApIHtcbiAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSkpIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlY29pbF9maWx0ZXJNYXAgPSBmaWx0ZXJNYXA7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIFJldHVybnMgYSBzZXQgY29udGFpbmluZyBhbGwgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBvcmlnaW5hbCBzZXQgd2hlcmVcbiAqIHRoZSBnaXZlbiBjYWxsYmFjayByZXR1cm5lZCB0cnVlLlxuICovXG5cbmZ1bmN0aW9uIGZpbHRlclNldChzZXQsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcblxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHNldCkge1xuICAgIGlmIChjYWxsYmFjayh2YWx1ZSkpIHtcbiAgICAgIHJlc3VsdC5hZGQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBSZWNvaWxfZmlsdGVyU2V0ID0gZmlsdGVyU2V0O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBtZXJnZU1hcHMoLi4ubWFwcykge1xuICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBtYXBzW2ldLmtleXMoKTtcbiAgICBsZXQgbmV4dEtleTtcblxuICAgIHdoaWxlICghKG5leHRLZXkgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLWNhbGxdIC0gbWFwL2l0ZXJhdG9yIGtub3dzIG5vdGhpbmcgYWJvdXQgZmxvdyB0eXBlc1xuICAgICAgcmVzdWx0LnNldChuZXh0S2V5LnZhbHVlLCBtYXBzW2ldLmdldChuZXh0S2V5LnZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlY29pbF9tZXJnZU1hcHMgPSBtZXJnZU1hcHM7XG5cbmNvbnN0IHtcbiAgYmF0Y2hVcGRhdGVzOiBiYXRjaFVwZGF0ZXMkM1xufSA9IFJlY29pbF9CYXRjaGluZztcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDMsXG4gIGdldE5vZGU6IGdldE5vZGUkNCxcbiAgbm9kZXM6IG5vZGVzJDFcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkM1xufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkNCxcbiAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZTogc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIFNVU1BFTlNFX1RJTUVPVVRfTVM6IFNVU1BFTlNFX1RJTUVPVVRfTVMkMlxufSA9IFJlY29pbF9SZXRlbnRpb247XG5cbmNvbnN0IHtcbiAgY2xvbmVTbmFwc2hvdDogY2xvbmVTbmFwc2hvdCQxXG59ID0gUmVjb2lsX1NuYXBzaG90JDE7XG5cbmNvbnN0IHtcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrJDIsXG4gIHVzZUVmZmVjdDogdXNlRWZmZWN0JDQsXG4gIHVzZVJlZjogdXNlUmVmJDUsXG4gIHVzZVN0YXRlOiB1c2VTdGF0ZSQyXG59ID0gcmVhY3Q7XG5cbmNvbnN0IHtcbiAgaXNTU1I6IGlzU1NSJDNcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiB1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvbihjYWxsYmFjaykge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDMoKTtcbiAgdXNlRWZmZWN0JDQoKCkgPT4ge1xuICAgIGNvbnN0IHN1YiA9IHN0b3JlUmVmLmN1cnJlbnQuc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnMoY2FsbGJhY2spO1xuICAgIHJldHVybiBzdWIucmVsZWFzZTtcbiAgfSwgW2NhbGxiYWNrLCBzdG9yZVJlZl0pO1xufVxuXG5mdW5jdGlvbiBleHRlcm5hbGx5VmlzaWJsZUF0b21WYWx1ZXNJblN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IGF0b21WYWx1ZXMgPSBzdGF0ZS5hdG9tVmFsdWVzLnRvTWFwKCk7XG4gIGNvbnN0IHBlcnNpc3RlZEF0b21Db250ZW50c1ZhbHVlcyA9IFJlY29pbF9tYXBNYXAoUmVjb2lsX2ZpbHRlck1hcChhdG9tVmFsdWVzLCAodiwgaykgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBnZXROb2RlJDQoayk7XG4gICAgY29uc3QgcGVyc2lzdGVuY2UgPSBub2RlLnBlcnNpc3RlbmNlX1VOU1RBQkxFO1xuICAgIHJldHVybiBwZXJzaXN0ZW5jZSAhPSBudWxsICYmIHBlcnNpc3RlbmNlLnR5cGUgIT09ICdub25lJyAmJiB2LnN0YXRlID09PSAnaGFzVmFsdWUnO1xuICB9KSwgdiA9PiB2LmNvbnRlbnRzKTsgLy8gTWVyZ2UgaW4gbm9udmFsaWRhdGVkIGF0b21zOyB3ZSBtYXkgbm90IGhhdmUgZGVmcyBmb3IgdGhlbSBidXQgdGhleSB3aWxsXG4gIC8vIGFsbCBoYXZlIHBlcnNpc3RlbmNlIG9uIG9yIHRoZXkgd291bGRuJ3QgYmUgdGhlcmUgaW4gdGhlIGZpcnN0IHBsYWNlLlxuXG4gIHJldHVybiBSZWNvaWxfbWVyZ2VNYXBzKHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLnRvTWFwKCksIHBlcnNpc3RlZEF0b21Db250ZW50c1ZhbHVlcyk7XG59XG5cbi8qKlxuICBDYWxscyB0aGUgZ2l2ZW4gY2FsbGJhY2sgYWZ0ZXIgYW55IGF0b21zIGhhdmUgYmVlbiBtb2RpZmllZCBhbmQgdGhlIGNvbnNlcXVlbnRcbiAgY29tcG9uZW50IHJlLXJlbmRlcnMgaGF2ZSBiZWVuIGNvbW1pdHRlZC4gVGhpcyBpcyBpbnRlbmRlZCBmb3IgcGVyc2lzdGluZ1xuICB0aGUgdmFsdWVzIG9mIHRoZSBhdG9tcyB0byBzdG9yYWdlLiBUaGUgc3RvcmVkIHZhbHVlcyBjYW4gdGhlbiBiZSByZXN0b3JlZFxuICB1c2luZyB0aGUgdXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzIGhvb2suXG5cbiAgVGhlIGNhbGxiYWNrIHJlY2VpdmVzIHRoZSBmb2xsb3dpbmcgaW5mbzpcblxuICBhdG9tVmFsdWVzOiBUaGUgY3VycmVudCB2YWx1ZSBvZiBldmVyeSBhdG9tIHRoYXQgaXMgYm90aCBwZXJzaXN0YWJsZSAocGVyc2lzdGVuY2VcbiAgICAgICAgICAgICAgdHlwZSBub3Qgc2V0IHRvICdub25lJykgYW5kIHdob3NlIHZhbHVlIGlzIGF2YWlsYWJsZSAobm90IGluIGFuXG4gICAgICAgICAgICAgIGVycm9yIG9yIGxvYWRpbmcgc3RhdGUpLlxuXG4gIHByZXZpb3VzQXRvbVZhbHVlczogVGhlIHZhbHVlIG9mIGV2ZXJ5IHBlcnNpc3RhYmxlIGFuZCBhdmFpbGFibGUgYXRvbSBiZWZvcmVcbiAgICAgICAgICAgICAgIHRoZSB0cmFuc2FjdGlvbiBiZWdhbi5cblxuICBhdG9tSW5mbzogQSBtYXAgY29udGFpbmluZyB0aGUgcGVyc2lzdGVuY2Ugc2V0dGluZ3MgZm9yIGVhY2ggYXRvbS4gRXZlcnkga2V5XG4gICAgICAgICAgICB0aGF0IGV4aXN0cyBpbiBhdG9tVmFsdWVzIHdpbGwgYWxzbyBleGlzdCBpbiBhdG9tSW5mby5cblxuICBtb2RpZmllZEF0b21zOiBUaGUgc2V0IG9mIGF0b21zIHRoYXQgd2VyZSB3cml0dGVuIHRvIGR1cmluZyB0aGUgdHJhbnNhY3Rpb24uXG5cbiAgdHJhbnNhY3Rpb25NZXRhZGF0YTogQXJiaXRyYXJ5IGluZm9ybWF0aW9uIHRoYXQgd2FzIGFkZGVkIHZpYSB0aGVcbiAgICAgICAgICB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMgaG9vay4gVXNlZnVsIGZvciBpZ25vcmluZyB0aGUgdXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzXG4gICAgICAgICAgdHJhbnNhY3Rpb24sIHRvIGF2b2lkIGxvb3BzLlxuKi9cbmZ1bmN0aW9uIHVzZVRyYW5zYWN0aW9uT2JzZXJ2YXRpb25fREVQUkVDQVRFRChjYWxsYmFjaykge1xuICB1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvbih1c2VDYWxsYmFjayQyKHN0b3JlID0+IHtcbiAgICBsZXQgcHJldmlvdXNUcmVlID0gc3RvcmUuZ2V0U3RhdGUoKS5wcmV2aW91c1RyZWU7XG4gICAgY29uc3QgY3VycmVudFRyZWUgPSBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xuXG4gICAgaWYgKCFwcmV2aW91c1RyZWUpIHtcbiAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignVHJhbnNhY3Rpb24gc3Vic2NyaWJlcnMgbm90aWZpZWQgd2l0aG91dCBhIHByZXZpb3VzIHRyZWUgYmVpbmcgcHJlc2VudCAtLSB0aGlzIGlzIGEgYnVnIGluIFJlY29pbCcpO1xuICAgICAgcHJldmlvdXNUcmVlID0gc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZTsgLy8gYXR0ZW1wdCB0byB0cnVuZGxlIG9uXG4gICAgfVxuXG4gICAgY29uc3QgYXRvbVZhbHVlcyA9IGV4dGVybmFsbHlWaXNpYmxlQXRvbVZhbHVlc0luU3RhdGUoY3VycmVudFRyZWUpO1xuICAgIGNvbnN0IHByZXZpb3VzQXRvbVZhbHVlcyA9IGV4dGVybmFsbHlWaXNpYmxlQXRvbVZhbHVlc0luU3RhdGUocHJldmlvdXNUcmVlKTtcbiAgICBjb25zdCBhdG9tSW5mbyA9IFJlY29pbF9tYXBNYXAobm9kZXMkMSwgbm9kZSA9PiB7XG4gICAgICB2YXIgX25vZGUkcGVyc2lzdGVuY2VfVU5TLCBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMyLCBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMzLCBfbm9kZSRwZXJzaXN0ZW5jZV9VTlM0O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwZXJzaXN0ZW5jZV9VTlNUQUJMRToge1xuICAgICAgICAgIHR5cGU6IChfbm9kZSRwZXJzaXN0ZW5jZV9VTlMgPSAoX25vZGUkcGVyc2lzdGVuY2VfVU5TMiA9IG5vZGUucGVyc2lzdGVuY2VfVU5TVEFCTEUpID09PSBudWxsIHx8IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzIudHlwZSkgIT09IG51bGwgJiYgX25vZGUkcGVyc2lzdGVuY2VfVU5TICE9PSB2b2lkIDAgPyBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMgOiAnbm9uZScsXG4gICAgICAgICAgYmFja0J1dHRvbjogKF9ub2RlJHBlcnNpc3RlbmNlX1VOUzMgPSAoX25vZGUkcGVyc2lzdGVuY2VfVU5TNCA9IG5vZGUucGVyc2lzdGVuY2VfVU5TVEFCTEUpID09PSBudWxsIHx8IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzQuYmFja0J1dHRvbikgIT09IG51bGwgJiYgX25vZGUkcGVyc2lzdGVuY2VfVU5TMyAhPT0gdm9pZCAwID8gX25vZGUkcGVyc2lzdGVuY2VfVU5TMyA6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7IC8vIEZpbHRlciBvbiBleGlzdGFuY2UgaW4gYXRvbVZhbHVlcyBzbyB0aGF0IGV4dGVybmFsbHktdmlzaWJsZSBydWxlc1xuICAgIC8vIGFyZSBhbHNvIGFwcGxpZWQgdG8gbW9kaWZpZWQgYXRvbXMgKHNwZWNpZmljYWxseSBleGNsdWRlIHNlbGVjdG9ycyk6XG5cbiAgICBjb25zdCBtb2RpZmllZEF0b21zID0gUmVjb2lsX2ZpbHRlclNldChjdXJyZW50VHJlZS5kaXJ0eUF0b21zLCBrID0+IGF0b21WYWx1ZXMuaGFzKGspIHx8IHByZXZpb3VzQXRvbVZhbHVlcy5oYXMoaykpO1xuICAgIGNhbGxiYWNrKHtcbiAgICAgIGF0b21WYWx1ZXMsXG4gICAgICBwcmV2aW91c0F0b21WYWx1ZXMsXG4gICAgICBhdG9tSW5mbyxcbiAgICAgIG1vZGlmaWVkQXRvbXMsXG4gICAgICB0cmFuc2FjdGlvbk1ldGFkYXRhOiB7IC4uLmN1cnJlbnRUcmVlLnRyYW5zYWN0aW9uTWV0YWRhdGFcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW2NhbGxiYWNrXSkpO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gIHVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uKHVzZUNhbGxiYWNrJDIoc3RvcmUgPT4ge1xuICAgIGNvbnN0IHNuYXBzaG90ID0gY2xvbmVTbmFwc2hvdCQxKHN0b3JlLCAnbGF0ZXN0Jyk7XG4gICAgY29uc3QgcHJldmlvdXNTbmFwc2hvdCA9IGNsb25lU25hcHNob3QkMShzdG9yZSwgJ3ByZXZpb3VzJyk7XG4gICAgY2FsbGJhY2soe1xuICAgICAgc25hcHNob3QsXG4gICAgICBwcmV2aW91c1NuYXBzaG90XG4gICAgfSk7XG4gIH0sIFtjYWxsYmFja10pKTtcbn0gLy8gUmV0dXJuIGEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHN1YnNjcmliZSB0byBhbGwgc3RhdGUgY2hhbmdlc1xuXG5cbmZ1bmN0aW9uIHVzZVJlY29pbFNuYXBzaG90KCkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDMoKTtcbiAgY29uc3QgW3NuYXBzaG90LCBzZXRTbmFwc2hvdF0gPSB1c2VTdGF0ZSQyKCgpID0+IGNsb25lU25hcHNob3QkMShzdG9yZVJlZi5jdXJyZW50KSk7XG4gIGNvbnN0IHByZXZpb3VzU25hcHNob3QgPSBSZWNvaWxfdXNlUHJldmlvdXMoc25hcHNob3QpO1xuICBjb25zdCB0aW1lb3V0SUQgPSB1c2VSZWYkNSgpO1xuICBjb25zdCByZWxlYXNlUmVmID0gdXNlUmVmJDUoKTtcbiAgdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb24odXNlQ2FsbGJhY2skMihzdG9yZSA9PiBzZXRTbmFwc2hvdChjbG9uZVNuYXBzaG90JDEoc3RvcmUpKSwgW10pKTsgLy8gUmV0YWluIHNuYXBzaG90IGZvciBkdXJhdGlvbiBjb21wb25lbnQgaXMgbW91bnRlZFxuXG4gIHVzZUVmZmVjdCQ0KCgpID0+IHtcbiAgICBjb25zdCByZWxlYXNlID0gc25hcHNob3QucmV0YWluKCk7IC8vIFJlbGVhc2UgdGhlIHJldGFpbiBmcm9tIHRoZSByZW5kZXJpbmcgY2FsbFxuXG4gICAgaWYgKHRpbWVvdXRJRC5jdXJyZW50ICYmICFpc1NTUiQzKSB7XG4gICAgICB2YXIgX3JlbGVhc2VSZWYkY3VycmVudDtcblxuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0SUQuY3VycmVudCk7XG4gICAgICB0aW1lb3V0SUQuY3VycmVudCA9IG51bGw7XG4gICAgICAoX3JlbGVhc2VSZWYkY3VycmVudCA9IHJlbGVhc2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX3JlbGVhc2VSZWYkY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbGVhc2VSZWYkY3VycmVudC5jYWxsKHJlbGVhc2VSZWYpO1xuICAgICAgcmVsZWFzZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gRGVmZXIgdGhlIHJlbGVhc2UuICBJZiBcIkZhc3QgUmVmcmVzaFwiXCIgaXMgdXNlZCB0aGVuIHRoZSBjb21wb25lbnQgbWF5XG4gICAgICAvLyByZS1yZW5kZXIgd2l0aCB0aGUgc2FtZSBzdGF0ZS4gIFRoZSBwcmV2aW91cyBjbGVhbnVwIHdpbGwgdGhlbiBydW4gYW5kXG4gICAgICAvLyB0aGVuIHRoZSBuZXcgZWZmZWN0IHdpbGwgcnVuLiBXZSBkb24ndCB3YW50IHRoZSBzbmFwc2hvdCB0byBiZSByZWxlYXNlZFxuICAgICAgLy8gYnkgdGhhdCBjbGVhbnVwIGJlZm9yZSB0aGUgbmV3IGVmZmVjdCBoYXMgYSBjaGFuY2UgdG8gcmV0YWluIGl0IGFnYWluLlxuICAgICAgLy8gVXNlIHRpbWVvdXQgb2YgMTAgdG8gd29ya2Fyb3VuZCBGaXJlZm94IGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tleHBlcmltZW50YWwvUmVjb2lsL2lzc3Vlcy8xOTM2XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChyZWxlYXNlLCAxMCk7XG4gICAgfTtcbiAgfSwgW3NuYXBzaG90XSk7IC8vIFJldGFpbiBzbmFwc2hvdCB1bnRpbCBhYm92ZSBlZmZlY3QgaXMgcnVuLlxuICAvLyBSZWxlYXNlIGFmdGVyIGEgdGhyZXNob2xkIGluIGNhc2UgY29tcG9uZW50IGlzIHN1c3BlbmRlZC5cblxuICBpZiAocHJldmlvdXNTbmFwc2hvdCAhPT0gc25hcHNob3QgJiYgIWlzU1NSJDMpIHtcbiAgICAvLyBSZWxlYXNlIHRoZSBwcmV2aW91cyBzbmFwc2hvdFxuICAgIGlmICh0aW1lb3V0SUQuY3VycmVudCkge1xuICAgICAgdmFyIF9yZWxlYXNlUmVmJGN1cnJlbnQyO1xuXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcbiAgICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gbnVsbDtcbiAgICAgIChfcmVsZWFzZVJlZiRjdXJyZW50MiA9IHJlbGVhc2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX3JlbGVhc2VSZWYkY3VycmVudDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZWxlYXNlUmVmJGN1cnJlbnQyLmNhbGwocmVsZWFzZVJlZik7XG4gICAgICByZWxlYXNlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cblxuICAgIHJlbGVhc2VSZWYuY3VycmVudCA9IHNuYXBzaG90LnJldGFpbigpO1xuICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdmFyIF9yZWxlYXNlUmVmJGN1cnJlbnQzO1xuXG4gICAgICB0aW1lb3V0SUQuY3VycmVudCA9IG51bGw7XG4gICAgICAoX3JlbGVhc2VSZWYkY3VycmVudDMgPSByZWxlYXNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9yZWxlYXNlUmVmJGN1cnJlbnQzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsZWFzZVJlZiRjdXJyZW50My5jYWxsKHJlbGVhc2VSZWYpO1xuICAgICAgcmVsZWFzZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9LCBTVVNQRU5TRV9USU1FT1VUX01TJDIpO1xuICB9XG5cbiAgcmV0dXJuIHNuYXBzaG90O1xufVxuXG5mdW5jdGlvbiBnb3RvU25hcHNob3Qoc3RvcmUsIHNuYXBzaG90KSB7XG4gIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTtcblxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3QgcHJldiA9IChfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG4gIGNvbnN0IG5leHQgPSBzbmFwc2hvdC5nZXRTdG9yZV9JTlRFUk5BTCgpLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XG4gIGJhdGNoVXBkYXRlcyQzKCgpID0+IHtcbiAgICBjb25zdCBrZXlzVG9VcGRhdGUgPSBuZXcgU2V0KCk7XG5cbiAgICBmb3IgKGNvbnN0IGtleXMgb2YgW3ByZXYuYXRvbVZhbHVlcy5rZXlzKCksIG5leHQuYXRvbVZhbHVlcy5rZXlzKCldKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIHZhciBfcHJldiRhdG9tVmFsdWVzJGdldCwgX25leHQkYXRvbVZhbHVlcyRnZXQ7XG5cbiAgICAgICAgaWYgKCgoX3ByZXYkYXRvbVZhbHVlcyRnZXQgPSBwcmV2LmF0b21WYWx1ZXMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9wcmV2JGF0b21WYWx1ZXMkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHJldiRhdG9tVmFsdWVzJGdldC5jb250ZW50cykgIT09ICgoX25leHQkYXRvbVZhbHVlcyRnZXQgPSBuZXh0LmF0b21WYWx1ZXMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9uZXh0JGF0b21WYWx1ZXMkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbmV4dCRhdG9tVmFsdWVzJGdldC5jb250ZW50cykgJiYgZ2V0Tm9kZSQ0KGtleSkuc2hvdWxkUmVzdG9yZUZyb21TbmFwc2hvdHMpIHtcbiAgICAgICAgICBrZXlzVG9VcGRhdGUuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBrZXlzVG9VcGRhdGUuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQxKHN0b3JlLCBuZXcgQWJzdHJhY3RSZWNvaWxWYWx1ZSQ0KGtleSksIG5leHQuYXRvbVZhbHVlcy5oYXMoa2V5KSA/IFJlY29pbF9udWxsdGhyb3dzKG5leHQuYXRvbVZhbHVlcy5nZXQoa2V5KSkgOiBERUZBVUxUX1ZBTFVFJDMpO1xuICAgIH0pO1xuICAgIHN0b3JlLnJlcGxhY2VTdGF0ZShzdGF0ZSA9PiAoeyAuLi5zdGF0ZSxcbiAgICAgIHN0YXRlSUQ6IHNuYXBzaG90LmdldElEKClcbiAgICB9KSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VHb3RvUmVjb2lsU25hcHNob3QoKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMygpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2skMihzbmFwc2hvdCA9PiBnb3RvU25hcHNob3Qoc3RvcmVSZWYuY3VycmVudCwgc25hcHNob3QpLCBbc3RvcmVSZWZdKTtcbn1cblxudmFyIFJlY29pbF9TbmFwc2hvdEhvb2tzID0ge1xuICB1c2VSZWNvaWxTbmFwc2hvdCxcbiAgZ290b1NuYXBzaG90LFxuICB1c2VHb3RvUmVjb2lsU25hcHNob3QsXG4gIHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXIsXG4gIHVzZVRyYW5zYWN0aW9uT2JzZXJ2YXRpb25fREVQUkVDQVRFRCxcbiAgdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25fREVQUkVDQVRFRDogdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25cbn07XG5cbmNvbnN0IHtcbiAgcGVla05vZGVJbmZvOiBwZWVrTm9kZUluZm8kMlxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkNFxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5mdW5jdGlvbiB1c2VHZXRSZWNvaWxWYWx1ZUluZm8oKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkNCgpO1xuICByZXR1cm4gKHtcbiAgICBrZXlcbiAgfSkgPT4gcGVla05vZGVJbmZvJDIoc3RvcmVSZWYuY3VycmVudCwgc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLCBrZXkpO1xufVxuXG52YXIgUmVjb2lsX3VzZUdldFJlY29pbFZhbHVlSW5mbyA9IHVzZUdldFJlY29pbFZhbHVlSW5mbztcblxuY29uc3Qge1xuICByZWFjdE1vZGU6IHJlYWN0TW9kZSQ0XG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcblxuY29uc3Qge1xuICBSZWNvaWxSb290OiBSZWNvaWxSb290JDEsXG4gIHVzZVN0b3JlUmVmOiB1c2VTdG9yZVJlZiQ1XG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XG5cblxuXG5jb25zdCB7XG4gIHVzZU1lbW86IHVzZU1lbW8kMlxufSA9IHJlYWN0O1xuXG5mdW5jdGlvbiB1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzKCkge1xuICAvLyBUaGUgdGVzdCBmYWlscyB3aGVuIHVzaW5nIHVzZU11dGFibGVTb3VyY2UoKSwgYnV0IG9ubHkgaWYgYWN0KCkgaXMgdXNlZFxuICAvLyBmb3IgdGhlIG5lc3RlZCByb290LiAgU28sIHRoaXMgbWF5IG9ubHkgYmUgYSB0ZXN0aW5nIGVudmlyb25tZW50IGlzc3VlLlxuICBpZiAocmVhY3RNb2RlJDQoKS5tb2RlID09PSAnTVVUQUJMRV9TT1VSQ0UnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9uby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBUaGVyZSBhcmUga25vd24gaXNzdWVzIHVzaW5nIHVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHMoKSBpbiByZWNvaWxfbXV0YWJsZV9zb3VyY2UgcmVuZGVyaW5nIG1vZGUuICBQbGVhc2UgY29uc2lkZXIgdXBncmFkaW5nIHRvIHJlY29pbF9zeW5jX2V4dGVybmFsX3N0b3JlIG1vZGUuJyk7XG4gIH1cblxuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlUmVmJDUoKS5jdXJyZW50O1xuICByZXR1cm4gdXNlTWVtbyQyKCgpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG4gICAgZnVuY3Rpb24gUmVjb2lsQnJpZGdlKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9yZWFjdC5jcmVhdGVFbGVtZW50KFJlY29pbFJvb3QkMSwge1xuICAgICAgICBzdG9yZV9JTlRFUk5BTDogc3RvcmVcbiAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVjb2lsQnJpZGdlO1xuICB9LCBbc3RvcmVdKTtcbn1cblxudmFyIFJlY29pbF91c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzID0gdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cztcblxuY29uc3Qge1xuICBsb2FkYWJsZVdpdGhWYWx1ZTogbG9hZGFibGVXaXRoVmFsdWUkMVxufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xuXG5jb25zdCB7XG4gIGluaXRpYWxpemVOb2RlOiBpbml0aWFsaXplTm9kZSQzXG59ID0gUmVjb2lsX0Z1bmN0aW9uYWxDb3JlO1xuXG5jb25zdCB7XG4gIERFRkFVTFRfVkFMVUU6IERFRkFVTFRfVkFMVUUkNCxcbiAgZ2V0Tm9kZTogZ2V0Tm9kZSQ1XG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgY29weVRyZWVTdGF0ZTogY29weVRyZWVTdGF0ZSQxLFxuICBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGU6IGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQzLFxuICBpbnZhbGlkYXRlRG93bnN0cmVhbXM6IGludmFsaWRhdGVEb3duc3RyZWFtcyQxLFxuICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGU6IHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZSQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5cblxuZnVuY3Rpb24gaXNBdG9tKHJlY29pbFZhbHVlKSB7XG4gIHJldHVybiBnZXROb2RlJDUocmVjb2lsVmFsdWUua2V5KS5ub2RlVHlwZSA9PT0gJ2F0b20nO1xufVxuXG5jbGFzcyBUcmFuc2FjdGlvbkludGVyZmFjZUltcGwge1xuICBjb25zdHJ1Y3RvcihzdG9yZSwgdHJlZVN0YXRlKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N0b3JlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdHJlZVN0YXRlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2hhbmdlc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0XCIsIHJlY29pbFZhbHVlID0+IHtcbiAgICAgIGlmICh0aGlzLl9jaGFuZ2VzLmhhcyhyZWNvaWxWYWx1ZS5rZXkpKSB7XG4gICAgICAgIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZXMuZ2V0KHJlY29pbFZhbHVlLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNBdG9tKHJlY29pbFZhbHVlKSkge1xuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdSZWFkaW5nIHNlbGVjdG9ycyB3aXRoaW4gYXRvbWljVXBkYXRlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9hZGFibGUgPSBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMyh0aGlzLl9zdG9yZSwgcmVjb2lsVmFsdWUsIHRoaXMuX3RyZWVTdGF0ZSk7XG5cbiAgICAgIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJykge1xuICAgICAgICByZXR1cm4gbG9hZGFibGUuY29udGVudHM7XG4gICAgICB9IGVsc2UgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzRXJyb3InKSB7XG4gICAgICAgIHRocm93IGxvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgUmVjb2lsX2VycihgRXhwZWN0ZWQgUmVjb2lsIGF0b20gJHtyZWNvaWxWYWx1ZS5rZXl9IHRvIGhhdmUgYSB2YWx1ZSwgYnV0IGl0IGlzIGluIGEgbG9hZGluZyBzdGF0ZS5gKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldFwiLCAocmVjb2lsU3RhdGUsIHZhbHVlT3JVcGRhdGVyKSA9PiB7XG4gICAgICBpZiAoIWlzQXRvbShyZWNvaWxTdGF0ZSkpIHtcbiAgICAgICAgdGhyb3cgUmVjb2lsX2VycignU2V0dGluZyBzZWxlY3RvcnMgd2l0aGluIGF0b21pY1VwZGF0ZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWVPclVwZGF0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuZ2V0KHJlY29pbFN0YXRlKTtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VzLnNldChyZWNvaWxTdGF0ZS5rZXksIHZhbHVlT3JVcGRhdGVyKGN1cnJlbnQpKTsgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgYXRvbSBhbmQgcnVuIGVmZmVjdHMgaWYgbm90IGluaXRpYWxpemVkIHlldFxuICAgICAgICBpbml0aWFsaXplTm9kZSQzKHRoaXMuX3N0b3JlLCByZWNvaWxTdGF0ZS5rZXksICdzZXQnKTtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VzLnNldChyZWNvaWxTdGF0ZS5rZXksIHZhbHVlT3JVcGRhdGVyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc2V0XCIsIHJlY29pbFN0YXRlID0+IHtcbiAgICAgIHRoaXMuc2V0KHJlY29pbFN0YXRlLCBERUZBVUxUX1ZBTFVFJDQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLl90cmVlU3RhdGUgPSB0cmVlU3RhdGU7XG4gICAgdGhpcy5fY2hhbmdlcyA9IG5ldyBNYXAoKTtcbiAgfSAvLyBBbGxvdyBkZXN0cnVjdGluZ1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L2V4dHJhLWFycm93LWluaXRpYWxpemVyXG5cblxuICBuZXdUcmVlU3RhdGVfSU5URVJOQUwoKSB7XG4gICAgaWYgKHRoaXMuX2NoYW5nZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyZWVTdGF0ZTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdTdGF0ZSA9IGNvcHlUcmVlU3RhdGUkMSh0aGlzLl90cmVlU3RhdGUpO1xuXG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgdGhpcy5fY2hhbmdlcykge1xuICAgICAgd3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlJDEobmV3U3RhdGUsIGssIGxvYWRhYmxlV2l0aFZhbHVlJDEodikpO1xuICAgIH1cblxuICAgIGludmFsaWRhdGVEb3duc3RyZWFtcyQxKHRoaXMuX3N0b3JlLCBuZXdTdGF0ZSk7XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gYXRvbWljVXBkYXRlcihzdG9yZSkge1xuICByZXR1cm4gZm4gPT4ge1xuICAgIHN0b3JlLnJlcGxhY2VTdGF0ZSh0cmVlU3RhdGUgPT4ge1xuICAgICAgY29uc3QgY2hhbmdlc2V0ID0gbmV3IFRyYW5zYWN0aW9uSW50ZXJmYWNlSW1wbChzdG9yZSwgdHJlZVN0YXRlKTtcbiAgICAgIGZuKGNoYW5nZXNldCk7XG4gICAgICByZXR1cm4gY2hhbmdlc2V0Lm5ld1RyZWVTdGF0ZV9JTlRFUk5BTCgpO1xuICAgIH0pO1xuICB9O1xufVxuXG52YXIgUmVjb2lsX0F0b21pY1VwZGF0ZXMgPSB7XG4gIGF0b21pY1VwZGF0ZXJcbn07XG5cbnZhciBSZWNvaWxfQXRvbWljVXBkYXRlc18xID0gUmVjb2lsX0F0b21pY1VwZGF0ZXMuYXRvbWljVXBkYXRlcjtcblxudmFyIFJlY29pbF9BdG9taWNVcGRhdGVzJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYXRvbWljVXBkYXRlcjogUmVjb2lsX0F0b21pY1VwZGF0ZXNfMVxufSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxudmFyIGludmFyaWFudF8xID0gaW52YXJpYW50O1xuXG4vLyBAb3NzLW9ubHlcblxuXG52YXIgUmVjb2lsX2ludmFyaWFudCA9IGludmFyaWFudF8xO1xuXG5jb25zdCB7XG4gIGF0b21pY1VwZGF0ZXI6IGF0b21pY1VwZGF0ZXIkMVxufSA9IFJlY29pbF9BdG9taWNVcGRhdGVzJDE7XG5cbmNvbnN0IHtcbiAgYmF0Y2hVcGRhdGVzOiBiYXRjaFVwZGF0ZXMkNFxufSA9IFJlY29pbF9CYXRjaGluZztcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDVcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkNlxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIHJlZnJlc2hSZWNvaWxWYWx1ZTogcmVmcmVzaFJlY29pbFZhbHVlJDEsXG4gIHNldFJlY29pbFZhbHVlOiBzZXRSZWNvaWxWYWx1ZSQzXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIGNsb25lU25hcHNob3Q6IGNsb25lU25hcHNob3QkMlxufSA9IFJlY29pbF9TbmFwc2hvdCQxO1xuXG5jb25zdCB7XG4gIGdvdG9TbmFwc2hvdDogZ290b1NuYXBzaG90JDFcbn0gPSBSZWNvaWxfU25hcHNob3RIb29rcztcblxuY29uc3Qge1xuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2skM1xufSA9IHJlYWN0O1xuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgU2VudGluZWwge31cblxuY29uc3QgU0VOVElORUwgPSBuZXcgU2VudGluZWwoKTtcblxuZnVuY3Rpb24gcmVjb2lsQ2FsbGJhY2soc3RvcmUsIGZuLCBhcmdzLCBleHRyYUludGVyZmFjZSkge1xuICBsZXQgcmV0ID0gU0VOVElORUw7XG4gIGxldCByZWxlYXNlU25hcHNob3Q7XG4gIGJhdGNoVXBkYXRlcyQ0KCgpID0+IHtcbiAgICBjb25zdCBlcnJNc2cgPSAndXNlUmVjb2lsQ2FsbGJhY2soKSBleHBlY3RzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb246ICcgKyAnaXQgYWNjZXB0cyBhIGZ1bmN0aW9uIG9mIHRoZSB0eXBlIChSZWNvaWxJbnRlcmZhY2UpID0+IChBcmdzKSA9PiBSZXR1cm5UeXBlICcgKyAnYW5kIHJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbiAoQXJncykgPT4gUmV0dXJuVHlwZSwgd2hlcmUgUmVjb2lsSW50ZXJmYWNlIGlzICcgKyAnYW4gb2JqZWN0IHtzbmFwc2hvdCwgc2V0LCAuLi59IGFuZCBBcmdzIGFuZCBSZXR1cm5UeXBlIGFyZSB0aGUgYXJndW1lbnQgYW5kIHJldHVybiAnICsgJ3R5cGVzIG9mIHRoZSBjYWxsYmFjayB5b3Ugd2FudCB0byBjcmVhdGUuICBQbGVhc2Ugc2VlIHRoZSBkb2NzICcgKyAnYXQgcmVjb2lsanMub3JnIGZvciBkZXRhaWxzLic7XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKGVyck1zZyk7XG4gICAgfSAvLyBDbG9uZSB0aGUgc25hcHNob3QgbGF6aWx5IHRvIGF2b2lkIG92ZXJoZWFkIGlmIHRoZSBjYWxsYmFjayBkb2VzIG5vdCB1c2UgaXQuXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgbWVhbnMgdGhlIHNuYXBzaG90IG1heSByZXByZXNlbnQgbGF0ZXIgc3RhdGUgZnJvbSB3aGVuXG4gICAgLy8gdGhlIGNhbGxiYWNrIHdhcyBjYWxsZWQgaWYgaXQgZmlyc3QgYWNjZXNzZXMgdGhlIHNuYXBzaG90IGFzeW5jaHJvbm91c2x5LlxuXG5cbiAgICBjb25zdCBjYWxsYmFja0ludGVyZmFjZSA9IFJlY29pbF9sYXp5UHJveHkoeyAuLi4oZXh0cmFJbnRlcmZhY2UgIT09IG51bGwgJiYgZXh0cmFJbnRlcmZhY2UgIT09IHZvaWQgMCA/IGV4dHJhSW50ZXJmYWNlIDoge30pLFxuICAgICAgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gICAgICBzZXQ6IChub2RlLCBuZXdWYWx1ZSkgPT4gc2V0UmVjb2lsVmFsdWUkMyhzdG9yZSwgbm9kZSwgbmV3VmFsdWUpLFxuICAgICAgcmVzZXQ6IG5vZGUgPT4gc2V0UmVjb2lsVmFsdWUkMyhzdG9yZSwgbm9kZSwgREVGQVVMVF9WQUxVRSQ1KSxcbiAgICAgIHJlZnJlc2g6IG5vZGUgPT4gcmVmcmVzaFJlY29pbFZhbHVlJDEoc3RvcmUsIG5vZGUpLFxuICAgICAgZ290b1NuYXBzaG90OiBzbmFwc2hvdCA9PiBnb3RvU25hcHNob3QkMShzdG9yZSwgc25hcHNob3QpLFxuICAgICAgdHJhbnNhY3RfVU5TVEFCTEU6IHRyYW5zYWN0aW9uID0+IGF0b21pY1VwZGF0ZXIkMShzdG9yZSkodHJhbnNhY3Rpb24pXG4gICAgfSwge1xuICAgICAgc25hcHNob3Q6ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSBjbG9uZVNuYXBzaG90JDIoc3RvcmUpO1xuICAgICAgICByZWxlYXNlU25hcHNob3QgPSBzbmFwc2hvdC5yZXRhaW4oKTtcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gZm4oY2FsbGJhY2tJbnRlcmZhY2UpO1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycihlcnJNc2cpO1xuICAgIH1cblxuICAgIHJldCA9IGNhbGxiYWNrKC4uLmFyZ3MpO1xuICB9KTtcbiAgISEocmV0IGluc3RhbmNlb2YgU2VudGluZWwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ2JhdGNoVXBkYXRlcyBzaG91bGQgcmV0dXJuIGltbWVkaWF0ZWx5JykgOiBSZWNvaWxfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICBpZiAoUmVjb2lsX2lzUHJvbWlzZShyZXQpKSB7XG4gICAgcmV0LmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdmFyIF9yZWxlYXNlU25hcHNob3Q7XG5cbiAgICAgIChfcmVsZWFzZVNuYXBzaG90ID0gcmVsZWFzZVNuYXBzaG90KSA9PT0gbnVsbCB8fCBfcmVsZWFzZVNuYXBzaG90ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsZWFzZVNuYXBzaG90KCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9yZWxlYXNlU25hcHNob3QyO1xuXG4gICAgKF9yZWxlYXNlU25hcHNob3QyID0gcmVsZWFzZVNuYXBzaG90KSA9PT0gbnVsbCB8fCBfcmVsZWFzZVNuYXBzaG90MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbGVhc2VTbmFwc2hvdDIoKTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYXN0XVxuXG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gdXNlUmVjb2lsQ2FsbGJhY2soZm4sIGRlcHMpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQ2KCk7XG4gIHJldHVybiB1c2VDYWxsYmFjayQzKCAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1jYWxsXVxuICAoLi4uYXJncykgPT4ge1xuICAgIHJldHVybiByZWNvaWxDYWxsYmFjayhzdG9yZVJlZi5jdXJyZW50LCBmbiwgYXJncyk7XG4gIH0sIGRlcHMgIT0gbnVsbCA/IFsuLi5kZXBzLCBzdG9yZVJlZl0gOiB1bmRlZmluZWQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmYi13d3cvcmVhY3QtaG9va3MtZGVwc1xuICApO1xufVxuXG52YXIgUmVjb2lsX3VzZVJlY29pbENhbGxiYWNrID0ge1xuICByZWNvaWxDYWxsYmFjayxcbiAgdXNlUmVjb2lsQ2FsbGJhY2tcbn07XG5cbmNvbnN0IHtcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDdcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuY29uc3Qge1xuICByZWZyZXNoUmVjb2lsVmFsdWU6IHJlZnJlc2hSZWNvaWxWYWx1ZSQyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIHVzZUNhbGxiYWNrOiB1c2VDYWxsYmFjayQ0XG59ID0gcmVhY3Q7XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFJlZnJlc2hlcihyZWNvaWxWYWx1ZSkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDcoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDQoKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICByZWZyZXNoUmVjb2lsVmFsdWUkMihzdG9yZSwgcmVjb2lsVmFsdWUpO1xuICB9LCBbcmVjb2lsVmFsdWUsIHN0b3JlUmVmXSk7XG59XG5cbnZhciBSZWNvaWxfdXNlUmVjb2lsUmVmcmVzaGVyID0gdXNlUmVjb2lsUmVmcmVzaGVyO1xuXG5jb25zdCB7XG4gIGF0b21pY1VwZGF0ZXI6IGF0b21pY1VwZGF0ZXIkMlxufSA9IFJlY29pbF9BdG9taWNVcGRhdGVzJDE7XG5cbmNvbnN0IHtcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDhcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuY29uc3Qge1xuICB1c2VNZW1vOiB1c2VNZW1vJDNcbn0gPSByZWFjdDtcblxuZnVuY3Rpb24gdXNlUmVjb2lsVHJhbnNhY3Rpb24oZm4sIGRlcHMpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQ4KCk7XG4gIHJldHVybiB1c2VNZW1vJDMoKCkgPT4gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBhdG9taWNVcGRhdGUgPSBhdG9taWNVcGRhdGVyJDIoc3RvcmVSZWYuY3VycmVudCk7XG4gICAgYXRvbWljVXBkYXRlKHRyYW5zYWN0aW9uSW50ZXJmYWNlID0+IHtcbiAgICAgIGZuKHRyYW5zYWN0aW9uSW50ZXJmYWNlKSguLi5hcmdzKTtcbiAgICB9KTtcbiAgfSwgZGVwcyAhPSBudWxsID8gWy4uLmRlcHMsIHN0b3JlUmVmXSA6IHVuZGVmaW5lZCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZiLXd3dy9yZWFjdC1ob29rcy1kZXBzXG4gICk7XG59XG5cbnZhciBSZWNvaWxfdXNlUmVjb2lsVHJhbnNhY3Rpb24gPSB1c2VSZWNvaWxUcmFuc2FjdGlvbjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuY2xhc3MgV3JhcHBlZFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbn1cblxudmFyIFJlY29pbF9XcmFwcGVyID0ge1xuICBXcmFwcGVkVmFsdWVcbn07XG5cbnZhciBSZWNvaWxfV3JhcHBlcl8xID0gUmVjb2lsX1dyYXBwZXIuV3JhcHBlZFZhbHVlO1xuXG52YXIgUmVjb2lsX1dyYXBwZXIkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBXcmFwcGVkVmFsdWU6IFJlY29pbF9XcmFwcGVyXzFcbn0pO1xuXG5jb25zdCB7XG4gIGlzRmFzdFJlZnJlc2hFbmFibGVkOiBpc0Zhc3RSZWZyZXNoRW5hYmxlZCQyXG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcblxuXG5cbmNsYXNzIENoYW5nZWRQYXRoRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5jbGFzcyBUcmVlQ2FjaGUge1xuICAvLyAkRmxvd0lzc3VlW3VuY2xlYXItdHlwZV1cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyRvbkhpdCwgX29wdGlvbnMkb25TZXQsIF9vcHRpb25zJG1hcE5vZGVWYWx1ZTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9uYW1lXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbnVtTGVhZnNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yb290XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfb25IaXRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9vblNldFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX21hcE5vZGVWYWx1ZVwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5fbmFtZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lO1xuICAgIHRoaXMuX251bUxlYWZzID0gMDtcbiAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB0aGlzLl9vbkhpdCA9IChfb3B0aW9ucyRvbkhpdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbkhpdCkgIT09IG51bGwgJiYgX29wdGlvbnMkb25IaXQgIT09IHZvaWQgMCA/IF9vcHRpb25zJG9uSGl0IDogKCkgPT4ge307XG4gICAgdGhpcy5fb25TZXQgPSAoX29wdGlvbnMkb25TZXQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25TZXQpICE9PSBudWxsICYmIF9vcHRpb25zJG9uU2V0ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRvblNldCA6ICgpID0+IHt9O1xuICAgIHRoaXMuX21hcE5vZGVWYWx1ZSA9IChfb3B0aW9ucyRtYXBOb2RlVmFsdWUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWFwTm9kZVZhbHVlKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRtYXBOb2RlVmFsdWUgIT09IHZvaWQgMCA/IF9vcHRpb25zJG1hcE5vZGVWYWx1ZSA6IHZhbCA9PiB2YWw7XG4gIH1cblxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9udW1MZWFmcztcbiAgfSAvLyAkRmxvd0lzc3VlW3VuY2xlYXItdHlwZV1cblxuXG4gIHJvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG4gIH1cblxuICBnZXQoZ2V0Tm9kZVZhbHVlLCBoYW5kbGVycykge1xuICAgIHZhciBfdGhpcyRnZXRMZWFmTm9kZTtcblxuICAgIHJldHVybiAoX3RoaXMkZ2V0TGVhZk5vZGUgPSB0aGlzLmdldExlYWZOb2RlKGdldE5vZGVWYWx1ZSwgaGFuZGxlcnMpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRMZWFmTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0TGVhZk5vZGUudmFsdWU7XG4gIH1cblxuICBnZXRMZWFmTm9kZShnZXROb2RlVmFsdWUsIGhhbmRsZXJzKSB7XG4gICAgaWYgKHRoaXMuX3Jvb3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IC8vIEl0ZXJhdGUgZG93biB0aGUgdHJlZSBiYXNlZCBvbiB0aGUgY3VycmVudCBub2RlIHZhbHVlcyB1bnRpbCB3ZSBoaXQgYSBsZWFmXG4gICAgLy8gJEZsb3dJc3N1ZVt1bmNsZWFyLXR5cGVdXG5cblxuICAgIGxldCBub2RlID0gdGhpcy5fcm9vdDtcblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBoYW5kbGVycyA9PT0gbnVsbCB8fCBoYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGFuZGxlcnMub25Ob2RlVmlzaXQobm9kZSk7XG5cbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdsZWFmJykge1xuICAgICAgICB0aGlzLl9vbkhpdChub2RlKTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZVZhbHVlID0gdGhpcy5fbWFwTm9kZVZhbHVlKGdldE5vZGVWYWx1ZShub2RlLm5vZGVLZXkpKTtcblxuICAgICAgbm9kZSA9IG5vZGUuYnJhbmNoZXMuZ2V0KG5vZGVWYWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHNldChyb3V0ZSwgdmFsdWUsIGhhbmRsZXJzKSB7XG4gICAgY29uc3QgYWRkTGVhZiA9ICgpID0+IHtcbiAgICAgIHZhciBfbm9kZTIsIF9ub2RlMywgX3RoaXMkX3Jvb3QyLCBfaGFuZGxlcnMkb25Ob2RlVmlzaXQyO1xuXG4gICAgICAvLyBGaXJzdCwgc2V0dXAgdGhlIGJyYW5jaCBub2RlcyBmb3IgdGhlIHJvdXRlOlxuICAgICAgLy8gSXRlcmF0ZSBkb3duIHRoZSB0cmVlIHRvIGZpbmQgb3IgYWRkIGJyYW5jaCBub2RlcyBmb2xsb3dpbmcgdGhlIHJvdXRlXG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGxldCBicmFuY2hLZXk7XG5cbiAgICAgIGZvciAoY29uc3QgW25vZGVLZXksIG5vZGVWYWx1ZV0gb2Ygcm91dGUpIHtcbiAgICAgICAgdmFyIF9ub2RlLCBfaGFuZGxlcnMkb25Ob2RlVmlzaXQsIF90aGlzJF9yb290O1xuXG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyByb290IHdhcyBhIGxlYWYsIHdoaWxlIHdlIG5vdCBoYXZlIGEgZ2V0KCksIGl0IG1lYW5zXG4gICAgICAgIC8vIHRoZSBzZWxlY3RvciBoYXMgaW5jb25zaXN0ZW50IHZhbHVlcyBvciBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkLlxuICAgICAgICBjb25zdCByb290ID0gdGhpcy5fcm9vdDtcblxuICAgICAgICBpZiAoKHJvb3QgPT09IG51bGwgfHwgcm9vdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm9vdC50eXBlKSA9PT0gJ2xlYWYnKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5pbnZhbGlkQ2FjaGVFcnJvcigpO1xuICAgICAgICB9IC8vIG5vZGUgbm93IHJlZmVycyB0byB0aGUgbmV4dCBub2RlIGRvd24gaW4gdGhlIHRyZWVcblxuXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGU7IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXVxuXG4gICAgICAgIG5vZGUgPSBwYXJlbnQgPyBwYXJlbnQuYnJhbmNoZXMuZ2V0KGJyYW5jaEtleSkgOiByb290OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV1cblxuICAgICAgICBub2RlID0gKF9ub2RlID0gbm9kZSkgIT09IG51bGwgJiYgX25vZGUgIT09IHZvaWQgMCA/IF9ub2RlIDoge1xuICAgICAgICAgIHR5cGU6ICdicmFuY2gnLFxuICAgICAgICAgIG5vZGVLZXksXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIGJyYW5jaGVzOiBuZXcgTWFwKCksXG4gICAgICAgICAgYnJhbmNoS2V5XG4gICAgICAgIH07IC8vIElmIHdlIGZvdW5kIGFuIGV4aXN0aW5nIG5vZGUsIGNvbmZpcm0gaXQgaGFzIGEgY29uc2lzdGVudCB2YWx1ZVxuXG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09ICdicmFuY2gnIHx8IG5vZGUubm9kZUtleSAhPT0gbm9kZUtleSkge1xuICAgICAgICAgIHRocm93IHRoaXMuaW52YWxpZENhY2hlRXJyb3IoKTtcbiAgICAgICAgfSAvLyBBZGQgdGhlIGJyYW5jaCBub2RlIHRvIHRoZSB0cmVlXG5cblxuICAgICAgICBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuYnJhbmNoZXMuc2V0KGJyYW5jaEtleSwgbm9kZSk7XG4gICAgICAgIGhhbmRsZXJzID09PSBudWxsIHx8IGhhbmRsZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2hhbmRsZXJzJG9uTm9kZVZpc2l0ID0gaGFuZGxlcnMub25Ob2RlVmlzaXQpID09PSBudWxsIHx8IF9oYW5kbGVycyRvbk5vZGVWaXNpdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2hhbmRsZXJzJG9uTm9kZVZpc2l0LmNhbGwoaGFuZGxlcnMsIG5vZGUpOyAvLyBQcmVwYXJlIGZvciBuZXh0IGl0ZXJhdGlvbiBhbmQgaW5zdGFsbCByb290IGlmIGl0IGlzIG5ldy5cblxuICAgICAgICBicmFuY2hLZXkgPSB0aGlzLl9tYXBOb2RlVmFsdWUobm9kZVZhbHVlKTtcbiAgICAgICAgdGhpcy5fcm9vdCA9IChfdGhpcyRfcm9vdCA9IHRoaXMuX3Jvb3QpICE9PSBudWxsICYmIF90aGlzJF9yb290ICE9PSB2b2lkIDAgPyBfdGhpcyRfcm9vdCA6IG5vZGU7XG4gICAgICB9IC8vIFNlY29uZCwgc2V0dXAgdGhlIGxlYWYgbm9kZTpcbiAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGxlYWYgZm9yIHRoaXMgcm91dGUgY29uZmlybSBpdCBpcyBjb25zaXN0ZW50XG5cblxuICAgICAgY29uc3Qgb2xkTGVhZiA9IG5vZGUgPyAoX25vZGUyID0gbm9kZSkgPT09IG51bGwgfHwgX25vZGUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZTIuYnJhbmNoZXMuZ2V0KGJyYW5jaEtleSkgOiB0aGlzLl9yb290O1xuXG4gICAgICBpZiAob2xkTGVhZiAhPSBudWxsICYmIChvbGRMZWFmLnR5cGUgIT09ICdsZWFmJyB8fCBvbGRMZWFmLmJyYW5jaEtleSAhPT0gYnJhbmNoS2V5KSkge1xuICAgICAgICB0aHJvdyB0aGlzLmludmFsaWRDYWNoZUVycm9yKCk7XG4gICAgICB9IC8vIENyZWF0ZSBhIG5ldyBvciByZXBsYWNlbWVudCBsZWFmLlxuXG5cbiAgICAgIGNvbnN0IGxlYWZOb2RlID0ge1xuICAgICAgICB0eXBlOiAnbGVhZicsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBwYXJlbnQ6IG5vZGUsXG4gICAgICAgIGJyYW5jaEtleVxuICAgICAgfTsgLy8gSW5zdGFsbCB0aGUgbGVhZiBhbmQgY2FsbCBoYW5kbGVyc1xuXG4gICAgICAoX25vZGUzID0gbm9kZSkgPT09IG51bGwgfHwgX25vZGUzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZTMuYnJhbmNoZXMuc2V0KGJyYW5jaEtleSwgbGVhZk5vZGUpO1xuICAgICAgdGhpcy5fcm9vdCA9IChfdGhpcyRfcm9vdDIgPSB0aGlzLl9yb290KSAhPT0gbnVsbCAmJiBfdGhpcyRfcm9vdDIgIT09IHZvaWQgMCA/IF90aGlzJF9yb290MiA6IGxlYWZOb2RlO1xuICAgICAgdGhpcy5fbnVtTGVhZnMrKztcblxuICAgICAgdGhpcy5fb25TZXQobGVhZk5vZGUpO1xuXG4gICAgICBoYW5kbGVycyA9PT0gbnVsbCB8fCBoYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9oYW5kbGVycyRvbk5vZGVWaXNpdDIgPSBoYW5kbGVycy5vbk5vZGVWaXNpdCkgPT09IG51bGwgfHwgX2hhbmRsZXJzJG9uTm9kZVZpc2l0MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2hhbmRsZXJzJG9uTm9kZVZpc2l0Mi5jYWxsKGhhbmRsZXJzLCBsZWFmTm9kZSk7XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBhZGRMZWFmKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIHRoZSBjYWNoZSB3YXMgc3RhbGUgb3Igb2JzZXJ2ZWQgaW5jb25zaXN0ZW50IHZhbHVlcywgc3VjaCBhcyB3aXRoXG4gICAgICAvLyBGYXN0IFJlZnJlc2gsIHRoZW4gY2xlYXIgaXQgYW5kIHJlYnVpbGQgd2l0aCB0aGUgbmV3IHZhbHVlcy5cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENoYW5nZWRQYXRoRXJyb3IpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICBhZGRMZWFmKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUmV0dXJucyB0cnVlIGlmIGxlYWYgd2FzIGFjdHVhbGx5IGRlbGV0ZWQgZnJvbSB0aGUgdHJlZVxuXG5cbiAgZGVsZXRlKGxlYWYpIHtcbiAgICBjb25zdCByb290ID0gdGhpcy5yb290KCk7XG5cbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobGVhZiA9PT0gcm9vdCkge1xuICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgICB0aGlzLl9udW1MZWFmcyA9IDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIEl0ZXJhdGUgdXAgZnJvbSB0aGUgbGVhZiBkZWxldGVpbmcgaXQgZnJvbSBpdCdzIHBhcmVudCdzIGJyYW5jaGVzLlxuXG5cbiAgICBsZXQgbm9kZSA9IGxlYWYucGFyZW50O1xuICAgIGxldCBicmFuY2hLZXkgPSBsZWFmLmJyYW5jaEtleTtcblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICB2YXIgX25vZGU0O1xuXG4gICAgICBub2RlLmJyYW5jaGVzLmRlbGV0ZShicmFuY2hLZXkpOyAvLyBTdG9wIGl0ZXJhdGluZyBpZiB3ZSBoaXQgdGhlIHJvb3QuXG5cbiAgICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICAgIGlmIChub2RlLmJyYW5jaGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9udW1MZWFmcyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbnVtTGVhZnMtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBTdG9wIGl0ZXJhdGluZyBpZiB0aGVyZSBhcmUgb3RoZXIgYnJhbmNoZXMgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgLy8gcmVtb3ZlIGFueSBtb3JlIG5vZGVzLlxuXG5cbiAgICAgIGlmIChub2RlLmJyYW5jaGVzLnNpemUgPiAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBJdGVyYXRlIHVwIHRvIG91ciBwYXJlbnRcblxuXG4gICAgICBicmFuY2hLZXkgPSAoX25vZGU0ID0gbm9kZSkgPT09IG51bGwgfHwgX25vZGU0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZTQuYnJhbmNoS2V5O1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH0gLy8gQ29uZmlybSB0aGF0IHRoZSBsZWFmIHdlIGFyZSBkZWxldGluZyBpcyBhY3R1YWxseSBhdHRhY2hlZCB0byBvdXIgdHJlZVxuXG5cbiAgICBmb3IgKDsgbm9kZSAhPT0gcm9vdDsgbm9kZSA9IG5vZGUucGFyZW50KSB7XG4gICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9udW1MZWFmcy0tO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fbnVtTGVhZnMgPSAwO1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICB9XG5cbiAgaW52YWxpZENhY2hlRXJyb3IoKSB7XG4gICAgY29uc3QgQ0hBTkdFRF9QQVRIX0VSUk9SX01FU1NBR0UgPSBpc0Zhc3RSZWZyZXNoRW5hYmxlZCQyKCkgPyAnUG9zc2libGUgRmFzdCBSZWZyZXNoIG1vZHVsZSByZWxvYWQgZGV0ZWN0ZWQuICAnICsgJ1RoaXMgbWF5IGFsc28gYmUgY2F1c2VkIGJ5IGFuIHNlbGVjdG9yIHJldHVybmluZyBpbmNvbnNpc3RlbnQgdmFsdWVzLiAnICsgJ1Jlc2V0dGluZyBjYWNoZS4nIDogJ0ludmFsaWQgY2FjaGUgdmFsdWVzLiAgVGhpcyBoYXBwZW5zIHdoZW4gc2VsZWN0b3JzIGRvIG5vdCByZXR1cm4gJyArICdjb25zaXN0ZW50IHZhbHVlcyBmb3IgdGhlIHNhbWUgaW5wdXQgZGVwZW5kZW5jeSB2YWx1ZXMuICBUaGF0IG1heSBhbHNvICcgKyAnYmUgY2F1c2VkIHdoZW4gdXNpbmcgRmFzdCBSZWZyZXNoIHRvIGNoYW5nZSBhIHNlbGVjdG9yIGltcGxlbWVudGF0aW9uLiAgJyArICdSZXNldHRpbmcgY2FjaGUuJztcbiAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oQ0hBTkdFRF9QQVRIX0VSUk9SX01FU1NBR0UgKyAodGhpcy5fbmFtZSAhPSBudWxsID8gYCAtICR7dGhpcy5fbmFtZX1gIDogJycpKTtcbiAgICB0aHJvdyBuZXcgQ2hhbmdlZFBhdGhFcnJvcigpO1xuICB9XG5cbn1cblxudmFyIFJlY29pbF9UcmVlQ2FjaGUgPSB7XG4gIFRyZWVDYWNoZVxufTtcblxudmFyIFJlY29pbF9UcmVlQ2FjaGVfMSA9IFJlY29pbF9UcmVlQ2FjaGUuVHJlZUNhY2hlO1xuXG52YXIgUmVjb2lsX1RyZWVDYWNoZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFRyZWVDYWNoZTogUmVjb2lsX1RyZWVDYWNoZV8xXG59KTtcblxuY2xhc3MgTFJVQ2FjaGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zJG1hcEtleTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tYXhTaXplXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2l6ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2hlYWRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90YWlsXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWFwXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfa2V5TWFwcGVyXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLl9tYXhTaXplID0gb3B0aW9ucy5tYXhTaXplO1xuICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgIHRoaXMuX3RhaWwgPSBudWxsO1xuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9rZXlNYXBwZXIgPSAoX29wdGlvbnMkbWFwS2V5ID0gb3B0aW9ucy5tYXBLZXkpICE9PSBudWxsICYmIF9vcHRpb25zJG1hcEtleSAhPT0gdm9pZCAwID8gX29wdGlvbnMkbWFwS2V5IDogdiA9PiB2O1xuICB9XG5cbiAgaGVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZDtcbiAgfVxuXG4gIHRhaWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhaWw7XG4gIH1cblxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplO1xuICB9XG5cbiAgbWF4U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4U2l6ZTtcbiAgfVxuXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyh0aGlzLl9rZXlNYXBwZXIoa2V5KSk7XG4gIH1cblxuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgbWFwcGVkS2V5ID0gdGhpcy5fa2V5TWFwcGVyKGtleSk7XG5cbiAgICBjb25zdCBub2RlID0gdGhpcy5fbWFwLmdldChtYXBwZWRLZXkpO1xuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMuc2V0KGtleSwgbm9kZS52YWx1ZSk7XG4gICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gIH1cblxuICBzZXQoa2V5LCB2YWwpIHtcbiAgICBjb25zdCBtYXBwZWRLZXkgPSB0aGlzLl9rZXlNYXBwZXIoa2V5KTtcblxuICAgIGNvbnN0IGV4aXN0aW5nTm9kZSA9IHRoaXMuX21hcC5nZXQobWFwcGVkS2V5KTtcblxuICAgIGlmIChleGlzdGluZ05vZGUpIHtcbiAgICAgIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGVhZCA9IHRoaXMuaGVhZCgpO1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICBrZXksXG4gICAgICByaWdodDogaGVhZCxcbiAgICAgIGxlZnQ6IG51bGwsXG4gICAgICB2YWx1ZTogdmFsXG4gICAgfTtcblxuICAgIGlmIChoZWFkKSB7XG4gICAgICBoZWFkLmxlZnQgPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90YWlsID0gbm9kZTtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXAuc2V0KG1hcHBlZEtleSwgbm9kZSk7XG5cbiAgICB0aGlzLl9oZWFkID0gbm9kZTtcbiAgICB0aGlzLl9zaXplKys7XG5cbiAgICB0aGlzLl9tYXliZURlbGV0ZUxSVSgpO1xuICB9XG5cbiAgX21heWJlRGVsZXRlTFJVKCkge1xuICAgIGlmICh0aGlzLnNpemUoKSA+IHRoaXMubWF4U2l6ZSgpKSB7XG4gICAgICB0aGlzLmRlbGV0ZUxydSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlbGV0ZUxydSgpIHtcbiAgICBjb25zdCB0YWlsID0gdGhpcy50YWlsKCk7XG5cbiAgICBpZiAodGFpbCkge1xuICAgICAgdGhpcy5kZWxldGUodGFpbC5rZXkpO1xuICAgIH1cbiAgfVxuXG4gIGRlbGV0ZShrZXkpIHtcbiAgICBjb25zdCBtYXBwZWRLZXkgPSB0aGlzLl9rZXlNYXBwZXIoa2V5KTtcblxuICAgIGlmICghdGhpcy5fc2l6ZSB8fCAhdGhpcy5fbWFwLmhhcyhtYXBwZWRLZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZSA9IFJlY29pbF9udWxsdGhyb3dzKHRoaXMuX21hcC5nZXQobWFwcGVkS2V5KSk7XG4gICAgY29uc3QgcmlnaHQgPSBub2RlLnJpZ2h0O1xuICAgIGNvbnN0IGxlZnQgPSBub2RlLmxlZnQ7XG5cbiAgICBpZiAocmlnaHQpIHtcbiAgICAgIHJpZ2h0LmxlZnQgPSBub2RlLmxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKGxlZnQpIHtcbiAgICAgIGxlZnQucmlnaHQgPSBub2RlLnJpZ2h0O1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSB0aGlzLmhlYWQoKSkge1xuICAgICAgdGhpcy5faGVhZCA9IHJpZ2h0O1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSB0aGlzLnRhaWwoKSkge1xuICAgICAgdGhpcy5fdGFpbCA9IGxlZnQ7XG4gICAgfVxuXG4gICAgdGhpcy5fbWFwLmRlbGV0ZShtYXBwZWRLZXkpO1xuXG4gICAgdGhpcy5fc2l6ZS0tO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICB9XG5cbn1cblxudmFyIFJlY29pbF9MUlVDYWNoZSA9IHtcbiAgTFJVQ2FjaGVcbn07XG5cbnZhciBSZWNvaWxfTFJVQ2FjaGVfMSA9IFJlY29pbF9MUlVDYWNoZS5MUlVDYWNoZTtcblxudmFyIFJlY29pbF9MUlVDYWNoZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIExSVUNhY2hlOiBSZWNvaWxfTFJVQ2FjaGVfMVxufSk7XG5cbmNvbnN0IHtcbiAgTFJVQ2FjaGU6IExSVUNhY2hlJDFcbn0gPSBSZWNvaWxfTFJVQ2FjaGUkMTtcblxuY29uc3Qge1xuICBUcmVlQ2FjaGU6IFRyZWVDYWNoZSQxXG59ID0gUmVjb2lsX1RyZWVDYWNoZSQxO1xuXG5mdW5jdGlvbiB0cmVlQ2FjaGVMUlUoe1xuICBuYW1lLFxuICBtYXhTaXplLFxuICBtYXBOb2RlVmFsdWUgPSB2ID0+IHZcbn0pIHtcbiAgY29uc3QgbHJ1Q2FjaGUgPSBuZXcgTFJVQ2FjaGUkMSh7XG4gICAgbWF4U2l6ZVxuICB9KTtcbiAgY29uc3QgY2FjaGUgPSBuZXcgVHJlZUNhY2hlJDEoe1xuICAgIG5hbWUsXG4gICAgbWFwTm9kZVZhbHVlLFxuICAgIG9uSGl0OiBub2RlID0+IHtcbiAgICAgIGxydUNhY2hlLnNldChub2RlLCB0cnVlKTtcbiAgICB9LFxuICAgIG9uU2V0OiBub2RlID0+IHtcbiAgICAgIGNvbnN0IGxydU5vZGUgPSBscnVDYWNoZS50YWlsKCk7XG4gICAgICBscnVDYWNoZS5zZXQobm9kZSwgdHJ1ZSk7XG5cbiAgICAgIGlmIChscnVOb2RlICYmIGNhY2hlLnNpemUoKSA+IG1heFNpemUpIHtcbiAgICAgICAgY2FjaGUuZGVsZXRlKGxydU5vZGUua2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2FjaGU7XG59XG5cbnZhciBSZWNvaWxfdHJlZUNhY2hlTFJVID0gdHJlZUNhY2hlTFJVO1xuXG5jb25zdCBUSU1FX1dBUk5JTkdfVEhSRVNIT0xEX01TID0gMTU7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeSh4LCBvcHQsIGtleSkge1xuICAvLyBBIG9wdGltaXphdGlvbiB0byBhdm9pZCB0aGUgbW9yZSBleHBlbnNpdmUgSlNPTi5zdHJpbmdpZnkoKSBmb3Igc2ltcGxlIHN0cmluZ3NcbiAgLy8gVGhpcyBtYXkgbG9zZSBwcm90ZWN0aW9uIGZvciB1MjAyOCBhbmQgdTIwMjksIHRob3VnaC5cbiAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJyAmJiAheC5pbmNsdWRlcygnXCInKSAmJiAheC5pbmNsdWRlcygnXFxcXCcpKSB7XG4gICAgcmV0dXJuIGBcIiR7eH1cImA7XG4gIH0gLy8gSGFuZGxlIHByaW1pdGl2ZSB0eXBlc1xuXG5cbiAgc3dpdGNoICh0eXBlb2YgeCkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gJyc7XG4gICAgLy8gSlNPTi5zdHJpbmdpZnkodW5kZWZpbmVkKSByZXR1cm5zIHVuZGVmaW5lZCwgYnV0IHdlIGFsd2F5cyB3YW50IHRvIHJldHVybiBhIHN0cmluZ1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4geCA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBjYXNlICdiaWdpbnQnOiAvLyBCaWdJbnQgaXMgbm90IHN1cHBvcnRlZCBpbiB3d3dcbiAgICAgIHJldHVybiBTdHJpbmcoeCk7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgLy8gQWRkIHN1cnJvdW5kaW5nIHF1b3RlcyBhbmQgZXNjYXBlIGludGVybmFsIHF1b3Rlc1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHgpO1xuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgaWYgKChvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuYWxsb3dGdW5jdGlvbnMpICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IFJlY29pbF9lcnIoJ0F0dGVtcHQgdG8gc2VyaWFsaXplIGZ1bmN0aW9uIGluIGEgUmVjb2lsIGNhY2hlIGtleScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYF9fRlVOQ1RJT04oJHt4Lm5hbWV9KV9fYDtcbiAgfVxuXG4gIGlmICh4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfSAvLyBGYWxsYmFjayBjYXNlIGZvciB1bmtub3duIHR5cGVzXG5cblxuICBpZiAodHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgdmFyIF9KU09OJHN0cmluZ2lmeTtcblxuICAgIHJldHVybiAoX0pTT04kc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnkoeCkpICE9PSBudWxsICYmIF9KU09OJHN0cmluZ2lmeSAhPT0gdm9pZCAwID8gX0pTT04kc3RyaW5naWZ5IDogJyc7XG4gIH0gLy8gRGVhbCB3aXRoIGFsbCBwcm9taXNlcyBhcyBlcXVpdmFsZW50IGZvciBub3cuXG5cblxuICBpZiAoUmVjb2lsX2lzUHJvbWlzZSh4KSkge1xuICAgIHJldHVybiAnX19QUk9NSVNFX18nO1xuICB9IC8vIEFycmF5cyBoYW5kbGUgcmVjdXJzaXZlIHN0cmluZ2lmaWNhdGlvblxuXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICByZXR1cm4gYFske3gubWFwKCh2LCBpKSA9PiBzdHJpbmdpZnkodiwgb3B0LCBpLnRvU3RyaW5nKCkpKX1dYDtcbiAgfSAvLyBJZiBhbiBvYmplY3QgZGVmaW5lcyBhIHRvSlNPTigpIG1ldGhvZCwgdGhlbiB1c2UgdGhhdCB0byBvdmVycmlkZSB0aGVcbiAgLy8gc2VyaWFsaXphdGlvbi4gIFRoaXMgbWF0Y2hlcyB0aGUgYmVoYXZpb3Igb2YgSlNPTi5zdHJpbmdpZnkoKS5cbiAgLy8gUGFzcyB0aGUga2V5IGZvciBjb21wYXRpYmlsaXR5LlxuICAvLyBJbW11dGFibGUuanMgY29sbGVjdGlvbnMgZGVmaW5lIHRoaXMgbWV0aG9kIHRvIGFsbG93IHVzIHRvIHNlcmlhbGl6ZSB0aGVtLlxuXG5cbiAgaWYgKHR5cGVvZiB4LnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxuICAgIHJldHVybiBzdHJpbmdpZnkoeC50b0pTT04oa2V5KSwgb3B0LCBrZXkpO1xuICB9IC8vIEZvciBidWlsdC1pbiBNYXBzLCBzb3J0IHRoZSBrZXlzIGluIGEgc3RhYmxlIG9yZGVyIGluc3RlYWQgb2YgdGhlXG4gIC8vIGRlZmF1bHQgaW5zZXJ0aW9uIG9yZGVyLiAgU3VwcG9ydCBub24tc3RyaW5nIGtleXMuXG5cblxuICBpZiAoeCBpbnN0YW5jZW9mIE1hcCkge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgeCkge1xuICAgICAgLy8gU3RyaW5naWZ5IHdpbGwgZXNjYXBlIGFueSBuZXN0ZWQgcXVvdGVzXG4gICAgICBvYmpbdHlwZW9mIGsgPT09ICdzdHJpbmcnID8gayA6IHN0cmluZ2lmeShrLCBvcHQpXSA9IHY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ2lmeShvYmosIG9wdCwga2V5KTtcbiAgfSAvLyBGb3IgYnVpbHQtaW4gU2V0cywgc29ydCB0aGUga2V5cyBpbiBhIHN0YWJsZSBvcmRlciBpbnN0ZWFkIG9mIHRoZVxuICAvLyBkZWZhdWx0IGluc2VydGlvbiBvcmRlci5cblxuXG4gIGlmICh4IGluc3RhbmNlb2YgU2V0KSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShBcnJheS5mcm9tKHgpLnNvcnQoKGEsIGIpID0+IHN0cmluZ2lmeShhLCBvcHQpLmxvY2FsZUNvbXBhcmUoc3RyaW5naWZ5KGIsIG9wdCkpKSwgb3B0LCBrZXkpO1xuICB9IC8vIEFueXRoaW5nIGVsc2UgdGhhdCBpcyBpdGVyYWJsZSBzZXJpYWxpemUgYXMgYW4gQXJyYXkuXG5cblxuICBpZiAoU3ltYm9sICE9PSB1bmRlZmluZWQgJiYgeFtTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgJiYgdHlwZW9mIHhbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxuICAgIHJldHVybiBzdHJpbmdpZnkoQXJyYXkuZnJvbSh4KSwgb3B0LCBrZXkpO1xuICB9IC8vIEZvciBhbGwgb3RoZXIgT2JqZWN0cywgc29ydCB0aGUga2V5cyBpbiBhIHN0YWJsZSBvcmRlci5cblxuXG4gIHJldHVybiBgeyR7T2JqZWN0LmtleXMoeCkuZmlsdGVyKGsgPT4geFtrXSAhPT0gdW5kZWZpbmVkKS5zb3J0KCkgLy8gc3RyaW5naWZ5IHRoZSBrZXkgdG8gYWRkIHF1b3RlcyBhbmQgZXNjYXBlIGFueSBuZXN0ZWQgc2xhc2hlcyBvciBxdW90ZXMuXG4gIC5tYXAoayA9PiBgJHtzdHJpbmdpZnkoaywgb3B0KX06JHtzdHJpbmdpZnkoeFtrXSwgb3B0LCBrKX1gKS5qb2luKCcsJyl9fWA7XG59IC8vIFV0aWxpdHkgc2ltaWxhciB0byBKU09OLnN0cmluZ2lmeSgpIGV4Y2VwdDpcbi8vICogU2VyaWFsaXplIGJ1aWx0LWluIFNldHMgYXMgYW4gQXJyYXlcbi8vICogU2VyaWFsaXplIGJ1aWx0LWluIE1hcHMgYXMgYW4gT2JqZWN0LiAgU3VwcG9ydHMgbm9uLXN0cmluZyBrZXlzLlxuLy8gKiBTZXJpYWxpemUgb3RoZXIgaXRlcmFibGVzIGFzIGFycmF5c1xuLy8gKiBTb3J0IHRoZSBrZXlzIG9mIE9iamVjdHMgYW5kIE1hcHMgdG8gaGF2ZSBhIHN0YWJsZSBvcmRlciBiYXNlZCBvbiBzdHJpbmcgY29udmVyc2lvbi5cbi8vICAgIFRoaXMgb3ZlcnJpZGVzIHRoZWlyIGRlZmF1bHQgaW5zZXJ0aW9uIG9yZGVyLlxuLy8gKiBTdGlsbCB1c2VzIHRvSlNPTigpIG9mIGFueSBvYmplY3QgdG8gb3ZlcnJpZGUgc2VyaWFsaXphdGlvblxuLy8gKiBTdXBwb3J0IFN5bWJvbHMgKHRob3VnaCBkb24ndCBndWFyYW50ZWUgdW5pcXVlbmVzcylcbi8vICogV2UgY291bGQgc3VwcG9ydCBCaWdJbnQsIGJ1dCBGbG93IGRvZXNuJ3Qgc2VlbSB0byBsaWtlIGl0LlxuLy8gU2VlIFJlY29pbF9zdGFibGVTdHJpbmdpZnktdGVzdC5qcyBmb3IgZXhhbXBsZXNcblxuXG5mdW5jdGlvbiBzdGFibGVTdHJpbmdpZnkoeCwgb3B0ID0ge1xuICBhbGxvd0Z1bmN0aW9uczogZmFsc2Vcbn0pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIDogMDtcbiAgICAgIGNvbnN0IHN0ciA9IHN0cmluZ2lmeSh4LCBvcHQpO1xuICAgICAgY29uc3QgZW5kVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6IDA7XG5cbiAgICAgIGlmIChlbmRUaW1lIC0gc3RhcnRUaW1lID4gVElNRV9XQVJOSU5HX1RIUkVTSE9MRF9NUykge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvbm8tY29uc29sZSAqL1xuICAgICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKGBSZWNvaWw6IFNwZW50ICR7ZW5kVGltZSAtIHN0YXJ0VGltZX1tcyBjb21wdXRpbmcgYSBjYWNoZSBrZXlgKTtcbiAgICAgICAgY29uc29sZS53YXJuKHgsIHN0cik7XG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBmYi13d3cvbm8tY29uc29sZSAqL1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnkoeCwgb3B0KTtcbn1cblxudmFyIFJlY29pbF9zdGFibGVTdHJpbmdpZnkgPSBzdGFibGVTdHJpbmdpZnk7XG5cbmNvbnN0IHtcbiAgVHJlZUNhY2hlOiBUcmVlQ2FjaGUkMlxufSA9IFJlY29pbF9UcmVlQ2FjaGUkMTtcblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IGRlZmF1bHRQb2xpY3kgPSB7XG4gIGVxdWFsaXR5OiAncmVmZXJlbmNlJyxcbiAgZXZpY3Rpb246ICdrZWVwLWFsbCcsXG4gIG1heFNpemU6IEluZmluaXR5XG59O1xuXG5mdW5jdGlvbiB0cmVlQ2FjaGVGcm9tUG9saWN5KHtcbiAgZXF1YWxpdHkgPSBkZWZhdWx0UG9saWN5LmVxdWFsaXR5LFxuICBldmljdGlvbiA9IGRlZmF1bHRQb2xpY3kuZXZpY3Rpb24sXG4gIG1heFNpemUgPSBkZWZhdWx0UG9saWN5Lm1heFNpemVcbn0gPSBkZWZhdWx0UG9saWN5LCBuYW1lKSB7XG4gIGNvbnN0IHZhbHVlTWFwcGVyID0gZ2V0VmFsdWVNYXBwZXIoZXF1YWxpdHkpO1xuICByZXR1cm4gZ2V0VHJlZUNhY2hlKGV2aWN0aW9uLCBtYXhTaXplLCB2YWx1ZU1hcHBlciwgbmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlTWFwcGVyKGVxdWFsaXR5KSB7XG4gIHN3aXRjaCAoZXF1YWxpdHkpIHtcbiAgICBjYXNlICdyZWZlcmVuY2UnOlxuICAgICAgcmV0dXJuIHZhbCA9PiB2YWw7XG5cbiAgICBjYXNlICd2YWx1ZSc6XG4gICAgICByZXR1cm4gdmFsID0+IFJlY29pbF9zdGFibGVTdHJpbmdpZnkodmFsKTtcbiAgfVxuXG4gIHRocm93IFJlY29pbF9lcnIoYFVucmVjb2duaXplZCBlcXVhbGl0eSBwb2xpY3kgJHtlcXVhbGl0eX1gKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJlZUNhY2hlKGV2aWN0aW9uLCBtYXhTaXplLCBtYXBOb2RlVmFsdWUsIG5hbWUpIHtcbiAgc3dpdGNoIChldmljdGlvbikge1xuICAgIGNhc2UgJ2tlZXAtYWxsJzpcbiAgICAgIHJldHVybiBuZXcgVHJlZUNhY2hlJDIoe1xuICAgICAgICBuYW1lLFxuICAgICAgICBtYXBOb2RlVmFsdWVcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnbHJ1JzpcbiAgICAgIHJldHVybiBSZWNvaWxfdHJlZUNhY2hlTFJVKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgbWF4U2l6ZTogUmVjb2lsX251bGx0aHJvd3MobWF4U2l6ZSksXG4gICAgICAgIG1hcE5vZGVWYWx1ZVxuICAgICAgfSk7XG5cbiAgICBjYXNlICdtb3N0LXJlY2VudCc6XG4gICAgICByZXR1cm4gUmVjb2lsX3RyZWVDYWNoZUxSVSh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIG1heFNpemU6IDEsXG4gICAgICAgIG1hcE5vZGVWYWx1ZVxuICAgICAgfSk7XG4gIH1cblxuICB0aHJvdyBSZWNvaWxfZXJyKGBVbnJlY29nbml6ZWQgZXZpY3Rpb24gcG9saWN5ICR7ZXZpY3Rpb259YCk7XG59XG5cbnZhciBSZWNvaWxfdHJlZUNhY2hlRnJvbVBvbGljeSA9IHRyZWVDYWNoZUZyb21Qb2xpY3k7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIGlzTm9kZShvYmplY3QpIHtcbiAgdmFyIF9vd25lckRvY3VtZW50LCBfZG9jJGRlZmF1bHRWaWV3O1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGRvYyA9IG9iamVjdCAhPSBudWxsID8gKF9vd25lckRvY3VtZW50ID0gb2JqZWN0Lm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9vd25lckRvY3VtZW50ICE9PSB2b2lkIDAgPyBfb3duZXJEb2N1bWVudCA6IG9iamVjdCA6IGRvY3VtZW50O1xuICBjb25zdCBkZWZhdWx0VmlldyA9IChfZG9jJGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3KSAhPT0gbnVsbCAmJiBfZG9jJGRlZmF1bHRWaWV3ICE9PSB2b2lkIDAgPyBfZG9jJGRlZmF1bHRWaWV3IDogd2luZG93O1xuICByZXR1cm4gISEob2JqZWN0ICE9IG51bGwgJiYgKHR5cGVvZiBkZWZhdWx0Vmlldy5Ob2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgZGVmYXVsdFZpZXcuTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbnZhciBSZWNvaWxfaXNOb2RlID0gaXNOb2RlO1xuXG5jb25zdCB7XG4gIGlzUmVhY3ROYXRpdmU6IGlzUmVhY3ROYXRpdmUkMSxcbiAgaXNXaW5kb3c6IGlzV2luZG93JDFcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XG5cblxuXG5cblxuZnVuY3Rpb24gc2hvdWxkTm90QmVGcm96ZW4odmFsdWUpIHtcbiAgLy8gUHJpbWl0aXZlcyBhbmQgZnVuY3Rpb25zOlxuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIFJlYWN0IGVsZW1lbnRzOlxuXG5cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUuJCR0eXBlb2YpIHtcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSW1tdXRhYmxlIHN0cnVjdHVyZXM6XG5cblxuICBpZiAodmFsdWVbJ0BAX19JTU1VVEFCTEVfSVRFUkFCTEVfX0BAJ10gIT0gbnVsbCB8fCB2YWx1ZVsnQEBfX0lNTVVUQUJMRV9LRVlFRF9fQEAnXSAhPSBudWxsIHx8IHZhbHVlWydAQF9fSU1NVVRBQkxFX0lOREVYRURfX0BAJ10gIT0gbnVsbCB8fCB2YWx1ZVsnQEBfX0lNTVVUQUJMRV9PUkRFUkVEX19AQCddICE9IG51bGwgfHwgdmFsdWVbJ0BAX19JTU1VVEFCTEVfUkVDT1JEX19AQCddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBET00gbm9kZXM6XG5cblxuICBpZiAoUmVjb2lsX2lzTm9kZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChSZWNvaWxfaXNQcm9taXNlKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gU29tZSBlbnZpcm9ubWVudHMsIGp1c3QgYXMgSmVzdCwgZG9uJ3Qgd29yayB3aXRoIHRoZSBpbnN0YW5jZW9mIGNoZWNrXG5cblxuICBpZiAoIWlzUmVhY3ROYXRpdmUkMSAmJiBpc1dpbmRvdyQxKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBSZWN1cnNpdmVseSBmcmVlemUgYSB2YWx1ZSB0byBlbmZvcmNlIGl0IGlzIHJlYWQtb25seS5cbi8vIFRoaXMgbWF5IGFsc28gaGF2ZSBtaW5pbWFsIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50cyBmb3IgZW51bWVyYXRpbmdcbi8vIG9iamVjdHMgKGJhc2VkIG9uIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zLCBvZiBjb3Vyc2UpXG5cblxuZnVuY3Rpb24gZGVlcEZyZWV6ZVZhbHVlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHNob3VsZE5vdEJlRnJvemVuKHZhbHVlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIE9iamVjdC5mcmVlemUodmFsdWUpOyAvLyBNYWtlIGFsbCBwcm9wZXJ0aWVzIHJlYWQtb25seVxuXG4gIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgLy8gJEZsb3dJc3N1ZVttZXRob2QtdW5iaW5kaW5nXSBhZGRlZCB3aGVuIGltcHJvdmluZyB0eXBpbmcgZm9yIHRoaXMgcGFyYW1ldGVyc1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIGNvbnN0IHByb3AgPSB2YWx1ZVtrZXldOyAvLyBQcmV2ZW50IGluZmluaXRlIHJlY3Vyc3Npb24gZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ29iamVjdCcgJiYgcHJvcCAhPSBudWxsICYmICFPYmplY3QuaXNGcm96ZW4ocHJvcCkpIHtcbiAgICAgICAgZGVlcEZyZWV6ZVZhbHVlKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5zZWFsKHZhbHVlKTsgLy8gVGhpcyBhbHNvIG1ha2VzIGV4aXN0aW5nIHByb3BlcnRpZXMgbm9uLWNvbmZpZ3VyYWJsZS5cbn1cblxudmFyIFJlY29pbF9kZWVwRnJlZXplVmFsdWUgPSBkZWVwRnJlZXplVmFsdWU7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogVGhpcyBpcyBhIHN0dWIgZm9yIHNvbWUgaW50ZWdyYXRpb24gaW50byBGQiBpbnRlcm5hbCBzdHVmZlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuZnVuY3Rpb24gc3RhcnRQZXJmQmxvY2soX2lkKSB7XG4gIHJldHVybiAoKSA9PiBudWxsO1xufVxuXG52YXIgUmVjb2lsX1BlcmZvcm1hbmNlVGltaW5ncyA9IHtcbiAgc3RhcnRQZXJmQmxvY2tcbn07XG5cbmNvbnN0IHtcbiAgaXNMb2FkYWJsZTogaXNMb2FkYWJsZSQxLFxuICBsb2FkYWJsZVdpdGhFcnJvcjogbG9hZGFibGVXaXRoRXJyb3IkMSxcbiAgbG9hZGFibGVXaXRoUHJvbWlzZTogbG9hZGFibGVXaXRoUHJvbWlzZSQxLFxuICBsb2FkYWJsZVdpdGhWYWx1ZTogbG9hZGFibGVXaXRoVmFsdWUkMlxufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xuXG5jb25zdCB7XG4gIFdyYXBwZWRWYWx1ZTogV3JhcHBlZFZhbHVlJDFcbn0gPSBSZWNvaWxfV3JhcHBlciQxO1xuXG5cblxuY29uc3Qge1xuICBnZXROb2RlTG9hZGFibGU6IGdldE5vZGVMb2FkYWJsZSQyLFxuICBwZWVrTm9kZUxvYWRhYmxlOiBwZWVrTm9kZUxvYWRhYmxlJDEsXG4gIHNldE5vZGVWYWx1ZTogc2V0Tm9kZVZhbHVlJDNcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgc2F2ZURlcHNUb1N0b3JlOiBzYXZlRGVwc1RvU3RvcmUkMVxufSA9IFJlY29pbF9HcmFwaDtcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDYsXG4gIGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlcjogZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDEsXG4gIGdldE5vZGU6IGdldE5vZGUkNixcbiAgcmVnaXN0ZXJOb2RlOiByZWdpc3Rlck5vZGUkMVxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkM1xufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xuXG5jb25zdCB7XG4gIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkOiBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdDogcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0JDFcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5jb25zdCB7XG4gIHJlY29pbENhbGxiYWNrOiByZWNvaWxDYWxsYmFjayQxXG59ID0gUmVjb2lsX3VzZVJlY29pbENhbGxiYWNrO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCB7XG4gIHN0YXJ0UGVyZkJsb2NrOiBzdGFydFBlcmZCbG9jayQxXG59ID0gUmVjb2lsX1BlcmZvcm1hbmNlVGltaW5ncztcblxuXG5cbmNsYXNzIENhbmNlbGVkIHt9XG5cbmNvbnN0IENBTkNFTEVEID0gbmV3IENhbmNlbGVkKCk7XG4vKipcbiAqIEFuIEV4ZWN1dGlvbklEIGlzIGFuIGFyYml0cmFyeSBJRCB0aGF0IGxldHMgdXMgZGlzdGluZ3Vpc2ggZXhlY3V0aW9ucyBmcm9tXG4gKiBlYWNoIG90aGVyLiBUaGlzIGlzIG5lY2Vzc2FyeSBhcyB3ZSBuZWVkIGEgd2F5IG9mIHNvbHZpbmcgdGhpcyBwcm9ibGVtOlxuICogXCJnaXZlbiAzIGFzeW5jIGV4ZWN1dGlvbnMsIG9ubHkgdXBkYXRlIHN0YXRlIGZvciB0aGUgJ2xhdGVzdCcgZXhlY3V0aW9uIHdoZW5cbiAqIGl0IGZpbmlzaGVzIHJ1bm5pbmcgcmVnYXJkbGVzcyBvZiB3aGVuIHRoZSBvdGhlciAyIGZpbmlzaFwiLiBFeGVjdXRpb25JRHNcbiAqIHByb3ZpZGUgYSBjb252ZW5pZW50IHdheSBvZiBpZGVudGlmeWluZyBleGVjdXRpb25zIHNvIHRoYXQgd2UgY2FuIHRyYWNrIGFuZFxuICogbWFuYWdlIHRoZW0gb3ZlciB0aW1lLlxuICovXG5cbmNvbnN0IGRlcGVuZGVuY3lTdGFjayA9IFtdOyAvLyBmb3IgZGV0ZWN0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cblxuY29uc3Qgd2FpdGluZ1N0b3JlcyA9IG5ldyBNYXAoKTtcblxuY29uc3QgZ2V0TmV3RXhlY3V0aW9uSUQgPSAoKCkgPT4ge1xuICBsZXQgZXhlY3V0aW9uSUQgPSAwO1xuICByZXR1cm4gKCkgPT4gZXhlY3V0aW9uSUQrKztcbn0pKCk7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZWRlY2xhcmUgKi9cblxuXG5mdW5jdGlvbiBzZWxlY3RvcihvcHRpb25zKSB7XG4gIGxldCByZWNvaWxWYWx1ZSA9IG51bGw7XG4gIGNvbnN0IHtcbiAgICBrZXksXG4gICAgZ2V0LFxuICAgIGNhY2hlUG9saWN5X1VOU1RBQkxFOiBjYWNoZVBvbGljeVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc2V0ID0gb3B0aW9ucy5zZXQgIT0gbnVsbCA/IG9wdGlvbnMuc2V0IDogdW5kZWZpbmVkOyAvLyBmbG93XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycignQSBrZXkgb3B0aW9uIHdpdGggYSB1bmlxdWUgc3RyaW5nIHZhbHVlIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBjcmVhdGluZyBhIHNlbGVjdG9yLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKCdTZWxlY3RvcnMgbXVzdCBzcGVjaWZ5IGEgZ2V0IGNhbGxiYWNrIG9wdGlvbiB0byBnZXQgdGhlIHNlbGVjdG9yIHZhbHVlLicpO1xuICAgIH1cbiAgfSAvLyBUaGlzIGlzIGV2ZXJ5IGRpc2NvdmVyZWQgZGVwZW5kZW5jeSBhY3Jvc3MgYWxsIGV4ZWN1dGlvbnNcblxuXG4gIGNvbnN0IGRpc2NvdmVyZWREZXBlbmRlbmN5Tm9kZUtleXMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGNhY2hlID0gUmVjb2lsX3RyZWVDYWNoZUZyb21Qb2xpY3koY2FjaGVQb2xpY3kgIT09IG51bGwgJiYgY2FjaGVQb2xpY3kgIT09IHZvaWQgMCA/IGNhY2hlUG9saWN5IDoge1xuICAgIGVxdWFsaXR5OiAncmVmZXJlbmNlJyxcbiAgICBldmljdGlvbjogJ2tlZXAtYWxsJ1xuICB9LCBrZXkpO1xuICBjb25zdCByZXRhaW5lZEJ5ID0gcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0JDEob3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFKTtcbiAgY29uc3QgZXhlY3V0aW9uSW5mb01hcCA9IG5ldyBNYXAoKTtcbiAgbGV0IGxpdmVTdG9yZXNDb3VudCA9IDA7XG5cbiAgZnVuY3Rpb24gc2VsZWN0b3JJc0xpdmUoKSB7XG4gICAgcmV0dXJuICFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpIHx8IGxpdmVTdG9yZXNDb3VudCA+IDA7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RvckluaXQoc3RvcmUpIHtcbiAgICBzdG9yZS5nZXRTdGF0ZSgpLmtub3duU2VsZWN0b3JzLmFkZChrZXkpO1xuICAgIGxpdmVTdG9yZXNDb3VudCsrO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXZlU3RvcmVzQ291bnQtLTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0b3JTaG91bGREZWxldGVDb25maWdPblJlbGVhc2UoKSB7XG4gICAgcmV0dXJuIGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQxKGtleSkgIT09IHVuZGVmaW5lZCAmJiAhc2VsZWN0b3JJc0xpdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVBc3luYyhzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklELCBsb2FkYWJsZSwgZGVwVmFsdWVzKSB7XG4gICAgc2V0Q2FjaGUoc3RhdGUsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpO1xuICAgIG5vdGlmeVN0b3Jlc09mUmVzb2x2ZWRBc3luYyhzdG9yZSwgZXhlY3V0aW9uSUQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5U3RvcmVzT2ZSZXNvbHZlZEFzeW5jKHN0b3JlLCBleGVjdXRpb25JRCkge1xuICAgIGlmIChpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpKSB7XG4gICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xuICAgIH1cblxuICAgIG5vdGlmeVdhaXRpbmdTdG9yZXMoZXhlY3V0aW9uSUQsIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBOb3RpZnkgc3RvcmVzIHRvIHB1bGwgdGhlIHNlbGVjdG9yIGFnYWluIGlmIGEgbmV3IGFzeW5jIGRlcCB3YXMgZGlzY292ZXJlZC5cbiAgICogMSkgQXN5bmMgc2VsZWN0b3IgYWRkcyBhIG5ldyBkZXAgYnV0IGRvZXNuJ3QgcmVzb2x2ZSB5ZXQuXG4gICAqICAgIE5vdGUgdGhhdCBkZXBzIGZvciBhbiBhc3luYyBzZWxlY3RvciBhcmUgYmFzZWQgb24gdGhlIHN0YXRlIHdoZW4gdGhlXG4gICAqICAgIGV2YWx1YXRpb24gc3RhcnRlZCwgaW4gb3JkZXIgdG8gcHJvdmlkZSBhIGNvbnNpc3RlbnQgcGljdHVyZSBvZiBzdGF0ZS5cbiAgICogMikgQnV0LCBuZXcgdmFsdWUgb2YgZGVwIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIG1pZ2h0IGNhdXNlIHRoZSBzZWxlY3RvclxuICAgKiAgICB0byByZXNvbHZlIG9yIHJlc29sdmUgZGlmZmVyZW50bHkuXG4gICAqIDMpIFRoZXJlZm9yZSwgdGhpcyBub3RpZmljYXRpb24gd2lsbCBwdWxsIHRoZSBzZWxlY3RvciBiYXNlZCBvbiB0aGUgY3VycmVudFxuICAgKiAgICBzdGF0ZSBmb3IgdGhlIGNvbXBvbmVudHNcbiAgICovXG5cblxuICBmdW5jdGlvbiBub3RpZnlTdG9yZXNPZk5ld0FzeW5jRGVwKHN0b3JlLCBleGVjdXRpb25JRCkge1xuICAgIGlmIChpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpKSB7XG4gICAgICBjb25zdCBleGVjdXRpb25JbmZvID0gUmVjb2lsX251bGx0aHJvd3MoZ2V0RXhlY3V0aW9uSW5mbyhzdG9yZSkpO1xuICAgICAgZXhlY3V0aW9uSW5mby5zdGF0ZVZlcnNpb25zLmNsZWFyKCk7XG4gICAgICBub3RpZnlXYWl0aW5nU3RvcmVzKGV4ZWN1dGlvbklELCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5V2FpdGluZ1N0b3JlcyhleGVjdXRpb25JRCwgY2xlYXJXYWl0bGlzdCkge1xuICAgIGNvbnN0IHN0b3JlcyA9IHdhaXRpbmdTdG9yZXMuZ2V0KGV4ZWN1dGlvbklEKTtcblxuICAgIGlmIChzdG9yZXMgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCB3YWl0aW5nU3RvcmUgb2Ygc3RvcmVzKSB7XG4gICAgICAgIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDEod2FpdGluZ1N0b3JlLCBSZWNvaWxfbnVsbHRocm93cyhyZWNvaWxWYWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xlYXJXYWl0bGlzdCkge1xuICAgICAgICB3YWl0aW5nU3RvcmVzLmRlbGV0ZShleGVjdXRpb25JRCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1N0b3JlV2FpdGluZ0ZvclJlc29sdmVkQXN5bmMoc3RvcmUsIGV4ZWN1dGlvbklEKSB7XG4gICAgbGV0IHN0b3JlcyA9IHdhaXRpbmdTdG9yZXMuZ2V0KGV4ZWN1dGlvbklEKTtcblxuICAgIGlmIChzdG9yZXMgPT0gbnVsbCkge1xuICAgICAgd2FpdGluZ1N0b3Jlcy5zZXQoZXhlY3V0aW9uSUQsIHN0b3JlcyA9IG5ldyBTZXQoKSk7XG4gICAgfVxuXG4gICAgc3RvcmVzLmFkZChzdG9yZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYXR0YWNoZXMgYSB0aGVuKCkgYW5kIGEgY2F0Y2goKSB0byBhIHByb21pc2UgdGhhdCB3YXNcbiAgICogcmV0dXJuZWQgZnJvbSBhIHNlbGVjdG9yJ3MgZ2V0KCkgKGVpdGhlciBleHBsaWNpdGx5IG9yIGltcGxpY2l0bHkgYnlcbiAgICogcnVubmluZyBhIGZ1bmN0aW9uIHRoYXQgdXNlcyB0aGUgXCJhc3luY1wiIGtleXdvcmQpLiBJZiBhIHNlbGVjdG9yJ3MgZ2V0KClcbiAgICogcmV0dXJucyBhIHByb21pc2UsIHdlIGhhdmUgdHdvIHBvc3NpYmlsaXRpZXM6XG4gICAqXG4gICAqIDEuIFRoZSBwcm9taXNlIHdpbGwgcmVzb2x2ZSwgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGhhdmUgY29tcGxldGVseSBmaW5pc2hlZFxuICAgKiAgICBleGVjdXRpbmcgd2l0aG91dCBhbnkgcmVtYWluaW5nIHBlbmRpbmcgZGVwZW5kZW5jaWVzLiBObyBtb3JlIHJldHJpZXNcbiAgICogICAgYXJlIG5lZWRlZCBhbmQgd2UgY2FuIHByb2NlZWQgd2l0aCB1cGRhdGluZyB0aGUgY2FjaGUgYW5kIG5vdGlmeWluZ1xuICAgKiAgICBzdWJzY3JpYmVycyAoaWYgaXQgaXMgdGhlIGxhdGVzdCBleGVjdXRpb24sIG90aGVyd2lzZSBvbmx5IHRoZSBjYWNoZVxuICAgKiAgICB3aWxsIGJlIHVwZGF0ZWQgYW5kIHN1YnNjcmlwdGlvbnMgd2lsbCBub3QgYmUgZmlyZWQpLiBUaGlzIGlzIHRoZSBjYXNlXG4gICAqICAgIGhhbmRsZWQgYnkgdGhlIGF0dGFjaGVkIHRoZW4oKSBoYW5kbGVyLlxuICAgKlxuICAgKiAyLiBUaGUgcHJvbWlzZSB3aWxsIHRocm93IGJlY2F1c2UgaXQgZWl0aGVyIGhhcyBhbiBlcnJvciBvciBpdCBjYW1lIGFjcm9zc1xuICAgKiAgICBhbiBhc3luYyBkZXBlbmRlbmN5IHRoYXQgaGFzIG5vdCB5ZXQgcmVzb2x2ZWQsIGluIHdoaWNoIGNhc2Ugd2Ugd2lsbFxuICAgKiAgICBjYWxsIHdyYXBEZXBkZW5jeVByb21pc2UoKSwgd2hvc2UgcmVzcG9uc2liaWxpdHkgaXMgdG8gaGFuZGxlIGRlcGVuZGVuY3lcbiAgICogICAgcHJvbWlzZXMuIFRoaXMgY2FzZSBpcyBoYW5kbGVkIGJ5IHRoZSBhdHRhY2hlZCBjYXRjaCgpIGhhbmRsZXIuXG4gICAqXG4gICAqIEJvdGggYnJhbmNoZXMgd2lsbCBldmVudHVhbGx5IHJlc29sdmUgdG8gdGhlIGZpbmFsIHJlc3VsdCBvZiB0aGUgc2VsZWN0b3JcbiAgICogKG9yIGFuIGVycm9yIGlmIGEgcmVhbCBlcnJvciBvY2N1cnJlZCkuXG4gICAqXG4gICAqIFRoZSBleGVjdXRpb24gd2lsbCBydW4gdG8gY29tcGxldGlvbiBldmVuIGlmIGl0IGlzIHN0YWxlLCBhbmQgaXRzIHZhbHVlXG4gICAqIHdpbGwgYmUgY2FjaGVkLiBCdXQgc3RhbGUgZXhlY3V0aW9ucyB3aWxsIG5vdCB1cGRhdGUgZ2xvYmFsIHN0YXRlIG9yIHVwZGF0ZVxuICAgKiBleGVjdXRpb25JbmZvIGFzIHRoYXQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSAnbGF0ZXN0JyBleGVjdXRpb24uXG4gICAqXG4gICAqIE5vdGUgdGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIHBhc3NlZCBhIHByb21pc2UgdGhhdCB3YXMgdGhyb3duLS1BS0EgYVxuICAgKiBkZXBlbmRlbmN5IHByb21pc2UuIERlcGVuZGVuY3kgcHJvbWlzZXMgc2hvdWxkIGJlIHBhc3NlZCB0b1xuICAgKiB3cmFwUGVuZGluZ0RlcGVuZGVuY3lQcm9taXNlKCkpLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHdyYXBSZXN1bHRQcm9taXNlKHN0b3JlLCBwcm9taXNlLCBzdGF0ZSwgZGVwVmFsdWVzLCBleGVjdXRpb25JRCwgbG9hZGluZ0RlcHNTdGF0ZSkge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgaWYgKCFzZWxlY3RvcklzTGl2ZSgpKSB7XG4gICAgICAgIC8vIFRoZSBzZWxlY3RvciB3YXMgcmVsZWFzZWQgc2luY2UgdGhlIHJlcXVlc3QgYmVnYW47IGlnbm9yZSB0aGUgcmVzcG9uc2UuXG4gICAgICAgIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSk7XG4gICAgICAgIHRocm93IENBTkNFTEVEO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2FkYWJsZSA9IGxvYWRhYmxlV2l0aFZhbHVlJDIodmFsdWUpO1xuICAgICAgcmVzb2x2ZUFzeW5jKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pLmNhdGNoKGVycm9yT3JQcm9taXNlID0+IHtcbiAgICAgIGlmICghc2VsZWN0b3JJc0xpdmUoKSkge1xuICAgICAgICAvLyBUaGUgc2VsZWN0b3Igd2FzIHJlbGVhc2VkIHNpbmNlIHRoZSByZXF1ZXN0IGJlZ2FuOyBpZ25vcmUgdGhlIHJlc3BvbnNlLlxuICAgICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xuICAgICAgICB0aHJvdyBDQU5DRUxFRDtcbiAgICAgIH1cblxuICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UoZXJyb3JPclByb21pc2UpKSB7XG4gICAgICAgIHJldHVybiB3cmFwUGVuZGluZ0RlcGVuZGVuY3lQcm9taXNlKHN0b3JlLCBlcnJvck9yUHJvbWlzZSwgc3RhdGUsIGRlcFZhbHVlcywgZXhlY3V0aW9uSUQsIGxvYWRpbmdEZXBzU3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2FkYWJsZSA9IGxvYWRhYmxlV2l0aEVycm9yJDEoZXJyb3JPclByb21pc2UpO1xuICAgICAgcmVzb2x2ZUFzeW5jKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpO1xuICAgICAgdGhyb3cgZXJyb3JPclByb21pc2U7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYXR0YWNoZXMgYSB0aGVuKCkgYW5kIGEgY2F0Y2goKSB0byBhIHByb21pc2UgdGhhdCB3YXNcbiAgICogdGhyb3duIGZyb20gYSBzZWxlY3RvcidzIGdldCgpLiBJZiBhIHNlbGVjdG9yJ3MgZ2V0KCkgdGhyb3dzIGEgcHJvbWlzZSxcbiAgICogd2UgaGF2ZSB0d28gcG9zc2liaWxpdGllczpcbiAgICpcbiAgICogMS4gVGhlIHByb21pc2Ugd2lsbCByZXNvbHZlLCBtZWFuaW5nIG9uZSBvZiBvdXIgc2VsZWN0b3IncyBkZXBlbmRlbmNpZXMgaXNcbiAgICogICAgbm93IGF2YWlsYWJsZSBhbmQgd2Ugc2hvdWxkIFwicmV0cnlcIiBvdXIgZ2V0KCkgYnkgcnVubmluZyBpdCBhZ2Fpbi4gVGhpc1xuICAgKiAgICBpcyB0aGUgY2FzZSBoYW5kbGVkIGJ5IHRoZSBhdHRhY2hlZCB0aGVuKCkgaGFuZGxlci5cbiAgICpcbiAgICogMi4gVGhlIHByb21pc2Ugd2lsbCB0aHJvdyBiZWNhdXNlIHNvbWV0aGluZyB3ZW50IHdyb25nIHdpdGggdGhlIGRlcGVuZGVuY3lcbiAgICogICAgcHJvbWlzZSAoaW4gb3RoZXIgd29yZHMgYSByZWFsIGVycm9yIG9jY3VycmVkKS4gVGhpcyBjYXNlIGlzIGhhbmRsZWQgYnlcbiAgICogICAgdGhlIGF0dGFjaGVkIGNhdGNoKCkgaGFuZGxlci4gSWYgdGhlIGRlcGVuZGVuY3kgcHJvbWlzZSB0aHJvd3MsIGl0IGlzXG4gICAqICAgIF9hbHdheXNfIGEgcmVhbCBlcnJvciBhbmQgbm90IGFub3RoZXIgZGVwZW5kZW5jeSBwcm9taXNlIChhbnkgZGVwZW5kZW5jeVxuICAgKiAgICBwcm9taXNlcyB3b3VsZCBoYXZlIGJlZW4gaGFuZGxlZCB1cHN0cmVhbSkuXG4gICAqXG4gICAqIFRoZSB0aGVuKCkgYnJhbmNoIHdpbGwgZXZlbnR1YWxseSByZXNvbHZlIHRvIHRoZSBmaW5hbCByZXN1bHQgb2YgdGhlXG4gICAqIHNlbGVjdG9yIChvciBhbiBlcnJvciBpZiBhIHJlYWwgZXJyb3Igb2NjdXJzKSwgYW5kIHRoZSBjYXRjaCgpIHdpbGwgYWx3YXlzXG4gICAqIHJlc29sdmUgdG8gYW4gZXJyb3IgYmVjYXVzZSB0aGUgZGVwZW5kZW5jeSBwcm9taXNlIGlzIGEgcHJvbWlzZSB0aGF0IHdhc1xuICAgKiB3cmFwcGVkIHVwc3RyZWFtLCBtZWFuaW5nIGl0IHdpbGwgb25seSByZXNvbHZlIHRvIGl0cyByZWFsIHZhbHVlIG9yIHRvIGFcbiAgICogcmVhbCBlcnJvci5cbiAgICpcbiAgICogVGhlIGV4ZWN1dGlvbiB3aWxsIHJ1biB0byBjb21wbGV0aW9uIGV2ZW4gaWYgaXQgaXMgc3RhbGUsIGFuZCBpdHMgdmFsdWVcbiAgICogd2lsbCBiZSBjYWNoZWQuIEJ1dCBzdGFsZSBleGVjdXRpb25zIHdpbGwgbm90IHVwZGF0ZSBnbG9iYWwgc3RhdGUgb3IgdXBkYXRlXG4gICAqIGV4ZWN1dGlvbkluZm8gYXMgdGhhdCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlICdsYXRlc3QnIGV4ZWN1dGlvbi5cbiAgICpcbiAgICogTm90ZSB0aGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgcGFzc2VkIGEgcHJvbWlzZSB0aGF0IHdhcyByZXR1cm5lZCBmcm9tXG4gICAqIGdldCgpLiBUaGUgaW50ZW50aW9uIGlzIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IHBhc3NlZCBwcm9taXNlcyB0aGF0XG4gICAqIHdlcmUgdGhyb3duIGR1ZSB0byBhIHBlbmRpbmcgZGVwZW5kZW5jeS4gUHJvbWlzZXMgcmV0dXJuZWQgYnkgZ2V0KCkgc2hvdWxkXG4gICAqIGJlIHBhc3NlZCB0byB3cmFwUmVzdWx0UHJvbWlzZSgpIGluc3RlYWQuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gd3JhcFBlbmRpbmdEZXBlbmRlbmN5UHJvbWlzZShzdG9yZSwgcHJvbWlzZSwgc3RhdGUsIGV4aXN0aW5nRGVwcywgZXhlY3V0aW9uSUQsIGxvYWRpbmdEZXBzU3RhdGUpIHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKHJlc29sdmVkRGVwID0+IHtcbiAgICAgIGlmICghc2VsZWN0b3JJc0xpdmUoKSkge1xuICAgICAgICAvLyBUaGUgc2VsZWN0b3Igd2FzIHJlbGVhc2VkIHNpbmNlIHRoZSByZXF1ZXN0IGJlZ2FuOyBpZ25vcmUgdGhlIHJlc3BvbnNlLlxuICAgICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xuICAgICAgICB0aHJvdyBDQU5DRUxFRDtcbiAgICAgIH0gLy8gQ2hlY2sgaWYgd2UgYXJlIGhhbmRsaW5nIGEgcGVuZGluZyBSZWNvaWwgZGVwZW5kZW5jeSBvciBpZiB0aGUgdXNlclxuICAgICAgLy8gdGhyZXcgdGhlaXIgb3duIFByb21pc2UgdG8gXCJzdXNwZW5kXCIgYSBzZWxlY3RvciBldmFsdWF0aW9uLiAgV2UgbmVlZFxuICAgICAgLy8gdG8gY2hlY2sgdGhhdCB0aGUgbG9hZGluZ0RlcFByb21pc2UgYWN0dWFsbHkgbWF0Y2hlcyB0aGUgcHJvbWlzZSB0aGF0XG4gICAgICAvLyB3ZSBjYXVnaHQgaW4gY2FzZSB0aGUgc2VsZWN0b3IgaGFwcGVuZWQgdG8gY2F0Y2ggdGhlIHByb21pc2Ugd2UgdGhyZXdcbiAgICAgIC8vIGZvciBhIHBlbmRpbmcgUmVjb2lsIGRlcGVuZGVuY3kgZnJvbSBgZ2V0UmVjb2lsVmFsdWUoKWAgYW5kIHRocmV3XG4gICAgICAvLyB0aGVpciBvd24gcHJvbWlzZSBpbnN0ZWFkLlxuXG5cbiAgICAgIGlmIChsb2FkaW5nRGVwc1N0YXRlLmxvYWRpbmdEZXBLZXkgIT0gbnVsbCAmJiBsb2FkaW5nRGVwc1N0YXRlLmxvYWRpbmdEZXBQcm9taXNlID09PSBwcm9taXNlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3RlIGZvciBhc3luYyBhdG9tcywgdGhpcyBtZWFucyB3ZSBhcmUgY2hhbmdpbmcgdGhlIGF0b20ncyB2YWx1ZVxuICAgICAgICAgKiBpbiB0aGUgc3RvcmUgZm9yIHRoZSBnaXZlbiB2ZXJzaW9uLiBUaGlzIHNob3VsZCBiZSBhbHJpZ2h0IGJlY2F1c2VcbiAgICAgICAgICogdGhlIHZlcnNpb24gb2Ygc3RhdGUgaXMgbm93IHN0YWxlIGFuZCBhIG5ldyB2ZXJzaW9uIHdpbGwgaGF2ZVxuICAgICAgICAgKiBhbHJlYWR5IGJlZW4gdHJpZ2dlcmVkIGJ5IHRoZSBhdG9tIGJlaW5nIHJlc29sdmVkIChzZWUgdGhpcyBsb2dpY1xuICAgICAgICAgKiBpbiBSZWNvaWxfYXRvbS5qcylcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRlLmF0b21WYWx1ZXMuc2V0KGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcEtleSwgbG9hZGFibGVXaXRoVmFsdWUkMihyZXNvbHZlZERlcCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHJlc29sdmVkRGVwS2V5IGlzIG5vdCBkZWZpbmVkLCB0aGUgcHJvbWlzZSB3YXMgYSB1c2VyLXRocm93blxuICAgICAgICAgKiBwcm9taXNlLiBVc2VyLXRocm93biBwcm9taXNlcyBhcmUgYW4gYWR2YW5jZWQgZmVhdHVyZSBhbmQgdGhleVxuICAgICAgICAgKiBzaG91bGQgYmUgYXZvaWRlZCBpbiBhbG1vc3QgYWxsIGNhc2VzLiBVc2luZyBgbG9hZGFibGUubWFwKClgIGluc2lkZVxuICAgICAgICAgKiBvZiBzZWxlY3RvcnMgZm9yIGxvYWRpbmcgbG9hZGFibGVzIGFuZCB0aGVuIHRocm93aW5nIHRoYXQgbWFwcGVkXG4gICAgICAgICAqIGxvYWRhYmxlJ3MgcHJvbWlzZSBpcyBhbiBleGFtcGxlIG9mIGEgdXNlci10aHJvd24gcHJvbWlzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiB3ZSBoaXQgYSB1c2VyLXRocm93biBwcm9taXNlLCB3ZSBoYXZlIHRvIGJhaWwgb3V0IG9mIGFuIG9wdGltaXphdGlvblxuICAgICAgICAgKiB3aGVyZSB3ZSBieXBhc3MgY2FsY3VsYXRpbmcgc2VsZWN0b3IgY2FjaGUga2V5cyBmb3Igc2VsZWN0b3JzIHRoYXRcbiAgICAgICAgICogaGF2ZSBiZWVuIHByZXZpb3VzbHkgc2VlbiBmb3IgYSBnaXZlbiBzdGF0ZSAodGhlc2Ugc2VsZWN0b3JzIGFyZSBzYXZlZCBpblxuICAgICAgICAgKiBzdGF0ZS5hdG9tVmFsdWVzKSB0byBhdm9pZCBzdGFsZSBzdGF0ZSBhcyB3ZSBoYXZlIG5vIHdheSBvZiBrbm93aW5nXG4gICAgICAgICAqIHdoYXQgc3RhdGUgY2hhbmdlcyBoYXBwZW5lZCAoaWYgYW55KSBpbiByZXN1bHQgdG8gdGhlIHByb21pc2UgcmVzb2x2aW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZGVhbGx5IHdlIHdvdWxkIG9ubHkgYmFpbCBvdXQgc2VsZWN0b3JzIHRoYXQgYXJlIGluIHRoZSBjaGFpbiBvZlxuICAgICAgICAgKiBkZXBlbmRlbmNpZXMgZm9yIHRoaXMgc2VsZWN0b3IsIGJ1dCB0aGVyZSdzIGN1cnJlbnRseSBubyB3YXkgdG8gZ2V0XG4gICAgICAgICAqIGEgZnVsbCBsaXN0IG9mIGEgc2VsZWN0b3IncyBkb3duc3RyZWFtIG5vZGVzIGJlY2F1c2UgdGhlIHN0YXRlIHRoYXRcbiAgICAgICAgICogaXMgZXhlY3V0aW5nIG1heSBiZSBhIGRpc2NhcmRlZCB0cmVlIChzbyBzdG9yZS5nZXRHcmFwaChzdGF0ZS52ZXJzaW9uKVxuICAgICAgICAgKiB3aWxsIGJlIGVtcHR5KSwgYW5kIHRoZSBmdWxsIGRlcCB0cmVlIG1heSBub3QgYmUgaW4gdGhlIHNlbGVjdG9yXG4gICAgICAgICAqIGNhY2hlcyBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgc2VsZWN0b3IncyBjYWNoZSB3YXMgY2xlYXJlZC4gVG8gc29sdmVcbiAgICAgICAgICogZm9yIHRoaXMgd2Ugd291bGQgaGF2ZSB0byBrZWVwIHRyYWNrIG9mIGFsbCBydW5uaW5nIHNlbGVjdG9yXG4gICAgICAgICAqIGV4ZWN1dGlvbnMgYW5kIHRoZWlyIGRvd25zdHJlYW0gZGVwcy4gQmVjYXVzZSB0aGlzIG9ubHkgY292ZXJzIGVkZ2VcbiAgICAgICAgICogY2FzZXMsIHRoYXQgY29tcGxleGl0eSBtaWdodCBub3QgYmUganVzdGlmeWFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLmtub3duU2VsZWN0b3JzLmZvckVhY2gobm9kZUtleSA9PiB7XG4gICAgICAgICAgc3RhdGUuYXRvbVZhbHVlcy5kZWxldGUobm9kZUtleSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBPcHRpbWl6YXRpb246IE5vdyB0aGF0IHRoZSBkZXBlbmRlbmN5IGhhcyByZXNvbHZlZCwgbGV0J3MgdHJ5IGhpdHRpbmdcbiAgICAgICAqIHRoZSBjYWNoZSBpbiBjYXNlIHRoZSBkZXAgcmVzb2x2ZWQgdG8gYSB2YWx1ZSB3ZSBoYXZlIHByZXZpb3VzbHkgc2Vlbi5cbiAgICAgICAqXG4gICAgICAgKiBUT0RPOlxuICAgICAgICogTm90ZSB0aGlzIG9wdGltaXphdGlvbiBpcyBub3QgcGVyZmVjdCBiZWNhdXNlIGl0IG9ubHkgcHJldmVudHMgcmUtZXhlY3V0aW9uc1xuICAgICAgICogX2FmdGVyXyB0aGUgcG9pbnQgd2hlcmUgYW4gYXN5bmMgZGVwZW5kZW5jeSBpcyBmb3VuZC4gQW55IGNvZGUgbGVhZGluZ1xuICAgICAgICogdXAgdG8gdGhlIGFzeW5jIGRlcGVuZGVuY3kgbWF5IGhhdmUgcnVuIHVubmVjZXNzYXJpbHkuIFRoZSBpZGVhbCBjYXNlXG4gICAgICAgKiB3b3VsZCBiZSB0byB3YWl0IGZvciB0aGUgYXN5bmMgZGVwZW5kZW5jeSB0byByZXNvbHZlIGZpcnN0LCBjaGVjayB0aGVcbiAgICAgICAqIGNhY2hlLCBhbmQgcHJldmVudCBfYW55XyBleGVjdXRpb24gb2YgdGhlIHNlbGVjdG9yIGlmIHRoZSByZXN1bHRpbmdcbiAgICAgICAqIHZhbHVlIG9mIHRoZSBkZXBlbmRlbmN5IGxlYWRzIHRvIGEgcGF0aCB0aGF0IGlzIGZvdW5kIGluIHRoZSBjYWNoZS5cbiAgICAgICAqIFRoZSBpZGVhbCBjYXNlIGlzIG1vcmUgZGlmZmljdWx0IHRvIGltcGxlbWVudCBhcyBpdCB3b3VsZCByZXF1aXJlIHRoYXRcbiAgICAgICAqIHdlIGNhcHR1cmUgYW5kIHdhaXQgZm9yIHRoZSB0aGUgYXN5bmMgZGVwZW5kZW5jeSByaWdodCBhZnRlciBjaGVja2luZ1xuICAgICAgICogdGhlIGNhY2hlLiBUaGUgY3VycmVudCBhcHByb2FjaCB0YWtlcyBhZHZhbnRhZ2Ugb2YgdGhlIGZhY3QgdGhhdCBydW5uaW5nXG4gICAgICAgKiB0aGUgc2VsZWN0b3IgYWxyZWFkeSBoYXMgYSBjb2RlIHBhdGggdGhhdCBsZXRzIHVzIGV4aXQgZWFybHkgd2hlblxuICAgICAgICogYW4gYXN5bmMgZGVwIHJlc29sdmVzLlxuICAgICAgICovXG5cblxuICAgICAgY29uc3QgY2FjaGVkTG9hZGFibGUgPSBnZXRMb2FkYWJsZUZyb21DYWNoZUFuZFVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlKTtcblxuICAgICAgaWYgKGNhY2hlZExvYWRhYmxlICYmIGNhY2hlZExvYWRhYmxlLnN0YXRlICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaGFzIHRvIG5vdGlmeSBzdG9yZXMgb2YgYSByZXNvbHZlZCBhc3luYywgZXZlbiBpZiB0aGVyZSBpcyBub1xuICAgICAgICAgKiBjdXJyZW50IHBlbmRpbmcgZXhlY3V0aW9uIGZvciB0aGUgZm9sbG93aW5nIGNhc2U6XG4gICAgICAgICAqIDEpIEEgY29tcG9uZW50IHJlbmRlcnMgd2l0aCB0aGlzIHBlbmRpbmcgbG9hZGFibGUuXG4gICAgICAgICAqIDIpIFRoZSB1cHN0cmVhbSBkZXBlbmRlbmN5IHJlc29sdmVzLlxuICAgICAgICAgKiAzKSBXaGlsZSBwcm9jZXNzaW5nIHNvbWUgb3RoZXIgc2VsZWN0b3IgaXQgcmVhZHMgdGhpcyBvbmUsIHN1Y2ggYXNcbiAgICAgICAgICogICAgd2hpbGUgdHJhdmVyc2luZyBpdHMgZGVwZW5kZW5jaWVzLiAgQXQgdGhpcyBwb2ludCBpdCBnZXRzIHRoZVxuICAgICAgICAgKiAgICBuZXcgcmVzb2x2ZWQgdmFsdWUgc3luY2hyb25vdXNseSBhbmQgY2xlYXJzIHRoZSBjdXJyZW50XG4gICAgICAgICAqICAgIGV4ZWN1dGlvbiBJRC4gIFRoZSBjb21wb25lbnQgd2Fzbid0IGdldHRpbmcgdGhlIHZhbHVlIGl0c2VsZixcbiAgICAgICAgICogICAgdGhvdWdoLCBzbyBpdCBzdGlsbCBoYXMgdGhlIHBlbmRpbmcgbG9hZGFibGUuXG4gICAgICAgICAqIDQpIFdoZW4gdGhpcyBjb2RlIGV4ZWN1dGVzIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBpZCB3YXMgY2xlYXJlZFxuICAgICAgICAgKiAgICBhbmQgaXQgd291bGRuJ3Qgbm90aWZ5IHRoZSBjb21wb25lbnQgb2YgdGhlIG5ldyB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSSB0aGluayB0aGlzIGlzIG9ubHkgYW4gaXNzdWUgd2l0aCBcImVhcmx5XCIgcmVuZGVyaW5nIHNpbmNlIHRoZVxuICAgICAgICAgKiBjb21wb25lbnRzIGdvdCB0aGVpciB2YWx1ZSB1c2luZyB0aGUgaW4tcHJvZ3Jlc3MgZXhlY3V0aW9uLlxuICAgICAgICAgKiBXZSBkb24ndCBoYXZlIGEgdW5pdCB0ZXN0IGZvciB0aGlzIGNhc2UgeWV0LiAgSSdtIG5vdCBzdXJlIGl0IGlzXG4gICAgICAgICAqIG5lY2Vzc2FyeSB3aXRoIHJlY29pbF90cmFuc2l0aW9uX3N1cHBvcnQgbW9kZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpIHx8IGdldEV4ZWN1dGlvbkluZm8oc3RvcmUpID09IG51bGwpIHtcbiAgICAgICAgICBub3RpZnlTdG9yZXNPZlJlc29sdmVkQXN5bmMoc3RvcmUsIGV4ZWN1dGlvbklEKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYWNoZWRMb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJykge1xuICAgICAgICAgIHJldHVybiBjYWNoZWRMb2FkYWJsZS5jb250ZW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBjYWNoZWRMb2FkYWJsZS5jb250ZW50cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGlzIGV4ZWN1dGlvbiBpcyBzdGFsZSwgbGV0J3MgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIHNvbWUgaW5cbiAgICAgICAqIHByb2dyZXNzIGV4ZWN1dGlvbiB3aXRoIGEgbWF0Y2hpbmcgc3RhdGUuIElmIHdlIGZpbmQgYSBtYXRjaCwgdGhlblxuICAgICAgICogd2UgY2FuIHRha2UgdGhlIHZhbHVlIGZyb20gdGhhdCBpbi1wcm9ncmVzcyBleGVjdXRpb24uIE5vdGUgdGhpcyBtYXlcbiAgICAgICAqIHNvdW5kIGxpa2UgYW4gZWRnZSBjYXNlLCBidXQgbWF5IGJlIHZlcnkgY29tbW9uIGluIGNhc2VzIHdoZXJlIGFcbiAgICAgICAqIGxvYWRpbmcgZGVwZW5kZW5jeSByZXNvbHZlcyBmcm9tIGxvYWRpbmcgdG8gaGF2aW5nIGEgdmFsdWUgKHRodXNcbiAgICAgICAqIHBvc3NpYmx5IHRyaWdnZXJpbmcgYSByZS1yZW5kZXIpLCBhbmQgUmVhY3QgcmUtcmVuZGVycyBiZWZvcmUgdGhlXG4gICAgICAgKiBjaGFpbmVkIC50aGVuKCkgZnVuY3Rpb25zIHJ1biwgdGh1cyBzdGFydGluZyBhIG5ldyBleGVjdXRpb24gYXMgdGhlXG4gICAgICAgKiBkZXAgaGFzIGNoYW5nZWQgdmFsdWUuIFdpdGhvdXQgdGhpcyBjaGVjayB3ZSB3aWxsIHJ1biB0aGUgc2VsZWN0b3JcbiAgICAgICAqIHR3aWNlIChvbmNlIGluIHRoZSBuZXcgZXhlY3V0aW9uIGFuZCBvbmNlIGFnYWluIGluIHRoaXMgLnRoZW4oKSwgc29cbiAgICAgICAqIHRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGtlZXAgdW5uZWNlc3NhcnkgcmUtZXhlY3V0aW9ucyB0byBhXG4gICAgICAgKiBtaW5pbXVtKS5cbiAgICAgICAqXG4gICAgICAgKiBBbHNvIG5vdGUgdGhpcyBjb2RlIGRvZXMgbm90IGNoZWNrIGFjcm9zcyBhbGwgZXhlY3V0aW9ucyB0aGF0IG1heSBiZVxuICAgICAgICogcnVubmluZy4gSXQgb25seSBvcHRpbWl6ZXMgZm9yIHRoZSBfbGF0ZXN0XyBleGVjdXRpb24gcGVyIHN0b3JlIGFzXG4gICAgICAgKiB3ZSBjdXJyZW50bHkgZG8gbm90IG1haW50YWluIGEgbGlzdCBvZiBhbGwgY3VycmVudGx5IHJ1bm5pbmcgZXhlY3V0aW9ucy5cbiAgICAgICAqIFRoaXMgbWVhbnMgaW4gc29tZSBjYXNlcyB3ZSBtYXkgcnVuIHNlbGVjdG9ycyBtb3JlIHRoYW4gc3RyaWN0bHlcbiAgICAgICAqIG5lY2Vzc2FyeSB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBleGVjdXRpb25zIHJ1bm5pbmcgZm9yIHRoZSBzYW1lXG4gICAgICAgKiBzZWxlY3Rvci4gVGhpcyBtYXkgYmUgYSB2YWxpZCB0cmFkZW9mZiBhcyBjaGVja2luZyBmb3IgZGVwIGNoYW5nZXNcbiAgICAgICAqIGFjcm9zcyBhbGwgaW4tcHJvZ3Jlc3MgZXhlY3V0aW9ucyBtYXkgdGFrZSBsb25nZXIgdGhhbiBqdXN0XG4gICAgICAgKiByZS1ydW5uaW5nIHRoZSBzZWxlY3Rvci4gVGhpcyB3aWxsIGJlIGFwcC1kZXBlbmRlbnQsIGFuZCBtYXliZSBpbiB0aGVcbiAgICAgICAqIGZ1dHVyZSB3ZSBjYW4gbWFrZSB0aGUgYmVoYXZpb3IgY29uZmlndXJhYmxlLiBBbiBpZGVhbCBmaXggbWF5IGJlXG4gICAgICAgKiB0byBleHRlbmQgdGhlIHRyZWUgY2FjaGUgdG8gc3VwcG9ydCBjYWNoaW5nIGxvYWRpbmcgc3RhdGVzLlxuICAgICAgICovXG5cblxuICAgICAgaWYgKCFpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpKSB7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvbkluZm8gPSBnZXRJblByb2dyZXNzRXhlY3V0aW9uSW5mbyhzdG9yZSwgc3RhdGUpO1xuXG4gICAgICAgIGlmIChleGVjdXRpb25JbmZvICE9IG51bGwpIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBSZXR1cm5pbmcgcHJvbWlzZSBoZXJlIHdpdGhvdXQgd3JhcHBpbmcgYXMgdGhlIHdyYXBwZXIgbG9naWMgd2FzXG4gICAgICAgICAgICogYWxyZWFkeSBkb25lIHVwc3RyZWFtIHdoZW4gdGhpcyBwcm9taXNlIHdhcyBnZW5lcmF0ZWQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgcmV0dXJuIGV4ZWN1dGlvbkluZm8ubG9hZGluZ0xvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJldHJ5IHRoZSBzZWxlY3RvciBldmFsdWF0aW9uIG5vdyB0aGF0IHRoZSBkZXBlbmRlbmN5IGhhcyByZXNvbHZlZFxuXG5cbiAgICAgIGNvbnN0IFtsb2FkYWJsZSwgZGVwVmFsdWVzXSA9IGV2YWx1YXRlU2VsZWN0b3JHZXR0ZXIoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCk7XG5cbiAgICAgIGlmIChsb2FkYWJsZS5zdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIHJlc29sdmVBc3luYyhzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklELCBsb2FkYWJsZSwgZGVwVmFsdWVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzRXJyb3InKSB7XG4gICAgICAgIHRocm93IGxvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9hZGFibGUuY29udGVudHM7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgLy8gVGhlIHNlbGVjdG9yIHdhcyByZWxlYXNlZCBzaW5jZSB0aGUgcmVxdWVzdCBiZWdhbjsgaWdub3JlIHRoZSByZXNwb25zZS5cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENhbmNlbGVkKSB7XG4gICAgICAgIHRocm93IENBTkNFTEVEO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGVjdG9ySXNMaXZlKCkpIHtcbiAgICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcbiAgICAgICAgdGhyb3cgQ0FOQ0VMRUQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvYWRhYmxlID0gbG9hZGFibGVXaXRoRXJyb3IkMShlcnJvcik7XG4gICAgICByZXNvbHZlQXN5bmMoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCwgbG9hZGFibGUsIGV4aXN0aW5nRGVwcyk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlLCBkZXBzLCBleGVjdXRpb25JRCkge1xuICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUsIF9zdG9yZSRnZXRTdGF0ZSRjdXJyZSwgX3N0b3JlJGdldFN0YXRlMiwgX3N0b3JlJGdldFN0YXRlMiRuZXh0O1xuXG4gICAgaWYgKGlzTGF0ZXN0RXhlY3V0aW9uKHN0b3JlLCBleGVjdXRpb25JRCkgfHwgc3RhdGUudmVyc2lvbiA9PT0gKChfc3RvcmUkZ2V0U3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc3RvcmUkZ2V0U3RhdGUkY3VycmUgPSBfc3RvcmUkZ2V0U3RhdGUuY3VycmVudFRyZWUpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZSRjdXJyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlJGdldFN0YXRlJGN1cnJlLnZlcnNpb24pIHx8IHN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlJGdldFN0YXRlMiA9IHN0b3JlLmdldFN0YXRlKCkpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc3RvcmUkZ2V0U3RhdGUyJG5leHQgPSBfc3RvcmUkZ2V0U3RhdGUyLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUyJG5leHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZSRnZXRTdGF0ZTIkbmV4dC52ZXJzaW9uKSkge1xuICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCwgX3N0b3JlJGdldFN0YXRlMywgX3N0b3JlJGdldFN0YXRlMyRuZXh0O1xuXG4gICAgICBzYXZlRGVwc1RvU3RvcmUkMShrZXksIGRlcHMsIHN0b3JlLCAoX3N0b3JlJGdldFN0YXRlJG5leHRUID0gKF9zdG9yZSRnZXRTdGF0ZTMgPSBzdG9yZS5nZXRTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3N0b3JlJGdldFN0YXRlMyRuZXh0ID0gX3N0b3JlJGdldFN0YXRlMy5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlMyRuZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUzJG5leHQudmVyc2lvbikgIT09IG51bGwgJiYgX3N0b3JlJGdldFN0YXRlJG5leHRUICE9PSB2b2lkIDAgPyBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgOiBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLnZlcnNpb24pO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qgbm9kZUtleSBvZiBkZXBzKSB7XG4gICAgICBkaXNjb3ZlcmVkRGVwZW5kZW5jeU5vZGVLZXlzLmFkZChub2RlS2V5KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBldmFsdWF0ZVNlbGVjdG9yR2V0dGVyKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQpIHtcbiAgICBjb25zdCBlbmRQZXJmQmxvY2sgPSBzdGFydFBlcmZCbG9jayQxKGtleSk7IC8vIFRPRE8gVDYzOTY1ODY2OiB1c2UgZXhlY3V0aW9uIElEIGhlcmVcblxuICAgIGxldCBkdXJpbmdTeW5jaHJvbm91c0V4ZWN1dGlvbiA9IHRydWU7XG4gICAgbGV0IGR1cmluZ0FzeW5jaHJvbm91c0V4ZWN1dGlvbiA9IHRydWU7XG5cbiAgICBjb25zdCBmaW5pc2hFdmFsdWF0aW9uID0gKCkgPT4ge1xuICAgICAgZW5kUGVyZkJsb2NrKCk7XG4gICAgICBkdXJpbmdBc3luY2hyb25vdXNFeGVjdXRpb24gPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgcmVzdWx0SXNFcnJvciA9IGZhbHNlO1xuICAgIGxldCBsb2FkYWJsZTtcbiAgICBjb25zdCBsb2FkaW5nRGVwc1N0YXRlID0ge1xuICAgICAgbG9hZGluZ0RlcEtleTogbnVsbCxcbiAgICAgIGxvYWRpbmdEZXBQcm9taXNlOiBudWxsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydGluZyBhIGZyZXNoIHNldCBvZiBkZXBzIHRoYXQgd2UnbGwgYmUgdXNpbmcgdG8gdXBkYXRlIHN0YXRlLiBXZSdyZVxuICAgICAqIHN0YXJ0aW5nIGEgbmV3IHNldCB2ZXJzdXMgYWRkaW5nIGl0IGluIGV4aXN0aW5nIHN0YXRlIGRlcHMgYmVjYXVzZVxuICAgICAqIHRoZSB2ZXJzaW9uIG9mIHN0YXRlIHRoYXQgd2UgdXBkYXRlIGRlcHMgZm9yIG1heSBiZSBhIG1vcmUgcmVjZW50IHZlcnNpb25cbiAgICAgKiB0aGFuIHRoZSB2ZXJzaW9uIHRoZSBzZWxlY3RvciB3YXMgY2FsbGVkIHdpdGguIFRoaXMgaXMgYmVjYXVzZSB0aGUgbGF0ZXN0XG4gICAgICogZXhlY3V0aW9uIHdpbGwgdXBkYXRlIHRoZSBkZXBzIG9mIHRoZSBjdXJyZW50L2xhdGVzdCB2ZXJzaW9uIG9mIHN0YXRlXG4gICAgICogKFRoaXMgaXMgc2FmZSB0byBkbyBiZWNhdXNlIHRoZSBmYWN0IHRoYXQgdGhlIHNlbGVjdG9yIGlzIHRoZSBsYXRlc3RcbiAgICAgKiBleGVjdXRpb24gbWVhbnMgdGhlIGRlcHMgd2UgZGlzY292ZXIgYmVsb3cgYXJlIG91ciBiZXN0IGd1ZXNzIGF0IHRoZVxuICAgICAqIGRlcHMgZm9yIHRoZSBjdXJyZW50L2xhdGVzdCBzdGF0ZSBpbiB0aGUgc3RvcmUpXG4gICAgICovXG5cbiAgICBjb25zdCBkZXBWYWx1ZXMgPSBuZXcgTWFwKCk7XG5cbiAgICBmdW5jdGlvbiBnZXRSZWNvaWxWYWx1ZSh7XG4gICAgICBrZXk6IGRlcEtleVxuICAgIH0pIHtcbiAgICAgIGNvbnN0IGRlcExvYWRhYmxlID0gZ2V0Tm9kZUxvYWRhYmxlJDIoc3RvcmUsIHN0YXRlLCBkZXBLZXkpO1xuICAgICAgZGVwVmFsdWVzLnNldChkZXBLZXksIGRlcExvYWRhYmxlKTsgLy8gV2UgbmVlZCB0byB1cGRhdGUgYXN5bmNocm9ub3VzIGRlcGVuZGVuY2llcyBhcyB3ZSBnbyBzbyB0aGUgc2VsZWN0b3JcbiAgICAgIC8vIGtub3dzIGlmIGl0IGhhcyB0byByZXN0YXJ0IGV2YWx1YXRpb24gaWYgb25lIG9mIHRoZW0gaXMgdXBkYXRlZCBiZWZvcmVcbiAgICAgIC8vIHRoZSBhc3luY2hyb25vdXMgc2VsZWN0b3IgY29tcGxldGVseSByZXNvbHZlcy5cblxuICAgICAgaWYgKCFkdXJpbmdTeW5jaHJvbm91c0V4ZWN1dGlvbikge1xuICAgICAgICB1cGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSwgbmV3IFNldChkZXBWYWx1ZXMua2V5cygpKSwgZXhlY3V0aW9uSUQpO1xuICAgICAgICBub3RpZnlTdG9yZXNPZk5ld0FzeW5jRGVwKHN0b3JlLCBleGVjdXRpb25JRCk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZGVwTG9hZGFibGUuc3RhdGUpIHtcbiAgICAgICAgY2FzZSAnaGFzVmFsdWUnOlxuICAgICAgICAgIHJldHVybiBkZXBMb2FkYWJsZS5jb250ZW50cztcblxuICAgICAgICBjYXNlICdoYXNFcnJvcic6XG4gICAgICAgICAgdGhyb3cgZGVwTG9hZGFibGUuY29udGVudHM7XG5cbiAgICAgICAgY2FzZSAnbG9hZGluZyc6XG4gICAgICAgICAgbG9hZGluZ0RlcHNTdGF0ZS5sb2FkaW5nRGVwS2V5ID0gZGVwS2V5O1xuICAgICAgICAgIGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcFByb21pc2UgPSBkZXBMb2FkYWJsZS5jb250ZW50cztcbiAgICAgICAgICB0aHJvdyBkZXBMb2FkYWJsZS5jb250ZW50cztcbiAgICAgIH1cblxuICAgICAgdGhyb3cgUmVjb2lsX2VycignSW52YWxpZCBMb2FkYWJsZSBzdGF0ZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGdldENhbGxiYWNrID0gZm4gPT4ge1xuICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChkdXJpbmdBc3luY2hyb25vdXNFeGVjdXRpb24pIHtcbiAgICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdDYWxsYmFja3MgZnJvbSBnZXRDYWxsYmFjaygpIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBhc3luY2hyb25vdXNseSBhZnRlciB0aGUgc2VsZWN0b3IgaXMgZXZhbHV0YXRlZC4gIEl0IGNhbiBiZSB1c2VkIGZvciBzZWxlY3RvcnMgdG8gcmV0dXJuIG9iamVjdHMgd2l0aCBjYWxsYmFja3MgdGhhdCBjYW4gd29yayB3aXRoIFJlY29pbCBzdGF0ZSB3aXRob3V0IGEgc3Vic2NyaXB0aW9uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgIShyZWNvaWxWYWx1ZSAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UsICdSZWNvaWwgVmFsdWUgY2FuIG5ldmVyIGJlIG51bGwnKSA6IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgICByZXR1cm4gcmVjb2lsQ2FsbGJhY2skMShzdG9yZSwgZm4sIGFyZ3MsIHtcbiAgICAgICAgICBub2RlOiByZWNvaWxWYWx1ZVxuICAgICAgICB9IC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGdldCh7XG4gICAgICAgIGdldDogZ2V0UmVjb2lsVmFsdWUsXG4gICAgICAgIGdldENhbGxiYWNrXG4gICAgICB9KTtcbiAgICAgIHJlc3VsdCA9IGlzUmVjb2lsVmFsdWUkMyhyZXN1bHQpID8gZ2V0UmVjb2lsVmFsdWUocmVzdWx0KSA6IHJlc3VsdDtcblxuICAgICAgaWYgKGlzTG9hZGFibGUkMShyZXN1bHQpKSB7XG4gICAgICAgIGlmIChyZXN1bHQuc3RhdGUgPT09ICdoYXNFcnJvcicpIHtcbiAgICAgICAgICByZXN1bHRJc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb250ZW50cztcbiAgICAgIH1cblxuICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQgPSB3cmFwUmVzdWx0UHJvbWlzZShzdG9yZSwgcmVzdWx0LCBzdGF0ZSwgZGVwVmFsdWVzLCBleGVjdXRpb25JRCwgbG9hZGluZ0RlcHNTdGF0ZSkuZmluYWxseShmaW5pc2hFdmFsdWF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmlzaEV2YWx1YXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gcmVzdWx0IGluc3RhbmNlb2YgV3JhcHBlZFZhbHVlJDEgPyByZXN1bHQudmFsdWUgOiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3JPckRlcFByb21pc2UpIHtcbiAgICAgIHJlc3VsdCA9IGVycm9yT3JEZXBQcm9taXNlO1xuXG4gICAgICBpZiAoUmVjb2lsX2lzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdCA9IHdyYXBQZW5kaW5nRGVwZW5kZW5jeVByb21pc2Uoc3RvcmUsIHJlc3VsdCwgc3RhdGUsIGRlcFZhbHVlcywgZXhlY3V0aW9uSUQsIGxvYWRpbmdEZXBzU3RhdGUpLmZpbmFsbHkoZmluaXNoRXZhbHVhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRJc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgZmluaXNoRXZhbHVhdGlvbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXN1bHRJc0Vycm9yKSB7XG4gICAgICBsb2FkYWJsZSA9IGxvYWRhYmxlV2l0aEVycm9yJDEocmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKFJlY29pbF9pc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgbG9hZGFibGUgPSBsb2FkYWJsZVdpdGhQcm9taXNlJDEocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZGFibGUgPSBsb2FkYWJsZVdpdGhWYWx1ZSQyKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgZHVyaW5nU3luY2hyb25vdXNFeGVjdXRpb24gPSBmYWxzZTtcbiAgICB1cGRhdGVFeGVjdXRpb25JbmZvRGVwVmFsdWVzKHN0b3JlLCBleGVjdXRpb25JRCwgZGVwVmFsdWVzKTtcbiAgICB1cGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSwgbmV3IFNldChkZXBWYWx1ZXMua2V5cygpKSwgZXhlY3V0aW9uSUQpO1xuICAgIHJldHVybiBbbG9hZGFibGUsIGRlcFZhbHVlc107XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMb2FkYWJsZUZyb21DYWNoZUFuZFVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlKSB7XG4gICAgLy8gRmlyc3QsIGxvb2sgdXAgaW4gdGhlIHN0YXRlIGNhY2hlXG4gICAgLy8gSWYgaXQncyBoZXJlLCB0aGVuIHRoZSBkZXBzIGluIHRoZSBzdG9yZSBzaG91bGQgYWxyZWFkeSBiZSB2YWxpZC5cbiAgICBsZXQgY2FjaGVkTG9hZGFibGUgPSBzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpO1xuXG4gICAgaWYgKGNhY2hlZExvYWRhYmxlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZWRMb2FkYWJsZTtcbiAgICB9IC8vIFNlY29uZCwgbG9vayB1cCBpbiB0aGUgc2VsZWN0b3IgY2FjaGUgYW5kIHVwZGF0ZSB0aGUgZGVwcyBpbiB0aGUgc3RvcmVcblxuXG4gICAgY29uc3QgZGVwc0FmdGVyQ2FjaGVMb29rdXAgPSBuZXcgU2V0KCk7XG5cbiAgICB0cnkge1xuICAgICAgY2FjaGVkTG9hZGFibGUgPSBjYWNoZS5nZXQobm9kZUtleSA9PiB7XG4gICAgICAgICEodHlwZW9mIG5vZGVLZXkgPT09ICdzdHJpbmcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UsICdDYWNoZSBub2RlS2V5IGlzIHR5cGUgc3RyaW5nJykgOiBSZWNvaWxfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIGdldE5vZGVMb2FkYWJsZSQyKHN0b3JlLCBzdGF0ZSwgbm9kZUtleSkuY29udGVudHM7XG4gICAgICB9LCB7XG4gICAgICAgIG9uTm9kZVZpc2l0OiBub2RlID0+IHtcbiAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnYnJhbmNoJyAmJiBub2RlLm5vZGVLZXkgIT09IGtleSkge1xuICAgICAgICAgICAgZGVwc0FmdGVyQ2FjaGVMb29rdXAuYWRkKG5vZGUubm9kZUtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycihgUHJvYmxlbSB3aXRoIGNhY2hlIGxvb2t1cCBmb3Igc2VsZWN0b3IgXCIke2tleX1cIjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cblxuICAgIGlmIChjYWNoZWRMb2FkYWJsZSkge1xuICAgICAgdmFyIF9nZXRFeGVjdXRpb25JbmZvO1xuXG4gICAgICAvLyBDYWNoZSB0aGUgcmVzdWx0cyBpbiB0aGUgc3RhdGUgdG8gYWxsb3cgZm9yIGNoZWFwZXIgbG9va3VwIHRoYW5cbiAgICAgIC8vIGl0ZXJhdGluZyB0aGUgdHJlZSBjYWNoZSBvZiBkZXBlbmRlbmNpZXMuXG4gICAgICBzdGF0ZS5hdG9tVmFsdWVzLnNldChrZXksIGNhY2hlZExvYWRhYmxlKTtcbiAgICAgIC8qKlxuICAgICAgICogRW5zdXJlIHN0b3JlIGNvbnRhaW5zIGNvcnJlY3QgZGVwZW5kZW5jaWVzIGlmIHdlIGhpdCB0aGUgY2FjaGUgc28gdGhhdFxuICAgICAgICogdGhlIHN0b3JlIGRlcHMgYW5kIGNhY2hlIGFyZSBpbiBzeW5jIGZvciBhIGdpdmVuIHN0YXRlLiBUaGlzIGlzIGltcG9ydGFudFxuICAgICAgICogYmVjYXVzZSBzdG9yZSBkZXBzIGFyZSBub3JtYWxseSB1cGRhdGVkIHdoZW4gbmV3IGV4ZWN1dGlvbnMgYXJlIGNyZWF0ZWQsXG4gICAgICAgKiBidXQgY2FjaGUgaGl0cyBkb24ndCB0cmlnZ2VyIG5ldyBleGVjdXRpb25zIGJ1dCB0aGV5IHN0aWxsIF9tYXlfIHNpZ25pZnlcbiAgICAgICAqIGEgY2hhbmdlIGluIGRlcHMgaW4gdGhlIHN0b3JlIGlmIHRoZSBzdG9yZSBkZXBzIGZvciB0aGlzIHN0YXRlIGFyZSBlbXB0eVxuICAgICAgICogb3Igc3RhbGUuXG4gICAgICAgKi9cblxuICAgICAgdXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUsIGRlcHNBZnRlckNhY2hlTG9va3VwLCAoX2dldEV4ZWN1dGlvbkluZm8gPSBnZXRFeGVjdXRpb25JbmZvKHN0b3JlKSkgPT09IG51bGwgfHwgX2dldEV4ZWN1dGlvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRFeGVjdXRpb25JbmZvLmV4ZWN1dGlvbklEKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVkTG9hZGFibGU7XG4gIH1cbiAgLyoqXG4gICAqIEdpdmVuIGEgdHJlZSBzdGF0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgTG9hZGFibGUgb2YgdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqXG4gICAqIFRoZSBzZWxlY3RvcidzIGdldCgpIGZ1bmN0aW9uIHdpbGwgb25seSBiZSByZS1ldmFsdWF0ZWQgaWYgX2JvdGhfIG9mIHRoZVxuICAgKiBmb2xsb3dpbmcgc3RhdGVtZW50cyBhcmUgdHJ1ZTpcbiAgICpcbiAgICogMS4gVGhlIGN1cnJlbnQgZGVwIHZhbHVlcyBmcm9tIHRoZSBnaXZlbiBzdGF0ZSBwcm9kdWNlZCBhIGNhY2hlIGtleSB0aGF0XG4gICAqICAgIHdhcyBub3QgZm91bmQgaW4gdGhlIGNhY2hlLlxuICAgKiAyLiBUaGVyZSBpcyBubyBjdXJyZW50bHkgcnVubmluZyBhc3luYyBleGVjdXRpb24gT1IgdGhlcmUgaXMgYW5cbiAgICogICAgYXN5bmMgZXhlY3V0aW9uIHRoYXQgaXMgcnVubmluZywgYnV0IGFmdGVyIGNvbXBhcmluZyB0aGUgZGVwIHZhbHVlcyBpblxuICAgKiAgICB0aGUgZ2l2ZW4gc3RhdGUgd2l0aCB0aGUgZGVwIHZhbHVlcyB0aGF0IHRoZSBleGVjdXRpb24gaGFzIGRpc2NvdmVyZWQgc29cbiAgICogICAgZmFyIHdlIGZpbmQgdGhhdCBhdCBsZWFzdCBvbmUgZGVwIHZhbHVlIGhhcyBjaGFuZ2VkLCBpbiB3aGljaCBjYXNlIHdlXG4gICAqICAgIHN0YXJ0IGEgbmV3IGV4ZWN1dGlvbiAodGhlIHByZXZpb3VzbHkgcnVubmluZyBleGVjdXRpb24gd2lsbCBjb250aW51ZSB0b1xuICAgKiAgICBydW4gdG8gY29tcGxldGlvbiwgYnV0IG9ubHkgdGhlIG5ldyBleGVjdXRpb24gd2lsbCBiZSBkZWVtZWQgdGhlXG4gICAqICAgICdsYXRlc3QnIGV4ZWN1dGlvbiwgbWVhbmluZyBpdCB3aWxsIGJlIHRoZSBvbmx5IGV4ZWN1dGlvbiB0aGF0IHdpbGxcbiAgICogICAgdXBkYXRlIGdsb2JhbCBzdGF0ZSB3aGVuIGl0IGlzIGZpbmlzaGVkLiBBbnkgbm9uLWxhdGVzdCBleGVjdXRpb25zIHdpbGxcbiAgICogICAgcnVuIHRvIGNvbXBsZXRpb24gYW5kIHVwZGF0ZSB0aGUgc2VsZWN0b3IgY2FjaGUgYnV0IG5vdCBnbG9iYWwgc3RhdGUpLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9yTG9hZGFibGVBbmRVcGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSkge1xuICAgIC8vIEZpcnN0LCBzZWUgaWYgb3VyIGN1cnJlbnQgc3RhdGUgaXMgY2FjaGVkXG4gICAgY29uc3QgY2FjaGVkVmFsID0gZ2V0TG9hZGFibGVGcm9tQ2FjaGVBbmRVcGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSk7XG5cbiAgICBpZiAoY2FjaGVkVmFsICE9IG51bGwpIHtcbiAgICAgIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSk7XG4gICAgICByZXR1cm4gY2FjaGVkVmFsO1xuICAgIH0gLy8gU2Vjb25kLCBjaGVjayBpZiB0aGVyZSBpcyBhbHJlYWR5IGFuIG9uZ29pbmcgZXhlY3V0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlXG5cblxuICAgIGNvbnN0IGluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvID0gZ2V0SW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8oc3RvcmUsIHN0YXRlKTtcblxuICAgIGlmIChpblByb2dyZXNzRXhlY3V0aW9uSW5mbyAhPSBudWxsKSB7XG4gICAgICB2YXIgX2luUHJvZ3Jlc3NFeGVjdXRpb25JO1xuXG4gICAgICBpZiAoKChfaW5Qcm9ncmVzc0V4ZWN1dGlvbkkgPSBpblByb2dyZXNzRXhlY3V0aW9uSW5mby5sb2FkaW5nTG9hZGFibGUpID09PSBudWxsIHx8IF9pblByb2dyZXNzRXhlY3V0aW9uSSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2luUHJvZ3Jlc3NFeGVjdXRpb25JLnN0YXRlKSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIG1hcmtTdG9yZVdhaXRpbmdGb3JSZXNvbHZlZEFzeW5jKHN0b3JlLCBpblByb2dyZXNzRXhlY3V0aW9uSW5mby5leGVjdXRpb25JRCk7XG4gICAgICB9IC8vIEZJWE1FOiBjaGVjayBhZnRlciB0aGUgZmFjdCB0byBzZWUgaWYgd2UgbWFkZSB0aGUgcmlnaHQgY2hvaWNlIGJ5IHdhaXRpbmdcblxuXG4gICAgICByZXR1cm4gaW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8ubG9hZGluZ0xvYWRhYmxlO1xuICAgIH0gLy8gVGhpcmQsIHN0YXJ0IGEgbmV3IGV2YWx1YXRpb24gb2YgdGhlIHNlbGVjdG9yXG5cblxuICAgIGNvbnN0IG5ld0V4ZWN1dGlvbklEID0gZ2V0TmV3RXhlY3V0aW9uSUQoKTtcbiAgICBjb25zdCBbbG9hZGFibGUsIG5ld0RlcFZhbHVlc10gPSBldmFsdWF0ZVNlbGVjdG9yR2V0dGVyKHN0b3JlLCBzdGF0ZSwgbmV3RXhlY3V0aW9uSUQpO1xuICAgIC8qKlxuICAgICAqIENvbmRpdGlvbmFsbHkgdXBkYXRlcyB0aGUgY2FjaGUgd2l0aCBhIGdpdmVuIGxvYWRhYmxlLlxuICAgICAqXG4gICAgICogV2Ugb25seSBjYWNoZSBsb2FkYWJsZXMgdGhhdCBhcmUgbm90IGxvYWRpbmcgYmVjYXVzZSBvdXIgY2FjaGUga2V5cyBhcmVcbiAgICAgKiBiYXNlZCBvbiBkZXAgdmFsdWVzLCB3aGljaCBhcmUgaW4gYW4gdW5maW5pc2hlZCBzdGF0ZSBmb3IgbG9hZGFibGVzIHRoYXRcbiAgICAgKiBoYXZlIGEgJ2xvYWRpbmcnIHN0YXRlIChuZXcgZGVwcyBtYXkgYmUgZGlzY292ZXJlZCB3aGlsZSB0aGUgc2VsZWN0b3JcbiAgICAgKiBydW5zIGl0cyBhc3luYyBjb2RlKS4gV2UgbmV2ZXIgd2FudCB0byBjYWNoZSBwYXJ0aWFsIGRlcGVuZGVuY2llcyBiL2MgaXRcbiAgICAgKiBjb3VsZCBsZWFkIHRvIGVycm9ycywgc3VjaCBhcyBwcmVtYXR1cmVseSByZXR1cm5pbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiBhXG4gICAgICogcGFydGlhbCBsaXN0IG9mIGRlcHMtLSB3ZSBuZWVkIHRoZSBmdWxsIGxpc3Qgb2YgZGVwcyB0byBlbnN1cmUgdGhhdCB3ZVxuICAgICAqIGFyZSByZXR1cm5pbmcgdGhlIGNvcnJlY3QgcmVzdWx0IGZyb20gY2FjaGUuXG4gICAgICovXG5cbiAgICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgc2V0RXhlY3V0aW9uSW5mbyhzdG9yZSwgbmV3RXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBuZXdEZXBWYWx1ZXMsIHN0YXRlKTtcbiAgICAgIG1hcmtTdG9yZVdhaXRpbmdGb3JSZXNvbHZlZEFzeW5jKHN0b3JlLCBuZXdFeGVjdXRpb25JRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSk7XG4gICAgICBzZXRDYWNoZShzdGF0ZSwgbG9hZGFibGUsIG5ld0RlcFZhbHVlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvYWRhYmxlO1xuICB9XG4gIC8qKlxuICAgKiBTZWFyY2hlcyBleGVjdXRpb24gaW5mbyBhY3Jvc3MgYWxsIHN0b3JlcyB0byBzZWUgaWYgdGhlcmUgaXMgYW4gaW4tcHJvZ3Jlc3NcbiAgICogZXhlY3V0aW9uIHdob3NlIGRlcGVuZGVuY3kgdmFsdWVzIG1hdGNoIHRoZSB2YWx1ZXMgb2YgdGhlIHJlcXVlc3Rpbmcgc3RvcmUuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0SW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8oc3RvcmUsIHN0YXRlKSB7XG4gICAgLy8gU29ydCB0aGUgcGVuZGluZyBleGVjdXRpb25zIHNvIHRoYXQgb3VyIGN1cnJlbnQgc3RvcmUgaXMgY2hlY2tlZCBmaXJzdC5cbiAgICBjb25zdCBwZW5kaW5nRXhlY3V0aW9ucyA9IFJlY29pbF9jb25jYXRJdGVyYWJsZXMoW2V4ZWN1dGlvbkluZm9NYXAuaGFzKHN0b3JlKSA/IFtSZWNvaWxfbnVsbHRocm93cyhleGVjdXRpb25JbmZvTWFwLmdldChzdG9yZSkpXSA6IFtdLCBSZWNvaWxfbWFwSXRlcmFibGUoUmVjb2lsX2ZpbHRlckl0ZXJhYmxlKGV4ZWN1dGlvbkluZm9NYXAsIChbc10pID0+IHMgIT09IHN0b3JlKSwgKFssIGV4ZWNJbmZvXSkgPT4gZXhlY0luZm8pXSk7XG5cbiAgICBmdW5jdGlvbiBhbnlEZXBDaGFuZ2VkKGV4ZWNEZXBWYWx1ZXMpIHtcbiAgICAgIGZvciAoY29uc3QgW2RlcEtleSwgZXhlY0xvYWRhYmxlXSBvZiBleGVjRGVwVmFsdWVzKSB7XG4gICAgICAgIGlmICghZ2V0Tm9kZUxvYWRhYmxlJDIoc3RvcmUsIHN0YXRlLCBkZXBLZXkpLmlzKGV4ZWNMb2FkYWJsZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBleGVjSW5mbyBvZiBwZW5kaW5nRXhlY3V0aW9ucykge1xuICAgICAgaWYgKCAvLyBJZiB0aGlzIGV4ZWN1dGlvbiB3YXMgYWxyZWFkeSBjaGVja2VkIHRvIGJlIHZhbGlkIHdpdGggdGhpcyB2ZXJzaW9uXG4gICAgICAvLyBvZiBzdGF0ZSwgdGhlbiBsZXQncyB1c2UgaXQhXG4gICAgICBleGVjSW5mby5zdGF0ZVZlcnNpb25zLmdldChzdGF0ZS52ZXJzaW9uKSB8fCAvLyBJZiB0aGUgZGVwcyBmb3IgdGhlIGV4ZWN1dGlvbiBtYXRjaCBvdXIgY3VycmVudCBzdGF0ZSwgdGhlbiBpdCdzIHZhbGlkXG4gICAgICAhYW55RGVwQ2hhbmdlZChleGVjSW5mby5kZXBWYWx1ZXNEaXNjb3ZlcmVkU29GYXJEdXJpbmdBc3luY1dvcmspKSB7XG4gICAgICAgIGV4ZWNJbmZvLnN0YXRlVmVyc2lvbnMuc2V0KHN0YXRlLnZlcnNpb24sIHRydWUpO1xuICAgICAgICByZXR1cm4gZXhlY0luZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGVjSW5mby5zdGF0ZVZlcnNpb25zLnNldChzdGF0ZS52ZXJzaW9uLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEV4ZWN1dGlvbkluZm8oc3RvcmUpIHtcbiAgICByZXR1cm4gZXhlY3V0aW9uSW5mb01hcC5nZXQoc3RvcmUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdXBkYXRlIHRoZSBzZWxlY3RvcidzIGV4ZWN1dGlvbiBpbmZvIHdoZW4gdGhlIHNlbGVjdG9yXG4gICAqIGhhcyBlaXRoZXIgZmluaXNoZWQgcnVubmluZyBhbiBleGVjdXRpb24gb3IgaGFzIHN0YXJ0ZWQgYSBuZXcgZXhlY3V0aW9uLiBJZlxuICAgKiB0aGUgZ2l2ZW4gbG9hZGFibGUgaXMgaW4gYSAnbG9hZGluZycgc3RhdGUsIHRoZSBpbnRlbnRpb24gaXMgdGhhdCBhIG5ld1xuICAgKiBleGVjdXRpb24gaGFzIHN0YXJ0ZWQuIE90aGVyd2lzZSwgdGhlIGludGVudGlvbiBpcyB0aGF0IGFuIGV4ZWN1dGlvbiBoYXNcbiAgICoganVzdCBmaW5pc2hlZC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBzZXRFeGVjdXRpb25JbmZvKHN0b3JlLCBuZXdFeGVjdXRpb25JRCwgbG9hZGFibGUsIGRlcFZhbHVlcywgc3RhdGUpIHtcbiAgICBleGVjdXRpb25JbmZvTWFwLnNldChzdG9yZSwge1xuICAgICAgZGVwVmFsdWVzRGlzY292ZXJlZFNvRmFyRHVyaW5nQXN5bmNXb3JrOiBkZXBWYWx1ZXMsXG4gICAgICBleGVjdXRpb25JRDogbmV3RXhlY3V0aW9uSUQsXG4gICAgICBsb2FkaW5nTG9hZGFibGU6IGxvYWRhYmxlLFxuICAgICAgc3RhdGVWZXJzaW9uczogbmV3IE1hcChbW3N0YXRlLnZlcnNpb24sIHRydWVdXSlcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUV4ZWN1dGlvbkluZm9EZXBWYWx1ZXMoc3RvcmUsIGV4ZWN1dGlvbklELCBkZXBWYWx1ZXMpIHtcbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gYm90aGVyIHVwZGF0aW5nIHRoZSBkZXBzIGZvciB0aGUgbGF0ZXN0IGV4ZWN1dGlvbiBiZWNhdXNlXG4gICAgLy8gdGhhdCdzIGFsbCBnZXRJblByb2dyZXNzRXhlY3V0aW9uSW5mbygpIHdpbGwgYmUgbG9va2luZyBmb3IuXG4gICAgaWYgKGlzTGF0ZXN0RXhlY3V0aW9uKHN0b3JlLCBleGVjdXRpb25JRCkpIHtcbiAgICAgIGNvbnN0IGV4ZWN1dGlvbkluZm8gPSBnZXRFeGVjdXRpb25JbmZvKHN0b3JlKTtcblxuICAgICAgaWYgKGV4ZWN1dGlvbkluZm8gIT0gbnVsbCkge1xuICAgICAgICBleGVjdXRpb25JbmZvLmRlcFZhbHVlc0Rpc2NvdmVyZWRTb0ZhckR1cmluZ0FzeW5jV29yayA9IGRlcFZhbHVlcztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpIHtcbiAgICBleGVjdXRpb25JbmZvTWFwLmRlbGV0ZShzdG9yZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpIHtcbiAgICB2YXIgX2dldEV4ZWN1dGlvbkluZm8yO1xuXG4gICAgcmV0dXJuIGV4ZWN1dGlvbklEID09PSAoKF9nZXRFeGVjdXRpb25JbmZvMiA9IGdldEV4ZWN1dGlvbkluZm8oc3RvcmUpKSA9PT0gbnVsbCB8fCBfZ2V0RXhlY3V0aW9uSW5mbzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRFeGVjdXRpb25JbmZvMi5leGVjdXRpb25JRCk7XG4gIH1cbiAgLyoqXG4gICAqIEZJWE1FOiBkZXAga2V5cyBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgdGhlIHN0YXRlIG9mIHRoZSBsb2FkYWJsZSB0b1xuICAgKiBwcmV2ZW50IHRoZSBlZGdlIGNhc2Ugd2hlcmUgYSBsb2FkYWJsZSB3aXRoIGFuIGVycm9yIGFuZCBhIGxvYWRhYmxlIHdpdGhcbiAgICogYW4gZXJyb3IgYXMgYSB2YWx1ZSBhcmUgdHJlYXRlZCBhcyB0aGUgc2FtZSB0aGluZyBpbmNvcnJlY3RseS4gRm9yIGV4YW1wbGVcbiAgICogdGhlc2UgdHdvIHNob3VsZCBiZSB0cmVhdGVkIGRpZmZlcmVudGx5OlxuICAgKlxuICAgKiBzZWxlY3Rvcih7a2V5OiAnJywgZ2V0OiAoKSA9PiBuZXcgRXJyb3IoJ2hpJyl9KTtcbiAgICogc2VsZWN0b3Ioe2tleTogJycsIGdldCAoKSA9PiB7dGhyb3cgbmV3IEVycm9yKCdoaScpfX0pO1xuICAgKlxuICAgKiBXaXRoIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gdGhleSBhcmUgdHJlYXRlZCB0aGUgc2FtZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGRlcFZhbHVlc1RvRGVwUm91dGUoZGVwVmFsdWVzKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZGVwVmFsdWVzLmVudHJpZXMoKSkubWFwKChbZGVwS2V5LCB2YWxMb2FkYWJsZV0pID0+IFtkZXBLZXksIHZhbExvYWRhYmxlLmNvbnRlbnRzXSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDYWNoZShzdGF0ZSwgbG9hZGFibGUsIGRlcFZhbHVlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmIChsb2FkYWJsZS5zdGF0ZSAhPT0gJ2xvYWRpbmcnICYmIEJvb2xlYW4ob3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSkgPT09IGZhbHNlKSB7XG4gICAgICAgIFJlY29pbF9kZWVwRnJlZXplVmFsdWUobG9hZGFibGUuY29udGVudHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLmF0b21WYWx1ZXMuc2V0KGtleSwgbG9hZGFibGUpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNhY2hlLnNldChkZXBWYWx1ZXNUb0RlcFJvdXRlKGRlcFZhbHVlcyksIGxvYWRhYmxlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycihgUHJvYmxlbSB3aXRoIHNldHRpbmcgY2FjaGUgZm9yIHNlbGVjdG9yIFwiJHtrZXl9XCI6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRlY3RDaXJjdWxhckRlcGVuZGVuY2llcyhmbikge1xuICAgIGlmIChkZXBlbmRlbmN5U3RhY2suaW5jbHVkZXMoa2V5KSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBSZWNvaWwgc2VsZWN0b3IgaGFzIGNpcmN1bGFyIGRlcGVuZGVuY2llczogJHtkZXBlbmRlbmN5U3RhY2suc2xpY2UoZGVwZW5kZW5jeVN0YWNrLmluZGV4T2Yoa2V5KSkuam9pbignIFxcdTIxOTIgJyl9YDtcbiAgICAgIHJldHVybiBsb2FkYWJsZVdpdGhFcnJvciQxKFJlY29pbF9lcnIobWVzc2FnZSkpO1xuICAgIH1cblxuICAgIGRlcGVuZGVuY3lTdGFjay5wdXNoKGtleSk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRlcGVuZGVuY3lTdGFjay5wb3AoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RvclBlZWsoc3RvcmUsIHN0YXRlKSB7XG4gICAgY29uc3QgY2FjaGVkTG9hZGFibGUgPSBzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpO1xuXG4gICAgaWYgKGNhY2hlZExvYWRhYmxlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZWRMb2FkYWJsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGUuZ2V0KG5vZGVLZXkgPT4ge1xuICAgICAgdmFyIF9wZWVrTm9kZUxvYWRhYmxlO1xuXG4gICAgICAhKHR5cGVvZiBub2RlS2V5ID09PSAnc3RyaW5nJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBSZWNvaWxfaW52YXJpYW50KGZhbHNlLCAnQ2FjaGUgbm9kZUtleSBpcyB0eXBlIHN0cmluZycpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gKF9wZWVrTm9kZUxvYWRhYmxlID0gcGVla05vZGVMb2FkYWJsZSQxKHN0b3JlLCBzdGF0ZSwgbm9kZUtleSkpID09PSBudWxsIHx8IF9wZWVrTm9kZUxvYWRhYmxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVla05vZGVMb2FkYWJsZS5jb250ZW50cztcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdG9yR2V0KHN0b3JlLCBzdGF0ZSkge1xuICAgIHJldHVybiBkZXRlY3RDaXJjdWxhckRlcGVuZGVuY2llcygoKSA9PiBnZXRTZWxlY3RvckxvYWRhYmxlQW5kVXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRhdGVTZWxlY3RvcihzdGF0ZSkge1xuICAgIHN0YXRlLmF0b21WYWx1ZXMuZGVsZXRlKGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhclNlbGVjdG9yQ2FjaGUoc3RvcmUsIHRyZWVTdGF0ZSkge1xuICAgICEocmVjb2lsVmFsdWUgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBSZWNvaWxfaW52YXJpYW50KGZhbHNlLCAnUmVjb2lsIFZhbHVlIGNhbiBuZXZlciBiZSBudWxsJykgOiBSZWNvaWxfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGZvciAoY29uc3Qgbm9kZUtleSBvZiBkaXNjb3ZlcmVkRGVwZW5kZW5jeU5vZGVLZXlzKSB7XG4gICAgICB2YXIgX25vZGUkY2xlYXJDYWNoZTtcblxuICAgICAgY29uc3Qgbm9kZSA9IGdldE5vZGUkNihub2RlS2V5KTtcbiAgICAgIChfbm9kZSRjbGVhckNhY2hlID0gbm9kZS5jbGVhckNhY2hlKSA9PT0gbnVsbCB8fCBfbm9kZSRjbGVhckNhY2hlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRjbGVhckNhY2hlLmNhbGwobm9kZSwgc3RvcmUsIHRyZWVTdGF0ZSk7XG4gICAgfVxuXG4gICAgZGlzY292ZXJlZERlcGVuZGVuY3lOb2RlS2V5cy5jbGVhcigpO1xuICAgIGludmFsaWRhdGVTZWxlY3Rvcih0cmVlU3RhdGUpO1xuICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQkMShzdG9yZSwgcmVjb2lsVmFsdWUpO1xuICB9XG5cbiAgaWYgKHNldCAhPSBudWxsKSB7XG4gICAgLyoqXG4gICAgICogRVM1IHN0cmljdCBtb2RlIHByb2hpYml0cyBkZWZpbmluZyBub24tdG9wLWxldmVsIGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyxcbiAgICAgKiBzbyBkb24ndCB1c2UgZnVuY3Rpb24gZGVjbGFyYXRpb24gc3ludGF4IGhlcmVcbiAgICAgKi9cbiAgICBjb25zdCBzZWxlY3RvclNldCA9IChzdG9yZSwgc3RhdGUsIG5ld1ZhbHVlKSA9PiB7XG4gICAgICBsZXQgc3luY1NlbGVjdG9yU2V0RmluaXNoZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHdyaXRlcyA9IG5ldyBNYXAoKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0UmVjb2lsVmFsdWUoe1xuICAgICAgICBrZXk6IGRlcEtleVxuICAgICAgfSkge1xuICAgICAgICBpZiAoc3luY1NlbGVjdG9yU2V0RmluaXNoZWQpIHtcbiAgICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdSZWNvaWw6IEFzeW5jIHNlbGVjdG9yIHNldHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9hZGFibGUgPSBnZXROb2RlTG9hZGFibGUkMihzdG9yZSwgc3RhdGUsIGRlcEtleSk7XG5cbiAgICAgICAgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnKSB7XG4gICAgICAgICAgcmV0dXJuIGxvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICB9IGVsc2UgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBgR2V0dGluZyB2YWx1ZSBvZiBhc3luY2hyb25vdXMgYXRvbSBvciBzZWxlY3RvciBcIiR7ZGVwS2V5fVwiIGluIGEgcGVuZGluZyBzdGF0ZSB3aGlsZSBzZXR0aW5nIHNlbGVjdG9yIFwiJHtrZXl9XCIgaXMgbm90IHlldCBzdXBwb3J0ZWQuYDtcbiAgICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24obXNnKTtcbiAgICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKG1zZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbG9hZGFibGUuY29udGVudHM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUsIHZhbHVlT3JVcGRhdGVyKSB7XG4gICAgICAgIGlmIChzeW5jU2VsZWN0b3JTZXRGaW5pc2hlZCkge1xuICAgICAgICAgIGNvbnN0IG1zZyA9ICdSZWNvaWw6IEFzeW5jIHNlbGVjdG9yIHNldHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLic7XG4gICAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKG1zZyk7XG4gICAgICAgICAgdGhyb3cgUmVjb2lsX2Vycihtc2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2V0VmFsdWUgPSB0eXBlb2YgdmFsdWVPclVwZGF0ZXIgPT09ICdmdW5jdGlvbicgPyAvLyBjYXN0IHRvIGFueSBiZWNhdXNlIHdlIGNhbid0IHJlc3RyaWN0IHR5cGUgUyBmcm9tIGJlaW5nIGEgZnVuY3Rpb24gaXRzZWxmIHdpdGhvdXQgbG9zaW5nIHN1cHBvcnQgZm9yIG9wYXF1ZSB0eXBlc1xuICAgICAgICAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgICB2YWx1ZU9yVXBkYXRlcihnZXRSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSkpIDogdmFsdWVPclVwZGF0ZXI7XG4gICAgICAgIGNvbnN0IHVwc3RyZWFtV3JpdGVzID0gc2V0Tm9kZVZhbHVlJDMoc3RvcmUsIHN0YXRlLCByZWNvaWxTdGF0ZS5rZXksIHNldFZhbHVlKTtcbiAgICAgICAgdXBzdHJlYW1Xcml0ZXMuZm9yRWFjaCgodiwgaykgPT4gd3JpdGVzLnNldChrLCB2KSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlc2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgICAgICAgc2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUsIERFRkFVTFRfVkFMVUUkNik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJldCA9IHNldCh7XG4gICAgICAgIHNldDogc2V0UmVjb2lsU3RhdGUsXG4gICAgICAgIGdldDogZ2V0UmVjb2lsVmFsdWUsXG4gICAgICAgIHJlc2V0OiByZXNldFJlY29pbFN0YXRlXG4gICAgICB9LCBuZXdWYWx1ZSk7IC8vIHNldCBzaG91bGQgYmUgYSB2b2lkIG1ldGhvZCwgYnV0IGlmIHRoZSB1c2VyIG1ha2VzIGl0IGBhc3luY2AsIHRoZW4gaXRcbiAgICAgIC8vIHdpbGwgcmV0dXJuIGEgUHJvbWlzZSwgd2hpY2ggd2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQuXG5cbiAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBSZWNvaWxfaXNQcm9taXNlKHJldCkgPyBSZWNvaWxfZXJyKCdSZWNvaWw6IEFzeW5jIHNlbGVjdG9yIHNldHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLicpIDogUmVjb2lsX2VycignUmVjb2lsOiBzZWxlY3RvciBzZXQgc2hvdWxkIGJlIGEgdm9pZCBmdW5jdGlvbi4nKTtcbiAgICAgIH1cblxuICAgICAgc3luY1NlbGVjdG9yU2V0RmluaXNoZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHdyaXRlcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlY29pbFZhbHVlID0gcmVnaXN0ZXJOb2RlJDEoe1xuICAgICAga2V5LFxuICAgICAgbm9kZVR5cGU6ICdzZWxlY3RvcicsXG4gICAgICBwZWVrOiBzZWxlY3RvclBlZWssXG4gICAgICBnZXQ6IHNlbGVjdG9yR2V0LFxuICAgICAgc2V0OiBzZWxlY3RvclNldCxcbiAgICAgIGluaXQ6IHNlbGVjdG9ySW5pdCxcbiAgICAgIGludmFsaWRhdGU6IGludmFsaWRhdGVTZWxlY3RvcixcbiAgICAgIGNsZWFyQ2FjaGU6IGNsZWFyU2VsZWN0b3JDYWNoZSxcbiAgICAgIHNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZTogc2VsZWN0b3JTaG91bGREZWxldGVDb25maWdPblJlbGVhc2UsXG4gICAgICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSxcbiAgICAgIHNob3VsZFJlc3RvcmVGcm9tU25hcHNob3RzOiBmYWxzZSxcbiAgICAgIHJldGFpbmVkQnlcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVjb2lsVmFsdWUgPSByZWdpc3Rlck5vZGUkMSh7XG4gICAgICBrZXksXG4gICAgICBub2RlVHlwZTogJ3NlbGVjdG9yJyxcbiAgICAgIHBlZWs6IHNlbGVjdG9yUGVlayxcbiAgICAgIGdldDogc2VsZWN0b3JHZXQsXG4gICAgICBpbml0OiBzZWxlY3RvckluaXQsXG4gICAgICBpbnZhbGlkYXRlOiBpbnZhbGlkYXRlU2VsZWN0b3IsXG4gICAgICBjbGVhckNhY2hlOiBjbGVhclNlbGVjdG9yQ2FjaGUsXG4gICAgICBzaG91bGREZWxldGVDb25maWdPblJlbGVhc2U6IHNlbGVjdG9yU2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlLFxuICAgICAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHksXG4gICAgICBzaG91bGRSZXN0b3JlRnJvbVNuYXBzaG90czogZmFsc2UsXG4gICAgICByZXRhaW5lZEJ5XG4gICAgfSk7XG4gIH1cbn1cbi8qIGVzbGludC1lbmFibGUgbm8tcmVkZWNsYXJlICovXG4vLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS11c2VdXG5cblxuc2VsZWN0b3IudmFsdWUgPSB2YWx1ZSA9PiBuZXcgV3JhcHBlZFZhbHVlJDEodmFsdWUpO1xuXG52YXIgUmVjb2lsX3NlbGVjdG9yID0gc2VsZWN0b3I7XG5cbi8vIEBmYi1vbmx5OiBpbXBvcnQgdHlwZSB7U2NvcGVSdWxlc30gZnJvbSAnUmVjb2lsX1Njb3BlZEF0b20nO1xuLy8gQGZiLW9ubHk6IGNvbnN0IHtzY29wZWRBdG9tfSA9IHJlcXVpcmUoJ1JlY29pbF9TY29wZWRBdG9tJyk7XG5jb25zdCB7XG4gIGlzTG9hZGFibGU6IGlzTG9hZGFibGUkMixcbiAgbG9hZGFibGVXaXRoRXJyb3I6IGxvYWRhYmxlV2l0aEVycm9yJDIsXG4gIGxvYWRhYmxlV2l0aFByb21pc2U6IGxvYWRhYmxlV2l0aFByb21pc2UkMixcbiAgbG9hZGFibGVXaXRoVmFsdWU6IGxvYWRhYmxlV2l0aFZhbHVlJDNcbn0gPSBSZWNvaWxfTG9hZGFibGUkMTtcblxuY29uc3Qge1xuICBXcmFwcGVkVmFsdWU6IFdyYXBwZWRWYWx1ZSQyXG59ID0gUmVjb2lsX1dyYXBwZXIkMTtcblxuY29uc3Qge1xuICBwZWVrTm9kZUluZm86IHBlZWtOb2RlSW5mbyQzXG59ID0gUmVjb2lsX0Z1bmN0aW9uYWxDb3JlO1xuXG5jb25zdCB7XG4gIERFRkFVTFRfVkFMVUU6IERFRkFVTFRfVkFMVUUkNyxcbiAgRGVmYXVsdFZhbHVlOiBEZWZhdWx0VmFsdWUkMixcbiAgZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyOiBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMixcbiAgcmVnaXN0ZXJOb2RlOiByZWdpc3Rlck5vZGUkMixcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyOiBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMVxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkNFxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xuXG5jb25zdCB7XG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZTogZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDQsXG4gIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkOiBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQyLFxuICBzZXRSZWNvaWxWYWx1ZTogc2V0UmVjb2lsVmFsdWUkNCxcbiAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZTogc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdDogcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0JDJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgdW53cmFwID0geCA9PiB4IGluc3RhbmNlb2YgV3JhcHBlZFZhbHVlJDIgPyB4LnZhbHVlIDogeDtcblxuZnVuY3Rpb24gYmFzZUF0b20ob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAga2V5LFxuICAgIHBlcnNpc3RlbmNlX1VOU1RBQkxFOiBwZXJzaXN0ZW5jZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmV0YWluZWRCeSA9IHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCQyKG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSk7XG4gIGxldCBsaXZlU3RvcmVzQ291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIHVud3JhcFByb21pc2UocHJvbWlzZSkge1xuICAgIHJldHVybiBsb2FkYWJsZVdpdGhQcm9taXNlJDIocHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgIGRlZmF1bHRMb2FkYWJsZSA9IGxvYWRhYmxlV2l0aFZhbHVlJDModmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIGRlZmF1bHRMb2FkYWJsZSA9IGxvYWRhYmxlV2l0aEVycm9yJDIoZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSkpO1xuICB9XG5cbiAgbGV0IGRlZmF1bHRMb2FkYWJsZSA9IFJlY29pbF9pc1Byb21pc2Uob3B0aW9ucy5kZWZhdWx0KSA/IHVud3JhcFByb21pc2Uob3B0aW9ucy5kZWZhdWx0KSA6IGlzTG9hZGFibGUkMihvcHRpb25zLmRlZmF1bHQpID8gb3B0aW9ucy5kZWZhdWx0LnN0YXRlID09PSAnbG9hZGluZycgPyB1bndyYXBQcm9taXNlKG9wdGlvbnMuZGVmYXVsdC5jb250ZW50cykgOiBvcHRpb25zLmRlZmF1bHQgOiBsb2FkYWJsZVdpdGhWYWx1ZSQzKHVud3JhcChvcHRpb25zLmRlZmF1bHQpKTtcbiAgbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZShkZWZhdWx0TG9hZGFibGUuY29udGVudHMpO1xuICBsZXQgY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSA9IHVuZGVmaW5lZDsgLy8gQ2xlYW51cCBoYW5kbGVycyBmb3IgdGhpcyBhdG9tXG4gIC8vIFJlbHkgb24gc3RhYmxlIHJlZmVyZW5jZSBlcXVhbGl0eSBvZiB0aGUgc3RvcmUgdG8gdXNlIGl0IGFzIGEga2V5IHBlciA8UmVjb2lsUm9vdD5cblxuICBjb25zdCBjbGVhbnVwRWZmZWN0c0J5U3RvcmUgPSBuZXcgTWFwKCk7XG5cbiAgZnVuY3Rpb24gbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZSh2YWx1ZU9yUHJvbWlzZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmIChvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5ICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKHZhbHVlT3JQcm9taXNlKSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZU9yUHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIFJlY29pbF9kZWVwRnJlZXplVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFJlY29pbF9kZWVwRnJlZXplVmFsdWUodmFsdWVPclByb21pc2UpO1xuICAgICAgICAgIHJldHVybiB2YWx1ZU9yUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZU9yUHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBQZW5kaW5nUHJvbWlzZShzdG9yZSwgcHJvbWlzZSkge1xuICAgIGNvbnN0IHdyYXBwZWRQcm9taXNlID0gcHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQsIF9zdGF0ZSRhdG9tVmFsdWVzJGdldDtcblxuICAgICAgY29uc3Qgc3RhdGUgPSAoX3N0b3JlJGdldFN0YXRlJG5leHRUID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlJGdldFN0YXRlJG5leHRUICE9PSB2b2lkIDAgPyBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgOiBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xuXG4gICAgICBpZiAoKChfc3RhdGUkYXRvbVZhbHVlcyRnZXQgPSBzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZSRhdG9tVmFsdWVzJGdldC5jb250ZW50cykgPT09IHdyYXBwZWRQcm9taXNlKSB7XG4gICAgICAgIHNldFJlY29pbFZhbHVlJDQoc3RvcmUsIG5vZGUsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQyLCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQyO1xuXG4gICAgICBjb25zdCBzdGF0ZSA9IChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQyID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlJGdldFN0YXRlJG5leHRUMiAhPT0gdm9pZCAwID8gX3N0b3JlJGdldFN0YXRlJG5leHRUMiA6IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XG5cbiAgICAgIGlmICgoKF9zdGF0ZSRhdG9tVmFsdWVzJGdldDIgPSBzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGUkYXRvbVZhbHVlcyRnZXQyLmNvbnRlbnRzKSA9PT0gd3JhcHBlZFByb21pc2UpIHtcbiAgICAgICAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQyKHN0b3JlLCBub2RlLCBsb2FkYWJsZVdpdGhFcnJvciQyKGVycm9yKSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIHJldHVybiB3cmFwcGVkUHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRBdG9tKHN0b3JlLCBpbml0U3RhdGUsIHRyaWdnZXIpIHtcbiAgICB2YXIgX29wdGlvbnMkZWZmZWN0cztcblxuICAgIGxpdmVTdG9yZXNDb3VudCsrO1xuXG4gICAgY29uc3QgY2xlYW51cEF0b20gPSAoKSA9PiB7XG4gICAgICB2YXIgX2NsZWFudXBFZmZlY3RzQnlTdG9yO1xuXG4gICAgICBsaXZlU3RvcmVzQ291bnQtLTtcbiAgICAgIChfY2xlYW51cEVmZmVjdHNCeVN0b3IgPSBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuZ2V0KHN0b3JlKSkgPT09IG51bGwgfHwgX2NsZWFudXBFZmZlY3RzQnlTdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY2xlYW51cEVmZmVjdHNCeVN0b3IuZm9yRWFjaChjbGVhbnVwID0+IGNsZWFudXAoKSk7XG4gICAgICBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuZGVsZXRlKHN0b3JlKTtcbiAgICB9O1xuXG4gICAgc3RvcmUuZ2V0U3RhdGUoKS5rbm93bkF0b21zLmFkZChrZXkpOyAvLyBTZXR1cCBhc3luYyBkZWZhdWx0cyB0byBub3RpZnkgc3Vic2NyaWJlcnMgd2hlbiB0aGV5IHJlc29sdmVcblxuICAgIGlmIChkZWZhdWx0TG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgY29uc3Qgbm90aWZ5RGVmYXVsdFN1YnNjcmliZXJzID0gKCkgPT4ge1xuICAgICAgICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRUMztcblxuICAgICAgICBjb25zdCBzdGF0ZSA9IChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQzID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlJGdldFN0YXRlJG5leHRUMyAhPT0gdm9pZCAwID8gX3N0b3JlJGdldFN0YXRlJG5leHRUMyA6IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5hdG9tVmFsdWVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQkMihzdG9yZSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGRlZmF1bHRMb2FkYWJsZS5jb250ZW50cy5maW5hbGx5KG5vdGlmeURlZmF1bHRTdWJzY3JpYmVycyk7XG4gICAgfSAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gUnVuIEF0b20gRWZmZWN0c1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4gICAgY29uc3QgZWZmZWN0cyA9IChfb3B0aW9ucyRlZmZlY3RzID0gb3B0aW9ucy5lZmZlY3RzKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRlZmZlY3RzICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRlZmZlY3RzIDogb3B0aW9ucy5lZmZlY3RzX1VOU1RBQkxFO1xuXG4gICAgaWYgKGVmZmVjdHMgIT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBzdGF0ZSBpcyBzY29wZWQgYnkgU3RvcmUsIHNpbmNlIHRoaXMgaXMgaW4gdGhlIGluaXRBdG9tKCkgY2xvc3VyZVxuICAgICAgbGV0IGluaXRWYWx1ZSA9IERFRkFVTFRfVkFMVUUkNztcbiAgICAgIGxldCBpc0R1cmluZ0luaXQgPSB0cnVlO1xuICAgICAgbGV0IGlzSW5pdEVycm9yID0gZmFsc2U7XG4gICAgICBsZXQgcGVuZGluZ1NldFNlbGYgPSBudWxsO1xuXG4gICAgICBmdW5jdGlvbiBnZXRMb2FkYWJsZShyZWNvaWxWYWx1ZSkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSBjYW4ganVzdCBnZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYW5vdGhlciBhdG9tLlxuICAgICAgICAvLyBCdXQgZm9yIG91ciBvd24gdmFsdWUgd2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBhIHBlbmRpbmdcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQgdmFsdWUgb3IgZ2V0IHRoZSBmYWxsYmFjayBkZWZhdWx0IHZhbHVlLlxuICAgICAgICBpZiAoaXNEdXJpbmdJbml0ICYmIHJlY29pbFZhbHVlLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgLy8gQ2FzdCBUIHRvIFNcbiAgICAgICAgICBjb25zdCByZXRWYWx1ZSA9IGluaXRWYWx1ZTsgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cbiAgICAgICAgICByZXR1cm4gcmV0VmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IHBlZWtBdG9tKHN0b3JlLCBpbml0U3RhdGUpIC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgICAgIDogUmVjb2lsX2lzUHJvbWlzZShyZXRWYWx1ZSkgPyBsb2FkYWJsZVdpdGhQcm9taXNlJDIocmV0VmFsdWUudGhlbih2ID0+IHYgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IC8vIENhc3QgVCB0byBTXG4gICAgICAgICAgZGVmYXVsdExvYWRhYmxlLnRvUHJvbWlzZSgpIC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgICAgIDogdikpIDogbG9hZGFibGVXaXRoVmFsdWUkMyhyZXRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDQoc3RvcmUsIHJlY29pbFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UHJvbWlzZShyZWNvaWxWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZ2V0TG9hZGFibGUocmVjb2lsVmFsdWUpLnRvUHJvbWlzZSgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRJbmZvX1VOU1RBQkxFKHJlY29pbFZhbHVlKSB7XG4gICAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ0O1xuXG4gICAgICAgIGNvbnN0IGluZm8gPSBwZWVrTm9kZUluZm8kMyhzdG9yZSwgKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDQgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ0ICE9PSB2b2lkIDAgPyBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ0IDogc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSwgcmVjb2lsVmFsdWUua2V5KTtcbiAgICAgICAgcmV0dXJuIGlzRHVyaW5nSW5pdCAmJiByZWNvaWxWYWx1ZS5rZXkgPT09IGtleSAmJiAhKGluaXRWYWx1ZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyKSA/IHsgLi4uaW5mbyxcbiAgICAgICAgICBpc1NldDogdHJ1ZSxcbiAgICAgICAgICBsb2FkYWJsZTogZ2V0TG9hZGFibGUocmVjb2lsVmFsdWUpXG4gICAgICAgIH0gOiBpbmZvO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXRTZWxmID0gZWZmZWN0ID0+IHZhbHVlT3JVcGRhdGVyID0+IHtcbiAgICAgICAgaWYgKGlzRHVyaW5nSW5pdCkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRMb2FkYWJsZSA9IGdldExvYWRhYmxlKG5vZGUpO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRMb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJyA/IGN1cnJlbnRMb2FkYWJsZS5jb250ZW50cyA6IERFRkFVTFRfVkFMVUUkNztcbiAgICAgICAgICBpbml0VmFsdWUgPSB0eXBlb2YgdmFsdWVPclVwZGF0ZXIgPT09ICdmdW5jdGlvbicgPyAvLyBjYXN0IHRvIGFueSBiZWNhdXNlIHdlIGNhbid0IHJlc3RyaWN0IFQgZnJvbSBiZWluZyBhIGZ1bmN0aW9uIHdpdGhvdXQgbG9zaW5nIHN1cHBvcnQgZm9yIG9wYXF1ZSB0eXBlc1xuICAgICAgICAgIHZhbHVlT3JVcGRhdGVyKGN1cnJlbnRWYWx1ZSkgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gICAgICAgICAgOiB2YWx1ZU9yVXBkYXRlcjtcblxuICAgICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKGluaXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGluaXRWYWx1ZSA9IGluaXRWYWx1ZS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgLy8gQXZvaWQgY2FsbGluZyBvblNldCgpIHdoZW4gc2V0U2VsZigpIGluaXRpYWxpemVzIHdpdGggYSBQcm9taXNlXG4gICAgICAgICAgICAgIHBlbmRpbmdTZXRTZWxmID0ge1xuICAgICAgICAgICAgICAgIGVmZmVjdCxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UodmFsdWVPclVwZGF0ZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdTZXR0aW5nIGF0b21zIHRvIGFzeW5jIHZhbHVlcyBpcyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZU9yVXBkYXRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcGVuZGluZ1NldFNlbGYgPSB7XG4gICAgICAgICAgICAgIGVmZmVjdCxcbiAgICAgICAgICAgICAgdmFsdWU6IHVud3JhcCh2YWx1ZU9yVXBkYXRlcilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0UmVjb2lsVmFsdWUkNChzdG9yZSwgbm9kZSwgdHlwZW9mIHZhbHVlT3JVcGRhdGVyID09PSAnZnVuY3Rpb24nID8gY3VycmVudFZhbHVlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdW53cmFwKCAvLyBjYXN0IHRvIGFueSBiZWNhdXNlIHdlIGNhbid0IHJlc3RyaWN0IFQgZnJvbSBiZWluZyBhIGZ1bmN0aW9uIHdpdGhvdXQgbG9zaW5nIHN1cHBvcnQgZm9yIG9wYXF1ZSB0eXBlc1xuICAgICAgICAgICAgdmFsdWVPclVwZGF0ZXIoY3VycmVudFZhbHVlKSAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwZW5kaW5nU2V0U2VsZiA9IHtcbiAgICAgICAgICAgICAgZWZmZWN0LFxuICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgICAgICAgfSA6IHVud3JhcCh2YWx1ZU9yVXBkYXRlcikpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXNldFNlbGYgPSBlZmZlY3QgPT4gKCkgPT4gc2V0U2VsZihlZmZlY3QpKERFRkFVTFRfVkFMVUUkNyk7XG5cbiAgICAgIGNvbnN0IG9uU2V0ID0gZWZmZWN0ID0+IGhhbmRsZXIgPT4ge1xuICAgICAgICB2YXIgX2NsZWFudXBFZmZlY3RzQnlTdG9yMjtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVsZWFzZVxuICAgICAgICB9ID0gc3RvcmUuc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnMoY3VycmVudFN0b3JlID0+IHtcbiAgICAgICAgICB2YXIgX2N1cnJlbnRUcmVlJGF0b21WYWx1O1xuXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBjdXJyZW50VHJlZSxcbiAgICAgICAgICAgIHByZXZpb3VzVHJlZVxuICAgICAgICAgIH0gPSBjdXJyZW50U3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgICAgIGlmICghcHJldmlvdXNUcmVlKSB7XG4gICAgICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ1RyYW5zYWN0aW9uIHN1YnNjcmliZXJzIG5vdGlmaWVkIHdpdGhvdXQgYSBuZXh0IHRyZWUgYmVpbmcgcHJlc2VudCAtLSB0aGlzIGlzIGEgYnVnIGluIFJlY29pbCcpO1xuICAgICAgICAgICAgcHJldmlvdXNUcmVlID0gY3VycmVudFRyZWU7IC8vIGF0dGVtcHQgdG8gdHJ1bmRsZSBvblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG5ld0xvYWRhYmxlID0gKF9jdXJyZW50VHJlZSRhdG9tVmFsdSA9IGN1cnJlbnRUcmVlLmF0b21WYWx1ZXMuZ2V0KGtleSkpICE9PSBudWxsICYmIF9jdXJyZW50VHJlZSRhdG9tVmFsdSAhPT0gdm9pZCAwID8gX2N1cnJlbnRUcmVlJGF0b21WYWx1IDogZGVmYXVsdExvYWRhYmxlO1xuXG4gICAgICAgICAgaWYgKG5ld0xvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnKSB7XG4gICAgICAgICAgICB2YXIgX3ByZXZpb3VzVHJlZSRhdG9tVmFsLCBfcGVuZGluZ1NldFNlbGYsIF9wZW5kaW5nU2V0U2VsZjIsIF9wZW5kaW5nU2V0U2VsZjM7XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gbmV3TG9hZGFibGUuY29udGVudHM7XG4gICAgICAgICAgICBjb25zdCBvbGRMb2FkYWJsZSA9IChfcHJldmlvdXNUcmVlJGF0b21WYWwgPSBwcmV2aW91c1RyZWUuYXRvbVZhbHVlcy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX3ByZXZpb3VzVHJlZSRhdG9tVmFsICE9PSB2b2lkIDAgPyBfcHJldmlvdXNUcmVlJGF0b21WYWwgOiBkZWZhdWx0TG9hZGFibGU7XG4gICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IG9sZExvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnID8gb2xkTG9hZGFibGUuY29udGVudHMgOiBERUZBVUxUX1ZBTFVFJDc7IC8vIFRPRE8gVGhpcyBpc24ndCBhY3R1YWxseSB2YWxpZCwgdXNlIGFzIGEgcGxhY2Vob2xkZXIgZm9yIG5vdy5cbiAgICAgICAgICAgIC8vIElnbm9yZSBhdG9tIHZhbHVlIGNoYW5nZXMgdGhhdCB3ZXJlIHNldCB2aWEgc2V0U2VsZigpIGluIHRoZSBzYW1lIGVmZmVjdC5cbiAgICAgICAgICAgIC8vIFdlIHdpbGwgc3RpbGwgcHJvcGVybHkgY2FsbCB0aGUgaGFuZGxlciBpZiB0aGVyZSB3YXMgYSBzdWJzZXF1ZW50XG4gICAgICAgICAgICAvLyBzZXQgZnJvbSBzb21ldGhpbmcgb3RoZXIgdGhhbiBhbiBhdG9tIGVmZmVjdCB3aGljaCB3YXMgYmF0Y2hlZFxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgYHNldFNlbGYoKWAgY2FsbC4gIEhvd2V2ZXIsIHdlIG1heSBpbmNvcnJlY3RseSBpZ25vcmVcbiAgICAgICAgICAgIC8vIHRoZSBoYW5kbGVyIGlmIHRoZSBzdWJzZXF1ZW50IGJhdGNoZWQgY2FsbCBoYXBwZW5zIHRvIHNldCB0aGVcbiAgICAgICAgICAgIC8vIGF0b20gdG8gdGhlIGV4YWN0IHNhbWUgdmFsdWUgYXMgdGhlIGBzZXRTZWxmKClgLiAgIEJ1dCwgaW4gdGhhdFxuICAgICAgICAgICAgLy8gY2FzZSwgaXQgd2FzIGtpbmQgb2YgYSBub29wLCBzbyB0aGUgc2VtYW50aWNzIGFyZSBkZWJhdGFibGUuLlxuXG4gICAgICAgICAgICBpZiAoKChfcGVuZGluZ1NldFNlbGYgPSBwZW5kaW5nU2V0U2VsZikgPT09IG51bGwgfHwgX3BlbmRpbmdTZXRTZWxmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ1NldFNlbGYuZWZmZWN0KSAhPT0gZWZmZWN0IHx8ICgoX3BlbmRpbmdTZXRTZWxmMiA9IHBlbmRpbmdTZXRTZWxmKSA9PT0gbnVsbCB8fCBfcGVuZGluZ1NldFNlbGYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ1NldFNlbGYyLnZhbHVlKSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgaGFuZGxlcihuZXdWYWx1ZSwgb2xkVmFsdWUsICFjdXJyZW50VHJlZS5hdG9tVmFsdWVzLmhhcyhrZXkpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChfcGVuZGluZ1NldFNlbGYzID0gcGVuZGluZ1NldFNlbGYpID09PSBudWxsIHx8IF9wZW5kaW5nU2V0U2VsZjMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wZW5kaW5nU2V0U2VsZjMuZWZmZWN0KSA9PT0gZWZmZWN0KSB7XG4gICAgICAgICAgICAgIHBlbmRpbmdTZXRTZWxmID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIGtleSk7XG4gICAgICAgIGNsZWFudXBFZmZlY3RzQnlTdG9yZS5zZXQoc3RvcmUsIFsuLi4oKF9jbGVhbnVwRWZmZWN0c0J5U3RvcjIgPSBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuZ2V0KHN0b3JlKSkgIT09IG51bGwgJiYgX2NsZWFudXBFZmZlY3RzQnlTdG9yMiAhPT0gdm9pZCAwID8gX2NsZWFudXBFZmZlY3RzQnlTdG9yMiA6IFtdKSwgcmVsZWFzZV0pO1xuICAgICAgfTtcblxuICAgICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBlZmZlY3Qoe1xuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHN0b3JlSUQ6IHN0b3JlLnN0b3JlSUQsXG4gICAgICAgICAgICBwYXJlbnRTdG9yZUlEX1VOU1RBQkxFOiBzdG9yZS5wYXJlbnRTdG9yZUlELFxuICAgICAgICAgICAgdHJpZ2dlcixcbiAgICAgICAgICAgIHNldFNlbGY6IHNldFNlbGYoZWZmZWN0KSxcbiAgICAgICAgICAgIHJlc2V0U2VsZjogcmVzZXRTZWxmKGVmZmVjdCksXG4gICAgICAgICAgICBvblNldDogb25TZXQoZWZmZWN0KSxcbiAgICAgICAgICAgIGdldFByb21pc2UsXG4gICAgICAgICAgICBnZXRMb2FkYWJsZSxcbiAgICAgICAgICAgIGdldEluZm9fVU5TVEFCTEVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChjbGVhbnVwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfY2xlYW51cEVmZmVjdHNCeVN0b3IzO1xuXG4gICAgICAgICAgICBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuc2V0KHN0b3JlLCBbLi4uKChfY2xlYW51cEVmZmVjdHNCeVN0b3IzID0gY2xlYW51cEVmZmVjdHNCeVN0b3JlLmdldChzdG9yZSkpICE9PSBudWxsICYmIF9jbGVhbnVwRWZmZWN0c0J5U3RvcjMgIT09IHZvaWQgMCA/IF9jbGVhbnVwRWZmZWN0c0J5U3RvcjMgOiBbXSksIGNsZWFudXBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaW5pdFZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgaXNJbml0RXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlzRHVyaW5nSW5pdCA9IGZhbHNlOyAvLyBNdXRhdGUgaW5pdGlhbCBzdGF0ZSBpbiBwbGFjZSBzaW5jZSB3ZSBrbm93IHRoZXJlIGFyZSBubyBvdGhlciBzdWJzY3JpYmVyc1xuICAgICAgLy8gc2luY2Ugd2UgYXJlIHRoZSBvbmVzIGluaXRpYWxpemluZyBvbiBmaXJzdCB1c2UuXG5cbiAgICAgIGlmICghKGluaXRWYWx1ZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyKSkge1xuICAgICAgICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRUNTtcblxuICAgICAgICBjb25zdCBpbml0TG9hZGFibGUgPSBpc0luaXRFcnJvciA/IGxvYWRhYmxlV2l0aEVycm9yJDIoaW5pdFZhbHVlKSA6IFJlY29pbF9pc1Byb21pc2UoaW5pdFZhbHVlKSA/IGxvYWRhYmxlV2l0aFByb21pc2UkMih3cmFwUGVuZGluZ1Byb21pc2Uoc3RvcmUsIGluaXRWYWx1ZSkpIDogbG9hZGFibGVXaXRoVmFsdWUkMyh1bndyYXAoaW5pdFZhbHVlKSk7XG4gICAgICAgIG1heWJlRnJlZXplVmFsdWVPclByb21pc2UoaW5pdExvYWRhYmxlLmNvbnRlbnRzKTtcbiAgICAgICAgaW5pdFN0YXRlLmF0b21WYWx1ZXMuc2V0KGtleSwgaW5pdExvYWRhYmxlKTsgLy8gSWYgdGhlcmUgaXMgYSBwZW5kaW5nIHRyYW5zYWN0aW9uLCB0aGVuIGFsc28gbXV0YXRlIHRoZSBuZXh0IHN0YXRlIHRyZWUuXG4gICAgICAgIC8vIFRoaXMgY291bGQgaGFwcGVuIGlmIHRoZSBhdG9tIHdhcyBmaXJzdCBpbml0aWFsaXplZCBpbiBhbiBhY3Rpb24gdGhhdFxuICAgICAgICAvLyBhbHNvIHVwZGF0ZWQgc29tZSBvdGhlciBhdG9tJ3Mgc3RhdGUuXG5cbiAgICAgICAgKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1LmF0b21WYWx1ZXMuc2V0KGtleSwgaW5pdExvYWRhYmxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xlYW51cEF0b207XG4gIH1cblxuICBmdW5jdGlvbiBwZWVrQXRvbShfc3RvcmUsIHN0YXRlKSB7XG4gICAgdmFyIF9yZWYsIF9zdGF0ZSRhdG9tVmFsdWVzJGdldDM7XG5cbiAgICByZXR1cm4gKF9yZWYgPSAoX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MyA9IHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSkpICE9PSBudWxsICYmIF9zdGF0ZSRhdG9tVmFsdWVzJGdldDMgIT09IHZvaWQgMCA/IF9zdGF0ZSRhdG9tVmFsdWVzJGdldDMgOiBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogZGVmYXVsdExvYWRhYmxlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QXRvbShfc3RvcmUsIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmF0b21WYWx1ZXMuaGFzKGtleSkpIHtcbiAgICAgIC8vIEF0b20gdmFsdWUgaXMgc3RvcmVkIGluIHN0YXRlOlxuICAgICAgcmV0dXJuIFJlY29pbF9udWxsdGhyb3dzKHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSkpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuaGFzKGtleSkpIHtcbiAgICAgIC8vIEF0b20gdmFsdWUgaXMgc3RvcmVkIGJ1dCBuZWVkcyB2YWxpZGF0aW9uIGJlZm9yZSB1c2UuXG4gICAgICAvLyBXZSBtaWdodCBoYXZlIGFscmVhZHkgdmFsaWRhdGVkIGl0IGFuZCBoYXZlIGEgY2FjaGVkIHZhbGlkYXRlZCB2YWx1ZTpcbiAgICAgIGlmIChjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwZXJzaXN0ZW5jZSA9PSBudWxsKSB7XG4gICAgICAgIFJlY29pbF9leHBlY3RhdGlvblZpb2xhdGlvbihgVHJpZWQgdG8gcmVzdG9yZSBhIHBlcnNpc3RlZCB2YWx1ZSBmb3IgYXRvbSAke2tleX0gYnV0IGl0IGhhcyBubyBwZXJzaXN0ZW5jZSBzZXR0aW5ncy5gKTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2FkYWJsZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9udmFsaWRhdGVkVmFsdWUgPSBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5nZXQoa2V5KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRvclJlc3VsdCA9IHBlcnNpc3RlbmNlLnZhbGlkYXRvcihub252YWxpZGF0ZWRWYWx1ZSwgREVGQVVMVF9WQUxVRSQ3KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFZhbHVlTG9hZGFibGUgPSB2YWxpZGF0b3JSZXN1bHQgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IGRlZmF1bHRMb2FkYWJsZSA6IGxvYWRhYmxlV2l0aFZhbHVlJDModmFsaWRhdG9yUmVzdWx0KTtcbiAgICAgIGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWUgPSB2YWxpZGF0ZWRWYWx1ZUxvYWRhYmxlO1xuICAgICAgcmV0dXJuIGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZWZhdWx0TG9hZGFibGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZUF0b20oKSB7XG4gICAgY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEF0b20oX3N0b3JlLCBzdGF0ZSwgbmV3VmFsdWUpIHtcbiAgICAvLyBCYWlsIG91dCBpZiB3ZSdyZSBiZWluZyBzZXQgdG8gdGhlIGV4aXN0aW5nIHZhbHVlLCBvciBpZiB3ZSdyZSBiZWluZ1xuICAgIC8vIHJlc2V0IGJ1dCBoYXZlIG5vIHN0b3JlZCB2YWx1ZSAodmFsaWRhdGVkIG9yIHVudmFsaWRhdGVkKSB0byByZXNldCBmcm9tOlxuICAgIGlmIChzdGF0ZS5hdG9tVmFsdWVzLmhhcyhrZXkpKSB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IFJlY29pbF9udWxsdGhyb3dzKHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSkpO1xuXG4gICAgICBpZiAoZXhpc3Rpbmcuc3RhdGUgPT09ICdoYXNWYWx1ZScgJiYgbmV3VmFsdWUgPT09IGV4aXN0aW5nLmNvbnRlbnRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuaGFzKGtleSkgJiYgbmV3VmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMikge1xuICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBtYXliZUZyZWV6ZVZhbHVlT3JQcm9taXNlKG5ld1ZhbHVlKTtcbiAgICBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlID0gdW5kZWZpbmVkOyAvLyBjYW4gYmUgcmVsZWFzZWQgbm93IGlmIGl0IHdhcyBwcmV2aW91c2x5IGluIHVzZVxuXG4gICAgcmV0dXJuIG5ldyBNYXAoKS5zZXQoa2V5LCBsb2FkYWJsZVdpdGhWYWx1ZSQzKG5ld1ZhbHVlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGREZWxldGVDb25maWdPblJlbGVhc2VBdG9tKCkge1xuICAgIHJldHVybiBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMihrZXkpICE9PSB1bmRlZmluZWQgJiYgbGl2ZVN0b3Jlc0NvdW50IDw9IDA7XG4gIH1cblxuICBjb25zdCBub2RlID0gcmVnaXN0ZXJOb2RlJDIoe1xuICAgIGtleSxcbiAgICBub2RlVHlwZTogJ2F0b20nLFxuICAgIHBlZWs6IHBlZWtBdG9tLFxuICAgIGdldDogZ2V0QXRvbSxcbiAgICBzZXQ6IHNldEF0b20sXG4gICAgaW5pdDogaW5pdEF0b20sXG4gICAgaW52YWxpZGF0ZTogaW52YWxpZGF0ZUF0b20sXG4gICAgc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlOiBzaG91bGREZWxldGVDb25maWdPblJlbGVhc2VBdG9tLFxuICAgIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiBvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5LFxuICAgIHBlcnNpc3RlbmNlX1VOU1RBQkxFOiBvcHRpb25zLnBlcnNpc3RlbmNlX1VOU1RBQkxFID8ge1xuICAgICAgdHlwZTogb3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRS50eXBlLFxuICAgICAgYmFja0J1dHRvbjogb3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRS5iYWNrQnV0dG9uXG4gICAgfSA6IHVuZGVmaW5lZCxcbiAgICBzaG91bGRSZXN0b3JlRnJvbVNuYXBzaG90czogdHJ1ZSxcbiAgICByZXRhaW5lZEJ5XG4gIH0pO1xuICByZXR1cm4gbm9kZTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxuZnVuY3Rpb24gYXRvbShvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMua2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycignQSBrZXkgb3B0aW9uIHdpdGggYSB1bmlxdWUgc3RyaW5nIHZhbHVlIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBjcmVhdGluZyBhbiBhdG9tLicpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHsgLy8gQGZiLW9ubHk6IHNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUyxcbiAgICAuLi5yZXN0T3B0aW9uc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgb3B0aW9uc0RlZmF1bHQgPSAnZGVmYXVsdCcgaW4gb3B0aW9ucyA/IC8vICRGbG93SXNzdWVbcHJvcC1taXNzaW5nXSBObyB3YXkgdG8gcmVmaW5lIGluIEZsb3cgdGhhdCBwcm9wZXJ0eSBpcyBub3QgZGVmaW5lZFxuICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS10eXBlXSBObyB3YXkgdG8gcmVmaW5lIGluIEZsb3cgdGhhdCBwcm9wZXJ0eSBpcyBub3QgZGVmaW5lZFxuICBvcHRpb25zLmRlZmF1bHQgOiBuZXcgUHJvbWlzZSgoKSA9PiB7fSk7XG5cbiAgaWYgKGlzUmVjb2lsVmFsdWUkNChvcHRpb25zRGVmYXVsdCkgLy8gQ29udGludWUgdG8gdXNlIGF0b21XaXRoRmFsbGJhY2sgZm9yIHByb21pc2UgZGVmYXVsdHMgZm9yIHNjb3BlZCBhdG9tc1xuICAvLyBmb3Igbm93LCBzaW5jZSBzY29wZWQgYXRvbXMgZG9uJ3Qgc3VwcG9ydCBhc3luYyBkZWZhdWx0c1xuICAvLyBAZmItb25seTogfHwgKGlzUHJvbWlzZShvcHRpb25zRGVmYXVsdCkgJiYgc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTKVxuICAvLyBAZmItb25seTogfHwgKGlzTG9hZGFibGUob3B0aW9uc0RlZmF1bHQpICYmIHNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUylcbiAgKSB7XG4gICAgcmV0dXJuIGF0b21XaXRoRmFsbGJhY2soeyAuLi5yZXN0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHQ6IG9wdGlvbnNEZWZhdWx0IC8vIEBmYi1vbmx5OiBzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1MsXG5cbiAgICB9KTsgLy8gQGZiLW9ubHk6IH0gZWxzZSBpZiAoc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTXG4gICAgLy8gQGZiLW9ubHk6ICYmICFpc1Byb21pc2Uob3B0aW9uc0RlZmF1bHQpXG4gICAgLy8gQGZiLW9ubHk6ICYmICFpc0xvYWRhYmxlKG9wdGlvbnNEZWZhdWx0KVxuICAgIC8vIEBmYi1vbmx5OiApIHtcbiAgICAvLyBAZmItb25seTogcmV0dXJuIHNjb3BlZEF0b208VD4oe1xuICAgIC8vIEBmYi1vbmx5OiAuLi5yZXN0T3B0aW9ucyxcbiAgICAvLyBAZmItb25seTogZGVmYXVsdDogdW53cmFwPFQ+KG9wdGlvbnNEZWZhdWx0KSxcbiAgICAvLyBAZmItb25seTogc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTLFxuICAgIC8vIEBmYi1vbmx5OiB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZUF0b20oeyAuLi5yZXN0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHQ6IG9wdGlvbnNEZWZhdWx0XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXRvbVdpdGhGYWxsYmFjayhvcHRpb25zKSB7XG4gIGNvbnN0IGJhc2UgPSBhdG9tKHsgLi4ub3B0aW9ucyxcbiAgICBkZWZhdWx0OiBERUZBVUxUX1ZBTFVFJDcsXG4gICAgcGVyc2lzdGVuY2VfVU5TVEFCTEU6IG9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHsgLi4ub3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRSxcbiAgICAgIHZhbGlkYXRvcjogc3RvcmVkVmFsdWUgPT4gc3RvcmVkVmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IHN0b3JlZFZhbHVlIDogUmVjb2lsX251bGx0aHJvd3Mob3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRSkudmFsaWRhdG9yKHN0b3JlZFZhbHVlLCBERUZBVUxUX1ZBTFVFJDcpXG4gICAgfSxcbiAgICAvLyBUT0RPIEhhY2sgZm9yIG5vdy5cbiAgICBlZmZlY3RzOiBvcHRpb25zLmVmZmVjdHMsXG4gICAgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxuICAgIGVmZmVjdHNfVU5TVEFCTEU6IG9wdGlvbnMuZWZmZWN0c19VTlNUQUJMRSAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTogb2ZmXG5cbiAgfSk7XG4gIGNvbnN0IHNlbCA9IFJlY29pbF9zZWxlY3Rvcih7XG4gICAga2V5OiBgJHtvcHRpb25zLmtleX1fX3dpdGhGYWxsYmFja2AsXG4gICAgZ2V0OiAoe1xuICAgICAgZ2V0XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgYmFzZVZhbHVlID0gZ2V0KGJhc2UpO1xuICAgICAgcmV0dXJuIGJhc2VWYWx1ZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyID8gb3B0aW9ucy5kZWZhdWx0IDogYmFzZVZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiAoe1xuICAgICAgc2V0XG4gICAgfSwgbmV3VmFsdWUpID0+IHNldChiYXNlLCBuZXdWYWx1ZSksXG4gICAgLy8gVGhpcyBzZWxlY3RvciBkb2VzIG5vdCBuZWVkIHRvIGNhY2hlIGFzIGl0IGlzIGEgd3JhcHBlciBzZWxlY3RvclxuICAgIC8vIGFuZCB0aGUgc2VsZWN0b3Igd2l0aGluIHRoZSB3cmFwcGVyIHNlbGVjdG9yIHdpbGwgaGF2ZSBhIGNhY2hlXG4gICAgLy8gb3B0aW9uIGJ5IGRlZmF1bHRcbiAgICBjYWNoZVBvbGljeV9VTlNUQUJMRToge1xuICAgICAgZXZpY3Rpb246ICdtb3N0LXJlY2VudCdcbiAgICB9LFxuICAgIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiBvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5XG4gIH0pO1xuICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMShzZWwua2V5LCBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMihvcHRpb25zLmtleSkpO1xuICByZXR1cm4gc2VsO1xufVxuXG5hdG9tLnZhbHVlID0gdmFsdWUgPT4gbmV3IFdyYXBwZWRWYWx1ZSQyKHZhbHVlKTtcblxudmFyIFJlY29pbF9hdG9tID0gYXRvbTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuY2xhc3MgTWFwQ2FjaGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zJG1hcEtleTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tYXBcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9rZXlNYXBwZXJcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9rZXlNYXBwZXIgPSAoX29wdGlvbnMkbWFwS2V5ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1hcEtleSkgIT09IG51bGwgJiYgX29wdGlvbnMkbWFwS2V5ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRtYXBLZXkgOiB2ID0+IHY7XG4gIH1cblxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuc2l6ZTtcbiAgfVxuXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyh0aGlzLl9rZXlNYXBwZXIoa2V5KSk7XG4gIH1cblxuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5nZXQodGhpcy5fa2V5TWFwcGVyKGtleSkpO1xuICB9XG5cbiAgc2V0KGtleSwgdmFsKSB7XG4gICAgdGhpcy5fbWFwLnNldCh0aGlzLl9rZXlNYXBwZXIoa2V5KSwgdmFsKTtcbiAgfVxuXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9tYXAuZGVsZXRlKHRoaXMuX2tleU1hcHBlcihrZXkpKTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICB9XG5cbn1cblxudmFyIFJlY29pbF9NYXBDYWNoZSA9IHtcbiAgTWFwQ2FjaGVcbn07XG5cbnZhciBSZWNvaWxfTWFwQ2FjaGVfMSA9IFJlY29pbF9NYXBDYWNoZS5NYXBDYWNoZTtcblxudmFyIFJlY29pbF9NYXBDYWNoZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIE1hcENhY2hlOiBSZWNvaWxfTWFwQ2FjaGVfMVxufSk7XG5cbmNvbnN0IHtcbiAgTFJVQ2FjaGU6IExSVUNhY2hlJDJcbn0gPSBSZWNvaWxfTFJVQ2FjaGUkMTtcblxuY29uc3Qge1xuICBNYXBDYWNoZTogTWFwQ2FjaGUkMVxufSA9IFJlY29pbF9NYXBDYWNoZSQxO1xuXG5cblxuXG5cblxuXG5jb25zdCBkZWZhdWx0UG9saWN5JDEgPSB7XG4gIGVxdWFsaXR5OiAncmVmZXJlbmNlJyxcbiAgZXZpY3Rpb246ICdub25lJyxcbiAgbWF4U2l6ZTogSW5maW5pdHlcbn07XG5cbmZ1bmN0aW9uIGNhY2hlRnJvbVBvbGljeSh7XG4gIGVxdWFsaXR5ID0gZGVmYXVsdFBvbGljeSQxLmVxdWFsaXR5LFxuICBldmljdGlvbiA9IGRlZmF1bHRQb2xpY3kkMS5ldmljdGlvbixcbiAgbWF4U2l6ZSA9IGRlZmF1bHRQb2xpY3kkMS5tYXhTaXplXG59ID0gZGVmYXVsdFBvbGljeSQxKSB7XG4gIGNvbnN0IHZhbHVlTWFwcGVyID0gZ2V0VmFsdWVNYXBwZXIkMShlcXVhbGl0eSk7XG4gIGNvbnN0IGNhY2hlID0gZ2V0Q2FjaGUoZXZpY3Rpb24sIG1heFNpemUsIHZhbHVlTWFwcGVyKTtcbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZU1hcHBlciQxKGVxdWFsaXR5KSB7XG4gIHN3aXRjaCAoZXF1YWxpdHkpIHtcbiAgICBjYXNlICdyZWZlcmVuY2UnOlxuICAgICAgcmV0dXJuIHZhbCA9PiB2YWw7XG5cbiAgICBjYXNlICd2YWx1ZSc6XG4gICAgICByZXR1cm4gdmFsID0+IFJlY29pbF9zdGFibGVTdHJpbmdpZnkodmFsKTtcbiAgfVxuXG4gIHRocm93IFJlY29pbF9lcnIoYFVucmVjb2duaXplZCBlcXVhbGl0eSBwb2xpY3kgJHtlcXVhbGl0eX1gKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FjaGUoZXZpY3Rpb24sIG1heFNpemUsIG1hcEtleSkge1xuICBzd2l0Y2ggKGV2aWN0aW9uKSB7XG4gICAgY2FzZSAna2VlcC1hbGwnOlxuICAgICAgcmV0dXJuIG5ldyBNYXBDYWNoZSQxKHtcbiAgICAgICAgbWFwS2V5XG4gICAgICB9KTtcblxuICAgIGNhc2UgJ2xydSc6XG4gICAgICByZXR1cm4gbmV3IExSVUNhY2hlJDIoe1xuICAgICAgICBtYXBLZXksXG4gICAgICAgIG1heFNpemU6IFJlY29pbF9udWxsdGhyb3dzKG1heFNpemUpXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ21vc3QtcmVjZW50JzpcbiAgICAgIHJldHVybiBuZXcgTFJVQ2FjaGUkMih7XG4gICAgICAgIG1hcEtleSxcbiAgICAgICAgbWF4U2l6ZTogMVxuICAgICAgfSk7XG4gIH1cblxuICB0aHJvdyBSZWNvaWxfZXJyKGBVbnJlY29nbml6ZWQgZXZpY3Rpb24gcG9saWN5ICR7ZXZpY3Rpb259YCk7XG59XG5cbnZhciBSZWNvaWxfY2FjaGVGcm9tUG9saWN5ID0gY2FjaGVGcm9tUG9saWN5O1xuXG4vLyBAZmItb25seTogaW1wb3J0IHR5cGUge1Njb3BlUnVsZXN9IGZyb20gJ1JlY29pbF9TY29wZWRBdG9tJztcblxuXG5jb25zdCB7XG4gIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlcjogc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDJcbn0gPSBSZWNvaWxfTm9kZTtcblxuXG5cblxuXG4vLyBQcm9jZXNzIHNjb3BlUnVsZXMgdG8gaGFuZGxlIGFueSBlbnRyaWVzIHdoaWNoIGFyZSBmdW5jdGlvbnMgdGFraW5nIHBhcmFtZXRlcnNcbi8vIHByZXR0aWVyLWlnbm9yZVxuLy8gQGZiLW9ubHk6IGZ1bmN0aW9uIG1hcFNjb3BlUnVsZXM8UD4oXG4vLyBAZmItb25seTogc2NvcGVSdWxlcz86IFBhcmFtZXRlcml6ZWRTY29wZVJ1bGVzPFA+LFxuLy8gQGZiLW9ubHk6IHBhcmFtOiBQLFxuLy8gQGZiLW9ubHk6ICk6IFNjb3BlUnVsZXMgfCB2b2lkIHtcbi8vIEBmYi1vbmx5OiByZXR1cm4gc2NvcGVSdWxlcz8ubWFwKHJ1bGUgPT5cbi8vIEBmYi1vbmx5OiBBcnJheS5pc0FycmF5KHJ1bGUpXG4vLyBAZmItb25seTogPyBydWxlLm1hcChlbnRyeSA9PiAodHlwZW9mIGVudHJ5ID09PSAnZnVuY3Rpb24nID8gZW50cnkocGFyYW0pIDogZW50cnkpKVxuLy8gQGZiLW9ubHk6IDogcnVsZSxcbi8vIEBmYi1vbmx5OiApO1xuLy8gQGZiLW9ubHk6IH1cblxuLypcbkEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBhdG9tIGJhc2VkIG9uIHRoZSBpbnB1dCBwYXJhbWV0ZXIuXG5cbkVhY2ggdW5pcXVlIHBhcmFtZXRlciByZXR1cm5zIGEgdW5pcXVlIGF0b20uIEUuZy4sXG5cbiAgY29uc3QgZiA9IGF0b21GYW1pbHkoLi4uKTtcbiAgZih7YTogMX0pID0+IGFuIGF0b21cbiAgZih7YTogMn0pID0+IGEgZGlmZmVyZW50IGF0b21cblxuVGhpcyBhbGxvd3MgY29tcG9uZW50cyB0byBwZXJzaXN0IGxvY2FsLCBwcml2YXRlIHN0YXRlIHVzaW5nIGF0b21zLiAgRWFjaFxuaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCBtYXkgaGF2ZSBhIGRpZmZlcmVudCBrZXksIHdoaWNoIGl0IHVzZXMgYXMgdGhlXG5wYXJhbWV0ZXIgZm9yIGEgZmFtaWx5IG9mIGF0b21zOyBpbiB0aGlzIHdheSwgZWFjaCBjb21wb25lbnQgd2lsbCBoYXZlXG5pdHMgb3duIGF0b20gbm90IHNoYXJlZCBieSBvdGhlciBpbnN0YW5jZXMuICBUaGVzZSBzdGF0ZSBrZXlzIG1heSBiZSBjb21wb3NlZFxuaW50byBjaGlsZHJlbidzIHN0YXRlIGtleXMgYXMgd2VsbC5cbiovXG5mdW5jdGlvbiBhdG9tRmFtaWx5KG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGNhY2hlUG9saWN5RiwgX29wdGlvbnMkY2FjaGVQb2xpY3lGMjtcblxuICBjb25zdCBhdG9tQ2FjaGUgPSBSZWNvaWxfY2FjaGVGcm9tUG9saWN5KHtcbiAgICBlcXVhbGl0eTogKF9vcHRpb25zJGNhY2hlUG9saWN5RiA9IChfb3B0aW9ucyRjYWNoZVBvbGljeUYyID0gb3B0aW9ucy5jYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRSkgPT09IG51bGwgfHwgX29wdGlvbnMkY2FjaGVQb2xpY3lGMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkY2FjaGVQb2xpY3lGMi5lcXVhbGl0eSkgIT09IG51bGwgJiYgX29wdGlvbnMkY2FjaGVQb2xpY3lGICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRjYWNoZVBvbGljeUYgOiAndmFsdWUnLFxuICAgIGV2aWN0aW9uOiAna2VlcC1hbGwnXG4gIH0pOyAvLyBTaW1wbGUgYXRvbUZhbWlseSBpbXBsZW1lbnRhdGlvbiB0byBjYWNoZSBpbmRpdmlkdWFsIGF0b21zIGJhc2VkXG4gIC8vIG9uIHRoZSBwYXJhbWV0ZXIgdmFsdWUgZXF1YWxpdHkuXG5cbiAgcmV0dXJuIHBhcmFtcyA9PiB7XG4gICAgdmFyIF9zdGFibGVTdHJpbmdpZnksIF9vcHRpb25zJGVmZmVjdHM7XG5cbiAgICBjb25zdCBjYWNoZWRBdG9tID0gYXRvbUNhY2hlLmdldChwYXJhbXMpO1xuXG4gICAgaWYgKGNhY2hlZEF0b20gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZEF0b207XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgY2FjaGVQb2xpY3lGb3JQYXJhbXNfVU5TVEFCTEUsXG4gICAgICAuLi5hdG9tT3B0aW9uc1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG9wdGlvbnNEZWZhdWx0ID0gJ2RlZmF1bHQnIGluIG9wdGlvbnMgPyAvLyAkRmxvd0lzc3VlW3Byb3AtbWlzc2luZ10gTm8gd2F5IHRvIHJlZmluZSBpbiBGbG93IHRoYXQgcHJvcGVydHkgaXMgbm90IGRlZmluZWRcbiAgICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS10eXBlXSBObyB3YXkgdG8gcmVmaW5lIGluIEZsb3cgdGhhdCBwcm9wZXJ0eSBpcyBub3QgZGVmaW5lZFxuICAgIG9wdGlvbnMuZGVmYXVsdCA6IG5ldyBQcm9taXNlKCgpID0+IHt9KTtcbiAgICBjb25zdCBuZXdBdG9tID0gUmVjb2lsX2F0b20oeyAuLi5hdG9tT3B0aW9ucyxcbiAgICAgIGtleTogYCR7b3B0aW9ucy5rZXl9X18keyhfc3RhYmxlU3RyaW5naWZ5ID0gUmVjb2lsX3N0YWJsZVN0cmluZ2lmeShwYXJhbXMpKSAhPT0gbnVsbCAmJiBfc3RhYmxlU3RyaW5naWZ5ICE9PSB2b2lkIDAgPyBfc3RhYmxlU3RyaW5naWZ5IDogJ3ZvaWQnfWAsXG4gICAgICBkZWZhdWx0OiB0eXBlb2Ygb3B0aW9uc0RlZmF1bHQgPT09ICdmdW5jdGlvbicgPyAvLyBUaGUgZGVmYXVsdCB3YXMgcGFyYW1ldGVyaXplZFxuICAgICAgLy8gRmxvdyBkb2Vzbid0IGtub3cgdGhhdCBUIGlzbid0IGEgZnVuY3Rpb24sIHNvIHdlIG5lZWQgdG8gY2FzZSB0byBhbnlcbiAgICAgIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXVzZV1cbiAgICAgIG9wdGlvbnNEZWZhdWx0KHBhcmFtcykgOiAvLyBEZWZhdWx0IG1heSBiZSBhIHN0YXRpYyB2YWx1ZSwgcHJvbWlzZSwgb3IgUmVjb2lsVmFsdWVcbiAgICAgIG9wdGlvbnNEZWZhdWx0LFxuICAgICAgcmV0YWluZWRCeV9VTlNUQUJMRTogdHlwZW9mIG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRShwYXJhbXMpIDogb3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFLFxuICAgICAgZWZmZWN0czogdHlwZW9mIG9wdGlvbnMuZWZmZWN0cyA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZWZmZWN0cyhwYXJhbXMpIDogdHlwZW9mIG9wdGlvbnMuZWZmZWN0c19VTlNUQUJMRSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZWZmZWN0c19VTlNUQUJMRShwYXJhbXMpIDogKF9vcHRpb25zJGVmZmVjdHMgPSBvcHRpb25zLmVmZmVjdHMpICE9PSBudWxsICYmIF9vcHRpb25zJGVmZmVjdHMgIT09IHZvaWQgMCA/IF9vcHRpb25zJGVmZmVjdHMgOiBvcHRpb25zLmVmZmVjdHNfVU5TVEFCTEUgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAvLyBAZmItb25seTogc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTOiBtYXBTY29wZVJ1bGVzKFxuICAgICAgLy8gQGZiLW9ubHk6IG9wdGlvbnMuc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTLFxuICAgICAgLy8gQGZiLW9ubHk6IHBhcmFtcyxcbiAgICAgIC8vIEBmYi1vbmx5OiApLFxuXG4gICAgfSk7XG4gICAgYXRvbUNhY2hlLnNldChwYXJhbXMsIG5ld0F0b20pO1xuICAgIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQyKG5ld0F0b20ua2V5LCAoKSA9PiB7XG4gICAgICBhdG9tQ2FjaGUuZGVsZXRlKHBhcmFtcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0F0b207XG4gIH07XG59XG5cbnZhciBSZWNvaWxfYXRvbUZhbWlseSA9IGF0b21GYW1pbHk7XG5cbmNvbnN0IHtcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyOiBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkM1xufSA9IFJlY29pbF9Ob2RlO1xuXG5cblxuXG5cbiAvLyBLZWVwIGluIG1pbmQgdGhlIHBhcmFtZXRlciBuZWVkcyB0byBiZSBzZXJpYWxpemFibGUgYXMgYSBjYWhjaGUga2V5XG4vLyB1c2luZyBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5XG5cblxuLy8gQWRkIGEgdW5pcXVlIGluZGV4IHRvIGVhY2ggc2VsZWN0b3IgaW4gY2FzZSB0aGUgY2FjaGUgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4vLyBkdXBsaWNhdGUga2V5cyBiYXNlZCBvbiBlcXVpdmFsZW50IHN0cmluZ2lmaWVkIHBhcmFtZXRlcnNcbmxldCBuZXh0SW5kZXggPSAwO1xuLyogZXNsaW50LWRpc2FibGUgbm8tcmVkZWNsYXJlICovXG5cbi8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBtZW1iZXJzIG9mIGEgZmFtaWx5IG9mIHNlbGVjdG9ycyBvZiB0aGUgc2FtZSB0eXBlXG4vLyBFLmcuLFxuLy9cbi8vIGNvbnN0IHMgPSBzZWxlY3RvckZhbWlseSguLi4pO1xuLy8gcyh7YTogMX0pID0+IGEgc2VsZWN0b3Jcbi8vIHMoe2E6IDJ9KSA9PiBhIGRpZmZlcmVudCBzZWxlY3RvclxuLy9cbi8vIEJ5IGRlZmF1bHQsIHRoZSBzZWxlY3RvcnMgYXJlIGRpc3Rpbmd1aXNoZWQgYnkgZGlzdGluY3QgdmFsdWVzIG9mIHRoZVxuLy8gcGFyYW1ldGVyIGJhc2VkIG9uIHZhbHVlIGVxdWFsaXR5LCBub3QgcmVmZXJlbmNlIGVxdWFsaXR5LiAgVGhpcyBhbGxvd3MgdXNpbmdcbi8vIG9iamVjdCBsaXRlcmFscyBvciBvdGhlciBlcXVpdmFsZW50IG9iamVjdHMgYXQgY2FsbHNpdGVzIHRvIG5vdCBjcmVhdGVcbi8vIGR1cGxpY2F0ZSBjYWNoZSBlbnRyaWVzLiAgVGhpcyBiZWhhdmlvciBtYXkgYmUgb3ZlcnJpZGRlbiB3aXRoIHRoZVxuLy8gY2FjaGVJbXBsZW1lbnRhdGlvbkZvclBhcmFtcyBvcHRpb24uXG5mdW5jdGlvbiBzZWxlY3RvckZhbWlseShvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRjYWNoZVBvbGljeUYsIF9vcHRpb25zJGNhY2hlUG9saWN5RjI7XG5cbiAgY29uc3Qgc2VsZWN0b3JDYWNoZSA9IFJlY29pbF9jYWNoZUZyb21Qb2xpY3koe1xuICAgIGVxdWFsaXR5OiAoX29wdGlvbnMkY2FjaGVQb2xpY3lGID0gKF9vcHRpb25zJGNhY2hlUG9saWN5RjIgPSBvcHRpb25zLmNhY2hlUG9saWN5Rm9yUGFyYW1zX1VOU1RBQkxFKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRjYWNoZVBvbGljeUYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRjYWNoZVBvbGljeUYyLmVxdWFsaXR5KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRjYWNoZVBvbGljeUYgIT09IHZvaWQgMCA/IF9vcHRpb25zJGNhY2hlUG9saWN5RiA6ICd2YWx1ZScsXG4gICAgZXZpY3Rpb246ICdrZWVwLWFsbCdcbiAgfSk7XG4gIHJldHVybiBwYXJhbXMgPT4ge1xuICAgIHZhciBfc3RhYmxlU3RyaW5naWZ5O1xuXG4gICAgLy8gVGhyb3cgYW4gZXJyb3Igd2l0aCBzZWxlY3RvciBrZXkgc28gdGhhdCBpdCBpcyBjbGVhciB3aGljaFxuICAgIC8vIHNlbGVjdG9yIGlzIGNhdXNpbmcgYW4gZXJyb3JcbiAgICBsZXQgY2FjaGVkU2VsZWN0b3I7XG5cbiAgICB0cnkge1xuICAgICAgY2FjaGVkU2VsZWN0b3IgPSBzZWxlY3RvckNhY2hlLmdldChwYXJhbXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKGBQcm9ibGVtIHdpdGggY2FjaGUgbG9va3VwIGZvciBzZWxlY3RvciAke29wdGlvbnMua2V5fTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cblxuICAgIGlmIChjYWNoZWRTZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkU2VsZWN0b3I7XG4gICAgfVxuXG4gICAgY29uc3QgbXlLZXkgPSBgJHtvcHRpb25zLmtleX1fX3NlbGVjdG9yRmFtaWx5LyR7KF9zdGFibGVTdHJpbmdpZnkgPSBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5KHBhcmFtcywge1xuICAgICAgLy8gSXQgaXMgcG9zc2libGUgdG8gdXNlIGZ1bmN0aW9ucyBpbiBwYXJhbWV0ZXJzIGlmIHRoZSB1c2VyIHVzZXNcbiAgICAgIC8vIGEgY2FjaGUgd2l0aCByZWZlcmVuY2UgZXF1YWxpdHkgdGhhbmtzIHRvIHRoZSBpbmNyZW1lbnRpbmcgaW5kZXguXG4gICAgICBhbGxvd0Z1bmN0aW9uczogdHJ1ZVxuICAgIH0pKSAhPT0gbnVsbCAmJiBfc3RhYmxlU3RyaW5naWZ5ICE9PSB2b2lkIDAgPyBfc3RhYmxlU3RyaW5naWZ5IDogJ3ZvaWQnfS8ke25leHRJbmRleCsrfWA7IC8vIEFwcGVuZCBpbmRleCBpbiBjYXNlIHZhbHVlcyBzZXJpYWxpemUgdG8gdGhlIHNhbWUga2V5IHN0cmluZ1xuXG4gICAgY29uc3QgbXlHZXQgPSBjYWxsYmFja3MgPT4gb3B0aW9ucy5nZXQocGFyYW1zKShjYWxsYmFja3MpO1xuXG4gICAgY29uc3QgbXlDYWNoZVBvbGljeSA9IG9wdGlvbnMuY2FjaGVQb2xpY3lfVU5TVEFCTEU7XG4gICAgY29uc3QgcmV0YWluZWRCeSA9IHR5cGVvZiBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUocGFyYW1zKSA6IG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRTtcbiAgICBsZXQgbmV3U2VsZWN0b3I7XG5cbiAgICBpZiAob3B0aW9ucy5zZXQgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2V0ID0gb3B0aW9ucy5zZXQ7XG5cbiAgICAgIGNvbnN0IG15U2V0ID0gKGNhbGxiYWNrcywgbmV3VmFsdWUpID0+IHNldChwYXJhbXMpKGNhbGxiYWNrcywgbmV3VmFsdWUpO1xuXG4gICAgICBuZXdTZWxlY3RvciA9IFJlY29pbF9zZWxlY3Rvcih7XG4gICAgICAgIGtleTogbXlLZXksXG4gICAgICAgIGdldDogbXlHZXQsXG4gICAgICAgIHNldDogbXlTZXQsXG4gICAgICAgIGNhY2hlUG9saWN5X1VOU1RBQkxFOiBteUNhY2hlUG9saWN5LFxuICAgICAgICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSxcbiAgICAgICAgcmV0YWluZWRCeV9VTlNUQUJMRTogcmV0YWluZWRCeVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1NlbGVjdG9yID0gUmVjb2lsX3NlbGVjdG9yKHtcbiAgICAgICAga2V5OiBteUtleSxcbiAgICAgICAgZ2V0OiBteUdldCxcbiAgICAgICAgY2FjaGVQb2xpY3lfVU5TVEFCTEU6IG15Q2FjaGVQb2xpY3ksXG4gICAgICAgIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiBvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5LFxuICAgICAgICByZXRhaW5lZEJ5X1VOU1RBQkxFOiByZXRhaW5lZEJ5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzZWxlY3RvckNhY2hlLnNldChwYXJhbXMsIG5ld1NlbGVjdG9yKTtcbiAgICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMyhuZXdTZWxlY3Rvci5rZXksICgpID0+IHtcbiAgICAgIHNlbGVjdG9yQ2FjaGUuZGVsZXRlKHBhcmFtcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld1NlbGVjdG9yO1xuICB9O1xufVxuLyogZXNsaW50LWVuYWJsZSBuby1yZWRlY2xhcmUgKi9cblxuXG52YXIgUmVjb2lsX3NlbGVjdG9yRmFtaWx5ID0gc2VsZWN0b3JGYW1pbHk7XG5cbi8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cblxuY29uc3QgY29uc3RhbnRTZWxlY3RvciA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XG4gIGtleTogJ19fY29uc3RhbnQnLFxuICBnZXQ6IGNvbnN0YW50ID0+ICgpID0+IGNvbnN0YW50LFxuICBjYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRToge1xuICAgIGVxdWFsaXR5OiAncmVmZXJlbmNlJ1xuICB9XG59KTsgLy8gRnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2VsZWN0b3Igd2hpY2ggYWx3YXlzIHByb2R1Y2VzIHRoZVxuLy8gc2FtZSBjb25zdGFudCB2YWx1ZS4gIEl0IG1heSBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aCB0aGVcbi8vIHNhbWUgdmFsdWUsIGJhc2VkIG9uIHJlZmVyZW5jZSBlcXVhbGl0eSwgYW5kIHdpbGwgcHJvdmlkZSB0aGVcbi8vIHNhbWUgc2VsZWN0b3IuXG5cbmZ1bmN0aW9uIGNvbnN0U2VsZWN0b3IoY29uc3RhbnQpIHtcbiAgcmV0dXJuIGNvbnN0YW50U2VsZWN0b3IoY29uc3RhbnQpO1xufVxuXG52YXIgUmVjb2lsX2NvbnN0U2VsZWN0b3IgPSBjb25zdFNlbGVjdG9yO1xuXG4vLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG5cbmNvbnN0IHRocm93aW5nU2VsZWN0b3IgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xuICBrZXk6ICdfX2Vycm9yJyxcbiAgZ2V0OiBtZXNzYWdlID0+ICgpID0+IHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKG1lc3NhZ2UpO1xuICB9LFxuICAvLyBUT0RPIFdoeT9cbiAgY2FjaGVQb2xpY3lGb3JQYXJhbXNfVU5TVEFCTEU6IHtcbiAgICBlcXVhbGl0eTogJ3JlZmVyZW5jZSdcbiAgfVxufSk7IC8vIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNlbGVjdG9yIHdoaWNoIGFsd2F5cyB0aHJvd3MgYW4gZXJyb3Jcbi8vIHdpdGggdGhlIHByb3ZpZGVkIG1lc3NhZ2UuXG5cbmZ1bmN0aW9uIGVycm9yU2VsZWN0b3IobWVzc2FnZSkge1xuICByZXR1cm4gdGhyb3dpbmdTZWxlY3RvcihtZXNzYWdlKTtcbn1cblxudmFyIFJlY29pbF9lcnJvclNlbGVjdG9yID0gZXJyb3JTZWxlY3RvcjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBXcmFwcyBhbm90aGVyIHJlY29pbCB2YWx1ZSBhbmQgcHJldmVudHMgd3JpdGluZyB0byBpdC5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gcmVhZE9ubHlTZWxlY3RvcihhdG9tKSB7XG4gIC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxuICByZXR1cm4gYXRvbTtcbn1cblxudmFyIFJlY29pbF9yZWFkT25seVNlbGVjdG9yID0gcmVhZE9ubHlTZWxlY3RvcjtcblxuY29uc3Qge1xuICBsb2FkYWJsZVdpdGhFcnJvcjogbG9hZGFibGVXaXRoRXJyb3IkMyxcbiAgbG9hZGFibGVXaXRoUHJvbWlzZTogbG9hZGFibGVXaXRoUHJvbWlzZSQzLFxuICBsb2FkYWJsZVdpdGhWYWx1ZTogbG9hZGFibGVXaXRoVmFsdWUkNFxufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xuXG5cblxuXG5cbiAvLy8vLy8vLy8vLy8vLy8vL1xuLy8gIFRSVVRIIFRBQkxFXG4vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRGVwZW5kZW5jaWVzICAgICAgICB3YWl0Rm9yTm9uZSAgICAgICAgIHdhaXRGb3JBbnkgICAgICAgIHdhaXRGb3JBbGwgICAgICAgd2FpdEZvckFsbFNldHRsZWRcbi8vICBbbG9hZGluZywgbG9hZGluZ10gIFtQcm9taXNlLCBQcm9taXNlXSAgUHJvbWlzZSAgICAgICAgICAgUHJvbWlzZSAgICAgICAgIFByb21pc2Vcbi8vICBbdmFsdWUsIGxvYWRpbmddICAgIFt2YWx1ZSwgUHJvbWlzZV0gICAgW3ZhbHVlLCBQcm9taXNlXSAgUHJvbWlzZSAgICAgICAgIFByb21pc2Vcbi8vICBbdmFsdWUsIHZhbHVlXSAgICAgIFt2YWx1ZSwgdmFsdWVdICAgICAgW3ZhbHVlLCB2YWx1ZV0gICAgW3ZhbHVlLCB2YWx1ZV0gIFt2YWx1ZSwgdmFsdWVdXG4vL1xuLy8gIFtlcnJvciwgbG9hZGluZ10gICAgW0Vycm9yLCBQcm9taXNlXSAgICBbRXJyb3IsIFByb21pc2VdICBFcnJvciAgICAgICAgICAgUHJvbWlzZVxuLy8gIFtlcnJvciwgZXJyb3JdICAgICAgW0Vycm9yLCBFcnJvcl0gICAgICBbRXJyb3IsIEVycm9yXSAgICBFcnJvciAgICAgICAgICAgW2Vycm9yLCBlcnJvcl1cbi8vICBbdmFsdWUsIGVycm9yXSAgICAgIFt2YWx1ZSwgRXJyb3JdICAgICAgW3ZhbHVlLCBFcnJvcl0gICAgRXJyb3IgICAgICAgICAgIFt2YWx1ZSwgZXJyb3JdXG4vLyBJc3N1ZSBwYXJhbGxlbCByZXF1ZXN0cyBmb3IgYWxsIGRlcGVuZGVuY2llcyBhbmQgcmV0dXJuIHRoZSBjdXJyZW50XG4vLyBzdGF0dXMgaWYgdGhleSBoYXZlIHJlc3VsdHMsIGhhdmUgc29tZSBlcnJvciwgb3IgYXJlIHN0aWxsIHBlbmRpbmcuXG5cblxuZnVuY3Rpb24gY29uY3VycmVudFJlcXVlc3RzKGdldFJlY29pbFZhbHVlLCBkZXBzKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBBcnJheShkZXBzLmxlbmd0aCkuZmlsbCh1bmRlZmluZWQpO1xuICBjb25zdCBleGNlcHRpb25zID0gQXJyYXkoZGVwcy5sZW5ndGgpLmZpbGwodW5kZWZpbmVkKTtcblxuICBmb3IgKGNvbnN0IFtpLCBkZXBdIG9mIGRlcHMuZW50cmllcygpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdHNbaV0gPSBnZXRSZWNvaWxWYWx1ZShkZXApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGV4Y2VwdGlvbnMgY2FuIGVpdGhlciBiZSBQcm9taXNlcyBvZiBwZW5kaW5nIHJlc3VsdHMgb3IgcmVhbCBlcnJvcnNcbiAgICAgIGV4Y2VwdGlvbnNbaV0gPSBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbcmVzdWx0cywgZXhjZXB0aW9uc107XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZXhwKSB7XG4gIHJldHVybiBleHAgIT0gbnVsbCAmJiAhUmVjb2lsX2lzUHJvbWlzZShleHApO1xufVxuXG5mdW5jdGlvbiB1bndyYXBEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRlcGVuZGVuY2llcykgPyBkZXBlbmRlbmNpZXMgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZXBlbmRlbmNpZXMpLm1hcChrZXkgPT4gZGVwZW5kZW5jaWVzW2tleV0pO1xufVxuXG5mdW5jdGlvbiB3cmFwUmVzdWx0cyhkZXBlbmRlbmNpZXMsXG4vKiAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdIFRoZSB0eXBlIGFubm90YXRpb24ocykgcmVxdWlyZWQgYnkgRmxvdydzXG4gKiBMVEkgdXBkYXRlIGNvdWxkIG5vdCBiZSBhZGRlZCB2aWEgY29kZW1vZCAqL1xucmVzdWx0cykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkZXBlbmRlbmNpZXMpID8gcmVzdWx0cyA6IC8vIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCkgaGFzIGNvbnNpc3RlbnQga2V5IG9yZGVyaW5nIHdpdGggRVM2XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRlcGVuZGVuY2llcykucmVkdWNlKChvdXQsIGtleSwgaWR4KSA9PiAoeyAuLi5vdXQsXG4gICAgW2tleV06IHJlc3VsdHNbaWR4XVxuICB9KSwge30pO1xufVxuXG5mdW5jdGlvbiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucykge1xuICBjb25zdCBvdXRwdXQgPSBleGNlcHRpb25zLm1hcCgoZXhjZXB0aW9uLCBpZHgpID0+IGV4Y2VwdGlvbiA9PSBudWxsID8gbG9hZGFibGVXaXRoVmFsdWUkNChyZXN1bHRzW2lkeF0pIDogUmVjb2lsX2lzUHJvbWlzZShleGNlcHRpb24pID8gbG9hZGFibGVXaXRoUHJvbWlzZSQzKGV4Y2VwdGlvbikgOiBsb2FkYWJsZVdpdGhFcnJvciQzKGV4Y2VwdGlvbikpO1xuICByZXR1cm4gd3JhcFJlc3VsdHMoZGVwZW5kZW5jaWVzLCBvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lQXN5bmNSZXN1bHRzV2l0aFN5bmNSZXN1bHRzKHN5bmNSZXN1bHRzLCBhc3luY1Jlc3VsdHMpIHtcbiAgcmV0dXJuIGFzeW5jUmVzdWx0cy5tYXAoKHJlc3VsdCwgaWR4KSA9PlxuICAvKipcbiAgICogaXQncyBpbXBvcnRhbnQgd2UgdXNlID09PSB1bmRlZmluZWQgYXMgb3Bwb3NlZCB0byA9PSBudWxsLCBiZWNhdXNlIHRoZVxuICAgKiByZXNvbHZlZCB2YWx1ZSBvZiB0aGUgYXN5bmMgcHJvbWlzZSBjb3VsZCBiZSBgbnVsbGAsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICogZG9uJ3Qgd2FudCB0byB1c2Ugc3luY1Jlc3VsdHNbaWR4XSwgd2hpY2ggd291bGQgYmUgdW5kZWZpbmVkLiBJZiBhc3luY1xuICAgKiBwcm9taXNlIHJlc29sdmVzIHRvIGB1bmRlZmluZWRgLCB0aGF0J3Mgb2sgYmVjYXVzZSBgc3luY1Jlc3VsdHNbaWR4XWBcbiAgICogd2lsbCBhbHNvIGJlIGB1bmRlZmluZWRgLiBUaGF0J3MgYSBsaXR0bGUgaGFja3ksIGJ1dCBpdCB3b3Jrcy5cbiAgICovXG4gIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gc3luY1Jlc3VsdHNbaWR4XSA6IHJlc3VsdCk7XG59IC8vIFNlbGVjdG9yIHRoYXQgcmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbCBhbmQgaW1tZWRpYXRlbHkgcmV0dXJuc1xuLy8gY3VycmVudCByZXN1bHRzIHdpdGhvdXQgd2FpdGluZy5cblxuXG5jb25zdCB3YWl0Rm9yTm9uZSA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XG4gIGtleTogJ19fd2FpdEZvck5vbmUnLFxuICBnZXQ6IGRlcGVuZGVuY2llcyA9PiAoe1xuICAgIGdldFxuICB9KSA9PiB7XG4gICAgLy8gSXNzdWUgcmVxdWVzdHMgZm9yIGFsbCBkZXBlbmRlbmNpZXMgaW4gcGFyYWxsZWwuXG4gICAgY29uc3QgZGVwcyA9IHVud3JhcERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpO1xuICAgIGNvbnN0IFtyZXN1bHRzLCBleGNlcHRpb25zXSA9IGNvbmN1cnJlbnRSZXF1ZXN0cyhnZXQsIGRlcHMpOyAvLyBBbHdheXMgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgcmVzdWx0czsgbmV2ZXIgYmxvY2suXG5cbiAgICByZXR1cm4gd3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpO1xuICB9LFxuICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogdHJ1ZVxufSk7IC8vIFNlbGVjdG9yIHRoYXQgcmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbCBhbmQgd2FpdHMgZm9yIGF0IGxlYXN0XG4vLyBvbmUgdG8gYmUgYXZhaWxhYmxlIGJlZm9yZSByZXR1cm5pbmcgcmVzdWx0cy4gIEl0IHdpbGwgb25seSBlcnJvciBpZiBhbGxcbi8vIGRlcGVuZGVuY2llcyBoYXZlIGVycm9ycy5cblxuY29uc3Qgd2FpdEZvckFueSA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XG4gIGtleTogJ19fd2FpdEZvckFueScsXG4gIGdldDogZGVwZW5kZW5jaWVzID0+ICh7XG4gICAgZ2V0XG4gIH0pID0+IHtcbiAgICAvLyBJc3N1ZSByZXF1ZXN0cyBmb3IgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbC5cbiAgICAvLyBFeGNlcHRpb25zIGNhbiBlaXRoZXIgYmUgUHJvbWlzZXMgb2YgcGVuZGluZyByZXN1bHRzIG9yIHJlYWwgZXJyb3JzXG4gICAgY29uc3QgZGVwcyA9IHVud3JhcERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpO1xuICAgIGNvbnN0IFtyZXN1bHRzLCBleGNlcHRpb25zXSA9IGNvbmN1cnJlbnRSZXF1ZXN0cyhnZXQsIGRlcHMpOyAvLyBJZiBhbnkgcmVzdWx0cyBhcmUgYXZhaWxhYmxlLCB2YWx1ZSBvciBlcnJvciwgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXR1c1xuXG4gICAgaWYgKGV4Y2VwdGlvbnMuc29tZShleHAgPT4gIVJlY29pbF9pc1Byb21pc2UoZXhwKSkpIHtcbiAgICAgIHJldHVybiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucyk7XG4gICAgfSAvLyBPdGhlcndpc2UsIHJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiB0aGUgbmV4dCByZXN1bHQgaXNcbiAgICAvLyBhdmFpbGFibGUsIHdoaWNoZXZlciBvbmUgaGFwcGVucyB0byBiZSBuZXh0LiAgQnV0LCBpZiBhbGwgcGVuZGluZ1xuICAgIC8vIGRlcGVuZGVuY2llcyBlbmQgdXAgd2l0aCBlcnJvcnMsIHRoZW4gcmVqZWN0IHRoZSBwcm9taXNlLlxuXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IFtpLCBleHBdIG9mIGV4Y2VwdGlvbnMuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKGV4cCkpIHtcbiAgICAgICAgICBleHAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGV4Y2VwdGlvbnNbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXNvbHZlKHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKSk7XG4gICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgZXhjZXB0aW9uc1tpXSA9IGVycm9yO1xuICAgICAgICAgICAgcmVzb2x2ZSh3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucykpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiB0cnVlXG59KTsgLy8gU2VsZWN0b3IgdGhhdCByZXF1ZXN0cyBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsIGFuZCB3YWl0cyBmb3IgYWxsIHRvIGJlXG4vLyBhdmFpbGFibGUgYmVmb3JlIHJldHVybmluZyBhIHZhbHVlLiAgSXQgd2lsbCBlcnJvciBpZiBhbnkgZGVwZW5kZW5jaWVzIGVycm9yLlxuXG5jb25zdCB3YWl0Rm9yQWxsID0gUmVjb2lsX3NlbGVjdG9yRmFtaWx5KHtcbiAga2V5OiAnX193YWl0Rm9yQWxsJyxcbiAgZ2V0OiBkZXBlbmRlbmNpZXMgPT4gKHtcbiAgICBnZXRcbiAgfSkgPT4ge1xuICAgIC8vIElzc3VlIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsLlxuICAgIC8vIEV4Y2VwdGlvbnMgY2FuIGVpdGhlciBiZSBQcm9taXNlcyBvZiBwZW5kaW5nIHJlc3VsdHMgb3IgcmVhbCBlcnJvcnNcbiAgICBjb25zdCBkZXBzID0gdW53cmFwRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgW3Jlc3VsdHMsIGV4Y2VwdGlvbnNdID0gY29uY3VycmVudFJlcXVlc3RzKGdldCwgZGVwcyk7IC8vIElmIGFsbCByZXN1bHRzIGFyZSBhdmFpbGFibGUsIHJldHVybiB0aGUgcmVzdWx0c1xuXG4gICAgaWYgKGV4Y2VwdGlvbnMuZXZlcnkoZXhwID0+IGV4cCA9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIHdyYXBSZXN1bHRzKGRlcGVuZGVuY2llcywgcmVzdWx0cyk7XG4gICAgfSAvLyBJZiB3ZSBoYXZlIGFueSBlcnJvcnMsIHRocm93IHRoZSBmaXJzdCBlcnJvclxuXG5cbiAgICBjb25zdCBlcnJvciA9IGV4Y2VwdGlvbnMuZmluZChpc0Vycm9yKTtcblxuICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IC8vIE90aGVyd2lzZSwgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIGFsbCByZXN1bHRzIGFyZSBhdmFpbGFibGVcblxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGV4Y2VwdGlvbnMpLnRoZW4oZXhjZXB0aW9uUmVzdWx0cyA9PiB3cmFwUmVzdWx0cyhkZXBlbmRlbmNpZXMsIGNvbWJpbmVBc3luY1Jlc3VsdHNXaXRoU3luY1Jlc3VsdHMocmVzdWx0cywgZXhjZXB0aW9uUmVzdWx0cykpKTtcbiAgfSxcbiAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IHRydWVcbn0pO1xuY29uc3Qgd2FpdEZvckFsbFNldHRsZWQgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xuICBrZXk6ICdfX3dhaXRGb3JBbGxTZXR0bGVkJyxcbiAgZ2V0OiBkZXBlbmRlbmNpZXMgPT4gKHtcbiAgICBnZXRcbiAgfSkgPT4ge1xuICAgIC8vIElzc3VlIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsLlxuICAgIC8vIEV4Y2VwdGlvbnMgY2FuIGVpdGhlciBiZSBQcm9taXNlcyBvZiBwZW5kaW5nIHJlc3VsdHMgb3IgcmVhbCBlcnJvcnNcbiAgICBjb25zdCBkZXBzID0gdW53cmFwRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgW3Jlc3VsdHMsIGV4Y2VwdGlvbnNdID0gY29uY3VycmVudFJlcXVlc3RzKGdldCwgZGVwcyk7IC8vIElmIGFsbCByZXN1bHRzIGFyZSBhdmFpbGFibGUsIHJldHVybiB0aGUgcmVzdWx0c1xuXG4gICAgaWYgKGV4Y2VwdGlvbnMuZXZlcnkoZXhwID0+ICFSZWNvaWxfaXNQcm9taXNlKGV4cCkpKSB7XG4gICAgICByZXR1cm4gd3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpO1xuICAgIH0gLy8gV2FpdCBmb3IgYWxsIHJlc3VsdHMgdG8gc2V0dGxlXG5cblxuICAgIHJldHVybiBQcm9taXNlLmFsbChleGNlcHRpb25zLm1hcCgoZXhwLCBpKSA9PiBSZWNvaWxfaXNQcm9taXNlKGV4cCkgPyBleHAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgcmVzdWx0c1tpXSA9IHJlc3VsdDtcbiAgICAgIGV4Y2VwdGlvbnNbaV0gPSB1bmRlZmluZWQ7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgcmVzdWx0c1tpXSA9IHVuZGVmaW5lZDtcbiAgICAgIGV4Y2VwdGlvbnNbaV0gPSBlcnJvcjtcbiAgICB9KSA6IG51bGwpKSAvLyBUaGVuIHdyYXAgdGhlbSBhcyBsb2FkYWJsZXNcbiAgICAudGhlbigoKSA9PiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucykpO1xuICB9LFxuICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogdHJ1ZVxufSk7XG5jb25zdCBub1dhaXQgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xuICBrZXk6ICdfX25vV2FpdCcsXG4gIGdldDogZGVwZW5kZW5jeSA9PiAoe1xuICAgIGdldFxuICB9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBSZWNvaWxfc2VsZWN0b3IudmFsdWUobG9hZGFibGVXaXRoVmFsdWUkNChnZXQoZGVwZW5kZW5jeSkpKTtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgIHJldHVybiBSZWNvaWxfc2VsZWN0b3IudmFsdWUoUmVjb2lsX2lzUHJvbWlzZShleGNlcHRpb24pID8gbG9hZGFibGVXaXRoUHJvbWlzZSQzKGV4Y2VwdGlvbikgOiBsb2FkYWJsZVdpdGhFcnJvciQzKGV4Y2VwdGlvbikpO1xuICAgIH1cbiAgfSxcbiAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IHRydWVcbn0pO1xudmFyIFJlY29pbF9XYWl0Rm9yID0ge1xuICB3YWl0Rm9yTm9uZSxcbiAgd2FpdEZvckFueSxcbiAgd2FpdEZvckFsbCxcbiAgd2FpdEZvckFsbFNldHRsZWQsXG4gIG5vV2FpdFxufTtcblxuY29uc3Qge1xuICBSZWNvaWxMb2FkYWJsZVxufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xuXG5jb25zdCB7XG4gIERlZmF1bHRWYWx1ZTogRGVmYXVsdFZhbHVlJDNcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBSZWNvaWxSb290OiBSZWNvaWxSb290JDIsXG4gIHVzZVJlY29pbFN0b3JlSUQ6IHVzZVJlY29pbFN0b3JlSUQkMVxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkNVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xuXG5jb25zdCB7XG4gIHJldGVudGlvblpvbmU6IHJldGVudGlvblpvbmUkMVxufSA9IFJlY29pbF9SZXRlbnRpb25ab25lO1xuXG5jb25zdCB7XG4gIGZyZXNoU25hcHNob3Q6IGZyZXNoU25hcHNob3QkMlxufSA9IFJlY29pbF9TbmFwc2hvdCQxO1xuXG5jb25zdCB7XG4gIHVzZVJlY29pbFN0YXRlOiB1c2VSZWNvaWxTdGF0ZSQxLFxuICB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlOiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlJDEsXG4gIHVzZVJlY29pbFZhbHVlOiB1c2VSZWNvaWxWYWx1ZSQxLFxuICB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlJDEsXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICB1c2VSZXNldFJlY29pbFN0YXRlOiB1c2VSZXNldFJlY29pbFN0YXRlJDEsXG4gIHVzZVNldFJlY29pbFN0YXRlOiB1c2VTZXRSZWNvaWxTdGF0ZSQxXG59ID0gUmVjb2lsX0hvb2tzO1xuXG5jb25zdCB7XG4gIHVzZUdvdG9SZWNvaWxTbmFwc2hvdDogdXNlR290b1JlY29pbFNuYXBzaG90JDEsXG4gIHVzZVJlY29pbFNuYXBzaG90OiB1c2VSZWNvaWxTbmFwc2hvdCQxLFxuICB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyOiB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyJDFcbn0gPSBSZWNvaWxfU25hcHNob3RIb29rcztcblxuXG5cblxuXG5jb25zdCB7XG4gIHVzZVJlY29pbENhbGxiYWNrOiB1c2VSZWNvaWxDYWxsYmFjayQxXG59ID0gUmVjb2lsX3VzZVJlY29pbENhbGxiYWNrO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3Qge1xuICBub1dhaXQ6IG5vV2FpdCQxLFxuICB3YWl0Rm9yQWxsOiB3YWl0Rm9yQWxsJDEsXG4gIHdhaXRGb3JBbGxTZXR0bGVkOiB3YWl0Rm9yQWxsU2V0dGxlZCQxLFxuICB3YWl0Rm9yQW55OiB3YWl0Rm9yQW55JDEsXG4gIHdhaXRGb3JOb25lOiB3YWl0Rm9yTm9uZSQxXG59ID0gUmVjb2lsX1dhaXRGb3I7XG5cbnZhciBSZWNvaWxfaW5kZXggPSB7XG4gIC8vIFR5cGVzXG4gIERlZmF1bHRWYWx1ZTogRGVmYXVsdFZhbHVlJDMsXG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkNSxcbiAgUmVjb2lsTG9hZGFibGUsXG4gIC8vIFJlY29pbCBSb290XG4gIFJlY29pbFJvb3Q6IFJlY29pbFJvb3QkMixcbiAgdXNlUmVjb2lsU3RvcmVJRDogdXNlUmVjb2lsU3RvcmVJRCQxLFxuICB1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzX1VOU1RBQkxFOiBSZWNvaWxfdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cyxcbiAgLy8gQXRvbXMvU2VsZWN0b3JzXG4gIGF0b206IFJlY29pbF9hdG9tLFxuICBzZWxlY3RvcjogUmVjb2lsX3NlbGVjdG9yLFxuICAvLyBDb252ZW5pZW5jZSBBdG9tcy9TZWxlY3RvcnNcbiAgYXRvbUZhbWlseTogUmVjb2lsX2F0b21GYW1pbHksXG4gIHNlbGVjdG9yRmFtaWx5OiBSZWNvaWxfc2VsZWN0b3JGYW1pbHksXG4gIGNvbnN0U2VsZWN0b3I6IFJlY29pbF9jb25zdFNlbGVjdG9yLFxuICBlcnJvclNlbGVjdG9yOiBSZWNvaWxfZXJyb3JTZWxlY3RvcixcbiAgcmVhZE9ubHlTZWxlY3RvcjogUmVjb2lsX3JlYWRPbmx5U2VsZWN0b3IsXG4gIC8vIENvbmN1cnJlbmN5IEhlbHBlcnMgZm9yIEF0b21zL1NlbGVjdG9yc1xuICBub1dhaXQ6IG5vV2FpdCQxLFxuICB3YWl0Rm9yTm9uZTogd2FpdEZvck5vbmUkMSxcbiAgd2FpdEZvckFueTogd2FpdEZvckFueSQxLFxuICB3YWl0Rm9yQWxsOiB3YWl0Rm9yQWxsJDEsXG4gIHdhaXRGb3JBbGxTZXR0bGVkOiB3YWl0Rm9yQWxsU2V0dGxlZCQxLFxuICAvLyBIb29rcyBmb3IgQXRvbXMvU2VsZWN0b3JzXG4gIHVzZVJlY29pbFZhbHVlOiB1c2VSZWNvaWxWYWx1ZSQxLFxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlJDEsXG4gIHVzZVJlY29pbFN0YXRlOiB1c2VSZWNvaWxTdGF0ZSQxLFxuICB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlOiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlJDEsXG4gIHVzZVNldFJlY29pbFN0YXRlOiB1c2VTZXRSZWNvaWxTdGF0ZSQxLFxuICB1c2VSZXNldFJlY29pbFN0YXRlOiB1c2VSZXNldFJlY29pbFN0YXRlJDEsXG4gIHVzZUdldFJlY29pbFZhbHVlSW5mb19VTlNUQUJMRTogUmVjb2lsX3VzZUdldFJlY29pbFZhbHVlSW5mbyxcbiAgdXNlUmVjb2lsUmVmcmVzaGVyX1VOU1RBQkxFOiBSZWNvaWxfdXNlUmVjb2lsUmVmcmVzaGVyLFxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSxcbiAgdXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFOiB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSxcbiAgdXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFOiB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSxcbiAgLy8gSG9va3MgZm9yIGNvbXBsZXggb3BlcmF0aW9uc1xuICB1c2VSZWNvaWxDYWxsYmFjazogdXNlUmVjb2lsQ2FsbGJhY2skMSxcbiAgdXNlUmVjb2lsVHJhbnNhY3Rpb25fVU5TVEFCTEU6IFJlY29pbF91c2VSZWNvaWxUcmFuc2FjdGlvbixcbiAgLy8gU25hcHNob3RzXG4gIHVzZUdvdG9SZWNvaWxTbmFwc2hvdDogdXNlR290b1JlY29pbFNuYXBzaG90JDEsXG4gIHVzZVJlY29pbFNuYXBzaG90OiB1c2VSZWNvaWxTbmFwc2hvdCQxLFxuICB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyX1VOU1RBQkxFOiB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyJDEsXG4gIHNuYXBzaG90X1VOU1RBQkxFOiBmcmVzaFNuYXBzaG90JDIsXG4gIC8vIE1lbW9yeSBNYW5hZ2VtZW50XG4gIHVzZVJldGFpbjogUmVjb2lsX3VzZVJldGFpbixcbiAgcmV0ZW50aW9uWm9uZTogcmV0ZW50aW9uWm9uZSQxXG59O1xudmFyIFJlY29pbF9pbmRleF8xID0gUmVjb2lsX2luZGV4LkRlZmF1bHRWYWx1ZTtcbnZhciBSZWNvaWxfaW5kZXhfMiA9IFJlY29pbF9pbmRleC5pc1JlY29pbFZhbHVlO1xudmFyIFJlY29pbF9pbmRleF8zID0gUmVjb2lsX2luZGV4LlJlY29pbExvYWRhYmxlO1xudmFyIFJlY29pbF9pbmRleF80ID0gUmVjb2lsX2luZGV4LlJlY29pbFJvb3Q7XG52YXIgUmVjb2lsX2luZGV4XzUgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU3RvcmVJRDtcbnZhciBSZWNvaWxfaW5kZXhfNiA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF83ID0gUmVjb2lsX2luZGV4LmF0b207XG52YXIgUmVjb2lsX2luZGV4XzggPSBSZWNvaWxfaW5kZXguc2VsZWN0b3I7XG52YXIgUmVjb2lsX2luZGV4XzkgPSBSZWNvaWxfaW5kZXguYXRvbUZhbWlseTtcbnZhciBSZWNvaWxfaW5kZXhfMTAgPSBSZWNvaWxfaW5kZXguc2VsZWN0b3JGYW1pbHk7XG52YXIgUmVjb2lsX2luZGV4XzExID0gUmVjb2lsX2luZGV4LmNvbnN0U2VsZWN0b3I7XG52YXIgUmVjb2lsX2luZGV4XzEyID0gUmVjb2lsX2luZGV4LmVycm9yU2VsZWN0b3I7XG52YXIgUmVjb2lsX2luZGV4XzEzID0gUmVjb2lsX2luZGV4LnJlYWRPbmx5U2VsZWN0b3I7XG52YXIgUmVjb2lsX2luZGV4XzE0ID0gUmVjb2lsX2luZGV4Lm5vV2FpdDtcbnZhciBSZWNvaWxfaW5kZXhfMTUgPSBSZWNvaWxfaW5kZXgud2FpdEZvck5vbmU7XG52YXIgUmVjb2lsX2luZGV4XzE2ID0gUmVjb2lsX2luZGV4LndhaXRGb3JBbnk7XG52YXIgUmVjb2lsX2luZGV4XzE3ID0gUmVjb2lsX2luZGV4LndhaXRGb3JBbGw7XG52YXIgUmVjb2lsX2luZGV4XzE4ID0gUmVjb2lsX2luZGV4LndhaXRGb3JBbGxTZXR0bGVkO1xudmFyIFJlY29pbF9pbmRleF8xOSA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxWYWx1ZTtcbnZhciBSZWNvaWxfaW5kZXhfMjAgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVmFsdWVMb2FkYWJsZTtcbnZhciBSZWNvaWxfaW5kZXhfMjEgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU3RhdGU7XG52YXIgUmVjb2lsX2luZGV4XzIyID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFN0YXRlTG9hZGFibGU7XG52YXIgUmVjb2lsX2luZGV4XzIzID0gUmVjb2lsX2luZGV4LnVzZVNldFJlY29pbFN0YXRlO1xudmFyIFJlY29pbF9pbmRleF8yNCA9IFJlY29pbF9pbmRleC51c2VSZXNldFJlY29pbFN0YXRlO1xudmFyIFJlY29pbF9pbmRleF8yNSA9IFJlY29pbF9pbmRleC51c2VHZXRSZWNvaWxWYWx1ZUluZm9fVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzI2ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFJlZnJlc2hlcl9VTlNUQUJMRTtcbnZhciBSZWNvaWxfaW5kZXhfMjcgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzI4ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTtcbnZhciBSZWNvaWxfaW5kZXhfMjkgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF8zMCA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxDYWxsYmFjaztcbnZhciBSZWNvaWxfaW5kZXhfMzEgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVHJhbnNhY3Rpb25fVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzMyID0gUmVjb2lsX2luZGV4LnVzZUdvdG9SZWNvaWxTbmFwc2hvdDtcbnZhciBSZWNvaWxfaW5kZXhfMzMgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU25hcHNob3Q7XG52YXIgUmVjb2lsX2luZGV4XzM0ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXJfVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzM1ID0gUmVjb2lsX2luZGV4LnNuYXBzaG90X1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF8zNiA9IFJlY29pbF9pbmRleC51c2VSZXRhaW47XG52YXIgUmVjb2lsX2luZGV4XzM3ID0gUmVjb2lsX2luZGV4LnJldGVudGlvblpvbmU7XG5cbmV4cG9ydCBkZWZhdWx0IFJlY29pbF9pbmRleDtcbmV4cG9ydCB7IFJlY29pbF9pbmRleF8xIGFzIERlZmF1bHRWYWx1ZSwgUmVjb2lsX2luZGV4XzMgYXMgUmVjb2lsTG9hZGFibGUsIFJlY29pbF9pbmRleF80IGFzIFJlY29pbFJvb3QsIFJlY29pbF9pbmRleF83IGFzIGF0b20sIFJlY29pbF9pbmRleF85IGFzIGF0b21GYW1pbHksIFJlY29pbF9pbmRleF8xMSBhcyBjb25zdFNlbGVjdG9yLCBSZWNvaWxfaW5kZXhfMTIgYXMgZXJyb3JTZWxlY3RvciwgUmVjb2lsX2luZGV4XzIgYXMgaXNSZWNvaWxWYWx1ZSwgUmVjb2lsX2luZGV4XzE0IGFzIG5vV2FpdCwgUmVjb2lsX2luZGV4XzEzIGFzIHJlYWRPbmx5U2VsZWN0b3IsIFJlY29pbF9pbmRleF8zNyBhcyByZXRlbnRpb25ab25lLCBSZWNvaWxfaW5kZXhfOCBhcyBzZWxlY3RvciwgUmVjb2lsX2luZGV4XzEwIGFzIHNlbGVjdG9yRmFtaWx5LCBSZWNvaWxfaW5kZXhfMzUgYXMgc25hcHNob3RfVU5TVEFCTEUsIFJlY29pbF9pbmRleF8yNSBhcyB1c2VHZXRSZWNvaWxWYWx1ZUluZm9fVU5TVEFCTEUsIFJlY29pbF9pbmRleF8zMiBhcyB1c2VHb3RvUmVjb2lsU25hcHNob3QsIFJlY29pbF9pbmRleF82IGFzIHVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHNfVU5TVEFCTEUsIFJlY29pbF9pbmRleF8zMCBhcyB1c2VSZWNvaWxDYWxsYmFjaywgUmVjb2lsX2luZGV4XzI2IGFzIHVzZVJlY29pbFJlZnJlc2hlcl9VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzMzIGFzIHVzZVJlY29pbFNuYXBzaG90LCBSZWNvaWxfaW5kZXhfMjEgYXMgdXNlUmVjb2lsU3RhdGUsIFJlY29pbF9pbmRleF8yMiBhcyB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlLCBSZWNvaWxfaW5kZXhfMjkgYXMgdXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFLCBSZWNvaWxfaW5kZXhfNSBhcyB1c2VSZWNvaWxTdG9yZUlELCBSZWNvaWxfaW5kZXhfMzQgYXMgdXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlcl9VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzMxIGFzIHVzZVJlY29pbFRyYW5zYWN0aW9uX1VOU1RBQkxFLCBSZWNvaWxfaW5kZXhfMTkgYXMgdXNlUmVjb2lsVmFsdWUsIFJlY29pbF9pbmRleF8yMCBhcyB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlLCBSZWNvaWxfaW5kZXhfMjcgYXMgdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUsIFJlY29pbF9pbmRleF8yOCBhcyB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUsIFJlY29pbF9pbmRleF8yNCBhcyB1c2VSZXNldFJlY29pbFN0YXRlLCBSZWNvaWxfaW5kZXhfMzYgYXMgdXNlUmV0YWluLCBSZWNvaWxfaW5kZXhfMjMgYXMgdXNlU2V0UmVjb2lsU3RhdGUsIFJlY29pbF9pbmRleF8xNyBhcyB3YWl0Rm9yQWxsLCBSZWNvaWxfaW5kZXhfMTggYXMgd2FpdEZvckFsbFNldHRsZWQsIFJlY29pbF9pbmRleF8xNiBhcyB3YWl0Rm9yQW55LCBSZWNvaWxfaW5kZXhfMTUgYXMgd2FpdEZvck5vbmUgfTtcbiJdLCJuYW1lcyI6WyJyZWFjdCIsInJlYWN0RG9tIiwiZXJyIiwibWVzc2FnZSIsImVycm9yIiwiRXJyb3IiLCJzdGFjayIsInVuZGVmaW5lZCIsIl8iLCJlcnJfMSIsIlJlY29pbF9lcnIiLCJpc1Byb21pc2UiLCJwIiwidGhlbiIsIlJlY29pbF9pc1Byb21pc2UiLCJudWxsdGhyb3dzIiwieCIsIlJlY29pbF9udWxsdGhyb3dzIiwiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIkJhc2VMb2FkYWJsZSIsImdldFZhbHVlIiwidG9Qcm9taXNlIiwidmFsdWVNYXliZSIsInZhbHVlT3JUaHJvdyIsInN0YXRlIiwicHJvbWlzZU1heWJlIiwicHJvbWlzZU9yVGhyb3ciLCJlcnJvck1heWJlIiwiZXJyb3JPclRocm93IiwiaXMiLCJvdGhlciIsImNvbnRlbnRzIiwibWFwIiwiX21hcCIsIlZhbHVlTG9hZGFibGUiLCJjb25zdHJ1Y3RvciIsIlByb21pc2UiLCJyZXNvbHZlIiwibmV4dCIsImxvYWRhYmxlV2l0aFByb21pc2UiLCJpc0xvYWRhYmxlIiwibG9hZGFibGVXaXRoVmFsdWUiLCJlIiwibG9hZGFibGVXaXRoRXJyb3IiLCJFcnJvckxvYWRhYmxlIiwicmVqZWN0IiwiTG9hZGluZ0xvYWRhYmxlIiwicHJvbWlzZSIsIm5leHRMb2FkYWJsZSIsImNhdGNoIiwiZnJlZXplIiwibG9hZGFibGVMb2FkaW5nIiwibG9hZGFibGVBbGxBcnJheSIsImlucHV0cyIsImV2ZXJ5IiwiaSIsInNvbWUiLCJmaW5kIiwiYWxsIiwibG9hZGFibGVBbGwiLCJ1bndyYXBlZElucHV0cyIsIkFycmF5IiwiaXNBcnJheSIsImdldE93blByb3BlcnR5TmFtZXMiLCJub3JtYWxpemVkSW5wdXRzIiwib3V0cHV0Iiwib3V0cHV0cyIsInJlZHVjZSIsIm91dCIsImlkeCIsIkxvYWRhYmxlU3RhdGljSW50ZXJmYWNlIiwib2YiLCJsb2FkaW5nIiwiUmVjb2lsX0xvYWRhYmxlIiwiUmVjb2lsTG9hZGFibGUiLCJSZWNvaWxfTG9hZGFibGVfMSIsIlJlY29pbF9Mb2FkYWJsZV8yIiwiUmVjb2lsX0xvYWRhYmxlXzMiLCJSZWNvaWxfTG9hZGFibGVfNCIsIlJlY29pbF9Mb2FkYWJsZV81IiwiUmVjb2lsX0xvYWRhYmxlXzYiLCJSZWNvaWxfTG9hZGFibGVfNyIsIlJlY29pbF9Mb2FkYWJsZSQxIiwiX19wcm90b19fIiwiZ2tzIiwiTWFwIiwic2V0IiwiUmVjb2lsX2dreF9PU1MiLCJnayIsIl9na3MkZ2V0IiwiZ2V0Iiwic2V0UGFzcyIsInNldEZhaWwiLCJjbGVhciIsIlJlY29pbF9na3giLCJfY3JlYXRlTXV0YWJsZVNvdXJjZSIsIl91c2VNdXRhYmxlU291cmNlIiwiX3VzZVN5bmNFeHRlcm5hbFN0b3JlIiwiY3JlYXRlTXV0YWJsZVNvdXJjZSIsInVuc3RhYmxlX2NyZWF0ZU11dGFibGVTb3VyY2UiLCJ1c2VNdXRhYmxlU291cmNlIiwidW5zdGFibGVfdXNlTXV0YWJsZVNvdXJjZSIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwidW5zdGFibGVfdXNlU3luY0V4dGVybmFsU3RvcmUiLCJyZWFjdE1vZGUiLCJtb2RlIiwiZWFybHkiLCJjb25jdXJyZW50Iiwid2luZG93IiwiJGRpc2FibGVSZWNvaWxWYWx1ZU11dGFibGVTb3VyY2VfVEVNUF9IQUNLX0RPX05PVF9VU0UiLCJpc0Zhc3RSZWZyZXNoRW5hYmxlZCIsIlJlY29pbF9SZWFjdE1vZGUiLCJBYnN0cmFjdFJlY29pbFZhbHVlIiwibmV3S2V5IiwidG9KU09OIiwiUmVjb2lsU3RhdGUiLCJSZWNvaWxWYWx1ZVJlYWRPbmx5IiwiaXNSZWNvaWxWYWx1ZSIsIlJlY29pbF9SZWNvaWxWYWx1ZSIsIlJlY29pbF9SZWNvaWxWYWx1ZV8xIiwiUmVjb2lsX1JlY29pbFZhbHVlXzIiLCJSZWNvaWxfUmVjb2lsVmFsdWVfMyIsIlJlY29pbF9SZWNvaWxWYWx1ZV80IiwiUmVjb2lsX1JlY29pbFZhbHVlJDEiLCJzcHJpbnRmIiwiZm9ybWF0IiwiYXJncyIsImluZGV4IiwicmVwbGFjZSIsIlN0cmluZyIsInNwcmludGZfMSIsImV4cGVjdGF0aW9uVmlvbGF0aW9uIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY2FsbCIsIm5hbWUiLCJjb25zb2xlIiwiZXhwZWN0YXRpb25WaW9sYXRpb25fMSIsIlJlY29pbF9leHBlY3RhdGlvblZpb2xhdGlvbiIsIm1hcEl0ZXJhYmxlIiwiaXRlcmFibGUiLCJjYWxsYmFjayIsIlJlY29pbF9tYXBJdGVyYWJsZSIsInJlY292ZXJhYmxlVmlvbGF0aW9uIiwiX3Byb2plY3ROYW1lIiwicmVjb3ZlcmFibGVWaW9sYXRpb25fMSIsIlJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbiIsImlzRmFzdFJlZnJlc2hFbmFibGVkJDEiLCJEZWZhdWx0VmFsdWUiLCJERUZBVUxUX1ZBTFVFIiwibm9kZXMiLCJyZWNvaWxWYWx1ZXMiLCJyZWNvaWxWYWx1ZXNGb3JLZXlzIiwia2V5cyIsInJlZ2lzdGVyTm9kZSIsIm5vZGUiLCJoYXMiLCJ3YXJuIiwicmVjb2lsVmFsdWUiLCJOb2RlTWlzc2luZ0Vycm9yIiwiZ2V0Tm9kZSIsImdldE5vZGVNYXliZSIsImNvbmZpZ0RlbGV0aW9uSGFuZGxlcnMiLCJkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZSIsIl9ub2RlJHNob3VsZERlbGV0ZUNvbiIsInNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZSIsIl9nZXRDb25maWdEZWxldGlvbkhhbiIsImRlbGV0ZSIsImdldENvbmZpZ0RlbGV0aW9uSGFuZGxlciIsInNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciIsImZuIiwiUmVjb2lsX05vZGUiLCJlbnF1ZXVlRXhlY3V0aW9uIiwicyIsImYiLCJSZWNvaWxfUXVldWUiLCJjcmVhdGVDb21tb25qc01vZHVsZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJoYW10XzEiLCJfdHlwZW9mIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJwcm90b3R5cGUiLCJoYW10IiwiU0laRSIsIkJVQ0tFVF9TSVpFIiwiTWF0aCIsInBvdyIsIk1BU0siLCJNQVhfSU5ERVhfTk9ERSIsIk1JTl9BUlJBWV9OT0RFIiwibm90aGluZyIsImNvbnN0YW50IiwiaGFzaCIsInN0ciIsInR5cGUiLCJsZW4iLCJsZW5ndGgiLCJjIiwiY2hhckNvZGVBdCIsInBvcGNvdW50IiwiaGFzaEZyYWdtZW50Iiwic2hpZnQiLCJoIiwidG9CaXRtYXAiLCJmcm9tQml0bWFwIiwiYml0bWFwIiwiYml0IiwiYXJyYXlVcGRhdGUiLCJtdXRhdGUiLCJhdCIsInYiLCJhcnIiLCJhcnJheVNwbGljZU91dCIsIm5ld0xlbiIsImciLCJhcnJheVNwbGljZUluIiwiX2kiLCJMRUFGIiwiQ09MTElTSU9OIiwiSU5ERVgiLCJBUlJBWSIsImVtcHR5IiwiX19oYW10X2lzRW1wdHkiLCJpc0VtcHR5Tm9kZSIsIkxlYWYiLCJlZGl0IiwiX21vZGlmeSIsIkxlYWZfX21vZGlmeSIsIkNvbGxpc2lvbiIsImNoaWxkcmVuIiwiQ29sbGlzaW9uX19tb2RpZnkiLCJJbmRleGVkTm9kZSIsIm1hc2siLCJJbmRleGVkTm9kZV9fbW9kaWZ5IiwiQXJyYXlOb2RlIiwic2l6ZSIsIkFycmF5Tm9kZV9fbW9kaWZ5IiwiaXNMZWFmIiwiZXhwYW5kIiwiZnJhZyIsImNoaWxkIiwic3ViTm9kZXMiLCJjb3VudCIsInBhY2siLCJyZW1vdmVkIiwiZWxlbWVudHMiLCJlbGVtIiwibWVyZ2VMZWF2ZXMiLCJoMSIsIm4xIiwiaDIiLCJuMiIsInN1YkgxIiwic3ViSDIiLCJ1cGRhdGVDb2xsaXNpb25MaXN0Iiwia2V5RXEiLCJsaXN0IiwiayIsIl9uZXdWYWx1ZSIsIm5ld1ZhbHVlIiwiY2FuRWRpdE5vZGUiLCJfdiIsImNhbkVkaXQiLCJpbmR4IiwiZXhpc3RzIiwiY3VycmVudCIsIm5ld0NoaWxkcmVuIiwibmV3Q2hpbGQiLCJlZGl0YWJsZSIsImNvbmZpZyIsInJvb3QiLCJfZWRpdGFibGUiLCJfZWRpdCIsIl9jb25maWciLCJfcm9vdCIsIl9zaXplIiwic2V0VHJlZSIsIm5ld1Jvb3QiLCJuZXdTaXplIiwidHJ5R2V0SGFzaCIsImFsdCIsInRyeUdldCIsImdldEhhc2giLCJoYXNIYXNoIiwiZGVmS2V5Q29tcGFyZSIsInkiLCJtYWtlIiwiaXNFbXB0eSIsIm1vZGlmeUhhc2giLCJOYU4iLCJtb2RpZnkiLCJzZXRIYXNoIiwiZGVsIiwicmVtb3ZlSGFzaCIsImRlbGV0ZUhhc2giLCJyZW1vdmUiLCJiZWdpbk11dGF0aW9uIiwiZW5kTXV0YXRpb24iLCJ0cmFuc2llbnQiLCJhcHBrIiwibGF6eVZpc2l0Q2hpbGRyZW4iLCJsYXp5VmlzaXQiLCJyZXN0IiwiRE9ORSIsImRvbmUiLCJNYXBJdGVyYXRvciIsInYwIiwidmlzaXQiLCJidWlsZFBhaXJzIiwiZW50cmllcyIsImJ1aWxkS2V5cyIsImJ1aWxkVmFsdWVzIiwidmFsdWVzIiwiZm9sZCIsInoiLCJtIiwidG9WaXNpdCIsInBvcCIsInB1c2giLCJmb3JFYWNoIiwiQnVpbHRJbk1hcCIsImV4aXN0aW5nIiwiY2xvbmUiLCJwZXJzaXN0ZW50TWFwIiwidG9NYXAiLCJIYXNoQXJyYXlNYXBwZWRUcmllTWFwIiwiX2hhbXQiLCJSZWNvaWxfUGVyc2lzdGVudE1hcCIsIlJlY29pbF9QZXJzaXN0ZW50TWFwXzEiLCJSZWNvaWxfUGVyc2lzdGVudE1hcCQxIiwiZGlmZmVyZW5jZVNldHMiLCJzZXRzV2l0aFZhbHVlc1RvUmVtb3ZlIiwicmV0IiwiU2V0IiwiRklSU1QiLCJvdGhlclNldCIsImFkZCIsIlJlY29pbF9kaWZmZXJlbmNlU2V0cyIsIm1hcE1hcCIsInJlc3VsdCIsIlJlY29pbF9tYXBNYXAiLCJtYWtlR3JhcGgiLCJub2RlRGVwcyIsIm5vZGVUb05vZGVTdWJzY3JpcHRpb25zIiwiY2xvbmVHcmFwaCIsImdyYXBoIiwibWVyZ2VEZXBzSW50b0dyYXBoIiwibmV3RGVwcyIsIm9sZGVyR3JhcGgiLCJvbGREZXBzIiwiYWRkZWREZXBzIiwiZGVwIiwicmVtb3ZlZERlcHMiLCJzYXZlRGVwc1RvU3RvcmUiLCJkZXBzIiwic3RvcmUiLCJ2ZXJzaW9uIiwiX3N0b3JlU3RhdGUkbmV4dFRyZWUiLCJfc3RvcmVTdGF0ZSRwcmV2aW91c1QiLCJfc3RvcmVTdGF0ZSRwcmV2aW91c1QyIiwiX3N0b3JlU3RhdGUkcHJldmlvdXNUMyIsInN0b3JlU3RhdGUiLCJnZXRTdGF0ZSIsImN1cnJlbnRUcmVlIiwibmV4dFRyZWUiLCJwcmV2aW91c1RyZWUiLCJnZXRHcmFwaCIsImN1cnJlbnRHcmFwaCIsIl9zdG9yZVN0YXRlJG5leHRUcmVlMiIsIm5leHRWZXJzaW9uIiwibmV4dEdyYXBoIiwiUmVjb2lsX0dyYXBoIiwibmV4dFRyZWVTdGF0ZVZlcnNpb24iLCJnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiIsIm5leHRTdG9yZUlEIiwiZ2V0TmV4dFN0b3JlSUQiLCJuZXh0Q29tcG9uZW50SUQiLCJnZXROZXh0Q29tcG9uZW50SUQiLCJSZWNvaWxfS2V5cyIsInBlcnNpc3RlbnRNYXAkMSIsImdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDEiLCJtYWtlRW1wdHlUcmVlU3RhdGUiLCJzdGF0ZUlEIiwidHJhbnNhY3Rpb25NZXRhZGF0YSIsImRpcnR5QXRvbXMiLCJhdG9tVmFsdWVzIiwibm9udmFsaWRhdGVkQXRvbXMiLCJtYWtlRW1wdHlTdG9yZVN0YXRlIiwiY29tbWl0RGVwdGgiLCJrbm93bkF0b21zIiwia25vd25TZWxlY3RvcnMiLCJ0cmFuc2FjdGlvblN1YnNjcmlwdGlvbnMiLCJub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zIiwibm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucyIsInF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVEIiwic3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzIiwiZ3JhcGhzQnlWZXJzaW9uIiwicmV0ZW50aW9uIiwicmVmZXJlbmNlQ291bnRzIiwibm9kZXNSZXRhaW5lZEJ5Wm9uZSIsInJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2UiLCJub2RlQ2xlYW51cEZ1bmN0aW9ucyIsIlJlY29pbF9TdGF0ZSIsIlJldGVudGlvblpvbmUiLCJyZXRlbnRpb25ab25lIiwiUmVjb2lsX1JldGVudGlvblpvbmUiLCJzZXRCeUFkZGluZ1RvU2V0Iiwic2V0QnlEZWxldGluZ0Zyb21TZXQiLCJtYXBCeVNldHRpbmdJbk1hcCIsIm1hcEJ5VXBkYXRpbmdJbk1hcCIsInVwZGF0ZXIiLCJtYXBCeURlbGV0aW5nRnJvbU1hcCIsIm1hcEJ5RGVsZXRpbmdNdWx0aXBsZUZyb21NYXAiLCJrcyIsIlJlY29pbF9Db3B5T25Xcml0ZSIsImZpbHRlckl0ZXJhYmxlIiwicHJlZGljYXRlIiwiUmVjb2lsX2ZpbHRlckl0ZXJhYmxlIiwibGF6eVByb3h5IiwiYmFzZSIsImZhY3RvcmllcyIsInByb3h5IiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwib3duS2V5cyIsIlJlY29pbF9sYXp5UHJveHkiLCJnZXROb2RlJDEiLCJnZXROb2RlTWF5YmUkMSIsInJlY29pbFZhbHVlc0ZvcktleXMkMSIsIlJldGVudGlvblpvbmUkMSIsInNldEJ5QWRkaW5nVG9TZXQkMSIsImVtcHR5U2V0IiwiUmVhZE9ubHlSZWNvaWxWYWx1ZUVycm9yIiwiaW5pdGlhbGl6ZVJldGVudGlvbkZvck5vZGUiLCJub2RlS2V5IiwicmV0YWluZWRCeSIsImFkZFRvWm9uZSIsInpvbmUiLCJkZWxldGVGcm9tWm9uZSIsImluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlIiwidHJlZVN0YXRlIiwidHJpZ2dlciIsInJldGVudGlvbkNsZWFudXAiLCJub2RlQ2xlYW51cCIsImluaXQiLCJpbml0aWFsaXplTm9kZSIsImNsZWFuVXBOb2RlIiwiX3N0YXRlJG5vZGVDbGVhbnVwRnVuIiwiZ2V0Tm9kZUxvYWRhYmxlIiwicGVla05vZGVMb2FkYWJsZSIsInBlZWsiLCJzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVEIiwiX25vZGUkaW52YWxpZGF0ZSIsImludmFsaWRhdGUiLCJzZXROb2RlVmFsdWUiLCJwZWVrTm9kZUluZm8iLCJub2RlVHlwZSIsImxvYWRhYmxlIiwiaXNBY3RpdmUiLCJpc1NldCIsImlzTW9kaWZpZWQiLCJfZ3JhcGgkbm9kZURlcHMkZ2V0Iiwic3Vic2NyaWJlcnMiLCJfc3RvcmVTdGF0ZSRub2RlVG9Db20iLCJfc3RvcmVTdGF0ZSRub2RlVG9Db20yIiwiZ2V0RG93bnN0cmVhbU5vZGVzIiwiY29tcG9uZW50cyIsInZpc2l0ZWROb2RlcyIsInZpc2l0aW5nTm9kZXMiLCJmcm9tIiwiX2dyYXBoJG5vZGVUb05vZGVTdWJzIiwic3Vic2NyaWJlZE5vZGVzIiwiZG93bnN0cmVhbU5vZGUiLCJSZWNvaWxfRnVuY3Rpb25hbENvcmUiLCJfaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QiLCJzZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCIsImludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90IiwiX2ludmFsaWRhdGVNZW1vaXplZFNuIiwiUmVjb2lsX1NuYXBzaG90Q2FjaGUiLCJnZXREb3duc3RyZWFtTm9kZXMkMSIsImdldE5vZGVMb2FkYWJsZSQxIiwic2V0Tm9kZVZhbHVlJDEiLCJnZXROZXh0Q29tcG9uZW50SUQkMSIsImdldE5vZGUkMiIsImdldE5vZGVNYXliZSQyIiwiRGVmYXVsdFZhbHVlJDEiLCJyZWFjdE1vZGUkMSIsIkFic3RyYWN0UmVjb2lsVmFsdWUkMSIsIlJlY29pbFN0YXRlJDEiLCJSZWNvaWxWYWx1ZVJlYWRPbmx5JDEiLCJpc1JlY29pbFZhbHVlJDEiLCJpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQxIiwiZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlIiwiYXBwbHlBdG9tVmFsdWVXcml0ZXMiLCJ3cml0ZXMiLCJ2YWx1ZUZyb21WYWx1ZU9yVXBkYXRlciIsInZhbHVlT3JVcGRhdGVyIiwibXNnIiwiYXBwbHlBY3Rpb24iLCJhY3Rpb24iLCJ3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUiLCJ1bnZhbGlkYXRlZFZhbHVlIiwiYXBwbHlBY3Rpb25zVG9TdG9yZSIsImFjdGlvbnMiLCJyZXBsYWNlU3RhdGUiLCJuZXdTdGF0ZSIsImNvcHlUcmVlU3RhdGUiLCJpbnZhbGlkYXRlRG93bnN0cmVhbXMiLCJxdWV1ZU9yUGVyZm9ybVN0YXRlVXBkYXRlIiwiYmF0Y2hTdGFjayIsImFjdGlvbnNCeVN0b3JlIiwiYmF0Y2hTdGFydCIsInBvcHBlZCIsImRvd25zdHJlYW1zIiwiX2dldE5vZGVNYXliZSIsIl9nZXROb2RlTWF5YmUkaW52YWxpZCIsInNldFJlY29pbFZhbHVlIiwic2V0UmVjb2lsVmFsdWVMb2FkYWJsZSIsIm1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkIiwic2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZSIsInN1YnNjcmliZVRvUmVjb2lsVmFsdWUiLCJjb21wb25lbnREZWJ1Z05hbWUiLCJzdWJJRCIsInJlbGVhc2UiLCJyZWxlYXNlU3RvcmVTdGF0ZSIsInN1YnMiLCJyZWZyZXNoUmVjb2lsVmFsdWUiLCJfbm9kZSRjbGVhckNhY2hlIiwiY2xlYXJDYWNoZSIsIlJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZSIsInNvbWVTZXQiLCJjb250ZXh0IiwiZW50cnkiLCJSZWNvaWxfc29tZVNldCIsImNsZWFuVXBOb2RlJDEiLCJkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZSQxIiwiZ2V0Tm9kZSQzIiwiUmV0ZW50aW9uWm9uZSQyIiwiU1VTUEVOU0VfVElNRU9VVF9NUyIsImVtcHR5U2V0JDEiLCJyZWxlYXNlUmV0YWluYWJsZXNOb3dPbkN1cnJlbnRUcmVlIiwicmV0YWluYWJsZXMiLCJyIiwibiIsInJlbGVhc2FibGVOb2RlcyIsImZpbmRSZWxlYXNhYmxlTm9kZXMiLCJyZWxlYXNlTm9kZSIsInNlYXJjaEZyb21Ob2RlcyIsIm5vblJlbGVhc2FibGVOb2RlcyIsImZpbmRSZWxlYXNhYmxlTm9kZXNJbm5lciIsInJlbGVhc2FibGVOb2Rlc0ZvdW5kVGhpc0l0ZXJhdGlvbiIsImdldERvd25zdHJlYW1Ob2Rlc0luVG9wb2xvZ2ljYWxPcmRlciIsIl9zdG9yZVN0YXRlJHJldGVudGlvbiIsInpvbmVzVGhhdENvdWxkUmV0YWluTm9kZSIsIm5vZGVDaGlsZHJlbiIsInBhcmVudHMiLCJwYXJlbnQiLCJkb05vdERlc2NlbmRJbnRvMSIsImRvTm90RGVzY2VuZEludG8yIiwiYW5zd2VyIiwidmlzaXRlZCIsInpvbmVzIiwiX3N0b3JlU3RhdGUkcmV0ZW50aW9uMiIsIl9zdG9yZVN0YXRlJHJldGVudGlvbjMiLCJzY2hlZHVsZU9yUGVyZm9ybVBvc3NpYmxlUmVsZWFzZU9mUmV0YWluYWJsZSIsInJldGFpbmFibGUiLCJ1cGRhdGVSZXRhaW5Db3VudCIsImRlbHRhIiwiX21hcCRnZXQiLCJuZXdDb3VudCIsInVwZGF0ZVJldGFpbkNvdW50VG9aZXJvIiwicmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93IiwicmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0IiwiUmVjb2lsX1JldGVudGlvbiIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwiUmVhY3RCYXRjaGVkVXBkYXRlcyIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDEiLCJSZWNvaWxfUmVhY3RCYXRjaGVkVXBkYXRlcyIsImJhdGNoU3RhcnQkMSIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDIiLCJiYXRjaGVyIiwic2V0QmF0Y2hlciIsIm5ld0JhdGNoZXIiLCJnZXRCYXRjaGVyIiwiYmF0Y2hVcGRhdGVzIiwiYmF0Y2hFbmQiLCJSZWNvaWxfQmF0Y2hpbmciLCJjb25jYXRJdGVyYWJsZXMiLCJpdGVycyIsIml0ZXIiLCJ2YWwiLCJSZWNvaWxfY29uY2F0SXRlcmFibGVzIiwiaXNTU1IiLCJXaW5kb3ciLCJpc1dpbmRvdyIsImlzUmVhY3ROYXRpdmUiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0IiwiUmVjb2lsX0Vudmlyb25tZW50IiwibWVtb2l6ZVdpdGhBcmdzSGFzaCIsImhhc2hGdW5jdGlvbiIsImNhY2hlIiwibWVtb2l6ZWRGbiIsImhhc093blByb3BlcnR5IiwibWVtb2l6ZU9uZVdpdGhBcmdzSGFzaCIsImxhc3RLZXkiLCJsYXN0UmVzdWx0IiwibWVtb2l6ZU9uZVdpdGhBcmdzSGFzaEFuZEludmFsaWRhdGlvbiIsIlJlY29pbF9NZW1vaXplIiwiYmF0Y2hVcGRhdGVzJDEiLCJpbml0aWFsaXplTm9kZSQxIiwicGVla05vZGVJbmZvJDEiLCJncmFwaCQxIiwiZ2V0TmV4dFN0b3JlSUQkMSIsIkRFRkFVTFRfVkFMVUUkMSIsInJlY29pbFZhbHVlcyQxIiwicmVjb2lsVmFsdWVzRm9yS2V5cyQyIiwiQWJzdHJhY3RSZWNvaWxWYWx1ZSQyIiwiZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDEiLCJzZXRSZWNvaWxWYWx1ZSQxIiwic2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZSQxIiwidXBkYXRlUmV0YWluQ291bnQkMSIsInNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDEiLCJnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQyIiwibWFrZUVtcHR5U3RvcmVTdGF0ZSQxIiwiaXNTU1IkMSIsIm1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb24kMSIsInJldGFpbldhcm5pbmciLCJTbmFwc2hvdCIsInBhcmVudFN0b3JlSUQiLCJjaGVja1JlZkNvdW50X0lOVEVSTkFMIiwiX3N0b3JlIiwiZ2V0TG9hZGFibGUiLCJvcHQiLCJpc0luaXRpYWxpemVkIiwibWFwcGVyIiwibXV0YWJsZVNuYXBzaG90IiwiTXV0YWJsZVNuYXBzaG90IiwicmV0YWluIiwiYXV0b1JlbGVhc2VfSU5URVJOQUwiLCJzdG9yZUlEIiwicmVwbGFjZXIiLCJncmFwaHMiLCJuZXdHcmFwaCIsInN1YnNjcmliZVRvVHJhbnNhY3Rpb25zIiwiYWRkVHJhbnNhY3Rpb25NZXRhZGF0YSIsIl9yZWZDb3VudCIsInJlbGVhc2VkIiwiX3JlbGVhc2UiLCJzZXRUaW1lb3V0IiwiY2xlYW51cCIsImlzUmV0YWluZWQiLCJnZXRTdG9yZV9JTlRFUk5BTCIsImdldElEIiwiZ2V0U3RvcmVJRCIsImNsb25lU3RvcmVTdGF0ZSIsImJ1bXBWZXJzaW9uIiwiZnJlc2hTbmFwc2hvdCIsImluaXRpYWxpemVTdGF0ZSIsInNuYXBzaG90IiwibWVtb2l6ZWRDbG9uZVNuYXBzaG90IiwiaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMiIsIl9zdG9yZSRnZXRTdGF0ZSRuZXh0VCIsIl9zdG9yZSRnZXRTdGF0ZSRwcmV2aSIsImNsb25lU25hcHNob3QiLCJiYXRjaCIsInJlY29pbFN0YXRlIiwibmV3VmFsdWVPclVwZGF0ZXIiLCJfYmF0Y2giLCJSZWNvaWxfU25hcHNob3QiLCJSZWNvaWxfU25hcHNob3RfMSIsIlJlY29pbF9TbmFwc2hvdF8yIiwiUmVjb2lsX1NuYXBzaG90XzMiLCJSZWNvaWxfU25hcHNob3RfNCIsIlJlY29pbF9TbmFwc2hvdCQxIiwidW5pb25TZXRzIiwic2V0cyIsIlJlY29pbF91bmlvblNldHMiLCJ1c2VSZWYiLCJ1c2VSZWZJbml0T25jZSIsImluaXRpYWxWYWx1ZSIsInJlZiIsIlJlY29pbF91c2VSZWZJbml0T25jZSIsImdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDMiLCJtYWtlRW1wdHlTdG9yZVN0YXRlJDIiLCJjbGVhblVwTm9kZSQyIiwiZ2V0RG93bnN0cmVhbU5vZGVzJDIiLCJpbml0aWFsaXplTm9kZSQyIiwic2V0Tm9kZVZhbHVlJDIiLCJzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVEJDEiLCJncmFwaCQyIiwiY2xvbmVHcmFwaCQxIiwiZ2V0TmV4dFN0b3JlSUQkMiIsImNyZWF0ZU11dGFibGVTb3VyY2UkMSIsInJlYWN0TW9kZSQyIiwiYXBwbHlBdG9tVmFsdWVXcml0ZXMkMSIsInJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdyQxIiwiZnJlc2hTbmFwc2hvdCQxIiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiQxIiwidXNlU3RhdGUiLCJub3RJbkFDb250ZXh0IiwiZGVmYXVsdFN0b3JlIiwic3RhdGVSZXBsYWNlcklzQmVpbmdFeGVjdXRlZCIsInN0YXJ0TmV4dFRyZWVJZk5lZWRlZCIsIkFwcENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlU3RvcmVSZWYiLCJNdXRhYmxlU291cmNlQ29udGV4dCIsInVzZVJlY29pbE11dGFibGVTb3VyY2UiLCJtdXRhYmxlU291cmNlIiwibm90aWZ5Q29tcG9uZW50cyIsImRlcGVuZGVudE5vZGVzIiwiY29tcHMiLCJfc3ViSUQiLCJfZGVidWdOYW1lIiwic2VuZEVuZE9mQmF0Y2hOb3RpZmljYXRpb25zIiwic3Vic2NyaXB0aW9ucyIsInN1YnNjcmlwdGlvbiIsImNiIiwic3BsaWNlIiwiZW5kQmF0Y2giLCJCYXRjaGVyIiwic2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlIiwic3RvcmVSZWYiLCJzZXRTdGF0ZSIsIiRyZWNvaWxEZWJ1Z1N0YXRlcyIsImluaXRpYWxTdG9yZVN0YXRlX0RFUFJFQ0FURUQiLCJpbml0aWFsIiwiYXRvbSIsIndyaXR0ZW5Ob2RlcyIsInNldFVudmFsaWRhdGVkQXRvbVZhbHVlcyIsImluaXRpYWxTdG9yZVN0YXRlIiwibmV4dElEIiwiUmVjb2lsUm9vdF9JTlRFUk5BTCIsImluaXRpYWxpemVTdGF0ZV9ERVBSRUNBVEVEIiwic3RvcmVfSU5URVJOQUwiLCJzdG9yZVByb3AiLCJzdG9yZVN0YXRlUmVmIiwiaWQiLCJtZXRhZGF0YSIsInJlcGxhY2VkIiwibm90aWZ5QmF0Y2hlck9mQ2hhbmdlIiwiYXRvbUtleSIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsIlJlY29pbFJvb3QiLCJwcm9wcyIsIm92ZXJyaWRlIiwicHJvcHNFeGNlcHRPdmVycmlkZSIsImFuY2VzdG9yU3RvcmVSZWYiLCJ1c2VSZWNvaWxTdG9yZUlEIiwiUmVjb2lsX1JlY29pbFJvb3QiLCJub3RpZnlDb21wb25lbnRzX0ZPUl9URVNUSU5HIiwic2VuZEVuZE9mQmF0Y2hOb3RpZmljYXRpb25zX0ZPUl9URVNUSU5HIiwic2hhbGxvd0FycmF5RXF1YWwiLCJhIiwiYiIsImwiLCJSZWNvaWxfc2hhbGxvd0FycmF5RXF1YWwiLCJ1c2VFZmZlY3QkMSIsInVzZVJlZiQyIiwidXNlUHJldmlvdXMiLCJSZWNvaWxfdXNlUHJldmlvdXMiLCJ1c2VTdG9yZVJlZiQxIiwiU1VTUEVOU0VfVElNRU9VVF9NUyQxIiwidXBkYXRlUmV0YWluQ291bnQkMiIsIlJldGVudGlvblpvbmUkMyIsInVzZUVmZmVjdCQyIiwidXNlUmVmJDMiLCJpc1NTUiQyIiwidXNlUmV0YWluIiwidG9SZXRhaW4iLCJ1c2VSZXRhaW5fQUNUVUFMIiwiYXJyYXkiLCJ0aW1lb3V0SUQiLCJjbGVhclRpbWVvdXQiLCJwcmV2aW91c1JldGFpbmFibGVzIiwiUmVjb2lsX3VzZVJldGFpbiIsInVzZUNvbXBvbmVudE5hbWUiLCJSZWNvaWxfdXNlQ29tcG9uZW50TmFtZSIsImJhdGNoVXBkYXRlcyQyIiwiREVGQVVMVF9WQUxVRSQyIiwicmVhY3RNb2RlJDMiLCJ1c2VNdXRhYmxlU291cmNlJDEiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxIiwidXNlUmVjb2lsTXV0YWJsZVNvdXJjZSQxIiwidXNlU3RvcmVSZWYkMiIsImlzUmVjb2lsVmFsdWUkMiIsIkFic3RyYWN0UmVjb2lsVmFsdWUkMyIsImdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyIiwic2V0UmVjb2lsVmFsdWUkMiIsInNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMiIsInN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMSIsInVzZUNhbGxiYWNrJDEiLCJ1c2VFZmZlY3QkMyIsInVzZU1lbW8kMSIsInVzZVJlZiQ0IiwidXNlU3RhdGUkMSIsInNldEJ5QWRkaW5nVG9TZXQkMiIsImhhbmRsZUxvYWRhYmxlIiwidmFsaWRhdGVSZWNvaWxWYWx1ZSIsImhvb2tOYW1lIiwidXNlUmVjb2lsSW50ZXJmYWNlX0RFUFJFQ0FURUQiLCJjb21wb25lbnROYW1lIiwiZm9yY2VVcGRhdGUiLCJyZWNvaWxWYWx1ZXNVc2VkIiwicHJldmlvdXNTdWJzY3JpcHRpb25zIiwidW5zdWJzY3JpYmVGcm9tIiwic3ViIiwidXBkYXRlU3RhdGUiLCJfc3RhdGUiLCJjdXJyZW50U3Vic2NyaXB0aW9ucyIsInVzZVNldFJlY29pbFN0YXRlIiwidXNlUmVzZXRSZWNvaWxTdGF0ZSIsInVzZVJlY29pbFZhbHVlTG9hZGFibGUiLCJ1c2VSZWNvaWxWYWx1ZSIsInVzZVJlY29pbFN0YXRlIiwidXNlUmVjb2lsU3RhdGVMb2FkYWJsZSIsImdldFJlY29pbFZhbHVlIiwiZ2V0UmVjb2lsVmFsdWVMb2FkYWJsZSIsImdldFJlY29pbFN0YXRlIiwiZ2V0UmVjb2lsU3RhdGVMb2FkYWJsZSIsImdldFNldFJlY29pbFN0YXRlIiwiZ2V0UmVzZXRSZWNvaWxTdGF0ZSIsInJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkciLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1NZTkNfRVhURVJOQUxfU1RPUkUiLCJnZXRTbmFwc2hvdCIsIm1lbW9pemVQcmV2aW91c1NuYXBzaG90IiwicHJldlN0YXRlIiwiX3ByZXZTdGF0ZSIsIl9wcmV2U3RhdGUyIiwibmV4dFN0YXRlIiwiZ2V0TWVtb2l6ZWRTbmFwc2hvdCIsInN1YnNjcmliZSIsIm5vdGlmeSIsInVzZVJlY29pbFZhbHVlTG9hZGFibGVfTVVUQUJMRV9TT1VSQ0UiLCJfc3RvcmVTdGF0ZSRuZXh0VHJlZTMiLCJnZXRMb2FkYWJsZVdpdGhUZXN0aW5nIiwiX3N0b3JlU3RhdGUiLCJuZXdMb2FkYWJsZSIsInByZXZMb2FkYWJsZVJlZiIsInNvdXJjZSIsInVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUIiwiX3N0b3JlU3RhdGUkbmV4dFRyZWU0IiwidXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9MRUdBQ1kiLCJfc3RvcmVTdGF0ZSRuZXh0VHJlZTUiLCJfcHJldkxvYWRhYmxlUmVmJGN1cnIiLCJfcHJldkxvYWRhYmxlUmVmJGN1cnIyIiwiVFJBTlNJVElPTl9TVVBQT1JUIiwiU1lOQ19FWFRFUk5BTF9TVE9SRSIsIk1VVEFCTEVfU09VUkNFIiwiTEVHQUNZIiwidXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzIiwidXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUiLCJ1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUiLCJ1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUiLCJSZWNvaWxfSG9va3MiLCJ1c2VSZWNvaWxJbnRlcmZhY2UiLCJmaWx0ZXJNYXAiLCJSZWNvaWxfZmlsdGVyTWFwIiwiZmlsdGVyU2V0IiwiUmVjb2lsX2ZpbHRlclNldCIsIm1lcmdlTWFwcyIsIm1hcHMiLCJuZXh0S2V5IiwiUmVjb2lsX21lcmdlTWFwcyIsImJhdGNoVXBkYXRlcyQzIiwiREVGQVVMVF9WQUxVRSQzIiwiZ2V0Tm9kZSQ0Iiwibm9kZXMkMSIsInVzZVN0b3JlUmVmJDMiLCJBYnN0cmFjdFJlY29pbFZhbHVlJDQiLCJzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlJDEiLCJTVVNQRU5TRV9USU1FT1VUX01TJDIiLCJjbG9uZVNuYXBzaG90JDEiLCJ1c2VDYWxsYmFjayQyIiwidXNlRWZmZWN0JDQiLCJ1c2VSZWYkNSIsInVzZVN0YXRlJDIiLCJpc1NTUiQzIiwidXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb24iLCJleHRlcm5hbGx5VmlzaWJsZUF0b21WYWx1ZXNJblN0YXRlIiwicGVyc2lzdGVkQXRvbUNvbnRlbnRzVmFsdWVzIiwicGVyc2lzdGVuY2UiLCJwZXJzaXN0ZW5jZV9VTlNUQUJMRSIsInVzZVRyYW5zYWN0aW9uT2JzZXJ2YXRpb25fREVQUkVDQVRFRCIsInByZXZpb3VzQXRvbVZhbHVlcyIsImF0b21JbmZvIiwiX25vZGUkcGVyc2lzdGVuY2VfVU5TIiwiX25vZGUkcGVyc2lzdGVuY2VfVU5TMiIsIl9ub2RlJHBlcnNpc3RlbmNlX1VOUzMiLCJfbm9kZSRwZXJzaXN0ZW5jZV9VTlM0IiwiYmFja0J1dHRvbiIsIm1vZGlmaWVkQXRvbXMiLCJ1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyIiwicHJldmlvdXNTbmFwc2hvdCIsInVzZVJlY29pbFNuYXBzaG90Iiwic2V0U25hcHNob3QiLCJyZWxlYXNlUmVmIiwiX3JlbGVhc2VSZWYkY3VycmVudCIsIl9yZWxlYXNlUmVmJGN1cnJlbnQyIiwiX3JlbGVhc2VSZWYkY3VycmVudDMiLCJnb3RvU25hcHNob3QiLCJwcmV2Iiwia2V5c1RvVXBkYXRlIiwiX3ByZXYkYXRvbVZhbHVlcyRnZXQiLCJfbmV4dCRhdG9tVmFsdWVzJGdldCIsInNob3VsZFJlc3RvcmVGcm9tU25hcHNob3RzIiwidXNlR290b1JlY29pbFNuYXBzaG90IiwiUmVjb2lsX1NuYXBzaG90SG9va3MiLCJ1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvbl9ERVBSRUNBVEVEIiwicGVla05vZGVJbmZvJDIiLCJ1c2VTdG9yZVJlZiQ0IiwidXNlR2V0UmVjb2lsVmFsdWVJbmZvIiwiUmVjb2lsX3VzZUdldFJlY29pbFZhbHVlSW5mbyIsInJlYWN0TW9kZSQ0IiwiUmVjb2lsUm9vdCQxIiwidXNlU3RvcmVSZWYkNSIsInVzZU1lbW8kMiIsInVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHMiLCJSZWNvaWxCcmlkZ2UiLCJSZWNvaWxfdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cyIsImxvYWRhYmxlV2l0aFZhbHVlJDEiLCJpbml0aWFsaXplTm9kZSQzIiwiREVGQVVMVF9WQUxVRSQ0IiwiZ2V0Tm9kZSQ1IiwiY29weVRyZWVTdGF0ZSQxIiwiZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDMiLCJpbnZhbGlkYXRlRG93bnN0cmVhbXMkMSIsIndyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZSQxIiwiaXNBdG9tIiwiVHJhbnNhY3Rpb25JbnRlcmZhY2VJbXBsIiwiX2NoYW5nZXMiLCJfdHJlZVN0YXRlIiwibmV3VHJlZVN0YXRlX0lOVEVSTkFMIiwiYXRvbWljVXBkYXRlciIsImNoYW5nZXNldCIsIlJlY29pbF9BdG9taWNVcGRhdGVzIiwiUmVjb2lsX0F0b21pY1VwZGF0ZXNfMSIsIlJlY29pbF9BdG9taWNVcGRhdGVzJDEiLCJpbnZhcmlhbnQiLCJjb25kaXRpb24iLCJpbnZhcmlhbnRfMSIsIlJlY29pbF9pbnZhcmlhbnQiLCJhdG9taWNVcGRhdGVyJDEiLCJiYXRjaFVwZGF0ZXMkNCIsIkRFRkFVTFRfVkFMVUUkNSIsInVzZVN0b3JlUmVmJDYiLCJyZWZyZXNoUmVjb2lsVmFsdWUkMSIsInNldFJlY29pbFZhbHVlJDMiLCJjbG9uZVNuYXBzaG90JDIiLCJnb3RvU25hcHNob3QkMSIsInVzZUNhbGxiYWNrJDMiLCJTZW50aW5lbCIsIlNFTlRJTkVMIiwicmVjb2lsQ2FsbGJhY2siLCJleHRyYUludGVyZmFjZSIsInJlbGVhc2VTbmFwc2hvdCIsImVyck1zZyIsImNhbGxiYWNrSW50ZXJmYWNlIiwicmVzZXQiLCJyZWZyZXNoIiwidHJhbnNhY3RfVU5TVEFCTEUiLCJ0cmFuc2FjdGlvbiIsImZpbmFsbHkiLCJfcmVsZWFzZVNuYXBzaG90IiwiX3JlbGVhc2VTbmFwc2hvdDIiLCJ1c2VSZWNvaWxDYWxsYmFjayIsIlJlY29pbF91c2VSZWNvaWxDYWxsYmFjayIsInVzZVN0b3JlUmVmJDciLCJyZWZyZXNoUmVjb2lsVmFsdWUkMiIsInVzZUNhbGxiYWNrJDQiLCJ1c2VSZWNvaWxSZWZyZXNoZXIiLCJSZWNvaWxfdXNlUmVjb2lsUmVmcmVzaGVyIiwiYXRvbWljVXBkYXRlciQyIiwidXNlU3RvcmVSZWYkOCIsInVzZU1lbW8kMyIsInVzZVJlY29pbFRyYW5zYWN0aW9uIiwiYXRvbWljVXBkYXRlIiwidHJhbnNhY3Rpb25JbnRlcmZhY2UiLCJSZWNvaWxfdXNlUmVjb2lsVHJhbnNhY3Rpb24iLCJXcmFwcGVkVmFsdWUiLCJSZWNvaWxfV3JhcHBlciIsIlJlY29pbF9XcmFwcGVyXzEiLCJSZWNvaWxfV3JhcHBlciQxIiwiaXNGYXN0UmVmcmVzaEVuYWJsZWQkMiIsIkNoYW5nZWRQYXRoRXJyb3IiLCJUcmVlQ2FjaGUiLCJvcHRpb25zIiwiX29wdGlvbnMkb25IaXQiLCJfb3B0aW9ucyRvblNldCIsIl9vcHRpb25zJG1hcE5vZGVWYWx1ZSIsIl9uYW1lIiwiX251bUxlYWZzIiwiX29uSGl0Iiwib25IaXQiLCJfb25TZXQiLCJvblNldCIsIl9tYXBOb2RlVmFsdWUiLCJtYXBOb2RlVmFsdWUiLCJnZXROb2RlVmFsdWUiLCJoYW5kbGVycyIsIl90aGlzJGdldExlYWZOb2RlIiwiZ2V0TGVhZk5vZGUiLCJvbk5vZGVWaXNpdCIsIm5vZGVWYWx1ZSIsImJyYW5jaGVzIiwicm91dGUiLCJhZGRMZWFmIiwiX25vZGUyIiwiX25vZGUzIiwiX3RoaXMkX3Jvb3QyIiwiX2hhbmRsZXJzJG9uTm9kZVZpc2l0MiIsImJyYW5jaEtleSIsIl9ub2RlIiwiX2hhbmRsZXJzJG9uTm9kZVZpc2l0IiwiX3RoaXMkX3Jvb3QiLCJpbnZhbGlkQ2FjaGVFcnJvciIsIm9sZExlYWYiLCJsZWFmTm9kZSIsImxlYWYiLCJfbm9kZTQiLCJDSEFOR0VEX1BBVEhfRVJST1JfTUVTU0FHRSIsIlJlY29pbF9UcmVlQ2FjaGUiLCJSZWNvaWxfVHJlZUNhY2hlXzEiLCJSZWNvaWxfVHJlZUNhY2hlJDEiLCJMUlVDYWNoZSIsIl9vcHRpb25zJG1hcEtleSIsIl9tYXhTaXplIiwibWF4U2l6ZSIsIl9oZWFkIiwiX3RhaWwiLCJfa2V5TWFwcGVyIiwibWFwS2V5IiwiaGVhZCIsInRhaWwiLCJtYXBwZWRLZXkiLCJleGlzdGluZ05vZGUiLCJyaWdodCIsImxlZnQiLCJfbWF5YmVEZWxldGVMUlUiLCJkZWxldGVMcnUiLCJSZWNvaWxfTFJVQ2FjaGUiLCJSZWNvaWxfTFJVQ2FjaGVfMSIsIlJlY29pbF9MUlVDYWNoZSQxIiwiTFJVQ2FjaGUkMSIsIlRyZWVDYWNoZSQxIiwidHJlZUNhY2hlTFJVIiwibHJ1Q2FjaGUiLCJscnVOb2RlIiwiUmVjb2lsX3RyZWVDYWNoZUxSVSIsIlRJTUVfV0FSTklOR19USFJFU0hPTERfTVMiLCJzdHJpbmdpZnkiLCJpbmNsdWRlcyIsIkpTT04iLCJhbGxvd0Z1bmN0aW9ucyIsIl9KU09OJHN0cmluZ2lmeSIsInRvU3RyaW5nIiwic29ydCIsImxvY2FsZUNvbXBhcmUiLCJmaWx0ZXIiLCJqb2luIiwic3RhYmxlU3RyaW5naWZ5Iiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJlbmRUaW1lIiwiZ3JvdXBDb2xsYXBzZWQiLCJncm91cEVuZCIsIlJlY29pbF9zdGFibGVTdHJpbmdpZnkiLCJUcmVlQ2FjaGUkMiIsImRlZmF1bHRQb2xpY3kiLCJlcXVhbGl0eSIsImV2aWN0aW9uIiwiSW5maW5pdHkiLCJ0cmVlQ2FjaGVGcm9tUG9saWN5IiwidmFsdWVNYXBwZXIiLCJnZXRWYWx1ZU1hcHBlciIsImdldFRyZWVDYWNoZSIsIlJlY29pbF90cmVlQ2FjaGVGcm9tUG9saWN5IiwiaXNOb2RlIiwib2JqZWN0IiwiX293bmVyRG9jdW1lbnQiLCJfZG9jJGRlZmF1bHRWaWV3IiwiZG9jIiwib3duZXJEb2N1bWVudCIsImRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJOb2RlIiwibm9kZU5hbWUiLCJSZWNvaWxfaXNOb2RlIiwiaXNSZWFjdE5hdGl2ZSQxIiwiaXNXaW5kb3ckMSIsInNob3VsZE5vdEJlRnJvemVuIiwiJCR0eXBlb2YiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImRlZXBGcmVlemVWYWx1ZSIsImlzRnJvemVuIiwic2VhbCIsIlJlY29pbF9kZWVwRnJlZXplVmFsdWUiLCJzdGFydFBlcmZCbG9jayIsIl9pZCIsIlJlY29pbF9QZXJmb3JtYW5jZVRpbWluZ3MiLCJpc0xvYWRhYmxlJDEiLCJsb2FkYWJsZVdpdGhFcnJvciQxIiwibG9hZGFibGVXaXRoUHJvbWlzZSQxIiwibG9hZGFibGVXaXRoVmFsdWUkMiIsIldyYXBwZWRWYWx1ZSQxIiwiZ2V0Tm9kZUxvYWRhYmxlJDIiLCJwZWVrTm9kZUxvYWRhYmxlJDEiLCJzZXROb2RlVmFsdWUkMyIsInNhdmVEZXBzVG9TdG9yZSQxIiwiREVGQVVMVF9WQUxVRSQ2IiwiZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDEiLCJnZXROb2RlJDYiLCJyZWdpc3Rlck5vZGUkMSIsImlzUmVjb2lsVmFsdWUkMyIsIm1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDEiLCJyZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQkMSIsInJlY29pbENhbGxiYWNrJDEiLCJzdGFydFBlcmZCbG9jayQxIiwiQ2FuY2VsZWQiLCJDQU5DRUxFRCIsImRlcGVuZGVuY3lTdGFjayIsIndhaXRpbmdTdG9yZXMiLCJnZXROZXdFeGVjdXRpb25JRCIsImV4ZWN1dGlvbklEIiwic2VsZWN0b3IiLCJjYWNoZVBvbGljeV9VTlNUQUJMRSIsImNhY2hlUG9saWN5IiwiZGlzY292ZXJlZERlcGVuZGVuY3lOb2RlS2V5cyIsInJldGFpbmVkQnlfVU5TVEFCTEUiLCJleGVjdXRpb25JbmZvTWFwIiwibGl2ZVN0b3Jlc0NvdW50Iiwic2VsZWN0b3JJc0xpdmUiLCJzZWxlY3RvckluaXQiLCJzZWxlY3RvclNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZSIsInJlc29sdmVBc3luYyIsImRlcFZhbHVlcyIsInNldENhY2hlIiwibm90aWZ5U3RvcmVzT2ZSZXNvbHZlZEFzeW5jIiwiaXNMYXRlc3RFeGVjdXRpb24iLCJjbGVhckV4ZWN1dGlvbkluZm8iLCJub3RpZnlXYWl0aW5nU3RvcmVzIiwibm90aWZ5U3RvcmVzT2ZOZXdBc3luY0RlcCIsImV4ZWN1dGlvbkluZm8iLCJnZXRFeGVjdXRpb25JbmZvIiwic3RhdGVWZXJzaW9ucyIsImNsZWFyV2FpdGxpc3QiLCJzdG9yZXMiLCJ3YWl0aW5nU3RvcmUiLCJtYXJrU3RvcmVXYWl0aW5nRm9yUmVzb2x2ZWRBc3luYyIsIndyYXBSZXN1bHRQcm9taXNlIiwibG9hZGluZ0RlcHNTdGF0ZSIsImVycm9yT3JQcm9taXNlIiwid3JhcFBlbmRpbmdEZXBlbmRlbmN5UHJvbWlzZSIsImV4aXN0aW5nRGVwcyIsInJlc29sdmVkRGVwIiwibG9hZGluZ0RlcEtleSIsImxvYWRpbmdEZXBQcm9taXNlIiwiY2FjaGVkTG9hZGFibGUiLCJnZXRMb2FkYWJsZUZyb21DYWNoZUFuZFVwZGF0ZURlcHMiLCJnZXRJblByb2dyZXNzRXhlY3V0aW9uSW5mbyIsImxvYWRpbmdMb2FkYWJsZSIsImV2YWx1YXRlU2VsZWN0b3JHZXR0ZXIiLCJ1cGRhdGVEZXBzIiwiX3N0b3JlJGdldFN0YXRlIiwiX3N0b3JlJGdldFN0YXRlJGN1cnJlIiwiX3N0b3JlJGdldFN0YXRlMiIsIl9zdG9yZSRnZXRTdGF0ZTIkbmV4dCIsIl9zdG9yZSRnZXRTdGF0ZTMiLCJfc3RvcmUkZ2V0U3RhdGUzJG5leHQiLCJlbmRQZXJmQmxvY2siLCJkdXJpbmdTeW5jaHJvbm91c0V4ZWN1dGlvbiIsImR1cmluZ0FzeW5jaHJvbm91c0V4ZWN1dGlvbiIsImZpbmlzaEV2YWx1YXRpb24iLCJyZXN1bHRJc0Vycm9yIiwiZGVwS2V5IiwiZGVwTG9hZGFibGUiLCJnZXRDYWxsYmFjayIsImVycm9yT3JEZXBQcm9taXNlIiwidXBkYXRlRXhlY3V0aW9uSW5mb0RlcFZhbHVlcyIsImRlcHNBZnRlckNhY2hlTG9va3VwIiwiX2dldEV4ZWN1dGlvbkluZm8iLCJnZXRTZWxlY3RvckxvYWRhYmxlQW5kVXBkYXRlRGVwcyIsImNhY2hlZFZhbCIsImluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvIiwiX2luUHJvZ3Jlc3NFeGVjdXRpb25JIiwibmV3RXhlY3V0aW9uSUQiLCJuZXdEZXBWYWx1ZXMiLCJzZXRFeGVjdXRpb25JbmZvIiwicGVuZGluZ0V4ZWN1dGlvbnMiLCJleGVjSW5mbyIsImFueURlcENoYW5nZWQiLCJleGVjRGVwVmFsdWVzIiwiZXhlY0xvYWRhYmxlIiwiZGVwVmFsdWVzRGlzY292ZXJlZFNvRmFyRHVyaW5nQXN5bmNXb3JrIiwiX2dldEV4ZWN1dGlvbkluZm8yIiwiZGVwVmFsdWVzVG9EZXBSb3V0ZSIsInZhbExvYWRhYmxlIiwiQm9vbGVhbiIsImRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5IiwiZGV0ZWN0Q2lyY3VsYXJEZXBlbmRlbmNpZXMiLCJzbGljZSIsImluZGV4T2YiLCJzZWxlY3RvclBlZWsiLCJfcGVla05vZGVMb2FkYWJsZSIsInNlbGVjdG9yR2V0IiwiaW52YWxpZGF0ZVNlbGVjdG9yIiwiY2xlYXJTZWxlY3RvckNhY2hlIiwic2VsZWN0b3JTZXQiLCJzeW5jU2VsZWN0b3JTZXRGaW5pc2hlZCIsInNldFJlY29pbFN0YXRlIiwic2V0VmFsdWUiLCJ1cHN0cmVhbVdyaXRlcyIsInJlc2V0UmVjb2lsU3RhdGUiLCJSZWNvaWxfc2VsZWN0b3IiLCJpc0xvYWRhYmxlJDIiLCJsb2FkYWJsZVdpdGhFcnJvciQyIiwibG9hZGFibGVXaXRoUHJvbWlzZSQyIiwibG9hZGFibGVXaXRoVmFsdWUkMyIsIldyYXBwZWRWYWx1ZSQyIiwicGVla05vZGVJbmZvJDMiLCJERUZBVUxUX1ZBTFVFJDciLCJEZWZhdWx0VmFsdWUkMiIsImdldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQyIiwicmVnaXN0ZXJOb2RlJDIiLCJzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMSIsImlzUmVjb2lsVmFsdWUkNCIsImdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQ0IiwibWFya1JlY29pbFZhbHVlTW9kaWZpZWQkMiIsInNldFJlY29pbFZhbHVlJDQiLCJzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlJDIiLCJyZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQkMiIsInVud3JhcCIsImJhc2VBdG9tIiwidW53cmFwUHJvbWlzZSIsImRlZmF1bHRMb2FkYWJsZSIsImRlZmF1bHQiLCJtYXliZUZyZWV6ZVZhbHVlT3JQcm9taXNlIiwiY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSIsImNsZWFudXBFZmZlY3RzQnlTdG9yZSIsInZhbHVlT3JQcm9taXNlIiwid3JhcFBlbmRpbmdQcm9taXNlIiwid3JhcHBlZFByb21pc2UiLCJfc3RhdGUkYXRvbVZhbHVlcyRnZXQiLCJfc3RvcmUkZ2V0U3RhdGUkbmV4dFQyIiwiX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MiIsImluaXRBdG9tIiwiaW5pdFN0YXRlIiwiX29wdGlvbnMkZWZmZWN0cyIsImNsZWFudXBBdG9tIiwiX2NsZWFudXBFZmZlY3RzQnlTdG9yIiwibm90aWZ5RGVmYXVsdFN1YnNjcmliZXJzIiwiX3N0b3JlJGdldFN0YXRlJG5leHRUMyIsImVmZmVjdHMiLCJlZmZlY3RzX1VOU1RBQkxFIiwiaW5pdFZhbHVlIiwiaXNEdXJpbmdJbml0IiwiaXNJbml0RXJyb3IiLCJwZW5kaW5nU2V0U2VsZiIsInJldFZhbHVlIiwicGVla0F0b20iLCJnZXRQcm9taXNlIiwiZ2V0SW5mb19VTlNUQUJMRSIsIl9zdG9yZSRnZXRTdGF0ZSRuZXh0VDQiLCJpbmZvIiwic2V0U2VsZiIsImVmZmVjdCIsImN1cnJlbnRMb2FkYWJsZSIsImN1cnJlbnRWYWx1ZSIsInJlc2V0U2VsZiIsImhhbmRsZXIiLCJfY2xlYW51cEVmZmVjdHNCeVN0b3IyIiwiY3VycmVudFN0b3JlIiwiX2N1cnJlbnRUcmVlJGF0b21WYWx1IiwiX3ByZXZpb3VzVHJlZSRhdG9tVmFsIiwiX3BlbmRpbmdTZXRTZWxmIiwiX3BlbmRpbmdTZXRTZWxmMiIsIl9wZW5kaW5nU2V0U2VsZjMiLCJvbGRMb2FkYWJsZSIsIm9sZFZhbHVlIiwicGFyZW50U3RvcmVJRF9VTlNUQUJMRSIsIl9jbGVhbnVwRWZmZWN0c0J5U3RvcjMiLCJfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1IiwiaW5pdExvYWRhYmxlIiwiX3JlZiIsIl9zdGF0ZSRhdG9tVmFsdWVzJGdldDMiLCJnZXRBdG9tIiwibm9udmFsaWRhdGVkVmFsdWUiLCJ2YWxpZGF0b3JSZXN1bHQiLCJ2YWxpZGF0b3IiLCJ2YWxpZGF0ZWRWYWx1ZUxvYWRhYmxlIiwiaW52YWxpZGF0ZUF0b20iLCJzZXRBdG9tIiwic2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlQXRvbSIsInJlc3RPcHRpb25zIiwib3B0aW9uc0RlZmF1bHQiLCJhdG9tV2l0aEZhbGxiYWNrIiwic3RvcmVkVmFsdWUiLCJzZWwiLCJiYXNlVmFsdWUiLCJSZWNvaWxfYXRvbSIsIk1hcENhY2hlIiwiUmVjb2lsX01hcENhY2hlIiwiUmVjb2lsX01hcENhY2hlXzEiLCJSZWNvaWxfTWFwQ2FjaGUkMSIsIkxSVUNhY2hlJDIiLCJNYXBDYWNoZSQxIiwiZGVmYXVsdFBvbGljeSQxIiwiY2FjaGVGcm9tUG9saWN5IiwiZ2V0VmFsdWVNYXBwZXIkMSIsImdldENhY2hlIiwiUmVjb2lsX2NhY2hlRnJvbVBvbGljeSIsInNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQyIiwiYXRvbUZhbWlseSIsIl9vcHRpb25zJGNhY2hlUG9saWN5RiIsIl9vcHRpb25zJGNhY2hlUG9saWN5RjIiLCJhdG9tQ2FjaGUiLCJjYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRSIsInBhcmFtcyIsIl9zdGFibGVTdHJpbmdpZnkiLCJjYWNoZWRBdG9tIiwiYXRvbU9wdGlvbnMiLCJuZXdBdG9tIiwiUmVjb2lsX2F0b21GYW1pbHkiLCJzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMyIsIm5leHRJbmRleCIsInNlbGVjdG9yRmFtaWx5Iiwic2VsZWN0b3JDYWNoZSIsImNhY2hlZFNlbGVjdG9yIiwibXlLZXkiLCJteUdldCIsImNhbGxiYWNrcyIsIm15Q2FjaGVQb2xpY3kiLCJuZXdTZWxlY3RvciIsIm15U2V0IiwiUmVjb2lsX3NlbGVjdG9yRmFtaWx5IiwiY29uc3RhbnRTZWxlY3RvciIsImNvbnN0U2VsZWN0b3IiLCJSZWNvaWxfY29uc3RTZWxlY3RvciIsInRocm93aW5nU2VsZWN0b3IiLCJlcnJvclNlbGVjdG9yIiwiUmVjb2lsX2Vycm9yU2VsZWN0b3IiLCJyZWFkT25seVNlbGVjdG9yIiwiUmVjb2lsX3JlYWRPbmx5U2VsZWN0b3IiLCJsb2FkYWJsZVdpdGhFcnJvciQzIiwibG9hZGFibGVXaXRoUHJvbWlzZSQzIiwibG9hZGFibGVXaXRoVmFsdWUkNCIsImNvbmN1cnJlbnRSZXF1ZXN0cyIsInJlc3VsdHMiLCJmaWxsIiwiZXhjZXB0aW9ucyIsImlzRXJyb3IiLCJleHAiLCJ1bndyYXBEZXBlbmRlbmNpZXMiLCJkZXBlbmRlbmNpZXMiLCJ3cmFwUmVzdWx0cyIsIndyYXBMb2FkYWJsZXMiLCJleGNlcHRpb24iLCJjb21iaW5lQXN5bmNSZXN1bHRzV2l0aFN5bmNSZXN1bHRzIiwic3luY1Jlc3VsdHMiLCJhc3luY1Jlc3VsdHMiLCJ3YWl0Rm9yTm9uZSIsIndhaXRGb3JBbnkiLCJ3YWl0Rm9yQWxsIiwiZXhjZXB0aW9uUmVzdWx0cyIsIndhaXRGb3JBbGxTZXR0bGVkIiwibm9XYWl0IiwiZGVwZW5kZW5jeSIsIlJlY29pbF9XYWl0Rm9yIiwiRGVmYXVsdFZhbHVlJDMiLCJSZWNvaWxSb290JDIiLCJ1c2VSZWNvaWxTdG9yZUlEJDEiLCJpc1JlY29pbFZhbHVlJDUiLCJyZXRlbnRpb25ab25lJDEiLCJmcmVzaFNuYXBzaG90JDIiLCJ1c2VSZWNvaWxTdGF0ZSQxIiwidXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEiLCJ1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlJDEiLCJ1c2VSZWNvaWxWYWx1ZSQxIiwidXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEiLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlJDEiLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxIiwidXNlUmVzZXRSZWNvaWxTdGF0ZSQxIiwidXNlU2V0UmVjb2lsU3RhdGUkMSIsInVzZUdvdG9SZWNvaWxTbmFwc2hvdCQxIiwidXNlUmVjb2lsU25hcHNob3QkMSIsInVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXIkMSIsInVzZVJlY29pbENhbGxiYWNrJDEiLCJub1dhaXQkMSIsIndhaXRGb3JBbGwkMSIsIndhaXRGb3JBbGxTZXR0bGVkJDEiLCJ3YWl0Rm9yQW55JDEiLCJ3YWl0Rm9yTm9uZSQxIiwiUmVjb2lsX2luZGV4IiwidXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290c19VTlNUQUJMRSIsInVzZUdldFJlY29pbFZhbHVlSW5mb19VTlNUQUJMRSIsInVzZVJlY29pbFJlZnJlc2hlcl9VTlNUQUJMRSIsInVzZVJlY29pbFRyYW5zYWN0aW9uX1VOU1RBQkxFIiwidXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlcl9VTlNUQUJMRSIsInNuYXBzaG90X1VOU1RBQkxFIiwiUmVjb2lsX2luZGV4XzEiLCJSZWNvaWxfaW5kZXhfMiIsIlJlY29pbF9pbmRleF8zIiwiUmVjb2lsX2luZGV4XzQiLCJSZWNvaWxfaW5kZXhfNSIsIlJlY29pbF9pbmRleF82IiwiUmVjb2lsX2luZGV4XzciLCJSZWNvaWxfaW5kZXhfOCIsIlJlY29pbF9pbmRleF85IiwiUmVjb2lsX2luZGV4XzEwIiwiUmVjb2lsX2luZGV4XzExIiwiUmVjb2lsX2luZGV4XzEyIiwiUmVjb2lsX2luZGV4XzEzIiwiUmVjb2lsX2luZGV4XzE0IiwiUmVjb2lsX2luZGV4XzE1IiwiUmVjb2lsX2luZGV4XzE2IiwiUmVjb2lsX2luZGV4XzE3IiwiUmVjb2lsX2luZGV4XzE4IiwiUmVjb2lsX2luZGV4XzE5IiwiUmVjb2lsX2luZGV4XzIwIiwiUmVjb2lsX2luZGV4XzIxIiwiUmVjb2lsX2luZGV4XzIyIiwiUmVjb2lsX2luZGV4XzIzIiwiUmVjb2lsX2luZGV4XzI0IiwiUmVjb2lsX2luZGV4XzI1IiwiUmVjb2lsX2luZGV4XzI2IiwiUmVjb2lsX2luZGV4XzI3IiwiUmVjb2lsX2luZGV4XzI4IiwiUmVjb2lsX2luZGV4XzI5IiwiUmVjb2lsX2luZGV4XzMwIiwiUmVjb2lsX2luZGV4XzMxIiwiUmVjb2lsX2luZGV4XzMyIiwiUmVjb2lsX2luZGV4XzMzIiwiUmVjb2lsX2luZGV4XzM0IiwiUmVjb2lsX2luZGV4XzM1IiwiUmVjb2lsX2luZGV4XzM2IiwiUmVjb2lsX2luZGV4XzM3Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/recoil/es/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css":
/*!********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css ***!
  \********************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*\\n! tailwindcss v3.1.8 | MIT License | https://tailwindcss.com\\n*//*\\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\\n*/\\n\\n*,\\n::before,\\n::after {\\n  box-sizing: border-box; /* 1 */\\n  border-width: 0; /* 2 */\\n  border-style: solid; /* 2 */\\n  border-color: #e5e7eb; /* 2 */\\n}\\n\\n::before,\\n::after {\\n  --tw-content: '';\\n}\\n\\n/*\\n1. Use a consistent sensible line-height in all browsers.\\n2. Prevent adjustments of font size after orientation changes in iOS.\\n3. Use a more readable tab size.\\n4. Use the user's configured `sans` font-family by default.\\n*/\\n\\nhtml {\\n  line-height: 1.5; /* 1 */\\n  -webkit-text-size-adjust: 100%; /* 2 */\\n  -moz-tab-size: 4; /* 3 */\\n  -o-tab-size: 4;\\n     tab-size: 4; /* 3 */\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\"; /* 4 */\\n}\\n\\n/*\\n1. Remove the margin in all browsers.\\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\\n*/\\n\\nbody {\\n  margin: 0; /* 1 */\\n  line-height: inherit; /* 2 */\\n}\\n\\n/*\\n1. Add the correct height in Firefox.\\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\\n3. Ensure horizontal rules are visible by default.\\n*/\\n\\nhr {\\n  height: 0; /* 1 */\\n  color: inherit; /* 2 */\\n  border-top-width: 1px; /* 3 */\\n}\\n\\n/*\\nAdd the correct text decoration in Chrome, Edge, and Safari.\\n*/\\n\\nabbr:where([title]) {\\n  -webkit-text-decoration: underline dotted;\\n          text-decoration: underline dotted;\\n}\\n\\n/*\\nRemove the default font size and weight for headings.\\n*/\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  font-size: inherit;\\n  font-weight: inherit;\\n}\\n\\n/*\\nReset links to optimize for opt-in styling instead of opt-out.\\n*/\\n\\na {\\n  color: inherit;\\n  text-decoration: inherit;\\n}\\n\\n/*\\nAdd the correct font weight in Edge and Safari.\\n*/\\n\\nb,\\nstrong {\\n  font-weight: bolder;\\n}\\n\\n/*\\n1. Use the user's configured `mono` font family by default.\\n2. Correct the odd `em` font sizing in all browsers.\\n*/\\n\\ncode,\\nkbd,\\nsamp,\\npre {\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace; /* 1 */\\n  font-size: 1em; /* 2 */\\n}\\n\\n/*\\nAdd the correct font size in all browsers.\\n*/\\n\\nsmall {\\n  font-size: 80%;\\n}\\n\\n/*\\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\\n*/\\n\\nsub,\\nsup {\\n  font-size: 75%;\\n  line-height: 0;\\n  position: relative;\\n  vertical-align: baseline;\\n}\\n\\nsub {\\n  bottom: -0.25em;\\n}\\n\\nsup {\\n  top: -0.5em;\\n}\\n\\n/*\\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\\n3. Remove gaps between table borders by default.\\n*/\\n\\ntable {\\n  text-indent: 0; /* 1 */\\n  border-color: inherit; /* 2 */\\n  border-collapse: collapse; /* 3 */\\n}\\n\\n/*\\n1. Change the font styles in all browsers.\\n2. Remove the margin in Firefox and Safari.\\n3. Remove default padding in all browsers.\\n*/\\n\\nbutton,\\ninput,\\noptgroup,\\nselect,\\ntextarea {\\n  font-family: inherit; /* 1 */\\n  font-size: 100%; /* 1 */\\n  font-weight: inherit; /* 1 */\\n  line-height: inherit; /* 1 */\\n  color: inherit; /* 1 */\\n  margin: 0; /* 2 */\\n  padding: 0; /* 3 */\\n}\\n\\n/*\\nRemove the inheritance of text transform in Edge and Firefox.\\n*/\\n\\nbutton,\\nselect {\\n  text-transform: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Remove default button styles.\\n*/\\n\\nbutton,\\n[type='button'],\\n[type='reset'],\\n[type='submit'] {\\n  -webkit-appearance: button; /* 1 */\\n  background-color: transparent; /* 2 */\\n  background-image: none; /* 2 */\\n}\\n\\n/*\\nUse the modern Firefox focus style for all focusable elements.\\n*/\\n\\n:-moz-focusring {\\n  outline: auto;\\n}\\n\\n/*\\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\\n*/\\n\\n:-moz-ui-invalid {\\n  box-shadow: none;\\n}\\n\\n/*\\nAdd the correct vertical alignment in Chrome and Firefox.\\n*/\\n\\nprogress {\\n  vertical-align: baseline;\\n}\\n\\n/*\\nCorrect the cursor style of increment and decrement buttons in Safari.\\n*/\\n\\n::-webkit-inner-spin-button,\\n::-webkit-outer-spin-button {\\n  height: auto;\\n}\\n\\n/*\\n1. Correct the odd appearance in Chrome and Safari.\\n2. Correct the outline style in Safari.\\n*/\\n\\n[type='search'] {\\n  -webkit-appearance: textfield; /* 1 */\\n  outline-offset: -2px; /* 2 */\\n}\\n\\n/*\\nRemove the inner padding in Chrome and Safari on macOS.\\n*/\\n\\n::-webkit-search-decoration {\\n  -webkit-appearance: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Change font properties to `inherit` in Safari.\\n*/\\n\\n::-webkit-file-upload-button {\\n  -webkit-appearance: button; /* 1 */\\n  font: inherit; /* 2 */\\n}\\n\\n/*\\nAdd the correct display in Chrome and Safari.\\n*/\\n\\nsummary {\\n  display: list-item;\\n}\\n\\n/*\\nRemoves the default spacing and border for appropriate elements.\\n*/\\n\\nblockquote,\\ndl,\\ndd,\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\nhr,\\nfigure,\\np,\\npre {\\n  margin: 0;\\n}\\n\\nfieldset {\\n  margin: 0;\\n  padding: 0;\\n}\\n\\nlegend {\\n  padding: 0;\\n}\\n\\nol,\\nul,\\nmenu {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n/*\\nPrevent resizing textareas horizontally by default.\\n*/\\n\\ntextarea {\\n  resize: vertical;\\n}\\n\\n/*\\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\\n2. Set the default placeholder color to the user's configured gray 400 color.\\n*/\\n\\ninput::-moz-placeholder, textarea::-moz-placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\ninput::placeholder,\\ntextarea::placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\n/*\\nSet the default cursor for buttons.\\n*/\\n\\nbutton,\\n[role=\\\"button\\\"] {\\n  cursor: pointer;\\n}\\n\\n/*\\nMake sure disabled buttons don't get the pointer cursor.\\n*/\\n:disabled {\\n  cursor: default;\\n}\\n\\n/*\\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\\n   This can trigger a poorly considered lint error in some tools but is included by design.\\n*/\\n\\nimg,\\nsvg,\\nvideo,\\ncanvas,\\naudio,\\niframe,\\nembed,\\nobject {\\n  display: block; /* 1 */\\n  vertical-align: middle; /* 2 */\\n}\\n\\n/*\\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\\n*/\\n\\nimg,\\nvideo {\\n  max-width: 100%;\\n  height: auto;\\n}\\n\\n*, ::before, ::after {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\n\\n::backdrop {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\r\\n.pointer-events-none {\\n  pointer-events: none;\\n}\\r\\n.fixed {\\n  position: fixed;\\n}\\r\\n.absolute {\\n  position: absolute;\\n}\\r\\n.relative {\\n  position: relative;\\n}\\r\\n.-top-3 {\\n  top: -0.75rem;\\n}\\r\\n.-top-5 {\\n  top: -1.25rem;\\n}\\r\\n.-top-16 {\\n  top: -4rem;\\n}\\r\\n.right-0 {\\n  right: 0px;\\n}\\r\\n.right-24 {\\n  right: 6rem;\\n}\\r\\n.left-1\\\\/2 {\\n  left: 50%;\\n}\\r\\n.right-1\\\\/2 {\\n  right: 50%;\\n}\\r\\n.bottom-36 {\\n  bottom: 9rem;\\n}\\r\\n.top-\\\\[85\\\\%\\\\] {\\n  top: 85%;\\n}\\r\\n.bottom-\\\\[17\\\\.2rem\\\\] {\\n  bottom: 17.2rem;\\n}\\r\\n.bottom-0 {\\n  bottom: 0px;\\n}\\r\\n.top-0 {\\n  top: 0px;\\n}\\r\\n.right-9 {\\n  right: 2.25rem;\\n}\\r\\n.left-0 {\\n  left: 0px;\\n}\\r\\n.z-10 {\\n  z-index: 10;\\n}\\r\\n.z-20 {\\n  z-index: 20;\\n}\\r\\n.col-span-2 {\\n  grid-column: span 2 / span 2;\\n}\\r\\n.col-span-3 {\\n  grid-column: span 3 / span 3;\\n}\\r\\n.col-span-12 {\\n  grid-column: span 12 / span 12;\\n}\\r\\n.col-span-10 {\\n  grid-column: span 10 / span 10;\\n}\\r\\n.col-span-4 {\\n  grid-column: span 4 / span 4;\\n}\\r\\n.col-span-6 {\\n  grid-column: span 6 / span 6;\\n}\\r\\n.col-span-7 {\\n  grid-column: span 7 / span 7;\\n}\\r\\n.row-span-3 {\\n  grid-row: span 3 / span 3;\\n}\\r\\n.my-2 {\\n  margin-top: 0.5rem;\\n  margin-bottom: 0.5rem;\\n}\\r\\n.mx-auto {\\n  margin-left: auto;\\n  margin-right: auto;\\n}\\r\\n.mx-3 {\\n  margin-left: 0.75rem;\\n  margin-right: 0.75rem;\\n}\\r\\n.mx-5 {\\n  margin-left: 1.25rem;\\n  margin-right: 1.25rem;\\n}\\r\\n.mx-1 {\\n  margin-left: 0.25rem;\\n  margin-right: 0.25rem;\\n}\\r\\n.my-1 {\\n  margin-top: 0.25rem;\\n  margin-bottom: 0.25rem;\\n}\\r\\n.mx-2 {\\n  margin-left: 0.5rem;\\n  margin-right: 0.5rem;\\n}\\r\\n.my-7 {\\n  margin-top: 1.75rem;\\n  margin-bottom: 1.75rem;\\n}\\r\\n.mx-\\\\[0\\\\.35rem\\\\] {\\n  margin-left: 0.35rem;\\n  margin-right: 0.35rem;\\n}\\r\\n.mx-10 {\\n  margin-left: 2.5rem;\\n  margin-right: 2.5rem;\\n}\\r\\n.mx-8 {\\n  margin-left: 2rem;\\n  margin-right: 2rem;\\n}\\r\\n.my-3 {\\n  margin-top: 0.75rem;\\n  margin-bottom: 0.75rem;\\n}\\r\\n.my-12 {\\n  margin-top: 3rem;\\n  margin-bottom: 3rem;\\n}\\r\\n.mt-16 {\\n  margin-top: 4rem;\\n}\\r\\n.mt-12 {\\n  margin-top: 3rem;\\n}\\r\\n.mt-8 {\\n  margin-top: 2rem;\\n}\\r\\n.mt-2 {\\n  margin-top: 0.5rem;\\n}\\r\\n.mt-5 {\\n  margin-top: 1.25rem;\\n}\\r\\n.-mt-14 {\\n  margin-top: -3.5rem;\\n}\\r\\n.-mb-5 {\\n  margin-bottom: -1.25rem;\\n}\\r\\n.mb-5 {\\n  margin-bottom: 1.25rem;\\n}\\r\\n.mt-3 {\\n  margin-top: 0.75rem;\\n}\\r\\n.mt-10 {\\n  margin-top: 2.5rem;\\n}\\r\\n.mt-7 {\\n  margin-top: 1.75rem;\\n}\\r\\n.mb-10 {\\n  margin-bottom: 2.5rem;\\n}\\r\\n.mt-1 {\\n  margin-top: 0.25rem;\\n}\\r\\n.mt-4 {\\n  margin-top: 1rem;\\n}\\r\\n.mb-7 {\\n  margin-bottom: 1.75rem;\\n}\\r\\n.mb-2 {\\n  margin-bottom: 0.5rem;\\n}\\r\\n.mr-16 {\\n  margin-right: 4rem;\\n}\\r\\n.ml-5 {\\n  margin-left: 1.25rem;\\n}\\r\\n.ml-1 {\\n  margin-left: 0.25rem;\\n}\\r\\n.mt-\\\\[15px\\\\] {\\n  margin-top: 15px;\\n}\\r\\n.mt-\\\\[0\\\\.8px\\\\] {\\n  margin-top: 0.8px;\\n}\\r\\n.mt-6 {\\n  margin-top: 1.5rem;\\n}\\r\\n.mb-4 {\\n  margin-bottom: 1rem;\\n}\\r\\n.-mb-1 {\\n  margin-bottom: -0.25rem;\\n}\\r\\n.-ml-\\\\[100\\\\%\\\\] {\\n  margin-left: -100%;\\n}\\r\\n.-ml-\\\\[0\\\\%\\\\] {\\n  margin-left: -0%;\\n}\\r\\n.-ml-\\\\[200\\\\%\\\\] {\\n  margin-left: -200%;\\n}\\r\\n.-ml-\\\\[300\\\\%\\\\] {\\n  margin-left: -300%;\\n}\\r\\n.-ml-\\\\[50vw\\\\] {\\n  margin-left: -50vw;\\n}\\r\\n.-mr-\\\\[50vw\\\\] {\\n  margin-right: -50vw;\\n}\\r\\n.mr-\\\\[0\\\\.35rem\\\\] {\\n  margin-right: 0.35rem;\\n}\\r\\n.ml-3 {\\n  margin-left: 0.75rem;\\n}\\r\\n.mr-3 {\\n  margin-right: 0.75rem;\\n}\\r\\n.mr-5 {\\n  margin-right: 1.25rem;\\n}\\r\\n.mb-1 {\\n  margin-bottom: 0.25rem;\\n}\\r\\n.mb-8 {\\n  margin-bottom: 2rem;\\n}\\r\\n.block {\\n  display: block;\\n}\\r\\n.inline-block {\\n  display: inline-block;\\n}\\r\\n.flex {\\n  display: flex;\\n}\\r\\n.inline-flex {\\n  display: inline-flex;\\n}\\r\\n.table {\\n  display: table;\\n}\\r\\n.grid {\\n  display: grid;\\n}\\r\\n.hidden {\\n  display: none;\\n}\\r\\n.aspect-square {\\n  aspect-ratio: 1 / 1;\\n}\\r\\n.h-5 {\\n  height: 1.25rem;\\n}\\r\\n.h-24 {\\n  height: 6rem;\\n}\\r\\n.h-72 {\\n  height: 18rem;\\n}\\r\\n.h-fit {\\n  height: -moz-fit-content;\\n  height: fit-content;\\n}\\r\\n.h-\\\\[330px\\\\] {\\n  height: 330px;\\n}\\r\\n.h-12 {\\n  height: 3rem;\\n}\\r\\n.h-max {\\n  height: -moz-max-content;\\n  height: max-content;\\n}\\r\\n.h-\\\\[467px\\\\] {\\n  height: 467px;\\n}\\r\\n.h-6 {\\n  height: 1.5rem;\\n}\\r\\n.h-full {\\n  height: 100%;\\n}\\r\\n.h-\\\\[30px\\\\] {\\n  height: 30px;\\n}\\r\\n.h-56 {\\n  height: 14rem;\\n}\\r\\n.h-\\\\[45vh\\\\] {\\n  height: 45vh;\\n}\\r\\n.h-\\\\[250px\\\\] {\\n  height: 250px;\\n}\\r\\n.h-4 {\\n  height: 1rem;\\n}\\r\\n.h-\\\\[166px\\\\] {\\n  height: 166px;\\n}\\r\\n.h-\\\\[199\\\\.69px\\\\] {\\n  height: 199.69px;\\n}\\r\\n.h-\\\\[190\\\\] {\\n  height: 190;\\n}\\r\\n.h-\\\\[60px\\\\] {\\n  height: 60px;\\n}\\r\\n.h-48 {\\n  height: 12rem;\\n}\\r\\n.max-h-fit {\\n  max-height: -moz-fit-content;\\n  max-height: fit-content;\\n}\\r\\n.max-h-\\\\[250px\\\\] {\\n  max-height: 250px;\\n}\\r\\n.max-h-\\\\[24px\\\\] {\\n  max-height: 24px;\\n}\\r\\n.min-h-screen {\\n  min-height: 100vh;\\n}\\r\\n.min-h-\\\\[100vh\\\\] {\\n  min-height: 100vh;\\n}\\r\\n.min-h-\\\\[330px\\\\] {\\n  min-height: 330px;\\n}\\r\\n.min-h-\\\\[213px\\\\] {\\n  min-height: 213px;\\n}\\r\\n.w-full {\\n  width: 100%;\\n}\\r\\n.w-5 {\\n  width: 1.25rem;\\n}\\r\\n.w-3\\\\/4 {\\n  width: 75%;\\n}\\r\\n.w-24 {\\n  width: 6rem;\\n}\\r\\n.w-8 {\\n  width: 2rem;\\n}\\r\\n.w-\\\\[90vw\\\\] {\\n  width: 90vw;\\n}\\r\\n.w-12 {\\n  width: 3rem;\\n}\\r\\n.w-\\\\[48\\\\%\\\\] {\\n  width: 48%;\\n}\\r\\n.w-fit {\\n  width: -moz-fit-content;\\n  width: fit-content;\\n}\\r\\n.w-2\\\\/3 {\\n  width: 66.666667%;\\n}\\r\\n.w-80 {\\n  width: 20rem;\\n}\\r\\n.w-\\\\[100vw\\\\] {\\n  width: 100vw;\\n}\\r\\n.w-6 {\\n  width: 1.5rem;\\n}\\r\\n.w-\\\\[30px\\\\] {\\n  width: 30px;\\n}\\r\\n.w-\\\\[300\\\\%\\\\] {\\n  width: 300%;\\n}\\r\\n.w-\\\\[100\\\\%\\\\] {\\n  width: 100%;\\n}\\r\\n.w-4 {\\n  width: 1rem;\\n}\\r\\n.w-\\\\[108px\\\\] {\\n  width: 108px;\\n}\\r\\n.w-\\\\[142px\\\\] {\\n  width: 142px;\\n}\\r\\n.w-\\\\[4\\\\.2rem\\\\] {\\n  width: 4.2rem;\\n}\\r\\n.w-20 {\\n  width: 5rem;\\n}\\r\\n.w-\\\\[144px\\\\] {\\n  width: 144px;\\n}\\r\\n.w-2\\\\/4 {\\n  width: 50%;\\n}\\r\\n.min-w-\\\\[300px\\\\] {\\n  min-width: 300px;\\n}\\r\\n.min-w-\\\\[50px\\\\] {\\n  min-width: 50px;\\n}\\r\\n.min-w-\\\\[78px\\\\] {\\n  min-width: 78px;\\n}\\r\\n.min-w-\\\\[108px\\\\] {\\n  min-width: 108px;\\n}\\r\\n.min-w-\\\\[26px\\\\] {\\n  min-width: 26px;\\n}\\r\\n.max-w-\\\\[1200px\\\\] {\\n  max-width: 1200px;\\n}\\r\\n.max-w-\\\\[1500px\\\\] {\\n  max-width: 1500px;\\n}\\r\\n.max-w-\\\\[1300px\\\\] {\\n  max-width: 1300px;\\n}\\r\\n.max-w-\\\\[1100px\\\\] {\\n  max-width: 1100px;\\n}\\r\\n.max-w-\\\\[581px\\\\] {\\n  max-width: 581px;\\n}\\r\\n.-translate-x-1\\\\/2 {\\n  --tw-translate-x: -50%;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\r\\n.cursor-pointer {\\n  cursor: pointer;\\n}\\r\\n.select-none {\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n          user-select: none;\\n}\\r\\n.appearance-none {\\n  -webkit-appearance: none;\\n     -moz-appearance: none;\\n          appearance: none;\\n}\\r\\n.grid-cols-2 {\\n  grid-template-columns: repeat(2, minmax(0, 1fr));\\n}\\r\\n.grid-cols-1 {\\n  grid-template-columns: repeat(1, minmax(0, 1fr));\\n}\\r\\n.grid-cols-4 {\\n  grid-template-columns: repeat(4, minmax(0, 1fr));\\n}\\r\\n.grid-cols-12 {\\n  grid-template-columns: repeat(12, minmax(0, 1fr));\\n}\\r\\n.grid-cols-10 {\\n  grid-template-columns: repeat(10, minmax(0, 1fr));\\n}\\r\\n.flex-col {\\n  flex-direction: column;\\n}\\r\\n.flex-wrap {\\n  flex-wrap: wrap;\\n}\\r\\n.place-content-between {\\n  place-content: space-between;\\n}\\r\\n.items-end {\\n  align-items: flex-end;\\n}\\r\\n.items-center {\\n  align-items: center;\\n}\\r\\n.justify-end {\\n  justify-content: flex-end;\\n}\\r\\n.justify-center {\\n  justify-content: center;\\n}\\r\\n.justify-between {\\n  justify-content: space-between;\\n}\\r\\n.gap-3 {\\n  gap: 0.75rem;\\n}\\r\\n.gap-10 {\\n  gap: 2.5rem;\\n}\\r\\n.gap-4 {\\n  gap: 1rem;\\n}\\r\\n.space-y-4 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-y-reverse: 0;\\n  margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));\\n  margin-bottom: calc(1rem * var(--tw-space-y-reverse));\\n}\\r\\n.space-x-3 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(0.75rem * var(--tw-space-x-reverse));\\n  margin-left: calc(0.75rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\r\\n.space-x-2 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(0.5rem * var(--tw-space-x-reverse));\\n  margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\r\\n.space-x-5 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(1.25rem * var(--tw-space-x-reverse));\\n  margin-left: calc(1.25rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\r\\n.space-x-8 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(2rem * var(--tw-space-x-reverse));\\n  margin-left: calc(2rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\r\\n.divide-solid > :not([hidden]) ~ :not([hidden]) {\\n  border-style: solid;\\n}\\r\\n.overflow-hidden {\\n  overflow: hidden;\\n}\\r\\n.overflow-x-auto {\\n  overflow-x: auto;\\n}\\r\\n.whitespace-nowrap {\\n  white-space: nowrap;\\n}\\r\\n.whitespace-pre-wrap {\\n  white-space: pre-wrap;\\n}\\r\\n.rounded-md {\\n  border-radius: 0.375rem;\\n}\\r\\n.rounded-3xl {\\n  border-radius: 1.5rem;\\n}\\r\\n.rounded-xl {\\n  border-radius: 0.75rem;\\n}\\r\\n.rounded-full {\\n  border-radius: 9999px;\\n}\\r\\n.rounded-lg {\\n  border-radius: 0.5rem;\\n}\\r\\n.rounded {\\n  border-radius: 0.25rem;\\n}\\r\\n.rounded-l-md {\\n  border-top-left-radius: 0.375rem;\\n  border-bottom-left-radius: 0.375rem;\\n}\\r\\n.rounded-l-none {\\n  border-top-left-radius: 0px;\\n  border-bottom-left-radius: 0px;\\n}\\r\\n.border {\\n  border-width: 1px;\\n}\\r\\n.border-\\\\[0\\\\.5px\\\\] {\\n  border-width: 0.5px;\\n}\\r\\n.border-2 {\\n  border-width: 2px;\\n}\\r\\n.border-\\\\[1px\\\\] {\\n  border-width: 1px;\\n}\\r\\n.border-4 {\\n  border-width: 4px;\\n}\\r\\n.border-b {\\n  border-bottom-width: 1px;\\n}\\r\\n.border-b-2 {\\n  border-bottom-width: 2px;\\n}\\r\\n.border-t {\\n  border-top-width: 1px;\\n}\\r\\n.border-b-\\\\[1px\\\\] {\\n  border-bottom-width: 1px;\\n}\\r\\n.border-t-2 {\\n  border-top-width: 2px;\\n}\\r\\n.border-t-\\\\[1px\\\\] {\\n  border-top-width: 1px;\\n}\\r\\n.border-r-0 {\\n  border-right-width: 0px;\\n}\\r\\n.border-solid {\\n  border-style: solid;\\n}\\r\\n.border-dashed {\\n  border-style: dashed;\\n}\\r\\n.border-blue-400 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(96 165 250 / var(--tw-border-opacity));\\n}\\r\\n.border-transparent {\\n  border-color: transparent;\\n}\\r\\n.border-gray-300 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(209 213 219 / var(--tw-border-opacity));\\n}\\r\\n.border-\\\\[\\\\#BBBBBB\\\\] {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(187 187 187 / var(--tw-border-opacity));\\n}\\r\\n.border-\\\\[\\\\#e2e2e2\\\\] {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(226 226 226 / var(--tw-border-opacity));\\n}\\r\\n.border-blue-800 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(30 64 175 / var(--tw-border-opacity));\\n}\\r\\n.bg-white {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\\n}\\r\\n.bg-slate-400 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(148 163 184 / var(--tw-bg-opacity));\\n}\\r\\n.bg-blue-500 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(59 130 246 / var(--tw-bg-opacity));\\n}\\r\\n.bg-zinc-300 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(212 212 216 / var(--tw-bg-opacity));\\n}\\r\\n.bg-zinc-400 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(161 161 170 / var(--tw-bg-opacity));\\n}\\r\\n.bg-yellow-500 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(234 179 8 / var(--tw-bg-opacity));\\n}\\r\\n.bg-indigo-500 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(99 102 241 / var(--tw-bg-opacity));\\n}\\r\\n.bg-teal-500 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(20 184 166 / var(--tw-bg-opacity));\\n}\\r\\n.bg-blue-200 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(191 219 254 / var(--tw-bg-opacity));\\n}\\r\\n.bg-\\\\[\\\\#3D414D\\\\] {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(61 65 77 / var(--tw-bg-opacity));\\n}\\r\\n.bg-gray-200 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(229 231 235 / var(--tw-bg-opacity));\\n}\\r\\n.bg-black {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(0 0 0 / var(--tw-bg-opacity));\\n}\\r\\n.bg-red-200 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(254 202 202 / var(--tw-bg-opacity));\\n}\\r\\n.bg-slate-300 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(203 213 225 / var(--tw-bg-opacity));\\n}\\r\\n.bg-slate-100 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(241 245 249 / var(--tw-bg-opacity));\\n}\\r\\n.bg-gray-50 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(249 250 251 / var(--tw-bg-opacity));\\n}\\r\\n.object-cover {\\n  -o-object-fit: cover;\\n     object-fit: cover;\\n}\\r\\n.p-6 {\\n  padding: 1.5rem;\\n}\\r\\n.p-3 {\\n  padding: 0.75rem;\\n}\\r\\n.p-2 {\\n  padding: 0.5rem;\\n}\\r\\n.p-\\\\[0\\\\.12rem\\\\] {\\n  padding: 0.12rem;\\n}\\r\\n.p-1 {\\n  padding: 0.25rem;\\n}\\r\\n.p-\\\\[0\\\\.2rem\\\\] {\\n  padding: 0.2rem;\\n}\\r\\n.p-0 {\\n  padding: 0px;\\n}\\r\\n.px-4 {\\n  padding-left: 1rem;\\n  padding-right: 1rem;\\n}\\r\\n.px-2 {\\n  padding-left: 0.5rem;\\n  padding-right: 0.5rem;\\n}\\r\\n.py-2 {\\n  padding-top: 0.5rem;\\n  padding-bottom: 0.5rem;\\n}\\r\\n.py-4 {\\n  padding-top: 1rem;\\n  padding-bottom: 1rem;\\n}\\r\\n.py-20 {\\n  padding-top: 5rem;\\n  padding-bottom: 5rem;\\n}\\r\\n.px-20 {\\n  padding-left: 5rem;\\n  padding-right: 5rem;\\n}\\r\\n.px-8 {\\n  padding-left: 2rem;\\n  padding-right: 2rem;\\n}\\r\\n.py-3 {\\n  padding-top: 0.75rem;\\n  padding-bottom: 0.75rem;\\n}\\r\\n.px-3 {\\n  padding-left: 0.75rem;\\n  padding-right: 0.75rem;\\n}\\r\\n.px-1 {\\n  padding-left: 0.25rem;\\n  padding-right: 0.25rem;\\n}\\r\\n.py-\\\\[5px\\\\] {\\n  padding-top: 5px;\\n  padding-bottom: 5px;\\n}\\r\\n.py-5 {\\n  padding-top: 1.25rem;\\n  padding-bottom: 1.25rem;\\n}\\r\\n.px-10 {\\n  padding-left: 2.5rem;\\n  padding-right: 2.5rem;\\n}\\r\\n.py-1 {\\n  padding-top: 0.25rem;\\n  padding-bottom: 0.25rem;\\n}\\r\\n.pb-4 {\\n  padding-bottom: 1rem;\\n}\\r\\n.pt-2 {\\n  padding-top: 0.5rem;\\n}\\r\\n.pb-14 {\\n  padding-bottom: 3.5rem;\\n}\\r\\n.pb-\\\\[60px\\\\] {\\n  padding-bottom: 60px;\\n}\\r\\n.pb-3 {\\n  padding-bottom: 0.75rem;\\n}\\r\\n.pt-1 {\\n  padding-top: 0.25rem;\\n}\\r\\n.pt-3 {\\n  padding-top: 0.75rem;\\n}\\r\\n.pb-1 {\\n  padding-bottom: 0.25rem;\\n}\\r\\n.pl-6 {\\n  padding-left: 1.5rem;\\n}\\r\\n.pb-2 {\\n  padding-bottom: 0.5rem;\\n}\\r\\n.pl-3 {\\n  padding-left: 0.75rem;\\n}\\r\\n.pl-7 {\\n  padding-left: 1.75rem;\\n}\\r\\n.pr-3 {\\n  padding-right: 0.75rem;\\n}\\r\\n.text-center {\\n  text-align: center;\\n}\\r\\n.font-sans {\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\";\\n}\\r\\n.text-3xl {\\n  font-size: 1.875rem;\\n  line-height: 2.25rem;\\n}\\r\\n.text-sm {\\n  font-size: 0.875rem;\\n  line-height: 1.25rem;\\n}\\r\\n.text-xl {\\n  font-size: 1.25rem;\\n  line-height: 1.75rem;\\n}\\r\\n.text-2xl {\\n  font-size: 1.5rem;\\n  line-height: 2rem;\\n}\\r\\n.text-xs {\\n  font-size: 0.75rem;\\n  line-height: 1rem;\\n}\\r\\n.text-lg {\\n  font-size: 1.125rem;\\n  line-height: 1.75rem;\\n}\\r\\n.text-base {\\n  font-size: 1rem;\\n  line-height: 1.5rem;\\n}\\r\\n.font-bold {\\n  font-weight: 700;\\n}\\r\\n.font-medium {\\n  font-weight: 500;\\n}\\r\\n.font-semibold {\\n  font-weight: 600;\\n}\\r\\n.uppercase {\\n  text-transform: uppercase;\\n}\\r\\n.leading-7 {\\n  line-height: 1.75rem;\\n}\\r\\n.leading-\\\\[1\\\\.8rem\\\\] {\\n  line-height: 1.8rem;\\n}\\r\\n.text-gray-500 {\\n  --tw-text-opacity: 1;\\n  color: rgb(107 114 128 / var(--tw-text-opacity));\\n}\\r\\n.text-blue-300 {\\n  --tw-text-opacity: 1;\\n  color: rgb(147 197 253 / var(--tw-text-opacity));\\n}\\r\\n.text-white {\\n  --tw-text-opacity: 1;\\n  color: rgb(255 255 255 / var(--tw-text-opacity));\\n}\\r\\n.text-gray-600 {\\n  --tw-text-opacity: 1;\\n  color: rgb(75 85 99 / var(--tw-text-opacity));\\n}\\r\\n.text-\\\\[\\\\#666676\\\\] {\\n  --tw-text-opacity: 1;\\n  color: rgb(102 102 118 / var(--tw-text-opacity));\\n}\\r\\n.text-red-400 {\\n  --tw-text-opacity: 1;\\n  color: rgb(248 113 113 / var(--tw-text-opacity));\\n}\\r\\n.text-gray-400 {\\n  --tw-text-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-text-opacity));\\n}\\r\\n.text-blue-500 {\\n  --tw-text-opacity: 1;\\n  color: rgb(59 130 246 / var(--tw-text-opacity));\\n}\\r\\n.text-blue-400 {\\n  --tw-text-opacity: 1;\\n  color: rgb(96 165 250 / var(--tw-text-opacity));\\n}\\r\\n.text-gray-700 {\\n  --tw-text-opacity: 1;\\n  color: rgb(55 65 81 / var(--tw-text-opacity));\\n}\\r\\n.text-black {\\n  --tw-text-opacity: 1;\\n  color: rgb(0 0 0 / var(--tw-text-opacity));\\n}\\r\\n.placeholder-gray-400::-moz-placeholder {\\n  --tw-placeholder-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-placeholder-opacity));\\n}\\r\\n.placeholder-gray-400::placeholder {\\n  --tw-placeholder-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-placeholder-opacity));\\n}\\r\\n.opacity-60 {\\n  opacity: 0.6;\\n}\\r\\n.shadow-sm {\\n  --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);\\n  --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\r\\n.shadow-xl {\\n  --tw-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);\\n  --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\r\\n.ring-2 {\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\n}\\r\\n.ring-yellow-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(234 179 8 / var(--tw-ring-opacity));\\n}\\r\\n.ring-indigo-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(99 102 241 / var(--tw-ring-opacity));\\n}\\r\\n.ring-teal-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(20 184 166 / var(--tw-ring-opacity));\\n}\\r\\n.ring-gray-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(107 114 128 / var(--tw-ring-opacity));\\n}\\r\\n.ring-black {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(0 0 0 / var(--tw-ring-opacity));\\n}\\r\\n.ring-red-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(239 68 68 / var(--tw-ring-opacity));\\n}\\r\\n.ring-blue-500 {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(59 130 246 / var(--tw-ring-opacity));\\n}\\r\\n.ring-offset-2 {\\n  --tw-ring-offset-width: 2px;\\n}\\r\\n.ring-offset-1 {\\n  --tw-ring-offset-width: 1px;\\n}\\r\\n.filter {\\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n}\\r\\n.transition {\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\r\\n.transition-all {\\n  transition-property: all;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\r\\n.duration-\\\\[0ms\\\\] {\\n  transition-duration: 0ms;\\n}\\r\\n.duration-1000 {\\n  transition-duration: 1000ms;\\n}\\r\\n.last\\\\:border-b-0:last-child {\\n  border-bottom-width: 0px;\\n}\\r\\n.odd\\\\:bg-blue-50:nth-child(odd) {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(239 246 255 / var(--tw-bg-opacity));\\n}\\r\\n.hover\\\\:cursor-pointer:hover {\\n  cursor: pointer;\\n}\\r\\n.hover\\\\:border-blue-500:hover {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(59 130 246 / var(--tw-border-opacity));\\n}\\r\\n.hover\\\\:border-gray-400:hover {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(156 163 175 / var(--tw-border-opacity));\\n}\\r\\n.hover\\\\:border-gray-300:hover {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(209 213 219 / var(--tw-border-opacity));\\n}\\r\\n.hover\\\\:bg-gray-50:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(249 250 251 / var(--tw-bg-opacity));\\n}\\r\\n.hover\\\\:bg-teal-500:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(20 184 166 / var(--tw-bg-opacity));\\n}\\r\\n.hover\\\\:bg-gray-200:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(229 231 235 / var(--tw-bg-opacity));\\n}\\r\\n.hover\\\\:bg-gray-100:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(243 244 246 / var(--tw-bg-opacity));\\n}\\r\\n.hover\\\\:bg-white:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\\n}\\r\\n.hover\\\\:text-gray-400:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-text-opacity));\\n}\\r\\n.hover\\\\:text-black:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(0 0 0 / var(--tw-text-opacity));\\n}\\r\\n.hover\\\\:text-blue-500:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(59 130 246 / var(--tw-text-opacity));\\n}\\r\\n.hover\\\\:text-red-500:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(239 68 68 / var(--tw-text-opacity));\\n}\\r\\n.hover\\\\:text-gray-500:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(107 114 128 / var(--tw-text-opacity));\\n}\\r\\n.hover\\\\:text-blue-400:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(96 165 250 / var(--tw-text-opacity));\\n}\\r\\n.hover\\\\:underline:hover {\\n  text-decoration-line: underline;\\n}\\r\\n.focus\\\\:border-blue-400:focus {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(96 165 250 / var(--tw-border-opacity));\\n}\\r\\n.focus\\\\:border-orange-500:focus {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(249 115 22 / var(--tw-border-opacity));\\n}\\r\\n.focus\\\\:bg-red-500:focus {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(239 68 68 / var(--tw-bg-opacity));\\n}\\r\\n.focus\\\\:outline-none:focus {\\n  outline: 2px solid transparent;\\n  outline-offset: 2px;\\n}\\r\\n.focus\\\\:ring-2:focus {\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\n}\\r\\n.focus\\\\:ring-blue-500:focus {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(59 130 246 / var(--tw-ring-opacity));\\n}\\r\\n.focus\\\\:ring-blue-400:focus {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(96 165 250 / var(--tw-ring-opacity));\\n}\\r\\n.focus\\\\:ring-orange-500:focus {\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(249 115 22 / var(--tw-ring-opacity));\\n}\\r\\n.focus\\\\:ring-offset-2:focus {\\n  --tw-ring-offset-width: 2px;\\n}\\r\\n.active\\\\:bg-yellow-500:active {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(234 179 8 / var(--tw-bg-opacity));\\n}\\r\\n.peer:checked ~ .peer-checked\\\\:bg-blue-600 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(37 99 235 / var(--tw-bg-opacity));\\n}\\r\\n.peer:checked ~ .peer-checked\\\\:text-white {\\n  --tw-text-opacity: 1;\\n  color: rgb(255 255 255 / var(--tw-text-opacity));\\n}\\r\\n@media (min-width: 640px) {\\n\\n  .sm\\\\:col-span-10 {\\n    grid-column: span 10 / span 10;\\n  }\\n\\n  .sm\\\\:mt-7 {\\n    margin-top: 1.75rem;\\n  }\\n\\n  .sm\\\\:grid {\\n    display: grid;\\n  }\\n\\n  .sm\\\\:max-w-\\\\[380px\\\\] {\\n    max-width: 380px;\\n  }\\n\\n  .sm\\\\:grid-cols-5 {\\n    grid-template-columns: repeat(5, minmax(0, 1fr));\\n  }\\n\\n  .sm\\\\:grid-cols-1 {\\n    grid-template-columns: repeat(1, minmax(0, 1fr));\\n  }\\n\\n  .sm\\\\:grid-cols-3 {\\n    grid-template-columns: repeat(3, minmax(0, 1fr));\\n  }\\n\\n  .sm\\\\:grid-cols-10 {\\n    grid-template-columns: repeat(10, minmax(0, 1fr));\\n  }\\n\\n  .sm\\\\:pl-5 {\\n    padding-left: 1.25rem;\\n  }\\n}\\r\\n@media (min-width: 768px) {\\n\\n  .md\\\\:grid-cols-5 {\\n    grid-template-columns: repeat(5, minmax(0, 1fr));\\n  }\\n\\n  .md\\\\:grid-cols-4 {\\n    grid-template-columns: repeat(4, minmax(0, 1fr));\\n  }\\n\\n  .md\\\\:grid-cols-3 {\\n    grid-template-columns: repeat(3, minmax(0, 1fr));\\n  }\\n\\n  .md\\\\:grid-cols-2 {\\n    grid-template-columns: repeat(2, minmax(0, 1fr));\\n  }\\n}\\r\\n@media (min-width: 1024px) {\\n\\n  .lg\\\\:col-span-1 {\\n    grid-column: span 1 / span 1;\\n  }\\n\\n  .lg\\\\:col-span-10 {\\n    grid-column: span 10 / span 10;\\n  }\\n\\n  .lg\\\\:col-span-5 {\\n    grid-column: span 5 / span 5;\\n  }\\n\\n  .lg\\\\:grid-cols-8 {\\n    grid-template-columns: repeat(8, minmax(0, 1fr));\\n  }\\n\\n  .lg\\\\:grid-cols-6 {\\n    grid-template-columns: repeat(6, minmax(0, 1fr));\\n  }\\n\\n  .lg\\\\:grid-cols-4 {\\n    grid-template-columns: repeat(4, minmax(0, 1fr));\\n  }\\n\\n  .lg\\\\:grid-rows-5 {\\n    grid-template-rows: repeat(5, minmax(0, 1fr));\\n  }\\n\\n  .lg\\\\:px-5 {\\n    padding-left: 1.25rem;\\n    padding-right: 1.25rem;\\n  }\\n\\n  .lg\\\\:px-0 {\\n    padding-left: 0px;\\n    padding-right: 0px;\\n  }\\n}\\r\\n@media (min-width: 1280px) {\\n\\n  .xl\\\\:grid-cols-5 {\\n    grid-template-columns: repeat(5, minmax(0, 1fr));\\n  }\\n\\n  .xl\\\\:grid-cols-3 {\\n    grid-template-columns: repeat(3, minmax(0, 1fr));\\n  }\\n}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://styles/globals.css\",\"<no source>\"],\"names\":[],\"mappings\":\"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mBAAmB;EAAnB;AAAmB;AAAnB;EAAA,mBAAmB;EAAnB;AAAmB;AAAnB;EAAA,mBAAmB;EAAnB;AAAmB;AAAnB;EAAA,oBAAmB;EAAnB;AAAmB;AAAnB;EAAA,mBAAmB;EAAnB;AAAmB;AAAnB;EAAA,iBAAmB;EAAnB;AAAmB;AAAnB;EAAA,mBAAmB;EAAnB;AAAmB;AAAnB;EAAA,gBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,wBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,wBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA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CAA;EDAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA;CCAA;ADAA;EAAA,uBCAA;EDAA;CCAA;ADAA;EAAA,uBCAA;EDAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,+BCAA;EDAA;CCAA;ADAA;EAAA,4GCAA;EDAA,0GCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;EAAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,mBCAA;EDAA;CCAA;ADAA;EAAA,qBCAA;EDAA;CCAA;ADAA;;EAAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;CAAA;ADAA;;EAAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;CAAA;ADAA;;EAAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA;GCAA;;EDAA;IAAA,sBCAA;IDAA;GCAA;;EDAA;IAAA,kBCAA;IDAA;GCAA;CAAA;ADAA;;EAAA;IAAA;GCAA;;EDAA;IAAA;GCAA;CAAA\",\"sourcesContent\":[\"@tailwind base;\\r\\n@tailwind components;\\r\\n@tailwind utilities;\\r\\n\",null],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls4XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOF0udXNlWzJdIS4vc3R5bGVzL2dsb2JhbHMuY3NzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ3dIO0FBQ3hILDhCQUE4QixrSEFBMkI7QUFDekQ7QUFDQSwwWEFBMFgsNEJBQTRCLDRCQUE0QixnQ0FBZ0Msa0NBQWtDLFVBQVUsd0JBQXdCLHFCQUFxQixHQUFHLHFQQUFxUCxzQkFBc0IsMkNBQTJDLDZCQUE2QiwwQkFBMEIsb0JBQW9CLHVQQUF1UCxVQUFVLGdLQUFnSyxlQUFlLGlDQUFpQyxVQUFVLDJOQUEyTixlQUFlLDJCQUEyQixrQ0FBa0MsVUFBVSxpR0FBaUcsOENBQThDLDhDQUE4QyxHQUFHLGtHQUFrRyx1QkFBdUIseUJBQXlCLEdBQUcsaUZBQWlGLG1CQUFtQiw2QkFBNkIsR0FBRywyRUFBMkUsd0JBQXdCLEdBQUcsMEpBQTBKLHlIQUF5SCwyQkFBMkIsVUFBVSxpRUFBaUUsbUJBQW1CLEdBQUcsMkdBQTJHLG1CQUFtQixtQkFBbUIsdUJBQXVCLDZCQUE2QixHQUFHLFNBQVMsb0JBQW9CLEdBQUcsU0FBUyxnQkFBZ0IsR0FBRyxnYkFBZ2Isb0JBQW9CLGtDQUFrQyxzQ0FBc0MsVUFBVSxrTUFBa00sMEJBQTBCLDRCQUE0QixpQ0FBaUMsaUNBQWlDLDJCQUEyQixzQkFBc0IsdUJBQXVCLFVBQVUsOEZBQThGLHlCQUF5QixHQUFHLG1MQUFtTCxnQ0FBZ0MsMENBQTBDLG1DQUFtQyxVQUFVLCtGQUErRixrQkFBa0IsR0FBRywrTUFBK00scUJBQXFCLEdBQUcsbUZBQW1GLDZC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b0JBQW9CLG9CQUFvQixNQUFNLE1BQU0sTUFBTSxNQUFNLFdBQVcsTUFBTSxPQUFPLE1BQU0sUUFBUSxxQkFBcUIscUJBQXFCLHFCQUFxQixNQUFNLE1BQU0sTUFBTSxLQUFLLFVBQVUsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE1BQU0sTUFBTSxNQUFNLFVBQVUsTUFBTSxPQUFPLE1BQU0sS0FBSyxxQkFBcUIscUJBQXFCLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE9BQU8sTUFBTSxLQUFLLHFCQUFxQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLGlCQUFpQixVQUFVLE1BQU0sS0FBSyxVQUFVLFVBQVUsTUFBTSxLQUFLLFVBQVUsTUFBTSxPQUFPLFdBQVcsVUFBVSxVQUFVLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE9BQU8sTUFBTSxLQUFLLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLE1BQU0sTUFBTSxLQUFLLEtBQUssVUFBVSxNQUFNLFFBQVEsTUFBTSxZQUFZLG9CQUFvQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLFVBQVUsTUFBTSxLQUFLLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsS0FBSyxNQUFNLEtBQUssV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxhQUFhLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxXQUFXLEtBQUssTUFBTSxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssS0FBSyx3Q0FBd0MseUJBQXlCLHdCQUF3Qiw0QkFBNEI7QUFDeGg1QztBQUNBLCtEQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9nbG9iYWxzLmNzcz80YmEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKlxcbiEgdGFpbHdpbmRjc3MgdjMuMS44IHwgTUlUIExpY2Vuc2UgfCBodHRwczovL3RhaWx3aW5kY3NzLmNvbVxcbiovLypcXG4xLiBQcmV2ZW50IHBhZGRpbmcgYW5kIGJvcmRlciBmcm9tIGFmZmVjdGluZyBlbGVtZW50IHdpZHRoLiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy80KVxcbjIuIEFsbG93IGFkZGluZyBhIGJvcmRlciB0byBhbiBlbGVtZW50IGJ5IGp1c3QgYWRkaW5nIGEgYm9yZGVyLXdpZHRoLiAoaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kY3NzL3RhaWx3aW5kY3NzL3B1bGwvMTE2KVxcbiovXFxuXFxuKixcXG46OmJlZm9yZSxcXG46OmFmdGVyIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIGJvcmRlci13aWR0aDogMDsgLyogMiAqL1xcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDsgLyogMiAqL1xcbiAgYm9yZGVyLWNvbG9yOiAjZTVlN2ViOyAvKiAyICovXFxufVxcblxcbjo6YmVmb3JlLFxcbjo6YWZ0ZXIge1xcbiAgLS10dy1jb250ZW50OiAnJztcXG59XFxuXFxuLypcXG4xLiBVc2UgYSBjb25zaXN0ZW50IHNlbnNpYmxlIGxpbmUtaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cXG4yLiBQcmV2ZW50IGFkanVzdG1lbnRzIG9mIGZvbnQgc2l6ZSBhZnRlciBvcmllbnRhdGlvbiBjaGFuZ2VzIGluIGlPUy5cXG4zLiBVc2UgYSBtb3JlIHJlYWRhYmxlIHRhYiBzaXplLlxcbjQuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYHNhbnNgIGZvbnQtZmFtaWx5IGJ5IGRlZmF1bHQuXFxuKi9cXG5cXG5odG1sIHtcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7IC8qIDEgKi9cXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTsgLyogMiAqL1xcbiAgLW1vei10YWItc2l6ZTogNDsgLyogMyAqL1xcbiAgLW8tdGFiLXNpemU6IDQ7XFxuICAgICB0YWItc2l6ZTogNDsgLyogMyAqL1xcbiAgZm9udC1mYW1pbHk6IHVpLXNhbnMtc2VyaWYsIHN5c3RlbS11aSwgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcXFwiU2Vnb2UgVUlcXFwiLCBSb2JvdG8sIFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsIEFyaWFsLCBcXFwiTm90byBTYW5zXFxcIiwgc2Fucy1zZXJpZiwgXFxcIkFwcGxlIENvbG9yIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIFN5bWJvbFxcXCIsIFxcXCJOb3RvIENvbG9yIEVtb2ppXFxcIjsgLyogNCAqL1xcbn1cXG5cXG4vKlxcbjEuIFJlbW92ZSB0aGUgbWFyZ2luIGluIGFsbCBicm93c2Vycy5cXG4yLiBJbmhlcml0IGxpbmUtaGVpZ2h0IGZyb20gYGh0bWxgIHNvIHVzZXJzIGNhbiBzZXQgdGhlbSBhcyBhIGNsYXNzIGRpcmVjdGx5IG9uIHRoZSBgaHRtbGAgZWxlbWVudC5cXG4qL1xcblxcbmJvZHkge1xcbiAgbWFyZ2luOiAwOyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cXG4vKlxcbjEuIEFkZCB0aGUgY29ycmVjdCBoZWlnaHQgaW4gRmlyZWZveC5cXG4yLiBDb3JyZWN0IHRoZSBpbmhlcml0YW5jZSBvZiBib3JkZXIgY29sb3IgaW4gRmlyZWZveC4gKGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE5MDY1NSlcXG4zLiBFbnN1cmUgaG9yaXpvbnRhbCBydWxlcyBhcmUgdmlzaWJsZSBieSBkZWZhdWx0LlxcbiovXFxuXFxuaHIge1xcbiAgaGVpZ2h0OiAwOyAvKiAxICovXFxuICBjb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcbiAgYm9yZGVyLXRvcC13aWR0aDogMXB4OyAvKiAzICovXFxufVxcblxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IHRleHQgZGVjb3JhdGlvbiBpbiBDaHJvbWUsIEVkZ2UsIGFuZCBTYWZhcmkuXFxuKi9cXG5cXG5hYmJyOndoZXJlKFt0aXRsZV0pIHtcXG4gIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBkZWZhdWx0IGZvbnQgc2l6ZSBhbmQgd2VpZ2h0IGZvciBoZWFkaW5ncy5cXG4qL1xcblxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0LFxcbmg1LFxcbmg2IHtcXG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gIGZvbnQtd2VpZ2h0OiBpbmhlcml0O1xcbn1cXG5cXG4vKlxcblJlc2V0IGxpbmtzIHRvIG9wdGltaXplIGZvciBvcHQtaW4gc3R5bGluZyBpbnN0ZWFkIG9mIG9wdC1vdXQuXFxuKi9cXG5cXG5hIHtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBpbmhlcml0O1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBFZGdlIGFuZCBTYWZhcmkuXFxuKi9cXG5cXG5iLFxcbnN0cm9uZyB7XFxuICBmb250LXdlaWdodDogYm9sZGVyO1xcbn1cXG5cXG4vKlxcbjEuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYG1vbm9gIGZvbnQgZmFtaWx5IGJ5IGRlZmF1bHQuXFxuMi4gQ29ycmVjdCB0aGUgb2RkIGBlbWAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuY29kZSxcXG5rYmQsXFxuc2FtcCxcXG5wcmUge1xcbiAgZm9udC1mYW1pbHk6IHVpLW1vbm9zcGFjZSwgU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBcXFwiTGliZXJhdGlvbiBNb25vXFxcIiwgXFxcIkNvdXJpZXIgTmV3XFxcIiwgbW9ub3NwYWNlOyAvKiAxICovXFxuICBmb250LXNpemU6IDFlbTsgLyogMiAqL1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuc21hbGwge1xcbiAgZm9udC1zaXplOiA4MCU7XFxufVxcblxcbi8qXFxuUHJldmVudCBgc3ViYCBhbmQgYHN1cGAgZWxlbWVudHMgZnJvbSBhZmZlY3RpbmcgdGhlIGxpbmUgaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cXG4qL1xcblxcbnN1YixcXG5zdXAge1xcbiAgZm9udC1zaXplOiA3NSU7XFxuICBsaW5lLWhlaWdodDogMDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuXFxuc3ViIHtcXG4gIGJvdHRvbTogLTAuMjVlbTtcXG59XFxuXFxuc3VwIHtcXG4gIHRvcDogLTAuNWVtO1xcbn1cXG5cXG4vKlxcbjEuIFJlbW92ZSB0ZXh0IGluZGVudGF0aW9uIGZyb20gdGFibGUgY29udGVudHMgaW4gQ2hyb21lIGFuZCBTYWZhcmkuIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05OTkwODgsIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDEyOTcpXFxuMi4gQ29ycmVjdCB0YWJsZSBib3JkZXIgY29sb3IgaW5oZXJpdGFuY2UgaW4gYWxsIENocm9tZSBhbmQgU2FmYXJpLiAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTM1NzI5LCBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTk1MDE2KVxcbjMuIFJlbW92ZSBnYXBzIGJldHdlZW4gdGFibGUgYm9yZGVycyBieSBkZWZhdWx0LlxcbiovXFxuXFxudGFibGUge1xcbiAgdGV4dC1pbmRlbnQ6IDA7IC8qIDEgKi9cXG4gIGJvcmRlci1jb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTsgLyogMyAqL1xcbn1cXG5cXG4vKlxcbjEuIENoYW5nZSB0aGUgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzLlxcbjIuIFJlbW92ZSB0aGUgbWFyZ2luIGluIEZpcmVmb3ggYW5kIFNhZmFyaS5cXG4zLiBSZW1vdmUgZGVmYXVsdCBwYWRkaW5nIGluIGFsbCBicm93c2Vycy5cXG4qL1xcblxcbmJ1dHRvbixcXG5pbnB1dCxcXG5vcHRncm91cCxcXG5zZWxlY3QsXFxudGV4dGFyZWEge1xcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMTAwJTsgLyogMSAqL1xcbiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyAvKiAxICovXFxuICBjb2xvcjogaW5oZXJpdDsgLyogMSAqL1xcbiAgbWFyZ2luOiAwOyAvKiAyICovXFxuICBwYWRkaW5nOiAwOyAvKiAzICovXFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBFZGdlIGFuZCBGaXJlZm94LlxcbiovXFxuXFxuYnV0dG9uLFxcbnNlbGVjdCB7XFxuICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG59XFxuXFxuLypcXG4xLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxcbjIuIFJlbW92ZSBkZWZhdWx0IGJ1dHRvbiBzdHlsZXMuXFxuKi9cXG5cXG5idXR0b24sXFxuW3R5cGU9J2J1dHRvbiddLFxcblt0eXBlPSdyZXNldCddLFxcblt0eXBlPSdzdWJtaXQnXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IC8qIDIgKi9cXG4gIGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5Vc2UgdGhlIG1vZGVybiBGaXJlZm94IGZvY3VzIHN0eWxlIGZvciBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzLlxcbiovXFxuXFxuOi1tb3otZm9jdXNyaW5nIHtcXG4gIG91dGxpbmU6IGF1dG87XFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBhZGRpdGlvbmFsIGA6aW52YWxpZGAgc3R5bGVzIGluIEZpcmVmb3guIChodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrby1kZXYvYmxvYi8yZjllYWNkOWQzZDk5NWM5MzdiNDI1MWE1NTU3ZDk1ZDQ5NGM5YmUxL2xheW91dC9zdHlsZS9yZXMvZm9ybXMuY3NzI0w3MjgtTDczNylcXG4qL1xcblxcbjotbW96LXVpLWludmFsaWQge1xcbiAgYm94LXNoYWRvdzogbm9uZTtcXG59XFxuXFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgdmVydGljYWwgYWxpZ25tZW50IGluIENocm9tZSBhbmQgRmlyZWZveC5cXG4qL1xcblxcbnByb2dyZXNzIHtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuXFxuLypcXG5Db3JyZWN0IHRoZSBjdXJzb3Igc3R5bGUgb2YgaW5jcmVtZW50IGFuZCBkZWNyZW1lbnQgYnV0dG9ucyBpbiBTYWZhcmkuXFxuKi9cXG5cXG46Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuLypcXG4xLiBDb3JyZWN0IHRoZSBvZGQgYXBwZWFyYW5jZSBpbiBDaHJvbWUgYW5kIFNhZmFyaS5cXG4yLiBDb3JyZWN0IHRoZSBvdXRsaW5lIHN0eWxlIGluIFNhZmFyaS5cXG4qL1xcblxcblt0eXBlPSdzZWFyY2gnXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IHRleHRmaWVsZDsgLyogMSAqL1xcbiAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5SZW1vdmUgdGhlIGlubmVyIHBhZGRpbmcgaW4gQ2hyb21lIGFuZCBTYWZhcmkgb24gbWFjT1MuXFxuKi9cXG5cXG46Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbn1cXG5cXG4vKlxcbjEuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXFxuMi4gQ2hhbmdlIGZvbnQgcHJvcGVydGllcyB0byBgaW5oZXJpdGAgaW4gU2FmYXJpLlxcbiovXFxuXFxuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgZm9udDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIENocm9tZSBhbmQgU2FmYXJpLlxcbiovXFxuXFxuc3VtbWFyeSB7XFxuICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxufVxcblxcbi8qXFxuUmVtb3ZlcyB0aGUgZGVmYXVsdCBzcGFjaW5nIGFuZCBib3JkZXIgZm9yIGFwcHJvcHJpYXRlIGVsZW1lbnRzLlxcbiovXFxuXFxuYmxvY2txdW90ZSxcXG5kbCxcXG5kZCxcXG5oMSxcXG5oMixcXG5oMyxcXG5oNCxcXG5oNSxcXG5oNixcXG5ocixcXG5maWd1cmUsXFxucCxcXG5wcmUge1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG5maWVsZHNldCB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG5sZWdlbmQge1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxub2wsXFxudWwsXFxubWVudSB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuLypcXG5QcmV2ZW50IHJlc2l6aW5nIHRleHRhcmVhcyBob3Jpem9udGFsbHkgYnkgZGVmYXVsdC5cXG4qL1xcblxcbnRleHRhcmVhIHtcXG4gIHJlc2l6ZTogdmVydGljYWw7XFxufVxcblxcbi8qXFxuMS4gUmVzZXQgdGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgb3BhY2l0eSBpbiBGaXJlZm94LiAoaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9pc3N1ZXMvMzMwMClcXG4yLiBTZXQgdGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgY29sb3IgdG8gdGhlIHVzZXIncyBjb25maWd1cmVkIGdyYXkgNDAwIGNvbG9yLlxcbiovXFxuXFxuaW5wdXQ6Oi1tb3otcGxhY2Vob2xkZXIsIHRleHRhcmVhOjotbW96LXBsYWNlaG9sZGVyIHtcXG4gIG9wYWNpdHk6IDE7IC8qIDEgKi9cXG4gIGNvbG9yOiAjOWNhM2FmOyAvKiAyICovXFxufVxcblxcbmlucHV0OjpwbGFjZWhvbGRlcixcXG50ZXh0YXJlYTo6cGxhY2Vob2xkZXIge1xcbiAgb3BhY2l0eTogMTsgLyogMSAqL1xcbiAgY29sb3I6ICM5Y2EzYWY7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5TZXQgdGhlIGRlZmF1bHQgY3Vyc29yIGZvciBidXR0b25zLlxcbiovXFxuXFxuYnV0dG9uLFxcbltyb2xlPVxcXCJidXR0b25cXFwiXSB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi8qXFxuTWFrZSBzdXJlIGRpc2FibGVkIGJ1dHRvbnMgZG9uJ3QgZ2V0IHRoZSBwb2ludGVyIGN1cnNvci5cXG4qL1xcbjpkaXNhYmxlZCB7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcblxcbi8qXFxuMS4gTWFrZSByZXBsYWNlZCBlbGVtZW50cyBgZGlzcGxheTogYmxvY2tgIGJ5IGRlZmF1bHQuIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzE0KVxcbjIuIEFkZCBgdmVydGljYWwtYWxpZ246IG1pZGRsZWAgdG8gYWxpZ24gcmVwbGFjZWQgZWxlbWVudHMgbW9yZSBzZW5zaWJseSBieSBkZWZhdWx0LiAoaHR0cHM6Ly9naXRodWIuY29tL2plbnNpbW1vbnMvY3NzcmVtZWR5L2lzc3Vlcy8xNCNpc3N1ZWNvbW1lbnQtNjM0OTM0MjEwKVxcbiAgIFRoaXMgY2FuIHRyaWdnZXIgYSBwb29ybHkgY29uc2lkZXJlZCBsaW50IGVycm9yIGluIHNvbWUgdG9vbHMgYnV0IGlzIGluY2x1ZGVkIGJ5IGRlc2lnbi5cXG4qL1xcblxcbmltZyxcXG5zdmcsXFxudmlkZW8sXFxuY2FudmFzLFxcbmF1ZGlvLFxcbmlmcmFtZSxcXG5lbWJlZCxcXG5vYmplY3Qge1xcbiAgZGlzcGxheTogYmxvY2s7IC8qIDEgKi9cXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5Db25zdHJhaW4gaW1hZ2VzIGFuZCB2aWRlb3MgdG8gdGhlIHBhcmVudCB3aWR0aCBhbmQgcHJlc2VydmUgdGhlaXIgaW50cmluc2ljIGFzcGVjdCByYXRpby4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3pkZXZzL2Nzc3JlbWVkeS9pc3N1ZXMvMTQpXFxuKi9cXG5cXG5pbWcsXFxudmlkZW8ge1xcbiAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG5cXG4qLCA6OmJlZm9yZSwgOjphZnRlciB7XFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXg6IDA7XFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXk6IDA7XFxuICAtLXR3LXRyYW5zbGF0ZS14OiAwO1xcbiAgLS10dy10cmFuc2xhdGUteTogMDtcXG4gIC0tdHctcm90YXRlOiAwO1xcbiAgLS10dy1za2V3LXg6IDA7XFxuICAtLXR3LXNrZXcteTogMDtcXG4gIC0tdHctc2NhbGUteDogMTtcXG4gIC0tdHctc2NhbGUteTogMTtcXG4gIC0tdHctcGFuLXg6ICA7XFxuICAtLXR3LXBhbi15OiAgO1xcbiAgLS10dy1waW5jaC16b29tOiAgO1xcbiAgLS10dy1zY3JvbGwtc25hcC1zdHJpY3RuZXNzOiBwcm94aW1pdHk7XFxuICAtLXR3LW9yZGluYWw6ICA7XFxuICAtLXR3LXNsYXNoZWQtemVybzogIDtcXG4gIC0tdHctbnVtZXJpYy1maWd1cmU6ICA7XFxuICAtLXR3LW51bWVyaWMtc3BhY2luZzogIDtcXG4gIC0tdHctbnVtZXJpYy1mcmFjdGlvbjogIDtcXG4gIC0tdHctcmluZy1pbnNldDogIDtcXG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDBweDtcXG4gIC0tdHctcmluZy1vZmZzZXQtY29sb3I6ICNmZmY7XFxuICAtLXR3LXJpbmctY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gMC41KTtcXG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXJpbmctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAwICMwMDAwO1xcbiAgLS10dy1ibHVyOiAgO1xcbiAgLS10dy1icmlnaHRuZXNzOiAgO1xcbiAgLS10dy1jb250cmFzdDogIDtcXG4gIC0tdHctZ3JheXNjYWxlOiAgO1xcbiAgLS10dy1odWUtcm90YXRlOiAgO1xcbiAgLS10dy1pbnZlcnQ6ICA7XFxuICAtLXR3LXNhdHVyYXRlOiAgO1xcbiAgLS10dy1zZXBpYTogIDtcXG4gIC0tdHctZHJvcC1zaGFkb3c6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWJsdXI6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3M6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWNvbnRyYXN0OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1ncmF5c2NhbGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWludmVydDogIDtcXG4gIC0tdHctYmFja2Ryb3Atb3BhY2l0eTogIDtcXG4gIC0tdHctYmFja2Ryb3Atc2F0dXJhdGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLXNlcGlhOiAgO1xcbn1cXG5cXG46OmJhY2tkcm9wIHtcXG4gIC0tdHctYm9yZGVyLXNwYWNpbmcteDogMDtcXG4gIC0tdHctYm9yZGVyLXNwYWNpbmcteTogMDtcXG4gIC0tdHctdHJhbnNsYXRlLXg6IDA7XFxuICAtLXR3LXRyYW5zbGF0ZS15OiAwO1xcbiAgLS10dy1yb3RhdGU6IDA7XFxuICAtLXR3LXNrZXcteDogMDtcXG4gIC0tdHctc2tldy15OiAwO1xcbiAgLS10dy1zY2FsZS14OiAxO1xcbiAgLS10dy1zY2FsZS15OiAxO1xcbiAgLS10dy1wYW4teDogIDtcXG4gIC0tdHctcGFuLXk6ICA7XFxuICAtLXR3LXBpbmNoLXpvb206ICA7XFxuICAtLXR3LXNjcm9sbC1zbmFwLXN0cmljdG5lc3M6IHByb3hpbWl0eTtcXG4gIC0tdHctb3JkaW5hbDogIDtcXG4gIC0tdHctc2xhc2hlZC16ZXJvOiAgO1xcbiAgLS10dy1udW1lcmljLWZpZ3VyZTogIDtcXG4gIC0tdHctbnVtZXJpYy1zcGFjaW5nOiAgO1xcbiAgLS10dy1udW1lcmljLWZyYWN0aW9uOiAgO1xcbiAgLS10dy1yaW5nLWluc2V0OiAgO1xcbiAgLS10dy1yaW5nLW9mZnNldC13aWR0aDogMHB4O1xcbiAgLS10dy1yaW5nLW9mZnNldC1jb2xvcjogI2ZmZjtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDU5IDEzMCAyNDYgLyAwLjUpO1xcbiAgLS10dy1yaW5nLW9mZnNldC1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctcmluZy1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDAgIzAwMDA7XFxuICAtLXR3LWJsdXI6ICA7XFxuICAtLXR3LWJyaWdodG5lc3M6ICA7XFxuICAtLXR3LWNvbnRyYXN0OiAgO1xcbiAgLS10dy1ncmF5c2NhbGU6ICA7XFxuICAtLXR3LWh1ZS1yb3RhdGU6ICA7XFxuICAtLXR3LWludmVydDogIDtcXG4gIC0tdHctc2F0dXJhdGU6ICA7XFxuICAtLXR3LXNlcGlhOiAgO1xcbiAgLS10dy1kcm9wLXNoYWRvdzogIDtcXG4gIC0tdHctYmFja2Ryb3AtYmx1cjogIDtcXG4gIC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzczogIDtcXG4gIC0tdHctYmFja2Ryb3AtY29udHJhc3Q6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZTogIDtcXG4gIC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZTogIDtcXG4gIC0tdHctYmFja2Ryb3AtaW52ZXJ0OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1vcGFjaXR5OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1zYXR1cmF0ZTogIDtcXG4gIC0tdHctYmFja2Ryb3Atc2VwaWE6ICA7XFxufVxcclxcbi5wb2ludGVyLWV2ZW50cy1ub25lIHtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXHJcXG4uZml4ZWQge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbn1cXHJcXG4uYWJzb2x1dGUge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXHJcXG4ucmVsYXRpdmUge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXHJcXG4uLXRvcC0zIHtcXG4gIHRvcDogLTAuNzVyZW07XFxufVxcclxcbi4tdG9wLTUge1xcbiAgdG9wOiAtMS4yNXJlbTtcXG59XFxyXFxuLi10b3AtMTYge1xcbiAgdG9wOiAtNHJlbTtcXG59XFxyXFxuLnJpZ2h0LTAge1xcbiAgcmlnaHQ6IDBweDtcXG59XFxyXFxuLnJpZ2h0LTI0IHtcXG4gIHJpZ2h0OiA2cmVtO1xcbn1cXHJcXG4ubGVmdC0xXFxcXC8yIHtcXG4gIGxlZnQ6IDUwJTtcXG59XFxyXFxuLnJpZ2h0LTFcXFxcLzIge1xcbiAgcmlnaHQ6IDUwJTtcXG59XFxyXFxuLmJvdHRvbS0zNiB7XFxuICBib3R0b206IDlyZW07XFxufVxcclxcbi50b3AtXFxcXFs4NVxcXFwlXFxcXF0ge1xcbiAgdG9wOiA4NSU7XFxufVxcclxcbi5ib3R0b20tXFxcXFsxN1xcXFwuMnJlbVxcXFxdIHtcXG4gIGJvdHRvbTogMTcuMnJlbTtcXG59XFxyXFxuLmJvdHRvbS0wIHtcXG4gIGJvdHRvbTogMHB4O1xcbn1cXHJcXG4udG9wLTAge1xcbiAgdG9wOiAwcHg7XFxufVxcclxcbi5yaWdodC05IHtcXG4gIHJpZ2h0OiAyLjI1cmVtO1xcbn1cXHJcXG4ubGVmdC0wIHtcXG4gIGxlZnQ6IDBweDtcXG59XFxyXFxuLnotMTAge1xcbiAgei1pbmRleDogMTA7XFxufVxcclxcbi56LTIwIHtcXG4gIHotaW5kZXg6IDIwO1xcbn1cXHJcXG4uY29sLXNwYW4tMiB7XFxuICBncmlkLWNvbHVtbjogc3BhbiAyIC8gc3BhbiAyO1xcbn1cXHJcXG4uY29sLXNwYW4tMyB7XFxuICBncmlkLWNvbHVtbjogc3BhbiAzIC8gc3BhbiAzO1xcbn1cXHJcXG4uY29sLXNwYW4tMTIge1xcbiAgZ3JpZC1jb2x1bW46IHNwYW4gMTIgLyBzcGFuIDEyO1xcbn1cXHJcXG4uY29sLXNwYW4tMTAge1xcbiAgZ3JpZC1jb2x1bW46IHNwYW4gMTAgLyBzcGFuIDEwO1xcbn1cXHJcXG4uY29sLXNwYW4tNCB7XFxuICBncmlkLWNvbHVtbjogc3BhbiA0IC8gc3BhbiA0O1xcbn1cXHJcXG4uY29sLXNwYW4tNiB7XFxuICBncmlkLWNvbHVtbjogc3BhbiA2IC8gc3BhbiA2O1xcbn1cXHJcXG4uY29sLXNwYW4tNyB7XFxuICBncmlkLWNvbHVtbjogc3BhbiA3IC8gc3BhbiA3O1xcbn1cXHJcXG4ucm93LXNwYW4tMyB7XFxuICBncmlkLXJvdzogc3BhbiAzIC8gc3BhbiAzO1xcbn1cXHJcXG4ubXktMiB7XFxuICBtYXJnaW4tdG9wOiAwLjVyZW07XFxuICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxufVxcclxcbi5teC1hdXRvIHtcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbn1cXHJcXG4ubXgtMyB7XFxuICBtYXJnaW4tbGVmdDogMC43NXJlbTtcXG4gIG1hcmdpbi1yaWdodDogMC43NXJlbTtcXG59XFxyXFxuLm14LTUge1xcbiAgbWFyZ2luLWxlZnQ6IDEuMjVyZW07XFxuICBtYXJnaW4tcmlnaHQ6IDEuMjVyZW07XFxufVxcclxcbi5teC0xIHtcXG4gIG1hcmdpbi1sZWZ0OiAwLjI1cmVtO1xcbiAgbWFyZ2luLXJpZ2h0OiAwLjI1cmVtO1xcbn1cXHJcXG4ubXktMSB7XFxuICBtYXJnaW4tdG9wOiAwLjI1cmVtO1xcbiAgbWFyZ2luLWJvdHRvbTogMC4yNXJlbTtcXG59XFxyXFxuLm14LTIge1xcbiAgbWFyZ2luLWxlZnQ6IDAuNXJlbTtcXG4gIG1hcmdpbi1yaWdodDogMC41cmVtO1xcbn1cXHJcXG4ubXktNyB7XFxuICBtYXJnaW4tdG9wOiAxLjc1cmVtO1xcbiAgbWFyZ2luLWJvdHRvbTogMS43NXJlbTtcXG59XFxyXFxuLm14LVxcXFxbMFxcXFwuMzVyZW1cXFxcXSB7XFxuICBtYXJnaW4tbGVmdDogMC4zNXJlbTtcXG4gIG1hcmdpbi1yaWdodDogMC4zNXJlbTtcXG59XFxyXFxuLm14LTEwIHtcXG4gIG1hcmdpbi1sZWZ0OiAyLjVyZW07XFxuICBtYXJnaW4tcmlnaHQ6IDIuNXJlbTtcXG59XFxyXFxuLm14LTgge1xcbiAgbWFyZ2luLWxlZnQ6IDJyZW07XFxuICBtYXJnaW4tcmlnaHQ6IDJyZW07XFxufVxcclxcbi5teS0zIHtcXG4gIG1hcmdpbi10b3A6IDAuNzVyZW07XFxuICBtYXJnaW4tYm90dG9tOiAwLjc1cmVtO1xcbn1cXHJcXG4ubXktMTIge1xcbiAgbWFyZ2luLXRvcDogM3JlbTtcXG4gIG1hcmdpbi1ib3R0b206IDNyZW07XFxufVxcclxcbi5tdC0xNiB7XFxuICBtYXJnaW4tdG9wOiA0cmVtO1xcbn1cXHJcXG4ubXQtMTIge1xcbiAgbWFyZ2luLXRvcDogM3JlbTtcXG59XFxyXFxuLm10LTgge1xcbiAgbWFyZ2luLXRvcDogMnJlbTtcXG59XFxyXFxuLm10LTIge1xcbiAgbWFyZ2luLXRvcDogMC41cmVtO1xcbn1cXHJcXG4ubXQtNSB7XFxuICBtYXJnaW4tdG9wOiAxLjI1cmVtO1xcbn1cXHJcXG4uLW10LTE0IHtcXG4gIG1hcmdpbi10b3A6IC0zLjVyZW07XFxufVxcclxcbi4tbWItNSB7XFxuICBtYXJnaW4tYm90dG9tOiAtMS4yNXJlbTtcXG59XFxyXFxuLm1iLTUge1xcbiAgbWFyZ2luLWJvdHRvbTogMS4yNXJlbTtcXG59XFxyXFxuLm10LTMge1xcbiAgbWFyZ2luLXRvcDogMC43NXJlbTtcXG59XFxyXFxuLm10LTEwIHtcXG4gIG1hcmdpbi10b3A6IDIuNXJlbTtcXG59XFxyXFxuLm10LTcge1xcbiAgbWFyZ2luLXRvcDogMS43NXJlbTtcXG59XFxyXFxuLm1iLTEwIHtcXG4gIG1hcmdpbi1ib3R0b206IDIuNXJlbTtcXG59XFxyXFxuLm10LTEge1xcbiAgbWFyZ2luLXRvcDogMC4yNXJlbTtcXG59XFxyXFxuLm10LTQge1xcbiAgbWFyZ2luLXRvcDogMXJlbTtcXG59XFxyXFxuLm1iLTcge1xcbiAgbWFyZ2luLWJvdHRvbTogMS43NXJlbTtcXG59XFxyXFxuLm1iLTIge1xcbiAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbn1cXHJcXG4ubXItMTYge1xcbiAgbWFyZ2luLXJpZ2h0OiA0cmVtO1xcbn1cXHJcXG4ubWwtNSB7XFxuICBtYXJnaW4tbGVmdDogMS4yNXJlbTtcXG59XFxyXFxuLm1sLTEge1xcbiAgbWFyZ2luLWxlZnQ6IDAuMjVyZW07XFxufVxcclxcbi5tdC1cXFxcWzE1cHhcXFxcXSB7XFxuICBtYXJnaW4tdG9wOiAxNXB4O1xcbn1cXHJcXG4ubXQtXFxcXFswXFxcXC44cHhcXFxcXSB7XFxuICBtYXJnaW4tdG9wOiAwLjhweDtcXG59XFxyXFxuLm10LTYge1xcbiAgbWFyZ2luLXRvcDogMS41cmVtO1xcbn1cXHJcXG4ubWItNCB7XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbn1cXHJcXG4uLW1iLTEge1xcbiAgbWFyZ2luLWJvdHRvbTogLTAuMjVyZW07XFxufVxcclxcbi4tbWwtXFxcXFsxMDBcXFxcJVxcXFxdIHtcXG4gIG1hcmdpbi1sZWZ0OiAtMTAwJTtcXG59XFxyXFxuLi1tbC1cXFxcWzBcXFxcJVxcXFxdIHtcXG4gIG1hcmdpbi1sZWZ0OiAtMCU7XFxufVxcclxcbi4tbWwtXFxcXFsyMDBcXFxcJVxcXFxdIHtcXG4gIG1hcmdpbi1sZWZ0OiAtMjAwJTtcXG59XFxyXFxuLi1tbC1cXFxcWzMwMFxcXFwlXFxcXF0ge1xcbiAgbWFyZ2luLWxlZnQ6IC0zMDAlO1xcbn1cXHJcXG4uLW1sLVxcXFxbNTB2d1xcXFxdIHtcXG4gIG1hcmdpbi1sZWZ0OiAtNTB2dztcXG59XFxyXFxuLi1tci1cXFxcWzUwdndcXFxcXSB7XFxuICBtYXJnaW4tcmlnaHQ6IC01MHZ3O1xcbn1cXHJcXG4ubXItXFxcXFswXFxcXC4zNXJlbVxcXFxdIHtcXG4gIG1hcmdpbi1yaWdodDogMC4zNXJlbTtcXG59XFxyXFxuLm1sLTMge1xcbiAgbWFyZ2luLWxlZnQ6IDAuNzVyZW07XFxufVxcclxcbi5tci0zIHtcXG4gIG1hcmdpbi1yaWdodDogMC43NXJlbTtcXG59XFxyXFxuLm1yLTUge1xcbiAgbWFyZ2luLXJpZ2h0OiAxLjI1cmVtO1xcbn1cXHJcXG4ubWItMSB7XFxuICBtYXJnaW4tYm90dG9tOiAwLjI1cmVtO1xcbn1cXHJcXG4ubWItOCB7XFxuICBtYXJnaW4tYm90dG9tOiAycmVtO1xcbn1cXHJcXG4uYmxvY2sge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcclxcbi5pbmxpbmUtYmxvY2sge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXHJcXG4uZmxleCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbn1cXHJcXG4uaW5saW5lLWZsZXgge1xcbiAgZGlzcGxheTogaW5saW5lLWZsZXg7XFxufVxcclxcbi50YWJsZSB7XFxuICBkaXNwbGF5OiB0YWJsZTtcXG59XFxyXFxuLmdyaWQge1xcbiAgZGlzcGxheTogZ3JpZDtcXG59XFxyXFxuLmhpZGRlbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXHJcXG4uYXNwZWN0LXNxdWFyZSB7XFxuICBhc3BlY3QtcmF0aW86IDEgLyAxO1xcbn1cXHJcXG4uaC01IHtcXG4gIGhlaWdodDogMS4yNXJlbTtcXG59XFxyXFxuLmgtMjQge1xcbiAgaGVpZ2h0OiA2cmVtO1xcbn1cXHJcXG4uaC03MiB7XFxuICBoZWlnaHQ6IDE4cmVtO1xcbn1cXHJcXG4uaC1maXQge1xcbiAgaGVpZ2h0OiAtbW96LWZpdC1jb250ZW50O1xcbiAgaGVpZ2h0OiBmaXQtY29udGVudDtcXG59XFxyXFxuLmgtXFxcXFszMzBweFxcXFxdIHtcXG4gIGhlaWdodDogMzMwcHg7XFxufVxcclxcbi5oLTEyIHtcXG4gIGhlaWdodDogM3JlbTtcXG59XFxyXFxuLmgtbWF4IHtcXG4gIGhlaWdodDogLW1vei1tYXgtY29udGVudDtcXG4gIGhlaWdodDogbWF4LWNvbnRlbnQ7XFxufVxcclxcbi5oLVxcXFxbNDY3cHhcXFxcXSB7XFxuICBoZWlnaHQ6IDQ2N3B4O1xcbn1cXHJcXG4uaC02IHtcXG4gIGhlaWdodDogMS41cmVtO1xcbn1cXHJcXG4uaC1mdWxsIHtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxyXFxuLmgtXFxcXFszMHB4XFxcXF0ge1xcbiAgaGVpZ2h0OiAzMHB4O1xcbn1cXHJcXG4uaC01NiB7XFxuICBoZWlnaHQ6IDE0cmVtO1xcbn1cXHJcXG4uaC1cXFxcWzQ1dmhcXFxcXSB7XFxuICBoZWlnaHQ6IDQ1dmg7XFxufVxcclxcbi5oLVxcXFxbMjUwcHhcXFxcXSB7XFxuICBoZWlnaHQ6IDI1MHB4O1xcbn1cXHJcXG4uaC00IHtcXG4gIGhlaWdodDogMXJlbTtcXG59XFxyXFxuLmgtXFxcXFsxNjZweFxcXFxdIHtcXG4gIGhlaWdodDogMTY2cHg7XFxufVxcclxcbi5oLVxcXFxbMTk5XFxcXC42OXB4XFxcXF0ge1xcbiAgaGVpZ2h0OiAxOTkuNjlweDtcXG59XFxyXFxuLmgtXFxcXFsxOTBcXFxcXSB7XFxuICBoZWlnaHQ6IDE5MDtcXG59XFxyXFxuLmgtXFxcXFs2MHB4XFxcXF0ge1xcbiAgaGVpZ2h0OiA2MHB4O1xcbn1cXHJcXG4uaC00OCB7XFxuICBoZWlnaHQ6IDEycmVtO1xcbn1cXHJcXG4ubWF4LWgtZml0IHtcXG4gIG1heC1oZWlnaHQ6IC1tb3otZml0LWNvbnRlbnQ7XFxuICBtYXgtaGVpZ2h0OiBmaXQtY29udGVudDtcXG59XFxyXFxuLm1heC1oLVxcXFxbMjUwcHhcXFxcXSB7XFxuICBtYXgtaGVpZ2h0OiAyNTBweDtcXG59XFxyXFxuLm1heC1oLVxcXFxbMjRweFxcXFxdIHtcXG4gIG1heC1oZWlnaHQ6IDI0cHg7XFxufVxcclxcbi5taW4taC1zY3JlZW4ge1xcbiAgbWluLWhlaWdodDogMTAwdmg7XFxufVxcclxcbi5taW4taC1cXFxcWzEwMHZoXFxcXF0ge1xcbiAgbWluLWhlaWdodDogMTAwdmg7XFxufVxcclxcbi5taW4taC1cXFxcWzMzMHB4XFxcXF0ge1xcbiAgbWluLWhlaWdodDogMzMwcHg7XFxufVxcclxcbi5taW4taC1cXFxcWzIxM3B4XFxcXF0ge1xcbiAgbWluLWhlaWdodDogMjEzcHg7XFxufVxcclxcbi53LWZ1bGwge1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcclxcbi53LTUge1xcbiAgd2lkdGg6IDEuMjVyZW07XFxufVxcclxcbi53LTNcXFxcLzQge1xcbiAgd2lkdGg6IDc1JTtcXG59XFxyXFxuLnctMjQge1xcbiAgd2lkdGg6IDZyZW07XFxufVxcclxcbi53LTgge1xcbiAgd2lkdGg6IDJyZW07XFxufVxcclxcbi53LVxcXFxbOTB2d1xcXFxdIHtcXG4gIHdpZHRoOiA5MHZ3O1xcbn1cXHJcXG4udy0xMiB7XFxuICB3aWR0aDogM3JlbTtcXG59XFxyXFxuLnctXFxcXFs0OFxcXFwlXFxcXF0ge1xcbiAgd2lkdGg6IDQ4JTtcXG59XFxyXFxuLnctZml0IHtcXG4gIHdpZHRoOiAtbW96LWZpdC1jb250ZW50O1xcbiAgd2lkdGg6IGZpdC1jb250ZW50O1xcbn1cXHJcXG4udy0yXFxcXC8zIHtcXG4gIHdpZHRoOiA2Ni42NjY2NjclO1xcbn1cXHJcXG4udy04MCB7XFxuICB3aWR0aDogMjByZW07XFxufVxcclxcbi53LVxcXFxbMTAwdndcXFxcXSB7XFxuICB3aWR0aDogMTAwdnc7XFxufVxcclxcbi53LTYge1xcbiAgd2lkdGg6IDEuNXJlbTtcXG59XFxyXFxuLnctXFxcXFszMHB4XFxcXF0ge1xcbiAgd2lkdGg6IDMwcHg7XFxufVxcclxcbi53LVxcXFxbMzAwXFxcXCVcXFxcXSB7XFxuICB3aWR0aDogMzAwJTtcXG59XFxyXFxuLnctXFxcXFsxMDBcXFxcJVxcXFxdIHtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXHJcXG4udy00IHtcXG4gIHdpZHRoOiAxcmVtO1xcbn1cXHJcXG4udy1cXFxcWzEwOHB4XFxcXF0ge1xcbiAgd2lkdGg6IDEwOHB4O1xcbn1cXHJcXG4udy1cXFxcWzE0MnB4XFxcXF0ge1xcbiAgd2lkdGg6IDE0MnB4O1xcbn1cXHJcXG4udy1cXFxcWzRcXFxcLjJyZW1cXFxcXSB7XFxuICB3aWR0aDogNC4ycmVtO1xcbn1cXHJcXG4udy0yMCB7XFxuICB3aWR0aDogNXJlbTtcXG59XFxyXFxuLnctXFxcXFsxNDRweFxcXFxdIHtcXG4gIHdpZHRoOiAxNDRweDtcXG59XFxyXFxuLnctMlxcXFwvNCB7XFxuICB3aWR0aDogNTAlO1xcbn1cXHJcXG4ubWluLXctXFxcXFszMDBweFxcXFxdIHtcXG4gIG1pbi13aWR0aDogMzAwcHg7XFxufVxcclxcbi5taW4tdy1cXFxcWzUwcHhcXFxcXSB7XFxuICBtaW4td2lkdGg6IDUwcHg7XFxufVxcclxcbi5taW4tdy1cXFxcWzc4cHhcXFxcXSB7XFxuICBtaW4td2lkdGg6IDc4cHg7XFxufVxcclxcbi5taW4tdy1cXFxcWzEwOHB4XFxcXF0ge1xcbiAgbWluLXdpZHRoOiAxMDhweDtcXG59XFxyXFxuLm1pbi13LVxcXFxbMjZweFxcXFxdIHtcXG4gIG1pbi13aWR0aDogMjZweDtcXG59XFxyXFxuLm1heC13LVxcXFxbMTIwMHB4XFxcXF0ge1xcbiAgbWF4LXdpZHRoOiAxMjAwcHg7XFxufVxcclxcbi5tYXgtdy1cXFxcWzE1MDBweFxcXFxdIHtcXG4gIG1heC13aWR0aDogMTUwMHB4O1xcbn1cXHJcXG4ubWF4LXctXFxcXFsxMzAwcHhcXFxcXSB7XFxuICBtYXgtd2lkdGg6IDEzMDBweDtcXG59XFxyXFxuLm1heC13LVxcXFxbMTEwMHB4XFxcXF0ge1xcbiAgbWF4LXdpZHRoOiAxMTAwcHg7XFxufVxcclxcbi5tYXgtdy1cXFxcWzU4MXB4XFxcXF0ge1xcbiAgbWF4LXdpZHRoOiA1ODFweDtcXG59XFxyXFxuLi10cmFuc2xhdGUteC0xXFxcXC8yIHtcXG4gIC0tdHctdHJhbnNsYXRlLXg6IC01MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh2YXIoLS10dy10cmFuc2xhdGUteCksIHZhcigtLXR3LXRyYW5zbGF0ZS15KSkgcm90YXRlKHZhcigtLXR3LXJvdGF0ZSkpIHNrZXdYKHZhcigtLXR3LXNrZXcteCkpIHNrZXdZKHZhcigtLXR3LXNrZXcteSkpIHNjYWxlWCh2YXIoLS10dy1zY2FsZS14KSkgc2NhbGVZKHZhcigtLXR3LXNjYWxlLXkpKTtcXG59XFxyXFxuLmN1cnNvci1wb2ludGVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxyXFxuLnNlbGVjdC1ub25lIHtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxyXFxuLmFwcGVhcmFuY2Utbm9uZSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAtbW96LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICAgIGFwcGVhcmFuY2U6IG5vbmU7XFxufVxcclxcbi5ncmlkLWNvbHMtMiB7XFxuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgyLCBtaW5tYXgoMCwgMWZyKSk7XFxufVxcclxcbi5ncmlkLWNvbHMtMSB7XFxuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgxLCBtaW5tYXgoMCwgMWZyKSk7XFxufVxcclxcbi5ncmlkLWNvbHMtNCB7XFxuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg0LCBtaW5tYXgoMCwgMWZyKSk7XFxufVxcclxcbi5ncmlkLWNvbHMtMTIge1xcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMTIsIG1pbm1heCgwLCAxZnIpKTtcXG59XFxyXFxuLmdyaWQtY29scy0xMCB7XFxuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgxMCwgbWlubWF4KDAsIDFmcikpO1xcbn1cXHJcXG4uZmxleC1jb2wge1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxyXFxuLmZsZXgtd3JhcCB7XFxuICBmbGV4LXdyYXA6IHdyYXA7XFxufVxcclxcbi5wbGFjZS1jb250ZW50LWJldHdlZW4ge1xcbiAgcGxhY2UtY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG59XFxyXFxuLml0ZW1zLWVuZCB7XFxuICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XFxufVxcclxcbi5pdGVtcy1jZW50ZXIge1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxyXFxuLmp1c3RpZnktZW5kIHtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxufVxcclxcbi5qdXN0aWZ5LWNlbnRlciB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxyXFxuLmp1c3RpZnktYmV0d2VlbiB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxufVxcclxcbi5nYXAtMyB7XFxuICBnYXA6IDAuNzVyZW07XFxufVxcclxcbi5nYXAtMTAge1xcbiAgZ2FwOiAyLjVyZW07XFxufVxcclxcbi5nYXAtNCB7XFxuICBnYXA6IDFyZW07XFxufVxcclxcbi5zcGFjZS15LTQgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXG4gIC0tdHctc3BhY2UteS1yZXZlcnNlOiAwO1xcbiAgbWFyZ2luLXRvcDogY2FsYygxcmVtICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSkpO1xcbiAgbWFyZ2luLWJvdHRvbTogY2FsYygxcmVtICogdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSk7XFxufVxcclxcbi5zcGFjZS14LTMgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXG4gIC0tdHctc3BhY2UteC1yZXZlcnNlOiAwO1xcbiAgbWFyZ2luLXJpZ2h0OiBjYWxjKDAuNzVyZW0gKiB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKTtcXG4gIG1hcmdpbi1sZWZ0OiBjYWxjKDAuNzVyZW0gKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKSk7XFxufVxcclxcbi5zcGFjZS14LTIgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXG4gIC0tdHctc3BhY2UteC1yZXZlcnNlOiAwO1xcbiAgbWFyZ2luLXJpZ2h0OiBjYWxjKDAuNXJlbSAqIHZhcigtLXR3LXNwYWNlLXgtcmV2ZXJzZSkpO1xcbiAgbWFyZ2luLWxlZnQ6IGNhbGMoMC41cmVtICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSkpO1xcbn1cXHJcXG4uc3BhY2UteC01ID4gOm5vdChbaGlkZGVuXSkgfiA6bm90KFtoaWRkZW5dKSB7XFxuICAtLXR3LXNwYWNlLXgtcmV2ZXJzZTogMDtcXG4gIG1hcmdpbi1yaWdodDogY2FsYygxLjI1cmVtICogdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSk7XFxuICBtYXJnaW4tbGVmdDogY2FsYygxLjI1cmVtICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSkpO1xcbn1cXHJcXG4uc3BhY2UteC04ID4gOm5vdChbaGlkZGVuXSkgfiA6bm90KFtoaWRkZW5dKSB7XFxuICAtLXR3LXNwYWNlLXgtcmV2ZXJzZTogMDtcXG4gIG1hcmdpbi1yaWdodDogY2FsYygycmVtICogdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSk7XFxuICBtYXJnaW4tbGVmdDogY2FsYygycmVtICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSkpO1xcbn1cXHJcXG4uZGl2aWRlLXNvbGlkID4gOm5vdChbaGlkZGVuXSkgfiA6bm90KFtoaWRkZW5dKSB7XFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbn1cXHJcXG4ub3ZlcmZsb3ctaGlkZGVuIHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcclxcbi5vdmVyZmxvdy14LWF1dG8ge1xcbiAgb3ZlcmZsb3cteDogYXV0bztcXG59XFxyXFxuLndoaXRlc3BhY2Utbm93cmFwIHtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcclxcbi53aGl0ZXNwYWNlLXByZS13cmFwIHtcXG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG59XFxyXFxuLnJvdW5kZWQtbWQge1xcbiAgYm9yZGVyLXJhZGl1czogMC4zNzVyZW07XFxufVxcclxcbi5yb3VuZGVkLTN4bCB7XFxuICBib3JkZXItcmFkaXVzOiAxLjVyZW07XFxufVxcclxcbi5yb3VuZGVkLXhsIHtcXG4gIGJvcmRlci1yYWRpdXM6IDAuNzVyZW07XFxufVxcclxcbi5yb3VuZGVkLWZ1bGwge1xcbiAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xcbn1cXHJcXG4ucm91bmRlZC1sZyB7XFxuICBib3JkZXItcmFkaXVzOiAwLjVyZW07XFxufVxcclxcbi5yb3VuZGVkIHtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjVyZW07XFxufVxcclxcbi5yb3VuZGVkLWwtbWQge1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMC4zNzVyZW07XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwLjM3NXJlbTtcXG59XFxyXFxuLnJvdW5kZWQtbC1ub25lIHtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDBweDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDBweDtcXG59XFxyXFxuLmJvcmRlciB7XFxuICBib3JkZXItd2lkdGg6IDFweDtcXG59XFxyXFxuLmJvcmRlci1cXFxcWzBcXFxcLjVweFxcXFxdIHtcXG4gIGJvcmRlci13aWR0aDogMC41cHg7XFxufVxcclxcbi5ib3JkZXItMiB7XFxuICBib3JkZXItd2lkdGg6IDJweDtcXG59XFxyXFxuLmJvcmRlci1cXFxcWzFweFxcXFxdIHtcXG4gIGJvcmRlci13aWR0aDogMXB4O1xcbn1cXHJcXG4uYm9yZGVyLTQge1xcbiAgYm9yZGVyLXdpZHRoOiA0cHg7XFxufVxcclxcbi5ib3JkZXItYiB7XFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAxcHg7XFxufVxcclxcbi5ib3JkZXItYi0yIHtcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDJweDtcXG59XFxyXFxuLmJvcmRlci10IHtcXG4gIGJvcmRlci10b3Atd2lkdGg6IDFweDtcXG59XFxyXFxuLmJvcmRlci1iLVxcXFxbMXB4XFxcXF0ge1xcbiAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4O1xcbn1cXHJcXG4uYm9yZGVyLXQtMiB7XFxuICBib3JkZXItdG9wLXdpZHRoOiAycHg7XFxufVxcclxcbi5ib3JkZXItdC1cXFxcWzFweFxcXFxdIHtcXG4gIGJvcmRlci10b3Atd2lkdGg6IDFweDtcXG59XFxyXFxuLmJvcmRlci1yLTAge1xcbiAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwcHg7XFxufVxcclxcbi5ib3JkZXItc29saWQge1xcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG59XFxyXFxuLmJvcmRlci1kYXNoZWQge1xcbiAgYm9yZGVyLXN0eWxlOiBkYXNoZWQ7XFxufVxcclxcbi5ib3JkZXItYmx1ZS00MDAge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDk2IDE2NSAyNTAgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXHJcXG4uYm9yZGVyLXRyYW5zcGFyZW50IHtcXG4gIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcclxcbi5ib3JkZXItZ3JheS0zMDAge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDIwOSAyMTMgMjE5IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJvcmRlci1cXFxcW1xcXFwjQkJCQkJCXFxcXF0ge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDE4NyAxODcgMTg3IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJvcmRlci1cXFxcW1xcXFwjZTJlMmUyXFxcXF0ge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDIyNiAyMjYgMjI2IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJvcmRlci1ibHVlLTgwMCB7XFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMzAgNjQgMTc1IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLXdoaXRlIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNTUgMjU1IDI1NSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLXNsYXRlLTQwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMTQ4IDE2MyAxODQgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1ibHVlLTUwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLXppbmMtMzAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMTIgMjEyIDIxNiAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLXppbmMtNDAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigxNjEgMTYxIDE3MCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLXllbGxvdy01MDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIzNCAxNzkgOCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLWluZGlnby01MDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDk5IDEwMiAyNDEgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy10ZWFsLTUwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjAgMTg0IDE2NiAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLWJsdWUtMjAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigxOTEgMjE5IDI1NCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLVxcXFxbXFxcXCMzRDQxNERcXFxcXSB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoNjEgNjUgNzcgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1ncmF5LTIwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjI5IDIzMSAyMzUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1ibGFjayB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCAwIDAgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1yZWQtMjAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNTQgMjAyIDIwMiAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLXNsYXRlLTMwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjAzIDIxMyAyMjUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1zbGF0ZS0xMDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI0MSAyNDUgMjQ5IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uYmctZ3JheS01MCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjQ5IDI1MCAyNTEgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5vYmplY3QtY292ZXIge1xcbiAgLW8tb2JqZWN0LWZpdDogY292ZXI7XFxuICAgICBvYmplY3QtZml0OiBjb3ZlcjtcXG59XFxyXFxuLnAtNiB7XFxuICBwYWRkaW5nOiAxLjVyZW07XFxufVxcclxcbi5wLTMge1xcbiAgcGFkZGluZzogMC43NXJlbTtcXG59XFxyXFxuLnAtMiB7XFxuICBwYWRkaW5nOiAwLjVyZW07XFxufVxcclxcbi5wLVxcXFxbMFxcXFwuMTJyZW1cXFxcXSB7XFxuICBwYWRkaW5nOiAwLjEycmVtO1xcbn1cXHJcXG4ucC0xIHtcXG4gIHBhZGRpbmc6IDAuMjVyZW07XFxufVxcclxcbi5wLVxcXFxbMFxcXFwuMnJlbVxcXFxdIHtcXG4gIHBhZGRpbmc6IDAuMnJlbTtcXG59XFxyXFxuLnAtMCB7XFxuICBwYWRkaW5nOiAwcHg7XFxufVxcclxcbi5weC00IHtcXG4gIHBhZGRpbmctbGVmdDogMXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDFyZW07XFxufVxcclxcbi5weC0yIHtcXG4gIHBhZGRpbmctbGVmdDogMC41cmVtO1xcbiAgcGFkZGluZy1yaWdodDogMC41cmVtO1xcbn1cXHJcXG4ucHktMiB7XFxuICBwYWRkaW5nLXRvcDogMC41cmVtO1xcbiAgcGFkZGluZy1ib3R0b206IDAuNXJlbTtcXG59XFxyXFxuLnB5LTQge1xcbiAgcGFkZGluZy10b3A6IDFyZW07XFxuICBwYWRkaW5nLWJvdHRvbTogMXJlbTtcXG59XFxyXFxuLnB5LTIwIHtcXG4gIHBhZGRpbmctdG9wOiA1cmVtO1xcbiAgcGFkZGluZy1ib3R0b206IDVyZW07XFxufVxcclxcbi5weC0yMCB7XFxuICBwYWRkaW5nLWxlZnQ6IDVyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiA1cmVtO1xcbn1cXHJcXG4ucHgtOCB7XFxuICBwYWRkaW5nLWxlZnQ6IDJyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAycmVtO1xcbn1cXHJcXG4ucHktMyB7XFxuICBwYWRkaW5nLXRvcDogMC43NXJlbTtcXG4gIHBhZGRpbmctYm90dG9tOiAwLjc1cmVtO1xcbn1cXHJcXG4ucHgtMyB7XFxuICBwYWRkaW5nLWxlZnQ6IDAuNzVyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAwLjc1cmVtO1xcbn1cXHJcXG4ucHgtMSB7XFxuICBwYWRkaW5nLWxlZnQ6IDAuMjVyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAwLjI1cmVtO1xcbn1cXHJcXG4ucHktXFxcXFs1cHhcXFxcXSB7XFxuICBwYWRkaW5nLXRvcDogNXB4O1xcbiAgcGFkZGluZy1ib3R0b206IDVweDtcXG59XFxyXFxuLnB5LTUge1xcbiAgcGFkZGluZy10b3A6IDEuMjVyZW07XFxuICBwYWRkaW5nLWJvdHRvbTogMS4yNXJlbTtcXG59XFxyXFxuLnB4LTEwIHtcXG4gIHBhZGRpbmctbGVmdDogMi41cmVtO1xcbiAgcGFkZGluZy1yaWdodDogMi41cmVtO1xcbn1cXHJcXG4ucHktMSB7XFxuICBwYWRkaW5nLXRvcDogMC4yNXJlbTtcXG4gIHBhZGRpbmctYm90dG9tOiAwLjI1cmVtO1xcbn1cXHJcXG4ucGItNCB7XFxuICBwYWRkaW5nLWJvdHRvbTogMXJlbTtcXG59XFxyXFxuLnB0LTIge1xcbiAgcGFkZGluZy10b3A6IDAuNXJlbTtcXG59XFxyXFxuLnBiLTE0IHtcXG4gIHBhZGRpbmctYm90dG9tOiAzLjVyZW07XFxufVxcclxcbi5wYi1cXFxcWzYwcHhcXFxcXSB7XFxuICBwYWRkaW5nLWJvdHRvbTogNjBweDtcXG59XFxyXFxuLnBiLTMge1xcbiAgcGFkZGluZy1ib3R0b206IDAuNzVyZW07XFxufVxcclxcbi5wdC0xIHtcXG4gIHBhZGRpbmctdG9wOiAwLjI1cmVtO1xcbn1cXHJcXG4ucHQtMyB7XFxuICBwYWRkaW5nLXRvcDogMC43NXJlbTtcXG59XFxyXFxuLnBiLTEge1xcbiAgcGFkZGluZy1ib3R0b206IDAuMjVyZW07XFxufVxcclxcbi5wbC02IHtcXG4gIHBhZGRpbmctbGVmdDogMS41cmVtO1xcbn1cXHJcXG4ucGItMiB7XFxuICBwYWRkaW5nLWJvdHRvbTogMC41cmVtO1xcbn1cXHJcXG4ucGwtMyB7XFxuICBwYWRkaW5nLWxlZnQ6IDAuNzVyZW07XFxufVxcclxcbi5wbC03IHtcXG4gIHBhZGRpbmctbGVmdDogMS43NXJlbTtcXG59XFxyXFxuLnByLTMge1xcbiAgcGFkZGluZy1yaWdodDogMC43NXJlbTtcXG59XFxyXFxuLnRleHQtY2VudGVyIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxyXFxuLmZvbnQtc2FucyB7XFxuICBmb250LWZhbWlseTogdWktc2Fucy1zZXJpZiwgc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFxcXCJTZWdvZSBVSVxcXCIsIFJvYm90bywgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgQXJpYWwsIFxcXCJOb3RvIFNhbnNcXFwiLCBzYW5zLXNlcmlmLCBcXFwiQXBwbGUgQ29sb3IgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgU3ltYm9sXFxcIiwgXFxcIk5vdG8gQ29sb3IgRW1vamlcXFwiO1xcbn1cXHJcXG4udGV4dC0zeGwge1xcbiAgZm9udC1zaXplOiAxLjg3NXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAyLjI1cmVtO1xcbn1cXHJcXG4udGV4dC1zbSB7XFxuICBmb250LXNpemU6IDAuODc1cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuMjVyZW07XFxufVxcclxcbi50ZXh0LXhsIHtcXG4gIGZvbnQtc2l6ZTogMS4yNXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjc1cmVtO1xcbn1cXHJcXG4udGV4dC0yeGwge1xcbiAgZm9udC1zaXplOiAxLjVyZW07XFxuICBsaW5lLWhlaWdodDogMnJlbTtcXG59XFxyXFxuLnRleHQteHMge1xcbiAgZm9udC1zaXplOiAwLjc1cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDFyZW07XFxufVxcclxcbi50ZXh0LWxnIHtcXG4gIGZvbnQtc2l6ZTogMS4xMjVyZW07XFxuICBsaW5lLWhlaWdodDogMS43NXJlbTtcXG59XFxyXFxuLnRleHQtYmFzZSB7XFxuICBmb250LXNpemU6IDFyZW07XFxuICBsaW5lLWhlaWdodDogMS41cmVtO1xcbn1cXHJcXG4uZm9udC1ib2xkIHtcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxufVxcclxcbi5mb250LW1lZGl1bSB7XFxuICBmb250LXdlaWdodDogNTAwO1xcbn1cXHJcXG4uZm9udC1zZW1pYm9sZCB7XFxuICBmb250LXdlaWdodDogNjAwO1xcbn1cXHJcXG4udXBwZXJjYXNlIHtcXG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxufVxcclxcbi5sZWFkaW5nLTcge1xcbiAgbGluZS1oZWlnaHQ6IDEuNzVyZW07XFxufVxcclxcbi5sZWFkaW5nLVxcXFxbMVxcXFwuOHJlbVxcXFxdIHtcXG4gIGxpbmUtaGVpZ2h0OiAxLjhyZW07XFxufVxcclxcbi50ZXh0LWdyYXktNTAwIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigxMDcgMTE0IDEyOCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4udGV4dC1ibHVlLTMwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMTQ3IDE5NyAyNTMgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxyXFxuLnRleHQtd2hpdGUge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcclxcbi50ZXh0LWdyYXktNjAwIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYig3NSA4NSA5OSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4udGV4dC1cXFxcW1xcXFwjNjY2Njc2XFxcXF0ge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDEwMiAxMDIgMTE4IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcclxcbi50ZXh0LXJlZC00MDAge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDI0OCAxMTMgMTEzIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcclxcbi50ZXh0LWdyYXktNDAwIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigxNTYgMTYzIDE3NSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4udGV4dC1ibHVlLTUwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4udGV4dC1ibHVlLTQwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoOTYgMTY1IDI1MCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4udGV4dC1ncmF5LTcwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoNTUgNjUgODEgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxyXFxuLnRleHQtYmxhY2sge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDAgMCAwIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcclxcbi5wbGFjZWhvbGRlci1ncmF5LTQwMDo6LW1vei1wbGFjZWhvbGRlciB7XFxuICAtLXR3LXBsYWNlaG9sZGVyLW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDE1NiAxNjMgMTc1IC8gdmFyKC0tdHctcGxhY2Vob2xkZXItb3BhY2l0eSkpO1xcbn1cXHJcXG4ucGxhY2Vob2xkZXItZ3JheS00MDA6OnBsYWNlaG9sZGVyIHtcXG4gIC0tdHctcGxhY2Vob2xkZXItb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMTU2IDE2MyAxNzUgLyB2YXIoLS10dy1wbGFjZWhvbGRlci1vcGFjaXR5KSk7XFxufVxcclxcbi5vcGFjaXR5LTYwIHtcXG4gIG9wYWNpdHk6IDAuNjtcXG59XFxyXFxuLnNoYWRvdy1zbSB7XFxuICAtLXR3LXNoYWRvdzogMCAxcHggMnB4IDAgcmdiKDAgMCAwIC8gMC4wNSk7XFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDFweCAycHggMCB2YXIoLS10dy1zaGFkb3ctY29sb3IpO1xcbiAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1yaW5nLXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctc2hhZG93KTtcXG59XFxyXFxuLnNoYWRvdy14bCB7XFxuICAtLXR3LXNoYWRvdzogMCAyMHB4IDI1cHggLTVweCByZ2IoMCAwIDAgLyAwLjEpLCAwIDhweCAxMHB4IC02cHggcmdiKDAgMCAwIC8gMC4xKTtcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMjBweCAyNXB4IC01cHggdmFyKC0tdHctc2hhZG93LWNvbG9yKSwgMCA4cHggMTBweCAtNnB4IHZhcigtLXR3LXNoYWRvdy1jb2xvcik7XFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXJpbmctc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1zaGFkb3cpO1xcbn1cXHJcXG4ucmluZy0yIHtcXG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiB2YXIoLS10dy1yaW5nLWluc2V0KSAwIDAgMCB2YXIoLS10dy1yaW5nLW9mZnNldC13aWR0aCkgdmFyKC0tdHctcmluZy1vZmZzZXQtY29sb3IpO1xcbiAgLS10dy1yaW5nLXNoYWRvdzogdmFyKC0tdHctcmluZy1pbnNldCkgMCAwIDAgY2FsYygycHggKyB2YXIoLS10dy1yaW5nLW9mZnNldC13aWR0aCkpIHZhcigtLXR3LXJpbmctY29sb3IpO1xcbiAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93KSwgdmFyKC0tdHctcmluZy1zaGFkb3cpLCB2YXIoLS10dy1zaGFkb3csIDAgMCAjMDAwMCk7XFxufVxcclxcbi5yaW5nLXllbGxvdy01MDAge1xcbiAgLS10dy1yaW5nLW9wYWNpdHk6IDE7XFxuICAtLXR3LXJpbmctY29sb3I6IHJnYigyMzQgMTc5IDggLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXG59XFxyXFxuLnJpbmctaW5kaWdvLTUwMCB7XFxuICAtLXR3LXJpbmctb3BhY2l0eTogMTtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDk5IDEwMiAyNDEgLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXG59XFxyXFxuLnJpbmctdGVhbC01MDAge1xcbiAgLS10dy1yaW5nLW9wYWNpdHk6IDE7XFxuICAtLXR3LXJpbmctY29sb3I6IHJnYigyMCAxODQgMTY2IC8gdmFyKC0tdHctcmluZy1vcGFjaXR5KSk7XFxufVxcclxcbi5yaW5nLWdyYXktNTAwIHtcXG4gIC0tdHctcmluZy1vcGFjaXR5OiAxO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoMTA3IDExNCAxMjggLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXG59XFxyXFxuLnJpbmctYmxhY2sge1xcbiAgLS10dy1yaW5nLW9wYWNpdHk6IDE7XFxuICAtLXR3LXJpbmctY29sb3I6IHJnYigwIDAgMCAvIHZhcigtLXR3LXJpbmctb3BhY2l0eSkpO1xcbn1cXHJcXG4ucmluZy1yZWQtNTAwIHtcXG4gIC0tdHctcmluZy1vcGFjaXR5OiAxO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoMjM5IDY4IDY4IC8gdmFyKC0tdHctcmluZy1vcGFjaXR5KSk7XFxufVxcclxcbi5yaW5nLWJsdWUtNTAwIHtcXG4gIC0tdHctcmluZy1vcGFjaXR5OiAxO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIHZhcigtLXR3LXJpbmctb3BhY2l0eSkpO1xcbn1cXHJcXG4ucmluZy1vZmZzZXQtMiB7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAycHg7XFxufVxcclxcbi5yaW5nLW9mZnNldC0xIHtcXG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDFweDtcXG59XFxyXFxuLmZpbHRlciB7XFxuICBmaWx0ZXI6IHZhcigtLXR3LWJsdXIpIHZhcigtLXR3LWJyaWdodG5lc3MpIHZhcigtLXR3LWNvbnRyYXN0KSB2YXIoLS10dy1ncmF5c2NhbGUpIHZhcigtLXR3LWh1ZS1yb3RhdGUpIHZhcigtLXR3LWludmVydCkgdmFyKC0tdHctc2F0dXJhdGUpIHZhcigtLXR3LXNlcGlhKSB2YXIoLS10dy1kcm9wLXNoYWRvdyk7XFxufVxcclxcbi50cmFuc2l0aW9uIHtcXG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IGNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXItY29sb3IsIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgZmlsbCwgc3Ryb2tlLCBvcGFjaXR5LCBib3gtc2hhZG93LCB0cmFuc2Zvcm0sIGZpbHRlciwgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI7XFxuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBjb2xvciwgYmFja2dyb3VuZC1jb2xvciwgYm9yZGVyLWNvbG9yLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIGZpbGwsIHN0cm9rZSwgb3BhY2l0eSwgYm94LXNoYWRvdywgdHJhbnNmb3JtLCBmaWx0ZXIsIGJhY2tkcm9wLWZpbHRlcjtcXG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IGNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXItY29sb3IsIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgZmlsbCwgc3Ryb2tlLCBvcGFjaXR5LCBib3gtc2hhZG93LCB0cmFuc2Zvcm0sIGZpbHRlciwgYmFja2Ryb3AtZmlsdGVyLCAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjtcXG4gIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO1xcbiAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMTUwbXM7XFxufVxcclxcbi50cmFuc2l0aW9uLWFsbCB7XFxuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBhbGw7XFxuICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtcXG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDE1MG1zO1xcbn1cXHJcXG4uZHVyYXRpb24tXFxcXFswbXNcXFxcXSB7XFxuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAwbXM7XFxufVxcclxcbi5kdXJhdGlvbi0xMDAwIHtcXG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDEwMDBtcztcXG59XFxyXFxuLmxhc3RcXFxcOmJvcmRlci1iLTA6bGFzdC1jaGlsZCB7XFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAwcHg7XFxufVxcclxcbi5vZGRcXFxcOmJnLWJsdWUtNTA6bnRoLWNoaWxkKG9kZCkge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIzOSAyNDYgMjU1IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOmN1cnNvci1wb2ludGVyOmhvdmVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxyXFxuLmhvdmVyXFxcXDpib3JkZXItYmx1ZS01MDA6aG92ZXIge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDU5IDEzMCAyNDYgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOmJvcmRlci1ncmF5LTQwMDpob3ZlciB7XFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMTU2IDE2MyAxNzUgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOmJvcmRlci1ncmF5LTMwMDpob3ZlciB7XFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMjA5IDIxMyAyMTkgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOmJnLWdyYXktNTA6aG92ZXIge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI0OSAyNTAgMjUxIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOmJnLXRlYWwtNTAwOmhvdmVyIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMCAxODQgMTY2IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOmJnLWdyYXktMjAwOmhvdmVyIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMjkgMjMxIDIzNSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmhvdmVyXFxcXDpiZy1ncmF5LTEwMDpob3ZlciB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjQzIDI0NCAyNDYgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5ob3ZlclxcXFw6Ymctd2hpdGU6aG92ZXIge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOnRleHQtZ3JheS00MDA6aG92ZXIge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDE1NiAxNjMgMTc1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcclxcbi5ob3ZlclxcXFw6dGV4dC1ibGFjazpob3ZlciB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMCAwIDAgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxyXFxuLmhvdmVyXFxcXDp0ZXh0LWJsdWUtNTAwOmhvdmVyIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcclxcbi5ob3ZlclxcXFw6dGV4dC1yZWQtNTAwOmhvdmVyIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigyMzkgNjggNjggLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxyXFxuLmhvdmVyXFxcXDp0ZXh0LWdyYXktNTAwOmhvdmVyIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigxMDcgMTE0IDEyOCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4uaG92ZXJcXFxcOnRleHQtYmx1ZS00MDA6aG92ZXIge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDk2IDE2NSAyNTAgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxyXFxuLmhvdmVyXFxcXDp1bmRlcmxpbmU6aG92ZXIge1xcbiAgdGV4dC1kZWNvcmF0aW9uLWxpbmU6IHVuZGVybGluZTtcXG59XFxyXFxuLmZvY3VzXFxcXDpib3JkZXItYmx1ZS00MDA6Zm9jdXMge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDk2IDE2NSAyNTAgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXHJcXG4uZm9jdXNcXFxcOmJvcmRlci1vcmFuZ2UtNTAwOmZvY3VzIHtcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICBib3JkZXItY29sb3I6IHJnYigyNDkgMTE1IDIyIC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxyXFxuLmZvY3VzXFxcXDpiZy1yZWQtNTAwOmZvY3VzIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMzkgNjggNjggLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5mb2N1c1xcXFw6b3V0bGluZS1ub25lOmZvY3VzIHtcXG4gIG91dGxpbmU6IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIG91dGxpbmUtb2Zmc2V0OiAycHg7XFxufVxcclxcbi5mb2N1c1xcXFw6cmluZy0yOmZvY3VzIHtcXG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiB2YXIoLS10dy1yaW5nLWluc2V0KSAwIDAgMCB2YXIoLS10dy1yaW5nLW9mZnNldC13aWR0aCkgdmFyKC0tdHctcmluZy1vZmZzZXQtY29sb3IpO1xcbiAgLS10dy1yaW5nLXNoYWRvdzogdmFyKC0tdHctcmluZy1pbnNldCkgMCAwIDAgY2FsYygycHggKyB2YXIoLS10dy1yaW5nLW9mZnNldC13aWR0aCkpIHZhcigtLXR3LXJpbmctY29sb3IpO1xcbiAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93KSwgdmFyKC0tdHctcmluZy1zaGFkb3cpLCB2YXIoLS10dy1zaGFkb3csIDAgMCAjMDAwMCk7XFxufVxcclxcbi5mb2N1c1xcXFw6cmluZy1ibHVlLTUwMDpmb2N1cyB7XFxuICAtLXR3LXJpbmctb3BhY2l0eTogMTtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDU5IDEzMCAyNDYgLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXG59XFxyXFxuLmZvY3VzXFxcXDpyaW5nLWJsdWUtNDAwOmZvY3VzIHtcXG4gIC0tdHctcmluZy1vcGFjaXR5OiAxO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoOTYgMTY1IDI1MCAvIHZhcigtLXR3LXJpbmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uZm9jdXNcXFxcOnJpbmctb3JhbmdlLTUwMDpmb2N1cyB7XFxuICAtLXR3LXJpbmctb3BhY2l0eTogMTtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDI0OSAxMTUgMjIgLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXG59XFxyXFxuLmZvY3VzXFxcXDpyaW5nLW9mZnNldC0yOmZvY3VzIHtcXG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDJweDtcXG59XFxyXFxuLmFjdGl2ZVxcXFw6YmcteWVsbG93LTUwMDphY3RpdmUge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIzNCAxNzkgOCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLnBlZXI6Y2hlY2tlZCB+IC5wZWVyLWNoZWNrZWRcXFxcOmJnLWJsdWUtNjAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigzNyA5OSAyMzUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5wZWVyOmNoZWNrZWQgfiAucGVlci1jaGVja2VkXFxcXDp0ZXh0LXdoaXRlIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigyNTUgMjU1IDI1NSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogNjQwcHgpIHtcXG5cXG4gIC5zbVxcXFw6Y29sLXNwYW4tMTAge1xcbiAgICBncmlkLWNvbHVtbjogc3BhbiAxMCAvIHNwYW4gMTA7XFxuICB9XFxuXFxuICAuc21cXFxcOm10LTcge1xcbiAgICBtYXJnaW4tdG9wOiAxLjc1cmVtO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpncmlkIHtcXG4gICAgZGlzcGxheTogZ3JpZDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWF4LXctXFxcXFszODBweFxcXFxdIHtcXG4gICAgbWF4LXdpZHRoOiAzODBweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Z3JpZC1jb2xzLTUge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg1LCBtaW5tYXgoMCwgMWZyKSk7XFxuICB9XFxuXFxuICAuc21cXFxcOmdyaWQtY29scy0xIHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMSwgbWlubWF4KDAsIDFmcikpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpncmlkLWNvbHMtMyB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDMsIG1pbm1heCgwLCAxZnIpKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Z3JpZC1jb2xzLTEwIHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMTAsIG1pbm1heCgwLCAxZnIpKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGwtNSB7XFxuICAgIHBhZGRpbmctbGVmdDogMS4yNXJlbTtcXG4gIH1cXG59XFxyXFxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuXFxuICAubWRcXFxcOmdyaWQtY29scy01IHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoNSwgbWlubWF4KDAsIDFmcikpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpncmlkLWNvbHMtNCB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDQsIG1pbm1heCgwLCAxZnIpKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Z3JpZC1jb2xzLTMge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgzLCBtaW5tYXgoMCwgMWZyKSk7XFxuICB9XFxuXFxuICAubWRcXFxcOmdyaWQtY29scy0yIHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMiwgbWlubWF4KDAsIDFmcikpO1xcbiAgfVxcbn1cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogMTAyNHB4KSB7XFxuXFxuICAubGdcXFxcOmNvbC1zcGFuLTEge1xcbiAgICBncmlkLWNvbHVtbjogc3BhbiAxIC8gc3BhbiAxO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpjb2wtc3Bhbi0xMCB7XFxuICAgIGdyaWQtY29sdW1uOiBzcGFuIDEwIC8gc3BhbiAxMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Y29sLXNwYW4tNSB7XFxuICAgIGdyaWQtY29sdW1uOiBzcGFuIDUgLyBzcGFuIDU7XFxuICB9XFxuXFxuICAubGdcXFxcOmdyaWQtY29scy04IHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoOCwgbWlubWF4KDAsIDFmcikpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpncmlkLWNvbHMtNiB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDYsIG1pbm1heCgwLCAxZnIpKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Z3JpZC1jb2xzLTQge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg0LCBtaW5tYXgoMCwgMWZyKSk7XFxuICB9XFxuXFxuICAubGdcXFxcOmdyaWQtcm93cy01IHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiByZXBlYXQoNSwgbWlubWF4KDAsIDFmcikpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpweC01IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxLjI1cmVtO1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxLjI1cmVtO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpweC0wIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAwcHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDBweDtcXG4gIH1cXG59XFxyXFxuQG1lZGlhIChtaW4td2lkdGg6IDEyODBweCkge1xcblxcbiAgLnhsXFxcXDpncmlkLWNvbHMtNSB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDUsIG1pbm1heCgwLCAxZnIpKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Z3JpZC1jb2xzLTMge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgzLCBtaW5tYXgoMCwgMWZyKSk7XFxuICB9XFxufVxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zdHlsZXMvZ2xvYmFscy5jc3NcIixcIjxubyBzb3VyY2U+XCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBOztDQUFjLENBQWQ7OztDQUFjOztBQUFkOzs7RUFBQSxzQkFBYyxFQUFkLE1BQWM7RUFBZCxlQUFjLEVBQWQsTUFBYztFQUFkLG1CQUFjLEVBQWQsTUFBYztFQUFkLHFCQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztFQUFBLGdCQUFjO0FBQUE7O0FBQWQ7Ozs7O0NBQWM7O0FBQWQ7RUFBQSxnQkFBYyxFQUFkLE1BQWM7RUFBZCw4QkFBYyxFQUFkLE1BQWM7RUFBZCxnQkFBYyxFQUFkLE1BQWM7RUFBZCxjQUFjO0tBQWQsV0FBYyxFQUFkLE1BQWM7RUFBZCw0TkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7RUFBQSxTQUFjLEVBQWQsTUFBYztFQUFkLG9CQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOzs7O0NBQWM7O0FBQWQ7RUFBQSxTQUFjLEVBQWQsTUFBYztFQUFkLGNBQWMsRUFBZCxNQUFjO0VBQWQscUJBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSx5Q0FBYztVQUFkLGlDQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7Ozs7OztFQUFBLGtCQUFjO0VBQWQsb0JBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGNBQWM7RUFBZCx3QkFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLG1CQUFjO0FBQUE7O0FBQWQ7OztDQUFjOztBQUFkOzs7O0VBQUEsK0dBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGNBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDs7RUFBQSxjQUFjO0VBQWQsY0FBYztFQUFkLGtCQUFjO0VBQWQsd0JBQWM7QUFBQTs7QUFBZDtFQUFBLGVBQWM7QUFBQTs7QUFBZDtFQUFBLFdBQWM7QUFBQTs7QUFBZDs7OztDQUFjOztBQUFkO0VBQUEsY0FBYyxFQUFkLE1BQWM7RUFBZCxxQkFBYyxFQUFkLE1BQWM7RUFBZCx5QkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7OztDQUFjOztBQUFkOzs7OztFQUFBLG9CQUFjLEVBQWQsTUFBYztFQUFkLGVBQWMsRUFBZCxNQUFjO0VBQWQsb0JBQWMsRUFBZCxNQUFjO0VBQWQsb0JBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYyxFQUFkLE1BQWM7RUFBZCxTQUFjLEVBQWQsTUFBYztFQUFkLFVBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7O0VBQUEsb0JBQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7Ozs7RUFBQSwwQkFBYyxFQUFkLE1BQWM7RUFBZCw2QkFBYyxFQUFkLE1BQWM7RUFBZCxzQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGFBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGdCQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSx3QkFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLFlBQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7RUFBQSw2QkFBYyxFQUFkLE1BQWM7RUFBZCxvQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLHdCQUFjO0FBQUE7O0FBQWQ7OztDQUFjOztBQUFkO0VBQUEsMEJBQWMsRUFBZCxNQUFjO0VBQWQsYUFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGtCQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7Ozs7Ozs7Ozs7Ozs7RUFBQSxTQUFjO0FBQUE7O0FBQWQ7RUFBQSxTQUFjO0VBQWQsVUFBYztBQUFBOztBQUFkO0VBQUEsVUFBYztBQUFBOztBQUFkOzs7RUFBQSxnQkFBYztFQUFkLFNBQWM7RUFBZCxVQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSxnQkFBYztBQUFBOztBQUFkOzs7Q0FBYzs7QUFBZDtFQUFBLFVBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7RUFBQSxVQUFjLEVBQWQsTUFBYztFQUFkLGNBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7O0VBQUEsZUFBYztBQUFBOztBQUFkOztDQUFjO0FBQWQ7RUFBQSxlQUFjO0FBQUE7O0FBQWQ7Ozs7Q0FBYzs7QUFBZDs7Ozs7Ozs7RUFBQSxjQUFjLEVBQWQsTUFBYztFQUFkLHNCQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLGVBQWM7RUFBZCxZQUFjO0FBQUE7O0FBQWQ7RUFBQSx3QkFBYztFQUFkLHdCQUFjO0VBQWQsbUJBQWM7RUFBZCxtQkFBYztFQUFkLGNBQWM7RUFBZCxjQUFjO0VBQWQsY0FBYztFQUFkLGVBQWM7RUFBZCxlQUFjO0VBQWQsYUFBYztFQUFkLGFBQWM7RUFBZCxrQkFBYztFQUFkLHNDQUFjO0VBQWQsZUFBYztFQUFkLG9CQUFjO0VBQWQsc0JBQWM7RUFBZCx1QkFBYztFQUFkLHdCQUFjO0VBQWQsa0JBQWM7RUFBZCwyQkFBYztFQUFkLDRCQUFjO0VBQWQsc0NBQWM7RUFBZCxrQ0FBYztFQUFkLDJCQUFjO0VBQWQsc0JBQWM7RUFBZCw4QkFBYztFQUFkLFlBQWM7RUFBZCxrQkFBYztFQUFkLGdCQUFjO0VBQWQsaUJBQWM7RUFBZCxrQkFBYztFQUFkLGNBQWM7RUFBZCxnQkFBYztFQUFkLGFBQWM7RUFBZCxtQkFBYztFQUFkLHFCQUFjO0VBQWQsMkJBQWM7RUFBZCx5QkFBYztFQUFkLDBCQUFjO0VBQWQsMkJBQWM7RUFBZCx1QkFBYztFQUFkLHdCQUFjO0VBQWQseUJBQWM7RUFBZDtBQUFjOztBQUFkO0VBQUEsd0JBQWM7RUFBZCx3QkFBYztFQUFkLG1CQUFjO0VBQWQsbUJBQWM7RUFBZCxjQUFjO0VBQWQsY0FBYztFQUFkLGNBQWM7RUFBZCxlQUFjO0VBQWQsZUFBYztFQUFkLGFBQWM7RUFBZCxhQUFjO0VBQWQsa0JBQWM7RUFBZCxzQ0FBYztFQUFkLGVBQWM7RUFBZCxvQkFBYztFQUFkLHNCQUFjO0VBQWQsdUJBQWM7RUFBZCx3QkFBYztFQUFkLGtCQUFjO0VBQWQsMkJBQWM7RUFBZCw0QkFBYztFQUFkLHNDQUFjO0VBQWQsa0NBQWM7RUFBZCwyQkFBYztFQUFkLHNCQUFjO0VBQWQsOEJBQWM7RUFBZCxZQUFjO0VBQWQsa0JBQWM7RUFBZCxnQkFBYztFQUFkLGlCQUFjO0VBQWQsa0JBQWM7RUFBZCxjQUFjO0VBQWQsZ0JBQWM7RUFBZCxhQUFjO0VBQWQsbUJBQWM7RUFBZCxxQkFBYztFQUFkLDJCQUFjO0VBQWQseUJBQWM7RUFBZCwwQkFBYztFQUFkLDJCQUFjO0VBQWQsdUJBQWM7RUFBZCx3QkFBYztFQUFkLHlCQUFjO0VBQWQ7QUFBYztBQUVkO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxnQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsd0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHdCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsNEJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEseUJBQW1CO0tBQW5CLHNCQUFtQjtVQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHdCQUFtQjtLQUFuQixxQkFBbUI7VUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQiw0REFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkIsdURBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CLHNEQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQix1REFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkIsb0RBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLGdDQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDJCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEscUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEscUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsZ0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsZUFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSwyQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSwyQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLDBDQUFtQjtFQUFuQix1REFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxnRkFBbUI7RUFBbkIsb0dBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsMkdBQW1CO0VBQW5CLHlHQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLGdLQUFtQjtFQUFuQix3SkFBbUI7RUFBbkIsaUxBQW1CO0VBQW5CLHdEQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHdCQUFtQjtFQUFuQix3REFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBRm5CO0VBQUE7Q0NBQTtBREFBO0VBQUEsbUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQTtDQ0FBO0FEQUE7RUFBQSx1QkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHVCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEsdUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxtQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLG1CQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEsbUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxtQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLG1CQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEscUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxxQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHFCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEscUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxxQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHFCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUE7Q0NBQTtBREFBO0VBQUEsdUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSx1QkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLG1CQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEsK0JDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSw0R0NBQTtFREFBLDBHQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUEscUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxxQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHFCQ0FBO0VEQUE7Q0NBQTtBREFBO0VBQUE7Q0NBQTtBREFBO0VBQUEsbUJDQUE7RURBQTtDQ0FBO0FEQUE7RUFBQSxtQkNBQTtFREFBO0NDQUE7QURBQTtFQUFBLHFCQ0FBO0VEQUE7Q0NBQTtBREFBOztFQUFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBO0NBQUE7QURBQTs7RUFBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7Q0FBQTtBREFBOztFQUFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTs7RURBQTtJQUFBLHNCQ0FBO0lEQUE7R0NBQTs7RURBQTtJQUFBLGtCQ0FBO0lEQUE7R0NBQTtDQUFBO0FEQUE7O0VBQUE7SUFBQTtHQ0FBOztFREFBO0lBQUE7R0NBQTtDQUFBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIkB0YWlsd2luZCBiYXNlO1xcclxcbkB0YWlsd2luZCBjb21wb25lbnRzO1xcclxcbkB0YWlsd2luZCB1dGlsaXRpZXM7XFxyXFxuXCIsbnVsbF0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app! ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"./pages/_app.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1wcml2YXRlLW5leHQtcGFnZXMlMkZfYXBwJnBhZ2U9JTJGX2FwcCEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxpREFBeUI7QUFDaEQ7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzY3ODIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHBcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL19hcHBcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!\n"));

/***/ }),

/***/ "./public/fdb_logo.png":
/*!*****************************!*\
  !*** ./public/fdb_logo.png ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/fdb_logo.a5ea18a4.png\",\"height\":143,\"width\":173,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ffdb_logo.a5ea18a4.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":7});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wdWJsaWMvZmRiX2xvZ28ucG5nLmpzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLG9NQUFvTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvZmRiX2xvZ28ucG5nPzZlMjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1wic3JjXCI6XCIvX25leHQvc3RhdGljL21lZGlhL2ZkYl9sb2dvLmE1ZWExOGE0LnBuZ1wiLFwiaGVpZ2h0XCI6MTQzLFwid2lkdGhcIjoxNzMsXCJibHVyRGF0YVVSTFwiOlwiL19uZXh0L2ltYWdlP3VybD0lMkZfbmV4dCUyRnN0YXRpYyUyRm1lZGlhJTJGZmRiX2xvZ28uYTVlYTE4YTQucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjd9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./public/fdb_logo.png\n"));

/***/ }),

/***/ "./styles/globals.css":
/*!****************************!*\
  !*** ./styles/globals.css ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvZ2xvYmFscy5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLG9OQUF3RztBQUMxSCwwQkFBMEIsbUJBQU8sQ0FBQyx1ZUFBK087O0FBRWpSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZCx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpQkFBaUI7QUFDckIsTUFBTSx1ZUFBK087QUFDclA7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyx1ZUFBK087O0FBRXpROztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9nbG9iYWxzLmNzcz9jOTgzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls4XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzhdLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBzdHlsZS1sb2FkZXIgaW5qZWN0cyBDU1MgaW50byB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIDxoZWFkPi4gVGhpcyBjYXVzZXMgb3JkZXJpbmcgcHJvYmxlbXMgYmV0d2VlbiBkZXZcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb2QuIFRvIGZpeCB0aGlzLCB3ZSByZW5kZXIgYSA8bm9zY3JpcHQ+IHRhZyBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBhbmNob3IgZm9yIHRoZSBzdHlsZXMgdG8gYmUgcGxhY2VkIGJlZm9yZS4gVGhlc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBfYmVmb3JlXyA8c3R5bGUganN4IGdsb2JhbD4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNfX25leHRfY3NzX19ET19OT1RfVVNFX19cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls4XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzhdLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls4XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzhdLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nconst isOldIE = function isOldIE() {\n    let memo;\n    return function memorize() {\n        if (typeof memo === \"undefined\") {\n            // Test for IE <= 9 as proposed by Browserhacks\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n            // Tests for existence of standard globals is to allow style-loader\n            // to operate correctly into non-standard environments\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\n            memo = Boolean(window && document && document.all && !window.atob);\n        }\n        return memo;\n    };\n}();\nconst getTarget = function getTarget() {\n    const memo = {};\n    return function memorize(target) {\n        if (typeof memo[target] === \"undefined\") {\n            let styleTarget = document.querySelector(target);\n            // Special case to return head of iframe instead of iframe itself\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n                try {\n                    // This will throw an exception if access to iframe is blocked\n                    // due to cross-origin restrictions\n                    styleTarget = styleTarget.contentDocument.head;\n                } catch (e) {\n                    // istanbul ignore next\n                    styleTarget = null;\n                }\n            }\n            memo[target] = styleTarget;\n        }\n        return memo[target];\n    };\n}();\nconst stylesInDom = [];\nfunction getIndexByIdentifier(identifier) {\n    let result = -1;\n    for(let i = 0; i < stylesInDom.length; i++){\n        if (stylesInDom[i].identifier === identifier) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\nfunction modulesToDom(list, options) {\n    const idCountMap = {};\n    const identifiers = [];\n    for(let i = 0; i < list.length; i++){\n        const item = list[i];\n        const id = options.base ? item[0] + options.base : item[0];\n        const count = idCountMap[id] || 0;\n        const identifier = id + \" \" + count.toString();\n        idCountMap[id] = count + 1;\n        const index = getIndexByIdentifier(identifier);\n        const obj = {\n            css: item[1],\n            media: item[2],\n            sourceMap: item[3]\n        };\n        if (index !== -1) {\n            stylesInDom[index].references++;\n            stylesInDom[index].updater(obj);\n        } else {\n            stylesInDom.push({\n                identifier: identifier,\n                updater: addStyle(obj, options),\n                references: 1\n            });\n        }\n        identifiers.push(identifier);\n    }\n    return identifiers;\n}\nfunction insertStyleElement(options) {\n    const style = document.createElement(\"style\");\n    const attributes = options.attributes || {};\n    if (typeof attributes.nonce === \"undefined\") {\n        const nonce = // eslint-disable-next-line no-undef\n         true ? __webpack_require__.nc : 0;\n        if (nonce) {\n            attributes.nonce = nonce;\n        }\n    }\n    Object.keys(attributes).forEach(function(key) {\n        style.setAttribute(key, attributes[key]);\n    });\n    if (typeof options.insert === \"function\") {\n        options.insert(style);\n    } else {\n        const target = getTarget(options.insert || \"head\");\n        if (!target) {\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        }\n        target.appendChild(style);\n    }\n    return style;\n}\nfunction removeStyleElement(style) {\n    // istanbul ignore if\n    if (style.parentNode === null) {\n        return false;\n    }\n    style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */ const replaceText = function replaceText() {\n    const textStore = [];\n    return function replace(index, replacement) {\n        textStore[index] = replacement;\n        return textStore.filter(Boolean).join(\"\\n\");\n    };\n}();\nfunction applyToSingletonTag(style, index, remove, obj) {\n    const css = remove ? \"\" : obj.media ? \"@media \" + obj.media + \" {\" + obj.css + \"}\" : obj.css;\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = replaceText(index, css);\n    } else {\n        const cssNode = document.createTextNode(css);\n        const childNodes = style.childNodes;\n        if (childNodes[index]) {\n            style.removeChild(childNodes[index]);\n        }\n        if (childNodes.length) {\n            style.insertBefore(cssNode, childNodes[index]);\n        } else {\n            style.appendChild(cssNode);\n        }\n    }\n}\nfunction applyToTag(style, options, obj) {\n    let css = obj.css;\n    const media = obj.media;\n    const sourceMap = obj.sourceMap;\n    if (media) {\n        style.setAttribute(\"media\", media);\n    } else {\n        style.removeAttribute(\"media\");\n    }\n    if (sourceMap && typeof btoa !== \"undefined\") {\n        css += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n    }\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        while(style.firstChild){\n            style.removeChild(style.firstChild);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n}\nlet singleton = null;\nlet singletonCounter = 0;\nfunction addStyle(obj, options) {\n    let style;\n    let update;\n    let remove;\n    if (options.singleton) {\n        const styleIndex = singletonCounter++;\n        style = singleton || (singleton = insertStyleElement(options));\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n    } else {\n        style = insertStyleElement(options);\n        update = applyToTag.bind(null, style, options);\n        remove = function() {\n            removeStyleElement(style);\n        };\n    }\n    update(obj);\n    return function updateStyle(newObj) {\n        if (newObj) {\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n                return;\n            }\n            update(obj = newObj);\n        } else {\n            remove();\n        }\n    };\n}\nmodule.exports = function(list, options) {\n    options = options || {};\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n    // tags it will allow on a page\n    if (!options.singleton && typeof options.singleton !== \"boolean\") {\n        options.singleton = isOldIE();\n    }\n    list = list || [];\n    let lastIdentifiers = modulesToDom(list, options);\n    return function update(newList) {\n        newList = newList || [];\n        if (Object.prototype.toString.call(newList) !== \"[object Array]\") {\n            return;\n        }\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            stylesInDom[index].references--;\n        }\n        const newLastIdentifiers = modulesToDom(newList, options);\n        for(let i1 = 0; i1 < lastIdentifiers.length; i1++){\n            const identifier = lastIdentifiers[i1];\n            const index = getIndexByIdentifier(identifier);\n            if (stylesInDom[index].references === 0) {\n                stylesInDom[index].updater();\n                stylesInDom.splice(index, 1);\n            }\n        }\n        lastIdentifiers = newLastIdentifiers;\n    };\n};\n\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUVBQXFFLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yNmVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gICAgbGV0IG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgICAgICBpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAgICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAgICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG59KCk7XG5jb25zdCBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gICAgY29uc3QgbWVtbyA9IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG4gICAgICAgICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICAgIH07XG59KCk7XG5jb25zdCBzdHlsZXNJbkRvbSA9IFtdO1xuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICAgIGxldCByZXN1bHQgPSAtMTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGlkQ291bnRNYXAgPSB7fTtcbiAgICBjb25zdCBpZGVudGlmaWVycyA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgIGNvbnN0IGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgICAgIGNvbnN0IGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGlkICsgXCIgXCIgKyBjb3VudC50b1N0cmluZygpO1xuICAgICAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3Qgb2JqID0ge1xuICAgICAgICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICAgICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBub25jZSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQob3B0aW9ucy5pbnNlcnQgfHwgXCJoZWFkXCIpO1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG59XG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovIGNvbnN0IHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gICAgY29uc3QgdGV4dFN0b3JlID0gW107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKTtcbiAgICB9O1xufSgpO1xuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gICAgY29uc3QgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiICsgb2JqLm1lZGlhICsgXCIge1wiICsgb2JqLmNzcyArIFwifVwiIDogb2JqLmNzcztcbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG4gICAgICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gICAgbGV0IGNzcyA9IG9iai5jc3M7XG4gICAgY29uc3QgbWVkaWEgPSBvYmoubWVkaWE7XG4gICAgY29uc3Qgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpO1xuICAgIH1cbiAgICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcbiAgICB9XG4gICAgLy8gRm9yIG9sZCBJRVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpe1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgfVxufVxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5sZXQgc2luZ2xldG9uQ291bnRlciA9IDA7XG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgICBsZXQgc3R5bGU7XG4gICAgbGV0IHVwZGF0ZTtcbiAgICBsZXQgcmVtb3ZlO1xuICAgIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgICAgICBjb25zdCBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgICAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgICAgIHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlKG9iaik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgICAgICBpZiAobmV3T2JqKSB7XG4gICAgICAgICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG4gICAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICAgIH1cbiAgICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgICBsZXQgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgICAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuICAgICAgICBmb3IobGV0IGkxID0gMDsgaTEgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpMSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaTFdO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIGlmIChzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKCk7XG4gICAgICAgICAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gICAgfTtcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n"));

/***/ }),

/***/ "./components/footer.tsx":
/*!*******************************!*\
  !*** ./components/footer.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Footer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction Footer() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"footer\", {\n        className: \" mt-10 px-10 text-center absolute bottom-0 h-[60px] w-full \",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: \"Copyright \\xa9 Sagan Jung 2022. All rights reserved.\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\footer.tsx\",\n                lineNumber: 4,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: \"contact - mk44879@gmail.com\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\footer.tsx\",\n                lineNumber: 5,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\footer.tsx\",\n        lineNumber: 3,\n        columnNumber: 5\n    }, this);\n}\n_c = Footer;\nvar _c;\n$RefreshReg$(_c, \"Footer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL2Zvb3Rlci50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFBZSxTQUFTQSxNQUFNLEdBQUc7SUFDL0IscUJBQ0UsOERBQUNDLFFBQU07UUFBQ0MsU0FBUyxFQUFDLDZEQUE2RDs7MEJBQzdFLDhEQUFDQyxHQUFDOzBCQUFDLHNEQUFpRDs7Ozs7b0JBQUk7MEJBQ3hELDhEQUFDQSxHQUFDOzBCQUFDLDZCQUEyQjs7Ozs7b0JBQUk7Ozs7OztZQUMzQixDQUNUO0FBQ0osQ0FBQztBQVB1QkgsS0FBQUEsTUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2Zvb3Rlci50c3g/ZTNhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGb290ZXIoKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxmb290ZXIgY2xhc3NOYW1lPVwiIG10LTEwIHB4LTEwIHRleHQtY2VudGVyIGFic29sdXRlIGJvdHRvbS0wIGgtWzYwcHhdIHctZnVsbCBcIj5cclxuICAgICAgPHA+Q29weXJpZ2h0IMKpIFNhZ2FuIEp1bmcgMjAyMi4gQWxsIHJpZ2h0cyByZXNlcnZlZC48L3A+XHJcbiAgICAgIDxwPmNvbnRhY3QgLSBtazQ0ODc5QGdtYWlsLmNvbTwvcD5cclxuICAgIDwvZm9vdGVyPlxyXG4gICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbIkZvb3RlciIsImZvb3RlciIsImNsYXNzTmFtZSIsInAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/footer.tsx\n"));

/***/ }),

/***/ "./components/gnb.tsx":
/*!****************************!*\
  !*** ./components/gnb.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Gnb; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next-auth/react */ \"./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _libs_client_useUser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libs/client/useUser */ \"./libs/client/useUser.tsx\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _public_fdb_logo_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../public/fdb_logo.png */ \"./public/fdb_logo.png\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction Gnb() {\n    _s();\n    var ref = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_2__.useSession)(), nextSession = ref.data;\n    var ref1 = (0,_libs_client_useUser__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(), user = ref1.user, isLoading = ref1.isLoading;\n    var _image, _id;\n    // const { data: CredentailSession } = useSWR(\"/api/users/me\");\n    // console.log(user);\n    // console.log(nextSession);\n    // useEffect(() => {\n    //   if (data && !data.ok) {\n    //     router.replace(\"/enter\");\n    //   }\n    // }, [data, router]);\n    // console.log(data);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n        className: \"flex bg-blue-200 fixed top-0 w-full py-2 z-20\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n            className: \"flex w-full justify-between items-center\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                    className: \"flex uppercase font-bold \",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \" ml-3 mr-3 cursor-pointer\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                className: \" \",\n                                href: \"/\",\n                                passHref: true,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    className: \" flex items-center \",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_4___default()), {\n                                        className: \" rounded-xl border-blue-800 border-4 border-solid\",\n                                        src: _public_fdb_logo_png__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n                                        width: 26,\n                                        height: 26\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                                        lineNumber: 26,\n                                        columnNumber: 17\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                                    lineNumber: 25,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                                lineNumber: 24,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                            lineNumber: 23,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"mr-3\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                href: \"/fictions/all/all/all/1/all\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    children: \"\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                                    lineNumber: 37,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                                lineNumber: 36,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                            lineNumber: 35,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"mr-3\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                href: \"/authors/1\",\n                                passHref: true,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    children: \"\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                                    lineNumber: 42,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                                lineNumber: 41,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                            lineNumber: 40,\n                            columnNumber: 11\n                        }, this),\n                        user ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"mr-3\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                href: \"/fictions/create\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    children: \"Create\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                                    lineNumber: 51,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                                lineNumber: 50,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                            lineNumber: 49,\n                            columnNumber: 13\n                        }, this) : null\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                    lineNumber: 22,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                    className: \" flex font-bold items-center\",\n                    children: [\n                        user ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"mr-3\",\n                            children: \"Admin\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                            lineNumber: 57,\n                            columnNumber: 19\n                        }, this) : null,\n                        nextSession ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \" mr-3 p-0 flex items-center cursor-pointer min-w-[26px]\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                className: \" rounded-full\",\n                                href: \"/profile\",\n                                passHref: true,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    className: \" flex items-center\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_4___default()), {\n                                        className: \" rounded-full\",\n                                        src: (_image = nextSession.user.image) !== null && _image !== void 0 ? _image : \"\",\n                                        width: 26,\n                                        height: 26,\n                                        alt: (_id = nextSession.user.id) !== null && _id !== void 0 ? _id : \"\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                                        lineNumber: 62,\n                                        columnNumber: 19\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                                    lineNumber: 61,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                                lineNumber: 60,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                            lineNumber: 59,\n                            columnNumber: 13\n                        }, this) : null,\n                        nextSession ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            className: \" mr-5 font-bold\",\n                            onClick: function() {\n                                return (0,next_auth_react__WEBPACK_IMPORTED_MODULE_2__.signOut)();\n                            },\n                            children: \"Sign out\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                            lineNumber: 74,\n                            columnNumber: 13\n                        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                href: \"/enter\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    className: \" mr-5 hover:cursor-pointer\",\n                                    children: \"Enter\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                                    lineNumber: 80,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                                lineNumber: 79,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                            lineNumber: 78,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n                    lineNumber: 56,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n            lineNumber: 21,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\gnb.tsx\",\n        lineNumber: 20,\n        columnNumber: 5\n    }, this);\n}\n_s(Gnb, \"hok5D1BpjBZA3UVuT/spEw5bbE0=\", false, function() {\n    return [\n        next_auth_react__WEBPACK_IMPORTED_MODULE_2__.useSession,\n        _libs_client_useUser__WEBPACK_IMPORTED_MODULE_3__[\"default\"]\n    ];\n});\n_c = Gnb;\nvar _c;\n$RefreshReg$(_c, \"Gnb\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL2duYi50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFBNkI7QUFDaUM7QUFDbkI7QUFDWjtBQUNXO0FBRTNCLFNBQVNNLEdBQUcsR0FBRzs7SUFDNUIsSUFBOEJMLEdBQVksR0FBWkEsMkRBQVUsRUFBRSxFQUFsQ00sV0FBaUIsR0FBS04sR0FBWSxDQUFsQ00sSUFBSTtJQUNaLElBQTRCSixJQUFTLEdBQVRBLGdFQUFPLEVBQUUsRUFBN0JNLElBQUksR0FBZ0JOLElBQVMsQ0FBN0JNLElBQUksRUFBRUMsU0FBUyxHQUFLUCxJQUFTLENBQXZCTyxTQUFTO1FBdURBRixNQUF1QixFQUd2QkEsR0FBb0I7SUF6RDNDLCtEQUErRDtJQUMvRCxxQkFBcUI7SUFDckIsNEJBQTRCO0lBQzVCLG9CQUFvQjtJQUNwQiw0QkFBNEI7SUFDNUIsZ0NBQWdDO0lBQ2hDLE1BQU07SUFDTixzQkFBc0I7SUFDdEIscUJBQXFCO0lBQ3JCLHFCQUNFLDhEQUFDRyxRQUFNO1FBQUNDLFNBQVMsRUFBQywrQ0FBK0M7a0JBQy9ELDRFQUFDQyxLQUFHO1lBQUNELFNBQVMsRUFBQywwQ0FBMEM7OzhCQUN2RCw4REFBQ0UsSUFBRTtvQkFBQ0YsU0FBUyxFQUFDLDJCQUEyQjs7c0NBQ3ZDLDhEQUFDRyxJQUFFOzRCQUFDSCxTQUFTLEVBQUMsMkJBQTJCO3NDQUN2Qyw0RUFBQ1osa0RBQUk7Z0NBQUNZLFNBQVMsRUFBQyxHQUFHO2dDQUFDSSxJQUFJLEVBQUMsR0FBRztnQ0FBQ0MsUUFBUTswQ0FDbkMsNEVBQUNDLEdBQUM7b0NBQUNOLFNBQVMsRUFBQyxxQkFBcUI7OENBQ2hDLDRFQUFDUixtREFBSzt3Q0FDSlEsU0FBUyxFQUFDLG1EQUFtRDt3Q0FDN0RPLEdBQUcsRUFBRWQsNERBQUk7d0NBQ1RlLEtBQUssRUFBRSxFQUFFO3dDQUNUQyxNQUFNLEVBQUUsRUFBRTs7Ozs7NENBQ0g7Ozs7O3dDQUNQOzs7OztvQ0FDQzs7Ozs7Z0NBQ0o7c0NBQ0wsOERBQUNOLElBQUU7NEJBQUNILFNBQVMsRUFBQyxNQUFNO3NDQUNsQiw0RUFBQ1osa0RBQUk7Z0NBQUNnQixJQUFJLEVBQUMsNkJBQTZCOzBDQUN0Qyw0RUFBQ0UsR0FBQzs4Q0FBQyxJQUFFOzs7Ozt3Q0FBSTs7Ozs7b0NBQ0o7Ozs7O2dDQUNKO3NDQUNMLDhEQUFDSCxJQUFFOzRCQUFDSCxTQUFTLEVBQUMsTUFBTTtzQ0FDbEIsNEVBQUNaLGtEQUFJO2dDQUFDZ0IsSUFBSSxFQUFDLFlBQVk7Z0NBQUNDLFFBQVE7MENBQzlCLDRFQUFDQyxHQUFDOzhDQUFDLElBQUU7Ozs7O3dDQUFJOzs7OztvQ0FDSjs7Ozs7Z0NBQ0o7d0JBSUpULElBQUksaUJBQ0gsOERBQUNNLElBQUU7NEJBQUNILFNBQVMsRUFBQyxNQUFNO3NDQUNsQiw0RUFBQ1osa0RBQUk7Z0NBQUNnQixJQUFJLEVBQUMsa0JBQWtCOzBDQUMzQiw0RUFBQ0UsR0FBQzs4Q0FBQyxRQUFNOzs7Ozt3Q0FBSTs7Ozs7b0NBQ1I7Ozs7O2dDQUNKLEdBQ0gsSUFBSTs7Ozs7O3dCQUNMOzhCQUNMLDhEQUFDSixJQUFFO29CQUFDRixTQUFTLEVBQUMsOEJBQThCOzt3QkFDekNILElBQUksaUJBQUcsOERBQUNNLElBQUU7NEJBQUNILFNBQVMsRUFBQyxNQUFNO3NDQUFDLE9BQUs7Ozs7O2dDQUFLLEdBQUcsSUFBSTt3QkFDN0NKLFdBQVcsaUJBQ1YsOERBQUNPLElBQUU7NEJBQUNILFNBQVMsRUFBQyx5REFBeUQ7c0NBQ3JFLDRFQUFDWixrREFBSTtnQ0FBQ1ksU0FBUyxFQUFDLGVBQWU7Z0NBQUNJLElBQUksRUFBQyxVQUFVO2dDQUFDQyxRQUFROzBDQUN0RCw0RUFBQ0MsR0FBQztvQ0FBQ04sU0FBUyxFQUFDLG9CQUFvQjs4Q0FDL0IsNEVBQUNSLG1EQUFLO3dDQUNKUSxTQUFTLEVBQUMsZUFBZTt3Q0FDekJPLEdBQUcsRUFBRVgsQ0FBQUEsTUFBdUIsR0FBdkJBLFdBQVcsQ0FBQ0MsSUFBSSxDQUFFYSxLQUFLLGNBQXZCZCxNQUF1QixjQUF2QkEsTUFBdUIsR0FBSSxFQUFFO3dDQUNsQ1ksS0FBSyxFQUFFLEVBQUU7d0NBQ1RDLE1BQU0sRUFBRSxFQUFFO3dDQUNWRSxHQUFHLEVBQUVmLENBQUFBLEdBQW9CLEdBQXBCQSxXQUFXLENBQUNDLElBQUksQ0FBRWUsRUFBRSxjQUFwQmhCLEdBQW9CLGNBQXBCQSxHQUFvQixHQUFJLEVBQUU7Ozs7OzRDQUN4Qjs7Ozs7d0NBQ1A7Ozs7O29DQUNDOzs7OztnQ0FDSixHQUNILElBQUk7d0JBQ1BBLFdBQVcsaUJBQ1YsOERBQUNpQixRQUFNOzRCQUFDYixTQUFTLEVBQUMsaUJBQWlCOzRCQUFDYyxPQUFPLEVBQUU7dUNBQU14Qix3REFBTyxFQUFFOzZCQUFBO3NDQUFFLFVBRTlEOzs7OztnQ0FBUyxpQkFFVCw4REFBQ2EsSUFBRTtzQ0FDRCw0RUFBQ2Ysa0RBQUk7Z0NBQUNnQixJQUFJLEVBQUMsUUFBUTswQ0FDakIsNEVBQUNFLEdBQUM7b0NBQUNOLFNBQVMsRUFBQyw0QkFBNEI7OENBQUMsT0FBSzs7Ozs7d0NBQUk7Ozs7O29DQUM5Qzs7Ozs7Z0NBQ0o7Ozs7Ozt3QkFFSjs7Ozs7O2dCQUNEOzs7OztZQUNDLENBQ1Q7QUFDSixDQUFDO0dBakZ1Qk4sR0FBRzs7UUFDS0wsdURBQVU7UUFDWkUsNERBQU87OztBQUZiRyxLQUFBQSxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvZ25iLnRzeD8wOWY3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMaW5rIGZyb20gXCJuZXh0L2xpbmtcIjtcclxuaW1wb3J0IHsgdXNlU2Vzc2lvbiwgc2lnbkluLCBzaWduT3V0IH0gZnJvbSBcIm5leHQtYXV0aC9yZWFjdFwiO1xyXG5pbXBvcnQgdXNlVXNlciBmcm9tIFwiQGxpYnMvY2xpZW50L3VzZVVzZXJcIjtcclxuaW1wb3J0IEltYWdlIGZyb20gXCJuZXh0L2ltYWdlXCI7XHJcbmltcG9ydCBsb2dvIGZyb20gXCIuLi9wdWJsaWMvZmRiX2xvZ28ucG5nXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBHbmIoKSB7XHJcbiAgY29uc3QgeyBkYXRhOiBuZXh0U2Vzc2lvbiB9ID0gdXNlU2Vzc2lvbigpO1xyXG4gIGNvbnN0IHsgdXNlciwgaXNMb2FkaW5nIH0gPSB1c2VVc2VyKCk7XHJcbiAgLy8gY29uc3QgeyBkYXRhOiBDcmVkZW50YWlsU2Vzc2lvbiB9ID0gdXNlU1dSKFwiL2FwaS91c2Vycy9tZVwiKTtcclxuICAvLyBjb25zb2xlLmxvZyh1c2VyKTtcclxuICAvLyBjb25zb2xlLmxvZyhuZXh0U2Vzc2lvbik7XHJcbiAgLy8gdXNlRWZmZWN0KCgpID0+IHtcclxuICAvLyAgIGlmIChkYXRhICYmICFkYXRhLm9rKSB7XHJcbiAgLy8gICAgIHJvdXRlci5yZXBsYWNlKFwiL2VudGVyXCIpO1xyXG4gIC8vICAgfVxyXG4gIC8vIH0sIFtkYXRhLCByb3V0ZXJdKTtcclxuICAvLyBjb25zb2xlLmxvZyhkYXRhKTtcclxuICByZXR1cm4gKFxyXG4gICAgPGhlYWRlciBjbGFzc05hbWU9XCJmbGV4IGJnLWJsdWUtMjAwIGZpeGVkIHRvcC0wIHctZnVsbCBweS0yIHotMjBcIj5cclxuICAgICAgPG5hdiBjbGFzc05hbWU9XCJmbGV4IHctZnVsbCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyXCI+XHJcbiAgICAgICAgPHVsIGNsYXNzTmFtZT1cImZsZXggdXBwZXJjYXNlIGZvbnQtYm9sZCBcIj5cclxuICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCIgbWwtMyBtci0zIGN1cnNvci1wb2ludGVyXCI+XHJcbiAgICAgICAgICAgIDxMaW5rIGNsYXNzTmFtZT1cIiBcIiBocmVmPVwiL1wiIHBhc3NIcmVmPlxyXG4gICAgICAgICAgICAgIDxhIGNsYXNzTmFtZT1cIiBmbGV4IGl0ZW1zLWNlbnRlciBcIj5cclxuICAgICAgICAgICAgICAgIDxJbWFnZVxyXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCIgcm91bmRlZC14bCBib3JkZXItYmx1ZS04MDAgYm9yZGVyLTQgYm9yZGVyLXNvbGlkXCJcclxuICAgICAgICAgICAgICAgICAgc3JjPXtsb2dvfVxyXG4gICAgICAgICAgICAgICAgICB3aWR0aD17MjZ9XHJcbiAgICAgICAgICAgICAgICAgIGhlaWdodD17MjZ9XHJcbiAgICAgICAgICAgICAgICA+PC9JbWFnZT5cclxuICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibXItM1wiPlxyXG4gICAgICAgICAgICA8TGluayBocmVmPVwiL2ZpY3Rpb25zL2FsbC9hbGwvYWxsLzEvYWxsXCI+XHJcbiAgICAgICAgICAgICAgPGE+7J6R7ZKIPC9hPlxyXG4gICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm1yLTNcIj5cclxuICAgICAgICAgICAgPExpbmsgaHJlZj1cIi9hdXRob3JzLzFcIiBwYXNzSHJlZj5cclxuICAgICAgICAgICAgICA8YT7snpHqsIA8L2E+XHJcbiAgICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICB7LyogPExpbmsgaHJlZj1cIi9yYW5raW5nXCI+XHJcbiAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJtci0zXCI+UmFua2luZzwvbGk+XHJcbiAgICAgICAgICA8L0xpbms+ICovfVxyXG4gICAgICAgICAge3VzZXIgPyAoXHJcbiAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJtci0zXCI+XHJcbiAgICAgICAgICAgICAgPExpbmsgaHJlZj1cIi9maWN0aW9ucy9jcmVhdGVcIj5cclxuICAgICAgICAgICAgICAgIDxhPkNyZWF0ZTwvYT5cclxuICAgICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICApIDogbnVsbH1cclxuICAgICAgICA8L3VsPlxyXG4gICAgICAgIDx1bCBjbGFzc05hbWU9XCIgZmxleCBmb250LWJvbGQgaXRlbXMtY2VudGVyXCI+XHJcbiAgICAgICAgICB7dXNlciA/IDxsaSBjbGFzc05hbWU9XCJtci0zXCI+QWRtaW48L2xpPiA6IG51bGx9XHJcbiAgICAgICAgICB7bmV4dFNlc3Npb24gPyAoXHJcbiAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCIgbXItMyBwLTAgZmxleCBpdGVtcy1jZW50ZXIgY3Vyc29yLXBvaW50ZXIgbWluLXctWzI2cHhdXCI+XHJcbiAgICAgICAgICAgICAgPExpbmsgY2xhc3NOYW1lPVwiIHJvdW5kZWQtZnVsbFwiIGhyZWY9XCIvcHJvZmlsZVwiIHBhc3NIcmVmPlxyXG4gICAgICAgICAgICAgICAgPGEgY2xhc3NOYW1lPVwiIGZsZXggaXRlbXMtY2VudGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxJbWFnZVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIiByb3VuZGVkLWZ1bGxcIlxyXG4gICAgICAgICAgICAgICAgICAgIHNyYz17bmV4dFNlc3Npb24udXNlciEuaW1hZ2UgPz8gXCJcIn1cclxuICAgICAgICAgICAgICAgICAgICB3aWR0aD17MjZ9XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PXsyNn1cclxuICAgICAgICAgICAgICAgICAgICBhbHQ9e25leHRTZXNzaW9uLnVzZXIhLmlkID8/IFwiXCJ9XHJcbiAgICAgICAgICAgICAgICAgID48L0ltYWdlPlxyXG4gICAgICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICkgOiBudWxsfVxyXG4gICAgICAgICAge25leHRTZXNzaW9uID8gKFxyXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cIiBtci01IGZvbnQtYm9sZFwiIG9uQ2xpY2s9eygpID0+IHNpZ25PdXQoKX0+XHJcbiAgICAgICAgICAgICAgU2lnbiBvdXRcclxuICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICApIDogKFxyXG4gICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgPExpbmsgaHJlZj1cIi9lbnRlclwiPlxyXG4gICAgICAgICAgICAgICAgPGEgY2xhc3NOYW1lPVwiIG1yLTUgaG92ZXI6Y3Vyc29yLXBvaW50ZXJcIj5FbnRlcjwvYT5cclxuICAgICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICApfVxyXG4gICAgICAgIDwvdWw+XHJcbiAgICAgIDwvbmF2PlxyXG4gICAgPC9oZWFkZXI+XHJcbiAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsiTGluayIsInVzZVNlc3Npb24iLCJzaWduT3V0IiwidXNlVXNlciIsIkltYWdlIiwibG9nbyIsIkduYiIsImRhdGEiLCJuZXh0U2Vzc2lvbiIsInVzZXIiLCJpc0xvYWRpbmciLCJoZWFkZXIiLCJjbGFzc05hbWUiLCJuYXYiLCJ1bCIsImxpIiwiaHJlZiIsInBhc3NIcmVmIiwiYSIsInNyYyIsIndpZHRoIiwiaGVpZ2h0IiwiaW1hZ2UiLCJhbHQiLCJpZCIsImJ1dHRvbiIsIm9uQ2xpY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/gnb.tsx\n"));

/***/ }),

/***/ "./components/top.tsx":
/*!****************************!*\
  !*** ./components/top.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Top; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_gnb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @components/gnb */ \"./components/gnb.tsx\");\n\n\nfunction Top() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_gnb__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\components\\\\top.tsx\",\n        lineNumber: 4,\n        columnNumber: 10\n    }, this);\n}\n_c = Top;\nvar _c;\n$RefreshReg$(_c, \"Top\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL3RvcC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQWtDO0FBRW5CLFNBQVNDLEdBQUcsR0FBRztJQUM1QixxQkFBTyw4REFBQ0QsdURBQUc7Ozs7WUFBRyxDQUFDO0FBQ2pCLENBQUM7QUFGdUJDLEtBQUFBLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy90b3AudHN4Pzg0OTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEduYiBmcm9tIFwiQGNvbXBvbmVudHMvZ25iXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUb3AoKSB7XHJcbiAgcmV0dXJuIDxHbmIgLz47XHJcbn1cclxuIl0sIm5hbWVzIjpbIkduYiIsIlRvcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/top.tsx\n"));

/***/ }),

/***/ "./libs/client/useUser.tsx":
/*!*********************************!*\
  !*** ./libs/client/useUser.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ useUser; }\n/* harmony export */ });\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! swr */ \"./node_modules/swr/dist/index.mjs\");\nvar _s = $RefreshSig$();\n\n\n\nfunction useUser() {\n    _s();\n    var ref = (0,swr__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"/api/users/me\"), data = ref.data, error = ref.error;\n    // const { data: session } = useSession();\n    var router = (0,next_router__WEBPACK_IMPORTED_MODULE_0__.useRouter)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (data && !data.ok) {\n        // router.replace(\"/enter\");\n        }\n    }, [\n        data,\n        router\n    ]);\n    //   return router.replace(\"/enter\");\n    return {\n        user: data === null || data === void 0 ? void 0 : data.profile,\n        isLoading: !data && !error\n    };\n}\n_s(useUser, \"4W9O7/pgHSLAxPizl2rA7NDDAiw=\", false, function() {\n    return [\n        swr__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n        next_router__WEBPACK_IMPORTED_MODULE_0__.useRouter\n    ];\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL2NsaWVudC91c2VVc2VyLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUF3QztBQUNOO0FBQ1Q7QUFFVixTQUFTRyxPQUFPLEdBQUc7O0lBQ2hDLElBQXdCRCxHQUF1QixHQUF2QkEsK0NBQU0sQ0FBQyxlQUFlLENBQUMsRUFBdkNFLElBQUksR0FBWUYsR0FBdUIsQ0FBdkNFLElBQUksRUFBRUMsS0FBSyxHQUFLSCxHQUF1QixDQUFqQ0csS0FBSztJQUNuQiwwQ0FBMEM7SUFDMUMsSUFBTUMsTUFBTSxHQUFHTixzREFBUyxFQUFFO0lBQzFCQyxnREFBUyxDQUFDLFdBQU07UUFDZCxJQUFJRyxJQUFJLElBQUksQ0FBQ0EsSUFBSSxDQUFDRyxFQUFFLEVBQUU7UUFDcEIsNEJBQTRCO1FBQzlCLENBQUM7SUFDSCxDQUFDLEVBQUU7UUFBQ0gsSUFBSTtRQUFFRSxNQUFNO0tBQUMsQ0FBQyxDQUFDO0lBRW5CLHFDQUFxQztJQUVyQyxPQUFPO1FBQUVFLElBQUksRUFBRUosSUFBSSxhQUFKQSxJQUFJLFdBQVMsR0FBYkEsS0FBQUEsQ0FBYSxHQUFiQSxJQUFJLENBQUVLLE9BQU87UUFBRUMsU0FBUyxFQUFFLENBQUNOLElBQUksSUFBSSxDQUFDQyxLQUFLO0tBQUUsQ0FBQztBQUM3RCxDQUFDO0dBYnVCRixPQUFPOztRQUNMRCwyQ0FBTTtRQUVmRixrREFBUyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWJzL2NsaWVudC91c2VVc2VyLnRzeD9jNjdlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L3JvdXRlclwiO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHVzZVNXUiBmcm9tIFwic3dyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VVc2VyKCkge1xyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHVzZVNXUihcIi9hcGkvdXNlcnMvbWVcIik7XHJcbiAgLy8gY29uc3QgeyBkYXRhOiBzZXNzaW9uIH0gPSB1c2VTZXNzaW9uKCk7XHJcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChkYXRhICYmICFkYXRhLm9rKSB7XHJcbiAgICAgIC8vIHJvdXRlci5yZXBsYWNlKFwiL2VudGVyXCIpO1xyXG4gICAgfVxyXG4gIH0sIFtkYXRhLCByb3V0ZXJdKTtcclxuXHJcbiAgLy8gICByZXR1cm4gcm91dGVyLnJlcGxhY2UoXCIvZW50ZXJcIik7XHJcblxyXG4gIHJldHVybiB7IHVzZXI6IGRhdGE/LnByb2ZpbGUsIGlzTG9hZGluZzogIWRhdGEgJiYgIWVycm9yIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZVJvdXRlciIsInVzZUVmZmVjdCIsInVzZVNXUiIsInVzZVVzZXIiLCJkYXRhIiwiZXJyb3IiLCJyb3V0ZXIiLCJvayIsInVzZXIiLCJwcm9maWxlIiwiaXNMb2FkaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/client/useUser.tsx\n"));

/***/ }),

/***/ "./pages/_app.tsx":
/*!************************!*\
  !*** ./pages/_app.tsx ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/src/_object_spread.mjs */ \"./node_modules/@swc/helpers/src/_object_spread.mjs\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../styles/globals.css */ \"./styles/globals.css\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_styles_globals_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_top__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @components/top */ \"./components/top.tsx\");\n/* harmony import */ var _components_footer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @components/footer */ \"./components/footer.tsx\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next-auth/react */ \"./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! swr */ \"./node_modules/swr/dist/index.mjs\");\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! recoil */ \"./node_modules/recoil/es/index.js\");\n\n\n\n\n\n\n\n\n// const { data: session } = useSession();\nfunction MyApp(param) {\n    var Component = param.Component, pageProps = param.pageProps;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_auth_react__WEBPACK_IMPORTED_MODULE_4__.SessionProvider, {\n        session: pageProps === null || pageProps === void 0 ? void 0 : pageProps.session,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(swr__WEBPACK_IMPORTED_MODULE_5__.SWRConfig, {\n            value: {\n                fetcher: function(url) {\n                    return fetch(url).then(function(response) {\n                        return response.json();\n                    });\n                }\n            },\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(recoil__WEBPACK_IMPORTED_MODULE_6__.RecoilRoot, {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \" min-w-[300px] max-h-fit flex flex-col items-center min-h-[100vh] relative\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_top__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                            lineNumber: 28,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                            className: \" mt-10 mx-3 flex-column items-center pb-[60px]\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, (0,_swc_helpers_src_object_spread_mjs__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({}, pageProps), void 0, false, {\n                                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                                lineNumber: 30,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                            lineNumber: 29,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_footer__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                            lineNumber: 32,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                    lineNumber: 27,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n                lineNumber: 26,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n            lineNumber: 20,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\mk448\\\\Dv_study\\\\fdbs_proto\\\\fdbsVer1.0\\\\pages\\\\_app.tsx\",\n        lineNumber: 19,\n        columnNumber: 5\n    }, this);\n}\n_c = MyApp;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MyApp);\nvar _c;\n$RefreshReg$(_c, \"MyApp\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9fYXBwLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7QUFBK0I7QUFFRztBQUNNO0FBQ1U7QUFDbEI7QUFDSTtBQUdwQywwQ0FBMEM7QUFFMUMsU0FBU0ssS0FBSyxDQUFDLEtBS2IsRUFBRTtRQUpGQyxTQUFTLEdBREksS0FLYixDQUpBQSxTQUFTLEVBQ1RDLFNBQVMsR0FGSSxLQUtiLENBSEFBLFNBQVM7SUFJVCxxQkFDRSw4REFBQ0wsNERBQWU7UUFBQ00sT0FBTyxFQUFFRCxTQUFTLGFBQVRBLFNBQVMsV0FBUyxHQUFsQkEsS0FBQUEsQ0FBa0IsR0FBbEJBLFNBQVMsQ0FBRUMsT0FBTztrQkFDMUMsNEVBQUNMLDBDQUFTO1lBQ1JNLEtBQUssRUFBRTtnQkFDTEMsT0FBTyxFQUFFLFNBQUNDLEdBQVc7MkJBQ25CQyxLQUFLLENBQUNELEdBQUcsQ0FBQyxDQUFDRSxJQUFJLENBQUMsU0FBQ0MsUUFBUTsrQkFBS0EsUUFBUSxDQUFDQyxJQUFJLEVBQUU7cUJBQUEsQ0FBQztpQkFBQTthQUNqRDtzQkFFRCw0RUFBQ1gsOENBQVU7MEJBQ1QsNEVBQUNZLEtBQUc7b0JBQUNDLFNBQVMsRUFBQyw0RUFBNkU7O3NDQUMxRiw4REFBQ2pCLHVEQUFHOzs7O2dDQUFHO3NDQUNQLDhEQUFDa0IsU0FBTzs0QkFBQ0QsU0FBUyxFQUFDLGdEQUFnRDtzQ0FDakUsNEVBQUNYLFNBQVMscUZBQUtDLFNBQVM7Ozs7b0NBQUk7Ozs7O2dDQUNwQjtzQ0FDViw4REFBQ04sMERBQU07Ozs7Z0NBQUc7Ozs7Ozt3QkFDTjs7Ozs7b0JBQ0s7Ozs7O2dCQUNIOzs7OztZQUNJLENBQ2xCO0FBQ0osQ0FBQztBQTFCUUksS0FBQUEsS0FBSztBQTRCZCwrREFBZUEsS0FBSyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL19hcHAudHN4PzJmYmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFwiLi4vc3R5bGVzL2dsb2JhbHMuY3NzXCI7XHJcbmltcG9ydCB0eXBlIHsgQXBwUHJvcHMgfSBmcm9tIFwibmV4dC9hcHBcIjtcclxuaW1wb3J0IFRvcCBmcm9tIFwiQGNvbXBvbmVudHMvdG9wXCI7XHJcbmltcG9ydCBGb290ZXIgZnJvbSBcIkBjb21wb25lbnRzL2Zvb3RlclwiO1xyXG5pbXBvcnQgeyBTZXNzaW9uUHJvdmlkZXIgfSBmcm9tIFwibmV4dC1hdXRoL3JlYWN0XCI7XHJcbmltcG9ydCB7IFNXUkNvbmZpZyB9IGZyb20gXCJzd3JcIjtcclxuaW1wb3J0IHsgUmVjb2lsUm9vdCB9IGZyb20gXCJyZWNvaWxcIjtcclxuaW1wb3J0IHsgU2Vzc2lvbiB9IGZyb20gXCJuZXh0LWF1dGhcIjtcclxuXHJcbi8vIGNvbnN0IHsgZGF0YTogc2Vzc2lvbiB9ID0gdXNlU2Vzc2lvbigpO1xyXG5cclxuZnVuY3Rpb24gTXlBcHAoe1xyXG4gIENvbXBvbmVudCxcclxuICBwYWdlUHJvcHMsXHJcbn06IEFwcFByb3BzPHtcclxuICBzZXNzaW9uOiBTZXNzaW9uO1xyXG59Pikge1xyXG4gIHJldHVybiAoXHJcbiAgICA8U2Vzc2lvblByb3ZpZGVyIHNlc3Npb249e3BhZ2VQcm9wcz8uc2Vzc2lvbn0+XHJcbiAgICAgIDxTV1JDb25maWdcclxuICAgICAgICB2YWx1ZT17e1xyXG4gICAgICAgICAgZmV0Y2hlcjogKHVybDogc3RyaW5nKSA9PlxyXG4gICAgICAgICAgICBmZXRjaCh1cmwpLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpLFxyXG4gICAgICAgIH19XHJcbiAgICAgID5cclxuICAgICAgICA8UmVjb2lsUm9vdD5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiIG1pbi13LVszMDBweF0gIG1heC1oLWZpdCBmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBtaW4taC1bMTAwdmhdIHJlbGF0aXZlXCI+XHJcbiAgICAgICAgICAgIDxUb3AgLz5cclxuICAgICAgICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwiIG10LTEwIG14LTMgZmxleC1jb2x1bW4gaXRlbXMtY2VudGVyIHBiLVs2MHB4XVwiPlxyXG4gICAgICAgICAgICAgIDxDb21wb25lbnQgey4uLnBhZ2VQcm9wc30gLz5cclxuICAgICAgICAgICAgPC9zZWN0aW9uPlxyXG4gICAgICAgICAgICA8Rm9vdGVyIC8+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L1JlY29pbFJvb3Q+XHJcbiAgICAgIDwvU1dSQ29uZmlnPlxyXG4gICAgPC9TZXNzaW9uUHJvdmlkZXI+XHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTXlBcHA7XHJcbiJdLCJuYW1lcyI6WyJUb3AiLCJGb290ZXIiLCJTZXNzaW9uUHJvdmlkZXIiLCJTV1JDb25maWciLCJSZWNvaWxSb290IiwiTXlBcHAiLCJDb21wb25lbnQiLCJwYWdlUHJvcHMiLCJzZXNzaW9uIiwidmFsdWUiLCJmZXRjaGVyIiwidXJsIiwiZmV0Y2giLCJ0aGVuIiwicmVzcG9uc2UiLCJqc29uIiwiZGl2IiwiY2xhc3NOYW1lIiwic2VjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/_app.tsx\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLGlCQUFULENBQTJCQyxHQUEzQixFQUFnQ0MsR0FBaEMsRUFBcUM7RUFDbkMsSUFBSUEsR0FBRyxJQUFJLElBQVAsSUFBZUEsR0FBRyxHQUFHRCxHQUFHLENBQUNFLE1BQTdCLEVBQXFDRCxHQUFHLEdBQUdELEdBQUcsQ0FBQ0UsTUFBVjs7RUFFckMsS0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBUixFQUFXQyxJQUFJLEdBQUcsSUFBSUMsS0FBSixDQUFVSixHQUFWLENBQXZCLEVBQXVDRSxDQUFDLEdBQUdGLEdBQTNDLEVBQWdERSxDQUFDLEVBQWpELEVBQXFEO0lBQ25EQyxJQUFJLENBQUNELENBQUQsQ0FBSixHQUFVSCxHQUFHLENBQUNHLENBQUQsQ0FBYjtFQUNEOztFQUVELE9BQU9DLElBQVA7QUFDRDs7QUFFREUsTUFBTSxDQUFDQyxPQUFQLEdBQWlCUixpQkFBakIsRUFBb0NPLHlCQUFBLEdBQTRCLElBQWhFLEVBQXNFQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF6RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzP2NmMDkiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9hcnJheUxpa2VUb0FycmF5IiwiYXJyIiwibGVuIiwibGVuZ3RoIiwiaSIsImFycjIiLCJBcnJheSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/arrayLikeToArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxHQUF6QixFQUE4QjtFQUM1QixJQUFJQyxLQUFLLENBQUNDLE9BQU4sQ0FBY0YsR0FBZCxDQUFKLEVBQXdCLE9BQU9BLEdBQVA7QUFDekI7O0FBRURHLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsZUFBakIsRUFBa0NJLHlCQUFBLEdBQTRCLElBQTlELEVBQW9FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF2RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcz9hNTI1Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2FycmF5V2l0aEhvbGVzIiwiYXJyIiwiQXJyYXkiLCJpc0FycmF5IiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/arrayWithHoles.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0Esc0JBQVQsQ0FBZ0NDLElBQWhDLEVBQXNDO0VBQ3BDLElBQUlBLElBQUksS0FBSyxLQUFLLENBQWxCLEVBQXFCO0lBQ25CLE1BQU0sSUFBSUMsY0FBSixDQUFtQiwyREFBbkIsQ0FBTjtFQUNEOztFQUVELE9BQU9ELElBQVA7QUFDRDs7QUFFREUsTUFBTSxDQUFDQyxPQUFQLEdBQWlCSixzQkFBakIsRUFBeUNHLHlCQUFBLEdBQTRCLElBQXJFLEVBQTJFQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUE5RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/MjAxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/assertThisInitialized.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLGtCQUFULENBQTRCQyxHQUE1QixFQUFpQ0MsT0FBakMsRUFBMENDLE1BQTFDLEVBQWtEQyxLQUFsRCxFQUF5REMsTUFBekQsRUFBaUVDLEdBQWpFLEVBQXNFQyxHQUF0RSxFQUEyRTtFQUN6RSxJQUFJO0lBQ0YsSUFBSUMsSUFBSSxHQUFHUCxHQUFHLENBQUNLLEdBQUQsQ0FBSCxDQUFTQyxHQUFULENBQVg7SUFDQSxJQUFJRSxLQUFLLEdBQUdELElBQUksQ0FBQ0MsS0FBakI7RUFDRCxDQUhELENBR0UsT0FBT0MsS0FBUCxFQUFjO0lBQ2RQLE1BQU0sQ0FBQ08sS0FBRCxDQUFOO0lBQ0E7RUFDRDs7RUFFRCxJQUFJRixJQUFJLENBQUNHLElBQVQsRUFBZTtJQUNiVCxPQUFPLENBQUNPLEtBQUQsQ0FBUDtFQUNELENBRkQsTUFFTztJQUNMRyxPQUFPLENBQUNWLE9BQVIsQ0FBZ0JPLEtBQWhCLEVBQXVCSSxJQUF2QixDQUE0QlQsS0FBNUIsRUFBbUNDLE1BQW5DO0VBQ0Q7QUFDRjs7QUFFRCxTQUFTUyxpQkFBVCxDQUEyQkMsRUFBM0IsRUFBK0I7RUFDN0IsT0FBTyxZQUFZO0lBQ2pCLElBQUlDLElBQUksR0FBRyxJQUFYO0lBQUEsSUFDSUMsSUFBSSxHQUFHQyxTQURYO0lBRUEsT0FBTyxJQUFJTixPQUFKLENBQVksVUFBVVYsT0FBVixFQUFtQkMsTUFBbkIsRUFBMkI7TUFDNUMsSUFBSUYsR0FBRyxHQUFHYyxFQUFFLENBQUNJLEtBQUgsQ0FBU0gsSUFBVCxFQUFlQyxJQUFmLENBQVY7O01BRUEsU0FBU2IsS0FBVCxDQUFlSyxLQUFmLEVBQXNCO1FBQ3BCVCxrQkFBa0IsQ0FBQ0MsR0FBRCxFQUFNQyxPQUFOLEVBQWVDLE1BQWYsRUFBdUJDLEtBQXZCLEVBQThCQyxNQUE5QixFQUFzQyxNQUF0QyxFQUE4Q0ksS0FBOUMsQ0FBbEI7TUFDRDs7TUFFRCxTQUFTSixNQUFULENBQWdCZSxHQUFoQixFQUFxQjtRQUNuQnBCLGtCQUFrQixDQUFDQyxHQUFELEVBQU1DLE9BQU4sRUFBZUMsTUFBZixFQUF1QkMsS0FBdkIsRUFBOEJDLE1BQTlCLEVBQXNDLE9BQXRDLEVBQStDZSxHQUEvQyxDQUFsQjtNQUNEOztNQUVEaEIsS0FBSyxDQUFDaUIsU0FBRCxDQUFMO0lBQ0QsQ0FaTSxDQUFQO0VBYUQsQ0FoQkQ7QUFpQkQ7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQlQsaUJBQWpCLEVBQW9DUSx5QkFBQSxHQUE0QixJQUFoRSxFQUFzRUEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBekciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcz9kMzEyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbImFzeW5jR2VuZXJhdG9yU3RlcCIsImdlbiIsInJlc29sdmUiLCJyZWplY3QiLCJfbmV4dCIsIl90aHJvdyIsImtleSIsImFyZyIsImluZm8iLCJ2YWx1ZSIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJmbiIsInNlbGYiLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJlcnIiLCJ1bmRlZmluZWQiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/asyncToGenerator.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxRQUF6QixFQUFtQ0MsV0FBbkMsRUFBZ0Q7RUFDOUMsSUFBSSxFQUFFRCxRQUFRLFlBQVlDLFdBQXRCLENBQUosRUFBd0M7SUFDdEMsTUFBTSxJQUFJQyxTQUFKLENBQWMsbUNBQWQsQ0FBTjtFQUNEO0FBQ0Y7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsZUFBakIsRUFBa0NJLHlCQUFBLEdBQTRCLElBQTlELEVBQW9FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF2RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcz9iN2FlIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/classCallCheck.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nvar isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct.js */ \"./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js\");\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct.bind(), module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsY0FBYyxHQUFHQyxtQkFBTyxDQUFDLG9GQUFELENBQTVCOztBQUVBLElBQUlDLHdCQUF3QixHQUFHRCxtQkFBTyxDQUFDLHdHQUFELENBQXRDOztBQUVBLFNBQVNFLFVBQVQsQ0FBb0JDLE1BQXBCLEVBQTRCQyxJQUE1QixFQUFrQ0MsS0FBbEMsRUFBeUM7RUFDdkMsSUFBSUosd0JBQXdCLEVBQTVCLEVBQWdDO0lBQzlCSyxNQUFNLENBQUNDLE9BQVAsR0FBaUJMLFVBQVUsR0FBR00sT0FBTyxDQUFDQyxTQUFSLENBQWtCQyxJQUFsQixFQUE5QixFQUF3REoseUJBQUEsR0FBNEIsSUFBcEYsRUFBMEZBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQTdIO0VBQ0QsQ0FGRCxNQUVPO0lBQ0xELE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsVUFBVSxHQUFHLFNBQVNBLFVBQVQsQ0FBb0JDLE1BQXBCLEVBQTRCQyxJQUE1QixFQUFrQ0MsS0FBbEMsRUFBeUM7TUFDckUsSUFBSU8sQ0FBQyxHQUFHLENBQUMsSUFBRCxDQUFSO01BQ0FBLENBQUMsQ0FBQ0MsSUFBRixDQUFPQyxLQUFQLENBQWFGLENBQWIsRUFBZ0JSLElBQWhCO01BQ0EsSUFBSVcsV0FBVyxHQUFHQyxRQUFRLENBQUNOLElBQVQsQ0FBY0ksS0FBZCxDQUFvQlgsTUFBcEIsRUFBNEJTLENBQTVCLENBQWxCO01BQ0EsSUFBSUssUUFBUSxHQUFHLElBQUlGLFdBQUosRUFBZjtNQUNBLElBQUlWLEtBQUosRUFBV04sY0FBYyxDQUFDa0IsUUFBRCxFQUFXWixLQUFLLENBQUNhLFNBQWpCLENBQWQ7TUFDWCxPQUFPRCxRQUFQO0lBQ0QsQ0FQRCxFQU9HWCx5QkFBQSxHQUE0QixJQVAvQixFQU9xQ0EseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FQeEU7RUFRRDs7RUFFRCxPQUFPTCxVQUFVLENBQUNZLEtBQVgsQ0FBaUIsSUFBakIsRUFBdUJLLFNBQXZCLENBQVA7QUFDRDs7QUFFRGIsTUFBTSxDQUFDQyxPQUFQLEdBQWlCTCxVQUFqQixFQUE2QkkseUJBQUEsR0FBNEIsSUFBekQsRUFBK0RBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQWxHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcz8yOTFlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuXG52YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcmVxdWlyZShcIi4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzXCIpO1xuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3QuYmluZCgpLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBzZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsic2V0UHJvdG90eXBlT2YiLCJyZXF1aXJlIiwiaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NvbnN0cnVjdCIsIlBhcmVudCIsImFyZ3MiLCJDbGFzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiYmluZCIsIl9fZXNNb2R1bGUiLCJhIiwicHVzaCIsImFwcGx5IiwiQ29uc3RydWN0b3IiLCJGdW5jdGlvbiIsImluc3RhbmNlIiwicHJvdG90eXBlIiwiYXJndW1lbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/construct.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxpQkFBVCxDQUEyQkMsTUFBM0IsRUFBbUNDLEtBQW5DLEVBQTBDO0VBQ3hDLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsS0FBSyxDQUFDRSxNQUExQixFQUFrQ0QsQ0FBQyxFQUFuQyxFQUF1QztJQUNyQyxJQUFJRSxVQUFVLEdBQUdILEtBQUssQ0FBQ0MsQ0FBRCxDQUF0QjtJQUNBRSxVQUFVLENBQUNDLFVBQVgsR0FBd0JELFVBQVUsQ0FBQ0MsVUFBWCxJQUF5QixLQUFqRDtJQUNBRCxVQUFVLENBQUNFLFlBQVgsR0FBMEIsSUFBMUI7SUFDQSxJQUFJLFdBQVdGLFVBQWYsRUFBMkJBLFVBQVUsQ0FBQ0csUUFBWCxHQUFzQixJQUF0QjtJQUMzQkMsTUFBTSxDQUFDQyxjQUFQLENBQXNCVCxNQUF0QixFQUE4QkksVUFBVSxDQUFDTSxHQUF6QyxFQUE4Q04sVUFBOUM7RUFDRDtBQUNGOztBQUVELFNBQVNPLFlBQVQsQ0FBc0JDLFdBQXRCLEVBQW1DQyxVQUFuQyxFQUErQ0MsV0FBL0MsRUFBNEQ7RUFDMUQsSUFBSUQsVUFBSixFQUFnQmQsaUJBQWlCLENBQUNhLFdBQVcsQ0FBQ0csU0FBYixFQUF3QkYsVUFBeEIsQ0FBakI7RUFDaEIsSUFBSUMsV0FBSixFQUFpQmYsaUJBQWlCLENBQUNhLFdBQUQsRUFBY0UsV0FBZCxDQUFqQjtFQUNqQk4sTUFBTSxDQUFDQyxjQUFQLENBQXNCRyxXQUF0QixFQUFtQyxXQUFuQyxFQUFnRDtJQUM5Q0wsUUFBUSxFQUFFO0VBRG9DLENBQWhEO0VBR0EsT0FBT0ssV0FBUDtBQUNEOztBQUVESSxNQUFNLENBQUNDLE9BQVAsR0FBaUJOLFlBQWpCLEVBQStCSyx5QkFBQSxHQUE0QixJQUEzRCxFQUFpRUEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBcEciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanM/NTQ2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3MsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/createClass.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxHQUF6QixFQUE4QkMsR0FBOUIsRUFBbUNDLEtBQW5DLEVBQTBDO0VBQ3hDLElBQUlELEdBQUcsSUFBSUQsR0FBWCxFQUFnQjtJQUNkRyxNQUFNLENBQUNDLGNBQVAsQ0FBc0JKLEdBQXRCLEVBQTJCQyxHQUEzQixFQUFnQztNQUM5QkMsS0FBSyxFQUFFQSxLQUR1QjtNQUU5QkcsVUFBVSxFQUFFLElBRmtCO01BRzlCQyxZQUFZLEVBQUUsSUFIZ0I7TUFJOUJDLFFBQVEsRUFBRTtJQUpvQixDQUFoQztFQU1ELENBUEQsTUFPTztJQUNMUCxHQUFHLENBQUNDLEdBQUQsQ0FBSCxHQUFXQyxLQUFYO0VBQ0Q7O0VBRUQsT0FBT0YsR0FBUDtBQUNEOztBQUVEUSxNQUFNLENBQUNDLE9BQVAsR0FBaUJWLGVBQWpCLEVBQWtDUyx5QkFBQSxHQUE0QixJQUE5RCxFQUFvRUEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBdkciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanM/ZDk0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/defineProperty.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxDQUF6QixFQUE0QjtFQUMxQkMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCSCxlQUFlLEdBQUdJLE1BQU0sQ0FBQ0MsY0FBUCxHQUF3QkQsTUFBTSxDQUFDRSxjQUFQLENBQXNCQyxJQUF0QixFQUF4QixHQUF1RCxTQUFTUCxlQUFULENBQXlCQyxDQUF6QixFQUE0QjtJQUNwSCxPQUFPQSxDQUFDLENBQUNPLFNBQUYsSUFBZUosTUFBTSxDQUFDRSxjQUFQLENBQXNCTCxDQUF0QixDQUF0QjtFQUNELENBRkQsRUFFR0MseUJBQUEsR0FBNEIsSUFGL0IsRUFFcUNBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BRnhFO0VBR0EsT0FBT0gsZUFBZSxDQUFDQyxDQUFELENBQXRCO0FBQ0Q7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkgsZUFBakIsRUFBa0NFLHlCQUFBLEdBQTRCLElBQTlELEVBQW9FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF2RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcz85MDAzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfZ2V0UHJvdG90eXBlT2YiLCJvIiwibW9kdWxlIiwiZXhwb3J0cyIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJiaW5kIiwiX19wcm90b19fIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/getPrototypeOf.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxjQUFjLEdBQUdDLG1CQUFPLENBQUMsb0ZBQUQsQ0FBNUI7O0FBRUEsU0FBU0MsU0FBVCxDQUFtQkMsUUFBbkIsRUFBNkJDLFVBQTdCLEVBQXlDO0VBQ3ZDLElBQUksT0FBT0EsVUFBUCxLQUFzQixVQUF0QixJQUFvQ0EsVUFBVSxLQUFLLElBQXZELEVBQTZEO0lBQzNELE1BQU0sSUFBSUMsU0FBSixDQUFjLG9EQUFkLENBQU47RUFDRDs7RUFFREYsUUFBUSxDQUFDRyxTQUFULEdBQXFCQyxNQUFNLENBQUNDLE1BQVAsQ0FBY0osVUFBVSxJQUFJQSxVQUFVLENBQUNFLFNBQXZDLEVBQWtEO0lBQ3JFRyxXQUFXLEVBQUU7TUFDWEMsS0FBSyxFQUFFUCxRQURJO01BRVhRLFFBQVEsRUFBRSxJQUZDO01BR1hDLFlBQVksRUFBRTtJQUhIO0VBRHdELENBQWxELENBQXJCO0VBT0FMLE1BQU0sQ0FBQ00sY0FBUCxDQUFzQlYsUUFBdEIsRUFBZ0MsV0FBaEMsRUFBNkM7SUFDM0NRLFFBQVEsRUFBRTtFQURpQyxDQUE3QztFQUdBLElBQUlQLFVBQUosRUFBZ0JKLGNBQWMsQ0FBQ0csUUFBRCxFQUFXQyxVQUFYLENBQWQ7QUFDakI7O0FBRURVLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQmIsU0FBakIsRUFBNEJZLHlCQUFBLEdBQTRCLElBQXhELEVBQThEQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUFqRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcz9mMzViIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsic2V0UHJvdG90eXBlT2YiLCJyZXF1aXJlIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiVHlwZUVycm9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/inherits.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0Esc0JBQVQsQ0FBZ0NDLEdBQWhDLEVBQXFDO0VBQ25DLE9BQU9BLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFYLEdBQXdCRCxHQUF4QixHQUE4QjtJQUNuQyxXQUFXQTtFQUR3QixDQUFyQztBQUdEOztBQUVERSxNQUFNLENBQUNDLE9BQVAsR0FBaUJKLHNCQUFqQixFQUF5Q0cseUJBQUEsR0FBNEIsSUFBckUsRUFBMkVBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQTlHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcz9lZThjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/interopRequireDefault.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeFunction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeFunction.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nmodule.exports = _isNativeFunction, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZUZ1bmN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLGlCQUFULENBQTJCQyxFQUEzQixFQUErQjtFQUM3QixPQUFPQyxRQUFRLENBQUNDLFFBQVQsQ0FBa0JDLElBQWxCLENBQXVCSCxFQUF2QixFQUEyQkksT0FBM0IsQ0FBbUMsZUFBbkMsTUFBd0QsQ0FBQyxDQUFoRTtBQUNEOztBQUVEQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJQLGlCQUFqQixFQUFvQ00seUJBQUEsR0FBNEIsSUFBaEUsRUFBc0VBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQXpHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlRnVuY3Rpb24uanM/OGM4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZUZ1bmN0aW9uLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9pc05hdGl2ZUZ1bmN0aW9uIiwiZm4iLCJGdW5jdGlvbiIsInRvU3RyaW5nIiwiY2FsbCIsImluZGV4T2YiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/isNativeFunction.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nmodule.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EseUJBQVQsR0FBcUM7RUFDbkMsSUFBSSxPQUFPQyxPQUFQLEtBQW1CLFdBQW5CLElBQWtDLENBQUNBLE9BQU8sQ0FBQ0MsU0FBL0MsRUFBMEQsT0FBTyxLQUFQO0VBQzFELElBQUlELE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkMsSUFBdEIsRUFBNEIsT0FBTyxLQUFQO0VBQzVCLElBQUksT0FBT0MsS0FBUCxLQUFpQixVQUFyQixFQUFpQyxPQUFPLElBQVA7O0VBRWpDLElBQUk7SUFDRkMsT0FBTyxDQUFDQyxTQUFSLENBQWtCQyxPQUFsQixDQUEwQkMsSUFBMUIsQ0FBK0JQLE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkcsT0FBbEIsRUFBMkIsRUFBM0IsRUFBK0IsWUFBWSxDQUFFLENBQTdDLENBQS9CO0lBQ0EsT0FBTyxJQUFQO0VBQ0QsQ0FIRCxDQUdFLE9BQU9JLENBQVAsRUFBVTtJQUNWLE9BQU8sS0FBUDtFQUNEO0FBQ0Y7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQlgseUJBQWpCLEVBQTRDVSx5QkFBQSxHQUE0QixJQUF4RSxFQUE4RUEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBakgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzPzFkNTQiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNoYW0iLCJQcm94eSIsIkJvb2xlYW4iLCJwcm90b3R5cGUiLCJ2YWx1ZU9mIiwiY2FsbCIsImUiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxxQkFBVCxDQUErQkMsR0FBL0IsRUFBb0NDLENBQXBDLEVBQXVDO0VBQ3JDLElBQUlDLEVBQUUsR0FBR0YsR0FBRyxJQUFJLElBQVAsR0FBYyxJQUFkLEdBQXFCLE9BQU9HLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNILEdBQUcsQ0FBQ0csTUFBTSxDQUFDQyxRQUFSLENBQXBDLElBQXlESixHQUFHLENBQUMsWUFBRCxDQUExRjs7RUFFQSxJQUFJRSxFQUFFLElBQUksSUFBVixFQUFnQjtFQUNoQixJQUFJRyxJQUFJLEdBQUcsRUFBWDtFQUNBLElBQUlDLEVBQUUsR0FBRyxJQUFUO0VBQ0EsSUFBSUMsRUFBRSxHQUFHLEtBQVQ7O0VBRUEsSUFBSUMsRUFBSixFQUFRQyxFQUFSOztFQUVBLElBQUk7SUFDRixLQUFLUCxFQUFFLEdBQUdBLEVBQUUsQ0FBQ1EsSUFBSCxDQUFRVixHQUFSLENBQVYsRUFBd0IsRUFBRU0sRUFBRSxHQUFHLENBQUNFLEVBQUUsR0FBR04sRUFBRSxDQUFDUyxJQUFILEVBQU4sRUFBaUJDLElBQXhCLENBQXhCLEVBQXVETixFQUFFLEdBQUcsSUFBNUQsRUFBa0U7TUFDaEVELElBQUksQ0FBQ1EsSUFBTCxDQUFVTCxFQUFFLENBQUNNLEtBQWI7O01BRUEsSUFBSWIsQ0FBQyxJQUFJSSxJQUFJLENBQUNVLE1BQUwsS0FBZ0JkLENBQXpCLEVBQTRCO0lBQzdCO0VBQ0YsQ0FORCxDQU1FLE9BQU9lLEdBQVAsRUFBWTtJQUNaVCxFQUFFLEdBQUcsSUFBTDtJQUNBRSxFQUFFLEdBQUdPLEdBQUw7RUFDRCxDQVRELFNBU1U7SUFDUixJQUFJO01BQ0YsSUFBSSxDQUFDVixFQUFELElBQU9KLEVBQUUsQ0FBQyxRQUFELENBQUYsSUFBZ0IsSUFBM0IsRUFBaUNBLEVBQUUsQ0FBQyxRQUFELENBQUY7SUFDbEMsQ0FGRCxTQUVVO01BQ1IsSUFBSUssRUFBSixFQUFRLE1BQU1FLEVBQU47SUFDVDtFQUNGOztFQUVELE9BQU9KLElBQVA7QUFDRDs7QUFFRFksTUFBTSxDQUFDQyxPQUFQLEdBQWlCbkIscUJBQWpCLEVBQXdDa0IseUJBQUEsR0FBNEIsSUFBcEUsRUFBMEVBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQTdHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzP2FmZTciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJhcnIiLCJpIiwiX2kiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9hcnIiLCJfbiIsIl9kIiwiX3MiLCJfZSIsImNhbGwiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImxlbmd0aCIsImVyciIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EsZ0JBQVQsR0FBNEI7RUFDMUIsTUFBTSxJQUFJQyxTQUFKLENBQWMsMklBQWQsQ0FBTjtBQUNEOztBQUVEQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJILGdCQUFqQixFQUFtQ0UseUJBQUEsR0FBNEIsSUFBL0QsRUFBcUVBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQXhHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcz80YzIwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/nonIterableRest.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\n\nvar assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized.js */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLE9BQU8sR0FBR0Msc0dBQWQ7O0FBRUEsSUFBSUMscUJBQXFCLEdBQUdELG1CQUFPLENBQUMsa0dBQUQsQ0FBbkM7O0FBRUEsU0FBU0UsMEJBQVQsQ0FBb0NDLElBQXBDLEVBQTBDQyxJQUExQyxFQUFnRDtFQUM5QyxJQUFJQSxJQUFJLEtBQUtMLE9BQU8sQ0FBQ0ssSUFBRCxDQUFQLEtBQWtCLFFBQWxCLElBQThCLE9BQU9BLElBQVAsS0FBZ0IsVUFBbkQsQ0FBUixFQUF3RTtJQUN0RSxPQUFPQSxJQUFQO0VBQ0QsQ0FGRCxNQUVPLElBQUlBLElBQUksS0FBSyxLQUFLLENBQWxCLEVBQXFCO0lBQzFCLE1BQU0sSUFBSUMsU0FBSixDQUFjLDBEQUFkLENBQU47RUFDRDs7RUFFRCxPQUFPSixxQkFBcUIsQ0FBQ0UsSUFBRCxDQUE1QjtBQUNEOztBQUVERyxNQUFNLENBQUNDLE9BQVAsR0FBaUJMLDBCQUFqQixFQUE2Q0kseUJBQUEsR0FBNEIsSUFBekUsRUFBK0VBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQWxIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanM/MGViOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIik7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJyZXF1aXJlIiwiYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJzZWxmIiwiY2FsbCIsIlR5cGVFcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/regeneratorRuntime.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/regeneratorRuntime.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\n\nfunction _regeneratorRuntime() {\n  \"use strict\";\n  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n\n  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {\n    return exports;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  var exports = {},\n      Op = Object.prototype,\n      hasOwn = Op.hasOwnProperty,\n      $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n      iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n      asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n      toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n        generator = Object.create(protoGenerator.prototype),\n        context = new Context(tryLocsList || []);\n    return generator._invoke = function (innerFn, self, context) {\n      var state = \"suspendedStart\";\n      return function (method, arg) {\n        if (\"executing\" === state) throw new Error(\"Generator is already running\");\n\n        if (\"completed\" === state) {\n          if (\"throw\" === method) throw arg;\n          return doneResult();\n        }\n\n        for (context.method = method, context.arg = arg;;) {\n          var delegate = context.delegate;\n\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n\n          if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n            if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n            context.dispatchException(context.arg);\n          } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n          state = \"executing\";\n          var record = tryCatch(innerFn, self, context);\n\n          if (\"normal\" === record.type) {\n            if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          }\n\n          \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n        }\n      };\n    }(innerFn, self, context), generator;\n  }\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {}\n\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n      NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n            value = result.value;\n        return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n\n      reject(record.arg);\n    }\n\n    var previousPromise;\n\n    this._invoke = function (method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    };\n  }\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (undefined === method) {\n      if (context.delegate = null, \"throw\" === context.method) {\n        if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel;\n        context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          for (; ++i < iterable.length;) {\n            if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n          }\n\n          return next.value = undefined, next.done = !0, next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    return {\n      next: doneResult\n    };\n  }\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {\n        \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n      }\n    },\n    stop: function stop() {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) throw exception;\n      var context = this;\n\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n            record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n              hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      }\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}\n\nmodule.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvclJ1bnRpbWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsT0FBTyxHQUFHQyxzR0FBZDs7QUFFQSxTQUFTQyxtQkFBVCxHQUErQjtFQUM3QjtFQUNBOztFQUVBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJGLG1CQUFtQixHQUFHLFNBQVNBLG1CQUFULEdBQStCO0lBQ3BFLE9BQU9FLE9BQVA7RUFDRCxDQUZELEVBRUdELHlCQUFBLEdBQTRCLElBRi9CLEVBRXFDQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUZ4RTtFQUdBLElBQUlBLE9BQU8sR0FBRyxFQUFkO0VBQUEsSUFDSUUsRUFBRSxHQUFHQyxNQUFNLENBQUNDLFNBRGhCO0VBQUEsSUFFSUMsTUFBTSxHQUFHSCxFQUFFLENBQUNJLGNBRmhCO0VBQUEsSUFHSUMsT0FBTyxHQUFHLGNBQWMsT0FBT0MsTUFBckIsR0FBOEJBLE1BQTlCLEdBQXVDLEVBSHJEO0VBQUEsSUFJSUMsY0FBYyxHQUFHRixPQUFPLENBQUNHLFFBQVIsSUFBb0IsWUFKekM7RUFBQSxJQUtJQyxtQkFBbUIsR0FBR0osT0FBTyxDQUFDSyxhQUFSLElBQXlCLGlCQUxuRDtFQUFBLElBTUlDLGlCQUFpQixHQUFHTixPQUFPLENBQUNPLFdBQVIsSUFBdUIsZUFOL0M7O0VBUUEsU0FBU0MsTUFBVCxDQUFnQkMsR0FBaEIsRUFBcUJDLEdBQXJCLEVBQTBCQyxLQUExQixFQUFpQztJQUMvQixPQUFPZixNQUFNLENBQUNnQixjQUFQLENBQXNCSCxHQUF0QixFQUEyQkMsR0FBM0IsRUFBZ0M7TUFDckNDLEtBQUssRUFBRUEsS0FEOEI7TUFFckNFLFVBQVUsRUFBRSxDQUFDLENBRndCO01BR3JDQyxZQUFZLEVBQUUsQ0FBQyxDQUhzQjtNQUlyQ0MsUUFBUSxFQUFFLENBQUM7SUFKMEIsQ0FBaEMsR0FLSE4sR0FBRyxDQUFDQyxHQUFELENBTFA7RUFNRDs7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SixDQUFVLHVCQUFWLENBQU47SUFDRCxDQW5GNkM7SUFvRjlDZ0csYUFBYSxFQUFFLFNBQVNBLGFBQVQsQ0FBdUJ4QyxRQUF2QixFQUFpQ2YsVUFBakMsRUFBNkNFLE9BQTdDLEVBQXNEO01BQ25FLE9BQU8sS0FBS3pDLFFBQUwsR0FBZ0I7UUFDckIvQixRQUFRLEVBQUVtRCxNQUFNLENBQUNrQyxRQUFELENBREs7UUFFckJmLFVBQVUsRUFBRUEsVUFGUztRQUdyQkUsT0FBTyxFQUFFQTtNQUhZLENBQWhCLEVBSUosV0FBVyxLQUFLN0MsTUFBaEIsS0FBMkIsS0FBS0MsR0FBTCxHQUFXdUMsU0FBdEMsQ0FKSSxFQUk4Q2pDLGdCQUpyRDtJQUtEO0VBMUY2QyxDQXBDekMsRUErSEo1QyxPQS9ISDtBQWdJRDs7QUFFREQsTUFBTSxDQUFDQyxPQUFQLEdBQWlCRixtQkFBakIsRUFBc0NDLHlCQUFBLEdBQTRCLElBQWxFLEVBQXdFQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUEzRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvclJ1bnRpbWUuanM/NWFkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XG5cbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9MSUNFTlNFICovXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICB2YXIgZXhwb3J0cyA9IHt9LFxuICAgICAgT3AgPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksXG4gICAgICAkU3ltYm9sID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSxcbiAgICAgIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIixcbiAgICAgIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIixcbiAgICAgIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwXG4gICAgfSksIG9ialtrZXldO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLFxuICAgICAgICBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksXG4gICAgICAgIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvci5faW52b2tlID0gZnVuY3Rpb24gKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgICAgICAgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuXG4gICAgICAgIGlmIChcImNvbXBsZXRlZFwiID09PSBzdGF0ZSkge1xuICAgICAgICAgIGlmIChcInRocm93XCIgPT09IG1ldGhvZCkgdGhyb3cgYXJnO1xuICAgICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnRleHQubWV0aG9kID0gbWV0aG9kLCBjb250ZXh0LmFyZyA9IGFyZzs7KSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcblxuICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFwibmV4dFwiID09PSBjb250ZXh0Lm1ldGhvZCkgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO2Vsc2UgaWYgKFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHtcbiAgICAgICAgICAgIGlmIChcInN1c3BlbmRlZFN0YXJ0XCIgPT09IHN0YXRlKSB0aHJvdyBzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQuYXJnO1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG4gICAgICAgICAgfSBlbHNlIFwicmV0dXJuXCIgPT09IGNvbnRleHQubWV0aG9kICYmIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgICBzdGF0ZSA9IFwiZXhlY3V0aW5nXCI7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBcImNvbXBsZXRlZFwiIDogXCJzdXNwZW5kZWRZaWVsZFwiLCByZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSAmJiAoc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KGlubmVyRm4sIHNlbGYsIGNvbnRleHQpLCBnZW5lcmF0b3I7XG4gIH1cblxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidGhyb3dcIixcbiAgICAgICAgYXJnOiBlcnJcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cblxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSAmJiAoSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSk7XG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG5cbiAgICAgIGlmIChcInRocm93XCIgIT09IHJlY29yZC50eXBlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnLFxuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IF90eXBlb2YodmFsdWUpICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSkgOiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHtcbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICB0aGlzLl9pbnZva2UgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuXG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gbWV0aG9kKSB7XG4gICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdICYmIChjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkLCBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkpIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcbiAgICBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgcmV0dXJuIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcsIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsO1xuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0ge1xuICAgICAgdHJ5TG9jOiBsb2NzWzBdXG4gICAgfTtcbiAgICAxIGluIGxvY3MgJiYgKGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXSksIDIgaW4gbG9jcyAmJiAoZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl0sIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSByZWNvcmQuYXJnLCBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7XG4gICAgICB0cnlMb2M6IFwicm9vdFwiXG4gICAgfV0sIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlcmFibGUubmV4dCkgcmV0dXJuIGl0ZXJhYmxlO1xuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSxcbiAgICAgICAgICAgIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIGZvciAoOyArK2kgPCBpdGVyYWJsZS5sZW5ndGg7KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSByZXR1cm4gbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV4dC52YWx1ZSA9IHVuZGVmaW5lZCwgbmV4dC5kb25lID0gITAsIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGRvbmVSZXN1bHRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRvbmU6ICEwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKEdwLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSwgZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGdlbkZ1biAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuICEhY3RvciAmJiAoY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpKTtcbiAgfSwgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKSwgZ2VuRnVuO1xuICB9LCBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB7XG4gICAgICBfX2F3YWl0OiBhcmdcbiAgICB9O1xuICB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpLCBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3IsIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgdm9pZCAwID09PSBQcm9taXNlSW1wbCAmJiAoUHJvbWlzZUltcGwgPSBQcm9taXNlKTtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7XG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgIH0pO1xuICB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApLCBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKSwgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfSksIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgZm9yICg7IGtleXMubGVuZ3RoOykge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHJldHVybiBuZXh0LnZhbHVlID0ga2V5LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0O1xuICAgIH07XG4gIH0sIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkge1xuICAgICAgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgIFwidFwiID09PSBuYW1lLmNoYXJBdCgwKSAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpICYmICh0aGlzW25hbWVdID0gdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB0aGlzLmRvbmUgPSAhMDtcbiAgICAgIHZhciByb290UmVjb3JkID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247XG4gICAgICBpZiAoXCJ0aHJvd1wiID09PSByb290UmVjb3JkLnR5cGUpIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJldHVybiByZWNvcmQudHlwZSA9IFwidGhyb3dcIiwgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbiwgY29udGV4dC5uZXh0ID0gbG9jLCBjYXVnaHQgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldLFxuICAgICAgICAgICAgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgaWYgKFwicm9vdFwiID09PSBlbnRyeS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKSxcbiAgICAgICAgICAgICAgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNGaW5hbGx5KSB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmluYWxseUVudHJ5ICYmIChcImJyZWFrXCIgPT09IHR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0eXBlKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MgJiYgKGZpbmFsbHlFbnRyeSA9IG51bGwpO1xuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZXR1cm4gcmVjb3JkLnR5cGUgPSB0eXBlLCByZWNvcmQuYXJnID0gYXJnLCBmaW5hbGx5RW50cnkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MsIENvbnRpbnVlU2VudGluZWwpIDogdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgcmV0dXJuIFwiYnJlYWtcIiA9PT0gcmVjb3JkLnR5cGUgfHwgXCJjb250aW51ZVwiID09PSByZWNvcmQudHlwZSA/IHRoaXMubmV4dCA9IHJlY29yZC5hcmcgOiBcInJldHVyblwiID09PSByZWNvcmQudHlwZSA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSAmJiBhZnRlckxvYyAmJiAodGhpcy5uZXh0ID0gYWZ0ZXJMb2MpLCBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG4gICAgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICAgIGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9LCBcIm5leHRcIiA9PT0gdGhpcy5tZXRob2QgJiYgKHRoaXMuYXJnID0gdW5kZWZpbmVkKSwgQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH0sIGV4cG9ydHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3JlZ2VuZXJhdG9yUnVudGltZSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwicmVxdWlyZSIsIl9yZWdlbmVyYXRvclJ1bnRpbWUiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSIsIk9wIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCIkU3ltYm9sIiwiU3ltYm9sIiwiaXRlcmF0b3JTeW1ib2wiLCJpdGVyYXRvciIsImFzeW5jSXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwidG9TdHJpbmdUYWdTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImRlZmluZSIsIm9iaiIsImtleSIsInZhbHVlIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJlcnIiLCJ3cmFwIiwiaW5uZXJGbiIsIm91dGVyRm4iLCJzZWxmIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsImNyZWF0ZSIsImNvbnRleHQiLCJDb250ZXh0IiwiX2ludm9rZSIsInN0YXRlIiwibWV0aG9kIiwiYXJnIiwiRXJyb3IiLCJkb25lUmVzdWx0IiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZVJlc3VsdCIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJDb250aW51ZVNlbnRpbmVsIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJhYnJ1cHQiLCJyZWNvcmQiLCJ0cnlDYXRjaCIsInR5cGUiLCJkb25lIiwiZm4iLCJjYWxsIiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwidmFsdWVzIiwiR3AiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJmb3JFYWNoIiwiQXN5bmNJdGVyYXRvciIsIlByb21pc2VJbXBsIiwiaW52b2tlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlc3VsdCIsIl9fYXdhaXQiLCJ0aGVuIiwidW53cmFwcGVkIiwiZXJyb3IiLCJwcmV2aW91c1Byb21pc2UiLCJjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyIsInVuZGVmaW5lZCIsIlR5cGVFcnJvciIsImluZm8iLCJyZXN1bHROYW1lIiwibmV4dCIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJsb2NzIiwiZW50cnkiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJwdXNoIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsIml0ZXJhYmxlIiwiaXRlcmF0b3JNZXRob2QiLCJpc05hTiIsImxlbmd0aCIsImkiLCJkaXNwbGF5TmFtZSIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5GdW4iLCJjdG9yIiwiY29uc3RydWN0b3IiLCJuYW1lIiwibWFyayIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiYXdyYXAiLCJhc3luYyIsIlByb21pc2UiLCJpdGVyIiwia2V5cyIsIm9iamVjdCIsInJldmVyc2UiLCJwb3AiLCJza2lwVGVtcFJlc2V0IiwicHJldiIsImNoYXJBdCIsInNsaWNlIiwic3RvcCIsInJvb3RSZWNvcmQiLCJydmFsIiwiZXhjZXB0aW9uIiwiaGFuZGxlIiwibG9jIiwiY2F1Z2h0IiwiaGFzQ2F0Y2giLCJoYXNGaW5hbGx5IiwiZmluYWxseUVudHJ5IiwiY29tcGxldGUiLCJmaW5pc2giLCJfY2F0Y2giLCJ0aHJvd24iLCJkZWxlZ2F0ZVlpZWxkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/regeneratorRuntime.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxDQUF6QixFQUE0QkMsQ0FBNUIsRUFBK0I7RUFDN0JDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkosZUFBZSxHQUFHSyxNQUFNLENBQUNDLGNBQVAsR0FBd0JELE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkMsSUFBdEIsRUFBeEIsR0FBdUQsU0FBU1AsZUFBVCxDQUF5QkMsQ0FBekIsRUFBNEJDLENBQTVCLEVBQStCO0lBQ3ZIRCxDQUFDLENBQUNPLFNBQUYsR0FBY04sQ0FBZDtJQUNBLE9BQU9ELENBQVA7RUFDRCxDQUhELEVBR0dFLHlCQUFBLEdBQTRCLElBSC9CLEVBR3FDQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUh4RTtFQUlBLE9BQU9KLGVBQWUsQ0FBQ0MsQ0FBRCxFQUFJQyxDQUFKLENBQXRCO0FBQ0Q7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkosZUFBakIsRUFBa0NHLHlCQUFBLEdBQTRCLElBQTlELEVBQW9FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF2RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcz8wNTI2Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbIl9zZXRQcm90b3R5cGVPZiIsIm8iLCJwIiwibW9kdWxlIiwiZXhwb3J0cyIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiYmluZCIsIl9fcHJvdG9fXyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/setPrototypeOf.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles.js */ \"./node_modules/@babel/runtime/helpers/arrayWithHoles.js\");\n\nvar iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit.js */ \"./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\");\n\nvar unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ \"./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\");\n\nvar nonIterableRest = __webpack_require__(/*! ./nonIterableRest.js */ \"./node_modules/@babel/runtime/helpers/nonIterableRest.js\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLGNBQWMsR0FBR0MsbUJBQU8sQ0FBQyxvRkFBRCxDQUE1Qjs7QUFFQSxJQUFJQyxvQkFBb0IsR0FBR0QsbUJBQU8sQ0FBQyxnR0FBRCxDQUFsQzs7QUFFQSxJQUFJRSwwQkFBMEIsR0FBR0YsbUJBQU8sQ0FBQyw0R0FBRCxDQUF4Qzs7QUFFQSxJQUFJRyxlQUFlLEdBQUdILG1CQUFPLENBQUMsc0ZBQUQsQ0FBN0I7O0FBRUEsU0FBU0ksY0FBVCxDQUF3QkMsR0FBeEIsRUFBNkJDLENBQTdCLEVBQWdDO0VBQzlCLE9BQU9QLGNBQWMsQ0FBQ00sR0FBRCxDQUFkLElBQXVCSixvQkFBb0IsQ0FBQ0ksR0FBRCxFQUFNQyxDQUFOLENBQTNDLElBQXVESiwwQkFBMEIsQ0FBQ0csR0FBRCxFQUFNQyxDQUFOLENBQWpGLElBQTZGSCxlQUFlLEVBQW5IO0FBQ0Q7O0FBRURJLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkosY0FBakIsRUFBaUNHLHlCQUFBLEdBQTRCLElBQTdELEVBQW1FQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUF0RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzP2Y1MGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXMuanNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzXCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiKTtcblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdC5qc1wiKTtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6WyJhcnJheVdpdGhIb2xlcyIsInJlcXVpcmUiLCJpdGVyYWJsZVRvQXJyYXlMaW1pdCIsInVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5Iiwibm9uSXRlcmFibGVSZXN0IiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJpIiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/slicedToArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(obj);\n}\n\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0I7RUFDcEI7O0VBRUEsT0FBTyxDQUFDQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJILE9BQU8sR0FBRyxjQUFjLE9BQU9JLE1BQXJCLElBQStCLFlBQVksT0FBT0EsTUFBTSxDQUFDQyxRQUF6RCxHQUFvRSxVQUFVSixHQUFWLEVBQWU7SUFDcEgsT0FBTyxPQUFPQSxHQUFkO0VBQ0QsQ0FGa0MsR0FFL0IsVUFBVUEsR0FBVixFQUFlO0lBQ2pCLE9BQU9BLEdBQUcsSUFBSSxjQUFjLE9BQU9HLE1BQTVCLElBQXNDSCxHQUFHLENBQUNLLFdBQUosS0FBb0JGLE1BQTFELElBQW9FSCxHQUFHLEtBQUtHLE1BQU0sQ0FBQ0csU0FBbkYsR0FBK0YsUUFBL0YsR0FBMEcsT0FBT04sR0FBeEg7RUFDRCxDQUpPLEVBSUxDLHlCQUFBLEdBQTRCLElBSnZCLEVBSTZCQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUpqRSxHQUkyRUgsT0FBTyxDQUFDQyxHQUFELENBSnpGO0FBS0Q7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkgsT0FBakIsRUFBMEJFLHlCQUFBLEdBQTRCLElBQXRELEVBQTREQSx5QkFBQSxHQUE0QkEsTUFBTSxDQUFDQyxPQUEvRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanM/ZjMzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIChtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzKSwgX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIm1vZHVsZSIsImV4cG9ydHMiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/typeof.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ \"./node_modules/@babel/runtime/helpers/arrayLikeToArray.js\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxnQkFBZ0IsR0FBR0MsbUJBQU8sQ0FBQyx3RkFBRCxDQUE5Qjs7QUFFQSxTQUFTQywyQkFBVCxDQUFxQ0MsQ0FBckMsRUFBd0NDLE1BQXhDLEVBQWdEO0VBQzlDLElBQUksQ0FBQ0QsQ0FBTCxFQUFRO0VBQ1IsSUFBSSxPQUFPQSxDQUFQLEtBQWEsUUFBakIsRUFBMkIsT0FBT0gsZ0JBQWdCLENBQUNHLENBQUQsRUFBSUMsTUFBSixDQUF2QjtFQUMzQixJQUFJQyxDQUFDLEdBQUdDLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkMsUUFBakIsQ0FBMEJDLElBQTFCLENBQStCTixDQUEvQixFQUFrQ08sS0FBbEMsQ0FBd0MsQ0FBeEMsRUFBMkMsQ0FBQyxDQUE1QyxDQUFSO0VBQ0EsSUFBSUwsQ0FBQyxLQUFLLFFBQU4sSUFBa0JGLENBQUMsQ0FBQ1EsV0FBeEIsRUFBcUNOLENBQUMsR0FBR0YsQ0FBQyxDQUFDUSxXQUFGLENBQWNDLElBQWxCO0VBQ3JDLElBQUlQLENBQUMsS0FBSyxLQUFOLElBQWVBLENBQUMsS0FBSyxLQUF6QixFQUFnQyxPQUFPUSxLQUFLLENBQUNDLElBQU4sQ0FBV1gsQ0FBWCxDQUFQO0VBQ2hDLElBQUlFLENBQUMsS0FBSyxXQUFOLElBQXFCLDJDQUEyQ1UsSUFBM0MsQ0FBZ0RWLENBQWhELENBQXpCLEVBQTZFLE9BQU9MLGdCQUFnQixDQUFDRyxDQUFELEVBQUlDLE1BQUosQ0FBdkI7QUFDOUU7O0FBRURZLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQmYsMkJBQWpCLEVBQThDYyx5QkFBQSxHQUE0QixJQUExRSxFQUFnRkEseUJBQUEsR0FBNEJBLE1BQU0sQ0FBQ0MsT0FBbkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanM/ZGE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbImFycmF5TGlrZVRvQXJyYXkiLCJyZXF1aXJlIiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwibyIsIm1pbkxlbiIsIm4iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/wrapNativeSuper.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\n\nvar setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nvar isNativeFunction = __webpack_require__(/*! ./isNativeFunction.js */ \"./node_modules/@babel/runtime/helpers/isNativeFunction.js\");\n\nvar construct = __webpack_require__(/*! ./construct.js */ \"./node_modules/@babel/runtime/helpers/construct.js\");\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _wrapNativeSuper(Class);\n}\n\nmodule.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsY0FBYyxHQUFHQyxtQkFBTyxDQUFDLG9GQUFELENBQTVCOztBQUVBLElBQUlDLGNBQWMsR0FBR0QsbUJBQU8sQ0FBQyxvRkFBRCxDQUE1Qjs7QUFFQSxJQUFJRSxnQkFBZ0IsR0FBR0YsbUJBQU8sQ0FBQyx3RkFBRCxDQUE5Qjs7QUFFQSxJQUFJRyxTQUFTLEdBQUdILG1CQUFPLENBQUMsMEVBQUQsQ0FBdkI7O0FBRUEsU0FBU0ksZ0JBQVQsQ0FBMEJDLEtBQTFCLEVBQWlDO0VBQy9CLElBQUlDLE1BQU0sR0FBRyxPQUFPQyxHQUFQLEtBQWUsVUFBZixHQUE0QixJQUFJQSxHQUFKLEVBQTVCLEdBQXdDQyxTQUFyRDs7RUFFQUMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCTixnQkFBZ0IsR0FBRyxTQUFTQSxnQkFBVCxDQUEwQkMsS0FBMUIsRUFBaUM7SUFDbkUsSUFBSUEsS0FBSyxLQUFLLElBQVYsSUFBa0IsQ0FBQ0gsZ0JBQWdCLENBQUNHLEtBQUQsQ0FBdkMsRUFBZ0QsT0FBT0EsS0FBUDs7SUFFaEQsSUFBSSxPQUFPQSxLQUFQLEtBQWlCLFVBQXJCLEVBQWlDO01BQy9CLE1BQU0sSUFBSU0sU0FBSixDQUFjLG9EQUFkLENBQU47SUFDRDs7SUFFRCxJQUFJLE9BQU9MLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7TUFDakMsSUFBSUEsTUFBTSxDQUFDTSxHQUFQLENBQVdQLEtBQVgsQ0FBSixFQUF1QixPQUFPQyxNQUFNLENBQUNPLEdBQVAsQ0FBV1IsS0FBWCxDQUFQOztNQUV2QkMsTUFBTSxDQUFDUSxHQUFQLENBQVdULEtBQVgsRUFBa0JVLE9BQWxCO0lBQ0Q7O0lBRUQsU0FBU0EsT0FBVCxHQUFtQjtNQUNqQixPQUFPWixTQUFTLENBQUNFLEtBQUQsRUFBUVcsU0FBUixFQUFtQmpCLGNBQWMsQ0FBQyxJQUFELENBQWQsQ0FBcUJrQixXQUF4QyxDQUFoQjtJQUNEOztJQUVERixPQUFPLENBQUNHLFNBQVIsR0FBb0JDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjZixLQUFLLENBQUNhLFNBQXBCLEVBQStCO01BQ2pERCxXQUFXLEVBQUU7UUFDWEksS0FBSyxFQUFFTixPQURJO1FBRVhPLFVBQVUsRUFBRSxLQUZEO1FBR1hDLFFBQVEsRUFBRSxJQUhDO1FBSVhDLFlBQVksRUFBRTtNQUpIO0lBRG9DLENBQS9CLENBQXBCO0lBUUEsT0FBT3ZCLGNBQWMsQ0FBQ2MsT0FBRCxFQUFVVixLQUFWLENBQXJCO0VBQ0QsQ0ExQkQsRUEwQkdJLHlCQUFBLEdBQTRCLElBMUIvQixFQTBCcUNBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BMUJ4RTtFQTJCQSxPQUFPTixnQkFBZ0IsQ0FBQ0MsS0FBRCxDQUF2QjtBQUNEOztBQUVESSxNQUFNLENBQUNDLE9BQVAsR0FBaUJOLGdCQUFqQixFQUFtQ0sseUJBQUEsR0FBNEIsSUFBL0QsRUFBcUVBLHlCQUFBLEdBQTRCQSxNQUFNLENBQUNDLE9BQXhHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlci5qcz9mNTIxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mLmpzXCIpO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcblxudmFyIGlzTmF0aXZlRnVuY3Rpb24gPSByZXF1aXJlKFwiLi9pc05hdGl2ZUZ1bmN0aW9uLmpzXCIpO1xuXG52YXIgY29uc3RydWN0ID0gcmVxdWlyZShcIi4vY29uc3RydWN0LmpzXCIpO1xuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcblxuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF93cmFwTmF0aXZlU3VwZXIsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOlsiZ2V0UHJvdG90eXBlT2YiLCJyZXF1aXJlIiwic2V0UHJvdG90eXBlT2YiLCJpc05hdGl2ZUZ1bmN0aW9uIiwiY29uc3RydWN0IiwiX3dyYXBOYXRpdmVTdXBlciIsIkNsYXNzIiwiX2NhY2hlIiwiTWFwIiwidW5kZWZpbmVkIiwibW9kdWxlIiwiZXhwb3J0cyIsIlR5cGVFcnJvciIsImhhcyIsImdldCIsInNldCIsIldyYXBwZXIiLCJhcmd1bWVudHMiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsInZhbHVlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/wrapNativeSuper.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// TODO(Babel 8): Remove this file.\nvar runtime = __webpack_require__(/*! ../helpers/regeneratorRuntime */ \"./node_modules/@babel/runtime/helpers/regeneratorRuntime.js\")();\n\nmodule.exports = runtime; // Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxPQUFPLEdBQUdDLG1CQUFPLENBQUMsa0dBQUQsQ0FBUCxFQUFkOztBQUNBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJILE9BQWpCLEMsQ0FFQTs7QUFDQSxJQUFJO0VBQ0ZJLGtCQUFrQixHQUFHSixPQUFyQjtBQUNELENBRkQsQ0FFRSxPQUFPSyxvQkFBUCxFQUE2QjtFQUM3QixJQUFJLE9BQU9DLFVBQVAsS0FBc0IsUUFBMUIsRUFBb0M7SUFDbENBLFVBQVUsQ0FBQ0Ysa0JBQVgsR0FBZ0NKLE9BQWhDO0VBQ0QsQ0FGRCxNQUVPO0lBQ0xPLFFBQVEsQ0FBQyxHQUFELEVBQU0sd0JBQU4sQ0FBUixDQUF3Q1AsT0FBeEM7RUFDRDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcz84MTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRPRE8oQmFiZWwgOCk6IFJlbW92ZSB0aGlzIGZpbGUuXG5cbnZhciBydW50aW1lID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvcmVnZW5lcmF0b3JSdW50aW1lXCIpKCk7XG5tb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG5cbi8vIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vcGFja2FnZXMvcnVudGltZS9ydW50aW1lLmpzI0w3MzY9XG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGVsc2Uge1xuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJydW50aW1lIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZWdlbmVyYXRvclJ1bnRpbWUiLCJhY2NpZGVudGFsU3RyaWN0TW9kZSIsImdsb2JhbFRoaXMiLCJGdW5jdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/regenerator/index.js\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_define_property.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_define_property.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _defineProperty; }\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fZGVmaW5lX3Byb3BlcnR5Lm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWUsU0FBU0EsZUFBVCxDQUF5QkMsR0FBekIsRUFBOEJDLEdBQTlCLEVBQW1DQyxLQUFuQyxFQUEwQztFQUN2RCxJQUFJRCxHQUFHLElBQUlELEdBQVgsRUFBZ0I7SUFDZEcsTUFBTSxDQUFDQyxjQUFQLENBQXNCSixHQUF0QixFQUEyQkMsR0FBM0IsRUFBZ0M7TUFDOUJDLEtBQUssRUFBRUEsS0FEdUI7TUFFOUJHLFVBQVUsRUFBRSxJQUZrQjtNQUc5QkMsWUFBWSxFQUFFLElBSGdCO01BSTlCQyxRQUFRLEVBQUU7SUFKb0IsQ0FBaEM7RUFNRCxDQVBELE1BT087SUFDTFAsR0FBRyxDQUFDQyxHQUFELENBQUgsR0FBV0MsS0FBWDtFQUNEOztFQUVELE9BQU9GLEdBQVA7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fZGVmaW5lX3Byb3BlcnR5Lm1qcz9iNTEyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuIl0sIm5hbWVzIjpbIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_define_property.mjs\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_object_spread.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_object_spread.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectSpread; }\n/* harmony export */ });\n/* harmony import */ var _define_property_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_define_property.mjs */ \"./node_modules/@swc/helpers/src/_define_property.mjs\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      (0,_define_property_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]);\n    });\n  }\n\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fb2JqZWN0X3NwcmVhZC5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUVlLFNBQVNDLGFBQVQsQ0FBdUJDLE1BQXZCLEVBQStCO0VBQzVDLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0MsU0FBUyxDQUFDQyxNQUE5QixFQUFzQ0YsQ0FBQyxFQUF2QyxFQUEyQztJQUN6QyxJQUFJRyxNQUFNLEdBQUdGLFNBQVMsQ0FBQ0QsQ0FBRCxDQUFULElBQWdCLElBQWhCLEdBQXVCQyxTQUFTLENBQUNELENBQUQsQ0FBaEMsR0FBc0MsRUFBbkQ7SUFDQSxJQUFJSSxPQUFPLEdBQUdDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZSCxNQUFaLENBQWQ7O0lBRUEsSUFBSSxPQUFPRSxNQUFNLENBQUNFLHFCQUFkLEtBQXdDLFVBQTVDLEVBQXdEO01BQ3RESCxPQUFPLEdBQUdBLE9BQU8sQ0FBQ0ksTUFBUixDQUFlSCxNQUFNLENBQUNFLHFCQUFQLENBQTZCSixNQUE3QixFQUFxQ00sTUFBckMsQ0FBNEMsVUFBVUMsR0FBVixFQUFlO1FBQ2xGLE9BQU9MLE1BQU0sQ0FBQ00sd0JBQVAsQ0FBZ0NSLE1BQWhDLEVBQXdDTyxHQUF4QyxFQUE2Q0UsVUFBcEQ7TUFDRCxDQUZ3QixDQUFmLENBQVY7SUFHRDs7SUFFRFIsT0FBTyxDQUFDUyxPQUFSLENBQWdCLFVBQVVDLEdBQVYsRUFBZTtNQUM3QmpCLGdFQUFjLENBQUNFLE1BQUQsRUFBU2UsR0FBVCxFQUFjWCxNQUFNLENBQUNXLEdBQUQsQ0FBcEIsQ0FBZDtJQUNELENBRkQ7RUFHRDs7RUFFRCxPQUFPZixNQUFQO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9zcmMvX29iamVjdF9zcHJlYWQubWpzPzdkNDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gJy4vX2RlZmluZV9wcm9wZXJ0eS5tanMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59Il0sIm5hbWVzIjpbImRlZmluZVByb3BlcnR5IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJvd25LZXlzIiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImNvbmNhdCIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJmb3JFYWNoIiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_object_spread.mjs\n"));

/***/ }),

/***/ "./node_modules/swr/dist/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/swr/dist/index.mjs ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SWRConfig\": function() { return /* binding */ SWRConfig; },\n/* harmony export */   \"default\": function() { return /* binding */ useSWR; },\n/* harmony export */   \"mutate\": function() { return /* binding */ mutate; },\n/* harmony export */   \"unstable_serialize\": function() { return /* binding */ unstable_serialize; },\n/* harmony export */   \"useSWRConfig\": function() { return /* binding */ useSWRConfig; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nvar noop = function () {}; // Using noop() as the undefined value as undefined can possibly be replaced\n// by something else.  Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\n\n\nvar UNDEFINED =\n/*#__NOINLINE__*/\nnoop();\nvar OBJECT = Object;\n\nvar isUndefined = function (v) {\n  return v === UNDEFINED;\n};\n\nvar isFunction = function (v) {\n  return typeof v == 'function';\n};\n\nvar mergeObjects = function (a, b) {\n  return OBJECT.assign({}, a, b);\n};\n\nvar STR_UNDEFINED = 'undefined'; // NOTE: Use function to guarantee it's re-evaluated between jsdom and node runtime for tests.\n\nvar hasWindow = function () {\n  return typeof window != STR_UNDEFINED;\n};\n\nvar hasDocument = function () {\n  return typeof document != STR_UNDEFINED;\n};\n\nvar hasRequestAnimationFrame = function () {\n  return hasWindow() && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\n}; // use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\n\n\nvar table = new WeakMap(); // counter of the key\n\nvar counter = 0; // A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsible.\n\nvar stableHash = function (arg) {\n  var type = typeof arg;\n  var constructor = arg && arg.constructor;\n  var isDate = constructor == Date;\n  var result;\n  var index;\n\n  if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n    // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n    // If it's already hashed, directly return the result.\n    result = table.get(arg);\n    if (result) return result; // Store the hash first for circular reference detection before entering the\n    // recursive `stableHash` calls.\n    // For other objects like set and map, we use this id directly as the hash.\n\n    result = ++counter + '~';\n    table.set(arg, result);\n\n    if (constructor == Array) {\n      // Array.\n      result = '@';\n\n      for (index = 0; index < arg.length; index++) {\n        result += stableHash(arg[index]) + ',';\n      }\n\n      table.set(arg, result);\n    }\n\n    if (constructor == OBJECT) {\n      // Object, sort keys.\n      result = '#';\n      var keys = OBJECT.keys(arg).sort();\n\n      while (!isUndefined(index = keys.pop())) {\n        if (!isUndefined(arg[index])) {\n          result += index + ':' + stableHash(arg[index]) + ',';\n        }\n      }\n\n      table.set(arg, result);\n    }\n  } else {\n    result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n  }\n\n  return result;\n};\n/**\n * Due to bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a work around, we always assume it's online on first load, and change\n * the status upon `online` or `offline` events.\n */\n\n\nvar online = true;\n\nvar isOnline = function () {\n  return online;\n};\n\nvar hasWin = hasWindow();\nvar hasDoc = hasDocument(); // For node and React Native, `add/removeEventListener` doesn't exist on window.\n\nvar onWindowEvent = hasWin && window.addEventListener ? window.addEventListener.bind(window) : noop;\nvar onDocumentEvent = hasDoc ? document.addEventListener.bind(document) : noop;\nvar offWindowEvent = hasWin && window.removeEventListener ? window.removeEventListener.bind(window) : noop;\nvar offDocumentEvent = hasDoc ? document.removeEventListener.bind(document) : noop;\n\nvar isVisible = function () {\n  var visibilityState = hasDoc && document.visibilityState;\n  return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\n\nvar initFocus = function (callback) {\n  // focus revalidate\n  onDocumentEvent('visibilitychange', callback);\n  onWindowEvent('focus', callback);\n  return function () {\n    offDocumentEvent('visibilitychange', callback);\n    offWindowEvent('focus', callback);\n  };\n};\n\nvar initReconnect = function (callback) {\n  // revalidate on reconnected\n  var onOnline = function () {\n    online = true;\n    callback();\n  }; // nothing to revalidate, just update the status\n\n\n  var onOffline = function () {\n    online = false;\n  };\n\n  onWindowEvent('online', onOnline);\n  onWindowEvent('offline', onOffline);\n  return function () {\n    offWindowEvent('online', onOnline);\n    offWindowEvent('offline', onOffline);\n  };\n};\n\nvar preset = {\n  isOnline: isOnline,\n  isVisible: isVisible\n};\nvar defaultConfigOptions = {\n  initFocus: initFocus,\n  initReconnect: initReconnect\n};\nvar IS_SERVER = !hasWindow() || 'Deno' in window; // Polyfill requestAnimationFrame\n\nvar rAF = function (f) {\n  return hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);\n}; // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\n\n\nvar useIsomorphicLayoutEffect = IS_SERVER ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect; // This assignment is to extend the Navigator type to use effectiveType.\n\nvar navigatorConnection = typeof navigator !== 'undefined' && navigator.connection; // Adjust the config based on slow connection status (<= 70Kbps).\n\nvar slowConnection = !IS_SERVER && navigatorConnection && (['slow-2g', '2g'].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\n\nvar serialize = function (key) {\n  if (isFunction(key)) {\n    try {\n      key = key();\n    } catch (err) {\n      // dependencies not ready\n      key = '';\n    }\n  }\n\n  var args = [].concat(key); // If key is not falsy, or not an empty array, hash it.\n\n  key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n  var infoKey = key ? '$swr$' + key : '';\n  return [key, args, infoKey];\n}; // Global state used to deduplicate requests and store listeners\n\n\nvar SWRGlobalState = new WeakMap();\nvar FOCUS_EVENT = 0;\nvar RECONNECT_EVENT = 1;\nvar MUTATE_EVENT = 2;\n\nvar broadcastState = function (cache, key, data, error, isValidating, revalidate, broadcast) {\n  if (broadcast === void 0) {\n    broadcast = true;\n  }\n\n  var _a = SWRGlobalState.get(cache),\n      EVENT_REVALIDATORS = _a[0],\n      STATE_UPDATERS = _a[1],\n      FETCH = _a[3];\n\n  var revalidators = EVENT_REVALIDATORS[key];\n  var updaters = STATE_UPDATERS[key]; // Cache was populated, update states of all hooks.\n\n  if (broadcast && updaters) {\n    for (var i = 0; i < updaters.length; ++i) {\n      updaters[i](data, error, isValidating);\n    }\n  } // If we also need to revalidate, only do it for the first hook.\n\n\n  if (revalidate) {\n    // Invalidate the key by deleting the concurrent request markers so new\n    // requests will not be deduped.\n    delete FETCH[key];\n\n    if (revalidators && revalidators[0]) {\n      return revalidators[0](MUTATE_EVENT).then(function () {\n        return cache.get(key);\n      });\n    }\n  }\n\n  return cache.get(key);\n}; // Global timestamp.\n\n\nvar __timestamp = 0;\n\nvar getTimestamp = function () {\n  return ++__timestamp;\n};\n\nvar internalMutate = function () {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  return __awaiter(void 0, void 0, void 0, function () {\n    var cache, _key, _data, _opts, options, populateCache, revalidate, rollbackOnError, customOptimisticData, _a, key, keyInfo, _b, MUTATION, data, error, beforeMutationTs, hasCustomOptimisticData, rollbackData, optimisticData, res;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          cache = args[0], _key = args[1], _data = args[2], _opts = args[3];\n          options = typeof _opts === 'boolean' ? {\n            revalidate: _opts\n          } : _opts || {};\n          populateCache = isUndefined(options.populateCache) ? true : options.populateCache;\n          revalidate = options.revalidate !== false;\n          rollbackOnError = options.rollbackOnError !== false;\n          customOptimisticData = options.optimisticData;\n          _a = serialize(_key), key = _a[0], keyInfo = _a[2];\n          if (!key) return [2\n          /*return*/\n          ];\n          _b = SWRGlobalState.get(cache), MUTATION = _b[2]; // If there is no new data provided, revalidate the key with current state.\n\n          if (args.length < 3) {\n            // Revalidate and broadcast state.\n            return [2\n            /*return*/\n            , broadcastState(cache, key, cache.get(key), UNDEFINED, UNDEFINED, revalidate, true)];\n          }\n\n          data = _data;\n          beforeMutationTs = getTimestamp();\n          MUTATION[key] = [beforeMutationTs, 0];\n          hasCustomOptimisticData = !isUndefined(customOptimisticData);\n          rollbackData = cache.get(key); // Do optimistic data update.\n\n          if (hasCustomOptimisticData) {\n            optimisticData = isFunction(customOptimisticData) ? customOptimisticData(rollbackData) : customOptimisticData;\n            cache.set(key, optimisticData);\n            broadcastState(cache, key, optimisticData);\n          }\n\n          if (isFunction(data)) {\n            // `data` is a function, call it passing current cache value.\n            try {\n              data = data(cache.get(key));\n            } catch (err) {\n              // If it throws an error synchronously, we shouldn't update the cache.\n              error = err;\n            }\n          }\n\n          if (!(data && isFunction(data.then))) return [3\n          /*break*/\n          , 2];\n          return [4\n          /*yield*/\n          , data.catch(function (err) {\n            error = err;\n          }) // Check if other mutations have occurred since we've started this mutation.\n          // If there's a race we don't update cache or broadcast the change,\n          // just return the data.\n          ];\n\n        case 1:\n          // This means that the mutation is async, we need to check timestamps to\n          // avoid race conditions.\n          data = _c.sent(); // Check if other mutations have occurred since we've started this mutation.\n          // If there's a race we don't update cache or broadcast the change,\n          // just return the data.\n\n          if (beforeMutationTs !== MUTATION[key][0]) {\n            if (error) throw error;\n            return [2\n            /*return*/\n            , data];\n          } else if (error && hasCustomOptimisticData && rollbackOnError) {\n            // Rollback. Always populate the cache in this case but without\n            // transforming the data.\n            populateCache = true;\n            data = rollbackData;\n            cache.set(key, rollbackData);\n          }\n\n          _c.label = 2;\n\n        case 2:\n          // If we should write back the cache after request.\n          if (populateCache) {\n            if (!error) {\n              // Transform the result into data.\n              if (isFunction(populateCache)) {\n                data = populateCache(data, rollbackData);\n              } // Only update cached data if there's no error. Data can be `undefined` here.\n\n\n              cache.set(key, data);\n            } // Always update or reset the error.\n\n\n            cache.set(keyInfo, mergeObjects(cache.get(keyInfo), {\n              error: error\n            }));\n          } // Reset the timestamp to mark the mutation has ended.\n\n\n          MUTATION[key][1] = getTimestamp();\n          return [4\n          /*yield*/\n          , broadcastState(cache, key, data, error, UNDEFINED, revalidate, !!populateCache) // Throw error or return data\n          ];\n\n        case 3:\n          res = _c.sent(); // Throw error or return data\n\n          if (error) throw error;\n          return [2\n          /*return*/\n          , populateCache ? res : data];\n      }\n    });\n  });\n};\n\nvar revalidateAllKeys = function (revalidators, type) {\n  for (var key in revalidators) {\n    if (revalidators[key][0]) revalidators[key][0](type);\n  }\n};\n\nvar initCache = function (provider, options) {\n  // The global state for a specific provider will be used to deduplicate\n  // requests and store listeners. As well as a mutate function that bound to\n  // the cache.\n  // Provider's global state might be already initialized. Let's try to get the\n  // global state associated with the provider first.\n  if (!SWRGlobalState.has(provider)) {\n    var opts = mergeObjects(defaultConfigOptions, options); // If there's no global state bound to the provider, create a new one with the\n    // new mutate function.\n\n    var EVENT_REVALIDATORS = {};\n    var mutate = internalMutate.bind(UNDEFINED, provider);\n    var unmount = noop; // Update the state if it's new, or the provider has been extended.\n\n    SWRGlobalState.set(provider, [EVENT_REVALIDATORS, {}, {}, {}, mutate]); // This is a new provider, we need to initialize it and setup DOM events\n    // listeners for `focus` and `reconnect` actions.\n\n    if (!IS_SERVER) {\n      // When listening to the native events for auto revalidations,\n      // we intentionally put a delay (setTimeout) here to make sure they are\n      // fired after immediate JavaScript executions, which can possibly be\n      // React's state updates.\n      // This avoids some unnecessary revalidations such as\n      // https://github.com/vercel/swr/issues/1680.\n      var releaseFocus_1 = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n      var releaseReconnect_1 = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n\n      unmount = function () {\n        releaseFocus_1 && releaseFocus_1();\n        releaseReconnect_1 && releaseReconnect_1(); // When un-mounting, we need to remove the cache provider from the state\n        // storage too because it's a side-effect. Otherwise when re-mounting we\n        // will not re-register those event listeners.\n\n        SWRGlobalState.delete(provider);\n      };\n    } // We might want to inject an extra layer on top of `provider` in the future,\n    // such as key serialization, auto GC, etc.\n    // For now, it's just a `Map` interface without any modifications.\n\n\n    return [provider, mutate, unmount];\n  }\n\n  return [provider, SWRGlobalState.get(provider)[4]];\n}; // error retry\n\n\nvar onErrorRetry = function (_, __, config, revalidate, opts) {\n  var maxRetryCount = config.errorRetryCount;\n  var currentRetryCount = opts.retryCount; // Exponential backoff\n\n  var timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n\n  if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n    return;\n  }\n\n  setTimeout(revalidate, timeout, opts);\n}; // Default cache provider\n\n\nvar _a = initCache(new Map()),\n    cache = _a[0],\n    mutate = _a[1]; // Default config\n\n\nvar defaultConfig = mergeObjects({\n  // events\n  onLoadingSlow: noop,\n  onSuccess: noop,\n  onError: noop,\n  onErrorRetry: onErrorRetry,\n  onDiscarded: noop,\n  // switches\n  revalidateOnFocus: true,\n  revalidateOnReconnect: true,\n  revalidateIfStale: true,\n  shouldRetryOnError: true,\n  // timeouts\n  errorRetryInterval: slowConnection ? 10000 : 5000,\n  focusThrottleInterval: 5 * 1000,\n  dedupingInterval: 2 * 1000,\n  loadingTimeout: slowConnection ? 5000 : 3000,\n  // providers\n  compare: function (currentData, newData) {\n    return stableHash(currentData) == stableHash(newData);\n  },\n  isPaused: function () {\n    return false;\n  },\n  cache: cache,\n  mutate: mutate,\n  fallback: {}\n}, // use web preset by default\npreset);\n\nvar mergeConfigs = function (a, b) {\n  // Need to create a new object to avoid mutating the original here.\n  var v = mergeObjects(a, b); // If two configs are provided, merge their `use` and `fallback` options.\n\n  if (b) {\n    var u1 = a.use,\n        f1 = a.fallback;\n    var u2 = b.use,\n        f2 = b.fallback;\n\n    if (u1 && u2) {\n      v.use = u1.concat(u2);\n    }\n\n    if (f1 && f2) {\n      v.fallback = mergeObjects(f1, f2);\n    }\n  }\n\n  return v;\n};\n\nvar SWRConfigContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\n\nvar SWRConfig$1 = function (props) {\n  var value = props.value; // Extend parent context values and middleware.\n\n  var extendedConfig = mergeConfigs((0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext), value); // Should not use the inherited provider.\n\n  var provider = value && value.provider; // Use a lazy initialized state to create the cache on first access.\n\n  var cacheContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function () {\n    return provider ? initCache(provider(extendedConfig.cache || cache), value) : UNDEFINED;\n  })[0]; // Override the cache if a new provider is given.\n\n  if (cacheContext) {\n    extendedConfig.cache = cacheContext[0];\n    extendedConfig.mutate = cacheContext[1];\n  } // Unsubscribe events.\n\n\n  useIsomorphicLayoutEffect(function () {\n    return cacheContext ? cacheContext[2] : UNDEFINED;\n  }, []);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SWRConfigContext.Provider, mergeObjects(props, {\n    value: extendedConfig\n  }));\n};\n/**\n * An implementation of state with dependency-tracking.\n */\n\n\nvar useStateWithDeps = function (state, unmountedRef) {\n  var rerender = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({})[1];\n  var stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state); // If a state property (data, error or isValidating) is accessed by the render\n  // function, we mark the property as a dependency so if it is updated again\n  // in the future, we trigger a rerender.\n  // This is also known as dependency-tracking.\n\n  var stateDependenciesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    data: false,\n    error: false,\n    isValidating: false\n  });\n  /**\n   * @param payload To change stateRef, pass the values explicitly to setState:\n   * @example\n   * ```js\n   * setState({\n   *   isValidating: false\n   *   data: newData // set data to newData\n   *   error: undefined // set error to undefined\n   * })\n   *\n   * setState({\n   *   isValidating: false\n   *   data: undefined // set data to undefined\n   *   error: err // set error to err\n   * })\n   * ```\n   */\n\n  var setState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (payload) {\n    var shouldRerender = false;\n    var currentState = stateRef.current;\n\n    for (var _ in payload) {\n      var k = _; // If the property has changed, update the state and mark rerender as\n      // needed.\n\n      if (currentState[k] !== payload[k]) {\n        currentState[k] = payload[k]; // If the property is accessed by the component, a rerender should be\n        // triggered.\n\n        if (stateDependenciesRef.current[k]) {\n          shouldRerender = true;\n        }\n      }\n    }\n\n    if (shouldRerender && !unmountedRef.current) {\n      rerender({});\n    }\n  }, // config.suspense isn't allowed to change during the lifecycle\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []); // Always update the state reference.\n\n  useIsomorphicLayoutEffect(function () {\n    stateRef.current = state;\n  });\n  return [stateRef, stateDependenciesRef.current, setState];\n};\n\nvar normalize = function (args) {\n  return isFunction(args[1]) ? [args[0], args[1], args[2] || {}] : [args[0], null, (args[1] === null ? args[2] : args[1]) || {}];\n};\n\nvar useSWRConfig = function () {\n  return mergeObjects(defaultConfig, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext));\n}; // It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\n\n\nvar withArgs = function (hook) {\n  return function useSWRArgs() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    } // Get the default and inherited configuration.\n\n\n    var fallbackConfig = useSWRConfig(); // Normalize arguments.\n\n    var _a = normalize(args),\n        key = _a[0],\n        fn = _a[1],\n        _config = _a[2]; // Merge configurations.\n\n\n    var config = mergeConfigs(fallbackConfig, _config); // Apply middleware\n\n    var next = hook;\n    var use = config.use;\n\n    if (use) {\n      for (var i = use.length; i-- > 0;) {\n        next = use[i](next);\n      }\n    }\n\n    return next(key, fn || config.fetcher, config);\n  };\n}; // Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\n\n\nvar subscribeCallback = function (key, callbacks, callback) {\n  var keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n  keyedRevalidators.push(callback);\n  return function () {\n    var index = keyedRevalidators.indexOf(callback);\n\n    if (index >= 0) {\n      // O(1): faster than splice\n      keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n      keyedRevalidators.pop();\n    }\n  };\n};\n\nvar WITH_DEDUPE = {\n  dedupe: true\n};\n\nvar useSWRHandler = function (_key, fetcher, config) {\n  var cache = config.cache,\n      compare = config.compare,\n      fallbackData = config.fallbackData,\n      suspense = config.suspense,\n      revalidateOnMount = config.revalidateOnMount,\n      refreshInterval = config.refreshInterval,\n      refreshWhenHidden = config.refreshWhenHidden,\n      refreshWhenOffline = config.refreshWhenOffline;\n\n  var _a = SWRGlobalState.get(cache),\n      EVENT_REVALIDATORS = _a[0],\n      STATE_UPDATERS = _a[1],\n      MUTATION = _a[2],\n      FETCH = _a[3]; // `key` is the identifier of the SWR `data` state, `keyInfo` holds extra\n  // states such as `error` and `isValidating` inside,\n  // all of them are derived from `_key`.\n  // `fnArgs` is an array of arguments parsed from the key, which will be passed\n  // to the fetcher.\n\n\n  var _b = serialize(_key),\n      key = _b[0],\n      fnArgs = _b[1],\n      keyInfo = _b[2]; // If it's the initial render of this hook.\n\n\n  var initialMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false); // If the hook is unmounted already. This will be used to prevent some effects\n  // to be called after unmounting.\n\n  var unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false); // Refs to keep the key and config.\n\n  var keyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(key);\n  var fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fetcher);\n  var configRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(config);\n\n  var getConfig = function () {\n    return configRef.current;\n  };\n\n  var isActive = function () {\n    return getConfig().isVisible() && getConfig().isOnline();\n  };\n\n  var patchFetchInfo = function (info) {\n    return cache.set(keyInfo, mergeObjects(cache.get(keyInfo), info));\n  }; // Get the current state that SWR should return.\n\n\n  var cached = cache.get(key);\n  var fallback = isUndefined(fallbackData) ? config.fallback[key] : fallbackData;\n  var data = isUndefined(cached) ? fallback : cached;\n  var info = cache.get(keyInfo) || {};\n  var error = info.error;\n  var isInitialMount = !initialMountedRef.current; // - Suspense mode and there's stale data for the initial render.\n  // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.\n  // - `revalidateIfStale` is enabled but `data` is not defined.\n\n  var shouldRevalidate = function () {\n    // If `revalidateOnMount` is set, we take the value directly.\n    if (isInitialMount && !isUndefined(revalidateOnMount)) return revalidateOnMount; // If it's paused, we skip revalidation.\n\n    if (getConfig().isPaused()) return false; // Under suspense mode, it will always fetch on render if there is no\n    // stale data so no need to revalidate immediately on mount again.\n    // If data exists, only revalidate if `revalidateIfStale` is true.\n\n    if (suspense) return isUndefined(data) ? false : config.revalidateIfStale; // If there is no stale data, we need to revalidate on mount;\n    // If `revalidateIfStale` is set to true, we will always revalidate.\n\n    return isUndefined(data) || config.revalidateIfStale;\n  }; // Resolve the current validating state.\n\n\n  var resolveValidating = function () {\n    if (!key || !fetcher) return false;\n    if (info.isValidating) return true; // If it's not mounted yet and it should revalidate on mount, revalidate.\n\n    return isInitialMount && shouldRevalidate();\n  };\n\n  var isValidating = resolveValidating();\n\n  var _c = useStateWithDeps({\n    data: data,\n    error: error,\n    isValidating: isValidating\n  }, unmountedRef),\n      stateRef = _c[0],\n      stateDependencies = _c[1],\n      setState = _c[2]; // The revalidation function is a carefully crafted wrapper of the original\n  // `fetcher`, to correctly handle the many edge cases.\n\n\n  var revalidate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (revalidateOpts) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var currentFetcher, newData, startAt, loading, opts, shouldStartNewRequest, isCurrentKeyMounted, cleanupState, newState, finishRequestAndUpdateState, mutationInfo, err_1;\n\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            currentFetcher = fetcherRef.current;\n\n            if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {\n              return [2\n              /*return*/\n              , false];\n            }\n\n            loading = true;\n            opts = revalidateOpts || {};\n            shouldStartNewRequest = !FETCH[key] || !opts.dedupe;\n\n            isCurrentKeyMounted = function () {\n              return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;\n            };\n\n            cleanupState = function () {\n              // Check if it's still the same request before deleting.\n              var requestInfo = FETCH[key];\n\n              if (requestInfo && requestInfo[1] === startAt) {\n                delete FETCH[key];\n              }\n            };\n\n            newState = {\n              isValidating: false\n            };\n\n            finishRequestAndUpdateState = function () {\n              patchFetchInfo({\n                isValidating: false\n              }); // We can only set state if it's safe (still mounted with the same key).\n\n              if (isCurrentKeyMounted()) {\n                setState(newState);\n              }\n            }; // Start fetching. Change the `isValidating` state, update the cache.\n\n\n            patchFetchInfo({\n              isValidating: true\n            });\n            setState({\n              isValidating: true\n            });\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n\n            if (shouldStartNewRequest) {\n              // Tell all other hooks to change the `isValidating` state.\n              broadcastState(cache, key, stateRef.current.data, stateRef.current.error, true); // If no cache being rendered currently (it shows a blank page),\n              // we trigger the loading slow event.\n\n              if (config.loadingTimeout && !cache.get(key)) {\n                setTimeout(function () {\n                  if (loading && isCurrentKeyMounted()) {\n                    getConfig().onLoadingSlow(key, config);\n                  }\n                }, config.loadingTimeout);\n              } // Start the request and save the timestamp.\n\n\n              FETCH[key] = [currentFetcher.apply(void 0, fnArgs), getTimestamp()];\n            }\n\n            _a = FETCH[key], newData = _a[0], startAt = _a[1];\n            return [4\n            /*yield*/\n            , newData];\n\n          case 2:\n            newData = _b.sent();\n\n            if (shouldStartNewRequest) {\n              // If the request isn't interrupted, clean it up after the\n              // deduplication interval.\n              setTimeout(cleanupState, config.dedupingInterval);\n            } // If there're other ongoing request(s), started after the current one,\n            // we need to ignore the current one to avoid possible race conditions:\n            //   req1------------------>res1        (current one)\n            //        req2---------------->res2\n            // the request that fired later will always be kept.\n            // The timestamp maybe be `undefined` or a number\n\n\n            if (!FETCH[key] || FETCH[key][1] !== startAt) {\n              if (shouldStartNewRequest) {\n                if (isCurrentKeyMounted()) {\n                  getConfig().onDiscarded(key);\n                }\n              }\n\n              return [2\n              /*return*/\n              , false];\n            } // Clear error.\n\n\n            patchFetchInfo({\n              error: UNDEFINED\n            });\n            newState.error = UNDEFINED;\n            mutationInfo = MUTATION[key];\n\n            if (!isUndefined(mutationInfo) && ( // case 1\n            startAt <= mutationInfo[0] || // case 2\n            startAt <= mutationInfo[1] || // case 3\n            mutationInfo[1] === 0)) {\n              finishRequestAndUpdateState();\n\n              if (shouldStartNewRequest) {\n                if (isCurrentKeyMounted()) {\n                  getConfig().onDiscarded(key);\n                }\n              }\n\n              return [2\n              /*return*/\n              , false];\n            } // Deep compare with latest state to avoid extra re-renders.\n            // For local state, compare and assign.\n\n\n            if (!compare(stateRef.current.data, newData)) {\n              newState.data = newData;\n            } else {\n              // data and newData are deeply equal\n              // it should be safe to broadcast the stale data\n              newState.data = stateRef.current.data; // At the end of this function, `brocastState` invokes the `onStateUpdate` function,\n              // which takes care of avoiding the re-render\n            } // For global state, it's possible that the key has changed.\n            // https://github.com/vercel/swr/pull/1058\n\n\n            if (!compare(cache.get(key), newData)) {\n              cache.set(key, newData);\n            } // Trigger the successful callback if it's the original request.\n\n\n            if (shouldStartNewRequest) {\n              if (isCurrentKeyMounted()) {\n                getConfig().onSuccess(newData, key, config);\n              }\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            err_1 = _b.sent();\n            cleanupState(); // Not paused, we continue handling the error. Otherwise discard it.\n\n            if (!getConfig().isPaused()) {\n              // Get a new error, don't use deep comparison for errors.\n              patchFetchInfo({\n                error: err_1\n              });\n              newState.error = err_1; // Error event and retry logic. Only for the actual request, not\n              // deduped ones.\n\n              if (shouldStartNewRequest && isCurrentKeyMounted()) {\n                getConfig().onError(err_1, key, config);\n\n                if (typeof config.shouldRetryOnError === 'boolean' && config.shouldRetryOnError || isFunction(config.shouldRetryOnError) && config.shouldRetryOnError(err_1)) {\n                  // When retrying, dedupe is always enabled\n                  if (isActive()) {\n                    // If it's active, stop. It will auto revalidate when refocusing\n                    // or reconnecting.\n                    getConfig().onErrorRetry(err_1, key, config, revalidate, {\n                      retryCount: (opts.retryCount || 0) + 1,\n                      dedupe: true\n                    });\n                  }\n                }\n              }\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            // Mark loading as stopped.\n            loading = false; // Update the current hook's state.\n\n            finishRequestAndUpdateState(); // Here is the source of the request, need to tell all other hooks to\n            // update their states.\n\n            if (isCurrentKeyMounted() && shouldStartNewRequest) {\n              broadcastState(cache, key, newState.data, newState.error, false);\n            }\n\n            return [2\n            /*return*/\n            , true];\n        }\n      });\n    });\n  }, // `setState` is immutable, and `eventsCallback`, `fnArgs`, `keyInfo`,\n  // and `keyValidating` are depending on `key`, so we can exclude them from\n  // the deps array.\n  //\n  // FIXME:\n  // `fn` and `config` might be changed during the lifecycle,\n  // but they might be changed every render like this.\n  // `useSWR('key', () => fetch('/api/'), { suspense: true })`\n  // So we omit the values from the deps array\n  // even though it might cause unexpected behaviors.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [key]); // Similar to the global mutate, but bound to the current cache and key.\n  // `cache` isn't allowed to change during the lifecycle.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  var boundMutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)( // By using `bind` we don't need to modify the size of the rest arguments.\n  // Due to https://github.com/microsoft/TypeScript/issues/37181, we have to\n  // cast it to any for now.\n  internalMutate.bind(UNDEFINED, cache, function () {\n    return keyRef.current;\n  }), // eslint-disable-next-line react-hooks/exhaustive-deps\n  []); // Always update fetcher and config refs.\n\n  useIsomorphicLayoutEffect(function () {\n    fetcherRef.current = fetcher;\n    configRef.current = config;\n  }); // After mounted or key changed.\n\n  useIsomorphicLayoutEffect(function () {\n    if (!key) return;\n    var keyChanged = key !== keyRef.current;\n    var softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE); // Expose state updater to global event listeners. So we can update hook's\n    // internal state from the outside.\n\n    var onStateUpdate = function (updatedData, updatedError, updatedIsValidating) {\n      setState(mergeObjects({\n        error: updatedError,\n        isValidating: updatedIsValidating\n      }, // Since `setState` only shallowly compares states, we do a deep\n      // comparison here.\n      compare(stateRef.current.data, updatedData) ? UNDEFINED : {\n        data: updatedData\n      }));\n    }; // Expose revalidators to global event listeners. So we can trigger\n    // revalidation from the outside.\n\n\n    var nextFocusRevalidatedAt = 0;\n\n    var onRevalidate = function (type) {\n      if (type == FOCUS_EVENT) {\n        var now = Date.now();\n\n        if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {\n          nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;\n          softRevalidate();\n        }\n      } else if (type == RECONNECT_EVENT) {\n        if (getConfig().revalidateOnReconnect && isActive()) {\n          softRevalidate();\n        }\n      } else if (type == MUTATE_EVENT) {\n        return revalidate();\n      }\n\n      return;\n    };\n\n    var unsubUpdate = subscribeCallback(key, STATE_UPDATERS, onStateUpdate);\n    var unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate); // Mark the component as mounted and update corresponding refs.\n\n    unmountedRef.current = false;\n    keyRef.current = key;\n    initialMountedRef.current = true; // When `key` updates, reset the state to the initial value\n    // and trigger a rerender if necessary.\n\n    if (keyChanged) {\n      setState({\n        data: data,\n        error: error,\n        isValidating: isValidating\n      });\n    } // Trigger a revalidation.\n\n\n    if (shouldRevalidate()) {\n      if (isUndefined(data) || IS_SERVER) {\n        // Revalidate immediately.\n        softRevalidate();\n      } else {\n        // Delay the revalidate if we have data to return so we won't block\n        // rendering.\n        rAF(softRevalidate);\n      }\n    }\n\n    return function () {\n      // Mark it as unmounted.\n      unmountedRef.current = true;\n      unsubUpdate();\n      unsubEvents();\n    };\n  }, [key, revalidate]); // Polling\n\n  useIsomorphicLayoutEffect(function () {\n    var timer;\n\n    function next() {\n      // Use the passed interval\n      // ...or invoke the function with the updated data to get the interval\n      var interval = isFunction(refreshInterval) ? refreshInterval(data) : refreshInterval; // We only start next interval if `refreshInterval` is not 0, and:\n      // - `force` is true, which is the start of polling\n      // - or `timer` is not 0, which means the effect wasn't canceled\n\n      if (interval && timer !== -1) {\n        timer = setTimeout(execute, interval);\n      }\n    }\n\n    function execute() {\n      // Check if it's OK to execute:\n      // Only revalidate when the page is visible, online and not errored.\n      if (!stateRef.current.error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {\n        revalidate(WITH_DEDUPE).then(next);\n      } else {\n        // Schedule next interval to check again.\n        next();\n      }\n    }\n\n    next();\n    return function () {\n      if (timer) {\n        clearTimeout(timer);\n        timer = -1;\n      }\n    };\n  }, [refreshInterval, refreshWhenHidden, refreshWhenOffline, revalidate]); // Display debug info in React DevTools.\n\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(data); // In Suspense mode, we can't return the empty `data` state.\n  // If there is `error`, the `error` needs to be thrown to the error boundary.\n  // If there is no `error`, the `revalidation` promise needs to be thrown to\n  // the suspense boundary.\n\n  if (suspense && isUndefined(data) && key) {\n    // Always update fetcher and config refs even with the Suspense mode.\n    fetcherRef.current = fetcher;\n    configRef.current = config;\n    unmountedRef.current = false;\n    throw isUndefined(error) ? revalidate(WITH_DEDUPE) : error;\n  }\n\n  return {\n    mutate: boundMutate,\n\n    get data() {\n      stateDependencies.data = true;\n      return data;\n    },\n\n    get error() {\n      stateDependencies.error = true;\n      return error;\n    },\n\n    get isValidating() {\n      stateDependencies.isValidating = true;\n      return isValidating;\n    }\n\n  };\n};\n\nvar SWRConfig = OBJECT.defineProperty(SWRConfig$1, 'default', {\n  value: defaultConfig\n});\n\nvar unstable_serialize = function (key) {\n  return serialize(key)[0];\n};\n\nvar useSWR = withArgs(useSWRHandler); // useSWR\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBMEM7SUFDdEM7SUFDQXNJLFVBQVUsQ0FBQzNCLE9BQVgsR0FBcUJVLE9BQXJCO0lBQ0FrQixTQUFTLENBQUM1QixPQUFWLEdBQW9CakQsTUFBcEI7SUFDQXlDLFlBQVksQ0FBQ1EsT0FBYixHQUF1QixLQUF2QjtJQUNBLE1BQU0zSyxXQUFXLENBQUM2RSxLQUFELENBQVgsR0FBcUJFLFVBQVUsQ0FBQzJHLFdBQUQsQ0FBL0IsR0FBK0M3RyxLQUFyRDtFQUNIOztFQUNELE9BQU87SUFDSHNDLE1BQU0sRUFBRTBHLFdBREw7O0lBRUgsSUFBSWpKLElBQUosR0FBVztNQUNQb0ksaUJBQWlCLENBQUNwSSxJQUFsQixHQUF5QixJQUF6QjtNQUNBLE9BQU9BLElBQVA7SUFDSCxDQUxFOztJQU1ILElBQUlDLEtBQUosR0FBWTtNQUNSbUksaUJBQWlCLENBQUNuSSxLQUFsQixHQUEwQixJQUExQjtNQUNBLE9BQU9BLEtBQVA7SUFDSCxDQVRFOztJQVVILElBQUlDLFlBQUosR0FBbUI7TUFDZmtJLGlCQUFpQixDQUFDbEksWUFBbEIsR0FBaUMsSUFBakM7TUFDQSxPQUFPQSxZQUFQO0lBQ0g7O0VBYkUsQ0FBUDtBQWVILENBeFpEOztBQXlaQSxJQUFJK0osU0FBUyxHQUFHL08sTUFBTSxDQUFDZ1AsY0FBUCxDQUFzQmxGLFdBQXRCLEVBQW1DLFNBQW5DLEVBQThDO0VBQzFEbk0sS0FBSyxFQUFFMks7QUFEbUQsQ0FBOUMsQ0FBaEI7O0FBR0EsSUFBSTJHLGtCQUFrQixHQUFHLFVBQVUvSyxHQUFWLEVBQWU7RUFBRSxPQUFPRCxTQUFTLENBQUNDLEdBQUQsQ0FBVCxDQUFlLENBQWYsQ0FBUDtBQUEyQixDQUFyRTs7QUFDQSxJQUFJZ0wsTUFBTSxHQUFHakUsUUFBUSxDQUFDYSxhQUFELENBQXJCLEVBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N3ci9kaXN0L2luZGV4Lm1qcz82MmUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgY3JlYXRlRWxlbWVudCwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlRGVidWdWYWx1ZSB9IGZyb20gJ3JlYWN0JztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuLy8gVXNpbmcgbm9vcCgpIGFzIHRoZSB1bmRlZmluZWQgdmFsdWUgYXMgdW5kZWZpbmVkIGNhbiBwb3NzaWJseSBiZSByZXBsYWNlZFxuLy8gYnkgc29tZXRoaW5nIGVsc2UuICBQcmV0dGllciBpZ25vcmUgYW5kIGV4dHJhIHBhcmVudGhlc2VzIGFyZSBuZWNlc3NhcnkgaGVyZVxuLy8gdG8gZW5zdXJlIHRoYXQgdHNjIGRvZXNuJ3QgcmVtb3ZlIHRoZSBfX05PSU5MSU5FX18gY29tbWVudC5cbi8vIHByZXR0aWVyLWlnbm9yZVxudmFyIFVOREVGSU5FRCA9ICggLyojX19OT0lOTElORV9fKi9ub29wKCkpO1xudmFyIE9CSkVDVCA9IE9iamVjdDtcbnZhciBpc1VuZGVmaW5lZCA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ID09PSBVTkRFRklORUQ7IH07XG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0eXBlb2YgdiA9PSAnZnVuY3Rpb24nOyB9O1xudmFyIG1lcmdlT2JqZWN0cyA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBPQkpFQ1QuYXNzaWduKHt9LCBhLCBiKTsgfTtcbnZhciBTVFJfVU5ERUZJTkVEID0gJ3VuZGVmaW5lZCc7XG4vLyBOT1RFOiBVc2UgZnVuY3Rpb24gdG8gZ3VhcmFudGVlIGl0J3MgcmUtZXZhbHVhdGVkIGJldHdlZW4ganNkb20gYW5kIG5vZGUgcnVudGltZSBmb3IgdGVzdHMuXG52YXIgaGFzV2luZG93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPSBTVFJfVU5ERUZJTkVEOyB9O1xudmFyIGhhc0RvY3VtZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9IFNUUl9VTkRFRklORUQ7IH07XG52YXIgaGFzUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBoYXNXaW5kb3coKSAmJiB0eXBlb2Ygd2luZG93WydyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXSAhPSBTVFJfVU5ERUZJTkVEO1xufTtcblxuLy8gdXNlIFdlYWtNYXAgdG8gc3RvcmUgdGhlIG9iamVjdC0+a2V5IG1hcHBpbmdcbi8vIHNvIHRoZSBvYmplY3RzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbi8vIFdlYWtNYXAgdXNlcyBhIGhhc2h0YWJsZSB1bmRlciB0aGUgaG9vZCwgc28gdGhlIGxvb2t1cFxuLy8gY29tcGxleGl0eSBpcyBhbG1vc3QgTygxKS5cbnZhciB0YWJsZSA9IG5ldyBXZWFrTWFwKCk7XG4vLyBjb3VudGVyIG9mIHRoZSBrZXlcbnZhciBjb3VudGVyID0gMDtcbi8vIEEgc3RhYmxlIGhhc2ggaW1wbGVtZW50YXRpb24gdGhhdCBzdXBwb3J0czpcbi8vIC0gRmFzdCBhbmQgZW5zdXJlcyB1bmlxdWUgaGFzaCBwcm9wZXJ0aWVzXG4vLyAtIEhhbmRsZXMgdW5zZXJpYWxpemFibGUgdmFsdWVzXG4vLyAtIEhhbmRsZXMgb2JqZWN0IGtleSBvcmRlcmluZ1xuLy8gLSBHZW5lcmF0ZXMgc2hvcnQgcmVzdWx0c1xuLy9cbi8vIFRoaXMgaXMgbm90IGEgc2VyaWFsaXphdGlvbiBmdW5jdGlvbiwgYW5kIHRoZSByZXN1bHQgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmVcbi8vIHBhcnNpYmxlLlxudmFyIHN0YWJsZUhhc2ggPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGFyZyAmJiBhcmcuY29uc3RydWN0b3I7XG4gICAgdmFyIGlzRGF0ZSA9IGNvbnN0cnVjdG9yID09IERhdGU7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgaW5kZXg7XG4gICAgaWYgKE9CSkVDVChhcmcpID09PSBhcmcgJiYgIWlzRGF0ZSAmJiBjb25zdHJ1Y3RvciAhPSBSZWdFeHApIHtcbiAgICAgICAgLy8gT2JqZWN0L2Z1bmN0aW9uLCBub3QgbnVsbC9kYXRlL3JlZ2V4cC4gVXNlIFdlYWtNYXAgdG8gc3RvcmUgdGhlIGlkIGZpcnN0LlxuICAgICAgICAvLyBJZiBpdCdzIGFscmVhZHkgaGFzaGVkLCBkaXJlY3RseSByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgICAgcmVzdWx0ID0gdGFibGUuZ2V0KGFyZyk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAvLyBTdG9yZSB0aGUgaGFzaCBmaXJzdCBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGlvbiBiZWZvcmUgZW50ZXJpbmcgdGhlXG4gICAgICAgIC8vIHJlY3Vyc2l2ZSBgc3RhYmxlSGFzaGAgY2FsbHMuXG4gICAgICAgIC8vIEZvciBvdGhlciBvYmplY3RzIGxpa2Ugc2V0IGFuZCBtYXAsIHdlIHVzZSB0aGlzIGlkIGRpcmVjdGx5IGFzIHRoZSBoYXNoLlxuICAgICAgICByZXN1bHQgPSArK2NvdW50ZXIgKyAnfic7XG4gICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PSBBcnJheSkge1xuICAgICAgICAgICAgLy8gQXJyYXkuXG4gICAgICAgICAgICByZXN1bHQgPSAnQCc7XG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBhcmcubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0YWJsZUhhc2goYXJnW2luZGV4XSkgKyAnLCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PSBPQkpFQ1QpIHtcbiAgICAgICAgICAgIC8vIE9iamVjdCwgc29ydCBrZXlzLlxuICAgICAgICAgICAgcmVzdWx0ID0gJyMnO1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPQkpFQ1Qua2V5cyhhcmcpLnNvcnQoKTtcbiAgICAgICAgICAgIHdoaWxlICghaXNVbmRlZmluZWQoKGluZGV4ID0ga2V5cy5wb3AoKSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChhcmdbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gaW5kZXggKyAnOicgKyBzdGFibGVIYXNoKGFyZ1tpbmRleF0pICsgJywnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGlzRGF0ZVxuICAgICAgICAgICAgPyBhcmcudG9KU09OKClcbiAgICAgICAgICAgIDogdHlwZSA9PSAnc3ltYm9sJ1xuICAgICAgICAgICAgICAgID8gYXJnLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICA6IHR5cGUgPT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeShhcmcpXG4gICAgICAgICAgICAgICAgICAgIDogJycgKyBhcmc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIER1ZSB0byBidWcgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Njc4MDc1LFxuICogaXQncyBub3QgcmVsaWFibGUgdG8gZGV0ZWN0IGlmIHRoZSBicm93c2VyIGlzIGN1cnJlbnRseSBvbmxpbmUgb3Igb2ZmbGluZVxuICogYmFzZWQgb24gYG5hdmlnYXRvci5vbkxpbmVgLlxuICogQXMgYSB3b3JrIGFyb3VuZCwgd2UgYWx3YXlzIGFzc3VtZSBpdCdzIG9ubGluZSBvbiBmaXJzdCBsb2FkLCBhbmQgY2hhbmdlXG4gKiB0aGUgc3RhdHVzIHVwb24gYG9ubGluZWAgb3IgYG9mZmxpbmVgIGV2ZW50cy5cbiAqL1xudmFyIG9ubGluZSA9IHRydWU7XG52YXIgaXNPbmxpbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvbmxpbmU7IH07XG52YXIgaGFzV2luID0gaGFzV2luZG93KCk7XG52YXIgaGFzRG9jID0gaGFzRG9jdW1lbnQoKTtcbi8vIEZvciBub2RlIGFuZCBSZWFjdCBOYXRpdmUsIGBhZGQvcmVtb3ZlRXZlbnRMaXN0ZW5lcmAgZG9lc24ndCBleGlzdCBvbiB3aW5kb3cuXG52YXIgb25XaW5kb3dFdmVudCA9IGhhc1dpbiAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgID8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIuYmluZCh3aW5kb3cpXG4gICAgOiBub29wO1xudmFyIG9uRG9jdW1lbnRFdmVudCA9IGhhc0RvYyA/IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIuYmluZChkb2N1bWVudCkgOiBub29wO1xudmFyIG9mZldpbmRvd0V2ZW50ID0gaGFzV2luICYmIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyXG4gICAgPyB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKHdpbmRvdylcbiAgICA6IG5vb3A7XG52YXIgb2ZmRG9jdW1lbnRFdmVudCA9IGhhc0RvY1xuICAgID8gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKGRvY3VtZW50KVxuICAgIDogbm9vcDtcbnZhciBpc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZpc2liaWxpdHlTdGF0ZSA9IGhhc0RvYyAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGU7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHZpc2liaWxpdHlTdGF0ZSkgfHwgdmlzaWJpbGl0eVN0YXRlICE9PSAnaGlkZGVuJztcbn07XG52YXIgaW5pdEZvY3VzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgLy8gZm9jdXMgcmV2YWxpZGF0ZVxuICAgIG9uRG9jdW1lbnRFdmVudCgndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKTtcbiAgICBvbldpbmRvd0V2ZW50KCdmb2N1cycsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBvZmZEb2N1bWVudEV2ZW50KCd2aXNpYmlsaXR5Y2hhbmdlJywgY2FsbGJhY2spO1xuICAgICAgICBvZmZXaW5kb3dFdmVudCgnZm9jdXMnLCBjYWxsYmFjayk7XG4gICAgfTtcbn07XG52YXIgaW5pdFJlY29ubmVjdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIHJldmFsaWRhdGUgb24gcmVjb25uZWN0ZWRcbiAgICB2YXIgb25PbmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9ubGluZSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgICAvLyBub3RoaW5nIHRvIHJldmFsaWRhdGUsIGp1c3QgdXBkYXRlIHRoZSBzdGF0dXNcbiAgICB2YXIgb25PZmZsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbmxpbmUgPSBmYWxzZTtcbiAgICB9O1xuICAgIG9uV2luZG93RXZlbnQoJ29ubGluZScsIG9uT25saW5lKTtcbiAgICBvbldpbmRvd0V2ZW50KCdvZmZsaW5lJywgb25PZmZsaW5lKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBvZmZXaW5kb3dFdmVudCgnb25saW5lJywgb25PbmxpbmUpO1xuICAgICAgICBvZmZXaW5kb3dFdmVudCgnb2ZmbGluZScsIG9uT2ZmbGluZSk7XG4gICAgfTtcbn07XG52YXIgcHJlc2V0ID0ge1xuICAgIGlzT25saW5lOiBpc09ubGluZSxcbiAgICBpc1Zpc2libGU6IGlzVmlzaWJsZVxufTtcbnZhciBkZWZhdWx0Q29uZmlnT3B0aW9ucyA9IHtcbiAgICBpbml0Rm9jdXM6IGluaXRGb2N1cyxcbiAgICBpbml0UmVjb25uZWN0OiBpbml0UmVjb25uZWN0XG59O1xuXG52YXIgSVNfU0VSVkVSID0gIWhhc1dpbmRvdygpIHx8ICdEZW5vJyBpbiB3aW5kb3c7XG4vLyBQb2x5ZmlsbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbnZhciByQUYgPSBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBoYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSA/IHdpbmRvd1sncmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10oZikgOiBzZXRUaW1lb3V0KGYsIDEpO1xufTtcbi8vIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXG4vLyBUbyBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxuLy8gdXNlTGF5b3V0RWZmZWN0IGluIHRoZSBicm93c2VyLlxudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBJU19TRVJWRVIgPyB1c2VFZmZlY3QgOiB1c2VMYXlvdXRFZmZlY3Q7XG4vLyBUaGlzIGFzc2lnbm1lbnQgaXMgdG8gZXh0ZW5kIHRoZSBOYXZpZ2F0b3IgdHlwZSB0byB1c2UgZWZmZWN0aXZlVHlwZS5cbnZhciBuYXZpZ2F0b3JDb25uZWN0aW9uID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBuYXZpZ2F0b3IuY29ubmVjdGlvbjtcbi8vIEFkanVzdCB0aGUgY29uZmlnIGJhc2VkIG9uIHNsb3cgY29ubmVjdGlvbiBzdGF0dXMgKDw9IDcwS2JwcykuXG52YXIgc2xvd0Nvbm5lY3Rpb24gPSAhSVNfU0VSVkVSICYmXG4gICAgbmF2aWdhdG9yQ29ubmVjdGlvbiAmJlxuICAgIChbJ3Nsb3ctMmcnLCAnMmcnXS5pbmNsdWRlcyhuYXZpZ2F0b3JDb25uZWN0aW9uLmVmZmVjdGl2ZVR5cGUpIHx8XG4gICAgICAgIG5hdmlnYXRvckNvbm5lY3Rpb24uc2F2ZURhdGEpO1xuXG52YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChpc0Z1bmN0aW9uKGtleSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGtleSA9IGtleSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGRlcGVuZGVuY2llcyBub3QgcmVhZHlcbiAgICAgICAgICAgIGtleSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBhcmdzID0gW10uY29uY2F0KGtleSk7XG4gICAgLy8gSWYga2V5IGlzIG5vdCBmYWxzeSwgb3Igbm90IGFuIGVtcHR5IGFycmF5LCBoYXNoIGl0LlxuICAgIGtleSA9XG4gICAgICAgIHR5cGVvZiBrZXkgPT0gJ3N0cmluZydcbiAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICA6IChBcnJheS5pc0FycmF5KGtleSkgPyBrZXkubGVuZ3RoIDoga2V5KVxuICAgICAgICAgICAgICAgID8gc3RhYmxlSGFzaChrZXkpXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICB2YXIgaW5mb0tleSA9IGtleSA/ICckc3dyJCcgKyBrZXkgOiAnJztcbiAgICByZXR1cm4gW2tleSwgYXJncywgaW5mb0tleV07XG59O1xuXG4vLyBHbG9iYWwgc3RhdGUgdXNlZCB0byBkZWR1cGxpY2F0ZSByZXF1ZXN0cyBhbmQgc3RvcmUgbGlzdGVuZXJzXG52YXIgU1dSR2xvYmFsU3RhdGUgPSBuZXcgV2Vha01hcCgpO1xuXG52YXIgRk9DVVNfRVZFTlQgPSAwO1xudmFyIFJFQ09OTkVDVF9FVkVOVCA9IDE7XG52YXIgTVVUQVRFX0VWRU5UID0gMjtcblxudmFyIGJyb2FkY2FzdFN0YXRlID0gZnVuY3Rpb24gKGNhY2hlLCBrZXksIGRhdGEsIGVycm9yLCBpc1ZhbGlkYXRpbmcsIHJldmFsaWRhdGUsIGJyb2FkY2FzdCkge1xuICAgIGlmIChicm9hZGNhc3QgPT09IHZvaWQgMCkgeyBicm9hZGNhc3QgPSB0cnVlOyB9XG4gICAgdmFyIF9hID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKSwgRVZFTlRfUkVWQUxJREFUT1JTID0gX2FbMF0sIFNUQVRFX1VQREFURVJTID0gX2FbMV0sIEZFVENIID0gX2FbM107XG4gICAgdmFyIHJldmFsaWRhdG9ycyA9IEVWRU5UX1JFVkFMSURBVE9SU1trZXldO1xuICAgIHZhciB1cGRhdGVycyA9IFNUQVRFX1VQREFURVJTW2tleV07XG4gICAgLy8gQ2FjaGUgd2FzIHBvcHVsYXRlZCwgdXBkYXRlIHN0YXRlcyBvZiBhbGwgaG9va3MuXG4gICAgaWYgKGJyb2FkY2FzdCAmJiB1cGRhdGVycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB1cGRhdGVyc1tpXShkYXRhLCBlcnJvciwgaXNWYWxpZGF0aW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB3ZSBhbHNvIG5lZWQgdG8gcmV2YWxpZGF0ZSwgb25seSBkbyBpdCBmb3IgdGhlIGZpcnN0IGhvb2suXG4gICAgaWYgKHJldmFsaWRhdGUpIHtcbiAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUga2V5IGJ5IGRlbGV0aW5nIHRoZSBjb25jdXJyZW50IHJlcXVlc3QgbWFya2VycyBzbyBuZXdcbiAgICAgICAgLy8gcmVxdWVzdHMgd2lsbCBub3QgYmUgZGVkdXBlZC5cbiAgICAgICAgZGVsZXRlIEZFVENIW2tleV07XG4gICAgICAgIGlmIChyZXZhbGlkYXRvcnMgJiYgcmV2YWxpZGF0b3JzWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0b3JzWzBdKE1VVEFURV9FVkVOVCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xufTtcblxuLy8gR2xvYmFsIHRpbWVzdGFtcC5cbnZhciBfX3RpbWVzdGFtcCA9IDA7XG52YXIgZ2V0VGltZXN0YW1wID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKytfX3RpbWVzdGFtcDsgfTtcblxudmFyIGludGVybmFsTXV0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhY2hlLCBfa2V5LCBfZGF0YSwgX29wdHMsIG9wdGlvbnMsIHBvcHVsYXRlQ2FjaGUsIHJldmFsaWRhdGUsIHJvbGxiYWNrT25FcnJvciwgY3VzdG9tT3B0aW1pc3RpY0RhdGEsIF9hLCBrZXksIGtleUluZm8sIF9iLCBNVVRBVElPTiwgZGF0YSwgZXJyb3IsIGJlZm9yZU11dGF0aW9uVHMsIGhhc0N1c3RvbU9wdGltaXN0aWNEYXRhLCByb2xsYmFja0RhdGEsIG9wdGltaXN0aWNEYXRhLCByZXM7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlID0gYXJnc1swXSwgX2tleSA9IGFyZ3NbMV0sIF9kYXRhID0gYXJnc1syXSwgX29wdHMgPSBhcmdzWzNdO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIF9vcHRzID09PSAnYm9vbGVhbicgPyB7IHJldmFsaWRhdGU6IF9vcHRzIH0gOiBfb3B0cyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcG9wdWxhdGVDYWNoZSA9IGlzVW5kZWZpbmVkKG9wdGlvbnMucG9wdWxhdGVDYWNoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcHRpb25zLnBvcHVsYXRlQ2FjaGU7XG4gICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGUgPSBvcHRpb25zLnJldmFsaWRhdGUgIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByb2xsYmFja09uRXJyb3IgPSBvcHRpb25zLnJvbGxiYWNrT25FcnJvciAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbU9wdGltaXN0aWNEYXRhID0gb3B0aW9ucy5vcHRpbWlzdGljRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBzZXJpYWxpemUoX2tleSksIGtleSA9IF9hWzBdLCBrZXlJbmZvID0gX2FbMl07XG4gICAgICAgICAgICAgICAgICAgIGlmICgha2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICBfYiA9IFNXUkdsb2JhbFN0YXRlLmdldChjYWNoZSksIE1VVEFUSU9OID0gX2JbMl07XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG5ldyBkYXRhIHByb3ZpZGVkLCByZXZhbGlkYXRlIHRoZSBrZXkgd2l0aCBjdXJyZW50IHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZhbGlkYXRlIGFuZCBicm9hZGNhc3Qgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgY2FjaGUuZ2V0KGtleSksIFVOREVGSU5FRCwgVU5ERUZJTkVELCByZXZhbGlkYXRlLCB0cnVlKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9kYXRhO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVNdXRhdGlvblRzID0gZ2V0VGltZXN0YW1wKCk7XG4gICAgICAgICAgICAgICAgICAgIE1VVEFUSU9OW2tleV0gPSBbYmVmb3JlTXV0YXRpb25UcywgMF07XG4gICAgICAgICAgICAgICAgICAgIGhhc0N1c3RvbU9wdGltaXN0aWNEYXRhID0gIWlzVW5kZWZpbmVkKGN1c3RvbU9wdGltaXN0aWNEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcm9sbGJhY2tEYXRhID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG9wdGltaXN0aWMgZGF0YSB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNDdXN0b21PcHRpbWlzdGljRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpY0RhdGEgPSBpc0Z1bmN0aW9uKGN1c3RvbU9wdGltaXN0aWNEYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY3VzdG9tT3B0aW1pc3RpY0RhdGEocm9sbGJhY2tEYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VzdG9tT3B0aW1pc3RpY0RhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCBvcHRpbWlzdGljRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBvcHRpbWlzdGljRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBkYXRhYCBpcyBhIGZ1bmN0aW9uLCBjYWxsIGl0IHBhc3NpbmcgY3VycmVudCBjYWNoZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEoY2FjaGUuZ2V0KGtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IHRocm93cyBhbiBlcnJvciBzeW5jaHJvbm91c2x5LCB3ZSBzaG91bGRuJ3QgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShkYXRhICYmIGlzRnVuY3Rpb24oZGF0YS50aGVuKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBkYXRhLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBvdGhlciBtdXRhdGlvbnMgaGF2ZSBvY2N1cnJlZCBzaW5jZSB3ZSd2ZSBzdGFydGVkIHRoaXMgbXV0YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcmFjZSB3ZSBkb24ndCB1cGRhdGUgY2FjaGUgb3IgYnJvYWRjYXN0IHRoZSBjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHJldHVybiB0aGUgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgbXV0YXRpb24gaXMgYXN5bmMsIHdlIG5lZWQgdG8gY2hlY2sgdGltZXN0YW1wcyB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBhdm9pZCByYWNlIGNvbmRpdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG90aGVyIG11dGF0aW9ucyBoYXZlIG9jY3VycmVkIHNpbmNlIHdlJ3ZlIHN0YXJ0ZWQgdGhpcyBtdXRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHJhY2Ugd2UgZG9uJ3QgdXBkYXRlIGNhY2hlIG9yIGJyb2FkY2FzdCB0aGUgY2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHJldHVybiB0aGUgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZU11dGF0aW9uVHMgIT09IE1VVEFUSU9OW2tleV1bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBoYXNDdXN0b21PcHRpbWlzdGljRGF0YSAmJiByb2xsYmFja09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvbGxiYWNrLiBBbHdheXMgcG9wdWxhdGUgdGhlIGNhY2hlIGluIHRoaXMgY2FzZSBidXQgd2l0aG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtaW5nIHRoZSBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9wdWxhdGVDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcm9sbGJhY2tEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgcm9sbGJhY2tEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBzaG91bGQgd3JpdGUgYmFjayB0aGUgY2FjaGUgYWZ0ZXIgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcHVsYXRlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIHJlc3VsdCBpbnRvIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocG9wdWxhdGVDYWNoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBvcHVsYXRlQ2FjaGUoZGF0YSwgcm9sbGJhY2tEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgY2FjaGVkIGRhdGEgaWYgdGhlcmUncyBubyBlcnJvci4gRGF0YSBjYW4gYmUgYHVuZGVmaW5lZGAgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyB1cGRhdGUgb3IgcmVzZXQgdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleUluZm8sIG1lcmdlT2JqZWN0cyhjYWNoZS5nZXQoa2V5SW5mbyksIHsgZXJyb3I6IGVycm9yIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdGltZXN0YW1wIHRvIG1hcmsgdGhlIG11dGF0aW9uIGhhcyBlbmRlZC5cbiAgICAgICAgICAgICAgICAgICAgTVVUQVRJT05ba2V5XVsxXSA9IGdldFRpbWVzdGFtcCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBkYXRhLCBlcnJvciwgVU5ERUZJTkVELCByZXZhbGlkYXRlLCAhIXBvcHVsYXRlQ2FjaGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBlcnJvciBvciByZXR1cm4gZGF0YVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBlcnJvciBvciByZXR1cm4gZGF0YVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHBvcHVsYXRlQ2FjaGUgPyByZXMgOiBkYXRhXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG52YXIgcmV2YWxpZGF0ZUFsbEtleXMgPSBmdW5jdGlvbiAocmV2YWxpZGF0b3JzLCB0eXBlKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHJldmFsaWRhdG9ycykge1xuICAgICAgICBpZiAocmV2YWxpZGF0b3JzW2tleV1bMF0pXG4gICAgICAgICAgICByZXZhbGlkYXRvcnNba2V5XVswXSh0eXBlKTtcbiAgICB9XG59O1xudmFyIGluaXRDYWNoZSA9IGZ1bmN0aW9uIChwcm92aWRlciwgb3B0aW9ucykge1xuICAgIC8vIFRoZSBnbG9iYWwgc3RhdGUgZm9yIGEgc3BlY2lmaWMgcHJvdmlkZXIgd2lsbCBiZSB1c2VkIHRvIGRlZHVwbGljYXRlXG4gICAgLy8gcmVxdWVzdHMgYW5kIHN0b3JlIGxpc3RlbmVycy4gQXMgd2VsbCBhcyBhIG11dGF0ZSBmdW5jdGlvbiB0aGF0IGJvdW5kIHRvXG4gICAgLy8gdGhlIGNhY2hlLlxuICAgIC8vIFByb3ZpZGVyJ3MgZ2xvYmFsIHN0YXRlIG1pZ2h0IGJlIGFscmVhZHkgaW5pdGlhbGl6ZWQuIExldCdzIHRyeSB0byBnZXQgdGhlXG4gICAgLy8gZ2xvYmFsIHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZXIgZmlyc3QuXG4gICAgaWYgKCFTV1JHbG9iYWxTdGF0ZS5oYXMocHJvdmlkZXIpKSB7XG4gICAgICAgIHZhciBvcHRzID0gbWVyZ2VPYmplY3RzKGRlZmF1bHRDb25maWdPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBnbG9iYWwgc3RhdGUgYm91bmQgdG8gdGhlIHByb3ZpZGVyLCBjcmVhdGUgYSBuZXcgb25lIHdpdGggdGhlXG4gICAgICAgIC8vIG5ldyBtdXRhdGUgZnVuY3Rpb24uXG4gICAgICAgIHZhciBFVkVOVF9SRVZBTElEQVRPUlMgPSB7fTtcbiAgICAgICAgdmFyIG11dGF0ZSA9IGludGVybmFsTXV0YXRlLmJpbmQoVU5ERUZJTkVELCBwcm92aWRlcik7XG4gICAgICAgIHZhciB1bm1vdW50ID0gbm9vcDtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzdGF0ZSBpZiBpdCdzIG5ldywgb3IgdGhlIHByb3ZpZGVyIGhhcyBiZWVuIGV4dGVuZGVkLlxuICAgICAgICBTV1JHbG9iYWxTdGF0ZS5zZXQocHJvdmlkZXIsIFtFVkVOVF9SRVZBTElEQVRPUlMsIHt9LCB7fSwge30sIG11dGF0ZV0pO1xuICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IHByb3ZpZGVyLCB3ZSBuZWVkIHRvIGluaXRpYWxpemUgaXQgYW5kIHNldHVwIERPTSBldmVudHNcbiAgICAgICAgLy8gbGlzdGVuZXJzIGZvciBgZm9jdXNgIGFuZCBgcmVjb25uZWN0YCBhY3Rpb25zLlxuICAgICAgICBpZiAoIUlTX1NFUlZFUikge1xuICAgICAgICAgICAgLy8gV2hlbiBsaXN0ZW5pbmcgdG8gdGhlIG5hdGl2ZSBldmVudHMgZm9yIGF1dG8gcmV2YWxpZGF0aW9ucyxcbiAgICAgICAgICAgIC8vIHdlIGludGVudGlvbmFsbHkgcHV0IGEgZGVsYXkgKHNldFRpbWVvdXQpIGhlcmUgdG8gbWFrZSBzdXJlIHRoZXkgYXJlXG4gICAgICAgICAgICAvLyBmaXJlZCBhZnRlciBpbW1lZGlhdGUgSmF2YVNjcmlwdCBleGVjdXRpb25zLCB3aGljaCBjYW4gcG9zc2libHkgYmVcbiAgICAgICAgICAgIC8vIFJlYWN0J3Mgc3RhdGUgdXBkYXRlcy5cbiAgICAgICAgICAgIC8vIFRoaXMgYXZvaWRzIHNvbWUgdW5uZWNlc3NhcnkgcmV2YWxpZGF0aW9ucyBzdWNoIGFzXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL3N3ci9pc3N1ZXMvMTY4MC5cbiAgICAgICAgICAgIHZhciByZWxlYXNlRm9jdXNfMSA9IG9wdHMuaW5pdEZvY3VzKHNldFRpbWVvdXQuYmluZChVTkRFRklORUQsIHJldmFsaWRhdGVBbGxLZXlzLmJpbmQoVU5ERUZJTkVELCBFVkVOVF9SRVZBTElEQVRPUlMsIEZPQ1VTX0VWRU5UKSkpO1xuICAgICAgICAgICAgdmFyIHJlbGVhc2VSZWNvbm5lY3RfMSA9IG9wdHMuaW5pdFJlY29ubmVjdChzZXRUaW1lb3V0LmJpbmQoVU5ERUZJTkVELCByZXZhbGlkYXRlQWxsS2V5cy5iaW5kKFVOREVGSU5FRCwgRVZFTlRfUkVWQUxJREFUT1JTLCBSRUNPTk5FQ1RfRVZFTlQpKSk7XG4gICAgICAgICAgICB1bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VGb2N1c18xICYmIHJlbGVhc2VGb2N1c18xKCk7XG4gICAgICAgICAgICAgICAgcmVsZWFzZVJlY29ubmVjdF8xICYmIHJlbGVhc2VSZWNvbm5lY3RfMSgpO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdW4tbW91bnRpbmcsIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBjYWNoZSBwcm92aWRlciBmcm9tIHRoZSBzdGF0ZVxuICAgICAgICAgICAgICAgIC8vIHN0b3JhZ2UgdG9vIGJlY2F1c2UgaXQncyBhIHNpZGUtZWZmZWN0LiBPdGhlcndpc2Ugd2hlbiByZS1tb3VudGluZyB3ZVxuICAgICAgICAgICAgICAgIC8vIHdpbGwgbm90IHJlLXJlZ2lzdGVyIHRob3NlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAgICAgICAgICBTV1JHbG9iYWxTdGF0ZS5kZWxldGUocHJvdmlkZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBtaWdodCB3YW50IHRvIGluamVjdCBhbiBleHRyYSBsYXllciBvbiB0b3Agb2YgYHByb3ZpZGVyYCBpbiB0aGUgZnV0dXJlLFxuICAgICAgICAvLyBzdWNoIGFzIGtleSBzZXJpYWxpemF0aW9uLCBhdXRvIEdDLCBldGMuXG4gICAgICAgIC8vIEZvciBub3csIGl0J3MganVzdCBhIGBNYXBgIGludGVyZmFjZSB3aXRob3V0IGFueSBtb2RpZmljYXRpb25zLlxuICAgICAgICByZXR1cm4gW3Byb3ZpZGVyLCBtdXRhdGUsIHVubW91bnRdO1xuICAgIH1cbiAgICByZXR1cm4gW3Byb3ZpZGVyLCBTV1JHbG9iYWxTdGF0ZS5nZXQocHJvdmlkZXIpWzRdXTtcbn07XG5cbi8vIGVycm9yIHJldHJ5XG52YXIgb25FcnJvclJldHJ5ID0gZnVuY3Rpb24gKF8sIF9fLCBjb25maWcsIHJldmFsaWRhdGUsIG9wdHMpIHtcbiAgICB2YXIgbWF4UmV0cnlDb3VudCA9IGNvbmZpZy5lcnJvclJldHJ5Q291bnQ7XG4gICAgdmFyIGN1cnJlbnRSZXRyeUNvdW50ID0gb3B0cy5yZXRyeUNvdW50O1xuICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICB2YXIgdGltZW91dCA9IH5+KChNYXRoLnJhbmRvbSgpICsgMC41KSAqXG4gICAgICAgICgxIDw8IChjdXJyZW50UmV0cnlDb3VudCA8IDggPyBjdXJyZW50UmV0cnlDb3VudCA6IDgpKSkgKiBjb25maWcuZXJyb3JSZXRyeUludGVydmFsO1xuICAgIGlmICghaXNVbmRlZmluZWQobWF4UmV0cnlDb3VudCkgJiYgY3VycmVudFJldHJ5Q291bnQgPiBtYXhSZXRyeUNvdW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0VGltZW91dChyZXZhbGlkYXRlLCB0aW1lb3V0LCBvcHRzKTtcbn07XG4vLyBEZWZhdWx0IGNhY2hlIHByb3ZpZGVyXG52YXIgX2EgPSBpbml0Q2FjaGUobmV3IE1hcCgpKSwgY2FjaGUgPSBfYVswXSwgbXV0YXRlID0gX2FbMV07XG4vLyBEZWZhdWx0IGNvbmZpZ1xudmFyIGRlZmF1bHRDb25maWcgPSBtZXJnZU9iamVjdHMoe1xuICAgIC8vIGV2ZW50c1xuICAgIG9uTG9hZGluZ1Nsb3c6IG5vb3AsXG4gICAgb25TdWNjZXNzOiBub29wLFxuICAgIG9uRXJyb3I6IG5vb3AsXG4gICAgb25FcnJvclJldHJ5OiBvbkVycm9yUmV0cnksXG4gICAgb25EaXNjYXJkZWQ6IG5vb3AsXG4gICAgLy8gc3dpdGNoZXNcbiAgICByZXZhbGlkYXRlT25Gb2N1czogdHJ1ZSxcbiAgICByZXZhbGlkYXRlT25SZWNvbm5lY3Q6IHRydWUsXG4gICAgcmV2YWxpZGF0ZUlmU3RhbGU6IHRydWUsXG4gICAgc2hvdWxkUmV0cnlPbkVycm9yOiB0cnVlLFxuICAgIC8vIHRpbWVvdXRzXG4gICAgZXJyb3JSZXRyeUludGVydmFsOiBzbG93Q29ubmVjdGlvbiA/IDEwMDAwIDogNTAwMCxcbiAgICBmb2N1c1Rocm90dGxlSW50ZXJ2YWw6IDUgKiAxMDAwLFxuICAgIGRlZHVwaW5nSW50ZXJ2YWw6IDIgKiAxMDAwLFxuICAgIGxvYWRpbmdUaW1lb3V0OiBzbG93Q29ubmVjdGlvbiA/IDUwMDAgOiAzMDAwLFxuICAgIC8vIHByb3ZpZGVyc1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICAgICAgICByZXR1cm4gc3RhYmxlSGFzaChjdXJyZW50RGF0YSkgPT0gc3RhYmxlSGFzaChuZXdEYXRhKTtcbiAgICB9LFxuICAgIGlzUGF1c2VkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICBjYWNoZTogY2FjaGUsXG4gICAgbXV0YXRlOiBtdXRhdGUsXG4gICAgZmFsbGJhY2s6IHt9XG59LCBcbi8vIHVzZSB3ZWIgcHJlc2V0IGJ5IGRlZmF1bHRcbnByZXNldCk7XG5cbnZhciBtZXJnZUNvbmZpZ3MgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIE5lZWQgdG8gY3JlYXRlIGEgbmV3IG9iamVjdCB0byBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgaGVyZS5cbiAgICB2YXIgdiA9IG1lcmdlT2JqZWN0cyhhLCBiKTtcbiAgICAvLyBJZiB0d28gY29uZmlncyBhcmUgcHJvdmlkZWQsIG1lcmdlIHRoZWlyIGB1c2VgIGFuZCBgZmFsbGJhY2tgIG9wdGlvbnMuXG4gICAgaWYgKGIpIHtcbiAgICAgICAgdmFyIHUxID0gYS51c2UsIGYxID0gYS5mYWxsYmFjaztcbiAgICAgICAgdmFyIHUyID0gYi51c2UsIGYyID0gYi5mYWxsYmFjaztcbiAgICAgICAgaWYgKHUxICYmIHUyKSB7XG4gICAgICAgICAgICB2LnVzZSA9IHUxLmNvbmNhdCh1Mik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYxICYmIGYyKSB7XG4gICAgICAgICAgICB2LmZhbGxiYWNrID0gbWVyZ2VPYmplY3RzKGYxLCBmMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuXG52YXIgU1dSQ29uZmlnQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xudmFyIFNXUkNvbmZpZyQxID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgLy8gRXh0ZW5kIHBhcmVudCBjb250ZXh0IHZhbHVlcyBhbmQgbWlkZGxld2FyZS5cbiAgICB2YXIgZXh0ZW5kZWRDb25maWcgPSBtZXJnZUNvbmZpZ3ModXNlQ29udGV4dChTV1JDb25maWdDb250ZXh0KSwgdmFsdWUpO1xuICAgIC8vIFNob3VsZCBub3QgdXNlIHRoZSBpbmhlcml0ZWQgcHJvdmlkZXIuXG4gICAgdmFyIHByb3ZpZGVyID0gdmFsdWUgJiYgdmFsdWUucHJvdmlkZXI7XG4gICAgLy8gVXNlIGEgbGF6eSBpbml0aWFsaXplZCBzdGF0ZSB0byBjcmVhdGUgdGhlIGNhY2hlIG9uIGZpcnN0IGFjY2Vzcy5cbiAgICB2YXIgY2FjaGVDb250ZXh0ID0gdXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvdmlkZXJcbiAgICAgICAgICAgID8gaW5pdENhY2hlKHByb3ZpZGVyKGV4dGVuZGVkQ29uZmlnLmNhY2hlIHx8IGNhY2hlKSwgdmFsdWUpXG4gICAgICAgICAgICA6IFVOREVGSU5FRDtcbiAgICB9KVswXTtcbiAgICAvLyBPdmVycmlkZSB0aGUgY2FjaGUgaWYgYSBuZXcgcHJvdmlkZXIgaXMgZ2l2ZW4uXG4gICAgaWYgKGNhY2hlQ29udGV4dCkge1xuICAgICAgICBleHRlbmRlZENvbmZpZy5jYWNoZSA9IGNhY2hlQ29udGV4dFswXTtcbiAgICAgICAgZXh0ZW5kZWRDb25maWcubXV0YXRlID0gY2FjaGVDb250ZXh0WzFdO1xuICAgIH1cbiAgICAvLyBVbnN1YnNjcmliZSBldmVudHMuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiAoY2FjaGVDb250ZXh0ID8gY2FjaGVDb250ZXh0WzJdIDogVU5ERUZJTkVEKTsgfSwgW10pO1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFNXUkNvbmZpZ0NvbnRleHQuUHJvdmlkZXIsIG1lcmdlT2JqZWN0cyhwcm9wcywge1xuICAgICAgICB2YWx1ZTogZXh0ZW5kZWRDb25maWdcbiAgICB9KSk7XG59O1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHN0YXRlIHdpdGggZGVwZW5kZW5jeS10cmFja2luZy5cbiAqL1xudmFyIHVzZVN0YXRlV2l0aERlcHMgPSBmdW5jdGlvbiAoc3RhdGUsIHVubW91bnRlZFJlZikge1xuICAgIHZhciByZXJlbmRlciA9IHVzZVN0YXRlKHt9KVsxXTtcbiAgICB2YXIgc3RhdGVSZWYgPSB1c2VSZWYoc3RhdGUpO1xuICAgIC8vIElmIGEgc3RhdGUgcHJvcGVydHkgKGRhdGEsIGVycm9yIG9yIGlzVmFsaWRhdGluZykgaXMgYWNjZXNzZWQgYnkgdGhlIHJlbmRlclxuICAgIC8vIGZ1bmN0aW9uLCB3ZSBtYXJrIHRoZSBwcm9wZXJ0eSBhcyBhIGRlcGVuZGVuY3kgc28gaWYgaXQgaXMgdXBkYXRlZCBhZ2FpblxuICAgIC8vIGluIHRoZSBmdXR1cmUsIHdlIHRyaWdnZXIgYSByZXJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGFsc28ga25vd24gYXMgZGVwZW5kZW5jeS10cmFja2luZy5cbiAgICB2YXIgc3RhdGVEZXBlbmRlbmNpZXNSZWYgPSB1c2VSZWYoe1xuICAgICAgICBkYXRhOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBheWxvYWQgVG8gY2hhbmdlIHN0YXRlUmVmLCBwYXNzIHRoZSB2YWx1ZXMgZXhwbGljaXRseSB0byBzZXRTdGF0ZTpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogc2V0U3RhdGUoe1xuICAgICAqICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxuICAgICAqICAgZGF0YTogbmV3RGF0YSAvLyBzZXQgZGF0YSB0byBuZXdEYXRhXG4gICAgICogICBlcnJvcjogdW5kZWZpbmVkIC8vIHNldCBlcnJvciB0byB1bmRlZmluZWRcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogc2V0U3RhdGUoe1xuICAgICAqICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxuICAgICAqICAgZGF0YTogdW5kZWZpbmVkIC8vIHNldCBkYXRhIHRvIHVuZGVmaW5lZFxuICAgICAqICAgZXJyb3I6IGVyciAvLyBzZXQgZXJyb3IgdG8gZXJyXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB2YXIgc2V0U3RhdGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgc2hvdWxkUmVyZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICAgIGZvciAodmFyIF8gaW4gcGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIGsgPSBfO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGhhcyBjaGFuZ2VkLCB1cGRhdGUgdGhlIHN0YXRlIGFuZCBtYXJrIHJlcmVuZGVyIGFzXG4gICAgICAgICAgICAvLyBuZWVkZWQuXG4gICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlW2tdICE9PSBwYXlsb2FkW2tdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFN0YXRlW2tdID0gcGF5bG9hZFtrXTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQgYnkgdGhlIGNvbXBvbmVudCwgYSByZXJlbmRlciBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyZWQuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlRGVwZW5kZW5jaWVzUmVmLmN1cnJlbnRba10pIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVyZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUmVyZW5kZXIgJiYgIXVubW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXJlbmRlcih7fSk7XG4gICAgICAgIH1cbiAgICB9LCBcbiAgICAvLyBjb25maWcuc3VzcGVuc2UgaXNuJ3QgYWxsb3dlZCB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZlY3ljbGVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW10pO1xuICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIHN0YXRlIHJlZmVyZW5jZS5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RhdGVSZWYuY3VycmVudCA9IHN0YXRlO1xuICAgIH0pO1xuICAgIHJldHVybiBbc3RhdGVSZWYsIHN0YXRlRGVwZW5kZW5jaWVzUmVmLmN1cnJlbnQsIHNldFN0YXRlXTtcbn07XG5cbnZhciBub3JtYWxpemUgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGFyZ3NbMV0pXG4gICAgICAgID8gW2FyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0gfHwge31dXG4gICAgICAgIDogW2FyZ3NbMF0sIG51bGwsIChhcmdzWzFdID09PSBudWxsID8gYXJnc1syXSA6IGFyZ3NbMV0pIHx8IHt9XTtcbn07XG5cbnZhciB1c2VTV1JDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0cyhkZWZhdWx0Q29uZmlnLCB1c2VDb250ZXh0KFNXUkNvbmZpZ0NvbnRleHQpKTtcbn07XG5cbi8vIEl0J3MgdHJpY2t5IHRvIHBhc3MgZ2VuZXJpYyB0eXBlcyBhcyBwYXJhbWV0ZXJzLCBzbyB3ZSBqdXN0IGRpcmVjdGx5IG92ZXJyaWRlXG4vLyB0aGUgdHlwZXMgaGVyZS5cbnZhciB3aXRoQXJncyA9IGZ1bmN0aW9uIChob29rKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVzZVNXUkFyZ3MoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBkZWZhdWx0IGFuZCBpbmhlcml0ZWQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgdmFyIGZhbGxiYWNrQ29uZmlnID0gdXNlU1dSQ29uZmlnKCk7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBhcmd1bWVudHMuXG4gICAgICAgIHZhciBfYSA9IG5vcm1hbGl6ZShhcmdzKSwga2V5ID0gX2FbMF0sIGZuID0gX2FbMV0sIF9jb25maWcgPSBfYVsyXTtcbiAgICAgICAgLy8gTWVyZ2UgY29uZmlndXJhdGlvbnMuXG4gICAgICAgIHZhciBjb25maWcgPSBtZXJnZUNvbmZpZ3MoZmFsbGJhY2tDb25maWcsIF9jb25maWcpO1xuICAgICAgICAvLyBBcHBseSBtaWRkbGV3YXJlXG4gICAgICAgIHZhciBuZXh0ID0gaG9vaztcbiAgICAgICAgdmFyIHVzZSA9IGNvbmZpZy51c2U7XG4gICAgICAgIGlmICh1c2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB1c2UubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgICAgICAgICAgIG5leHQgPSB1c2VbaV0obmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQoa2V5LCBmbiB8fCBjb25maWcuZmV0Y2hlciwgY29uZmlnKTtcbiAgICB9O1xufTtcblxuLy8gQWRkIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYSBsaXN0IG9mIGtleWVkIGNhbGxiYWNrIGZ1bmN0aW9ucyBhbmQgcmV0dXJuXG4vLyB0aGUgdW5zdWJzY3JpYmUgZnVuY3Rpb24uXG52YXIgc3Vic2NyaWJlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoa2V5LCBjYWxsYmFja3MsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGtleWVkUmV2YWxpZGF0b3JzID0gY2FsbGJhY2tzW2tleV0gfHwgKGNhbGxiYWNrc1trZXldID0gW10pO1xuICAgIGtleWVkUmV2YWxpZGF0b3JzLnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGtleWVkUmV2YWxpZGF0b3JzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgLy8gTygxKTogZmFzdGVyIHRoYW4gc3BsaWNlXG4gICAgICAgICAgICBrZXllZFJldmFsaWRhdG9yc1tpbmRleF0gPSBrZXllZFJldmFsaWRhdG9yc1trZXllZFJldmFsaWRhdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGtleWVkUmV2YWxpZGF0b3JzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbnZhciBXSVRIX0RFRFVQRSA9IHsgZGVkdXBlOiB0cnVlIH07XG52YXIgdXNlU1dSSGFuZGxlciA9IGZ1bmN0aW9uIChfa2V5LCBmZXRjaGVyLCBjb25maWcpIHtcbiAgICB2YXIgY2FjaGUgPSBjb25maWcuY2FjaGUsIGNvbXBhcmUgPSBjb25maWcuY29tcGFyZSwgZmFsbGJhY2tEYXRhID0gY29uZmlnLmZhbGxiYWNrRGF0YSwgc3VzcGVuc2UgPSBjb25maWcuc3VzcGVuc2UsIHJldmFsaWRhdGVPbk1vdW50ID0gY29uZmlnLnJldmFsaWRhdGVPbk1vdW50LCByZWZyZXNoSW50ZXJ2YWwgPSBjb25maWcucmVmcmVzaEludGVydmFsLCByZWZyZXNoV2hlbkhpZGRlbiA9IGNvbmZpZy5yZWZyZXNoV2hlbkhpZGRlbiwgcmVmcmVzaFdoZW5PZmZsaW5lID0gY29uZmlnLnJlZnJlc2hXaGVuT2ZmbGluZTtcbiAgICB2YXIgX2EgPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpLCBFVkVOVF9SRVZBTElEQVRPUlMgPSBfYVswXSwgU1RBVEVfVVBEQVRFUlMgPSBfYVsxXSwgTVVUQVRJT04gPSBfYVsyXSwgRkVUQ0ggPSBfYVszXTtcbiAgICAvLyBga2V5YCBpcyB0aGUgaWRlbnRpZmllciBvZiB0aGUgU1dSIGBkYXRhYCBzdGF0ZSwgYGtleUluZm9gIGhvbGRzIGV4dHJhXG4gICAgLy8gc3RhdGVzIHN1Y2ggYXMgYGVycm9yYCBhbmQgYGlzVmFsaWRhdGluZ2AgaW5zaWRlLFxuICAgIC8vIGFsbCBvZiB0aGVtIGFyZSBkZXJpdmVkIGZyb20gYF9rZXlgLlxuICAgIC8vIGBmbkFyZ3NgIGlzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBwYXJzZWQgZnJvbSB0aGUga2V5LCB3aGljaCB3aWxsIGJlIHBhc3NlZFxuICAgIC8vIHRvIHRoZSBmZXRjaGVyLlxuICAgIHZhciBfYiA9IHNlcmlhbGl6ZShfa2V5KSwga2V5ID0gX2JbMF0sIGZuQXJncyA9IF9iWzFdLCBrZXlJbmZvID0gX2JbMl07XG4gICAgLy8gSWYgaXQncyB0aGUgaW5pdGlhbCByZW5kZXIgb2YgdGhpcyBob29rLlxuICAgIHZhciBpbml0aWFsTW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gSWYgdGhlIGhvb2sgaXMgdW5tb3VudGVkIGFscmVhZHkuIFRoaXMgd2lsbCBiZSB1c2VkIHRvIHByZXZlbnQgc29tZSBlZmZlY3RzXG4gICAgLy8gdG8gYmUgY2FsbGVkIGFmdGVyIHVubW91bnRpbmcuXG4gICAgdmFyIHVubW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gUmVmcyB0byBrZWVwIHRoZSBrZXkgYW5kIGNvbmZpZy5cbiAgICB2YXIga2V5UmVmID0gdXNlUmVmKGtleSk7XG4gICAgdmFyIGZldGNoZXJSZWYgPSB1c2VSZWYoZmV0Y2hlcik7XG4gICAgdmFyIGNvbmZpZ1JlZiA9IHVzZVJlZihjb25maWcpO1xuICAgIHZhciBnZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWdSZWYuY3VycmVudDsgfTtcbiAgICB2YXIgaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRDb25maWcoKS5pc1Zpc2libGUoKSAmJiBnZXRDb25maWcoKS5pc09ubGluZSgpOyB9O1xuICAgIHZhciBwYXRjaEZldGNoSW5mbyA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5zZXQoa2V5SW5mbywgbWVyZ2VPYmplY3RzKGNhY2hlLmdldChrZXlJbmZvKSwgaW5mbykpO1xuICAgIH07XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0YXRlIHRoYXQgU1dSIHNob3VsZCByZXR1cm4uXG4gICAgdmFyIGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgIHZhciBmYWxsYmFjayA9IGlzVW5kZWZpbmVkKGZhbGxiYWNrRGF0YSlcbiAgICAgICAgPyBjb25maWcuZmFsbGJhY2tba2V5XVxuICAgICAgICA6IGZhbGxiYWNrRGF0YTtcbiAgICB2YXIgZGF0YSA9IGlzVW5kZWZpbmVkKGNhY2hlZCkgPyBmYWxsYmFjayA6IGNhY2hlZDtcbiAgICB2YXIgaW5mbyA9IGNhY2hlLmdldChrZXlJbmZvKSB8fCB7fTtcbiAgICB2YXIgZXJyb3IgPSBpbmZvLmVycm9yO1xuICAgIHZhciBpc0luaXRpYWxNb3VudCA9ICFpbml0aWFsTW91bnRlZFJlZi5jdXJyZW50O1xuICAgIC8vIC0gU3VzcGVuc2UgbW9kZSBhbmQgdGhlcmUncyBzdGFsZSBkYXRhIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgLy8gLSBOb3Qgc3VzcGVuc2UgbW9kZSBhbmQgdGhlcmUgaXMgbm8gZmFsbGJhY2sgZGF0YSBhbmQgYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBlbmFibGVkLlxuICAgIC8vIC0gYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBlbmFibGVkIGJ1dCBgZGF0YWAgaXMgbm90IGRlZmluZWQuXG4gICAgdmFyIHNob3VsZFJldmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElmIGByZXZhbGlkYXRlT25Nb3VudGAgaXMgc2V0LCB3ZSB0YWtlIHRoZSB2YWx1ZSBkaXJlY3RseS5cbiAgICAgICAgaWYgKGlzSW5pdGlhbE1vdW50ICYmICFpc1VuZGVmaW5lZChyZXZhbGlkYXRlT25Nb3VudCkpXG4gICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0ZU9uTW91bnQ7XG4gICAgICAgIC8vIElmIGl0J3MgcGF1c2VkLCB3ZSBza2lwIHJldmFsaWRhdGlvbi5cbiAgICAgICAgaWYgKGdldENvbmZpZygpLmlzUGF1c2VkKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFVuZGVyIHN1c3BlbnNlIG1vZGUsIGl0IHdpbGwgYWx3YXlzIGZldGNoIG9uIHJlbmRlciBpZiB0aGVyZSBpcyBub1xuICAgICAgICAvLyBzdGFsZSBkYXRhIHNvIG5vIG5lZWQgdG8gcmV2YWxpZGF0ZSBpbW1lZGlhdGVseSBvbiBtb3VudCBhZ2Fpbi5cbiAgICAgICAgLy8gSWYgZGF0YSBleGlzdHMsIG9ubHkgcmV2YWxpZGF0ZSBpZiBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIHRydWUuXG4gICAgICAgIGlmIChzdXNwZW5zZSlcbiAgICAgICAgICAgIHJldHVybiBpc1VuZGVmaW5lZChkYXRhKSA/IGZhbHNlIDogY29uZmlnLnJldmFsaWRhdGVJZlN0YWxlO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBzdGFsZSBkYXRhLCB3ZSBuZWVkIHRvIHJldmFsaWRhdGUgb24gbW91bnQ7XG4gICAgICAgIC8vIElmIGByZXZhbGlkYXRlSWZTdGFsZWAgaXMgc2V0IHRvIHRydWUsIHdlIHdpbGwgYWx3YXlzIHJldmFsaWRhdGUuXG4gICAgICAgIHJldHVybiBpc1VuZGVmaW5lZChkYXRhKSB8fCBjb25maWcucmV2YWxpZGF0ZUlmU3RhbGU7XG4gICAgfTtcbiAgICAvLyBSZXNvbHZlIHRoZSBjdXJyZW50IHZhbGlkYXRpbmcgc3RhdGUuXG4gICAgdmFyIHJlc29sdmVWYWxpZGF0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWtleSB8fCAhZmV0Y2hlcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGluZm8uaXNWYWxpZGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIElmIGl0J3Mgbm90IG1vdW50ZWQgeWV0IGFuZCBpdCBzaG91bGQgcmV2YWxpZGF0ZSBvbiBtb3VudCwgcmV2YWxpZGF0ZS5cbiAgICAgICAgcmV0dXJuIGlzSW5pdGlhbE1vdW50ICYmIHNob3VsZFJldmFsaWRhdGUoKTtcbiAgICB9O1xuICAgIHZhciBpc1ZhbGlkYXRpbmcgPSByZXNvbHZlVmFsaWRhdGluZygpO1xuICAgIHZhciBfYyA9IHVzZVN0YXRlV2l0aERlcHMoe1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIGlzVmFsaWRhdGluZzogaXNWYWxpZGF0aW5nXG4gICAgfSwgdW5tb3VudGVkUmVmKSwgc3RhdGVSZWYgPSBfY1swXSwgc3RhdGVEZXBlbmRlbmNpZXMgPSBfY1sxXSwgc2V0U3RhdGUgPSBfY1syXTtcbiAgICAvLyBUaGUgcmV2YWxpZGF0aW9uIGZ1bmN0aW9uIGlzIGEgY2FyZWZ1bGx5IGNyYWZ0ZWQgd3JhcHBlciBvZiB0aGUgb3JpZ2luYWxcbiAgICAvLyBgZmV0Y2hlcmAsIHRvIGNvcnJlY3RseSBoYW5kbGUgdGhlIG1hbnkgZWRnZSBjYXNlcy5cbiAgICB2YXIgcmV2YWxpZGF0ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChyZXZhbGlkYXRlT3B0cykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRGZXRjaGVyLCBuZXdEYXRhLCBzdGFydEF0LCBsb2FkaW5nLCBvcHRzLCBzaG91bGRTdGFydE5ld1JlcXVlc3QsIGlzQ3VycmVudEtleU1vdW50ZWQsIGNsZWFudXBTdGF0ZSwgbmV3U3RhdGUsIGZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSwgbXV0YXRpb25JbmZvLCBlcnJfMTtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RmV0Y2hlciA9IGZldGNoZXJSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFjdXJyZW50RmV0Y2hlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMgPSByZXZhbGlkYXRlT3B0cyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RhcnROZXdSZXF1ZXN0ID0gIUZFVENIW2tleV0gfHwgIW9wdHMuZGVkdXBlO1xuICAgICAgICAgICAgICAgICAgICBpc0N1cnJlbnRLZXlNb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF1bm1vdW50ZWRSZWYuY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9PT0ga2V5UmVmLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsTW91bnRlZFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIHN0aWxsIHRoZSBzYW1lIHJlcXVlc3QgYmVmb3JlIGRlbGV0aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RJbmZvID0gRkVUQ0hba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0SW5mbyAmJiByZXF1ZXN0SW5mb1sxXSA9PT0gc3RhcnRBdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBGRVRDSFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHsgaXNWYWxpZGF0aW5nOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaEZldGNoSW5mbyh7IGlzVmFsaWRhdGluZzogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gb25seSBzZXQgc3RhdGUgaWYgaXQncyBzYWZlIChzdGlsbCBtb3VudGVkIHdpdGggdGhlIHNhbWUga2V5KS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRLZXlNb3VudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGZldGNoaW5nLiBDaGFuZ2UgdGhlIGBpc1ZhbGlkYXRpbmdgIHN0YXRlLCB1cGRhdGUgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBwYXRjaEZldGNoSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXRlKHsgaXNWYWxpZGF0aW5nOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUZWxsIGFsbCBvdGhlciBob29rcyB0byBjaGFuZ2UgdGhlIGBpc1ZhbGlkYXRpbmdgIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgc3RhdGVSZWYuY3VycmVudC5kYXRhLCBzdGF0ZVJlZi5jdXJyZW50LmVycm9yLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIGNhY2hlIGJlaW5nIHJlbmRlcmVkIGN1cnJlbnRseSAoaXQgc2hvd3MgYSBibGFuayBwYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHRyaWdnZXIgdGhlIGxvYWRpbmcgc2xvdyBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubG9hZGluZ1RpbWVvdXQgJiYgIWNhY2hlLmdldChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2FkaW5nICYmIGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25Mb2FkaW5nU2xvdyhrZXksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjb25maWcubG9hZGluZ1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHJlcXVlc3QgYW5kIHNhdmUgdGhlIHRpbWVzdGFtcC5cbiAgICAgICAgICAgICAgICAgICAgICAgIEZFVENIW2tleV0gPSBbY3VycmVudEZldGNoZXIuYXBwbHkodm9pZCAwLCBmbkFyZ3MpLCBnZXRUaW1lc3RhbXAoKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2EgPSBGRVRDSFtrZXldLCBuZXdEYXRhID0gX2FbMF0sIHN0YXJ0QXQgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbmV3RGF0YV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCBpc24ndCBpbnRlcnJ1cHRlZCwgY2xlYW4gaXQgdXAgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWR1cGxpY2F0aW9uIGludGVydmFsLlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjbGVhbnVwU3RhdGUsIGNvbmZpZy5kZWR1cGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdyZSBvdGhlciBvbmdvaW5nIHJlcXVlc3QocyksIHN0YXJ0ZWQgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lLFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGlnbm9yZSB0aGUgY3VycmVudCBvbmUgdG8gYXZvaWQgcG9zc2libGUgcmFjZSBjb25kaXRpb25zOlxuICAgICAgICAgICAgICAgICAgICAvLyAgIHJlcTEtLS0tLS0tLS0tLS0tLS0tLS0+cmVzMSAgICAgICAgKGN1cnJlbnQgb25lKVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgcmVxMi0tLS0tLS0tLS0tLS0tLS0+cmVzMlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCB0aGF0IGZpcmVkIGxhdGVyIHdpbGwgYWx3YXlzIGJlIGtlcHQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0aW1lc3RhbXAgbWF5YmUgYmUgYHVuZGVmaW5lZGAgb3IgYSBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFGRVRDSFtrZXldIHx8IEZFVENIW2tleV1bMV0gIT09IHN0YXJ0QXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRGlzY2FyZGVkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGZXRjaEluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFVOREVGSU5FRFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUuZXJyb3IgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSW5mbyA9IE1VVEFUSU9OW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQobXV0YXRpb25JbmZvKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhcnRBdCA8PSBtdXRhdGlvbkluZm9bMF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEF0IDw9IG11dGF0aW9uSW5mb1sxXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSW5mb1sxXSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRLZXlNb3VudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25EaXNjYXJkZWQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIERlZXAgY29tcGFyZSB3aXRoIGxhdGVzdCBzdGF0ZSB0byBhdm9pZCBleHRyYSByZS1yZW5kZXJzLlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgbG9jYWwgc3RhdGUsIGNvbXBhcmUgYW5kIGFzc2lnbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKHN0YXRlUmVmLmN1cnJlbnQuZGF0YSwgbmV3RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmRhdGEgPSBuZXdEYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBhbmQgbmV3RGF0YSBhcmUgZGVlcGx5IGVxdWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgc2FmZSB0byBicm9hZGNhc3QgdGhlIHN0YWxlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmRhdGEgPSBzdGF0ZVJlZi5jdXJyZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdCB0aGUgZW5kIG9mIHRoaXMgZnVuY3Rpb24sIGBicm9jYXN0U3RhdGVgIGludm9rZXMgdGhlIGBvblN0YXRlVXBkYXRlYCBmdW5jdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHRha2VzIGNhcmUgb2YgYXZvaWRpbmcgdGhlIHJlLXJlbmRlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBnbG9iYWwgc3RhdGUsIGl0J3MgcG9zc2libGUgdGhhdCB0aGUga2V5IGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL3N3ci9wdWxsLzEwNThcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKGNhY2hlLmdldChrZXkpLCBuZXdEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgbmV3RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciB0aGUgc3VjY2Vzc2Z1bCBjYWxsYmFjayBpZiBpdCdzIHRoZSBvcmlnaW5hbCByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25TdWNjZXNzKG5ld0RhdGEsIGtleSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGVycl8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IHBhdXNlZCwgd2UgY29udGludWUgaGFuZGxpbmcgdGhlIGVycm9yLiBPdGhlcndpc2UgZGlzY2FyZCBpdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFnZXRDb25maWcoKS5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBuZXcgZXJyb3IsIGRvbid0IHVzZSBkZWVwIGNvbXBhcmlzb24gZm9yIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoRmV0Y2hJbmZvKHsgZXJyb3I6IGVycl8xIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUuZXJyb3IgPSBlcnJfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9yIGV2ZW50IGFuZCByZXRyeSBsb2dpYy4gT25seSBmb3IgdGhlIGFjdHVhbCByZXF1ZXN0LCBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZHVwZWQgb25lcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QgJiYgaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25FcnJvcihlcnJfMSwga2V5LCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGNvbmZpZy5zaG91bGRSZXRyeU9uRXJyb3IgPT09ICdib29sZWFuJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc2hvdWxkUmV0cnlPbkVycm9yKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNGdW5jdGlvbihjb25maWcuc2hvdWxkUmV0cnlPbkVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnNob3VsZFJldHJ5T25FcnJvcihlcnJfMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gcmV0cnlpbmcsIGRlZHVwZSBpcyBhbHdheXMgZW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhY3RpdmUsIHN0b3AuIEl0IHdpbGwgYXV0byByZXZhbGlkYXRlIHdoZW4gcmVmb2N1c2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgcmVjb25uZWN0aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25FcnJvclJldHJ5KGVycl8xLCBrZXksIGNvbmZpZywgcmV2YWxpZGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5Q291bnQ6IChvcHRzLnJldHJ5Q291bnQgfHwgMCkgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZHVwZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAvLyBNYXJrIGxvYWRpbmcgYXMgc3RvcHBlZC5cbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgaG9vaydzIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGVyZSBpcyB0aGUgc291cmNlIG9mIHRoZSByZXF1ZXN0LCBuZWVkIHRvIHRlbGwgYWxsIG90aGVyIGhvb2tzIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGVpciBzdGF0ZXMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRLZXlNb3VudGVkKCkgJiYgc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBuZXdTdGF0ZS5kYXRhLCBuZXdTdGF0ZS5lcnJvciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0cnVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7IH0sIFxuICAgIC8vIGBzZXRTdGF0ZWAgaXMgaW1tdXRhYmxlLCBhbmQgYGV2ZW50c0NhbGxiYWNrYCwgYGZuQXJnc2AsIGBrZXlJbmZvYCxcbiAgICAvLyBhbmQgYGtleVZhbGlkYXRpbmdgIGFyZSBkZXBlbmRpbmcgb24gYGtleWAsIHNvIHdlIGNhbiBleGNsdWRlIHRoZW0gZnJvbVxuICAgIC8vIHRoZSBkZXBzIGFycmF5LlxuICAgIC8vXG4gICAgLy8gRklYTUU6XG4gICAgLy8gYGZuYCBhbmQgYGNvbmZpZ2AgbWlnaHQgYmUgY2hhbmdlZCBkdXJpbmcgdGhlIGxpZmVjeWNsZSxcbiAgICAvLyBidXQgdGhleSBtaWdodCBiZSBjaGFuZ2VkIGV2ZXJ5IHJlbmRlciBsaWtlIHRoaXMuXG4gICAgLy8gYHVzZVNXUigna2V5JywgKCkgPT4gZmV0Y2goJy9hcGkvJyksIHsgc3VzcGVuc2U6IHRydWUgfSlgXG4gICAgLy8gU28gd2Ugb21pdCB0aGUgdmFsdWVzIGZyb20gdGhlIGRlcHMgYXJyYXlcbiAgICAvLyBldmVuIHRob3VnaCBpdCBtaWdodCBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9ycy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW2tleV0pO1xuICAgIC8vIFNpbWlsYXIgdG8gdGhlIGdsb2JhbCBtdXRhdGUsIGJ1dCBib3VuZCB0byB0aGUgY3VycmVudCBjYWNoZSBhbmQga2V5LlxuICAgIC8vIGBjYWNoZWAgaXNuJ3QgYWxsb3dlZCB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZlY3ljbGUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIHZhciBib3VuZE11dGF0ZSA9IHVzZUNhbGxiYWNrKFxuICAgIC8vIEJ5IHVzaW5nIGBiaW5kYCB3ZSBkb24ndCBuZWVkIHRvIG1vZGlmeSB0aGUgc2l6ZSBvZiB0aGUgcmVzdCBhcmd1bWVudHMuXG4gICAgLy8gRHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzcxODEsIHdlIGhhdmUgdG9cbiAgICAvLyBjYXN0IGl0IHRvIGFueSBmb3Igbm93LlxuICAgIGludGVybmFsTXV0YXRlLmJpbmQoVU5ERUZJTkVELCBjYWNoZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4ga2V5UmVmLmN1cnJlbnQ7IH0pLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW10pO1xuICAgIC8vIEFsd2F5cyB1cGRhdGUgZmV0Y2hlciBhbmQgY29uZmlnIHJlZnMuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZldGNoZXJSZWYuY3VycmVudCA9IGZldGNoZXI7XG4gICAgICAgIGNvbmZpZ1JlZi5jdXJyZW50ID0gY29uZmlnO1xuICAgIH0pO1xuICAgIC8vIEFmdGVyIG1vdW50ZWQgb3Iga2V5IGNoYW5nZWQuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgha2V5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIga2V5Q2hhbmdlZCA9IGtleSAhPT0ga2V5UmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBzb2Z0UmV2YWxpZGF0ZSA9IHJldmFsaWRhdGUuYmluZChVTkRFRklORUQsIFdJVEhfREVEVVBFKTtcbiAgICAgICAgLy8gRXhwb3NlIHN0YXRlIHVwZGF0ZXIgdG8gZ2xvYmFsIGV2ZW50IGxpc3RlbmVycy4gU28gd2UgY2FuIHVwZGF0ZSBob29rJ3NcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGUgZnJvbSB0aGUgb3V0c2lkZS5cbiAgICAgICAgdmFyIG9uU3RhdGVVcGRhdGUgPSBmdW5jdGlvbiAodXBkYXRlZERhdGEsIHVwZGF0ZWRFcnJvciwgdXBkYXRlZElzVmFsaWRhdGluZykge1xuICAgICAgICAgICAgc2V0U3RhdGUobWVyZ2VPYmplY3RzKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogdXBkYXRlZEVycm9yLFxuICAgICAgICAgICAgICAgIGlzVmFsaWRhdGluZzogdXBkYXRlZElzVmFsaWRhdGluZ1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvLyBTaW5jZSBgc2V0U3RhdGVgIG9ubHkgc2hhbGxvd2x5IGNvbXBhcmVzIHN0YXRlcywgd2UgZG8gYSBkZWVwXG4gICAgICAgICAgICAvLyBjb21wYXJpc29uIGhlcmUuXG4gICAgICAgICAgICBjb21wYXJlKHN0YXRlUmVmLmN1cnJlbnQuZGF0YSwgdXBkYXRlZERhdGEpXG4gICAgICAgICAgICAgICAgPyBVTkRFRklORURcbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdXBkYXRlZERhdGFcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEV4cG9zZSByZXZhbGlkYXRvcnMgdG8gZ2xvYmFsIGV2ZW50IGxpc3RlbmVycy4gU28gd2UgY2FuIHRyaWdnZXJcbiAgICAgICAgLy8gcmV2YWxpZGF0aW9uIGZyb20gdGhlIG91dHNpZGUuXG4gICAgICAgIHZhciBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ID0gMDtcbiAgICAgICAgdmFyIG9uUmV2YWxpZGF0ZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBGT0NVU19FVkVOVCkge1xuICAgICAgICAgICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGlmIChnZXRDb25maWcoKS5yZXZhbGlkYXRlT25Gb2N1cyAmJlxuICAgICAgICAgICAgICAgICAgICBub3cgPiBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ICYmXG4gICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEZvY3VzUmV2YWxpZGF0ZWRBdCA9IG5vdyArIGdldENvbmZpZygpLmZvY3VzVGhyb3R0bGVJbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFJFQ09OTkVDVF9FVkVOVCkge1xuICAgICAgICAgICAgICAgIGlmIChnZXRDb25maWcoKS5yZXZhbGlkYXRlT25SZWNvbm5lY3QgJiYgaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICBzb2Z0UmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gTVVUQVRFX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHVuc3ViVXBkYXRlID0gc3Vic2NyaWJlQ2FsbGJhY2soa2V5LCBTVEFURV9VUERBVEVSUywgb25TdGF0ZVVwZGF0ZSk7XG4gICAgICAgIHZhciB1bnN1YkV2ZW50cyA9IHN1YnNjcmliZUNhbGxiYWNrKGtleSwgRVZFTlRfUkVWQUxJREFUT1JTLCBvblJldmFsaWRhdGUpO1xuICAgICAgICAvLyBNYXJrIHRoZSBjb21wb25lbnQgYXMgbW91bnRlZCBhbmQgdXBkYXRlIGNvcnJlc3BvbmRpbmcgcmVmcy5cbiAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAga2V5UmVmLmN1cnJlbnQgPSBrZXk7XG4gICAgICAgIGluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAvLyBXaGVuIGBrZXlgIHVwZGF0ZXMsIHJlc2V0IHRoZSBzdGF0ZSB0byB0aGUgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAvLyBhbmQgdHJpZ2dlciBhIHJlcmVuZGVyIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgaWYgKGtleUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IGlzVmFsaWRhdGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJpZ2dlciBhIHJldmFsaWRhdGlvbi5cbiAgICAgICAgaWYgKHNob3VsZFJldmFsaWRhdGUoKSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGRhdGEpIHx8IElTX1NFUlZFUikge1xuICAgICAgICAgICAgICAgIC8vIFJldmFsaWRhdGUgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERlbGF5IHRoZSByZXZhbGlkYXRlIGlmIHdlIGhhdmUgZGF0YSB0byByZXR1cm4gc28gd2Ugd29uJ3QgYmxvY2tcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJpbmcuXG4gICAgICAgICAgICAgICAgckFGKHNvZnRSZXZhbGlkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gTWFyayBpdCBhcyB1bm1vdW50ZWQuXG4gICAgICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICB1bnN1YlVwZGF0ZSgpO1xuICAgICAgICAgICAgdW5zdWJFdmVudHMoKTtcbiAgICAgICAgfTtcbiAgICB9LCBba2V5LCByZXZhbGlkYXRlXSk7XG4gICAgLy8gUG9sbGluZ1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGltZXI7XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIHBhc3NlZCBpbnRlcnZhbFxuICAgICAgICAgICAgLy8gLi4ub3IgaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSB1cGRhdGVkIGRhdGEgdG8gZ2V0IHRoZSBpbnRlcnZhbFxuICAgICAgICAgICAgdmFyIGludGVydmFsID0gaXNGdW5jdGlvbihyZWZyZXNoSW50ZXJ2YWwpXG4gICAgICAgICAgICAgICAgPyByZWZyZXNoSW50ZXJ2YWwoZGF0YSlcbiAgICAgICAgICAgICAgICA6IHJlZnJlc2hJbnRlcnZhbDtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgc3RhcnQgbmV4dCBpbnRlcnZhbCBpZiBgcmVmcmVzaEludGVydmFsYCBpcyBub3QgMCwgYW5kOlxuICAgICAgICAgICAgLy8gLSBgZm9yY2VgIGlzIHRydWUsIHdoaWNoIGlzIHRoZSBzdGFydCBvZiBwb2xsaW5nXG4gICAgICAgICAgICAvLyAtIG9yIGB0aW1lcmAgaXMgbm90IDAsIHdoaWNoIG1lYW5zIHRoZSBlZmZlY3Qgd2Fzbid0IGNhbmNlbGVkXG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgJiYgdGltZXIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWN1dGUsIGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBPSyB0byBleGVjdXRlOlxuICAgICAgICAgICAgLy8gT25seSByZXZhbGlkYXRlIHdoZW4gdGhlIHBhZ2UgaXMgdmlzaWJsZSwgb25saW5lIGFuZCBub3QgZXJyb3JlZC5cbiAgICAgICAgICAgIGlmICghc3RhdGVSZWYuY3VycmVudC5lcnJvciAmJlxuICAgICAgICAgICAgICAgIChyZWZyZXNoV2hlbkhpZGRlbiB8fCBnZXRDb25maWcoKS5pc1Zpc2libGUoKSkgJiZcbiAgICAgICAgICAgICAgICAocmVmcmVzaFdoZW5PZmZsaW5lIHx8IGdldENvbmZpZygpLmlzT25saW5lKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZShXSVRIX0RFRFVQRSkudGhlbihuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIG5leHQgaW50ZXJ2YWwgdG8gY2hlY2sgYWdhaW4uXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgdGltZXIgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbcmVmcmVzaEludGVydmFsLCByZWZyZXNoV2hlbkhpZGRlbiwgcmVmcmVzaFdoZW5PZmZsaW5lLCByZXZhbGlkYXRlXSk7XG4gICAgLy8gRGlzcGxheSBkZWJ1ZyBpbmZvIGluIFJlYWN0IERldlRvb2xzLlxuICAgIHVzZURlYnVnVmFsdWUoZGF0YSk7XG4gICAgLy8gSW4gU3VzcGVuc2UgbW9kZSwgd2UgY2FuJ3QgcmV0dXJuIHRoZSBlbXB0eSBgZGF0YWAgc3RhdGUuXG4gICAgLy8gSWYgdGhlcmUgaXMgYGVycm9yYCwgdGhlIGBlcnJvcmAgbmVlZHMgdG8gYmUgdGhyb3duIHRvIHRoZSBlcnJvciBib3VuZGFyeS5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBgZXJyb3JgLCB0aGUgYHJldmFsaWRhdGlvbmAgcHJvbWlzZSBuZWVkcyB0byBiZSB0aHJvd24gdG9cbiAgICAvLyB0aGUgc3VzcGVuc2UgYm91bmRhcnkuXG4gICAgaWYgKHN1c3BlbnNlICYmIGlzVW5kZWZpbmVkKGRhdGEpICYmIGtleSkge1xuICAgICAgICAvLyBBbHdheXMgdXBkYXRlIGZldGNoZXIgYW5kIGNvbmZpZyByZWZzIGV2ZW4gd2l0aCB0aGUgU3VzcGVuc2UgbW9kZS5cbiAgICAgICAgZmV0Y2hlclJlZi5jdXJyZW50ID0gZmV0Y2hlcjtcbiAgICAgICAgY29uZmlnUmVmLmN1cnJlbnQgPSBjb25maWc7XG4gICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIHRocm93IGlzVW5kZWZpbmVkKGVycm9yKSA/IHJldmFsaWRhdGUoV0lUSF9ERURVUEUpIDogZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG11dGF0ZTogYm91bmRNdXRhdGUsXG4gICAgICAgIGdldCBkYXRhKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuZGF0YSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNWYWxpZGF0aW5nKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuaXNWYWxpZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkYXRpbmc7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbnZhciBTV1JDb25maWcgPSBPQkpFQ1QuZGVmaW5lUHJvcGVydHkoU1dSQ29uZmlnJDEsICdkZWZhdWx0Jywge1xuICAgIHZhbHVlOiBkZWZhdWx0Q29uZmlnXG59KTtcbnZhciB1bnN0YWJsZV9zZXJpYWxpemUgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBzZXJpYWxpemUoa2V5KVswXTsgfTtcbnZhciB1c2VTV1IgPSB3aXRoQXJncyh1c2VTV1JIYW5kbGVyKTtcblxuLy8gdXNlU1dSXG5cbmV4cG9ydCB7IFNXUkNvbmZpZywgdXNlU1dSIGFzIGRlZmF1bHQsIG11dGF0ZSwgdW5zdGFibGVfc2VyaWFsaXplLCB1c2VTV1JDb25maWcgfTtcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwiY3JlYXRlRWxlbWVudCIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwidXNlRGVidWdWYWx1ZSIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9fZ2VuZXJhdG9yIiwiYm9keSIsIl8iLCJsYWJlbCIsInNlbnQiLCJ0IiwidHJ5cyIsIm9wcyIsImYiLCJ5IiwiZyIsInZlcmIiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm4iLCJ2Iiwib3AiLCJUeXBlRXJyb3IiLCJjYWxsIiwicG9wIiwibGVuZ3RoIiwicHVzaCIsIm5vb3AiLCJVTkRFRklORUQiLCJPQkpFQ1QiLCJPYmplY3QiLCJpc1VuZGVmaW5lZCIsImlzRnVuY3Rpb24iLCJtZXJnZU9iamVjdHMiLCJhIiwiYiIsImFzc2lnbiIsIlNUUl9VTkRFRklORUQiLCJoYXNXaW5kb3ciLCJ3aW5kb3ciLCJoYXNEb2N1bWVudCIsImRvY3VtZW50IiwiaGFzUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidGFibGUiLCJXZWFrTWFwIiwiY291bnRlciIsInN0YWJsZUhhc2giLCJhcmciLCJ0eXBlIiwiY29uc3RydWN0b3IiLCJpc0RhdGUiLCJEYXRlIiwiaW5kZXgiLCJSZWdFeHAiLCJnZXQiLCJzZXQiLCJBcnJheSIsImtleXMiLCJzb3J0IiwidG9KU09OIiwidG9TdHJpbmciLCJKU09OIiwic3RyaW5naWZ5Iiwib25saW5lIiwiaXNPbmxpbmUiLCJoYXNXaW4iLCJoYXNEb2MiLCJvbldpbmRvd0V2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImJpbmQiLCJvbkRvY3VtZW50RXZlbnQiLCJvZmZXaW5kb3dFdmVudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvZmZEb2N1bWVudEV2ZW50IiwiaXNWaXNpYmxlIiwidmlzaWJpbGl0eVN0YXRlIiwiaW5pdEZvY3VzIiwiY2FsbGJhY2siLCJpbml0UmVjb25uZWN0Iiwib25PbmxpbmUiLCJvbk9mZmxpbmUiLCJwcmVzZXQiLCJkZWZhdWx0Q29uZmlnT3B0aW9ucyIsIklTX1NFUlZFUiIsInJBRiIsInNldFRpbWVvdXQiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwibmF2aWdhdG9yQ29ubmVjdGlvbiIsIm5hdmlnYXRvciIsImNvbm5lY3Rpb24iLCJzbG93Q29ubmVjdGlvbiIsImluY2x1ZGVzIiwiZWZmZWN0aXZlVHlwZSIsInNhdmVEYXRhIiwic2VyaWFsaXplIiwia2V5IiwiZXJyIiwiYXJncyIsImNvbmNhdCIsImlzQXJyYXkiLCJpbmZvS2V5IiwiU1dSR2xvYmFsU3RhdGUiLCJGT0NVU19FVkVOVCIsIlJFQ09OTkVDVF9FVkVOVCIsIk1VVEFURV9FVkVOVCIsImJyb2FkY2FzdFN0YXRlIiwiY2FjaGUiLCJkYXRhIiwiZXJyb3IiLCJpc1ZhbGlkYXRpbmciLCJyZXZhbGlkYXRlIiwiYnJvYWRjYXN0IiwiX2EiLCJFVkVOVF9SRVZBTElEQVRPUlMiLCJTVEFURV9VUERBVEVSUyIsIkZFVENIIiwicmV2YWxpZGF0b3JzIiwidXBkYXRlcnMiLCJpIiwiX190aW1lc3RhbXAiLCJnZXRUaW1lc3RhbXAiLCJpbnRlcm5hbE11dGF0ZSIsIl9pIiwiYXJndW1lbnRzIiwiX2tleSIsIl9kYXRhIiwiX29wdHMiLCJvcHRpb25zIiwicG9wdWxhdGVDYWNoZSIsInJvbGxiYWNrT25FcnJvciIsImN1c3RvbU9wdGltaXN0aWNEYXRhIiwia2V5SW5mbyIsIl9iIiwiTVVUQVRJT04iLCJiZWZvcmVNdXRhdGlvblRzIiwiaGFzQ3VzdG9tT3B0aW1pc3RpY0RhdGEiLCJyb2xsYmFja0RhdGEiLCJvcHRpbWlzdGljRGF0YSIsInJlcyIsIl9jIiwiY2F0Y2giLCJyZXZhbGlkYXRlQWxsS2V5cyIsImluaXRDYWNoZSIsInByb3ZpZGVyIiwiaGFzIiwib3B0cyIsIm11dGF0ZSIsInVubW91bnQiLCJyZWxlYXNlRm9jdXNfMSIsInJlbGVhc2VSZWNvbm5lY3RfMSIsImRlbGV0ZSIsIm9uRXJyb3JSZXRyeSIsIl9fIiwiY29uZmlnIiwibWF4UmV0cnlDb3VudCIsImVycm9yUmV0cnlDb3VudCIsImN1cnJlbnRSZXRyeUNvdW50IiwicmV0cnlDb3VudCIsInRpbWVvdXQiLCJNYXRoIiwicmFuZG9tIiwiZXJyb3JSZXRyeUludGVydmFsIiwiTWFwIiwiZGVmYXVsdENvbmZpZyIsIm9uTG9hZGluZ1Nsb3ciLCJvblN1Y2Nlc3MiLCJvbkVycm9yIiwib25EaXNjYXJkZWQiLCJyZXZhbGlkYXRlT25Gb2N1cyIsInJldmFsaWRhdGVPblJlY29ubmVjdCIsInJldmFsaWRhdGVJZlN0YWxlIiwic2hvdWxkUmV0cnlPbkVycm9yIiwiZm9jdXNUaHJvdHRsZUludGVydmFsIiwiZGVkdXBpbmdJbnRlcnZhbCIsImxvYWRpbmdUaW1lb3V0IiwiY29tcGFyZSIsImN1cnJlbnREYXRhIiwibmV3RGF0YSIsImlzUGF1c2VkIiwiZmFsbGJhY2siLCJtZXJnZUNvbmZpZ3MiLCJ1MSIsInVzZSIsImYxIiwidTIiLCJmMiIsIlNXUkNvbmZpZ0NvbnRleHQiLCJTV1JDb25maWckMSIsInByb3BzIiwiZXh0ZW5kZWRDb25maWciLCJjYWNoZUNvbnRleHQiLCJQcm92aWRlciIsInVzZVN0YXRlV2l0aERlcHMiLCJzdGF0ZSIsInVubW91bnRlZFJlZiIsInJlcmVuZGVyIiwic3RhdGVSZWYiLCJzdGF0ZURlcGVuZGVuY2llc1JlZiIsInNldFN0YXRlIiwicGF5bG9hZCIsInNob3VsZFJlcmVuZGVyIiwiY3VycmVudFN0YXRlIiwiY3VycmVudCIsImsiLCJub3JtYWxpemUiLCJ1c2VTV1JDb25maWciLCJ3aXRoQXJncyIsImhvb2siLCJ1c2VTV1JBcmdzIiwiZmFsbGJhY2tDb25maWciLCJmbiIsIl9jb25maWciLCJmZXRjaGVyIiwic3Vic2NyaWJlQ2FsbGJhY2siLCJjYWxsYmFja3MiLCJrZXllZFJldmFsaWRhdG9ycyIsImluZGV4T2YiLCJXSVRIX0RFRFVQRSIsImRlZHVwZSIsInVzZVNXUkhhbmRsZXIiLCJmYWxsYmFja0RhdGEiLCJzdXNwZW5zZSIsInJldmFsaWRhdGVPbk1vdW50IiwicmVmcmVzaEludGVydmFsIiwicmVmcmVzaFdoZW5IaWRkZW4iLCJyZWZyZXNoV2hlbk9mZmxpbmUiLCJmbkFyZ3MiLCJpbml0aWFsTW91bnRlZFJlZiIsImtleVJlZiIsImZldGNoZXJSZWYiLCJjb25maWdSZWYiLCJnZXRDb25maWciLCJpc0FjdGl2ZSIsInBhdGNoRmV0Y2hJbmZvIiwiaW5mbyIsImNhY2hlZCIsImlzSW5pdGlhbE1vdW50Iiwic2hvdWxkUmV2YWxpZGF0ZSIsInJlc29sdmVWYWxpZGF0aW5nIiwic3RhdGVEZXBlbmRlbmNpZXMiLCJyZXZhbGlkYXRlT3B0cyIsImN1cnJlbnRGZXRjaGVyIiwic3RhcnRBdCIsImxvYWRpbmciLCJzaG91bGRTdGFydE5ld1JlcXVlc3QiLCJpc0N1cnJlbnRLZXlNb3VudGVkIiwiY2xlYW51cFN0YXRlIiwibmV3U3RhdGUiLCJmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUiLCJtdXRhdGlvbkluZm8iLCJlcnJfMSIsInJlcXVlc3RJbmZvIiwiYm91bmRNdXRhdGUiLCJrZXlDaGFuZ2VkIiwic29mdFJldmFsaWRhdGUiLCJvblN0YXRlVXBkYXRlIiwidXBkYXRlZERhdGEiLCJ1cGRhdGVkRXJyb3IiLCJ1cGRhdGVkSXNWYWxpZGF0aW5nIiwibmV4dEZvY3VzUmV2YWxpZGF0ZWRBdCIsIm9uUmV2YWxpZGF0ZSIsIm5vdyIsInVuc3ViVXBkYXRlIiwidW5zdWJFdmVudHMiLCJ0aW1lciIsImludGVydmFsIiwiZXhlY3V0ZSIsImNsZWFyVGltZW91dCIsIlNXUkNvbmZpZyIsImRlZmluZVByb3BlcnR5IiwidW5zdGFibGVfc2VyaWFsaXplIiwidXNlU1dSIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/swr/dist/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!"), __webpack_exec__("./node_modules/next/dist/client/router.js"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);